["class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        flowersN = len(bloomDay)\n        if flowersN < m*k:\n            return -1\n        \n        def checkFlowers(x):\n            count = 0\n            gotFlowers = 0\n            for num in bloomDay:\n                if num <= x:\n                    count += 1\n                    if count == k:\n                        gotFlowers += 1\n                        count = 0\n                else:\n                    count = 0\n            # print(gotFlowers, x, m)\n            return gotFlowers >= m\n        \n        sortedDays = sorted(list(set(bloomDay)))\n        l = 0\n        r = len(sortedDays) - 1\n        if checkFlowers(sortedDays[l]):\n            return sortedDays[l]\n        while l < r:\n            mm = (l + r)//2\n            if checkFlowers(sortedDays[mm]):\n                r = mm\n            else:\n                l = mm+ 1\n        return sortedDays[l]", "class Solution:\n    def minDays(self, arr: List[int], m: int, k: int) -> int:\n        def count(arr, x, k):\n            out = 0\n            count = 0\n            for i in arr:\n                if i <= x:\n                    count += 1\n                    if count == k:\n                        out += 1\n                        count = 0\n                else:\n                    count = 0\n\n            return out\n        \n        if len(arr) < m*k:\n            return -1\n        res = -1\n        bi = list(sorted(set(arr)))\n        start = 0\n        end = len(bi)-1\n        while start <= end:\n            mid = (start+end)//2\n            if count(arr, bi[mid], k) >= m:\n                res = bi[mid]\n                end = mid - 1\n            else:\n                start = mid + 1\n\n        return res\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if m * k > n:\n            return -1\n        \n        def invalid(threshold):\n            cur = 0\n            bouquets = 0\n            for x in bloomDay:\n                if x <= threshold:\n                    cur += 1\n                else:\n                    bouquets += cur // k\n                    cur = 0\n            bouquets += cur // k\n            return bouquets < m\n        \n        left, right = 1, max(bloomDay)\n        while left <= right:\n            mid = (left + right) // 2\n            # print(left, right, mid)\n            if invalid(mid):\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left", "class Solution:\n    def minDays(self, arr: List[int], m: int, k: int) -> int:\n        l, r, n = 0, max(arr) + 1, len(arr)\n        if m * k > n: return -1\n        while l < r:\n            mid = l + (r - l) // 2\n            cnt, tmp = 0, 0\n            for i, v in enumerate(arr):\n                cnt = 0 if v > mid else cnt + 1\n                if cnt == k:\n                    tmp += 1\n                    cnt = 0\n                    if tmp == m: break\n            if tmp == m:\n                r = mid\n            else:\n                l = mid + 1\n        return l\n", "class Solution:\n    def checkDay(self,day,bloomDay,m,k)->bool:\n        y,count=0,0\n        for i in range(len(bloomDay)):\n            if bloomDay[i] <= day:\n                #bloomed.append(1)\n                y+=1\n            else:\n                #bloomed.append(0)\n                y=0\n            if y==k:\n                count+=1\n                y=0\n            if count==m:\n                return True\n        return False\n    \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        '''\n        bloomDay: Flower garden, elements are # of days required for that flower to bloom\n        m: # of bouquets needed\n        k: # of adjacent flowers needed in each bouquet\n        First, check to see if mk>len(bloomDay). If so return -1\n        Then, see how many days needed until mk flowers have bloomed\n            Check to see if they are adjacent\n            if so return days\n            else maybe check how many adjacents are needed, or go to the next day\n        \n        '''\n        #bloomDay,m,k = [7,7,7,7,12,7,7],2,3\n        \n        FN=m*k # (Flowers Needed)\n        if FN > len(bloomDay):\n            return -1\n        \n        \n        # After x days, is it possible to create m bouquets?\n        \n        \n        bloomed=sorted(set(bloomDay))\n        lastWorking,count,start,stop=-1,0,0,len(bloomed)\n        #print(bloomed)\n        half=stop//2\n        #day=bloomed[half]\n        while(start<=half<stop):\n            day=bloomed[half]\n            #print('Half: ',half,', Day: ',day,' || Bounds: ',start,', ',stop)\n            \n            # If current day works, check previous day\n            if self.checkDay(day,bloomDay,m,k):\n                #print('Day:  ',day,' works')\n                lastWorking,stop=day,half\n            # Otherwise check half of new bounds\n            else:\n                start=half+1\n            half=(start+stop)//2\n            \n        return lastWorking", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m*k:\n            return -1\n        \n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right-left) // 2\n            if self.__feasible(bloomDay, k, m, mid):\n                right = mid\n            else:\n                left = mid+1\n        return left\n    \n    def __feasible(self, bloomDay, k, m, day):\n        bloom = [day >= bloom_day for bloom_day in bloomDay]\n        cnt = 0\n        accu = 0\n        for b in bloom:\n            if b:\n                accu += 1\n                if accu == k:\n                    cnt += 1\n                    accu = 0\n            else:\n                accu = 0\n        return cnt >= m", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def canMakeBouquets(cap):\n            nBouquets = 0\n            nFlowers = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i] > cap:\n                    nFlowers = 0\n                    continue\n                nFlowers += 1\n                if nFlowers == k:\n                    nBouquets += 1\n                    nFlowers = 0\n            return nBouquets >= m\n        \n        if m*k > len(bloomDay):\n            return -1\n        \n        lo, hi = min(bloomDay), max(bloomDay)\n        while lo < hi:\n            med = lo + (hi-lo)//2\n            if canMakeBouquets(med):\n                hi = med\n            else:\n                lo = med + 1\n        return hi", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def bouquet_count(t):\n            count = 0\n            res = 0\n            for i in range(n):\n                if bloomDay[i] <= t:\n                    count += 1\n                    if count == k:\n                        count = 0\n                        res += 1\n                else:\n                    count = 0\n            return res\n        \n        n = len(bloomDay)\n        if m * k > n:\n            return -1\n        \n        low, high = min(bloomDay), max(bloomDay)\n        \n        while low <= high:\n            mid = low + (high - low) // 2\n            if bouquet_count(mid) >= m:\n                high = mid - 1\n            else:\n                low = mid + 1\n                \n        return low", "class Solution:\n    def checkDay(self,day,bloomDay,m,k)->bool:\n        y,count=0,0\n        for i in range(len(bloomDay)):\n            if bloomDay[i] <= day:\n                #bloomed.append(1)\n                y+=1\n            else:\n                #bloomed.append(0)\n                y=0\n            if y==k:\n                count+=1\n                y=0\n            if count==m:\n                return True\n        return False\n    \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        '''\n        bloomDay: Flower garden, elements are # of days required for that flower to bloom\n        m: # of bouquets needed\n        k: # of adjacent flowers needed in each bouquet\n        First, check to see if mk>len(bloomDay). If so return -1\n        Then, see how many days needed until mk flowers have bloomed\n            Check to see if they are adjacent\n            if so return days\n            else maybe check how many adjacents are needed, or go to the next day\n        \n        '''\n        #bloomDay,m,k = [7,7,7,7,12,7,7],2,3\n        \n        FN=m*k # (Flowers Needed)\n        if FN > len(bloomDay):\n            return -1\n        \n        \n        # After x days, is it possible to create m bouquets?\n        lastWorking,count,start,stop=-1,0,0,len(bloomDay)\n        bloomed=sorted(bloomDay)\n        print(bloomed)\n        half=stop//2\n        #day=bloomed[half]\n        while(start<=half<stop):\n            day=bloomed[half]\n            print('Half: ',half,', Day: ',day,' || Bounds: ',start,', ',stop)\n            \n            # If current day works, check previous day\n            if self.checkDay(day,bloomDay,m,k):\n                print('Day:  ',day,' works')\n                lastWorking,stop=day,half\n            # Otherwise check half of new bounds\n            else:\n                start=half+1\n            half=(start+stop)//2\n            \n        return lastWorking", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        left = min(bloomDay)\n        right = max(bloomDay)\n        n = len(bloomDay)\n        if m*k > n:\n            return -1\n        \n        while left <= right:\n            mid = (left + right)//2\n            c = 0\n            bout = m\n            print((left, mid, right))\n            for b in bloomDay:\n                if b <= mid:\n                    c += 1\n                else:\n                    c = 0\n                if c >= k: \n                    bout -= 1\n                    c -= k\n                    if bout == 0: break\n            if bout == 0: right = mid - 1\n            else: left = mid + 1\n        return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        l = 1\n        r = max(bloomDay)\n        while l < r:\n            mid = (l + r) // 2\n            flow = 0\n            nums = 0\n            for i in range(len(bloomDay)):\n                if nums >= m:\n                    break\n                if bloomDay[i] > mid:\n                    flow = 0\n                else:\n                    flow += 1\n                    if flow >= k:\n                        flow = 0\n                        nums += 1\n            # print(mid, nums)\n            if nums >= m:\n                r = mid\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay)<m*k:\n            return -1\n        n=len(bloomDay)\n        def counter(day, k):\n            count, bouquets = 0, 0\n            for i in range(n):\n                if bloomDay[i]<=day:\n                    count+=1\n                else:\n                    count=0\n                if count==k:\n                    bouquets+=1\n                    count=0\n            return bouquets\n        low, high = 1, max(bloomDay)\n        while(low<high):\n            mid=(low+high)//2\n            if counter(mid, k) >= m:\n                high = mid\n            else:\n                low=mid+1\n        return low", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        lower_bound = min(bloomDay)\n        upper_bound = max(bloomDay)\n        while lower_bound < upper_bound:\n            days = (lower_bound + upper_bound) // 2\n            if self.can_make_bouquets(bloomDay, m, k, days):\n                upper_bound = days\n            else:\n                lower_bound = days + 1\n                \n        return upper_bound\n    \n    def can_make_bouquets(self, bloomDay, m, k, days):\n        bouquets_made = 0\n        adj_count = 0\n        \n        K = k\n        for i in range(len(bloomDay)):\n            if bloomDay[i] <= days:\n                K -= 1\n            else:\n                K = k\n            \n            if K == 0:\n                bouquets_made += 1\n                K = k\n                \n        return bouquets_made >= m", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        tmp = sorted(list(set(bloomDay)))\n        low = 0\n        high = len(tmp) - 1\n\n        def feasible(val):\n            count = 0\n            total = m\n\n            for day in bloomDay:\n                if val >= day:\n                    count += 1\n                    \n                    if count == k:\n                        total -= 1\n                        count = 0\n\n                        if total == -1:\n                            break\n\n                else:\n                    count = 0\n                \n\n            return total <= 0\n            \n\n        while low < high:\n            mid = (low + high) // 2\n            val = tmp[mid]\n\n            if feasible(val):\n                high = mid\n            else:\n                low = mid + 1\n        \n        return tmp[low]", "class Solution:\n    def minDays(self, F: List[int], m: int, k: int) -> int:\n        \n        if(m*k>len(F)):\n            return -1\n        \n        ans = 0\n        \n        left = 1\n        right = max(F)\n        while(left<=right):\n            mid = (left+right)//2\n            \n            if(self.possible(mid,F,m,k)==True):\n                ans = mid\n                right = mid-1\n                \n            else:\n                left=mid+1\n                \n        return ans\n    \n    \n    def possible(self,mid,F,m,k):\n        # print(mid)\n        count = 0\n        a = 0\n        for i in range(len(F)):\n            if(a==k):\n                count+=1\n                a=0\n                \n            if(F[i]<=mid):\n                a+=1\n            else:\n                a = 0\n        if(a==k):\n            count+=1\n                \n        if(count>=m):\n            return True\n        return False", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if m*k > n:\n            return -1\n        \n        def can_make_bouquets(m: int, k: int, day: int) -> bool:\n            #print(m, k, day)\n            total_bouquets = 0\n            curr_flowers = 0\n            for index, d in enumerate(bloomDay):\n                if total_bouquets + 1 + (n-index-1)//k < m:\n                    #print(\\\"No\\\")\n                    return False\n                if d <= day:\n                    curr_flowers += 1\n                    if curr_flowers == k:\n                        total_bouquets += 1\n                        curr_flowers = 0\n                else:\n                    curr_flowers = 0\n                if total_bouquets == m:\n                    #print(\\\"Yes\\\")\n                    return True\n            return False\n        \n        days = sorted(list(set(bloomDay)))\n        lo, hi = 0, len(days)-1\n        min_days = float('inf')\n        #print(days)\n        while lo <= hi:\n            mi = (lo+hi)//2\n            #print(lo, mi, hi)\n            if can_make_bouquets(m, k, days[mi]):\n                min_days = min(min_days, days[mi])\n                hi = mi-1\n            else:\n                lo = mi+1\n        \n        return min_days if min_days < float('inf') else -1\n                \n            \n", "class Solution:\n    def minDays(self, blooms: List[int], m: int, k: int) -> int:\n        def check(d):\n            bouq, b = 0, 0\n            for i in range(len(blooms)):\n                if blooms[i] <= d:\n                    b += 1\n                else:\n                    b = 0\n                if b == k:\n                    b = 0\n                    bouq += 1\n                    if bouq >= m:\n                        return True\n            return bouq >= m\n        \n        lo, hi = 1, max(blooms)\n        while lo < hi:\n            mid = (hi+lo)//2\n            if not check(mid):\n                lo = mid + 1\n            else: hi = mid\n        return lo if check(lo) else -1\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if n < m*k: return -1\n        def count(day):\n            cnt,counter=0,0\n            for i in range(n):\n                if bloomDay[i]<=day:\n                    counter +=1\n                    if counter ==k:\n                        cnt +=1\n                        counter = 0\n                else:\n                    counter =0\n            return cnt\n        l,r = min(bloomDay),max(bloomDay)\n        while l<=r:\n            mid = l+(r-l)//2\n            if count(mid) <m:\n                l = mid+1\n            else:\n                r = mid -1\n        return l\n                \n            \n            \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def bouquets_possible(day):\n            bouquets_count = 0\n            conse_day = 0\n            for i, v in enumerate(bloomDay):\n                if v <= day:\n                    conse_day += 1\n                    if conse_day == k:\n                        bouquets_count += 1\n                        conse_day = 0\n                else:\n                    conse_day = 0\n            return bouquets_count\n        \n        if len(bloomDay) < m * k:\n            return -1\n        \n        left = min(bloomDay)\n        right = max(bloomDay)\n        \n        while left < right:\n            mid = left + ( right - left)//2\n            if bouquets_possible(mid) < m:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        # min -> 0 max - > max(element)\n        # check for m*k and valid check kar\n        # condition main keep checking the consecutive flowers\n        # m -> m bouqets , k adjacent flower\n        # if len(bloomDay)<m*k:\n        #     return -1\n        \n        def isPossible(t):\n            count = 0\n            res = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i] <= t:    \n                    count += 1\n                    if count == k:\n                        count = 0\n                        res += 1\n                else:\n                    count = 0\n            return res>=m\n        \n        s,e = 0, max(bloomDay)+1\n        \n        while s<e:\n            mid = (s+e)//2\n            if isPossible(mid):\n                e = mid\n            else:\n                s = mid+1\n                \n        if s==max(bloomDay)+1:\n            return -1\n        \n        return s", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if k*m > len(bloomDay): \n            return -1\n        \n        def isPossible(mid): \n            numFlowers = 0\n            numBouquets = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i] > mid:\n                    numFlowers = 0\n                else:\n                    numFlowers += 1\n                    if numFlowers >= k:\n                        numBouquets += 1\n                        numFlowers -= k\n            \n            # print(mid, numBouquets)\n            return numBouquets >= m\n        \n        low = 0\n        high = max(bloomDay)\n        while (low < high):\n            mid = int((low + high)/2)\n            if (isPossible(mid)):\n                # print(\\\"true\\\", mid)\n                high = mid\n            else:\n                low = mid + 1\n        return low \n                \n            \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def check(days_cand):\n            nonlocal bloomDay\n            nonlocal m\n            nonlocal k\n            nonlocal res\n\n            bukets = 0\n            flowers_per_cur_bucket = 0\n\n            for i in range(len(bloomDay)):\n                today = bloomDay[i]\n                if today <= days_cand:\n                    #is flower\n                    flowers_per_cur_bucket +=1\n                    if flowers_per_cur_bucket == k:\n                        bukets +=1\n                        flowers_per_cur_bucket = 0\n                        if bukets == m:\n                            res = min(res, days_cand)                        \n                            return True\n                    pass\n                else:\n                    #no flower today\n                    flowers_per_cur_bucket = 0\n                    pass\n            return False        \n\n\n        res = float('inf')   \n        left = min(bloomDay)\n        right = max(bloomDay)+1\n\n        while left < right:\n            mid = left + (right - left) // 2\n            if check(mid):\n                # add to answer, check if can do better decrease mid and look up in left part\n                right = mid\n            else:\n                left = mid + 1            \n        if res < float('inf'):\n            return left\n        return -1   \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        flowers = collections.defaultdict(list)\n        for idx, day in enumerate(bloomDay):\n            flowers[day].append(idx)\n        root = list(range(n))\n        num_flowers_left = collections.Counter()\n        num_flowers_right = collections.Counter()\n        num_bouquets = 0\n        for day in sorted(flowers.keys()):\n            for idx in flowers[day]:\n                start = idx - num_flowers_left[idx - 1]\n                num_bouquets -= num_flowers_left[idx - 1] // k\n                end = idx + num_flowers_right[idx + 1]\n                num_bouquets -= num_flowers_right[idx + 1] // k\n                total_num_flowers = end - start + 1\n                num_bouquets += total_num_flowers // k\n                num_flowers_left[end] = total_num_flowers\n                num_flowers_right[start] = total_num_flowers\n                if num_bouquets >= m:\n                    return day\n        return -1\n                    \n                    \n", "class Solution:\n    def minDays(self, A, m, k):\n        if m * k > len(A): return -1\n        left, right = 1, max(A)\n        while left < right:\n            mid = (left + right) // 2\n            flow = bouq = 0\n            for a in A:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        def bouqets(d):\n            res, c = 0, 0\n            for n in bloomDay:\n                c = 0 if n > d else c + 1\n                if c == k:\n                    res, c = res + 1, 0\n            return res\n            \n        days = sorted(set(bloomDay))\n        lo, hi = 0, len(days)-1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if bouqets(days[mid]) < m:\n                lo = mid + 1\n            else:\n                hi = mid\n        return days[hi] if days[hi] >= m else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if not bloomDay or m*k>len(bloomDay):\n            return(-1)\n        def feasible(days):\n                bouquets,flower=0,0\n                for bloom in bloomDay:\n                    if bloom>days:\n                        flower=0\n                    else:\n                        bouquets+=(flower+1)//k\n                        flower=(flower+1)%k\n                return bouquets>=m\n        l,r=0,max(bloomDay)\n        while(l<r):\n            mid=l+(r-l)//2\n            if(feasible(mid)):\n                r=mid\n            else:\n                l=mid+1\n        return l", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        if m * k > len(bloomDay): return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            flow = bouq = 0\n            for a in bloomDay:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        ## Function to check required bouquets can be made \n        ## within the parameterized number of days.\n        def canMakeBouquet(m, k, bloomDay, currDay):\n            \n            ## Variable for keeping track of \n            ## the number of bouquets made.\n            numBouquets = 0\n            \n            ## Variable for sliding window length.\n            slidingWindowLen = 0\n            \n            for i in range(0, len(bloomDay)):\n                \n                ## Check whether the flower has bloomed or not.\n                if (bloomDay[i] <= currDay):\n                    slidingWindowLen += 1\n                else:\n                    slidingWindowLen = 0\n                    \n                ## Check whether a bouquet can be constructed.\n                if (slidingWindowLen == k):\n                    numBouquets += 1\n                    slidingWindowLen = 0\n                    \n            ## Check whether sufficient bouquets can be made.\n            return (numBouquets >= m)\n        \n        ## return canMakeBouquet(m, k, bloomDay, 4)\n        \n        ## Initialise binary search bounds.\n        lowBound = 1\n        highBound = max(bloomDay)\n        \n        ## Perform Binary Search.\n        while (lowBound < highBound):\n            \n            ## Compute the midBound.\n            midBound = lowBound + (highBound - lowBound)//2\n            \n            ## If bouquets cannot be made.\n            if (not canMakeBouquet(m, k, bloomDay, midBound)):\n                lowBound = midBound + 1\n            else:\n                highBound = midBound\n                \n        ## Perform sanity check.\n        if (canMakeBouquet(m, k, bloomDay, lowBound)):\n            return lowBound\n        else:\n            return -1\n            \n", "class Solution:\n    def minDays(self, bloomDay, m: int, k: int) -> int:\n        beg = min(bloomDay)\n        end = max(bloomDay)\n        n = len(bloomDay)\n        res = -1\n        while (beg <= end):\n            mid = beg + int((end - beg) / 2)\n            #print(mid)\n            if (self.isValid(bloomDay, n, m, k, mid) >= m):\n                res = mid\n                end = mid - 1\n            else:\n                beg = mid + 1\n        return res\n\n    def isValid(self, bloomDay, n, m, k, mx):\n        sum = 0\n        boquet = 0\n        k1 = 0\n        for i in range(n):\n            k1 += 1\n            if (bloomDay[i] > mx):\n                k1 = 0\n            if(k1==k):\n                boquet+=1\n                k1=0\n        #print(\\\"boquet\\\",boquet)\n        return boquet", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m*k: return -1\n        \n        \n        \n        \n#         def helper(D_days):\n#             n_m = 0\n#             low = 0 \n#             while low + k <= len(bloomDay):\n#                 _range = bloomDay[low: low+k]\n#                 isValid = True\n#                 for fl in _range:\n#                     if fl > D_days: \n#                         low += 1\n#                         isValid = False\n#                         break\n#                 if isValid:\n#                     n_m += 1\n#                     low += k\n                \n#             if n_m < m: return +1\n#             else: return -1\n            \n        def helper(D_days):\n            n_m = 0\n            n_k = 0\n\n            for index, fl in enumerate(bloomDay):\n                if fl > D_days:\n                    n_k = 0\n                else: \n                    n_k += 1\n\n                if n_k == k: \n                    n_m +=1 \n                    n_k = 0\n\n            if n_m < m: return +1\n            else: return -1\n\n                        \n            \n#             low = 0 \n#             while low + k <= len(bloomDay):\n#                 _range = bloomDay[low: low+k]\n#                 isValid = True\n#                 for fl in _range:\n#                     if fl > D_days: \n#                         low += 1\n#                         isValid = False\n#                         break\n#                 if isValid:\n#                     n_m += 1\n#                     low += k\n                \n#             if n_m < m: return +1\n#             else: return -1\n    \n            \n    \n                        \n# Binary search   \n        def B_search():\n            low, high = 0, max(bloomDay)+1\n            \n            while low < high:\n                mid = low + (high-low)//2\n                \n                if helper(mid)==+1:\n                    low = mid +1\n                else:\n                    high = mid\n                    \n            return low\n        \n        return B_search()\n                    \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        low = float('inf')\n        high = float('-inf')\n        for day in bloomDay:\n            low = min(low, day)\n            high = max(high, day)\n        \n        good = set()\n        \n        i = 0\n        while low < high:\n            guess = (low + high) >> 1\n            \n            count = 0\n            boquets = 0\n            for day in bloomDay:\n                if day <= guess:\n                    count += 1\n                    if count == k:\n                        boquets += 1\n                        count = 0\n                        if boquets == m:\n                            break\n                else:\n                    count = 0\n                day += 1\n            \n            if boquets < m:\n                low = guess + 1\n            else:\n                good.add(guess)\n                high = guess\n        else:\n            if not good:\n                count = 0\n                boquets = 0\n                for day in bloomDay:\n                    if day <= high:\n                        count += 1\n                        if count == k:\n                            boquets += 1\n                            count = 0\n                            if boquets == m:\n                                return high\n                    else:\n                        count = 0\n                    day += 1\n        \n        return min(good) if good else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def canMakeMBouquetsInKDays(max_days):\n            flowers = 0\n            bouquets = 0\n            for flower in range(len(bloomDay)):\n                if bloomDay[flower]<=max_days:\n                    flowers+=1\n                else:\n                    flowers=0  \n                if flowers==k:\n                    bouquets+=1\n                    flowers=0\n            return bouquets>=m\n            \n        \n        if m*k>len(bloomDay):\n            return -1\n        \n        start = 1\n        end = max(bloomDay)\n        while start<=end:\n            mid = (start+end)//2\n            if canMakeMBouquetsInKDays(mid):\n                end = mid-1\n            else:\n                start = mid+1\n        return start", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def possible(bloomDay, days, m, k):\n            bouq = 0\n            curr = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i] <= days:\n                    curr += 1\n                else:\n                    curr = 0\n                if curr == k:\n                    bouq += 1\n                    curr = 0\n            return bouq >= m\n        l = 0\n        r = max(bloomDay)\n        while l < r:\n            mid = (l + r) // 2\n            print(mid)\n            if possible(bloomDay, mid, m, k):\n                r = mid\n            else:\n                l = mid + 1\n        # print(l, possible(bloomDay, l, m, k))\n        if possible(bloomDay, l, m, k):\n            return l\n        return -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def possible(days):\n            flowers = 0\n            bouquets = 0\n            for bloom in bloomDay:\n                if bloom<=days:\n                    flowers += 1\n                    if flowers>=k:\n                        bouquets += 1\n                        flowers = 0\n                        if bouquets>=m:\n                            return True\n                else:\n                    flowers = 0\n            return False\n            \n        if len(bloomDay)<m*k:\n            return -1\n        \n        l = 1\n        h = max(bloomDay)\n        while l<h:\n            days = (l+h)//2\n            if possible(days):\n                h = days\n            else:\n                l = days+1\n        return l\n", "class Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass BST:\n    def __init__(self, root = None):\n        self.root = root\n    \n    def insert(self, value):\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert(self.root, value)\n        \n        \n    def _insert(self, root, v):\n        if v < root.val:\n            if not root.left:\n                root.left = Node(v)\n            else:\n                self._insert(root.left, v)\n        else:\n            if not root.right:\n                root.right = Node(v)\n            else:\n                self._insert(root.right, v)\n            \n    \n    def findBounds(self, value, lower, upper):\n        root = self.root\n        while root:\n            if root.val < value:\n                lower = root.val\n                root = root.right\n            else:\n                upper = root.val\n                root = root.left\n        \n        return (lower, upper)\n                \n        \n                \n                \n              \n            \n                \n\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        n = len(bloomDay)\n        if m*k > n: return -1\n        \n        h = [(-d,f) for f,d in enumerate(bloomDay)]\n        heapq.heapify(h)        \n        \n        bst = BST()\n        fit = n//k\n        while True:\n            day, flower = heapq.heappop(h)\n            l, u = bst.findBounds(flower, -1, n)\n            fit +=  (flower-l-1)//k + (u-flower-1)//k - (u-l-1)//k\n            bst.insert(flower)\n            if fit < m:\n                return -day\n            \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m * k:\n            return -1\n        \n        min_day, max_day = min(bloomDay), max(bloomDay)\n        \n        while min_day < max_day:\n            mid = min_day + (max_day - min_day) // 2\n            if self.check(bloomDay, mid, m , k):\n                max_day = mid\n            else:\n                min_day = mid + 1\n        return min_day\n    \n    \n    def check(self, bloomDay, day, m, k):\n        un_m = 0\n        last_bloom = -1 \n        n_before_bloom = 0\n        for i, d in enumerate(bloomDay):\n            if d <= day:\n                n_before_bloom += 1\n                last_bloom = i\n                if n_before_bloom >= k:\n                    un_m += 1\n                    n_before_bloom -= k\n            else:\n                n_before_bloom = 0\n        return un_m >= m\n                        \n                        \n                \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def canMakeBouquets(cap):\n            nBouquets = 0\n            nFlowers = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i] > cap:\n                    nFlowers = 0\n                    continue\n                nFlowers += 1\n                if nFlowers == k:\n                    nBouquets += 1\n                    nFlowers = 0\n            return nBouquets >= m\n        \n        if m*k > len(bloomDay):\n            return -1\n        \n        lo, hi = 1, max(bloomDay)\n        while lo < hi:\n            med = lo + (hi-lo)//2\n            if canMakeBouquets(med):\n                hi = med\n            else:\n                lo = med + 1\n        return hi", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay)<m*k:\n            return -1\n        mi,ma = min(bloomDay),max(bloomDay)\n        while(mi<ma):\n            mid = (mi + ma)//2\n            curr=0\n            adj=0\n            for i in range(len(bloomDay)):\n                if bloomDay[i]>mid:\n                    adj=0\n                else:\n                    adj+=1\n                    if adj==k:\n                        adj=0\n                        curr+=1\n                if curr>=m:\n                    break\n            if curr<m:\n                mi = mid+1\n            else:\n                ma = mid\n        return (mi)       \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if k * m > len(bloomDay):\n            return -1\n        \n        def flowers(days):\n            boq, full = 0, 0\n            adj = False\n            for flower in bloomDay:\n                if flower <= days:\n                    full += 1\n                else:\n                    full = 0\n                if full == k:\n                    full = 0\n                    boq += 1\n            return boq >= m\n             \n        left, right = 0, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if flowers(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(days):\n            bouquets=flowers=0\n            for i in range(len(bloomDay)):\n                if bloomDay[i]<=days:\n                    flowers+=1\n                    if flowers==k:\n                        bouquets+=1\n                        flowers=0\n                    if bouquets>=m:\n                        return True\n                else:\n                    flowers=0\n            return False\n        if m*k>len(bloomDay):\n            return -1\n        left,right=min(bloomDay),max(bloomDay)\n        while left<right:\n            mid=left+(right-left)//2\n            if feasible(mid):\n                right=mid\n            else:\n                left=mid+1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = max(bloomDay)\n        if m*k > len(bloomDay):\n            return -1\n        \n        l, r = 1, n\n        while l <= r:\n            mid = (l+r)//2\n            count, rec = 0, 0\n            \n            for i in range(len(bloomDay)):\n                if bloomDay[i] <= mid:\n                    count += 1\n                    if count >= k:\n                        rec += 1\n                        count = 0\n                    if rec >= m:\n                        break\n                else:\n                    count = 0\n            \n            if rec < m: #need more bouquets, increase the mid makes it easy to collect flowers\n                l = mid+1\n            else:\n                r = mid-1\n        \n        return l\n", "class Solution:\n    def minDays(self, b: List[int], m: int, k: int) -> int:\n        mi,ma=min(b),max(b)\n        if m*k>len(b):\n            return -1\n        n=len(b)\n        cur,adj=0,0\n        while(mi<ma):\n            mid=(mi+ma)//2\n            cur,adj=0,0\n            for i in range(n):\n                if(mid<b[i]):\n                    adj=0\n                else:\n                    adj+=1\n                    if(adj==k):\n                        cur+=1\n                        adj=0\n                if(cur>=m):\n                    break\n            if(cur<m):\n                mi=mid+1\n            else:\n                ma=mid\n        return mi", "from collections import Counter\nfrom heapq import *\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if k*m > len(bloomDay): return -1\n        \n        que = [[-1*num,ind] for ind,num in enumerate(bloomDay[:k])]\n        heapify(que)\n        \n        maxArr = [-1*que[0][0]]\n        for ind in range(k,len(bloomDay)):\n            while que and que[0][1] <= ind-k:\n                heappop(que)\n            heappush(que, [-1*bloomDay[ind], ind])\n            maxArr.append(-1*que[0][0])\n            \n        # print(maxArr)\n        def isValid(num):\n            cnt = 0\n            ind = 0\n            while ind < len(maxArr):\n                if maxArr[ind] <= num:\n                    cnt+=1\n                    ind+=k\n                else:\n                    ind+=1\n            # print(\\\"{0} => {1}\\\".format(num, cnt))\n            return cnt >= m\n                \n        \n        low = 1\n        high = max(bloomDay)+1\n        ans = -1\n        while low < high:\n            mid = low + (high-low)//2\n            if isValid(mid):\n                high = mid\n                ans = mid\n            else:\n                low=mid+1\n        return ans\n            \n            \n            \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) // k < m:\n            return -1\n        low, high = min(bloomDay), max(bloomDay)\n        \n        def valid(days):\n            start = 0\n            count = 0\n            for i, val in enumerate(bloomDay):\n                if val <= days:\n                    if i - start + 1 >= k:\n                        count += 1\n                        start = i + 1\n                else:\n                    start = i + 1\n            \n            return count >= m\n\n        while low < high:\n            days = (low + high) // 2\n            \n            if valid(days):\n                high = days\n            else:\n                low = days + 1\n        \n        return low", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n\n        if m*k>len(bloomDay):\n            return -1\n\n\n        def check(days):\n\n            i = 0\n            bouquet = 0\n            count = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i]<=days:\n                    count+=1\n                else:\n                    count = 0\n\n                if count == k:\n                    bouquet+=1\n                    count = 0\n                if bouquet == m:\n                    return True\n            return False\n\n        low,high = min(bloomDay),max(bloomDay)\n\n        while low<high:\n\n            mid = low + (high-low)//2\n\n            possible = check(mid)\n\n            if possible:\n                high = mid\n            else:\n                low = mid+1\n\n        return low", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if k*m > n:\n            return -1\n        l, r = 1, max(bloomDay)\n        ans = -1\n        while l <= r:\n            mid = int((l+r)/2)\n            bouquetCount = 0\n            adjacentFlowerCount = 0\n            for bloom in bloomDay:\n                if bloom <= mid:\n                    adjacentFlowerCount += 1\n                    if adjacentFlowerCount == k:\n                        bouquetCount += 1\n                        adjacentFlowerCount = 0\n                        if bouquetCount == m:\n                            break\n                else:\n                    adjacentFlowerCount = 0\n            if bouquetCount == m:\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        return ans", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k > len(bloomDay):\n            return -1\n        lo = min(bloomDay)\n        hi = max(bloomDay)\n        while lo < hi:\n            mid = lo + (hi-lo)//2\n            pos_b = 0\n            cur_b = 0\n            for f in bloomDay:\n                if f <= mid:\n                    cur_b += 1\n                else:\n                    cur_b = 0\n                if cur_b == k:\n                    pos_b += 1\n                    cur_b = 0\n            if pos_b >= m:\n                hi = mid\n            else:\n                lo = mid+1\n        return lo", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def feasible(day):\n            \n            bou = 0\n            flowers = 0\n            \n            for bloom in bloomDay:\n                if bloom > day:\n                    flowers = 0\n                else:\n                    bou += (flowers+1)//k\n                    flowers = (flowers+1)%k\n            \n            \n            if bou < m:\n                return False\n            return True\n        \n        if len(bloomDay) < (m*k):\n            return -1\n        \n        left = 1\n        right = max(bloomDay)\n        \n        while left < right :\n            mid = (left+right)//2\n            \n            if feasible(mid):\n                right = mid\n            else: left = mid + 1\n                \n        return left", "class Solution:\n    def minDays(self, B: List[int], m: int, k: int) -> int:\n        \n        n = len(B)\n        if m*k>n: return -1\n        \n        lo = min(B)\n        hi = max(B)+1\n        while lo<hi:\n            mi = lo+(hi-lo)//2\n            bouquets = 0\n            curflowers = 0\n            for i in range(n):\n                if B[i]<=mi:\n                    curflowers += 1\n                else:\n                    curflowers = 0\n                    \n                if curflowers == k:\n                    bouquets += 1\n                    curflowers = 0\n                #print(m,i,curflowers,bouquets)\n                    \n                if bouquets == m:\n                    #print(m,i,'here')\n                    hi = mi\n                    break\n            if hi>mi:\n                lo = mi+1\n            \n        return lo", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def make_boquets(mid):\n            bonquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > mid:\n                    flowers = 0\n                else:\n                    bonquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bonquets >= m\n        left,right = min(bloomDay), max(bloomDay) + 1\n        while left < right:\n            mid = left + (right-left)//2\n            if make_boquets(mid):\n                right = mid\n            else:\n                left = mid + 1\n        if left > max(bloomDay):\n            return -1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = max(bloomDay)\n        if m*k > len(bloomDay):\n            return -1\n        \n        l, r = 1, n\n        while l <= r:\n            mid = (l+r)//2 #need a threshold for collecting, binary search this threshold\n            count, rec = 0, 0\n            \n            for i in range(len(bloomDay)):\n                if bloomDay[i] <= mid:\n                    count += 1\n                    if count >= k:\n                        rec += 1\n                        count = 0\n                    if rec >= m:\n                        break\n                else:\n                    count = 0\n            \n            if rec < m: #need more bouquets, increase the mid makes it easy to collect flowers\n                l = mid+1\n            else:\n                r = mid-1\n        \n        return l\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        def feasible(days):\n            flower = 0\n            bouq = 0\n            #print('----------'+str(days))\n            for bloom in bloomDay:\n                if bloom > days:\n                    flower = 0\n                else:\n                    flower += 1\n                    #print(bloom,flower)\n                    if flower >= k:\n                        bouq += 1\n                        flower = 0\n                        #print(bloom,bouq)\n            return bouq >= m\n        \n        left = 1\n        right = max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(days):\n            flower = 0\n            boq = 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flower = 0\n                    \n                else:\n                    boq = boq + (flower+1)//k\n                    flower = (flower+ 1)%k\n                    \n            if boq >= m:\n                return True\n            \n            return False\n            \n        if len(bloomDay) < m * k:\n            return -1\n    \n        low = min(bloomDay)\n        high = max(bloomDay)\n        \n        \n        while low < high:\n            mid = (low+high)//2\n            if feasible(mid):\n                high = mid\n                \n            else:\n                low = mid + 1\n                \n        return low\n    \n\n\n    # if len(bloomDay) < m * k:\n    #     return -1\n    # left, right = 1, max(bloomDay)\n    # while left < right:\n    #     mid = left + (right - left) // 2\n    #     if feasible(mid):\n    #         right = mid\n    #     else:\n    #         left = mid + 1\n    # return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def canMakeMBouquetsInKDays(max_days):\n            flowers = 0\n            bouquets = 0\n            for flower in range(len(bloomDay)):\n                if bloomDay[flower]<=max_days:\n                    flowers+=1\n                else:\n                    flowers=0  \n                if flowers==k:\n                    bouquets+=1\n                    flowers=0\n                if bouquets==m:\n                    return True\n            return bouquets>=m\n            \n        \n        if m*k>len(bloomDay):\n            return -1\n        \n        start = 1\n        end = max(bloomDay)\n        while start<=end:\n            mid = (start+end)//2\n            if canMakeMBouquetsInKDays(mid):\n                end = mid-1\n            else:\n                start = mid+1\n        return start", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        def check(curr_day):\n            ans = 0\n            i = -1\n            for j, day in enumerate(bloomDay):\n                if day > curr_day:\n                    ans += (j - 1 - i) // k\n                    i = j\n                if ans >= m:\n                    return True\n            ans += (len(bloomDay) - 1 - i) // k\n            return ans >= m\n        candidates = sorted(set(bloomDay))\n        \n        l, r = 0, len(candidates) - 1\n        while r > l:\n            mid = l + (r - l) // 2\n            if check(candidates[mid]):\n                r = mid\n            else:\n                l = mid + 1\n        return candidates[l]\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if m * k > n:\n            return -1\n        eV = max(bloomDay)\n        sV = min(bloomDay)\n        \n        while sV <= eV:\n            mV = (sV+eV) // 2\n            i = 0\n            x = 0\n            c = 0\n            while i < n:\n                if bloomDay[i] <= mV:\n                    x += 1\n                    if x >= k:\n                        c += 1\n                        if c >= m:\n                            break\n                        x = 0\n                else:\n                    x = 0\n                i += 1\n            else:\n                sV = mV + 1\n                continue\n            eV = mV - 1\n        \n        return sV\n                \n            \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(day):\n            numAdjFlowers = 0\n            numBouquets = 0\n            \n            for bloom in bloomDay:\n                if bloom <= day:\n                    numAdjFlowers += 1\n                    if numAdjFlowers == k:\n                        numBouquets += 1\n                        numAdjFlowers = 0\n                else:\n                    numAdjFlowers = 0\n            return numBouquets >= m\n                    \n        # Eliminate cases where it's not possible\n        if len(bloomDay) < (m*k):\n            return -1\n                    \n        left = min(bloomDay)\n        right = max(bloomDay)\n        \n        while left < right:\n            mid = left + (right - left)//2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self,bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(days) -> bool:\n            bonquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bonquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bonquets >= m\n\n        if len(bloomDay) < m * k:\n            return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n", "class UnionFind:\n    def __init__(self, n):\n        self.father = [i for i in range(n)]\n        self.size = [1 for _ in range(n)]\n        \n    def find(self, x):\n        if self.father[x] != x:\n            self.father[x] = self.find(self.father[x])\n        return self.father[x]\n    \n    def union(self, x, y):\n        fx, fy = self.find(x), self.find(y)\n        if fx == fy:\n            return\n        self.father[fx] = fy\n        self.size[fy] += self.size[fx]\n        \n    def get_size(self, x):\n        fx = self.find(x)\n        return self.size[fx]\n\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if m * k > n:\n            return -1\n        sort_indexes = sorted(range(n), key = lambda i: bloomDay[i])\n        uf = UnionFind(n)\n        bouquets = 0\n        bloomed = [False] * n\n        for idx in sort_indexes:\n            bloomed[idx] = True\n            left, right = idx - 1, idx + 1\n            left_size, right_size = 0, 0\n            if left >= 0 and bloomed[left]:\n                left_size = uf.get_size(left)\n                uf.union(left, idx)\n            if right <= n - 1 and bloomed[right]:\n                right_size = uf.get_size(right)\n                uf.union(right, idx)\n            cur_size = uf.get_size(idx)\n            bouquets += cur_size // k - (left_size // k + right_size // k)\n            # print(bouquets, bloomed, left_size, right_size, cur_size)\n            if bouquets >= m:\n                return bloomDay[idx]\n        return -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m * k:\n            return -1\n        \n        min_day, max_day = min(bloomDay), max(bloomDay)\n        \n        while min_day <= max_day:\n            mid = min_day + (max_day - min_day) // 2\n            if self.check(bloomDay, mid, m , k):\n                if max_day == mid:\n                    return max_day\n                max_day = mid\n            else:\n                min_day = mid + 1\n        return max_day\n    \n    \n    def check(self, bloomDay, day, m, k):\n        un_m = 0\n        last_bloom = -1 \n        n_before_bloom = 0\n        for i, d in enumerate(bloomDay):\n            if d <= day:\n                n_before_bloom += 1\n                last_bloom = i\n                if n_before_bloom >= k:\n                    un_m += 1\n                    n_before_bloom -= k\n            else:\n                n_before_bloom = 0\n        return un_m >= m\n                        \n                        \n                \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        def feasible_bloom_day(value):\n            total_bouquet = 0\n            num_flowers = 0\n            \n            for bloom in bloomDay:\n                # Flower bloomed\n                if ((bloom-1) // value) == 0:\n                    num_flowers += 1\n                \n                    if num_flowers == k:\n                        total_bouquet += 1\n                        num_flowers = 0\n                        \n                    if total_bouquet == m:\n                        return True\n                else: \n                    num_flowers = 0\n                    \n            \n            return False\n        \n        left, right = 1, max(bloomDay)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if feasible_bloom_day(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def make_bouquets(mid):\n            bouquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > mid:\n                    flowers = 0\n                else:\n                    bouquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bouquets >= m\n        left,right = min(bloomDay), max(bloomDay) + 1\n        while left < right:\n            mid = left + (right-left)//2\n            if make_bouquets(mid):\n                right = mid\n            else:\n                left = mid + 1\n        if left > max(bloomDay):\n            return -1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(days) -> bool:\n            bonquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bonquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bonquets >= m\n\n        if len(bloomDay) < m * k:\n            return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(days) -> bool:\n            bonquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bonquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bonquets >= m\n\n        if len(bloomDay) < m * k:\n            return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n#     def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n#         def feasible(day):\n#             adj_count = 0\n#             bouquet = 0\n#             for bday in bloomDay:\n#                 if bday <= day:\n#                     adj_count += 1\n#                 else:\n#                     adj_count = 0\n#                 if adj_count == k:\n#                     bouquet += 1\n#                     adj_count = 0\n#             return bouquet == m\n        \n#         if len(bloomDay) < m * k:\n#             return -1\n#         left, right = 1, max(bloomDay)\n#         while left < right:\n#             mid = (left + right) // 2\n#             if feasible(mid):\n#                 right = mid\n#             else:\n#                 left = mid + 1\n#         return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        groups = dict()\n        sorted_original_idx_and_days = sorted(enumerate(bloomDay), key=lambda item: item[1])\n        \n        SIZE = len(sorted_original_idx_and_days)\n        bloom_flag = [False]*SIZE\n        max_right = [-1]*SIZE\n        min_left = [-1]*SIZE\n        count = 0\n        \n        merge_right_flag = False\n        merge_left_flag = False\n        for idx, (ith_flower, day) in enumerate(sorted_original_idx_and_days):\n            # print(\\\"=\\\"*50)\n            bloom_flag[ith_flower] = True\n            max_right[ith_flower] = min_left[ith_flower] = ith_flower\n            merge_left_flag = merge_right_flag = False\n            if ith_flower < SIZE-1 and bloom_flag[ith_flower+1]:\n                merge_right_flag = True\n                ptr = ith_flower+1\n                while max_right[ptr] != -1 and max_right[ptr] != ptr:\n                    ptr = max_right[ptr]\n                max_right[ith_flower] = ptr\n            if ith_flower > 0 and bloom_flag[ith_flower-1]:\n                merge_left_flag = True\n                ptr = ith_flower-1\n                while min_left[ptr] != -1 and min_left[ptr] != ptr:\n                    ptr = min_left[ptr]\n                min_left[ith_flower] = ptr\n            max_right[min_left[ith_flower]] = max_right[ith_flower]\n            min_left[max_right[ith_flower]] = min_left[ith_flower]\n            \n            if merge_left_flag:\n                # print(\\\"merge left\\\", (ith_flower-min_left[ith_flower])//k)\n                count -= (ith_flower-min_left[ith_flower])//k\n            if merge_right_flag:\n                # print(\\\"merge right\\\", ((max_right[ith_flower]+1)-ith_flower)//k)\n                count -= (max_right[ith_flower]-ith_flower)//k\n            count += ((max_right[ith_flower]+1)-min_left[ith_flower])//k\n            \n            # print(bloom_flag)\n            # print(max_right)\n            # print(min_left)\n            # print(count)\n            if count >= m:\n                return day\n        return -1", "class Solution:\n    def calc(self, bloomDay, mid, k):\n        adj=0\n        totes=0\n        for i in range(len(bloomDay)):\n            if adj==k:\n                totes+=1\n                adj=0\n            if bloomDay[i]<=mid:\n                adj+=1\n                continue\n            adj=0\n        if adj==k:\n            totes+=1\n        return totes\n                \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n=len(bloomDay)\n        if m*k>n:\n            return -1\n        \n        l=0\n        r=max(bloomDay)+1\n        while r-l>1:\n            mid=l + (r-l)//2\n            t=self.calc(bloomDay, mid, k)\n            if t>=m:\n                r=mid\n            elif t<m:\n                l=mid\n        \n        return r\n            \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(days):\n            cur = 0\n            bou = 0\n            for b in bloomDay:\n                if b <= days:\n                    cur += 1\n                    if cur == k:\n                        bou += 1\n                        if bou >= m:\n                            return True\n                        cur = 0\n                else:\n                    cur = 0\n            return False\n            \n        \n        if m * k > len(bloomDay):\n            return -1\n        if m * k == len(bloomDay):\n            return max(bloomDay)\n        \n        l, r = min(bloomDay), max(bloomDay)\n        while l < r:\n            mid = l + (r - l) // 2\n            if feasible(mid):\n                r = mid\n            else:\n                l = mid + 1\n        \n        return l", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n    \n        def condition(cap):\n            curr_m = 0\n            curr_k = 0\n            for flower in bloomDay:\n                if flower <= cap: # 1 # 10 # 3 # 10 # 2\n                    curr_k += 1 # 1 # 1 # 1\n                    if curr_k == k:\n                        curr_m += 1 # 1 # 2 # 3\n                        curr_k = 0 # 0 # 0\n                    if curr_m >= m: # F # F\n                        return True\n                else:\n                    curr_k = 0  # 0 # 0\n            return False\n                        \n                \n        \n        left, right = 1, max(bloomDay)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n=len(bloomDay)\n        if m*k>n: return -1\n        \n        def canmake(days):\n            flowers=0\n            bs=0\n            i=0\n            while bs<m and i<n:\n                while flowers<k and i<n:\n                    if bloomDay[i]<=days:\n                        flowers+=1\n                    else:\n                        flowers=0\n                    i+=1\n                if flowers==k:\n                    flowers=0\n                    bs+=1\n            return bs==m\n        \n        l,r=min(bloomDay),max(bloomDay)\n        \n        while l<r:\n            mid=(l+r)>>1\n            if canmake(mid):\n                r=mid\n            else:\n                l=mid+1\n        return l", "class Solution:\n    def minDays(self, bloomDay, m, k):\n        \n        if m * k > len(bloomDay): return -1\n            \n        def canBloom(cand):\n            bloomed = 0\n            bouquet = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i] > cand:\n                    bouquet = 0\n                else:\n                    bouquet += 1\n                    if bouquet == k:\n                        bloomed += 1\n                        bouquet = 0\n            return bloomed>=m\n\n        l, r = min(bloomDay), max(bloomDay)\n        while l < r:\n            mid = l + (r - l) // 2\n            if canBloom(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k>len(bloomDay):\n            return -1\n        left, right = 1, max(bloomDay)\n        while left<right:\n            mid = (left+right)//2\n            flower, bouquet = 0, 0\n            for b in bloomDay:\n                flower = 0 if b>mid else flower + 1\n                if flower>=k:\n                    flower = 0\n                    bouquet += 1\n                    if bouquet==m: break\n            if bouquet == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        \n        def feasible(threshold):\n            bouquets = 0\n            flowers = 0\n            \n            for bloom in bloomDay:\n                if bloom > threshold:\n                    flowers = 0\n                else:\n                    bouquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bouquets >= m\n            \n        if m*k > n:\n            return -1\n        \n        left, right = 1, max(bloomDay)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(days):\n            bouquets,flowers=0,0\n            for bloom in bloomDay:\n                if bloom>days:\n                    flowers=0\n                else:\n                    bouquets+=(flowers+1)//k\n                    flowers=(flowers+1)%k\n            return bouquets>=m\n        \n        \n        if len(bloomDay)<m*k:\n            return -1\n        l,r=1,max(bloomDay)\n        while l<r:\n            mid=(l+r)//2\n            if feasible(mid):\n                r=mid\n            else:\n                l=mid+1\n        return l", "class Solution:\n    def minDays(self, bd: List[int], m: int, k: int) -> int:\n        if m * k > len(bd): return -1\n        \n        def helper(d):\n            ans, cur = 0, 0\n            for b in bd:\n                cur = 0 if b > d else cur+1\n                if cur == k:\n                    ans += 1\n                    cur = 0\n            return ans\n        \n        days = sorted(set(bd))\n        l, h = 0, len(days) - 1\n        while l<h:\n            mid = (l+h)//2\n            if helper(days[mid]) < m:\n                l = mid + 1\n            else:\n                h = mid\n        \n        return days[h] if helper(days[h])>=m else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def canMakeBouquets(blooms:List[bool], m:int, k:int)->bool:\n            bouqs_to_fit = m\n            run = 0\n            for f in blooms:\n                if f:\n                    run +=1\n                else:\n                    run = 0\n                if run == k:\n                    bouqs_to_fit -=1 #fit a bouquet\n                    run = 0\n            return bouqs_to_fit <= 0\n        if len(bloomDay) < m*k:\n            return -1\n        \n        candidates = sorted(set(bloomDay))\n        \n        lo = 0\n        hi = len(candidates)-1\n        while(lo < hi):\n            mid = (lo + hi)//2\n            if canMakeBouquets(map(lambda x: x<=candidates[mid], bloomDay),m,k):\n                hi = mid\n            else:\n                lo = mid + 1\n        return candidates[lo]", "from functools import reduce\nclass Solution:\n    def valid(self, bloomDay, k, m, mid):\n        i, n = 0, len(bloomDay)\n        while i+k-1 < n:\n            j = i\n            while j < n and j < i+k:\n                if bloomDay[j] > mid:\n                    i = j+1\n                    break\n                j+=1\n            else:\n                m-=1\n                i = j\n            if m <= 0:\n                return True\n        return False\n    \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if (len(bloomDay) < m*k): return -1\n        l, r = reduce(lambda a, b: (min(a[0], b), max(a[1], b)), bloomDay, (float('inf'), float('-inf')))\n        while l < r:\n            mid = (l+r-1)//2\n            v = self.valid(bloomDay, k, m, mid)\n            if v:\n                r = mid\n            else:\n                l = mid+1\n        return r", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        # This is a greedy approach and is generally O(N) time\n        def is_feasible(max_day) -> bool:\n            total_bouquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > max_day:\n                    flowers = 0\n                else:\n                    total_bouquets += (flowers + 1)//k\n                    flowers = (flowers + 1) % k\n            return total_bouquets >= m\n                    \n        if m * k > len(bloomDay):\n            return -1\n        \n        l, r = min(bloomDay), max(bloomDay)\n        while l < r:\n            mid = l + (r - l)//2\n            if is_feasible(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay)<m*k:\n            return -1\n        \n        def feasible(day):\n            flowers,bouquets=0,0\n            for bloom in bloomDay:\n                if bloom>day:\n                    flowers=0\n                else:\n                    bouquets+=(flowers+1)//k\n                    flowers=(flowers+1)%k\n            return bouquets>=m\n            \n        \n        l,r=1,max(bloomDay)\n        while l<r:\n            mid=(l+r)//2\n            if feasible(mid):\n                r=mid\n            else:\n                l=mid+1\n        return l\n    \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay)<m*k:\n            return -1\n        \n        def enough(Day):\n            flowers,bouquets=0,0\n            for bloom in bloomDay:\n                if bloom>Day:\n                    flowers=0\n                else:\n                    bouquets+=(flowers+1)//k\n                    flowers=(flowers+1)%k\n            return bouquets>=m\n        \n        l,r=1,max(bloomDay)\n        while l<r:\n            mid=(l+r)//2\n            if enough(mid):\n                r=mid\n            else:\n                l=mid+1\n        return l", "import heapq\n\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k > len(bloomDay): return -1\n        \n        def is_valid(mid):\n            count, size = 0, 0\n            \n            for i, v in enumerate(bloomDay):\n                size = size+1 if v <= mid else 0\n                # print(f\\\"\\\\tsize: {size} count: {count} i: {i} v: {v}\\\")\n                \n                if size == k:\n                    size = 0\n                    count += 1\n                if count == m:\n                    return True\n                \n            return False\n        \n        left, right = float('inf'), float('-inf')\n        for i, v in enumerate(bloomDay):\n            left = min(left, v)\n            right = max(right, v)\n        # print(f\\\"left: {left}, right: {right}\\\")\n            \n        while left <= right:\n            mid =  left + (right - left) // 2\n            # print(left, right, mid)\n            \n            if is_valid(mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return left if left != float('-inf') else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(days):\n            bouquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bouquets += (flowers + 1)//k\n                    flowers = (flowers+1)%k\n            return bouquets >= m\n        \n        if m*k > len(bloomDay):\n            return -1\n        lo, hi = 1, max(bloomDay)\n        \n        while lo < hi:\n            mid = lo + (hi-lo)//2\n            if feasible(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo\n", "class Solution:\n    def minDays(self, A, m, k):\n        if m * k > len(A): return -1\n        left, right = 1, max(A)\n        while left < right:\n            mid = (left + right) / 2\n            flow = bouq = 0\n            for a in A:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return int(left)\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if n < m * k:\n            return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if self.validBouquets(bloomDay, mid, m, k):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n    def validBouquets(self, bloomDay, days, m, k):\n        # Count how many bouquets we can collect\n        count_bouquets = 0\n        temp_flowers = 0\n        for bloom in bloomDay:\n            if bloom <= days:\n                temp_flowers += 1\n            else:\n                temp_flowers = 0\n            # Determine whether flowers in hand can form a bouquet\n            if temp_flowers >= k:\n                count_bouquets += 1\n                temp_flowers = 0\n                if count_bouquets == m:\n                    return True\n        return False", "class Solution:\n    def search(self, bloomDay, m, k, days):\n        bouquets = 0\n        flowers = 0\n        for day in bloomDay:\n            if day > days:\n                flowers = 0\n            else:\n                bouquets += (flowers + 1) // k\n                flowers = (flowers + 1) % k\n               \n        return bouquets >= m\n    \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m * k:\n            return -1\n        \n        lowerBound = 1\n        upperBound = max(bloomDay)\n        \n        while lowerBound <= upperBound:\n            mid = (lowerBound + upperBound) // 2\n            check = self.search(bloomDay, m, k, mid)\n            if check:\n                upperBound = mid - 1\n            else:\n                lowerBound = mid + 1\n        return lowerBound", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def condition(day) -> bool:\n            a = 0\n            b = 0\n            for bloom in bloomDay:\n                if bloom <= day:\n                    a += 1\n                else:\n                    b += a//k\n                    a = 0\n            b += a//k\n            return b >= m\n        \n        if len(bloomDay) < m * k:\n            return -1\n        \n        left, right = 1, max(bloomDay) # could be [0, n], [1, n] etc. Depends on problem\n        while left < right:\n            mid = (left + right) // 2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        if len(bloomDay)<m*k:\n            return -1\n        def feasible(days):\n            flowers,bouquets=0,0\n            for bloom in bloomDay:\n                if bloom>days:\n                    flowers=0\n                else:\n                    bouquets+=(flowers+1)//k\n                    flowers=(flowers+1)%k\n            return bouquets>=m\n        \n        l,r=1,max(bloomDay)\n        while l<r:\n            mid=(l+r)//2\n            if feasible(mid):\n                r=mid\n            else:\n                l=mid+1\n        return l", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay)<m*k:\n            return -1\n        \n        def feasible(Day):\n            flowers,bouquets=0,0\n            for bloom in bloomDay:\n                if bloom>Day:\n                    flowers=0\n                else:\n                    bouquets+=(flowers+1)//k\n                    flowers=(flowers+1)%k\n            return bouquets>=m\n        \n        l,r=1,max(bloomDay)\n        while l<r:\n            mid=(l+r)//2\n            if feasible(mid):\n                r=mid\n            else:\n                l=mid+1\n        return l", "from typing import List\n\n\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def condition(numDays: int) -> bool:\n            flowers, bouquets = 0, 0\n            for bloom in bloomDay:\n                if numDays < bloom:\n                    flowers = 0\n                else:\n                    bouquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bouquets >= m\n\n        if len(bloomDay) < m * k: return -1\n        low, high = min(bloomDay), max(bloomDay)\n        while low < high:\n            mid = low + (high - low) // 2\n            if condition(mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\n\n", "class Solution:\n    def minDays(self, bloomDay: List[int], n: int, k: int) -> int:\n        def ok(m, n):\n            bloomed = [d <= m for d in bloomDay]\n            c = i = j = 0\n            while i < len(bloomed)-k+1:\n                for _ in range(k):\n                    if bloomed[j]:\n                        j += 1\n                    else:\n                        i = j = j+1\n                        break\n                else:\n                    i = j\n                    c += 1\n                    if c == n:\n                        break\n            else:\n                return False\n            return True\n        \n        \n        l, r = min(bloomDay), max(bloomDay)\n        while l < r:\n            m = (l+r) // 2\n            if ok(m, n):\n                r = m\n            else:\n                l = m+1\n        return l if ok(l, n) else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if n < m*k:\n            return -1\n        left, right = min(bloomDay), max(bloomDay)\n        def condition(day):\n            counter = 0\n            res = 0\n            for d in bloomDay:\n                if d<=day:\n                    counter += 1\n                else:\n                    counter = 0\n                if counter >=k:\n                    res += 1\n                    counter = 0\n            return res >= m\n        while left < right:\n            mid = left + (right - left) // 2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(days):\n            bouquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bouquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bouquets >= m\n        \n        if len(bloomDay) < (m * k):\n            return -1\n            \n        l, r = 1, max(bloomDay)\n        while l < r:\n            mid = (l + r) // 2\n            if feasible(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def minDays(self, bloom: List[int], m: int, k: int) -> int:\n        def isFeasible(day):\n            flower,bouqets=0,0\n            for b in bloom:\n                if b>day:\n                    flower=0\n                else:\n                    bouqets+=(flower+1)//k\n                    flower=(flower+1)%k\n            return bouqets>=m\n        \n        if len(bloom) < m * k:\n            return -1\n        l,r=1,max(bloom)\n        while l<r:\n            mid=l+(r-l)//2\n            if isFeasible(mid):\n                r=mid\n            else:\n                l=mid+1\n                \n        return l\n            \n            \n            \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def condition(x):\n            count = 0\n            M = 0\n            for i, day in enumerate(bloomDay):\n                bloom = 0\n                if day <= x:\n                    bloom = 1\n                    count += 1\n                    if count >= k:\n                        count = 0\n                        M += 1\n                    if M >= m:\n                        return True\n                else:\n                    count = 0\n            return False\n\n        if len(bloomDay) < m*k: return -1\n        left = min(bloomDay)\n        right = max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def canMake(bloomDay, m, k, day):\n            \n            r, cur, cnt = 0, 0, 0\n            while r < len(bloomDay):\n                if bloomDay[r] <= day:\n                    cur += 1\n                    if cur == k:\n                        cnt += 1\n                        cur = 0\n                        if cnt == m:\n                            return True\n                else:\n                    cur = 0\n                r += 1\n            return False\n        if m*k > len(bloomDay):\n            return -1\n        left, right = min(bloomDay), max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            if not canMake(bloomDay, m, k, mid):\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "# check length of array with total number of flowers needed- \n#https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/691031/Python3-Binary-Search-(ELIF5%3A-Explained-Like-I'm-5-Years-Old)\nclass Solution:\n    def minDays(self, listOfFlowerBloomDays: List[int], targetNumberOfBouquets: int, flowersPerBouquet: int) -> int:\n        def numberOfBouquetsWeCanMakeOnThisDay(dayThatWeAreChecking):\n            \n            currentListOfAdjacentBloomedFlowers = []\n            numberOfBouquetsWeCanMakeOnThisDay = 0\n            \n            for dayThatFlowerBlooms in listOfFlowerBloomDays: \n                if dayThatFlowerBlooms <= dayThatWeAreChecking:\n                    currentListOfAdjacentBloomedFlowers.append('x')   \n                else:\n                    numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\n                    currentListOfAdjacentBloomedFlowers = []\n\n            numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\n                    \n            return numberOfBouquetsWeCanMakeOnThisDay\n        \n        totalNumberOfFlowersNeeded = targetNumberOfBouquets*flowersPerBouquet\n        numberOfFlowersWeCanGrow = len(listOfFlowerBloomDays)\n        \n        if numberOfFlowersWeCanGrow < totalNumberOfFlowersNeeded: \n            return -1\n        \n        leftDay = 0\n        rightDay = max(listOfFlowerBloomDays)\n        \n        while leftDay < rightDay:\n            \n            currentDay = leftDay + (rightDay-leftDay)//2\n            if numberOfBouquetsWeCanMakeOnThisDay(currentDay) < targetNumberOfBouquets:\n                leftDay = currentDay+1\n            else:\n                rightDay = currentDay\n\n        return leftDay", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def condition(x):\n            count = 0\n            M = 0\n            for i, day in enumerate(bloomDay):\n                bloom = 0\n                if day <= x:\n                    bloom = 1\n                if bloom:\n                    count += 1\n                else:\n                    count = 0\n                if count >= k:\n                    count = 0\n                    M += 1\n                if M >= m:\n                    return True\n            return False\n\n        if len(bloomDay) < m*k: return -1\n        left = min(bloomDay)\n        right = max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        # m -- qty of bouquets, k -- qty of flowers\n        if len(bloomDay) < m * k:\n            return - 1\n        def feasible(days):\n            bonquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bonquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bonquets >= m\n        \n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        \n        def isFeasible(days):\n            \n            bouquetsSoFar = 0\n            flowersSoFar = 0\n            \n            for d in bloomDay:\n                \n                if d <= days:\n                    bouquetsSoFar += (flowersSoFar + 1) // k\n                    flowersSoFar = (flowersSoFar + 1) % k\n                    if bouquetsSoFar == m:\n                        return True\n                else:\n                    flowersSoFar = 0\n                \n            return False\n        \n        if len(bloomDay) < m * k:\n            return -1\n        \n        left, right = min(bloomDay), max(bloomDay)\n        \n        while left < right:\n            \n            mid = left + (right - left) // 2\n            \n            if isFeasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left", "class Solution:\n    IMPOSSIBLE = -1\n    \n#     @staticmethod\n#     def canMakeBouquetsOnDay(bloom_day: List[int], m: int, k: int, day: int) -> bool:\n#         n = len(bloom_day)\n#         bouquets_made = 0\n#         i = 0\n#         while i < n and bouquets_made < m:\n#             j = i\n#             while j < n and bloom_day[j] <= day:\n#                 j += 1\n#             if i == j:\n#                 i += 1\n#             else:\n#                 bouquets_made += (j - i) // k\n#                 i = j\n#         return bouquets_made >= m\n    \n#     def minDays(self, bloom_day: List[int], m: int, k: int) -> int:\n#         n = len(bloom_day)\n#         if k * m > n:\n#             return Solution.IMPOSSIBLE\n#         l = min(bloom_day) - 1\n#         r = max(bloom_day)\n#         # The invariant is it is possible to make k bouquets on day r.\n#         while r - l > 1:\n#             middle = (l + r) // 2\n#             if Solution.canMakeBouquetsOnDay(bloom_day, m, k, middle):\n#                 r = middle\n#             else:\n#                 l = middle\n#         return r\n\n    def bouquetsFrom(self, l: int, r: int) -> int:\n        return (r - l + 1) // self.k\n\n    def minDays(self, bloom_day: List[int], m: int, k: int) -> int:\n        self.k = k\n        n = len(bloom_day)\n        if k * m > n:\n            return Solution.IMPOSSIBLE\n        bloom_order = list(range(n))\n        bloom_order.sort(key=lambda index: bloom_day[index])\n        bloomed = [False for _ in range(n)]\n        to_left = [0 for _ in range(n)]\n        to_right = [0 for _ in range(n)]\n        bouquets_made = 0\n        for index in bloom_order:\n            bloomed[index] = True\n            l = index\n            r = index\n            if index != 0 and bloomed[index - 1]:\n                bouquets_made -= self.bouquetsFrom(\n                    to_left[index - 1], to_right[index - 1])\n                l = to_left[index - 1]\n            if index + 1 != n and bloomed[index + 1]:\n                bouquets_made -= self.bouquetsFrom(\n                    to_left[index + 1], to_right[index + 1])\n                r = to_right[index + 1]\n            bouquets_made += self.bouquetsFrom(l, r)\n            to_left[l] = to_left[r] = l\n            to_right[l] = to_right[r] = r\n            if bouquets_made >= m:\n                return bloom_day[index]\n        return Solution.IMPOSSIBLE\n", "class Solution:\n    def minDays(self, A: List[int], m: int, k: int) -> int:\n        if m * k > len(A):\n            return -1\n        \n        def isit(d):\n            b = m\n            for i, j in itertools.groupby(A, key=lambda x: x<=d):\n                l = sum(1 for _ in j)\n                if i==True:\n                    b -= l//k\n                if b<=0:\n                    break\n            return b<=0\n\n        l = 1\n        r = max(A)\n        while l < r:\n            mid = (l+r)//2\n            if isit(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        '''\n        binary search\n        '''\n        def check(day):\n            adjacent = 0\n            made = 0\n            for f in range(len(flowers)):\n                if day >= bloomDay[f]:\n                    flowers[f] = True\n                    adjacent += 1\n                else:\n                    adjacent = 0\n                if adjacent>=k:\n                    adjacent = 0\n                    made += 1\n                if made >= m:\n                    return True\n            return False\n        \n        if len(bloomDay) < m * k:\n            return -1\n        \n        flowers = [False] * len(bloomDay)\n        \n        l=1\n        r=max(bloomDay)\n        while l<r:\n            mid = l + (r - l)//2\n            if check(mid):\n                r = mid\n            else:\n                l = mid+1\n        return l\n                    \n                \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        l = min(bloomDay)\n        r = max(bloomDay)\n        ans = -1\n        \n        while l <= r:\n            mid = (l + r) >> 1\n            adjs = 0\n            bouqs = 0\n            for day in bloomDay:\n                if day <= mid:\n                    adjs += 1\n                else:\n                    bouqs += adjs // k\n                    if bouqs >= m:\n                        break\n                    adjs = 0\n            \n            bouqs += adjs // k\n            if bouqs >= m:\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n            \n        return ans", "class Solution:\n    def checkDate(self, bloom, m, k, day):\n        streak = 0\n        count = 0 \n        for b in bloom:\n            if b <= day:\n                streak += 1\n                if streak == k:\n                    count += 1\n                    if count == m:\n                        return True\n                    streak = 0\n            else:\n                streak = 0\n        return False\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        left, right = min(bloomDay), max(bloomDay) + 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if self.checkDate(bloomDay, m, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n                \n        return left if left != max(bloomDay) + 1 else -1", "class Solution:\n    def checkL(self,arr,t,k):\n        ans=0\n        temp=0\n        for i,n in enumerate(arr):\n            if t>=n:\n                temp+=1\n            else:\n                ans+=temp//k\n                temp=0\n        ans+=temp//k\n        return ans\n    \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        l=min(bloomDay)\n        r=max(bloomDay)\n        mm = r\n        while l<=r:\n            mid = (l+r)//2\n            if self.checkL(bloomDay,mid,k)>=m:\n                r=mid-1\n            elif self.checkL(bloomDay,mid,k)<m:\n                l=mid+1\n        if l==mm+1:\n            return -1\n        return l    ", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def possible(days):\n            bonquets = flowers = 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bonquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bonquets >= m\n        \n        if len(bloomDay) < m * k:\n            return -1\n\n        left = min(bloomDay)\n        right = max(bloomDay)\n        while left < right:\n            mid = (left + right) >> 1\n            if possible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left if possible(left) else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def check(day):\n            flowers = list(map(lambda d: d <= day, bloomDay))\n            mm = 0\n            kk = 0\n            for f in flowers:\n                if f is False:\n                    kk = 0\n                else:\n                    kk += 1\n                    if kk == k:\n                        mm += 1\n                        kk = 0\n            return mm >= m\n        days = sorted(list(set(bloomDay)))\n        def binarysearch(i, j):\n            if j <= i: return -1\n            if j - i <= 2:\n                for ii in range(i, j):\n                    if check(days[ii]): return days[ii]\n                return -1\n            mid = (i + j) // 2\n            if check(days[mid]): return binarysearch(i, mid+1)\n            return binarysearch(mid+1, j)\n        return binarysearch(0, len(days))", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def feasible(days) -> bool:\n            bonquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bonquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bonquets >= m\n\n        if len(bloomDay) < m * k:\n            return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    '''\n     [10,10,10,10,10,100], \n     m = 3, k = 2\n\n    \n    '''\n    def checkBl(self,arr,day,m,k):\n        \n        cnt=0\n        i=0\n        start=0\n        N=len(arr)\n        while i<N:\n            if arr[i]<=day:\n                if start==k-1:\n                    start=0\n                    cnt+=1\n                else:\n                    start+=1\n            else:\n                start=0\n            \n            if cnt==m:\n                return True\n            \n            i+=1\n            \n        return False\n        \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m==0:\n            return 0\n        \n        if m*k>len(bloomDay):\n            return -1\n        \n\n        '''\n        max_bd=float('-inf')\n        min_bd=float('inf')\n        \n        for i in bloomDay:\n            max_bd=max(max_bd,i)\n            min_bd=min(min_bd,i)\n         \n        l=min_bd\n        r=max_bd\n        '''\n        r=max(bloomDay)\n        l=min(bloomDay)\n        while  l<r:\n            mid=(l+r)//2\n            if self.checkBl(bloomDay,mid,m,k):\n                r=mid\n            else:\n                l=mid+1\n            \n        return l\n             \n            \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k > len(bloomDay):\n            return -1\n        \n        def canMakeBouquets(cap):\n            nBouquets = 0\n            nFlowers = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i] > cap:\n                    nFlowers = 0\n                    continue\n                nFlowers += 1\n                if nFlowers == k:\n                    nBouquets += 1\n                    nFlowers = 0\n            return nBouquets >= m\n        \n        lo, hi = min(bloomDay), max(bloomDay)\n        while lo < hi:\n            med = lo + (hi-lo)//2\n            if canMakeBouquets(med):\n                hi = med\n            else:\n                lo = med + 1\n        return hi", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        low = min(bloomDay)\n        high = max(bloomDay) + 1\n\n        def feasible(val):\n            flowers = [True if val >= d else False for d in bloomDay]\n            count = 0\n            total = m\n\n            while flowers:\n                if flowers.pop():\n                    count += 1\n                else:\n                    count = 0\n\n                if count >= k:\n                    total -= 1\n                    count -= k\n                    if total ==-1:\n                        break\n            return total <= 0\n            \n\n        while low < high:\n            mid = (low + high) // 2\n\n            if feasible(mid):\n                high = mid\n            else:\n                low = mid + 1\n        \n        if low == max(bloomDay) + 1:\n            return -1\n        else:\n            return low", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            cnt, n = 0, 0\n            for b in bloomDay:\n                if b <= mid:\n                    n += (cnt + 1) // k\n                    if n == m:\n                        break\n                    cnt = (cnt + 1) % k\n                else:\n                    cnt = 0\n            if n == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, A: List[int], m: int, k: int) -> int:\n        if len(A) < m * k: return -1\n        \n        def count(v):\n            ret, ct = 0, 0\n            for a in A:\n                if a <= v:\n                    ct += 1\n                else: ct = 0\n                if ct == k:\n                    ret += 1\n                    ct = 0\n            return ret\n        \n        left, right = min(A), max(A)\n        while left < right:\n            mid = (left + right) // 2\n            if count(mid) < m:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def feasible(limit):\n            flower=bouquets=0\n            for day in bloomDay:\n                if day<=limit:\n                    bouquets+=(flower+1)//k\n                    flower=(flower+1)%k\n                else:\n                    flower=0\n                    \n            return bouquets>=m\n        \n        \n        if len(bloomDay)<m*k:return -1\n    \n        left,right=1,max(bloomDay)\n        \n        while left<right:\n            \n            mid=(left+right)//2\n            \n            if feasible(mid):\n                right=mid\n            \n            else:\n                left=mid+1\n                \n        return left\n    \n        \n                    \n                    \n                    \n                    \n                    \n                    \n                \n                \n    \n        \n", "class Solution:\n    def minDays(self, A: List[int], m: int, k: int) -> int:\n        if m * k > len(A):\n            return -1\n        \n        def isit(d):\n            b = m\n            for i, j in itertools.groupby(A, key=lambda x: x<=d):\n                l = sum(1 for _ in j)\n                if i==True:\n                    b -= l//k\n            return b<=0\n\n        l = 0\n        r = max(A)+1\n        while l < r:\n            mid = (l+r)//2\n            if isit(mid):\n                r = mid\n            else:\n                l = mid + 1\n        print((l, r))\n        return l\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        n = len(bloomDay)\n        if n < m * k:\n            return -1\n        \n        def check(x):\n            cnt = 0\n            i = 0\n            for day in bloomDay:\n                if day <= x:\n                    i += 1\n                    if i == k:\n                        cnt += 1\n                        i = 0\n                    if cnt == m:\n                        return True\n                else:\n                    i = 0\n            return False\n        \n        days = sorted(set(bloomDay))\n        \n        lo, hi = 0, len(days) - 1\n        while lo < hi:\n            mid = (lo + hi)//2\n            if check(days[mid]):\n                hi = mid\n            else:\n                lo = mid + 1\n        return days[hi] if check(days[hi]) else -1\n        \n                    \n            \n", "class Solution:\n    def minDays(self, A: List[int], m: int, k: int) -> int:\n        if m * k > len(A):\n            return -1\n        \n        def isit(d):\n            b = m\n            for i, j in itertools.groupby(A, key=lambda x: x<=d):\n                l = sum(1 for _ in j)\n                if i==True:\n                    b -= l//k\n            return b<=0\n\n        l = 0\n        r = max(A)+1\n        while l < r:\n            mid = (l+r)//2\n            if isit(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def bouquets_possible(day):\n            print(day)\n            bouquets_count = 0\n            conse_day = 0\n            for i, v in enumerate(bloomDay):\n                if v <= day:\n                    conse_day += 1\n                    if conse_day == k:\n                        bouquets_count += 1\n                        conse_day = 0\n                else:\n                    conse_day = 0\n            print(bouquets_count)\n            return bouquets_count\n        \n        if len(bloomDay) < m * k:\n            return -1\n        \n        left = min(bloomDay)\n        right = max(bloomDay)\n        \n        while left < right:\n            mid = left + ( right - left)//2\n            if bouquets_possible(mid) < m:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def possible(x):\n            flo, bq = 0, 0\n            for bloom in bloomDay:\n                if bloom > x:\n                    flo = 0\n                else:\n                    flo += 1\n                    if flo >= k:\n                        flo = 0\n                        bq += 1\n            return bq >= m\n        \n        if m*k > len(bloomDay):\n            return -1\n        \n        \n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = (left + right)//2\n            if possible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def possible(day):\n            i=temp=b=0\n            while i<len(bloomDay):\n                if bloomDay[i]<=day:\n                    temp+=1\n                    if temp==k:\n                        b+=1\n                        temp=0\n                        if b>=m:return True\n                else:temp=0\n                i+=1\n            return False\n        \n        if len(bloomDay)<m*k:return -1\n        \n        left,right=min(bloomDay),max(bloomDay)\n        while left<right:\n            mid=left+(right-left)//2\n            if possible(mid):\n                right=mid\n            else:\n                left=mid+1\n        return left", "class Solution:\n    def minDays(self, blooms: List[int], m: int, k: int) -> int:\n        if m * k > len(blooms):\n            return -1\n        lo, hi = 0, max(blooms)\n\n        def is_possible(today):\n            streak = bouquets = 0\n\n            for day in blooms:\n                if day <= today:\n                    streak += 1\n                    if streak == k:\n                        bouquets += 1\n                        streak = 0\n                else:\n                    streak = 0\n\n            return bouquets >= m\n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if not is_possible(mid):\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo", "class Solution:\n    '''\n     [10,10,10,10,10,100], \n     m = 3, k = 2\n\n    \n    '''\n    def checkBl(self,arr,day,m,k):\n        \n        cnt=0\n        i=0\n        start=0\n        N=len(arr)\n        while i<N:\n            if arr[i]<=day:\n                if start==k-1:\n                    start=0\n                    cnt+=1\n                else:\n                    start+=1\n            else:\n                start=0\n            \n            if cnt==m:\n                return True\n            \n            i+=1\n            \n        return False\n        \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m==0:\n            return 0\n        \n        if m*k>len(bloomDay):\n            return -1\n        \n        \n        max_bd=float('-inf')\n        min_bd=float('inf')\n        \n        for i in bloomDay:\n            max_bd=max(max_bd,i)\n            min_bd=min(min_bd,i)\n            \n        l=min_bd\n        r=max_bd\n        while  l<r:\n            mid=(l+r)//2\n            if self.checkBl(bloomDay,mid,m,k):\n                r=mid\n            else:\n                l=mid+1\n            \n        return l\n             \n            \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        minDays = float('inf')\n        maxDays = 0\n        for bloomday in bloomDay:\n            if (bloomday < minDays):\n                minDays = bloomday\n            if (bloomday > maxDays):\n                maxDays = bloomday\n\n        low = minDays\n        high = maxDays\n        mid = (low+high)//2\n\n        while (low < high):\n            if(self.validDays(mid, bloomDay, m, k)):\n                high = mid\n            else:\n                low = mid+1\n            mid = (low+high)//2\n\n        if (self.validDays(low, bloomDay, m, k)):\n            return low\n        return -1\n\n    def validDays(self, days, bloomDay, m, k):\n        bouquets = 0\n        idx = 0\n        while(idx < len(bloomDay)):\n            flowergroupcount = 0\n            while (idx < len(bloomDay) and bloomDay[idx] <= days):\n                flowergroupcount += 1\n                idx += 1\n            bouquets += flowergroupcount//k\n            idx += 1\n        if (bouquets >= m):\n            return True\n        return False", "class Solution:\n    def producedAfterqDays(self, garden, adj, q):\n        wat = [i - q for i in garden]\n        return sum([len(list(cgen)) // adj for c, cgen in itertools.groupby(wat, key=lambda w: w<=0) if c])\n        \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        # for i in range(100):\n        #     if self.producedAfterqDays(bloomDay, k, i) >= m:\n        #         return i\n        # else:\n        #     return -1\n        l = 0\n        r = max(bloomDay)\n        ans = -1\n        while l <= r:\n            mid = (l + r)//2\n            if self.producedAfterqDays(bloomDay, k, mid) >= m:\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        return ans", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        l = 1; r = int(1e9)\n        def check(days, k):\n            made = 0\n            soFar = 0\n            for i in range(len(bloomDay)):\n                if(bloomDay[i] > days):\n                    soFar = 0\n                else:\n                    soFar += 1\n                if(soFar == k):\n                    soFar = 0\n                    made += 1\n            return made\n        while(l < r):\n            mid = l+((r-l)>>1)\n            if(check(mid, k) >= m):\n                r = mid\n            else:\n                l = mid+1\n        if(check(l, k) >= m):\n            return l\n        return -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        low,high = min(bloomDay),max(bloomDay)\n        res = sys.maxsize\n        while low <= high:\n            med = (low+high)//2\n            i = b = 0\n            while i < len(bloomDay):\n                f = 0\n                while i < len(bloomDay) and bloomDay[i]<=med and f<k:\n                    i, f = i+1, f+1\n                if f==k:\n                    b+=1\n                    if b==m: break\n                else: i+=1\n            if b<m: low=med+1\n            else:\n                res=min(res,med) \n                high=med-1\n        return res if res!=sys.maxsize else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        left = min(bloomDay)\n        right = max(bloomDay)\n        while left < right:\n            mid = left + ((right - left) // 2)\n            m1 = 0\n            k1 = 0\n            for f in range(len(bloomDay)):\n                if bloomDay[f] <= mid:\n                    if f == 0 or bloomDay[f - 1] <= mid:\n                        k1 += 1\n                    else:\n                        k1 = 1\n                    if k1 == k:\n                        m1 += 1\n                        k1 = 0\n            if m1 >= m:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, A, m, k):\n        if m * k > len(A): return -1\n        left, right = 1, max(A)\n        while left < right:\n            mid = (left + right) / 2\n            flow = bouq = 0\n            for a in A:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return int(left)", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        def bouqets(d):\n            res, c = 0, 0\n            for n in bloomDay:\n                c = 0 if n > d else c + 1\n                if c == k:\n                    res, c = res + 1, 0\n            return res\n            \n        days = sorted(set(bloomDay))\n        lo, hi = 0, len(days)-1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if bouqets(days[mid]) < m:\n                lo = mid + 1\n            else:\n                hi = mid\n        return days[hi] if days[hi] >= m else -1\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def count(d):\n            total = 0\n            curr = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i]>d:\n                    curr = 0\n                # else:\n                #     curr += 1\n                # if curr==k:\n                #     total += 1\n                else:\n                    total += (curr + 1) // k\n                    curr = (curr + 1) % k\n            return total\n        \n        if m*k>len(bloomDay):\n            return -1\n        l = min(bloomDay)\n        r = max(bloomDay)\n        while l<r:\n            d = l+(r-l)//2\n            if count(d)>=m:\n                r = d\n            else:\n                l = d+1\n        return l", "class Solution:\n    def minDays(self, days: List[int], m: int, k: int) -> int:\n        n = len(days)\n        if m*k > n: return -1\n        i, j = 1, max(days)\n        while i < j:\n            day = (i+j)/2\n            bou = flow = 0\n            for a in days:\n                flow = 0 if a > day else flow+1\n                if flow >= k:\n                    flow = 0\n                    bou += 1\n                    if bou == m: break\n            if bou == m:\n                j = day\n            else:\n                i = day+1\n            \n        return int(i)", "\n\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n\n        if len(bloomDay) < m*k:\n            return -1\n\n\n        def isPossible(l):\n            i = 0\n            temp = 0\n            num_bouquets = 0\n            while i < len(bloomDay):\n                if bloomDay[i] > l:\n                    temp = 0\n                else:\n                    temp += 1\n                    if temp == k:\n                        num_bouquets += 1\n                        if num_bouquets == m:\n                            return True\n                        temp = 0\n\n                i += 1\n\n            return False\n\n\n        low, high = min(bloomDay), max(bloomDay)\n        while low < high:\n            mid = low + (high-low)//2\n            if isPossible(mid):\n                high = mid\n            else:\n                low = mid+1\n        return low\n\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        A = bloomDay\n        if m * k > len(A): return -1\n        left, right = 1, max(A)\n        while left < right:\n            mid = (left + right) / 2\n            flow = bouq = 0\n            for a in A:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return int(left)", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        left=min(bloomDay)\n        right=max(bloomDay)\n        def feasible(day):\n            flower=0\n            count=0\n            for bloom in bloomDay:\n                if bloom>day:\n                    flower=0\n                else:\n                    count+=(flower+1)//k\n                    flower=(flower+1)%k\n                    \n            return count>=m\n                    \n        if len(bloomDay)<m*k:\n            return -1\n        \n        \n            \n        while left<right:\n            mid=left+(right-left)//2\n            if feasible(mid):\n                right=mid\n            else:\n                left=mid+1\n                \n        return left\n", "class Solution:\n    def minDays(self, bloom: List[int], m: int, k: int) -> int:\n        l, r = 1, max(bloom) + 1\n        \n        def do(t):\n            j = 0\n            ct = 0\n            while j < len(bloom):\n                i = j\n                a = 0\n                while i < len(bloom) and bloom[i] <= t:\n                    a += 1\n                    if a == k:\n                        ct += 1\n                        break\n                    i += 1\n\n                if ct == m:\n                    return True\n                \n                j = i + 1\n            return False\n        \n        while l < r:\n            mid = (l + r) // 2\n            \n            if not do(mid):\n                l = mid + 1\n            else:\n                r = mid\n        \n        return l if l <= max(bloom) else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k>len(bloomDay): return -1\n        left=min(bloomDay)\n        right=max(bloomDay)\n        \n        while left<right:\n            mid=(left+right)//2\n            print((left,right,mid,self.boquets(bloomDay,mid,k)))\n            if self.boquets(bloomDay,mid,k)>=m:\n                right=mid\n            else:\n                left=mid+1\n    \n        return left\n    def boquets(self,bloom,day,k):\n        res=0\n        cur=0\n        \n        for d in bloom:\n            if d<=day:\n                cur+=1\n            else:\n                cur=0\n            if cur==k:\n                res+=1\n                cur=0\n        return res\n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        l = 1; r = max(bloomDay)\n        def check(days, k):\n            made = 0\n            soFar = 0\n            for i in range(len(bloomDay)):\n                if(bloomDay[i] > days):\n                    soFar = 0\n                else:\n                    soFar += 1\n                if(soFar == k):\n                    soFar = 0\n                    made += 1\n            return made\n        while(l < r):\n            mid = l+((r-l)>>1)\n            if(check(mid, k) >= m):\n                r = mid\n            else:\n                l = mid+1\n        if(check(l, k) >= m):\n            return l\n        return -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        bloomDayDict = defaultdict(list)\n        \n        for i, v in enumerate(bloomDay):\n            bloomDayDict[v].append(i)\n                    \n        def feasible(days) -> bool:\n            bonquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bonquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bonquets >= m\n\n        \n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left if feasible(left) else -1", "class Solution:\n    \n    \n    \n    \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if n < m*k or k == 0: return -1\n        if n == m*k: return max(bloomDay)\n        \n        def isGood(days):\n            kk = 0\n            mm = 0\n            i = 0\n            while i < len(bloomDay):\n                if bloomDay[i] <= days:\n                    while i < len(bloomDay) and bloomDay[i] <= days and kk < k:\n                        i += 1        \n                        kk += 1\n                    if kk == k:\n                        mm += 1\n                        kk = 0\n                else:\n                    kk = 0\n                    i += 1\n                if mm == m:\n                    return True\n            return False\n        \n        low, high = 0, max(bloomDay)\n        while low < high:\n            mid = low + (high-low)//2\n            if isGood(mid):\n                high = mid\n            else:\n                low = mid+1\n        return low\n        \n        \n                        \n            \n                \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def count(l,i):\n            c,count=0,0\n            for j in l:\n                if(j<=i):\n                    c+=1\n                elif(j>i):\n                    count+=c//k\n                    c=0\n            return count+c//k\n        l=bloomDay[:]\n        if((len(l)//k)<m):return -1\n        l1=min(l)\n        r=max(l)\n        while(l1<r):\n            mid=l1+(r-l1)//2\n            if(count(l,mid)>=m):\n                r=mid\n            else:\n                l1=mid+1\n        return l1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        low,high = 1,max(bloomDay)\n        if m * k > len(bloomDay): return -1\n        res = sys.maxsize\n        while low <= high:\n            med = (low+high)//2\n            i = b = 0\n            while i < len(bloomDay):\n                f = 0\n                while i < len(bloomDay) and bloomDay[i]<=med and f<k:\n                    i, f = i+1, f+1\n                if f==k: b+=1\n                else: i+=1\n            if b<m: low=med+1\n            else:\n                res=min(res,med) \n                high=med-1\n        return res if res!=sys.maxsize else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def canCreate(days):\n            flowers = [1 if days >= bloom else 0 for bloom in bloomDay]\n            bouquets = 0\n            adj = 0\n            for flower in flowers:\n                if not flower:\n                    adj = 0\n                    continue\n                adj += 1\n                if adj == k:\n                    adj = 0\n                    bouquets += 1\n                    if bouquets == m:\n                        return True\n            return False\n        MAX = 10**9+1\n        left, right = 1, MAX\n        while left < right:\n            mid = (left+right)//2\n            if canCreate(mid):\n                right = mid\n            else:\n                left = mid+1\n        return left if left != MAX else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n    \n        def check(flower,N,m,k):\n            count=0\n            for i in flower:\n                if i==1:\n                    count+=1\n                    if count==k:\n                        m-=1\n                        count=0\n                    if m==0:\n                        return True\n                else:\n                    count=0\n            return False\n            \n        \n        N=len(bloomDay)\n        if N<m*k:\n            return -1\n        left=0\n        right=max(bloomDay)\n        res=right\n        while left<right:\n            day=(left+right)//2\n            flower=[0]*N\n            for x in range(N):\n                if bloomDay[x]<=day:\n                    flower[x]=1  \n  \n            if check(flower,N,m,k):\n                right=day\n                res=min(res,day)\n            else:\n                left=day+1\n            \n        \n        return res\n\n                \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay)<m*k:\n            return -1\n        low=k\n        high=min1=max(bloomDay)\n        while low<=high:\n            mid=(low+high)//2\n            flag=sum1(mid,bloomDay,k)\n            if flag>=m:\n                high=mid-1\n                min1=min(mid,min1)\n            else:\n                low=mid+1\n                \n        return min1\ndef sum1(given,bloom,k):\n    res=0\n    count=0\n    i=0\n    while i<len(bloom):\n        if bloom[i]>given:\n            i+=1\n            count=0\n            continue\n        while i<len(bloom) and bloom[i]<=given:\n            count+=1\n            i+=1\n            if count==k:\n                res+=1\n                count=0\n    return res\n                \n                \n            \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def condition(x):\n            currNumFlower, numBouquets = 0, 0\n            for flower in bloomDay:\n                currNumFlower+=1\n                if flower > x:  currNumFlower=0\n                else:\n                    if currNumFlower == k:\n                        currNumFlower, numBouquets = 0, numBouquets+1\n            if numBouquets >= m:    return True\n            return False\n        \n        left, right = 1, max(bloomDay)+1\n        while left<right:\n            mid = left + (right-left)//2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid+1\n        return left if left>0 and left<max(bloomDay)+1 else -1\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        start, end = 1, max(bloomDay)\n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if self.helper(bloomDay, m, k, mid):\n                end = mid\n            else:\n                start = mid\n        \n        if self.helper(bloomDay, m, k, start):\n            return start\n        elif self.helper(bloomDay, m, k, end):\n            return end\n        else:\n            return -1\n    \n    def helper(self, bloomDay, m, k, day):\n        consecutive = 0\n        count = 0\n        \n        for bloomday in bloomDay:\n            if bloomday > day:\n                consecutive = 0\n            else:\n                consecutive += 1\n                if consecutive == k:\n                    count += 1\n                    consecutive = 0\n        \n        return count >= m\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        if len(bloomDay) < m*k:\n            return -1\n        \n        def can_make(days):\n            flowers = 0\n            bouq = 0\n            for i in bloomDay:\n                if i > days:\n                    flowers = 0\n                else:\n                    flowers += 1\n                \n                if flowers == k:\n                    bouq += 1\n                    flowers = 0\n            \n            return bouq >=m\n                    \n        \n        left , right = 1 , max(bloomDay)\n        while left < right:\n            mid = left + (right- left) // 2\n            \n            if can_make(mid):\n                right = mid\n            \n            else:\n                left = mid + 1\n        \n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        low,high = min(bloomDay),max(bloomDay)\n        if m * k > len(bloomDay): return -1\n        res = sys.maxsize\n        while low <= high:\n            med = (low+high)//2\n            i = b = 0\n            while i < len(bloomDay):\n                f = 0\n                while i < len(bloomDay) and bloomDay[i]<=med and f<k:\n                    i, f = i+1, f+1\n                if f==k: b+=1\n                else: i+=1\n            if b<m: low=med+1\n            else:\n                res=min(res,med) \n                high=med-1\n        return res if res!=sys.maxsize else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        \n        def feasible(days) -> bool:\n            \n            bouquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bouquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bouquets >= m\n    \n        \n        if len(bloomDay) < m * k:\n            return -1\n        \n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "'''\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        A = bloomDay\n        if m * k > len(A): return -1\n        left, right = 1, max(A)\n        while left < right:\n            mid = (left + right) // 2\n            flow = bouq = 0\n            for a in A:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n'''\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if n < m*k :return -1\n        l, r = 1, max(bloomDay)\n        while l < r:\n            mid = l + (r - l) // 2\n            temp = 0\n            cnt = 0\n            for n in bloomDay:\n                temp = 0 if n > mid else temp + 1\n                if temp >=k:\n                    temp = 0\n                    cnt+=1\n                    if cnt==m:break\n            if cnt == m : r= mid\n            else: l = mid+1\n        return l\n\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        def get_num_boquets(wait_days):\n            i = 0\n            while i < n and bloomDay[i] > wait_days:\n                i += 1\n            # i: index of first available flower\n            j = i\n            count = 0\n            while j < n:\n                while j < n and bloomDay[j] <= wait_days:\n                    j += 1\n                j -= 1 # index of last available flower in the adjacent subarray\n                count += (j-i+1) // k\n                i = j + 1\n                while i < n and bloomDay[i] > wait_days:\n                    i += 1\n                # i: index of first available flower\n                j = i\n            return count\n        start = 1\n        end = max(bloomDay)\n        while start < end:\n            mid = start + (end-start) // 2\n            #print(mid, get_num_boquets(mid))\n            if get_num_boquets(mid) >= m:\n                # wait is too long, or just right\n                end = mid\n            else:\n                # wait is too short\n                start = mid + 1\n        if start >= 1 and start <= max(bloomDay) and get_num_boquets(start) >= m:\n            return start\n        else:\n            return -1\n", "from array import array\n\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m * k:\n            return -1\n        if k == 0:\n            return 0\n        \n        min_d, max_d = bloomDay[0], bloomDay[0]\n        \n        for d in bloomDay:\n            if d > max_d:\n                max_d = d\n            if d < min_d:\n                min_d = d\n        \n        def possible_bouquets(day):\n            bouquets = 0\n            flower_count = 0\n            i = 0\n            while i < len(bloomDay):\n                if bloomDay[i] <= day:\n                    flower_count += 1\n                    \n                    if flower_count == k:\n                        bouquets+=1\n                        flower_count = 0\n                else:\n                    flower_count = 0\n                i+=1\n            return bouquets\n            \n        possible_days = -1\n        day_guess = (min_d + max_d) // 2\n        \n        while min_d <= max_d:\n            bouquets = possible_bouquets(day_guess)\n            #print(f\\\"{day_guess}:{bouquets}\\\")\n            if bouquets >= m:\n                max_d = day_guess - 1\n                possible_days = day_guess\n            else:\n                min_d = day_guess + 1\n            \n            day_guess = (min_d + max_d) // 2\n            \n        return possible_days\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        low,high = min(bloomDay),max(bloomDay)\n        res = sys.maxsize\n        while low <= high:\n            med = (low+high)//2\n            i = b = 0\n            while i < len(bloomDay):\n                f = 0\n                while i < len(bloomDay) and bloomDay[i]<=med and f<k:\n                    i, f = i+1, f+1\n                if f==k: b+=1\n                else: i+=1\n            if b<m: low=med+1\n            else:\n                res=min(res,med) \n                high=med-1\n        return res if res!=sys.maxsize else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def checkFlowers(mid,m,k):\n            bq = 0\n            i = 0\n            while i <len(bloomDay):\n                if bloomDay[i] <= mid:\n                    count = 1\n                    i+=1\n                    while i <len(bloomDay) and count < k and bloomDay[i] <= mid:\n                        count+=1\n                        i+=1\n                    if count == k:\n                        bq+=1\n                else:\n                    i+=1\n            return bq\n        \n        \n        if len(bloomDay) < k*m :\n            return -1\n        \n        low = 1\n        high = max(bloomDay)\n        while low < high:\n            mid = (low + high)//2\n            x = checkFlowers(mid,m,k) \n            if x >= m:\n                high = mid\n            else:\n                low = mid + 1\n        return high", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        low = min(bloomDay)\n        high = max(bloomDay) + 1\n\n        def feasible(val):\n            flowers = list(map(lambda f: val >= f, bloomDay))\n            count = 0\n            total = m\n\n            while flowers:\n                if flowers.pop():\n                    count += 1\n                else:\n                    count = 0\n\n                if count >= k:\n                    total -= 1\n                    count -= k\n                    if total ==-1:\n                        break\n            return total <= 0\n            \n\n        while low < high:\n            mid = (low + high) // 2\n\n            if feasible(mid):\n                high = mid\n            else:\n                low = mid + 1\n        \n        if low == max(bloomDay) + 1:\n            return -1\n        else:\n            return low", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k > len(bloomDay):\n            return -1\n\n        bloomDay_sort = sorted(bloomDay)\n        bloomDay_dict = {}\n        num = 0\n        prev = -1\n        for item in bloomDay_sort:      # \u79bb\u6563\n            if item != prev:\n                bloomDay_dict[num] = item\n                num += 1\n                prev = item\n\n        # \u4e8c\u5206day\n        bloomDay_tmp = [0 for ii in range(len(bloomDay))]\n        l, r = 0, num\n        while l < r:\n            mid = (l+r)//2\n            for i in range(len(bloomDay)):\n                if bloomDay[i] <= bloomDay_dict[mid]:\n                    bloomDay_tmp[i] = 1\n                else:\n                    bloomDay_tmp[i] = 0\n\n            count_nonlocal = 0\n            count = 0\n            for i in range(len(bloomDay_tmp)):\n                if bloomDay_tmp[i] == 1:\n                    count += 1\n                else:\n                    count_nonlocal += count // k\n                    count = 0\n\n            if count != 0:          ##\n                count_nonlocal += count // k\n                count = 0\n\n            if count_nonlocal >= m:\n                r = mid\n            else:\n                l = mid+1\n\n        return bloomDay_dict[l]      # ", "class Solution:\n    def minDays(self, bd: List[int], no_of_bouqs: int, flowers_in_a_bouq: int) -> int:\n        if len(bd)<no_of_bouqs*flowers_in_a_bouq:\n            return -1\n        def condition(minDays):\n            #print(minDays,end=' ')\n            bouq=0; bouq_flowers=0\n            for i in bd:\n                if i<=minDays:  # The flower can be used\n                    bouq_flowers+=1\n                    if bouq_flowers==flowers_in_a_bouq:\n                        bouq+=1\n                        bouq_flowers=0\n                        if bouq==no_of_bouqs:\n                            return True\n                if i>minDays:\n                    bouq_flowers=0\n                #print(i,minDays,bouq_flowers,bouq)\n            return False\n        \n        l=min(bd)\n        r=max(bd)\n        while l<r:\n            mid=(l+r)//2\n            if condition(mid):\n                r=mid\n            else:\n                l=mid+1\n        return l", "class Solution:\n    def minDays(self, A: List[int], m: int, k: int) -> int:\n        \n        def valid(mid):\n            cur = 0\n            accu = 0\n            for n in A:\n                if n <= mid:\n                    cur += 1\n                    if cur == k:\n                        accu += 1\n                        cur = 0\n                else:\n                    cur = 0\n            return accu >= m\n        \n        n = len(A)\n        if m * k > n: return -1\n        \n        l, r = min(A), max(A)\n        while l < r:\n            mid = (l+r)//2\n            if valid(mid): r = mid\n            else: l = mid + 1\n        return l\n        \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        lo, hi = float('inf'), -float('inf')\n        for day in bloomDay:\n            lo = min(lo, day)\n            hi = max(hi, day)\n        \n        def check(d): # check if D days is good enough for m bouquets of k flowers\n            cnt, start = 0, -1\n            for i, val in enumerate(bloomDay):\n                if val <= d and i - start >= k:\n                    cnt += 1\n                    start = i\n                elif val > d:\n                    start = i\n            return cnt >= m\n        \n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if check(mid):\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return lo", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def make_boquets(mid):\n            flowers,bouquets = 0,0\n            for flower in bloomDay:\n                if flower > mid:\n                    flowers = 0\n                else:\n                    flowers += 1\n                    if flowers == k:\n                        flowers = 0\n                        bouquets += 1\n            return bouquets >= m\n        left,right = min(bloomDay), max(bloomDay) + 1\n        while left < right:\n            mid = left + (right-left)//2\n            if make_boquets(mid):\n                right = mid\n            else:\n                left = mid + 1\n        if left > max(bloomDay):\n            return -1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        def bouqets(d):\n            res, c = 0, 0\n            for n in bloomDay:\n                c = 0 if n > d else c + 1\n                if c == k:\n                    res, c = res + 1, 0\n            return res\n            \n        days = sorted(set(bloomDay))\n        lo, hi = 0, len(days)-1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            bouq, c = 0, 0\n            for n in bloomDay:\n                c = 0 if n > days[mid] else c + 1\n                if c == k:\n                    bouq, c = bouq + 1, 0\n            if bouq < m:\n                lo = mid + 1\n            else:\n                hi = mid\n        return days[hi] if bouqets(days[hi]) >= m else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def condition(x):\n            bloom = [0]*len(bloomDay)\n            for i, day in enumerate(bloomDay):\n                if day <= x:\n                    bloom[i] = 1\n            count = 0\n            M = 0\n            for flower in bloom:\n                if flower:\n                    count += 1\n                else:\n                    count = 0\n                if count >= k:\n                    count = 0\n                    M += 1\n                if M >= m:\n                    return True\n            return False\n\n        if len(bloomDay) < m*k: return -1\n        left = min(bloomDay)\n        right = max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def make_boquets(mid):\n            i,boquets = 0,0\n            while i < len(bloomDay):\n                j = i\n                while j < len(bloomDay) and j - i < k:\n                    if bloomDay[j] > mid:\n                        break\n                    j += 1\n                if j-i == k:\n                    boquets += 1\n                    j -= 1\n                i = j + 1\n            return boquets >= m\n        left,right = min(bloomDay), max(bloomDay) + 1\n        while left < right:\n            mid = left + (right-left)//2\n            if make_boquets(mid):\n                right = mid\n            else:\n                left = mid + 1\n        if left > max(bloomDay):\n            return -1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        '''\n        # Notes:\n            k adjacent flowers\n        \n        '''\n        # edge case\n        n = len(bloomDay)\n        if n // k < m:\n            return -1\n        if k * m == n:\n            return max(bloomDay)\n        \n        def feasible(days) -> bool:\n            bonquets, flowers = 0, 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bonquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bonquets >= m\n\n        if len(bloomDay) < m * k:\n            return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay)<m*k:\n            return -1\n        \n        def canMake(days, bloomDay, k):\n            flowers, n = 0, 0\n            for bloom in bloomDay:\n                if bloom>days:\n                    flowers = 0\n                else:\n                    n = n + (flowers+1)//k\n                    flowers = (flowers+1)%k\n            return n\n                    \n        # use binary search. search values are\n        # within min(bloomDay) and max(bloomDay)\n        l, r = min(bloomDay), max(bloomDay)\n        while l<=r:\n            mid = l+(r-l)//2\n            count = canMake(mid, bloomDay, k)\n            if count==m:\n                r = mid-1\n            elif count<m:\n                l = mid+1\n            elif count>m:\n                r = mid-1\n        return l", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(day):\n            bouquets = 0\n            adjacent = 0\n            for bloom in bloomDay:\n                if bloom > day:\n                    adjacent = 0\n                else:\n                    adjacent += 1\n                \n                if adjacent == k:\n                    bouquets += 1\n                    adjacent = 0\n            \n            return bouquets >= m\n            \n        \n        left, right = min(bloomDay), max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left if feasible(left) else -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(days: int):\n            flowers, bouquets = 0, 0\n            for bloom in bloomDay:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    bouquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n            return bouquets >= m\n\n        if len(bloomDay) < m * k: return -1\n        low, high = 1, max(bloomDay)\n        while low < high:\n            mid = low + (high - low) // 2\n            if feasible(mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\n\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k>len(bloomDay): return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            flow = bouq = 0\n            for a in bloomDay:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if n < m * k:\n            return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if self.validBouquets(bloomDay, mid, m, k):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n    def validBouquets(self, bloomDay, days, m, k):\n        # Count how many bouquets we can collect\n        count_bouquets = 0\n        temp_flowers = 0\n        for bloom in bloomDay:\n            if bloom <= days:\n                temp_flowers += 1\n            else:\n                temp_flowers = 0\n            # Determine whether flowers in hand can form a bouquet\n            if temp_flowers >= k:\n                count_bouquets += 1\n                temp_flowers = 0\n        return count_bouquets >= m", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def make_boquets(mid):\n            i,boquets = 0,0\n            while i < len(bloomDay):\n                j = i\n                while j < len(bloomDay) and j - i < k:\n                    if bloomDay[j] > mid:\n                        break\n                    j += 1\n                if j-i == k:\n                    boquets += 1\n                    j -= 1\n                i = j + 1\n            return boquets >= m\n        if len(bloomDay) < m * k:\n            return -1\n        left,right = min(bloomDay), max(bloomDay) + 1\n        while left < right:\n            mid = left + (right-left)//2\n            if make_boquets(mid):\n                right = mid\n            else:\n                left = mid + 1\n        if left > max(bloomDay):\n            return -1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n#         binary search\n        def validable(days):\n#             how many booms in days, and how many bouquet can make\n            bloom = 0\n            bouquet = 0\n            for b in bloomDay:\n                if b <= days:\n                    bloom += 1\n                    bouquet += bloom // k\n                    bloom = bloom % k\n                else:\n                    bloom = 0\n            return bouquet >= m\n                    \n        if len(bloomDay) < m * k:\n            return -1\n        left = min(bloomDay)\n        right = max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            if validable(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n    \n    \n#     def minDays(bloomDay: List[int], m: int, k: int) -> int:\n#     def feasible(days) -> bool:\n#         bonquets, flowers = 0, 0\n#         for bloom in bloomDay:\n#             if bloom > days:\n#                 flowers = 0\n#             else:\n#                 bonquets += (flowers + 1) // k\n#                 flowers = (flowers + 1) % k\n#         return bonquets >= m\n\n#     if len(bloomDay) < m * k:\n#         return -1\n#     left, right = 1, max(bloomDay)\n#     while left < right:\n#         mid = left + (right - left) // 2\n#         if feasible(mid):\n#             right = mid\n#         else:\n#             left = mid + 1\n#     return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        if len(bloomDay)<m*k:\n            return -1\n        l,r=1,max(bloomDay)\n        \n        def feasible(days):\n            flowers,bouquets=0,0\n            for bloom in bloomDay:\n                if bloom>days:\n                    flowers=0\n                else:\n                    bouquets+=(flowers+1)//k\n                    flowers=(flowers+1)%k\n            return bouquets>=m\n        \n        while l<r:\n            mid=(l+r)//2\n            if feasible(mid):\n                r=mid\n            else:\n                l=mid+1\n        return l\n", "class Solution:\n    def bloom(self,arr,k,d,m):\n        cnt,bk=0,0\n        for i in arr:\n            if i<=d:\n                cnt+=1\n                if cnt==k:\n                    bk+=1\n                    cnt=0\n            else:\n                cnt=0\n        if bk>=m:\n            return 1\n        else:\n            return 0\n            \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        l=1\n        r=max(bloomDay)+1\n        while l<r:\n            mid=(l+r)//2\n            if self.bloom(bloomDay,k,mid,m):\n                r=mid\n            else:\n                l=mid+1\n        return -1 if l>max(bloomDay) else l       ", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n    \n        def can_make(days):\n            num_boqs = 0\n            num_flows = 0\n            \n            start = 0\n            \n            for bloom in bloomDay:\n                if bloom > days:\n                    num_flows = 0\n                else:\n                    num_boqs += (num_flows + 1) // k\n                    num_flows = (num_flows + 1) % k\n                    \n            return num_boqs >= m\n            \n        if len(bloomDay) < m * k:\n            return -1\n        \n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if can_make(mid):\n                right = mid\n            else:\n                left = mid + 1\n                \n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def feasible(days) -> bool:\n            flowers = 0\n            bouquets = 0\n            \n            #loop through the array to check the days to bloom\n            for bloom in bloomDay:\n                if bloom > days: #we cannot gather any flowers to make the bouquets because the flower are not yet bloomed \n                    flowers = 0\n                    \n                else: \n                    bouquets += (flowers + 1) // k\n                    flowers = (flowers + 1) % k\n                    \n            return bouquets >= m\n        \n            \n        \n        \n        #base case: \n        if len(bloomDay) < m * k:\n            return -1\n        left = 1\n        right = max(bloomDay)\n        while left < right: \n            mid = left + (right - left) // 2\n            if feasible(mid):\n                right = mid\n                \n            else: \n                left = mid + 1\n                \n        return left\n    \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        left = 1\n        right = max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            flow = 0\n            bouq = 0\n            for n in bloomDay:\n                if n > mid:\n                    flow = 0\n                else:\n                    flow += 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m:\n                        break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        s = 0\n        e = max(bloomDay)\n        ans = -1\n        \n        while s <= e:\n            mid = int(s + (e-s)/2)\n            if self.checkDay(bloomDay, m, k, mid):\n                ans = mid\n                e = mid - 1\n            else:\n                s = mid + 1\n        \n        return ans\n    \n    def checkDay(self, a, m, k, d):\n        tot = 0\n        count = 0\n        for i in range(len(a)):\n            if a[i] <= d:\n                count+=1\n                if count == k:\n                    tot += 1\n                    count = 0\n            else:\n                count = 0\n        \n        return tot >= m", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        lo, hi = min(bloomDay), max(bloomDay)\n        def validDay(bloom, day):\n            cnt, adj = 0, 0\n            for b in bloom:\n                if b <= day:\n                    adj += 1\n                if adj >= k:\n                    adj = 0\n                    cnt += 1\n                if b > day:\n                    adj = 0\n            print((cnt, k))\n            return cnt >= m\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if validDay(bloomDay, mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        min_day = bloomDay[0]\n        max_day = bloomDay[0]\n        for day in bloomDay:\n            if min_day > day:\n                min_day = day\n            if max_day < day:\n                max_day = day\n\n        def isValidDay(day_try: int) -> bool:\n            count = 0\n            current = 0\n            for local_day in bloomDay:\n                if day_try >= local_day:\n                    current += 1\n                    if current >= k:\n                        count += 1\n                        current = 0\n                else:\n                    current = 0\n            return count >= m\n\n        left = min_day\n        right = max_day\n        result = 0\n        while left <= right:\n            mid = (left + right) // 2\n            if isValidDay(mid):\n                result = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return result", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        l = 1\n        r = 1000000000\n        if m * k > len(bloomDay):\n            return -1\n        \n        while l < r:\n            \n            mid = l + (r - l)//2\n            if self.validflower(mid, bloomDay, k, m) == True:\n                r = mid\n            else:\n                l = mid + 1\n        return l         \n            \n \n            \n    def validflower(self, mid, bloomDay, k, m):\n        count = 0\n        f = 0\n        for j in bloomDay:\n            if j <= mid:\n                f += 1\n            else:\n                f = 0\n                \n            if f == k:\n                count += 1\n                f = 0\n            \n        if count >= m:\n            return True\n        \n        return False\n                \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        len_bloom = len(bloomDay)\n        lis = [[bloomDay[i], i] for i in range(len_bloom)]\n        lis.sort()\n        lis2 = [[] for x in range(len_bloom)]\n        tot = 0\n        for i in lis:\n            val, index = i\n            if(index > 0 and lis2[index-1] and index < len_bloom-1 and lis2[index+1]):\n                start = lis2[index-1][0]\n                end = lis2[index+1][1]\n                tot -= (lis2[index-1][3] + lis2[index+1][3])\n                tot_len = lis2[index-1][2] + 1 + lis2[index+1][2]\n                tot += tot_len//k\n                to_be_inserted = [start, end, tot_len, tot_len//k]\n                lis2[start] = to_be_inserted\n                lis2[end] = to_be_inserted\n            elif(index > 0 and lis2[index-1]):\n                start = lis2[index-1][0]\n                end = index\n                tot -= lis2[index-1][3]\n                tot_len = lis2[index-1][2] + 1\n                tot += tot_len//k\n                lis2[start] = [start, end, tot_len, tot_len//k]\n                lis2[end] = lis2[start]\n            elif(index < len_bloom - 1 and lis2[index+1]):\n                start = index\n                end = lis2[index+1][1]\n                tot -= lis2[index+1][3]\n                tot_len = lis2[index+1][2] + 1\n                tot += tot_len//k\n                lis2[end] = [start, end, tot_len, tot_len//k]\n                lis2[start] = lis2[end]\n            else:\n                tot += 1//k\n                lis2[index] = [index, index, 1, 1//k]\n            if(tot >= m):\n                return val\n        return -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k > len(bloomDay):\n            return -1\n        lo , hi = min(bloomDay), max(bloomDay)\n        while lo<hi:\n            mid=(lo+hi)//2\n            i, cap, bqts = 0, 0, 0\n            while i<len(bloomDay):\n                if bloomDay[i]<=mid: \n                    cap+=1\n                else:\n                    cap=0\n                if cap==k:\n                    bqts+=1\n                    cap=0\n                i+=1  \n            if bqts<m:\n                lo=mid+1\n            else:\n                hi=mid\n        return lo\n                    \n                    \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n=len(bloomDay)\n        events=sorted(bloomDay)\n        \n        def possible(time):\n            flower = [j for j, i in enumerate(bloomDay) if i<=time]\n            left=0\n            bouquets=0\n            for i, c in enumerate(flower):\n                if i==len(flower)-1 or flower[i+1]!=c+1:\n                    bouquets+=(i-left+1)//k\n                    left=i+1\n            return bouquets>=m\n        \n        lo, hi = 0, n\n        while lo<hi:\n            mid = lo+(hi-lo)//2 #prevent overflow\n            if not possible(events[mid]):\n                lo=mid+1\n            else:\n                hi=mid\n        return events[lo] if lo<n else -1\n            \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n=len(bloomDay)\n        events=sorted(list(set(bloomDay)))\n        \n        def possible(time):\n            flower = [j for j, i in enumerate(bloomDay) if i<=time]\n            left=0\n            bouquets=0\n            for i, c in enumerate(flower):\n                if i==len(flower)-1 or flower[i+1]!=c+1:\n                    bouquets+=(i-left+1)//k\n                    left=i+1\n            return bouquets>=m\n        \n        lo, hi = 0, len(events)\n        while lo<hi:\n            mid = lo+(hi-lo)//2 #prevent overflow\n            if not possible(events[mid]):\n                lo=mid+1\n            else:\n                hi=mid\n        return events[lo] if lo<len(events) else -1\n            \n", "class Solution:\n    def minDays(self, A: List[int], m: int, k: int) -> int:\n        if m * k > len(A): \n            return -1\n        left, right = 1, max(A)\n        while left <= right:\n            mid = (left + right) // 2\n            flow = bouq = 0\n            for a in A:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n            \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        def feasible_bloom_day(value):\n            total_bouquet = 0\n            num_flowers = 0\n            \n            for bloom in bloomDay:\n                # Flower bloomed\n                if bloom > value:\n                    num_flowers = 0\n                else:\n                    total_bouquet += (num_flowers+1) // k\n                    num_flowers = (num_flowers+1) % k\n            \n            return total_bouquet >= m\n        \n        left, right = 1, max(bloomDay)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if feasible_bloom_day(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        # day d how many bouquets we could make\n        if m*k > len(bloomDay):\n            return -1\n        \n        \n        def count(d):\n            ans = 0\n            curr = 0\n            \n            for i in range(len(bloomDay)):\n                if bloomDay[i] <= d:\n                    curr += 1\n                    if curr == k:\n                        ans += 1\n                        curr = 0\n                else:\n                    curr = 0\n            return ans\n        \n        l, r = 1, max(bloomDay)\n        \n        while l < r:\n            mid = (l + r) //2\n            print((l, r, mid, count(mid)))\n            if count(mid) >= m:\n                r = mid\n            else:\n                l = mid + 1\n        \n        return l\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if m * k > n:\n            return -1\n        vals = list(set(bloomDay))\n        vals.sort()\n        \n        def invalid(threshold):\n            cur = 0\n            bouquets = 0\n            for x in bloomDay:\n                if x <= threshold:\n                    cur += 1\n                    if cur == k:\n                        cur = 0\n                        bouquets += 1\n                else:\n                    cur = 0\n            return bouquets < m\n        \n        left, right = 0, len(vals) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            # print(left, right, mid)\n            if invalid(vals[mid]):\n                left = mid + 1\n            else:\n                right = mid - 1\n        return vals[left]", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def isOK(day, m):\n            cur = 0\n            for ptr in range(len(bloomDay)):\n                if bloomDay[ptr] > day:\n                    cur = 0\n                else:\n                    cur += 1\n                    if cur == k:\n                        m -= 1\n                        cur = 0\n                        if m == 0:\n                            return True\n            return False\n            \n        if m * k > len(bloomDay):\n            return -1\n        left, right = min(bloomDay), max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            if isOK(mid, m):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def check(days):\n            ans = 0\n            temp = k\n            func = lambda x : 1 if x <= days else 0\n            nums = [func(i) for i in bloomDay]\n            \n            for i in nums:\n                if i == 0:\n                    temp = k\n                else:\n                    if temp == 1:\n                        temp = k\n                        ans += 1\n                    else:\n                        temp -= 1\n            return ans >= m\n               \n        n = len(bloomDay)\n        if n < m * k:\n            return -1\n        \n        l,r = 0,max(bloomDay)\n        while l <= r:\n            mid = (l+r) // 2\n            if check(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n    \n        if m*k>len(bloomDay):\n            return -1\n        l=1\n        r=max(bloomDay)\n        while l<=r:\n            mid=(l+r)//2\n            count=0\n            b=0\n            for i in range(len(bloomDay)):\n                if bloomDay[i]<=mid:\n                    count+=1\n                if count%k==0 and count!=0:\n                    b+=1\n                    count=0\n                if bloomDay[i]>mid:\n                    count=0\n            if b>=m:\n                \n                r=mid-1\n            else:\n                l=mid+1\n        return l\n                \n                \n                \n                \n            \n        \n        \n        \n                        \n            \n                \n            \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if not bloomDay or m*k > len(bloomDay):\n            return -1\n        mx = max(bloomDay)\n        mn = min(bloomDay)\n        l = mn\n        r = mx\n        not_possible = False\n        while l < r:\n            day = (l+r) // 2\n            p = self.works(day, bloomDay, m, k)\n            if p:\n                r = day\n            else:\n                l = day+1\n            #if l >= r and not p:\n            #    not_possible = True\n        \n        return l if not not_possible else -1\n    \n    def works(self, day, arr, m, k):\n        ktmp = k\n        for i in range(len(arr)):\n            n = arr[i]\n            if n <= day:\n                ktmp -= 1\n                if ktmp == 0:\n                    ktmp = k\n                    m -= 1\n                if m == 0:\n                    return True\n            else:\n                ktmp = k\n        return False\n                    \n            \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        left = min(bloomDay)\n        right = max(bloomDay)\n        max_day = right\n        \n        \n        def check(days):\n            num = 0\n            count = 0\n            for i in bloomDay:\n                if i <= days:\n                    count+=1\n                    if count == k:\n                        num += 1\n                        count = 0\n                else:\n                    count = 0\n            return num >= m\n        \n        while left < right:\n            mid = (left+right)>>1\n            if check(mid) == True:\n                right = mid\n            else:\n                left = mid+1\n        \n        if left == max_day and check(left) != True:\n            return -1\n        \n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def count(d):\n            total = 0\n            curr = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i]>d:\n                    curr = 0\n                else:\n                    curr += 1\n                if curr==k:\n                    total += 1\n                    curr = 0\n                # else:\n                #     total += (curr + 1) // k\n                #     curr = (curr + 1) % k\n            return total\n        \n        if m*k>len(bloomDay):\n            return -1\n        l = min(bloomDay)\n        r = max(bloomDay)\n        while l<r:\n            d = l+(r-l)//2\n            print(l, r, d, count(d))\n            if count(d)>=m:\n                r = d\n            else:\n                l = d+1\n        return l", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def binarySearch(bloomDay, m, k, smallest, longest):\n            waitDay = (smallest + longest) // 2\n            totalCount = 0\n            currentCount = 0\n            # print(\\\"-=-=-=-=-=-=-=-=-=-=-=-=-=\\\")\n            # print(smallest)\n            # print(longest)\n            for i in range(len(bloomDay)):\n                if bloomDay[i] <= waitDay:\n                    currentCount += 1\n                else:\n                    currentCount = 0\n                \n                if currentCount == k:\n                    totalCount += 1\n                    currentCount = 0\n            if totalCount >= m:\n                if smallest == waitDay:\n                    return waitDay\n                else:\n                    checkSmaller = binarySearch(bloomDay, m, k, smallest, waitDay - 1)\n                    if checkSmaller != -1:\n                        return checkSmaller\n                    else:\n                        return waitDay\n            else:\n                if waitDay == longest:\n                    return -1\n                else:\n                    return binarySearch(bloomDay, m, k, waitDay + 1, longest)\n        \n        if m * k > len(bloomDay):\n            return -1\n        else:\n            return binarySearch(bloomDay, m, k, 0, max(bloomDay))", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        # arr[i] = time after which we can use index i, k = no. of adjacent flowers , m = no. of boquet\n        # ans = min. no of days to make m boquet else -1\n        \n        # arr = [1,10,3,4,10,2] m = 3 k = 2\n        # ans = 10\n        \n        # after d will there be m subarrays with k elements each?\n        \n        def feasible(d) -> bool:\n            # m separate subbarr of size k where max val in each subarr <= d\n            count = 0\n            prevBadIndex = -1\n            for i in range(len(bloomDay)):\n                if bloomDay[i] > d:\n                    count += (i - prevBadIndex - 1) // k\n                    prevBadIndex = i\n            \n            if prevBadIndex != len(bloomDay) - 1:\n                count += (len(bloomDay) - prevBadIndex - 1) // k\n            \n            return count >= m\n        \n        if len(bloomDay) < (m * k):\n            return -1\n        \n        \n        left,right = min(bloomDay), max(bloomDay)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        min_day = min(bloomDay)\n        max_day = max(bloomDay)\n        lbd = len(bloomDay)\n        \n        if lbd < m*k:\n            return -1\n        \n        while min_day < max_day:\n            mid = (min_day + max_day - 1)//2\n            \n            nk, nm = 0, 0\n            for i in range(lbd):\n                \n                if bloomDay[i] <= mid:\n                    nk += 1\n                else:\n                    nk = 0\n                if nk >= k:\n                    nm += 1\n                    nk = 0\n            if nm < m:\n                min_day = mid + 1\n            else:\n                max_day = mid\n            \n        return min_day\n                    \n            \n            \n            \n        \n        \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        low = 0\n        high = max(bloomDay)\n        \n        if m*k > len(bloomDay):\n            return -1\n        \n        def can_make_bouquets(mid):\n            days = 0\n            curr = [0]*len(bloomDay)\n            for i in range(len(bloomDay)):\n                if bloomDay[i] <= mid:\n                    if i == 0:\n                        curr[i] = 1\n                    elif curr[i-1] == k:\n                        curr[i] = 1\n                    else:\n                        curr[i] = curr[i - 1] + 1\n            \n            if curr.count(k) >= m:\n                return True\n            \n            return False\n            \n        while low < high:\n            mid = math.floor((low+high)/2)\n            if can_make_bouquets(mid):\n                high = mid\n            else:\n                low = mid +1\n        \n        return low ", "\nfrom typing import List\n\ndef binarysearch(start, end, condition):\n    l, r = start, end\n    while l < r:\n        mid = l + (r - l) // 2\n        if condition(mid):\n            r = mid\n        else:\n            l = mid + 1\n    return l\n\n\nclass Solution:\n    def minDays(self, bloomDay, m: int, k: int) -> int:\n        if m*k > len(bloomDay):\n            return -1\n\n        def canMakeBouquet():\n            def condition(day):\n                count = 0\n                curr = 0\n                for b_day in bloomDay:\n                    has_bloomed = day >= b_day\n                    if has_bloomed:\n                        curr += 1\n                        if curr == k:\n                            curr = 0\n                            count += 1\n                    else:\n                        curr = 0\n\n                    if count >= m:\n                        return True\n\n                return False\n\n            return condition\n\n        return binarysearch(0, max(bloomDay), canMakeBouquet())\n\n\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k>len(bloomDay):\n            return -1\n        def fesible(mid):\n            c,n,l = 0,0,[]\n            b=[(i-mid) for i in bloomDay] \n            # print(b)\n            for i in range(len(b)):\n                # print(l)\n                if b[i]<=0 and i!=(len(b)-1):\n                    c+=1\n                elif b[i]<=0 and i==(len(b)-1):\n                    ##\n                    c+=1\n                    l.append(c)\n                elif b[i]>0:\n                    l.append(c)\n                    c=0\n            \n            # print(l)\n            l2=[j for j in l if j>=k]\n            ss=0\n            for i in l2:\n                ss+=i//k\n            if ss>=m or m*k<=max(l):\n                return True\n            return False\n        \n        v=0\n        left, right = min(bloomDay), max(bloomDay)+1\n        while left<right:\n            mid = left + (right-left)//2\n            # print(mid)\n            if fesible(mid):\n                right=mid\n                v=1\n            else:\n                left = mid +1\n        if v==0:\n            return -1\n        return left\n    \n    \n    \n        \n", "\nfrom typing import List\n\ndef binarysearch(start, end, condition, postprocessing):\n    l, r = start, end\n    while l < r:\n        mid = l + (r - l) // 2\n        if condition(mid):\n            r = mid\n        else:\n            l = mid + 1\n    return postprocessing(l)\n\n\nclass Solution:\n    def minDays(self, bloomDay, m: int, k: int) -> int:\n        def canMakeBouquet():\n            def condition(day):\n                count = 0\n                curr = 0\n                for b_day in bloomDay:\n                    has_bloomed = day >= b_day\n                    if has_bloomed:\n                        curr += 1\n                        if curr == k:\n                            curr = 0\n                            count += 1\n                    else:\n                        curr = 0\n\n                    if count >= m:\n                        return True\n\n                return False\n\n            return condition\n\n        def maybeCantMake(final_day):\n            return -1 if not canMakeBouquet()(final_day) else final_day\n\n        return binarysearch(0, max(bloomDay), canMakeBouquet(), maybeCantMake)\n\n\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k>len(bloomDay):\n            return -1\n        def fesible(mid):\n            c,l = 0,[]\n            b=[(i-mid) for i in bloomDay] \n            # print(b)\n            for i in range(len(b)):\n                # print(l)\n                if b[i]<=0 and i!=(len(b)-1):\n                    c+=1\n                elif b[i]<=0 and i==(len(b)-1):\n                    ##\n                    c+=1\n                    l.append(c)\n                elif b[i]>0:\n                    l.append(c)\n                    c=0\n        \n            ss=0\n            for i in l:\n                ss+=i//k\n            if ss>=m:\n                return True\n            return False\n        \n        v=0\n        left, right = min(bloomDay), max(bloomDay)+1\n        while left<right:\n            mid = left + (right-left)//2\n            if fesible(mid):\n                right=mid\n                v=1\n            else:\n                left = mid +1\n        if v==0:\n            return -1\n        return left\n    \n    \n    \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def canMake(bloomDay, m, k, day):\n            bloom = []\n            for bday in bloomDay:\n                if bday <= day:\n                    bloom.append(1)\n                else:\n                    bloom.append(-1)\n            r, cur, cnt = 0, 0, 0\n            while r < len(bloomDay):\n                if bloom[r] == 1:\n                    cur += 1\n                    if cur == k:\n                        cnt += 1\n                        cur = 0\n                        if cnt == m:\n                            return True\n                else:\n                    cur = 0\n                r += 1\n            return False\n        if m*k > len(bloomDay):\n            return -1\n        left, right = min(bloomDay), max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            if not canMake(bloomDay, m, k, mid):\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k>len(bloomDay):\n            return -1\n        def fesible(mid):\n            c,n,l = 0,0,[]\n            b=[(i-mid) for i in bloomDay] \n            # print(b)\n            for i in range(len(b)):\n                # print(l)\n                if b[i]<=0 and i!=(len(b)-1):\n                    c+=1\n                elif b[i]<=0 and i==(len(b)-1):\n                    ##\n                    c+=1\n                    l.append(c)\n                elif b[i]>0:\n                    l.append(c)\n                    c=0\n        \n            ss=0\n            for i in l:\n                ss+=i//k\n            if ss>=m:\n                return True\n            return False\n        \n        v=0\n        left, right = min(bloomDay), max(bloomDay)+1\n        while left<right:\n            mid = left + (right-left)//2\n            # print(mid)\n            if fesible(mid):\n                right=mid\n                v=1\n            else:\n                left = mid +1\n        if v==0:\n            return -1\n        return left\n    \n    \n    \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        def bouqets(d):\n            res = 0\n            c = 0\n            for n in bloomDay:\n                if n <= d:\n                    c += 1\n                else:\n                    c = 0\n                \n                if c == k:\n                    res += 1\n                    c = 0\n            return res\n            \n        days = sorted(set(bloomDay))\n        lo, hi = 0, len(days)-1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if bouqets(days[mid]) < m:\n                lo = mid + 1\n            else:\n                hi = mid\n        return days[hi] if days[hi] >= m else -1\n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        l, r = 1, max(bloomDay)\n        while l + 1 < r:\n            mid = (l + r) // 2\n            if self.is_ok(bloomDay, mid, m, k):\n                r = mid\n            else:\n                l = mid\n        if self.is_ok(bloomDay, l, m, k):\n            return l\n        if self.is_ok(bloomDay, r, m, k):\n            return r\n        return -1\n    \n    def is_ok(self, bloomDay, target, m, k):\n        flowers = 0\n        for remain in bloomDay:\n            if remain <= target:\n                flowers += 1\n                if flowers == k:\n                    m -= 1\n                    flowers = 0\n            else:\n                flowers = 0\n        \n        return m <= 0\n", "class Solution:\n    def minDays(self, A: List[int], m: int, k: int) -> int:\n        \n        #divide array into m parts or more, each part has at least k elements, minimize the maximum values of parts\n        if len(A) < m*k:\n            return -1\n        \n        def canSplit(T):\n            count = 0\n            cur = 0\n            i = 0\n            for x in A:\n                cur = max(cur, x)\n                i += 1\n                if cur > T:\n                    cur = 0\n                    i = 0\n                elif i==k:\n                    cur = 0\n                    i = 0\n                    count += 1\n            return count >= m\n        \n        l = min(A)\n        r = max(A)\n        \n        while l < r:\n            mid = l + (r-l)//2\n            if canSplit(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n            \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def is_possible(days) -> bool:\n            bouquets = 0\n            flowers = 0\n            for bloom in bloomDay:\n                if bloom <= days:\n                    flowers += 1\n                    if flowers >= k:\n                        bouquets += 1\n                        flowers = 0\n                        if bouquets >= m:\n                            return True\n                else:\n                    flowers = 0\n            return False\n\n        if len(bloomDay) < m * k:\n            return -1\n        left = min(bloomDay)\n        right = max(bloomDay)\n        while left < right:\n            days = left + (right - left) // 2\n            if is_possible( days ):\n                right = days\n            else:\n                left = days + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m * k:\n            return -1\n        \n        def canmake(days):\n            b = 0\n            f = 0\n            \n            for d in bloomDay:\n                if d <= days:\n                    b += (f + 1) // k\n                    f = (f + 1) % k\n                else:\n                    f = 0\n            \n            return b >= m\n\n        left = min(bloomDay)\n        right = max(bloomDay)\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if canmake(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], num_bouq: int, num_flowers: int) -> int:\n        def canMake(day):\n            i = 0\n            num_adj = 0\n            count = 0\n            while i < len(bloomDay):\n                if bloomDay[i] <= day:\n                    num_adj += 1\n                if num_adj == num_flowers:\n                    count += 1\n                    num_adj = 0\n                if bloomDay[i] > day:\n                    num_adj = 0\n                    \n                i += 1\n                \n            \n            return count >= num_bouq\n                    \n        \n        left = 1\n        right = max(bloomDay)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if canMake(mid):\n                right = mid\n            else:\n                left = mid + 1\n                \n        if canMake(left):\n            return left\n        else:\n            return -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k>len(bloomDay):\n            return -1\n        def fesible(mid):\n            c,n,l = 0,0,[]\n            b=[(i-mid) for i in bloomDay] \n            # print(b)\n            for i in range(len(b)):\n                # print(l)\n                if b[i]<=0 and i!=(len(b)-1):\n                    c+=1\n                elif b[i]<=0 and i==(len(b)-1):\n                    ##\n                    c+=1\n                    l.append(c)\n                elif b[i]>0:\n                    l.append(c)\n                    c=0\n            \n\n            ss=0\n            for i in l:\n                ss+=i//k\n            if ss>=m or m*k<=max(l):\n                return True\n            return False\n        \n        v=0\n        left, right = min(bloomDay), max(bloomDay)+1\n        while left<right:\n            mid = left + (right-left)//2\n            # print(mid)\n            if fesible(mid):\n                right=mid\n                v=1\n            else:\n                left = mid +1\n        if v==0:\n            return -1\n        return left\n    \n    \n    \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        lo, hi = min(bloomDay), max(bloomDay)\n        def check(d): # check if D days is good enough for m bouquets of k flowers\n            cnt, start = 0, -1\n            for i, val in enumerate(bloomDay):\n                if val <= d and i - start >= k:\n                    cnt += 1\n                    start = i\n                elif val > d:\n                    start = i\n            return cnt >= m\n        \n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if check(mid):\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return lo", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        \n        def isFeasible(days):\n            \n            bouquetsSoFar = 0\n            flowersSoFar = 0\n            \n            for d in bloomDay:\n                \n                if d <= days:\n                    flowersSoFar += 1\n                    if flowersSoFar == k:\n                        bouquetsSoFar += 1\n                        flowersSoFar = 0\n                        if bouquetsSoFar == m:\n                            return True\n                else:\n                    flowersSoFar = 0\n                \n            return False\n        \n        if len(bloomDay) < m * k:\n            return -1\n        \n        left, right = min(bloomDay), max(bloomDay)\n        \n        while left < right:\n            \n            mid = left + (right - left) // 2\n            \n            if isFeasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m * k: return -1\n        l, r = 1, max(bloomDay)\n        while l < r:\n            p, curr, cnt = l + (r - l) // 2, 0, 0\n            for x in bloomDay:\n                curr = curr + 1 if x <= p else 0\n                if curr >= k:\n                    cnt, curr = cnt+1, curr - k\n            if cnt < m: l = p+1\n            else: r = p\n        return l", "'''\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        A = bloomDay\n        if m * k > len(A): return -1\n        left, right = 1, max(A)\n        while left < right:\n            mid = (left + right) // 2\n            flow = bouq = 0\n            for a in A:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n'''\nclass Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m*k :return -1\n        l, r = 1, max(bloomDay)\n        while l < r:\n            mid = l + (r - l) // 2\n            temp = 0\n            cnt = 0\n            for n in bloomDay:\n                temp = 0 if n > mid else temp + 1\n                if temp >=k:\n                    temp = 0\n                    cnt+=1\n                    if cnt==m:break\n            if cnt == m : r= mid\n            else: l = mid+1\n        return l\n\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            cnt, n = 0, 0\n            for b in bloomDay:\n                if b <= mid:\n                    cnt += 1\n                    if cnt == k:\n                        n += 1\n                        if n == m:\n                            break\n                        cnt = 0\n                else:\n                    cnt = 0\n            if n == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        a=bloomDay\n        if len(a)<m*k:return -1\n        def ck(n,m,k):\n            c=0\n            b=0\n            for x in a:\n                if x<=n:\n                    c+=1\n                    if c==k:\n                        b+=1\n                        if b==m:return bool(1)\n                        c=0\n                else:c=0\n            return bool(0)\n        def bs(m,k):\n            l,r=min(a),max(a)\n            while l<r:\n                mid=(l+r)//2\n                if ck(mid,m,k):r=mid\n                else:l=mid+1\n            return l\n        return bs(m,k)", "class Solution:\n    def minDays(self, A: List[int], m: int, k: int) -> int:\n        if m * k > len(A): return -1\n        left, right = 1, max(A)\n        while left < right:\n            mid = (left + right) // 2\n            flow = bouq = 0\n            for a in A:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq ==m:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def isPossible(cap):\n            bouquets = 0\n            flowers = 0\n            \n           \n            for flower in bloomDay:\n                if flower <= cap:\n                    flowers += 1\n                else:\n                    flowers = 0\n                if flowers == k:\n                    bouquets += 1\n                    flowers = 0\n            if bouquets < m:\n                return False\n            else:\n                return True\n            \n        \n        left = 1\n        right = max(bloomDay)\n        if m*k > len(bloomDay):\n            return -1\n        while left < right:\n            \n            mid = left + (right-left)//2\n            \n            if isPossible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay)< m*k: return -1\n        \n        l, r= 1, max(bloomDay)\n        while l< r:\n            mid= (l+r)//2\n\n            flow = bouq = 0\n            for a in bloomDay:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    bouq += 1\n                    flow = 0\n                    if bouq == m:\n                        break\n            if bouq == m:\n                r = mid\n            else:\n                l = mid + 1  \n        return l\n            \n", "class Solution:\n    def minDays(self, arr: List[int], m: int, k: int) -> int:\n        def count(arr, x, k):\n            out = 0\n            count = 0\n            for i in arr:\n                if i <= x:\n                    count += 1\n                    if count == k:\n                        out += 1\n                        count = 0\n                else:\n                    count = 0\n\n            return out\n        \n        if len(arr) < m*k:\n            return -1\n        res = -1\n        bi = list(sorted(set(arr)))\n        start = 0\n        end = len(bi)-1\n        while start <= end:\n            mid = (start+end)//2\n            if count(arr, bi[mid], k) >= m:\n                res = bi[mid]\n                end = mid - 1\n            else:\n                start = mid + 1\n\n        return res", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        max_, min_ = max(bloomDay),min(bloomDay)\n        \n        def check(day):\n            m_done = 0\n            cont_count = 0\n            for x in bloomDay:\n                if x <= day:\n                    cont_count +=1\n                    if cont_count == k:\n                        m_done +=1\n                        cont_count = 0\n                else:\n                    cont_count = 0\n            #print(day, m_done)\n            if m_done < m:\n                return False\n            return True\n        \n        left = min_ - 1\n        right = max_\n        \n        while left < right:\n            mid = left + (right-left)//2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        l, r = min(bloomDay), max(bloomDay)\n        while l < r:\n            mid = (l + r) // 2\n            if not self.check(bloomDay, m, k, mid):\n                l = mid + 1\n            else:\n                r = mid\n        if self.check(bloomDay, m, k, l):\n            return l\n        return -1\n    \n    def check(self, bloomDay, m, k, day):\n        cnt, consecutive = 0, 0\n        for bd in bloomDay:\n            if bd <= day:\n                consecutive += 1\n                if consecutive >= k:\n                    cnt += 1\n                    if cnt >= m:\n                        return True\n                    consecutive = 0\n            else:\n                consecutive = 0\n        return False", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay): return -1\n        low, high = min(bloomDay), max(bloomDay)\n        while low < high:\n            mid = (low + high) // 2\n            flow = bouq = 0\n            for bloom in bloomDay:\n                if bloom > mid:\n                    flow = 0\n                else:\n                    flow += 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: \n                        break\n            if bouq == m:\n                high = mid\n            else:\n                low = mid + 1\n        return low\n            \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay): return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            flow = bouq = 0\n            for a in bloomDay:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay): return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            flow = bouq = 0\n            for fl in bloomDay:\n                if fl > mid:\n                    flow = 0\n                else:\n                    flow += 1\n                if flow >= k:\n                    # enough adjacent flowers to make bouque\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq >= m:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        left = min(bloomDay)\n        right = max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            flowers = 0\n            bouquets = 0\n            for day in bloomDay:\n                flowers = flowers + 1 if day <= mid else 0\n                if flowers == k:\n                    bouquets += 1\n                    flowers = 0\n            if bouquets < m:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "class Solution:\n    def minDays(self, bloomDay, m, k):\n\n        #print (f\\\"bloomDay={bloomDay} m={m} k={k}\\\")\n\n        def max_bouquets(bdays, k, days):\n            count = 0\n            cursum = 0\n            for d in bdays:\n                if (d > days ):\n                    cursum = 0 # can't pick up that flower\n                else:\n                    cursum += 1\n                    if cursum == k:\n                        count += 1\n                        cursum = 0\n            #print(f\\\"bdays={bdays} -> can make {count} bouquets if waiting {days} days\\\")\n            return count\n\n        if m*k > len(bloomDay):\n            return -1\n\n        bDays = sorted(list(set(sorted(bloomDay)[m*k-1:])))\n        left = 0\n        right = len(bDays)\n        minDays = -1\n        while left<right:\n            mid = left + int((right-left)/2)\n            #print(f\\\"left={left} mid={mid} right={right}\\\")\n            val = bDays[mid]\n            if max_bouquets(bloomDay,k, val) >= m:\n                minDays = val\n                right = mid\n            else:\n                left = mid+1\n        return minDays\n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        if len(bloomDay) < m * k:\n            return -1\n        \n        b = min(bloomDay)\n        e = max(bloomDay)\n        \n        def check_day(day):\n            flowers = 0\n            bouquets = 0\n            for d in bloomDay:\n                if d > day:\n                    flowers = 0\n                else:\n                    flowers += 1\n                    if flowers >= k:\n                        bouquets += 1\n                        flowers = 0\n                        if bouquets >= m:\n                            return True\n            return False\n        \n        while e>=b:\n            mid = (b+e)//2\n            \n            if check_day(mid):\n                e = mid - 1\n            else:\n                b = mid + 1\n                \n        return b", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k>len(bloomDay):\n            return -1\n        def can_make(day):\n            bouquet,count = 0,0\n            for i in bloomDay:\n                if day>=i:\n                    count += 1\n                else:\n                    count = 0\n                if count==k:\n                    bouquet += 1\n                    count = 0\n                    if bouquet==m:\n                        return True\n            return False\n        \n        left,right = min(bloomDay),max(bloomDay)\n        while left<right:\n            mid = left + (right-left)//2\n            if can_make(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay, m, k):\n        start, end = 1, max(bloomDay)\n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if self.check(mid, bloomDay, m, k):\n                end = mid\n            else:\n                start = mid\n        if self.check(start, bloomDay, m, k):\n            return start\n        if self.check(end, bloomDay, m, k):\n            return end\n        return -1\n    \n    def check(self, days, bloomDay, m, k):\n        cnt = 0\n        res = 0\n        for d in bloomDay:\n            if d <= days:\n                cnt += 1\n            else:\n                cnt = 0\n            if cnt == k:\n                res += 1\n                cnt = 0\n        return res >= m", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if not bloomDay :return -1\n        if k * m > len(bloomDay): return -1\n\n        def check(cur):\n            res = 0\n            curk = 0\n            for item in bloomDay:\n                if item <= cur:\n                    curk += 1\n                    if curk == k:\n                        res+=1\n                        curk = 0\n                else:\n                    curk = 0\n            if res < m: return False\n            return True\n\n        b = min(bloomDay)\n        e = max(bloomDay) \n        rt = 0\n        #n2\n        while b <= e:\n            \n            mid = b + (e-b)//2\n            if check(mid):\n                e = mid-1\n            else:\n                b = mid +1\n        return b\n            \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        #arr = [abs difference prev and cur]\n#         # for idx, val in enumerate(bloomDay):\n#         h = defaultdict(list)\n#         for idx, val in enumerate(bloomDay):\n            \n#             dif = abs(bloomday[idx+1] - val)\n#             h[dif].append((idx, idx+1))\n            \n        \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        return rt\n", "class Solution:\n    def minDays(self, A: List[int], m: int, k: int) -> int:\n        if m * k > len(A):\n            return -1\n        \n        def isit(d):\n            c = b = 0\n            for a in A:\n                c = 0 if a>d else c+1\n                if c==k:\n                    c=0\n                    b+=1\n                    if b==m:\n                        return 1\n            return 0\n\n        l = 1\n        r = max(A)\n        while l < r:\n            mid = (l+r)//2\n            if isit(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        A = bloomDay\n        if m * k > len(A): return -1\n        left, right = 1, max(A)\n        while left < right:\n            mid = (left + right) // 2\n            flow = bouq = 0\n            for a in A:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n            \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n\n        bloom_day_flowers = {}\n        for i, day in enumerate(bloomDay):\n            bloom_day_flowers.setdefault(day, []).append(i)\n            \n        days = sorted(bloom_day_flowers.keys())\n        \n        segments = {}\n        total_b = 0\n\n        for day in days:\n            for flower in bloom_day_flowers[day]:\n                assert flower not in segments\n                \n                lower_ext, upper_ext = False, False\n                lower_rm, upper_rm = 0, 0\n                new_seg = None\n                \n                # check lower interval\n                if flower - 1 in segments:\n                    seg = segments[flower - 1]\n                    seg[1] = flower\n                    segments[flower] = seg\n                    lower_rm = seg[1] - seg[0]\n                    if lower_rm > 1:\n                        del segments[flower - 1]\n                    new_seg = seg\n                    lower_ext = True\n                \n                # check upper interval\n                if flower + 1 in segments:\n                    if flower in segments:\n                        # merge segments\n                        lower_seg = segments[flower]\n                        upper_seg = segments[flower + 1]\n                        upper_rm = upper_seg[1] - upper_seg[0] + 1\n                        \n                        new_end = upper_seg[1]\n                        lower_seg[1] = new_end\n                        del segments[flower + 1]\n                        del segments[flower]\n                        segments[new_end] = lower_seg\n                        new_set = lower_seg\n                    else:\n                        seg = segments[flower + 1]\n                        seg[0] = flower\n                        segments[flower] = seg\n                        upper_rm = seg[1] - seg[0]\n                        if upper_rm > 1:\n                            del segments[flower + 1]\n                        new_seg = seg\n                    upper_ext = True\n                \n                if not (lower_ext or upper_ext):\n                    seg = [flower, flower]\n                    segments[flower] = seg\n                    new_seg = seg\n                \n                total_b -= lower_rm // k + upper_rm // k\n                total_b += (new_seg[1] - new_seg[0] + 1) // k\n                    \n                \n                # print(day, total_b, segments)\n                if total_b >= m:\n                    return day\n                \n        return -1\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m*k > len(bloomDay): return -1\n        \n        M = max(bloomDay)\n        lo, hi= 0,M\n        \n        def works(h):\n            curr = 0\n            bou = 0\n            for b in bloomDay:\n                if b<=h:\n                    curr+=1\n                    if curr==k:\n                        bou+=1\n                        curr=0\n                    if bou==m:\n                        return True\n                else:\n                    curr=0\n        \n        while hi-lo>1:\n            h = (hi+lo)//2\n            if works(h):\n                hi=h\n            else:\n                lo=h\n        \n        return hi     ", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def can(days):\n            res = 0\n            count = 0\n            for a in bloomDay:\n                if a <= days:\n                    count += 1\n                else:\n                    count = 0\n                if count == k:\n                    count = 0\n                    res += 1\n            return res >= m\n            \n        l, r = 1, max(bloomDay)\n        while l < r:\n            mid = (l + r)//2\n            if can(mid):\n                r = mid\n            else:\n                l = mid + 1\n        if can(l):\n            return l\n        return -1\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):   #\u8981\u5f62\u6210\u81f3\u5c11\u9700\u8981\u7684\u82b1\u6735\u6570\n            return -1\n        l, r = 1, max(bloomDay)\n        while l < r:\n            mid = (l+r)//2\n            flow = bouq = 0\n            for a in bloomDay:\n                if a > mid:\n                    flow=0\n                else:\n                    flow+=1\n                if flow== k:\n                    flow = 0\n                    bouq += 1\n            if bouq>=m:\n                r = mid\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def canMake(bloomDay, m, k, day):         \n            cur, cnt = 0, 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i] <= day:\n                    cur += 1\n                    if cur == k:\n                        cnt += 1\n                        cur = 0\n                        if cnt == m:\n                            return True\n                else:\n                    cur = 0\n            return False\n        if m*k > len(bloomDay):\n            return -1\n        left, right = min(bloomDay), max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            if not canMake(bloomDay, m, k, mid):\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m * k: return -1\n        l, r = 1, max(bloomDay)\n        while l < r:\n            p, curr, cnt = l + (r - l) // 2, 0, 0\n            for x in bloomDay:\n                curr = curr + 1 if x <= p else 0\n                if curr == k:\n                    cnt, curr = cnt+1, 0\n                if cnt == m: break\n            if cnt < m: l = p+1\n            else: r = p\n        return l", "class Solution:\n    def minDays(self, bloom_day: List[int], m: int, k: int) -> int:\n        \n        def bouquets_made(day):\n            total = adjacent = 0\n            for d in bloom_day:\n                if d <= day:\n                    adjacent += 1\n                else:\n                    adjacent = 0\n            \n                if adjacent == k:\n                    total += 1\n                    adjacent = 0\n                \n            return total\n        \n        \n        min_days = -1\n        lo, hi = 1, max(bloom_day)\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if bouquets_made(mid) >= m:\n                min_days = mid\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        \n        return min_days\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m*k:\n            return -1\n        \n        l, r = min(bloomDay), max(bloomDay)\n        while l < r:\n            mid = (l+r)//2\n            temp = self.bouquets(mid, bloomDay, k, m)\n            if temp:\n                r = mid\n            else:\n                l = mid+1\n        return l\n            \n            \n    \n    def bouquets(self, day, bloomDay, k, m):\n        c = 0\n        contDays = 0\n        for i in range(len(bloomDay)):\n            if bloomDay[i] > day:\n                contDays = 0\n                continue\n\n            contDays += 1\n            if contDays == k:\n                c += 1\n                contDays = 0\n        return c >= m\n", "class Solution:\n    def minDays(self, b: List[int], m: int, k: int) -> int:\n        if m*k > len(b):\n            return -1\n        l,r = min(b), max(b)\n        def possible(days):\n            bonquets, flowers = 0, 0\n            for bloom in b:\n                if bloom > days:\n                    flowers = 0\n                else:\n                    flowers += 1\n                if flowers == k:\n                    flowers = 0\n                    bonquets += 1\n            return bonquets >= m\n            \n        while l<r:\n            mi = (l+r)//2\n            \n            if possible(mi):\n                r = mi\n            else:\n                l = mi+1\n        return l", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if not bloomDay :return -1\n        if k * m > len(bloomDay): return -1\n\n        def check(cur):\n            res = 0\n            curk = 0\n            for item in bloomDay:\n                if item <= cur:\n                    curk += 1\n                    if curk == k:\n                        res+=1\n                        curk = 0\n                else:\n                    curk = 0\n            if res < m: return False\n            return True\n\n        b = min(bloomDay)\n        e = max(bloomDay) \n        rt = 0\n        #n2\n        while b < e:\n            \n            mid = b + (e-b)//2\n            if check(mid):\n                e = mid\n            else:\n                b = mid +1\n        return b\n            \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        #arr = [abs difference prev and cur]\n#         # for idx, val in enumerate(bloomDay):\n#         h = defaultdict(list)\n#         for idx, val in enumerate(bloomDay):\n            \n#             dif = abs(bloomday[idx+1] - val)\n#             h[dif].append((idx, idx+1))\n            \n        \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        return rt\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        curr = 0\n        left = len(bloomDay)*[0]\n        right = len(bloomDay)*[0]\n        days = defaultdict(list)\n        for i in range(len(bloomDay)):\n            days[bloomDay[i]].append(i)\n        sorted_days = sorted(days)\n        for i in sorted_days:\n            for x in days[i]:\n                right[x] = 1\n                left[x] = 1\n                if x < len(bloomDay)-1:\n                    right[x] += right[x+1]\n                if x > 0:\n                    left[x] += left[x-1]\n                if ((left[x]-1)%k + (right[x]-1)%k + 1) >= k:\n                    curr += 1\n                    if curr == m:\n                        return i\n                right[x-left[x]+1] = left[x] + right[x] - 1\n                left[x+right[x]-1] = left[x] + right[x] - 1\n        return -1", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def feasible(largest):\n            cur_len, made = 0, 0\n            for bloom in bloomDay:\n                if bloom > largest:\n                    cur_len = 0\n                    continue\n                cur_len += 1\n                if cur_len == k:\n                    made += 1\n                    cur_len = 0\n                if made == m:\n                    return True\n            return False\n        \n        if len(bloomDay) < k*m:\n            return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = (left+right) // 2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid+1\n        \n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if len(bloomDay) < m*k:\n            return -1\n        left, right = min(bloomDay), max(bloomDay)\n        while left <= right:\n            mid = left + (right-left)//2\n            if self.feasible(mid, m, k, bloomDay): # need min number of days\n                right = mid -1\n            else:\n                left = mid + 1\n        return right + 1\n\n    def feasible(self, mid, m, k, bloomDay):\n        # all available flowers after mid days of waiting\n        # check if it's possible to make m bouquets with the available flowers \n        # need m, k adjacent flowers\n        adj_flower = 0\n        bouquet_num = 0\n        for d in bloomDay:\n            if d <= mid:\n                adj_flower +=1\n                if adj_flower ==k:\n                    bouquet_num +=1\n                    adj_flower = 0\n            else:\n                adj_flower = 0\n        return bouquet_num >= m", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n\n        def feasible(day):  # check whether it is possible to arrange m banquet on this day.\n            banquet = 0\n            streak = 0\n            for d in bloomDay:\n                if d > day:  # available\n                    streak = 0\n                else:\n                    streak += 1\n                    if streak == k:  # enough for a banquet\n                        banquet += 1\n                        streak = 0\n                    if banquet == m:  # enough banquet\n                        return True\n            return False\n\n        low, high = min(bloomDay), max(bloomDay)\n        while low < high:\n            mid = (low + high) // 2\n            if feasible(mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if  m*k > len(bloomDay)+1:\n            return -1\n        pos = False\n        \n        \n        def possible(mid):\n            a , curr = 0,0\n            for bloom in bloomDay:\n                if bloom > mid:\n                    a = 0\n                else:\n                    a +=1\n                    if a == k:\n                        a = 0\n                        curr += 1\n            if curr >= m:\n                return True\n            else:\n                return False\n\n       \n        left, right=min(bloomDay),max(bloomDay)\n        while(left<right):\n            mid = left +(right-left)//2\n            if possible(mid):\n                pos = True\n                right = mid\n            else:\n                left = mid + 1\n        \n        if possible(left):\n            return left\n    \n        else:\n            return -1", "from itertools import groupby\n\nclass Solution:\n    def minDays(self, b: List[int], m: int, k: int) -> int:\n        \n        def is_possible(arr, min_day):\n            after_days = [1 if min_day >= d else 0 for d in b]\n\n            cont_days = sum([len(list(g)) // k for num, g in groupby(after_days) if num == 1])\n            return cont_days >= m\n\n\n\n        if m * k > len(b):\n            print(-1)\n            return -1\n\n        else:\n            left, right = min(b), max(b)\n\n            while left < right:\n                mid = left + (right - left) // 2\n\n                if is_possible(b, mid):\n                    right = mid\n                else:\n                    left = mid + 1\n\n            print(left)\n            return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        if k*m > len(bloomDay):\n            return -1\n        \n        unique_bloom_days = sorted(set(bloomDay))\n\n        \n        \n        \n        lo = 0\n        hi = len(unique_bloom_days)-1\n        \n        if hi == 0:\n            return unique_bloom_days[0]\n        \n        while True:\n            curr_idx = int((lo+hi)/2)\n            if curr_idx == lo:\n                idx = curr_idx\n            curr_day = unique_bloom_days[curr_idx]\n            # check if the condition is satisfiable\n            bouquet = 0\n            curr = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i] <= curr_day:\n                    curr += 1\n                    if curr >= k:\n                        bouquet += 1\n                        curr = 0\n                else:\n                    curr = 0\n            \n            if bouquet < m:  # not enough\n                if curr_idx == lo:\n                    idx = lo+1\n                    break\n                else:\n                    lo = curr_idx\n            else:  # enough\n                hi = curr_idx\n                if hi == lo:\n                    idx = hi\n                    break\n        return unique_bloom_days[idx]", "class Solution:\n    def minDays(self, A: List[int], m: int, k: int) -> int:\n        if m * k > len(A): return -1\n        \n        left, right = 1, max(A)\n        \n        while left < right:\n            mid = (left + right) >> 1\n            flow = bouq = 0\n            \n            for a in A:\n                flow = 0 if a > mid else flow + 1\n                if flow >= k:\n                    flow = 0\n                    bouq += 1\n                    if bouq == m: break\n            if bouq == m:\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if bloomDay == [] or m * k == 0 or len(bloomDay) < m * k:\n            return -1\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if self.getPossibleBouquetNum(bloomDay, k, mid) >= m:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n    def getPossibleBouquetNum(self, bloomDay: List[int], k: int, day_threshold: int) -> int:\n        bloom_count = 0\n        bouquet_count = 0\n        for day in bloomDay:\n            if day <= day_threshold:\n                bloom_count += 1\n            else:\n                bouquet_count += bloom_count // k\n                bloom_count = 0\n        bouquet_count += bloom_count // k\n        return bouquet_count", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        def bouqets(d):\n            res, c = 0, 0\n            for n in bloomDay:\n                c = 0 if n > d else c + 1\n                if c == k:\n                    res, c = res + 1, 0\n            return res\n            \n        days = sorted(set(bloomDay))\n        lo, hi = 0, len(days)-1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if bouqets(days[mid]) < m:\n                lo = mid + 1\n            else:\n                hi = mid\n        return days[hi] if days[hi] >= m else -1\n", "class Solution:\n    def make_bouquets(self, A, day, k):\n        cnt, consec = 0, 0\n        for i in A:\n            if day >= i:\n                consec += 1\n            else:\n                consec = 0\n            if consec == k:\n                cnt += 1\n                consec = 0\n        return cnt\n    \n    def minDays(self, A, m, k):\n        l, r = min(A), max(A)\n        print(f'{l=} | {r=}')\n        while r > l:\n            mid = (l+r) // 2\n            if self.make_bouquets(A, mid, k) >= m:\n                r = mid\n            else:\n                l = mid + 1\n        print(f'{l=} | {r=}')\n        if self.make_bouquets(A, l, k) >= m:\n            return l\n        else: return -1\n\n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if (len(bloomDay) < m * k):\n            return -1\n        \n        sorted_bloomDay = sorted(set(bloomDay))\n        left = 1\n        right = len(sorted_bloomDay)\n        ret = -1\n\n        \n        while (left <= right):\n            middle = (left + right) // 2 - 1\n            bouquets_left = m\n            flowers_left = k \n            search_right = True\n            \n            \n            for i in range(len(bloomDay)):\n                if (bloomDay[i] <= sorted_bloomDay[middle]):\n                    flowers_left -= 1\n                    \n                    \n                    if (flowers_left == 0):\n                        bouquets_left -= 1\n                        \n                        \n                        if (bouquets_left == 0):\n                            ret = sorted_bloomDay[middle]\n                            search_right = False\n                            break\n                        else:\n                            flowers_left = k\n                else:\n                    flowers_left = k\n                    \n            \n            if (search_right):\n                left = middle + 2\n            else:\n                right = middle\n                \n        return ret", "class Solution:\n    def is_good(self, day):\n        bouqet_count = 0\n        cont_count = 0\n        for d in self.bloomDay:\n            if d <= day:\n                cont_count += 1\n            else:\n                bouqet_count += cont_count // self.k\n                cont_count = 0\n        bouqet_count += cont_count // self.k\n        return bouqet_count >= self.m\n        \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        self.bloomDay = bloomDay\n        self.m = m\n        self.k = k\n        \n        if m * k > len(bloomDay):\n            return -1\n        start = 1\n        end = 10**9\n        \n        \n        while start != end:\n            middle = (start + end) // 2\n            if self.is_good(middle):\n                end = middle\n            else:\n                start = middle + 1\n        \n        return start", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        b=bloomDay\n        if m*k>len(b):\n            return -1\n        else:\n            def posb(c)->bool:\n                p=0\n                l=0\n                for i in range(len(b)):\n                    if b[i]>c:\n                        l=0\n                    else:\n                        l+=1\n                        if l==k:\n                            p+=1\n                            l=0\n                        \n\n                #print(p,c)\n\n                return p>=m\n            l,r=min(b),max(b)\n            while l<r:\n                mid=l+(r-l)//2\n                if posb(mid):\n                    r=mid\n                else:\n                    l=mid+1\n            return l\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        # minDay\n        # we need k consecutive elems in bloomDay list where all those elems <= minDay\n        # we need m such groups\n        \n        # minimum possible val is min val in the list\n        # maxmimum possible val is max val in the list\n        # impossible case: m * k > list size\n        \n        if m * k > len(bloomDay):\n            return -1\n        \n        def condition(minDay):\n            numB = m\n            curF = 0\n            for day in bloomDay:\n                if day <= minDay:\n                    curF += 1\n                    if curF == k:\n                        numB -= 1\n                        curF = 0\n                    if numB == 0:\n                        break\n                else:\n                    curF = 0\n            return numB == 0\n        \n        l = min(bloomDay)\n        r = max(bloomDay)\n        # possible = 0\n        while l < r:\n            mid = l + (r - l) // 2\n            if condition(mid):\n                r = mid\n            else:\n                l = mid + 1\n       \n        return l", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay): return -1\n        else: \n            left, right = 0, max(bloomDay)\n            while left < right:\n                mid = (left + right) // 2\n                flow, bq = 0,0\n                for d in bloomDay:\n                    if d > mid:\n                        flow = 0\n                    else:\n                        flow += 1\n                    if flow == k:\n                        bq += 1\n                        flow = 0\n                    if bq == m:\n                        break\n                if bq == m:\n                    right = mid\n                else:\n                    left = mid + 1\n            return left", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if m * k > n:\n            return -1\n        vals = list(set(bloomDay))\n        vals.sort()\n        \n        def invalid(threshold):\n            cur = 0\n            bouquets = 0\n            for x in bloomDay:\n                if x <= threshold:\n                    cur += 1\n                else:\n                    bouquets += cur // k\n                    cur = 0\n            bouquets += cur // k\n            return bouquets < m\n        \n        left, right = 0, len(vals) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            # print(left, right, mid)\n            if invalid(vals[mid]):\n                left = mid + 1\n            else:\n                right = mid - 1\n        return vals[left]", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        def check(bloomDay, day, m, k):\n            count = 0\n            for flower in bloomDay:\n                if flower <= day:\n                    count += 1\n                    if count == k:\n                        m -= 1\n                        count = 0\n                    if m == 0:\n                        return True\n                else:\n                    count = 0\n            return False\n        \n        start = min(bloomDay)\n        end = max(bloomDay)\n        res = -1 \n    \n        while start <= end:\n            center = start + (end - start) // 2\n            if check(bloomDay, center, m, k):\n                res = center\n                end = center - 1\n            else:\n                start = center + 1\n        \n        return res\n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        \n        def isValid(val):\n            count = 0\n            tmp = 0\n            for i in range(len(bloomDay)):\n                if bloomDay[i] <= val:\n                    tmp += 1\n                    if tmp == k:\n                        count += 1\n                        if count == m:\n                            return True\n                        tmp = 0\n                else:\n                    tmp = 0\n            return False\n        \n        \n        ls = len(bloomDay)\n        if m * k > ls:\n            return -1\n        \n        l, r = min(bloomDay), max(bloomDay)\n        \n        while l < r:\n            mid = (l + r) // 2\n            if isValid(mid):\n                r = mid\n            else:\n                l = mid + 1\n                \n        return l\n        \n        \n", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        # \u82b1\u7684\u603b\u6570>=m*k\u5219\u4e00\u5b9a\u80fd\u5b8c\u6210\n        n = len(bloomDay)\n        if n < m * k:\n            return -1\n        # \u641c\u7d22\u6240\u6709\u53ef\u80fd\u7684\u5929\u6570, \u5982\u679c\u7b2cx\u5929\u65e0\u6cd5\u6ee1\u8db3\u6761\u4ef6, x-1, x-2...\u4e5f\u65e0\u6cd5\u6ee1\u8db3\u6761\u4ef6\n        # \u4e8c\u5206\u67e5\u627e \u6ee1\u8db3\u6761\u4ef6\u6700\u5c0fk\u7684\u6a21\u677f\n        lo = 1\n        hi = max(bloomDay)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if self.can_make(mid, bloomDay, m, k):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo\n    \n    def can_make(self, day, bloomDay, m, k):\n        cnt = 0\n        for d in bloomDay:\n            if d <= day:\n                cnt += 1\n            else:\n                cnt = 0\n            if cnt == k:\n                m -= 1\n                cnt = 0\n            if m == 0:\n                return True\n        return m == 0\n", "class Solution:\n    def checkDay(self,day,bloomDay,m,k)->bool:\n        y,count=0,0\n        for i in range(len(bloomDay)):\n            if bloomDay[i] <= day:\n                #bloomed.append(1)\n                y+=1\n            else:\n                #bloomed.append(0)\n                y=0\n            if y==k:\n                count+=1\n                y=0\n            if count==m:\n                return True\n        return False\n    \n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        '''\n        bloomDay: Flower garden, elements are # of days required for that flower to bloom\n        m: # of bouquets needed\n        k: # of adjacent flowers needed in each bouquet\n        First, check to see if mk>len(bloomDay). If so return -1\n        Then, see how many days needed until mk flowers have bloomed\n            Check to see if they are adjacent\n            if so return days\n            else maybe check how many adjacents are needed, or go to the next day\n        \n        '''\n        #bloomDay,m,k = [7,7,7,7,12,7,7],2,3\n        \n        FN=m*k # (Flowers Needed)\n        if FN > len(bloomDay):\n            return -1\n        \n        \n        # After x days, is it possible to create m bouquets?\n        \n        \n        bloomed=sorted(bloomDay)\n        lastWorking,count,start,stop=-1,0,0,len(bloomed)\n        #print(bloomed)\n        half=stop//2\n        #day=bloomed[half]\n        while(start<=half<stop):\n            day=bloomed[half]\n            #print('Half: ',half,', Day: ',day,' || Bounds: ',start,', ',stop)\n            \n            # If current day works, check previous day\n            if self.checkDay(day,bloomDay,m,k):\n                #print('Day:  ',day,' works')\n                lastWorking,stop=day,half\n            # Otherwise check half of new bounds\n            else:\n                start=half+1\n            half=(start+stop)//2\n            \n        return lastWorking", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        if m * k > len(bloomDay):\n            return -1\n        \n        def feasible(days,m,k):\n            flowers =0\n            bouq =0\n            for item in bloomDay:\n                if item <= days:\n                    flowers +=1\n                else:\n                    flowers =0\n                if flowers >=k:\n                    bouq +=1\n                    flowers =0\n                    if bouq == m:\n                        return True\n            return False\n        \n        left = min(bloomDay) # min number of days\n        right = max(bloomDay)# maximum number of days\n        while left < right:\n            mid = left + (right-left) //2\n            if feasible(mid,m,k):\n                right = mid\n            else:\n                left = mid +1\n        return left\n", "class Solution:\n    def minDays(self, bloomDay: List[int], M: int, K: int) -> int:\n        if len(bloomDay) < M * K : return -1\n        def condition(day) -> bool:\n            m, k = 0, 0\n            for bd in bloomDay:\n                if bd <= day : k += 1\n                else : k = 0\n                if k >= K : \n                    m += 1\n                    k = 0\n                if m >= M : return True\n            return False\n\n        left, right = min(bloomDay), max(bloomDay)\n        while left < right:\n            mid = left + (right - left) // 2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left        ", "class Solution:\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\n        n = len(bloomDay)\n        if n//k < m:\n            return -1\n        \n        left = min(bloomDay)\n        right = max(bloomDay)\n        \n        while left < right:\n            mid = (left + right)//2\n            numBouqets = 0\n            count = 0\n            for i in range(n):\n                if bloomDay[i]<=mid:\n                    count += 1\n                else:\n                    count = 0\n                if count == k:\n                    count = 0\n                    numBouqets += 1\n            # print(left, mid, right, numBouqets)\n            if numBouqets >= m:\n                right = mid\n            else:\n                left = mid+1\n        return left"]
["def dithering(width, height, x=0, y=0, c=1):\n    if width <= c and height <= c:\n        if x < width and y < height: yield x, y\n        return\n    for u, v in (0,0), (c,c), (c,0), (0,c):\n        for p, q in dithering(width, height, x+u, y+v, c+c): yield p, q", "def dithering(width, height):\n    size =  1\n    while width > size or height > size:\n        size *= 2\n    if size == 1:\n        yield (0,0)\n    else:\n        for (x, y) in  dithering(size/2, size/2):\n            for t in ((x,y), (x+size/2, y+size/2), (x+size/2, y), (x, y+size/2)):\n                if t[0] < width and t[1] < height:\n                    yield t\n", "from math import *\ndef dithering(x,y):\n    def di2(x):\n        if x==1:\n            for i in [(0,0),(1,1),(1,0),(0,1)]: yield i\n        else:\n            for i,j in di2(x-1):\n                for a,b in di2(1): \n                    yield i+a*(2**(x-1)),j+b*(2**(x-1))\n    for i in di2(int(ceil(log(max(x,y),2)))):\n        if i[0]<x and i[1]<y: yield i", "from math import ceil,log2\n\ndef dithering(width, height):\n    \"\"\"yields coordinates in the given pixmap\"\"\"\n    pow2dim = max(ceil(log2(x)) for x in [width,height])\n    pos = [0]*(pow2dim)\n    for _ in range((2**pow2dim)**2):\n        x,y=0,0\n        for idx in range(pow2dim):\n            if pos[idx] in [1,2]:\n                x += 2**(pow2dim - idx - 1)\n            if pos[idx] in [1,3]:\n                y += 2**(pow2dim - idx - 1)\n        if x < width and y < height:\n            yield x,y\n        for idx in range(pow2dim):\n            pos[idx] = (pos[idx] + 1) % 4\n            if pos[idx] > 0:\n                break\n", "from math import ceil,log2\ndef dithering(width, height):\n    size=ceil(log2(max(width,height)))\n    grid=[(0,0),(1,1),(1,0),(0,1)]\n    add=2\n    for i in range(size-1):\n        g=[]\n        for gg in grid:\n            g.append(gg)\n            g.append((gg[0]+add,gg[1]+add))\n            g.append((gg[0]+add,gg[1]))\n            g.append((gg[0],gg[1]+add))\n        grid=g; add*=2\n    for i in range(len(grid)-1,-1,-1):\n        if grid[i][0]>=width or grid[i][1]>=height:\n            del grid[i]\n    return iter(grid)", "from itertools import cycle\nfrom math import log2, ceil\n\ndef dithering(h,w):\n    \n    def rec(x,y,d,sendIt=True):\n        d >>= 1\n        if d:\n            for g in cycle( rec(x+d*dx,y+d*dy,d,i) for i,(dx,dy) in enumerate([(0,0),(1,1),(1,0),(0,1)]) ):\n                yield next(g)\n        else:\n            yield x,y\n    \n    for x,y in rec(0, 0, 2 ** ceil(log2(max(w,h))) ):\n        if 0<=x<h and 0<=y<w:\n            yield x,y", "def gen_id():\n    i = 1\n    while True:\n        yield i\n        i += 1\n\ndef dithering(width, height):\n    \"\"\"yields coordinates in the given pixmap\"\"\"\n    result = []\n    pix_map = []\n    max_step = 1\n    while max_step <= max(width - 1, height - 1):\n        max_step *= 2\n    for i in range(height):\n        temp_list = [0] * width\n        pix_map.append(temp_list)\n    start = (0, 0)\n    recursion(result, 1, max_step, start, pix_map)\n    for i in result:\n        yield i\n\ndef recursion(result, step, max_step, start, pix_map):\n    if step * 2 <= max_step:\n        recursion(result, step * 2, max_step, (start[0], start[1]), pix_map)\n        recursion(result, step * 2, max_step, (start[0] + step, start[1] + step), pix_map)\n        recursion(result, step * 2, max_step, (start[0], start[1] + step), pix_map)\n        recursion(result, step * 2, max_step, (start[0] + step, start[1]), pix_map)\n\n    if len(pix_map) > start[0] and len(pix_map[start[0]]) > start[1] and pix_map[start[0]][start[1]] == 0:\n        pix_map[start[0]][start[1]] = num_gen.__next__()\n        result.append((start[1], start[0]))\n    if len(pix_map) > start[0] + step and len(pix_map[start[0]]) > start[1] + step and pix_map[start[0] + step][start[1] + step] == 0:\n        pix_map[start[0] + step][start[1] + step] = num_gen.__next__()\n        result.append((start[1] + step, start[0] + step))\n    if len(pix_map) > start[0] and len(pix_map[start[0]]) > start[1] + step and pix_map[start[0]][start[1] + step] == 0:\n        pix_map[start[0]][start[1] + step] = num_gen.__next__()\n        result.append((start[1] + step, start[0]))\n    if len(pix_map) > start[0] + step and len(pix_map[start[0]]) > start[1] and pix_map[start[0] + step][start[1]] == 0:\n        pix_map[start[0] + step][start[1]] = num_gen.__next__()\n        result.append((start[1], start[0] + step))\n\nnum_gen = gen_id()", "def dithering(width, height, x=0, y=0, c=1):\n    if width <= c and height <= c:\n        if x < width and y < height: yield (x, y)\n        return\n    for u, v in (x,y), (x+c,y+c), (x+c,y), (x,y+c):\n        for p, q in dithering(width, height, u, v, c+c): yield p, q", "def dithering(width, height):\n    def rec(v, x, y):\n        if not (x < width and y < height): return\n        if not (x+v < width or y+v < height): yield x,y; return\n        for k in rec(2*v, x, y): yield k\n        for k in rec(2*v, x+v, y+v): yield k\n        for k in rec(2*v, x+v, y): yield k\n        for k in rec(2*v, x, y+v): yield k\n    for k in rec(1, 0, 0): yield k", "import math\n\ndef dithering(width, height):\n    d = int(math.pow(2, math.ceil(math.log(max(width, height), 2))))\n    return (\n        (x, y)\n        for x, y in _dithering(d)\n        if x < width and y < height\n    )\n\ndef _dithering(d):\n    if d == 1:\n        yield (0, 0)\n        return\n\n    fac = d//2\n    for x, y in _dithering(d>>1):\n        yield x, y\n        yield x+fac, y+fac\n        yield x+fac, y\n        yield x, y+fac"]
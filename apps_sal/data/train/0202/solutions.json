["class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        up=0\n        down=0\n        ans=0\n        for i in range(0,len(A)-1):\n            if A[i]<A[i+1]:\n                if down==0:\n                    up+=1\n                else:\n                    up=1\n                    down=0\n                    \n            elif A[i]>A[i+1]:\n                if up>0:\n                    down+=1\n                    mountain=up+down+1\n                    if ans<mountain:\n                        ans=mountain\n                \n            else:\n                up=0\n                down=0\n\n            \n        \n        return ans", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n       \n        leftpivot = 0\n        rightpivot = 0\n        ascendign = False\n        descending = False\n        changes = 0\n        highest = 0\n        while(leftpivot<len(A)):\n            rightpivot=leftpivot\n            \n            if(rightpivot+1 < len(A) and A[rightpivot]<A[rightpivot+1]):\n                while(rightpivot + 1<len(A) and A[rightpivot]<A[rightpivot+1] ):\n                    rightpivot+=1\n\n\n                if(rightpivot + 1<len(A) and A[rightpivot]>A[rightpivot+1]):\n                    while(rightpivot<(len(A)-1) and A[rightpivot]>A[rightpivot+1]):\n                        rightpivot+=1   \n                    highest = max(highest,rightpivot+1-leftpivot)\n\n            leftpivot = max(rightpivot,leftpivot+1)\n        return highest\n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        if len(A) < 3:\n            return 0\n            \n        prev_height = None\n        peaks = [0 for _ in range(len(A))]\n        has_increment = False\n        \n        # combs left to right for peaks\n        for idx in range(len(A)):\n            if prev_height is not None:\n                if prev_height < A[idx]:\n                    peaks[idx] = peaks[idx-1] + 1\n                    has_increment = True\n                else:\n                    if has_increment:\n                        peaks[idx-1] += 1\n                    peaks[idx] = 0\n                    has_increment = False\n            prev_height = A[idx]\n            \n        print(peaks)\n        \n        # combs right to left for peaks\n        prev_height = None\n        max_so_far = 0\n        has_increment = False\n        \n        for idx in range(len(A)-1, -1, -1):\n            if prev_height is not None:\n                if prev_height < A[idx]:\n                    peaks[idx] += peaks[idx+1] + 1\n                    has_increment = True\n                else:\n                    if has_increment and prev_height > A[idx]:\n                        max_so_far = max(max_so_far, peaks[idx+1])\n                    peaks[idx] = peaks[idx]\n                    has_increment = False\n            prev_height = A[idx]\n        \n        print(peaks)\n            \n        return max_so_far\n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        if len(A) < 3:\n            return 0\n        \n        n = len(A)\n        ups, downs = [0] * n, [0] * n\n        i, j = 0, n - 1\n        \n        while i < n - 1:\n            if A[i] < A[i+1]:\n                ups[i+1] = ups[i] + 1\n                \n            i += 1\n        \n        while j > 0:\n            if A[j] < A[j-1]:\n                downs[j-1] = downs[j] + 1\n                \n            j -= 1\n        \n        print((ups, downs))\n        longest = [u + d + 1 for u, d in zip(ups, downs) if u and d]\n        \n        return max(longest) if longest else 0\n", "class Solution:\n    \n    def longestMountain(self, A: List[int]) -> int:\n        N = len(A)\n        prefix = [1] * N\n        suffix = [1] * N\n        \n        for i, num in enumerate(A[1:], 1):\n            i_rev = N - i - 1\n            prefix[i] = prefix[i-1] + 1 if A[i-1] < num else 1\n            suffix[i_rev] = suffix[i_rev+1] + 1 if A[i_rev] > A[i_rev+1] else 1\n            \n        ans = 0\n        for i, num in enumerate(A):\n            left = prefix[i]\n            right = suffix[i]\n            length = left + right - 1\n            \n            if length >= 3 and min(left, right) > 1:\n                ans = max(ans, length)\n        \n        return ans\n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        \n        leftIncreasing = [0 for x in range(len(A))]\n        rightIncreasing = [0 for x in range(len(A))]\n        \n        for x in range(1, len(A)):\n            \n            if A[x] > A[x - 1]:\n                leftIncreasing[x] += (leftIncreasing[x - 1] + 1)\n            \n            if A[len(A) - 1 - x] > A[len(A) - x]:\n                rightIncreasing[len(A) - 1 - x] += (rightIncreasing[len(A) - x] + 1)\n        \n        result = 0\n        \n        for x in range(len(A)):\n            \n            if leftIncreasing[x] and rightIncreasing[x]:\n                result = max(result, leftIncreasing[x] + rightIncreasing[x] + 1)\n        \n        return result if result >= 3 else 0\n", "class Solution:\n\n    def longestMountain(self, A):\n        up, down = [0] * len(A), [0] * len(A)\n        for i in range(1, len(A)):\n            if A[i] > A[i - 1]: up[i] = up[i - 1] + 1\n        for i in range(len(A) - 1)[::-1]:\n            if A[i] > A[i + 1]: down[i] = down[i + 1] + 1\n                \n        print(down)\n        print(up)\n        return max([u + d + 1 for u, d in zip(up, down) if u and d] or [0])\n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        if len(A) < 3:\n            return 0\n        \n        longestMountain = 0\n\n        for i in range(1, len(A) - 1):\n            # Index i denotes a 'peak' in the mountain.\n            if A[i - 1] < A[i] > A[i + 1]:\n                left = right = i\n                \n                # Traverse left and down the mountain from i until there is no longer a downwards slope.\n                while left > 0 and A[left - 1] < A[left]:\n                    left -= 1\n                                \n                # Traverse right and down the mountain from i until there is no longer a downwards slope.\n                while right + 1 < len(A) and A[right + 1] < A[right]:\n                    right += 1\n                    \n                # The length of the mountain will be the distance from left and right (+ 1 to factor in the peak).\n                mountainLength = right - left + 1\n                longestMountain = max(longestMountain, mountainLength)\n        \n        return longestMountain", "class Solution:\n    def longestMountain(self, a: List[int]) -> int:\n        ml = 0\n        i = 0\n        while(i<len(a)):\n            c = 0\n            if i+1<len(a) and a[i+1]>a[i]:\n                c = 1\n                while(i+1<len(a) and a[i+1]>a[i]):\n                    c = c + 1\n                    i = i + 1\n                while(i+1<len(a) and a[i+1]<a[i]):\n                    c = c + 1\n                    ml = max(c,ml)\n                    i = i + 1\n            else:\n                i = i + 1\n        return ml\n                    \n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        idx = 0\n        big = 0\n        while idx+1 < len(A):\n            long = 1\n            if A[idx+1] > A[idx]:\n                while idx+1 < len(A) and A[idx+1] > A[idx]:\n                    idx += 1\n                    long += 1\n            else:\n                idx += 1\n                continue\n            if idx+1 < len(A) and A[idx+1] < A[idx]:\n                while idx+1 < len(A) and A[idx+1] < A[idx]:\n                    idx += 1\n                    long += 1\n            else:\n                idx += 1\n                continue\n            big = max(long, big)\n        return big if big >= 3 else 0", "class Solution:\n    def longestMountain(self, A):\n        res = up = down = 0\n        for i in range(1, len(A)):\n            if down and A[i - 1] < A[i] or A[i - 1] == A[i]: up = down = 0\n            up += A[i - 1] < A[i]\n            down += A[i - 1] > A[i]\n            if up and down: res = max(res, up + down + 1)\n        return res", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        res = up = down = 0\n        for i in range(1, len(A)):\n            if down and A[i - 1] < A[i] or A[i - 1] == A[i]:\n                up = down = 0\n            if A[i - 1] < A[i]:\n                up += 1\n            else:\n                down += 1\n            if up and down:\n                res = max(res, up + down + 1)\n        return res", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        n=len(A)\n        left_inc=[0]*n\n        for i in range(1,n):\n            if A[i]>A[i-1]:\n                left_inc[i]=1+left_inc[i-1]\n        print(left_inc)\n        \n        right_inc=[0]*n\n        for i in range(n-2,-1,-1):\n            if A[i]>A[i+1]:\n                right_inc[i]=1+right_inc[i+1]\n        print(right_inc)\n        \n        res=0\n        for i in range(n):\n            if left_inc[i]!=0 and right_inc[i]!=0:\n                res=max(res,left_inc[i]+right_inc[i]+1)\n        \n        return res if res>=3 else 0", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        # edge case\n        if len(A)==0: return 0\n        \n        n = len(A)\n        peak = None\n        maxMountainLen = 0\n        \n        i = 1\n        while (i+1) <n:\n            if A[i-1]<A[i] and A[i]>A[i+1]:\n                # already obtained the peak\n                left = right = i\n                \n                while (left-1)>=0 and A[left-1] < A[left]:\n                    left -= 1\n                \n                while (right+1) <n and A[right+1] < A[right]:\n                    right += 1\n                \n                # max length of mountain\n                maxMountainLen = max(maxMountainLen, right-left+1)\n                i=right+1\n            else:\n                i+=1\n        \n        return maxMountainLen\n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        \n        i = 0\n        answer = 0\n        while i < len(A) - 1:\n            \n            j = i + 1\n            visited_top = False\n            \n            while j < len(A):\n                print(i, j)\n                if A[j] > A[j-1]:\n                    if visited_top:\n                        break\n                    \n                if A[j] < A[j-1]:\n                    if not visited_top:\n                        if j - i == 1:\n                            break\n                        visited_top = True\n                \n                if A[j] == A[j-1]:\n                    break\n                j += 1\n\n            \n            \n            if visited_top and j - i > 2:\n                answer = max(answer, j - i)\n            i = j\n            if visited_top:\n                i -= 1\n            \n        return answer", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        import copy \n        \n        if not A:\n            return 0\n        \n        dp = []\n        B = copy.deepcopy(A)\n        B.insert(0, A[0])\n        B.append(A[-1])\n        \n        for i in range(1,len(B) - 1):\n            \n            if (B[i-1] < B[i] and B[i+1] < B[i]):\n                dp.append(i-1)\n                \n            \n        ret = []\n        A.append(A[-1])\n        for top in dp:\n            \n            \n            left = top\n            while A[left - 1] < A[left] and left > 0:\n                left -= 1\n            \n            right = top\n            while A[right + 1] < A[right]:\n                right +=1\n                \n            print(right, left)\n            ret.append(right -left + 1)\n            \n        print(dp, ret)\n        \n                \n        return max(ret) if ret else 0", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        if not A or len(A)==1: return 0\n        m=len(A)\n        up,down=[0 for i in range(m)],[0 for i in range(m)]\n        up[0], down[-1]=0,0\n        for i in range(1,m):\n            j=m-1-i\n            if A[i]>A[i-1]:\n                up[i]=up[i-1]+1\n            else:up[i]=0\n            if A[j]>A[j+1]:\n                down[j]=down[j+1]+1\n            else: down[j]=0\n        ans=0\n        for i in range(m):\n            if up[i] and down[i]: ## need peak\n                ans=max(ans,up[i]+down[i]+1)\n        return ans\n            \n        \n            \n                \n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        \n        ans = 0\n        temp = 0\n        trend = False\n        \n        if len(A)<3: return 0\n        good = False\n        \n        for i in range(1,len(A)):\n            \n            diff = A[i]-A[i-1]\n            if diff>0:\n                if not trend:\n                    good = True\n                    trend = True\n                    temp = 2\n                else:\n                    temp=max(temp+1,2)\n            elif diff<0:\n                if trend:\n                    trend = False\n                    temp = max(temp+1,2)\n                    ans = max(ans,temp)\n                else:\n                    temp=max(temp+1,2)\n                    if good: ans = max(ans,temp)\n            else:\n                temp = 0\n                trend = False\n                good = False\n            print(A[i], temp,trend, ans)\n        \n        # ans = max(ans,temp)\n            \n        return ans", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        if len(A) < 3: return 0\n        up, down, Max = [1] * len(A), [1] * len(A), 0\n        for i in range(1, len(A)):\n            if A[i] > A[i - 1]: up[i] = up[i - 1] + 1\n        \n        for i in range(len(A) - 2, -1, -1):\n            if A[i] > A[i + 1]: down[i] = down[i + 1] + 1\n        \n        # print(up)\n        # print(down)\n        \n        for i in range(1, len(A) - 1):\n            if A[i - 1] < A[i] > A[i + 1]:\n                Max = max(Max, up[i] + down[i] - 1)\n        return Max \n        \n                \n            \n        \n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        # https://leetcode.com/problems/longest-mountain-in-array/discuss/135593/C%2B%2BJavaPython-1-pass-and-O(1)-space\n        res = up = down = 0\n        for i in range(1, len(A)):\n            if down and A[i - 1] < A[i] or A[i - 1] == A[i]: up = down = 0\n            up += A[i - 1] < A[i]\n            down += A[i - 1] > A[i]\n            if up and down: res = max(res, up + down + 1)\n        return res", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        N = len(A)\n        up = [1]*N\n        for i in range(1, N):\n            if A[i]>A[i-1]: up[i]+=up[i-1]\n        down = [1]*N\n        for i in range(N-2,-1, -1):\n            if A[i]>A[i+1]: down[i]+=down[i+1]\n        # print(up, down)\n        return max([u+d-1 for u, d in zip(up, down) if u>1 and d>1 and u+d-1>=3] or [0])", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        res = up = down = 0\n        for i in range(1, len(A)):\n            if down and A[i-1] < A[i] or A[i-1] == A[i]: # to check if we found down and the next is up\n                up = down = 0 # reset for next down and make sure we are counting right up's\n            up += A[i-1] < A[i]\n            down += A[i-1] > A[i]\n            if up and down:\n                res = max(res, up+down+1)\n        return res", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        if not A: return 0\n        # None -> Haven't started a mountain, True -> rising up, False -> Falling down\n        rising = None\n        curr = 0\n        best = 0\n        prev = None\n        for i,x in enumerate(A):\n            print((i,':', x, 'curr', curr))\n            if prev is None:\n                prev = x\n                curr = best = 1\n                continue\n                \n            if rising is None and x < prev:\n                prev = x\n                continue\n            if rising is None and x > prev:\n                rising = True\n                prev = x\n                curr = 2\n                continue\n            \n            # Continue rising\n            if rising and x > prev:\n                curr += 1\n            # Continue falling\n            elif not rising and x < prev:\n                curr += 1\n            # Failure regardless of rising/not rising\n            elif x == prev:\n                rising = None\n                best = max(best, curr)\n            # Was rising, gonna fall now\n            elif rising and x < prev:\n                rising = False\n                curr += 1\n            # Was falling, gonna start a new mountain\n            elif not rising and x > prev:\n                best = max(best, curr)\n                rising = True\n                curr = 2 # x and the previous\n                    \n            prev = x\n        # Check if \n        if rising is not None and not rising:\n            best = max(best, curr)\n        return 0 if best < 3 else best\n                \n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        N = len(A)\n        start = 0 \n        ans = 0 \n        while start < N:\n            end = start\n            if end + 1 < N and A[end] < A[end+1]:\n                while end + 1 < N and A[end] < A[end+1]:\n                    end +=1\n                if end + 1 < N and A[end] > A[end+1]:\n                    while end + 1 < N and A[end] > A[end+1]:\n                        end +=1\n                    ans = max(ans, end-start+1)\n            start = max(end, start+1)\n        return ans\n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        if len(A) == 0:\n            return 0\n        increasing = False\n        count = -float('inf')\n        last = A[0]\n        max_len = 0\n        for i in range(1,len(A)):\n            if A[i] > last and increasing:\n                count += 1\n            elif A[i] > last and not increasing:\n                count = 2\n                increasing = True\n            elif A[i] < last and increasing:\n                count += 1\n                increasing = False\n                max_len = max(max_len, count)\n            elif A[i] < last and not increasing:\n                count += 1\n                max_len = max(max_len, count)\n            else:\n                if not increasing:\n                    max_len = max(max_len, count)\n                count = -float('inf')\n                increasing = False\n            last = A[i]\n        \n        if max_len < 3:\n            return 0\n        return max_len\n                \n\n\n", "class Solution:\n    def longestMountain(self, A):\n        res = up = down = 0\n        for i in range(1, len(A)):\n            if down and A[i - 1] < A[i] or A[i - 1] == A[i]: up = down = 0\n            up += A[i - 1] < A[i]\n            down += A[i - 1] > A[i]\n            if up and down: res = max(res, up + down + 1)\n        return res\n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        if not A or len(A) < 3:\n            return 0\n        \n        left = right = mid = max_moun = 0\n        while right < len(A):\n            \n            prev = mid\n            while right + 1 < len(A) and A[right + 1] > A[right]:\n                right += 1\n                mid += 1\n                \n            if prev != mid:\n                while right + 1 < len(A) and A[right + 1] < A[right]:\n                    right += 1\n\n                if mid != 0 and mid != len(A) - 1:\n                    max_moun = max(max_moun, right - left + 1)\n            \n            right = mid + 1\n            left = right\n            mid = right\n            \n        if max_moun < 3:\n            return 0\n        \n        return max_moun", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        left = right = 0\n        max_length = 0\n        while left < len(A):\n            \n            prev = A[left]\n            climbing = False\n            descending = False\n            right = left + 1\n            while right < len(A):\n                current = A[right]\n                if prev < current and not descending:\n                    climbing = True\n                elif prev > current and (climbing or descending):\n                    climbing = False\n                    descending = True\n                else:\n                    right -= 1\n                    break\n                right += 1\n                prev = current\n                \n            if right == len(A):\n                right -= 1\n            \n            curr_length = right - left + 1\n            if curr_length > 2 and descending:\n                max_length = max(max_length, curr_length)\n                \n            left = max(left + 1, right)\n                \n        return max_length", "class Solution:\n    def mountain_search(self,start,A):\n        valid_mountain = True\n        i = start\n        while (i < len(A)-1 and A[i] < A[i+1]):\n            i+=1\n        if (i < len(A)-1 and A[i] != A[i+1]):\n            while (i < len(A)-1 and A[i] > A[i+1]):\n                i+=1\n        else:\n            valid_mountain = False\n            \n        return valid_mountain, i\n    \n    def longestMountain(self, A: List[int]) -> int:\n        # Idea: go through every element in array and try to build largest mountain\n        max_mountain = 0\n        i = 0\n        if not A: return 0\n        A.append(A[-1]+1)\n        \n        while i < len(A)-3:\n            if A[i] < A[i+1]:\n                valid, new_i = self.mountain_search(i, A)\n                if valid:\n                    max_mountain = max(max_mountain, new_i-i+1)\n                i = new_i\n            else:\n                i+=1\n        return max_mountain\n            \n", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        res = 0\n        for i in range(1,len(A) - 1):\n            if A[i + 1] < A[i] > A[i - 1]:\n                l = r = i\n                \n                while l and A[l] > A[l - 1]:\n                    l -= 1\n                    \n                while r + 1 < len(A) and A[r] > A[r + 1]:\n                    r += 1\n                    \n                if r - l + 1 > res:\n                    res = r - l + 1\n        return res", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        is_peak = False\n        index = 1\n        longest = 0\n        while index < len(A) - 1:\n            if A[index] > A[index-1] and A[index] > A[index+1]:\n                is_peak = True\n            if not is_peak:\n                index += 1\n                continue\n            left = index-1\n            while left-1 >= 0 and A[left] > A[left-1]:\n                left -= 1\n            right = index+1\n            while right+1 < len(A) and A[right] > A[right+1]:\n                right += 1\n            longest = max(longest, right-left+1)\n            index = right\n            is_peak = False\n        return longest", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        up = down = ans = 0\n        for i in range(1, len(A)):\n            if A[i-1]==A[i]:\n                up = down = 0\n            elif A[i-1]<A[i]:\n                if down or up==0:\n                    up = 2\n                    down = 0\n                else:\n                    up += 1\n            else:\n                down += 1\n            if up and down:\n                ans = max(ans, up+down)\n        return ans\n    \n        \n        '''\n        up = down = ans = 0\n        for i in range(1, len(A)):\n            if A[i-1]>A[i] and up:\n                down += 1\n            if A[i-1]==A[i] or A[i-1]<A[i] and down or i==len(A)-1:\n                if up and down:\n                    ans = max(ans, up+down)\n                up = down = 0\n            if A[i-1]<A[i]:\n                up = 2 if not up else up+1\n\n        return ans\n        '''\n        \n        '''\n        l = ans = 0\n        phase = 0 #0:ascend, 1: descend\n        for r in range(1, len(A)):\n            if phase==0:\n                if A[r-1]==A[r]:\n                    l = r\n                elif A[r-1]>A[r]:\n                    if l+1<r:\n                        phase = 1\n                    else:\n                        l = r\n            if phase==1:\n                if A[r-1]<=A[r] or r==len(A)-1:\n                    ans = max(ans, r-l)\n                    if r==len(A)-1 and A[r-1]>A[r] and r-l==ans:\n                        ans += 1\n                    l = r if A[r-1]==A[r] else r-1\n                    phase = 0\n                          \n        return ans\n        ''' ", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        res = cur = 1\n        desc = False\n        for i in range(1, len(A)):\n            if A[i-1] == A[i]:\n                if desc: res = max(res, cur)\n                desc = False\n                cur = 1\n            elif A[i-1] < A[i]:\n                if not desc: cur += 1\n                else:\n                    res = max(res, cur)\n                    cur = 2\n                    desc = False\n            else:\n                if desc: cur += 1\n                elif cur > 1: \n                    desc = True\n                    cur += 1\n                else:\n                    cur = 1\n                    desc = False\n        if desc: res = max(res, cur)\n        return 0 if res < 3 and not desc else res", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        res = 0\n        i = 0\n        \n        while i < len(A):\n            j = i\n            while j + 1 < len(A) and A[j] < A[j+1]:\n                j += 1\n            mid = j\n            while j + 1 < len(A) and A[j] > A[j+1]:\n                j += 1\n            if i < mid < j:\n                res = max(res, j-i+1)\n            if i == j:\n                i +=1\n            else:\n                i = j\n        \n        return res", "'''\n\nmountain = relative maximum\n- find decr and incr after mountain\n\n[2,1,4,7,3,2,5]\n\n[2,3,2]\n\n\nwhile j < len\n    use flag to incr and decr\n    \n    while next and next incr\n        j+=1\n    \n    if not incr:\n        incr and cont\n        \n    while next and next decr\n        j+=1\n        \n    if not decr:\n        incr and cont\n        \n    if len 3\n        check/override max\n'''\n\nclass Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        \n        long_mont = 0\n        i, j = 0, 0\n        \n        while j < len(A):\n            \n            incr = False\n            while j!=len(A)-1 and A[j] < A[j+1]:\n                incr = True\n                j+=1\n            \n            if not incr:\n                j+=1\n                i=j\n                continue\n                \n            decr = False\n            while j!=len(A)-1 and A[j] > A[j+1]:\n                decr = True\n                j+=1\n                \n            if not decr:\n                j+=1\n                i=j\n                continue\n                \n            curr_len = j-i+1\n            if curr_len >= 3:\n                long_mont = max(long_mont, curr_len)\n\n            i = j\n                \n        return long_mont\n", "class Solution(object):\n    def longestMountain(self, A):\n        N = len(A)\n        ans = base = 0\n\n        while base < N:\n            end = base\n            if end + 1 < N and A[end] < A[end + 1]: #if base is a left-boundary\n                #set end to the peak of this potential mountain\n                while end+1 < N and A[end] < A[end+1]:\n                    end += 1\n\n                if end + 1 < N and A[end] > A[end + 1]: #if end is really a peak..\n                    #set 'end' to right-boundary of mountain\n                    while end+1 < N and A[end] > A[end+1]:\n                        end += 1\n                    #record candidate answer\n                    ans = max(ans, end - base + 1)\n\n            base = max(end, base + 1)\n\n        return ans", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n    # Write your code here.\n        longest, i = 0, 1\n        while i < len(A) - 1:\n            is_peak = A[i-1] < A[i] and A[i] > A[i+1]\n            #Check if i is peak\n            if is_peak:\n                left = i-2\n                #Move left pointer left while in bounds and greater\n                while left >= 0 and A[left] < A[left + 1]:\n                    left -= 1\n                right = i + 2\n                #Move right pointer right while in bounds and greater\n                while right < len(A) and A[right] < A[right - 1]:\n                    right += 1\n                #Current peak  \n                longest = max(longest, right - left - 1)\n                #Increment i\n                i = right\n            #If i is not peak, increment and continue.\n            else:\n                i += 1\n                continue\n        return longest", "class Solution:\n    def longestMountain(self, A: List[int]) -> int:\n        if len(A)<3:\n            return 0\n        a=A\n        start =0\n        end = 0\n        maxlen=0\n        n=len(a)\n        while(start<n-1 and end<n):\n            end = start\n            if a[start]<a[start+1]:\n                while end<n-1 and a[end]<a[end+1]:\n                    end+=1\n                if end<n-1 and a[end]>a[end+1]:\n                    while(end<n-1 and a[end]>a[end+1]):\n                        end +=1\n                    maxlen = max(maxlen,end-start+1)\n            start = max(start+1,end)\n        \n        return maxlen"]
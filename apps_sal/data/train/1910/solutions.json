["# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def kth(self, v, k):\n         for i in range(k-1):\n             if not v:\n                 return None\n             v=v.next\n         return v\n     \n     def reverseKGroup(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         if k==1:\n             return head\n         kthnode=self.kth(head, k)\n         v=head\n         head=kthnode if kthnode else head\n         i=0\n         tmphead=v\n         while kthnode:\n             vprev=kthnode.next\n             for i in range(k):\n                 v.next, v, vprev = vprev, v.next, v\n                 kthnode=None if not kthnode else kthnode.next\n             tmphead.next=kthnode if kthnode else v\n             tmphead=v\n         return head", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def reverseKGroup(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         if head == None:\n             return None\n         if head.next == None:\n             return head\n         \n         cur = head\n         prev = None\n         count = 0\n         if self.getsize(cur) >= k:\n             while count < k and cur != None:\n                 temp = cur\n                 cur = cur.next\n                 temp.next = prev\n                 prev = temp\n                 count = count + 1\n             if cur != None:\n                 head.next = self.reverseKGroup(cur, k)\n             return prev\n         \n         return cur\n                 \n         \n     def getsize(self, head):\n         curnode = head\n         count = 0\n         while curnode != None:\n             curnode = curnode.next\n             count = count + 1\n         return count\n         ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def reverse(self, start, end):\n         head = ListNode(0)\n         head.next = start\n         while head.next != end:\n             temp = start.next\n             start.next = temp.next\n             temp.next = head.next\n             head.next = temp\n         return [end, start]\n     \n     def reverseKGroup(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         if head is None or head.next is None:\n             return head\n         dummpy = ListNode(0)\n         dummpy.next = head\n         phead = dummpy\n         while phead.next:\n             start, end = phead.next, phead.next\n             for i in range(k-1):\n                 end = end.next\n                 if end is None:\n                     return dummpy.next\n             result = self.reverse(start, end)\n             phead.next = result[0]\n             phead = result[1]\n         return dummpy.next\n             ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def reverse(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         counter = k\n         tail = head\n         prev = None\n         current = head\n         \n         while counter > 0 and current:\n             newCurrent = current.next\n             current.next = prev\n             prev = current\n             current = newCurrent\n             counter -= 1\n         \n         if counter > 0:\n             return self.reverse(prev, k - counter)\n         \n         head = prev\n             \n         return (head, tail, current)\n     \n     def reverseKGroup(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         if k == 0:\n             return head\n         \n         head, tail, current = self.reverse(head, k)\n         while current:\n             joinedFragmentHead, newTail, newCurrent = self.reverse(current, k)\n             tail.next = joinedFragmentHead\n             tail = newTail\n             current = newCurrent\n             \n         return head", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def reverseKGroup(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         current = head \n         next  = None\n         prev = None\n         count = 0\n         \n         if(self.nextkthnode(head,k) is None):\n             return head\n         while(current is not None and count < k):\n             next = current.next\n             current.next = prev\n             prev = current\n             current = next\n             count += 1\n  \n        \n         if next is not None and self.nextkthnode(next,k) is not None:\n             head.next = self.reverseKGroup(next, k)\n         elif(next is not None):\n             head.next = next\n  \n         return prev \n             \n         \n     def nextkthnode(self, head, k):\n         for i in range(k-1):\n             if(head==None):\n                 return None\n             head=head.next\n         return head", "# Definition for singly-linked list.\n class ListNode:\n     def __init__(self, x):\n         self.val = x\n         self.next = None\n \n class Solution:\n     def reverseKGroup(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n \n         copy = head\n         for _ in range(k):\n             if copy is None:\n                 return head\n             else:\n                 copy = copy.next\n \n         k_nodes = []\n         for _ in range(k):\n             k_nodes.append(head)\n             head = head.next\n         rest = k_nodes[-1].next\n \n         for i in reversed(range(1, len(k_nodes))):\n             k_nodes[i].next = k_nodes[i-1]\n         k_nodes[0].next = self.reverseKGroup(rest, k)\n \n         return k_nodes[-1]\n \n", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def reverseKGroup(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         if head == None:\n             return None\n         if k == 1:\n             return head\n         res = []\n         while(head!=None):\n             res.append(head.val)\n             head = head.next\n         lens = len(res)\n         res1 = []\n         start = 0\n         while(start+k <= lens):\n             b = res[start:start+k]\n             c = list(reversed(b))\n             res1 += c\n             start += k\n         b = res[start:lens]\n         res1 += b\n         return res1\n         \n         ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def reverseKGroup(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         previous_node, current_node = None, head\n         ret = self.getKElem(head, k - 1)\n         if not ret: return head\n         last = ret\n         while last:\n             if previous_node: previous_node.next = last\n             for _ in range(k):\n                 next_node = current_node.next\n                 current_node.next = previous_node\n                 current_node, previous_node = next_node, current_node\n             previous_node = head\n             previous_node.next = current_node\n             head = current_node\n             last = self.getKElem(head, k - 1)\n         \n         return ret\n     \n     def getKElem(self, head, k):\n         if k < 0: return None\n         while k > 0:\n             if not head: return None\n             k -= 1\n             head = head.next\n         return head", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def reverseKGroup(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         root = p = ListNode(0);\n         flag = 0\n         while head:\n             tlist = []\n             for i in range(k):\n                 if head != None:\n                     tlist.append(head.val);\n                     head = head.next;\n                 else:\n                     flag = 1;\n                     break;\n             if flag == 0:\n                 for i in range(k):\n                     p.next = ListNode(tlist[k-1-i]);\n                     p = p.next;\n             else:\n                 for i in tlist:\n                     p.next = ListNode(i);\n                     p = p.next;\n         return root.next", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def reverseK(self, beg, end):        \n         prev = None\n         curr = beg\n         while curr is not end:\n             next_node = curr.next\n             curr.next = prev\n             prev = curr\n             \n             curr = next_node\n             \n         return prev, beg\n             \n         \n     def reverseKGroup(self, head, k):\n         \"\"\"\n         :type head: ListNode\n         :type k: int\n         :rtype: ListNode\n         \"\"\"\n         if head is None:\n             return None\n         \n         fake = ListNode(0)\n         prev = fake\n         curr = head\n         \n         while curr:\n             i = 1\n             tail = curr\n             while i <= k and tail:\n                 tail = tail.next\n                 i += 1\n             \n             if i -1 == k:\n                 new_curr = tail\n                 r_head, r_tail = self.reverseK(curr, tail)\n             else:\n                 r_head = curr\n                 r_tail = None\n                 new_curr = None\n             \n             curr = new_curr\n             prev.next = r_head\n             \n             if r_tail:\n                 r_tail.next = curr\n                 \n             prev = r_tail\n             \n         return fake.next        ", "class Solution:\n     def reverseKGroup(self, head, k):\n         if not head:\n             return head\n \n         cur = head\n \n         for _ in range(k - 1):\n             cur = cur.next\n             if not cur:\n                 return head\n \n         prev = self.reverseKGroup(cur.next, k)\n         cur.next = None\n         cur = head\n \n         while cur:\n             temp = cur.next\n             cur.next = prev\n             prev, cur = cur, temp\n \n         return prev", "\"\"\"\n 3->2->1->6->5->4\n \n \"\"\"\n \n # Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n #return (head, tail)\n def reverse_LL2(node, length):\n     if length == 1:\n         return (node, node)\n     back = None\n     curr = node\n     forward = node.next\n     for _ in range(length):\n         curr.next = back\n         back = curr\n         curr = forward\n         if forward:\n             forward = forward.next\n     return (back, node)\n \n def reverse_LL(node, length):\n     if length == 1:\n         return node\n     rest = node.next\n     restR = reverse_LL(rest, length - 1)\n     rest.next = node\n     node.next = None\n     return restR\n     \n     \n def jump_LL(node, length):\n     curr = node\n     for _ in range(length):\n         if curr == None:\n             return False\n         curr = curr.next\n     return curr\n \n class Solution:\n     def reverseKGroup(self, head, k):\n         if (head == None):\n             return None\n         jumped = jump_LL(head, k)\n         if jumped == False:\n             return head\n         rev = reverse_LL(head, k)\n         head.next = self.reverseKGroup(jumped, k)\n         return rev\n         "]
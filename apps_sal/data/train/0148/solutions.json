["class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        ws = sorted(worker, reverse=True)\n        dp = sorted(zip(difficulty, profit), key=lambda x: x[1], reverse=True)\n        # print(list(dp))\n        \n        i = 0\n        total = 0\n        for w in ws:\n            while dp[i][0] > w:\n                i = i + 1\n                if i >= len(dp):\n                    return total\n            total = total + dp[i][1]\n        return total", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        job = sorted(zip(difficulty, profit))\n\n        best = 0 \n        i = 0 \n        profit = 0\n\n        for work in sorted(worker):\n            while (i < len(difficulty) and job[i][0] <= work):\n                best = max(best, job[i][1])\n                i += 1\n            profit += best\n\n        return profit", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        rel = zip(difficulty, profit)\n        rel = sorted(rel)\n        output = 0\n        worker.sort()\n        mx = 0\n        j = 0\n        for i in worker:\n            while j < len(rel) and i >= rel[j][0]:\n                mx = max(mx, rel[j][1])\n                j += 1\n            print(i, mx)\n            output += mx\n        return output", "# 6:12 -> 6:25 | 7:23 -> \n# Find mapping of workers to jobs such that profit is maximized\n# Greedy approach: take highest profit job, assign it to most highly skilled worker\nfrom queue import PriorityQueue\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        # print('difficulty', difficulty)\n        # print('profit', profit)\n        # print('worker', worker)\n        pq = PriorityQueue()\n        \n        worker.sort()\n        \n        for i, job in enumerate(profit):\n            pq.put( (-job, i) )\n        \n        profit = 0\n        \n        while worker:\n            skill = worker.pop()\n            cash, diff_index = pq.get() if not pq.empty() else (0, -1)\n            while not pq.empty() and diff_index > -1 and skill < difficulty[diff_index]:\n                cash, diff_index = pq.get()\n            if skill < difficulty[diff_index]:\n                cash, diff_index = 0, -1\n            if cash != 0:\n                pq.put( (cash, diff_index) )\n            cash *= -1\n            profit += cash\n            # print(profit, cash, skill)\n        \n        return profit", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = [[0,0]] + sorted([[difficulty[i], profit[i]] for i in range(len(profit))]) \n        for i in range(1, len(jobs)):\n            jobs[i][1] = max(jobs[i-1][1], jobs[i][1])\n        res, workerCounts = 0, collections.Counter(worker) \n        def binarySearch(n):\n            l, r = 0, len(jobs)-1\n            while l < r-1:\n                \n                mid = (l+r)//2\n                if jobs[mid][0] > n:\n                    r =  mid - 1\n                else:\n                    l = mid\n            return jobs[l][1] if jobs[r][0] > n else jobs[r][1]\n                \n        for work, count in list(workerCounts.items()):\n            res += binarySearch(work)*count\n        return res\n\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        \n        temp = sorted( zip(difficulty, profit) )\n        \n        d = collections.defaultdict(int)\n        \n        for u, v in temp:\n            d[u] = v\n        \n        maxdifficulty = max(worker)\n        \n        for i in range(1, maxdifficulty + 1):\n            d[i] = max(d[i], d[i - 1])\n            \n        # print (d)\n            \n        ans = 0\n        \n        for i in worker:\n            \n            # print (i, d[i])\n            \n            ans += d[i]\n            \n        return ans\n                \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        d = sorted([(difficulty[i],profit[i]) for i in range(len(difficulty))])\n        c = [0] * 100005\n        \n        # print(d)\n        \n        t = 0\n        for i in range(1,100005):\n            c[i] = c[i-1]\n            while t < len(d) and i == d[t][0]:\n                c[i] = max(c[i],d[t][1])\n                t += 1\n                \n        \n        # print(c[0:101])\n        # print([c[i] for i in worker])\n        \n        return sum([c[i] for i in worker])", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        max_v = max(max(difficulty), max(worker))\n        \n        n = len(difficulty)\n        best = [0] * (max_v + 1)\n        for i in range(n):\n            d = difficulty[i]\n            p = profit[i]\n            best[d] = max(best[d], p)\n        \n        for i in range (1, max_v + 1):\n            best[i] = max(best[i - 1], best[i])\n        \n        s = 0 \n        for d in worker:\n            s += best[d]\n        return s", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        arr=[0 for _ in range(10**5+1)]\n        for i in range(len(profit)):\n            arr[difficulty[i]]=max(profit[i],arr[difficulty[i]])\n        for i in range(1,10**5+1):\n            arr[i]=max(arr[i-1],arr[i])\n        ans=0\n        # print(arr[:101])\n        for i in worker:\n            ans+=arr[i]\n        return ans\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        output=0\n        job=sorted(zip(difficulty,profit),reverse=True,key=lambda x:x[1])\n        worker=sorted(worker,reverse=True)\n        jobIndex=0\n        for workerCab in worker:\n            # print(workerCab)\n            \n            while jobIndex<len(job):\n                # print(jobIndex)\n                if job[jobIndex][0]<=workerCab:\n                    # print('find')\n                    break\n                else:\n                    jobIndex+=1\n            \n            if jobIndex<len(job):\n                output=output+job[jobIndex][1]\n            # print(output,job[jobIndex][1])\n        # print(job)\n        return output", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        for i in range(len(difficulty)):\n            difficulty[i] = (difficulty[i], profit[i])\n        difficulty.sort(key = lambda x:x[0]) # O(NlogN)\n        i, L = 0, len(difficulty)\n        ans, most = 0, 0\n        for wker in sorted(worker):\n            while i < L and difficulty[i][0] <= wker:\n                most = max(most, difficulty[i][1])\n                i += 1\n            ans += most\n        return ans", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = []\n        total = 0\n        \n        for i in range(len(profit)):\n            jobs.append([difficulty[i], profit[i]])\n        print(jobs)\n        \n        worker.sort()\n        jobs.sort()\n        i = 0\n        best = 0\n        \n        for work in worker:\n            while i < len(jobs) and work >= jobs[i][0]:\n                best = max(best, jobs[i][1])\n                i += 1\n            total += best\n        \n        return total\n            \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = sorted(zip(difficulty, profit))\n        worker.sort()\n\n        m = len(worker)\n        n = len(jobs)\n\n        j = 0\n        max_profit = 0\n        result = 0\n        for i in range(m):\n            ability = worker[i]\n\n            while j < n and jobs[j][0] <= ability:\n                max_profit = max(max_profit, jobs[j][1])\n                j += 1\n\n            result += max_profit\n\n        return result\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        best = 0\n        tot = 0\n        worker.sort()\n        for d, p in sorted(zip(difficulty, profit)):\n            while worker and d > worker[0]:\n                tot += best\n                worker.pop(0)\n            best = max(best, p)\n        tot += best * len(worker)\n        return tot\n        \n            \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        l = sorted(zip(profit,difficulty), reverse = True)\n        \n        worker.sort(reverse = True)\n        \n        p = 0\n        \n        for w in worker:\n            while l and w < l[0][1]:\n                l.pop(0)\n            if not l:\n                break\n            p+=l[0][0]\n        return p", "import bisect\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        m,n={},len(difficulty)\n        for ind, val in enumerate(difficulty):\n            m[val]=max(m.get(val,0),profit[ind])\n        difficulty.sort()\n        for ind, val in enumerate(difficulty):\n            if ind>0:\n                m[val]=max(m[val],m[difficulty[ind-1]])\n        \n        ans = 0\n        for ind, val in enumerate(worker):\n            d_ind = bisect.bisect_left(difficulty, val)\n            if d_ind<n:\n                if difficulty[d_ind]<=val:\n                    ans+=m[difficulty[d_ind]]\n                else:\n                    ans+=m[difficulty[d_ind-1]] if d_ind>0 else 0\n            else:\n                ans+=m[difficulty[d_ind-1]]\n        return ans\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\n        \n        \n        profit_table = {} # maps difficulty to profit\n        \n        for i, (d, p) in enumerate(zip(difficulty, profit)):\n            if i > 0:\n                profit_table[d] = max(p, profit_table[difficulty[i-1]])\n            else:\n                profit_table[d] = p\n        \n        value = 0\n        \n        d_index = len(difficulty) - 1\n        for w in reversed(sorted(worker)):\n            while d_index >= 0 and difficulty[d_index] > w:\n                d_index -= 1\n            if d_index >= 0: value += profit_table[difficulty[d_index]]\n        return value", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = sorted(zip(difficulty, profit))\n        profit = i = maxprofits = 0\n        for ability in sorted(worker):\n            while i < len(jobs) and ability >= jobs[i][0]:\n                profit = max(jobs[i][1], profit)\n                i += 1\n            maxprofits += profit\n        return maxprofits", "import bisect\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        if not difficulty:\n            return 0\n        indices = sorted(list(range(len(difficulty))), key=lambda i: difficulty[i])        \n        difficulty = [difficulty[i] for i in indices]\n        profit = [profit[i] for i in indices]\n        max_profit = [profit[0]]\n        for p in profit[1:]:\n            max_profit.append(max(max_profit[-1], p))\n        total = 0            \n        for ability in worker:\n            idx = bisect.bisect_right(difficulty, ability)\n            if idx > 0:\n                total += max_profit[idx-1]\n        return total                \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        if difficulty is None: return 0\n        thislist = []\n        for i in range(0, len(difficulty)): thislist.append((difficulty[i], profit[i]))\n        thislist.sort()\n        worker.sort()\n        res = 0\n        curr_max = 0\n        worker_index = 0\n        list_index = 0\n        while worker_index < len(worker) and list_index < len(thislist):\n            if thislist[list_index][0] <= worker[worker_index]:\n                curr_max = max(curr_max, thislist[list_index][1])\n                list_index += 1\n            else:\n                res += curr_max\n                worker_index += 1\n        \n        if worker_index < len(worker): res += curr_max*(len(worker)-worker_index)\n        return res", "import bisect\n\nclass Solution:\n    def solve(self, diff, profit, worker):\n        mp = {}\n        for i in range(len(diff)):\n            d = diff[i]\n            p = profit[i]\n            if d not in mp:\n                mp[d] = 0\n            mp[d] = max(mp[d], p)\n        diff2 = sorted(mp.keys())\n        ln = len(diff2)\n        mx = [0]*ln\n        for i in range(ln):\n            d = diff2[i]\n            p = mp[d]\n            if i == 0:\n                mx[i] = p\n            else:\n                mx[i] = max(mx[i-1], p)\n        total = 0\n        # print(diff2)\n        # print(profit2)\n        # print(mx)\n        # print('---')\n        for w in worker:\n            if w < diff2[0]:\n                continue\n            i = bisect.bisect_left(diff2, w)\n            if i >= len(diff2):\n                i = len(diff2)-1                \n            elif diff2[i] > w:\n                i -= 1\n                if i < 0:\n                    continue\n            max_profit = mx[i]\n            # print(w, i, mx[i])\n            total += max_profit\n        return total\n    \n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        return self.solve(difficulty, profit, worker)\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        combined = sorted(zip(difficulty,profit))\n        worker.sort()\n        n = len(worker)\n        start = 0\n        net_profit = 0\n        current_profit = 0\n        for i in range(n):\n            while start< len(difficulty) and combined[start][0]<=worker[i]:\n                current_profit = max(combined[start][1],current_profit)\n                start += 1\n            net_profit += current_profit\n        return net_profit", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        value = list(zip(difficulty, profit))\n        value.sort()\n        print(value)\n        res = 0\n        i = 0\n        best = 0\n        for person in sorted(worker):\n            while i < len(value) and person >= value[i][0]:\n                best = max(best, value[i][1])\n                i += 1\n            res += best\n        \n        return res", "class Solution:\n    def maxProfitAssignment(\n        self, difficulty: List[int], profit: List[int], worker: List[int]\n    ) -> int:\n\n        pairs = [(a, b) for a, b in zip(difficulty, profit)]\n        sorted_pairs = sorted(pairs, key=lambda p: p[0])\n        benifit = []\n        current_max = 0\n        for diff, pro in sorted_pairs:\n            current_max = max(pro, current_max)\n            benifit.append((diff, current_max))\n\n        sorted_workers = sorted(worker)\n        ans = 0\n        current_difficulty_index = worker_index = 0\n        while worker_index < len(worker):\n            if sorted_workers[worker_index] < benifit[current_difficulty_index][0]:\n                worker_index += 1\n                continue\n            while (\n                current_difficulty_index + 1 < len(worker)\n                and benifit[current_difficulty_index + 1][0]\n                <= sorted_workers[worker_index]\n            ):\n                current_difficulty_index += 1\n\n            # print(\n            #     f\\\"{worker_index=} {current_difficulty_index=} {benifit[worker_index][1]=}\\\"\n            # )\n            ans += benifit[current_difficulty_index][1]\n            worker_index += 1\n\n        return ans\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        worker.sort()\n        arr=[]\n        for i in range(len(profit)):\n            arr.append([difficulty[i],profit[i]])\n            \n        arr.sort(key=lambda x:x[0])\n        for i in range(len(arr)):\n            difficulty[i] = arr[i][0]\n            profit[i] = arr[i][1]\n        # print(difficulty)\n        # print(profit)\n        # print(worker)\n        prev = [profit[0]]\n        for i in range(1,len(profit)):\n            prev.append(max(profit[i],prev[-1]))\n        i = 0\n        p=0\n        j = 0\n        while(j<len(worker)):\n            if(i==len(difficulty)):\n                p+=prev[i-1]\n                j+=1\n                continue\n                \n            if(difficulty[i]<=worker[j]):\n                i+=1\n            # elif(difficulty[i]==worker[j]):\n            #     # p+=prev[i]\n            #     i+=1\n            #     # j+=1\n            else:\n                x=i-1\n                while(x>=0 and difficulty[x]>worker[j]):\n                    x-=1\n                if(x>=0):\n                    p+=prev[x]\n                j+=1\n                \n        return p\n", "from bisect import bisect\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        \n        maxp = 0\n        maxpa = []\n        for difficulty,profit in sorted(zip(difficulty,profit),key=lambda x:x[0]):\n            maxp = max(maxp,profit)\n            maxpa.append((difficulty,maxp))\n            \n        \n        total = 0\n        for w in worker:\n            ind = bisect(maxpa,(w,float('inf')))\n            if ind>0:\n                total += maxpa[ind-1][1]\n            \n        return total\n\n            \n        \n        \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        \n        job = {}\n        for cost, gain in zip(difficulty, profit):           \n            if cost in job:\n                job[cost] = max(job[cost], gain)\n            else:\n                job[cost] = gain\n        \n        job = [(k, v) for k, v in list(job.items())] + [(0, 0)]\n        job.sort()\n        useless = set()\n        \n        global_max = -float('inf')\n        for i, (c, g) in enumerate(job):\n            if g < global_max:\n                useless.add(i)\n            else:\n                global_max = g\n        \n        job = [job[i] for i in range(len(job)) if i not in useless]\n        print(job)\n        worker.sort()\n        \n        i, j = 0, 0\n        ans = 0\n        while j < len(worker):\n            \n            while job[i][0] < worker[j] and i < len(job) - 1:\n                i += 1\n            \n            ans += job[i][1] if job[i][0] <= worker[j] else job[i- 1][1]\n            \n            j += 1\n        \n        return ans\n", "class Solution:\n    def maxProfitAssignment(self, difficulty, profit, worker):\n        \n        data = sorted([(d,p) for d,p in zip(difficulty, profit)])\n        worker.sort()\n        i, n, money = 0, len(data), 0\n        res = 0\n        for w in worker:\n            while i < n and w >= data[i][0]:\n                money = max(money, data[i][1])\n                i += 1\n            res += money\n        return res\n        \n        \n        \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        mDifficulty = {}\n        \n        for i in range(len(difficulty)):\n            d = difficulty[i]\n            if difficulty[i] not in mDifficulty:\n                mDifficulty[d] = 0\n            mDifficulty[d] = max(mDifficulty[d], profit[i])\n        \n        jobs = []\n        for key, value in mDifficulty.items():\n            jobs.append([key, value]) \n            \n        jobs.sort(key=lambda job:job[0])\n        \n        for i in range(1, len(jobs)):\n            jobs[i][1] = max(jobs[i][1], jobs[i - 1][1])\n            \n        worker.sort()\n        start = len(jobs) - 1\n        count = 0\n        \n        for i in range(len(worker) - 1, - 1, -1):\n            while worker[i] < jobs[start][0] and start >= 0:\n                start -= 1\n            if start < 0:\n                break\n            count += jobs[start][1]\n            \n        return count", "class Solution(object):\n    def maxProfitAssignment(self, difficulty, profit, worker):\n        jobs = zip(difficulty, profit)\n        jobs = sorted(jobs)\n        ans = i = best = 0\n        for skill in sorted(worker):\n            while i < len(jobs) and skill >= jobs[i][0]:\n                best = max(best, jobs[i][1])\n                i += 1\n            ans += best\n        return ans", "class Solution:\n    def maxProfitAssignment(self, difficulty, profit, worker):\n        jobs = sorted(zip(difficulty, profit))\n        ans = i = best = 0\n        for skill in sorted(worker):\n            while i < len(jobs) and skill >= jobs[i][0]:\n                best = max(best, jobs[i][1])\n                i += 1\n            ans += best\n        return ans", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        arr = []\n        for i in range(len(difficulty)):\n            arr.append((difficulty[i], profit[i]))\n        arr = sorted(arr, key=lambda x: x[0])\n\n        maxProfit, maxProfits = 0, []\n        for _, gain in arr:\n            maxProfit = max(maxProfit, gain)\n            maxProfits.append(maxProfit)\n\n        total = 0\n        for person in worker:\n            idx = self.uppperBsearch(arr, person) - 1\n            if idx > -1:\n                total += maxProfits[idx]\n\n        return total\n\n    def uppperBsearch(self, arr, target):\n        left = 0\n        right = len(arr)\n        while left < right:\n            mid = (left + right)//2\n            if target >= arr[mid][0]:\n                left = mid + 1\n            else:\n                right = mid\n        return right", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        ls = sorted(range(len(difficulty)), key= lambda x : difficulty[x])\n        workers = sorted(worker)\n        \n        idx = 0\n        resp = 0\n        best = 0\n        for worker in workers:\n            while idx < len(ls) and worker >= difficulty[ls[idx]]:\n                best = max(best, profit[ls[idx]])\n                idx += 1\n            resp += best\n        return resp", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = sorted(zip(difficulty, profit),key=lambda t:t[0])\n        ans = i = best = 0\n        for w in sorted(worker):\n            while i < len(jobs) and w >= jobs[i][0]:\n                best = max(best, jobs[i][1])\n                i += 1\n            ans += best\n        return ans", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        tup=[]\n        dic = {}\n        for i in range(0,len(profit)):\n            tup.append((profit[i],difficulty[i]))\n      \n        worker.sort(reverse=True)        \n        tup.sort(reverse=True)\n        indx=0\n        t_indx=0\n        \n        res=0\n        \n        while(indx<len(worker)):\n            \n            while(t_indx < len(profit) and worker[indx]<tup[t_indx][1]):\n                t_indx+=1             \n                \n            if(t_indx < len(profit)):\n                res+=tup[t_indx][0]\n            indx+=1\n        \n        return res\n            \n            \n            \n            \n        \n        \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        worker = sorted(worker)\n        jobs = sorted([(-1,0)]+[(difficulty[i],profit[i])for i in range(len(difficulty))])\n        job_nums = len(jobs)\n        maxProfit = 0\n        job_index = 0\n        res = 0\n        for ability in worker:\n            while job_index < job_nums-1 and ability>= jobs[job_index+1][0]:\n                job_index+=1\n                maxProfit = max(maxProfit,jobs[job_index][1])\n            res+=maxProfit\n        return res\n            \n        \n        \n", "class Solution(object):\n    def maxProfitAssignment(self, difficulty, profit, worker):\n        arr = []\n        for d, p in sorted(zip(difficulty, profit)):\n            if arr and arr[-1][1]>=p:\n                continue\n            arr.append([d, p])    \n        \n        N = len(arr)\n        res, i, best = 0, 0, 0\n        for w in sorted(worker):\n            while i<N and w>=arr[i][0]:\n                best = arr[i][1]\n                i += 1\n            \n            res += best\n        return res\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        tup_list = sorted(list(zip(difficulty, profit)))\n        filtered_list = []\n        best = 0\n        for d, p in tup_list:\n            if p > best:\n                best = p\n                filtered_list.append((d, p))\n\n        worker = sorted(worker)\n\n        profit = 0\n\n        dix = 0\n        for w in worker:\n            if w < filtered_list[dix][0]:\n                continue\n\n            while dix+1 < len(filtered_list) and filtered_list[dix+1][0] <= w:\n                dix += 1\n\n            profit += filtered_list[dix][1]\n\n        return profit", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        \n        val_dict = dict()\n        for i in range(len(difficulty)):\n            val_dict[difficulty[i]] = max(val_dict.get(difficulty[i], 0), profit[i])\n        key_list = list(val_dict.keys())\n        key_list = sorted(key_list)\n\n        max_val = 0\n        max_list = [0] * len(key_list)\n        for i in range(len(key_list)):\n            max_val = max(max_val, val_dict[key_list[i]])\n            max_list[i] = max_val\n        \n        total = 0\n        #print(key_list, max_list)\n        for w in worker:\n            #print(w, self.bisect(w, key_list, max_list))\n            total += self.bisect(w, key_list, max_list)\n        return total\n    \n    def bisect(self, w, key_list, max_list):\n\n        left, right = 0, len(key_list)-1\n        if w < key_list[0]:\n            return 0\n        if w >= key_list[right]:\n            return max_list[right]\n\n        while left != right - 1:\n            mid = (left + right) // 2\n            if w > key_list[mid]:\n                left = mid\n            elif w < key_list[mid]:\n                right = mid\n            else:\n                return max_list[mid]\n        return max_list[left]", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        # 8:49 9/26/20\n        \n        def find_difficulty(d, w):\n            n = len(d)\n            lt, rt = 0, n\n            while lt < rt:\n                mid = lt + (rt - lt) // 2\n                if d[mid] == w:\n                    return mid\n                elif d[mid] > w:\n                    rt = mid\n                else:\n                    lt = mid + 1\n            return rt-1\n\n        difficulty1 = sorted(difficulty)\n        \n        difficulty = list(zip(difficulty, profit))\n        difficulty.sort(key = lambda x: (x[0]))\n        \n        profit = {}\n        max_profit = 0\n        for i in range(len(difficulty)):\n            if difficulty[i][0] not in profit or profit[difficulty[i][0]] < difficulty[i][1]:\n                profit[difficulty[i][0]] = difficulty[i][1]\n            max_profit = max(max_profit, profit[difficulty[i][0]])\n            profit[difficulty[i][0]] = max_profit\n                \n        \n        total = 0\n        pre = -1\n        for i in range(len(worker)):\n            # if i > 0 and worker[i] == worker[i-1] and pre != -1:\n            #     total += profit[pre]\n            #     continue\n            pre = find_difficulty(difficulty1, worker[i])\n            if pre != -1:\n                total += profit[difficulty1[pre]]\n                \n        return total\n            \n        \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = list(zip(difficulty, profit))\n        jobs.sort(key=lambda x:x[1], reverse=True)\n        jobs.sort(key=lambda x:x[0])\n        bestjobs=[]\n        res = 0\n        for a,b in jobs:\n            if not bestjobs:\n                bestjobs.append((a,b))\n            elif bestjobs[-1][1]<b:\n                bestjobs.append((a,b))\n        print(bestjobs)\n        for wo in worker:\n            lo, hi = 0, len(bestjobs)-1\n            while lo<hi:\n                mid = (lo+hi+1)//2\n                if bestjobs[mid][0]>wo:\n                    hi = mid-1\n                else:\n                    lo = mid\n            if bestjobs[lo][0]<=wo:\n                res+=bestjobs[lo][1]\n        return res\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        m = len(difficulty)\n        \n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\n        \n        difficulty = list(difficulty)\n        profit = list(profit)\n        \n        best_profit = m * [0]\n        best_profit[0] = profit[0]\n        ind = 0\n        prev_v = difficulty[0]\n        \n        for i in range(1, m):\n            if prev_v != difficulty[i]:\n                ind += 1\n                difficulty[ind] = prev_v = difficulty[i]\n                best_profit[ind] = best_profit[ind - 1]\n            \n            best_profit[ind] = max(best_profit[ind], profit[i])\n            \n        # print(best_profit)\n        # print(difficulty)\n            \n        m = ind + 1\n            \n        def bins(target):\n            start = 0\n            end = m - 1\n            bsres = 0\n            \n            while start <= end:\n                middle = start + (end - start) // 2\n                \n                if difficulty[middle] == target:\n                    return best_profit[middle]\n                \n                if difficulty[middle] < target:\n                    bsres = best_profit[middle]\n                    start = middle + 1\n                    \n                else:\n                    end = middle - 1\n                    \n            return bsres\n        \n        res = 0\n        h = dict()\n        \n        for w in worker:\n            if w not in h:\n                h[w] = bins(w)\n            \n            res += h[w]\n        \n        return res", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        m = len(difficulty)\n        \n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\n        \n        difficulty = list(difficulty)\n        profit = list(profit)\n        \n        best_profit = m * [0]\n        best_profit[0] = profit[0]\n        ind = 0\n        prev_v = difficulty[0]\n        \n        for i in range(1, m):\n            if prev_v != difficulty[i]:\n                ind += 1\n                difficulty[ind] = prev_v = difficulty[i]\n                best_profit[ind] = best_profit[ind - 1]\n            \n            best_profit[ind] = max(best_profit[ind], profit[i])\n            \n        # print(best_profit)\n        # print(difficulty)\n            \n        m = ind + 1\n            \n        def bins(target):\n            start = 0\n            end = m - 1\n            bsres = 0\n            \n            while start <= end:\n                middle = start + (end - start) // 2\n                \n                if difficulty[middle] == target:\n                    return best_profit[middle]\n                \n                if difficulty[middle] < target:\n                    bsres = best_profit[middle]\n                    start = middle + 1\n                    \n                else:\n                    end = middle - 1\n                    \n            return bsres\n        \n        res = 0\n        h = dict()\n        \n        for w in worker:\n            # if w not in h:\n                # h[w] = bins(w)\n            \n            res += bins(w)\n        \n        return res", "# 20201007 1:23 am ref\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = sorted(zip(difficulty, profit))\n        profit = i = maxprofits = 0\n        for ability in sorted(worker):\n            while i < len(jobs) and ability >= jobs[i][0]:\n                profit = max(jobs[i][1], profit)\n                i += 1\n            maxprofits += profit\n        return maxprofits", "from heapq import *\n\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        worker.sort()\n        difficulty_min_heap = []\n        profit_max_heap = []\n        \n        total = 0\n        \n        for i in range(len(profit)):\n            heappush(difficulty_min_heap, (difficulty[i], i))\n            \n            \n        for w in worker:\n            while difficulty_min_heap and difficulty_min_heap[0][0] <= w:\n                current_difficulty, job_id = heappop(difficulty_min_heap)\n                heappush(profit_max_heap, (-profit[job_id], job_id))\n            if profit_max_heap:\n                total += -profit_max_heap[0][0]\n            \n        return total\n                \n                \n            \n        \n        \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        def binary_search(arr, target):\n            l, r = 0, len(arr) - 1\n            res = -1\n            while l <= r:\n                mid = (l + r) // 2\n                if arr[mid][0] <= target:\n                    res = mid\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            return res        \n        jobs = sorted([d, p] for d,p in zip(difficulty, profit))    \n        for i in range(1,len(jobs)):\n            jobs[i][1] = max(jobs[i][1], jobs[i - 1][1])    \n        res = 0\n        for w in worker:\n            i = binary_search(jobs, w)\n            if i == -1:\n                continue\n            res += jobs[i][1]    \n        return res    ", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        for i in range(len(profit)):\n            difficulty[i] = [difficulty[i], profit[i]]\n        difficulty.sort()\n        for i in range(1, len(profit)):\n            difficulty[i][1] = max(difficulty[i-1][1], difficulty[i][1])\n        \n        def search(d):\n            if d < difficulty[0][0]:\n                return -1\n            l = 0\n            r = len(profit)-1\n            \n            while l < r:\n                m = (l+r+1)//2\n                if difficulty[m][0] <= d:\n                    l = m\n                else:\n                    r = m-1\n            return l\n        \n        res = 0\n        for w in worker:\n            i = search(w)\n            if i >= 0:\n                res += difficulty[i][1]\n        return res\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = [[difficulty[i],profit[i]] for i in range(len(difficulty))]\n        jobs.sort()\n        \n        worker.sort()\n        \n        ans, best ,i = 0, 0,0\n        \n        \n        for skill in worker:\n            while i < (len(jobs)) and skill >= jobs[i][0]:\n                best = max(best,jobs[i][1])\n                i += 1\n            ans += best\n        return ans", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        n = len(worker)\n        jobs =  sorted(zip(difficulty, profit))\n        total = 0\n        best = 0\n        i = 0\n        for ability in sorted(worker):\n            while i < len(jobs) and ability >= jobs[i][0]:\n                best = max(jobs[i][1], best)\n                i += 1\n            total += best\n        return total\n", "class Solution:\n    def maxProfitAssignment(self, d: List[int], p: List[int], work: List[int]) -> int:\n        N, maxd = len(p), max(d)\n        cmb = [(d[i], p[i]) for i in range(N)]\n        cmb.sort()\n        \n        dd = [0]*(maxd+1)\n        val = j = 0\n        for i in range(maxd+1):\n            while j<N and i >= cmb[j][0]:\n                val = max(val, cmb[j][1])\n                j += 1\n            dd[i] = val \n         \n        # print(dd)\n        ans = 0\n        for w in work:\n            if w>maxd:\n                ans += dd[maxd]\n            else:\n                ans += dd[w]\n        \n        return ans", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        _max=max(worker)+1\n        make=[0]*_max\n        num=[(difficulty[i],profit[i])for i in range(len(profit)) if difficulty[i]<_max]\n        num.sort(key=lambda x:x[0])\n        p_max=0\n        for i in range(len(num)):\n            if num[i][1]>=p_max:\n                make[num[i][0]]=num[i][1]\n                p_max=num[i][1]\n        pre=-1\n        for i in range(len(make)):\n            if make[i]!=0:\n                pre=make[i]\n            elif pre!=-1:\n                make[i]=pre\n        ans=0\n        for w in worker:\n            ans+=make[w]\n        return ans ", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        dp = {}\n        for i, d in enumerate(difficulty):\n            dp[d] = max(profit[i], dp.get(d, 0))\n        dp = sorted([ (d,p) for d, p in dp.items() ])\n\n        d2p = []\n        pre = 0\n        for d, p in dp:\n            pre = max(pre, p)\n            d2p.append((d, pre))\n\n        def getjob(work, pv, pw, pi):\n            l, r = 0, len(d2p) - 1\n            if d2p[l][0] > work: return 0, 0 \n            if d2p[r][0] <= work: return d2p[r][1], r\n            l = pi\n\n            while l <= r:\n                i = (l + r) // 2\n                if d2p[i][0] == work:\n                    return max(d2p[i][1], pv), i\n                if d2p[i][0] > work:\n                    r = i - 1\n                else:\n                    l = i + 1\n            if i == r:\n                return max(d2p[i][1], pv), i\n            return max(d2p[i-1][1], pv), i - 1\n\n        rs = 0\n        pv = 0\n        pw = 0\n        pi = 0\n        for w in sorted(worker):\n            pv, pi = getjob(w, pv, pw, pi)\n            pw = w\n            rs += pv\n        return rs", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        dp = {}\n        for i, d in enumerate(difficulty):\n            dp[d] = max(profit[i], dp.get(d, 0))\n        dp = sorted([ (d,p) for d, p in dp.items() ])\n\n        d2p = []\n        pre = 0\n        for d, p in dp:\n            pre = max(pre, p)\n            d2p.append((d, pre))\n\n        def getjob(work):\n            l, r = 0, len(d2p) - 1\n            if d2p[l][0] > work: return 0\n            if d2p[r][0] <= work: return d2p[r][1]\n\n            while l <= r:\n                i = (l + r) // 2\n                if d2p[i][0] == work:\n                    return d2p[i][1]\n                if d2p[i][0] > work:\n                    r = i - 1\n                else:\n                    l = i + 1\n            if i == r:\n                return d2p[i][1]\n            return d2p[i-1][1]\n\n        rs = 0\n        for w in worker:\n            rs += getjob(w)\n        return rs", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        _max=max(worker)+1\n        make=[0]*_max\n        num=[(difficulty[i],profit[i])for i in range(len(profit)) if difficulty[i]<_max]\n        num.sort(key=lambda x:x[0])\n##        x=0\n##        while x<len(num):\n##            if x+1<len(num):\n##                if num[x][1]>num[x+1][1]:\n##                    num.pop(x+1)\n##                else:x+=1\n##            else:break\n        p_max=0\n        for i in range(len(num)):\n            p_max=max(p_max,num[i][1])\n            if num[i][1]>=p_max:make[num[i][0]]=num[i][1]\n        pre=-1\n##        print(make)\n        for i in range(len(make)):\n            if make[i]!=0:\n                pre=make[i]\n            elif pre!=-1:\n                make[i]=pre\n        ans=0\n        for w in worker:\n            ans+=make[w]\n        return ans ", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = sorted([(difficulty[i], profit[i]) for i in range(len(difficulty))], key=lambda x: x[0])\n        worker = sorted(worker)\n        jobPointer = 0\n        workerPointer = 0\n        maxProfit = 0\n        totalProfit = 0\n        while True:\n            if workerPointer >= len(worker):\n                break\n            talent = worker[workerPointer]\n            if jobPointer >= len(jobs) or jobs[jobPointer][0] > talent:\n                totalProfit += maxProfit\n                workerPointer += 1\n            else:\n                if jobs[jobPointer][1] > maxProfit:\n                    maxProfit = jobs[jobPointer][1]\n                jobPointer += 1\n        return totalProfit\n        \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        \n        _max=max(worker)+1\n        make=[0]*_max\n        num=[(difficulty[i],profit[i])for i in range(len(profit)) if difficulty[i]<_max]\n        num.sort(key=lambda x:x[0])\n        x=0\n        while x<len(num):\n            if x+1<len(num):\n                if num[x][1]>num[x+1][1]:\n                    num.pop(x+1)\n                else:x+=1\n            else:break\n        for i in range(len(num)):\n            make[num[i][0]]=num[i][1]\n        pre=-1\n        for i in range(len(make)):\n            if make[i]!=0:\n                pre=make[i]\n            elif pre!=-1:\n                make[i]=pre\n        ans=0\n        for w in worker:\n            ans+=make[w]\n        return ans       \n", "class Solution:\n    def maxProfitAssignment(self, d: List[int], p: List[int], work: List[int]) -> int:\n        maxd = max(d)\n        cmb1 = defaultdict(int)\n        for i in range(len(p)):\n            cmb1[d[i]] = max(cmb1[d[i]], p[i])\n        \n        cmb = sorted(cmb1.items(), key=lambda x: x[0])\n\n        NN = len(cmb)\n        dd = [0]*(maxd+1)\n        val = j = 0\n        for i in range(maxd+1):\n            if j<NN and i == cmb[j][0]:\n                val = max(val, cmb[j][1])\n                j += 1\n            dd[i] = val \n         \n        \n        ans = 0\n        for w in work:\n            if w>maxd:\n                ans += dd[maxd]\n            else:\n                ans += dd[w]\n        \n        return ans", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = sorted(zip(difficulty, profit), key = lambda x: x[0])\n        ans = i = best = 0\n        for skill in sorted(worker):\n            while i < len(jobs) and skill >= jobs[i][0]:\n                best = max(best, jobs[i][1])\n                i += 1\n            ans += best\n        return ans", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        \n        \n        def findProfit(ppl, goodJobs):\n            l=0\n            r=len(goodJobs)-1\n            while l<r-1:\n                test=int((l+r)/2)\n                if goodJobs[test][1]>ppl:\n                    l=test\n                else:\n                    r=test\n            if goodJobs[r][1]>ppl:\n                return 0\n            elif goodJobs[l][1]>ppl:\n                return goodJobs[r][0]\n            return goodJobs[l][0]\n                \n        \n        goodJobs=[]\n        jobs=[(profit[i], difficulty[i]) for i in range(len(difficulty))]\n        jobs=sorted(jobs, key=lambda job:job[0], reverse=True)\n        goodJobs.append(jobs[0])\n        for i in range(1,len(jobs)):\n            if jobs[i][1]<goodJobs[-1][1]:\n                goodJobs.append(jobs[i])\n        ans=0\n        print((goodJobs, worker))\n        for ppl in worker:\n            ans=ans+findProfit(ppl, goodJobs)\n            print(ans)\n        return ans\n         \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = list(zip(difficulty, profit))\n        jobs = sorted(jobs, key=lambda x: x[0])\n        worker.sort()\n        idx = 0\n        ans = 0\n        p = 0\n        for skill in worker:\n            while idx < len(jobs) and jobs[idx][0] <= skill:\n                p = max(p, jobs[idx][1])\n                idx += 1\n            ans += p\n        return ans\n        \n    \n    \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        worker.sort()\n        difprof = [(difficulty[i], profit[i]) for i in range(len(difficulty))]\n        difprof.sort()\n        total = 0\n        \n        index = 0\n        maxProfit = 0\n        for w in worker:\n            while index < len(difprof) and w >= difprof[index][0]:\n                maxProfit = max(maxProfit, difprof[index][1])\n                index += 1\n            \n            total += maxProfit\n        return total\n            \n#         n = len(worker)\n#         dp = [0 for i in range(worker[n - 1]+1)]\n        \n#         index = 0\n#         for i in range(1, len(dp)):\n#             if index < len(difficulty) and i == difficulty[index]:\n#                 dp[i] = max(dp[i-1], profit[index])\n#                 index += 1\n#             else:\n#                 dp[i] = dp[i-1]\n        \n#         total = 0\n#         for w in worker:\n#             total += dp[w]\n            \n#         return total\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        profit = [i[1] for i in sorted(zip(difficulty, profit))]\n        difficulty.sort()\n        for i in range(1, len(profit)):\n            profit[i] = max(profit[i], profit[i-1])\n        difficulty.append(float('inf'))\n        tot = 0\n        for w in range(len(worker)):\n            low = 0\n            high = len(difficulty)-1\n            while low < high:\n                mid = low + (high-low)//2\n                if difficulty[mid] > worker[w]:\n                    high = mid\n                else:\n                    low = mid+1\n            low -= 1\n            if low < 0:\n                continue\n            tot += profit[low]\n        return tot\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = sorted(zip(difficulty, profit))\n        res = i = best = 0\n        for ability in sorted(worker):\n            while i < len(jobs) and ability >= jobs[i][0]:\n                best = max(jobs[i][1], best)\n                i += 1\n            res += best\n        return res", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        mapProfit = dict()\n        for i in range(len(difficulty)):\n            if difficulty[i] in mapProfit:\n                mapProfit[difficulty[i]] = max(mapProfit[difficulty[i]], profit[i])\n            else:\n                mapProfit[difficulty[i]] = profit[i]\n        l = list()\n        maxDiff = max(difficulty)\n        for i in range(maxDiff + 1):\n            if i in mapProfit:\n                l.append(mapProfit[i])\n            else:\n                l.append(0)\n        \n        maxFromBegin = 0\n        for i in range(len(l)):\n            if l[i] < maxFromBegin:\n                l[i] = maxFromBegin\n            else:\n                maxFromBegin = l[i]\n        # print(l)\n        res = 0\n        for work in worker:\n            if work > maxDiff:\n                res += l[-1]\n            else:\n                res += l[work]\n        return res", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        n=len(profit)\n        maxm=max(difficulty)\n        dp=[0]*(1+maxm)\n        for i in range(n):\n            dp[difficulty[i]]=max(dp[difficulty[i]],profit[i])\n        for i in range(1,maxm+1):\n            dp[i]=max(dp[i],dp[i-1])\n        res=0\n\n        for x in worker:\n            if x>maxm:\n                res+=dp[maxm]\n            else:\n                res+=dp[x]\n        return res\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        # Max profits for each level of difficulty.\n        max_diff = max(difficulty)\n        max_profits = [0] * (max_diff + 1)\n        \n        # Set the initial values\n        for diff, profit in zip(difficulty, profit):\n            max_profits[diff] = max(max_profits[diff], profit)\n        \n        # Consider the profit from lower difficulty (ie. diff 1 profit 5 might be better than diff 5 profit 1)\n        for i in range(1, max_diff + 1):\n            max_profits[i] = max(max_profits[i], max_profits[i - 1])\n        \n        # Figure out max profits.\n        pft = 0\n        for wskill in worker:\n            pft += max_profits[max_diff if wskill > max_diff else wskill]\n        \n        return pft\n        \n", "from bisect import bisect_right\n\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        dp = [(d, p) for d, p in zip(difficulty, profit)]\n        dp.sort()\n        G = []\n        C = []\n        for x, y in dp:\n            if not G or G[-1] < x:\n                G.append(x)\n                C.append(y)\n                continue\n            if G[-1] == x:\n                C[-1] = y\n        for y in range(1, len(C)):\n            if C[y-1] > C[y]:\n                C[y] = C[y-1]\n        ans = 0\n        for w in worker:\n            idx = bisect_right(G, w)-1\n            if idx >= 0:\n                ans += C[idx]\n        return ans", "def maximum_profit_for_difficulty(diff_job, difficulty, profit):\n    return max([profit[job] for job in diff_job[difficulty]])\n\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        min_difficulty = min(difficulty)\n        max_difficulty = max(difficulty)\n        least_difficult_job = difficulty.index(min_difficulty)\n        \n        diff_job = defaultdict(list)\n        for i, diff in enumerate(difficulty):\n            diff_job[diff].append(i)\n    \n        max_profit = [maximum_profit_for_difficulty(diff_job, min_difficulty, profit)]\n        for i in range(1, max_difficulty-min_difficulty+1):\n            current_difficulty = i + min_difficulty\n            if current_difficulty in diff_job:\n                current_job_profit = maximum_profit_for_difficulty(diff_job, current_difficulty, profit)\n                max_profit.append(max(max_profit[i-1], current_job_profit))\n            else:\n                max_profit.append(max_profit[i-1])\n\n        result = 0  \n        for ability in worker:\n            if ability >= max_difficulty:\n                result += max_profit[-1]\n            elif ability < min_difficulty:\n                result += 0\n            else:\n                result += max_profit[ability-min_difficulty]\n        return result\n", "# # Fisrt solution\n# def createListOfProfitDiff(profit, difficulty):\n#     profit_diff = []\n#     for i in range(len(profit)):\n#         profit_diff.append((profit[i], difficulty[i]))\n#     return profit_diff\n        \n        \n        \n# class Solution:\n#     def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n#         profit_diff = createListOfProfitDiff(profit, difficulty)\n#         profit_diff.sort(key=lambda x:x[0])\n#         worker2 = sorted(worker)\n\n#         maxprofit = 0\n#         for i in range(len(profit_diff)-1, -1, -1):\n#             for j in range(len(worker2) -1, -1, -1):\n#                 if profit_diff[i][1]> worker2[j]:\n#                     break\n#                 else:\n#                     maxprofit += profit_diff[i][0]\n#                     worker2.pop(j)\n#         return maxprofit\n# Second solution\ndef createListOfProfitDiff(profit, difficulty):\n    profit_diff = []\n    for i in range(len(profit)):\n        profit_diff.append((profit[i], difficulty[i]))\n    return profit_diff\n        \n        \n        \n# class Solution:\n#     def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n#         profit_diff = createListOfProfitDiff(profit, difficulty)\n#         profit_diff.sort(key=lambda x:x[0])\n#         worker2 = sorted(worker)\n\n#         maxprofit = 0\n#         i = len(profit_diff) -1\n#         j = len(worker2)-1\n#         while i<len(profit_diff) and j <len(worker2) and i>-1 and j>-1:\n#             if profit_diff[i][1]> worker2[j]:\n#                 i-=1\n#             else:\n#                 maxprofit += profit_diff[i][0]\n#                 worker2.pop(j)\n#                 j-=1\n#         return maxprofit\n\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        w = sorted(worker)\n        w.reverse()\n        dp = []\n        for i in range(len(profit)):\n            dp.append((profit[i], difficulty[i]))\n        dp.sort(key =  lambda x:x[0])\n        dp.reverse()\n\n        i = 0\n        count = 0\n        for p in dp:\n            while i<len(w) and p[1] <= w[i]:\n                count += p[0]\n                i+=1\n        return count\n                \n", "from itertools import chain\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        li = list(chain(zip(profit, difficulty)))\n        li.sort()\n        cutoffs = [li[-1][1]]\n        profits = [li[-1][0]]\n        for i in range(len(profit)-2, -1, -1):\n            if li[i][1] < cutoffs[0]:\n                cutoffs.insert(0, li[i][1])\n                profits.insert(0, li[i][0])\n        cutoffs.insert(0, 0)\n        profits.insert(0, 0)\n        ans = 0\n        n = len(cutoffs)\n        for ability in worker:\n            l = 0\n            r = n-1\n            while(r >= l):\n                mid = (l + r) // 2\n                if ability == cutoffs[mid]:\n                    break\n                elif ability > cutoffs[mid]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            mid = mid - 1\n            for i in range(3):\n                if mid+1 < n:\n                    if ability >= cutoffs[mid+1]:\n                        mid += 1\n            ans += profits[mid]\n        return(ans)", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        combined = []\n\n        for i in range(len(difficulty)):\n            combined.append((difficulty[i], profit[i]))\n\n        combined = sorted(combined, key=lambda x: x[0])\n        total = 0\n        i = 0\n        best_profit = 0\n        \n        for w in sorted(worker):\n            while i < len(combined) and w >= combined[i][0]:\n                best_profit = max(best_profit, combined[i][1])\n                i += 1\n            \n            # best_profit is the most profit you can get for current worker, if the next worker has the same workload capability, he will do add to the total doing with the same best_profit.\n            total += best_profit\n            \n        return total\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        profit = [i[1] for i in sorted(zip(difficulty, profit))]\n        difficulty.sort()\n        for i in range(1, len(profit)):\n            profit[i] = max(profit[i], profit[i-1])\n        difficulty.append(float('inf'))\n        worker.sort()\n        tot = 0\n        low = 0\n        for w in range(len(worker)):\n            low = 0\n            high = len(difficulty)-1\n            while low < high:\n                mid = low + (high-low)//2\n                if difficulty[mid] > worker[w]:\n                    high = mid\n                else:\n                    low = mid+1\n            low -= 1\n            if low < 0:\n                low = 0\n                continue\n            tot += profit[low]\n        return tot\n", "def maximum_profit_for_difficulty(diff_job, difficulty, profit):\n    return max([profit[job] for job in diff_job[difficulty]])\n\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        min_difficulty = min(difficulty)\n        max_difficulty = max(difficulty)        \n        diff_job = defaultdict(list)\n        for i, diff in enumerate(difficulty):\n            diff_job[diff].append(i)\n    \n        max_profit = [maximum_profit_for_difficulty(diff_job, min_difficulty, profit)]\n        for i in range(1, max_difficulty-min_difficulty+1):\n            current_difficulty = i + min_difficulty\n            if current_difficulty in diff_job:\n                current_job_profit = maximum_profit_for_difficulty(diff_job, current_difficulty, profit)\n                max_profit.append(max(max_profit[i-1], current_job_profit))\n            else:\n                max_profit.append(max_profit[i-1])\n\n        result = 0  \n        for ability in worker:\n            if ability >= max_difficulty:\n                result += max_profit[-1]\n            elif ability < min_difficulty:\n                result += 0\n            else:\n                result += max_profit[ability-min_difficulty]\n        return result\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = list(zip(difficulty, profit))\n        jobs.sort()\n        ans = 0\n        i = 0\n        best = 0\n        for skill in sorted(worker):\n            while i<len(jobs) and skill >= jobs[i][0]:\n                best = max(best, jobs[i][1])\n                i += 1\n            \n            ans += best\n        \n        return ans", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        \n        n=max(worker)\n        s=[0 for i in range(n)]\n        \n        for i in range(len(difficulty)):\n            if difficulty[i]<=n :\n                s[difficulty[i]-1]=max(s[difficulty[i]-1],profit[i])\n        \n        \n        for i in range(1,n):\n            if s[i]<s[i-1]:\n                s[i]=s[i-1]\n        ans=sum([s[worker[i]-1] for i in range(len(worker))])\n        return ans", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        def bs(arr, s, e, target):\n            while s<=e:\n                mid = s+(e-s)//2\n                if arr[mid][0]<=target:\n                    s = mid+1\n                else:\n                    e = mid-1\n            return e\n        \n        arr = []\n        for pd in sorted(zip(difficulty, profit)):\n            if arr and arr[-1][1]>=pd[1]:\n                continue\n            arr.append(pd)\n            \n        res = 0\n        N = len(arr)\n        for w in worker:\n            idx = bs(arr, 0, N-1, w)\n            if idx>=0:\n                res += arr[idx][1]\n            \n        return res", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        n=len(profit)\n        maxm=max(difficulty)\n        dp=[0]*(1+maxm)\n        for i in range(n):\n            dp[difficulty[i]]=max(dp[difficulty[i]],profit[i])\n        for i in range(1,maxm+1):\n            dp[i]=max(dp[i],dp[i-1])\n        res=0\n\n        for x in worker:\n            if x>maxm:\n                res+=dp[maxm]\n            else:\n                res+=dp[x]\n        return res", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        bfb = [0]*max(max(worker),max(difficulty)) # bfb[i] will tell us the best profitting job that is at or below difficulty i+1\n        for diff,prof in sorted(zip(difficulty,profit)):\n            bfb[diff-1] = max(bfb[diff-1],prof)\n        \n        currMax = 0\n        for i in range(len(bfb)):\n            bfb[i] = max(currMax,bfb[i])\n            currMax = bfb[i]\n            \n        # print(bfb)\n        \n        total = 0\n        for w in worker:\n            total += bfb[w-1]\n            \n        return total", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n            difficulty_price = sorted(list(zip(difficulty, profit)), key = lambda x: (x[0], x[1]))    \n            max_prices = []\n            n = -1\n            curr_price = 0\n            for i in range(max(difficulty)+1):\n                if i == difficulty_price[n+1][0]:\n                    n+=1\n                    while n < len(difficulty_price) - 1 and i == difficulty_price[n+1][0]:\n                        n+=1\n                    if difficulty_price[n][1] > curr_price:\n                        curr_price = difficulty_price[n][1]\n                max_prices.append(curr_price)\n            profit_sum = 0\n            for sub_worker in worker:\n                if sub_worker >= len(max_prices):\n                    profit_sum += max_prices[-1]\n                else:\n                    profit_sum += max_prices[sub_worker]\n            return profit_sum", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        #get best profit by difficulty and apply to each worker\n        #init memo table\n        m = max(difficulty)\n        dp = [0] * m\n        for d, p in zip(difficulty, profit):\n            dp[d - 1] = max(dp[d - 1], p) \n        for i in range(1,len(dp)):\n            dp[i] = max(dp[i], dp[i - 1])    \n        return sum([dp[min(w - 1, m - 1)] for w in worker])    \n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        jobs = list(zip(difficulty, profit))\n        jobs.sort()\n        ans = i = best = 0\n        for skill in sorted(worker):\n            while i < len(jobs) and skill >= jobs[i][0]:\n                best = max(best, jobs[i][1])\n                i += 1\n            ans += best\n        return ans", "class Solution:\n  def binarySearch(self, l, r, x, li):\n    if (r - l <= 1):\n      if (li[r] <= x):\n          return r\n      else:\n          return l\n    m = (l + r + 1)//2\n    if (li[m] <= x):\n      return self.binarySearch(m, r, x, li)\n    else:\n      return self.binarySearch(l, m-1, x, li)\n      \n  def maxProfitAssignment(self, difficulty, profit, worker):\n    difficulty.append(0)\n    profit.append(0)\n    jobs = sorted(zip(difficulty, profit))\n    J = len(jobs)\n    jobDifficulty = [j[0] for j in jobs]\n    mostProfit = [jobs[0][1] for j in jobs]\n    for i in range(1, J):\n      mostProfit[i] = max(jobs[i][1], mostProfit[i-1])\n    totProfit = 0\n    for w in worker:\n      maxJob = self.binarySearch(0, J-1, w, jobDifficulty)\n      totProfit += mostProfit[maxJob]\n    return totProfit", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        n = len(profit)\n        maxm = max(difficulty)\n        dp = [0]*(1+maxm)\n        \n        for i in range(n):\n            dp[difficulty[i]] = max(dp[difficulty[i]],profit[i])\n        \n        for i in range(1,maxm+1):\n            dp[i] = max(dp[i],dp[i-1])\n        \n        ans = 0\n        \n        for i in worker:\n            if i > maxm:\n                ans += dp[maxm]\n            else:\n                ans += dp[i]\n        return ans", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        max_v = max(max(difficulty), max(worker))\n        \n        n = len(difficulty)\n        best = {}\n        for i in range(n):\n            d = difficulty[i]\n            p = profit[i]\n            if d not in best:\n                best[d] = p\n            else:\n                best[d] = max(best[d], p)\n        \n        dp = [0] * (max_v + 1)\n        dp[0] = 0\n        for i in range (max_v + 1):\n            p = 0\n            if i in best:\n                p = best[i]\n            dp[i] = max(dp[i - 1], p)\n        \n        s = 0 \n        for d in worker:\n            s += dp[d]\n        return s", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        dp_dict = dict(list(zip(difficulty, profit)))\n        l = len(difficulty)\n        for idx in range(l):\n            d = difficulty[idx]\n            if profit[idx] > dp_dict[d]:\n                dp_dict[d] = profit[idx]\n        dp_items = sorted(list(dp_dict.items()), key=lambda x: x[0])\n        darr = [x[0] for x in dp_items]\n\n        max_p = 0\n        parr = list()\n        for d,p in dp_items:\n            if p > max_p:\n                max_p = dp_dict[d]\n            parr.append(max_p)\n\n        ret = 0\n\n        def get_nearest(w, arr):\n            l = len(arr)\n            if w < arr[0]: return None\n            if w > arr[-1]: return l-1\n\n            def binary_search(w, i, j):\n                if i >= l or j >= l or w < arr[i] or w > arr[j]:\n                    return None\n                if w == arr[i]: return i\n                if w == arr[j]: return j\n                k = (i + j) // 2\n                if arr[k] <= w < arr[k + 1]:\n                    return k\n                prev = binary_search(w, i, k)\n                return binary_search(w, k + 1, j) if prev is None else prev\n\n            return binary_search(w, 0, l - 1)\n\n        for w in worker:\n            floor_idx = get_nearest(w, darr)\n            if floor_idx is not None:\n                ret += parr[floor_idx]\n        return ret\n", "from typing import List\nimport heapq\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        # (-profit[i], difficulty[i])\u7ec4\u6210\u6700\u5c0f\u5806\n        result_profit = 0\n        profit_minus_min_heap = list()\n        for i in range(len(profit) ):\n            heapq.heappush(profit_minus_min_heap, (-profit[i], difficulty[i]) )\n        worker_minus_min_heap = [-worker[i] for i in range( len(worker) )]\n        heapq.heapify(worker_minus_min_heap)\n\n        while len(worker_minus_min_heap)!=0  and len(profit_minus_min_heap)!=0:\n            job_profit, job_difficulty = profit_minus_min_heap[0]\n            job_profit = -job_profit\n            worker_ability = worker_minus_min_heap[0]\n            worker_ability = -worker_ability\n            if worker_ability >= job_difficulty:\n                result_profit += job_profit\n                heapq.heappop( worker_minus_min_heap)\n            else:\n                heapq.heappop( profit_minus_min_heap)\n        \n        return result_profit", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        make=[0]*(10**5)\n        num=[(difficulty[i],profit[i])for i in range(len(profit))]\n        num.sort(key=lambda x:x[0])\n        x=0\n        while x<len(num):\n            if x+1<len(num):\n                if num[x][1]>num[x+1][1]:\n                    num.pop(x+1)\n                else:x+=1\n            else:break\n        for i in range(len(num)):\n            make[num[i][0]]=num[i][1]\n        pre=-1\n        for i in range(len(make)):\n            if make[i]!=0:\n                pre=make[i]\n            elif pre!=-1:\n                make[i]=pre\n##        print(make)\n        ans=0\n        \n        for w in worker:\n            ans+=make[w]\n        return ans\n", "class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        make=[0]*(10**5)\n        num=[(difficulty[i],profit[i])for i in range(len(profit))]\n        num.sort(key=lambda x:x[0])\n        x=0\n        while x<len(num):\n            if x+1<len(num):\n                if num[x][1]>num[x+1][1]:\n                    num.pop(x+1)\n                else:x+=1\n            else:break\n        for i in range(len(num)):\n            make[num[i][0]]=num[i][1]\n        pre=-1\n        for i in range(len(make)):\n            if make[i]!=0:\n                pre=make[i]\n            elif pre!=-1:\n                make[i]=pre\n        ans=0\n        for w in worker:\n            ans+=make[w]\n        return ans    \n", "import numpy as np\nclass Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        direc = np.zeros((len(profit),2))\n        direc[:,0] = difficulty\n        direc[:,1] = profit\n        direc = direc[direc[:,0].argsort()]\n        # print(direc)\n        max_profit = np.array(direc[:,1])\n        for i in range(1,len(profit)):\n            if max_profit[i-1] > direc[i,1]:\n                max_profit[i] = max_profit[i-1]\n        # print(max_profit)\n        result = 0\n        for j in range(len(worker)):\n            # if worker[j] in difficulty:\n            #     ind = np.searchsorted(direc[:,0],worker[j],side = 'Left')\n            # else: ind = np.searchsorted(direc[:,0],worker[j],side = 'Left') - 1\n            ind = np.searchsorted(direc[:,0],worker[j],side = 'Right') - 1\n            # print(ind,max_profit[ind])\n            if ind >-1:result += max_profit[ind]\n        return int(result)"]
["class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        st=[['*',0]]\n        for c in s:\n            if c!=st[-1][0]:\n                st.append([c,1])\n            else:\n                st[-1][1]+=1\n                if st[-1][1]==k:\n                    st.pop()\n        res=''\n        for c,v in st:\n            res+=c*v\n        return res", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        if not s or k == 0:\n            return s\n        \n        stack = [['#', 0]]\n        for c in s:\n            if stack[-1][0] == c:\n                stack[-1][1] += 1\n                if stack[-1][1] == k:\n                    stack.pop()\n            else:\n                stack.append([c, 1])\n        \n\n        return ''.join(c*k for c, k in stack)\n\n        \n        \n", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        res = []\n        char = s[0]\n        count = 1\n\n        for i in range(1, len(s)):\n            if s[i] == char:\n                count += 1\n            else:\n                count = 1\n                char = s[i]\n\n            if count == k:\n                return self.removeDuplicates(s[:i-k+1] + s[i+1:], k)\n            \n        return s", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        if len(s) < k:\n            return s\n        # stack=[]\n        # cnt_stack=[]\n        # for char in s:\n        #     if not stack or stack[-1] !=char:\n        #         stack.append(char)\n        #         cnt_stack.append(1)\n        #     else:\n        #         cnt_stack[-1] +=1\n        #     if cnt_stack[-1] == k:\n        #         cnt_stack.pop()\n        #         stack.pop()\n        # return ''.join([stack[i]*cnt_stack[i] for i in range(len(stack))])\n        stack=[[0,'#']]\n        for char in s:\n            if char == stack[-1][1]:\n                stack[-1][0] +=1\n                if stack[-1][0] == k:\n                    stack.pop()\n            else:\n                stack.append([1,char])\n        return ''.join(c*k for c,k in stack)\n            \n                    \n                \n        \n               \n", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str: \n        \n        unique = set(s)\n        dups = []\n        \n        for c in unique: \n            dups.append(c*k)\n            \n        while True: \n            start = s\n            for c in dups: \n                s = s.replace(c, '')\n                \n            if start == s: \n                return s\n        \n#         ret = list(s) \n        \n#         while True: \n#             s = ret\n#             ret = []\n#             ac = 1\n#             for c in s: \n#                 if not ret or ret[-1] != c: \n#                     ac = 1\n#                     ret.append(c)\n#                 else: \n#                     if ac + 1 == k: \n#                         while ac: \n#                             ret.pop()\n#                             ac -= 1\n#                     else: \n#                         ret.append(c)\n#                         ac += 1\n#                 # print(ret, ac)\n#             if len(ret) == len(s): \n#                 break\n                        \n#         return ''.join(ret)\n                    \n", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        lengths = [[None, 0]]\n        idx = 0\n        \n        while idx < len(s):\n            current = lengths[-1][0]\n            \n            if current == s[idx]:\n                lengths[-1][1] += 1\n            else:\n                lengths.append([s[idx], 1])\n                current = s[idx]\n                \n            if lengths[-1][1] == k:\n                lengths.pop()\n                s = s[:idx - k + 1] + s[idx + 1:]\n                idx -= k\n                \n            idx += 1\n                    \n        return s", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        \n        ret = list(s) \n        \n        while True: \n            s = ret\n            ret = []\n            ac = 1\n            for c in s: \n                if not ret or ret[-1] != c: \n                    ac = 1\n                    ret.append(c)\n                else: \n                    if ac + 1 == k: \n                        while ac: \n                            ret.pop()\n                            ac -= 1\n                    else: \n                        ret.append(c)\n                        ac += 1\n                # print(ret, ac)\n            if len(ret) == len(s): \n                break\n                        \n        return ''.join(ret)\n                    \n", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        \n        \n        count = 1\n        flag = 1\n        last_idx = 0\n        while(1):\n            i = 0\n            temp_s = s\n            while(i < len(s)-1):\n                #print(\\\"i = \\\",i)\n                #print(\\\"s = \\\",s)\n                if(s[i] != s[i+1]):\n                    i = i+1\n                else:\n                    last_idx = i\n                    while(1):\n                        if(i+1 == len(s)):\n                            break \n                        elif(s[i] == s[i+1]):\n                            count = count+1\n                            i = i+1\n                        else:\n                            break \n                    if(count >= k):\n                        s = s[:last_idx] + s[last_idx+k:]\n                        i = last_idx\n                    count = 1\n            if(temp_s == s):\n                break \n        return s", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        while True:\n            stk = []\n            s_new = []\n            for c in s:\n                if len(stk)==k: stk=[]\n                while stk and c!=stk[-1]:\n                    s_new.append(stk.pop())\n                stk.append(c)\n                if len(stk)==k: stk=[]\n            while stk:\n                s_new.append(stk.pop())  \n            print(''.join(s_new))\n            if s==s_new: break\n            s = s_new\n        return ''.join(s)", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        \n        ns = []\n        deleted= True\n        while deleted:\n            deleted = False\n            i = 0\n            ns = []\n            while i < len(s):\n                if i <= len(s) - k and s[i+1:i+k] == s[i]*(k-1):\n                    deleted = True\n                    i += k\n                else:\n                    ns.append(s[i])\n                    i += 1\n            s = ''.join(ns)\n\n        return s", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        \n        def helper(s):\n        \n            ans = []\n        \n            i = 0\n            while i < len(s):\n            \n                if s[i] * k != s[i:i+k]:\n                    ans.append(s[i])\n                    i += 1\n                else:\n                    i += k\n        \n            if len(ans) == len(s):\n                res.append(''.join(ans))\n                return\n            else:\n                helper(''.join(ans))\n\n        res = []\n        helper(s)\n        return res[0]", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        sliced = True\n        while sliced == True:\n            s, sliced = self.getSlices(s, k)\n        return s\n    \n    def getSlices(self, s, k):\n        sliced = False\n        idx = set()\n        i = 0\n        while i < len(s):\n            if s[i]*k == s[i:i+k]:\n                idx.update(range(i, i+k))\n                sliced = True\n                i += k\n            i += 1\n        if sliced:\n            new_str = ''.join([char for i, char in enumerate(s) if i not in idx])\n            return new_str, sliced\n        return s, sliced", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        while True:\n            stk = []\n            s_new = []\n            for c in s:\n                if len(stk)==k: stk=[]\n                while stk and c!=stk[-1]:\n                    s_new.append(stk.pop())\n                stk.append(c)\n                if len(stk)==k: stk=[]\n            while stk:\n                s_new.append(stk.pop())  \n            if s==s_new: break\n            s = s_new\n        return ''.join(s)", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        len_s = len(s)\n        \n        if k > len_s:\n            return s\n        \n        def helper(string, itr_range):\n            not_found = False    #if no k repeating elements found, then True\n            \n            while not not_found:\n                not_found = True\n                \n                for i in range(itr_range):\n                    if string[i:i+k] == string[i]*k:\n                        string = string[:i]+string[i+k:]\n                        itr_range = len(string)-k+1\n                        not_found = False\n                        break\n            return string\n        \n        return helper(s, len_s-k+1)", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        if len(s)<k:\n            return s\n        found = self.findStr(s, k)\n        if not found:\n            return s\n        else:\n            return self.removeDuplicates(s.replace(found, ''), k)\n        \n    def findStr(self, s:str, k:int):\n        for i in range(len(s)):\n            if (s[i]*k) in s:\n                return s[i]*k\n        return None", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        distinct = len(set(s))\n        while len(s) >= k:\n            new_s = ''\n            cur, count = s[0], 1\n            for i in range(1, len(s)):\n                print(cur, count)\n                if s[i] == cur:\n                    count += 1\n                else:\n                    new_s += cur * (count % k)\n                    cur, count = s[i], 1\n            new_s += cur * (count % k)\n            if s == new_s:\n                break\n            s = new_s\n        return s", "\nclass Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        duplicates=[k*i for i in 'abcdefghijklmnopqrstuvwxyz']\n        counter=0\n        while counter!=len(s):\n            counter=len(s)\n            for i in duplicates:\n                s=s.replace(i,'')\n                \n        return s", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n                \n        if not s:\n            return ''\n        \n        stack = []\n        \n        prev = count = None\n        for i in range(0, len(s)):\n            \n            if not prev:\n                prev, count = s[i], 1\n            elif s[i] == prev:\n                count += 1\n            else:\n                stack.append((prev, count))\n                prev = s[i]\n                count = 1\n                \n            if count == k:\n                if stack:\n                    prev, count = stack.pop()\n                else:\n                    prev = None\n            \n            # print(stack, s[i], i, prev, count)\n            \n        stack.append((prev, count))\n        \n        output = ''\n        for e,c in stack:\n            output += e*c\n        \n        return output\n        \n        \n        \n            \n                \n            \n            \n                \n'''\n#check k = 1\n'''", "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n        stack = [['#', 0]]\n        for c in s:\n            if stack[-1][0] == c:\n                stack[-1][1] += 1\n                if stack[-1][1] == k:\n                    stack.pop()\n            else:\n                stack.append([c, 1])\n        return ''.join(c * k for c, k in stack)"]
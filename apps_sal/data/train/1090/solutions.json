["# cook your dish here\n\nimport collections\n\ndef shortestSubarray(A, K):\n  \n  \n  N = len(A)\n  P = [0]\n\n  for x in A:\n   P.append(P[-1] + x)\n\n  #Want smallest y-x with Py - Px >= K\n  ans = N+1 # N+1 is impossible\n  monoq = collections.deque() #opt(y) candidates, represented as indices \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of P\n  for y, Py in enumerate(P):\n   #Want opt(y) = largest x with Px <= Py - K\n   if not monoq: \n    if Py>=K: return 1\n   while monoq and Py <= P[monoq[-1]]:\n    monoq.pop()\n\n   while monoq and Py - P[monoq[0]] >= K:\n    ans = min(ans, y - monoq.popleft())\n\n   monoq.append(y)\n\n  return ans if ans < N+1 else -1\n  \n  \nfor t in range(int(input())):\n N, D = [int(x) for x in input().split()]\n \n A = [int(x) for x in input().split()] \n \n print(shortestSubarray(A, D))\n \n"]
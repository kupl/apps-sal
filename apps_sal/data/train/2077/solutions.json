["from collections import defaultdict\n\ndef solve(n, a, b, xs):\n    group = [None] * n\n    id_ = {x: i for i, x in enumerate(xs)}\n    if a == b:\n        for x in xs:\n            if a - x not in id_:\n                return False\n        group = [0] * n\n    else:\n        for i, x in enumerate(xs):\n            if group[i] is not None:\n                continue\n            y = a - x\n            z = b - x\n            f1 = y in id_ and group[id_[y]] is None\n            f2 = z in id_ and group[id_[z]] is None\n            if f1 + f2 == 0:\n                return False\n            elif f1 + f2 == 1:\n                g = int(f2)\n                # End of link\n                link = []\n                t = a if f1 else b\n                while x in id_:\n                    link.append(x)\n                    x = t - x\n                    if x + x == t:\n                        break\n                    t = a + b - t\n                # print(link)\n                if len(link) % 2 == 0:\n                    for i, x in enumerate(link):\n                        group[id_[x]] = g\n                elif link[0] * 2 == (b, a)[g]:\n                    for i, x in enumerate(link):\n                        group[id_[x]] = 1 - g\n                elif link[-1] * 2 == (a, b)[g]:\n                    for i, x in enumerate(link):\n                        group[id_[x]] = g\n                else:\n                    # Found invalid link, answer is \"NO\"\n                    return False\n\n    return group\n\nn, a, b = list(map(int, input().split()))\nxs = list(map(int, input().split()))\ngroup = solve(n, a, b, xs)\nif isinstance(group, list):\n    print('YES')\n    print(' '.join(map(str, group)))\nelse:\n    print('NO')\n", "class DisjointSet:\n    def __init__(self, n):\n        self._fa = list(range(n))\n\n    def union(self, x, y):\n        x = self.get_father(x)\n        y = self.get_father(y)\n        self._fa[x] = y\n        return y\n\n    def get_father(self, x):\n        y = self._fa[x]\n        if self._fa[y] == y:\n            return y\n        else:\n            z = self._fa[y] = self.get_father(y)\n            return z\n\n    def __repr__(self):\n        return repr([self.get_father(i) for i in range(len(self._fa))])\n\ndef solve(n, a, b, xs):\n    h = {x: i for i, x in enumerate(xs)}\n    if a == b:\n        if all(a - x in h for x in xs):\n            return [0] * n\n        return False\n    g1 = n\n    g2 = n + 1\n    ds = DisjointSet(n + 2)\n\n    for i, x in enumerate(xs):\n        for t in (a, b):\n            if t - x in h:\n                ds.union(i, h[t - x])\n\n    for i, x in enumerate(xs):\n        b1 = (a - x) in h\n        b2 = (b - x) in h\n        if b1 + b2 == 0:\n            return False\n        if b1 + b2 == 1:\n            if b1:\n                ds.union(i, g1)\n            else:\n                ds.union(i, g2)\n            if ds.get_father(g1) == ds.get_father(g2):\n                return False\n    group = [None] * n\n    for i, x in enumerate(xs):\n        f = ds.get_father(i)\n        if f < n:\n            return False\n        group[i] = f - n\n    return group\n\nn, a, b = list(map(int, input().split()))\nxs = list(map(int, input().split()))\ngroup = solve(n, a, b, xs)\nif isinstance(group, list):\n    print('YES')\n    print(' '.join(map(str, group)))\nelse:\n    print('NO')\n", "class DisjointSet:\n    def __init__(self, n):\n        self._fa = list(range(n))\n\n    def union(self, x, y):\n        x = self.get_father(x)\n        y = self.get_father(y)\n        self._fa[x] = y\n        return y\n\n    def get_father(self, x):\n        y = self._fa[x]\n        if self._fa[y] == y:\n            return y\n        else:\n            z = self._fa[y] = self.get_father(y)\n            return z\n\n    def __repr__(self):\n        return repr([self.get_father(i) for i in range(len(self._fa))])\n\ndef solve(n, a, b, xs):\n    h = {x: i for i, x in enumerate(xs)}\n    if a == b:\n        if all(a - x in h for x in xs):\n            return [0] * n\n        return False\n    g1 = n\n    g2 = n + 1\n    ds = DisjointSet(n + 2)\n\n    for i, x in enumerate(xs):\n        for t in (a, b):\n            if t - x in h:\n                ds.union(i, h[t - x])\n\n    for i, x in enumerate(xs):\n        b1 = (a - x) in h\n        b2 = (b - x) in h\n        if b1 + b2 == 0:\n            return False\n        if b1 + b2 == 1:\n            if b1:\n                ds.union(i, g1)\n            else:\n                ds.union(i, g2)\n            if ds.get_father(g1) == ds.get_father(g2):\n                return False\n    group = [None] * n\n    for i, x in enumerate(xs):\n        f = ds.get_father(i)\n        if f < n:\n            return False\n        group[i] = f - n\n    return group\n\nn, a, b = map(int, input().split())\nxs = list(map(int, input().split()))\ngroup = solve(n, a, b, xs)\nif isinstance(group, list):\n    print('YES')\n    print(' '.join(map(str, group)))\nelse:\n    print('NO')", "def find(u):\n    nonlocal par\n    if u != par[u]:\n        par[u] = find(par[u])\n    return par[u]\n\ndef union(u, v):\n    u = find(u)\n    v = find(v)\n    par[u] = v\n\nn, a, b = map(int, input().split())\np = list(map(int, input().split()))\nmp = dict()\nfor i in range(n):\n    mp[p[i]] = i + 1\npar = [i for i in range(n + 2)]\n\nfor i in range(n):\n    union(i + 1, mp.get(a - p[i], n + 1))\n    union(i + 1, mp.get(b - p[i], 0))\n\nA = find(0)\nB = find(n + 1)\n\nif A != B:\n    print('YES')\n    print(' '.join(['1' if find(i) == B else '0' for i in range(1, n + 1)]))\nelse:\n    print('NO')", "MAX = 100001\nparent = []\n\ndef makeSet():\n    nonlocal parent\n    parent = [i for i in range(MAX + 1)]\n\ndef findSet(u):\n    nonlocal parent\n    if u != parent[u]:\n        parent[u] = findSet(parent[u])\n    return parent[u]\n\ndef unionSet(u, v):\n    up = findSet(u)\n    vp = findSet(v)\n    parent[up] = vp\n\nmakeSet()\nn, a, b = map(int, input().split())\np = list(map(int, input().split()))\npos = dict()\nfor i in range(n):\n    pos[p[i]] = i + 1\n\nfor i in range(n):\n    unionSet(i + 1, pos.get(a - p[i], n + 1))\n    unionSet(i + 1, pos.get(b - p[i], 0))\n\nA = findSet(0)\nB = findSet(n + 1)\n\nif A != B:\n    print('YES')\n    for i in range(1, n + 1):\n        if findSet(i) == B:\n            print('1', end = \" \")\n        else:\n            print('0', end = \" \")\nelse:\n    print('NO')\n", "parent = []\nranks = []\n\n\ndef make_set(n):\n    nonlocal parent, ranks\n    parent = [i for i in range(n + 5)]\n    ranks = [0 for i in range(n + 5)]\n\n\ndef find_set(u):\n    if parent[u] != u:\n        parent[u] = find_set(parent[u])\n    else:\n        parent[u] = u\n    return parent[u]\n\n\ndef union_set(u, v):\n    up = find_set(u)\n    vp = find_set(v)\n\n    if ranks[up] > ranks[vp]:\n        parent[vp] = up\n    elif ranks[up] < ranks[vp]:\n        parent[up] = vp\n    else:\n        parent[up] = vp\n        ranks[vp] += 1\n\n\ndef solution():\n    set_indicators = dict()\n    n, a, b = list(map(int, input().split()))\n    numbers = list(map(int, input().split()))\n    A = n + 1\n    B = A + 1\n\n    make_set(n)\n    for i in range(n):\n        set_indicators[numbers[i]] = i\n\n    for i in range(n):\n        if set_indicators.get(a - numbers[i]) is not None:\n            union_set(i, set_indicators.get(a - numbers[i]))\n        else:\n            union_set(i, B)\n        if set_indicators.get(b - numbers[i]) is not None:\n            union_set(i, set_indicators.get(b - numbers[i]))\n        else:\n            union_set(i, A)\n    if find_set(A) == find_set(B):\n        print('NO')\n        return\n\n    print('YES')\n    print(''.join('1 ' if find_set(i) == find_set(n + 2) else '0 ' for i in range(n)))\n\n\nsolution()\n", "def find(u):\n    nonlocal par\n    if u != par[u]:\n        par[u] = find(par[u])\n    return par[u]\n\ndef union(u, v):\n    u = find(u)\n    v = find(v)\n    par[u] = v\n\nn, a, b = map(int, input().split())\np = list(map(int, input().split()))\nmp = dict()\nfor i in range(n):\n    mp[p[i]] = i + 1\npar = [i for i in range(n + 2)]\n\nfor i in range(n):\n    union(i + 1, mp.get(a - p[i], n + 1))\n    union(i + 1, mp.get(b - p[i], 0))\n\nA = find(0)\nB = find(n + 1)\n\nif A != B:\n    print('YES')\n    print(' '.join(['1' if find(i) == B else '0' for i in range(1, n + 1)]))\nelse:\n    print('NO')", "import sys\nfrom collections import defaultdict as dd\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\nn,a,b=I()\nl=I()\ndic=dd(int)\nfor i in range(n):\n\tdic[l[i]]=1\nbs=[]\npa=dd(int)\nfor i in range(n):\n\tif dic[a-l[i]]==0:\n\t\tbs.append(l[i])\n\telse:\n\t\tpa[l[i]]=a-l[i]\nj=0\nwhile j<len(bs):\t\t\n\tfor i in range(j,len(bs)):\n\t\tcr=bs[i]\n\t\tdic[cr]=2\n\t\tif dic[b-cr]==0:\n\t\t\tprint(\"NO\");return\n\t\tdic[b-cr]=2\n\t\tif dic[a-b+cr]==1:\n\t\t\tdic[a-b+cr]=2\n\t\t\tbs.append(a-b+cr)\n\t\tj+=1\n\t\t#ct=0;vt=a-b+cr\n\t\t#while vt!=pa[pa[vt]]:\n\t\t#\tvt=pa[vt];dic[b-vt]=2\n\t\t#\tdic[vt]=2\nan=[0]*n\nfor i in range(n):\n\tan[i]=dic[l[i]]-1\nprint(\"YES\")\nprint(*an)\n", "import sys\nfrom collections import defaultdict as dd\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\nn,a,b=I()\nl=I()\ndic=dd(int)\nfor i in range(n):\n\tdic[l[i]]=1\nbs=[]\npa=dd(int)\nfor i in range(n):\n\tif dic[a-l[i]]==0:\n\t\tbs.append(l[i])\n\telse:\n\t\tpa[l[i]]=a-l[i]\nj=0\nwhile j<len(bs):\t\t\n\tfor i in range(j,len(bs)):\n\t\tcr=bs[i]\n\t\tdic[cr]=2\n\t\tif dic[b-cr]==0:\n\t\t\tprint(\"NO\");return\n\t\tdic[b-cr]=2\n\t\tif dic[a-b+cr]==1:\n\t\t\tdic[a-b+cr]=2\n\t\t\tbs.append(a-b+cr)\n\t\tj+=1\n\t\t#ct=0;vt=a-b+cr\n\t\t#while vt!=pa[pa[vt]]:\n\t\t#\tvt=pa[vt];dic[b-vt]=2\n\t\t#\tdic[vt]=2\nan=[0]*n\nfor i in range(n):\n\tan[i]=dic[l[i]]-1\nprint(\"YES\")\nprint(*an)\n"]
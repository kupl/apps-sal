["import collections\n \n solved_boards = {((1,2,3),(4,5,0)): 0}\n class Solution:\n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         asked = tuple(tuple(row) for row in board)\n         queue = collections.deque([((1,2,3),(4,5,0))])\n         while queue:\n             tboard = queue.popleft()\n             for next_board in next_boards(tboard):\n                 if next_board in solved_boards:\n                     continue\n                 solved_boards[next_board] = solved_boards[tboard] + 1\n                 queue.append(next_board)\n         return solved_boards.get(asked, -1)\n     \n def next_boards(board):\n     board = [list(row) for row in board]\n     zy, zx = find_zero(board)\n     for dy, dx in ((-1, 0), (0, 1), (1, 0), (0, -1)):\n         nzy, nzx = zy + dy, zx +dx\n         if nzy in range(2) and nzx in range(3):\n             board[zy][zx],board[nzy][nzx] = board[nzy][nzx],board[zy][zx]\n             yield tuple(tuple(row) for row in board)\n             board[zy][zx],board[nzy][nzx] = board[nzy][nzx],board[zy][zx]\n \n def find_zero(board):\n     for y, row in enumerate(board):\n         for x, e in enumerate(row):\n             if e == 0:\n                 return y,x", "import heapq\n class Solution:\n     def tupletize(self, board):\n         return  tuple(tuple(row) for row in board)\n     \n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         heap = [(0, self.tupletize(board))]\n         visited = set()\n         target = ((1,2,3), (4,5,0))\n         while heap:\n             new_q = []\n             for dist, b in heap:\n                 if b in visited:\n                     continue\n                 visited.add(b)\n                     \n                 if b == target:\n                     return dist\n                 \n                 x = None\n                 y = None\n                 for i in range(len(b)):\n                     if x is not None: break\n                     for j in range(len(b[i])):\n                         if b[i][j] == 0:\n                             x = i\n                             y = j\n                             break\n                             \n                 for dx, dy in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):\n                     if dx >= 0 and dy >= 0 and dx < len(board) and dy < len(board[dx]):\n                         newboard = list(list(row) for row in b)\n                         newboard[dx][dy], newboard[x][y] = newboard[x][y], newboard[dx][dy]\n                         heapq.heappush(new_q, (dist + 1, self.tupletize(newboard)))\n                 \n             heap = new_q\n         \n         return -1", "class Solution:\n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         possible_moves = {0: [1,3], 1: [0,2,4], 2: [1,5], 3: [0,4], 4: [1,3,5], 5: [2,4]}\n         state = \"\".join([str(x) for x in board[0]]) + \"\".join([str(x) for x in board[1]])\n         \n         seen = {state: 0}\n         q = [[state, state.find(\"0\")]]\n \n         while q and q[0][0] != \"123450\":\n             cur = q.pop(0)\n             for move in possible_moves[cur[1]]:\n                 new_state = [int(x) for x in cur[0]]\n                 new_state[cur[1]], new_state[move] = new_state[move], new_state[cur[1]]\n                 new_state = \"\".join([str(x) for x in new_state])\n                 if new_state not in seen:\n                     seen[new_state] = seen[cur[0]]+1\n                     q.append([new_state, move])\n         return -1 if not q else seen[q[0][0]]", "from functools import reduce\n from collections import deque\n class Solution:\n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         hashtable = {}\n         end, steps = \"123450\", None\n         startstr = ''.join([str(i) for i in board[0]]) + ''.join([str(i) for i in board[1]])\n         options = [[1,3],[0,2,4],[1,5],[0,4],[1,3,5],[2,4]]\n         queue = deque()\n         queue.append([startstr, 0])\n         \n         def move(currstr, moveto, currenti):\n             moving = currstr[moveto]\n             currstr = currstr.replace(moving, '!',)\n             currstr = currstr.replace('0', moving)\n             currstr = currstr.replace('!', '0')\n             return currstr\n         \n         while (len(queue) > 0 and steps == None):\n             currstr = queue.popleft()\n             if currstr[0] == end:\n                 steps = currstr[1]\n                 break\n \n             if currstr[0] not in hashtable:\n                 currenti = currstr[0].find('0')\n                 hashtable[currstr[0]] = True\n                 possibilities = [move(currstr[0], i, currenti) for i in options[currenti]]\n                 for el in possibilities:\n                     queue.append([el, currstr[1] + 1])\n \n         return -1 if steps == None else steps", "from copy import deepcopy\n from collections import deque\n \n class Solution:\n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \n         n, m = len(board), len(board[0])\n \n         def isValid():\n             def getNumberOfInversions():\n                 boardInOneLine = []\n                 for line in board:\n                     for el in line:\n                         if el != 0:\n                             boardInOneLine.append(el)\n \n                 inversions = 0\n                 for i, l in enumerate(boardInOneLine):\n                     for r in boardInOneLine[i+1:]:\n                         inversions += (l > r)\n                 return inversions\n \n             inversions = getNumberOfInversions()\n             if m%2 == 1:\n                 return inversions%2 == 0\n \n             def getBlankRow():\n                 for i, line in enumerate(board):\n                     if 0 in line:\n                         return i\n \n             blankRow = getBlankRow\n             if inversions%2 == 0 and blankRow%2 == 1:\n                 return True\n             if inversions%2 == 1 and blankRow%2 == 0:\n                 return True\n             return False\n         \n         if not isValid():\n             return -1\n \n         def toTuple(mat):\n             return tuple(tuple(line) for line in mat)\n \n         def toList(mat):\n             return list(list(line) for line in mat)\n \n         \n         def getSolution():\n             sol = []\n             for line in range(n):\n                 sol.append([])\n                 for column in range(1,m+1):\n                     sol[-1].append(column+line*m)\n             sol[-1][-1] = 0\n             return toTuple(sol)\n         \n         sol = getSolution()\n         h = deque([(toTuple(board),0)])\n         visited = set()\n         while True:\n             board, count = h.popleft()\n             if board == sol:\n                 return count\n             elif board in visited:\n                 continue\n             visited.add(board)\n             board = toList(board)\n             \n             def findBlack():\n                 for i, line in enumerate(board):\n                     for j, el in enumerate(line):\n                         if el == 0:\n                             return (i,j)\n \n             bx, by = findBlack()\n \n             def isValidPosition(x,y):\n                 return 0 <= x < n and 0 <= y < m\n \n             for dx,dy in ((-1,0),(1,0),(0,-1),(0,1)):\n                 if isValidPosition(dx+bx,dy+by):\n                     nboard = toList(deepcopy(board))\n                     nboard[bx][by], nboard[bx+dx][by+dy] = nboard[bx+dx][by+dy], nboard[bx][by]\n                     h.append((toTuple(nboard),count+1))\n \n \n         return -1\n \n", "class Solution:\n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         from collections import deque as dq\n         curs = \"\".join(map(str,board[0])) + \"\".join(map(str,board[1])) \n         dist, pre = {}, {}\n         dist[curs] = 0\n         q = dq([curs])\n         while q:\n             curs = q.pop()\n             if curs == \"123450\":\n                 while curs in pre:\n                     #print(curs)\n                     curs = pre[curs]\n                 return dist[\"123450\"]\n             #print(\"curs is\" + curs, curs not in dist)\n             ind = curs.index(\"0\")\n             if ind > 0 and ind != 3:\n                 preswap = curs[:ind-1] + '0' + curs[ind-1] + curs[ind+1:]\n                 #print(\"preswap is\" + preswap)\n                 if preswap not in dist:\n                     dist[preswap] = dist[curs] + 1\n                     pre[preswap] = curs\n                     q.appendleft(preswap)\n             if ind < 5 and ind != 2:\n                 afterswap = curs[:ind] + curs[ind+1]  + '0' + curs[ind+2:]\n                 #print(\"afterswap is\" + afterswap)\n                 if afterswap not in dist:\n                     dist[afterswap] = dist[curs] + 1\n                     pre[afterswap] = curs\n                     q.appendleft(afterswap)\n             if ind < 3:\n                 downswap =  curs[:ind] + curs[ind+3] + curs[ind+1:ind+3] + '0' + curs[ind+4:]\n                 #print(\"downswap is\" + downswap)\n                 if downswap not in dist:\n                     dist[downswap] = dist[curs] + 1\n                     pre[downswap] = curs\n                     q.appendleft(downswap)\n             else:\n                 upswap =  curs[:ind-3] + '0' + curs[ind-2:ind] + curs[ind-3]+ curs[ind+1:]\n                 #print(\"upwap is\" + upswap)\n                 if upswap not in dist:\n                     dist[upswap] = dist[curs] + 1\n                     pre[upswap] = curs\n                     q.appendleft(upswap)\n             #print(dist)\n         \n         return -1\n                 \n", "from collections import deque\n \n class Solution:\n     def slidingPuzzle(self, b):\n         seen = set()\n         q = deque()\n         q.append(([1,2,3,4,5,0], 5, 0))\n         while q:\n             u, p, m = q.popleft()\n             if u == b[0] + b[1]:\n                 return m\n             for np in [p-1 if p != 3 else -1, p+1 if p != 2 else -1, p-3, p+3]:\n                 if 0 <= np < 6:\n                     v = u[:]\n                     v[p], v[np] = v[np], v[p]\n                     if tuple(v) not in seen:\n                         seen.add(tuple(v))\n                         q.append((v[:], np, m+1))\n         return -1", "class Solution:\n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         q = collections.deque()\n         steps = collections.defaultdict(int)\n         \n         start = tuple(board[0]+board[1])\n         steps[start] = 0\n         q.append(start)\n         target = (1,2,3,4,5,0)\n         \n         while q:\n             bd = q.popleft()\n             if bd == target:\n                 return steps[bd]\n             ind = bd.index(0)\n             i, j = ind//3, ind % 3\n             for m, n in [[i-1, j], [i+1, j], [i, j-1], [i, j+1]]:\n                 if 0 <= m < 2 and 0 <= n < 3:\n                     move = list(bd)\n                     move[ind], move[m*3+n] = move[m*3+n], move[ind]\n                     new_bd = tuple(move)\n                     if new_bd not in steps or steps[new_bd] > steps[bd] + 1:\n                         q.append(new_bd)\n                         steps[new_bd] = steps[bd] + 1\n         \n         return -1", "from functools import reduce\n from collections import deque\n class Solution:\n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         hashtable, queue, steps = {}, deque(), None\n         startstr = ''.join([str(i) for i in board[0]]) + ''.join([str(i) for i in board[1]])\n         options = [[1,3],[0,2,4],[1,5],[0,4],[1,3,5],[2,4]] # possible locations to switch for each position of 0\n         queue.append([startstr, 0]) # [string to check, current num of steps]\n         \n         # function to switch characters in a string\n         def move(string, moveto, currenti):\n             moving = string[moveto]\n             string = string.replace(moving, 'x',)\n             string = string.replace('0', moving)\n             return string.replace('x', '0')\n         \n         # loop through and add to queue until solution is found or all variations are examined\n         while (len(queue) > 0 and steps == None):\n             curr = queue.popleft()\n             if curr[0] == \"123450\":\n                 steps = curr[1]\n                 break\n             if curr[0] not in hashtable:\n                 currenti = curr[0].find('0')\n                 hashtable[curr[0]] = True\n                 possibilities = [move(curr[0], i, currenti) for i in options[currenti]]\n                 for el in possibilities:\n                     queue.append([el, curr[1] + 1])\n \n         return -1 if steps == None else steps", "from collections import deque\n \n class Solution:\n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         t = tuple(board[0]), tuple(board[1])\n         v,q = set([t]), deque([(t, 0)])\n         \n         def addNeighbor(i, j, a, b, steps):\n             if 0 <= a < 2 and 0 <= b < 3:\n                 board[i][j], board[a][b] = board[a][b], board[i][j]\n                 t = tuple(board[0]), tuple(board[1])\n                 if t not in v:\n                     v.add(t)\n                     q.append((t, steps + 1))\n                 board[i][j], board[a][b] = board[a][b], board[i][j]\n         \n         while q:\n             t, steps = q.popleft()\n             if t == ((1, 2, 3), (4, 5, 0)):\n                 return steps\n             \n             board[0], board[1] = list(t[0]), list(t[1])\n             for i in range(2):\n                 for j in range(3):\n                     if board[i][j] == 0:\n                         addNeighbor(i, j, i - 1, j, steps)\n                         addNeighbor(i, j, i + 1, j, steps)\n                         addNeighbor(i, j, i, j - 1, steps)\n                         addNeighbor(i, j, i, j + 1, steps)\n         \n         return -1", "class Solution:\n     def __init__(self):\n         self.win = [[1,2,3],[4,5,0]]\n         self.lose = [[[1,2,3],[5,4,0]],[[2,1,3],[4,5,0]],[[1,3,2],[4,5,0]],\n                     [[3,0,1],[4,2,5]],[[4,2,3],[1,5,0]],[[1,5,3],[4,2,0]]]\n         \n         \n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         s = 0\n         if board == self.win:\n             return 0\n         to = [board]\n         path = [board]\n         while True:\n             s += 1\n             t = []\n             for x in to:\n                 tmp = self.move(x)\n                 for z in tmp:\n                     if z not in path:\n                         path.append(z)\n                         t.append(z)\n             for y in t:\n                 if (y == self.win):\n                     return s\n                 else:\n                     for z in self.lose:\n                         if z == y:\n                             return -1\n             to = t    \n         return -1\n     \n     def same(self, x, y):\n         for i in range(2):\n             for j in range(3):\n                 if x[i][j] != y[i][j]:\n                     return False\n         return True\n     \n     def copy(self, x):\n         r = []\n         for y in x:\n             r.append(y.copy())\n         return r\n         \n     def move(self, bd):\n         p = self.find(bd)\n         r = []\n         low = p[0] > 0\n         le = p[1] == 0\n         re = p[1] == 2\n         if not le:\n             to = self.copy(bd)\n             to[p[0]][p[1]] = bd[p[0]][p[1]-1]\n             to[p[0]][p[1]-1] = 0\n             r.append(to)\n         if not re:\n             to = self.copy(bd)\n             to[p[0]][p[1]] = bd[p[0]][p[1]+1]\n             to[p[0]][p[1]+1] = 0\n             r.append(to)\n         if low:\n             to = self.copy(bd)\n             to[p[0]][p[1]] = bd[p[0]-1][p[1]]\n             to[p[0]-1][p[1]] = 0\n             r.append(to)\n         else:\n             to = self.copy(bd)\n             to[p[0]][p[1]] = bd[p[0]+1][p[1]]\n             to[p[0]+1][p[1]] = 0\n             r.append(to)        \n         return r\n         \n     def find(self, bd):\n         for i, x in enumerate(bd):\n             if 0 in x:\n                 return (i, x.index(0))", "class Solution:\n     def __init__(self):\n       self.GOAL_STATE = [1, 2, 3, 4, 5, 0]\n   \n     def slidingPuzzle(self, board):\n       \"\"\"\n       :type board: List[List[int]]\n       :rtype: int\n       \"\"\"\n       from itertools import chain\n       seen = set()\n       \n       from collections import deque\n       q = deque()\n       q.append((list(chain.from_iterable(board)), 0))\n       \n       while q:\n         state, dist = q.popleft()\n         seen.add(tuple(state))\n         \n         if state == self.GOAL_STATE:\n           return dist\n         \n         for nextState in self.nextStates(state):\n           if tuple(nextState) not in seen:\n             q.append((nextState, dist + 1))\n       \n       return -1\n       \n     def swap(self, state, i, j):\n       temp = state[i]\n       state[i] = state[j]\n       state[j] = temp\n       \n     def getNeighbors(self, index):\n       neighbors = {0:[1,3], 1:[0, 4, 2], 2: [1,5], 3:[0,4], 4: [3, 1, 5], 5: [4, 2]}\n       return neighbors[index]\n       \n     def nextStates(self, state):\n       states = []\n       zeroIndex = state.index(0)\n       \n       for nei in self.getNeighbors(zeroIndex):\n         nextState = list(state)\n         self.swap(nextState, nei, zeroIndex)\n         states.append(nextState)\n       return states\n \n         \n", "class Solution:\n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         step=0\n         board=tuple(map(tuple,board))\n         q=[board]\n         memo=set([board])\n         while q:\n             q0=[]\n             for b in q:\n                 if b==((1,2,3),(4,5,0)):\n                     return step\n                 for x in range(2):\n                     for y in range(3):\n                         if b[x][y]:\n                             continue\n                         for dx,dy in zip((1,0,-1,0),(0,1,0,-1)):\n                             nx,ny=x+dx,y+dy\n                             if 0<=nx<2 and 0<=ny<3:\n                                 nb=list(map(list,b))\n                                 nb[x][y],nb[nx][ny]=nb[nx][ny],nb[x][y]\n                                 nb=tuple(map(tuple,nb))\n                                 if nb not in memo:\n                                     memo.add(nb)\n                                     q0.append(nb)\n             q=q0\n             step+=1\n         return -1 #\u6ce8\u610f\u6700\u540e\u4e00\u6b65 \u8fd4\u56de\u7684\u662f-1\n                                 \n                             \n", "class Solution:\n     def slidingPuzzle(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         step=0\n         board=tuple(map(tuple,board))\n         q=[board]\n         memo=set([board])\n         while q:\n             q0=[]\n             for b in q:\n                 if b==((1,2,3),(4,5,0)):\n                     return step\n                 for x in range(2):\n                     for y in range(3):\n                         if b[x][y]:\n                             continue\n                         for dx,dy in zip((1,0,-1,0),(0,1,0,-1)):\n                             nx,ny=x+dx,y+dy\n                             if 0<=nx<2 and 0<=ny<3:\n                                 nb=list(map(list,b))\n                                 nb[x][y],nb[nx][ny]=nb[nx][ny],nb[x][y]\n                                 nb=tuple(map(tuple,nb))\n                                 if nb not in memo:\n                                     memo.add(nb)\n                                     q0.append(nb)\n             q=q0\n             step+=1\n         return -1\n                                 \n                             \n"]
["def check_relative(i,j):\n    if is_relative[i]:return\n    if len(land[i].intersection(land[j]))>=k:\n        is_relative[i]=True\n        for ii in range(n):\n            check_relative(ii,i)\n\nn,k=map(int,input().split())\nland=[]\nis_relative=[True]+[False]*(n-1)\nfor i in range(n):\n    p,*q=input().split()\n    land.append(set(map(int,q)))\n\nfor i in range(n):\n    check_relative(i,0)\n        \nprint(is_relative.count(True))", "import sys\nsys.setrecursionlimit(10**9)\n\ndef check_relative(i,j):\n    if is_relative[i]:return\n    if len(land[i].intersection(land[j]))>=k:\n        is_relative[i]=True\n        for ii in range(n):\n            check_relative(ii,i)\n\nn,k=map(int,input().split())\nland=[]\nis_relative=[False]*n\nfor i in range(n):\n    p,*q=input().split()\n    land.append(set(map(int,q)))\n\nfor i in range(n):\n    check_relative(i,0)\n        \nprint(is_relative.count(True))", "def check_relative(i,j):\n    if is_relative[i] or i==j:return\n    if len(land[i].intersection(land[j]))>=k:\n        is_relative[i]=True\n        for ii in range(n):\n            check_relative(ii,i)\n\nn,k=map(int,input().split())\nland=[]\nis_relative=[False]*n\nfor i in range(n):\n    p,*q=input().split()\n    land.append(set(q))\n\nfor i in range(n):\n    check_relative(i,0)\n        \nprint(is_relative.count(True))", "def check_relative(i,j):\n    if is_relative[i]:return\n    if j in direct_relatives[i] or i in direct_relatives[j]:\n        is_relative[i]=True\n        for ii in range(n):\n            check_relative(ii,i)\n\nn,k=map(int,input().split())\nland=[]\nis_relative=[False]*n\n\nfor i in range(n):\n    p,*q=input().split()\n    land.append(set(q))\n\ndirect_relatives={k:set() for k in range(n)}\nfor i in range(n):\n    for j in range(n):\n        if len(land[i].intersection(land[j]))>=k:\n            direct_relatives[i].add(j)\n\nfor i in range(n):\n    check_relative(i,0)\n        \nprint(is_relative.count(True))", "def check_relative(i,j):\n    if is_relative[i]:return\n    if len(land[i].intersection(land[j]))>=k:\n        is_relative[i]=True\n        for ii in range(n):\n            check_relative(ii,i)\n\nn,k=map(int,input().split())\nland=[]\nis_relative=[False]*n\nfor i in range(n):\n    p,*q=input().split()\n    land.append(set(q))\n\nfor i in range(n):\n    check_relative(i,0)\n        \nprint(is_relative.count(True))", "def check_relative(i,j):\n    if is_relative[i]:return\n    if len(land[i].intersection(land[j]))>=2:\n        is_relative[i]=True\n        for ii in range(n):\n            check_relative(ii,i)\n\nn,k=map(int,input().split())\nland=[]\nis_relative=[False]*n\nfor i in range(n):\n    p,*q=input().split()\n    land.append(set(q))\n\nfor i in range(n):\n    check_relative(i,0)\n        \nprint(is_relative.count(True))", "# cook your dish here\nfrom collections import defaultdict\nn, k = list(map(int,input().split()))\nb = []\ndrel = defaultdict(list)\nans = 0\nfor i in range(n):\n    a = list(map(int,input().split()))\n    b.append(set(a[1:]))\nfor i in range(n):\n    for j in range(n):\n        if i != j:\n            m = 0\n            for l in b[j]:\n                if l in b[i]:\n                    m += 1 \n                if m>=k:\n                    drel[i].append(j)\n                    break\nvisited = set()\ndef dfs(node):\n    global ans\n    visited.add(node) \n    for i in drel[node]:\n        if i not in visited:\n            ans += 1\n            dfs(i)\ndfs(0)\nprint(ans+1)", "# cook your dish here\nfrom collections import defaultdict\nn, k = list(map(int,input().split()))\nb = []\ndrel = defaultdict(list)\nans = 0\nfor i in range(n):\n    a = list(map(int,input().split()))\n    b.append(set(a[1:]))\nfor i in range(n):\n    for j in range(n):\n        if i != j:\n            m = 0\n            for l in b[j]:\n                if l in b[i]:\n                    m += 1 \n                if m>=k:\n                    drel[i].append(j)\n                    break\nvisited = set()\ndef dfs(node):\n    global ans\n    visited.add(node) \n    for i in drel[node]:\n        if i not in visited:\n            ans += 1\n            dfs(i)\ndfs(0)\nprint(ans+1)\n\n", "# cook your dish here\nfrom collections import defaultdict\nn, k = list(map(int,input().split()))\nb = []\ndrel = defaultdict(list)\nans = 0\nfor i in range(n):\n    a = list(map(int,input().split()))\n    b.append(set(a[1:]))\nfor i in range(n):\n    for j in range(n):\n        if i != j:\n            m = 0\n            for l in b[j]:\n                if l in b[i]:\n                    m += 1 \n                if m>=k:\n                    drel[i].append(j)\n                    break\nvisited = set()\ndef dfs(node):\n    global ans\n    visited.add(node) \n    for i in drel[node]:\n        if i not in visited:\n            ans += 1\n            dfs(i)\ndfs(0)\nprint(ans+1)\n", "# cook your dish here\nfrom collections import defaultdict\nn, k = list(map(int,input().split()))\nb = []\ndrel = defaultdict(list)\nans = 0\nfor i in range(n):\n    a = list(map(int,input().split()))\n    b.append(a[1:])\nfor i in range(n):\n    for j in range(n):\n        m = 0\n        for l in b[j]:\n            if l in b[i]:\n                m += 1 \n            if m>=k:\n                drel[i].append(j)\n                break\nvisited = set()\ndef dfs(node):\n    global ans\n    visited.add(node) \n    for i in drel[node]:\n        if i not in visited:\n            ans += 1\n            dfs(i)\ndfs(0)\nprint(ans+1)\n", "\ndef dfs(graph,i):\n    visited[i]=True\n    for j in graph[i]:\n        if not visited[j]:\n            dfs(graph,j)\n\nN, K = map(int, input().split())\narr = []\nfor i in range(N):\n    arr.append(list(map(int, input().split())))\nnodes = [[] for _ in range(N)]\nfor i in range(N-1):\n    for j in range(i+1,N):\n        count = len(set(arr[i]).intersection(set(arr[j])))\n        if count>= K:\n            nodes[i].append(j)\n            nodes[j].append(i)\nvisited = [False]*N\ndfs(nodes, 0)\nprint(visited.count(True))\n\n\n\n\n", "# cook your dish here\nfrom collections import defaultdict\ndef friend(i,j,k):\n    counter=0\n    for num in ids[i]:\n        if (j,num) in insieme:\n            counter+=1 \n        if counter==k:\n            break\n    if counter==k:\n        return True\n    return False\n\nn, k =map(int, input().split())\nids=[]\ninsieme=set()\nfor i in range(n):\n    id=list(map(int, input().split()))\n    id=id[1:]\n    for el in id:\n        insieme.add((i,el))\n    ids.append(id)\ngraph=defaultdict(lambda : [])\nfor i in range(n-1):\n    for j in range(i+1, n):\n        if friend(i,j,k):\n            graph[i].append(j)\n            graph[j].append(i)\nvisited=[0]*n \nvisited[0]=1 \nstack=[0]\ncounter=1 \nwhile len(stack)>0:\n    u=stack.pop()\n    for v in graph[u]:\n        if visited[v]==0:\n            visited[v]=1 \n            stack.append(v)\n            counter+=1\nprint(counter)", "n,k=map(int,input().split())\nl=[0]\nvis=[0]*(n+1)\nfor i in range(n):\n    s=list(map(int,input().split(\" \")))\n    l.append(s[1:s[0]+1])\nq=[]\nq.append(1)\nsol=1\nwhile(q!=[]):\n    temp=q[0]\n    q.pop(0)\n    vis[temp]=1\n    for i in range(1,n+1):\n        if(vis[i]==0):\n            l1=len(l[temp])\n            l2=len(l[i])\n            len1=l1+l2\n            slen1=len(set(l[temp]+l[i]))\n            if(len1-slen1>=k):\n                vis[i]=1\n                sol+=1\n                q.append(i)\nprint(sol)        ", "# cook your dish here\ndef find_relatives(list1):\n    global graph,relatives,K\n    temp={}\n    for j in list1:\n        if j not in graph:\n            list1.remove(j)\n    for i in range(len(list1)):\n        temp1 = graph[list1[i]]\n        for j in temp1:\n            try:\n                temp[j] +=1\n            except:\n                temp[j]=1\n    keys = list(temp.keys())\n    rel1=[]\n    for j in range(len(keys)):\n        if temp[keys[j]] >=K:\n            if keys[j] not in relatives:\n                rel1.append(keys[j])\n    return rel1\nfrom collections import defaultdict\nN,K = map(int,input().split())\nlistim=list(map(int,input().split()))\nlistim = listim[1:]\nlistcit=[]\nfor i in range(N-1):\n    temp = list(map(int,input().split()))\n    temp= temp[1:]\n    listcit.append(temp)\ngraph= defaultdict(list)\nfor i in range(len(listcit)):\n    for x in listcit[i]:\n        graph[x].append(i)\nrelatives=[]\nrelatives = set(relatives)\nt1 = find_relatives(listim)\nrel = t1\nfor j in rel:\n    relatives.add(j)\nlength=len(relatives)\ncount=0\nwhile length!= len(relatives) or count==0:\n    length = len(relatives)\n    for i in rel:\n        t1 = find_relatives(listcit[i])\n        rel = t1\n        for j in rel:\n            relatives.add(j)\n    count +=1\nprint(len(relatives)+1)\n\n    ", "# cook your dish here\ndef find_relatives(list1):\n    global graph,relatives,K\n    temp={}\n    for j in list1:\n        if j not in graph:\n            list1.remove(j)\n    for i in range(len(list1)):\n        temp1 = graph[list1[i]]\n        for j in temp1:\n            try:\n                temp[j] +=1\n            except:\n                temp[j]=1\n    keys = list(temp.keys())\n    rel1=[]\n    for j in range(len(keys)):\n        if temp[keys[j]] >=K:\n            if keys[j] not in relatives:\n                rel1.append(keys[j])\n    return rel1\nfrom collections import defaultdict\nN,K = map(int,input().split())\nlistim=list(map(int,input().split()))\nlistim = listim[1:]\nlistcit=[]\nfor i in range(N-1):\n    temp = list(map(int,input().split()))\n    temp= temp[1:]\n    listcit.append(temp)\ngraph= defaultdict(list)\nfor i in range(len(listcit)):\n    for x in listcit[i]:\n        graph[x].append(i)\nrelatives=[]\nt1 = find_relatives(listim)\nrel = t1\nfor j in rel:\n    relatives.append(j)\nlength=len(relatives)\ncount=0\nwhile length!= len(relatives) or count==0:\n    length = len(relatives)\n    for i in rel:\n        t1 = find_relatives(listcit[i])\n        rel = t1\n        for j in rel:\n            relatives.append(j)\n    count +=1\nprint(len(relatives)+1)\n\n    ", "# cook your dish here\ndef find_relatives(list1):\n    global graph,relatives,K\n    temp={}\n    for j in list1:\n        if j not in graph:\n            list1.remove(j)\n    for i in range(len(list1)):\n        temp1 = graph[list1[i]]\n        for j in temp1:\n            try:\n                temp[j] +=1\n            except:\n                temp[j]=1\n    keys = list(temp.keys())\n    rel1=[]\n    for j in range(len(keys)):\n        if temp[keys[j]] >=K:\n            if keys[j] not in relatives:\n                rel1.append(keys[j])\n    return rel1\nfrom collections import defaultdict\nN,K = map(int,input().split())\nlistim=list(map(int,input().split()))\nlistim = listim[1:]\nlistcit=[]\nfor i in range(N-1):\n    temp = list(map(int,input().split()))\n    temp= temp[1:]\n    listcit.append(temp)\ngraph= defaultdict(list)\nfor i in range(len(listcit)):\n    for x in listcit[i]:\n        graph[x].append(i)\nrelatives=[]\nt1 = find_relatives(listim)\nrel = t1\nfor j in rel:\n    relatives.append(j)\nwhile len(rel)!=0:\n    for i in rel:\n        t1 = find_relatives(listcit[i])\n        rel = t1\n        for j in rel:\n            relatives.append(j)\nprint(len(relatives)+1)\n\n    ", "def is_relative(a,b):\n    global K\n    if len(a.intersection(b))>=K:\n        return True\n    else:\n        return False\n\ndef getval():\n    waste,*v=map(int,input().split())\n    return set(v)\n\nN,K=map(int,input().split())\np=getval()\ncitizens=[]\nrel=[]\n\nfor _ in range(N-1):\n    citizens.append(getval())\n\nfor citizen in citizens:\n    if is_relative(p,citizen):\n        rel.append(citizen)\n        citizens.remove(citizen)\n#print(rel)\nfor relative in rel:\n    for citizen in citizens:\n        if is_relative(relative,citizen):\n            rel.append(citizen)\n            #print(rel)\n            citizens.remove(citizen)\nprint(len(rel)+1)\n", "# import all important libraries and inbuilt functions\n\nfrom fractions import Fraction\nimport numpy as np\nimport sys,bisect,copyreg,copy,statistics,os\nfrom math import *\nfrom collections import Counter,defaultdict,deque,OrderedDict   \nfrom itertools import combinations,permutations,accumulate,groupby \nfrom numpy.linalg import matrix_power as mp\nfrom bisect import bisect_left,bisect_right,bisect,insort,insort_left,insort_right\nfrom statistics import mode\nfrom functools import reduce,cmp_to_key \nfrom io import BytesIO, IOBase\nfrom scipy.spatial import ConvexHull\nfrom heapq import *\nfrom decimal import *\nfrom queue import Queue,PriorityQueue\nfrom re import sub,subn\n\n# end of library import\n\n# map system version faults\nif sys.version_info[0] < 3:\n    from builtins import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n# template of many functions used in competitive programming can add more later \n# based on need we will use this commonly.\n\n# bfs in a graph\ndef bfs(adj,v): # a schema of bfs\n    visited=[False]*(v+1);q=deque()\n    while q:pass\n\n# definition of vertex of a graph\ndef graph(vertex): return [[] for i in range(vertex+1)]\n\ndef powermodulo(x, y, p) : \n    res = 1;x = x % p        \n    if (x == 0) : return 0  \n    while (y > 0) : \n        if ((y & 1) == 1) :   res = (res * x) % p \n        y = y >> 1 \n        x = (x * x) % p           \n    return res\n\ndef lcm(a,b): return (a*b)//gcd(a,b)\n\n# most common list in a array of lists\ndef most_frequent(List):return Counter(List).most_common(1)[0][0]\n\n# element with highest frequency\ndef most_common(List):return(mode(List))\n\n#In number theory, the Chinese remainder theorem states that \n#if one knows the remainders of the Euclidean division of an integer n by \n#several integers, then one can determine uniquely the remainder of the \n#division of n by the product of these integers, under the condition \n#that the divisors are pairwise coprime.\ndef chinese_remainder(a, p):\n    prod = reduce(op.mul, p, 1);x = [prod // pi for pi in p]\n    return sum(a[i] * powermodulo(x[i], p[i] - 2, p[i]) * x[i] for i in range(len(a))) % prod\n\n# make a matrix\ndef createMatrix(rowCount, colCount, dataList):   \n    mat = []\n    for i in range (rowCount):\n        rowList = []\n        for j in range (colCount):\n            if dataList[j] not in mat:rowList.append(dataList[j])\n        mat.append(rowList) \n    return mat\n\n# input for a binary tree\ndef readTree(): \n    v=int(inp());adj=[set() for i in range(v+1)]\n    for i in range(v-1):u1,u2=In(); adj[u1].add(u2);adj[u2].add(u1)\n    return adj,v\n    \n# sieve of prime numbers    \ndef sieve():\n    li=[True]*1000001;li[0],li[1]=False,False;prime=[]\n    for i in range(2,len(li),1):\n        if li[i]==True:\n            for j in range(i*i,len(li),i):li[j]=False    \n    for i in range(1000001):\n        if li[i]==True:prime.append(i)\n    return prime\n\n#count setbits of a number.\ndef setBit(n):\n    count=0\n    while n!=0:n=n&(n-1);count+=1\n    return count\n\n# sum of digits of a number\ndef digitsSum(n):\n    if n == 0:return 0\n    r = 0\n    while n > 0:r += n % 10;n //= 10\n    return r\n\n# ncr efficiently\ndef ncr(n, r):\n    r = min(r, n - r);numer = reduce(op.mul, list(range(n, n - r, -1)), 1);denom = reduce(op.mul, list(range(1, r + 1)), 1)\n    return numer // denom  # or / in Python 2\n\n#factors of a number\ndef factors(n):return list(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\n\n#prime fators of a number\ndef prime_factors(n):\n    i = 2;factors = []\n    while i * i <= n:\n        if n % i:i += 1\n        else:n //= i;factors.append(i)\n    if n > 1:factors.append(n)\n    return len(set(factors))\n\ndef prefixSum(arr):\n    for i in range(1, len(arr)):arr[i] = arr[i] + arr[i-1]\n    return arr    \n\ndef binomial_coefficient(n, k):\n    if 0 <= k <= n:\n        ntok = 1;ktok = 1\n        for t in range(1, min(k, n - k) + 1):ntok *= n;ktok *= t;n -= 1\n        return ntok // ktok\n    else:return 0\n \ndef powerOfK(k, max):\n    if k == 1:return [1]\n    if k == -1:return [-1, 1] \n    result = [];n = 1\n    while n <= max:result.append(n);n *= k\n    return result\n\n# maximum subarray sum use kadane's algorithm\ndef kadane(a,size):\n    max_so_far = 0;max_ending_here = 0 \n    for i in range(0, size):\n        max_ending_here = max_ending_here + a[i]\n        if (max_so_far < max_ending_here):max_so_far = max_ending_here \n        if max_ending_here < 0:max_ending_here = 0\n    return max_so_far                                    \n                  \ndef divisors(n):\n    result = []\n    for i in range(1,ceil(sqrt(n))+1):\n        if n%i == 0:\n            if n/i == i:result.append(i)\n            else:result.append(i);result.append(n/i)\n    return result\n\ndef sumtilln(n): return ((n*(n+1))//2)\n\ndef isPrime(n) : \n\tif (n <= 1) :return False\n\tif (n <= 3) :return True\n\tif (n % 2 == 0 or n % 3 == 0) :return False\n\tfor i in range(5,ceil(sqrt(n))+1,6):\n\t\tif (n % i == 0 or n % (i + 2) == 0) :return False\n\treturn True\n\ndef isPowerOf2(n):\n    while n % 2 == 0:n //= 2\n    return (True if n == 1 else False)\n\ndef power2(n):\n    k = 0\n    while n % 2 == 0:k += 1;n //= 2\n    return k\n\ndef sqsum(n):return ((n*(n+1))*(2*n+1)//6)\n    \ndef cusum(n):return ((sumn(n))**2)\n\ndef pa(a):\n    for i in range(len(a)):print(a[i], end = \" \")\n    print()\n\ndef pm(a,rown,coln):\n    for i in range(rown):\n        for j in range(coln):print(a[i][j],end = \" \")\n        print()\n\ndef pmasstring(a,rown,coln):\n    for i in range(rown):\n        for j in range(coln):print(a[i][j],end = \"\")\n        print()\n        \ndef isPerfectSquare(n):return pow(floor(sqrt(n)),2) == n\n\ndef nC2(n,m):return (((n*(n-1))//2) % m)\n\ndef modInverse(n,p):return powermodulo(n,p-2,p)\n\ndef ncrmodp(n, r, p):  \n\tnum = den = 1\n\tfor i in range(r):num = (num * (n - i)) % p ;den = (den * (i + 1)) % p \n\treturn (num * powermodulo(den,p - 2, p)) % p \n\ndef reverse(string):return \"\".join(reversed(string))        \n\ndef listtostr(s):return ' '.join([str(elem) for elem in s]) \n\ndef binarySearch(arr, l, r, x): \n\twhile l <= r: \n\t\tmid = l + (r - l) // 2; \n\t\tif arr[mid] == x:return mid \n\t\telif arr[mid] < x:l = mid + 1\n\t\telse:r = mid - 1\n\treturn -1\n\ndef isarrayodd(a):\n    r = True\n    for i in range(len(a)):\n        if a[i] % 2 == 0:\n            r = False\n            break\n    return r\n\ndef isPalindrome(s):return s == s[::-1] \n\ndef gt(x,h,c,t):return ((x*h+(x-1)*c)/(2*x-1))\n\ndef CountFrequency(my_list): \n    freq = {} \n    for item in my_list:freq[item] = (freq[item] + 1 if (item in freq) else 1)\n    return freq\n\ndef CountFrequencyasPair(my_list1,my_list2,freq): \n    for item in my_list1:freq[item][0] = (freq[item][0] + 1 if (item in freq) else 1)\n    for item in my_list2:freq[item][1] = (freq[item][1] + 1 if (item in freq) else 1)     \n    return freq \n \ndef binarySearchCount(arr, n, key):   \n    left = 0;right = n - 1;count = 0  \n    while (left <= right):  \n        mid = int((right + left) / 2) \n        if (arr[mid] <= key):count,left = mid + 1,mid + 1\n        else:right = mid - 1      \n    return count\n\ndef primes(n):\n  sieve,l = [True] * (n+1),[]\n  for p in range(2, n+1):\n    if (sieve[p]):\n      l.append(p)\n      for i in range(p, n+1, p):sieve[i] = False\n  return l\n\ndef Next_Greater_Element_for_all_in_array(arr): \n\ts,n,reta,retb = list(),len(arr),[],[];arr1 = [list([0,i]) for i in range(n)]\n\tfor i in range(n - 1, -1, -1): \n\t\twhile (len(s) > 0 and s[-1][0] <= arr[i]):s.pop() \n\t\tif (len(s) == 0):arr1[i][0] = -1\t\t\t\t\t\n\t\telse:arr1[i][0] = s[-1]\t \n\t\ts.append(list([arr[i],i]))\t\t\n\tfor i in range(n):reta.append(list([arr[i],i]));retb.append(arr1[i][0])\n\treturn reta,retb\n\ndef polygonArea(X,Y,n):   \n    area = 0.0;j = n - 1\n    for i in range(n):area += (X[j] + X[i]) * (Y[j] - Y[i]);j = i   \n    return abs(area / 2.0)\n\ndef merge(a, b):\n\tans = defaultdict(int)\n\tfor i in a:ans[i] += a[i]\n\tfor i in b:ans[i] += b[i]\n\treturn ans\n \n#defining a LRU Cache\n# where we can set values and get values based on our requirement\nclass LRUCache: \n\t# initialising capacity \n\tdef __init__(self, capacity: int): \n\t\tself.cache = OrderedDict() \n\t\tself.capacity = capacity \n\n\t# we return the value of the key \n\t# that is queried in O(1) and return -1 if we \n\t# don't find the key in out dict / cache. \n\t# And also move the key to the end \n\t# to show that it was recently used. \n\tdef get(self, key: int) -> int: \n\t\tif key not in self.cache:return -1\n\t\telse:self.cache.move_to_end(key);return self.cache[key] \n\n\t# first, we add / update the key by conventional methods. \n\t# And also move the key to the end to show that it was recently used. \n\t# But here we will also check whether the length of our \n\t# ordered dictionary has exceeded our capacity, \n\t# If so we remove the first key (least recently used) \n\tdef put(self, key: int, value: int) -> None: \n\t\tself.cache[key] = value;self.cache.move_to_end(key) \n\t\tif len(self.cache) > self.capacity:self.cache.popitem(last = False)\n\nclass segtree:\n    def __init__(self,n):\n        self.m = 1\n        while self.m < n:self.m *= 2\n        self.data = [0] * (2 * self.m)\n    def __setitem__(self,i,x):\n        x = +(x != 1);i += self.m;self.data[i] = x;i >>= 1\n        while i:self.data[i] = self.data[2 * i] + self.data[2 * i + 1];i >>= 1\n    def __call__(self,l,r):\n        l += self.m;r += self.m;s = 0\n        while l < r:\n            if l & 1:s += self.data[l];l += 1\n            if r & 1:r -= 1;s += self.data[r]\n            l >>= 1;r >>= 1\n        return s        \n\nclass FenwickTree:\n  def __init__(self, n):self.n = n;self.bit = [0]*(n+1)  \n  def update(self, x, d):\n    while x <= self.n:self.bit[x] += d;x += (x & (-x))  \n  def query(self, x):\n    res = 0\n    while x > 0:res += self.bit[x];x -= (x & (-x))\n    return res\n  def range_query(self, l, r):return self.query(r) - self.query(l-1)        \n# can add more template functions here\n    \n# end of template functions\n\n# To enable the file I/O i the below 2 lines are uncommented.\n# read from in.txt if uncommented\nif os.path.exists('in.txt'): sys.stdin=open('in.txt','r')\n# will print on Console if file I/O is not activated\n#if os.path.exists('out.txt'): sys.stdout=open('out.txt', 'w')\n\n# inputs template\n#for fast input we areusing sys.stdin\ndef inp(): return sys.stdin.readline().strip()\n\n#for fast output, always take string\ndef out(var): sys.stdout.write(str(var))  \n\n# cusom base input needed for the program\ndef I():return (inp())\ndef II():return (int(inp()))\ndef FI():return (float(inp()))\ndef SI():return (list(str(inp())))\ndef MI():return (map(int,inp().split()))\ndef LI():return (list(MI()))\ndef SLI():return (sorted(LI()))\ndef MF():return (map(float,inp().split()))\ndef LF():return (list(MF()))\ndef SLF():return (sorted(LF()))\n\n# end of inputs template\n\n# common modulo values used in competitive programming\nMOD = 998244353\nmod = 10**9+7\n\n# any particular user-defined functions for the code.\n# can be written here.  \n \n# end of any user-defined functions\n\n# main functions for execution of the program.\ndef __starting_point():  \n    # execute your program from here.\n    # start your main code from here\n        \n    # Write your code here\n    n,k = MI()\n    x = []\n    for ii in range(n):\n        x.append(set(LI()[1:]))\n    v = {}\n    v[0] = True\n    q = [x[0]]\n    for ele in q:\n        for j in range(n):\n            if not v.get(j,False):\n                if len(ele.intersection(x[j])) >= k :\n                    q.append(x[j])\n                    v[j] = True\n    print(len(q))\n                                    \n    # end of main code\n    # end of program\n\n# This program is written by :\n#   Shubham Gupta\n#   B.Tech (2019-2023)\n#   Computer Science and Engineering,\n#   Department of EECS\n#   Contact No:8431624358\n#   Indian Institute of Technology(IIT),Bhilai\n#   Sejbahar,\n#   Datrenga,\n#   Raipur,\n#   Chhattisgarh\n#   492015\n\n#   THANK YOU FOR \n#YOUR KIND PATIENCE FOR READING THE PROGRAM.    \n__starting_point()", "n,k=map(int, input().split())\r\nids=[]\r\npr=list(map(int, input().split()))\r\npr.pop(0)\r\nrelatives=[]\r\n\r\ndef common_member(a, b): \r\n    a_set = set(a) \r\n    b_set = set(b) \r\n    return len(a_set.intersection(b_set))\r\n\r\nfor _ in range(n-1):\r\n    ids.append(list(map(int, input().split())))\r\nfor i in ids:\r\n    i.pop(0)\r\n\r\nfor i in ids:\r\n    if common_member(pr,i)>=k:\r\n        relatives.append(i)\r\n        ids.remove(i)\r\ny=1\r\nwhile y>=0:\r\n    y=0\r\n    for x in relatives:\r\n        for i in ids:\r\n            if common_member(x,i)>=k:\r\n                relatives.append(i)\r\n                ids.remove(i)\r\n                y+=1\r\n    if y==0:\r\n        y=-1\r\n\r\nprint(len(relatives)+1)", "n1 = input()\n# k = int(input())\nn, k = map(int, n1.split())\nmain_lot = []\nrel_mat = []\nfor i in range(n):\n    x1 =[]\n    for j in range(n):\n        x1.append(0)\n    rel_mat.append(x1)\nfor i in range(n):\n    # print(i)\n    rel_mat[i][i] = 1\n# print(rel_mat)\nfor gen in range(n):\n    length1 = list(map(int, input().split()))\n    length1 = length1[1:]\n    # print(length1)\n    for lits in range(len(main_lot)):\n        independentcunt = 0\n        # main_lot[lits]\n        for everyele in range(len(length1)):\n            # length1[everyele]\n            if length1[everyele] in main_lot[lits]:\n                independentcunt += 1\n        # print(independentcunt)\n        if independentcunt>=k:\n            rel_mat[gen][lits] = rel_mat[lits][gen] = 1\n            pass\n    main_lot.append(length1)\n    pass\n\n\n# print(n)\n# print(k)\n\n# print(main_lot)\n# print(rel_mat)\nfami_ly = []\nunfam_ily = []\ni1te = 0\n\n\n\n\n\n\nwhile i1te<5:\n    new_ele_rel = []\n    for ele in rel_mat:\n        temp1 = []\n        for el1 in ele:\n            temp1.append(el1)\n        new_ele_rel.append(temp1)\n    i1te+=1\n    for lists1 in range(len(rel_mat)):\n        \n        unfam_ily = [i2 for i2 in range(n)]\n        fami_ly = [i1 for i1 in range(len(rel_mat[lists1])) if rel_mat[lists1][i1] == 1 ]\n        fami_ly.remove(lists1)\n        unfam_ily.remove(lists1)\n        for tem1 in fami_ly:\n            unfam_ily.remove(tem1)\n        unfami_ly = [i2 for i2 in range(len(rel_mat[lists1])) if rel_mat[lists1][i2] == 0 ]\n\n        for iter1 in fami_ly:\n            for iter2 in unfam_ily:\n                if new_ele_rel[iter1][iter2] == 1:\n                    # print(\"did reach\")\n\n                    new_ele_rel[iter2][lists1] = 1\n                    new_ele_rel[lists1][iter2] = 1\n                    # print(new_ele_rel[lists1][iter1])\n                    # print(iter1,lists1)\n                    # print(new_ele_rel)\n\n                    pass \n                pass \n        #     pass\n        # print(fami_ly)\n        # print(unfam_ily)\n        fami_ly = []\n        unfam_ily = []\n\n        # print(rel_mat)\n\n\n\ncount = sum(new_ele_rel[0])\nprint(count)\n\n\n\n", "from collections import defaultdict\r\ndef dfs(graph,i):\r\n    visited[i]=True\r\n    for j in graph[i]:\r\n        if not visited[j]:\r\n            dfs(graph,j)\r\nn,k=map(int,input().split())\r\narr=[]\r\nfor i in range(n):\r\n    arr.append(list(map(int,input().split()))[1:])\r\ngraph=defaultdict(list)\r\nfor i in range(n):\r\n    for j in range(i+1,n):\r\n        c=len(set(arr[i]).intersection(set(arr[j])))\r\n        if c>=k:\r\n            graph[i].append(j)\r\n            graph[j].append(i)\r\nvisited=[False]*n\r\ndfs(graph,0)\r\nprint(visited.count(True))", "n,k = map(int,input().split())\r\nx = []\r\n\r\nfor _ in range(n):\r\n\tx.append(set([int(w) for w in input().split()][1:]))\r\n\r\n# using bfs\r\n\r\nvis = {}\r\nvis[0] = True\r\nq = [x[0]]\r\n\r\nfor ele in q:\r\n\tfor j in range(n):\r\n\t\tif not vis.get(j,False):\r\n\t\t\tif len(ele.intersection(x[j])) >= k:\r\n\t\t\t\tq.append(x[j])\r\n\t\t\t\tvis[j] = True\r\n\r\n#ct = dfs(0,x[0],0,vis)\r\n\r\nprint(len(q))\r\n\r\n\r\n", "import sys\r\ndef dfs(adj, n):\r\n    vis[n]=True\r\n    for i in adj[n]:\r\n        if vis[i]==False:\r\n            dfs(adj,i)\r\n        \r\nsys.setrecursionlimit(10**9) \r\nn,k=map(int,input().split())\r\na=[]\r\nfor i in range(n):\r\n    t=list(map(int,input().split()))\r\n    a.append(t[1:])\r\nadj=[]\r\nglobal vis\r\nvis=[False]*n\r\nfor i in range(n):\r\n    adj.append([])\r\nfor i in range(n):\r\n    for j in range(i+1,n):\r\n        c=len(set(a[i]).intersection(set(a[j])))\r\n        if c>=k:\r\n              adj[i].append(j)\r\n              adj[j].append(i)\r\ndfs(adj,0)\r\nc=0\r\nfor i in range(0,n):\r\n    if vis[i]==True:\r\n        c+=1\r\nprint(c)\r\n\r\n\r\n", "(n,k2) = map(int,input().split())\r\n\r\nl=[]\r\nfor i in range(n):\r\n    t=input().split()\r\n    t = [int(x) for x  in t]\r\n    l.append([])\r\n    l[i]=t[1:]\r\n# print(l)\r\n\r\ntotal=1\r\nans= set(l[0])\r\nnotPres=[]\r\nfor i in l[1:]:\r\n    count=0;\r\n    temp = []\r\n    for j in i:\r\n        if j in ans:\r\n            count+=1;\r\n    if count>=k2:\r\n        total+=1\r\n        for j in i:\r\n            ans.add(j);\r\n        index=[];indC=0;\r\n        for k in notPres:\r\n            c=0\r\n            for l in k:\r\n                if l in ans:\r\n                    c+=1;\r\n            if c>=k2:\r\n                total+=1\r\n                for l in k:\r\n                    ans.add(l)\r\n                index.append(indC)\r\n            indC+=1\r\n        for i in index:\r\n            notPres[i]=[]\r\n    else:\r\n        notPres.append(i)\r\nfor i in notPres:\r\n    c=0\r\n    for l in i:\r\n        if l in ans:\r\n            c+=1;\r\n            if c>=k2:\r\n                total+=1\r\n                for l in k:\r\n                    ans.add(l)\r\n    #print(notPres)\r\nprint(total)\r\n", "(n,k2) = map(int,input().split())\r\n\r\nl=[]\r\nfor i in range(n):\r\n    t=input().split()\r\n    t = [int(x) for x  in t]\r\n    l.append([])\r\n    l[i]=t[1:]\r\n# print(l)\r\n\r\ntotal=1\r\nans= set(l[0])\r\nnotPres=[]\r\nfor i in l[1:]:\r\n    count=0;\r\n    temp = []\r\n    for j in i:\r\n        if j in ans:\r\n            count+=1;\r\n    if count>=k2:\r\n        total+=1\r\n        for j in i:\r\n            ans.add(j);\r\n        index=0;\r\n        for k in notPres:\r\n            c=0\r\n            for l in k:\r\n                if l in ans:\r\n                    c+=1;\r\n            if c>=k2:\r\n                total+=1\r\n                for l in k:\r\n                    ans.add(l)\r\n                notPres[index]=[]\r\n            index+=1\r\n    else:\r\n        notPres.append(i)\r\nfor i in notPres:\r\n    c=0\r\n    for l in i:\r\n        if l in ans:\r\n            c+=1;\r\n            if c>=k2:\r\n                total+=1\r\n                for l in k:\r\n                    ans.add(l)\r\n    #print(notPres)\r\nprint(total)\r\n"]
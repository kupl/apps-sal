["class Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        s = 0\n        m = n\n        while m:\n            s += m & 1\n            m >>= 1\n\n        k = 1\n        while s:\n            s -= bool(n & k)\n            n ^= (s & 1) and k\n            k <<= 1\n\n        return n", "class Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        ans = 0\n        while n:\n            ans^=n\n            n//=2\n        \n        return ans\n", "class Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        if n <= 1: return n\n        b = int(math.log2(n)) + 1        \n        return ((1 << b)-1) - self.minimumOneBitOperations(n - (1 << (b-1)))        ", "class Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        result = 0\n        while n:\n            result = ((n & -n) << 1) - 1 - result\n            n -= n & -n\n        return result", "from functools import lru_cache\n\n# removehigh = [(1 << l) - 1 for l in range(31)]\n@lru_cache()\ndef removehigh(l: int) -> int:\n    if l <= 1:\n        return l + 1\n    return (1 << l)\n    \n@lru_cache()\ndef sethigh(l: int, n: int) -> int:\n    if n == 0:\n        return removehigh(l) - 1\n    \n    t2 = 1 << l - 2\n    \n    if n >= t2:\n        return removehigh(l - 1) + remove(n - t2)\n    \n    if n & (n - 1) == 0:\n        return removehigh(l) - removehigh(n.bit_length())\n    \n    return removehigh(l - 1) + sethigh(l - 1, n) \n\n    \n@lru_cache()\ndef remove(n: int) -> int:\n    if n <= 1:\n        return n\n    elif n <= 3:\n        return 5 - n\n    \n    l = n.bit_length()\n    if n & (n - 1) == 0:\n        return removehigh(l) - 1\n    \n    t3 = 3 << l - 2\n    if n >= t3:\n        return removehigh(l - 1) + remove(n - t3)\n    \n    t1 = 1 << l - 1\n    return removehigh(l - 1) + sethigh(l - 1, n - t1) \n\n\n\nclass Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        return remove(n)\n", "class Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        \n        ans = 0\n        \n        while n>0:\n            ans = ans^n\n        \n            n = n>>1\n        \n        return ans", "class Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        tot = 0\n        \n        b = bin(n)[2:]\n        if b[1] == '0':\n            tot += 2**(len(b)-2)\n            \n        lastChanged = b[1] == '0'\n        for i in range(2,len(b)):\n            if (lastChanged and b[i] == '0') or (not lastChanged and b[i] == '1'):\n                tot += 2**(len(b)-1-i)\n                lastChanged = True\n            else:\n                lastChanged = False\n        \n        return tot + 1 + self.minimumOneBitOperations(int('1' + '0'*(len(b)-2),2))\n", "from functools import lru_cache\n\nclass Solution:\n    def minimumOneBitOperations(self, n: int) -> int:\n        return self.toZero(n)\n    \n    @lru_cache(maxsize=None)\n    def toZero(self, n):\n        if n <= 1:\n            return n\n        elif n == 2:\n            return 3\n        elif n == 3:\n            return 2\n        \n        offset = 0\n        while ((1 << (offset + 1)) - 1) & n != n:\n            offset += 1\n        \n        target = 1 << (offset - 1)\n        return self.topower2(n & ((target << 1) - 1), target) + 1 + self.toZero(target)\n    \n    @lru_cache(maxsize=None)\n    def topower2(self, n, target):\n        if n == 0:\n            return 1 + self.topower2(1, target)\n        elif n == target:\n            return 0\n        \n        offset = 0\n        while ((1 << (offset + 1)) - 1) & n != n:\n            offset += 1\n             \n        if n & target == 0:\n            return self.topower2(n, target >> 1) + 1 + self.toZero(target >> 1)\n        \n        return self.toZero(n & (target - 1))\n        \n"]
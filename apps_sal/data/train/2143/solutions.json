["from bisect import *\n\nn, tc, td = [int(i) for i in input().split()]\nfc = []\nfd = []\nmbc = 0\nmbd = 0\nfor _ in range(n):\n    b, p, ft = input().split()\n    b, p = int(b), int(p)\n    f = (p, b)\n    if ft == 'C':\n        if p <= tc:\n            fc.append(f)\n            mbc = max(mbc, b)\n    else:\n        if p <= td:\n            fd.append(f)\n            mbd = max(mbd, b)\n\nfc = sorted(fc)\nfd = sorted(fd)\n\ndef pick2(fc, tc):\n    bf = []\n    maxb = 0\n    ans = 0\n    for f in fc:\n        p, b = f\n        maxpp = tc - p\n        ii = bisect_left(bf, (maxpp+1, 0)) - 1\n        if ii >= 0:\n            pp, bb = bf[ii]\n            ans = max(ans, bb + b)\n        if b > maxb:\n            bf.append(f)\n            maxb = b\n    return ans\n\nans = mbc + mbd if mbc > 0 and mbd > 0 else 0\nans = max(ans, pick2(fc, tc))\nans = max(ans, pick2(fd, td))\n\nprint(ans)\n", "n, c, d = map(int, input().split())\n\ninf = 10 ** 9\na = [0] * n\nsc = []\nsd = []\nfor i in range(n):\n    b, p, t = input().split()\n    b = int(b)\n    p = int(p)\n    \n    a[i] = [b, p, t]\n    \n    if t == 'C':\n        sc.append([p, b])\n    else:\n        sd.append([p, b])\n        \n    \nmaxc = -inf\nmaxd = -inf\nfor i in range(n):\n    if a[i][2] == 'C' and a[i][1] <= c:\n        maxc = max(maxc, a[i][0])\n        \n    if a[i][2] == 'D' and a[i][1] <= d:\n        maxd = max(maxd, a[i][0])    \n        \nans1 = maxc + maxd\n\nsc.sort()\nscpref = [0] * (len(sc) + 1)\nscpref[0] = -inf\nfor i in range(len(sc)):\n    scpref[i + 1] = max(scpref[i], sc[i][1])\n\nans2 = -inf\nfor i in range(len(sc)):\n    l = -1\n    r = i\n    while l < r - 1:\n        m = (l + r) // 2\n        if sc[m][0] <= c - sc[i][0]:\n            l = m\n        else:\n            r = m\n            \n    ans2 = max(ans2, sc[i][1] + scpref[l + 1])\n    \n    \nsd.sort()\nsdpref = [0] * (len(sd) + 1)\nsdpref[0] = -inf\nfor i in range(len(sd)):\n    sdpref[i + 1] = max(sdpref[i], sd[i][1])\n\nans3 = -inf\nfor i in range(len(sd)):\n    l = -1\n    r = i\n    while l < r - 1:\n        m = (l + r) // 2\n        if sd[m][0] <= d - sd[i][0]:\n            l = m\n        else:\n            r = m\n            \n    ans3 = max(ans3, sd[i][1] + sdpref[l + 1])\n    \n    \nans = max(ans1, ans2, ans3)\nprint(max(ans, 0))", "#a, b, h, w, n = map(int,input().split())\n#rash = map(int,input().split())\nn, c, d = list(map(int,input().split()))\n\nfon = []\n\nfor i in range(n):\n    s = input().split()\n    kras = int(s[0])\n    ctoim = int(s[1])\n    if(s[2]==\"C\"):\n        fon.append([kras,ctoim,True])\n    else:\n        fon.append([kras, ctoim, False])\ndef sravni(elem):\n    return elem[0]\nfon.sort(key=sravni,reverse=True)\n#print(fon)\n\nmaxkras = 0\nfor fon1 in range(n):\n    tekc = c\n    tekd = d\n    if fon[fon1][2]:\n        tekc -= fon[fon1][1]\n    else:\n        tekd-= fon[fon1][1]\n    if tekc<0 or tekd<0:\n        continue\n    fon2 = -1\n    for i in range(fon1+1,n):\n        if fon[i][2]:\n            if fon[i][1]<=tekc:\n                fon2 = i\n                break\n        else:\n            if fon[i][1]<=tekd:\n                fon2 = i\n                break\n    if not fon2== -1:\n        if fon[fon1][0]+fon[fon2][0]>maxkras:\n            maxkras = fon[fon1][0]+fon[fon2][0]\nprint(maxkras)\n", "n,c,d = list(map(int, input().split()))\na = []\ninf = 10 ** 10\nfor i in range(n):\n    a.append(input().split())\n    a[i][0], a[i][1] = int(a[i][0]), int(a[i][1])\n    \ndef tr(r,s,have):\n    if len(r) < 2:\n        return 0\n    mn = [0] * len(r)\n    mn[0] = r[0][1]\n    for i in range(len(r)):\n        mn[i] = max(r[i][1], mn[i - 1])\n    p = -1\n    rs = -inf\n    for i in range(len(r) - 1, -1, -1):\n        while p + 1 < i and r[p + 1][0] <= have - r[i][0]:\n            p += 1\n        if p != -1:\n            if p >= i:\n                if i:\n                    rs = max(rs, mn[i - 1] + r[i][1])\n            else:\n                rs = max(rs, mn[p] + r[i][1])\n    return rs\n        \n        \n        \n    \n    \n\nans = 0\ncmx = 0\ndmx = 0\nfor i in range(n):\n    if a[i][2] == \"C\" and a[i][1] <= c:\n        cmx = max(cmx, a[i][0])\n    elif a[i][1] <= d:\n        dmx = max(dmx, a[i][0])\nif cmx > 0 and dmx > 0:\n    ans = max(ans, cmx + dmx)\ndm = []\nfor i in range(len(a)):\n    if a[i][2] == \"C\":\n        dm.append((a[i][1], a[i][0]))\ndm.sort()\nans = max(ans,tr(dm,\"C\",c))\ndm = []\nfor i in range(len(a)):\n    if a[i][2] == \"D\":\n        dm.append((a[i][1], a[i][0]))\ndm.sort()\nans = max(ans,tr(dm,\"D\",d))\nif ans == -inf:\n    print(0)\nelse:\n    print(ans)\n\n    \n    \n", "n, t, d = map(int, input().split())\ncoin = [[(0, 0), (0, 0)] for i in range(100001)]\ndiam = [[(0, 0), (0, 0)] for i in range(100001)]\nf = []\nfor i in range(n):\n    b, c, q = input().split()\n    b = int(b)\n    c = int(c)\n    if q == 'C':\n        f.append((b, c, 1))\n        if coin[c][0][0] < b:\n            coin[c][1] = coin[c][0]\n            coin[c][0] = (b, i)\n        elif coin[c][1][0] < b:\n            coin[c][1] = (b, i)\n    else:\n        f.append((b, c, 2))\n        if diam[c][0][0] < b:\n            diam[c][1] = diam[c][0]\n            diam[c][0] = (b, i)\n        elif diam[c][1][0] < b:\n            diam[c][1] = (b, i)\nfor i in range(2, 100001):\n    if coin[i][0][0] < coin[i - 1][0][0]:\n        coin[i][1] = max(coin[i][0], coin[i - 1][1])\n        coin[i][0] = coin[i - 1][0]\n    else:\n        coin[i][1] = max(coin[i - 1][1], coin[i][1])\n    if diam[i][0][0] < diam[i - 1][0][0]:\n        diam[i][1] = max(diam[i][0], diam[i - 1][1])\n        diam[i][0] = diam[i - 1][0]\n    else:\n        diam[i][1] = max(diam[i - 1][1], diam[i][1])\np = False\nans = 0\nfor i in range(n):\n    fnt = f[i]\n    #print(fnt)\n    if fnt[2] == 1:\n        if t >= fnt[1]:\n            s = t - fnt[1]\n            if coin[s][0][0] > 0 and coin[s][0][1] != i:\n                ans = max(fnt[0] + coin[s][0][0], ans)\n                p = True\n            elif coin[s][1][0] > 0:\n                ans = max(fnt[0] + coin[s][1][0], ans)\n                p = True\n            if diam[d][0][0] > 0:\n                ans = max(fnt[0] + diam[d][0][0], ans)\n                p = True\n    else:\n        if d >= fnt[1]:\n            s = d - fnt[1]\n            if diam[s][0][0] > 0 and diam[s][0][1] != i:\n                ans = max(fnt[0] + diam[s][0][0], ans)\n                p = True\n            elif diam[s][1][0] > 0:\n                ans = max(fnt[0] + diam[s][1][0], ans)\n                p = True\n            if coin[t][0][0] > 0:\n                ans = max(fnt[0] + coin[t][0][0], ans)\n                p = True\nif p:\n    print(ans)\nelse:\n    print(0)", "from bisect import *\n\nn, tc, td = [int(i) for i in input().split()]\nfc = []\nfd = []\nmbc = 0\nmbd = 0\nfor _ in range(n):\n    b, p, ft = input().split()\n    b, p = int(b), int(p)\n    f = (p, b)\n    if ft == 'C':\n        if p <= tc:\n            fc.append(f)\n            mbc = max(mbc, b)\n    else:\n        if p <= td:\n            fd.append(f)\n            mbd = max(mbd, b)\n\nfc = sorted(fc)\nfd = sorted(fd)\n\ndef pick2(fc, tc):\n    bf = []\n    maxb = 0\n    ans = 0\n    for f in fc:\n        p, b = f\n        maxpp = tc - p\n        ii = bisect_left(bf, (maxpp+1, 0)) - 1\n        if ii >= 0:\n            pp, bb = bf[ii]\n            ans = max(ans, bb + b)\n        if b > maxb:\n            bf.append(f)\n            maxb = b\n    return ans\n\nans = mbc + mbd if mbc > 0 and mbd > 0 else 0\nans = max(ans, pick2(fc, tc))\nans = max(ans, pick2(fd, td))\n\nprint(ans)", "from bisect import *\n\ndef pair(fc, tc):\n    bf = []\n    maxb = 0\n    ans = 0\n    for f in fc:\n        p, b = f\n        maxpp = tc - p\n        ii = bisect_left(bf, (maxpp+1, 0)) - 1\n        if ii >= 0:\n            pp, bb = bf[ii]\n            ans = max(ans, bb + b)\n        if b > maxb:\n            bf.append(f)\n            maxb = b\n    return ans\n            \nn,c,d = map(int, input().split())\narr1 = []\narr2 = []\nfor i in range(n):\n    b, k, t = input().split()\n    b,k = int(b), int(k)\n    if t == 'C' and k <= c:\n        arr1.append((k,b))\n    if t == 'D' and k <= d:\n        arr2.append((k,b))\nif len(arr1) > 0 and len(arr2) > 0:\n    v1 = max(arr1, key = lambda x: x[1])[1] + max(arr2, key = lambda x: x[1])[1]\nelse:\n    v1 = 0\nv2 = pair(sorted(arr1), c)\nv3 = pair(sorted(arr2), d)\nprint(max([v1,v2,v3]))", "import operator\n\nfc = []\nfd = []\nn, c, d = list(map(int, input().split()))\n\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    if m == 'C':\n        if p <= c:\n            fc.append((b, p))\n    else:\n        if p <= d:\n            fd.append((b, p))\n\nfc.sort(key=operator.itemgetter(0), reverse=True)\nfd.sort(key=operator.itemgetter(0), reverse=True)\n\nmx = 0\nif fc and fd:\n    mx = fc[0][0] + fd[0][0]\n\nfor i in range(len(fc)):\n    b1, p1 = fc[i]\n    if 2 * b1 <= mx:\n        break\n    for j in range(i + 1, len(fc)):\n        b2, p2 = fc[j]\n        if b1 + b2 <= mx:\n            break\n        if p1 + p2 <= c:\n            mx = b1 + b2\n            break\n        \nfor i in range(len(fd)):\n    b1, p1 = fd[i]\n    if 2 * b1 <= mx:\n        break\n    for j in range(i + 1, len(fd)):\n        b2, p2 = fd[j]\n        if b1 + b2 <= mx:\n            break\n        if p1 + p2 <= d:\n            mx = b1 + b2\n            break\n\nprint(mx)\n\n", "import operator\n\ndef maxl(l, m, mx):\n    for i in range(len(l) - 1):\n        b1, p1 = l[i]\n        if 2 * b1 <= mx:\n            break\n        for j in range(i + 1, len(l)):\n            b2, p2 = l[j]\n            if b1 + b2 <= mx:\n                break\n            if p1 + p2 <= m:\n                mx = b1 + b2\n                break\n    return mx\n\n   \nfc = []\nfd = []\nn, c, d = list(map(int, input().split()))\n\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    if m == 'C':\n        if p <= c:\n            fc.append((b, p))\n    else:\n        if p <= d:\n            fd.append((b, p))\n\nfc.sort(key=operator.itemgetter(0), reverse=True)\nfd.sort(key=operator.itemgetter(0), reverse=True)\n\nmx = 0\nif fc and fd:\n    mx = fc[0][0] + fd[0][0]\n\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n\n", "import operator\n\ndef maxl(l, m, mx):\n    for i in range(len(l) - 1):\n        b1, p1 = l[i]\n        if 2 * b1 <= mx:\n            break\n        for j in range(i + 1, len(l)):\n            b2, p2 = l[j]\n            if b1 + b2 <= mx:\n                break\n            if p1 + p2 <= m:\n                mx = b1 + b2\n                break\n    return mx\n\n   \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\n\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    if m == 'C':\n        if p <= c:\n            fc.append((b, p))\n    else:\n        if p <= d:\n            fd.append((b, p))\n\nfc.sort(key=operator.itemgetter(0), reverse=True)\nfd.sort(key=operator.itemgetter(0), reverse=True)\n\nmx = fc[0][0] + fd[0][0] if fc and fd else 0\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "import operator\n\ndef maxl(l, m, mx):\n    for i in range(len(l) - 1):\n        b1, p1 = l[i]\n        for j in range(i + 1, len(l)):\n            b2, p2 = l[j]\n            if b1 + b2 <= mx:\n                break\n            if p1 + p2 <= m:\n                mx = b1 + b2\n                break\n    return mx\n\n   \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\n\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    if m == 'C':\n        if p <= c:\n            fc.append((b, p))\n    else:\n        if p <= d:\n            fd.append((b, p))\n\nfc.sort(key=operator.itemgetter(0), reverse=True)\nfd.sort(key=operator.itemgetter(0), reverse=True)\n\nmx = fc[0][0] + fd[0][0] if fc and fd else 0\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "import operator\n\ndef maxl(l, m, mx):\n    for i in range(len(l) - 1):\n        b1, p1 = l[i]\n        if b1 + l[i + 1][0] <= mx:\n            break\n        for j in range(i + 1, len(l)):\n            b2, p2 = l[j]\n            if b1 + b2 <= mx:\n                break\n            if p1 + p2 <= m:\n                mx = b1 + b2\n                break\n    return mx\n\n   \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\n\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    if m == 'C':\n        if p <= c:\n            fc.append((b, p))\n    else:\n        if p <= d:\n            fd.append((b, p))\n\nfc.sort(key=operator.itemgetter(0), reverse=True)\nfd.sort(key=operator.itemgetter(0), reverse=True)\n\nmx = fc[0][0] + fd[0][0] if fc and fd else 0\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "import operator\n\ndef maxl(l, m, mx):\n    for i in range(len(l) - 1):\n        b1, p1 = l[i]\n        if b1 + b1 <= mx:\n            break\n        for j in range(i + 1, len(l)):\n            b2, p2 = l[j]\n            if b1 + b2 <= mx:\n                break\n            if p1 + p2 <= m:\n                mx = b1 + b2\n                break\n    return mx\n\n   \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\n\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    if m == 'C':\n        if p <= c:\n            fc.append((b, p))\n    else:\n        if p <= d:\n            fd.append((b, p))\n\nfc.sort(key=operator.itemgetter(0), reverse=True)\nfd.sort(key=operator.itemgetter(0), reverse=True)\n\nmx = fc[0][0] + fd[0][0] if fc and fd else 0\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "import operator\n\ndef maxl(l, m, mx):\n    for i in range(len(l) - 1):\n        b1, p1 = l[i]\n        if b1 + b1 <= mx:\n            break\n        for j in range(i + 1, len(l)):\n            b2, p2 = l[j]\n            if b1 + b2 <= mx:\n                break\n            if p1 + p2 <= m:\n                mx = b1 + b2\n                break\n    return mx\n\n   \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\n\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    if m == 'C':\n        if p <= c:\n            fc.append((b, p))\n    else:\n        if p <= d:\n            fd.append((b, p))\n\nfc.sort(key=operator.itemgetter(0), reverse=True)\nfd.sort(key=operator.itemgetter(0), reverse=True)\n\nmx = 0\nif len(fc) and len(fd):\n    mx = fc[0][0] + fd[0][0]\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "import operator\n\ndef maxl(l, m, mx):\n    for i in range(len(l) - 1):\n        b1, p1 = l[i]\n        if b1 * 2 <= mx:\n            break\n        for j in range(i + 1, len(l)):\n            b2, p2 = l[j]\n            if b1 + b2 <= mx:\n                break\n            if p1 + p2 <= m:\n                mx = b1 + b2\n                break\n    return mx\n\n   \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\n\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    if m == 'C':\n        if p <= c:\n            fc.append((b, p))\n    else:\n        if p <= d:\n            fd.append((b, p))\n\nfc.sort(key=operator.itemgetter(0), reverse=True)\nfd.sort(key=operator.itemgetter(0), reverse=True)\n\nmx = fc[0][0] + fd[0][0] if fc and fd else 0\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "import operator\n\nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\n\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    if m == 'C':\n        if p <= c:\n            fc.append((b, p))\n    else:\n        if p <= d:\n            fd.append((b, p))\n\nfc.sort(key=operator.itemgetter(0), reverse=True)\nfd.sort(key=operator.itemgetter(0), reverse=True)\n\nmx = fc[0][0] + fd[0][0] if fc and fd else 0\n\nfor l, m in ((fc, c), (fd, d)):\n    for i in range(len(l) - 1):\n        b1, p1 = l[i]\n        if b1 * 2 <= mx:\n            break\n        for j in range(i + 1, len(l)):\n            b2, p2 = l[j]\n            if b1 + b2 <= mx:\n                break\n            if p1 + p2 <= m:\n                mx = b1 + b2\n                break\n\nprint(mx)\n", "from operator import itemgetter\n\n\ndef get_one_max(arr, resource):\n    res = 0\n    for beauty, _ in [x for x in arr if x[1] <= resource]:\n        res = max(res, beauty)\n    return res\n\n\ndef get_two_max(arr, resource):\n    arr.sort(key=itemgetter(1))\n    best = [-1] * (resource + 1)\n    ptr = 0\n    for index, (beauty, price) in enumerate(arr):\n        if price > resource:\n            break\n        while ptr < price:\n            ptr += 1\n            best[ptr] = best[ptr - 1]\n        if best[ptr] == -1 or arr[best[ptr]][0] < beauty:\n            best[ptr] = index\n\n    while ptr < resource:\n        ptr += 1\n        best[ptr] = best[ptr - 1]\n\n    res = 0\n    for index, (beauty, price) in enumerate(arr):\n        rest = resource - price\n        if rest <= 0:\n            break\n        if best[rest] == -1 or best[rest] == index:\n            continue\n        res = max(res, beauty + arr[best[rest]][0])\n\n    return res\n\n\nn, coins, diamonds = list(map(int, input().split()))\n\nwith_coins = []\nwith_diamonds = []\n\nfor i in range(n):\n    beauty, price, tp = input().split()\n    if tp == 'C':\n        with_coins.append((int(beauty), int(price)))\n    else:\n        with_diamonds.append((int(beauty), int(price)))\n\nwith_coins_max = get_one_max(with_coins, coins)\nwith_diamonds_max = get_one_max(with_diamonds, diamonds)\nans = 0 if with_coins_max == 0 or with_diamonds_max == 0 \\\n    else with_coins_max + with_diamonds_max\nans = max(ans, get_two_max(with_coins, coins))\nans = max(ans, get_two_max(with_diamonds, diamonds))\n\nprint(ans)\n", "from operator import itemgetter\n\n\ndef get_one_max(arr, resource):\n    res = 0\n    for beauty, _ in [x for x in arr if x[1] <= resource]:\n        res = max(res, beauty)\n    return res\n\n\ndef get_two_max(arr, resource):\n    arr.sort(key=itemgetter(1))\n    best = [-1] * (resource + 1)\n    ptr = 0\n    for index, (beauty, price) in enumerate(arr):\n        if price > resource:\n            break\n        while ptr < price:\n            ptr += 1\n            best[ptr] = best[ptr - 1]\n        if best[ptr] == -1 or arr[best[ptr]][0] < beauty:\n            best[ptr] = index\n\n    while ptr < resource:\n        ptr += 1\n        best[ptr] = best[ptr - 1]\n\n    res = 0\n    for index, (beauty, price) in enumerate(arr):\n        rest = resource - price\n        if rest <= 0:\n            break\n        if best[rest] == -1 or best[rest] == index:\n            continue\n        res = max(res, beauty + arr[best[rest]][0])\n\n    return res\n\n\nn, coins, diamonds = list(map(int, input().split()))\n\nwith_coins = []\nwith_diamonds = []\n\nfor i in range(n):\n    beauty, price, tp = input().split()\n    if tp == 'C':\n        with_coins.append((int(beauty), int(price)))\n    else:\n        with_diamonds.append((int(beauty), int(price)))\n\nwith_coins_max = get_one_max(with_coins, coins)\nwith_diamonds_max = get_one_max(with_diamonds, diamonds)\nans = 0 if with_coins_max == 0 or with_diamonds_max == 0 \\\n    else with_coins_max + with_diamonds_max\nans = max(ans, get_two_max(with_coins, coins))\nans = max(ans, get_two_max(with_diamonds, diamonds))\n\nprint(ans)\n", "import operator\n\ndef maxl(l, m, mx):\n    for i in range(len(l) - 1):\n        b1, p1 = l[i]\n        if b1 * 2 <= mx:\n            break\n        for j in range(i + 1, len(l)):\n            b2, p2 = l[j]\n            if b1 + b2 <= mx:\n                break\n            if p1 + p2 <= m:\n                mx = b1 + b2\n                break\n    return mx\n\n   \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    f, cd = (fc, c) if m == 'C' else (fd, d)\n    if p <= cd:\n        f.append((b, p))\n\nfc.sort(key=operator.itemgetter(0), reverse=True)\nfd.sort(key=operator.itemgetter(0), reverse=True)\n\nmx = fc[0][0] + fd[0][0] if fc and fd else 0\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "n, c, d = list(map(int, input().split()))\ncoin = []\ndiamond = []\nfor i in range(n):\n    tmp = input().split()\n    if tmp[-1] == 'C' and int(tmp[1]) <= c:\n        coin.append(list(map(int, tmp[:2])))\n    if tmp[-1] == 'D' and int(tmp[1]) <= d:\n        diamond.append(list(map(int, tmp[:2])))\nres1 = 0\nmc = -float('inf')\nfor i in coin:\n    if mc < i[0] and i[1] <= c:\n        mc = i[0]\nmd = -float('inf')\nfor i in diamond:\n    if md < i[0] and i[1] <= d:\n        md = i[0]\nif mc != -float('inf') and md != -float('inf'):\n    res1 = md + mc\ncoin.sort(key=lambda x: x[1], reverse=True)\ndiamond.sort(key=lambda x: x[1], reverse=True)\nprefc = [0 for i in range(len(coin))]\nprefd = [0 for i in range(len(diamond))]\nif len(coin):\n    prefc[-1] = coin[-1][0]\nif len(diamond):\n    prefd[-1] = diamond[-1][0]\nfor i in range(len(coin) - 2, -1, -1):\n    prefc[i] = max(prefc[i + 1], coin[i][0])\nfor i in range(len(diamond) - 2, -1, -1):\n    prefd[i] = max(prefd[i + 1], diamond[i][0])\nres2 = 0\nres3 = res2\nfor i in range(len(coin)):\n    p = c - coin[i][1]\n    l = i\n    r = len(coin) - 1\n    while r - l > 1:\n        m = (r + l) // 2\n        if coin[m][1] > p:\n            l = m\n        else:\n            r = m\n    if coin[r][1] <= p and r > i:\n        res2 = max(res2, coin[i][0] + prefc[r])\nfor i in range(len(diamond)):\n    p = d - diamond[i][1]\n    l = i\n    r = len(diamond) - 1\n    while r - l > 1:\n        m = (r + l) // 2\n        if diamond[m][1] > p:\n            l = m\n        else:\n            r = m\n    if diamond[r][1] <= p and r > i:\n        res3 = max(res3, diamond[i][0] + prefd[r])\nprint(max(res1, res2, res3))\n", "import operator\nimport itertools\nimport bisect\n\ndef maxl(l, m, mx):\n    l.sort(key=operator.itemgetter(1))\n    \n    m1, m2 = 0, 0\n    pp = None\n    for b, p in l:\n        if p != pp:\n            if 2 * p > m:\n                break\n            if m1 and m2 and m1 + m2 > mx:\n                mx = m1 + m2\n            m1, m2 = b, 0\n            pp = p\n        else:\n            if b > m1:\n                m1, m2 = b, m1\n            elif b > m2:\n                m2 = b\n    if m1 and m2 and m1 + m2 > mx:\n         mx = m1 + m2\n         \n    lp = list(p for(b, p) in l)\n    lb = list(itertools.accumulate((b for (b, p) in l), max))\n    for i, ((b, p), mb) in enumerate(zip(l, lb)):\n        p1 = min(m - p, p - 1)\n        k = bisect.bisect_right(lp, p1, 0, i)\n        if k:\n            x = b + lb[k - 1]\n            if x > mx:\n                mx = x\n    return mx\n\n   \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    f, cd = (fc, c) if m == 'C' else (fd, d)\n    if p <= cd:\n        f.append((b, p))\n\nmx = 0\nif fc and fd:\n    bc, pc = max(fc, key=operator.itemgetter(0))\n    bd, pd = max(fd, key=operator.itemgetter(0))\n    mx = bc + bd\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "import operator\nimport itertools\nimport bisect\n\ndef maxl(l, m, mx):\n    l.sort(key=operator.itemgetter(1))\n    \n    m1, m2 = 0, 0\n    pp = None\n    for b, p in l:\n        if p != pp:\n            if 2 * p > m:\n                break\n            if m1 and m2 and m1 + m2 > mx:\n                mx = m1 + m2\n            m1, m2 = b, 0\n            pp = p\n        else:\n            if b > m1:\n                m1, m2 = b, m1\n            elif b > m2:\n                m2 = b\n    if m1 and m2 and m1 + m2 > mx:\n         mx = m1 + m2\n         \n    lp = [p for(b, p) in l]\n    lb = list(itertools.accumulate((b for (b, p) in l), max))\n    for i, ((b, p), mb) in enumerate(zip(l, lb)):\n        p1 = min(m - p, p - 1)\n        k = bisect.bisect_right(lp, p1, 0, i)\n        if k:\n            x = b + lb[k - 1]\n            if x > mx:\n                mx = x\n    return mx\n\n   \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    f, cd = (fc, c) if m == 'C' else (fd, d)\n    if p <= cd:\n        f.append((b, p))\n\nmx = 0\nif fc and fd:\n    bc, pc = max(fc, key=operator.itemgetter(0))\n    bd, pd = max(fd, key=operator.itemgetter(0))\n    mx = bc + bd\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "import operator\nimport itertools\nimport bisect\n\ndef maxl(l, m, mx):\n    l.sort(key=operator.itemgetter(1))\n    lp = [p for(b, p) in l]\n    lb = list(itertools.accumulate((b for (b, p) in l), max))\n    for i, ((b, p), mb) in enumerate(zip(l, lb)):\n        k = bisect.bisect_right(lp, m - p, 0, i)\n        if k:\n            x = b + lb[k - 1]\n            if x > mx:\n                mx = x\n    return mx\n\n \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    f, cd = (fc, c) if m == 'C' else (fd, d)\n    if p <= cd:\n        f.append((b, p))\n\nmx = 0\nif fc and fd:\n    bc, pc = max(fc, key=operator.itemgetter(0))\n    bd, pd = max(fd, key=operator.itemgetter(0))\n    mx = bc + bd\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "import operator\nimport itertools\nimport bisect\n\ndef maxl(l, m, mx):\n    l.sort(key=operator.itemgetter(1))\n    lp = [p for(b, p) in l]\n    lb = list(itertools.accumulate((b for (b, p) in l), max))\n    for i, (b, p) in enumerate(l):\n        k = bisect.bisect_right(lp, m - p, 0, i)\n        if k:\n            x = b + lb[k - 1]\n            if x > mx:\n                mx = x\n    return mx\n\n \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    f, cd = (fc, c) if m == 'C' else (fd, d)\n    if p <= cd:\n        f.append((b, p))\n\nmx = 0\nif fc and fd:\n    bc, pc = max(fc, key=operator.itemgetter(0))\n    bd, pd = max(fd, key=operator.itemgetter(0))\n    mx = bc + bd\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n", "import operator\nimport itertools\nimport bisect\n\ndef maxl(l, m, mx):\n    l.sort(key=operator.itemgetter(1))\n    lp = [p for(b, p) in l]\n    lb = list(itertools.accumulate((b for (b, p) in l), max))\n    for i, (b, p) in enumerate(l):\n        k = bisect.bisect_right(lp, m - p, 0, i)\n        if k:\n            x = b + lb[k - 1]\n            if x > mx:\n                mx = x\n    return mx\n\n \nfc = []\nfd = []\n\nn, c, d = list(map(int, input().split()))\nfor _ in range(n):\n    b, p, m = input().split()\n    b, p = int(b), int(p)\n    f, cd = (fc, c) if m == 'C' else (fd, d)\n    if p <= cd:\n        f.append((b, p))\n\nmx = 0\nif fc and fd:\n    bc = max(b for (b, p) in fc)\n    bd = max(b for (b, p) in fd)\n    mx = bc + bd\nmx = maxl(fc, c, mx)\nmx = maxl(fd, d, mx)\n\nprint(mx)\n"]
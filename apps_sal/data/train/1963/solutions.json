["class Solution:\n     def shoppingOffers(self, price, special, needs):\n         \"\"\"\n         :type price: List[int]\n         :type special: List[List[int]]\n         :type needs: List[int]\n         :rtype: int\n         \"\"\"\n         def dfs(curr, special, needs):\n             p=curr+sum(p*needs[i] for i,p in enumerate(price))\n             for si in range(len(special)):\n                 s = special[si]\n                 if all(n>=s[i] for i,n in enumerate(needs)):\n                     p=min(p, dfs(curr+s[-1], special[si:], [n-s[i] for i,n in enumerate(needs)]))\n                 # else: p=min(p, dfs(curr, special[si+1:], needs))\n             return p\n         return dfs(0, special, needs)", "class Solution:\n     def shoppingOffers(self, price, special, needs):\n         \"\"\"\n         :type price: List[int]\n         :type special: List[List[int]]\n         :type needs: List[int]\n         :rtype: int\n         \"\"\"\n         #\u7528\u4e00\u4e2a\u5c40\u90e8\u7684\u6700\u5c0f\u503c\uff0c\u6bcf\u6b21\u66f4\u65b0\n         def directPurchase(price,needs):\n             total=0\n             for i in range(len(needs)):\n                 total+=price[i]*needs[i]\n             return total\n         #index\u8868\u793a\u5bf9special offer\u904d\u5386\n         def dfs(price,special,needs,index):\n             #\u4e00\u79cd\u5728\u73b0\u5b9e\u4e2d\u6709\u53ef\u80fd\u53d1\u751f\u7684\u60c5\u51b5\uff1a\u5355\u72ec\u4e70\u53ef\u80fd\u6bd4\u4e70\u5957\u9910\u66f4\u52a0\u4fbf\u5b9c\n             local_min=directPurchase(price,needs)\n             for i in range(index,len(special)):\n                 offer=special[i]\n                 temp=[]\n                 #\u5982\u679c\u4e70\u4e86\u67d0\u79cd\u5546\u54c1\uff0c\u5219needs\u7684\u6570\u91cf\u4e00\u76f4\u66f4\u65b0,needs\u662f\u4e2a\u6570\u7ec4\uff0c\u6240\u4ee5\u9700\u8981\u904d\u5386\n                 for j in range(len(needs)):\n                     #\u9700\u8981\u7684\u6bd4\u63d0\u4f9b\u7684\u5c11\uff0c\u4e0d\u6ee1\u8db3\u201c\u521a\u597d\u201d\u7684\u6761\u4ef6\n                     if needs[j]<offer[j]:\n                         #\u8fd9\u4e00\u53e5\u5f88\u91cd\u8981\uff0c\u4e0d\u7136\u4f1a\u62a5\u9519\uff0c\u53ea\u8981\u6709\u4e00\u79cd\u4ea7\u54c1\u4e0d\u6ee1\u8db3\u6761\u4ef6\uff0c\u8fd9\u4e00\u4e2aspecial\u5c31\u90fd\u4e0d\u80fd\u4e70\n                         temp=[]\n                         break\n                     else:\n                         #\u9700\u8981\u7684\u66f4\u591a\n                         temp.append(needs[j]-offer[j])\n                 #\u5982\u679c\u8fd8\u6709\u9700\u8981\u4e70\u7684\u4e1c\u897f\n                 if temp!=[]:\n                     #\u52a8\u6001\u89c4\u5212\u7684\u8fc7\u7a0b\n                     local_min=min(local_min,offer[-1]+dfs(price,special,temp,i))\n             return local_min\n         return dfs(price,special,needs,0)\n                         \n", "class Solution:\n     def shoppingOffers(self, price, special, needs):\n         \"\"\"\n         :type price: List[int]\n         :type special: List[List[int]]\n         :type needs: List[int]\n         :rtype: int\n         \"\"\"\n         d = {}\n         n = len(needs)\n         \n         def minp(needs,d):\n             if str(needs) in d:\n                 return d[str(needs)]\n             res = 0\n             for i in range(n):\n                 res += price[i]*needs[i]\n             for s in special:\n                 for i in range(n):\n                     if s[i]>needs[i]:\n                         break\n                 else:\n                     need2 = []\n                     for i in range(n):\n                         need2.append(needs[i]-s[i])\n                     res = min(res, minp(need2,d)+s[-1])\n             d[str(needs)] = res\n             return res\n         \n         return minp(needs,d)", "class Solution:\n     def shoppingOffers(self, price, special, needs):\n         \"\"\"\n         :type price: List[int]\n         :type special: List[List[int]]\n         :type needs: List[int]\n         :rtype: int\n         \"\"\"\n         d = {}\n         n = len(needs)\n         \n         def minp(needs,d):\n             if str(needs) in d:\n                 return d[str(needs)]\n             res = 0\n             for i in range(n):\n                 res += price[i]*needs[i]\n             for s in special:\n                 need2 = []\n                 for i in range(n):\n                     if s[i]>needs[i]:\n                         break\n                     need2.append(needs[i]-s[i])\n                 else:\n                     res = min(res, minp(need2,d)+s[-1])\n             d[str(needs)] = res\n             return res\n         \n         return minp(needs,d)", "class Solution:\n     def shoppingOffers(self, rps,sos,tq):\n         if len(sos)<1: return sum([x*y for x,y in zip(rps,tq)])\n         so=sos.pop()\n         m=self.shoppingOffers(rps,sos,tq)\n         ss=so[:]\n         while all([x<=y for x,y in zip(ss,tq)]):\n             rq=[x-y for x,y in zip(tq,ss)]\n             m=min(m,ss[-1]+self.shoppingOffers(rps,sos,rq))\n             ss=[x+y for x,y in zip(ss,so)]\n         sos.append(so)\n         return m", "class Solution:\n     def shoppingOffers(self, price, special, needs):\n         \"\"\"\n         :type price: List[int]\n         :type special: List[List[int]]\n         :type needs: List[int]\n         :rtype: int\n         \"\"\"\n         res = 0\n         for pric, need in zip(price,needs):\n             res += pric*need\n         for offer in special:\n             clone = list(needs)\n             i=0\n             while (i < len(needs)):\n                 diff = clone[i] - offer[i]\n                 if diff < 0:\n                     break\n                 clone[i] = diff\n                 i+=1\n             if i == len(needs):\n                 res = min(res, offer[-1]+self.shoppingOffers(price,special,clone))\n         return res\n             \n", "class Solution:\n     def shoppingOffers(self, price, special, needs):\n         a = 0\n         n = len(needs)\n         for i in range(n):\n             a += needs[i] * price[i]\n         \n         \n         for s in special:\n             new_needs = needs.copy()\n             check = True\n             for i in range(n):\n                 new_needs[i] = new_needs[i] - s[i]\n                 if new_needs[i] < 0:\n                     check = False\n                     break\n             \n             if check:\n                 a = min(a, s[n] + self.shoppingOffers(price, special, new_needs))\n         return a\n", "\"\"\"\n https://leetcode.com/problems/shopping-offers/description/\n \"\"\"\n \n class Solution:\n     def shoppingOffers(self, price, special, needs):\n         \"\"\"\n         :type price: List[int]\n         :type special: List[List[int]]\n         :type needs: List[int]\n         :rtype: int\n         \"\"\"\n         number_of_items = len(price)\n         states = {}\n \n         for offer in special:\n             offer_state = offer[0:number_of_items]\n             offer_price = offer[-1]\n \n             offer_state_key = self.convert_to_key(offer_state)\n \n             if offer_state_key in states:\n                 offer_price = min(offer_price, states[offer_state_key][\"price\"])\n \n             states[offer_state_key] = {\n                 \"price\": offer_price,\n                 \"state\": offer_state\n             }\n \n         return self.compute_best_price(states, {}, needs, price)\n \n     def convert_to_key(self, state):\n         return \"\".join(str(i) for i in state)\n \n     def compute_worst_price(self, needs, individual_prices):\n         price = 0\n         for i,v in enumerate(needs):\n             price += needs[i] * individual_prices[i]\n \n         return price\n \n     def compute_best_price(self, original_offers, all_states, needs, individual_prices):\n         if needs == [0] * len(needs):\n             return 0\n \n         needs_key = self.convert_to_key(needs)\n \n         # If the state already exists - return\n         if needs_key in all_states:\n             return all_states[needs_key][\"price\"]\n \n         # Compute\n         best_price = self.compute_worst_price(needs, individual_prices)\n         new_needs = []\n         for offer_key in original_offers.keys():\n             offer = original_offers[offer_key]\n             valid_new_state = False\n             new_needs = []\n             for i, item_quantity in enumerate(offer[\"state\"]):\n                 quantity_left_for_item = needs[i] - item_quantity\n \n                 if quantity_left_for_item < 0:\n                     valid_new_state = False\n                     break\n                 else:\n                     new_needs.append(quantity_left_for_item)\n                     valid_new_state = True\n \n             if valid_new_state:\n                 new_price = offer[\"price\"] + self.compute_best_price(original_offers, all_states, new_needs, individual_prices)\n                 best_price = min(\n                     best_price,\n                     new_price\n                 )\n \n             # else just go to the next offer\n \n         all_states[self.convert_to_key(new_needs)] = {\n             \"state\": new_needs,\n             \"price\": best_price\n         }\n \n         return best_price\n"]
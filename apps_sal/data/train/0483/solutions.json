["class Solution:\n     def maxArea(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         # l = []\n         # maxH = 0\n         # for i in range(len(height)-1, -1, -1):\n         #     if height[i] > maxH:\n         #         maxH = height[i]\n         #         l.append((i, maxH))\n         # maxArea = 0\n         # for i in range(len(height)):\n         #     for jl in l:\n         #         if i >= jl[0]:\n         #             break\n         #         area = (jl[0] - i) * min(height[i], jl[1])\n         #         if area > maxArea:\n         #             maxArea = area\n         # return maxArea\n         \n         left = 0\n         right = len(height) - 1\n         if height[left] > height[right]:\n             minH = height[right]\n             minIndex = right\n         else:\n             minH = height[left]\n             minIndex = left\n         area = (right - left) * minH\n         maxArea = area\n         \n         while left != right:\n             if minIndex == left:\n                 while left != right:\n                     left += 1\n                     if height[left] > minH:\n                         if height[left] > height[right]:\n                             minH = height[right]\n                             minIndex = right\n                         else:\n                             minH = height[left]\n                             minIndex = left\n                         break\n                 area = (right - left) * minH\n             else:\n                 while left != right:\n                     right -= 1\n                     if height[right] > minH:\n                         if height[right] > height[left]:\n                             minH = height[left]\n                             minIndex = left\n                         else:\n                             minH = height[right]\n                             minIndex = right\n                         break\n                 area = (right - left) * minH\n             if area > maxArea:\n                 maxArea = area\n         return maxArea", "class Solution:\n     def maxArea(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         left_index = 0\n         right_index = len(height) - 1\n         water = 0\n         while True:\n             if left_index >= right_index:\n                 break\n             left_height = height[left_index]\n             right_height = height[right_index]\n             water = max(water, (right_index - left_index) * min(left_height, right_height))\n             if left_height < right_height:\n                 left_index += 1\n             else:\n                 right_index -= 1\n         return water\n", "class Solution:\n     def maxArea(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         if height == []:\n             return 0\n         l = len(height)\n         p1 = 0\n         p2 = l - 1\n         area = 0\n         while(p1 < p2):\n             if(height[p1] <= height[p2]):\n                 area = max(area,height[p1] * (p2 - p1))\n                 p1 += 1\n             else:\n                 area = max(area,height[p2] * (p2 - p1))\n                 p2 -= 1\n         return area\n", "class Solution:\n     def maxArea(self, height):\n         left, right = 0, len(height) - 1\n         area = 0\n         \n         while left < right:\n             if height[left] <= height[right]:\n                 h = height[left]\n                 tmp = (right - left) * h\n                 left += 1\n             else:\n                 h = height[right]\n                 tmp = (right - left) * h\n                 right -= 1\n             if area < tmp:\n                 area = tmp\n             \n         return area\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n", "class Solution:\n     def maxArea(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         area = (len(height)-1)*min([height[0], height[-1]])\n         left_idx = 0\n         right_idx = len(height)-1\n         while left_idx < right_idx:\n             if height[left_idx] < height[right_idx]:\n                 start = left_idx + 1\n                 while start < right_idx:\n                     if height[start] > height[left_idx]:\n                         left_idx = start\n                         area2 = (right_idx - left_idx) * min([height[left_idx], height[right_idx]])\n                         if area2 > area:\n                             area = area2\n                         break\n                     start += 1\n                 if start != left_idx:\n                     break\n             elif height[left_idx] > height[right_idx]:\n                 start = right_idx - 1\n                 while start > left_idx:\n                     if height[start] > height[right_idx]:\n                         right_idx = start\n                         area2 = (right_idx - left_idx) * min([height[left_idx], height[right_idx]])\n                         if area2 > area:\n                             area = area2\n                         break\n                     start -= 1\n                 if start!= right_idx:\n                     break\n             else:\n                 left_idx += 1\n         \n         return area\n", "class Solution:\n     def maxArea(self, items):\n         '''\n         Hi Lo Technique\n         -----------------------\n         Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate \n         (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and \n         (i, 0). Find two lines, which together with x-axis forms a container, such that the container\n         contains the most water.\n         -----------------------\n         (1) Set lo and hi pointer at ends & bring them closer as results compared.\n         (2) Get height for lo and hi. Keep the smallest.\n         (3) Calcuate the area (smallest height * distance between lo and hi pointers) (height * width)\n             If area is larger than currently stored max area, make it the max area.\n         (4) Move the smallest pointer in.\n         (5) Repeat steps 2-4\n         (6) Return the max area\n         '''              \n         max_area = 0\n         lo = 0\n         hi = len(items)-1\n         \n         while(lo < hi):\n             \n             # get value stored for height. calculate width.\n             height_a = items[lo]\n             height_b = items[hi]\n             width = hi - lo\n             height = min(height_a, height_b)\n             \n             # calculate area (height * width)\n             area = height * width\n             if area > max_area:\n                 max_area = area\n             \n             # move the smaller pointer in\n             if height_a < height_b:\n                 lo += 1\n             else: \n                 hi -= 1\n         \n         return(max_area)        ", "class Solution:\n     def maxArea(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \n         idea:\n         Shorter coordinate determines the water size\n         \"\"\"\n         \n         if len(height) < 2: return False\n         if len(height) == 2: return min(height[0], height[1])\n         \n         current_highest = 0\n         i, j = 0, len(height) - 1\n         while i < j:\n             left = height[i]\n             right = height[j]\n             current_highest = max(current_highest, min(left, right) * (j - i))\n             if right > left:\n                 i += 1\n             else:\n                 j -= 1\n         return current_highest", "class Solution:\n     def maxArea(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         h = height\n         most = 0\n         i = 0\n         j = len(h) - 1\n         while i < j:\n             most = max(most, (j - i) * min(h[i], h[j]))\n             if h[i] < h[j]:\n                 i += 1\n             else:\n                 j -= 1\n         return most", "class Solution:\n     def maxArea(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         i = 0\n         j = len(height)-1\n         res = 0\n         while i < j:\n             res = max(res,(j-i)*min(height[i], height[j]))\n             if height[i] > height[j]:\n                 j -= 1\n             else:\n                 i += 1\n         return res\n", "class Solution:\n \n     # two pointer, O(N) time\n     def maxArea(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n \n         left = 0\n         right = len(height) -1\n         max_area = 0\n \n         while left < right:\n \n             # area = height * width\n             area = min(height[left], height[right]) * (right - left)\n \n             if area > max_area:\n \n                 max_area = area\n \n             if height[left] < height[right]:\n \n                 left += 1\n \n             else:\n \n                 right -= 1\n \n         return max_area\n \n", "class Solution:\n     def get_ans(self, l, r):\n         return (r-l) * min(self.__height[l], self.__height[r])\n     \n     def rmove(self, l):\n         for i in range(l+1, len(self.__height)):\n             if self.__height[i] > self.__height[l]:\n                 return i\n         return 10000000\n     \n     def lmove(self, r):\n         for i in range(r-1, -1, -1):\n             if self.__height[i] > self.__height[r]:\n                 return i\n         return -1\n         \n     def maxArea(self, height):\n         \"\"\"\n         :type height: List[int]\n         :rtype: int\n         \"\"\"\n         self.__height = height\n         ans = 0\n         L = 0\n         R = len(height) - 1\n         while L < R:\n             ans = max(ans, self.get_ans(L, R))\n             if height[L] <= height[R]:\n                 L = self.rmove(L)\n             else:\n                 R = self.lmove(R)\n         # L = 0\n         # R = len(height) - 1\n         # while L < R:\n         #     ans = max(ans, self.get_ans(L, R))\n         #     if height[L] < height[R]:\n         #         L = self.rmove(L)\n         #     else:\n         #         R = self.lmove(R)\n         return ans\n         \n             \n             \n"]
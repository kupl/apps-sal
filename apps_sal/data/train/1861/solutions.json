["class Solution:\n    def minAreaRect(self, points):\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in pSet) and ((p2x, p1y) in pSet):\n                    ans = min(ans, abs((p1x - p2x) * (p1y - p2y)))\n        return ans if ans < float('inf') else 0\n    \nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in pSet and (p2x, p1y) in pSet:\n                    ans = area\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n        if Nr < Nc:\n            points = [[c, r] for (r, c) in points]\n            return self.minAreaRect(points)\n    \n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        d = defaultdict(set)\n        rset, cset, N, ans = set(), set(), len(points), float('inf')\n        for r, c in points:\n            rset.add(r)\n            cset.add(c)\n        Nr, Nc = len(rset), len(cset)\n        if Nr == 1 or Nc == 1:\n            return 0\n        elif Nr < Nc:\n            for r, c in points:\n                d[r].add(c)\n        else:\n            for r, c in points:\n                d[c].add(r)\n\n        A = sorted(d.keys())\n        for i, r1 in enumerate(A):\n            cols1 = d[r1]\n            for r2 in A[i+1:]:\n                cols2 = d[r2]\n                s = sorted(cols1 & cols2)\n                for c1, c2 in zip(s[:-1], s[1:]):\n                    area = (r1 - r2) * (c1 - c2)\n                    #ans = min(ans, area)\n                    if area < ans: ans = area\n        return ans if ans < float('inf') else 0\n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        d = defaultdict(set)\n        rset, cset, N, ans = set(), set(), len(points), float('inf')\n        for r, c in points:\n            rset.add(r)\n            cset.add(c)\n        Nr, Nc = len(rset), len(cset)\n        if Nr == 1 or Nc == 1:\n            return 0\n        elif Nr < Nc:\n            for r, c in points:\n                d[r].add(c)\n        else:\n            for r, c in points:\n                d[c].add(r)\n\n        A = sorted(d.keys())\n        for i, r1 in enumerate(A):\n            cols1 = d[r1]\n            for r2 in A[i+1:]:\n                cols2 = d[r2]\n                s = sorted(cols1 & cols2)\n                for c1, c2 in zip(s[:-1], s[1:]):\n                    area = abs((r1 - r2) * (c1 - c2))\n                    ans = min(ans, area)\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        # count of each distinct x axis point\n        countx = len(set(x for x, y in points))\n        # count of each distinct y axixs point\n        county = len(set(y for x, y in points))\n        \n         # if either same as n, no points for that axis\n        if countx == n or county == n:\n            return 0\n        \n        container = defaultdict(list)\n        \n        # add y val to x list in container if x > y, opposite if otherwise\n        if countx > county:\n            for x, y in points:\n                container[x].append(y)\n        else:\n            for x, y in points:\n                container[y].append(x)\n        \n        # seen set/dict\n        lastx = {}\n        ans = float('inf')\n        \n        for x in sorted(container):\n            container[x].sort()\n            # loop for the len of x's list in container\n            for y in range(len(container[x])):\n                # loop curr num/index\n                for z in range(y):\n                    # get from container\n                    y1, y2 = container[x][z], container[x][y]\n                    \n                    #seen before, reset ans to min of itself and last seen x, curr y\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1, y2]) * abs(y2 - y1))\n                    # put curr x in seen\n                    lastx[y1,y2] = x\n        \n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        maxRow = {(col pair): largest row index}\n        \n        for every col pair, if in maxRow, update globalMin, update maxRow\n        \n        O(m * n^2)\n        \\\"\\\"\\\"\n        grid = {}       # {row: [cols with 1]}\n        for x, y in points:\n            grid[x] = grid.get(x, []) + [y]\n        for value in grid.values():\n            value.sort()\n        \n        minArea = float(\\\"inf\\\")\n        maxRow = {}\n        for row in sorted(grid.keys()):\n            n = len(grid[row])\n            for i in range(n):\n                for j in range(i + 1, n):\n                    pair = (grid[row][i], grid[row][j])\n                    if pair in maxRow:\n                        rowPre = maxRow[pair]\n                        minArea = min(minArea, (row - rowPre) * (pair[1] - pair[0]))\n                    maxRow[pair] = row\n        return minArea if minArea != float(\\\"inf\\\") else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort(key = lambda x:(x[0], x[1]))\n        ver = collections.defaultdict(list)\n        hor = collections.defaultdict(list)\n        seen = set()\n        res = float(\\\"inf\\\")\n        for x, y in points:\n            if len(ver[x]) > 0 and len(hor[y]) > 0:\n                for i in ver[x][::-1]:\n                    for j in hor[y][::-1]:\n                        if (j, i) in seen:\n                            res = min(res, (x - j) * (y - i))\n            seen.add((x, y))\n            ver[x].append(y)\n            hor[y].append(x)\n        if res != float(\\\"inf\\\"):\n            return res\n        else:\n            return 0\n\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        cols = collections.defaultdict(list)\n        \n        for x, y in points:\n            cols[x].append(y)\n        \n        min_ = float(\\\"inf\\\")\n        pre_x = {}\n        \n        for x2 in sorted(cols):\n            cols[x2] = sorted(cols[x2])\n            for j in range(len(cols[x2])):\n                for i in range(j):\n                    y1 = cols[x2][i]\n                    y2 = cols[x2][j]\n                    if (y1,y2) in pre_x:\n                        delta_x = x2 - pre_x[y1,y2]\n                        delta_y = y2 - y1\n                        area =  delta_x * delta_y\n                        min_ = min(min_, area)\n                    \n                    pre_x[y1,y2] = x2\n        \n        return min_ if min_ < float(\\\"inf\\\") else 0\n                        \n                        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        d_x = collections.defaultdict(set)\n        d_y = collections.defaultdict(set)\n        for x, y in points: \n            d_x[x].add(y)\n            d_y[y].add(x)\n        area = sys.maxsize            \n        for x, y in points:\n            for yy in d_x[x]: # find same x (point above), larger y\n                if yy <= y: continue\n                for xx in d_y[y]: # find same y (point right), larget x\n                    if xx > x and yy in d_x[xx]:\n                        area = min(area, (xx-x)*(yy-y))\n        return area if area != sys.maxsize else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0", "import collections\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        p = collections.defaultdict(list)\n        for x, y in points:\n            p[x].append(y)\n        \n        lastx = {}\n        res = float('inf')\n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i]\n                    if (y1, y2) in lastx:\n                        res = min(res, (x - lastx[y1, y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        \n        return res if res < float('inf') else 0", "import collections\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        sameX = collections.defaultdict(list)\n        for x, y in points:\n            sameX[x].append(y)\n        lastX = {}\n        minArea = float('inf')\n        for x in sorted(sameX):\n            sameX[x].sort()\n            for i in range(len(sameX[x])):\n                for j in range(i):\n                    y1, y2 = sameX[x][j], sameX[x][i]\n                    if (y1, y2) in lastX:\n                        minArea = min(minArea, (y2-y1) * (x - lastX[y1, y2]))\n                    lastX[y1, y2] = x\n        return minArea if minArea != float('inf') else 0\n", "import numpy as np\nimport collections\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        col = collections.defaultdict(list)\n        lastx = {}\n        ans = float('inf')\n        for x,y in points:\n            col[x].append(y)\n        for x,col_item in sorted(col.items()):\n            col_item = sorted(col_item)\n            for i in range(len(col_item)):\n                y2 = col_item[i]\n                for j in range(i):\n                    y1 = col_item[j]\n                    x1 = lastx.get((y1,y2))\n                    if x1!=None:\n                        ans = min(ans,(x-x1)*(y2-y1))\n                    lastx[(y1,y2)] = x\n                    \n        if ans<float('inf'):\n            return ans\n        else:\n            return 0\n\n        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        columns = defaultdict(list)\n        \n        points = sorted(points, key = lambda x: (x[0], x[1]))\n        \n        for x, y in points:\n            columns[x].append(y)\n                \n        most_recent = {}\n        min_area = float('inf')\n        \n        #for x in sorted(columns):\n        for x in columns:\n            #column = sorted(columns[x])\n            column = columns[x]\n            \n            for index, y2 in enumerate(column):\n                for y1 in column[:index]:\n                    if (y1, y2) in most_recent:\n                        min_area = min(min_area, (y2 - y1) * (x - most_recent[(y1, y2)]))\n                                       \n                    most_recent[(y1, y2)] = x\n        \n        return min_area if min_area < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points):\n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        if nx == n or ny == n:\n            return 0\n\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n\n        lastx = {}\n        res = float('inf')\n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i]\n                    if (y1, y2) in lastx:\n                        res = min(res, (x - lastx[y1, y2]) * abs(y2 - y1))\n                    lastx[y1, y2] = x\n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points: return 0\n        cache_x = defaultdict(set)\n        cache_y = defaultdict(set)\n        cache = set()\n        for i, p in enumerate(points):\n            cache_x[p[0]].add(i)\n            cache_y[p[1]].add(i)\n            cache.add((p[0], p[1]))\n        \n        res = float('inf')\n        for i, (x0, y0) in enumerate(points):\n            cache_x[x0].remove(i)\n            cache_y[y0].remove(i)\n            cache.remove((x0,y0))\n            for ix in cache_y[y0]:\n                for iy in cache_x[x0]:\n                    x1, y1 = points[ix][0], points[iy][1]\n                    if (x1, y1) in cache: \n                        res = min(res, abs(x1-x0)*abs(y1-y0))\n        return 0 if res==float('inf') else res\n            \n", "import collections\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        s= set(map(tuple,points))\n        dx = collections.defaultdict(list)\n        dy = collections.defaultdict(list)\n        for item in points:\n            dx[item[0]].append(item[1])\n            dy[item[1]].append(item[0])\n        \n        res = float(\\\"inf\\\")\n        for x in sorted(dx.keys()):\n            for i in range(len(dx[x])):\n                y1 = dx[x][i]\n                for j in range(i+1,len(dx[x])):\n                    y2 = dx[x][j]\n                    for x1 in dy[y2]:\n                        if x1<=x:\n                            continue\n                        if (x1,y1) in s:\n                            res = min(res,abs(x1-x)*abs(y1-y2))\n        if res ==float(\\\"inf\\\"):\n            return 0\n        return res ", "from collections import defaultdict\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        x_dict = defaultdict(set)\n        \n        # x coordinate as key, y coordiante as value\n        for x, y in points:\n            x_dict[x].add(y)\n            \n        x_vals = list(x_dict.keys())\n        best = float(\\\"inf\\\")\n        \n        # loop through combinations\n        for i in range(1, len(x_vals)):\n            for j in range(i):\n                matching_y = []\n                \n                # find all matching y values, keep track of largest and smallest\n                for y in x_dict[x_vals[i]]: \n                    if y in x_dict[x_vals[j]]:\n                        matching_y.append(y)\n                        \n                # if found two distinct matching y values, can make rectangle\n                if len(matching_y) >= 2:\n                    smallest_diff = get_smallest_diff(matching_y)\n                    best = min(best, smallest_diff * abs(x_vals[i] - x_vals[j]))\n                \n        return 0 if best == float(\\\"inf\\\") else best\n    \ndef get_smallest_diff(array):\n    array.sort()\n    smallest = float(\\\"inf\\\")\n    \n    for i in range(len(array) - 1):\n        smallest = min(smallest, array[i + 1] - array[i])\n        \n    return smallest", "class Solution(object):\n    def minAreaRect(self, points):\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0\n", "from collections import defaultdict\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        x_groups = defaultdict(list)\n        for pnt in points:\n            x_groups[pnt[0]].append(pnt[1])\n            \n        pair2x = dict()\n        \n        min_area = float('inf')\n        for x in sorted(x_groups):\n            group = x_groups[x]\n            group.sort()\n            \n            for i in range(len(group)):\n                for j in range(i + 1, len(group)):\n                    last_x = pair2x.get((group[i], group[j]))\n                    if last_x is not None:\n                        min_area = min(min_area, (x - last_x) * (group[j] - group[i]))\n                    pair2x[group[i], group[j]] = x\n                    \n                    \n        return min_area if min_area < float('inf') else 0", "class Solution(object):\n    def minAreaRect(self, points):\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points):\n        seen, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y):\n                    area = abs((p2x-p1x)*(p2y-p1y))\n                    if area > ans or area == 0:\n                        continue\n                    if (p1x, p2y) in seen and (p2x, p1y) in seen:\n                        ans = area\n        return ans if ans < float('inf') else 0", "class Solution:\n     def minAreaRect(self, points):\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort(key = lambda x: (x[0], x[1]))\n        # print(points)\n        mx_y = defaultdict(list)\n        for x, y in points:\n            mx_y[x].append(y)\n        \n        # print(mx_y)\n        res = float('inf')\n        seenY_pairs = {}\n        \n        for x in mx_y:\n            if len(mx_y[x])<2: continue\n            for i in range(len(mx_y[x])-1):\n                y1 = mx_y[x][i]\n                for j in range(i+1, len(mx_y[x])):\n                    y2 = mx_y[x][j]\n                    \n                    if (y1, y2) in seenY_pairs:\n                        width = x - seenY_pairs[(y1, y2)]\n                        height = y2 - y1\n                        res = min(res, width*height)\n                    seenY_pairs[(y1, y2)] = x\n        \n        if res == float('inf'):\n            return 0\n        else:\n            return res\n        \n# [[1,1],[1,3],[3,1],[3,3],[2,2]]\n# [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        if nx == n or ny == n:\n            return 0\n\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n\n        lastx = {}\n        res = float('inf')\n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i]\n                    if (y1, y2) in lastx:\n                        res = min(res, (x - lastx[y1, y2]) * abs(y2 - y1))\n                    lastx[y1, y2] = x\n        return res if res < float('inf') else 0\n                \n            \n", "from collections import defaultdict\nclass Solution:\n\\tdef minAreaRect(self, points) -> int:\n\\t\\tif(len(points) < 2):\n\\t\\t\\treturn 0\n\n\\t\\tpoints = set(map(tuple,points))\n\\t\\txMap = defaultdict(list)\n\\t\\tyMap = defaultdict(list)\n\n\\t\\tfor point in points:\n\\t\\t\\tx = point[0]\n\\t\\t\\ty = point[1]\n\\t\\t\\t\n\\t\\t\\txMap[x].append(y)\n\n\\t\\t\\tyMap[y].append(x)\n\n\\t\\tresult = float('inf')\n\\t\\tfor x1 in xMap.keys():\n\\t\\t\\tfor i in range(len(xMap[x1])):\n\\t\\t\\t\\ty1 = xMap[x1][i]\n\\t\\t\\t\\tfor j in range(i+1, len(xMap[x1])):\n\\t\\t\\t\\t\\ty2 = xMap[x1][j]\n\\t\\t\\t\\t\\tfor x2 in yMap[y2]:\n\\t\\t\\t\\t\\t\\tif(x1 < x2 and ((x2,y1) in points)):\n\\t\\t\\t\\t\\t\\t\\tresult = min(result,abs((y2-y1)*(x2-x1)))\n\\t\\tif(result == float('inf')):\n\\t\\t\\treturn 0\n\\t\\treturn result", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        hx = dict()\n        hy = dict()\n        \n        for i, (x, y) in enumerate(points):\n            hx.setdefault(x, set())\n            hy.setdefault(y, set())\n            \n            hx[x].add(y)\n            hy[y].add(x)\n        \n        res = float(\\\"inf\\\")\n        \n        \n        for xa, ys in hy.items():\n            for ya in ys:\n                for xb in hx[ya]:\n                    if xa < xb:\n                        for yb in ys:\n                            if yb < ya and yb in hy[xb]:\n                                res = min(res, abs(xa - xb) * abs(ya - yb))\n            \n        return res if res < float(\\\"inf\\\") else 0\n            ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n\n\n        s = set(map(tuple, points))\n        dx = collections.defaultdict(list)\n        dy = collections.defaultdict(list)\n        for x,y in points:\n            dx[x].append(y)\n            dy[y].append(x)\n\n        res = float('inf')\n        for x in sorted(dx.keys()): # 1. find x in dx\n            for i in range(len(dx[x])): # 2. find y1, y2 in dx[x]\n                y1 = dx[x][i]\n                for j in range(i+1, len(dx[x])):\n                    y2 = dx[x][j]\n                    for x1 in dy[y2]: # 3. find x1 in dy[y2]\n                        # always make x in the left side\n                        if x1 <= x: continue\n                        if (x1, y1) in s: # 4. judeg (x1,y1) in points\n                            res = min(res, abs(x-x1) * abs(y1-y2))\n\n        return res if res != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        h = defaultdict(deque)\n        v = defaultdict(deque)\n        p = set([(x, y) for x, y in points])\n\n        for x, y in points:\n            h[x].append(y)\n            v[y].append(x)\n        \n        minArea = float('inf')\n        for x, y in points:\n            for y1 in h[x]:\n                if y1 != y:\n                    for x1 in v[y]:\n                        if x1 != x:\n                            if (x1, y1) in p:\n                                minArea = min(minArea, abs(y1 - y) * abs(x1 - x))\n            if h[x]:\n                h[x].popleft()\n            if v[y]:\n                v[y].popleft()\n\n        if minArea == float('inf'):\n            return 0\n        return minArea\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        record = {}\n        points.sort(key = lambda x: [x[0], x[1]])\n        res = float('inf')\n        temp = [points[0][1]]\n        #print(record, points)\n        for i in range(1, len(points)):\n            if points[i][0] == points[i-1][0]:\n                temp.append(points[i][1])\n            else:\n                if len(temp) >= 2:\n                    for j in range(len(temp)-1):\n                        for k in range(j+1, len(temp)):\n                            if (temp[j], temp[k]) in record:\n                                res = min(res, (points[i-1][0]-record[(temp[j], temp[k])])*(temp[k]-temp[j]))\n                            record[(temp[j], temp[k])] = points[i-1][0]\n                temp = [points[i][1]]\n        #print(temp,record)\n        if len(temp) >= 2:\n            for j in range(len(temp)-1):\n                for k in range(j+1, len(temp)):\n                    if (temp[j], temp[k]) in record:\n                        res = min(res, (points[-1][0]-record[(temp[j], temp[k])])*(temp[k]-temp[j]))\n        \n        if res == float('inf'):\n            return 0\n        return res\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        col = defaultdict(list)\n        \n        for x, y in points:\n            col[x].append(y)\n        \n        res = float('inf')\n        \n        pre = defaultdict(int)\n        for x in sorted(col):\n            col[x].sort()\n            for i in range(len(col[x]) - 1):\n                for j in range(i + 1, len(col[x])):\n                    if (col[x][i], col[x][j]) in pre:\n                        res = min(res, (col[x][j] - col[x][i]) * (x - pre[(col[x][i], col[x][j])]))\n                    pre[(col[x][i], col[x][j])] = x\n        \n        return (res if res != float('inf') else 0)", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        columns = defaultdict(list)\n        lastx = {}\n        ans = sys.maxsize\n        \n        for x, y in points:\n            columns[x].append(y)\n        \n        for x in sorted(columns):\n            y_list = columns[x]\n            y_list.sort()\n            for i, y1 in enumerate(y_list):\n                for j in range(i):\n                    y2 = y_list[j]\n                    \n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[(y1,y2)]) * (y1-y2))\n                    \n                    lastx[(y1,y2)] = x\n        \n        return ans if ans < sys.maxsize else 0\n        \n        \n        '''\n        seen = set()\n        ans = sys.maxsize\n        \n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1-x2) * abs(y1-y2)\n                    ans = min(ans, area)\n            \n            seen.add((x1,y1))\n        \n        return ans if ans < sys.maxsize else 0\n        '''\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        sorted_points = {}\n        for point in points:\n            if point[0] not in sorted_points:\n                sorted_points[point[0]] = []\n            sorted_points[point[0]].append(point)\n        sorted_col = sorted(sorted_points.keys())\n        \n        min_area = None\n        seen = {} # set((row1, row2)) -> col\n        for col in sorted_col:\n            sorted_points[col] = sorted(sorted_points[col])\n            for idx1 in range(len(sorted_points[col])):\n                for idx2 in range(idx1 + 1, len(sorted_points[col])):\n                    point1 = sorted_points[col][idx1]\n                    point2 = sorted_points[col][idx2]\n                    if (point1[1], point2[1]) in seen:\n                        temp = (point2[1] - point1[1]) * (col - seen[(point1[1], point2[1])])\n                        min_area = min(min_area, temp) if min_area is not None else temp\n                    seen[(point1[1], point2[1])] = col\n        \n        # print(seen)\n        \n        return min_area if min_area is not None else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        columns = defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n\n        seen, result = {}, float('inf')\n\n        for x2 in sorted(columns):\n            column = columns[x2]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in seen:\n                        result = min(result, (x2 - seen[y1,y2]) * (y2 - y1))\n                    seen[y1, y2] = x2\n        return result if result != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        nx = len(set(x for x, _ in points))\n        ny = len(set(y for _, y in points))\n        if nx == n and ny == n:\n            return False\n        \n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n        \n        last_x = {}\n        area = float('inf')\n        \n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i]\n                    \n                    if (y1, y2) in last_x:\n                        area = min(area, (x - last_x[(y1, y2)]) * (y2 - y1))\n                    last_x[(y1, y2)] = x\n        return area if area < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        xtoy = collections.defaultdict(set)\n        for x, y in points:\n            xtoy[x].add(y)\n            \n        minarea = sys.maxsize\n        for x1 in xtoy:\n            for x2 in xtoy:\n                if x1 >= x2:\n                    continue \n                commony = list(xtoy[x1].intersection(xtoy[x2]))\n                if len(commony) < 2:\n                    continue \n                commony.sort()\n                width = x2 - x1 \n                height = commony[1] - commony[0]\n                for i in range(2, len(commony)):\n                    height = min(height, commony[i] - commony[i-1])\n                minarea = min(minarea, height * width)\n        return minarea if minarea != sys.maxsize else 0 \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        \n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0\n    \n    \n        \n        # S = set(map(tuple, points))\n        # ans = float('inf')\n        # for j, p2 in enumerate(points):\n        #     for i in range(j):\n        #         p1 = points[i]\n        #         if (p1[0] != p2[0] and p1[1] != p2[1] and\n        #                 (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n        #             ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        # return ans if ans < float('inf') else 0        \n\n        \n        \n        \n#         min_area = float('inf')\n#         same_y = {}\n#         h_segments = {}\n                \n#         for i in range(len(points)  - 1):\n#             for j in range(i + 1 , len(points)):\n#                 if points[i][1] == points[j][1]:\n#                     key = (min(points[i][0] , points[j][0]) , max(points[i][0] , points[j][0]) )\n#                     if key not in h_segments:\n#                         h_segments[key] = []\n#                     h_segments[key].append(points[i][1])\n                                    \n#         for key in h_segments:\n#             width = key[1] - key[0]\n            \n#             val = h_segments[key]\n#             if len(val) > 1:\n#                 for i in range(len(val) - 1):\n#                     for j in range(i, len(val)):\n#                         height = abs(val[i] - val[j])\n#                         if  width > 0 and  height > 0:\n#                             min_area = min(min_area , width * height)\n        \n#         if min_area == float('inf'):\n#             return 0\n                \n#         return min_area\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points:\n            return 0\n        \n        ret = float('inf')\n        \n        r_to_c = collections.defaultdict(list)\n        \n        for r, c in points:\n            r_to_c[r].append(c)\n            \n        seen = {}\n        \n        for bottom in sorted(r_to_c.keys()):\n            cols = r_to_c[bottom]\n            cols.sort()\n            \n            for right_i in range(len(cols)):\n                for left_i in range(right_i):\n                    left = cols[left_i]\n                    right = cols[right_i]\n                    \n                    if (left, right) in seen:\n                        top = seen[(left, right)]\n                        ret = min(ret, (bottom - top) * (right - left))\n                    \n                    seen[(left, right)] = bottom\n                    \n        \n        \n        \n        if ret == float('inf'):\n            return 0\n        return ret", "class Solution:\n    def minAreaRect(self, points):\n        s = set(map(tuple, points))\n        dx = collections.defaultdict(list)\n        dy = collections.defaultdict(list)\n        for x,y in points:\n            dx[x].append(y)\n            dy[y].append(x)\n\n        res = float('inf')\n        for x in sorted(dx.keys()): # 1. find x in dx\n            for i in range(len(dx[x])): # 2. find y1, y2 in dx[x]\n                y1 = dx[x][i]\n                for j in range(i+1, len(dx[x])):\n                    y2 = dx[x][j]\n                    for x1 in dy[y2]: # 3. find x1 in dy[y2]\n                        # always make x in the left side\n                        if x1 <= x: continue\n                        if (x1, y1) in s: # 4. judeg (x1,y1) in points\n                            res = min(res, abs(x-x1) * abs(y1-y2))\n\n        return res if res != float('inf') else 0", "from itertools import combinations\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        area = float('inf')\n        by_x = {}\n        visited = {}\n        for point in points:\n            by_x[point[0]] = []\n        for point in points:\n            by_x[point[0]].append(point[1])\n            \n        for x in sorted(by_x):\n            for y1, y2 in combinations(sorted(by_x[x]), 2):\n                if (y1, y2) in visited:\n                    area = min(area, abs(x - visited[(y1, y2)]) * abs(y2 - y1))\n                visited[(y1, y2)] = x\n            \n        return area if area != float('inf') else 0", "from collections import defaultdict\nfrom itertools import combinations\nimport sys\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        coordMap = defaultdict(set)\n        for x, y in points:\n            coordMap[x].add(y)\n        ans = sys.maxsize\n        for x1, x2 in combinations(list(coordMap.keys()), 2):\n            ylist = coordMap[x1].intersection(coordMap[x2])\n            if len(ylist) < 2:\n                continue\n            ylist = sorted(list(ylist))\n            idx = min(list(range(len(ylist)-1)), key=lambda i: ylist[i+1] - ylist[i])\n            h = ylist[idx+1] - ylist[idx]\n            ans = min(ans, (abs(x2-x1))*h)\n        return ans if ans != sys.maxsize else 0\n                    \n        \n", "import collections\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        columns = {}\n        for x,y in points:\n            if x not in columns:\n                columns[x] = []\n            columns[x].append(y)\n        \n        lastx = {}\n        ans = float('inf')\n        \n        for x in sorted(columns.keys()):\n            column = columns[x]\n            column.sort()\n            for i,v in enumerate(column):\n                for j in range(i):\n                    val = column[j]\n                    if (val, v) in lastx:\n                        ans = min(ans, (x-lastx[val, v])*(v-val))\n                    lastx[val, v] = x\n                    \n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        ans = float('inf')\n        lastx = dict()\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for i,y2 in enumerate(column):\n                for y1 in column[:i]:\n                    if (y1,y2) in lastx:\n                        ans = min(ans, (x-lastx[y1,y2]) * abs(y2-y1))\n                    lastx[y1,y2] = x\n        return ans if ans < float('inf') else 0\n                \n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        points.sort()\n        d, ans = defaultdict(set), float('inf')\n        for r, c in points:\n            d[r].add(c)\n\n        A = list(d.keys())\n        for i, r1 in enumerate(A):\n            cols1 = d[r1]\n            for r2 in A[i+1:]:\n                cols2 = d[r2]\n                s = sorted(cols1 & cols2)\n                for c1, c2 in zip(s[:-1], s[1:]):\n                    area = ((r1 - r2) * (c1 - c2))\n                    if area < ans: ans = area\n        return ans if ans < float('inf') else 0\n\n# from collections import defaultdict\n# class Solution:\n#     def minAreaRect(self, points):\n#         d = defaultdict(set)\n#         rset, cset, N, ans = set(), set(), len(points), float('inf')\n#         for r, c in points:\n#             rset.add(r)\n#             cset.add(c)\n#         Nr, Nc = len(rset), len(cset)\n#         if Nr == N or Nc == N:\n#             return 0\n#         elif Nr < Nc:\n#             for r, c in points:\n#                 d[r].add(c)\n#         else:\n#             for r, c in points:\n#                 d[c].add(r)\n# \n#         A = sorted(d.keys())\n#         for i, r1 in enumerate(A):\n#             cols1 = d[r1]\n#             for r2 in A[i+1:]:\n#                 cols2 = d[r2]\n#                 s = sorted(cols1 & cols2)\n#                 for c1, c2 in zip(s[:-1], s[1:]):\n#                     area = abs((r1 - r2) * (c1 - c2))\n#                     ans = min(ans, area)\n#         return ans if ans < float('inf') else 0\n", "from collections import defaultdict \nclass Solution:\n    def minAreaRect(self, points):\n        d, ans = defaultdict(set), float('inf')\n        for r, c in points:\n            d[r].add(c)\n         \n        #A = sorted(d.keys())\n        A = list(d.keys())\n        for i, r1 in enumerate(A):\n            cols1 = d[r1]\n            for r2 in A[i+1:]:\n                cols2 = d[r2]\n                s = sorted(cols1 & cols2)\n                for c1, c2 in zip(s[:-1], s[1:]):\n                    area = abs((r1 - r2) * (c1 - c2))\n                    if area < ans: ans = area\n        return ans if ans < float('inf') else 0", "import collections as clc\nimport itertools as it\n\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        xs = set()\n        ys = set()\n        for x, y in points:\n            xs.add(x)\n            ys.add(y)\n        ys_at = clc.defaultdict(list)\n        if len(xs) > len(ys):\n            for x, y in points:\n                ys_at[x].append(y)\n        else:\n            for x, y in points:\n                ys_at[y].append(x)\n        latest_x = {}\n        ans = float(\\\"inf\\\")\n        for x in sorted(ys_at):\n            for y1, y2 in it.combinations(ys_at[x], 2):\n                y1, y2 = sorted([y1, y2])\n                if (y1, y2) in latest_x:\n                    ans = min(ans, (x - latest_x[y1, y2]) * (y2 - y1))\n                latest_x[y1, y2] = x\n        return ans if ans != float(\\\"inf\\\") else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        def compute_table(points, axis=0):\n            table = {}\n            for point in points:\n                key, value = point[axis], point[1-axis]\n                if key in table:\n                    table[key].append(value)\n                else:\n                    table[key] = [value]\n            return table\n\n        points.sort()\n        x_2_y = compute_table(points, 0)\n        y_2_x = compute_table(points, 1)\n        min_area = float('inf')\n        hashed = set([tuple(point) for point in points])\n        for point in points:\n            x, y = point\n            y_candidates = [_y for _y in x_2_y[x] if _y > y]\n            x_candidates = [_x for _x in y_2_x[y] if _x > x]\n            for c_y in y_candidates:\n                for c_x in x_candidates:\n                    if (c_x, c_y) in hashed:\n                        min_area = min(min_area, abs(c_y - y) * abs(c_x - x))\n        # no rectangles\n        if min_area == float('inf'):\n            return 0\n        return min_area\n", "from collections import defaultdict \nclass Solution:\n    def minAreaRect(self, points):\n        d, ans = defaultdict(set), float('inf')\n        for r, c in points:\n            d[r].add(c)\n         \n        A = sorted(d.keys())\n        for i, r1 in enumerate(A):\n            cols1 = d[r1]\n            for r2 in A[i+1:]:\n                cols2 = d[r2]\n                s = sorted(cols1 & cols2)\n                for c1, c2 in zip(s[:-1], s[1:]):\n                    area = abs((r1 - r2) * (c1 - c2))\n                    if area < ans: ans = area\n        return ans if ans < float('inf') else 0", "from collections import defaultdict \nclass Solution:\n    def minAreaRect(self, points):\n        d, ans = defaultdict(set), float('inf')\n        for r, c in points:\n            d[r].add(c)\n         \n        A = sorted(d.keys())\n        for i, r1 in enumerate(A):\n            cols1 = d[r1]\n            for r2 in A[i+1:]:\n                cols2 = d[r2]\n                s = sorted(cols1 & cols2)\n                for c1, c2 in zip(s[:-1], s[1:]):\n                    area = abs((r1 - r2) * (c1 - c2))\n                    ans = min(ans, area)\n        return ans if ans < float('inf') else 0", "from collections import defaultdict\nfrom itertools import combinations\nimport sys\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        coordMap = defaultdict(list)\n        visited = {}\n        for x, y in points:\n            coordMap[x].append(y)\n        ans = sys.maxsize\n        for x in sorted(coordMap):\n            for y1, y2 in combinations(sorted(coordMap[x]), 2):\n                if (y1, y2) in visited:\n                    ans = min(ans, (x-visited[y1, y2])*abs(y1-y2))\n                visited[y1, y2] = x\n        return ans if ans != sys.maxsize else 0\n                \n                \n                    \n        \n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        d, ans = defaultdict(set), float('inf')\n        for r, c in points:\n            d[r].add(c)\n\n        A = list(d.keys())\n        for i, r1 in enumerate(A):\n            cols1 = d[r1]\n            for r2 in A[i+1:]:\n                cols2 = d[r2]\n                s = sorted(cols1 & cols2)\n                for c1, c2 in zip(s[:-1], s[1:]):\n                    area = abs((r1 - r2) * (c1 - c2))\n                    if area < ans: ans = area\n        return ans if ans < float('inf') else 0\n\n# from collections import defaultdict\n# class Solution:\n#     def minAreaRect(self, points):\n#         d = defaultdict(set)\n#         rset, cset, N, ans = set(), set(), len(points), float('inf')\n#         for r, c in points:\n#             rset.add(r)\n#             cset.add(c)\n#         Nr, Nc = len(rset), len(cset)\n#         if Nr == N or Nc == N:\n#             return 0\n#         elif Nr < Nc:\n#             for r, c in points:\n#                 d[r].add(c)\n#         else:\n#             for r, c in points:\n#                 d[c].add(r)\n# \n#         A = sorted(d.keys())\n#         for i, r1 in enumerate(A):\n#             cols1 = d[r1]\n#             for r2 in A[i+1:]:\n#                 cols2 = d[r2]\n#                 s = sorted(cols1 & cols2)\n#                 for c1, c2 in zip(s[:-1], s[1:]):\n#                     area = abs((r1 - r2) * (c1 - c2))\n#                     ans = min(ans, area)\n#         return ans if ans < float('inf') else 0\n", "from collections import defaultdict\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        #x1,y2  x2,y2\n        #x1,y1  x2,y1\n        \n        xp = defaultdict(set)\n        yp = defaultdict(set)\n        for x, y in points:\n            xp[x].add(y)\n            yp[y].add(x)\n        \n        a_min = None\n        for x1, ys in xp.items():\n            if len(ys) < 2:\n                continue\n            for y1 in ys:\n                for y2 in ys:\n                    if y1 >= y2:\n                        continue\n                    for x2 in yp.get(y2, []):\n                        if x1 >= x2:\n                            continue\n                        if y1 in xp[x2]:\n                            area = (x2 - x1) * (y2 - y1)\n                            if a_min is None:\n                                a_min = area\n                            else:\n                                a_min = min(area, a_min)\n        if a_min is None:\n            return 0\n        return a_min", "import math\n\nfrom collections import defaultdict\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        horizontal_lines = defaultdict(set)\n        vertical_lines   = defaultdict(set)\n        \n        for x, y in points:\n            vertical_lines[x].add(y)\n            horizontal_lines[y].add(x)\n        \n        min_area = math.inf \n        for x, y in points:\n            for next_y in vertical_lines[x]:\n                if next_y > y:\n                    for intersect_x in horizontal_lines[y] & horizontal_lines[next_y]:\n                        if intersect_x < x:\n                            min_area = min((x - intersect_x) * (next_y - y), min_area)\n                            \n        if min_area == math.inf:\n            return 0\n        else:\n            return min_area", "from collections import defaultdict\nclass Solution:\n    # O(n ^ 2) Time | O(n) Space\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        rows = defaultdict(list)\n        for i, j in points:\n            rows[i].append(j)\n        result = float('inf')\n        lastRow = {}\n        for row in sorted(rows.keys()):\n            cols = (rows[row])\n            cols.sort()\n            for j, col2 in enumerate(cols):\n                for i in range(j):\n                    col1 = cols[i]\n                    if (col1, col2) in lastRow:\n                        result = min(result, ((row - lastRow[(col1, col2)]) * (col2 - col1)))\n                    lastRow[(col1, col2)] = row\n        return result if result != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # sort by x // N log(N)\n        # [y0, y1] -> (min dx, last) // log(N)\n\n        lines = self.find_lines(points)\n        min_area = 0\n        d = {}\n        for x, ys in lines:\n            if ys in d:\n                px = d[ys]\n                curr_min_area = abs(x - px) * abs(ys[0] - ys[1])\n                min_area = min(min_area, curr_min_area) if min_area > 0 else curr_min_area\n            d[ys] = x\n        return min_area\n        \n    def find_lines(self, points: List[List[int]]) -> List[Tuple[int, Tuple[int, int]]]:\n        ps = defaultdict(list)\n        for x, y in sorted(points):\n            ps[x].append(y)\n        lines = []\n        for x, ys in ps.items():\n            for i, y0 in enumerate(ys):\n                for y1 in ys[i+1:]:\n                    lines.append((x, (y0, y1)))\n        return lines", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        if nx == n or ny == n:\n            return 0\n\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n\n        lastx = {}\n        res = float('inf')\n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i]\n                    if (y1, y2) in lastx:\n                        res = min(res, (x - lastx[y1, y2]) * abs(y2 - y1))\n                    lastx[y1, y2] = x\n        return res if res < float('inf') else 0\n", "from collections import defaultdict\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        points.sort(key = lambda x: (x[0], x[1]))\n        \n        heights = defaultdict(list)\n        for point in points:\n            x, h = point\n            heights[x].append(h)\n            \n        segments = {}\n        keys = list(heights.keys())\n        keys.sort()\n        min_area = float('inf')\n        \n        for x in keys:    \n            heights_x = heights[x]\n            if len(heights_x) < 2:\n                continue\n                \n            # print(x, heights_x)\n            \n            for i in range(len(heights_x)-1):\n                for j in range(i+1, len(heights_x)):\n                    pair = (heights_x[i], heights_x[j])\n                    if pair not in segments:\n                        segments[pair] = [None, x]\n                    else:\n                        height_diff = heights_x[j] - heights_x[i]\n                        width_diff = x  - segments[pair][1]\n                        area = height_diff * width_diff\n                        min_area = min(min_area, area)\n                        segments[pair] = [segments[pair][1], x]\n            \n        if min_area == float('inf'):\n            return 0\n        else:\n            return min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        x_dict = defaultdict(set)\n        for p in points:\n            x_dict[p[0]].add(p[1])\n\n        min_area = float(\\\"inf\\\")\n        x = sorted(list(x_dict.keys()))\n        for i in range(len(x)):\n            for j in range(i+1, len(x)):\n                y = sorted(list(x_dict[x[i]] & x_dict[x[j]]))\n                if len(y)>1:\n                    min_height = min(y[k]-y[k-1] for k in range(1, len(y)))\n                    min_area = min(min_area, (x[j]-x[i])*min_height)\n        \n        if min_area == float(\\\"inf\\\"):\n            return 0\n        \n        return min_area\n    \n                    \n                \n                ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort()\n        xs = collections.defaultdict(list)\n        ys = collections.defaultdict(list)\n        for x, y in points:\n            xs[x].append(y)\n            ys[y].append(x)\n        result = math.inf\n        for x0, ylist in xs.items():\n            for y1, y2 in itertools.combinations(ylist, 2):\n                xlist1, xlist2 = ys[y1], ys[y2]\n                m, n = len(xlist1), len(xlist2)\n                i = bisect.bisect(xlist1, x0)\n                if i == m:\n                    continue\n                j = bisect.bisect(xlist2, x0)\n                if j == n:\n                    continue\n                while i < m and j < n:\n                    if xlist1[i] < xlist2[j]:\n                        i += 1\n                    elif xlist1[i] > xlist2[j]:\n                        j += 1\n                    else:\n                        result = min(result, (xlist1[i] - x0) * (y2 - y1))\n                        break\n        return 0 if math.isinf(result) else  result", "import collections\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points:\n            return 0\n        dic = collections.defaultdict(list)\n        for x,y in points:\n            dic[x].append(y)\n        \n        res = float('inf')\n        store = {}\n        for x in sorted(dic):\n            col = sorted(dic[x])\n            for i, y1 in enumerate(col):\n                for j in range(i):\n                    if (y1,col[j]) not in store:\n                        store[(y1,col[j])] = x\n                    else:\n                        res = min(res, (y1-col[j])*(x-store[(y1,col[j])]))\n                        store[(y1,col[j])] = x\n        return res if res != float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        table = {}\n        mark = []\n        best = 0\n        for i in points:\n            if i[0] not in table:\n                table[i[0]] = [[i[1]],[]]\n            else:\n                if i[1] not in table[i[0]][0]:\n                    for j in table[i[0]][0]:\n                        if j < i[1]:\n                            table[i[0]][1].append((j, i[1]))\n                        else:\n                            table[i[0]][1].append((i[1],j))\n                    table[i[0]][0].append(i[1])\n                    if len(table[i[0]][0]) == 2:\n                        mark.append(i[0])\n        g = {}\n        if len(mark) < 2:\n            return 0\n        for i in mark:\n            p = table[i]\n            for j in p[1]:\n                if j in g:\n                    for k in g[j]:\n                        temp = abs((k - i) * (j[1] - j[0]))\n                        if best == 0 or temp < best:\n                            best = temp\n                    g[j].append(i)\n                else:\n                    g[j] = [i]\n        return best", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n < 4:\n          return 0\n        s = set([tuple(i) for i in points])\n        d = {}\n        for i in points:\n          if i[0] in d:\n            d[i[0]].append(i[1])\n          else:\n            d[i[0]] = [i[1]]\n        # print(d)\n        for i in list(d.keys()):\n          if len(d[i]) == 1:\n            d.pop(i)\n        # print(d)\n        dkeys = list(d.keys())\n        minarea = float('inf')\n        for i in range(len(dkeys)-1):\n          if len(points[i]) == 1:\n            continue\n\n          for x in range(len(d[dkeys[i]])-1):\n            for y in range(x+1, len(d[dkeys[i]])):\n              for j in range(i+1, len(dkeys)):\n                # print(i, j, d[dkeys[i]], x, y, (dkeys[j], d[dkeys[i]][x]), (dkeys[j], d[dkeys[i]][y]))\n                if (dkeys[j], d[dkeys[i]][x]) in s and (dkeys[j], d[dkeys[i]][y]) in s:\n                  # found a rectangle\n                  # print('test1', dkeys[i], dkeys[j], d[dkeys[i]][x], d[dkeys[i]][y])\n                  minarea = min(minarea, abs(dkeys[i]-dkeys[j])*abs(d[dkeys[i]][x]-d[dkeys[i]][y]))\n        \n        if minarea == float('inf'):\n          return 0\n        return minarea", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points)<4:\n            return\n        minimum=float(\\\"inf\\\")\n        length=defaultdict(list)\n        for x,y in points:\n            length[x].append(y)\n         \n        print(length)\n        breadth={}\n        \n        for x in sorted(length):\n            values=length[x]\n            print(values)\n            values.sort()\n            if len(values)<2:\n                continue\n            for i in range(0,len(values)-1):\n                for j in range(i+1,len(values)):\n                    if (values[i],values[j]) in breadth:\n                        minimum=min(minimum,(x-breadth[(values[i],values[j])])*(values[j]-values[i]))\n                        \n                    breadth[(values[i],values[j])]=x\n        \n        if minimum==float(\\\"inf\\\"):\n            return 0\n        else:\n            return minimum\n        ", "class Solution:\n    def minAreaRect(self, points):\n        seen, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in seen and (p2x, p1y) in seen:\n                    ans = area\n        return ans if ans < float('inf') else 0", "class Solution(object):\n    def minAreaRect(self, points):\n        \\\"\\\"\\\"\n        :type points: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        seen = set()\n        res = float('inf')\n        # for point, compare with all other points that we've seen so far, a rectangle can only be formed when the two points are diagonal to each other and the other points forming the other two corners also exist. If the points are parallel you don't know if you can form a rectangle yet. If there exists two other points that form a rectangle with them you will run into them both in the future so no worries to attempt to find them right away.\n        for (x1, y1) in points:\n            for (x2, y2) in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x2-x1) * abs(y2-y1)\n                    if area < res:\n                        res = area\n            seen.add((x1, y1))\n        return res if res != float('inf') else 0", "\nclass Solution(object):\n    def minAreaRect(self, points):\n        seen = set()\n        res = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    if area and area < res:\n                        res = area\n            seen.add((x1, y1))\n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        nx = len(set(x for x, _ in points))\n        ny = len(set(y for _, y in points))\n        \n        if n == nx or n == ny:\n            return 0\n        \n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n        \n        last_x = {}\n        res = float('inf')\n        \n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i]\n                    \n                    if (y1, y2) in last_x:\n                        res = min(res, (y2 - y1) * (x - last_x[(y1, y2)]))\n                    last_x[(y1, y2)] = x\n        \n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        nx, ny = len(set(x for x, _ in points)), len(set(y for _, y in points))\n        \n        if nx == n or ny == n:\n            return 0\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n        \n        res = float('inf')\n        dic_last = {}\n        for x1, x2 in itertools.combinations(p, 2):\n            if (len(p[x1]) < 2 or len(p[x2]) < 2):\n                continue\n            for y1, y2 in itertools.combinations( sorted(set(p[x1]) & set(p[x2])), 2 ):\n                res = min(res, abs(x1-x2) * (y2 - y1))\n        # for x in sorted(p):\n        #     # print(x)\n        #     p[x].sort()\n        #     for y1, y2 in itertools.combinations(p[x], 2):\n        #         if (y1, y2) in dic_last:\n        #             res = min(res, abs( x - dic_last[y1, y2]) * abs(y1 -y2))\n        #             # if res == 2:\n        #             #     print(x, dic_last[y1, y2],  y1, y2)\n        #         dic_last[y1, y2] = x\n        return res if res < float('inf') else 0\n        \n        # n = len(points)\n        # nx, ny = len(set(x for x, y in points)), len(set(y for x, y in points))\n        # if nx == n or ny == n:\n        #     return 0\n        \n        # p = collections.defaultdict(list)\n        # if nx > ny:\n        #     for x, y in points:\n        #         p[x].append(y)\n        # else:\n        #     for x, y in points:\n        #         p[y].append(x)\n        # res = float('inf')\n        # dic = {}\n        # for x in sorted(p):\n        #     p[x].sort()\n        #     for y1, y2 in itertools.combinations(p[x], 2):\n        #         if (y1, y2) in dic:\n        #             res = min(res, abs(x - dic[y1, y2]) * abs(y1 - y2) )\n        #         dic[y1, y2] = x\n        # return res if res < float('inf') else 0\n#         dic_x = {}\n        \n#         n = len(points)\n#         nx, ny = len( set(x for x, y in points) ), len( set(y for x, y in points) )\n#         if nx == n or ny == n:\n#             return 0\n        \n#         p = collections.defaultdict(list)\n#         if nx > ny:\n#             for x, y in points:\n#                 p[x].append(y)\n#         else:\n#             for x, y in points:\n#                 p[y].append(x)\n#         res = float('inf')\n#         for x in sorted(p):\n#             p[x].sort()\n            \n#             for y1, y2 in itertools.combinations(p[x], 2):\n#                 # y1, y2 = p[x][i], p[x][j]\n#                 if (y1, y2) in dic_x:\n#                     res = min(res, abs(x - dic_x[y1, y2]) * abs(y1 -y2))\n#                 dic_x[y1, y2] = x\n#         return res if res < float('inf') else 0\n#         seen = set()\n        \n#         res = float('inf')\n#         for x1, y1 in points:\n#             for x2, y2 in seen:\n#                 if (x1, y2) in seen and (x2, y1) in seen:\n#                     area = abs(x1 - x2) * abs(y1 - y2)\n#                     if area and res > area:\n#                         res = area\n#                     # res = min(res, )\n#             seen.add((x1, y1))\n#         return res if res < float('inf') else 0\n", "from collections import defaultdict\nimport sys\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        coordMap = defaultdict(set)\n        for x, y in points:\n            coordMap[x].add(y)\n        xlist = sorted(list(coordMap.keys()))\n        ans = sys.maxsize\n        for i in range(1, len(xlist)):\n            for j in range(len(xlist)-i):\n                ylist = coordMap[xlist[j]].intersection(coordMap[xlist[j+i]])\n                if len(ylist) < 2:\n                    continue\n                ylist = sorted(list(ylist))\n                idx = min(list(range(len(ylist)-1)), key=lambda i: ylist[i+1]-ylist[i])\n                h = ylist[idx+1]-ylist[idx]\n                ans = min(ans, (xlist[j+i]-xlist[j])*h)\n        return ans if ans != sys.maxsize else 0\n                    \n        \n", "class Solution(object):\n    def minAreaRect(self, points):\n        \\\"\\\"\\\"\n        :type points: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        seen = set()\n        res = float('inf')\n        # for point, compare with all other points that we've seen so far, a rectangle can only be formed when the two points are diagonal to each other and the other points forming the other two corners also exist. If the points are parallel you don't know if you can form a rectangle yet. If there exists two other points that form a rectangle with them you will run into them both in the future so no worries to attempt to find them right away.\n        for (x1, y1) in points:\n            # all points are distinct so you are guaranteed to not run into (x1, y1)\n            for (x2, y2) in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x2-x1) * abs(y2-y1)\n                    if area < res:\n                        res = area\n            seen.add((x1, y1))\n        return res if res != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points):\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in pSet and (p2x, p1y) in pSet:\n                    ans = area\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        result = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    if area and area < result:\n                        result = area\n            seen.add((x1, y1))\n            \n        return result if result != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n#         res = 2**31\n#         s = {(p[0], p[1]) for p in points}\n        \n#         for i, p1 in enumerate(points):\n#             for j, p2 in enumerate(points[i + 1:]):\n#                 if p1[0] != p2[0] and p1[1] != p2[1]:\n#                     if (p1[0], p2[1]) in s and (p2[0], p1[1]) in s:\n#                         res = min(res, abs(p1[1] - p2[1]) * abs(p1[0] - p2[0]))\n#         res = res if res < 2**31 else 0\n#         return res\n        \n        seen = set()\n        res = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    if area and area < res:\n                        res = area\n            seen.add((x1, y1))\n        return res if res < float('inf') else 0\n\n                \n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort()\n        points_set = set([tuple(point) for point in points])\n        smallest = float('inf')\n        for i, (x1, y1) in enumerate(points):\n            for j, (x2, y2) in enumerate(points[i:]):\n                if x1 < x2 and y1 < y2 and (x1, y2) in points_set and (x2, y1) in points_set:\n                    area = (x2 - x1) * (y2 - y1)\n                    smallest = min(smallest, area)\n        return smallest if smallest != float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        res = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    if area and area < res:\n                        res = area\n            seen.add((x1, y1))\n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort()\n        points_set = set([tuple(point) for point in points])\n        smallest = float('inf')\n        for i, (x1, y1) in enumerate(points):\n            for j, (x2, y2) in enumerate(points[i:], i):\n                if x1 < x2 and y1 < y2 and (x1, y2) in points_set and (x2, y1) in points_set:\n                    area = (x2 - x1) * (y2 - y1)\n                    smallest = min(smallest, area)\n        return smallest if smallest != float('inf') else 0\n", "class Solution(object):\n    def minAreaRect(self, points):\n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        if nx == n or ny == n:\n            return 0\n\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n\n        lastx = {}\n        res = float('inf')\n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i]\n                    if (y1, y2) in lastx:\n                        res = min(res, (x - lastx[y1, y2]) * abs(y2 - y1))\n                    lastx[y1, y2] = x\n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        import math\n        from collections import defaultdict\n        row_m = defaultdict(list)\n        \n        for x, y in points:\n            row_m[x].append(y)\n            \n        sol = float(\\\"inf\\\")\n        # print(rows)\n        pairs = {}\n        \n        for x in sorted(row_m):\n            row = row_m[x]\n            for i in range(len(row)):                \n                for j in range(i + 1, len(row)):\n                    \n                    candidate = tuple(sorted([row[i], row[j]]))\n                    if candidate in pairs:\n                        sol = min(\n                            sol,\n                            abs(pairs[candidate] - x) * abs(row[i] - row[j]),\n                        )                        \n                    \n                    pairs[candidate] = x\n        # print(pairs)\n        if sol == float('inf'):\n            return 0\n        return sol\n                \n            \n            ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_set = set()\n        points.sort()\n        for point in points:\n            point_set.add((point[0], point[1]))\n        \n        min_area = math.inf\n        N = len(points)\n        for i in range(N):\n            start_point = points[i]\n            for j in range(i+1,N):\n                end_point = points[j]\n                if end_point[0] > start_point[0] and end_point[1] > start_point[1]:\n                    area = (end_point[0]-start_point[0])*(end_point[1]-start_point[1])\n                    if area < min_area and \\\\\n                       (start_point[0], end_point[1]) in point_set and \\\\\n                       (end_point[0], start_point[1]) in point_set:\n                        min_area = area\n                \n        return min_area if min_area != math.inf else 0\n            \n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n       \n        # pointsSet = set([(x, y) for x, y in points])\n        # minv = float('inf')\n        # for i in range(len(points)): \n        #     for j in range(i + 1, len(points)):\n        #         if points[i][0] != points[j][0] and points[i][1] != points[j][1] and  (points[i][0], points[j][1]) in pointsSet and (points[j][0], points[i][1]) in pointsSet:\n        #             minv = min(minv, abs(points[i][0] - points[j][0])*abs(points[i][1] - points[j][1]))\n        #             if minv == 1: print(points[i], points[j])\n        # return minv if minv != float('inf') else 0\n    \n        \n        seen = set()\n        minv = float('inf')\n        for x, y in points:\n            for a, b in seen:\n                if x != a and y != b and (x, b) in seen and (a, y) in seen:\n                    minv = min(minv, abs(a - x)*abs(y - b))\n            seen.add((x,y))\n        return  minv if minv != float('inf') else 0\n                    \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        output = float('inf')\n        \n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    if area > 0 and area < output:\n                        output = area\n            seen.add((x1,y1))\n        return output if output < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        res = inf = float('inf')\n        seen = set()\n        n = len(points)\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    res = min(res, abs((x2-x1)*(y2-y1)))\n            seen.add((x1, y1))\n        return res if res != inf else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        \n        area = float('inf')\n        seen = set()\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if x1 != x2 and y1 != y2:\n                    if (x1, y2) in seen and (x2, y1) in seen:\n                        l, w = abs(x1 - x2), abs(y1 - y2)\n                        area = min(area, l*w)\n                        \n            seen.add((x1, y1))\n        \n        return 0 if area == float('inf') else area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        res = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    if area and area < res:\n                        res = area\n            seen.add((x1, y1))\n        return res if res < float('inf') else 0\n", "import sys\nclass Solution:\n    def minAreaRect(self, points):\n        seen = set()\n        res = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    if area and area < res:\n                        res = area\n            seen.add((x1, y1))\n        return res if res < float('inf') else 0", "class Solution(object):\n     def minAreaRect(self, points):\n        seen = set()\n        res = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    if area and area < res:\n                        res = area\n            seen.add((x1, y1))\n        return res if res < float('inf') else 0", "class Solution(object):\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        setx = set()\n        sety = set()\n        for x, y in points:\n            setx.add(x)\n            sety.add(y)\n        nx = len(setx)\n        ny = len(sety)\n\n        if nx == n or ny == n:\n            return 0\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n\n        res = float('inf')\n        dic_last = {}\n        for x in sorted(p):\n            p[x].sort()\n            for y1, y2 in itertools.combinations(p[x], 2):\n                if (y1, y2) in dic_last:\n                    res = min(res, (x - dic_last[y1, y2]) * (y2-y1))\n                dic_last[y1, y2] = x\n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        ans = float('inf')\n        \n        for x1,y1 in points:\n            for x2,y2 in seen:\n                if (x1,y2) in seen and (x2,y1) in seen:\n                    ans = min(ans, abs(x1-x2)*abs(y1-y2) )\n            \n            seen.add((x1,y1))\n            \n        return(ans if ans!=float(inf) else 0)\n            \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        '''\n        Input: [[1,1],[1,3],[3,1],[3,3],[2,2]]\n        visited = {(1,1), (1,3)}\n        '''\n        visited = set()\n        output = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in visited:\n                if (x1, y2) in visited and (x2, y1) in visited:\n                    temp = abs(x2 - x1) * abs(y2 - y1)\n                    if temp < output:\n                        output = temp\n            visited.add((x1, y1))\n        return output if output != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # count by diagonal, Time O(n^2); space O(n)\n        seen = set()\n        res = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    res = min(res, area)\n                    \n            seen.add((x1, y1))\n        return res if res != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        res = inf = float('inf')\n        seen = set()\n        n = len(points)\n        for x1, y1 in set(map(tuple, points)):\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    res = min(res, abs((x2-x1)*(y2-y1)))\n            seen.add((x1, y1))\n        return res if res != inf else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        \n        area = float('inf')\n        seen = set()\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    l, w = abs(x1 - x2), abs(y1 - y2)\n                    area = min(area, l*w)\n                        \n            seen.add((x1, y1))\n        \n        return area if area < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        res = float('inf')\n        for (x1, y1) in points:\n            for (x2, y2) in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    res = min(res, abs(x2-x1) * abs(y2-y1))\n            seen.add((x1, y1))\n        return res if res != float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        min_area = float('inf')\n        seen = set()\n        \n        poi = []\n        for x, y in points:\n            poi.append((x, y))\n        \n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    if area and area < min_area:\n                        min_area = area\n\n            seen.add((x1, y1))\n                    \n        return min_area if min_area < float('inf') else 0\n            \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        min_area = math.inf\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen and (x1, y2) != (x2, y1):\n                    area = abs(x2 - x1) * abs(y2 - y1)\n                    if area < min_area:\n                        min_area = area\n            seen.add((x1, y1))\n        return min_area if min_area < math.inf else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        \n        seen = set()\n        minarea = sys.maxsize\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1,y2) in seen and (x2,y1) in seen:\n                    minarea = min(minarea, abs(x2-x1)*abs(y2-y1))\n            seen.add((x1,y1))\n        return minarea if minarea < sys.maxsize else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        res = float('inf') # initiate as inf\n        lookup = set()\n        for x1, y1 in points:\n            for x2, y2 in lookup:\n                if (x1, y2) in lookup and (x2, y1) in lookup: # if all in the lookup\n                    res = min(res, abs(x1-x2) * abs(y1-y2)) # check the min area\n            # add to lookup for the outer loop\n            lookup.add((x1, y1))\n        return res if res != float('inf') else 0\n    \n    \n        ys_with_same_x = defaultdict(list)\n        for x, y in points:\n            ys_with_same_x[x].append(y)\n        \n        pair_of_ys_history = {}\n        res = float('inf')\n        for x, ys in sorted(ys_with_same_x.items()):\n            ys.sort()\n            for i, y1 in enumerate(ys):\n                for j in range(i):\n                    y2 = ys[j]\n                    if (y1, y2) in pair_of_ys_history:\n                        res = min(res, (x - pair_of_ys_history[(y1,y2)]) * (y1-y2) )\n                    pair_of_ys_history[(y1,y2)] = x\n        if res == float('inf'):\n            return 0\n        else:\n            return res\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        \n        p = collections.defaultdict(list)\n        lastseen = {}\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n                \n        minarea =float(\\\"inf\\\")     \n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1,y2 = p[x][i], p[x][j]\n                    if (y1,y2) in lastseen:\n                        area = abs(y1-y2) * abs(x-lastseen[(y1,y2)])\n                        minarea = min(area,minarea)\n                    lastseen[(y1,y2)] = x\n        #print(lastseen)\n        return minarea if minarea < 10**21 else 0", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        res = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1,y2) in seen and (x2,y1) in seen:\n                    # find the rectangle\n                    res = min(res, abs(x1-x2)*abs(y1-y2))\n            seen.add((x1,y1))\n            \n        return res if res < float('inf') else 0\n                    \n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_set = set((x, y) for x, y in points)\n        min_rec = math.inf\n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 < x2 and y1 > y2:\n                    if (x1, y2) in point_set and (x2, y1) in point_set:\n                        min_rec = min(min_rec, (x2 - x1) * (y1 - y2))\n        return 0 if min_rec == math.inf else min_rec", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        \n        area = float('inf')\n        seen = set()\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    l, w = abs(x1 - x2), abs(y1 - y2)\n                    area = min(area, l*w)\n                        \n            seen.add((x1, y1))\n        \n        return 0 if area == float('inf') else area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # N = 500 is really loose.\n        # Just check all pairs of points.\n        # Time O(N^2) , 1000ms ~ 1200ms\n        \n        seen = set()\n        minA = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1,y2) in seen and (x2,y1) in seen:\n                    area = abs(x1-x2)*abs(y1-y2)\n                    minA = min(minA, area)\n            seen.add((x1,y1))\n        return minA if minA<float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        \n        # Rectangle (x0, y0), (x1, y1), (x0, y1), (x1, y0)\n        min_area = float('inf')\n        seen = set()\n        \n        \n        for x0, y0 in points: \n            for x1, y1 in seen: \n                if (x0, y1) in seen and (x1, y0) in seen: \n                    current_area = (abs(y1-y0))*(abs(x1-x0))\n                    # print(current_area)\n                    min_area = min(min_area, current_area)\n            seen.add((x0, y0))\n        \n\n        \n        return min_area if min_area != float('inf') else 0 \n    \n    \n    \n    \n    \n    \n        #     .       .\n        #         .\n        #     .       .\n        # .\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        def smallestinterval(l):\n            rst = float('inf')\n            for i in range(1, len(l)):\n                if l[i] - l[i-1] < rst:\n                    rst = l[i] - l[i-1]\n            return rst\n            \n        xloc = defaultdict(set)\n#        yloc = defaultdict(set())\n        for p in points:\n            xloc[p[0]].add(p[1])\n#            yloc[p[1]].add(p[0])\n        minarea = float('inf')\n        xkeys = list(xloc.keys())\n        for x1 in xkeys:\n            for x2 in xkeys:\n                if x1 != x2:\n                    sharedy = xloc[x1] & xloc[x2]\n                    if len(sharedy)> 1:\n                        ally = list(sharedy)\n                        ally.sort()\n                        smallinterval = smallestinterval(ally)\n                        if smallinterval * abs(x1 - x2) < minarea:\n                            minarea = smallinterval * abs(x1-x2)\n        if minarea == float('inf'):\n            return 0\n        return minarea\n        \n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n        if Nr < Nc:\n            points = [[c, r] for (r, c) in points]\n            return self.minAreaRect(points)\n\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in columns.items():\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0", "class Solution(object):\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        setx = set()\n        sety = set()\n        for x, y in points:\n            setx.add(x)\n            sety.add(y)\n        nx = len(setx)\n        ny = len(sety)\n\n        if nx == n or ny == n:\n            return 0\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n\n        res = float('inf')\n        dic_last = {}\n        for x in sorted(p):\n            column = p[x]\n            column.sort()\n            for y1, y2 in itertools.combinations(column, 2):\n                if (y1, y2) in dic_last:\n                    res = min(res, (x - dic_last[y1, y2]) * (y2 -y1))\n                dic_last[y1, y2] = x\n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        min_area = math.inf\n        seen = set()\n        \n        for x0, y0 in points:\n            for x1, y1 in seen:\n                if (x0, y1) in seen and (x1, y0) in seen:\n                    area = abs(x0 - x1) * abs(y0 - y1)\n                    if area > 0:\n                        min_area = min(min_area, area)\n            seen.add((x0, y0))\n        \n        return 0 if min_area == math.inf else min_area", "from collections import defaultdict\n\nclass Solution:\n    \n    def minAreaRect(self, points: List[List[int]]) -> int:\n        area = float('inf')\n        gx = defaultdict(list)\n        gy = defaultdict(list)\n        \n        for p in points:\n            [x1, y1] = p\n            \n            if x1 in gx and y1 in gy:\n                for y2 in gx[x1]:\n                    if y2 in gy:\n                        for x2 in gy[y2]:\n                            if x2 in gy[y1]:\n                                area = min(area, abs(x1-x2) * abs(y1-y2))\n            gx[x1].append(y1)\n            gy[y1].append(x1)\n            \n        return area if area < float('inf') else 0\n                    \n                    \n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        group_x_coords = collections.defaultdict(list)\n        group_y_coords = collections.defaultdict(set)\n        \n        # Form the grouping\n        for point in points:\n            group_x_coords[point[0]].append(point[1])\n            group_y_coords[point[1]].add(point[0])\n        \n        \n        # Pick element from x coords\n        # Then pick another element from it\n        # Do the intersection on the group_y_coords \n        # Find the maximum in the intersection\n        min_area = float('inf')\n        for key in group_x_coords.keys():\n            if len(group_x_coords[key]) < 2:\n                continue\n            for i in range(len(group_x_coords[key])):\n                for j in range(i + 1, len(group_x_coords[key])):\n                    y_val_1 = group_x_coords[key][i]\n                    y_val_2 = group_x_coords[key][j]\n                    # Get the max rectangle\n                    common_x_coords = group_y_coords[y_val_1] & group_y_coords[y_val_2]\n                    if len(common_x_coords) > 1:\n                        y_diff = abs(y_val_1 - y_val_2)\n                        # Need to find number closest to current\n                        x_diff = float('inf')\n                        for ele in common_x_coords:\n                            if ele == key:\n                                continue\n                            if abs(ele - key) < x_diff:\n                                x_diff = abs(ele - key)\n                        area = x_diff * y_diff\n                        if area < min_area:\n                            min_area = area\n        if min_area == float('inf'):\n            return 0\n        return min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        rows = collections.defaultdict(list)\n        \n        points.sort()\n        \n        \n        seen = set()\n        \n        result = float('inf')\n        \n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if x1 < x2 and y1 < y2:\n                    continue\n                    \n                if (x1, y2) in seen and (x2, y1) in seen :\n                    \n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    if area and area < result:\n                        result = area\n            seen.add((x1, y1))\n        \n        return result if result < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # idea, use lookup set to store the point that has seen before. for (x1,y1) in points, for (x2,y2) in lookup, check whether (x1,y2) and (x2, y1) in lookup. Time O(n^2), Space O(n).\n        res = float('inf') # initiate as inf\n        lookup = set()\n        for x1, y1 in points:\n            for x2, y2 in lookup:\n                if (x1, y2) in lookup and (x2, y1) in lookup: # if all in the lookup\n                    res = min(res, abs(x1-x2) * abs(y1-y2)) # check the min area\n            # add to lookup for the outer loop\n            lookup.add((x1, y1))\n        return res if res != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        globalMinArea = float('inf')\n        a = set()\n        for x,y in points:\n            for x1,y1 in a:\n                if (x,y1) in a and (x1,y) in a:\n                    currentMinArea = abs(x-x1)*abs(y-y1)\n                    globalMinArea = min(globalMinArea, currentMinArea)\n            a.add((x,y))\n        return globalMinArea if globalMinArea<float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        res = float('inf')\n        for point in points:                                                    \n            x, y = point[0], point[1]            \n            for _x, _y in seen:\n                if (x, _y) in seen and (_x, y) in seen:\n                    res = min(res, abs(x - _x) * abs(y - _y))\n            seen.add((x, y))\n            \n        if res == float('inf'):\n            return 0\n        return res\n    \n    ''' mine\n    class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n                \n        Y = dict()\n        X = dict()                \n        for point in points:\n            x, y = point[0], point[1]\n            if x not in X:\n                X[x] = set()\n            X[x].add(y)\n            \n            if y not in Y:\n                Y[y] = set()\n            Y[y].add(x)\n        \n                \n        _min = float('inf')\n        for point in points:            \n            x, y = point[0], point[1]\n            for _y in X[x]:\n                if _y > y:\n                    for _x in Y[_y]:\n                        if _x > x and _x in Y[y]:\n                            h = abs(_y - y)\n                            w = abs(_x - x)                    \n                            if h * w != 0:\n                                _min = min(_min, h * w)\n                        \n        if _min == float('inf'):\n            return 0\n        \n        return _min\n            \n    \n    '''\n\n            \n            \n'''\n    def minAreaRect(self, points):\n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        if nx == n or ny == n:\n            return 0\n\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n\n        lastx = {}\n        res = float('inf')\n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i]\n                    if (y1, y2) in lastx:\n                        res = min(res, (x - lastx[y1, y2]) * abs(y2 - y1))\n                    lastx[y1, y2] = x\n        return res if res < float('inf') else 0\n\n'''\n        \n        \n            \n            \n", "class Solution(object):\n    def minAreaRect(self, points):\n        min_area = sys.maxsize\n        points_table = set()\n        for x, y in points:\n            points_table.add((x,y))\n        for x1, y1 in points:\n            for x2, y2 in points:\n                if (x1 > x2) and (y1 > y2):\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 -  x2) * abs(y1 - y2)\n                        if area:\n                            min_area = min(area, min_area)\n        return 0 if min_area == sys.maxsize else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        hs = set()\n        N = len(points)\n        res = float('inf')\n        \n        for i in range(N):\n            x1, y1 = points[i]\n            for x2, y2 in hs:\n                if (x1, y2) in hs and (x2, y1) in hs:\n                    res = min(res, abs(x1-x2)*abs(y1-y2))\n            \n            hs.add((x1, y1))\n            \n        return res if res!=float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        ans=float('inf')\n        s=set()\n        for i,j in points:\n            for x,y in s:\n                if (i,y) in s and (x,j) in s:\n                    ans=min(ans,abs(i-x)*abs(j-y))\n            s.add((i,j))\n        return ans if ans!=float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        :type points: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        min_area = sys.maxsize\n        points_table = set()\n        \n        for x, y in points:\n            points_table.add((x,y))\n            \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2: # Skip looking at same point\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 -  x2) * abs(y1 - y2)\n                        if area:\n                            min_area = min(area, min_area)\n                        \n        return 0 if min_area == sys.maxsize else min_area       ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        res = float('inf')\n        lookup = set()\n        for x1, y1 in points:\n            for x2, y2 in lookup:\n                if (x1, y2) in lookup and (x2, y1) in lookup:\n                    res = min(res, abs(x2 - x1) * abs(y2 - y1))\n            lookup.add((x1, y1))\n        return res if res != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        #\n        #  0123456\n        # 0\n        # 1 * **\n        # 2 \n        # 3 * **\n        # 4\n        seen = set()\n        best = 0\n        \n        for p1 in points:\n            x1, y1 = p1\n            for p2 in seen:\n                x2, y2 = p2\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x2 - x1) * abs(y2 - y1)\n                    if best == 0:\n                        best = area\n                    else:\n                        best = min(best, area)\n            seen.add((x1, y1))\n        return best\n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pts = set([(x,y) for x, y in points])\n        min_area = float(\\\"inf\\\")\n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2 and (x1, y2) in pts and (x2, y1) in pts:\n                    min_area = min(abs(x1-x2)*abs(y1-y2), min_area)\n        return min_area if min_area != float(\\\"inf\\\") else 0\n                \n            \n        ", "class Solution(object):\n        def minAreaRect(self, points):\n            \\\"\\\"\\\"\n            :type points: List[List[int]]\n            :rtype: int\n            \\\"\\\"\\\"\n            min_area = sys.maxsize\n            points_table = set()\n\n            for x, y in points:\n                points_table.add((x,y))\n\n            for x1, y1 in points:\n                for x2, y2 in points:\n                    if (x1 > x2) and (y1 > y2): \n                        # Skip looking at same point\n                        if ((x1, y2) in points_table) and ((x2, y1) in points_table):\n                            area = abs(x1 -  x2) * abs(y1 - y2)\n                            if area:\n                                min_area = min(area, min_area)\n\n            return 0 if min_area == sys.maxsize else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        min_area = sys.maxsize\n        points_table = set()\n        for x, y in points:\n            points_table.add((x,y))\n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2: # Skip looking at same point\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 -  x2) * abs(y1 - y2)\n                        if area:\n                            min_area = min(area, min_area)\n                        \n        return 0 if min_area == sys.maxsize else min_area        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # count by diagonal, Time O(n); space O(n)\n        seen = set()\n        res = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    res = min(res, area)\n            \n            seen.add((x1, y1))\n        \n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n\n        min_area = float('inf')\n        points_table = set()\n        \n        for x, y in points:\n            points_table.add((x,y))\n            \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2: \n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 -  x2) * abs(y1 - y2)\n                        if area:\n                            min_area = min(area, min_area)\n                        \n        return 0 if min_area == float('inf') else min_area", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        setr, setc = set(), set()\n        for r, c in points:\n            setr.add(r)\n            setc.add(c)\n        if len(points) in (len(setr), len(setc)): return 0\n        \n        \n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r in sorted(columns):\n            cols = sorted(columns[r])\n            for j, y2 in enumerate(cols):\n                for i, y1 in enumerate(cols[:j]):\n                    if (y1, y2) in lastc:\n                        ans = min(ans, (r - lastc[(y1, y2)]) * (y2 - y1))\n                    lastc[(y1, y2)] = r\n        return ans if ans < float('inf') else 0\n\n\n                              \nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(points) in (len(set(X[0])), len(set(X[1]))): return 0\n        seen, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in seen) and ((p2x, p1y) in seen):\n                    ans = min(ans, abs((p1x-p2x)*(p1y-p2y)))\n        return ans if ans < float('inf') else 0\n", "\\\"\\\"\\\"\nIn order to form a rectangle, you need four points all positioned at 90 degrees to each other.\n\nIn this approach, we store all given points in a set.\n\nThen iteratively go through all the points in two loops (x1, y1) and (x2, y2) while checking if (x1, y2) and (x2, y1) are also valid points. If so, we found a rectangle.\n\nWe calculate the area of this rectangle. If this area is smaller than the minimum area seen so far, make it the minimum area.\n\\\"\\\"\\\"\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        min_area = sys.maxsize\n        points_table = set()\n        \n        for x, y in points:\n            points_table.add((x,y))\n            \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2: # Skip looking at same point\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 -  x2) * abs(y1 - y2)\n                        if area:\n                            min_area = min(area, min_area)\n                        \n        return 0 if min_area == sys.maxsize else min_area", "class Solution(object):\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        setx = set()\n        sety = set()\n        for x, y in points:\n            setx.add(x)\n            sety.add(y)\n        nx = len(setx)\n        ny = len(sety)\n\n        if nx == n or ny == n:\n            return 0\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n\n        res = float('inf')\n        dic_last = {}\n        for x in sorted(p):\n            p[x].sort()\n            for j, y2 in enumerate(p[x]):\n                for y1 in p[x][:j]:\n                    if (y1, y2) in dic_last:\n                        res = min(res, (x - dic_last[y1, y2]) * (y2-y1))\n                    dic_last[y1, y2] = x\n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points):\n        min_area = float('inf')\n        points_table = set()\n        \n        for x, y in points:\n            points_table.add((x,y))\n            \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2: # Skip looking at same point\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 -  x2) * abs(y1 - y2)\n                        if area:\n                            min_area = min(area, min_area)\n                        \n        return 0 if min_area == float('inf') else min_area\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_set = set((x, y) for x, y in points)\n        min_rec = math.inf\n        points.sort()\n        for idx1 in range(len(points)):\n            for idx2 in range(idx1 + 1, len(points)):\n                x1, y1 = points[idx1]\n                x2, y2 = points[idx2]\n                # O(N^2)\n                if x1 < x2 and y1 > y2:\n                    if (x1, y2) in point_set and (x2, y1) in point_set:\n                        min_rec = min(min_rec, (x2 - x1) * (y1 - y2)) #O(1)\n        return 0 if min_rec == math.inf else min_rec", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        ans = float(\\\"inf\\\")\n        point_set = set()\n        for p in points:\n            point_set.add((p[0],p[1]))\n        for x1, y1 in point_set:\n            for x2, y2 in point_set:\n                if x1 > x2 and y1 > y2: # make sure no zero \n                    if (x1,y2) in point_set and (x2, y1) in point_set:\n                        ans = min(abs((x1 - x2)) * abs((y1 - y2)), ans)\n        return ans if ans != float(\\\"inf\\\") else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort()\n        points = map(tuple, points)\n        xdict, ydict = collections.defaultdict(list), collections.defaultdict(list)\n        pset = set()\n        res = float(\\\"inf\\\")\n        for point in points:\n            xdict[point[0]].append(point)\n            ydict[point[1]].append(point)\n            pset.add(point)\n        for x1 in xdict.keys():\n            if len(xdict[x1]) == 1:\n                continue\n            for i in range(len(xdict[x1]) - 1):\n                p1 = xdict[x1][i]\n                for j in range(i + 1, len(xdict[x1])):\n                    p2 = xdict[x1][j]\n                    for p3 in ydict[p1[1]]:\n                        if p3 != p1:\n                            if (p3[0], p2[1]) in pset:\n                                res = min(res, abs((p3[0] - p1[0]) * (p2[1] - p1[1])))\n        return res if res != float(\\\"inf\\\") else 0", "\\\"\\\"\\\"\nInputs\n    points (List[List[int]]): x y locations of points\nOutputs\n    int: minimum area of a rectangle\nNotes\n    - if no rectangle possible, output 0\n\nExamples\n    \n    Example 1\n        \n        Input: [[1,1],[1,3],[3,1],[3,3],[2,2]]\n        Output: 4\n    \n    Example 2\n\n        Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\n        Output: 2\n\nIdeas\n    - distance doesn't tell us if points are parallel or not\n    \n    - keep track of points at common x and y locations\n        const_x: {1: index 0, index 1}\n        const_y: {1: index 0, index 2}\n        \n    - sorting points may help us\n    \n    - area calc\n        + dx * dy\n    \n    - find two points at same x, and different y\n        + then find another two points at different x and same y\n            x1, y1\n            x2, y2\n            x1 = x2\n        + then find one point at same y1, different x\n            x3, y3\n            \n            y1 = y3\n            \n        + then find one point at same y2, different x\n            \n            x4, y4\n            \n            x3 = x4\n            y2 = y4\n    \n    - checking for points will be easier with set or hash\n        O(1) checks.\n        + we need the (x,y) values to verify this\n\n\\\"\\\"\\\"\n\nfrom collections import defaultdict\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        \n        - aggreate points by common x or y coordinate\n        - \n        \n        \\\"\\\"\\\"\n        \n        ans = float('inf')\n        \n        ''' Aggregate points by common location '''\n        const_x = defaultdict(list)\n        \n        for point in points:\n            x, y = point\n            const_x[x].append(y)\n        \n        ''' Iterate over constant x pairs'''\n        \n        prev_x = {}  # store x location for pairs of points\n        \n        for x in sorted(const_x):\n            n: int = len(const_x[x])\n                \n            # Sort by y value\n            const_x[x].sort()\n            \n            for ix in range(n):\n                for jx in range(ix + 1, n):\n                \n                    y1 = const_x[x][ix]  # (x1, y1) smaller y\n                    y2 = const_x[x][jx]  # (x1, y2) larger y\n                    \n                    dy = y2 - y1\n                    \n                    # Find points at the same y and different x from current\n                    # but same x as each other\n                    if (y1, y2) in prev_x:\n                        dx = x - prev_x[(y1, y2)]\n                        ans = min(ans, dx * dy)\n                    \n                    # Save the x location for every pair of y points\n                    prev_x[(y1, y2)] = x\n                     \n        \n        if ans != float('inf'):\n            return ans\n        else:\n            return 0\n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort()\n        points_set = set([tuple(point) for point in points])\n        smallest = float('inf')\n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 < x2 and y1 < y2 and (x1, y2) in points_set and (x2, y1) in points_set:\n                    area = (x2 - x1) * (y2 - y1)\n                    smallest = min(smallest, area)\n        return smallest if smallest != float('inf') else 0", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pts = set([(x,y) for x, y in points])\n        min_area = float(\\\"inf\\\")\n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 < x2 and y1 < y2 and (x1, y2) in pts and (x2, y1) in pts:\n                    min_area = min(abs(x1-x2)*abs(y1-y2), min_area)\n        return min_area if min_area != float(\\\"inf\\\") else 0\n                \n            \n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        for point in points:\n            seen.add((point[0], point[1]))\n        min_area = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2:\n                    if (x1, y2) in seen and (x2, y1) in seen:\n                        area = abs(y2 - y1) * abs(x2 - x1)\n                        min_area = min(min_area, area)\n        return 0 if min_area == float('inf') else min_area", "import math\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points = set(map(tuple, points))\n        \n        min_area = math.inf\n        \n        for start_x, start_y in points:\n            for diag_x, diag_y in points:\n                if diag_y < start_y and diag_x > start_x and (diag_x, start_y) in points and (start_x, diag_y) in points:\n                    min_area = min(min_area, (diag_x - start_x) * (start_y - diag_y))\n                    \n        if min_area == math.inf:\n            return 0\n        else:\n            return min_area\n                    \n        \n", "'''\n1. When we see new x point, we establish base point x as baseX.\n2. For every baseX, there will be multiple y points (y_for_baseX array)\n3. If y was registered in previous base(for base in y_for_baseX), we update res.\n  - In other words, we update res if (y, base) seen before at another x.\n4. We also update x value of seen[base][y]\n5. After processing, we append y to bases array.\n6. Return res\n'''\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        :type points: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        min_area = float('inf')\n        points_table = set()\n        \n        for x, y in points:\n            points_table.add((x,y))\n            \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2: # skip dupes\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 - x2) * abs(y1 - y2)\n                        if area: min_area = min(area, min_area)\n                        \n        return 0 if min_area == float('inf') else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        if nx == n or ny == n:\n            return 0\n\n        p = collections.defaultdict(list)   # this is my 1st thought, should be a dictionary of lists. \n    # Here is the right way to define the dictionary.\n    # This is one of the KEY step shorten the time. If define in the opposite way, short dictionary but long lists, ~5 fold slower.\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)  # if using this define, long dictionary, each list is short.\n\n        lastx = {}\n        res = float('inf')\n\n        for x in sorted(p):\n            p[x].sort() # the dictionary p and the list in p must be sorted here, because it was unknown x or y should be the keys for the dictionary. \n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i] # fix one dimension, find possible pairs for the other dimention.\n                    #Record the fixed dimension as value, the pair as the key.\n                    if (y1, y2) in lastx:  \n                        res = min(res, (x - lastx[y1, y2]) * abs(y2 - y1)) # if the pari appeared before, calculate an area, compare with the current min.\n                    lastx[y1, y2] = x # no matter the pair appeared before or not, record the new one. \n                    # This is because the dictionary is sorted, the last must be the lowest.\n        return res if res < float('inf') else 0  # simple version.\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        lookup = set()\n        for x, y in points:\n            lookup.add((x, y))\n        \n        res = float(\\\"inf\\\")\n        for x1, y1 in points:              ##\u5728points\u91cc\u9762\u904d\u5386\uff01\uff01\u5b9a\u4e0b\u4e24\u4e2a\u70b9\u5c31\u53ef\u4ee5\u786e\u5b9a\u4e00\u4e2a\u77e9\u5f62,\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2:  ##\u53bb\u6389\u4e4b\u524d\u770b\u8fc7\u7684\u5143\u7d20\uff01\uff01\n                    if (x1, y2) in lookup and (x2, y1) in lookup:\n                  \n                        res = min(res, abs(x1 - x2) * abs(y1 - y2))\n        \n        if res < float(\\\"inf\\\"):\n            return res\n        else:\n            return 0\n            ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        ans = float(\\\"inf\\\")\n        point_set = set()\n        for p in points:\n            point_set.add((p[0],p[1]))\n        for x1, y1 in point_set:\n            for x2, y2 in point_set:\n                if x1 > x2 and y1 > y2:\n                    if (x1,y2) in point_set and (x2, y1) in point_set:\n                        ans = min(abs((x1 - x2)) * abs((y1 - y2)), ans)\n        return ans if ans !=  float(\\\"inf\\\") else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_table = set()\n        for x,y in points:\n            point_table.add((x,y))\n        minarea = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1>x2 and y1>y2:\n                    if (x1,y2) in point_table and (x2,y1) in point_table:\n                        area = abs(x1-x2)*abs(y1-y2)\n                        if area:\n                            area = min(area, minarea)\n                            minarea = area\n        return minarea if minarea<float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        min_area = sys.maxsize\n        points_table = set()\n        \n        for x, y in points:\n            points_table.add((x,y))\n            \n        print(points)\n            \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2: # Skip looking at same point\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 -  x2) * abs(y1 - y2)\n                        if area:\n                            min_area = min(area, min_area)\n                        \n        return 0 if min_area == sys.maxsize else min_area", "# +------------------------------+\n# |                              |\n# |                              |\n# |                              |\n# |    +-----------------+       |\n# |    |                 |       |\n# | +---------+          |       |\n# | |  |      |          |       |\n# | |  +-----------------+       |\n# | +---------+                  |\n# |           (x1, y2)           |   (x2, y2)\n# |              +-------------------+\n# |              |               |   |\n# |              |               |   |\n# +------------------------------+   |\n#                |                   |\n#                |                   |\n#                +-------------------+\n#             (x1, y1)               (x2, y1)\n            \n\nfrom collections import defaultdict\n\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        # stores all points into a set\n        points_set = set()\n        \n        for x, y in points:\n            points_set.add((x, y))\n        \n        min_area = float('inf')\n        \n        # iterate through all the points nested way\n        # for each point, compare with all other points\n        for x1, y1 in points:\n            for x2, y2 in points:\n                # skip looking at the same point\n                if x2 > x1 and y2 > y1:\n                    # looking for two other points for form a rec\n                    # see diag above\n                    if (x2, y1) in points_set and (x1, y2) in points_set:\n                        area = abs(x1 - x2) * abs(y1 - y2)\n                        min_area = min(min_area, area)\n                    \n                        \n        return min_area if min_area != float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        min_area = sys.maxsize\n        points_table = set()\n\n        for x, y in points:\n            points_table.add((x,y))\n\n        for x1, y1, in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2: # Skip looking at same point\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                            area = abs(x1 -  x2) * abs(y1 - y2)\n                            if area:\n                                min_area = min(area, min_area)\n\n        return 0 if min_area == sys.maxsize else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        ys = {}\n        for x, y in points:\n            if y not in ys:\n                ys[y] = set()\n            ys[y].add(x)                \n        result = -1            \n        for y1 in ys:\n            for y2 in ys:\n                if y1 == y2:\n                    continue\n                points = ys[y1].intersection(ys[y2])                      \n                if len(points) < 2:\n                    continue\n                points = list(points)                    \n                points.sort()\n                x1 = points[0]\n                for i in range(1, len(points)):\n                    x2 = points[i]\n                    area = (x2-x1) * abs(y2 - y1)\n                    if result < 0:\n                        result = area\n                    else:\n                        result = min(area, result)\n                    x1 = x2                        \n                        \n        return result if result >= 0 else 0                                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        min_area = math.inf\n        seen = set()\n        \n        for i, (x0, y0) in enumerate(points):\n            for j in range(i):\n                x1, y1 = points[j]\n                if (x0, y1) in seen and (x1, y0) in seen:\n                    area = abs(x0 - x1) * abs(y0 - y1)\n                    if area > 0:\n                        min_area = min(min_area, area)\n            seen.add((x0, y0))\n        \n        return 0 if min_area == math.inf else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        #Parallel with x, y -> find all point on same x, and same y that can form parallel edge\n        \n        def calculateArea(x1,x2,y1,y2):\n            return abs(y2-y1) * abs(x2-x1)\n        if not points or len(points) < 4: return 0\n        \n        visited = set()\n        area = float('inf')\n        for x1,y1 in points:\n            for x2,y2 in visited:\n                if (x1,y2) in visited and (x2,y1) in visited:\n                    area = min(area, calculateArea(x1,x2,y1,y2))\n            \n            visited.add((x1,y1))\n        \n        return area if area != float('inf') else 0\n        #Skip those that have less than len 2 (cant form a line)\n        \n        #  (1,5)        (6,5)       (x1,y2)         (x2,y2)\n        #                       or \n        #  (1,2)        (6,2)       (x1,y1)         (x2,y1)\n\n        # Rectangle would be\n        \n", "from collections import defaultdict\nfrom math import inf\n\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        byrow = defaultdict(set) # row: {col,}\n        bycol = defaultdict(list) # col: [row,]\n        for x, y in points:\n            byrow[y].add(x)\n            bycol[x].append(y)\n            \n        area = inf\n        for x1, ys in list(bycol.items()):\n            if len(ys) < 2:\n                continue\n            for j, y1 in enumerate(ys):\n                for y2 in ys[j+1:]:\n                    lens = [abs(x1-x2) for x2 in byrow[y1] & byrow[y2] - {x1}]\n                    if lens:\n                        area = min(area, min(lens)*abs(y1-y2))\n        return area if area < inf else 0\n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n        \n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in columns.items():\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pointsets = set()\n        for point in points:\n            pointsets.add((point[0], point[1]))\n        ans = float(\\\"inf\\\")\n        # consider two points at diagonal\n        # (x1, y1) at lower left, (x2, y2) at upper right\n        # since sides are parallel to x and y axes\n        # then we should also find (x1, y2) and (x2, y1)\n        # if found, we can form a rectangle\n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x2>x1 and y2>y1:\n                    if (x2, y1) in pointsets and (x1, y2) in pointsets:\n                        area = abs(x1-x2)*abs(y1-y2)\n                        ans = min(area, ans)\n        return ans if ans < float(\\\"inf\\\") else 0", "class Solution(object):\n    def minAreaRect(self, points):\n        \\\"\\\"\\\"\n        :type points: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        min_area = sys.maxsize\n        points_table = set()\n\n        for x, y in points:\n            points_table.add((x, y))\n\n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2:  # Skip looking at same point\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 - x2) * abs(y1 - y2)\n                        if area:\n                            min_area = min(area, min_area)\n\n        return 0 if min_area == sys.maxsize else min_area\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        min_area = float('inf')\n        points_table = set()\n        \n        for x, y in points:\n            points_table.add((x,y))\n            \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2:\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 -  x2) * abs(y1 - y2)\n                        if area: \n                            min_area = min(area, min_area)     \n        return 0 if min_area == float('inf') else min_area", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        setr, setc = set(), set()\n        for r, c in points:\n            setr.add(r)\n            setc.add(c)\n        if len(points) in (len(setr), len(setc)): return 0\n        \n        \n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r in sorted(columns):\n            cols = sorted(columns[r])\n            for j, y2 in enumerate(cols):\n                for i, y1 in enumerate(cols[:j]):\n                    if (y1, y2) in lastc:\n                        ans = min(ans, (r - lastc[(y1, y2)]) * (y2 - y1))\n                    lastc[(y1, y2)] = r\n        return ans if ans < float('inf') else 0\n\n\n                              \nclass Solution:\n    def minAreaRect(self, points):\n        seen, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in seen) and ((p2x, p1y) in seen):\n                    ans = min(ans, abs((p1x-p2x)*(p1y-p2y)))\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        min_area = float(\\\"inf\\\")\n        points_table = set()\n        for p in points:\n            points_table.add(tuple(p))\n        \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x2 > x1 and y2 > y1:\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 - x2) * abs(y1 - y2)\n                        if area:\n                            min_area = min(min_area, area)\n        return 0 if min_area == float(\\\"inf\\\") else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        saw = set()\n        res = float('inf')\n        for x, y in points:\n            for dx, dy in saw:\n                p1 = (dx, y)\n                p2 = (x, dy)\n                if p1 in saw and p2 in saw and dx != x and dy != y:\n                    res = min(res, abs(dx - x) * abs(dy - y))\n            saw.add((x, y))\n        return res if res != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        # watch for degenerate cases of 4 same points or getting a line\n        # if points weren't distinct, can convert to set and then back to list\n        # for every x, need list of y's (set)\n        # for every y, need list of x's (set)\n        # then, O(4) to find a rectangle\n        # x_vals: {1: [1, 3], 3: [3, 1], 2: [2]}\n        # y_vals: {1, [1, 3], 3: [3, 1], 2: [2]}\n        \n        # Then, to check, loop through all x's and see if we can get all 4 points for each; if so, calculate area\n        \n        # Runtime: O(n^3)\n        # x_vals = defaultdict(set)\n        # y_vals = defaultdict(set)\n        # for p in points:\n        #     x_vals[p[0]].add(p[1])\n        #     y_vals[p[1]].add(p[0])\n        # # print(x_vals)\n        # # print(y_vals)\n        # min_area = 40000*40000 + 1\n        # for x, y_coords in x_vals.items():\n        #     if len(y_coords) == 1:\n        #         continue # can't make a rectangle if it's the only point on that x = x line\n        #     y_list = list(y_coords)\n        #     for i, y_1 in enumerate(y_list):\n        #         for j, y_2 in enumerate(y_list[i+1:]):\n        #             # we have points (x, y_1) and (x, y_2)\n        #             # now need to check if same value in both y_vals[y_1] and y_vals[y_2]\n        #             # if so, we have a rectangle!\n        #             common_x_2 = y_vals[y_1].intersection(y_vals[y_2])\n        #             common_x_2.remove(x) # avoid degenerate case of a line\n        #             for x_2 in list(common_x_2):\n        #                 # print(x, x_2, y_1, y_2)\n        #                 min_area = min(min_area, abs(x_2 - x) * abs(y_2 - y_1))\n        # if min_area == 40000*40000 + 1:\n        #     return 0\n        # return min_area\n    \n        # Improved O(n^2) solution that's a lot simpler too:\n        min_area = 40000*40000 + 1\n        seen_points = set()\n        for x,y in points:\n            seen_points.add((x, y))\n        # print(seen_points)\n        for p1_x, p1_y in points:\n            for p2_x, p2_y in points:\n                if p1_x > p2_x and p1_y > p2_y:\n                    if (p1_x, p2_y) in seen_points and (p2_x, p1_y) in seen_points:\n                        area = abs(p2_x - p1_x) * abs(p2_y - p1_y)\n                        if area > 0:\n                            min_area = min(min_area, area)\n        if min_area == 40000*40000 + 1:\n            return 0\n        return min_area\n            \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        table = {}\n        mark = []\n        best = 0\n        for i in points:\n            if i[0] not in table:\n                table[i[0]] = [[i[1]],[]]\n            else:\n                if i[1] not in table[i[0]][0]:\n                    for j in table[i[0]][0]:\n                        if j < i[1]:\n                            table[i[0]][1].append((j, i[1]))\n                        else:\n                            table[i[0]][1].append((i[1],j))\n                    table[i[0]][0].append(i[1])\n                    if len(table[i[0]][0]) == 2:\n                        mark.append(i[0])\n        g = {}\n        print(mark)\n        for i in mark:\n            p = table[i]\n            for j in p[1]:\n                if j in g:\n                    for k in g[j]:\n                        temp = abs((k - i) * (j[1] - j[0]))\n                        if best == 0 or temp < best:\n                            best = temp\n                    g[j].append(i)\n                else:\n                    g[j] = [i]\n        return best", "class Solution:\n    def minAreaRect(self, points):\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in pSet) and ((p2x, p1y) in pSet):\n                    ans = min(ans, abs((p1x - p2x) * (p1y - p2y)))\n        return ans if ans < float('inf') else 0", "\n   #     if Nr < Nc:\n   #         points = [[c, r] for (r, c) in points]\n   #         return self.minAreaRect(points)\n\nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in columns.items():\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        setr, setc = set(), set()\n        for r, c in points:\n            setr.add(r)\n            setc.add(c)\n        if len(points) in (len(setr), len(setc)): return 0\n        \n        \n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r in sorted(columns):\n            cols = sorted(columns[r])\n            for j, y2 in enumerate(cols):\n                for i, y1 in enumerate(cols[:j]):\n                    if (y1, y2) in lastc:\n                        ans = min(ans, (r - lastc[(y1, y2)]) * (y2 - y1))\n                    lastc[(y1, y2)] = r\n        return ans if ans < float('inf') else 0\n\n\n                              \nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(points) in (len(set(X[0])), len(set(X[1]))): return 0\n        seen, ans = set(map(tuple, points)), float('inf')\n        points.sort()\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in seen and (p2x, p1y) in seen:\n                    ans = area\n        return ans if ans < float('inf') else 0\n    \nclass Solution:\n    def minAreaRect(self, points):\n        seen, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in seen) and ((p2x, p1y) in seen):\n                    ans = min(ans, abs((p1x - p2x) * (p1y - p2y)))\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        min_area = float('inf')\n        points_set = set()\n        for x, y in points:\n            points_set.add((x,y))\n        for (x1, y1) in points_set:\n            for (x2, y2) in points_set:\n                if x1 > x2 and y1 > y2 and (x1, y2) in points_set and (x2, y1) in points_set:\n                        \n                        area = abs(x1 - x2) * abs(y1 - y2)\n                        min_area = min(min_area, area)\n        return min_area if min_area < float('inf') else 0\n                        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        s = set(tuple(p) for p in points)\n        \n        area = math.inf\n        for i, (x1, y1) in enumerate(points):\n            for x2, y2 in points[i:]:\n                if x1==x2 or y1==y2:\n                    continue\n                    \n                if (x2, y1) not in s or (x1, y2) not in s:\n                    continue\n                    \n                area = min(area, abs((x2-x1)*(y2-y1)))\n                \n        return area if area != math.inf else 0", "# +------------------------------+\n# |                              |\n# |                              |\n# |                              |\n# |    +-----------------+       |\n# |    |                 |       |\n# | +---------+          |       |\n# | |  |      |          |       |\n# | |  +-----------------+       |\n# | +---------+                  |\n# |           (x1, y2)           |   (x2, y2)\n# |              +-------------------+\n# |              |               |   |\n# |              |               |   |\n# +------------------------------+   |\n#                |                   |\n#                |                   |\n#                +-------------------+\n#             (x1, y1)               (x2, y1)\n            \n\nfrom collections import defaultdict\n\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        # stores points seen before into a set\n        points_set = set()\n        \n        for x, y in points:\n            points_set.add((x, y))\n        \n        min_area = float('inf')\n        \n        # iterate through all the points nested way\n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x2 > x1 and y2 > y1:\n                    if (x2, y1) in points_set and (x1, y2) in points_set:\n                        area = abs(x1 - x2) * abs(y1 - y2)\n                        min_area = min(min_area, area)\n                    \n                        \n        return min_area if min_area != float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        dx = defaultdict(list)\n        for x, y in points:\n            dx[x].append(y)\n        lastx = defaultdict(list)\n        ans = float('inf')\n        \n        for x in sorted(dx):\n            col = dx[x]\n            col.sort()\n            for i in range(len(col)-1):\n                for j in range(i+1, len(col)):\n                    y1 = col[i]\n                    y2 = col[j]\n                    if (y1,y2) in lastx:\n                        for xs in lastx[y1,y2]:\n                            ans = min(ans, (abs(y2-y1))*(abs(x-xs)))\n                    lastx[y1,y2].append(x)\n        return ans if ans<float('inf') else 0\n            \n            \n        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        Time complexity: O(n^2)\n        Space complexity: O(n)\n        \\\"\\\"\\\"\n        # idea, use lookup set to store the point that has been seen before. for (x1,y1) in points, for (x2,y2) in lookup, check whether (x1,y2) and (x2, y1) in lookup. \n        \n        min_area = float('inf') \n        lookup = set()\n        \n        \n        for x1, y1 in points:\n            for x2, y2 in lookup:\n                if (x1, y2) in lookup and (x2, y1) in lookup:\n                    min_area = min(min_area, abs(x1-x2) * abs(y1-y2)) \n                    \n            # add to lookup for the outer loop\n            lookup.add((x1, y1))\n            \n            \n        if min_area != float('inf'):\n            return min_area\n        else:\n            return 0", "class Solution:\n    def minAreaRect(self, points):\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in pSet) and ((p2x, p1y) in pSet):\n                    ans = min(ans, abs((p1x - p2x) * (p1y - p2y)))\n        return ans if ans < float('inf') else 0\n    \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        '''\n        columns = defaultdict(list)\n        \n        for x, y in points:\n            columns[x].append(y)\n        \n        result = float('inf')\n        lastx = {}\n        \n        for x in sorted(columns):\n            column_list = columns[x]\n            column_list.sort()\n            \n            for j, y2 in enumerate(column_list):\n                for i in range(j):\n                    y1 = column_list[i]\n                    \n                    if (y1, y2) in lastx:\n                        result = min(result, (x-lastx[y1,y2]) * (y2-y1))\n                    lastx[y1,y2] = x\n        \n        return result if result < float('inf') else 0\n        '''\n        \n        seen = set()\n        ans = sys.maxsize\n        \n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1-x2) * abs(y1-y2)\n                    ans = min(ans, area)\n            \n            seen.add((x1,y1))\n        \n        return ans if ans < sys.maxsize else 0\n                    \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        counter = Counter(list(map(tuple, points)))\n        points = list(counter)\n        result = float('inf')\n        for i, (x, y) in enumerate(points):\n            for j in range(i + 1, len(points)):\n                x_, y_ = points[j]\n                if x != x_ and y != y_:\n                    area = abs((x_ - x) * (y_ - y))\n                    if area < result and (x, y_) in counter and (x_, y) in counter:\n                        if not area:\n                            return 0\n                        result = area\n                elif counter[(x, y)] == 2 and counter[(x_, y_)] == 2:\n                        return 0\n        return 0 if result == float('inf') else result\n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n\n# from collections import defaultdict\n# class Solution:\n#     def minAreaRect(self, points):\n#         d = defaultdict(set)\n#         rset, cset, N, ans = set(), set(), len(points), float('inf')\n#         for r, c in points:\n#             rset.add(r)\n#             cset.add(c)\n#         Nr, Nc = len(rset), len(cset)\n#         if Nr == N or Nc == N:\n#             return 0\n#         elif Nr < Nc:\n#             for r, c in points:\n#                 d[r].add(c)\n#         else:\n#             for r, c in points:\n#                 d[c].add(r)\n# \n#         A = sorted(d.keys())\n#         for i, r1 in enumerate(A):\n#             cols1 = d[r1]\n#             for r2 in A[i+1:]:\n#                 cols2 = d[r2]\n#                 s = sorted(cols1 & cols2)\n#                 for c1, c2 in zip(s[:-1], s[1:]):\n#                     area = abs((r1 - r2) * (c1 - c2))\n#                     ans = min(ans, area)\n#         return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_set = set(map(tuple,points))\n        min_area = float('inf')\n        for i, (x1, y1) in enumerate(points):\n            for x2, y2 in points[:i]:\n                if x1 != x2 and y1 != y2:\n                    if (x1, y2) in point_set and (x2, y1) in point_set:\n                        min_area = min(min_area, abs((x2 - x1) * (y2 - y1)))\n        return min_area if min_area != float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        appeared = set()\n        res = math.inf\n        for x1, y1 in points:\n            for x2, y2 in appeared:\n                if (x1, y2) in appeared and (x2, y1) in appeared:\n                    area = abs(x1-x2) * abs(y1-y2)\n                    if area and area < res:\n                        res = area\n            appeared.add((x1, y1))\n        return 0 if res == math.inf else res", "class Solution:\n    \n    # O(n^2), O(n)\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # O(nlogn), O(1)\n        points.sort()\n        \n        cols = defaultdict(list)\n        for p in points:\n            cols[p[0]].append(p[1])\n        \n        last_x = {}\n        ans = float('inf')\n        for x in sorted(cols):\n            for i in range(len(cols[x])):\n                for j in range(i + 1, len(cols[x])):\n                    if (cols[x][i], cols[x][j]) in last_x:\n                        ans = min(ans, (cols[x][j] - cols[x][i]) * (x - last_x[(cols[x][i], cols[x][j])]))\n                    last_x[(cols[x][i], cols[x][j])] = x\n                    \n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points:\n            return 0\n        \n        xMap = defaultdict(set)\n        yMap = defaultdict(int)\n        \n        for x,y in points:\n            yMap[y] += 1\n            xMap[x].add(y)\n        \n        \n        \n        xUnique = list(xMap.keys())\n        xUnique.sort()\n        \n        res = float(\\\"inf\\\")\n        for i in range(len(xUnique)):\n            for j in range(i+1, len(xUnique)):\n                x1 = xUnique[i]\n                x2 = xUnique[j]\n                \n                values = xMap[x1].intersection(xMap[x2])\n                \n                values = list(sorted(values))\n            \n                minDiff = float(\\\"inf\\\")\n                for k in range(1, len(values)):\n                    minDiff = min(minDiff, values[k] - values[k-1])\n                \n                if minDiff == float(\\\"inf\\\"):\n                    continue\n                \n                res = min(res, (x2 - x1) * minDiff)\n        \n        if res == float(\\\"inf\\\"):\n            return 0\n        \n        return res\n                \n                \n        \n        \n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        nx, ny = len(set(x for x, _ in points)), len(set(y for _, y in points))\n        \n        if nx == n or ny == n:\n            return 0\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n        \n        res = float('inf')\n        dic_last = {}\n        for x1, x2 in itertools.combinations(p, 2):\n            if (len(p[x1]) < 2 or len(p[x2]) < 2):\n                continue\n            l1, l2 = sorted(p[x1]), sorted(p[x2])\n            i = j = 0\n            y = []\n            while i < len(l1) and j < len(l2):\n                v = max(l1[i], l2[j])\n                if l1[i] < v:\n                    i += 1\n                elif l2[j] < v:\n                    j += 1\n                else:\n                    y += v,\n                    i, j = i + 1, j + 1\n            \n            for y1, y2 in itertools.combinations( y , 2 ):\n                res = min(res, abs(x1-x2) * (y2 - y1))\n        # for x in sorted(p):\n        #     # print(x)\n        #     p[x].sort()\n        #     for y1, y2 in itertools.combinations(p[x], 2):\n        #         if (y1, y2) in dic_last:\n        #             res = min(res, abs( x - dic_last[y1, y2]) * abs(y1 -y2))\n        #             # if res == 2:\n        #             #     print(x, dic_last[y1, y2],  y1, y2)\n        #         dic_last[y1, y2] = x\n        return res if res < float('inf') else 0\n        \n        # n = len(points)\n        # nx, ny = len(set(x for x, y in points)), len(set(y for x, y in points))\n        # if nx == n or ny == n:\n        #     return 0\n        \n        # p = collections.defaultdict(list)\n        # if nx > ny:\n        #     for x, y in points:\n        #         p[x].append(y)\n        # else:\n        #     for x, y in points:\n        #         p[y].append(x)\n        # res = float('inf')\n        # dic = {}\n        # for x in sorted(p):\n        #     p[x].sort()\n        #     for y1, y2 in itertools.combinations(p[x], 2):\n        #         if (y1, y2) in dic:\n        #             res = min(res, abs(x - dic[y1, y2]) * abs(y1 - y2) )\n        #         dic[y1, y2] = x\n        # return res if res < float('inf') else 0\n#         dic_x = {}\n        \n#         n = len(points)\n#         nx, ny = len( set(x for x, y in points) ), len( set(y for x, y in points) )\n#         if nx == n or ny == n:\n#             return 0\n        \n#         p = collections.defaultdict(list)\n#         if nx > ny:\n#             for x, y in points:\n#                 p[x].append(y)\n#         else:\n#             for x, y in points:\n#                 p[y].append(x)\n#         res = float('inf')\n#         for x in sorted(p):\n#             p[x].sort()\n            \n#             for y1, y2 in itertools.combinations(p[x], 2):\n#                 # y1, y2 = p[x][i], p[x][j]\n#                 if (y1, y2) in dic_x:\n#                     res = min(res, abs(x - dic_x[y1, y2]) * abs(y1 -y2))\n#                 dic_x[y1, y2] = x\n#         return res if res < float('inf') else 0\n#         seen = set()\n        \n#         res = float('inf')\n#         for x1, y1 in points:\n#             for x2, y2 in seen:\n#                 if (x1, y2) in seen and (x2, y1) in seen:\n#                     area = abs(x1 - x2) * abs(y1 - y2)\n#                     if area and res > area:\n#                         res = area\n#                     # res = min(res, )\n#             seen.add((x1, y1))\n#         return res if res < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        length = len(points)\n        if length <= 3:\n            return 0\n        \n        sets = set([])\n        for point in points:\n            sets.add(tuple(point))\n        \n        min_area = float('inf')\n        for i in range(length - 1):\n            x1, y1 = points[i]\n            for j in range(i + 1, length):              \n                x2, y2 = points[j]\n                #print(x1, y1, x2, y2)\n                if x1 == x2 or y1 == y2:\n                    continue\n                #print((x1, y2) in sets and (x2, y1) in sets)   \n                if (x1, y2) in sets and (x2, y1) in sets:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    #print(area)\n                    if area < min_area:\n                        min_area = area\n                        \n        if min_area == float('inf'):\n            return 0\n        return min_area\n        \n                    \n                \n                \n        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen=set()\n        res=float('inf')\n        for x1,y1 in points:\n            for x2,y2 in seen:\n                if (x1,y2) in seen and (x2,y1) in seen:\n                    area=abs(x1-x2)*abs(y1-y2)\n                    if area and area <res:\n                        res=area\n            seen.add((x1,y1))\n        return res if res<float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        dictY=collections.defaultdict(list)\n        for i, (x, y) in enumerate(points):\n            dictY[y].append(i)\n        \n        y2Xpair=collections.defaultdict(set)\n        for y in dictY.keys():\n            if len(dictY[y])<=1:\n                continue\n                \n            for p1, p2 in itertools.combinations(dictY[y], 2):\n                x1, _, x2, _ = points[p1] + points[p2]\n                y2Xpair[y].add((min(x1,x2), max(x1,x2)))  \n            \n        res=float('inf')\n        for (y1,p1), (y2, p2) in itertools.combinations(y2Xpair.items(), 2):\n            h=abs(y1-y2)\n            for x1, x2 in p1&p2:\n                res=min(res, (x2-x1)*h)\n        \n             \n        return 0 if res==float('inf') else res", "from math import inf\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) == 0:\n            return 0\n        \n        N, min_area = len(points), inf\n        d = set()\n        for i in range(N):\n            d.add(tuple(points[i]))\n        #print(d)\n        for i in range(N):\n            for j in range(i+1, N, 1):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if (x1 > x2 and y1 > y2) or (x2 > x1 and y2 > y1):\n                    if (x1, y2) in d and (x2, y1) in d:\n                        min_area = min(min_area, (x2 - x1) * (y2 - y1))\n        \n        if min_area == inf:\n            return 0\n        else:\n            return min_area", "class Solution:\n    def minAreaRect(self, points):\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in pSet) and ((p2x, p1y) in pSet):\n                    ans = min(ans, abs((p1x - p2x) * (p1y - p2y)))\n        return ans if ans < float('inf') else 0\n    \nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in pSet and (p2x, p1y) in pSet:\n                    ans = area\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n    \n    \n", "from itertools import product\n\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        # create the row and col dicts\n        if not points or not points[0]:\n            return 0\n        \n        m, n = len(points), len(points[0])\n        \n        d_row, d_col = {}, {}\n        \n        for r, c in points:\n            d_row[r] = d_row.get(r, []) + [c]\n            d_col[c] = d_col.get(c, []) + [r]\n            \n        # while iterating through the list, check if there are:\n        # 1. if there's another point in the same col\n        # 2. if there's another point in the same row\n        # 3. if there's point that can make a rectangle with points from 2, 3\n        # only consider points to the down/right\n        \n        for r in d_row:\n            d_row[r] = sorted(d_row[r])\n            \n        for c in d_col:\n            d_col[c] = sorted(d_col[c])\n        \n        area = float('inf')\n        for r, c, in points:\n            c2s = [x for x in d_row[r] if x > c]\n            r2s = [x for x in d_col[c] if x > r]\n            if not c2s or not r2s:\n                continue\n                \n            for r2, c2 in product(r2s, c2s):\n                if c2 in d_row[r2]:\n                    area = min(area, (r2 - r) * (c2 - c))\n                    \n        return area if area < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        from collections import defaultdict\n        \n        x_dic = defaultdict(list)\n        y_dic = defaultdict(list)\n        \n        area = float('inf')\n        \n        for x, y in points:\n            x_dic[x].append(y)\n            y_dic[y].append(x)\n            \n            for _y in x_dic[x]:\n                if _y != y and _y in y_dic:\n                    for _x in y_dic[_y]:\n                        if _x != x and _x in x_dic and y in x_dic[_x]:\n                            area = min(area, abs(x - _x) * abs(y - _y))\n        \n        return area if area < float('inf') else 0\n        \n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n      \n        \n#   Assume one point(x1,y1) as bottom left and other (x2,y2) as top right point of a diagnol now search for   \n        points=set([(i[0],i[1]) for i in points ])\n        \n        mini=float(\\\"INF\\\")\n        # points.sort(key=lambda x:x[0])\n        for point1 in points:\n            for point2 in points: \n                x1,y1=point1\n                x2,y2=point2\n                \n                if (x2>x1) and (y2>y1) and (x1,y2) in points and (x2,y1) in points:\n                    # print(x1,y1,x2,y2)\n                    mini=min(mini,(y2-y1)*(x2-x1)) \n            \n        return mini if not mini==float(\\\"INF\\\") else 0\n                \n        \n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        x_memo = collections.defaultdict(set)\n        for x, y in points:\n            x_memo[x].add(y)\n        x_lst = sorted(list(x_memo.keys()))\n        res = math.inf\n        for i in range(len(x_lst)):\n            for j in range(i+1, len(x_lst)):\n                dx = x_lst[j]-x_lst[i]\n                # print (dx)\n                y_common = x_memo[x_lst[i]].intersection(x_memo[x_lst[j]])\n                if len(y_common)<2:\n                    continue\n                y_common = sorted(list(y_common))\n                for k in range(len(y_common)-1):\n                    res = min(res, dx*(y_common[k+1]-y_common[k]))\n        if math.isfinite(res):\n            return res\n        else:\n            return 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        p = collections.defaultdict(set)\n        for x, y in points:\n            p[x].add(y)\n        xs = sorted(p.keys())\n        minv = float('inf')\n        for i in range(len(xs) - 1):\n            for j in range(i + 1, len(xs)):\n                le = xs[j] - xs[i]\n                if le > minv:\n                    break\n                potential = sorted(p[xs[i]].intersection(p[xs[j]]))\n                #print(le, potential)\n                v = float('inf')\n                for j in range(len(potential) - 1):\n                    v = min(v, potential[j + 1] - potential[j])\n                minv = min(minv, v * le)\n        return minv if minv < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n\n\n        s = set(map(tuple, points))\n        dx = collections.defaultdict(list)\n        dy = collections.defaultdict(list)\n        for x,y in points:\n            dx[x].append(y)\n            dy[y].append(x)\n\n        res = float('inf')\n        for x in sorted(dx.keys()): # 1. find x in dx\n            for i in range(len(dx[x])): # 2. find y1, y2 in dx[x]\n                y1 = dx[x][i]\n                for j in range(i+1, len(dx[x])):\n                    y2 = dx[x][j]\n                    for x1 in set(dy[y2])&set(dy[y1]): # 3. find x1 in dy[y2]\n                        # always make x in the left side\n                        if x1 <= x: continue\n                      \n                        res = min(res, abs(x-x1) * abs(y1-y2))\n\n        return res if res != float('inf') else 0", "'''\n939. Minimum Area Rectangle.  Medium\n\nGiven a set of points in the xy-plane, \ndetermine the minimum area of a rectangle\nformed from these points, with sides parallel\nto the x and y axes.\n\nIf there isn't any rectangle, return 0.\n\nExample 1:\nInput: [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\n\nExample 2:\nInput: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n\nNote:\n1 <= points.length <= 500\n0 <= points[i][0] <= 40000\n0 <= points[i][1] <= 40000\nAll points are distinct.\n\nAccepted\n55,377\nSubmissions\n107,280\n\nNOTE: Clarify: rectangle formed by ALL these points (convex hull)\n            v. rectangle formed by ANY four distinct points\n'''\nclass Solution:\n    def minAreaRectangularHull(self, points: List[List[int]]) -> int:\n        area = 0\n        if points:\n            minx, miny = points[0]\n            maxx, maxy = points[0]\n            for x, y in points:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n            area = (maxx - minx)*(maxy - miny)\n        return area\n                \n\n    def minAreaRect(self, points):\n        '''\n        Runtime: 1720 ms, faster than 36.22% of Python3 online submissions for Minimum Area Rectangle.\n        Memory Usage: 14.4 MB, less than 17.19% of Python3 online submissions for Minimum Area Rectangle.\n        '''\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for k, (xB, yB) in enumerate(points):\n            for j in range(k):\n                xA, yA = points[j]\n                if (xA != xB and yA != yB and (xA, yB) in S and (xB, yA) in S):\n                    ans = min(ans, abs((xB - xA) * (yB - yA)))\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points):\n        \\\"\\\"\\\"\n        * loose criteria, just check all pairs of points.\n        * set is faster than list\n        \\\"\\\"\\\"\n        seen = set()\n        res = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    res = min(res, area)\n                    # if area and area < res:\n                    #     res = area\n            seen.add((x1, y1))\n        return res if res < float('inf') else 0\n    \n        ### TLE\n        # res = float('inf')\n        # for i, (x1, y1) in enumerate(points):\n        #     for x2, y2 in points[i:]:\n        #         if [x1, y2] in points and [x2, y1] in points:\n        #             area = abs(x1 - x2) * abs(y1 - y2)\n        #             if area and area < res:\n        #                 res = area\n        #     #seen.add((x1, y1))\n        # return res if res < float('inf') else 0\n    \n\n\n        ", "from collections import defaultdict\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        xs = defaultdict(list)\n        ys = defaultdict(list)\n        hm = defaultdict(bool)\n\n        for point in points:\n            xs[point[0]] += [point]\n            ys[point[1]] += [point]\n            hm[tuple(point)] = True \n\n        min_area = float(\\\"inf\\\")\n        for p1 in points:\n            # get all points on the same y as p1 that are \n            same_y = [(x,y) for x,y in ys[p1[1]] if x > p1[0]]\n            same_x = [(x,y) for x,y in xs[p1[0]] if y > p1[1]]\n\n            for p2 in same_y:\n                for p3 in same_x:\n                    p4 = (p2[0], p3[1])\n                    if hm[p4]:\n                        dx = abs(p2[0]-p1[0])\n                        dy = abs(p3[1]-p1[1])\n                        min_area = min(min_area, dx*dy)\n\n        return min_area if min_area < float(\\\"inf\\\") else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        output = float('inf')\n        \n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1-x2) * abs(y1-y2)\n                    if area > 0 and area < output:\n                        output = area\n            seen.add((x1,y1))\n        return output if output < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) <= 1:\n            return 0\n        points.sort(key=lambda a: a[0] * 10 ** 6 + a[1])\n        min_array = float(\\\"inf\\\")\n        point_dict = {}\n        current_layer = -1\n        current_points = []\n        for y, x in points:\n            if y != current_layer:\n                for old_x in current_points:\n                    point_dict.setdefault(old_x, set()).add(current_layer)\n                current_layer = y\n                current_points = []\n            if x in point_dict:\n                for previous_x in current_points:\n                    valid_y = point_dict[x].intersection(point_dict[previous_x])\n                    if valid_y:\n                        min_array = min(min_array, (y - max(valid_y)) * (x - previous_x))\n                current_points.append(x)\n            else:\n                point_dict.setdefault(x, set()).add(y)\n        if min_array == float(\\\"inf\\\"):\n            return 0\n        else:\n            return min_array", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n      #  if points == [] or points == [[]] or points == None or len(points) < 4:\n      #      return 0\n        \n        seen = set()\n        res = float('inf')\n        for x1, y1 in points:\n            for x2, y2 in seen:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x1 - x2) * abs(y1 - y2)\n                    if area and area < res:\n                        res = area\n            seen.add((x1, y1))\n        \n        if res != float('inf'):\n            return res\n        else: \n            return 0\n\n            \n        \n        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        horizontal line if yi == yj\n        veritcal line if xi == xj\n        \n        valid rectangle:\n        - p1, p2, p3, p4 such that\n        \\\"\\\"\\\"\n        \n        min_area = float('inf')\n        \n        pts = {(x,y) for x,y in points}\n        \n        for x1,y1 in pts:\n            for x2,y2 in pts:\n                if x2 > x1 and y2 > y1: #first pt is bottom left vertex, second pt is upper right vertex\n                    if (x1, y2) in pts and (x2, y1) in pts:\n                        min_area = min(min_area, abs(x2-x1) * abs(y2-y1))\n                        \n        if min_area == float('inf'):\n            return 0\n        return min_area", "'''\n939. Minimum Area Rectangle.  Medium\n\nGiven a set of points in the xy-plane, \ndetermine the minimum area of a rectangle\nformed from these points, with sides parallel\nto the x and y axes.\n\nIf there isn't any rectangle, return 0.\n\nExample 1:\nInput: [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\n\nExample 2:\nInput: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n\nNote:\n1 <= points.length <= 500\n0 <= points[i][0] <= 40000\n0 <= points[i][1] <= 40000\nAll points are distinct.\n\nAccepted\n55,377\nSubmissions\n107,280\n\nNOTE: Clarify: rectangle formed by ALL these points (convex hull)\n            v. rectangle formed by ANY four distinct points\n'''\nclass Solution:\n    def minAreaRectangularHull(self, points: List[List[int]]) -> int:\n        area = 0\n        if points:\n            minx, miny = points[0]\n            maxx, maxy = points[0]\n            for x, y in points:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n            area = (maxx - minx)*(maxy - miny)\n        return area\n                \n\n    def minAreaRect(self, points):\n        '''\n        Runtime: 1628 ms, faster than 38.40% of Python3 online submissions for Minimum Area Rectangle.\n        Memory Usage: 14.4 MB, less than 17.19% of Python3 online submissions for Minimum Area Rectangle.\n        '''\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for k, (xB, yB) in enumerate(points):\n            for j in range(k):\n                xA, yA = points[j]\n                if (xA != xB and yA != yB and (xA, yB) in S and (xB, yA) in S):\n                    ans = min(ans, abs((xB - xA) * (yB - yA)))\n        return ans if ans < float('inf') else 0\n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # similar=[]\n        \n        # for point in points:\n        #     x,y=point\n        #     if x==y:\n        #         similar.append((x,y))\n        points_set=set([(i[0],i[1]) for i in points ])\n        \n        mini=float(\\\"INF\\\")\n        # points.sort(key=lambda x:x[0])\n        for point1 in points:\n            for point2 in points: \n                x1,y1=point1\n                x2,y2=point2\n                \n                if (x2>x1) and (y2>y1) and (x1,y2) in points_set and (x2,y1) in points_set:\n                    # print(x1,y1,x2,y2)\n                    mini=min(mini,(y2-y1)*(x2-x1)) \n            \n        return mini if not mini==float(\\\"INF\\\") else 0\n                \n        \n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        mx = defaultdict(set)\n        for x, y in points: mx[x].add(y)\n        ans, n = float('inf'), len(points)\n        for i in range(n-1):\n            x1, y1 = points[i]\n            for j in range(i+1, n):                \n                x2, y2 = points[j]\n                if x2 == x1 or y2 == y1 or y2 not in mx[x1] or y1 not in mx[x2]: continue                    \n                ans = min(abs(x2-x1)*abs(y2-y1), ans)\n        return 0 if ans == float('inf') else ans", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        counter = Counter(list(map(tuple, points)))\n        if any(count >= 4 for count in list(counter.values())):\n            return 0\n        points = list(counter)\n        result = float('inf')\n        for i, (x, y) in enumerate(points):\n            for j in range(i + 1, len(points)):\n                x_, y_ = points[j]\n                if x != x_ and y != y_:\n                    area = abs((x_ - x) * (y_ - y))\n                    if area < result and (x, y_) in counter and (x_, y) in counter:\n                        if not area:\n                            return 0\n                        result = area\n                elif counter[(x, y)] == 2 and counter[(x_, y_)] == 2:\n                        return 0\n        return 0 if result == float('inf') else result\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        # hash set\n        points = { (x, y) for x, y in points}\n        min_area = float('inf')\n        \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 == x2 or y1 == y2:\n                    continue\n                if abs((x1 - x2) * (y1 - y2)) > min_area:\n                    # Don't lookup\n                    continue\n                if (x1, y2) in points and (x2, y1) in points:\n                    min_area = min(min_area, abs((x1 - x2) * (y1 - y2)))\n                        \n        if min_area == float('inf'):\n            return 0\n        return min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points: return 0\n        x_lines, y_lines = {}, {}\n        for x, y in points:\n            x_lines[x] = x_lines.get(x, set()) | {y}\n            y_lines[y] = y_lines.get(y, set()) | {x}\n        # print(x_lines, y_lines)\n        res = float('inf')\n        for x, y_s in x_lines.items():\n            if len(y_s) <2: continue\n            # print(x, y_s)\n            y_s = list(y_s)\n            for i in range(len(y_s)):\n                for j in range(i+1, len(y_s)):\n                    y1, y2 = y_s[i], y_s[j]\n                    inter = y_lines[y1].intersection(y_lines[y2])\n                    # print(inter)\n                    if len(inter) <= 1: continue\n                    for x2 in inter:\n                        if x2 == x: continue \n                        res = min(res, abs(y1-y2)*abs(x-x2))\n        return res if res != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        # watch for degenerate cases of 4 same points or getting a line\n        # if points weren't distinct, can convert to set and then back to list\n        # for every x, need list of y's (set)\n        # for every y, need list of x's (set)\n        # then, O(4) to find a rectangle\n        # x_vals: {1: [1, 3], 3: [3, 1], 2: [2]}\n        # y_vals: {1, [1, 3], 3: [3, 1], 2: [2]}\n        \n        # Then, to check, loop through all x's and see if we can get all 4 points for each; if so, calculate area\n        x_vals = defaultdict(set)\n        y_vals = defaultdict(set)\n        for p in points:\n            x_vals[p[0]].add(p[1])\n            y_vals[p[1]].add(p[0])\n        # print(x_vals)\n        # print(y_vals)\n        min_area = 40000*40000 + 1\n        for x, y_coords in list(x_vals.items()):\n            if len(y_coords) == 1:\n                continue # can't make a rectangle if it's the only point on that x = x line\n            y_list = list(y_coords)\n            for i, y_1 in enumerate(y_list):\n                for j, y_2 in enumerate(y_list[i+1:]):\n                    # we have points (x, y_1) and (x, y_2)\n                    # now need to check if same value in both y_vals[y_1] and y_vals[y_2]\n                    # if so, we have a rectangle!\n                    common_x_2 = y_vals[y_1].intersection(y_vals[y_2])\n                    common_x_2.remove(x)\n                    for x_2 in list(common_x_2):\n                        # print(x, x_2, y_1, y_2)\n                        min_area = min(min_area, abs(x_2 - x) * abs(y_2 - y_1))\n        if min_area == 40000*40000 + 1:\n            return 0\n        return min_area\n", "\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        point_set = set([tuple(x) for x in points])\n            \n        min_size = float('inf')\n        n = len(points)\n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(i+1, n):\n                x2, y2 = points[j]\n                if x1 == x2 or y1 == y2:\n                    continue\n                \n                if (x1, y2) in point_set and (x2, y1) in point_set:\n                    size = (y2-y1)*(x2-x1)\n                    min_size = min(min_size, abs(size))\n                    continue\n                    \n        if min_size == float('inf'):\n            return 0\n        return min_size\n                \n", "class Solution:\n    def minAreaRect(self, points):\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in pSet) and ((p2x, p1y) in pSet):\n                    ans = min(ans, abs((p1x - p2x) * (p1y - p2y)))\n        return ans if ans < float('inf') else 0\n    \nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in pSet and (p2x, p1y) in pSet:\n                    ans = area\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        m = set()\n        for point in points:\n            m.add(tuple(point))\n        res = 0x3fffffff\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            for j in range(i + 1, len(points)):\n                x2, y2 = points[j]\n                if x1 != x2 and y1 != y2:\n                    if (x1, y2) in m and (x2, y1) in m:\n                        res = min(res, abs((y1 - y2) * (x1 - x2)))\n        res = 0 if res == 0x3fffffff else res\n        return res", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        res = float('inf')\n        for point in points:                                                    \n            x, y = point[0], point[1]            \n            for _x, _y in seen:\n                if (x, _y) in seen and (_x, y) in seen:\n                    res = min(res, abs(x - _x) * abs(y - _y))\n            seen.add((x, y))\n            \n        if res == float('inf'):\n            return 0\n        return res\n                \n\n            \n            \n'''\n    def minAreaRect(self, points):\n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        if nx == n or ny == n:\n            return 0\n\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n\n        lastx = {}\n        res = float('inf')\n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i]\n                    if (y1, y2) in lastx:\n                        res = min(res, (x - lastx[y1, y2]) * abs(y2 - y1))\n                    lastx[y1, y2] = x\n        return res if res < float('inf') else 0\n\n'''\n        \n        \n            \n            \n", "class Solution:\n    def minAreaRect(self, points):\n        \\\"\\\"\\\"\n        :type points: List[List[int]]\n        :rtype: int\n        In order to form a rectangle, you need four points all positioned at 90 degrees to each other.\n        In this approach, we store all given points in a set.Then iteratively go through all the points in two loops (x1, y1) and (x2, y2) while checking if (x1, y2) and (x2, y1) are also valid points. If so, we found a rectangle.We calculate the area of this rectangle. If this area is smaller than the minimum area seen so far, make it the minimum area.\n        \n        \\\"\\\"\\\"\n        min_area = sys.maxsize\n        points_table = set()\n        \n        for x, y in points:\n            points_table.add((x,y))\n            \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2:\n                    # Skip looking at same point\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x1 -  x2) * abs(y1 - y2)\n                        if area:\n                            min_area = min(area, min_area)\n                        \n        return 0 if min_area == sys.maxsize else min_area", "'''\n939. Minimum Area Rectangle.  Medium\n\nGiven a set of points in the xy-plane, \ndetermine the minimum area of a rectangle\nformed from these points, with sides parallel\nto the x and y axes.\n\nIf there isn't any rectangle, return 0.\n\nExample 1:\nInput: [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\n\nExample 2:\nInput: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n\nNote:\n1 <= points.length <= 500\n0 <= points[i][0] <= 40000\n0 <= points[i][1] <= 40000\nAll points are distinct.\n\nAccepted\n55,377\nSubmissions\n107,280\n\nNOTE: Clarify: rectangle formed by ALL these points (convex hull)\n            v. rectangle formed by ANY four distinct points\n'''\nclass Solution:\n    def minAreaRectangularHull(self, points: List[List[int]]) -> int:\n        area = 0\n        if points:\n            minx, miny = points[0]\n            maxx, maxy = points[0]\n            for x, y in points:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n            area = (maxx - minx)*(maxy - miny)\n        return area\n                \n\n    def minAreaRect(self, points):\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for k, (xB, yB) in enumerate(points):\n            for j in range(k):\n                xA, yA = points[j]\n                if (xA != xB and yA != yB and (xA, yB) in S and (xB, yA) in S):\n                    ans = min(ans, abs(xB - xA) * abs(yB - yA))\n        return ans if ans < float('inf') else 0\n", "from collections import defaultdict\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points:\n            return 0\n        \n        mapper = defaultdict(set)\n\n        for point in points:\n            mapper[point[1]].add(point[0])\n            \n        result = float('inf')\n        \n        for y1, x_values1 in list(mapper.items()):\n            \n            for y2, x_values2 in list(mapper.items()):\n                if y1 == y2:\n                    continue\n                intersect = x_values1.intersection(x_values2)\n                \n                if len(intersect) < 2:\n                    continue\n                \n                x_min_diff = self.min_diff(list(intersect))\n                \n                temp = x_min_diff * abs(y1-y2)\n                if temp < result:\n                    result = temp\n        return result if result != float('inf') else 0\n    \n    def min_diff(self, given: list) -> int:\n        result = float('inf')\n        \n        for i in range(len(given)):\n            for j in range(i+1, len(given)):\n                diff = abs(given[i] - given[j])\n                if diff < result:\n                    result = diff\n        return result\n                \n                        \n        \n            \n            \n        \n            \n            \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_set = set(map(tuple, points))\n        \n        min_area = float('inf')\n        \n        for i, p1 in enumerate(points):\n            for j in range(i):\n                p2 = points[j]\n                potential_area = abs(p1[0]-p2[0]) * abs(p1[1]-p2[1])\n                \n                if potential_area == 0 or potential_area > min_area:\n                    continue\n                    \n                if (p1[0],p2[1]) in point_set and (p2[0],p1[1]) in point_set:\n                    \n                    min_area = min(potential_area, min_area)     \n                    \n        return 0 if min_area == float('inf') else min_area", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        ref_x = defaultdict(list)\n        ref_y = defaultdict(list)\n        \n        for point in points:\n            x, y = point[0], point[1]\n            ref_x[x].append(y)\n            ref_y[y].append(x)\n            \n        print(\\\"ref_x={}\\\".format(ref_x))\n        print(\\\"ref_y={}\\\".format(ref_y))\n        \n        ans = float('inf')\n        for x in ref_x.keys():\n            if len(ref_x[x]) < 2:\n                continue\n            \n            ys = sorted(ref_x[x])\n            for i in range(len(ys)-1):\n                first_y = ys[i]\n                if len(ref_y[first_y]) < 2:\n                    continue\n                for j in range(i+1, len(ys)):\n                    second_y = ys[j]\n                    if len(ref_y[second_y]) < 2:\n                        continue\n                    \n                    second_xs = list(set(ref_y[first_y]).intersection(set(ref_y[second_y])))\n                    if not second_xs:\n                        continue\n                    \n                    for second_x in second_xs:\n                        #print(\\\"first_x={} second_x={} first_y={} second_y={} res={}\\\".format(x, second_x, first_y, second_y, abs(x-second_x)*abs(first_y-second_y)))\n                        if x != second_x and first_y != second_y:\n                            ans = min(ans, abs(x-second_x)*abs(first_y-second_y))\n                        \n        return ans if ans < float('inf') else 0\n                \n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points_set = set((r,c) for r,c in points)\n        m = 2 ** 32\n        for i in range(len(points)):\n            x1,y1 = points[i]\n            for j in range(i, len(points)):\n                x2,y2 = points[j]\n                if x2 == x1 or y2 == y1:\n                    continue\n                if (x2,y1) not in points_set:\n                    continue\n                if (x1,y2) not in points_set:\n                    continue\n                area = abs(x1-x2) * abs(y1 - y2)\n                m = min(m,area)\n        if m == 2**32:\n            return 0\n        else:\n            return m", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        st = set()\n        \n        for x,y in points:\n            st.add((x,y))\n            \n        minarea = float('Inf')\n        for i, p1 in enumerate(points):\n            for p2 in points[:i]:\n                x1,y1 = p1\n                x2,y2 = p2\n                \n                if x1 != x2 and y1 != y2 and (x1,y2) in st and (x2,y1) in st:\n                    minarea = min(minarea, abs(x1-x2)*abs(y1-y2))\n                    \n        return minarea if minarea < float('Inf') else 0", "class Solution:\n    def minAreaRect(self, a: List[List[int]]) -> int:\n        mx = defaultdict(set)\n        for x, y in a:\n            mx[x].add(y)\n        ans, n = float('inf'), len(a)\n        # print(mx)\n        for i in range(n-1):\n            x1, y1 = a[i]\n            for j in range(i+1, n):                \n                x2, y2 = a[j]\n                if x2 == x1 or y2 == y1 or y2 not in mx[x1] or y1 not in mx[x2]:\n                    continue                    \n                ans = min(abs(x2-x1)*abs(y2-y1), ans)\n        return 0 if ans == float('inf') else ans", "from collections import defaultdict\nfrom bisect import insort\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0 \n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            insort(columns[r], c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in columns.items():\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = abs((r - lastc[(c1, c2)]) * (c2 - c1))\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        dic = collections.defaultdict(set)\n        for x, y in points:\n            dic[x].add(y)\n        res = float('inf')\n        n = len(points)\n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                if x1 == x2 or y1 == y2 or y2 not in dic[x1] or y1 not in dic[x2]:\n                    continue\n                else:\n                    res = min(res, abs(x1 - x2) * abs(y1 - y2))\n        return res if res != float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points = sorted(points, key=lambda x: (x[0], x[1]))\n        self.res = float('inf')\n        self.cache = defaultdict(list)\n        \n        x_cache = defaultdict(list)\n        \n        for x,y in points:\n            for y2 in x_cache[x]:\n                if y2 < y:\n                    for x_other in self.cache[(y, y2)]:\n                        self.res = min(self.res, abs(x_other-x) * abs(y2-y))\n                    self.cache[(y, y2)].append(x)\n            x_cache[x].append(y)\n        if self.res == float('inf'):\n            self.res = 0\n        return self.res", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        maps = set(map(tuple, points))\n        points.sort()\n        n = len(points)\n        result = math.inf\n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                if x2 == x1 or y1 == y2: continue\n                if (x1, y2) in maps and (x2, y1) in maps:\n                    result = min(result, (x2 - x1) * abs(y2 - y1))\n        return 0 if math.isinf(result) else result", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        |\n        |  *       *   \n        |       *\n        |  *       *\n        |_______________\n        \n        \n        \n        \n        \\\"\\\"\\\"\n        \n        min_x = float('inf')\n        max_x = float('-inf')\n        \n        points_dict = dict()\n        left_sides = dict()\n        \n        for point in points:\n            min_x = min(min_x, point[0])\n            max_x = max(max_x, point[0])\n        \n            if point[0] not in points_dict:\n                points_dict[point[0]] = [point]\n            else:\n                points_dict[point[0]].append(point)\n        \n        min_area = float('inf')\n        \n        \n        for x in range(min_x, max_x + 1):\n            if x in points_dict:\n                for point in points_dict[x]:\n                    for point2 in points_dict[x]:\n                        if (point[1], point2[1]) in left_sides:\n                            min_area = min(min_area, abs(point[1] - point2[1]) * abs(point[0] - left_sides[point[1], point2[1]]))\n\n                        if point != point2:\n                            left_sides[point[1], point2[1]] = x\n        \n        return 0 if min_area == float('inf') else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        dic = collections.defaultdict(set)\n        for x, y in points:\n            dic[x].add(y)\n        res = float('inf')\n        n = len(points)\n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                if x1 == x2 or y1 == y2 or y2 not in dic[x1] or y1 not in dic[x2]:\n                    continue\n                else:\n                    res = min(res, abs(x1 - x2) * abs(y1 - y2))\n        return res if res != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        res = sys.maxsize\n        diag = collections.defaultdict(set)\n        for i, j in points:\n            diag[i].add(j)\n        \n        for i in range(len(points)):\n            a1, a2 = points[i]\n            for j in range(len(points)):\n                b1, b2 = points[j]\n                if not (b1 > a1 and b2 > a2):\n                    continue\n                if b2 in diag[a1] and a2 in diag[b1]:\n                    # print(\\\"?\\\")\n                    res = min(res, abs(a1 - b1) * abs(a2 - b2))\n        \n        \n        return res if res != sys.maxsize else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        def intersection(lst1, lst2): \n            return list(set(lst1) & set(lst2)) \n  \n        col=defaultdict(list)\n#        row=defaultdict(list)\n        ans=float('inf')\n        for point in points:\n            col[point[0]].append(point[1])\n#            row[point[1]].append(point[0])\n        cols=list(col.keys())\n        for i1 in range(len(cols)):\n            for i2 in range(i1+1,len(cols)):\n                col1=cols[i1]\n                col2=cols[i2]\n                il=sorted(intersection(col[col1],col[col2]))\n                for i in range(1,len(il)):\n                    ans=min(ans,(il[i]-il[i-1])*abs(col2-col1))\n        return ans if ans<float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        minArea = float('inf')\n        pointsSet = set()\n        for x, y in points:\n            pointsSet.add((x, y))\n        \n            \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 > x2 and y1 > y2:\n                    if (x1, y2) in pointsSet and (x2, y1) in pointsSet:\n                        area = abs(x1-x2) * abs(y1-y2)\n                        if area:\n                            minArea = min(minArea, area)\n                            \n        return minArea if minArea != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        area = float(inf)\n        dt = set()\n        for x, y in points:\n            dt.add((x,y))\n        \n        for i in range(len(points)):\n            x, y = points[i]\n            for j in range(i+1, len(points)):\n                h, v = points[j]\n                if h == x or v == y:\n                    continue\n                if (x,v) in dt and (h, y) in dt:\n                    area = min(area, abs(y-v)*abs(h-x))\n        \n        return area if area != float('inf') else 0", "import itertools\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points:\n            return 0\n        ybucket = defaultdict(list)\n        for x, y in points:\n            ybucket[y].append(x)\n\n        for k, v in ybucket.items():\n            if len(v) >= 2:\n                ybucket[k] = sorted(v)\n\n        ys = [k for k in ybucket.keys() if len(ybucket[k]) >= 2]\n        ans = float('inf')\n        for y1, y2 in itertools.combinations(ys, 2):\n            row1 = set(ybucket[y1])\n            row2 = ybucket[y2]\n            dy = abs(y2-y1)\n            xlast = None            \n            for x in row2:\n                if x in row1:\n                    if xlast is not None:\n                        ans = min(ans, abs(x-xlast)*dy)\n                    xlast = x\n\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        xs = collections.defaultdict(set)\n        ys = collections.defaultdict(set)\n        for point in points:\n            x, y = point[0], point[1]\n            xs[x].add(y)\n            ys[y].add(x)\n        area = 40000 ** 2 + 1\n        for x in xs:\n            for y1, y2 in itertools.product(xs[x], xs[x]):\n                if y1 <= y2:\n                    continue\n                #print(f'x={x}, y1={y1}, y2={y2}')\n                A = set(xx for xx in ys[y1] & ys[y2] if xx < x)\n                #print('A=', A)\n                if len(A) > 0:\n                    area = min(area, (y1 - y2) * (x - max(A)))\n        return 0 if area == 40000 ** 2 + 1 else area", "\\\"\\\"\\\"\nhttps://www.youtube.com/watch?v=pFgBZFKJ2Co\nfast forward to 17minutes\n\nGroup the points by x coordinates, so that we have columns of points. Then, for every pair of points in a column (with coordinates (x,y1) and (x,y2)), check for the smallest rectangle with this pair of points as the rightmost edge. We can do this by keeping memory of what pairs of points we've seen before.\n\ncolumns = {\n    1: 1, 3\n    3: 1, 3\n    4: 1, 4\n    \n}\n\ncolumn = [1,3]\n\\\"\\\"\\\"\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # dictionary that stores a list of x coordinates for each vertical edge (y1, y2) where y1 < y2\n        x_coord = collections.defaultdict(list) \n        points.sort(key = lambda x: (x[0], x[1])) # For making traversal more convenient\n        min_area = float('inf')\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 == x2: # This is a vertical edge.\n                    if (y1, y2) in x_coord: # We have seen this vertical edge in the past.\n                        x_other = x_coord[(y1, y2)][-1] # Recall: we traverse points in the order of inceasing x\n                        min_area = min(min_area, (y2-y1) * (x1 - x_other)) # Update min area\n                    x_coord[(y1, y2)].append(x1)\n        return min_area if min_area!=float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        ptmap = {}\n        min_area = float('inf')\n        for x1,y1 in points:\n            for x2,y2 in ptmap:\n                if ((x1,y2) in ptmap) and ((x2,y1) in ptmap):\n                    area = abs(x2-x1) * abs(y2-y1)\n                    min_area  = min(area,min_area)\n            ptmap[(x1,y1)] = (x1,y1)\n        return min_area if min_area!=float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pointrec=dict()\n        for x,y in points:\n            if not x in pointrec:\n                pointrec[x]=dict()\n            pointrec[x][y]=1\n        area=16*10**8\n        for i in range(len(points)-1):\n            for j in range(i+1,len(points)):\n                a=abs((points[i][0]-points[j][0])*(points[i][1]-points[j][1]))\n                if a==0:\n                    continue\n                if a<area and (points[j][1] in pointrec[points[i][0]]) and (points[i][1] in pointrec[points[j][0]]):\n                    area=a\n        if area==16*10**8:\n            area=0\n        return area", "MAX_AREA = 40000 * 40000\nclass Solution:\n\\tdef minAreaRect(self, points: List[List[int]]) -> int:\n\\t\\tpoints_set = set()\n\\t\\tfor x, y in points:\n\\t\\t\\tpoints_set.add((x,y))\n\\t\\tmin_area = MAX_AREA\n\\t\\tn = len(points)\n\\t\\tfor i in range(n-1):\n\\t\\t\\tx1,y1 = points[i]\n\\t\\t\\tfor j in range(i+1, n):\n\\t\\t\\t\\tx2,y2 = points[j]\n\\t\\t\\t\\tif x1 == x2 or y1 == y2:\n\\t\\t\\t\\t\\tcontinue\n\\t\\t\\t\\tif (x1, y2) in points_set and (x2,y1) in points_set:\n\\t\\t\\t\\t\\tmin_area = min(min_area, abs(x2 - x1) * abs(y2 - y1))\n\n\\t\\treturn 0 if min_area == MAX_AREA else min_area\n", "from collections import defaultdict\nfrom itertools import combinations\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        mPoints = set( (x, y) for x, y in points )\n        area = float('inf')\n        \n        for (x1, y1), (x2, y2) in combinations(points, 2):\n            if x1 != x2 and y1 != y2 and (x1, y2) in mPoints and (x2, y1) in mPoints:\n                area = min(area, abs(x1-x2)*abs(y1-y2))\n        return area if area < float('inf') else 0\n                \n            \n        \n        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        counter = Counter(list(map(tuple, points)))\n        if any(count >= 4 for count in list(counter.values())):\n            return 0\n        points = list(counter)\n        result = float('inf')\n        for i, (x, y) in enumerate(points):\n            for j in range(i + 1, len(points)):\n                x_, y_ = points[j]\n                area = abs((x_ - x) * (y_ - y))\n                if x != x_ and y != y_:\n                    if area < result and (x, y_) in counter and (x_, y) in counter:\n                        result = area\n                        if not result:\n                            return 0\n                elif counter[(x, y)] == 2 and counter[(x_, y_)] == 2:\n                        return 0\n        return 0 if result == float('inf') else result\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        xd = collections.defaultdict(set)\n        \n        for p in points:\n            xd[p[0]].add(p[1])\n        \n        yd = collections.defaultdict(list)\n        \n        for x, v in list(xd.items()):\n            if len(v) < 2:\n                continue\n                \n            ys = list(v)\n            \n            for i in range(len(ys)):\n                for j in range(i+1, len(ys)):\n                    miny, maxy = min(ys[i], ys[j]), max(ys[i], ys[j])\n                    yd[(miny, maxy)].append(x)\n                    \n        res = float('inf')\n        \n        for ypair, xlist in list(yd.items()):\n            if len(xlist) < 2:\n                continue\n            \n            xlist = sorted(xlist)\n            h = ypair[1] - ypair[0]\n            \n            for i in range(len(xlist)-1):\n                res = min(res, h * (xlist[i+1] - xlist[i]))\n        \n        return res if res != float('inf') else 0\n                \n            \n             \n            \n        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        d = collections.defaultdict(set)\n        for i in range(len(points)):\n            x0, y0 = points[i]\n            for j in range(i+1, len(points)):\n                x1, y1 = points[j]\n                if x0 == x1:\n                    d[x0].add(tuple(sorted([y0,y1])))\n        seen = set()\n        minA = float('inf')\n        for x0, lines0 in d.items(): \n            seen.add(x0)\n            for x1, lines1 in d.items():\n                if x1 not in seen:\n                    for l in lines0:\n                        if l in lines1:\n                            minA = min(minA, abs(x0-x1)*(l[1]-l[0]))\n        return minA if minA<float('inf') else 0", "from collections import defaultdict\nfrom bisect import insort\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            insort(columns[r], c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in columns.items():\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        ans = min(ans, (r - lastc[(c1, c2)]) * (c2 - c1))\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, a: List[List[int]]) -> int:\n        mx = defaultdict(set)\n\n        for x, y in a: mx[x].add(y)\n\n        ans, n = float('inf'), len(a)\n        for i in range(n-1):\n            x1, y1 = a[i]\n            for j in range(i+1, n):\n                x2, y2 = a[j]\n\n                if x2 == x1 or y2 == y1 or y2 not in mx[x1] or y1 not in mx[x2]: continue\n                ans = min(abs(x2-x1)*abs(y2-y1), ans)\n\n        return 0 if ans == float('inf') else ans\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        x_to_points = defaultdict(lambda: [])\n        y_to_points = defaultdict(lambda: set())\n        for [x, y] in points:\n            x_to_points[x].append((x, y))\n            y_to_points[y].add((x, y))\n            \n        min_rect = float('inf')\n        for x in sorted(x_to_points.keys()):\n            xpoints = x_to_points[x]\n            if len(xpoints) < 2:\n                continue\n            \n            for x1_index in range(len(xpoints)):\n                for x2_index in range(x1_index + 1, len(xpoints)):\n                    x1, y1 = xpoints[x1_index]\n                    x2, y2 = xpoints[x2_index]\n                    for x3, y3 in y_to_points[y1]:     \n                        if x3 == x2:\n                            continue\n                        if (x3, y2) in y_to_points[y2]:\n                            min_rect = min(min_rect, abs(y2-y1)*abs(x3-x2))\n            \n        \n        return 0 if min_rect  == float('inf') else min_rect\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        res = inf = float('inf')\n        points_set = set(tuple(i) for i in points)\n        points = list(points_set)\n        n = len(points)\n        for i in range(n):\n            for j in range(i+1, n):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 != x2 and y1 != y2 and (x1, y2) in points_set and (x2, y1) in points_set:\n                    res = min(res, abs((x2-x1)*(y2-y1)))\n        return res if res != inf else 0", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        dctyx=defaultdict(set) #key: y, value:x\n        dctxy=defaultdict(set)\n        xlist=[]\n        ylist=[]\n        for x,y in points:\n            dctyx[y].add(x)\n            dctxy[x].add(y)\n        ans=inf\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                x1,y1=points[i]\n                x2,y2=points[j]\n                if not (x1==x2 or y1==y2):\n                    if y2 in dctxy[x1] and x2 in dctyx[y1]:\n                        ans=min(ans,abs(x1-x2)*abs(y1-y2))\n        return ans if ans!=inf else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        # watch for degenerate cases of 4 same points or getting a line\n        # if points weren't distinct, can convert to set and then back to list\n        # for every x, need list of y's (set)\n        # for every y, need list of x's (set)\n        # then, O(4) to find a rectangle\n        # x_vals: {1: [1, 3], 3: [3, 1], 2: [2]}\n        # y_vals: {1, [1, 3], 3: [3, 1], 2: [2]}\n        \n        # Then, to check, loop through all x's and see if we can get all 4 points for each; if so, calculate area\n        \n        # Runtime: O(n^3)\n        # x_vals = defaultdict(set)\n        # y_vals = defaultdict(set)\n        # for p in points:\n        #     x_vals[p[0]].add(p[1])\n        #     y_vals[p[1]].add(p[0])\n        # # print(x_vals)\n        # # print(y_vals)\n        # min_area = 40000*40000 + 1\n        # for x, y_coords in x_vals.items():\n        #     if len(y_coords) == 1:\n        #         continue # can't make a rectangle if it's the only point on that x = x line\n        #     y_list = list(y_coords)\n        #     for i, y_1 in enumerate(y_list):\n        #         for j, y_2 in enumerate(y_list[i+1:]):\n        #             # we have points (x, y_1) and (x, y_2)\n        #             # now need to check if same value in both y_vals[y_1] and y_vals[y_2]\n        #             # if so, we have a rectangle!\n        #             common_x_2 = y_vals[y_1].intersection(y_vals[y_2])\n        #             common_x_2.remove(x) # avoid degenerate case of a line\n        #             for x_2 in list(common_x_2):\n        #                 # print(x, x_2, y_1, y_2)\n        #                 min_area = min(min_area, abs(x_2 - x) * abs(y_2 - y_1))\n        # if min_area == 40000*40000 + 1:\n        #     return 0\n        # return min_area\n    \n        # Improved O(n^2) solution that's a lot simpler too:\n        x_coord = collections.defaultdict(list) # dictionary that stores a list of x coordinates for each vertical edge (y1, y2) where y1 < y2\n        points.sort(key = lambda x: (x[0], x[1])) # For making traversal more convenient\n        min_area = float('inf')\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 == x2: # This is a vertical edge.\n                    if (y1, y2) in x_coord: # We have seen this vertical edge in the past.\n                        x_other = x_coord[(y1, y2)][-1] # Recall: we traverse points in the order of inceasing x\n                        min_area = min(min_area, (y2-y1) * (x1 - x_other)) # Update min area\n                    x_coord[(y1, y2)].append(x1)\n        return min_area if min_area!=float('inf') else 0\n", "from itertools import combinations\n\nclass Solution:\n    def minAreaRect(self, points) -> int:\n        point_x = {}\n        point_y = {}\n        result = float('inf')\n        for i in points:\n            if point_x.get(i[0]):\n                point_x[i[0]].add(i[1])\n            else:\n                point_x[i[0]] = set([i[1]])\n            if point_y.get(i[1]):\n                point_y[i[1]].add(i[0])\n            else:\n                point_y[i[1]] = set([i[0]])\n        for i in point_x:\n            if len(point_x[i]) < 2:\n                continue\n            for y1, y2 in combinations(point_x[i], 2):\n                inter = sorted(point_y[y1].intersection(point_y[y2]))\n                if len(inter) >= 2:\n                    result = min(min([inter[j] - inter[j - 1] for j in range(1, len(inter))]) * abs(y1 - y2), result)\n\n        if result == float('inf'):\n            result = 0\n        return result", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        coord = {(x, y) for x, y in points}\n        n = len(points)\n        min_area = sys.maxsize\n        for i in range(n):\n            for j in range(i+1, n):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 == x2 or y1 == y2: # Not diagonal of rectangle. It's just straight line so rect area would be 0 then\n                    continue\n                if (x1, y2) in coord and (x2, y1) in coord:\n                    min_area = min(min_area, abs((x1-x2)*(y1-y2)))\n                    # print(x1, x2, y1, y2, min_area)\n                \n        return min_area if min_area!=sys.maxsize else 0\n    \n#     math.sqrt((y1-y2)**2 + (x1-x2)**2), min_area\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        s = set()\n        for a,b in points:\n            s.add((a,b))\n        n = len(points)\n        res = float('inf')\n        for i in range(n):\n            for j in range(i+1,n):\n                \n                a,b = points[i]\n                c,d = points[j]\n                if a!=c and b!=d:\n                    if (a,d) in s and (c,b) in s: \n                        res = min(res, abs((a-c)*(b-d)))\n        return res if res < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        counter = Counter(list(map(tuple, points)))\n        if any(count >= 4 for count in list(counter.values())):\n            return 0\n        points = list(counter)\n        result = float('inf')\n        for i, (x, y) in enumerate(points):\n            for j in range(i + 1, len(points)):\n                x_, y_ = points[j]\n                if x != x_ and y != y_:\n                    if (x, y_) in counter and (x_, y) in counter:\n                        result = min(result, abs((x_ - x) * (y_ - y)))\n                        if not result:\n                            break\n        return 0 if result == float('inf') else result\n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n        points.sort()\n        d, ans = defaultdict(set), float('inf')\n        for r, c in points:\n            d[r].add(c)\n\n        A = list(d.keys())\n        for i, r1 in enumerate(A):\n            cols1 = d[r1]\n            for r2 in A[i+1:]:\n                cols2 = d[r2]\n                s = sorted(cols1 & cols2)\n                for c1, c2 in zip(s[:-1], s[1:]):\n                    area = ((r1 - r2) * (c1 - c2))\n                    if area < ans: ans = area\n        return ans if ans < float('inf') else 0\n\n# from collections import defaultdict\n# class Solution:\n#     def minAreaRect(self, points):\n#         d = defaultdict(set)\n#         rset, cset, N, ans = set(), set(), len(points), float('inf')\n#         for r, c in points:\n#             rset.add(r)\n#             cset.add(c)\n#         Nr, Nc = len(rset), len(cset)\n#         if Nr == N or Nc == N:\n#             return 0\n#         elif Nr < Nc:\n#             for r, c in points:\n#                 d[r].add(c)\n#         else:\n#             for r, c in points:\n#                 d[c].add(r)\n# \n#         A = sorted(d.keys())\n#         for i, r1 in enumerate(A):\n#             cols1 = d[r1]\n#             for r2 in A[i+1:]:\n#                 cols2 = d[r2]\n#                 s = sorted(cols1 & cols2)\n#                 for c1, c2 in zip(s[:-1], s[1:]):\n#                     area = abs((r1 - r2) * (c1 - c2))\n#                     ans = min(ans, area)\n#         return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        '''\n        Count by diagonal - approach 2 in solution\n        \n        https://leetcode.com/problems/minimum-area-rectangle/discuss/240341/Python-O(n2)-easy-to-understand.-Good-for-beginners\n        '''\n        \n        if not points:\n            return 0\n        \n        points_table = set()\n        for x, y in points:\n            points_table.add((x,y))\n        \n        min_area = float('inf')\n        for i in range(len(points) - 1):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                '''\n                check for diagonal only\n                the points coul;d be on same vertical line, we need to ignore those\n                '''\n                if x1 != x2 and y1 != y2:\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        min_area = min(min_area, abs(x1 - x2) * abs(y1 - y2))\n        \n        return 0 if min_area == float('inf') else min_area\n", "from collections import defaultdict\nimport math\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        d = dict()\n        for x, y in points:\n            if x not in d:\n                d[x] = set()\n            d[x].add(y)\n            \n        ans = float(\\\"inf\\\")\n        \n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 == x2 or y1 == y2:\n                    continue\n                if y2 in d[x1] and y1 in d[x2]:\n                    ans = min(ans, abs((x2 - x1)) * abs((y2 - y1)))\n        return 0 if ans == float(\\\"inf\\\") else ans\n                    \n                \n                    \n            \n        ", "MAX_VAL = 10 ** 9 + 7\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points_set = set()\n        for x,y in points:\n            points_set.add((x,y))\n        \n        n = len(points)\n        min_area = MAX_VAL\n        \n        for i in range(n-1):\n            for j in range(i +1, n):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                \n                if x1 != x2 and y1 != y2 and (x2, y1) in points_set and (x1, y2) in points_set:\n                    curr_area = abs((x1 - x2) * (y1 - y2))\n                    min_area = min(min_area, curr_area)\n        \n        return 0 if min_area == MAX_VAL else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        pointset = set([(x,y) for x,y in points])\n        minArea = math.inf\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 != x2 and y1!=y2 and (x1, y2) in pointset and (x2, y1) in pointset:\n                    area = abs((x1-x2)*(y1-y2))\n                    minArea = min(area, minArea)\n        \n        return minArea if minArea < math.inf else 0\n        \n        \n        # x     x    x\n        #    x       x\n        # x     x\n#         x          x\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        import math\n        from collections import defaultdict\n        row_m = defaultdict(set)\n        rows = set()\n        for x, y in points:\n            row_m[x].add(y)\n            rows.add(x)\n        \n        rows = sorted(rows)\n        l = len(rows)\n        sol = math.inf\n        # print(rows)\n        for i in range(l):\n            x1 = rows[i]\n            for j in range(i + 1, l):                \n                x2 = rows[j]\n                \n                # print(\\\"x1\\\", x1, \\\"x2\\\", x2)\n                row1 = row_m[x1]\n                row2 = row_m[x2]\n                \n                intersect = sorted(set(row1) & set(row2))\n                \n                if len(intersect) < 1:\n                    continue\n                \n                smallest = math.inf\n                for i, point in enumerate(intersect[1:], start=1):\n                    # print(\\\"point\\\", point, i, intersect[i - 1])\n                    smallest = min(\n                        smallest,\n                        point - intersect[i - 1]\n                    )\n                # print(\\\"smallest\\\", smallest, intersect)\n                sol = min(\n                    sol,\n                    smallest * (x2 - x1),\n                )\n                \n        if sol is math.inf:\n            return 0\n        return sol\n                \n            \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        if nx == n or ny == n:\n            return 0\n        res = 2**31\n        s = {(p[0], p[1]) for p in points}\n        \n        for i, p1 in enumerate(points):\n            for j, p2 in enumerate(points[i + 1:]):\n                if p1[0] != p2[0] and p1[1] != p2[1]:\n                    if (p1[0], p2[1]) in s and (p2[0], p1[1]) in s:\n                        res = min(res, abs(p1[1] - p2[1]) * abs(p1[0] - p2[0]))\n        res = res if res < 2**31 else 0\n        return res\n\n\n#         p = collections.defaultdict(list)\n#         if nx > ny:\n#             for x, y in points:\n#                 p[x].append(y)\n#         else:\n#             for x, y in points:\n#                 p[y].append(x)\n\n#         lastx = {}\n#         res = float('inf')\n#         for x in sorted(p):\n#             p[x].sort()\n#             for i in range(len(p[x])):\n#                 for j in range(i):\n#                     y1, y2 = p[x][j], p[x][i]\n#                     if (y1, y2) in lastx:\n#                         res = min(res, (x - lastx[y1, y2]) * abs(y2 - y1))\n#                     lastx[y1, y2] = x\n#         return res if res < float('inf') else 0\n                \n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        rows = defaultdict(set)\n        cols = defaultdict(set)\n        for i,point in enumerate(points):\n            rows[point[0]].add(tuple(point))\n            cols[point[1]].add(tuple(point))\n            \n        minArea = 99999999999\n        for point in points:\n            rowPoints = rows[point[0]]\n            colPoints = cols[point[1]]\n            for iP in rowPoints:\n                for jP in colPoints:\n                    # print(point,iP,jP, (jP[0],iP[1]))\n                    if iP[1] > point[1] and jP[0] > point[0] and (jP[0],iP[1]) in rows[jP[0]]:\n                        minArea = min(minArea,(iP[1]-point[1])*(jP[0]-point[0]))\n                        # print(minArea)\n                        \n        if minArea == 99999999999:\n            return 0\n        \n        return minArea", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pts = set([(x,y) for x, y in points])\n        min_area = float(\\\"inf\\\")\n        for i in range(len(points)-1):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 != x2 and y1 != y2 and (x1, y2) in pts and (x2, y1) in pts:\n                    min_area = min(abs(x1-x2)*abs(y1-y2), min_area)\n        return min_area if min_area != float(\\\"inf\\\") else 0\n                \n            \n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_set = set()\n        area = 0\n        for i1, j1 in points:\n            for i2, j2 in points:\n                if i1 != i2 and j1 != j2:\n                    if (i1, j2) in point_set and (i2, j1) in point_set:\n                        if area == 0:\n                            area = abs(i1 - i2) * abs(j1 - j2)\n                        else:\n                            area = min(area, abs(i1 - i2) * abs(j1 - j2))\n            point_set.add((i1, j1))    \n        return area\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        point_set = {(x, y) for x, y in points}\n        min_area = float(\\\"inf\\\")\n        \n        for i in range(n-1):\n            for j in range(i+1, n):\n                x0, y0 = points[i]\n                x1, y1 = points[j]\n                \n                if x0 != x1 and y0 != y1:\n                    if (x0, y1) in point_set and (x1, y0) in point_set:\n                        area = abs((x1-x0)*(y1-y0))\n                        min_area = min(area, min_area)\n                    \n        return min_area if min_area < float(\\\"inf\\\") else 0\n\n# time: O(n^2)\n# space: O(n)", "from collections import defaultdict\nfrom bisect import insort\nclass Solution:\n    def minAreaRect(self, points):\n        setr, setc = set(), set()\n        for r, c in points:\n            setr.add(r)\n            setc.add(c)\n        if len(points) in (len(setr), len(setc)): return 0\n        \n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            insort(columns[r], c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for j, y2 in enumerate(cols):\n                for i, y1 in enumerate(cols[:j]):\n                    if (y1, y2) in lastc:\n                        ans = min(ans, (r - lastc[(y1, y2)]) * (y2 - y1))\n                    lastc[(y1, y2)] = r\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        d = collections.defaultdict(set)\n        for i in range(len(points)):\n            x0, y0 = points[i]\n            for j in range(i+1, len(points)):\n                x1, y1 = points[j]\n                if x0 == x1:\n                    d[x0].add(tuple(sorted([y0,y1]))) # sorted ys since later we will use it to match\n        seen = set()\n        minA = float('inf')\n        for x0, lines0 in d.items(): \n            seen.add(x0)\n            for x1, lines1 in d.items():\n                if x1 not in seen:\n                    for l in lines0:\n                        if l in lines1: # matching ys, that's why we sort it earlier\n                            minA = min(minA, abs(x0-x1)*(l[1]-l[0]))\n        return minA if minA<float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        '''\n        Count by diagonal - approach 2 in solution\n        \n        https://leetcode.com/problems/minimum-area-rectangle/discuss/240341/Python-O(n2)-easy-to-understand.-Good-for-beginners\n        '''\n        \n        if not points:\n            return 0\n        \n        points_table = set()\n        for x, y in points:\n            points_table.add((x,y))\n        \n        min_area = float('inf')\n        for i in range(len(points) - 1):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                '''\n                check for diagonal only\n                '''\n                if x1 != x2 and y1 != y2:\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        min_area = min(min_area, abs(x1 - x2) * abs(y1 - y2))\n        \n        return 0 if min_area == float('inf') else min_area\n", "\\\"\\\"\\\"\n\u603b\u4f53\u601d\u8def\u662f\uff0cenum\u6240\u6709\u70b9pair\uff0c\u628a\u4ed6\u4eec\u5355\u505adiagnal\u4e0a\u7684\u4e24\u4e2a\u70b9\uff0c\u8fd9\u6837\u6211\u4eec\u53ea\u8981\u5728points\u4e2d\u627e\u6709\u6ca1\u6709\u53e6\u5916\u4e24\u4e2a\u70b9\u5c31\u597d\u4e86\u3002\n\u6ce8\u610f\u8fd9\u91cc\u6211\u4eec\u76f4\u63a5\u628a\u62ff\u51fa\u6765\u7684\u70b9\u5f53\u505a\u5de6\u4e0a\u548c\u53f3\u4e0b\uff0c\u4e3a\u4ec0\u4e48\u53ef\u4ee5\u8fd9\u4e48\u505a\uff1f\u56e0\u4e3a\u6211\u4eec\u8981\u7a77\u4e3e\u6240\u6709\u7684\u70b9pair\uff0c\u6240\u4ee5\u80af\u5b9a\u80fd\u627e\u5230\u4e00\u4e2a\u8fd9\u6837\u7684\u70b9pair\n\\\"\\\"\\\"\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        hashset = set()\n        # for lookup\n        for p in points:\n            hashset.add((p[0], p[1]))\n        \n        ans = sys.maxsize\n        # we enumerate all diagnal points\n        for i in range(len(points)-1):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 == x2 or y1 == y2: # we need diagnal points\n                    continue\n                if (x1, y2) in hashset and (x2, y1) in hashset:\n                    ans = min(ans, abs((x2 - x1) * (y1 - y2)))\n        return 0 if ans == sys.maxsize else ans            \n                \n                \n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        import math\n        from collections import defaultdict\n        row_m = defaultdict(set)\n        rows = set()\n        for x, y in points:\n            row_m[x].add(y)\n            rows.add(x)\n        \n        rows = sorted(rows)\n        l = len(rows)\n        sol = math.inf\n        print(rows)\n        for i in range(l):\n            x1 = rows[i]\n            for j in range(i + 1, l):                \n                x2 = rows[j]\n                \n                # print(\\\"x1\\\", x1, \\\"x2\\\", x2)\n                row1 = row_m[x1]\n                row2 = row_m[x2]\n                \n                intersect = sorted(set(row1) & set(row2))\n                \n                if len(intersect) < 1:\n                    continue\n                \n                smallest = math.inf\n                for i, point in enumerate(intersect[1:], start=1):\n                    # print(\\\"point\\\", point, i, intersect[i - 1])\n                    smallest = min(\n                        smallest,\n                        point - intersect[i - 1]\n                    )\n                # print(\\\"smallest\\\", smallest, intersect)\n                sol = min(\n                    sol,\n                    smallest * (x2 - x1),\n                )\n                \n        if sol is math.inf:\n            return 0\n        return sol\n                \n            \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        data = set()\n        res = 2 ** 31 -1\n        \n        for x1, y1 in points:\n            for x2, y2 in data:\n                if (x1, y2) in data and (x2, y1) in data:\n                    res = min(res, abs(x1 - x2) * abs(y1 - y2))\n            data.add((x1, y1))\n        return res if res < 2 ** 31 -1 else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        res = float('inf')\n        for point in points:                                                    \n            x, y = point[0], point[1]            \n            for _x, _y in seen:\n                if (x, _y) in seen and (_x, y) in seen:\n                    res = min(res, abs(x - _x) * abs(y - _y))\n            seen.add((x, y))\n            \n        if res == float('inf'):\n            return 0\n        return res\n                \n\n            \n            \n            \n        \n        \n            \n            \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        xAxis = {}\n        yAxis = {}\n        minArea = None\n        \n        for point in points:\n            if xAxis.get(point[0]):\n                xAxis[point[0]].append(point[1])\n            else:\n                xAxis[point[0]] = [point[1]]\n                \n            if yAxis.get(point[1]):\n                yAxis[point[1]].append(point[0])\n            else:\n                yAxis[point[1]] = [point[0]]\n                \n        # Treat every point as bottom left corner then try to find valid points\n        for point in points:\n            topLeft = xAxis[point[0]]\n            bottomRight = yAxis[point[1]]\n            \n            for tlPoint in topLeft:\n                if tlPoint == point[1]:\n                    continue\n                \n                possibleTopRight = yAxis[tlPoint]\n                topRight = [value for value in possibleTopRight if value in bottomRight and value != point[0]]\n\n                for trPoint in topRight:\n                    area = abs((trPoint - point[0]) * (tlPoint - point[1]))\n\n                    if area != 0 and (minArea == None or area < minArea):\n                        minArea = area      \n                        \n            xAxis[point[0]].remove(point[1])\n            yAxis[point[1]].remove(point[0])\n            \n        return 0 if minArea == None else minArea", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen = set()\n        res = float('inf')\n        for x1,y1 in points:\n            for x2,y2 in seen:\n                if (x1,y2) in seen and (x2,y1) in seen:\n                   \n                    area = abs(x1-x2)*abs(y2-y1)\n                    #print(area)\n                    if area>0 and area < res:\n                        res = area\n            seen.add((x1,y1))\n        #print(seen)\n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort()\n        xs = collections.defaultdict(list)\n        ys = collections.defaultdict(list)\n        for x, y in points:\n            xs[x].append(y)\n            ys[y].append(x)\n        result = math.inf\n        for x0, ylist in xs.items():\n            for i in range(len(ylist)):\n                y1 = ylist[i]\n                xlist1 = ys[y1]\n                m = len(xlist1)\n                ii = bisect.bisect(xlist1, x0)\n                if ii == m:\n                    continue\n                for j in range(i + 1, len(ylist)):\n                    y2 = ylist[j]\n                    xlist2 = ys[y2]\n                    n = len(xlist2)\n                    jj = bisect.bisect(xlist2, x0)\n                    if jj == n:\n                        continue\n                    i1 = ii\n                    while i1 < m and jj < n:\n                        if xlist1[i1] < xlist2[jj]:\n                            i1 += 1\n                        elif xlist1[i1] > xlist2[jj]:\n                            jj += 1\n                        else:\n                            result = min(result, (xlist1[i1] - x0) * (y2 - y1))\n                            break\n        return 0 if math.isinf(result) else  result", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        xys = set()\n        for point in points:\n            xys.add((point[0], point[1]))\n            \n        sq_min = float('inf')\n        for i, pointi in enumerate(points):\n            xi, yi = pointi[0], pointi[1]\n            for j in range(i+1, len(points)):\n                xj, yj = points[j][0], points[j][1]\n                if xi != xj and yi != yj and (xi, yj) in xys and (xj, yi) in xys:\n                    sq_min = min(sq_min, abs((xi-xj)*(yi-yj)))\n        \n        return sq_min if sq_min != float('inf') else 0", "class Solution(object):\n    def minAreaRect(self, points):\n        # idea, use lookup set to store the point that has seen before. for (x1,y1) in points, for (x2,y2) in lookup, check whether (x1,y2) and (x2, y1) in lookup. Time O(n^2), Space O(n).\n        res = float('inf') # initiate as inf\n        lookup = set()\n        for x1, y1 in points:\n            for x2, y2 in lookup:\n                if (x1, y2) in lookup and (x2, y1) in lookup: # if all in the lookup\n                    res = min(res, abs(x1-x2) * abs(y1-y2)) # check the min area\n            # add to lookup for the outer loop\n            lookup.add((x1, y1))\n        return res if res != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort()\n        point_set = set([tuple(point) for point in points])\n        min_area = math.inf\n        N = len(points)\n        for i in range(N):\n            start_point = points[i]\n            for j in range(i+1,N):\n                end_point = points[j]\n                if end_point[0] > start_point[0] and end_point[1] > start_point[1]:\n                    area = (end_point[0]-start_point[0])*(end_point[1]-start_point[1])\n                    if area < min_area and \\\\\n                       (start_point[0], end_point[1]) in point_set and \\\\\n                       (end_point[0], start_point[1]) in point_set:\n                        min_area = area\n                \n        return min_area if min_area != math.inf else 0\n            \n        ", "\\\"\\\"\\\"\nsolution 2: O(N^2)\n\u6211\u4eecchoose two diagnol points to iterate - then check if other two diagonal points in p_set\n\\\"\\\"\\\"\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort(key = lambda x: (x[0], x[1]))\n        p_set = set(map(tuple, points))     # \u53d8\u6210set, \u8fd9\u6837\u67e5\u627e\u66f4\u5feb\n\n        # \u6ce8\u610f\u6211\u4eecchoose two diagnol points to iterate\n        min_area = float(\\\"inf\\\")\n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 == x2 or y1 == y2:    # diagonal\u5143\u7d20\u5fc5\u987b\u4e0d\u80fd\u5e73\u884c\u4e8ex-axes or y-axes\n                    continue\n                x3, y3 = x2, y1\n                x4, y4 = x1, y2\n                if (x3, y3) in p_set and (x4, y4) in p_set:\n                    min_area = min(min_area, abs(x1 - x2) * abs(y1 - y2))\n\n        return 0 if min_area == float(\\\"inf\\\") else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # group points by x coord, for each pari of points in column,\n        # check for the smallest rectangle with this pair of points as the right edge\n        # Time Coplexity: O(N^2) N is the number of points\n        # columns = collections.defaultdict(list)\n        # for x, y in points:\n        #     columns[x].append(y)\n        # last_x = {}\n        # res = float('inf')\n        # for x in sorted(columns):\n        #     column = columns[x]\n        #     column.sort()\n        #     for j, y2 in enumerate(column):\n        #         for i in range(j):\n        #             y1 = column[i]\n        #             if (y1, y2) in last_x:\n        #                 res = min(res, (y2 - y1) * (x - last_x[(y1, y2)]))\n        #             last_x[(y1, y2)] = x\n        # return res if res < float('inf') else 0\n        \n        # assume each pair of points form the diagnal of the rectangle, check if other points\n        # exist in the set, if so, we have a candidate\n        # Time Coplexity: O(N^2)\n        s = set([(x, y) for x, y in points])\n        res = float('inf')\n        for i, point1 in enumerate(points):\n            for j in range(i):\n                point2 = points[j]\n                x1, y1 = point1\n                x2, y2 = point2\n                # two point can't form diagnal if they are on the same line\n                if x1 != x2 and y1 != y2 and (x1, y2) in s and (x2, y1) in s:\n                    res = min(res, abs(x1 - x2) * abs(y1 - y2))\n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pointsSet = set([(x, y) for x, y in points])\n        points = list(pointsSet)\n        numberOfPoints = len(points)\n        minimumArea = float('inf')\n        for i in range(numberOfPoints):\n            for j in range(i + 1, numberOfPoints):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 != x2 and y1 != y2 and (x1, y2) in pointsSet and (x2, y1) in pointsSet:\n                    minimumArea = min(minimumArea, abs(x2 - x1) * abs(y2 - y1))\n        return 0 if minimumArea == float('inf') else minimumArea ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        pointSet = set()\n        \n        for dx, dy in points:\n            pointSet.add((dx, dy))\n        minArea = float('inf')\n        for i in range(len(points)):\n            x1, y1 = points[i][0], points[i][1]\n\n            for j in range(i + 1, len(points)):\n                x2, y2 = points[j][0], points[j][1]\n                if x1 != x2 and y1 != y2:\n                    if (x2, y1) in  pointSet and (x1, y2) in pointSet:\n                        \n                        minArea = min(minArea,  abs(x2- x1) * abs(y2 - y1))\n\n        \n        return minArea if minArea < float('inf') else 0\n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        y_in_x = defaultdict(list)\n        x_in_vline = defaultdict(list)\n        ans = float(\\\"inf\\\")\n        for x,y in points:\n            if len(y_in_x[x]) >= 1 :\n                for pre_y in y_in_x[x]:\n                    a,b = max(pre_y,y) , min(pre_y,y)\n                    if len(x_in_vline[(a,b)]) >= 1:\n                        for pre_x in x_in_vline[(a,b)]:\n                            ans = min(ans,(a-b)*abs(x-pre_x))\n                    x_in_vline[(a,b)].append(x)\n            y_in_x[x].append(y)\n        \n        #print(y_in_x)\n        #print(x_in_vline)\n        return ans if ans < float(\\\"inf\\\") else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        res = float('inf')\n        pointSet = set([tuple(p) for p in points])\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 == x2 or y1 == y2:\n                    continue\n                if (x1,y2) in pointSet and (x2,y1) in pointSet:\n                    res = min(res, abs(x1-x2)*abs(y1-y2))\n        if res == float('inf'):\n            return 0\n        return res\n\n                        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # store y coordinates at each x\n        # for each y1 y2 pairs at each x from left to right\n        # find the last x that has y1 and y2, and calculate area\n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        if nx == n or ny == n:\n            return 0\n        lastx = {}\n        everyx = collections.defaultdict(list)\n        min_area = math.inf\n        for x, y in points:\n            everyx[x].append(y)\n        for x in sorted(everyx):\n            everyy = sorted(everyx[x])\n            for i, y1 in enumerate(everyy):\n                for j in range(i):\n                    y2 = everyy[j]\n                    if (y1, y2) in lastx:\n                        area = abs(y2-y1) * abs(x - lastx[y1, y2])\n                        min_area = min(area, min_area)\n                    lastx[y1,y2] = x\n        return min_area if min_area < math.inf else 0\n", "\\\"\\\"\\\"\nsolution 2: O(N^2)\n\u6211\u4eecchoose two diagnol points to iterate - then check if other two diagonal points in p_set\n\\\"\\\"\\\"\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        p_set = set(map(tuple, points))     # \u53d8\u6210set, \u8fd9\u6837\u67e5\u627e\u66f4\u5feb\n\n        # \u6ce8\u610f\u6211\u4eecchoose two diagnol points to iterate\n        min_area = float(\\\"inf\\\")\n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 == x2 or y1 == y2:    # diagonal\u5143\u7d20\u5fc5\u987b\u4e0d\u80fd\u5e73\u884c\u4e8ex-axes or y-axes\n                    continue\n                x3, y3 = x2, y1\n                x4, y4 = x1, y2\n                if (x3, y3) in p_set and (x4, y4) in p_set:\n                    min_area = min(min_area, abs(x1 - x2) * abs(y1 - y2))\n\n        return 0 if min_area == float(\\\"inf\\\") else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points or len(points) <= 3:\n            return 0\n        visited = set()\n        res = float('Inf')\n        for x1, y1 in points:\n            for x2, y2 in visited:\n                if (x1, y2) in visited and (x2, y1) in visited:\n                    area = abs(x1-x2)*abs(y1-y2)\n                    if area and area <= res:\n                        res = area\n            visited.add((x1, y1))\n        return res if res != float('Inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        max_area = float(\\\"inf\\\")\n        seen = set()\n        for x1, y1 in points:\n            for x2, y2 in points:\n                if (x1, y2) in seen and (x2, y1) in seen:\n                    area = abs(x2 - x1) * abs(y2 - y1)\n                    if area != 0:\n                        max_area = min(max_area, area)\n            seen.add((x1, y1))\n        return max_area if max_area < float(\\\"inf\\\") else 0 ", "from collections import defaultdict\n\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # (1,1), (1,3), (3, 1), (3,3)\n        # (1,1), (1,3), (3,1), (3,3) X (3,1), (3,3), (4,1), (4,3)\n        \n        point_set = set()\n        for x, y in points:\n            point_set.add((x, y))\n            \n        min_area = float('inf')\n        for i, (x1, y1) in enumerate(points):\n            for (x2, y2) in points[i+1:]:\n                if x1 == x2 or y1 == y2:\n                    continue\n\n                if (x1, y2) in point_set and (x2, y1) in point_set:\n                    min_area = min(min_area, abs((x1-x2) * (y1-y2)))\n            \n        return min_area if min_area != float('inf') else 0\n            \n        #x1, y1    x2, y1\n        #x1, y2    x2, y2\n        \n        #3, 3      \n        #3,4       4, 4\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        point_dict = {}\n        point_list = []\n        \n        for i in points:\n            point_dict[(i[0],i[1])] = 1\n            point_list.append((i[0],i[1]))\n            \n        print(point_dict)\n        print(point_list)\n        \n        ans = math.inf\n        for i in range(0,len(points)):\n            for j in range(i,len(points)):\n                ix, iy = point_list[i]\n                jx, jy = point_list[j]\n                if ix==jx or iy==jy:\n                    continue\n                if ((ix,jy) in point_dict) and ((jx,iy) in point_dict):\n                    ans = min(ans,abs(ix-jx)*abs(iy-jy))\n\n        if ans == math.inf:\n            return 0\n        return ans", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points_set = set(map(tuple, points))\n        result = float(\\\"inf\\\")\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if p2[0] != p1[0] and p2[1] != p1[1] and (p1[0], p2[1]) in points_set and (p2[0], p1[1]) in points_set:\n                    result = min(result, abs((p2[0] - p1[0]) * (p2[1] - p1[1])))\n        return result if result != float(\\\"inf\\\") else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        y_in_x = defaultdict(list)\n        x_in_vline = defaultdict(list)\n        ans = float(\\\"inf\\\")\n        for x,y in points:\n            if len(y_in_x[x]) >= 1 :\n                for pre_y in y_in_x[x]:\n                    a,b = max(pre_y,y) , min(pre_y,y)\n                    if len(x_in_vline[(a,b)]) >= 1:\n                        for pre_x in x_in_vline[(a,b)]:\n                            ans = min(ans,(a-b)*abs(x-pre_x))\n                    x_in_vline[(a,b)].append(x)\n            y_in_x[x].append(y)\n        \n\n        return ans if ans < float(\\\"inf\\\") else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        # hash set\n        points = { (x, y) for x, y in points}\n        min_area = float('inf')\n        \n        for x1, y1 in points:\n            for x2, y2 in points:\n                if x1 == x2 or y1 == y2:\n                    continue\n                x3, y3, x4, y4 = x1, y2, x2, y1\n                \n                theoretical_area = abs((x1 - x2) * (y1 - y2))\n                if theoretical_area > min_area:\n                    # Don't lookup\n                    continue\n                \n                if (x3, y3) in points and (x4, y4) in points:\n                    min_area = min(min_area, abs((x1 - x2) * (y1 - y2)))\n                        \n        if min_area == float('inf'):\n            return 0\n        return min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        coords = {}\n        \n        for x, y in points:\n            if x not in coords:\n                coords[x] = {}\n                 \n            coords[x][y] = True\n        \n        area = None\n        for x1 in coords:\n            for y1 in coords[x1]:\n                for y2 in coords[x1]:\n                    if y1 == y2:\n                        continue\n                           \n                    for x2 in coords:\n                        if x1 == x2:\n                            continue\n                            \n                        if y1 in coords[x2] and y2 in coords[x2]:\n                            current = abs(x1 - x2) * abs(y1 - y2)\n                            \n                            if area == None or current < area:\n                                area = current\n                                \n        if area == None:\n            return 0\n        \n        return area\n                        \n                    \n                        \n", "import math\nimport itertools\nimport collections\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        x_index = defaultdict(set)\n        y_index = defaultdict(set)\n        \n        for x,y in points:\n            x_index[x].add(y)\n            y_index[y].add(x)\n        \n        rects = []\n        \n        for p1,p2 in itertools.combinations(points, 2):\n            x1,y1 = p1\n            x2,y2 = p2\n            \n            if x1 == x2 or y1 == y2:\n                continue\n                \n            if y1 in x_index[x2] and x1 in y_index[y2]:\n                rects.append([p1,p2])\n        \n        if len(rects) == 0:\n            return 0\n        \n        ret = math.inf\n        for ((x1, y1), (x2, y2)) in rects:\n            area = abs((x1 - x2) * (y1 - y2))\n            if area < ret:\n                ret = area\n        \n        return ret\n            \n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n        \n        d, ans = defaultdict(set), float('inf')\n        for r, c in points:\n            d[r].add(c)\n\n        A = list(d.keys())\n        for i, r1 in enumerate(A):\n            cols1 = d[r1]\n            for r2 in A[i+1:]:\n                cols2 = d[r2]\n                s = sorted(cols1 & cols2)\n                for c1, c2 in zip(s[:-1], s[1:]):\n                    area = abs((r1 - r2) * (c1 - c2))\n                    ans = min(ans, area)\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        min_area = float(\\\"inf\\\")\n        points_table = set((x,y) for x, y in points)\n        \n        for (x1, y1) in points:\n            for (x2, y2) in points:\n                if x1 > x2 and y1 > y2:\n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                        area = abs(x2-x1) * abs(y2-y1)\n                        if area:\n                            min_area = min(min_area, area)\n        return min_area if min_area != float(\\\"inf\\\") else 0\n                \n\n        \n        \n        ", "\\\"\\\"\\\"\nsolution 2: O(N^2)\n\u6211\u4eecchoose two diagnol points to iterate - then check if other two diagonal elements in p_set\n\\\"\\\"\\\"\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # points.sort(key = lambda x: (x[0], x[1]))\n        p_set = set(map(tuple, points))\n\n        # \u6ce8\u610f\u6211\u4eecchoose two diagnol points to iterate\n        min_area = float(\\\"inf\\\")\n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 == x2 or y1 == y2:    # diagonal\u5143\u7d20\u5fc5\u987b\u4e0d\u80fd\u5e73\u884c\u4e8ex-axes or y-axes\n                    continue\n                x3, y3 = x2, y1\n                x4, y4 = x1, y2\n                if (x3, y3) in p_set and (x4, y4) in p_set:\n                    min_area = min(min_area, abs(x1 - x2) * abs(y1 - y2))\n\n        return 0 if min_area == float(\\\"inf\\\") else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # you need 4 points to make a rectangle\n        # first dedupe and add elements to a set\n        # for every x,y - iterate the remaining elements, idenitfy the new x,y is greater than current x,y\n        # also check if there is x1,y2 and x2,y1 is present in the set:\n        # then find the area, and process the minimum area\n        \n        pointset = set()\n        \n        for x, y in points:\n            pointset.add((x,y))\n        minarea = float('inf')    \n        \n        for x1, y1 in pointset:\n            for x2, y2 in pointset:\n                if x1>x2 and y1>y2 and (x1,y2) in pointset and (x2,y1) in pointset:\n                    area = abs(x1-x2) * abs(y1-y2)\n                    minarea = min(minarea, area)\n                    \n                    \n        if minarea == float('inf'):\n            return 0\n        else:\n            return minarea\n            \n                        \n                        \n            \n                        \n                        \n                    \n                    \n        \n        \n        \n        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        min_area = float(\\\"inf\\\")\n        point_set = {(x, y) for x, y in points}\n        \n        for i in range(n-1):\n            for j in range(i+1, n):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                \n                if x1 != x2 and y1 != y2 and (x1, y2) in point_set and (x2, y1) in point_set:\n                    min_area = min(min_area, abs((y2-y1)*(x2-x1)))\n                    \n        return min_area if min_area < float(\\\"inf\\\") else 0\n                ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pointsSet = set()\n        \n        for x, y in points:\n            pointsSet.add((x, y))\n        \n        minArea = float(\\\"inf\\\")\n        for idx, point in enumerate(points):\n            x1 = point[0]\n            y1 = point[1]\n            for x2, y2 in points[idx:]:\n                if x1 != x2 and y1 != y2:\n                    if (x1, y2) in pointsSet and (x2, y1) in pointsSet:\n                        curtArea = abs(x1 - x2) * abs(y1 - y2)\n                        minArea = min(curtArea, minArea)\n        if minArea == float(\\\"inf\\\"):\n            return 0\n        return minArea\n            ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        point_set = set([tuple(p) for p in points])\n        \n        min_area = float('inf')\n        \n        for idx, p1 in enumerate(points):\n            for idx2 in range(idx, len(points)):\n                p2 = points[idx2]\n                \n                if p1[0] != p2[0] and p1[1] != p2[1]:\n                    # search for other points\n                    p3 = (p1[0], p2[1])\n                    p4 = (p2[0], p1[1])\n                    \n                    if p3 in point_set and p4 in point_set:\n                        # calc area\n                        dx = abs(p1[0] - p2[0])\n                        dy = abs(p1[1] - p2[1])\n                        area = dx * dy\n                        if area < min_area:\n                            min_area = area\n        return min_area if min_area != float('inf') else 0\n                \n            \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        min_area = 999999999999999999\n        points = [(l[0], l[1]) for l in points]\n        s_points = set(points)\n        for p1 in points:\n            for p2 in points:\n                x1, y1 = p1\n                x2, y2 = p2\n                if x1 == x2 or y1 == y2:\n                    continue\n                area = abs(x2 - x1) * abs(y2 - y1)\n                if area < min_area:\n                    if (x1, y2) in s_points and (x2, y1) in s_points:\n                            min_area = area\n        if min_area is 999999999999999999:\n            return 0\n        return min_area\n", "# store column values for every x in a dictionary, find diagonal points\n# time - O(n*n), space - O(n)\n\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        columns = defaultdict(set)\n        minArea = float(\\\"inf\\\")\n        \n        for pt in points:\n            columns[pt[0]].add(pt[1])\n\n        for i,pt1 in enumerate(points):\n            for j,pt2 in enumerate(points[i:]):\n                if pt1[0]==pt2[0] or pt1[1]==pt2[1]:\n                    continue\n                \n                # if y point of diagonal in column[x of point1] and y of point1 in column[x point of diagonal]\n                if pt2[1] in columns[pt1[0]] and pt1[1] in columns[pt2[0]]:\n                    \n                    curArea = abs(pt2[1]-pt1[1])*abs(pt2[0]-pt1[0])\n                    minArea = min(minArea, curArea)\n                    \n               \n        \n        return minArea if minArea!=float(\\\"inf\\\") else 0 \n\n       \n            ", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        p_set = set(map(tuple, points))\n        \n        res = float('inf')\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n\n                if p1[0] != p2[0] and p1[1] != p2[1] and (p1[0], p2[1]) in p_set and (p2[0], p1[1]) in p_set:\n                    area = abs(p1[0]-p2[0]) * abs(p1[1]-p2[1])\n                    res = min(area, res)\n\n        return 0 if res == float('inf') else res\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        from collections import defaultdict\n        \n        x_set, y_set = set(), set()\n        for x, y in points:\n            x_set.add(x)\n            y_set.add(y)\n        \n        if len(x_set) == len(points) or len(y_set) == len(points):\n            return 0\n        \n        # using a hash map to record {x:[y]}\n        columns = defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        \n        visited = {}\n        res = float('inf')\n        \n        # sort hash map, for every 2 ys in the current column, calculate area\n        for col in sorted(columns):\n            num_y = columns[col]\n            num_y.sort()\n            \n            for i in range(len(num_y)):\n                for j in range(i):\n                    y1 = num_y[i]\n                    y2 = num_y[j]\n                    \n                    if (y1, y2) in visited:\n                        col_prev = visited[(y1, y2)]\n                        area = (y1 - y2) * (col - col_prev)\n                        res = min(res, area)\n                    \n                    visited[(y1, y2)] = col\n        \n        return res if res != float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pointset = {tuple(i) for i in points}\n        ans = float('inf')\n        area = lambda x,y: abs((x[0]-y[0])*(x[1]-y[1]))\n        \n        for A, B in combinations(points, 2):\n            if A[0] == B[0] or A[1] == B[1]: continue\n            if (A[1]-B[1])//(A[0]-B[0]) >= 0: continue\n\n            C = (A[0], B[1])\n            D = (B[0], A[1])\n\n            if C in pointset and D in pointset:\n                ans = min(ans, area(A, B))\n\n        return ans if ans != float('inf') else 0\n                        \n", "import sys\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        S = set([(x,y) for x,y in points])\n        mini = sys.maxsize\n        for i,p1 in enumerate(points):\n            for j in range(i):\n                p2 = points[j]\n                if (p1[0]!=p2[0]) and (p1[1]!=p2[1]) and (p1[0],p2[1]) in S and (p2[0], p1[1]) in S:\n                    mini = min(mini, abs((p1[1]-p2[1])*(p1[0]-p2[0])))\n        return mini if mini != sys.maxsize else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        ans = float('inf')\n\n        s = set(map(tuple, points))\n        for i, p2 in enumerate(points):\n            for j in range(i):\n                p1 = points[j]\n                if (p2[0] != p1[0]) and (p2[1] != p1[1]) and ((p1[0], p2[1]) in s) and ((p2[0], p1[1]) in s):\n                    ans = min(ans, (abs(p2[0] - p1[0]) * abs(p2[1] - p1[1])))\n        return ans if ans < float('inf') else 0\n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points_set = set([(point[0], point[1]) for point in points])\n        min_area = float(\\\"inf\\\")\n        for i, point1 in enumerate(points):\n            for j in range(i):\n                point2 = points[j]\n                if point1[0] != point2[0] and point1[1] != point2[1] and (point1[0], point2[1]) in points_set and (point2[0], point1[1]) in points_set:\n                    min_area = min(min_area, abs(point2[0]-point1[0])*abs(point2[1]-point1[1]))\n        return min_area if min_area < float('inf') else 0\n                    \n                \n            \n        ", "class Solution:\n    def minAreaRectangularHull(self, points: List[List[int]]) -> int:\n        area = 0\n        if points:\n            minx, miny = points[0]\n            maxx, maxy = points[0]\n            for x, y in points:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n            area = (maxx - minx)*(maxy - miny)\n        return area\n                \n\n    def minAreaRect(self, points):\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        ref = set(map(tuple, points))\n        minArea = float('inf')\n        curArea = 0\n        for i, p2 in enumerate(points):\n            for j in range(i):\n                p1 = points[j]\n\n                if (p1[0] != p2[0] and p1[1] != p2[1]) and (p1[0], p2[1]) in ref and (p2[0], p1[1]) in ref:\n                    curArea = abs(p2[0] - p1[0]) * abs(p2[1] - p1[1])\n                    minArea = min(minArea, curArea)\n        return minArea if minArea != float('inf') else 0\n\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0\n        \n        res = float('inf') # initiate as inf\n        lookup = set()\n        for x1, y1 in points:\n            for x2, y2 in lookup:\n                if (x1, y2) in lookup and (x2, y1) in lookup: # if all in the lookup\n                    res = min(res, abs(x1-x2) * abs(y1-y2)) # check the min area\n            # add to lookup for the outer loop\n            lookup.add((x1, y1))\n        return res if res != float('inf') else 0\n    \n    \n        ys_with_same_x = defaultdict(list)\n        for x, y in points:\n            ys_with_same_x[x].append(y)\n        \n        pair_of_ys_history = {}\n        res = float('inf')\n        for x, ys in sorted(ys_with_same_x.items()):\n            ys.sort()\n            for i, y1 in enumerate(ys):\n                for j in range(i):\n                    y2 = ys[j]\n                    if (y1, y2) in pair_of_ys_history:\n                        res = min(res, (x - pair_of_ys_history[(y1,y2)]) * (y1-y2) )\n                    pair_of_ys_history[(y1,y2)] = x\n        if res == float('inf'):\n            return 0\n        else:\n            return res\n", "class Solution(object):\n    def minAreaRect(self, points):\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        setr, setc = set(), set()\n        for r, c in points:\n            setr.add(r)\n            setc.add(c)\n        if len(points) in (len(setr), len(setc)): return 0\n        \n        \n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r in sorted(columns):\n            cols = sorted(columns[r])\n            for j, y2 in enumerate(cols):\n                for i, y1 in enumerate(cols[:j]):\n                    if (y1, y2) in lastc:\n                        ans = min(ans, (r - lastc[(y1, y2)]) * (y2 - y1))\n                    lastc[(y1, y2)] = r\n        return ans if ans < float('inf') else 0\n\nclass Solution:\n    def minAreaRect(self, points):\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i, p1 in enumerate(points[:j]):\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0\n", "\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        columns = defaultdict(set)\n        minArea = float(\\\"inf\\\")\n        \n        for pt in points:\n            columns[pt[0]].add(pt[1])\n\n        for i,pt1 in enumerate(points):\n            for j,pt2 in enumerate(points[i:]):\n                if pt1[0]==pt2[0] or pt1[1]==pt2[1]:\n                    continue\n        \n                if pt2[1] in columns[pt1[0]] and pt1[1] in columns[pt2[0]]:\n                    \n                    curArea = abs(pt2[1]-pt1[1])*abs(pt2[0]-pt1[0])\n                    minArea = min(minArea, curArea)\n                    \n               \n        \n        return minArea if minArea!=float(\\\"inf\\\") else 0 \n\n        # S = set(map(tuple, points))\n        # ans = float('inf')\n        # for j, p2 in enumerate(points):\n        #     for i in range(j):\n        #         p1 = points[i]\n        #         if (p1[0] != p2[0] and p1[1] != p2[1] and\n        #                 (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n        #             ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        # return ans if ans < float('inf') else 0\n        \n            ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        if nx == n or ny == n:\n            return 0\n\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for a, b in points:\n                p[a].append(b)\n        else:\n            for a, b in points:\n                p[a].append(b)\n\n        lastx = {}\n        res = float('inf')\n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i]\n                    if (y1, y2) in lastx:\n                        res = min(res, (x - lastx[y1, y2]) * abs(y2 - y1))\n                    lastx[y1, y2] = x\n        return res if res < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0\n", "'''\nWe can group them in group of X's, using dictionary\n\nSo we loop through all Y's in xs and keep track of the X of last seen pair of Y. We can hash Y's and keep dictionary of pair. Each time we find pair that already exist, we document their solution. \n\nComplexity:\nSo if there are N points and each column has K points. So there are N/K columns. We loop through each column, for each column we loop through k points twice. So N/K * K * K so = Nk\n\nO(Nk) but K could be N so O(N^2)\nO(N)\n'''\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        xD = collections.defaultdict(list)\n        for x, y in points:\n            xD[x].append(y)\n        \n        sol = math.inf\n        lastSeen = collections.defaultdict(int)\n        for x in sorted(xD.keys()):\n            for i1 in range(len(xD[x])):\n                for i2 in range(i1 + 1, len(xD[x])):\n                    \n                    pair1,pair2, diff = (xD[x][i1], xD[x][i2]), (xD[x][i2], xD[x][i1]),abs(xD[x][i1]-xD[x][i2])\n                    if pair1 in lastSeen or pair2 in lastSeen:\n                        sol = min(diff * (x-lastSeen[pair1]), sol)\n                    lastSeen[pair1], lastSeen[pair2] = x,x\n        return sol if sol != math.inf else 0\n                        \n                        \n                \n                        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        group_x_coords = collections.defaultdict(list)\n        group_y_coords = collections.defaultdict(set)\n        \n        # Form the grouping\n        for point in points:\n            group_x_coords[point[0]].append(point[1])\n            group_y_coords[point[1]].add(point[0])\n        \n        \n        # Pick element from x coords\n        # Then pick another element from it\n        # Do the intersection on the group_y_coords \n        # Find the maximum in the intersection\n        min_area = float('inf')\n        for key in group_x_coords.keys():\n            if len(group_x_coords[key]) < 2:\n                continue\n            for i in range(len(group_x_coords[key])):\n                for j in range(i + 1, len(group_x_coords[key])):\n                    y_val_1 = group_x_coords[key][i]\n                    y_val_2 = group_x_coords[key][j]\n                    # print(y_val)\n                    # Get the max rectangle\n                    common_x_coords = group_y_coords[y_val_1] & group_y_coords[y_val_2]\n                    if len(common_x_coords) > 1:\n                        y_diff = abs(y_val_1 - y_val_2)\n                        # Need to find number closest to current\n                        x_diff = min([abs(ele - key) for ele in common_x_coords if ele != key])\n                        area = x_diff * y_diff\n                        if area < min_area:\n                            min_area = area\n        if min_area == float('inf'):\n            return 0\n        return min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # you need 4 points to make a rectangle\n        # first dedupe and add elements to a set\n        # for every x,y - iterate the remaining elements, idenitfy the new x,y is greater than current x,y\n        # also check if there is x1,y2 and x2,y1 is present in the set:\n        # then find the area, and process the minimum area\n        \n        pointset = set()\n        minarea = float('inf')\n        \n        for x, y in points:\n            pointset.add((x,y))\n            \n        \n        for x1,y1 in pointset:\n            for x2, y2 in pointset:\n                if x1>x2 and y1>y2 and (x1,y2) in pointset and (x2,y1) in pointset:\n                    area = abs(x1-x2) * abs(y1-y2)\n                    minarea = min(area, minarea)\n            \n        if minarea == float('inf'):\n            return 0\n        else:\n            return minarea\n                        \n                        \n            \n                        \n                        \n                    \n                    \n        \n        \n        \n        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        visited = set()\n        res = float(\\\"inf\\\")\n        for x1, y1 in points:\n            for x2, y2 in visited:\n                if (x1, y2) in visited and (x2, y1) in visited:\n                    res = min(res, abs(x2 - x1) * abs(y2 - y1))\n                    \n            visited.add((x1, y1))\n        return res if res != float(\\\"inf\\\") else 0\n                ", "'''\n939. Minimum Area Rectangle.  Medium\n\nGiven a set of points in the xy-plane, \ndetermine the minimum area of a rectangle\nformed from these points, with sides parallel\nto the x and y axes.\n\nIf there isn't any rectangle, return 0.\n\nExample 1:\nInput: [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\n\nExample 2:\nInput: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n\nNote:\n1 <= points.length <= 500\n0 <= points[i][0] <= 40000\n0 <= points[i][1] <= 40000\nAll points are distinct.\n\nAccepted\n55,377\nSubmissions\n107,280\n\nNOTE: Clarify: rectangle formed by ALL these points (convex hull)\n            v. rectangle formed by ANY four distinct points\n'''\nclass Solution:\n    def minAreaRectangularHull(self, points: List[List[int]]) -> int:\n        area = 0\n        if points:\n            minx, miny = points[0]\n            maxx, maxy = points[0]\n            for x, y in points:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n            area = (maxx - minx)*(maxy - miny)\n        return area\n                \n\n    def minAreaRect(self, points):\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        res = 2**31\n        s = {(p[0], p[1]) for p in points}\n        \n        for i, p1 in enumerate(points):\n            for j, p2 in enumerate(points[i + 1:]):\n                if p1[0] != p2[0] and p1[1] != p2[1]:\n                    if (p1[0], p2[1]) in s and (p2[0], p1[1]) in s:\n                        res = min(res, abs(p1[1] - p2[1]) * abs(p1[0] - p2[0]))\n        res = res if res < 2**31 else 0\n        return res\n                \n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        counter = Counter(list(map(tuple, points)))\n        if any(count >= 4 for count in list(counter.values())):\n            return 0\n        points = list(counter)\n        result = float('inf')\n        for i, (x, y) in enumerate(points):\n            for j in range(i + 1, len(points)):\n                x_, y_ = points[j]\n                if x != x_ and y != y_:\n                    if (x, y_) in counter and (x_, y) in counter:\n                        result = min(result, abs(x - x_) * abs(y - y_))\n                        if not result:\n                            break\n        return 0 if result == float('inf') else result\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_set = set()\n        points.sort()\n        for point in points:\n            point_set.add((point[0], point[1]))\n        \n        def getArea(point1: List[int], point2: List[int]) -> int:\n            if point2[0] <= point1[0] or point2[1] <= point1[1]:\n                return 0\n            \n            if (point1[0], point2[1]) in point_set and (point2[0], point1[1]) in point_set:\n                return (point2[0]-point1[0])*(point2[1]-point1[1])\n            return 0\n        \n        min_area = math.inf\n        N = len(points)\n        for i in range(N):\n            start_point = points[i]\n            for j in range(i+1,N):\n                area = getArea(start_point, points[j])\n                if area > 0:\n                    min_area = min(min_area, area)\n                \n        return min_area if min_area != math.inf else 0\n            \n", "class Solution:\n    def minAreaRect(self, points):\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in pSet) and ((p2x, p1y) in pSet):\n                    ans = min(ans, abs((p1x - p2x) * (p1y - p2y)))\n        return ans if ans < float('inf') else 0\n    \nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in pSet and (p2x, p1y) in pSet:\n                    ans = area\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n        if Nr < Nc:\n            points = [[c, r] for (r, c) in points]\n            return self.minAreaRect(points)\n    \n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n    \n    \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        horizontal = collections.defaultdict(set)\n        vertical = collections.defaultdict(set)\n        for x,y in points:\n            horizontal[y].add(x)\n            vertical[x].add(y)\n        xlist = [x for x in vertical if len(vertical[x])>1]\n        ans = float('inf')\n        for i in range(len(xlist)-1):\n            x1 = xlist[i]\n            for j in range(i+1,len(xlist)):\n                x2 = xlist[j]\n                cand = []\n                for y in  vertical[x1]:\n                    if y in  vertical[x2]:\n                        cand.append(y)\n                if len(cand)>=2:\n                    cand.sort()\n                    for i in range(len(cand)-1):\n                        ans = min(ans, abs(x2-x1)*(cand[i+1]-cand[i]) )\n        return ans if ans < float('inf') else 0\n", "class Solution:\n#     def minAreaRect(self, points: List[List[int]]) -> int:\n#         columns = collections.defaultdict(list)\n#         for x, y in points:\n#             columns[x].append(y)\n#         lastx = {}\n#         ans = float('inf')\n        \n#         for x in sorted(columns):\n#             column = columns[x]\n#             column.sort()\n#             for index_j, y2 in enumerate(column):\n#                 for index_i in range(index_j):\n#                     y1 = column[index_i]\n#                     if (y1, y2) in lastx:\n#                         ans = min(ans, (x - lastx[(y1, y2)])* (y2 - y1))\n#                     lastx[(y1, y2)] = x\n#         return ans if ans < float('inf') else 0\n\n    def minAreaRect(self, points):\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for index_j, p2 in enumerate(points):\n            for index_i in range(index_j):\n                p1 = points[index_i]\n                if p1[0] != p2[0] and p1[1] != p2[1]:\n                    if (p1[0], p2[1]) in S and (p2[0], p1[1]) in S:\n                        ans = min(ans, abs((p1[0] - p2[0]) * (p1[1] - p2[1])))\n            \n        return ans if ans < float('inf') else 0", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        S = set(map(tuple, points))\n        area = float(\\\"inf\\\")\n        points.sort()\n        for i in range(len(points)):\n            for j in range(i):\n                p0, p1 = points[i], points[j]\n                if p0[0] == p1[0] or p0[1] == p1[1]: continue\n                if (p1[0], p0[1]) in S and (p0[0], p1[1]) in S:\n                    area = min(area, abs((p1[1]-p0[1]) * (p1[0]-p0[0])))\n        return area if area != float(\\\"inf\\\") else 0\n            ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        marea=float(\\\"inf\\\")\n        pd={}\n        for p in points:\n            pd[(p[0],p[1])]=True\n        for p1 in points:\n            for p2 in points:\n                if p1!=p2 and p2[0]>p1[0] and p2[1]>p1[1]:\n                    if (p1[0],p2[1]) in pd and (p2[0],p1[1]) in pd:\n                        marea=min(marea, (p2[0]-p1[0])*(p2[1]-p1[1]) )\n        return marea if marea!=float(\\\"inf\\\") else 0\n        ", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        res = float('inf')\n        past_points = set()\n        for x1, y1 in points:\n            for x2, y2 in past_points:\n                if x1 != x2 and y1 != y2:\n                    if (x1, y2) in past_points and (x2, y1) in past_points:\n                        area = abs(x1 - x2) * abs(y1 - y2)\n                        res = min(res, area)\n            past_points.add((x1, y1))\n        # for cur_point in points:\n        #     for dia_point in points:\n        #         if cur_point[0] != dia_point[0] and cur_point[1] != dia_point[1]:\n        #             if (cur_point[0], dia_point[1]) in past_points \\\\\n        #             and (dia_point[0], cur_point[1]) in past_points:\n        #                 new_area = abs(cur_point[0]-dia_point[0]) * abs(cur_point[1]-dia_point[1])\n        #                 print(new_area)\n        #                 res = min(res, new_area)\n        #     past_points.add((cur_point[0], cur_point[1]))\n        return res if res!=float('inf') else 0\n\n\n", "from itertools import combinations\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points_s = set(map(tuple,points))\n        \n        ans = float(\\\"inf\\\")\n        for p, q in combinations(points, 2):\n            if p[0] != q[0] and p[1] != q[1]:\n                if (p[0], q[1]) in points_s and (q[0], p[1]) in points_s:\n                    ans = min(ans, abs(p[0] - q[0]) * abs(p[1] - q[1]))\n                    \n        return ans if ans < float(\\\"inf\\\") else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_set = set()\n        x_map, y_map = defaultdict(set), defaultdict(set)\n        for x, y in points:\n            point_set.add((x, y))\n            x_map[x].add((x, y))\n            y_map[y].add((x, y))\n        \n        min_rec = math.inf\n        def dfs(points:list):\n            nonlocal x_map, y_map, point_set, min_rec\n            if len(points) not in (1, 2, 3):\n                return \n            if len(points) == 1:\n                x, y = points[0]\n                for point in x_map[x]:\n                    if point[1] < y:\n                        points.append(point)\n                        dfs(points)\n                        points.pop()\n            elif len(points) == 2:\n                x, y = points[0]\n                for point in y_map[y]:\n                    if point[0] > x:\n                        points.append(point)\n                        dfs(points)\n                        points.pop()\n            else:\n                x2, y1 = points[2][0], points[1][1]\n                if (x2, y1) in point_set:\n                    x1, y2 = points[1][0], points[2][1]\n                    min_rec = min(min_rec, (x2 - x1) * (y2 - y1))\n        for point in point_set:\n            dfs([point])\n        if min_rec != math.inf:\n            return min_rec\n        else:\n            return 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        # \u9488\u5bf9\u6bcf\u4e00\u7ec4\u70b9, check \u6709\u6ca1\u6709\u53e6\u5916\u4e24\u4e2a\u70b9\u53ef\u4ee5\u7ec4\u6210\u4e00\u4e2a\u957f\u65b9\u5f62\n        # (1, 2) \u548c (4, 3), \u68c0\u67e5\u6709\u6ca1\u6709 (1, 3) \u548c (4, 2)\n        \n        points_set = set(map(tuple, points))\n        min_area = float('inf')\n        \n        for idx, p2 in enumerate(points):\n            for i in range(idx):\n                p1 = points[i]\n                if p1[0] != p2[0] and p1[1] != p2[1] and (p1[0], p2[1]) in points_set and (p2[0], p1[1]) in points_set:\n                    area = abs( (p2[0]-p1[0])*(p2[1] - p1[1]) )\n                    min_area = min(min_area, area)\n        \n        return min_area if min_area < float('inf') else 0\n        \n        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        seen, bases, baseX, res = collections.defaultdict(dict), [], -1, float(\\\"inf\\\")\n        for x, y in sorted(points):\n            if x != baseX:\n                baseX, bases = x, []\n            for base in bases:\n                if y in seen[base]:\n                    res = min(res, (x - seen[base][y]) * (y - base))\n                seen[base][y] = x\n            bases.append(y)\n        return res if res < float(\\\"inf\\\") else 0", "from collections import defaultdict\n\nclass Solution:\n    \n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        A rectangle consists of four points:\n        A ---- B\n        |      |\n        D ---- C\n        \n        Point B = [Cx, Ay]\n        Point D = [Ax, Cy]\n\n        \\\"\\\"\\\"\n\n        point_set = set(map(tuple, points))\n        minArea = float('inf')\n\n        for i, point_a in enumerate(points):\n            for point_c in points[i:]:\n\n                # Make sure A and C have different x and y position\n                # otherwise the rectangle will be of 0 width/height.\n                if point_a[0] == point_c[0] or point_a[1] == point_c[1]:\n                    continue\n\n                point_b = (point_c[0], point_a[1])\n                point_d = (point_a[0], point_c[1])\n                \n                if point_b in point_set and point_d in point_set:\n                    minArea = min(minArea,\n                                  abs(point_a[0] - point_b[0])*abs(point_a[1] - point_d[1]))\n\n        if minArea == float('inf'):\n            return 0\n        else:\n            return minArea", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pointset = {tuple(i) for i in points}\n        ans = float('inf')\n        area = lambda x,y: abs((x[0]-y[0])*(x[1]-y[1]))\n        \n        for A, B in combinations(points, 2):\n            if A[0] == B[0] or A[1] == B[1]: continue\n            if (A[1]-B[1])//(A[0]-B[0]) >= 0: continue\n\n            if (A[0], B[1]) in pointset and (B[0], A[1]) in pointset:\n                ans = min(ans, area(A, B))\n\n        return ans if ans != float('inf') else 0\n                        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_set = {(x, y) for x, y in points}\n        n = len(points)\n        result = float('inf')\n        for i in range(1, n):\n            for j in range(i):\n                p1 = points[i]\n                p2 = points[j]\n                if p1[0] != p2[0] and p1[1] != p2[1] \\\\\n                    and (p1[0], p2[1]) in point_set \\\\\n                    and (p2[0], p1[1]) in point_set:\n                    result = min( result, abs((p2[0]-p1[0]) * (p2[1]-p1[1])) )\n        \n        return result if result != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n\n        points = sorted(points)\n\n        points_set = set([tuple(p) for p in points])\n\n        min_area = 999999999999\n\n        has_rectangle = False\n\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                x1 = points[i][0]\n                y1 = points[i][1]\n\n                x2 = points[j][0]\n                y2 = points[j][1]\n\n                # check (x1, y2) and (x2, y1)\n\n                if x1==x2:\n                    continue\n\n                if y1==y2:\n                    continue\n\n                if (x1, y2) not in points_set:\n                    continue\n\n                if (x2, y1) not in points_set:\n                    continue\n\n                area = abs((x1-x2)*(y1-y2))\n\n                has_rectangle = True\n                    \n                if area<min_area:\n                    min_area = area\n                    \n        if not has_rectangle:\n            return 0\n        else:\n            return min_area                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        '''\n        Exactly two row values, exactly two column values such that\n        we minimize (row2 - row1) * (col2 - col1)\n        '''\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0\n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        \n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0\n    \n    \n        \n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        \n#         columns = collections.defaultdict(list)\n#         for x, y in points:\n#             columns[x].append(y)\n#         lastx = {}\n#         ans = float('inf')\n\n#         for x in sorted(columns):\n#             column = columns[x]\n#             column.sort()\n#             for j, y2 in enumerate(column):\n#                 for i in range(j):\n#                     y1 = column[i]\n#                     if (y1, y2) in lastx:\n#                         ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n#                     lastx[y1, y2] = x\n#         return ans if ans < float('inf') else 0\n    \n    \n        \n        S = set(map(tuple, points))\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0        \n\n        \n        \n        \n#         min_area = float('inf')\n#         same_y = {}\n#         h_segments = {}\n                \n#         for i in range(len(points)  - 1):\n#             for j in range(i + 1 , len(points)):\n#                 if points[i][1] == points[j][1]:\n#                     key = (min(points[i][0] , points[j][0]) , max(points[i][0] , points[j][0]) )\n#                     if key not in h_segments:\n#                         h_segments[key] = []\n#                     h_segments[key].append(points[i][1])\n                                    \n#         for key in h_segments:\n#             width = key[1] - key[0]\n            \n#             val = h_segments[key]\n#             if len(val) > 1:\n#                 for i in range(len(val) - 1):\n#                     for j in range(i, len(val)):\n#                         height = abs(val[i] - val[j])\n#                         if  width > 0 and  height > 0:\n#                             min_area = min(min_area , width * height)\n        \n#         if min_area == float('inf'):\n#             return 0\n                \n#         return min_area\n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        \n        ss=set([tuple(ele) for ele in points])\n        ans=float('inf')\n        \n        for i in range(len(points)-1):\n            for j in range(i+1,len(points)):\n                x1,y1=points[i]\n                x2,y2=points[j]\n                if (x2,y1) in ss and (x1,y2) in ss and x1!=x2 and y1!=y2:\n                    ans=min(ans,abs((x1-x2)*(y1-y2)))\n        return (0 if ans==float('inf') else ans)\n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_set = set(map(tuple, points)) \n        result = float(\\\"inf\\\")\n        for k, p2 in enumerate(points):\n            for i in range(k):\n                p1 = points[i]\n                if p1[0] != p2[0] and p1[1] != p2[1] and (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set:\n                    area = abs(p1[0] - p2[0]) * abs(p1[1] - p2[1])\n                    result = min(result, area)\n                    \n        return result if result != float(\\\"inf\\\") else 0\n        \n        ", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n        if Nr > Nc:\n            points = [[c, r] for (r, c) in points]\n            return self.minAreaRect(points)\n\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n\n# from collections import defaultdict\n# class Solution:\n#     def minAreaRect(self, points):\n#         d = defaultdict(set)\n#         rset, cset, N, ans = set(), set(), len(points), float('inf')\n#         for r, c in points:\n#             rset.add(r)\n#             cset.add(c)\n#         Nr, Nc = len(rset), len(cset)\n#         if Nr == N or Nc == N:\n#             return 0\n#         elif Nr < Nc:\n#             for r, c in points:\n#                 d[r].add(c)\n#         else:\n#             for r, c in points:\n#                 d[c].add(r)\n# \n#         A = sorted(d.keys())\n#         for i, r1 in enumerate(A):\n#             cols1 = d[r1]\n#             for r2 in A[i+1:]:\n#                 cols2 = d[r2]\n#                 s = sorted(cols1 & cols2)\n#                 for c1, c2 in zip(s[:-1], s[1:]):\n#                     area = abs((r1 - r2) * (c1 - c2))\n#                     ans = min(ans, area)\n#         return ans if ans < float('inf') else 0\n", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\n\nclass Solution:\n\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        s = set()\n        for p in points:\n            s.add((p[0], p[1]))\n\n        N = len(points)\n        ans = 0\n        for i in range(N):\n            p1 = points[i]\n            for j in range(i + 1, N):\n                p2 = points[j]\n                if p1[0] == p2[0] or p1[1] == p2[1]:\n                    continue\n                newA = abs(p1[0] - p2[0]) * abs(p1[1] - p2[1])\n                if (ans == 0 or\n                        newA < ans) and (p1[0], p2[1]) in s and (p2[0],\n                                                                 p1[1]) in s:\n                    ans = newA\n        return ans\n\n\\\"\\\"\\\"\nl = [[1, 1], [1, 2]]\nS = Solution()\nl = [[1, 1], [1, 3], [3, 1], [3, 3], [2, 2]]\nl = [[1, 1], [1, 3], [3, 1], [3, 3], [4, 1], [4, 3]]\nprint(S.minAreaRect(l))\n\\\"\\\"\\\"", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort()\n        min_area = 40000**2+1\n        m = len(points)\n        # set_points = set()\n        # for i in points:\n        #     set_points.add(i)\n        # print(set_points)\n        points_table = set()\n\n        for x, y in points:\n            points_table.add((x,y))\n        for i in range(m):\n            for j in range(i+1,m):\n                a = points[i]\n                b = points[j]\n                if a[0]!=b[0] and a[1]!=b[1]:\n                    if ((a[0],b[1]) in points_table) and ((b[0],a[1]) in points_table):\n                        z=abs((b[0]-a[0])*(b[1]-a[1]))\n                        min_area = min(min_area, z)\n        if min_area == 40000**2+1:\n            min_area = 0\n        return min_area", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        S = set(map(tuple, points))\n        area = float(\\\"inf\\\")\n        for i in range(len(points)):\n            for j in range(i):\n                p0, p1 = points[i], points[j]\n                if p0[0] == p1[0] or p0[1] == p1[1]: continue\n                if (p1[0], p0[1]) in S and (p0[0], p1[1]) in S:\n                    area = min(area, abs((p1[1]-p0[1]) * (p1[0]-p0[0])))\n        return area if area != float(\\\"inf\\\") else 0\n            ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points:\n            return 0\n        \n        pointsLookup = set(map(tuple, points))\n        minArea = math.inf\n\n        for i in range(0, len(points)-1):\n            p1 = points[i]\n            for j in range(i+1, len(points)):\n                p2 = points[j]\n                # Find two potential diagonal points and see if other points of the rectangle\n                # are present. If so, we've a rectangle.\n                if p1[0] != p2[0] and p1[1] != p2[1] \\\\\n                    and (p1[0], p2[1]) in pointsLookup and (p2[0], p1[1]) in pointsLookup:\n                    area = abs(p1[0] - p2[0]) * abs(p1[1] - p2[1])\n                    minArea = min(minArea, area)\n\n        return minArea if minArea < math.inf else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n  \n        S = set(map(tuple, points))\n        ans = float('inf')\n        \n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        \n        return ans if ans < float('inf') else 0\n            \n        \n        \n", "from collections import defaultdict\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # Sort by Column\n        # Time  complexity: O(N^2)\n        # Space complexity: O(N)\n        # columns = defaultdict(list)\n        # for x, y in points:\n        #     columns[x].append(y)\n        # lastx, ans = {}, float(\\\"inf\\\")\n\n        # for x in sorted(columns):\n        #     column = columns[x]\n        #     column.sort()\n        #     for j, y2 in enumerate(column):\n        #         for i in range(j):\n        #             y1 = column[i]\n        #             if (y1, y2) in lastx:\n        #                 ans = min(ans, (x - lastx[y1, y2]) * (y2 - y1))\n        #             lastx[y1, y2] = x\n\n        # return ans if ans < float(\\\"inf\\\") else 0\n\n\n        # Count by Diagonal\n        # For each pair of points in the array, consider them to be the long diagonal of a potential rectangle. We can check if all 4 points are there using a Set.\n        # Time  complexity: O(N^2)\n        # Space complexity: O(N)\n        S = set(map(tuple, points))\n        ans = float(\\\"inf\\\")\n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if p1[0] != p2[0] and p1[1] != p2[1] and \\\\\n                    (p1[0], p2[1]) in S and (p2[0], p1[1]) in S:\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float(\\\"inf\\\") else 0\n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        d = set(map(tuple, points))\n        \n        min_square = sys.maxsize\n        for i, x in enumerate(points):\n            for j in range(i, len(points)):\n                y = points[j]            \n                if x[0] != y[0] and x[1] != y[1] and (x[0], y[1]) in d and (y[0], x[1]) in d:\n                    min_square = min(min_square, abs(x[0]-y[0])*abs(x[1]-y[1]))\n            \n        return min_square if min_square != sys.maxsize else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        S = set(map(tuple, points))\n        minArea = float('inf')\n        \n        for i, p1 in enumerate(points):\n            for j in range(i):\n                p2 = points[j]\n                \n                if p1[0] == p2[0] or p1[1] == p2[1]:\n                    continue\n                \n                if (p1[0], p2[1]) in S and \\\\\n                   (p2[0], p1[1]) in S:\n                    area = abs(p2[0] - p1[0]) * abs(p2[1] - p1[1])\n                    minArea = min(minArea, area)\n        \n        if minArea == float('inf'):\n            return 0\n        return minArea", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        all_points = set([(point[0],point[1]) for point in points])\n        min_area = float('inf')\n        for idx,point1 in enumerate(points):\n            for idx,point2 in enumerate(points[idx+1:],start=idx):\n                if point1[0] != point2[0] and point1[1] != point2[1] and (point1[0],point2[1]) in all_points and (point2[0],point1[1]) in all_points:\n                    min_area = min(min_area, abs(point1[0]-point2[0])*abs(point1[1]-point2[1]))\n        return min_area if min_area != float('inf') else 0", "import itertools\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points:\n            return 0\n        ybucket = defaultdict(list)\n        for x, y in points:\n            ybucket[y].append(x)\n\n        for k, v in ybucket.items():\n            if len(v) >= 2:\n                ybucket[k] = sorted(v)\n\n        ys = [k for k in ybucket.keys() if len(ybucket[k]) >= 2]\n        ans = 2**31-1\n        for y1, y2 in itertools.combinations(ys, 2):\n            row1 = set(ybucket[y1])\n            row2 = ybucket[y2]\n            for idx, x in enumerate(row2):\n                if x in row1:\n                    print(x)\n                    xlast = x\n                    idx_last = idx\n                    break\n            else:\n                continue\n     \n            dy = abs(y2-y1)\n            for x in row2[idx_last+1:]:\n                if x in row1:\n                    ans = min(ans, abs(x-xlast)*dy)\n                    xlast = x\n\n        return ans if ans < 2**31-1 else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        ans = float('inf')\n            \n        s = {tuple(point) for point in points}\n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                p1, p2 = points[i], points[j]\n                if p1[0] == p2[0] or p1[1] == p2[1]:\n                    continue\n                if (p1[0], p2[1]) in s and (p2[0], p1[1]) in s:\n                    ans = min(ans, abs(p1[0] - p2[0]) * abs(p1[1] - p2[1]))\n        \n        return ans if ans != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        hash_set = set(map(tuple, points))\n        min_ = float('inf')\n\n            \n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                x1,y1 = p2[0],p2[1]\n                x2,y2 = p1[0],p1[1]\n                if x1 != x2 and y1 != y2:\n                    if (x2, y1) in hash_set and (x1,y2) in hash_set:\n                        min_ = min(min_, abs(x1-x2)*abs(y1-y2))\n        \n        if min_ == float('inf'):\n            return 0\n        \n        return min_", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points or len(points) < 4:\n            return 0\n        \n        pointsSet = set()\n        \n        minArea = float(\\\"inf\\\")\n        for x1, y1 in points:\n            for x2, y2 in pointsSet:\n                if (x1,y2) in pointsSet and (x2, y1) in pointsSet:\n                    minArea = min(minArea, self.getArea(x1,y1,x2,y2))\n            pointsSet.add((x1, y1))\n        \n        return 0 if minArea == float(\\\"inf\\\") else minArea\n                    \n                \n    \n    def getArea(self, x1, y1, x2, y2) -> int:\n        x = abs(x2 - x1)\n        y = abs(y2 - y1)\n        return x * y", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        S = set(map(tuple,points))\n        minarea = float('inf')\n        for j,p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if p1[0] != p2[0] and p1[1] != p2[1] and (p1[0],p2[1]) in S and (p2[0],p1[1]) in S:\n                    minarea = min(minarea,abs(p2[0]-p1[0]) * abs(p1[1]-p2[1]))\n                \n                \n        return minarea if minarea < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        res = float('inf')\n        dic = collections.defaultdict(set)\n        for p in points:\n            dic[p[0]].add(p[1])\n        for i in range(len(points)):\n            for j in range(len(points)):\n                p1,p2=points[i],points[j]\n                if p1[0]>=p2[0] or p1[1]>=p2[1]:\n                    continue\n                if p1[1] in dic[p2[0]] and p2[1] in dic[p1[0]]:\n                    res = min(res,(p2[0]-p1[0])*(p2[1]-p1[1]))\n        return res if res!=float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        area = float('inf')\n        \n        points_set = {tuple(p) for p in points}\n        \n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                (x1, y1) = points[i]\n                (x2, y2) = points[j]\n                \n                if x1 != x2 and y1!=y2:\n                    if (x2, y1) in points_set and (x1, y2) in points_set:\n                        area = min(abs(y2-y1) * abs(x2-x1), area)\n        \n        return area if area  < float('inf') else 0\n                        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        _set = {(x, y) for x, y in points}\n        res = math.inf\n        for p1, p2 in combinations(points, 2):\n            arr = [p1, p2]\n            arr.sort()\n            (x1, y1), (x2, y2) = arr\n            l, w = y2 - y1, x2 - x1\n            if l > 0 and w > 0 and (x1, y1 + l) in _set and (x1 + w, y1) in _set:\n                res = min(res, l * w)\n    \n        return 0 if math.isinf(res) else res", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pointSet = set()\n        for x, y in points:\n            pointSet.add((x, y))\n        length = len(points)\n        minArea = float('inf')\n        for i in range(length):\n            for j in range(i, length):\n                p1 = points[i]\n                p2 = points[j]\n                if p1[0] != p2[0] and p1[1] != p2[1]:\n                    if (p1[0], p2[1]) in pointSet and (p2[0], p1[1]) in pointSet:\n                        minArea = min(minArea, abs(p1[0] - p2[0]) * abs(p1[1] - p2[1]))\n        if minArea == float('inf'):\n            return 0\n        return minArea", "class Solution:\n\\tdef minAreaRect(self, points: List[List[int]]) -> int:\n\\t\\tpoints.sort(key = lambda x:(x[0], x[1]))\n\\t\\tver = collections.defaultdict(list)\n\\t\\thor = collections.defaultdict(list)\n\\t\\tseen = set()\n\\t\\tres = float(\\\"inf\\\")\n\\t\\tfor x, y in points:            \n\\t\\t\\tif len(ver[x]) > 0 and len(hor[y]) > 0:\n\\t\\t\\t\\tfor i in ver[x][::-1]:\n\\t\\t\\t\\t\\tfor j in hor[y][::-1]:\n\\t\\t\\t\\t\\t\\tif (j, i) in seen:\n\\t\\t\\t\\t\\t\\t\\tres = min(res, (x - j) * (y - i))\n\\t\\t\\tseen.add((x, y))\n\\t\\t\\tver[x].append(y)\n\\t\\t\\thor[y].append(x)\n\\t\\tif res != float(\\\"inf\\\"):\n\\t\\t\\treturn res\n\\t\\telse:\n\\t\\t\\treturn 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        point_set = set(map(tuple, points)) \n        result = float(\\\"inf\\\")\n        for k, p2 in enumerate(points):\n            for i in range(k+1, len(points)):\n                p1 = points[i]\n                if p1[0] != p2[0] and p1[1] != p2[1] and (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set:\n                    area = abs(p1[0] - p2[0]) * abs(p1[1] - p2[1])\n                    result = min(result, area)\n                    \n        return result if result != float(\\\"inf\\\") else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort()\n        n = len(points)\n        result = math.inf\n        seen = set()\n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                if x2 == x1: continue\n                a = (x1, y2, x2, y1)\n                if a in seen:\n                    result = min(result, (x2 - x1) * abs(y2 - y1))\n                seen.add((x1, y1, x2, y2))\n        return 0 if math.isinf(result) else result", "from collections import defaultdict\n\nclass Solution:\n    \n    def computeArea(self, point_a, point_b, point_c, point_d):\n        width = abs(point_a[0] - point_b[0])\n        height = abs(point_a[1] - point_d[1])\n        return width*height\n    \n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        A rectangle consists of four points:\n        A ---- B\n        |      |\n        D ---- C\n        \n        Point B = [Cx, Ay]\n        Point D = [Ax, Cy]\n\n        \\\"\\\"\\\"\n\n        point_set = set(map(tuple, points))\n            \n        minArea = None\n        for i, point_a in enumerate(points):\n            for point_c in points[i:]:\n\n                # Make sure A and C have different x and y position\n                # otherwise the rectangle will be of 0 width/height.\n                if point_a[0] == point_c[0] or point_a[1] == point_c[1]:\n                    continue\n\n                point_b = (point_c[0], point_a[1])\n                point_d = (point_a[0], point_c[1])\n                \n                if point_b in point_set and point_d in point_set:\n                    area = self.computeArea(point_a, point_b, point_c, point_d)\n                    if area > 0 and minArea is None or area < minArea:\n                        minArea = area\n\n        if minArea is None:\n            return 0\n        else:\n            return minArea", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        ans = float('inf')\n        seen = set(map(tuple, points))\n        points.sort()\n        for i in range(len(points)):\n            for j in range(i):\n                x1, y1 = points[i][0], points[i][1]\n                x2, y2 = points[j][0], points[j][1]\n                                \n                if x1 != x2 and y1!= y2 and (x1, y2) in seen and (x2, y1) in seen:\n                    ans = min(ans, (x1-x2)*abs(y2-y1))\n\n        return ans if ans != float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        s = set(map(tuple, points))\n        res = float('inf')\n        for i in range(len(points)-1):\n            for j in range(i+1,len(points)):\n                x1 = points[i][0]\n                y1 = points[i][1]\n                x2 = points[j][0]\n                y2 = points[j][1]\n                if x1!=x2 and y1!=y2 and (x1,y2) in s and (x2,y1) in s:\n                    res = min (res,abs((y2-y1)*(x2-x1)))\n        return res if res!=float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        s = set()\n        for point in points:\n            x = point[0]\n            y = point[1]\n            s.add((x,y))\n        res = float('inf')\n        for i in range(len(points)-1):\n            for j in range(i+1,len(points)):\n                x1 = points[i][0]\n                y1 = points[i][1]\n                x2 = points[j][0]\n                y2 = points[j][1]\n                if x1==x2 or y1==y2:\n                    continue\n                if (x1,y2) in s and (x2,y1) in s:\n                    res = min (res,abs((y2-y1)*(x2-x1)))\n        return res if res!=float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        S = set(map(tuple, points))\n        print(S)\n        ans = float('inf')\n        for j, p2 in enumerate(points):\n            print((j,p2))\n            for i in range(j):\n                p1 = points[i]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        p_set = set([(x, y) for x, y in points])\n        \n        res = float('inf')\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                p1 = points[i]\n                p2 = points[j]\n                if p1[0] == p2[0] or p1[1] == p2[1]:\n                    continue\n                up = (p1[0], p2[1])\n                left = (p2[0], p1[1])\n                if up in p_set and left in p_set:\n                    area = abs(p1[0]-p2[0])*abs(p1[1]-p2[1])\n                    res = min(res, area)\n        \n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pointset = {tuple(i) for i in points}\n        ans = float('inf')\n        area = lambda x,y: abs((x[0]-y[0])*(x[1]-y[1]))\n        \n        for i, A in enumerate(points):\n            for j in range(i):\n                B = points[j]\n                if A[0] == B[0] or A[1] == B[1]: continue\n                #if (A[1]-B[1])//(A[0]-B[0]) >= 0: continue\n\n                if (A[0], B[1]) in pointset and (B[0], A[1]) in pointset:\n                    ans = min(ans, area(A, B))\n\n        return ans if ans != float('inf') else 0\n                        \n", "'''\n\n    When we see new x point, we establish base point x as baseX.\n    For every baseX, there will be multiple y points (y_for_baseX array)\n    If y was registered in previous base(for base in y_for_baseX), we update res.\n        In other words, we update res if (y, base) seen before at another x.\n    We also update x value of seen[base][y]\n    After processing, we append y to bases array.\n    Return res\n\n'''\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        base_x_to_y = collections.defaultdict(dict)\n        y_for_base_x = []\n        base_x = -1\n        min_area = float('inf')\n        for x, y in sorted(points):\n            if x != base_x:\n                base_x = x\n                y_for_base_x = []\n            for prev_base_x in y_for_base_x:\n                if y in base_x_to_y[prev_base_x]:\n                    w = x - base_x_to_y[prev_base_x][y]\n                    h = y - prev_base_x\n                    area = w * h\n                    min_area = min(min_area, area)\n                base_x_to_y[prev_base_x][y] = x\n            y_for_base_x.append(y)\n        return min_area if min_area < float('inf') else 0", "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points = [Point(x, y) for [x, y] in points]\n        dic_x = collections.defaultdict(set)\n        dic_y = collections.defaultdict(set)\n        for p in points:\n            dic_x[p.x].add(p.y)\n            dic_y[p.y].add(p.x)\n        \n        area = math.inf\n        for (p1, p2) in itertools.combinations(points, 2):\n            if p1.x == p2.x or p1.y == p2.y:\n                continue\n            if p2.y in dic_x[p1.x] and p2.x in dic_y[p1.y]:\n                area = min(area, abs(p2.x-p1.x) * abs(p2.y-p1.y))\n        return area if area != math.inf else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n#         # N = 500 is really loose.\n#         # Just check all pairs of points.\n#         # Time O(N^2) , 1000ms ~ 1200ms\n        \n#         seen = set()\n#         minA = float('inf')\n#         for x1, y1 in points:\n#             for x2, y2 in seen:\n#                 if (x1,y2) in seen and (x2,y1) in seen:\n#                     area = abs(x1-x2)*abs(y1-y2)\n#                     minA = min(minA, area)\n#             seen.add((x1,y1))\n#         return minA if minA<float('inf') else 0\n    \n        # Below is a bit more ugly solution but is easier to understand\n        # time is O(N^2)\n        # similar question #963. Minimum Area Rectangle II\n        minA = float('inf')\n        cache = {(x,y) for x, y in points} # hash all points for quicker lookup\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            for j in range(i+1, len(points)): # for every possible pair in points\n                x2, y2 = points[j]\n                if (x1,y2) in cache and (x2,y1) in cache:\n                    area = abs(x1-x2)*abs(y1-y2)\n                    if area != 0:\n                        minA = min(minA, area)\n        return minA if minA<float('inf') else 0\n                \n                \n                \n                \n                \n                \n                \n", "from collections import defaultdict\nfrom math import inf\n\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        byrow = defaultdict(set) # row: {col,}\n        bycol = defaultdict(set) # col: {row,}\n        for x, y in points:\n            byrow[y].add(x)\n            bycol[x].add(y)\n            \n        area = inf\n        for x1, ys in list(bycol.items()):\n            if len(ys) < 2:\n                continue\n            for y1 in ys:\n                for y2 in ys - {y1}:\n                    for x2 in byrow[y1] & byrow[y2] - {x1}:\n                        area = min(area, abs(x1-x2)*abs(y1-y2))\n        return area if area < inf else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        point_set = {(x, y) for x, y in points}\n        min_area = math.inf\n        \n        for i in range(n):\n            x0, y0 = points[i]\n            for j in range(i + 1, n):\n                x1, y1 = points[j]\n                if (x0, y1) in point_set and (x1, y0) in point_set:\n                    area = abs(x0 - x1) * abs(y0 - y1)\n                    if area > 0:\n                        min_area = min(min_area, area)\n        \n        return 0 if min_area == math.inf else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        counter = Counter(list(map(tuple, points)))\n        if any(count >= 4 for count in list(counter.values())):\n            return 0\n        points = list(counter)\n        result = float('inf')\n        for i, (x, y) in enumerate(points):\n            for j in range(i + 1, len(points)):\n                x_, y_ = points[j]\n                if x != x_ and y != y_:\n                    if (x, y_) in counter and (x_, y) in counter:\n                        result = min(result, abs((x_ - x) * (y_ - y)))\n                        if not result:\n                            return 0\n                elif counter[(x, y)] == 2 and counter[(x_, y_)] == 2:\n                        return 0\n        return 0 if result == float('inf') else result\n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        \n        ss={}\n        for ele in points:\n            ss[tuple(ele)]=1\n            \n        ans=float('inf')\n        for i in range(len(points)-1):\n            for j in range(i+1,len(points)):\n                x1,y1=points[i]\n                x2,y2=points[j]\n                if (x2,y1) in ss and (x1,y2) in ss and x1!=x2 and y1!=y2:\n                    ans=min(ans,abs((x1-x2)*(y1-y2)))\n        return (0 if ans==float('inf') else ans)\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        st = set()\n        \n        min_area = float('inf')\n        \n        for item in points:\n            st.add((item[0], item[1]))\n            \n        for i in range(len(points)-1):\n            for j in range(i+1,len(points)):\n                x1,y1 = points[i][0], points[i][1]\n                \n                x2,y2 = points[j][0], points[j][1]\n                \n                if x1 == x2 or y1 ==y2:\n                    continue\n                \n                if (x1,y2) in st and (x2, y1) in st:\n                    curr_area = abs((y2-y1) * (x2-x1))\n                    min_area = min(min_area, curr_area)\n        \n        if min_area == float('inf'):\n            return 0\n        \n        return min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points_set = set([tuple(v) for v in points])\n        min_area = None\n        for i, x1y1 in enumerate(points):\n            for x2y2 in points[i:]:\n                if x1y1[0] == x2y2[0] or x1y1[1] == x2y2[1]:\n                    continue\n                x1y2 = tuple([x1y1[0], x2y2[1]])\n                x2y1 = tuple([x2y2[0], x1y1[1]])\n                if x1y2 in points_set and x2y1 in points_set:\n                    area = abs((x1y1[0]-x2y2[0]) * (x1y1[1]-x2y2[1]))\n                    # print(abs(area))\n                    if min_area is None or area < min_area:\n                        min_area=area\n        return min_area if min_area else 0\n        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # for every pair of points, check if other diagonal is in points\n        pointset = set([tuple(x) for x in points])\n        res = 2 ** 32\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                p1 = points[i]\n                p2 = points[j]\n                if p1[0] != p2[0] and p1[1] != p2[1]: # check points aren't on the same line\n                    if (p1[0],p2[1]) in pointset and (p2[0], p1[1]) in pointset: # check other diag is in points\n                        res = min(res, abs(p1[0] - p2[0]) * abs(p1[1] - p2[1])) # update res\n        return res if res < 2 ** 32 else 0\n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        \n        hashset = set()\n        \n        for x, y in points:\n            hashset.add((x, y))\n        \n        area = float('inf')\n        for i in range(len(points)):\n            for j in range(len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                \n                if x1 >= x2 or y1 >= y2:\n                    continue\n                \n                if (x1, y2) in hashset and (x2, y1) in hashset:\n                    area = min(area, (y2-y1)*(x2-x1))\n                \n        return area if area < float('inf') else 0", "'''\n1. When we see new x point, we establish base point x as baseX.\n2. For every baseX, there will be multiple y points (y_for_baseX array)\n3. If y was registered in previous base(for base in y_for_baseX), we update res.\n  - In other words, we update res if (y, base) seen before at another x.\n4. We also update x value of seen[base][y]\n5. After processing, we append y to bases array.\n6. Return res\n'''\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        base_x_to_y = collections.defaultdict(dict)\n        y_for_base_x = []\n        base_x = -1\n        min_area = float('inf')\n        for x, y in sorted(points):\n            if x != base_x: # 1\n                base_x = x # 1\n                y_for_base_x = [] # 2\n            for prev_base_x in y_for_base_x: # 3\n                if y in base_x_to_y[prev_base_x]: # 3\n                    w = x - base_x_to_y[prev_base_x][y]\n                    h = y - prev_base_x\n                    area = w * h\n                    min_area = min(min_area, area) # 3\n                base_x_to_y[prev_base_x][y] = x # 4\n            y_for_base_x.append(y) # 5\n        return min_area if min_area < float('inf') else 0 # 6", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        \n#         columns = collections.defaultdict(list)\n#         for x, y in points:\n#             columns[x].append(y)\n#         lastx = {}\n#         ans = float('inf')\n\n#         for x in sorted(columns):\n#             column = columns[x]\n#             column.sort()\n#             for j, y2 in enumerate(column):\n#                 for i in range(j):\n#                     y1 = column[i]\n#                     if (y1, y2) in lastx:\n#                         ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n#                     lastx[y1, y2] = x\n#         return ans if ans < float('inf') else 0\n    \n    \n        \n        # S = set(map(tuple, points))\n        S = {tuple(p) for p in points}\n        \n        result = float('inf')\n        \n        for j in range(len(points)):\n            for i in range(j):\n                p1 = points[i]\n                p2 = points[j]\n                if (p1[0] != p2[0] and p1[1] != p2[1] and\n                        (p1[0], p2[1]) in S and (p2[0], p1[1]) in S):\n                    result = min(result, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        \n        return result if result < float('inf') else 0        \n\n        \n        \n        \n#         min_area = float('inf')\n#         same_y = {}\n#         h_segments = {}\n                \n#         for i in range(len(points)  - 1):\n#             for j in range(i + 1 , len(points)):\n#                 if points[i][1] == points[j][1]:\n#                     key = (min(points[i][0] , points[j][0]) , max(points[i][0] , points[j][0]) )\n#                     if key not in h_segments:\n#                         h_segments[key] = []\n#                     h_segments[key].append(points[i][1])\n                                    \n#         for key in h_segments:\n#             width = key[1] - key[0]\n            \n#             val = h_segments[key]\n#             if len(val) > 1:\n#                 for i in range(len(val) - 1):\n#                     for j in range(i, len(val)):\n#                         height = abs(val[i] - val[j])\n#                         if  width > 0 and  height > 0:\n#                             min_area = min(min_area , width * height)\n        \n#         if min_area == float('inf'):\n#             return 0\n                \n#         return min_area\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        x = 0; y = 1\n        points_set = set()\n        for point in points:\n            points_set.add((point[x], point[y]))\n        if len(points_set) < 4: return 0\n        best = None\n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                p1 = points[i]\n                p2 = points[j]\n                if p1[x] == p2[x] or p1[y] == p2[y]:\n                    continue\n                if (p1[x],p2[y]) in points_set and (p2[x],p1[y]) in points_set:\n                    area = abs(p2[x]-p1[x])*abs(p2[y]-p1[y])\n                    best = area if best is None else min(best, area)\n        return 0 if not best else best", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n#         # N = 500 is really loose.\n#         # Just check all pairs of points.\n#         # Time O(N^2) , 1000ms ~ 1200ms\n        \n#         seen = set()\n#         minA = float('inf')\n#         for x1, y1 in points:\n#             for x2, y2 in seen:\n#                 if (x1,y2) in seen and (x2,y1) in seen:\n#                     area = abs(x1-x2)*abs(y1-y2)\n#                     minA = min(minA, area)\n#             seen.add((x1,y1))\n#         return minA if minA<float('inf') else 0\n    \n        # Below is a bit more ugly solution but is easier to understand\n        # time is O(N^2)\n        # similar question #963. Minimum Area Rectangle II\n        cache = set()\n        minA = float('inf')\n        for x, y in points:\n            cache.add((x,y)) # hash all points for quicker lookup\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            for j in range(i+1, len(points)): # for every possible pair in points\n                x2, y2 = points[j]\n                if (x1,y2) in cache and (x2,y1) in cache:\n                    area = abs(x1-x2)*abs(y1-y2)\n                    if area != 0:\n                        minA = min(minA, area)\n        return minA if minA<float('inf') else 0\n                \n                \n                \n                \n                \n                \n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        setPts = set(map(tuple,points))\n        ans = sys.maxsize\n        for p in range(len(points)):\n            for i in range(p):\n                p1 = points[p]\n                p2 = points[i]\n                if p1[0] != p2[0] and p1[1] != p2[1] and \\\\\n                ((p1[0],p2[1]) in setPts and (p2[0],p1[1]) in setPts):\n                    ans = min(ans,abs(p1[0]-p2[0]) * abs(p1[1]-p2[1]))\n                        \n        return ans if ans < sys.maxsize else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pointsSet = set(map(tuple, points))\n        pointsLength = len(points)\n        minArea = float('inf')\n        for i in range(pointsLength):\n            for j in range(i + 1, pointsLength):\n                p1, p2 = points[i], points[j]\n                if p1[0] != p2[0] and p1[1] != p2[1] and (p1[0], p2[1]) in pointsSet and (p2[0], p1[1]) in pointsSet:\n                    minArea = min(minArea, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return minArea if minArea < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pointsSet = set(tuple(point) for point in points)\n        minarea = sys.maxsize\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                x_i = points[i][0]\n                y_i = points[i][1]\n                x_j = points[j][0]\n                y_j = points[j][1]\n                if x_i!=x_j and y_i!=y_j and (x_i,y_j) in pointsSet and (x_j,y_i) in pointsSet:\n                    minarea = min(minarea,abs(x_j-x_i)*abs(y_j-y_i))\n        return minarea if minarea!=sys.maxsize else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n#         # N = 500 is really loose.\n#         # Just check all pairs of points.\n#         # Time O(N^2) , 1000ms ~ 1200ms\n        \n#         seen = set()\n#         minA = float('inf')\n#         for x1, y1 in points:\n#             for x2, y2 in seen:\n#                 if (x1,y2) in seen and (x2,y1) in seen:\n#                     area = abs(x1-x2)*abs(y1-y2)\n#                     minA = min(minA, area)\n#             seen.add((x1,y1))\n#         return minA if minA<float('inf') else 0\n    \n        # Below is a bit more ugly solution but is easier to understand\n        cache = set()\n        minA = float('inf')\n        for x, y in points:\n            cache.add((x,y)) # hash all points for quicker lookup\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            for j in range(i+1, len(points)): # for every possible pair in points\n                x2, y2 = points[j]\n                if (x1,y2) in cache and (x2,y1) in cache:\n                    area = abs(x1-x2)*abs(y1-y2)\n                    if area != 0:\n                        minA = min(minA, area)\n        return minA if minA<float('inf') else 0\n                \n                \n                \n                \n                \n                \n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        grid = {}\n        for x, y in points:\n            grid[x] = grid.get(x, []) + [y]\n        \n        for row in grid.values():\n            row.sort()\n            \n        globalMin = float(\\\"inf\\\")\n        for row1 in grid:\n            for row2 in grid:\n                if row1 == row2:\n                    continue\n                i = j = 0\n                preIdx = -1\n                while i < len(grid[row1]) and j < len(grid[row2]):\n                    if grid[row1][i] < grid[row2][j]:\n                        i += 1\n                    elif grid[row1][i] > grid[row2][j]:\n                        j += 1\n                    else:\n                        if preIdx != -1:\n                            globalMin = min(globalMin, abs(row2 - row1)*(grid[row1][i] - preIdx))\n                        preIdx = grid[row1][i]\n                        i += 1\n                        j += 1\n                        \n        if globalMin == float(\\\"inf\\\"):\n            return 0\n        return globalMin", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n#         # N = 500 is really loose.\n#         # Just check all pairs of points.\n#         # Time O(N^2) , 1000ms ~ 1200ms\n        \n#         seen = set()\n#         minA = float('inf')\n#         for x1, y1 in points:\n#             for x2, y2 in seen:\n#                 if (x1,y2) in seen and (x2,y1) in seen:\n#                     area = abs(x1-x2)*abs(y1-y2)\n#                     minA = min(minA, area)\n#             seen.add((x1,y1))\n#         return minA if minA<float('inf') else 0\n    \n        # Below is a bit more ugly solution but is easier to understand\n        # time is O(N^2)\n        cache = set()\n        minA = float('inf')\n        for x, y in points:\n            cache.add((x,y)) # hash all points for quicker lookup\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            for j in range(i+1, len(points)): # for every possible pair in points\n                x2, y2 = points[j]\n                if (x1,y2) in cache and (x2,y1) in cache:\n                    area = abs(x1-x2)*abs(y1-y2)\n                    if area != 0:\n                        minA = min(minA, area)\n        return minA if minA<float('inf') else 0\n                \n                \n                \n                \n                \n                \n                \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        min_area = sys.maxsize\n        \n        point_set = set([(p[0], p[1]) for p in points])\n        \n        for i in range(len(points)):\n            \n            for j in range(i + 1, len(points)):\n                \n                p1 = points[i]\n                \n                p2 = points[j]\n                \n                if p1[0] != p2[0] and p1[1] != p2[1]:\n                    \n                    p3 = (p1[0], p2[1])\n                    \n                    p4 = (p2[0], p1[1])\n                    \n                    if p3 in point_set and p4 in point_set:\n                        \n                        min_area = min(min_area, abs((p1[0] - p2[0]) * (p1[1] - p2[1])))\n                                    \n        return min_area if min_area != sys.maxsize else 0\n                    \n                    \n                    \n        \n        \n", "class Solution:\n    def minAreaRect(self, points):\n        seen, bases, baseX, res = collections.defaultdict(dict), [], -1, float(\\\"inf\\\")\n        for x, y in sorted(points):\n            if x != baseX:\n                baseX, bases = x, []\n            for base in bases:\n                if y in seen[base]:\n                    res = min(res, (x - seen[base][y]) * (y - base))\n                seen[base][y] = x\n            bases.append(y)\n        return res if res < float(\\\"inf\\\") else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        S = {(point[0], point[1]) for point in points}\n        minArea = math.inf\n        for i,point1 in enumerate(points):\n            for j in range(i):\n                point2 = points[j]\n                x1, x2, y1, y2 = point1[0], point2[0], point1[1], point2[1]\n                diagPoints = (x1 != x2) and (y1 != y2)\n                if diagPoints and (x1, y2) in S and (x2, y1) in S:\n                    minArea = min(minArea, abs(x1 - x2) * abs(y1 - y2))\n        return minArea if minArea != math.inf else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        by_x = defaultdict(set)\n        by_y = defaultdict(set)\n        for x, y in points:\n            by_x[x].add(y)\n            by_y[y].add(x)\n        min_area = float(\\\"inf\\\")\n        for x, ys in by_x.items():\n            if len(ys) < 2:\n                continue\n            for y1 in ys:\n                for y2 in ys:\n                    if y1 == y2:\n                        continue\n                    valid_xs = by_y[y1] & by_y[y2]\n                    for other_x in valid_xs:\n                        if other_x == x:\n                            continue\n                        min_area = min(min_area, abs(x - other_x) * abs(y1 - y2))\n        if min_area == float(\\\"inf\\\"):\n            return 0\n        else:\n            return min_area", "class Solution:\n    def minAreaRect(self, z: List[List[int]]) -> int:\n        \n        \n        \n        x=defaultdict(set)\n        y=defaultdict(set)\n        z.sort()\n        #se= set(tuple(i) for i in z)\n        for a,b in z:\n            x[a].add(b)\n            y[b].add(a)\n        ans=inf\n        l=len(z)\n        for k in range(l):\n            a,b=z[k]\n            for m in range(k+1,l):\n                c,d=z[m]\n                if a<c:break\n                for j in y[b].intersection(y[d]):\n                    if j!=a:\n                        ans= min(ans, abs(b-d)*abs(a-j))\n        return ans if ans!=inf else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        x_grouped = collections.defaultdict(set)\n\n        for x, y in points:\n            x_grouped[x].add(y)\n\n        res = float(\\\"inf\\\")\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n\n                if y2 in x_grouped[x1] and y1 in x_grouped[x2]:\n                    width = abs(x1 - x2)\n                    height = abs(y1 - y2)\n                    if width != 0 and height != 0:\n                        res = min(res, width * height)\n\n        if res < float(\\\"inf\\\"): return res\n        return 0", "\\\"\\\"\\\"\nsol1 hashmap \u5b58 x:[y1,y2,...], \u5bfb\u627e\u5bf9\u89d2\u7ebfdiagonal\u4e0a\u7684\u4e24\u70b9\uff0c\u518d\u68c0\u67e5\u662f\u5426\u5b58\u5728\u5269\u4e0b\u7684\u4e24\u70b9\ntimeO(n^2) spaceO(n^2)\n\\\"\\\"\\\"\nclass Solution:\n    \\\"\\\"\\\"sol1 diagonal+hashmap timeO(n^2) spaceO(n^2)\\\"\\\"\\\"\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        x2y = collections.defaultdict(set)\n        minArea = float('inf')\n        \n        for x,y in points: # hashmap <x, {y1,y2,...}>\n            x2y[x].add(y)\n        \n        # find diagnal (x1,y1) -> (x2,y2)\n        for x1,y1 in points:\n            for x2,y2 in points:\n                if x1==x2 or y1==y2: continue # in the same row/column, cannot form retangle\n                elif y2 in x2y[x1] and y1 in x2y[x2]:\n                    minArea = min(minArea, abs((x1-x2)*(y1-y2)) )\n                \n        if minArea<float('inf'): return minArea\n        return 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pointSet = set(map(tuple, points))\n        n = len(points)\n        minArea = float('inf')\n        for i in range(n-1):\n            for j in range(i+1, n):\n                diag1, diag2 = points[i], points[j]\n                if diag2[0] == diag1[0] or diag2[1] == diag1[1]:    continue\n                if (diag2[0], diag1[1]) not in pointSet:    continue\n                if (diag1[0], diag2[1]) not in pointSet:    continue\n                minArea = min(minArea, abs(diag2[0]-diag1[0])*abs(diag2[1]-diag1[1]))\n        return minArea if minArea < float('inf') else 0", "\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        S = {(point[0], point[1]) for point in points}\n        minArea = math.inf\n        for i,point1 in enumerate(points):\n            for j in range(i):\n                point2 = points[j]\n                x1, x2, y1, y2 = point1[0], point2[0], point1[1], point2[1]\n                diagPoints = (x1 != x2) and (y1 != y2)\n                if diagPoints and (x1, y2) in S and (x2, y1) in S:\n                    minArea = min(minArea, abs(x1 - x2) * abs(y1 - y2))\n        return minArea if minArea != math.inf else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        hash_set = set(map(tuple, points))\n        min_ = float('inf')\n\n            \n        for j, p2 in enumerate(points):\n            for i in range(j):\n                p1 = points[i]\n                if p1[0] != p2[0] and p1[1] != p2[1]:\n                    if (p1[0], p2[1]) in hash_set and (p2[0],p1[1]) in hash_set:\n                        min_ = min(min_, abs(p2[0]-p1[0])*abs(p2[1]-p1[1]))\n        \n        if min_ == float('inf'):\n            return 0\n        \n        return min_", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        S = set((p[0], p[1]) for p in points)\n        ans = float('inf')\n        for i in range(len(points)):\n          for j in range(i):\n            p1 = points[i]\n            p2 = points[j]\n            if p1[0] == p2[0] or p1[1] == p2[1]:\n              continue\n            if (p1[0], p2[1]) in S and (p2[0], p1[1]) in S:\n              ans = min(ans, abs(p2[0] - p1[0]) * abs(p2[1] - p1[1]))\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        x_grouped, y_grouped = collections.defaultdict(set), collections.defaultdict(set)\n\n        for x, y in points:\n            x_grouped[x].add(y)\n\n        res = float(\\\"inf\\\")\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n\n                if y2 in x_grouped[x1] and y1 in x_grouped[x2]:\n                    width = abs(x1 - x2)\n                    height = abs(y1 - y2)\n                    if width != 0 and height != 0:\n                        res = min(res, width * height)\n\n        if res < float(\\\"inf\\\"): return res\n        return 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        x_axes = {}\n        y_axes = {}\n        \n        for point in points:\n            if point[0] not in x_axes:\n                x_axes[point[0]] = set()\n            if point[1] not in y_axes:\n                y_axes[point[1]] = set()\n            x_axes[point[0]].add(point[1])\n            y_axes[point[1]].add(point[0])\n        \n        def findMinArea(point, x_axes, y_axes):\n            # traverse x axes, fix y axis\n            possible_x = y_axes[point[1]]\n            possible_y = x_axes[point[0]]\n            # print(point, possible_x, possible_y)\n            min_area = None\n            for x in possible_x:\n                if x == point[0]:\n                    continue\n                for y in possible_y:\n                    if y == point[1]:\n                        continue\n                    if x in y_axes[y]:\n                        area = abs((x-point[0])*(y-point[1]))\n                        # print(area)\n                        min_area = area if min_area is None else min(area, min_area)\n            return min_area\n        \n        min_area = None\n        for point in points:\n            area = findMinArea(point, x_axes, y_axes)\n            if area is not None:\n                min_area = area if min_area is None else min(min_area, area)\n        \n        return min_area if min_area else 0\n", "import sys\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        minArea = sys.maxsize\n        \n        pointSet = set()\n        for point in points:\n            pointSet.add((point[0], point[1]))\n        \n        #print(pointSet)\n        for i in range(0, len(points)):\n            for j in range(i+1, len(points)):\n                point1 = points[i]\n                point2 = points[j]\n                x1, y1 = point1[0], point1[1]\n                x2, y2 = point2[0], point2[1]\n                \n                # same point\n                if x1 == x2 or y1 == y2:\n                    continue\n                \n                if (x1, y2) in pointSet and (x2, y1) in pointSet:\n                    \n                    area = abs(x2-x1) * abs(y2-y1)\n                    minArea = min(minArea, area)\n                    \n        if minArea == sys.maxsize:\n            return 0\n        return minArea", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        def hashing(i,j,p=40001):\n            return i*p+j\n        board = set()\n        for x,y in points:\n            board.add(hashing(x,y))\n        ans = float('inf')\n        print(board)\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                tlx,tly = points[i]\n                brx,bry = points[j]\n                if tlx==brx or tly==bry:   continue\n                if hashing(tlx,bry) in board and hashing(brx,tly) in board:\n                \n                    ans = min(ans,abs((brx-tlx)*(bry-tly)))\n        if ans < float('inf'):  return ans\n        else:   return 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        y2x = collections.defaultdict(list)\n        for x,y in points:\n            y2x[y].append(x)\n        res = float('inf')\n        ys = list(y2x.keys())\n        for y1 in ys:\n            for y2 in ys:\n                if y1!=y2:\n                    x1List = y2x[y1]\n                    x2Set = y2x[y2]\n                    canList = []\n                    for x1 in x1List:\n                        if x1 in x2Set:\n                            canList.append(x1)\n                    for m in canList:\n                        for n in canList:\n                            if m!=n:\n                                res = min(res, abs(m-n)*abs(y1-y2))\n        if res == float('inf'):\n            return 0\n        return res\n\n                        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n < 4:\n            return 0\n        \n        ptSet = set([(x,y) for x,y in points])\n        area = math.inf\n        for i in range(n):\n            for j in range(i):\n                if points[i][0] != points[j][0] and points[i][1] != points[j][1]:\n                    if (points[i][0], points[j][1]) in ptSet and (points[j][0], points[i][1]) in ptSet:\n                        area = min(area, abs(points[i][0] - points[j][0]) * abs(points[i][1] - points[j][1]))\n        \n        return area if area < math.inf else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort()\n        n = len(points)\n        pmap = {(i, j) for i, j in points}\n        area = float('inf')\n        for i in range(n):\n            for j in range(i+1, n):\n                x1 = points[i][0]\n                y1 = points[i][1]\n                x2 = points[j][0]\n                y2 = points[j][1]\n                if x1 != x2 and y2 != y1 and x1 != y2 and x2 != y1:\n                    if (x1, y2) in pmap and (x2, y1) in pmap:\n                        area = min(area, abs(x1-x2) * abs(y2-y1))\n        \n        return 0 if area == float('inf') else area\n", "class Solution(object):\n    def minAreaRect(self, points):\n        \\\"\\\"\\\"\n        :type points: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        min_area = sys.maxsize\n        points_table = set()\n        \n        for x, y in points:\n            points_table.add((x,y))\n            \n        for p1,p2 in itertools.combinations(points_table,2):\n               # print (p1,p2)\n                x1,y1 = p1\n                x2,y2 = p2 \n               # if x1 > x2 and y1 > y2: # Skip looking at same point\n                if 1:   \n                    if (x1, y2) in points_table and (x2, y1) in points_table:\n                       # print (\\\"wew\\\",p1,p2)\n                        area = abs(x1 -  x2) * abs(y1 - y2)\n                        if area:\n                            min_area = min(area, min_area)\n                        \n        return 0 if min_area == sys.maxsize else min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        area = float('inf')\n        x_order = collections.defaultdict(list)\n        y_order = collections.defaultdict(list)\n        for p in points:\n            x_order[p[0]].append(p[1])\n            y_order[p[1]].append(p[0])\n        \n        xs = sorted(list(x_order.items()), key = lambda x:x[0])\n        for col in xs:\n            if len(col[1]) < 2:\n                continue\n            \n            for i in range(len(col[1])-1):\n                j = i + 1\n                while j < len(col[1]):\n                    common_x = list(set(y_order[col[1][i]]) & set(y_order[col[1][j]]))\n                    # remove the side of the col we hold now\n                    common_x.remove(col[0])\n                    if common_x:\n                        for x in common_x:\n                            a = (abs(col[0]-x)*abs(col[1][i] - col[1][j]))\n                            area = min(area, a)\n                    j += 1\n        return area if area < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n < 4:\n          return 0\n        s = set([tuple(i) for i in points])\n        # print(s)\n        minarea = float('inf')\n        for i in range(n-1):\n          for j in range(i+1, n):\n            if points[i][0] != points[j][0] and points[i][1] != points[j][1]:  # not in same line horizontally and vertically\n              if (points[j][0], points[i][1]) in s and (points[i][0], points[j][1]) in s:\n                # print(i, j)\n                minarea = min(minarea, abs(points[i][0] - points[j][0]) * abs(points[i][1] - points[j][1]))\n\n        if minarea == float('inf'):\n          return 0\n        return minarea", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) < 4:\n            return 0\n        \n        area = float('inf')\n        corners = set([tuple(x) for x in points])\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[i][0] != points[j][0] and points[i][1] != points[j][1]:\n                    if (points[i][0], points[j][1]) in corners and (points[j][0], points[i][1]) in corners:\n                        l, w = abs(points[i][0] - points[j][0]), abs(points[i][1] - points[j][1])\n                        area = min(area, l*w)\n                    # corners.add(tuple(points[i]))\n                    # corners.add(tuple(points[j]))\n        \n        return 0 if area == float('inf') else area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n       \n        pointsSet = set([(x, y) for x, y in points])\n        minv = float('inf')\n        for i in range(len(points)): \n            for j in range(i + 1, len(points)):\n                if points[i][0] != points[j][0] and points[i][1] != points[j][1] and  (points[i][0], points[j][1]) in pointsSet and (points[j][0], points[i][1]) in pointsSet:\n                    minv = min(minv, abs(points[i][0] - points[j][0])*abs(points[i][1] - points[j][1]))\n                    if minv == 1: print((points[i], points[j]))\n        return minv if minv != float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # Let's make a set of points\n        # With two nested loops, find points (x1, y1) and (x2, y2) and use those to see if (x1,y2) and (x2,y1) are in the sets\n        points_set = {tuple(p) for p in points}\n        res = float('inf')\n        for p1 in points:\n            for p2 in points:\n                # Find diagonal points\n                if p1[0] != p2[0] and p1[1] != p2[1]:\n                    area = abs(p1[0] - p2[0]) * abs(p1[1] - p2[1])\n                    if area < res:\n                        if ((p1[0], p2[1]) in points_set and (p2[0], p1[1]) in points_set):\n                            res = area\n        return 0 if res == float('inf') else res        \n\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        pts = set()\n        for p in points:\n            pts.add((p[0], p[1]))\n        ans = float('inf')\n        flag = False\n        P = len(points)\n        for i in range(P):\n            for j in range(i+1, P):\n                if points[i][0] == points[j][0] or points[i][1] == points[j][1]:\n                    continue\n                else:\n                    dx1 = points[i][0]\n                    dy1 = points[j][1]\n                    dx2 = points[j][0]\n                    dy2 = points[i][1]\n                    if (dx1, dy1) in pts and (dx2, dy2) in pts:\n                        area = abs(dy1-dy2)*abs(dx1-dx2)\n                        ans = min(area, ans)\n                        flag = True\n        return ans if flag else 0\n", "class Solution:\n    def minAreaRect(self, points):\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in pSet) and ((p2x, p1y) in pSet):\n                    ans = min(ans, abs((p1x - p2x) * (p1y - p2y)))\n        return ans if ans < float('inf') else 0\n    \nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in pSet and (p2x, p1y) in pSet:\n                    ans = area\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n    \nfrom collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        Nr, Nc = len(set(X[0])), len(set(X[1]))\n        if Nr == 1 or Nc == 1: return 0\n        if Nr < Nc:\n            points = [[c, r] for (r, c) in points]\n            return self.minAreaRect(points)\n    \n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0\n    \n\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        hor = defaultdict(list)\n        ver = defaultdict(list)\n        seen = set()\n        area = float(\\\"inf\\\")\n        for point in points:\n            x, y = point\n            if len(hor[y]) > 0 and len(ver[x]) > 0:\n                for i in ver[x]:\n                    for j in hor[y]:\n                        if (j, i) in seen:\n                            area = min(area, abs((x-j)*(y-i)))\n            seen.add((x, y))\n            ver[x].append(y)\n            hor[y].append(x)\n        if area != float('inf'):\n            return area\n        else:\n            return 0", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points_by_x = defaultdict(set)\n        # points_by_y = defaultdict(set)\n        for point in points:\n            points_by_x[point[0]].add(point[1])\n            # points_by_y[point[1]].add(point[0])\n        \n        \n        xs_to_delete = []\n        for x, ys in points_by_x.items():\n            if len(ys) < 2:\n                xs_to_delete.append(x)\n        for x in xs_to_delete:\n            del points_by_x[x] \n        \n        \\\"\\\"\\\"\n        ys_to_delete = []\n        for y, xs in points_by_y.items():\n            if len(xs) < 2:\n                ys_to_delete.append(y)\n        [del points_by_y[y] for y in ys_to_delete]\n        \\\"\\\"\\\"\n        # [ys.sort() for x, ys in points_by_x.items()]\n        # [xs.sort() for y, xs in points_by_y.items()]\n        \n        minarea = float('inf')\n        for x1, ys1 in points_by_x.items():\n            for x2, ys2 in points_by_x.items():\n                if x1 == x2:\n                    continue\n                xdiff = abs(x2-x1)\n                if xdiff > minarea:\n                    continue\n                ys_common = sorted(ys1.intersection(ys2))\n                if len(ys_common) < 2:\n                    continue\n                ydiff = min(y2-y1 for y1, y2 in zip(ys_common[:-1], ys_common[1:]))\n                area = xdiff*ydiff\n                if area < minarea:\n                    minarea = area\n        return 0 if minarea == float('inf') else minarea\n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort(key = lambda x:(x[0], x[1]))\n        print(points)\n        ver = collections.defaultdict(list)\n        hor = collections.defaultdict(list)\n        seen = set()\n        res = float(\\\"inf\\\")\n        for x, y in points:            \n            if len(ver[x]) > 0 and len(hor[y]) > 0:\n                for i in ver[x][::-1]:\n                    for j in hor[y][::-1]:\n                        if (j, i) in seen:\n                            res = min(res, (x - j) * (y - i))\n            seen.add((x, y))\n            ver[x].append(y)\n            hor[y].append(x)\n        if res != float(\\\"inf\\\"):\n            return res\n        else:\n            return 0\n        \n        #1 0 1\n        #0 1 0\n        #1 1 1", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in columns.items():\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        len_x = {x for x, y in points}\n        len_y = {y for x, y in points}\n        \n        if len(len_x) == len(points) or len(len_y) == len(points):\n            return 0\n        \n        memo = collections.defaultdict(list)\n        if len_x > len_y:\n            for x, y in points:\n                memo[x].append(y)\n        else:\n            for x, y in points:\n                memo[y].append(x)\n        \n        res = float('inf')\n        memo2 = {}\n        for i in sorted(memo):\n            memo[i].sort()\n            for j in range(len(memo[i])):\n                for k in range(j+1, len(memo[i])):\n                    if (memo[i][j], memo[i][k]) in memo2:\n                        res = min(res, ((memo[i][k]-memo[i][j]) * abs(memo2[(memo[i][j], memo[i][k])] - i)))\n                    \n                    memo2[memo[i][j], memo[i][k]] = i\n        \n        return res if res < float('inf') else 0\n    \n    \n#         n = len(points)\n#         nx = len(set(x for x, y in points))\n#         ny = len(set(y for x, y in points))\n#         if nx == n or ny == n:\n#             return 0\n\n#         p = collections.defaultdict(list)\n#         if nx > ny:\n#             for x, y in points:\n#                 p[x].append(y)\n#         else:\n#             for x, y in points:\n#                 p[y].append(x)\n\n#         lastx = {}\n#         res = float('inf')\n#         for x in sorted(p):\n#             p[x].sort()\n#             for i in range(len(p[x])):\n#                 for j in range(i):\n#                     y1, y2 = p[x][j], p[x][i]\n#                     if (y1, y2) in lastx:\n#                         res = min(res, (x - lastx[y1, y2]) * abs(y2 - y1))\n#                     lastx[y1, y2] = x\n#         return res if res < float('inf') else 0\n", "from collections import defaultdict\nfrom bisect import insort\nclass Solution:\n    def minAreaRect(self, points):\n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            insort(columns[r], c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in columns.items():\n            for i, c1 in enumerate(cols):\n                for c2 in cols[i+1:]:\n                    if (c1, c2) in lastc:\n                        area = (r - lastc[(c1, c2)]) * (c2 - c1)\n                        #ans = min(ans, area)\n                        if area < ans: ans = area\n                    lastc[(c1, c2)] = r\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        ans = float(\\\"inf\\\")\n        seen = {}\n        for x in sorted(columns):\n            col = sorted(columns[x])\n            for j, y2 in enumerate(col):\n                for i in range(j):\n                    y1 = col[i]\n                    key = (y1, y2)\n                    if key in seen:\n                        ans = min(ans, (x - seen[key]) * (y2-y1))\n                    seen[key] = x\n        return ans if ans < float('inf') else 0", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        columns = defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        seen = {}\n        min_area = float(\\\"inf\\\")\n        for col, ys in sorted(columns.items()):\n            ys = sorted(ys)\n            for i, y1 in enumerate(ys):\n                for y2 in ys[i+1:]:\n                    if (y1, y2) in seen:\n                        #we have a rectangle\n                        x1 = seen[(y1, y2)]\n                        area = (col -x1) * (y2-y1)\n                        min_area = min(min_area, area)\n                        \n                        \n                    seen[(y1, y2)] = col\n        return 0 if min_area == float(\\\"inf\\\") else min_area\n                    \n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        points.sort()\n        xs = collections.defaultdict(list)\n        for x, y in points:\n            xs[x].append(y)\n        seen = {}\n        result = math.inf\n        for x, ylist in xs.items():\n            for ys in itertools.combinations(ylist, 2):\n                if ys in seen:\n                    result = min(result, (x - seen[ys]) * (ys[1] - ys[0]))\n                seen[ys] = x\n        return 0 if math.isinf(result) else  result", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        nx = len(set(x for x, y in points))\n        ny = len(set(y for x, y in points))\n        if nx == n or ny == n:\n            return 0\n\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n\n        lastx = {}\n        res = float('inf')\n        for x in sorted(p):\n            p[x].sort()\n            for i in range(len(p[x])):\n                for j in range(i):\n                    y1, y2 = p[x][j], p[x][i]\n                    if (y1, y2) in lastx:\n                        res = min(res, (x - lastx[y1, y2]) * abs(y2 - y1))\n                    lastx[y1, y2] = x\n        return res if res < float('inf') else 0", "class Solution(object):\n    def minAreaRect(self, points):\n        y_group=collections.defaultdict(list)\n        for x, y in points:\n            y_group[x].append(y)\n            \n        visited={}\n        area=inf\n        \n        for x in sorted(y_group):\n            Y=y_group[x]\n            Y.sort()\n            for i in range(len(Y)):\n                y1= Y[i]\n                for j in range(i):\n                    y2=Y[j]\n                    if (y1, y2) in visited:\n                        area=min((x - visited[(y1, y2)])* (y1 - y2), area)\n                    visited[(y1, y2)]=x\n        return area if area<inf else 0\n                    \n", "class Solution(object):\n    def minAreaRect(self, points):\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0\n# class Solution:\n#     def minAreaRect(self, points: List[List[int]]) -> int:\n#         d_x = collections.defaultdict(set)\n#         d_y = collections.defaultdict(set)\n#         for x, y in points: \n#             d_x[x].add(y)\n#             d_y[y].add(x)\n#         area = sys.maxsize            \n#         for x, y in points:\n#             for yy in d_x[x]: # find same x (point above), larger y\n#                 if yy <= y: continue\n#                 for xx in d_y[y]: # find same y (point right), larget x\n#                     if xx > x and yy in d_x[xx]:\n#                         area = min(area, (xx-x)*(yy-y))\n#         return area if area != sys.maxsize else 0\n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        columns = defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        seen = {}\n        min_area = float(\\\"inf\\\")\n        for col, ys in sorted(columns.items()):\n            print(col, ys)\n            ys = sorted(ys)\n            for i, y1 in enumerate(ys):\n                for y2 in ys[i+1:]:\n                    if (y1, y2) in seen:\n                        #we have a rectangle\n                        x1 = seen[(y1, y2)]\n                        area = (col -x1) * (y2-y1)\n                        min_area = min(min_area, area)\n                        \n                        \n                    seen[(y1, y2)] = col\n        return 0 if min_area == float(\\\"inf\\\") else min_area\n                    \n        ", "\\\"\\\"\\\"\nhttps://www.youtube.com/watch?v=pFgBZFKJ2Co\nfast forward to 17minutes\n\nGroup the points by x coordinates, so that we have columns of points. Then, for every pair of points in a column (with coordinates (x,y1) and (x,y2)), check for the smallest rectangle with this pair of points as the rightmost edge. We can do this by keeping memory of what pairs of points we've seen before.\n\nInput: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n\ncolumns = {\n  # x: y1, y1\n    1: 1, 3\n    3: 1, 3\n    4: 1, 3\n}\n\nlastx {\n    (1,3) : 1 -> 3      # (y1, y2) : x axis\n}\n            i\n            y2\ncolumn = [1,3]\n            j\n            y1 \n\\\"\\\"\\\"\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) <= 3: return 0\n        columns = collections.defaultdict(list)\n        for x,y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n        \n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for i, y2 in enumerate(column):\n                for j in range(i):\n                    y1 = column[j]\n                    if (y1, y2) in lastx:\n                        area = (x - lastx[y1, y2]) * (y2 - y1)\n                        ans = min(ans, area)\n                    lastx[y1, y2] = x\n        \n        return ans if ans < float('inf') else 0\n            ", "'''\n939. Minimum Area Rectangle.  Medium\n\nGiven a set of points in the xy-plane, \ndetermine the minimum area of a rectangle\nformed from these points, with sides parallel\nto the x and y axes.\n\nIf there isn't any rectangle, return 0.\n\nExample 1:\nInput: [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\n\nExample 2:\nInput: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n\nNote:\n1 <= points.length <= 500\n0 <= points[i][0] <= 40000\n0 <= points[i][1] <= 40000\nAll points are distinct.\n\nAccepted\n55,377\nSubmissions\n107,280\n\nNOTE: Clarify: rectangle formed by ALL these points (convex hull)\n            v. rectangle formed by ANY four distinct points\n'''\nclass Solution:\n    def minAreaRectangularHull(self, points: List[List[int]]) -> int:\n        area = 0\n        if points:\n            minx, miny = points[0]\n            maxx, maxy = points[0]\n            for x, y in points:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n            area = (maxx - minx)*(maxy - miny)\n        return area\n                \n\n    def minAreaRect(self, points):\n        '''\n        Runtime: 1628 ms, faster than 38.40% of Python3 online submissions for Minimum Area Rectangle.\n        Memory Usage: 14.4 MB, less than 17.19% of Python3 online submissions for Minimum Area Rectangle.\n        '''\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for k, (xB, yB) in enumerate(points):\n            for j in range(k):\n                xA, yA = points[j]\n                if (xA != xB and yA != yB and (xA, yB) in S and (xB, yA) in S):\n                    ans = min(ans, abs((xB - xA) * (yB - yA)))\n        return ans if ans < float('inf') else 0\n    \n\nclass Solution:\n    '''\n    Runtime: 688 ms, faster than 88.20% of Python3 online submissions for Minimum Area Rectangle.\n    Memory Usage: 31.7 MB, less than 17.19% of Python3 online submissions for Minimum Area Rectangle.\n    '''\n    def minAreaRect(self, points):\n        columns = collections.defaultdict(set)\n        for x, y in points:\n            columns[x].add(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = sorted(columns[x])\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0\n", "from collections import defaultdict\n\nclass Solution(object):\n    def minAreaRect(self, points):\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0", "'''\n939. Minimum Area Rectangle.  Medium\n\nGiven a set of points in the xy-plane, \ndetermine the minimum area of a rectangle\nformed from these points, with sides parallel\nto the x and y axes.\n\nIf there isn't any rectangle, return 0.\n\nExample 1:\nInput: [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\n\nExample 2:\nInput: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n\nNote:\n1 <= points.length <= 500\n0 <= points[i][0] <= 40000\n0 <= points[i][1] <= 40000\nAll points are distinct.\n\nAccepted\n55,377\nSubmissions\n107,280\n\nNOTE: Clarify: rectangle formed by ALL these points (convex hull)\n            v. rectangle formed by ANY four distinct points\n'''\nclass Solution:\n    def minAreaRectangularHull(self, points: List[List[int]]) -> int:\n        area = 0\n        if points:\n            minx, miny = points[0]\n            maxx, maxy = points[0]\n            for x, y in points:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n            area = (maxx - minx)*(maxy - miny)\n        return area\n                \n\n    def minAreaRect(self, points):\n        '''\n        Runtime: 1628 ms, faster than 38.40% of Python3 online submissions for Minimum Area Rectangle.\n        Memory Usage: 14.4 MB, less than 17.19% of Python3 online submissions for Minimum Area Rectangle.\n        '''\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for k, (xB, yB) in enumerate(points):\n            for j in range(k):\n                xA, yA = points[j]\n                if (xA != xB and yA != yB and (xA, yB) in S and (xB, yA) in S):\n                    ans = min(ans, abs((xB - xA) * (yB - yA)))\n        return ans if ans < float('inf') else 0\n    \n\nclass Solution:\n    '''\n    Runtime: 688 ms, faster than 88.20% of Python3 online submissions for Minimum Area Rectangle.\n    Memory Usage: 31.7 MB, less than 17.19% of Python3 online submissions for Minimum Area Rectangle.\n    '''\n    def minAreaRect(self, points):\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = sorted(columns[x])\n            # column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        columns=collections.defaultdict(list)\n        for x,y in points:\n            columns[x].append(y)\n        \n        lastx={}\n        ans=float('inf')\n        for x in sorted(columns):\n            column=columns[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1=column[i]\n                    if (y1,y2) in lastx:\n                        ans=min(ans,(x-lastx[y1,y2])*(y2-y1))\n                    lastx[y1,y2]=x\n            \n        return ans if ans<float('inf') else 0", "'''\n939. Minimum Area Rectangle.  Medium\n\nGiven a set of points in the xy-plane,\ndetermine the minimum area of a rectangle\nformed from these points, with sides parallel\nto the x and y axes.\n\nIf there isn't any rectangle, return 0.\n\nExample 1:\nInput: [[1, 1], [1, 3], [3, 1], [3, 3], [2, 2]]\nOutput: 4\n\nExample 2:\nInput: [[1, 1], [1, 3], [3, 1], [3, 3], [4, 1], [4, 3]]\nOutput: 2\n\nNote:\n1 <= points.length <= 500\n0 <= points[j][0] <= 40000\n0 <= points[j][1] <= 40000\nAll points are distinct.\n\nAccepted 55,377 / 107,280 submissions.\n\nNOTE: Clarify: rectangle formed by ALL these points (convex hull)\n            v. rectangle formed by ANY four distinct points\n'''\n###############################################################################\n\nclass SolutionDefDictSort:      # Faster\n    '''\n    Runtime: 664 ms, faster than 90.46% of Python3 online submissions for Minimum Area Rectangle.\n    Memory Usage: 31.7 MB, less than 20.13% of Python3 online submissions for Minimum Area Rectangle.\n    '''\n    def minAreaRect(self, points):\n        columns = collections.defaultdict(set)\n        for x, y in points:\n            columns[x].add(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = sorted(columns[x])\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0\n\n###############################################################################\n\nclass SolutionTupleSet:         # Slower\n    '''\n    Runtime: 1628 ms, faster than 38.40% in Python3.\n    Memory Usage: 14.4 MB, less than 17.19% in Python3.\n    '''\n\n    def minAreaRect(self, points):\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for k, (xB, yB) in enumerate(points):\n            for j in range(k):\n                xA, yA = points[j]\n                if (xA != xB and yA != yB and (xA, yB) in S and (xB, yA) in S):\n                    ans = min(ans, abs((xB - xA) * (yB - yA)))\n        return ans if ans < float('inf') else 0\n\n\n    def minAreaRectangularHull(self, points: List[List[int]]) -> int:\n        '''\n        NOTE: Not what the question was intended to meant!\n        '''\n        area = 0\n        if points:\n            minx, miny = points[0]\n            maxx, maxy = points[0]\n            for x, y in points:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n            area = (maxx - minx)*(maxy - miny)\n        return area\n\n###############################################################################\n\nclass Solution:\n    pass\n\nSolution = SolutionTupleSet\nSolution = SolutionDefDictSort\n", "'''\n939. Minimum Area Rectangle.  Medium\n\nGiven a set of points in the xy-plane, \ndetermine the minimum area of a rectangle\nformed from these points, with sides parallel\nto the x and y axes.\n\nIf there isn't any rectangle, return 0.\n\nExample 1:\nInput: [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\n\nExample 2:\nInput: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n\nNote:\n1 <= points.length <= 500\n0 <= points[i][0] <= 40000\n0 <= points[i][1] <= 40000\nAll points are distinct.\n\nAccepted\n55,377\nSubmissions\n107,280\n\nNOTE: Clarify: rectangle formed by ALL these points (convex hull)\n            v. rectangle formed by ANY four distinct points\n'''\nclass Solution:\n    def minAreaRectangularHull(self, points: List[List[int]]) -> int:\n        area = 0\n        if points:\n            minx, miny = points[0]\n            maxx, maxy = points[0]\n            for x, y in points:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n            area = (maxx - minx)*(maxy - miny)\n        return area\n                \n\n    def minAreaRect(self, points):\n        '''\n        Runtime: 1628 ms, faster than 38.40% of Python3 online submissions for Minimum Area Rectangle.\n        Memory Usage: 14.4 MB, less than 17.19% of Python3 online submissions for Minimum Area Rectangle.\n        '''\n        S = set(map(tuple, points))\n        ans = float('inf')\n        for k, (xB, yB) in enumerate(points):\n            for j in range(k):\n                xA, yA = points[j]\n                if (xA != xB and yA != yB and (xA, yB) in S and (xB, yA) in S):\n                    ans = min(ans, abs((xB - xA) * (yB - yA)))\n        return ans if ans < float('inf') else 0\n    \nclass Solution(object):\n    def minAreaRect(self, points):\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x - lastx[y1,y2]) * (y2 - y1))\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        columns = collections.defaultdict(list)\n\n        for x, y in points:\n            columns[x].append(y)\n\n        lastx = {}\n        ans = float(\\\"inf\\\")\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n\n            for j, y2 in enumerate(column):\n                for i in range(j):\n                    y1 = column[i]\n                    if (y1, y2) in lastx:\n                        ans = min(ans, (x-lastx[y1, y2]) * (y2-y1))\n\n                    lastx[y1, y2] = x\n\n        return ans if ans < float(\\\"inf\\\") else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # store y coordinates at each x\n        # for each y1 y2 pairs at each x from left to right\n        # find the last x that has y1 and y2, and calculate area\n        \n        lastx = {}\n        everyx = collections.defaultdict(list)\n        min_area = math.inf\n        for x, y in points:\n            everyx[x].append(y)\n        for x in sorted(everyx):\n            everyy = sorted(everyx[x])\n            for i, y1 in enumerate(everyy):\n                for j in range(i):\n                    y2 = everyy[j]\n                    if (y1, y2) in lastx:\n                        area = abs(y2-y1) * abs(x - lastx[y1, y2])\n                        min_area = min(area, min_area)\n                    lastx[y1,y2] = x\n        return min_area if min_area < math.inf else 0\n", "from collections import defaultdict\nfrom bisect import insort\nclass Solution:\n    def minAreaRect(self, points):\n       # setr, setc = set(), set()\n       # for r, c in points:\n       #     setr.add(r)\n       #     setc.add(c)\n       # if len(points) in (len(setr), len(setc)): return 0\n        \n        points.sort()\n        columns = defaultdict(list)\n        for r, c in points:\n            insort(columns[r], c)\n        ans, lastc = float('inf'), dict()\n        for r, cols in list(columns.items()):\n            #cols = sorted(columns[r])\n            for j, y2 in enumerate(cols):\n                for i, y1 in enumerate(cols[:j]):\n                    if (y1, y2) in lastc:\n                        ans = min(ans, (r - lastc[(y1, y2)]) * (y2 - y1))\n                    lastc[(y1, y2)] = r\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if 1 in (len(set(X[0])), len(set(X[1]))): return 0\n        seen, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y):\n                    area = abs((p2x-p1x)*(p2y-p1y))\n                    if area > ans or area == 0:\n                        continue\n                    if (p1x, p2y) in seen and (p2x, p1y) in seen:\n                        ans = area\n        return ans if ans < float('inf') else 0", "\\\"\\\"\\\"\nhttps://www.youtube.com/watch?v=pFgBZFKJ2Co\nfast forward to 17minutes\n\nGroup the points by x coordinates, so that we have columns of points. Then, for every pair of points in a column (with coordinates (x,y1) and (x,y2)), check for the smallest rectangle with this pair of points as the rightmost edge. We can do this by keeping memory of what pairs of points we've seen before.\n\ncolumns = {\n    1: 1, 3\n    3: 1, 3\n    4: 1, 4\n    \n}\n\ncolumn = [1,3]\n\\\"\\\"\\\"\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if len(points) <= 3: return 0\n        columns = collections.defaultdict(list)\n        for x, y in points:\n            columns[x].append(y)\n        lastx = {}\n        ans = float('inf')\n\n        for x in sorted(columns):\n            column = columns[x]\n            column.sort()\n            for i, y2 in enumerate(column):\n                for j in range(i):\n                    y1 = column[j]\n                    if (y1, y2) in lastx:\n                        area = (x - lastx[y1,y2]) * (y2 - y1)\n                        ans = min(ans, area)\n                    lastx[y1, y2] = x\n        return ans if ans < float('inf') else 0", "from collections import defaultdict\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        result = float(\\\"inf\\\")\n        found = False\n        \n        point_by_x = defaultdict(set)\n        \n        for x, y in points:\n            point_by_x[x].add(y)\n            \n        y_pair_to_x = dict()\n        sorted_x = sorted(list(point_by_x.keys()))\n\n        for x in sorted_x:\n            y_list = sorted(list(point_by_x[x]))\n            \n            for i in range(len(y_list)):\n                for j in range(i+1, len(y_list)):\n                    v1, v2 = y_list[i], y_list[j]\n                    if (v1, v2) in y_pair_to_x:\n                        width = v2 - v1\n                        height = x - y_pair_to_x[(v1, v2)]\n                        result = min(result, width * height)\n                        found = True\n                    y_pair_to_x[(v1, v2)] = x\n                    \n        if not found:\n            return 0\n        return result\n                    \n        \n        \n        ", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        points_dict = collections.defaultdict(list)\n        for x, y in points:\n            points_dict[x].append(y)\n        points_dict = dict(sorted(list(points_dict.items()), key=lambda x:x[0]))\n        seen_ys = dict()\n        \n        result = float('inf')\n        \n        for x in list(points_dict.keys()):\n            ys = sorted(points_dict[x])\n            print((x, ys))\n            \n            for i, y2 in enumerate(ys):\n                \n                for j in range(i):\n                    y1 = ys[j]\n                \n                    if (y1, y2) in seen_ys:\n                        result = min(result, (y2-y1)*(x-seen_ys[(y1, y2)]))\n\n                    seen_ys[(y1, y2)] = x\n        return result if result < float('inf') else 0\n", "from collections import defaultdict\n\nclass Solution(object):\n    def minAreaRect(self, points):\n        x_points = defaultdict(list)\n        for x,y in points:\n            x_points[x].append(y)\n        min_area = float('inf')\n        vert_lines = {}\n        sort_by_x = sorted(x_points)\n        for x in sort_by_x:\n            y_list = x_points[x]\n            y_list.sort()\n            for i in range(len(y_list)):\n                y2 = y_list[i]\n                for j in range(i):\n                    y1 = y_list[j]\n                    if (y1,y2) in vert_lines:\n                        x2 = vert_lines[(y1,y2)]\n                        min_area = min(min_area, abs(x - x2)* abs(y1-y2))\n                    vert_lines[(y1,y2)] = x\n        return min_area if min_area != float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        collection = collections.defaultdict(list)\n        for x, y in points:\n            collection[x].append(y)\n        result = float('inf')\n        previousx = {}\n        for x in sorted(collection):\n            column = collection[x]\n            column.sort()\n            for j, y2 in enumerate(column):\n                \n                for i in range(j):\n                    \n                    y1 = column[i]\n                    if (y1, y2) in previousx:\n                        result = min(result, ((x-previousx[y1,y2]) * (y2-y1)))\n                                     \n                    previousx[y1,y2] = x\n                                    \n        if result < float('inf'):\n               return result\n        return 0\n                                \n            \n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        setr, setc = set(), set()\n        for r, c in points:\n            setr.add(r)\n            setc.add(c)\n        if len(points) in (len(setr), len(setc)): return 0\n        \n        \n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r in sorted(columns):\n            cols = sorted(columns[r])\n            for j, y2 in enumerate(cols):\n                for i, y1 in enumerate(cols[:j]):\n                    if (y1, y2) in lastc:\n                        ans = min(ans, (r - lastc[(y1, y2)]) * (y2 - y1))\n                    lastc[(y1, y2)] = r\n        return ans if ans < float('inf') else 0\n\n\n                              \nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(points) in (len(set(X[0])), len(set(X[1]))): return 0\n        seen, ans = set(map(tuple, points)), float('inf')\n        points.sort()\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in seen and (p2x, p1y) in seen:\n                    ans = area\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n        \n        seen, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y):\n                    area = abs((p2x-p1x)*(p2y-p1y))\n                    if area > ans or area == 0:\n                        continue\n                    if (p1x, p2y) in seen and (p2x, p1y) in seen:\n                        ans = area\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        def smallestinterval(l):\n            rst = float('inf')\n            for i in range(1, len(l)):\n                if l[i] - l[i-1] < rst:\n                    rst = l[i] - l[i-1]\n            return rst\n            \n        xloc = defaultdict(set)\n#        yloc = defaultdict(set())\n        for p in points:\n            xloc[p[0]].add(p[1])\n#            yloc[p[1]].add(p[0])\n        minarea = float('inf')\n        xkeys = list(xloc.keys())\n        for x1 in range(len(xkeys)):\n            for x2 in range(x1):\n                if x1 != x2:\n                    sharedy = xloc[xkeys[x1]] & xloc[xkeys[x2]]\n                    if len(sharedy)> 1:\n                        ally = list(sharedy)\n                        ally.sort()\n                        smallinterval = smallestinterval(ally)\n                        if smallinterval * abs(xkeys[x1] - xkeys[x2]) < minarea:\n                            minarea = smallinterval * abs(xkeys[x1]-xkeys[x2])\n        if minarea == float('inf'):\n            return 0\n        return minarea\n        \n", "class Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n        \n        seen, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in seen and (p2x, p1y) in seen:\n                    ans = area\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n        seen, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y):\n                    area = abs((p2x-p1x)*(p2y-p1y))\n                    if area > ans or area == 0:\n                        continue\n                    if (p1x, p2y) in seen and (p2x, p1y) in seen:\n                        ans = area\n        return ans if ans < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points):\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                if (p1x != p2x) and (p1y != p2y) and ((p1x, p2y) in pSet) and ((p2x, p1y) in pSet):\n                    ans = min(ans, abs((p1x - p2x) * (p1y - p2y)))\n        return ans if ans < float('inf') else 0\n    \nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(set(X[0])) == 1 or len(set(X[1])) == 1: return 0\n\n        pSet, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in pSet and (p2x, p1y) in pSet:\n                    ans = area\n        return ans if ans < float('inf') else 0\n    \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        def smallestinterval(l):\n            rst = float('inf')\n            for i in range(1, len(l)):\n                if l[i] - l[i-1] < rst:\n                    rst = l[i] - l[i-1]\n            return rst\n            \n        xloc = defaultdict(set)\n        for p in points:\n            xloc[p[1]].add(p[0])\n        minarea = float('inf')\n        xkeys = list(xloc.keys())\n        for x1 in range(len(xkeys)):\n            for x2 in range(x1):\n                if x1 != x2:\n                    sharedy = xloc[xkeys[x1]] & xloc[xkeys[x2]]\n                    if len(sharedy)> 1:\n                        ally = list(sharedy)\n                        ally.sort()\n                        smallinterval = smallestinterval(ally)\n                        if smallinterval * abs(xkeys[x1] - xkeys[x2]) < minarea:\n                            minarea = smallinterval * abs(xkeys[x1]-xkeys[x2])\n        if minarea == float('inf'):\n            return 0\n        return minarea\n        \n", "from collections import defaultdict\nclass Solution:\n    def minAreaRect(self, points):\n        setr, setc = set(), set()\n        for r, c in points:\n            setr.add(r)\n            setc.add(c)\n        if len(points) in (len(setr), len(setc)): return 0\n        \n        \n        columns = defaultdict(list)\n        for r, c in points:\n            columns[r].append(c)\n        ans, lastc = float('inf'), dict()\n        for r in sorted(columns):\n            cols = sorted(columns[r])\n            for j, y2 in enumerate(cols):\n                for i, y1 in enumerate(cols[:j]):\n                    if (y1, y2) in lastc:\n                        ans = min(ans, (r - lastc[(y1, y2)]) * (y2 - y1))\n                    lastc[(y1, y2)] = r\n        return ans if ans < float('inf') else 0\n\n\n                              \nclass Solution:\n    def minAreaRect(self, points):\n        X = list(zip(*points))\n        if len(points) in (len(set(X[0])), len(set(X[1]))): return 0\n        seen, ans = set(map(tuple, points)), float('inf')\n        for i, (p1x, p1y) in enumerate(points):\n            for (p2x, p2y) in points[i+1:]:\n                area = abs((p2x-p1x)*(p2y-p1y))\n                if area > ans or area == 0:\n                    continue\n                if (p1x, p2y) in seen and (p2x, p1y) in seen:\n                    ans = area\n        return ans if ans < float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        nx, ny = len(set(x for x, _ in points)), len(set(y for _, y in points))\n        \n        if nx == n or ny == n:\n            return 0\n        p = collections.defaultdict(list)\n        if nx > ny:\n            for x, y in points:\n                p[x].append(y)\n        else:\n            for x, y in points:\n                p[y].append(x)\n        \n        res = float('inf')\n        dic_last = {}\n        for x in sorted(p):\n            # print(x)\n            p[x].sort()\n            for y1, y2 in itertools.combinations(p[x], 2):\n                if (y1, y2) in dic_last:\n                    res = min(res, abs( x - dic_last[y1, y2]) * abs(y1 -y2))\n                    # if res == 2:\n                    #     print(x, dic_last[y1, y2],  y1, y2)\n                dic_last[y1, y2] = x\n        return res if res < float('inf') else 0\n        \n        # n = len(points)\n        # nx, ny = len(set(x for x, y in points)), len(set(y for x, y in points))\n        # if nx == n or ny == n:\n        #     return 0\n        \n        # p = collections.defaultdict(list)\n        # if nx > ny:\n        #     for x, y in points:\n        #         p[x].append(y)\n        # else:\n        #     for x, y in points:\n        #         p[y].append(x)\n        # res = float('inf')\n        # dic = {}\n        # for x in sorted(p):\n        #     p[x].sort()\n        #     for y1, y2 in itertools.combinations(p[x], 2):\n        #         if (y1, y2) in dic:\n        #             res = min(res, abs(x - dic[y1, y2]) * abs(y1 - y2) )\n        #         dic[y1, y2] = x\n        # return res if res < float('inf') else 0\n#         dic_x = {}\n        \n#         n = len(points)\n#         nx, ny = len( set(x for x, y in points) ), len( set(y for x, y in points) )\n#         if nx == n or ny == n:\n#             return 0\n        \n#         p = collections.defaultdict(list)\n#         if nx > ny:\n#             for x, y in points:\n#                 p[x].append(y)\n#         else:\n#             for x, y in points:\n#                 p[y].append(x)\n#         res = float('inf')\n#         for x in sorted(p):\n#             p[x].sort()\n            \n#             for y1, y2 in itertools.combinations(p[x], 2):\n#                 # y1, y2 = p[x][i], p[x][j]\n#                 if (y1, y2) in dic_x:\n#                     res = min(res, abs(x - dic_x[y1, y2]) * abs(y1 -y2))\n#                 dic_x[y1, y2] = x\n#         return res if res < float('inf') else 0\n#         seen = set()\n        \n#         res = float('inf')\n#         for x1, y1 in points:\n#             for x2, y2 in seen:\n#                 if (x1, y2) in seen and (x2, y1) in seen:\n#                     area = abs(x1 - x2) * abs(y1 - y2)\n#                     if area and res > area:\n#                         res = area\n#                     # res = min(res, )\n#             seen.add((x1, y1))\n#         return res if res < float('inf') else 0\n", "from collections import defaultdict\n\nclass Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n < 4:\n            return 0\n        \n        d = defaultdict(set)\n        for (x, y) in points:\n            d[x].add(y)\n                \n        xs = sorted(d.keys())\n        # print(d, xs)\n        ans = float('inf')    \n        \n        exist = False\n        for i in range(len(xs) - 1):\n            x1 = xs[i]\n            ys1 = d[x1]\n            for j in range(i+1, len(xs)):\n                x2 = xs[j]\n                ys2 = d[x2]\n                ys = sorted(ys1 & ys2)\n                # print(x1, x2, ys)\n                if len(ys) >= 2:\n                    exist = True\n                    minHeight = ys[1] - ys[0]\n                    for j in range(2, len(ys)):\n                        minHeight = min(minHeight, ys[j] - ys[j-1])\n                    ans = min(ans, minHeight * (x2-x1))\n            \n        return 0 if not exist else ans", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        columns = collections.defaultdict(list)\n        res = float('inf')\n        \n        for x,y in points:\n            columns[x].append(y)\n        y_pairs = dict()\n        for x in sorted(columns):\n            ys = sorted(columns[x])\n            # print('ys',ys,x)\n            for i in range(len(ys)-1):\n                for j in range(i+1,len(ys)):\n                    if (ys[i], ys[j]) in y_pairs:\n                        res = min(res, (x - y_pairs[(ys[i], ys[j])]) * (ys[j] - ys[i]))\n                    y_pairs[(ys[i],ys[j])] = x\n        return res if res != float('inf') else 0\n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \n        x_to_ys = collections.defaultdict(set)\n        for px, py in points:\n            x_to_ys[px].add(py)\n            \n        min_area = float(\\\"inf\\\")\n        xs = sorted(list(x_to_ys.keys()))\n        for i, x1 in enumerate(xs):\n            for j in range(i+1, len(xs)):\n                x2 = xs[j]\n                if x2-x1>min_area:\n                    break\n                common_ys = x_to_ys[x1] & x_to_ys[x2]\n                if len(common_ys)>=2:\n                    common_ys = sorted(list(common_ys))\n                    min_y_diff = min(y-common_ys[iy] \n                                     for iy, y in enumerate(common_ys[1:]))\n                    min_area = min(min_area, min_y_diff*(x2-x1))\n                \n        if min_area==float(\\\"inf\\\"):\n            return 0\n        else:\n            return min_area", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        res = float('inf')\n        xs, ys = collections.defaultdict(set), collections.defaultdict(set)\n        for x1, y1 in points:\n            for x2 in xs[y1]:\n                for y2 in ys[x1]:\n                    if x2 in xs[y2]:\n                        res = min(res, abs(x2 - x1) * abs(y2 - y1))\n            xs[y1].add(x1)\n            ys[x1].add(y1)\n        return res if res < float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        result = float('inf')\n        columns = collections.defaultdict(lambda: [])\n        for x, y in points:\n            columns[x].append(y)\n            \n        print('columns is: ' + str(columns))\n            \n        # Map from (y1, y2) pair to x\n        lastSeen = {}\n        for x in sorted(columns.keys()):\n            column = sorted(columns[x])\n            for i in range(len(column)):\n                y1 = column[i]\n                for j in range(i+1, len(column)):\n                    if y1 != column[j]:\n                        y2 = column[j]\n                        if (y1, y2) in lastSeen:\n                            prev_x = lastSeen[(y1, y2)]\n                            result = min(result, (y2-y1)*(x-prev_x))\n                        lastSeen[(y1, y2)] = x\n        return 0 if result == float('inf') else result", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        if not points:\n            return 0\n        \n        x_map= {}\n        points.sort(key=lambda x: x)\n        area = float('inf')\n        \n        y_map = {}\n        \n        for point in points:\n            if point[0] in x_map:\n                x_map[point[0]].append(point[1])\n                continue\n            x_map[point[0]] = [point[1]]\n            \n        for x in x_map:\n            x_map[x].sort()\n            for j in range(0, len(x_map[x])):\n                y2 = x_map[x][j]\n                for k in range(0, j):\n                    y1 =x_map[x][k]\n                    if (y1, y2) in y_map:\n                        area = min(area, (y2-y1) * (x - y_map[(y1, y2)]))\n                    y_map[(y1, y2)] = x\n        return area if area!=float('inf') else 0\n                    \n                \n        \n        \n", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        | x   x x\n        |   x x x\n        | x   x    x1:y1,y3\n        |________  x2:y2\n                   x3:y1,y2,y3\n                   x4:y2,y3\n        \\\"\\\"\\\"\n        minarea=float('inf')\n        d = defaultdict(set)\n        for x,y in points:\n            d[x].add(y)\n        sortx=sorted(d)\n        \n        #print(d)\n        for i in range(len(sortx)):\n            for j in range(i+1, len(sortx)):\n                ys= d[sortx[i]] & d[sortx[j]]\n                if len(ys)>1:\n                    ylist = list(ys)\n                    ylist.sort()\n                    ylen =min([abs(ii-jj) for ii, jj in zip(ylist, ylist[1:])])\n                    \n                    minarea = min(minarea, abs(sortx[i]-sortx[j])*ylen)\n                \n        return minarea if minarea!=float('inf') else 0", "class Solution:\n    def minAreaRect(self, points: List[List[int]]) -> int:\n        # [[1,1],[2,2],[1,3],[3,1],[3,3],[4,1],[4,3]]\n        # vsides = {1: [1,3], 2:[2], 3:[1, 3], 4:[1,3]}\n        # slengths = {(1,3):1}\n        vsides = dict()\n        for x, y in points:\n            if x in vsides:\n                vsides[x].append(y)\n            else:\n                vsides[x] = [y]\n        slengths = dict()\n        min_area = float('inf')\n        xs = list(vsides.keys())\n        xs.sort()\n        for x in xs:\n            vs = vsides[x]\n            vs.sort()\n            for i in range(len(vs) - 1):\n                for j in range(i + 1, len(vs)):\n                    if (vs[i], vs[j]) in slengths:\n                        area = abs( (x - slengths[(vs[i], vs[j])]) * (vs[j] - vs[i]) )\n                        min_area = min(min_area, area)\n                    slengths[(vs[i], vs[j])] = x\n        return min_area if min_area != float('inf') else 0"]
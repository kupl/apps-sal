["class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        # max profit ending at time t\n        dp = [(0,0)]\n        \n        task = [(startTime[i], endTime[i], profit[i]) for i in range(len(startTime))]\n        task = sorted(task, key = lambda x: x[1])\n        \n        for s, e, p in task:\n            noTaskProf = dp[-1][1]\n            for end, pro in reversed(dp):\n                # end, pro = dp[i]\n                if end <= s:\n                    doTaskProf = pro + p\n                    break\n            if doTaskProf > noTaskProf:\n                dp.append((e, doTaskProf))\n        return dp[-1][1]\n        \n        \n        \n", "from heapq import *\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = sorted(zip(startTime, endTime, profit))\n        heap = []\n        max_profit = 0\n        \n        for start, end, p in jobs:\n            while heap and heap[0][0] <= start:\n                max_profit = max(max_profit, heappop(heap)[1])\n            heappush(heap, (end, max_profit + p))\n        \n        for _, p in heap:\n            max_profit = max(max_profit, p)\n        return max_profit\n            \n        \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        # TLE\n        # jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])\n        # dp = defaultdict(int)\n        # dp[0] = 0\n        # #find the max profit before time i\n        # def find(i):\n        #     tmp = []\n        #     for time in dp:\n        #         if time<=i:\n        #             tmp.append(dp[time])\n        #     return max(tmp)\n        # for s, e, p in jobs:\n        #     dp[e] = max(find(e),find(s)+p)\n        # return max(list(dp.values()))\n        \n        jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])\n        # time 0: profit 0\n        dp = [(0,0)]\n        \n        #find the max profit before time i\n        def find(time):\n            size = len(dp)\n            for i in range(size-1,-1,-1):\n                pre_time = dp[i][0]\n                if pre_time<=time:\n                    return dp[i][1]\n            \n        for s, e, p in jobs:\n            dp.append((e,max(find(e),find(s)+p)))\n            \n        return dp[-1][1]\n\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        dp = [0]*(len(profit))\n        intervals = [(startTime[i], endTime[i], profit[i]) for i in range(len(startTime))]\n        intervals.sort(key=lambda x: x[1])\n        dp[0] = intervals[0][2]\n        for j in range(1, len(dp)):\n            dp[j]=max(intervals[j][2], dp[j-1])\n            l=0;r=len(intervals)-1\n            while(l<r):\n                mid=l+((r-l+1)>>1)\n                if(intervals[mid][1]<=intervals[j][0]):\n                    l=mid\n                else:\n                    r=mid-1\n            if(intervals[j][0]>=intervals[l][1]):\n                dp[j]=max(dp[j], intervals[j][2]+dp[l])\n        return dp[-1]", "class Solution:\n    def binSearch(self, stack: List[int], target: int) -> List[int]:\n        left = 0\n        right = len(stack) - 1\n        #[1,2,3] target= 4\n        while left <= right:\n            mid = (left + right + 1) // 2\n            if stack[mid][1] > target:\n                right = mid - 1\n            elif stack[mid][1] == target or left == right and stack[mid][1] < target:\n                return stack[mid]\n            else:\n                left = mid\n        return None\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n = len(startTime)\n        jobs = [[startTime[i], endTime[i], profit[i]] for i in range(n)]\n        jobs.sort(key = lambda x : x[1])\n        stack = []\n        for i in range(n):\n            job = jobs[i]\n            prev = self.binSearch(stack, job[0])\n            if prev is not None:\n                job[2] += prev[2]\n            if not stack or stack[-1][2] < job[2]:\n                stack.append(job)\n        return stack[-1][2]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        '''\n        diff from max intervals. \n        Sort by Start Time (dont do the greedy sort by earliest finish time)\n        Choose it or dont. \n        Always choose it if it doesnt interfere with the next one. \n        you can binary search the end time in the start times to find the next available start times you can take. \n        \n        Have 3 solutions.\n        '''\n       \n        # sort by start times\n        res = sorted(zip(startTime, endTime, profit), key=lambda x: x[0])\n        # unzip it now!\n        unzipped_res = list(zip(*res))\n        startTime = unzipped_res[0]\n        endTime = unzipped_res[1]\n        profit = unzipped_res[2]\n        \n        #return self.topDown(startTime, endTime, profit)\n        return self.backwardDP(startTime, endTime, profit)\n        # return self.forwardDP(startTime, endTime, profit)\n    \n    # TOP DOWN COMPLETED.\n    def topDown(self, startTime, endTime, profit):\n        N = len(startTime)\n        \n        # Only memoizing one param\n        '''\n        Thought I would need to do the other params like \n        endTime or maxProfit but dont have to because \n        parent call does not have to communicate to child recursive calls\n        to help child recursive calls to achieve max. Since we\n        dont need parent-child communication, we can get away with \n        passing very little info to child through its function params.\n        '''\n        @lru_cache(None)\n        def solve(i):\n            \n            if i == N:\n                return 0\n            \n            # either take or dont\n            start = startTime[i]\n            end = endTime[i]\n            \n            # you can skip to the index that has a start time ahead of \n            # end time -> so that you dont have to \n            # pass along endtime in memtable? \n            \n            nextI = N\n            \n            # CAN USE BINARY SEARCH HERE!\n            for j in range(i+1, N):\n                if startTime[j] >= end:\n                    nextI = j\n                    break\n                    \n            prof = profit[i]\n            \n            # take it\n            taken = solve(nextI) + profit[i]\n            \n            # dont take:\n            notTaken = solve(i+1)\n            # print(\\\"nextI, TAKEN AND NOT TAKEN ARE\\\", i,nextI, taken, notTaken)\n            return max(taken, notTaken)\n        \n        amt = solve(0)\n        return amt\n            \n    def backwardDP(self, startTime, endTime, profit):      \n        from bisect import bisect_left\n        \n        # Bottom Up.\n        '''\n        \n        So the states I need is \n        max profit achieved at each index. \n        then we binary search to the right an index we can use to include\n        in our max profit!\n        \n        and process backwards like that!\n        \n        OPT[i] = max(Take, DontTake)\n                    OPT[i`] + profit[i], OPT[i-1]\n                    \n        \n        '''\n        N = len(startTime)\n        OPT = [0 for i in range(N+1)]\n        \n        for i in range(N-1, -1, -1):\n            \n            start = startTime[i]\n            end = endTime[i]\n            prof = profit[i]\n            \n            # Take operation\n            # find the end index!\n            \n            # endI = bisect_left(end, startTime)\n            # if endI < \n            freeK = N\n            '''\n            Linear search that leads to O(N^2)\n            for k in range(i+1, N):\n                if end <= startTime[k]:\n                    freeK = k\n                    break    \n            '''\n            # Has to be bisect_left not bisect_right!\n            freeK = bisect_left(startTime, end)\n            take = profit[i] + OPT[freeK]\n            dontTake = OPT[i+1]\n            OPT[i] = max(take, dontTake)\n        return OPT[0]\n    \n    # COULD NOT DO FORWARD VERY HARD!\n    def forwardDP(self, startTime, endTime, profit):\n        '''\n        Ok look at idx 0\n            -> Is there a way to do it NlogN?\n            -> find all intervals to right that dont intersect with us!\n            -> add it in. \n            \n        Is this the brute force solution or what does the brute force \n        solution look like?\n\n        Actaully this one is very difficult\n        '''\n        N = len(startTime)\n        OPT = [profit[i] for i in range(N)]\n        \n        for i in range(N):\n            # find all intervals ahead of us! \n            # and add us in.\n            \n            prof = profit[i]\n            end = endTime[i]\n            \n            x = bisect_left(startTime, end)\n            for k in range(x, N):\n                OPT[k] += prof\n        \n        return OPT[-1]\n    \n                        \n            \n            \n            \n            \n        \n            \n            \n        \n        \n         \n    \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    \n            \n            \n        \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        # sort intervals by their endTime\n        intervals = sorted(zip(startTime, endTime, profit), key=lambda x: (x[1], x[2]))\n        N = len(profit)\n        # bottom up solutions: (profit, endtime, index)\n        dp = [(0, 0, 0)]\n        \n        for idx, (s, e, p) in enumerate(intervals):\n            nonoverlapping_idx = self.find_nonoverlapping_interval(dp, s + 0.1)\n            # print(idx, nonoverlapping_idx, s)\n            if dp[nonoverlapping_idx][0] + p > dp[idx-1+1][0]:\n                dp.append((dp[nonoverlapping_idx][0] + p, e, idx))\n            else:\n                dp.append(dp[idx-1+1])\n        \n        # print(dp)\n        solutions = []\n        cur_idx = N\n        while cur_idx != 0:\n            solutions.append(cur_idx)\n            solution = self.find_nonoverlapping_interval(dp, intervals[dp[cur_idx][2]][0])\n            cur_idx = dp[solution][2]\n            solutions.append(cur_idx)\n        print(solutions)\n        \n        return dp[-1][0]\n    \n    def find_nonoverlapping_interval(self, dp, start):\n        l_idx = 0\n        r_idx = len(dp) - 1\n        \n        # print(dp, l_idx, r_idx, start)\n        \n        # using binary search\n        while r_idx >= 0 and l_idx < len(dp) and l_idx <= r_idx:\n            mid_idx = (l_idx + r_idx) // 2\n            if dp[mid_idx][1] < start:\n                l_idx = mid_idx + 1\n            else:\n                r_idx = mid_idx - 1\n        \n        # print(dp, l_idx, r_idx, start)\n        \n        return l_idx - 1\n", "from collections import defaultdict\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        times = sorted(zip(startTime, endTime, profit), key= lambda x: x[1])\n        \n        n = len(endTime)\n        dp = [(0, 0)]\n        \n        def bsearch(arr, target):\n            start, end = 0, len(arr) - 1\n            while start < end:\n                mid = (end - start) // 2 + start\n                if arr[mid][0] == target:\n                    return mid\n                elif arr[mid][0] > target:\n                    end = mid - 1\n                else:\n                    start = mid + 1\n            return start if target >= arr[start][0] else start - 1\n        \n        for i in range(1, n+1):\n            start, end, p = times[i-1]\n            last_start = bsearch(dp, start)\n            if len(dp) > last_start >= 0:\n                dp.append((end, max(dp[last_start][1] + p, dp[-1][1])))\n            else:\n                dp.append((end, p))\n        #     print(dp, last_start, start)\n        # print(dp)\n        return dp[n][1]\n                \n            \n        \n", "class Solution:\n    def binsearch(self, arr, ele, l, r):\n        while (r-l>1):\n            mid = l + (r-l)//2 \n            if arr[mid][1]==ele:\n                return mid\n            elif arr[mid][1]>ele:\n                r=mid \n            else: \n                l=mid \n            \n        return(l)\n                \n        \n        \n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n=len(startTime)\n        dp=[0]*n\n        times = []\n        for i in range(n):\n            times.append([startTime[i], endTime[i], profit[i]])\n            \n        \n        times.sort(key = lambda it:it[1])\n        #print(times)\n        \n        dp[0]=times[0][2]\n        \n        for i in range(1,n):\n            prof = times[i][2]\n            binInd = self.binsearch(times, times[i][0], -1, i)\n            #print(binInd)\n            if binInd!=-1:\n                prof+=dp[binInd]\n            \n            dp[i]=max(dp[i-1], prof)\n        \n        return dp[n-1]\n        \n        \n        \n        \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])\n        dp = [0 for j in range(len(jobs))]\n        \n        for i in range(len(jobs)):\n            if i == 0:\n                inc_n = 0\n            else:\n                inc_n = dp[i-1]\n            \n            ind = self.find(jobs, jobs[i][0])\n            if ind == -1:\n                inc = jobs[i][2]\n            else:\n                inc = dp[ind] + jobs[i][2]\n            dp[i] = max(inc, inc_n)\n            \n        print(dp)\n        return dp[-1]\n    \n    def find(self, arr, val):\n        l = 0\n        r = len(arr) - 1\n        ans = -1\n        while l <= r:\n            m = (l + r) // 2\n            if arr[m][1] > val:\n                r = m - 1\n            else:\n                ans = m\n                l = m + 1\n                \n        return ans\n                \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        '''\n        Refer to Eva Tardos's 'Algorithm Design' - 6.1 Weighted Interval Scheduling\n        \n        First post in the discuss section explains the same approach\n        \n        Steps\n        ------\n        1. Sort and order jobs by the end time - O(n logn)\n        \n        2. Build a most_recent array with most_recent[j] being the index of the most recent disjoint job - O(n logn)\n           ** use binary search to build this array ** \n           \n        3. Calculate profit for each position using the relation - O(n)\n           ** dp_profits[j] = max(profits[j] + dp_profits[previous[j]], dp_profits[j-1]) **\n        '''\n        \n        # zip and order jobs by end time\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n        \n        '''\n        for each job in jobs find the most recent disjoint\n        this is nothing but finding the index of the floor of each start time in the sorted end times\n        i.e. for each start time, finding the index of greatest end time less than or equal to start time\n        \n        if the floor is not present the value returned would be -1\n        '''\n        def binary_search(val: int):\n            '''\n            Try doing a dry run with test cases before implementing\n            \n            Always choose one test value in the left of mid, one in the right and one for each boundar condition.\n            Refer to vscode playground floor.py\n            '''\n            nonlocal jobs\n            \n            # boundary conditions - note job = (start_time, end_time, profit)\n            if val < jobs[0][1]:\n                return -1\n            if val >= jobs[-1][1]:\n                return len(jobs) - 1\n            \n            start, end = 0, len(jobs) - 1\n            \n            while start < end - 1:\n                mid = start + (end - start) // 2\n                \n                if jobs[mid][1] < val:\n                    start = mid\n                elif jobs[mid][1] > val:\n                    end = mid -1\n                else:\n                    return mid\n            \n            return end if jobs[end][1] <= val else start\n        \n        most_recent = [0] * len(jobs)\n        \n        for i, job in enumerate(jobs):\n            most_recent[i] = binary_search(job[0])\n        \n        '''\n        Calculate profit for each job using recurrence relation and return the last value.\n        \n        \n        '''\n        dp_profits = [0] * len(jobs)\n        for i, job in enumerate(jobs):\n            most_recents_profit = 0 if most_recent[i] == -1 else dp_profits[most_recent[i]]\n            prev_profit = 0 if i == 0 else dp_profits[i-1]\n            \n            dp_profits[i] = max(job[2] + most_recents_profit, prev_profit)\n        \n        return dp_profits[-1]", "import collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\n\n'''\nn\u4efd\u5de5\u4f5c\u85aa\u6c34\u4e0d\u540c\uff0c\u5f00\u59cb\u65f6\u95f4\u548c\u7ed3\u675f\u65f6\u95f4\u4e0d\u540c\uff0c\u627e\u5230\u6700\u5927\u7684\u6536\u76ca\uff0c\u65f6\u95f4\u4e0d\u80fd\u51b2\u7a81\u3002\n\n\u80cc\u5305\u95ee\u9898\uff0c\u5de5\u4f5c\u53ef\u4ee5\u505a\u6216\u8005\u4e0d\u505a\uff0c\u505a\u65f6\u9009\u62e9\u4e0b\u4e00\u4e2a\u4e0d\u51b2\u7a81\u7684\u5de5\u4f5c\u7ee7\u7eed\u3002\n'''\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        def dfs_func():\n            n = len(profit)\n            dp = {}\n            jobs = [(startTime[i], endTime[i], profit[i]) for i in range(n)]\n            jobs.sort()\n\n            def find_next_confict(jobs_i):\n                for jobs_j in range(jobs_i + 1, n):\n                    if jobs[jobs_i][1] <= jobs[jobs_j][0]:\n                        return jobs_j\n                return n\n\n            # \u4e8c\u5206\u52a0\u901f\n            def find_next_confict_left(jobs_i):\n                dst = jobs[jobs_i][1]\n                left = jobs_i\n                right = n\n                while left < right:\n                    mid = int((left + right) / 2)\n                    mid_value = jobs[mid][0]\n                    if dst < mid_value:\n                        right = mid\n                    elif dst > mid_value:\n                        left = mid + 1\n                    else:\n                        right = mid\n                return left\n\n            def dfs(jobs_i):\n                if jobs_i >= n:\n                    return 0\n                if jobs_i in dp:\n                    return dp[jobs_i]\n                s, e, p = jobs[jobs_i]\n                jobs_j = find_next_confict_left(jobs_i)\n                choose = p\n                if jobs_j < n:\n                    choose += dfs(jobs_j)\n                not_choose = dfs(jobs_i + 1)\n                dp[jobs_i] = max(choose, not_choose)\n                return dp[jobs_i]\n\n            return dfs(0)\n\n        def dp_func():\n            # dp[end] = max(dp[end-1],dp[last_not_conflict] + profit))\n            # end\u6709\u591a\u4e2a\uff0c\u7528\u5750\u6807\u4ee3\u66ff\n            # sort(end)\n            # dp[i] = max(dp[i-1],dp[last_not_conflict] + profit))\n\n            # \u4e8c\u5206\u52a0\u901f\n\n            n = len(profit)\n            jobs = [(endTime[i], startTime[i], profit[i]) for i in range(n)]\n            jobs.sort()\n            dp = [0 for _ in range(n + 1)]\n\n            # \u53f3\u8fb9\u754c\n            def find_pre_not_confict(jobs_i):\n                dst = jobs[jobs_i][1]\n                left = 0\n                right = jobs_i\n                while left < right:\n                    mid = int((left + right) / 2)\n                    mid_value = jobs[mid][0]\n                    if dst < mid_value:\n                        right = mid\n                    elif dst > mid_value:\n                        left = mid + 1\n                    else:\n                        left = mid + 1\n                return left - 1\n\n            def find_pre_not_confict1(jobs_i):\n                for i in range(jobs_i, -1, -1):\n                    if jobs[jobs_i][1] >= jobs[i][0]:\n                        return i\n                return -1\n\n            for i in range(1, n + 1):\n                last_not_conflict = find_pre_not_confict(i-1)\n                choose = jobs[i - 1][2]\n                # \u518d\u5224\u65ad\u4e00\u6b21\uff0c\u9632\u6b620\n                if last_not_conflict != -1:\n                    choose += dp[last_not_conflict + 1]\n                dp[i] = max(dp[i - 1], choose)\n            return dp[n]\n        return dp_func()", "class Solution:\n    def jobScheduling(self, S: List[int], E: List[int], profit: List[int]) -> int:\n        n=len(S)\n        jobs=sorted([(S[i],E[i],profit[i]) for i in range(n)],key=lambda x:x[1])\n        S=[jobs[i][0] for i in range(n)]\n        E=[jobs[i][1] for i in range(n)]\n        profit=[jobs[i][2] for i in range(n)]\n        dp=[-1]*n\n        \n        dp[0]=profit[0],E[0]\n        \n        for i in range(1,n):\n            \n            prev_profit,endTime=dp[i-1]\n            startTime=S[i]\n            left=0\n            right=i-1\n            ans=profit[i]\n            while left<=right:\n                mid=(left+right)//2\n                if dp[mid][1]<=startTime:\n                    ans=max(ans,profit[i]+dp[mid][0])\n                    left=mid+1\n                else:\n                    right=mid-1\n            if ans>prev_profit:\n                dp[i]=ans,E[i]\n            else:\n                dp[i]=dp[i-1]\n                \n        return max([ele[0] for ele in dp])", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n = len(startTime)\n        jobs = list(zip(endTime, startTime, profit))\n        jobs.sort()\n\n        def binary_search(jobs, i):\n            left = 0\n            right = i-1\n            while left <= right:\n                mid = (left + right)//2\n                if jobs[mid][0] <= jobs[i][1]:\n                    if jobs[mid+1][0] <= jobs[i][1]:\n                        left = mid+1\n                    else:\n                        return mid\n                else:\n                    right = mid-1\n            return -1\n        \n        dp = [0] * n\n        dp[0] = jobs[0][2]\n        for i in range(1,n):\n            k = binary_search(jobs, i)\n            if k != -1:\n                dp[i] = max(dp[k] + jobs[i][2], dp[i-1])\n            else:\n                dp[i] = max(jobs[i][2], dp[i-1])\n        return dp[n-1]    \n", "# from heapq import heappush, heappop\nfrom sortedcontainers import SortedList\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        # sort by the starting times\n        lst = sorted(zip(startTime, endTime, profit))\n        maxprofit, tempstck = 0, SortedList()\n        # tempstck -> [(profitval, -endtime)]\n        # maxheap -> -maxprofit\n        for i in range(len(lst)):\n            curr_strt, curr_end, curr_price = lst[i]\n            while tempstck and -tempstck[-1][0] <= curr_strt:\n                # pop and insert into max heap\n                maxprofit = max(tempstck.pop()[1], maxprofit)\n            # now do dp\n            curr_maxprofit = maxprofit + curr_price\n            tempstck.add((-curr_end, curr_maxprofit))\n            # don't update maxprofit now because we are not sure whether the next starting price would be greater than current ending price which\n            # is why we add it to the temp stack to process it later\n        return max(maxprofit, *(i[1] for i in tempstck))", "#[Runtime: 584 ms, faster than 74.95%] DP, BinarySearch\n#O(NlogN)\n#sort by endtime, iterate each job from earlier-end to latest-end\n#f(i): the maximum profit if we can take job[0~i]\n#f(-1) = 0\n#f(i) = max{ f(i-1), f(j) + profit[i] } for first j s.t. endTime[j] <= startTime[i]\nfrom bisect import bisect_right\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        pair, N = sorted(enumerate(endTime), key=lambda tup: tup[1]), len(endTime)\n        endTime, startTime, profit = [e for _, e in pair], [startTime[i] for i, _ in pair], [profit[i] for i, _ in pair]\n        dp = [0] * (N + 1)\n        for i, s in enumerate(startTime):\n            j = bisect_right(endTime, s, 0, i) - 1 #search in endTime[0~i-1]\n            dp[i] = max(dp[i-1], dp[j] + profit[i]) #j=-1 if not found, and dp[-1] is 0\n        return dp[N-1]", "\nclass Solution:       \n    def findPreviousJob(self, jobs, curIdx):\n        low = 0\n        high = curIdx - 1\n        while (low < high):\n            mid = low + (high-low+1)//2\n            if jobs[mid].end <= jobs[curIdx].start:\n                low = mid\n            else:\n                high = mid - 1\n        return low\n\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = []\n        for i in range(len(profit)):\n            job = Job(startTime[i], endTime[i], profit[i])\n            jobs.append(job)\n        jobs.sort(key=lambda x:x.end)\n        # for job in jobs:\n            # print(job.start, ', ', job.end, ', ', job.profit)\n        dp = [0] * len(jobs)\n        dp[0] = jobs[0].profit\n        for i in range(1, len(jobs)):\n            dp[i] = jobs[i].profit\n            # find the job whose end time is smaller than job i's start time\n            index = self.findPreviousJob(jobs, i)\n            if jobs[index].end <= jobs[i].start:\n                dp[i] += dp[index]\n            '''\n            index = -1\n            for j in range(i):\n                if jobs[j].end <= jobs[i].start:\n                    index = j\n                else:\n                    break\n            if index >= 0:\n                dp[i] = dp[index] + dp[i]\n            '''\n            dp[i] = max(dp[i-1], dp[i])\n            # print(dp)\n        return dp[len(jobs)-1]\n            \nclass Job:\n    def __init__(self, start, end, profit):\n        self.start = start\n        self.end = end\n        self.profit = profit\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n       # (1,3,50),(2,4,10),(3,5,40),(3,6,70)\n        \n        \n        \n        l=[(startTime[i],endTime[i],profit[i])  for i in range(len(startTime))]\n        \n        l=sorted(l,key=lambda x: x[1])\n        ma=0\n        \n        def binarysearch(x):\n            \n            left=0\n            right=x\n            while left<right:\n                mid=(left+right)//2\n                if l[mid][1]<=l[x][0]:\n                    if l[mid+1][1]<=l[x][0]:\n                        left=mid+1\n                    else:\n                        return mid\n                    \n                else:\n                    right=mid-1\n            return left\n            \n            \n        dp=[0]*len(startTime)\n        for i in range(len(startTime)):\n            dp[i]=max(dp[i-1],l[i][2])\n            #print(dp)\n            p=binarysearch(i)\n            #print(p)\n            #for j in range(i):\n            if l[p][1]<=l[i][0]:\n                dp[i]=max(dp[i],dp[p]+l[i][2])\n              #  else:\n               #     break\n           # print(dp)\n        #    ma=max(ma,dp[i])\n       # print(dp)\n        return dp[-1]\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        '''\n            take timeslot list: [(s1,f1)...(si, fi)]\n            sort by finish time, build dp array\n            dp[0] = 0\n            dp[i] = max(take i, dont take i)\n                  = max(first non overlapping j -> dp[j] + profit[i], dp[i-1]) \n                  \n            startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n            \n            \n            timeslots [(0, 1, 3) (1, 2, 4) (2, 3, 5) (3, 3, 6)]\n            dp [0, 50, 50, 90, 120]\n        \n        '''\n        def bisect(arr, num, l, r):\n            if l >= r: return l\n            mid = (l+r+1)//2\n            if arr[mid][2] > num: return bisect(arr, num, l, mid-1)\n            else: return bisect(arr, num, mid, r)\n        \n        n = len(startTime)\n        timeslots = [(profit[i], startTime[i], endTime[i]) for i in range(n)]\n        timeslots = sorted(timeslots, key=lambda a: a[2])\n        dp = [0] * (n + 1)\n        for i, (p, s, e) in enumerate(timeslots):\n            j = bisect(timeslots, s, -1, n-1) + 1\n            dp[i+1] = max(dp[j] + p, dp[i])\n        \n        return dp[-1]", "\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        n = len(startTime)\n        jobs = [(startTime[i], endTime[i], profit[i]) for i in range(n)]\n        jobs.sort(key=lambda x: x[1])\n        dp = [0] * (n+1)\n       \n        for i in range(n):\n            dp[i+1] = dp[i]\n            l = 0\n            r = i-1\n            while l <= r:\n                mid = (l+r) // 2\n                if jobs[mid][1] <= jobs[i][0]:\n                    l = mid + 1\n                else:\n                    r = mid - 1 \n            dp[i+1] = max(dp[i+1], dp[l]+jobs[i][2])\n        return dp[n]\n    \n    \n        \n            \n            \n", "import bisect\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        dp=[[0,0]]\n        curinfo=sorted(list(zip(startTime,endTime,profit)),key=lambda x:x[1])\n        for s,e,p in curinfo:\n            i=bisect.bisect_right(dp,[s+1])-1\n            if dp[i][1]+p>dp[-1][1]:\n         \n                dp.append([e,dp[i][1]+p])\n\n        return dp[-1][1]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        events = []\n        for i, (start, end) in enumerate(zip(startTime, endTime)):\n            events.append((start, i + 1))\n            events.append((end, -(i + 1)))\n        \n        best = 0\n        for _, idx in sorted(events):\n            if idx > 0:\n                profit[idx - 1] += best\n            else:\n                best = max(best, profit[-idx - 1])\n        return best\n", "from functools import lru_cache\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs=[(startTime[i],endTime[i],profit[i]) for i in range(len(startTime))]\n        jobs=sorted(jobs)\n        \n        @lru_cache(maxsize=None)\n        def dp(i):\n            if i>=len(jobs): return 0\n            if i==len(jobs)-1: return jobs[-1][2]\n            l,r=i+1,len(jobs)-1\n            j=l\n            while l<=r:\n                m=(l+r)//2\n                if jobs[m][0]<jobs[i][1]:\n                    l=m+1\n                    j=max(j,m+1)\n                elif jobs[m][0]==jobs[i][1]:\n                    r=m-1\n                    j=m\n                else:\n                    r=m-1\n                    j=m\n            return max(jobs[i][2]+dp(j),dp(i+1))\n        \n        return dp(0)\n                    \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        #\u7528\u7a7a\u95f4\u5b58\u5728startTime\u5f00\u59cb\u524d\u6700\u5927\u7684profit\n        #\u50cf\u627e\u96f6\u94b1\u4e00\u6837\u5199\u7684\u8bdd\uff0c\u4f1a\u5f88\u6162\n#         jobs = []\n#         for i in range(len(startTime)):\n#             jobs.append([startTime[i], endTime[i], profit[i]])\n#         jobs.sort(key = lambda x:x[1])\n        \n#         dict1 = {}\n#         for job in jobs:\n#             if job[1] not in dict1:\n#                 dict1[job[1]] = [job]\n#             else:\n#                 dict1[job[1]].append(job)\n#         tail = jobs[-1][1]\n#         dp = [0 for _ in range(tail + 1)]\n        \n#         for i in range(1, len(dp)):\n#             dp[i] = dp[i-1]\n#             if i in dict1:\n#                 for job in dict1[i]:\n#                     startTime = job[0]\n#                     dp[i] = max(dp[i], dp[startTime] + job[2])\n#         #print(dp)\n#         return dp[-1]\n\n        #\u56e0\u4e3a\u4ec5\u6709\u505a\u51b3\u5b9a\u7684\u70b9\u6709\u7528\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u628a\u6240\u6709\u7684\u70b9\u53d6\u4e0b\u6765\uff0c\u4ec5\u9700\u8981\u5b58\u6bcf\u6b21\u505a\u51b3\u5b9a\u4ea7\u751f\u7684\u6700\u5927\u503c\n        #\u5c31\u50cf\u627e\u96f6\u94b1\uff0c\u6bcf\u6b21\u505a\u51b3\u5b9a\u7684\u65f6\u5019\uff0c\u627edp[cur - value]\n        #\u4f46\u662f\u56e0\u4e3a\u6211\u4eec\u53ea\u5b58\u4e86\u7a00\u758f\u7684\u94fe\u8868\u7ed3\u6784\uff0c\u9700\u8981\u5728\u5b58\u7684\u7ed3\u679c\u4e2d\u627e\u90a3\u4e2a\u5bf9\u5e94\u7684dp[cur - value]\u7684\u70b9\n        \n        def bs(list1, target):\n            left = 0\n            right = len(list1) - 1\n            while left < right - 1:\n                mid = (left + right) // 2\n                if target == list1[mid][0]:\n                    return list1[mid]\n                elif target > list1[mid][0]:\n                    left = mid\n                else:\n                    right = mid - 1\n            if list1[right][0] > target:\n                return list1[left]\n            else:\n                return list1[right]\n            \n        jobs = []\n        for i in range(len(startTime)):\n            jobs.append([startTime[i], endTime[i], profit[i]])\n        jobs.sort(key = lambda x:x[1])\n        dp = [[0, 0]]\n        for job in jobs:\n            maxLast = bs(dp, job[0])[1]\n            if maxLast + job[2] > dp[-1][1]:\n                dp.append([job[1], maxLast + job[2]])\n        return dp[-1][1]\n            \n        \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        n = len(startTime)\n        jobs = []\n        for i in range(n):\n            jobs.append((startTime[i], endTime[i], profit[i]))\n            \n        jobs.sort(key = lambda x:(x[1], x[0], x[2]))\n        \n        from sortedcontainers import SortedDict\n        sd = SortedDict()\n        \n        result = 0\n\n        for i in range(n):\n            start,end, profit = jobs[i]\n            previ = sd.bisect_right(start)\n            if previ == 0:\n                sd[end] = max(result, profit)\n            else:\n                prev_key = list(sd.keys())[previ-1]\n                sd[end] = max(result, profit + sd.get(prev_key))\n            \n            result = max(result, sd.get(end))\n        \n        #print(sd)\n        return result\n                \n\n            \n", "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    \n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        intervals = sorted(zip(startTime, endTime, profit))\n        n = len(intervals)\n        \n        def get_next_idx(start_idx, end_time):\n            lo, hi, res = start_idx, n - 1, n\n            while (lo <= hi):\n                mid = (hi + lo) // 2\n                start_time = intervals[mid][0]\n                if (start_time >= end_time):\n                    res, hi = mid, mid - 1\n                else:\n                    lo = mid + 1\n            return res\n        \n        @lru_cache(None)\n        def helper(idx):\n            if idx >= n:\n                return 0\n            start, end, profit = intervals[idx]\n            not_take_option = helper(idx + 1)\n            take_option = profit + helper(get_next_idx(idx + 1, end))\n            return max(not_take_option, take_option)\n        \n        return helper(0)", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = []\n        for i in range(len(startTime)):\n            jobs.append([endTime[i], startTime[i], profit[i]])\n        jobs.sort()\n        # print(jobs)\n        dp = [0] * (max(endTime) + 1)\n        arr = [0]\n        for job in jobs:\n            prev_largest_idx = self.get_prev_idx(job[1], arr)\n            curr_max = max(job[2] + dp[prev_largest_idx], dp[arr[-1]])\n            dp[job[0]] = max(curr_max, dp[job[0]])\n            arr.append(job[0])\n        # print(dp)\n        return dp[-1]\n    \n    def get_prev_idx(self, target, arr):\n        # find the greatest number smaller or equal to target in sorted arr\n        # print('---')\n        # print(target)\n        # print(arr)\n        if arr[-1] <= target:\n            return arr[-1]\n        l, r = 0, len(arr) - 1\n        while l < r:\n            mid = l + (r - l) // 2\n            if arr[mid] > target:\n                r = mid\n            else:\n                l = mid + 1\n        # if arr[l] <= target:\n        #     # print(arr[l])\n        #     return arr[l]\n        # print(arr[l-1])\n        return arr[l-1]", "class JOB:\n    def __init__(self,start,end,profit):\n        self.start=start\n        self.end=end\n        self.profit=profit\nclass Solution:\n    def binsearch(self,job,start_index):\n        lo=0\n        hi=start_index-1\n        while(lo<=hi):\n            mid=lo+(hi-lo)//2\n            if job[mid].end<=job[start_index].start:\n                if job[mid+1].end<=job[start_index].start:\n                    lo=mid+1\n                else:\n                    return mid\n            else:\n                hi=mid-1\n        return -1        \n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        job=[]\n        n=len(profit)\n        for i in range(n):\n            job.append(JOB(startTime[i],endTime[i],profit[i]))\n        job = sorted(job ,key=lambda x:x.end)\n        table=[0 for i in range(n)]\n        table[0]=job[0].profit\n        for i in range(1,len(profit)):\n            cur_profit=job[i].profit\n            l=self.binsearch(job,i)\n            if l!=-1:\n                cur_profit+=table[l]\n            table[i]=max(table[i-1],cur_profit)\n        return table[-1]    \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        def last_not_conflict(jobs, m):\n            for j in range(m-1,-1,-1):\n                if jobs[j][1] <= jobs[m][0]:\n                    return j\n            return -1\n        \n        def recursive(jobs, l):\n            if l == 1:\n                return jobs[0][2]\n            if l in dp:\n                return dp[l]\n            include = jobs[l-1][2]\n            i = last_not_conflict(jobs, l-1)\n            if i != -1:\n                include += recursive(jobs, i+1)\n            exclude = recursive(jobs, l-1)\n            dp[l] = max(include, exclude)\n            return dp[l]\n                \n        n = len(startTime)\n        jobs = [[startTime[i], endTime[i], profit[i]] for i in range(n)]\n        jobs.sort(key=lambda x: x[1])\n        dp = dict()\n        return recursive(jobs, n)", "class BIT:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(n+1)\n\n    def add(self, i, x):\n        i += 1\n        \n        while i<=self.n:\n            self.bit[i] = max(self.bit[i], x)\n            i += i&(-i)\n\n    def acc(self, i):\n        s = 0\n        \n        while i>0:\n            s = max(s, self.bit[i])\n            i -= i&(-i)\n        \n        return s\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        l = startTime+endTime\n        l = list(set(l))\n        l.sort()\n        idx = defaultdict(int)\n        \n        for i in range(len(l)):\n            idx[l[i]] = i\n        \n        sep = [(idx[s], idx[e], p) for s, e, p in zip(startTime, endTime, profit)]\n        sep.sort()\n        bit = BIT(10**5+10)\n        \n        for s, e, p in sep:\n            bit.add(e, bit.acc(s+1)+p)\n        \n        return bit.acc(10**5+10)", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n=len(startTime)\n        \n        '''table=[[] for i in range(n)]\n        \n        for i in range(n):\n            table[i]=[startTime[i],endTime[i],profit[i]]\n        table.sort(key = lambda x:x[1])\n        print(table)'''\n        \n        table = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])\n        \n        def find(table,x):\n            l=0\n            h=n-1\n            ans=-1\n            while l<=h:\n                m=(l+h)//2\n                if table[m][1]==x:\n                    return m\n                if table[m][1]<x:\n                    ans=m\n                    l=m+1\n                else:\n                    h=m-1\n        \n            return ans\n        \n        \n        dp=[0]*n\n        \n        dp[0]=table[0][2]\n        \n        mx=0\n        for i in range(1,n):\n            x=table[i][0]\n            loca=find(table,x)\n            #print(loca,table[i])\n            if loca>=0:\n                ans=table[i][2]+dp[loca]\n            else:\n                ans=table[i][2]\n            \n            dp[i]=max(ans,dp[i-1])\n            \n        print(dp)\n        return max(dp)\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        dp = [0 for _ in range(len(startTime))]\n        \n        intervals = [(startTime[i], endTime[i], profit[i]) for i in range(len(startTime))]\n        \n        intervals.sort()\n        \n        def findNext(curr):\n            for n in range(curr+1, len(intervals)):\n                if intervals[n][0] >= intervals[curr][1]:\n                    return n\n            return -1\n            \n        for i in range(len(intervals)-1, -1, -1):\n            currS, currE, currP = intervals[i]\n            \n            nextI = findNext(i)\n            dp[i] = max(currP + (0 if nextI == -1 else dp[nextI]), 0 if i == len(intervals)-1 else dp[i+1])\n\n\n                \n        return max(dp)\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        time_table = list(zip(endTime, startTime, profit))\n        time_table.sort()\n        cumul_profit = [0 for i in range(len(profit))]\n        cumul_profit[0] = time_table[0][2]\n        for qu in range(len(time_table)):\n            find = 0\n\n            for f in range(qu-1,-1,-1):\n                if time_table[f][0] <= time_table[qu][1]:\n                    find = cumul_profit[f]\n                    break\n\n            cumul_profit[qu] = max(cumul_profit[qu-1], find + time_table[qu][2])\n        return cumul_profit[len(profit)-1]\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        \n        \n        temp = list(zip(startTime,endTime,profit))\n        #print(temp)\n        #return 0\n        temp = sorted(temp , key = lambda x : x[0])\n        n = len(profit)\n        ans = [0 for _ in range(len(profit))]\n        ans[-1] = temp[-1][2]\n        \n        def binary_s(low,high,end):\n            mid = int((low + high)/2)\n            if(mid == high):\n                return high\n            if(temp[mid][0] < end and temp[mid+1][0] >= end):\n                return mid\n            elif(temp[mid][0] >= end):\n                return binary_s(low,mid-1,end)\n            else:\n                return binary_s(mid + 1, high, end)\n            \n        \n        for x in range(n-2,-1,-1):\n            mid = binary_s(x,n-1,temp[x][1])\n            if(mid != n-1 and temp[mid+1][0] >= temp[x][1]):\n                ans[x] = max(temp[x][2] + ans[mid+1],ans[x+1])\n            else:\n                ans[x] = max(temp[x][2],ans[x+1])\n                \n        # print(temp)\n        # print(ans)        \n        return ans[0]        ", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        n = len(startTime)\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])\n        dp = [0] * (n+1)\n\n        for i, job in enumerate(jobs):\n            s1, e1, p1 = job[0], job[1], job[2]\n            dp[i+1] = p1\n            for j in range(i, -1, -1):\n                if jobs[j][1] <= s1:\n                    dp[i+1] = max(dp[i], dp[j+1] + job[2])\n                    break\n            dp[i+1] = max(dp[i], dp[i+1])\n        return dp[-1]\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        # max profit ending at time t\n        dp = [(0,0)]\n        \n        task = [(startTime[i], endTime[i], profit[i]) for i in range(len(startTime))]\n        task = sorted(task, key = lambda x: x[1])\n        \n        for s, e, p in task:\n            noTaskProf = dp[-1][1]\n            for i in range(len(dp)-1, -1,-1):\n                end, pro = dp[i]\n                if end <= s:\n                    doTaskProf = pro + p\n                    break\n            if doTaskProf > noTaskProf:\n                dp.append((e, doTaskProf))\n        return dp[-1][1]\n        \n        \n        \n", "from sortedcontainers import SortedList\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = []\n        for i in range(len(startTime)):\n            s = startTime[i]\n            e = endTime[i]\n            p = profit[i]\n            jobs.append((e, s, p))\n        \n        jobs = sorted(jobs)\n        jobs = SortedList(jobs)\n\n        # either take the job or don't take the job\n        # dp[i] = max(dp[i-1], dp[k] + p) for j[k][e] <= j[i][s]\n        N = len(jobs)\n        dp = [0 for _ in range(N)]\n\n        dp[0] = jobs[0][2]\n\n        # TODO: might have to rethink just a little bit here.\n        for i in range(1, N):\n            job = jobs[i]\n            end_to_look = job[1]\n\n            to_look_index = jobs.bisect_right((end_to_look, sys.maxsize, sys.maxsize))\n            print(to_look_index)\n            dp[i] = dp[i-1]\n            if to_look_index - 1 >= 0 and jobs[to_look_index - 1][0] <= job[1]:\n                dp[i] = max(dp[i], dp[to_look_index-1] + job[2]) # take the profit\n            else: # if I can't find anything then just take the max.\n                dp[i] = max(job[2], dp[i])\n        \n        print(dp)\n        return dp[N-1]\n\n\n\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = sorted(zip(startTime, endTime, profit))\n        \n        memo = {}\n        \n        def maximize_profit(start_time, min_job_id):\n            if start_time in memo:\n                return memo[start_time]\n            \n            i = min_job_id\n            while i < len(jobs) and jobs[i][0] < start_time:\n                i += 1\n            \n            max_profit = 0\n            min_end_time = float('inf')\n            while i < len(jobs) and jobs[i][0] < min_end_time:\n                profit = jobs[i][2] + maximize_profit(jobs[i][1], i + 1)\n                max_profit = max(max_profit, profit)\n                min_end_time = min(min_end_time, jobs[i][1])\n                i += 1\n            \n            memo[start_time] = max_profit\n            return max_profit\n        \n        return maximize_profit(0, 0)", "class Job:\n    def __init__(self, start, end, profit):\n        self.start = start\n        self.end = end\n        self.profit = profit\n        \n    def __lt__(self, other):\n        return (self.end, self.start, self.profit) < (other.end, other.start, other.profit)\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n = len(startTime)\n        if n == 0:\n            return 0\n        arr = [Job(startTime[i], endTime[i], profit[i]) for i in range(n)]\n        arr.sort()\n        dp = [0 for x in range(n)]\n        dp[0] = arr[0].profit\n        for i in range(1, n):\n            job = arr[i]\n            cmax = job.profit\n            le = self.binarySearch(arr, i, job.start)\n            if 0 <= le < i:\n                cmax += dp[le]\n            dp[i] = max(dp[i - 1], cmax)\n        return dp[-1]\n    \n    def binarySearch(self, arr, i, start):\n        s, e = 0, i - 1\n        while s <= e:\n            m = (s + e) // 2\n            if arr[m].end > start:\n                e = m - 1\n            # arr[m].end <= start\n            elif m == e or (0 <= m + 1 < i and arr[m + 1].end > start):\n                return m\n            else:\n                s = m + 1\n        return -(s + 1)", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n = len(startTime)\n        jobs = sorted(zip(startTime,endTime,profit), key = lambda x:x[0])\n        dp = [0]*n\n        dp[n-1] = jobs[n-1][2]\n        for i in range(n-2,-1,-1):\n            dp[i] = max(jobs[i][2],dp[i+1])\n            for j in range(i+1,n):\n                if jobs[i][1]<=jobs[j][0]:\n                    dp[i] = max(dp[i],jobs[i][2]+dp[j])\n                    break\n        print(jobs)\n        print(dp)\n        return dp[0]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n = len(startTime)\n        jobs = [(startTime[i], endTime[i], profit[i]) for i in range(n)]\n        jobs.sort(key = lambda x: x[1])\n        dp = [(0,0)]\n        \n        def find(time):\n            n = len(dp)\n            for i in range(n-1,-1,-1):\n                if dp[i][0] <= time:\n                    return dp[i][1]\n        \n        for j in jobs:\n            dp.append((j[1],max(j[2] + find(j[0]), find(j[1]))))\n        return dp[-1][1]\n            \n        \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        N = len(startTime)\n        endtime_ith = sorted([(endTime[i], i) for i in range(N)])\n        return self.get_max_profit(max(endTime), {}, endtime_ith, startTime, endTime, profit)\n\n    def get_max_profit(self, end, cache, endtime_ith, startTime, endTime, profit):\n        if end in cache:\n            return cache[end]\n        k = self.floor(endtime_ith, end)\n        res = 0\n        if k >= 0:\n            # .......... floor_start(boundary) ....... floor_end\n            #     [start                        end]   <- need check\n            floor_ith = endtime_ith[k][1]\n            boundary = startTime[floor_ith]\n            while k >= 0:\n                cur_end_time, original_ith = endtime_ith[k]\n                if cur_end_time < boundary:\n                    break\n                cur_start_time = startTime[original_ith]\n                res = max(res, self.get_max_profit(cur_start_time, cache, endtime_ith, startTime, endTime, profit) + profit[original_ith])\n                k -= 1\n        cache[end] = res\n        return res\n\n    def floor(self, endtime_ith, end):\n        res = -1\n        hi, lo = len(endtime_ith) - 1, 0\n        while hi >= lo:\n            mid = lo + (hi - lo) // 2\n            if endtime_ith[mid][0] <= end:\n                res = max(res, mid)\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return res", "class Solution:\n     def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        def last_non_conflict(jobs, i):\n            for j in range(i - 1, -1, -1):\n                if jobs[j][1] <= jobs[i][0]:\n                    return j\n            return -1\n        \n        def recursive(jobs, l):\n            if l == 1:\n                return jobs[0][2]\n            if l in dp:\n                return dp[l]\n            include_profit = jobs[l-1][2]\n            i = last_non_conflict(jobs, l - 1)\n            if i != -1:\n                include_profit += recursive(jobs, i + 1)\n            exclude_profit = recursive(jobs, l - 1)\n            dp[l] = max(include_profit, exclude_profit)\n            return dp[l]\n        \n        n = len(startTime)\n        jobs = [[startTime[i], endTime[i], profit[i]] for i in range(n)]\n        jobs.sort(key=lambda x: x[1])\n        dp = dict()\n        return recursive(jobs, n)", "class Solution:\n    def jobScheduling(self, startTime, endTime, profit):\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])\n        #print(jobs)\n\n        dp = [0] * len(jobs)\n        dp[0] = jobs[0][-1]\n        for i in range(1, len(dp)):\n            curProfit = jobs[i][-1]\n            j = self.searchInsert(jobs, jobs[i][0])\n            if j != -1:\n                curProfit += dp[j]\n            dp[i] = max(dp[i-1], curProfit)\n        return dp[-1]\n\n\n    def searchInsert(self, nums, target: int) -> int:\n        if not nums:\n            return 0\n\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m][1] == target:\n                return m\n            elif nums[m][1] < target:\n                l = m + 1\n            else:\n                r = m - 1\n        return l - 1", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        time_line, sz, time_mapping, f = [], len(profit), {}, [0] * (2 * len(profit))\n        for i in range(sz): time_line.append((startTime[i], sz)), time_line.append((endTime[i], i))\n        for index, entry in enumerate(sorted(time_line)):\n            if entry[1] < sz:\n                f[index] = max(f[index - 1], f[time_mapping[startTime[entry[1]]]] + profit[entry[1]])\n            else:\n                f[index] = f[index - 1]; time_mapping[entry[0]] = index\n        return f[-1]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        \n        hel = [[startTime[i], 1, endTime[i], profit[i]] for i in range(len(startTime))]\n        heapq.heapify(hel)\n        res = 0\n        \n        while hel:\n            \n            ele = heapq.heappop(hel)\n             \n            if ele[1] == 1:\n                heapq.heappush(hel, [ele[2], 0, ele[2], ele[-1]+res])\n                \n            else:\n                res = max(res,ele[-1])\n                \n        return res\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n=len(startTime)\n        table=[[] for i in range(n)]\n        \n        for i in range(n):\n            table[i]=[startTime[i],endTime[i],profit[i]]\n        table.sort(key = lambda x:x[1])\n        print(table)\n        def find(table,x):\n            l=0\n            h=n-1\n            ans=-1\n            while l<=h:\n                m=(l+h)//2\n                if table[m][1]==x:\n                    return m\n                if table[m][1]<x:\n                    ans=m\n                    l=m+1\n                else:\n                    h=m-1\n        \n            return ans\n        \n        dp=[0]*n\n        \n       \n        \n        dp[0]=table[0][2]\n        \n        mx=0\n        for i in range(1,n):\n            x=table[i][0]\n            loca=find(table,x)\n            #print(loca,table[i])\n            if loca>=0:\n                ans=table[i][2]+dp[loca]\n            else:\n                ans=table[i][2]\n            \n            dp[i]=max(ans,dp[i-1])\n            \n        print(dp)\n        return max(dp)\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        def find(i):\n            l = -1\n            r = i - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if jobs[m][1] <= jobs[i][0]:\n                    l = m\n                else:\n                    r = m - 1\n            return l\n        n = len(startTime)\n        jobs = []\n        for i in range(n):\n            jobs.append([startTime[i], endTime[i], profit[i]])\n        jobs.sort(key = lambda x: x[1])\n        tot = [0 for _ in range(n + 1)]\n        tot[0] = jobs[0][2]\n        print(jobs)\n        for i in range(1, n):\n            p = find(i)\n            tot[i] = max(tot[i - 1], tot[p] + jobs[i][2])\n        return tot[n - 1]\n", "import collections\nclass Solution:\n    @staticmethod\n    def binary_search(arr, i):\n        lo = 0\n        hi = len(arr)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if arr[mid][0] <= i:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo\n        \n        \n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        mapping = collections.defaultdict(list)\n        for i in range(len(startTime)):\n            mapping[endTime[i]].append([startTime[i], profit[i]])\n\n        tasks = sorted(list(mapping.items()), key=lambda x : x[0])\n        \n        dp = [[0, 0]]\n        for group in tasks:\n            for task in group[1]:\n                idx = self.binary_search(dp, task[0]) - 1\n                if idx >= 0 and task[1] + dp[idx][1] > dp[-1][1]:\n                    if dp[-1][0] == group[0]:\n                        dp[-1][1] = task[1] + dp[idx][1]\n                    else:\n                        dp.append([group[0], task[1] + dp[idx][1]])\n        return dp[-1][1]\n", "class JOB:\n    def __init__(self,start,end,profit):\n        self.start=start\n        self.end=end\n        self.profit=profit\nclass Solution:\n    def binsearch(self,job,start_index):\n        lo=0\n        hi=start_index-1\n        while(lo<=hi):\n            mid=lo+(hi-lo)//2\n            if job[mid].end<=job[start_index].start:\n                if job[mid+1].end<=job[start_index].start:\n                    lo=mid+1\n                else:\n                    return mid\n            else:\n                hi=mid-1\n        return -1        \n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        job=[]\n        n=len(profit)\n        for i in range(n):\n            job.append(JOB(startTime[i],endTime[i],profit[i]))\n        job = sorted(job ,key=lambda x:x.end)\n        table=[0 for i in range(n)]\n        table[0]=job[0].profit\n        for i in range(1,len(profit)):\n            cur_profit=job[i].profit\n            l=self.binsearch(job,i)\n            if l!=-1:\n                cur_profit+=table[l]\n            table[i]=max(table[i-1],cur_profit)\n        return table[-1]    \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n=len(endTime)\n        endidx=defaultdict(list)\n        maxt=0\n        for i,t in enumerate(endTime):\n            endidx[t].append(i)\n            maxt=max(maxt, t)\n        dp=[0]*(maxt+1)\n        for t in range(1, maxt+1):\n            if t not in endidx:\n                dp[t]=dp[t-1]\n            else:\n                cur=dp[t-1]\n                for i in endidx[t]:\n                    cur=max(cur, dp[startTime[i]]+profit[i])\n                dp[t]=cur\n        return dp[-1]\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        intervals = []\n        n = len(startTime)\n        for i in range(n):\n            intervals.append((startTime[i], endTime[i], profit[i]))\n\n        intervals.sort(key = lambda x:x[1]) # sorted by endTime\n        T = intervals[-1][1] # largest time\n\n        dp = [0] *(T + 1)\n        co = [0] *(T + 1)\n        for i in range(n):\n            s, e, p = intervals[i] \n            if dp[s]+p > dp[e]:\n                dp[e] = dp[s]+p\n                co[e] = co[s]+1\n            if i == n - 1: break\n            nxte = intervals[i+1][1] + 1      \n            for t in range(e + 1, nxte):\n                dp[t] = dp[e]\n                co[t] = co[e]\n        print(co[T])\n        return dp[T]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        start = collections.defaultdict(list)\n        for i, time in enumerate(startTime):\n            start[time].append(i)\n        \n        dp = [0]*(max(endTime)+1)\n        for t in range(max(endTime)-1, 0, -1):\n            if t in start:\n                for i in start[t]:\n                    dp[t] = max( profit[i]+dp[endTime[i]], dp[t+1], dp[t] )\n            else:\n                dp[t] = dp[t+1]\n        return dp[1]\n                \n                \n                # dp \n                #    0 1 2 ....6\n", "from collections import defaultdict\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        time_dict = defaultdict(list)\n        \n        for start, end, p in zip(startTime, endTime, profit):\n            time_dict[end].append((start, p))\n        \n        n = max(endTime)\n        dp = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            if i not in time_dict:\n                dp[i] = dp[i-1]\n                continue\n            for start, profit in time_dict[i]:\n                curr_p = dp[start] + profit\n                dp[i] = max(curr_p, dp[i], dp[i-1])\n        return dp[n]\n                \n            \n        \n", "from collections import defaultdict\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        finish = defaultdict(list)\n        for i,j,k in zip(startTime,endTime,profit):\n            finish[j].append((i,k))\n        \n        nn=max(endTime)\n        dp=[0]*(nn+1)\n        for i in range(2,nn+1):\n            if i in finish:\n                for j in finish[i]:\n                    #print(j,dp[i])\n                    dp[i] = max(dp[i-1],dp[j[0]]+j[1],dp[i])\n            else:\n                dp[i]=dp[i-1]\n        #print(dp)\n        return dp[nn]\n            \n", "class Solution:\n    def jobScheduling(self, startTime, endTime, profit):\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])\n        print(jobs)\n\n        dp = [0] * len(jobs)\n        dp[0] = jobs[0][-1]\n        for i in range(1, len(dp)):\n            curProfit = jobs[i][-1]\n            j = self.searchInsert(jobs, jobs[i][0])\n            if j != -1:\n                curProfit += dp[j]\n            dp[i] = max(dp[i-1], curProfit)\n        return dp[-1]\n\n\n    def searchInsert(self, nums, target: int) -> int:\n        if not nums:\n            return 0\n\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m][1] == target:\n                return m\n            elif nums[m][1] < target:\n                l = m + 1\n            else:\n                r = m - 1\n        return l - 1", "from sortedcontainers import SortedList\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = []\n        for i in range(len(startTime)):\n            s = startTime[i]\n            e = endTime[i]\n            p = profit[i]\n            jobs.append((e, s, p))\n        \n        jobs = sorted(jobs)\n        jobs = SortedList(jobs)\n\n        # either take the job or don't take the job\n        # dp[i] = max(dp[i-1], dp[k] + p) for j[k][e] <= j[i][s]\n        N = len(jobs)\n        dp = [0 for _ in range(N)]\n\n        dp[0] = jobs[0][2]\n\n        # TODO: might have to rethink just a little bit here.\n        for i in range(1, N):\n            job = jobs[i]\n            end_to_look = job[1]\n\n            to_look_index = jobs.bisect_right((end_to_look, sys.maxsize, sys.maxsize))\n            print(to_look_index)\n            dp[i] = dp[i-1]\n            if to_look_index - 1 >= 0 and jobs[to_look_index - 1][0] <= job[1]:\n                dp[i] = max(dp[i], dp[to_look_index-1] + job[2]) # take the profit\n            else: # if I can't find anything then just take the max.\n                dp[i] = max(job[2], dp[i])\n        \n        return dp[N-1]\n\n\n\n", "from collections import defaultdict\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n = max(endTime)\n        lookup = defaultdict(list)\n        for s,e,p in zip(startTime,endTime,profit): lookup[e].append((s,p))\n        dp = [0]*(n+1)\n        \n        for i in range(1,len(dp)):\n            dp[i] = dp[i-1]\n            if i in lookup:\n                for start,prof in lookup[i]:\n                    dp[i] = max(dp[i],dp[start]+prof)\n        return dp[-1]\n        \n        \n    '''\n    [[1,3],[2,4],[3,5],[3,6]] [50,10,40,70]\n    \n    [0,-i,-i,50,50,90,120]\n    \n    startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n    [0,0,0,20,20,20,90,90,90,150,150]\n    \n    [1,2,3,3]\n    [3,4,5,6]\n    [50,10,40,70]\n  [0,0,0,50,50,90,120] \n    dp = []\n    \n    \n    [47,13,28,16,2,11]\n    [48,35,48,26,21,39]\n    [11,13,2,15,1,1]\n    \n    [1,15,15,15,17]\n    '''\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        l=len(startTime)\n        sep=list(zip(endTime,startTime,profit))\n        # for i in range(l):\n        #     sep.append(())\n        sep=sorted(sep)\n       # print(sep)\n        dp=[0]*(sep[-1][0]+1)\n        j=0\n        for i in range(2,len(dp)):\n            if sep[j][0]!=i:\n                dp[i]=dp[i-1]\n            else:\n                dp[i]=max(dp[i-1],sep[j][2]+dp[sep[j][1]])\n                j+=1\n                while (j<l and sep[j][0]==sep[j-1][0]):\n                    dp[i]=max(dp[i],sep[j][2]+dp[sep[j][1]])\n                    j+=1\n      #  print(dp)\n        return dp[-1]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        last_dict = {}\n        for i in range(len(startTime)):\n            if endTime[i] not in last_dict:\n                last_dict[endTime[i]] = []\n            last_dict[endTime[i]].append((startTime[i], profit[i]))\n        last_end = max(endTime)\n        result = [0]*(last_end+1)\n        \n        for t in range(1, len(result)):\n            max_val = result[t-1]\n            if t in last_dict:\n                for (start, profit) in last_dict[t]:\n                    # print(last_dict[t])\n                    max_val = max(result[start] + profit, max_val)\n            result[t] = max_val\n        return result[-1]\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobLen = len(startTime)\n        jobSchedule = []\n        for s, e, p in zip(startTime, endTime, profit):\n            jobSchedule.append((s, e, p))\n        jobSchedule.sort(key = lambda x:(x[0], x[1], -x[2]))\n        \n        # print(jobSchedule)\n        \n        dp = {}\n        \n        def findNextJob(preE, preI):\n            \n            l = preI\n            r = jobLen - 1\n            if preE > jobSchedule[r][0]:\n                return 0\n            \n            if (preE, preI) in dp:\n                return dp[(preE, preI)]\n            \n            while r > l:\n                m = (r + l) // 2\n                if jobSchedule[m][0] < preE:\n                    l = m + 1\n                else:\n                    r = m\n            lastStart = jobSchedule[l][1]\n            bestP = 0\n            bestE = 0\n            subAns = 0\n            for nextJob in range(l, jobLen):\n                if jobSchedule[nextJob][0] >= lastStart:\n                    break\n                if jobSchedule[nextJob][1] >= bestE and jobSchedule[nextJob][2] <= bestP:\n                    continue\n                if jobSchedule[nextJob][2] > bestP or (jobSchedule[nextJob][2] == bestP and jobSchedule[nextJob][1] < bestE):\n                    bestP = jobSchedule[nextJob][2]\n                    bestE = jobSchedule[nextJob][1]\n                subAns = max(subAns, jobSchedule[nextJob][2] + findNextJob(jobSchedule[nextJob][1], nextJob))\n            dp[(preE, preI)] = subAns\n            return subAns\n    \n        return findNextJob(0, 0)\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        n = max(endTime)\n        dp, dicti = (n+2) * [0], collections.defaultdict(list)\n        for start, end, profit in zip(startTime, endTime, profit):\n            dicti[start].append([end, profit])\n        \n        for start in range(n, -1, -1):\n            dp[start] = dp[start+1]\n            \n            if start in dicti:\n                dp[start] = dp[start+1]\n                for end, profit in dicti[start]:\n                    dp[start] = max(dp[start], profit + dp[end])\n        return dp[1]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n = len(profit)\n        timeline = []\n        for i in range(n): \n            timeline.append((startTime[i], n)), \n            timeline.append((endTime[i], i))\n            \n        mapping = {}\n        dp = [0] * (2 * n)\n        for i, v in enumerate(sorted(timeline)):\n            if v[1] < n:\n                dp[i] = max(dp[i - 1], dp[mapping[startTime[v[1]]]] + profit[v[1]])\n            else:\n                dp[i] = dp[i - 1];\n                mapping[v[0]] = i\n                \n        return dp[-1]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        m = {}\n        new_start = []\n        for i, v in enumerate(startTime):\n            new_start.append((v, i))\n            if v in m:\n                m[v].append((endTime[i], profit[i]))\n            else:\n                m[v] = [(endTime[i], profit[i])]\n        new_start = [(v, i) for i, v in enumerate(startTime)]\n        new_start.sort()\n        \n        last = new_start[-1][0]\n        dp = [0] * (last + 1)\n        for v in reversed(range(last+1)):\n            if v not in m:\n                dp[v] = dp[v+1]\n                continue\n            maxi = -float('inf')\n            for end, profit in m[v]:\n                maxi = max(maxi, profit)\n                if end < len(dp):\n                    val = dp[end] + profit\n                    maxi = max(maxi, val)\n                if v+1 < len(dp):\n                    maxi = max(maxi, dp[v+1])\n            dp[v] = maxi\n            \n        return dp[0]", "class Solution:\n    # DP bottom-up working from end to start\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        arr, length = [], len(startTime)\n        for i in range(length):\n            arr.append([startTime[i], endTime[i], profit[i]])\n        arr.sort()\n        \n        ans = arr[-1][2]\n        max_start, max_prof, dp = arr[-1][0], arr[-1][2], {}\n        dp[arr[-1][0]] = arr[-1][2]\n        for i in range(length-2, -1, -1):\n            start,end,prof = arr[i]\n            after = 0\n            while end <= max_start:\n                if end in dp:\n                    after = dp[end]\n                    break\n                end += 1\n                \n            dp[start] = max(max_prof, prof+after)\n            ans, max_prof = dp[start], dp[start]\n        return ans\n        \n                    \n                    \n                    \n                \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = []\n        n = len(profit)\n        for i in range(n):\n            jobs.append([startTime[i],endTime[i],profit[i]])\n        jobs.sort(key = lambda x : x[1])\n        \n        \n        dp = [0 for i in range(n+1)]\n        for i in range(n):\n            start = jobs[i][0]\n            prof = 0\n            for j in reversed(range(i)):\n                if jobs[j][1] <= start:\n                    prof = dp[j+1]\n                    break\n            dp[i+1] = max(dp[i],prof+jobs[i][2])\n        #print(dp)\n        return dp[n]", "class Solution:\n    def jobScheduling(self, startTime, endTime, profit):\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[0])\n        #Heap store (endTime, profitSoFar)\n        heap = []\n        total = 0\n        \n        for s,e,p in jobs:\n            while heap and heap[0][0] <= s:\n                end, profit = heappop(heap)\n                total = max(total, profit)\n   \n            heappush(heap, (e, p + total))\n\n        while heap:\n            end, profit = heappop(heap)\n            total = max(total, profit)\n            \n        return total", "class Solution:\n    def findprofit(self,arr):\n        dp =[0 for i in range(len(arr))]\n        dp[0] = arr[0][2] # dp[i] -> profit till ith job (we know jobs are sorted by finish time)\n        \n        # now we start filling dp from index 1, cause 0 has been taken care of\n        for i in range(1,len(dp)):\n            including = arr[i][2] # if we decide to include ith job's profit , we have to do some checks \n            \n            last_non_conflict_job = -1\n            for j in range(i-1,-1,-1): # check all the previous jobs and find the one that doesnt conflict with this current ith job, we traverse in reverse to find the last one that doesnt conflict\n                if arr[j][1]<=arr[i][0]: # if end time of jth(previous ones) is less that start time of current ,, then we are good to go\n                    \n                    last_non_conflict_job = j # we found the job\n                    break # breaking here is very important otherwise we will not find the last job but the first job\n            \n            if last_non_conflict_job!=-1: # that means we know the previous job and we can now add our current job in it\n                including += dp[last_non_conflict_job]\n                \n            dp[i] = max(dp[i-1],including) # dp[i] has two options, to take ith job or to not take ith job, we do whichever is maximum\n        return(dp[-1])\n                    \n                    \n        \n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        # arr = [[startTime[i],endTime[i],profit[i]] for i in range(len(startTime))]\n        arr = list(zip(startTime,endTime,profit))\n        arr.sort(key=lambda x:x[1]) # sort by finish time\n        \n        return(self.findprofit(arr))", "from bisect import bisect_left\n\nclass Solution:\n    def jobScheduling(self, start_times: List[int], end_times: List[int], profits: List[int]) -> int:\n        start_times, end_times, profits = list(zip(*sorted(zip(start_times, end_times, profits))))\n        n = len(start_times)\n        cache = {n - 1 : profits[n - 1], n : 0}\n        \n        def max_profit(i):\n            if i not in cache:\n                next_start = bisect_left(start_times, end_times[i])\n                cache[i] = max(profits[i] + max_profit(next_start), max_profit(i + 1))\n            return cache[i]\n        \n        return max_profit(0)\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        time_line, sz, time_mapping, f = [], len(profit), {}, [0] * (2 * len(profit))\n        for i in range(sz): \n            time_line.append((startTime[i], sz))\n            time_line.append((endTime[i], i))\n        for index, entry in enumerate(sorted(time_line)):\n            if entry[1] < sz:\n                f[index] = max(f[index - 1], f[time_mapping[startTime[entry[1]]]] + profit[entry[1]])\n            else:\n                f[index] = f[index - 1]\n                time_mapping[entry[0]] = index\n        return f[-1]", "import bisect\nfrom typing import List\n\n\nclass Solution:\n  def jobScheduling(self, start: List[int], end: List[int], profit: List[int]) -> int:\n    ans = []\n    start_end = []\n    dp = []\n\n    for i in range(len(start)):\n      start_end.append((start[i], end[i], profit[i]))\n      dp.append(-1)\n    start_end.sort()\n    start.sort()\n\n\n    def find_next_ind(curr_end):\n      return bisect.bisect_left(start, curr_end)\n\n    def recur(ind):\n      if ind == len(start_end):\n        return 0\n\n      if dp[ind] != -1:\n        return dp[ind]\n\n      curr_end = start_end[ind][1]\n      curr_profit = start_end[ind][2]\n\n      new_ind = find_next_ind(curr_end)\n      ans = max(curr_profit + recur(new_ind), recur(ind + 1))\n      dp[ind] = ans\n      return ans\n\n    ans = 0\n    recur(0)\n    for res in dp:\n      ans = max(ans, res)\n    return ans\n", "# dynamic programming + binary search\nimport bisect\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = sorted(zip(startTime,endTime,profit))\n        startTime = sorted(startTime)\n        dp = [-1]*len(jobs)\n        \n        def helper(index):\n            if index == len(jobs):\n                return 0\n            \n            if dp[index] != -1:\n                return dp[index]\n            \n            currEnd, currProfit = jobs[index][1],jobs[index][2]\n            \n            newIdx = bisect.bisect_left(startTime,currEnd)\n            \n            currRes = max(currProfit + helper(newIdx), helper(index+1))\n            \n            ans = max(dp[-1],currRes)\n            \n            dp[index] = ans\n            \n            return ans\n        \n        return helper(0)", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        \n        # tps = sorted(zip(endTime,startTime, profit))\n        # print (tps)\n        # return 0\n        events = []\n        n = len(startTime)\n        for i in range(n):\n            events.append((startTime[i], i + 1))            \n            events.append((endTime[i], -i - 1))\n        \n        events.sort()\n        # print (events)\n        \n        p = 0\n        for (curr, idx) in events:\n            if idx > 0:\n                profit[idx - 1] += p\n            else:\n                p = max(p, profit[-idx - 1])\n            # print (curr, p)\n        return p\n", "import bisect\nclass Solution:\n    def jobScheduling(self, start: List[int], end: List[int], profit: List[int]) -> int:\n        ans = []\n        start_end = []\n        dp = []\n        \n        for i in range(len(start)):\n            start_end.append((start[i], end[i], profit[i]))\n            dp.append(-1)\n        start_end.sort()\n        start.sort()\n        \n        def find_next_ind(curr_end):\n            return bisect.bisect_left(start, curr_end)\n            \n        \n        def recur(ind):\n            if ind == len(start_end):\n                return 0\n            \n            if dp[ind] != -1:\n                return dp[ind]\n            \n            curr_end = start_end[ind][1]\n            curr_profit = start_end[ind][2]\n            \n            new_ind = find_next_ind(curr_end)\n            ans = max(curr_profit + recur(new_ind), recur(ind+1))\n            dp[ind] = ans\n            return ans\n        \n        ans = 0\n        recur(0)\n        for res in dp:\n            ans = max(ans, res)\n        return ans\n", "import bisect\nimport numpy as np\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        X = list(zip(endTime,profit,startTime))\n        s = sorted(X)\n        end = [x for x,_,_ in s]\n        prof = [x for _,x,_ in s]\n        start = [x for _,_,x in s]\n\n        p = [0] * (len(end))\n        \n        for i in range(len(end) -1,-1,-1):\n            idx = bisect.bisect(end,start[i],lo =0,hi=i)\n            p[i] = idx\n\n        dp = [0] * (len(end) + 1)\n        \n        for i in range(1,len(end)+1):\n            dp[i] = max(prof[i-1] + dp[p[i-1]], dp[i-1])\n        \n        print(dp)\n        \n        return max(dp)\n        \n\n        \n            \n            \n            \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        slots={}\n        slots=set(startTime+endTime)\n        time={}\n        \n        c=0\n        for s in sorted(list(slots)):\n            time[s]=c\n            c+=1\n        \n        for i in range(len(startTime)):\n            startTime[i]=time[startTime[i]]\n            \n        tasks=collections.defaultdict(list)\n        for i in range(len(endTime)):\n            endTime[i]=time[endTime[i]]\n            tasks[endTime[i]].append(i)\n            \n        dp = [0]*c\n        for t in range(0,c):\n            dp[t]=dp[t-1]\n            for job in tasks[t]:\n                st = startTime[job]\n                dp[t]=max(dp[t], dp[st]+profit[job])\n        \n        return max(dp)\n                \n            \n            \n            \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        line=list(set(startTime)|set(endTime))\n        line.sort()\n        dp=dict()\n        d=dict()\n        v=dict()\n        for i in range(len(endTime)):\n            if endTime[i] not in d:\n                d[endTime[i]]=[]\n            d[endTime[i]].append(startTime[i])\n            v[(startTime[i],endTime[i])]=profit[i]\n        m=0\n        for n in line:\n            if n not in d:\n                dp[n]=m\n            else:\n                dp[n]=max([m]+[dp[i]+v[(i,n)]  for i in d[n]])\n                m=max(dp[n],m)\n        return dp[line[-1]]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = []\n        for i in range(len(profit)):\n            jobs.append([startTime[i], endTime[i], profit[i]])\n        \n        srt = sorted(jobs, key=lambda x: x[1])\n        print(srt)\n        maxp = [j[2] for j in srt]\n        n = len(profit)\n        for i in range(1,n):\n            for j in range(i-1, -1, -1):\n                \n                if srt[j][1] <= srt[i][0]:\n                    maxp[i] = max(srt[i][2] + maxp[j], maxp[i-1])\n                    break\n            maxp[i] = max(maxp[i-1], maxp[i])\n        print(maxp)\n        return maxp[-1]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        '''\n        diff from max intervals. \n        \n        either take or dont take a certain interval.\n        \n        then do max\n        Do top down then bottom up. \n        \n        Greedy -> earliest finishing time. \n        \n        Sort by finishing time. \n        Choose it or dont. \n        Always choose it if it doesnt interfere with the next one. \n        \n        you can binary search the end time in the start times to find the next available start times you can take. \n        \n        \n        So DP[i] -> max profit after processing interval i. \n        \n        '''\n        N = len(startTime)\n        \n        \n        # sort by start times\n        \n        res = sorted(zip(startTime, endTime, profit), key=lambda x: x[0])\n        # print(\\\"res\\\", res)\n        \n        # unzip it now!\n        unzipped_res = list(zip(*res))\n        \n        startTime = unzipped_res[0]\n        endTime = unzipped_res[1]\n        profit = unzipped_res[2]\n        \n        @lru_cache(None)\n        def solve(i):\n            \n            if i == N:\n                return 0\n            \n            # either take or dont\n            start = startTime[i]\n            end = endTime[i]\n            \n            # you can skip to the index that has a start time ahead of \n            # end time -> so that you dont have to \n            # pass along endtime in memtable? \n            \n            nextI = N\n            \n            for j in range(i+1, N):\n                \n                if startTime[j] >= end:\n                    nextI = j\n                    break\n            \n            prof = profit[i]\n            \n            # take it\n            taken = solve(nextI) + profit[i]\n            \n            # dont take:\n            notTaken = solve(i+1)\n            # print(\\\"nextI, TAKEN AND NOT TAKEN ARE\\\", i,nextI, taken, notTaken)\n            return max(taken, notTaken)\n        \n        amt = solve(0)\n        return amt\n    \n            \n                \n            \n            \n            \n        \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        n = len(startTime)\n        slots = []\n        for i in range(n): slots.append([startTime[i], endTime[i], profit[i]])\n            \n        slots.sort(key = lambda x: (x[0], x[1]))\n        mem = {}\n        \n        def dp(i):\n            if i>=n: return 0\n            if i==n-1: \n                mem[i] = slots[i][2]\n                return mem[i]\n            \n            if i in mem: return mem[i]\n            max_non_overlapping_val = slots[i][2]\n            \n            for j in range(i+1, n):\n                if slots[j][0]< slots[i][1]: continue\n                    \n                max_non_overlapping_val = max(max_non_overlapping_val, slots[i][2]+dp(j))\n                break\n                \n            max_non_overlapping_val = max(max_non_overlapping_val, dp(i+1))\n            mem[i] =max_non_overlapping_val\n            return mem[i]\n        \n        return dp(0)", "import bisect\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda t: (t[1], t[0], t[2]))\n        dp = [(0, 0)] # (endtime, max profit till this endtime) \n        # profit and endtime will both be strictly increasing\n        for start, end, profit in jobs:\n            i = bisect.bisect_right(dp, (start, float('inf'))) # dp[i - 1][0] <= end\n            profit += dp[i - 1][1] \n            if profit <= dp[-1][1]:\n                continue\n\n            if end == dp[-1][0]:\n                dp[-1] = (end, profit)\n            else:\n                dp.append((end, profit))\n        \n        return dp[-1][1]\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        from collections import defaultdict\n        \n        times = sorted(set(startTime) | set(endTime))\n        dp = [0]*len(times)\n        \n        time_id = {}\n        for i,x in enumerate(times):\n            time_id[x] = i\n            \n        start_id = defaultdict(list)\n        for i,x in enumerate(startTime):\n            start_id[x].append(i)\n\n        for i,x in enumerate(times):\n            if i > 0:\n                dp[i] = max(dp[i], dp[i-1])\n            for j in start_id[x]:\n                et = endTime[j]\n                dp[time_id[et]] = max(dp[time_id[et]], dp[i] + profit[j])\n                \n                \n        return dp[-1]\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = sorted([[startTime[i], endTime[i], profit[i]] for i in range(len(startTime))])\n        mem = {}        \n        return self.scheduleJobs(jobs, 0, mem)\n    \n    def scheduleJobs(self, jobs, i, mem):\n        '''\n        select current job, and push i after the end time of jobs[i]\n        or\n        skip current job, and push i += 1\n        '''\n        if i >= len(jobs):\n            return 0\n        if i in mem:\n            return mem[i]\n        \n        # skip current job, and push i += 1\n        profit1 = self.scheduleJobs(jobs, i + 1, mem)\n        \n        # select current job, and push i after the end time of jobs[i]\n        j = i + 1\n        while j < len(jobs) and jobs[j][0] < jobs[i][1]:\n            j += 1\n        profit2 = self.scheduleJobs(jobs, j, mem) + jobs[i][2]\n        \n        mem[i] = max(profit1, profit2)\n        return mem[i]", "from heapq import *\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = sorted(zip(startTime, endTime, profit))\n        heap = []\n        max_profit = 0\n        \n        for job in jobs:\n            while heap and heap[0][0] <= job[0]:\n                max_profit = max(max_profit, heappop(heap)[1])\n            heappush(heap, (job[1], max_profit + job[2]))\n        \n        for item in heap:\n            max_profit = max(max_profit, item[1])\n        return max_profit\n            \n        \n", "\n# This class represents a job = [start-time, end-time, weight]\nclass Job:\n    def __init__(self, start_time, end_time, weight):\n        self.start_time = start_time\n        self.end_time = end_time\n        self.weight = weight\n\n    #overriding hashcode and equals to use the Job object as a key in dict\n    def __hash__(self):\n        return hash((self.start_time, self.end_time, self.weight))\n\n    def __eq__(self, other):\n        return self.start_time == other.start_time and self.end_time == other.end_time and self.weight == other.weight\n\n\nclass WeightedIntervalSchedule:\n\n    def __init__(self, sch):\n        self.jobs = list()\n        for job in sch:\n            self.jobs.append(Job(job[0], job[1], job[2]))\n\n        self.jobs_end_first = []\n        self.jobs_start_first = []\n        self.previous_job = len(self.jobs) * [0]\n        # Memoization will be done using this memory dict\n        self.memory = dict()\n        #computing the previous mappings\n        self.compute_latest_job_scheduled_before()\n        \n\n    def getResult(self):\n        return self.dp(self.jobs_end_first, len(self.jobs) - 1, self.previous_job)\n\n    def compute_latest_job_scheduled_before(self):\n        \n        # Sorting the jobs in non decreasing order of end_time - O(nlogn)\n        self.jobs_end_first = sorted(self.jobs, key=lambda x: x.end_time)\n\n        indexed_jobs_start_first = [(index, job) for index, job in enumerate(self.jobs_end_first)]\n        # Sorting the jobs in non decreasing order of start_time - O(nlogn)\n        self.jobs_start_first = sorted(indexed_jobs_start_first, key=lambda x: x[1].start_time)\n\n        # This list X will store the index of the previous job in jobs_end_first\n        X = len(self.jobs) * [0]\n        X[0] = -1\n\n        # The time complexity of this method is O(n) as the statement inside the while loop\n        # is only called once for each index\n        # We use the intution that the latest job for the current job will be greater than or \n        # equal to the latest job for the preious job\n        for i in range(1, len(self.jobs_start_first)):\n            j = X[i - 1]\n            while (self.jobs_start_first[i][1].start_time >= self.jobs_end_first[j + 1].end_time):\n                j = j + 1\n\n            X[i] = j\n\n        # We now map the respective job to its index in jobs_end_first.\n        # O(n)        \n        for i in range(0, len(self.jobs_start_first)):\n            self.previous_job[self.jobs_start_first[i][0]] = X[i]\n            \n\n    def dp(self, jobs, index, previous_job):\n\n        dp = [0] * len(jobs)\n        dp[0] = jobs[0].weight\n\n        for i in range(1, len(jobs)):\n\n            if (previous_job[i] != -1):\n                dp[i] = max(dp[i - 1], jobs[i].weight + dp[previous_job[i]])\n            else:\n                dp[i] = max(jobs[i].weight, dp[i - 1])\n\n        return dp[len(jobs) - 1]\n\n\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        temp = list()\n        for i in range(len(startTime)):\n            temp.append([startTime[i], endTime[i], profit[i]])\n            \n        return WeightedIntervalSchedule(temp).getResult()\n        \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = list(zip(startTime, endTime, profit))\n        jobs = sorted(jobs, key=lambda x:x[1])\n        dp = [0] + profit\n        # print(dp)\n        def search_start(i):\n            nonlocal jobs\n            target = jobs[i][0]\n            \n            l, r = 0, i\n            while l<r:\n                mid = (l+r)//2\n                if jobs[mid][1] > target:\n                    r = mid\n                else:\n                    l=mid+1\n            return l\n        \n        for i,(start_time,end_time, pft) in enumerate(jobs):\n            pft_if_not_take_job = dp[search_start(i)]\n            \n            dp[i+1] = max(dp[i], pft_if_not_take_job+pft)\n            \n        # print(dp)    \n        return dp[-1]\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        def bs(arr, l, r, target):\n            while l<=r:\n                m = l+(r-l)//2\n                if arr[m][0]<=target:\n                    l = m+1\n                else:\n                    r = m-1\n            return r\n        \n        dp = [[0, 0]]\n        \n        for e, s, p in sorted(zip(endTime, startTime, profit)):\n            idx = bs(dp, 0, len(dp)-1, s)\n            if p+dp[idx][1]>dp[-1][1]:\n                dp.append([e, p+dp[idx][1]])\n                \n        return dp[-1][1]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        # Approach: dfs with memoization\n        \n        self.jobs = list()\n        \n        for i in range(len(startTime)):\n            self.jobs.append((startTime[i], endTime[i], profit[i]))\n        \n        self.jobs.sort()\n        self.memo = dict()\n        return self.dfs(0)\n        \n    \n    def dfs(self, index):\n        if index == len(self.jobs):\n            return 0\n        if index in self.memo:\n            return self.memo[index]\n        \n        res = 0\n        res = max(res, self.dfs(index + 1))\n        nextIndex = self.findNext(index)\n        res = max(res, self.dfs(nextIndex) + self.jobs[index][2])\n        self.memo[index] = res\n        \n        return res\n        \n    def findNext(self, index):\n        for i in range(index + 1, len(self.jobs)):\n            if self.jobs[index][1] <= self.jobs[i][0]:\n                return i\n        return len(self.jobs)", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        self.schedule = list(zip(startTime, endTime, profit))\n        self.schedule.sort()\n        self.scheduleLen = len(self.schedule)\n        self.mem = [-1]*(self.scheduleLen)\n        return self.getMaxProfit(0)\n    \n    def getMaxProfit(self, idx):\n        if idx >= self.scheduleLen:\n            return 0\n        \n        if self.mem[idx] != -1:\n            return self.mem[idx]\n        \n        prof = 0\n        endTime = self.schedule[idx][1]\n        profit = self.schedule[idx][2] \n        \n        prof = max(prof, self.getMaxProfit(idx+1))\n        nextJob = self.getNextNonOverlappingJob(idx, endTime)\n        prof = max(prof, profit + self.getMaxProfit(nextJob))\n        \n        self.mem[idx] =  prof\n        return self.mem[idx]\n    \n    def getNextNonOverlappingJob(self, i, endTime):\n        while i < self.scheduleLen and self.schedule[i][0] < endTime:\n            i+=1\n        return i\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        # sort the set of all start and end\n        T = []\n        for i, s in enumerate(startTime):\n            T.append((s, False, i))\n        for i, e in enumerate(endTime):\n            T.append((e, True, i))\n        T = sorted(T)\n\n        best = dict()\n        prev = 0\n        for t in T:\n            time, end, i = t\n            if end:\n                curr = max(best[startTime[i]] + profit[i], prev)\n            else:\n                curr = prev\n            best[time] = curr\n            #print(\\\"index: {}, time: {}, curr: {}\\\".format(i, time, curr))\n            prev = curr\n        return best[T[-1][0]]", "from typing import List\nfrom functools import lru_cache\nfrom bisect import bisect\n\nclass Solution:\n    \n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        intervals = sorted(zip(startTime, endTime, profit))\n        n = len(intervals)\n        \n        @lru_cache(None)\n        def helper(idx):\n            if idx >= n:\n                return 0\n            start, end, profit = intervals[idx]\n            not_take_option = helper(idx + 1)\n            take_option = profit + helper(bisect(intervals, (end,)))\n            return max(not_take_option, take_option)\n        \n        return helper(0)", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = []\n        for idx in range(len(startTime)):\n            jobs.append([startTime[idx], endTime[idx], profit[idx]])\n        jobs.sort(key=lambda x: x[1])\n        dp = [[0, 0]]\n        for s, e, p in jobs:\n            idx = self.bs(dp, s)\n            if dp[idx-1][1] + p >= dp[-1][1]:\n                dp.append([e, dp[idx-1][1] + p])\n        return dp[-1][1]\n            \n    def bs(self, arr, val):\n        l = 0\n        r = len(arr) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if arr[mid][0] >= val:\n                r = mid\n            else:\n                l = mid + 1              \n        return l if arr[l][0] > val else l + 1", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        def search(dp, end):\n            left, right = 0, len(dp) - 1\n            while left < right:\n                mid = left + (right - left + 1) // 2\n                if dp[mid][0] <= end:\n                    left = mid\n                else:\n                    right = mid - 1\n            return left\n        \n        jobs = sorted(zip(startTime, endTime, profit), key = lambda v: v[1])\n        dp = [[0, 0]] # end_time, profit\n        for start, end, profit in jobs:\n            pos = search(dp, start)\n            # print(pos, dp, end)\n            if dp[pos][1] + profit > dp[-1][1]:\n                dp.append([end, dp[pos][1] + profit])\n        return dp[-1][1]", "# dp[i] :max profit if take the ith job\n# dp[i] = max(0, dp[j] + profit[i] if endTime[j] <= startTime[i]) for j < i\n# return max(dp)\n\n#DP + Binary Search\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        if len(startTime) != len(endTime) or len(startTime) != len(profit):\n            return 0\n        \n        n = len(startTime)\n        \n        combined = []\n        \n        for i in range(n):\n            combined.append((endTime[i], startTime[i], profit[i]))\n        \n        combined.sort()\n            \n        dp = [0] * n\n        res = 0\n        \n        for i in range(n):\n            end_i, start_i, profit_i = combined[i]\n            dp[i] = max(dp[i - 1] if i > 0 else profit_i, profit_i)\n            \n            j = self.firstPosLargerThanTarget(combined, start_i, i)\n            \n            if j > 0:\n                dp[i] = max(dp[j - 1] + profit_i, dp[i])\n            \n        return dp[-1]\n\n    def firstPosLargerThanTarget(self, combined, target, end):\n        left, right = 0, end\n        \n        while left + 1 < right:\n            mid = (left + right) // 2\n            \n            if combined[mid][0] <= target:\n                left = mid\n            else:\n                right = mid\n        \n        if combined[left][0] > target:\n            return left\n        \n        return right", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        points = list(set(startTime + endTime))\n        points.sort()\n        dic = defaultdict(list)\n        for start, end, profit in zip(startTime, endTime, profit):\n            dic[end].append([start, profit])\n        DP = {points[0]: 0}\n        res = 0\n        for i in range(1, len(points)):\n            DP[points[i]] = DP[points[i-1]]\n            for start, profit in dic[points[i]]:\n                DP[points[i]] = max(DP[points[i]], DP[start] + profit)\n            res = max(res, DP[points[i]])\n        return res", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n=len(profit)\n        schedule=[(startTime[i],endTime[i],profit[i]) for i in range(len(startTime))]\n        schedule.sort(key=lambda x:(x[1]))\n        dp=[0]*(n+1)\n        dp[0]=0\n        p=[0]*(n+1)\n        value=[]\n        value.append(0)              \n        for i in range(n):\n             value.append(schedule[i][2])\n        bs=[]\n        bs.append(schedule[0][1])\n        p[1]=0\n        def bst(bs,x):\n            h=len(bs)-1\n            l=0\n            while(l<=h):\n                m=(l+h)//2\n                if bs[m]==x:\n                      return m+1\n                elif bs[m]<x:\n                      l=m+1\n                else:\n                      h=m-1 \n            return l\n        for i in range(2,n+1):\n                p[i]=bst(bs,schedule[i-1][0])\n                bs.append(schedule[i-1][1])\n        for i in range(1,n+1):\n                    dp[i]=max(dp[i-1],dp[p[i]]+value[i])\n        return dp[-1]\n", "class Solution:\n    # Without cache, O(2^n log n) time, O(1) space; with cache, O(n x log n) time, O(n) space\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        A = sorted(zip(startTime, endTime, profit))\n        n = len(A)\n        \n        def find_next_starting_point(cur_starting_point, start_time):\n            if cur_starting_point >= n:\n                return cur_starting_point\n            \n            left, right = cur_starting_point, n - 1\n            while left + 1 < right:\n                mid = left + (right - left) // 2\n                if A[mid][0] < start_time:\n                    left = mid\n                else:\n                    right = mid\n            \n            if A[left][0] >= start_time:\n                return left\n            # left < start_time\n            if A[right][0] >= start_time:\n                return right\n            # right < start_time\n            return right + 1           \n        \n        cache = {n: 0}\n        \n        def find_max_profit(i):\n            if i in cache:\n                return cache[i]\n            \n            next_start = find_next_starting_point(i + 1, A[i][1])\n            with_cur_task = A[i][2] + find_max_profit(next_start)\n            without_cur_task = find_max_profit(i + 1)\n            cache[i] = max(with_cur_task, without_cur_task)\n            return cache[i]\n        \n        return find_max_profit(0)\n\n    # O(n x log n) time, O(n) space\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        A = sorted(zip(endTime, startTime, profit))\n        n = len(A)\n        \n        # The biggest profit as of the ith task\n        cache = [0] * (n + 1)\n        \n        def find_closest_ending_point(cur_ending_point, end_time_limit):\n            if cur_ending_point < 0:\n                return 0\n            \n            left, right = 0, cur_ending_point\n            while left + 1 < right:\n                mid = left + (right - left) // 2\n                if A[mid][0] <= end_time_limit:\n                    left = mid\n                else:\n                    right = mid\n            \n            if end_time_limit >= A[right][0]:\n                return right + 1\n            # end_time_limit < right\n            if end_time_limit >= A[left][0]:\n                return left + 1\n            # end_time_limit < left\n            return left\n        \n        for i in range(1, n + 1):\n            index = find_closest_ending_point(i - 2, A[i - 1][1])\n            cache[i] = max(cache[i - 1], cache[index] + A[i - 1][2])\n        \n        return cache[n]\n        \n        \n        \n", "from functools import lru_cache\n\n\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        if not startTime or not endTime or not profit:\n            return 0\n\n        intervals = list(zip(startTime, endTime, profit))\n        # sorted by start-time\n        intervals.sort(key=lambda x: x[0])\n\n        def find_next_idx_binary_search(left, right, time):\n            while left < right:\n                mid = left + (right - left) // 2\n                if intervals[mid][0] >= time:\n                    right = mid\n                else:\n                    left = mid + 1\n            return left\n\n        @lru_cache(maxsize=None)\n        def helper(idx):\n            if idx == len(intervals) or idx < 0:\n                return 0\n            j = find_next_idx_binary_search(idx+1, len(intervals), intervals[idx][1])\n            #option 1) include current interval + next valid interval\n            #option 2) exclude current interval:  helper(j+1)\n            return max(helper(j) + intervals[idx][2], helper(idx+1))\n        \n        return helper(0)", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        def bs(list1, target):\n            left = 0\n            right = len(list1) - 1\n            while left < right - 1:\n                mid = (left + right) // 2\n                if list1[mid][1] == target:\n                    return list1[mid]\n                elif list1[mid][1] < target:\n                    left =  mid\n                else:\n                    right = mid - 1\n            if list1[right][1] <= target:\n                return list1[right]\n            else:\n                return list1[left]\n        \n        \n        jobs = []\n        for i in range(len(startTime)):\n            jobs.append([startTime[i], endTime[i], profit[i]])\n        dp = [[0, 0, 0]]\n        \n        lastMax = 0\n        \n        jobs.sort(key = lambda x:x[1])\n        for job in jobs:\n            lastMax = dp[-1][2]\n            candidate = bs(dp, job[0])\n            if candidate[2] + job[2] > lastMax:\n                \n                dp.append([job[0], job[1], candidate[2] + job[2]])\n        print(dp)\n        return dp[-1][-1]\n        \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        lis = []\n        dp = []\n        for i in range(len(startTime)):\n            lis += [[startTime[i], endTime[i],profit[i]]]\n        lis = sorted(lis,key = lambda x : x[0])\n        dp += [lis[-1][2]]\n        for i in range(len(lis)-2,-1,-1):\n            cur = lis[i][2]\n            for j in range(i+1,len(lis)):\n                if lis[j][0] >= lis[i][1]:\n                    \n                    cur = lis[i][2] + dp[i-j]\n                    break\n            dp += [max(cur,dp[-1])]\n            \n        return dp[-1]\n            \n", "# topdown DP\n\nfrom functools import lru_cache\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        list_jobs = sorted(zip(startTime, endTime, profit))\n        \n        @lru_cache(maxsize=None)\n        def find(i=0):\n            if i >= len(list_jobs):\n                return 0\n            # left and right\n            l = i+1\n            r = len(list_jobs) - 1\n            \n            # keep track var\n            j = len(list_jobs)\n            \n            while l <= r:\n                middle = (l+r)//2\n                \n                # check the middle startTime and the i endTime\n                if list_jobs[middle][0] < list_jobs[i][1]:\n                    l = middle+1\n                else:\n                    r = middle-1\n                    j = middle\n            \n            # find max profit\n            return max(list_jobs[i][2] + find(j), find(i+1))\n        \n        # start at index 0\n        return find()\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        n = len(profit)\n        line = list(zip(startTime, endTime, profit))\n        line.sort(key=lambda x: x[1])\n        dp = [0] * n\n        dp[0] = line[0][2]\n    \n        for i in range(n):\n            prev_profit = 0\n            left, right = 0, i - 1\n            \n            while left <= right:\n                mid = (left + right) // 2\n                if line[i][0] < line[mid][1]: # need prev job to end bef current\n                    right = mid - 1\n                else:\n                    prev_profit = dp[mid]\n                    left = mid + 1\n            dp[i] = max(dp[i-1], prev_profit + line[i][2])\n       \n    \n        return dp[-1]\n            \n            \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = []\n        for i in range(len(startTime)):\n            jobs.append([startTime[i], endTime[i], profit[i]])\n        \n        jobs = sorted(jobs, key=lambda x: x[1])\n        dp = [0 for i in range(len(jobs))]\n        dp[0] = jobs[0][2]\n        \n        def search(target):\n            # larger than or equal to target\n            l, r = 0, len(jobs)\n            while l < r:\n                mid = l + (r - l) // 2\n                if jobs[mid][1] < target:\n                    l = mid + 1\n                else:\n                    r = mid\n\n            return l\n        \n        # print(jobs)\n                \n        for i in range(1, len(jobs)):\n            start, end, profit = jobs[i]\n            # search for previous jobs ends before current job\n            idx = search(start)\n            if jobs[idx][1] == start:\n                prev_best = dp[idx]\n            elif jobs[idx-1][1] < start:\n                prev_best = dp[idx - 1]\n            else:\n                prev_best = 0\n                \n            # print(start, idx, jobs[idx][1], prev_best)\n                \n            dp[i] = max(dp[i - 1], profit + prev_best)\n            \n            # print(dp)\n        \n        return dp[-1]\n            \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n\n#         def binary_search(intervals, index):\n\n#             start = 0\n#             end = index - 1\n\n#             while start <= end:\n#                 mid = (start + end) // 2\n\n#                 if intervals[index][0] < intervals[mid][1]:\n#                     end = mid - 1\n#                 else:\n#                     start = mid + 1\n\n#             return start - 1\n        \n        def binary_search(intervals, index):\n\n            start = 0\n            end = index\n\n            while start < end:\n                mid = (start + end) // 2\n\n                if intervals[mid][1] > intervals[index][0]:\n                    end = mid\n                else:\n                    start = mid + 1\n\n            return start - 1\n        \n        \n\n        intervals = []\n        for i in range(len(startTime)):\n            intervals.append((startTime[i], endTime[i], profit[i]))\n\n        intervals.sort(key=lambda i: i[1])\n        # print(intervals)\n        # see other submitted code for clear explanation\n        dp = [0] * len(intervals)\n        for i in range(len(intervals)):\n            profit_if_i_inlcuded = intervals[i][2]\n\n            k_th = binary_search(intervals, i)\n            \n            if (k_th != -1):\n                profit_if_i_inlcuded += dp[k_th]\n\n            dp[i] = max(dp[i - 1], profit_if_i_inlcuded)  # max of not including i, including i\n            # print(intervals, i, k_th, dp)\n        return max(dp)\n\n    # almost all  test cases passed\n#     def jobScheduling_n2(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n\n#         def binary_search(intervals, index):\n\n#             start = 0\n#             end = index - 1\n\n#             while start <= end:\n#                 mid = (start + end) // 2\n\n#                 if intervals[index][0] < intervals[mid][1]:\n#                     end = mid - 1\n#                 else:\n#                     start = mid + 1\n\n#             return start - 1\n\n#         intervals = []\n#         for i in range(len(startTime)):\n#             intervals.append((startTime[i], endTime[i], profit[i]))\n\n#         intervals.sort(key=lambda i: i[1])\n#         # print(intervals)\n#         dp = [0] * len(intervals)\n#         for i in range(len(intervals)):\n#             dp[i] = intervals[i][2]\n\n#             k_th = binary_search(intervals, i)\n\n#             if k_th != -1:\n#                 for j in range(0, k_th + 1):\n#                     if dp[i] < dp[j] + intervals[i][2]:\n#                         dp[i] = dp[j] + intervals[i][2]\n\n#         # print(dp)\n#         return max(dp)\n\n#     def jobScheduling_n2(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n\n#         intervals = []\n#         for i in range(len(startTime)):\n#             intervals.append((startTime[i], endTime[i], profit[i]))\n\n#         intervals.sort(key=lambda i: i[1])\n#         # print(intervals)\n#         dp = [0] * len(intervals)\n#         for i in range(len(intervals)):\n#             dp[i] = intervals[i][2]\n\n#             for j in range(0, i):\n\n#                 if intervals[i][0] >= intervals[j][1]:\n#                     if dp[i] < dp[j] + intervals[i][2]:\n#                         dp[i] = dp[j] + intervals[i][2]\n\n#         # print(dp)\n#         return max(dp)\n", "# This class represents a job = [start-time, end-time, weight]\nclass Job:\n    def __init__(self, start_time, end_time, weight):\n        self.start_time = start_time\n        self.end_time = end_time\n        self.weight = weight\n\n    #overriding hashcode and equals to use the Job object as a key in dict\n    def __hash__(self):\n        return hash((self.start_time, self.end_time, self.weight))\n\n    def __eq__(self, other):\n        return self.start_time == other.start_time and self.end_time == other.end_time and self.weight == other.weight\n\n\nclass WeightedIntervalSchedule:\n\n    def __init__(self, sch):\n        self.jobs = list()\n        for job in sch:\n            self.jobs.append(Job(job[0], job[1], job[2]))\n\n        self.jobs_end_first = []\n        self.jobs_start_first = []\n        self.X = len(self.jobs) * [0]\n        self.previous_job_mapping = dict()\n        # Memoization will be done using this memory dict\n        self.memory = dict()\n        #computing the previous mappings\n        self.compute_latest_job_scheduled_before()\n        \n\n    def getResult(self):\n        return self.dp(self.jobs_end_first, len(self.jobs) - 1, self.previous_job_mapping)\n\n    def compute_latest_job_scheduled_before(self):\n        \n        # Sorting the jobs in non decreasing order of start_time - O(nlogn)\n        self.jobs_start_first = sorted(self.jobs, key=lambda x: x.start_time)\n        # Sorting the jobs in non decreasing order of end_time - O(nlogn)\n        self.jobs_end_first = sorted(self.jobs, key=lambda x: x.end_time)\n        # This list X will store the index of the previous job in jobs_end_first\n        self.X[0] = -1\n\n        # The time complexity of this method is O(n) as the statement inside the while loop\n        # is only called once for each index\n        # We use the intution that the latest job for the current job will be greater than or \n        # equal to the latest job for the preious job\n        for i in range(1, len(self.jobs_start_first)):\n            j = self.X[i - 1]\n            while (self.jobs_start_first[i].start_time >= self.jobs_end_first[j + 1].end_time):\n                j = j + 1\n\n            self.X[i] = j\n\n        # We now map the respective job to its index in jobs_end_first.\n        # O(n)        \n        for i in range(0, len(self.jobs_start_first)):\n            self.previous_job_mapping[self.jobs_start_first[i]] = self.X[i]\n            \n\n    def dp(self, jobs, index, mapping):\n\n        current_job = jobs[index]\n\n        profit_including_current_job = current_job.weight\n        profit_excluding_current_job = 0\n\n        if index == 0:\n            return profit_including_current_job\n\n        # Dynamic programming - checking if the subproblem is already solved\n        if index in self.memory:\n            return self.memory[index]\n\n        if mapping[jobs[index]] != -1:\n            profit_including_current_job += self.dp(\n                jobs, mapping[jobs[index]], mapping)\n\n        profit_excluding_current_job = self.dp(\n            jobs, index - 1, mapping)\n\n        # Storing the result in the memory\n        result = max(profit_including_current_job, profit_excluding_current_job)\n        \n        self.memory[index] = result\n\n        return result\n\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        temp = list()\n        for i in range(len(startTime)):\n            temp.append([startTime[i], endTime[i], profit[i]])\n            \n        return WeightedIntervalSchedule(temp).getResult()\n        \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        # sort w.r.t. the end time\n        # here the dp[i] is the max profit up to task i (the current may not be i)\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])\n        \n        def search(idx):\n            e_time = jobs[idx][0]\n            l, r = 0, idx-1\n            while l <= r:\n                mid = (r - l) // 2 + l\n                if jobs[mid][1] <= e_time:\n                    if jobs[mid+1][1] <= e_time:\n                        l = mid + 1\n                    else:\n                        return mid\n                else:\n                    r = mid - 1\n            return -1\n        \n        def find(idx):\n            e_time = jobs[idx][0]\n            l, r = 0, idx\n            while l < r:\n                mid = (r - l) // 2 + l\n                if jobs[mid][1] <= e_time:\n                    l = mid + 1\n                else:\n                    r = mid\n            return l - 1\n            \n        dp = [0] * len(jobs)\n        dp[0] = jobs[0][2]\n        \n        for i in range(1, len(jobs)):\n            profit = jobs[i][2]\n            j = find(i)\n            # j = search(i)\n            # print(j)\n            if j != -1:\n                profit += dp[j]\n            dp[i] = max(dp[i-1], profit)\n        \n        print(dp)\n        return dp[-1]\n        \n\n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n = len(startTime)\n        stack = [0 for _ in range(n)]\n        for i in range(len(startTime)):\n            stack[i] = [startTime[i], endTime[i], profit[i]]\n        stack = sorted(stack, key = lambda x: x[1])\n        print(stack)\n        dp = [[0, 0]]   \n        for s, e, p in stack:\n            \n            idx = self.binarySearch(dp, s)\n            if dp[idx][1] + p > dp[-1][1]:\n                dp.append([e, dp[idx][1] + p])\n        return dp[-1][1]\n    \n    def binarySearch(self, dp, s):\n        i, j = 0, len(dp) \n        while i < j:\n            mid = i + (j - i) // 2\n            if dp[mid][0] == s:\n                return mid\n            elif dp[mid][0] > s:\n                j = mid\n            else:\n                i = mid + 1\n\n        if i == len(dp):\n            return i - 1\n        elif dp[i][0] > s:\n            return i - 1\n        else:\n            return i\n \n        \n        \n", "\n\nclass Job:\n    def __init__(self, start_time, end_time, weight):\n        self.start_time = start_time\n        self.end_time = end_time\n        self.weight = weight\n\n    def __hash__(self):\n        return hash((self.start_time, self.end_time, self.weight))\n\n    def __eq__(self, other):\n        return self.start_time == other.start_time and self.end_time == other.end_time and self.weight == other.weight\n\n\nclass WeightedIntervalSchedule:\n\n    def __init__(self, sch):\n        self.jobs = list()\n        for job in sch:\n            self.jobs.append(Job(job[0], job[1], job[2]))\n\n        self.jobs_end_first = []\n        self.jobs_start_first = []\n        self.X = len(self.jobs) * [0]\n        self.previous_job_mapping = dict()\n        self.compute_latest_job_scheduled_before()\n        self.memory = dict()\n        \n\n    def getResult(self):\n        return self.dp(self.jobs_end_first, len(self.jobs) - 1, self.previous_job_mapping)\n\n    def compute_latest_job_scheduled_before(self):\n\n        self.jobs_start_first = sorted(self.jobs, key=lambda x: x.start_time)\n        self.jobs_end_first = sorted(self.jobs, key=lambda x: x.end_time)\n\n        self.X[0] = -1\n\n        for i in range(1, len(self.jobs_start_first)):\n            j = self.X[i - 1]\n            while (self.jobs_start_first[i].start_time >= self.jobs_end_first[j + 1].end_time):\n                j = j + 1\n\n            self.X[i] = j\n        \n        for i in range(0, len(self.jobs_start_first)):\n            self.previous_job_mapping[self.jobs_start_first[i]] = self.X[i]\n\n        print((self.X))\n            \n\n    def dp(self, jobs, index, mapping):\n\n        current_job = jobs[index]\n\n        profit_including_current_job = current_job.weight\n        profit_excluding_current_job = 0\n\n        if index == 0:\n            return profit_including_current_job\n\n        if index in self.memory:\n            return self.memory[index]\n\n        if mapping[jobs[index]] != -1:\n            profit_including_current_job += self.dp(\n                jobs, mapping[jobs[index]], mapping)\n\n        profit_excluding_current_job = self.dp(\n            jobs, index - 1, mapping)\n\n        result = max(profit_including_current_job, profit_excluding_current_job)\n        self.memory[index] = result\n        \n        return result\n\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        temp = list()\n        for i in range(len(startTime)):\n            temp.append([startTime[i], endTime[i], profit[i]])\n            \n        return WeightedIntervalSchedule(temp).getResult()\n        \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = list(zip(startTime, endTime, profit))\n        jobs.sort(key=lambda x: x[1])\n        n = len(jobs)\n        \n        def binarySearchForLastDisjointInterval(interval: List[int]) -> int:\n            s1, e1 = interval\n            l, r = 0, n - 1\n            while l <= r:\n                mid = (l + r) // 2\n                s2, e2 = jobs[mid][0], jobs[mid][1]\n                if s1 >= e2:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            return r\n            \n        def getLastDisjointIntervals() -> List[int]:\n            last_disjoint_intervals = [None] * n\n            for i in range(n):\n                interval = [jobs[i][0], jobs[i][1]]\n                last_disjoint_intervals[i] = binarySearchForLastDisjointInterval(interval)\n            return last_disjoint_intervals\n        \n        last_disjoint_intervals = getLastDisjointIntervals()\n        dp = [0] * n # dp[i] stores the maximum profit if we only consider the first (i+1) jobs\n        dp[0] = jobs[0][2] # Can take the first job under any circumstance\n        for i in range(1, n):\n            # For a new job, we can either take this new job or don't take this new job\n            # Consider not taking the new job\n            profit_not_take = dp[i-1]\n            # Consider taking the new job\n            profit_take = jobs[i][2]\n            j = last_disjoint_intervals[i]\n            if j != -1:\n                profit_take += dp[j]\n            dp[i] = max(profit_not_take, profit_take)\n        return dp[n-1]", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        comb = []\n        dd = dict()\n        for i in range(len(startTime)):\n            comb.append((startTime[i],endTime[i],profit[i]))\n        comb.sort()\n        print(comb)\n        l = len(comb)\n        \n        def returnIdx(idx, l, val):\n            while idx < l:\n                #print(idx, l)\n                mid = idx+(l-idx)//2\n                if comb[mid][0]<val:\n                    idx = mid+1\n                else:\n                    l = mid\n            return idx\n            \n        \n        def maxProfit(jobidx):\n            if jobidx == l:\n                return 0\n            if jobidx in dd:\n                return dd[jobidx]\n            ans = 0\n            ans =  max(ans, maxProfit(jobidx+1))\n            ans = max(ans, comb[jobidx][2] + maxProfit(returnIdx(jobidx, l, comb[jobidx][1])))\n            dd[jobidx] = ans\n            return ans\n        \n        return maxProfit(0)\n                \n                \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        # Approach: dfs with memoization\n        \n        self.jobs = list()\n        \n        for i in range(len(startTime)):\n            self.jobs.append((startTime[i], endTime[i], profit[i]))\n        \n        self.jobs.sort()\n        self.memo = dict()\n        return self.dfs(0)\n        \n    \n    def dfs(self, index):\n        if index == len(self.jobs):\n            return 0\n        if index in self.memo:\n            return self.memo[index]\n        \n        res = 0\n        res = max(res, self.dfs(index + 1))\n        nextIndex = self.findNext(index)\n        res = max(res, self.dfs(nextIndex) + self.jobs[index][2])\n        self.memo[index] = res\n        \n        return res\n        \n    def findNext(self, index):\n        left = index + 1\n        right = len(self.jobs)\n        target = self.jobs[index][1]\n        while left < right:\n            mid = (left + right) // 2\n            if self.jobs[mid][0] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        # Approach: dfs with memoization\n        # after bundling start time, end time together and sort\n        \n        self.jobs = list()\n        \n        # bundle start time, end time and profit together\n        for i in range(len(startTime)):\n            self.jobs.append((startTime[i], endTime[i], profit[i]))\n        \n        self.jobs.sort()\n        self.memo = dict()\n        return self.dfs(0)\n        \n    \n    def dfs(self, index):\n        if index == len(self.jobs):\n            return 0\n        if index in self.memo:\n            return self.memo[index]\n        \n        res = 0\n        \n        # the case when we don't do the job\n        res = max(res, self.dfs(index + 1))\n        \n        # use binary search to find the next index if we decide to do this job\n        nextIndex = self.findNext(index)\n        res = max(res, self.dfs(nextIndex) + self.jobs[index][2])\n        self.memo[index] = res\n        \n        return res\n    \n    # Binary search to find the next index\n    def findNext(self, index):\n        left = index + 1\n        right = len(self.jobs)\n        target = self.jobs[index][1]\n        while left < right:\n            mid = (left + right) // 2\n            if self.jobs[mid][0] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        dp = {}\n        interval = []\n        for i in range(len(startTime)):\n            interval.append((endTime[i], startTime[i], profit[i]))\n        interval.sort()\n        ans = 0\n        for j, i, p in interval:\n            index = self.find_previous_end(interval, i)\n            dp.setdefault(index, 0)\n            dp[j] = max(dp[index] + p, ans)\n            ans = max(ans, dp[j])\n        return ans\n    \n    def find_previous_end(self, nums, target):\n        l, r = 0, len(nums)\n        while l + 1 < r:\n            mid = (l + r) // 2\n            if nums[mid][0] > target:\n                r = mid\n            else:\n                l = mid\n        if nums[r][0] <= target:\n            return nums[r][0]\n        if nums[l][0] <= target:\n            return nums[l][0]\n        return 0", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n = len(startTime)\n        arr = [(endTime[i], startTime[i], profit[i]) for i in range(n)]\n        arr.sort()\n        dp = [0 for x in range(n)] # up to idx, the maximum gain\n        dp[0] = arr[0][2]\n        for i in range(1, n):\n            e, s, p = arr[i][0], arr[i][1], arr[i][2]\n            # find the rightmost idx j whose end <= start\n            bs, be = 0, i - 1\n            ridx = -1\n            while bs <= be:\n                m = (bs + be) // 2\n                if arr[m][0] > s:\n                    be = m - 1\n                else: # arr[m][1] <= s\n                    ridx = max(ridx, m)\n                    bs = m + 1\n            if ridx == -1:\n                dp[i] = max(dp[i - 1], p)\n            else:\n                dp[i] = max(dp[i - 1], dp[ridx] + p)\n        return max(dp)", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        # sort intervals by their endTime\n        intervals = sorted(zip(startTime, endTime, profit), key=lambda x: (x[1], x[2]))\n        N = len(profit)\n        # bottom up solutions: (profit, endtime, index)\n        dp = [(0, 0, -1)]\n        \n        for idx, (s, e, p) in enumerate(intervals):\n            nonoverlapping_idx = self.find_nonoverlapping_interval(dp, s + 0.1)\n            # print(idx, nonoverlapping_idx, s)\n            if dp[nonoverlapping_idx][0] + p > dp[idx-1+1][0]:\n                dp.append((dp[nonoverlapping_idx][0] + p, e, idx))\n            else:\n                dp.append(dp[idx-1+1])\n        \n        # print(dp)\n        solutions = []\n        cur_idx = dp[N][2] # of the activity\n        while cur_idx != -1:\n            solutions.insert(0, cur_idx)\n            start_idx = intervals[cur_idx][0]\n            nonoverlapping_idx = self.find_nonoverlapping_interval(dp, start_idx + 0.1)\n            cur_idx = dp[nonoverlapping_idx][2]\n        print(solutions)\n        \n        return dp[-1][0]\n    \n    def find_nonoverlapping_interval(self, dp, start):\n        l_idx = 0\n        r_idx = len(dp) - 1\n        \n        # print(dp, l_idx, r_idx, start)\n        \n        # using binary search\n        while l_idx <= r_idx:\n            mid_idx = (l_idx + r_idx) // 2\n            if dp[mid_idx][1] < start:\n                l_idx = mid_idx + 1\n            else:\n                r_idx = mid_idx - 1\n        \n        # print(dp, l_idx, r_idx, start)\n        \n        return l_idx - 1\n", "class Solution:\n    \n    def next_index(self,arr,i,target):\n        \n        \n        left = 0\n        right = i\n        \n        if i<0:\n            return -1\n        \n        mid = left\n        while left<right:\n            \n           \n            mid = (left+right+1) // 2\n            #print(left,mid,right)\n            if arr[mid][1]<=target:\n                left = mid\n            elif arr[mid][1] > target:\n                right = mid-1\n                \n            \n         \n        \n        \n        return left if arr[left][1]<=target else -1\n    def solve(self,i,arr):\n        \n        if i < 0:\n            return 0\n    \n        if i in self.dp:\n            return self.dp[i]\n        \n        \n        x = self.solve(i-1,arr)\n        \n        y = 0\n        ind = self.next_index(arr,i-1,arr[i][0])\n        \n        \n        y = self.solve(ind,arr)+arr[i][2]\n        \n        self.dp[i] = max(x,y)\n        \n        \n        return self.dp[i]\n        \n        \n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        \n        \n        self.dp = {}\n        \n        arr = []\n        \n        \n        for i in range(len(startTime)):\n            \n            arr.append((startTime[i],endTime[i],profit[i]))\n            \n        arr.sort(key = lambda x:x[1])  \n        \n        #print(arr)\n        \n        ans = self.solve(len(profit)-1,arr)\n            \n        #print(self.dp)\n        \n        #print(self.next_index(arr,2,2))\n        return ans\n        \n", "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = []\n        for s, e, p in zip(startTime, endTime, profit):\n            jobs.append([s,e,p])\n            \n        jobs.sort(key=lambda x : x[0])\n        \n        memo = [0] * len(jobs)\n        \n        def recur(i):\n            if i >= len(jobs):\n                return 0\n            if memo[i] > 0:\n                return memo[i]\n            else:\n                pro = 0\n                l, r = i+1, len(jobs)\n                while l < r:\n                    mid = (l + r) // 2\n                    if jobs[mid][0] < jobs[i][1]:\n                        l = mid + 1\n                    else:\n                        r = mid\n                pro = max(recur(i+1), recur(l) + jobs[i][2])\n                memo[i] = pro\n                return pro\n        return recur(0)"]
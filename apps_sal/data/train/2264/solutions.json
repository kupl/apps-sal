["# ARC090E\n\ndef hoge():\n    M = 10**9 + 7\n    import sys\n    input = lambda : sys.stdin.readline().rstrip()\n\n    n, m = map(int, input().split())\n    s, t = map(int, input().split())\n    s -= 1\n    t -= 1\n    from collections import defaultdict\n    ns = defaultdict(set)\n    for i in range(m):\n        u, v, d = map(int, input().split())\n        ns[u-1].add((v-1, d))\n        ns[v-1].add((u-1, d))\n    \n    def _dijkstra(N, s, Edge):\n        import heapq\n        geta = 10**15\n        inf = geta\n        dist = [inf] * N\n        dist[s] = 0\n        Q = [(0, s)]\n        dp = [0]*N\n        dp[s] = 1\n        while Q:\n            dn, vn = heapq.heappop(Q)\n            if dn > dist[vn]:\n                continue\n            for vf, df in Edge[vn]:\n                if dist[vn] + df < dist[vf]:\n                    dist[vf] = dist[vn] + df\n                    dp[vf] = dp[vn]\n                    heapq.heappush(Q, (dn + df,vf))\n                elif dist[vn] + df == dist[vf]:\n                    dp[vf] = (dp[vf] + dp[vn]) % M\n        return dist, dp\n\n    def dijkstra(start):\n        import heapq\n        vals = [None] * n\n        nums = [None] * n\n        nums[start] = 1\n        h = [(0, start)] # (\u8ddd\u96e2, \u30ce\u30fc\u30c9\u756a\u53f7)\n        vals[start] = 0\n        while h:\n            val, u = heapq.heappop(h)\n            for v, d in ns[u]:\n                if vals[v] is None or vals[v]>val+d:\n                    vals[v] = val+d\n                    nums[v] = nums[u]\n                    heapq.heappush(h, (vals[v], v))\n                elif vals[v] is not None and vals[v]==val+d:\n                    nums[v] = (nums[v] + nums[u]) % M\n        return vals, nums\n    \n    vals1, nums1 = dijkstra(s)\n    vals2, nums2 = dijkstra(t)\n    \n    T = vals1[t]\n\n    c1 = 0 # \u9802\u70b9\u3067\u885d\u7a81\u3059\u308b\u30da\u30a2\u306e\u6570\n    c2 = 0 # \u30a8\u30c3\u30b8(\u7aef\u70b9\u9664\u304f)\u3067\u885d\u7a81\u3059\u308b\u30da\u30a2\u306e\u6570\n    \n    for u in range(n):\n        if 2*vals1[u]==T and 2*vals2[u]==T:\n            c1 = (c1 + pow((nums1[u] * nums2[u]), 2, M)) % M\n        for v,d in ns[u]:\n            if (vals1[u]+d+vals2[v]==T) and (2*vals1[u] < T < 2*(vals1[u] + d)):\n                c2 = (c2 + (nums1[u] * nums2[v])**2) % M\n    print((nums1[t]*nums2[s] - (c1+c2)) % M)\nhoge()", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n,m = LI()\n    s,t = LI()\n    e = collections.defaultdict(list)\n    for _ in range(m):\n        u,v,d = LI()\n        e[u].append((v,d))\n        e[v].append((u,d))\n\n    def search(s,t):\n        d = collections.defaultdict(lambda: inf)\n        dc = collections.defaultdict(int)\n        d[s] = 0\n        dc[s] = 1\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while len(q):\n            k, u = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n\n            dc[u] %= mod\n            if u == t:\n                return (d,dc)\n\n            uc = dc[u]\n\n            for uv, ud in e[u]:\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] < vd:\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    dc[uv] = uc\n                    heapq.heappush(q, (vd, uv))\n                elif d[uv] == vd:\n                    dc[uv] += uc\n\n        return (d,dc)\n\n    d1,dc1 = search(s,t)\n    d2,dc2 = search(t,s)\n    rd = d1[t]\n    kk = rd / 2.0\n\n    r = dc1[t] ** 2 % mod\n    for k in list(d1.keys()):\n        t = d1[k]\n        c = dc1[k]\n        if t > kk:\n            continue\n        if t == kk:\n            if d2[k] == t:\n                r -= pow(c,2,mod) * pow(dc2[k],2,mod) % mod\n            continue\n\n        for uv, ud in e[k]:\n            if d2[uv] >= kk or t + ud + d2[uv] != rd:\n                continue\n            r -= pow(c,2,mod) * pow(dc2[uv],2,mod) % mod\n\n    return r % mod\n\n\n\n\nprint(main())\n", "from heapq import heappush as k,heappop as l\ndef f(s):\n    a=[1<<50]*N;a[s]=0;p=[(0,s)]\n    while p:\n        d,v=l(p)\n        if d>a[v]:continue\n        for u,w in G[v]:\n            if a[u]>d+w:a[u]=d+w;k(p,(d+w,u))\n    return a\ndef g(a,s):\n    w=[0]*N;w[s]=1;b=[0]*N;b[s]=1;p=[(0,s)]\n    while p:\n        d,v=l(p)\n        for u,d in G[v]:\n            if a[v]+d==a[u]:\n                w[u]=(w[u]+w[v])%m\n                if 1-b[u]:k(p,(a[u],u));b[u]=1\n    return w\nm=10**9+7\nN,M=map(int,input().split());N+=1\nS,T=map(int,input().split())\nG=[[]for _ in[0]*N]\nfor _ in[0]*M:U,V,D=map(int,input().split());G[U]+=[(V,D)];G[V]+=[(U,D)]\nP=f(S);Q=f(T);X=g(P,S);Y=g(Q,T);s=P[T]\nprint((X[T]**2-(1-s%2)*sum((X[i]*Y[i])**2for i in range(N)if P[i]==Q[i]==s//2)-sum((P[i]+d+Q[j]==s)*(P[i]<Q[i])*(Q[j]<P[j])*(X[i]*Y[j])**2for i in range(N)for j,d in G[i]))%m)", "import sys\ninput = sys.stdin.readline\nN, M = map(int, input().split())\nS, T = map(int, input().split())\nmod = 10 ** 9 + 7\ne = [[] for _ in range(N + 1)]\nfor _ in range(M):\n  u, v, c = map(int, input().split())\n  e[u].append((v, c))\n  e[v].append((u, c))\n\nimport heapq\nhpush = heapq.heappush\nhpop = heapq.heappop\nclass dijkstra:\n  def __init__(self, n, e):\n    self.e = e\n    self.n = n\n  def path(self, s):\n    d = [float(\"inf\")] * (self.n + 1)\n    vis = [0] * (self.n + 1)\n    d[s] = 0\n    h = [s]\n    while len(h):\n      v = hpop(h)\n      v1 = v % (10 ** 6)\n      v0 = v // (10 ** 6)\n      if vis[v1]: continue\n      vis[v1] = 1\n      for p in self.e[v1]:\n        d[p[0]] = min(d[p[0]], d[v1] + p[1])\n        if vis[p[0]]: continue\n        hpush(h, d[p[0]] * (10 ** 6) + p[0])\n    return d\n\ndij = dijkstra(N, e)\nps = dij.path(S)\npt = dij.path(T)\ndps = [0] * (N + 1)\ndpt = [0] * (N + 1)\ndps[S] = 1\nh = []\nfor x in range(1, N + 1): hpush(h, (ps[x], x))\nwhile len(h):\n  _, x = hpop(h)\n  for y, c in e[x]:\n    if ps[y] > ps[x] and ps[y] - ps[x] == c:\n      dps[y] += dps[x]\n      dps[y] %= mod\n\ndpt[T] = 1\nh = []\nfor x in range(1, N + 1): hpush(h, (pt[x], x))\nwhile len(h):\n  _, x = hpop(h)\n  for y, c in e[x]:\n    if pt[y] > pt[x] and pt[y] - pt[x] == c:\n      dpt[y] += dpt[x]\n      dpt[y] %= mod\n\nres = dps[T] * dpt[S] % mod\nfor x in range(1, N + 1):\n  if ps[x] == pt[x]:\n    if ps[x] + pt[x] > ps[T]: continue\n    res -= dps[x] ** 2 * dpt[x] ** 2 % mod\n    res %= mod\n\nfor x in range(1, N + 1):\n  for y, c in e[x]:\n    if ps[y] - ps[x] == c and ps[y] * 2 > ps[T] and ps[x] * 2 < ps[T]:\n      if ps[x] + pt[y] + c > ps[T]: continue\n      res -= dps[x] ** 2 *  dpt[y] ** 2 % mod\n      res %= mod\nprint(res)", "from heapq import heappop,heappush\ndef main0(n,m,s,t,abc):\n  mod=10**9+7\n  g=[set() for _ in range(n)]\n  for i,(a,b,c) in enumerate(abc):\n    a,b=a-1,b-1\n    g[a].add((b,c,i))\n    g[b].add((a,c,i))\n  s,t=s-1,t-1\n  todo=[[0,s]]\n  inf=float('inf')\n  froms=[inf]*n\n  froms[s]=0\n  while todo:\n    c,v=heappop(todo)\n    if froms[v]<c:continue\n    for nv,nc,_ in g[v]:\n      if froms[nv]>c+nc:\n        froms[nv]=c+nc\n        heappush(todo,[nc+c,nv])\n  mincost=froms[t]\n  mideary=[0]*m\n  midvary=[0]*n\n  vary=[0]*n\n  vary[t]=1\n  todo=[[0,t]]\n  fromt=[inf]*n\n  fromt[t]=0\n  fromt[s]=mincost\n  while todo:\n    c,v=heappop(todo)\n    for nv,nc,i in g[v]:\n      if mincost==froms[nv]+c+nc:\n        if c<mincost/2 and c+nc>mincost/2:\n          mideary[i]+=vary[v]\n          mideary[i]%=mod\n        elif mincost%2==0 and c+nc==mincost//2:\n          midvary[nv]+=vary[v]\n          midvary[nv]%=mod\n        vary[nv]+=vary[v]\n        vary[nv]%=mod\n        if fromt[nv]>c+nc:\n          fromt[nv]=c+nc\n          heappush(todo,[c+nc,nv])\n\n  mideary1=[0]*m\n  midvary1=[0]*n\n  vary=[0]*n\n  vary[s]=1\n  todo=[[0,s]]\n  nfroms=[inf]*n\n  nfroms[s]=0\n  nfroms[t]=mincost\n  while todo:\n    c,v=heappop(todo)\n    for nv,nc,i in g[v]:\n      if mincost==fromt[nv]+c+nc:\n        if c<mincost/2 and c+nc>mincost/2:\n          mideary1[i]+=vary[v]\n          mideary1[i]%=mod\n        elif mincost%2==0 and c+nc==mincost//2:\n          midvary1[nv]+=vary[v]\n          midvary1[nv]%=mod\n        vary[nv]+=vary[v]\n        vary[nv]%=mod\n        if nfroms[nv]>c+nc:\n          nfroms[nv]=c+nc\n          heappush(todo,[c+nc,nv])\n  for i in range(n):\n    midvary[i]*=midvary1[i]\n    midvary[i]%=mod\n  for i in range(m):\n    mideary[i]*=mideary1[i]\n    mideary[i]%=mod\n  summid=sum(mideary)+sum(midvary)\n  summid%=mod\n  ret=0\n  for x in mideary:\n    if x!=0:\n      ret+=x*(summid-x)\n      ret%=mod\n  for x in midvary:\n    if x!=0:\n      ret+=x*(summid-x)\n      ret%=mod\n  #print(mincost,mideary,midvary)\n  return ret\nimport sys\ninput=sys.stdin.readline\ndef __starting_point():\n  n,m=list(map(int,input().split()))\n  s,t=list(map(int,input().split()))\n  abc=[list(map(int,input().split())) for _ in range(m)]\n  print((main0(n,m,s,t,abc)))\n\n__starting_point()", "from collections import defaultdict, deque\nfrom heapq import heappop, heappush\ndef inpl(): return list(map(int, input().split()))\n\nN, M = inpl()\nS, T = inpl()\nG = [[] for _ in range(N+1)]\nMOD = 10**9 + 7\nfor _ in range(M):\n    u, v, d = inpl()\n    G[u].append((v, d))\n    G[v].append((u, d))\n\ncost = [10**18]*(N+1)\nappear = [0]*(N+1)\n\nQ = [(0, S)]\ncost[S] = 0\nappear[S] = 1\n\nwhile Q:\n    c, p = heappop(Q)\n    if cost[p] < c:\n        continue\n    for q, d in G[p]:\n        if cost[p] + d == cost[q]:\n            appear[q] = (appear[q] + appear[p])%MOD\n        elif cost[p] + d < cost[q]:\n            cost[q] = cost[p] + d\n            appear[q] = appear[p] % MOD\n            heappush(Q, (cost[q], q))\n\nend = cost[T]*1\nans = pow(appear[T], 2, MOD)\n\nQ = [(0, T)]\ncost2 = [10**18]*(N+1)\ncost2[T] = 0\nappear2 = [0]*(N+1)\nappear2[T] = 1\nwhile Q:\n    c, p = heappop(Q)\n    if cost2[p] < c:\n        continue\n    for q, d in G[p]:\n        if cost[p] - d != cost[q]:\n            continue\n        if cost2[p] + d == cost2[q]:\n            appear2[q] = (appear2[q] + appear2[p])%MOD\n        elif cost2[p] + d < cost2[q]:\n            cost2[q] = cost2[p] + d\n            appear2[q] = appear2[p] % MOD\n            heappush(Q, (cost2[q], q))\n\nQ = deque([S])\nsearched = [False]*(N+1)\nsearched[S] = True\n\nwhile Q:\n    p = Q.pop()\n    if 2*cost2[p] == end:\n        ans = (ans - (appear[p]*appear2[p])**2)%MOD\n\n    for q, d in G[p]:\n        if cost2[p] - d != cost2[q]:\n            continue\n        if 2*cost2[q] < end < 2*cost2[p]:\n            ans = (ans - (appear[p]*appear2[q])**2)%MOD\n        if not searched[q]:\n            Q.append(q)\n            searched[q] = True\nprint(ans)", "import sys\ninput = sys.stdin.readline\nimport heapq as hq\nn,m = map(int,input().split())\ns,t = map(int,input().split())\nabd = [list(map(int,input().split())) for i in range(m)]\nmod = 10**9+7\ngraph = [[] for i in range(n+1)]\n#\u96a3\u63a5\u30ea\u30b9\u30c8\nfor a,b,d in abd:\n  graph[a].append((b,d))\n  graph[b].append((a,d))\ndists = [[10**18,0] for i in range(n+1)]\ndistt = [[10**18,0] for i in range(n+1)]\n#S,T\u304b\u3089dijkstra\n#distX[i]: [X\u304b\u3089i\u3078\u306e\u6700\u77ed\u7d4c\u8def\u9577\u3001\u305d\u306e\u30d1\u30b9\u306e\u672c\u6570]\nfor start,dist in (s,dists),(t,distt):\n  dist[start] = [0,1]\n  q = [(0,start)]\n  hq.heapify(q)\n  while q:\n    dx,x = hq.heappop(q)\n    k = dist[x][1]\n    for y,d in graph[x]:\n      if dist[y][0] > dx+d:\n        dist[y][0] = dx+d\n        dist[y][1] = k\n        hq.heappush(q,(dist[y][0],y))\n      elif dist[y][0] == dx+d:\n        dist[y][1] = (dist[y][1]+k)%mod\ndst = dists[t][0]\n#dst: S-T\u9593\u306e\u8ddd\u96e2\n#ansls\u306b\u300c2\u4eba\u304c\u51fa\u4f1a\u3044\u3046\u308b\u8fba/\u9802\u70b9\u3092\u901a\u308b\u30d1\u30b9\u306e\u672c\u6570\u300d\u3092\u683c\u7d0d\nans = dists[t][1]**2%mod\nfor v in range(1,n+1):\n  if dists[v][0]+distt[v][0] != dst:\n    continue\n  if dists[v][0]*2 == distt[v][0]*2 == dst:\n    ans = (ans-(dists[v][1]*distt[v][1])**2)%mod\n  else:\n    for u,d in graph[v]:\n      if dists[u][0]*2 < dst and distt[v][0]*2 < dst:\n        if dists[u][0]+distt[v][0]+d == dst:\n          ans = (ans-(dists[u][1]*distt[v][1])**2)%mod\n#\u7b54\u3048: ansls\u306e\u8981\u7d20\u3092ai\u3068\u3059\u308b\u3068\n#(\u03a3ai)^2-\u03a3(ai^2)\u306b\u306a\u308b\u306f\u305a\u2026\n\nprint(ans%mod)", "from heapq import heappop, heappush\nimport sys\n\nMOD, INF = 1000000007, float('inf')\n\n\ndef count_routes(visited, s, links):\n    counts = [0] * n\n    counts[s] = 1\n    for dv, v in sorted((d, v) for v, d in enumerate(visited) if d != INF):\n        for u, du in list(links[v].items()):\n            if dv + du == visited[u]:\n                counts[u] += counts[v]\n                counts[u] %= MOD\n    return counts\n\n\ndef solve(s, t, links):\n    q = [(0, 0, s, -1, 0), (0, 0, t, -1, 1)]\n    visited_fwd, visited_bwd = [INF] * n, [INF] * n\n    collision_nodes, collision_links = set(), set()\n    limit = 0\n    while q:\n        cost, cost_a, v, a, is_bwd = heappop(q)\n        if is_bwd:\n            visited_self = visited_bwd\n            visited_opp = visited_fwd\n        else:\n            visited_self = visited_fwd\n            visited_opp = visited_bwd\n\n        relax_flag = False\n        cost_preceding = visited_self[v]\n        if cost_preceding == INF:\n            visited_self[v] = cost\n            relax_flag = True\n        elif cost > cost_preceding:\n            continue\n\n        cost_opp = visited_opp[v]\n        if cost_opp != INF:\n            limit = cost + cost_opp\n            if cost == cost_opp:\n                collision_nodes.add(v)\n            else:\n                collision_links.add((v, a) if is_bwd else (a, v))\n            break\n\n        if relax_flag:\n            for u, du in list(links[v].items()):\n                nc = cost + du\n                if visited_self[u] < nc:\n                    continue\n                heappush(q, (nc, cost, u, v, is_bwd))\n\n    collision_time = limit / 2\n    while q:\n        cost, cost_a, v, a, is_bwd = heappop(q)\n        if cost > limit:\n            break\n        visited_self = visited_bwd if is_bwd else visited_fwd\n        if visited_self[v] == INF:\n            visited_self[v] = cost\n        if is_bwd:\n            continue\n        if cost_a == collision_time:\n            collision_nodes.add(a)\n        elif cost == collision_time:\n            collision_nodes.add(v)\n        else:\n            collision_links.add((v, a) if is_bwd else (a, v))\n\n    counts_fwd = count_routes(visited_fwd, s, links)\n    counts_bwd = count_routes(visited_bwd, t, links)\n    shortest_count = 0\n    collision_count = 0\n\n    for v in collision_nodes:\n        if visited_fwd[v] == visited_bwd[v]:\n            r = counts_fwd[v] * counts_bwd[v]\n            shortest_count += r\n            shortest_count %= MOD\n            collision_count += r * r\n            collision_count %= MOD\n\n    for u, v in collision_links:\n        if visited_fwd[u] + visited_bwd[v] + links[u][v] == limit:\n            r = counts_fwd[u] * counts_bwd[v]\n            shortest_count += r\n            shortest_count %= MOD\n            collision_count += r * r\n            collision_count %= MOD\n\n    return (shortest_count ** 2 - collision_count) % MOD\n\n\nn, m = list(map(int, input().split()))\ns, t = list(map(int, input().split()))\ns -= 1\nt -= 1\nlinks = [{} for _ in range(n)]\nfor uvd in sys.stdin.readlines():\n    u, v, d = list(map(int, uvd.split()))\n    # for _ in range(m):\n    #     u, v, d = map(int, input().split())\n    u -= 1\n    v -= 1\n    links[u][v] = d\n    links[v][u] = d\nprint((solve(s, t, links)))\n", "from heapq import*\ndef f(s):\n a=[1<<50]*N;a[s]=0;p=[(0,s)];c=[0]*N;c[s]=1\n while p:\n  d,v=heappop(p)\n  if d<=a[v]:\n   for u,w in G[v]:\n    if a[u]>d+w:a[u]=d+w;heappush(p,(d+w,u));c[u]=0\n    c[u]+=c[v]*(a[u]==d+w)\n return a,c\nn=lambda:map(int,input().split());N,M=n();N+=1;S,T=n();G=[[]for _ in[0]*N]\nfor _ in[0]*M:U,V,D=n();G[U]+=[(V,D)];G[V]+=(U,D),\nP,X=f(S);Q,Y=f(T);s=P[T];print((X[T]**2--~s%2*sum((x*y)**2for x,y,p,q in zip(X,Y,P,Q)if p==q==s//2)-sum((P[i]+d+Q[j]==s)*(P[i]<Q[i])*(Q[j]<P[j])*(X[i]*Y[j])**2for i in range(N)for j,d in G[i]))%(10**9+7))", "import sys\nreadline = sys.stdin.readline\n\nfrom heapq import heappop as hpp, heappush as hp\ndef dijkstra(N, s, Edge):\n    inf = geta\n    dist = [inf] * N\n    dist[s] = 0\n    Q = [(0, s)]\n    dp = [0]*N\n    dp[s] = 1\n    while Q:\n        dn, vn = hpp(Q)\n        if dn > dist[vn]:\n            continue\n        for df, vf in Edge[vn]:\n            if dist[vn] + df < dist[vf]:\n                dist[vf] = dist[vn] + df\n                dp[vf] = dp[vn]\n                hp(Q, (dn + df,vf))\n            elif dist[vn] + df == dist[vf]:\n                dp[vf] = (dp[vf] + dp[vn]) % MOD\n    return dist, dp\n\nMOD = 10**9+7\nN, M = map(int, readline().split())\nS, T = map(int, readline().split())\nS -= 1\nT -= 1\n\ngeta = 10**15\nEdge = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v, d = map(int, readline().split())\n    u -= 1\n    v -= 1\n    Edge[u].append((d, v))\n    Edge[v].append((d, u))\n    \n\ndists, dps = dijkstra(N, S, Edge)\ndistt, dpt = dijkstra(N, T, Edge)\nst = dists[T]\n\nonpath = [i for i in range(N) if dists[i] + distt[i] == st]\n\nans = dps[T]**2%MOD\nfor i in onpath:\n    if 2*dists[i] == 2*distt[i] == st:\n        ans = (ans - pow(dps[i]*dpt[i], 2, MOD))%MOD\n    \n    for cost, vf in Edge[i]:\n        if dists[i] + cost + distt[vf] == st:\n            if 2*dists[i] < st < 2*dists[vf]:\n                ans = (ans - pow(dps[i]*dpt[vf], 2, MOD))%MOD\nprint(ans)", "import heapq\nimport sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nMOD = 10**9+7\nclass DijkstraList():\n\t#\u96a3\u63a5\u30ea\u30b9\u30c8\u7248\n\t#\u540c\u4e00\u9802\u70b9\u306e\u8907\u6570\u56de\u63a2\u7d22\u3092\u9632\u3050\u305f\u3081\u8a2a\u554f\u3057\u305f\u9802\u70b9\u6570\u3092\u5909\u6570cnt\u3067\u6301\u3064\n\tdef __init__(self, adj, start):\n\t\tself.list = adj\n\t\tself.start = start\n\t\tself.size = len(adj)\n\n\tdef solve(self):\n\t\tself.dist = [float(\"inf\") for _ in range(self.size)]\n\t\tself.dist[self.start] = 0\n\t\tself.dp = [0 for _ in range(self.size)]\n\t\tself.dp[self.start] = 1\n\t\t#self.prev = [-1 for _ in range(self.size)]\n\t\tself.q = []\n\t\tself.cnt = 0\n\n\t\theapq.heappush(self.q, (0, self.start))\n\n\t\twhile self.q and self.cnt < self.size:\n\t\t\tu_dist, u = heapq.heappop(self.q)\n\t\t\tif self.dist[u] < u_dist:\n\t\t\t\tcontinue\n\t\t\tfor v, w in self.list[u]:\n\t\t\t\tif self.dist[v] > u_dist + w:\n\t\t\t\t\tself.dist[v] = u_dist + w\n\t\t\t\t\tself.dp[v] = self.dp[u]\n\t\t\t\t\t#self.prev[v] = u\n\t\t\t\t\theapq.heappush(self.q, (self.dist[v], v))\n\t\t\t\telif self.dist[v] == u_dist + w:\n\t\t\t\t\tself.dp[v] += self.dp[u]\n\t\t\t\t\tself.dp[v] %= MOD\n\n\t\t\tself.cnt += 1\n\t\t#print(self.dp)\n\t\treturn\n\n\tdef distance(self, goal):\n\t\treturn self.dist[goal]\n\n\tdef get_dp(self, x):\n\t\treturn self.dp[x]\n\nn, m = map(int, input().split())\ns, t = map(int, input().split())\ns, t = s-1, t-1\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n\tu, v, d = map(int, input().split())\n\tadj[u-1].append([v-1, d])\n\tadj[v-1].append([u-1, d])\nS, T = DijkstraList(adj, s), DijkstraList(adj, t)\nS.solve()\nT.solve()\nans = pow(S.get_dp(t), 2, MOD)\ngoal = S.distance(t)\n#print(ans, goal)\n\nfor i in range(n):\n\tSI, TI = S.distance(i), T.distance(i)\n\tif SI + TI != goal:\n\t\tcontinue\n\tif SI*2 == goal:\n\t\tans -= S.get_dp(i) * T.get_dp(i) * S.get_dp(i) * T.get_dp(i)\n\t\tans %= MOD\n\n\telse:\n\t\tfor j, d in adj[i]:\n\t\t\tif i>j:\n\t\t\t\tcontinue\n\t\t\tSJ, TJ = S.distance(j), T.distance(j)\n\t\t\tif SJ + TJ != goal or abs(SI - SJ) != d:\n\t\t\t\tcontinue\n\t\t\tif SI*2 < goal < SJ*2:\n\t\t\t\t#print(i, j, SI, SJ)\n\t\t\t\tans -= S.get_dp(i) * T.get_dp(j) * S.get_dp(i) * T.get_dp(j)\n\t\t\t\tans %= MOD\n\t\t\telif SJ*2 < goal < SI*2:\n\t\t\t\t#print(i, j, SI, SJ)\n\t\t\t\tans -= S.get_dp(j) * T.get_dp(i) * S.get_dp(j) * T.get_dp(i)\n\t\t\t\tans %= MOD\n\nprint(ans)", "mod=10**9+7\n\nclass Dijkstra():\n    \"\"\" \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\n    \u91cd\u307f\u4ed8\u304d\u30b0\u30e9\u30d5\u306b\u304a\u3051\u308b\u5358\u4e00\u59cb\u70b9\u6700\u77ed\u8def\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\n\n    * \u4f7f\u7528\u6761\u4ef6\n        - \u8ca0\u306e\u30b3\u30b9\u30c8\u304c\u306a\u3044\u3053\u3068\n        - \u6709\u5411\u30b0\u30e9\u30d5\u3001\u7121\u5411\u30b0\u30e9\u30d5\u3068\u3082\u306bOK\n\n    * \u8a08\u7b97\u91cf\u306fO(E*log(V))\n\n    * \u30d9\u30eb\u30de\u30f3\u30d5\u30a9\u30fc\u30c9\u6cd5\u3088\u308a\u9ad8\u901f\u306a\u306e\u3067\u3001\u8ca0\u306e\u30b3\u30b9\u30c8\u304c\u306a\u3044\u306a\u3089\u3070\u3053\u3061\u3089\u3092\u4f7f\u3046\u3068\u3088\u3044\n    \"\"\"\n    class Edge():\n        \"\"\" \u91cd\u307f\u4ed8\u304d\u6709\u5411\u8fba \"\"\"\n        def __init__(self, _to, _cost):\n            self.to = _to\n            self.cost = _cost\n\n    def __init__(self, V):\n        \"\"\" \u91cd\u307f\u4ed8\u304d\u6709\u5411\u8fba\n        \u7121\u5411\u8fba\u3092\u8868\u73fe\u3057\u305f\u3044\u3068\u304d\u306f\u3001_from\u3068_to\u3092\u9006\u306b\u3057\u305f\u6709\u5411\u8fba\u3092\u52a0\u3048\u308c\u3070\u3088\u3044\n\n        Args:\n            V(int): \u9802\u70b9\u306e\u6570\n        \"\"\"\n        self.G = [[] for i in range(V)]  # \u96a3\u63a5\u30ea\u30b9\u30c8G[u][i] := \u9802\u70b9u\u306ei\u500b\u76ee\u306e\u96a3\u63a5\u8fba\n        self._E = 0  # \u8fba\u306e\u6570\n        self._V = V  # \u9802\u70b9\u306e\u6570\n\n    @property\n    def E(self):\n        \"\"\" \u8fba\u6570\n        \u7121\u5411\u30b0\u30e9\u30d5\u306e\u3068\u304d\u306f\u3001\u8fba\u6570\u306f\u6709\u5411\u30b0\u30e9\u30d5\u306e\u500d\u306b\u306a\u308b\n        \"\"\"\n        return self._E\n\n    @property\n    def V(self):\n        \"\"\" \u9802\u70b9\u6570 \"\"\"\n        return self._V\n\n    def add(self, _from, _to, _cost):\n        \"\"\" 2\u9802\u70b9\u3068\u3001\u8fba\u306e\u30b3\u30b9\u30c8\u3092\u8ffd\u52a0\u3059\u308b \"\"\"\n        self.G[_from].append(self.Edge(_to, _cost))\n        self._E += 1\n\n    def edge(self,_from):\n        return self.G[_from]\n\n    def shortest_path(self, s):\n        \"\"\" \u59cb\u70b9s\u304b\u3089\u9802\u70b9i\u307e\u3067\u306e\u6700\u77ed\u8def\u3092\u683c\u7d0d\u3057\u305f\u30ea\u30b9\u30c8\u3092\u8fd4\u3059\n        Args:\n            s(int): \u59cb\u70b9s\n        Returns:\n            d(list): d[i] := \u59cb\u70b9s\u304b\u3089\u9802\u70b9i\u307e\u3067\u306e\u6700\u77ed\u30b3\u30b9\u30c8\u3092\u683c\u7d0d\u3057\u305f\u30ea\u30b9\u30c8\u3002\n                     \u5230\u9054\u4e0d\u53ef\u306e\u5834\u5408\u3001\u5024\u306ffloat(\"inf\")\n        \"\"\"\n        import heapq\n        que = []  # \u30d7\u30e9\u30a4\u30aa\u30ea\u30c6\u30a3\u30ad\u30e5\u30fc\uff08\u30d2\u30fc\u30d7\u6728\uff09\n        d = [10**15] * self.V\n        d[s] = 0\n        cnt=[0]*self.V\n        cnt[s]=1\n        heapq.heappush(que, (0, s))  # \u59cb\u70b9\u306e(\u6700\u77ed\u8ddd\u96e2, \u9802\u70b9\u756a\u53f7)\u3092\u30d2\u30fc\u30d7\u306b\u8ffd\u52a0\u3059\u308b\n\n        while len(que) != 0:\n            cost, v = heapq.heappop(que)\n            # \u30ad\u30e5\u30fc\u306b\u683c\u7d0d\u3055\u308c\u3066\u3044\u308b\u6700\u77ed\u7d4c\u8def\u306e\u5019\u88dc\u304cd\u306e\u8ddd\u96e2\u3088\u308a\u3082\u5927\u304d\u3051\u308c\u3070\u3001\u4ed6\u306e\u7d4c\u8def\u3067\u6700\u77ed\u7d4c\u8def\u304c\u5b58\u5728\u3059\u308b\u306e\u3067\u3001\u51e6\u7406\u3092\u30b9\u30ad\u30c3\u30d7\n            if d[v] < cost: continue\n\n            for i in range(len(self.G[v])):\n                # \u9802\u70b9v\u306b\u96a3\u63a5\u3059\u308b\u5404\u9802\u70b9\u306b\u95a2\u3057\u3066\u3001\u9802\u70b9v\u3092\u7d4c\u7531\u3057\u305f\u5834\u5408\u306e\u8ddd\u96e2\u3092\u8a08\u7b97\u3057\u3001\u4eca\u307e\u3067\u306e\u8ddd\u96e2(d)\u3088\u308a\u3082\u5c0f\u3055\u3051\u308c\u3070\u66f4\u65b0\u3059\u308b\n                e = self.G[v][i]  # v\u306ei\u500b\u76ee\u306e\u96a3\u63a5\u8fbae\n                if d[e.to] > d[v] + e.cost:\n                    d[e.to] = d[v] + e.cost  # d\u306e\u66f4\u65b0\n                    heapq.heappush(que, (d[e.to], e.to))  # \u30ad\u30e5\u30fc\u306b\u65b0\u305f\u306a\u6700\u77ed\u7d4c\u8def\u306e\u5019\u88dc(\u6700\u77ed\u8ddd\u96e2, \u9802\u70b9\u756a\u53f7)\u306e\u60c5\u5831\u3092push\n                    cnt[e.to]=cnt[v]%mod\n                elif d[e.to]==d[v]+e.cost:\n                    cnt[e.to]+=cnt[v]\n                    cnt[e.to]%=mod\n        return d,cnt\n\nimport sys\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(1000000)\n\nN,M=list(map(int,input().split()))\nS,T=list(map(int,input().split()))\nmati=Dijkstra(N)\nfor i in range(M):\n    u,v,d=list(map(int,input().split()))\n    mati.add(u-1,v-1,d)\n    mati.add(v-1,u-1,d)\n\nspath,Sways=mati.shortest_path(S-1)\ntpath,Tways=mati.shortest_path(T-1)\n\nans=Sways[T-1]*Tways[S-1]\nans%=mod\nfor u in range(N):\n    for e in mati.edge(u):\n        v=e.to\n        d=e.cost\n        ans-=(Tways[v]*Sways[u])**2*(spath[u]+d+tpath[v]==spath[T-1] and spath[u]+d!=tpath[v] and spath[u]!=tpath[v]+d and (tpath[v]+d>=spath[u]>=tpath[v] or tpath[v]+d>=spath[u]+d>=tpath[v]))\n        ans%=mod\n\nfor i in range(N):\n    ans-=(Tways[i]*Sways[i])**2*(spath[i]+tpath[i]==spath[T-1] and spath[i]==tpath[i])\n    ans%=mod\n\nprint((ans%mod))\n", "from heapq import heappush,heappop\ndef dijkstra(s):\n    a=[1<<50]*N;a[s]=0;p=[(0,s)]\n    while p:\n        d,v=heappop(p)\n        if d>a[v]:continue\n        for u,w in G[v]:\n            if a[u]>d+w:a[u]=d+w;heappush(p,(d+w,u))\n    return a\ndef cnt(dist,s):\n    w=[0]*N;w[s]=1;b=[0]*N;b[s]=1;p=[(0,s)]\n    while p:\n        d,v=heappop(p)\n        for u,d in G[v]:\n            if dist[v]+d==dist[u]:\n                w[u]=(w[u]+w[v])%m\n                if not b[u]:heappush(p,(dist[u],u));b[u]=1\n    return w\nm=10**9+7\nN,M=map(int,input().split())\nS,T=map(int,input().split())\nS-=1;T-=1\nG=[[]for _ in[0]*N]\nfor _ in[0]*M:\n    U,V,D=map(int,input().split())\n    U-=1;V-=1\n    G[U]+=[(V,D)]\n    G[V]+=[(U,D)]\ndS=dijkstra(S)\ndT=dijkstra(T)\nwS=cnt(dS,S)\nwT=cnt(dT,T)\ns=dS[T]\na=wS[T]**2%m\nif s%2==0:\n    for i in range(N):\n        if dS[i]==dT[i]==s//2:\n            a=(a-(wS[i]*wT[i])**2)%m\nfor i in range(N):\n    for j,d in G[i]:\n        if dS[i]+d+dT[j]==s:\n            if dS[i]<dT[i]and dT[j]<dS[j]:\n                a=(a-(wS[i]*wT[j])**2)%m\nprint(a)", "def main():\n    import sys\n    sys.setrecursionlimit(100000)\n    input = sys.stdin.readline\n    from heapq import heappop, heappush\n    mod = 10**9+7\n    INF = 1<<60\n    N, M = list(map(int, input().split()))\n    S, T = list(map(int, input().split()))\n    E = [[] for _ in range(N+1)]\n    edges = []\n    # for _ in range(M):\n    #     u, v, d = map(int, input().split())\n    #     E[u].append((v, d))\n    #     E[v].append((u, d))\n    #     edges.append((u, v, d))\n    for u, v, d in zip(*[iter(map(int, sys.stdin.read().split()))]*3):\n        E[u].append((v, d))\n        E[v].append((u, d))\n        edges.append((u, v, d))\n\n    def dijksrtra(start):\n        Dist = [INF] * (N+1)\n        Dist[start] = 0\n        q = [0<<17 | start]\n        mask = (1<<17)-1\n        while q:\n            dist_v = heappop(q)\n            v = dist_v & mask\n            dist = dist_v >> 17\n            if Dist[v] != dist:\n                continue\n            for u, d in E[v]:\n                new_dist = dist + d\n                if Dist[u] > new_dist:\n                    Dist[u] = new_dist\n                    heappush(q, new_dist<<17 | u)\n        return Dist\n\n    Dist_S = dijksrtra(S)\n    Dist_T = dijksrtra(T)\n    dist_st = Dist_S[T]\n\n    DAG_edges = []  # S -> T\n    DAG = [[] for _ in range(N+1)]\n    DAG_rev = [[] for _ in range(N+1)]\n    for u, v, d in edges:\n        if Dist_S[u] + Dist_T[v] + d == dist_st:\n            DAG_edges.append((u, v))\n            DAG[u].append(v)\n            DAG_rev[v].append(u)\n        elif Dist_T[u] + Dist_S[v] + d == dist_st:\n            DAG_edges.append((v, u))\n            DAG[v].append(u)\n            DAG_rev[u].append(v)\n\n\n    # \u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8\n    V = []\n    rem = [0] * (N+1)\n    for _, v in DAG_edges:\n        rem[v] += 1\n    q = [S]\n    while q:\n        v = q.pop()\n        V.append(v)\n        for u in DAG[v]:\n            rem[u] -= 1\n            if rem[u] == 0:\n                q.append(u)\n\n\n    # n_paths_S = [-1] * (N+1)\n    # n_paths_T = [-1] * (N+1)\n    n_paths_S = [0] * (N+1)\n    n_paths_T = [0] * (N+1)\n    n_paths_S[S] = 1\n    n_paths_T[T] = 1\n    # def calc_n_paths_S(v):\n    #     if n_paths_S[v] != -1:\n    #         return n_paths_S[v]\n    #     res = 0\n    #     for u in DAG_rev[v]:\n    #         res = (res + calc_n_paths_S(u)) % mod\n    #     n_paths_S[v] = res\n    #     return res\n    # def calc_n_paths_T(v):\n    #     if n_paths_T[v] != -1:\n    #         return n_paths_T[v]\n    #     res = 0\n    #     for u in DAG[v]:\n    #         res = (res + calc_n_paths_T(u)) % mod\n    #     n_paths_T[v] = res\n    #     return res\n\n    # ans = calc_n_paths_S(T)  # \u5168\u7d4c\u8def\u6570\n    # calc_n_paths_T(S)\n\n    for v in V:\n        n = n_paths_S[v]\n        for u in DAG[v]:\n            n_paths_S[u] += n\n    for v in V[::-1]:\n        n = n_paths_T[v]\n        for u in DAG_rev[v]:\n            n_paths_T[u] += n\n    ans = n_paths_S[T]\n    ans = ans * ans % mod\n\n    for v, u in DAG_edges:  # \u8fba\u3067\u3059\u308c\u9055\u3046\u5834\u5408\n        if Dist_S[v]*2 < dist_st and dist_st < Dist_S[u]*2:\n            ans = (ans - (n_paths_S[v]*n_paths_T[u])**2) % mod\n\n    # \u9802\u70b9\u3067\u3059\u308c\u9055\u3046\u5834\u5408\n    for v, (dist, ns, nt) in enumerate(zip(Dist_S, n_paths_S, n_paths_T)):\n        if dist*2 == dist_st:\n            ans = (ans - (ns*nt)**2) % mod\n\n    print(ans)\n\nmain()\n", "import sys\ninput = sys.stdin.readline\n\nINF = 10**18\nmod = 10**9+7\n# AOJ GRL_1_A Single Sourse Shortest Path\nimport heapq as hp\n\nN, M = map(int, input().split())\ns, t = map(int, input().split())\ns -= 1; t -= 1\ngraph = [[] for _ in range(N)]\nfor _ in range(M):\n    n, m, d = map(int, input().split())\n    graph[n-1].append((d, m-1)) \n    graph[m-1].append((d, n-1)) #\u7121\u5411\u30b0\u30e9\u30d5\u306a\u3089\u3053\u308c\u4f7f\u3046\n\ndef dijkstra(s):\n    D = [INF for _ in range(N)] # \u9802\u70b9i\u3078\u306e\u6700\u77ed\u8ddd\u96e2\u304cD[i]\n    B = [0]*N\n    D[s] = 0\n    B[s] = 1\n    q = [] # \u3057\u307e\u3063\u3066\u3044\u304f\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\n    hp.heappush(q, (0, s))\n\n    while q:\n        nd, np = hp.heappop(q)\n        if D[np] < nd:\n            continue\n        for d, p in graph[np]:\n            if D[p] > D[np] + d:\n                D[p] = D[np] + d\n                B[p] = B[np]\n                hp.heappush(q, (D[p], p))\n            elif D[p] == D[np] + d:\n                B[p] = (B[p] + B[np])%mod\n    return D, B\n\nsD, sB = dijkstra(s)\ntD, tB = dijkstra(t)\n\ndistance = sD[t]\n\nans = 0\nfor n in range(N):\n    for d, m in graph[n]:\n        if sD[n] + d + tD[m] == distance and 2*sD[n] < distance < 2*(sD[n]+d):\n            ans = (ans + (sB[n]*tB[m])**2)%mod\n    if sD[n] + tD[n] == distance and 2*sD[n] == distance:\n        ans = (ans + (sB[n]*tB[n])**2) % mod\nans = (sB[t]*tB[s] - ans) % mod\nprint(ans)", "import sys\nreadline = sys.stdin.readline\n\nfrom heapq import heappop as hpp, heappush as hp\ndef dijkstra(N, s, Edge):\n    inf = geta\n    dist = [inf] * N\n    dist[s] = 0\n    Q = [(0, s)]\n    dp = [0]*N\n    dp[s] = 1\n    while Q:\n        dn, vn = hpp(Q)\n        if dn > dist[vn]:\n            continue\n        for df, vf in Edge[vn]:\n            if dist[vn] + df < dist[vf]:\n                dist[vf] = dist[vn] + df\n                dp[vf] = dp[vn]\n                hp(Q, (dn + df,vf))\n            elif dist[vn] + df == dist[vf]:\n                dp[vf] = (dp[vf] + dp[vn]) % MOD\n    return dist, dp\n\nMOD = 10**9+7\nN, M = map(int, readline().split())\nS, T = map(int, readline().split())\nS -= 1\nT -= 1\n\ngeta = 10**15\nEdge = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v, d = map(int, readline().split())\n    u -= 1\n    v -= 1\n    Edge[u].append((d, v))\n    Edge[v].append((d, u))\n    \n\ndists, dps = dijkstra(N, S, Edge)\ndistt, dpt = dijkstra(N, T, Edge)\nst = dists[T]\n\nonpath = [i for i in range(N) if dists[i] + distt[i] == st]\n\nans = dps[T]**2%MOD\nfor i in onpath:\n    if 2*dists[i] == 2*distt[i] == st:\n        ans = (ans - pow(dps[i]*dpt[i], 2, MOD))%MOD\n    \n    for cost,vf in Edge[i]:\n        if dists[i]+cost+distt[vf] == st:\n            if 2*dists[i] < st < 2*dists[vf]:\n                ans = (ans - pow(dps[i]*dpt[vf], 2, MOD))%MOD\nprint(ans)", "from heapq import*\ndef f(s):\n a=[1<<50]*N;a[s]=0;p=[(0,s)];c=[0]*N;c[s]=1\n while p:\n  d,v=heappop(p)\n  if d<=a[v]:\n   for u,w in G[v]:\n    if a[u]>d+w:a[u]=d+w;heappush(p,(d+w,u));c[u]=0\n    c[u]+=c[v]*(a[u]==d+w)\n return a,c\nn=lambda:map(int,input().split());N,M=n();N+=1;S,T=n();G=[[]for _ in[0]*N]\nfor _ in[0]*M:U,V,D=n();G[U]+=[(V,D)];G[V]+=[(U,D)]\nP,X=f(S);Q,Y=f(T);s=P[T];print((X[T]**2--~s%2*sum((x*y)**2for x,y,p,q in zip(X,Y,P,Q)if p==q==s//2)-sum((P[i]+d+Q[j]==s)*(P[i]<Q[i])*(Q[j]<P[j])*(X[i]*Y[j])**2for i in range(N)for j,d in G[i]))%(10**9+7))", "import sys\ninput = sys.stdin.readline\nimport heapq as hq\nn,m = map(int,input().split())\ns,t = map(int,input().split())\nabd = [list(map(int,input().split())) for i in range(m)]\nmod = 10**9+7\ngraph = [[] for i in range(n+1)]\nfor a,b,d in abd:\n  graph[a].append((b,d))\n  graph[b].append((a,d))\ndists = [[10**18,0] for i in range(n+1)]\ndistt = [[10**18,0] for i in range(n+1)]\nfor start,dist in (s,dists),(t,distt):\n  dist[start] = [0,1]\n  q = [(0,start)]\n  hq.heapify(q)\n  while q:\n    dx,x = hq.heappop(q)\n    k = dist[x][1]\n    for y,d in graph[x]:\n      if dist[y][0] > dx+d:\n        dist[y][0] = dx+d\n        dist[y][1] = k\n        hq.heappush(q,(dist[y][0],y))\n      elif dist[y][0] == dx+d:\n        dist[y][1] = (dist[y][1]+k)%mod\ndst = dists[t][0]\nansls = []\nfor u,v,d in abd:\n  for a,b in (u,v),(v,u):\n    if dists[a][0] < distt[a][0]:\n      if dists[a][0]*2 < dst and distt[b][0]*2 < dst:\n        if dists[a][0]+distt[b][0]+d == dst:\n          ansls.append(dists[a][1]*distt[b][1]%mod)\nfor v in range(1,n+1):\n  if dists[v][0]*2 == distt[v][0]*2 == dst:\n    ansls.append(dists[v][1]*distt[v][1]%mod)\nsm = sum(ansls)%mod\nans = sm**2%mod\nfor i in ansls:\n  ans = (ans-i**2)%mod\nprint(ans)", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nfrom heapq import heapify, heappush as hpush, heappop as hpop\ndef dijkstra(n, E, i0=0):\n    kk = 18\n    mm = (1 << kk) - 1\n    h = [i0]\n    D = [-1] * n\n    done = [0] * n\n    D[i0] = 0\n    while h:\n        x = hpop(h)\n        d, i = x >> kk, x & mm\n        if done[i]: continue\n        done[i] = 1\n        for j, w in E[i]:\n            nd = d + w\n            if D[j] < 0 or D[j] > nd:\n                if done[j] == 0:\n                    hpush(h, (nd << kk) + j)\n                    D[j] = nd\n    return D\ndef dijkstra2(n, DD, i0=0):\n    L = [0] * n\n    L[i0] = 1\n    AA = [i for i in V]\n    AA.sort(key = lambda x: DD[x])\n    for a in AA:\n        for b, c in E[a]:\n            if DD[b] + c == DD[a]:\n                L[a] += L[b]\n                if L[a] >= P: L[a] -= P\n    return L\n\nP = 10 ** 9 + 7\nN, M = list(map(int, input().split()))\nS, T = [int(a) - 1 for a in input().split()]\nE = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    E[a-1].append((b-1, c))\n    E[b-1].append((a-1, c))\n\nD1 = dijkstra(N, E, S)\nD2 = dijkstra(N, E, T)\nmad = D1[T]\nV = set([i for i in range(N) if D1[i] + D2[i] == mad])\nX = dijkstra2(N, D1, S)\nY = dijkstra2(N, D2, T)\nans = X[T] ** 2 % P\nfor i in V:\n    if D1[i] == D2[i]:\n        ans = (ans - (X[i] * Y[i] % P) ** 2) % P\nfor a in V:\n    for b, c in E[a]:\n        if D1[a] + c == D1[b]:\n            if D1[a] * 2 < mad < D1[b] * 2:\n                ans = (ans - (X[a] * Y[b] % P) ** 2) % P\nprint(ans)\n", "from heapq import*\ndef f(s):\n a=[1<<50]*N;a[s]=0;p=[(0,s)];c=[0]*N;c[s]=1\n while p:\n  d,v=heappop(p)\n  if d<=a[v]:\n   for u,w in G[v]:\n    if a[u]>d+w:a[u]=d+w;heappush(p,(d+w,u));c[u]=0\n    c[u]+=c[v]*(a[u]==d+w)\n return a,c\nn=lambda:map(int,input().split());N,M=n();N+=1;S,T=n();G=[[]for _ in[0]*N]\nfor _ in[0]*M:U,V,D=n();G[U]+=(V,D),;G[V]+=(U,D),\nP,X=f(S);Q,Y=f(T);s=P[T];print((X[T]**2-sum(-~s%2*x*x*y*y*(p==q==s//2)+(p<q)*x*x*sum((p+d+Q[j]==s)*(Q[j]<P[j])*Y[j]**2for j,d in g)for g,p,q,x,y in zip(G,P,Q,X,Y)))%(10**9+7))", "import heapq\nimport sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nMOD = 10**9+7\nclass DijkstraList():\n\t#\u96a3\u63a5\u30ea\u30b9\u30c8\u7248\n\t#\u540c\u4e00\u9802\u70b9\u306e\u8907\u6570\u56de\u63a2\u7d22\u3092\u9632\u3050\u305f\u3081\u8a2a\u554f\u3057\u305f\u9802\u70b9\u6570\u3092\u5909\u6570cnt\u3067\u6301\u3064\n\tdef __init__(self, adj, start):\n\t\tself.list = adj\n\t\tself.start = start\n\t\tself.size = len(adj)\n\n\tdef solve(self):\n\t\tself.dist = [float(\"inf\") for _ in range(self.size)]\n\t\tself.dist[self.start] = 0\n\t\tself.dp = [0 for _ in range(self.size)]\n\t\tself.dp[self.start] = 1\n\t\t#self.prev = [-1 for _ in range(self.size)]\n\t\tself.q = []\n\t\tself.cnt = 0\n\n\t\theapq.heappush(self.q, (0, self.start))\n\n\t\twhile self.q and self.cnt < self.size:\n\t\t\tu_dist, u = heapq.heappop(self.q)\n\t\t\tif self.dist[u] < u_dist:\n\t\t\t\tcontinue\n\t\t\tfor v, w in self.list[u]:\n\t\t\t\tif self.dist[v] > u_dist + w:\n\t\t\t\t\tself.dist[v] = u_dist + w\n\t\t\t\t\tself.dp[v] = self.dp[u]\n\t\t\t\t\t#self.prev[v] = u\n\t\t\t\t\theapq.heappush(self.q, (self.dist[v], v))\n\t\t\t\telif self.dist[v] == u_dist + w:\n\t\t\t\t\tself.dp[v] += self.dp[u]\n\t\t\t\t\tself.dp[v] %= MOD\n\n\t\t\tself.cnt += 1\n\t\t#print(self.dp)\n\t\treturn\n\n\tdef distance(self, goal):\n\t\treturn self.dist[goal]\n\n\tdef get_dp(self, x):\n\t\treturn self.dp[x]\n\nn, m = map(int, input().split())\ns, t = map(int, input().split())\ns, t = s-1, t-1\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n\tu, v, d = map(int, input().split())\n\tadj[u-1].append([v-1, d])\n\tadj[v-1].append([u-1, d])\nS, T = DijkstraList(adj, s), DijkstraList(adj, t)\nS.solve()\nT.solve()\nans = pow(S.get_dp(t), 2, MOD)\ngoal = S.distance(t)\n#print(ans, goal)\n\nfor i in range(n):\n\tSI, TI = S.distance(i), T.distance(i)\n\tif SI + TI != goal:\n\t\tcontinue\n\tif SI*2 == goal:\n\t\tans -= S.get_dp(i) * T.get_dp(i) * S.get_dp(i) * T.get_dp(i)\n\t\tans %= MOD\n\n\telse:\n\t\tfor j, d in adj[i]:\n\t\t\tif i>j:\n\t\t\t\tcontinue\n\t\t\tSJ, TJ = S.distance(j), T.distance(j)\n\t\t\tif SJ + TJ != goal or abs(SI - SJ) != d:\n\t\t\t\tcontinue\n\t\t\tif SI*2 < goal < SJ*2:\n\t\t\t\t#print(i, j, SI, SJ)\n\t\t\t\tans -= S.get_dp(i) * T.get_dp(j) * S.get_dp(i) * T.get_dp(j)\n\t\t\t\tans %= MOD\n\t\t\telif SJ*2 < goal < SI*2:\n\t\t\t\t#print(i, j, SI, SJ)\n\t\t\t\tans -= S.get_dp(j) * T.get_dp(i) * S.get_dp(j) * T.get_dp(i)\n\t\t\t\tans %= MOD\n\nprint(ans)", "import sys\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\nN,M = MI()\nS,T = MI()\nedges = [[] for _ in range(N+1)]\nedges2 = []\nfor _ in range(M):\n    U,V,D = MI()\n    edges[U].append((V,D))\n    edges[V].append((U,D))\n    edges2.append((U,V,D))\n    edges2.append((V,U,D))\n\nmod = 10**9+7\n\nfrom heapq import heappop,heappush\n\ndistS = [(10**18,0)]*(N+1)  # (\u6700\u77ed\u8ddd\u96e2,\u7d4c\u8def\u6570)\ndistS[S] = (0,1)\nqS = []\nheappush(qS,(0,S))\nvS = [False]*(N+1)\nwhile qS:\n    d,i = heappop(qS)\n    if vS[i]:\n        continue\n    vS[i] = True\n    for j,d in edges[i]:\n        if vS[j]:\n            continue\n        if distS[j][0] > distS[i][0] + d:\n            distS[j] = (distS[i][0] + d,distS[i][1])\n            heappush(qS,(distS[i][0] + d,j))\n        elif distS[j][0] == distS[i][0] + d:\n            distS[j] = (distS[j][0],distS[j][1]+distS[i][1])\n            heappush(qS,(distS[i][0] + d,j))\n\ndistT = [(10**18,0)]*(N+1)\ndistT[T] = (0,1)\nqT = []\nheappush(qT,(0,T))\nvT = [False]*(N+1)\nwhile qT:\n    d,i = heappop(qT)\n    if vT[i]:\n        continue\n    vT[i] = True\n    for j,d in edges[i]:\n        if vT[j]:\n            continue\n        if distT[j][0] > distT[i][0] + d:\n            distT[j] = (distT[i][0] + d,distT[i][1])\n            heappush(qT,(distT[i][0] + d,j))\n        elif distT[j][0] == distT[i][0] + d:\n            distT[j] = (distT[j][0],distT[j][1]+distT[i][1])\n            heappush(qT,(distT[i][0] + d,j))\n\na,b = distS[T]  # S\u304b\u3089T\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2,\u7d4c\u8def\u6570\nans = b**2 % mod\n\n# \u9802\u70b9\u3067\u51fa\u304f\u308f\u3059\u5834\u5408\nif a % 2 == 0:\n    for i in range(1,N+1):\n        if distS[i][0] == distT[i][0] == a//2:\n            ans -= (distS[i][1]*distT[i][1])**2\n            ans %= mod\n\n# \u8fba\u4e0a\u3067\u51fa\u304f\u308f\u3059\u5834\u5408\nfor i in range(2*M):\n    U,V,D = edges2[i]\n    if distS[U][0] < (a+1)//2 and distT[V][0] < (a+1)//2 and a == distS[U][0] + D + distT[V][0]:\n        ans -= (distS[U][1]*distT[V][1])**2\n        ans %= mod\n\nprint(ans)\n", "from heapq import heappush,heappop\ndef f(s):\n    a=[1<<50]*N;a[s]=0;p=[(0,s)]\n    while p:\n        d,v=heappop(p)\n        if d>a[v]:continue\n        for u,w in G[v]:\n            if a[u]>d+w:a[u]=d+w;heappush(p,(d+w,u))\n    return a\ndef g(a,s):\n    w=[0]*N;w[s]=1;b=[0]*N;b[s]=1;p=[(0,s)]\n    while p:\n        d,v=heappop(p)\n        for u,d in G[v]:\n            if a[v]+d==a[u]:\n                w[u]=(w[u]+w[v])%m\n                if not b[u]:heappush(p,(a[u],u));b[u]=1\n    return w\nm=10**9+7\nN,M=map(int,input().split());N+=1\nS,T=map(int,input().split())\nG=[[]for _ in[0]*N]\nfor _ in[0]*M:U,V,D=map(int,input().split());G[U]+=[(V,D)];G[V]+=[(U,D)]\ndS=f(S)\ndT=f(T)\nwS=g(dS,S)\nwT=g(dT,T)\ns=dS[T]\na=(wS[T]**2-(1-s%2)*sum((wS[i]*wT[i])**2for i in range(N)if dS[i]==dT[i]==s//2))%m\nfor i in range(N):\n    for j,d in G[i]:\n        if(dS[i]+d+dT[j]==s)*(dS[i]<dT[i])*(dT[j]<dS[j]):a=(a-(wS[i]*wT[j])**2)%m\nprint(a)", "\n\"\"\"\n\n\u4e21\u65b9\u304b\u3089\u8ddd\u96e2L\u306e\u70b9\u306e\u6570\u304c\u308f\u304b\u308c\u3070\u3088\u3044\nST\u304b\u3089\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\n\n\u9802\u70b9\u304c\u306a\u308b\u5834\u5408\u2192\u8abf\u3079\u308b\n\u8fba\u306e\u9593\u3067\u306a\u308b\u5834\u5408\n\u4e21\u65b9\u8fd1\u3044\u307b\u3046\u304c\u7570\u306a\u308b & \u305d\u306e\u548c+\u8fba\u306e\u9577\u3055\u304c2L\n\n\u3076\u3064\u304b\u308b\u3082\u306e\u3092\u5f15\u304d\u305f\u3044\n\u305d\u306e\u9802\u70b9\u307e\u3067\u306e\u7d4c\u8def\u6570\u3082\u6c42\u3081\u3066\u304a\u304f\n\n\"\"\"\n\nfrom sys import stdin\n\nimport heapq\ndef Dijkstra(lis,start):\n\n    ret = [float(\"inf\")] * len(lis)\n    rnum = [0] * len(lis)\n    rnum[start] = 1\n    \n    ret[start] = 0\n    end_flag = [False] * len(lis)\n    end_num = 0\n    \n    q = [[0,start]]\n\n    while len(q) > 0:\n\n        ncost,now = heapq.heappop(q)\n\n        if end_flag[now]:\n            continue\n\n        end_flag[now] = True\n        end_num += 1\n\n        if end_num == len(lis):\n            break\n\n        for nex,ecost in lis[now]:\n\n            if ret[nex] > ncost + ecost:\n                ret[nex] = ncost + ecost\n                heapq.heappush(q , [ret[nex] , nex])\n                rnum[nex] = 0\n            if ret[nex] == ncost + ecost:\n                rnum[nex] = (rnum[nex] + rnum[now]) % mod\n        #print (now,rnum)\n    return ret,rnum\n\nN,M = list(map(int,stdin.readline().split()))\nS,T = list(map(int,stdin.readline().split()))\nS -= 1\nT -= 1\nmod = 10**9+7\n\nlis = [ [] for i in range(N) ]\nfor i in range(M):\n    u,v,d = list(map(int,stdin.readline().split()))\n    u -= 1\n    v -= 1\n    lis[u].append((v,d))\n    lis[v].append((u,d))\n\nDS,rootS = Dijkstra(lis,S)\nDT,rootT = Dijkstra(lis,T)\n\nans = (rootS[T] ** 2) % mod\nL = DS[T]\n\n#print (DS,rootS)\n\nfor v in range(N):\n    \n    if L % 2 == 0 and DS[v] == DT[v] == L//2:\n        ans -= (rootS[v] * rootT[v]) ** 2\n        continue\n\n    for nex,ecost in lis[v]:\n        if nex < v:\n            if DS[v]+DT[nex]+ecost == L and DS[v]*2<L and DT[nex]*2<L:\n                ans -= (rootS[v] * rootT[nex]) ** 2\n            elif DS[nex]+DT[v]+ecost == L and DS[nex]*2<L and DT[v]*2<L:\n                ans -= (rootS[nex] * rootT[v]) ** 2\n            ans %= mod\n    \nprint((ans % mod))\n", "def main():\n    from sys import stdin\n    input = stdin.readline\n\n    n, m = list(map(int, input().split()))\n    s, t = [int(x)-1 for x in input().split()]\n    g = [[] for _ in [0]*n]\n    for i in range(m):\n        a, b, c = list(map(int, input().split()))\n        g[a-1].append((b-1, c))\n        g[b-1].append((a-1, c))\n\n    import heapq\n    inf = 10**16\n    short = inf\n    mod = 10**9+7\n\n    dist_s = [inf]*n\n    dp_s = ([0]*n)+[1]\n    h = [(0, s, -1)]\n    heapq.heapify(h)\n    while h:\n        d, i, a = heapq.heappop(h)\n        if d > short:\n            break\n        elif i == t:\n            short = d\n        d2 = dist_s[i]\n        if d2 == inf:\n            dist_s[i] = d\n            dp_s[i] = dp_s[a]\n            for j, k in g[i]:\n                if dist_s[j] == inf:\n                    heapq.heappush(h, (d+k, j, i))\n        elif d2 == d:\n            dp_s[i] = (dp_s[i]+dp_s[a]) % mod\n\n    dist_t = [inf]*n\n    dp_t = ([0]*n)+[1]\n    h = [(0, t, -1)]\n    heapq.heapify(h)\n    while h:\n        d, i, a = heapq.heappop(h)\n        if d > short:\n            break\n        d2 = dist_t[i]\n        if d2 == inf:\n            dist_t[i] = d\n            dp_t[i] = dp_t[a]\n            for j, k in g[i]:\n                if dist_t[j] == inf:\n                    heapq.heappush(h, (d+k, j, i))\n        elif d2 == d:\n            dp_t[i] = (dp_t[i]+dp_t[a]) % mod\n\n    ans = dp_s[t]**2 % mod\n\n    for i, (p, q) in enumerate(zip(dist_s, dist_t)):\n        if p+q == short:\n            d = p*2\n            if d == short and q*2 == short:\n                ans = (ans-(dp_s[i]*dp_t[i])**2) % mod\n            elif d < short:\n                for j, k in g[i]:\n                    if d+2*k > short:\n                        if d+2*k+2*dist_t[j] == 2*short:\n                            ans = (ans-(dp_s[i]*dp_t[j])**2) % mod\n\n    print(ans)\n\n\nmain()\n", "from heapq import heappush, heappop\nimport sys\ninput = sys.stdin.readline\nINF = 10**18\nmod = 10**9+7\ndef dijkstra(start, n, graph):\n    route_cnt = [start] * n\n    route_cnt[start] = 1\n    que = [(0, start)]\n    dist = [INF] * n\n    dist[start] = 0\n    while que:\n        min_dist, u = heappop(que)\n        if min_dist > dist[u]:\n            continue\n        for c, v in graph[u]:\n            if dist[u] + c < dist[v]:\n                dist[v] = dist[u] + c\n                route_cnt[v] = route_cnt[u]\n                heappush(que, (dist[u] + c  , v))\n            elif dist[u] + c == dist[v]:\n                route_cnt[v] = (route_cnt[v] + route_cnt[u]) % mod\n    return route_cnt, dist\nN, M = list(map(int, input().split()))\nS, T = list(map(int, input().split()))\nG = [[] for _ in range(N)]\nedges = []\nfor _ in range(M):\n    u, v, d = list(map(int, input().split()))\n    G[u-1].append((d, v-1))\n    G[v-1].append((d, u-1))\n    edges.append((v-1, u-1, d))\nnum_s, dist_s = dijkstra(S-1, N, G)\nnum_t, dist_t = dijkstra(T-1, N, G)\nans = num_s[T-1]**2%mod\nl = dist_s[T-1]\nfor u, v, d in edges:\n    if dist_s[v]<dist_s[u]:\n        u, v = v, u\n    if dist_s[u]*2<l<dist_s[v]*2 and dist_s[u]+dist_t[v]+d == l:\n        ans-=(num_s[u]**2%mod)*(num_t[v]**2%mod)\n        ans%=mod\nfor v in range(N):\n    if dist_s[v] == dist_t[v] == l/2:\n        ans-=(num_t[v]**2%mod)*(num_s[v]**2%mod)\n        ans%=mod\nprint((ans%mod))\n\n\n\n\n\n", "from heapq import heappush,heappop\ndef f(s):\n    a=[1<<50]*N;a[s]=0;p=[(0,s)]\n    while p:\n        d,v=heappop(p)\n        if d>a[v]:continue\n        for u,w in G[v]:\n            if a[u]>d+w:a[u]=d+w;heappush(p,(d+w,u))\n    return a\ndef g(a,s):\n    w=[0]*N;w[s]=1;b=[0]*N;b[s]=1;p=[(0,s)]\n    while p:\n        d,v=heappop(p)\n        for u,d in G[v]:\n            if a[v]+d==a[u]:\n                w[u]=(w[u]+w[v])%m\n                if not b[u]:heappush(p,(a[u],u));b[u]=1\n    return w\nm=10**9+7\nN,M=map(int,input().split())\nS,T=map(int,input().split())\nS-=1;T-=1\nG=[[]for _ in[0]*N]\nfor _ in[0]*M:U,V,D=map(int,input().split());U-=1;V-=1;G[U]+=[(V,D)];G[V]+=[(U,D)]\ndS=f(S)\ndT=f(T)\nwS=g(dS,S)\nwT=g(dT,T)\ns=dS[T]\na=(wS[T]**2-(1-s%2)*sum((wS[i]*wT[i])**2for i in range(N)if dS[i]==dT[i]==s//2))%m\nfor i in range(N):\n    for j,d in G[i]:\n        if dS[i]+d+dT[j]==s:\n            if(dS[i]<dT[i])*(dT[j]<dS[j]):a=(a-(wS[i]*wT[j])**2)%m\nprint(a)", "from heapq import heapify, heappush, heappop\ndef conv(c, p, pp):\n  return (c*N + p)*N + pp\ndef rev(X):\n  pp = X % N\n  X //= N\n  p = X % N\n  c = X // N\n  return (c, p, pp)\n\nMOD = 10**9 + 7\nN, M = list(map(int,input().split()))\ns, t = list(map(int,input().split()))\ns -= 1; t -= 1;\nI = [[] for _ in range(N)]\nedges = []\nfor _ in range(M):\n  u, v, c = list(map(int,input().split()))\n  u -= 1; v -= 1;\n  I[u].append((v, c))\n  I[v].append((u, c))\n  edges.append(conv(c,u,v))\n  \nfin_i = [0 for _ in range(N)]\nml_i = [0 for _ in range(N)]\nfin_r = [0 for _ in range(N)]\nml_r = [0 for _ in range(N)]\n\n  \ndef dijkstra(s, fin, ml):\n  task = [conv(0, s, s)]\n  fin[s] = 1\n  ml[s] = 0\n  vis = set()\n  while task:\n    while True:\n      if not task:\n        return\n      #print(task)\n      c, p, pp = rev(heappop(task))\n      #print(c, p, pp, task)\n      if p in vis and c == ml[p]:\n        #print(p, pp, 1, vis)\n        fin[p] += fin[pp]\n        fin[p] %= MOD\n      elif p not in vis:\n        #print(p)\n        break\n    if p != s:\n      #print(p, pp, 2)\n      fin[p] += fin[pp]\n      fin[p] %= MOD\n      ml[p] = c\n    vis.add(p)\n    #print(p, I[p])\n    for q, c_n in I[p]:\n      if q not in vis:\n        heappush(task, conv(c+c_n, q, p))\n  return\n\ndijkstra(s, fin_i, ml_i)\ndijkstra(t, fin_r, ml_r)\n#print(ml_i)\n#print(fin_i)\n#print(ml_r)\n#print(fin_r)\nL = ml_i[t]\n\nans = 0\nfor X in edges:\n  c, u, v = rev(X)\n  if ml_i[u] + c + ml_r[v] == L and ml_i[u]*2 < L < ml_i[v]*2:\n    #print(u, v, fin_i[u], fin_r[v])\n    ans += (fin_i[u] * fin_r[v]) ** 2\n  u, v = v, u\n  if ml_i[u] + c + ml_r[v] == L and ml_i[u]*2 < L < ml_i[v]*2:\n    #print(u, v, fin_i[u], fin_r[v])\n    ans += (fin_i[u] * fin_r[v]) ** 2\n    ans %= MOD\nfor p in range(N):\n  if 2*ml_i[p] == L:\n    #print(p, fin_i[p] * fin_r[p])\n    ans += (fin_i[p] * fin_r[p]) ** 2\n    ans %= MOD\n    \nprint(((fin_i[t]**2 - ans) %MOD))\n", "from heapq import heappop, heappush\nimport sys\n\nMOD, INF = 1000000007, float('inf')\n\n\ndef solve(s, t, links):\n    q = [(0, 0, s, -1, 0), (0, 0, t, -1, 1)]\n    visited_fwd, visited_bwd = [INF] * n, [INF] * n\n    patterns_fwd, patterns_bwd = [0] * (n + 1), [0] * (n + 1)\n    patterns_fwd[-1] = patterns_bwd[-1] = 1\n    collision_nodes, collision_links = set(), set()\n    limit = 0\n    while q:\n        cost, cost_a, v, a, is_bwd = heappop(q)\n        if is_bwd:\n            visited_self = visited_bwd\n            visited_opp = visited_fwd\n            patterns_self = patterns_bwd\n        else:\n            visited_self = visited_fwd\n            visited_opp = visited_bwd\n            patterns_self = patterns_fwd\n\n        relax_flag = False\n        cost_preceding = visited_self[v]\n        if cost_preceding == INF:\n            visited_self[v] = cost\n            relax_flag = True\n        elif cost > cost_preceding:\n            continue\n\n        patterns_self[v] += patterns_self[a]\n\n        cost_opp = visited_opp[v]\n        if cost_opp != INF:\n            limit = cost + cost_opp\n            if cost == cost_opp:\n                collision_nodes.add(v)\n            else:\n                collision_links.add((v, a) if is_bwd else (a, v))\n            break\n\n        if relax_flag:\n            for u, du in list(links[v].items()):\n                nc = cost + du\n                if visited_self[u] < nc:\n                    continue\n                heappush(q, (nc, cost, u, v, is_bwd))\n\n    collision_time = limit / 2\n    while q:\n        cost, cost_a, v, a, is_bwd = heappop(q)\n        if cost > limit:\n            break\n        visited_self = visited_bwd if is_bwd else visited_fwd\n        if visited_self[v] == INF:\n            visited_self[v] = cost\n        if is_bwd:\n            if cost == collision_time:\n                patterns_bwd[v] += patterns_bwd[a]\n            continue\n        if cost_a == collision_time:\n            collision_nodes.add(a)\n        elif cost == collision_time:\n            collision_nodes.add(v)\n            patterns_fwd[v] += patterns_fwd[a]\n        else:\n            collision_links.add((a, v))\n\n    shortest_count = 0\n    collision_count = 0\n\n    for v in collision_nodes:\n        if visited_fwd[v] == visited_bwd[v]:\n            r = patterns_fwd[v] * patterns_bwd[v]\n            shortest_count += r\n            shortest_count %= MOD\n            collision_count += r * r\n            collision_count %= MOD\n\n    for u, v in collision_links:\n        if visited_fwd[u] + visited_bwd[v] + links[u][v] == limit:\n            r = patterns_fwd[u] * patterns_bwd[v]\n            shortest_count += r\n            shortest_count %= MOD\n            collision_count += r * r\n            collision_count %= MOD\n\n    return (shortest_count ** 2 - collision_count) % MOD\n\n\nn, m = list(map(int, input().split()))\ns, t = list(map(int, input().split()))\ns -= 1\nt -= 1\nlinks = [{} for _ in range(n)]\nfor uvd in sys.stdin.readlines():\n    u, v, d = list(map(int, uvd.split()))\n    # for _ in range(m):\n    #     u, v, d = map(int, input().split())\n    u -= 1\n    v -= 1\n    links[u][v] = d\n    links[v][u] = d\nprint((solve(s, t, links)))\n", "from heapq import heappush, heappop\nfrom collections import deque\nN, M = list(map(int, input().split()))\nS, T = list(map(int, input().split()))\nS -= 1; T -= 1\nG = [[] for i in range(N)]\nfor i in range(M):\n    u, v, d = list(map(int, input().split()))\n    G[u-1].append((v-1, d))\n    G[v-1].append((u-1, d))\n\nINF = 10**18\nMOD = 10**9 + 7\n\ndist = [INF]*N\ndist[S] = 0\nque = [(0, S)]\nwhile que:\n    cost, v = heappop(que)\n    if dist[v] < cost:\n        continue\n    for w, c in G[v]:\n        if cost + c < dist[w]:\n            dist[w] = cost + c\n            heappush(que, (cost + c, w))\n\nque = deque()\nmi = [0]*N\nque.append(T)\nmi[T] = 1\nH = [[] for i in range(N)]\nRH = [[] for i in range(N)]\n\nD = dist[T]\n\nV = []\nE = []\nwhile que:\n    v = que.popleft()\n    d = dist[v]\n    if d*2 == D:\n        V.append(v)\n    for w, c in G[v]:\n        if d == dist[w] + c:\n            if dist[w]*2 < D < d*2:\n                E.append((w, v))\n            H[v].append(w)\n            RH[w].append(v)\n            if mi[w] == 0:\n                mi[w] = 1\n                que.append(w)\n\ndef bfs(G, RG, s):\n    *deg, = list(map(len, RG))\n    que = deque([s])\n    res = [0]*N\n    res[s] = 1\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            deg[w] -= 1\n            res[w] += res[v]\n            if deg[w] == 0:\n                que.append(w)\n                res[w] %= MOD\n    return res\nCT = bfs(H, RH, T)\nCS = bfs(RH, H, S)\n\nans = CS[T] * CT[S] % MOD\nfor v in V:\n    ans -= (CS[v] * CT[v]) ** 2\n    ans %= MOD\nfor v, w in E:\n    ans -= (CS[v] * CT[w]) ** 2\n    ans %= MOD\nprint(ans)\n", "from heapq import *\ndef dijkstra(g,start):\n    n = len(g)\n    INF = 1<<61\n    dist = [INF]*(n) #start\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\n    num = [0]*n\n    dist[start] = 0\n    num[start] = 1\n    q = [(0,start)] #(\u305d\u3053\u307e\u3067\u306e\u8ddd\u96e2\u3001\u70b9)\n    while q:\n        dv,v = heappop(q)\n        if dist[v] < dv: continue\n        for to, cost in g[v]:\n            if dv + cost < dist[to]:\n                dist[to] = dv + cost\n                num[to] = num[v]\n                heappush(q, (dist[to], to))\n            elif dv + cost == dist[to]:\n                num[to] += num[v]\n                num[to] %= MOD\n    return dist,num\n\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn,m = list(map(int,readline().split()))\ns,t = list(map(int,readline().split()))\ns -= 1\nt -= 1\n\ng = [[] for _ in range(n)]\nedges = []\nfor _ in range(m):\n    a,b,c = list(map(int,readline().split()))\n    g[a-1].append((b-1,c))\n    g[b-1].append((a-1,c))\n    edges.append((a-1,b-1,c))\n\nMOD = 10**9+7\ndist,num = dijkstra(g,s)\ndt,nt = dijkstra(g,t)\n\n#print(dist,dt)\n#print(num,nt)\n\nans = num[t]**2\n#print(ans,\"original\")\n\nD = dist[t]\nfor i in range(n):\n    if dist[i]*2 == D and dist[i] + dt[i] == dist[t]:\n        ans -= ((num[i]*nt[i]%MOD)**2)%MOD\n\n#print(ans,\"remove-pt\")\n\nfor a,b,c in edges:\n    da = dist[a]\n    db = dist[b]\n    if da > db:\n        a,b = b,a\n        da,db = db,da\n    if da*2 < D and db*2 > D and dist[a] + dt[b] + c == dist[t]:\n        ans -= ((num[a]*nt[b]%MOD)**2)%MOD\n\nprint((ans%MOD))\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n,m = LI()\n    s,t = LI()\n    e = collections.defaultdict(list)\n    for _ in range(m):\n        u,v,d = LI()\n        e[u].append((v,d))\n        e[v].append((u,d))\n\n    def search(s,t):\n        d = collections.defaultdict(lambda: inf)\n        dc = collections.defaultdict(int)\n        d[s] = 0\n        dc[s] = 1\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while len(q):\n            k, u = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n\n            if u == t:\n                return (d,dc)\n\n            uc = dc[u]\n\n            for uv, ud in e[u]:\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] < vd:\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    dc[uv] = uc\n                    heapq.heappush(q, (vd, uv))\n                elif d[uv] == vd:\n                    dc[uv] += uc\n\n        return (d,dc)\n\n    d1,dc1 = search(s,t)\n    d2,dc2 = search(t,s)\n    rd = d1[t]\n    kk = rd / 2.0\n\n    r = dc1[t] ** 2 % mod\n    for k in list(d1.keys()):\n        t = d1[k]\n        c = dc1[k]\n        if t > kk:\n            continue\n        if t == kk:\n            if d2[k] == t:\n                r -= (c**2 * dc2[k]**2) % mod\n            continue\n\n        for uv, ud in e[k]:\n            if d2[uv] >= kk or t + ud + d2[uv] != rd:\n                continue\n            r -= (c**2 * dc2[uv]**2) % mod\n\n    return r % mod\n\n\n\n\nprint(main())\n", "from heapq import*\ndef f(s):\n a=[1<<50]*N;a[s]=0;p=[(0,s)];c=[0]*N;c[s]=1\n while p:\n  d,v=heappop(p)\n  if d<=a[v]:\n   for u,w in G[v]:\n    if a[u]>d+w:a[u]=d+w;heappush(p,(d+w,u));c[u]=0\n    c[u]+=c[v]*(a[u]==d+w)\n return a,c\nn=lambda:map(int,input().split());N,M=n();N+=1;S,T=n();G=[[]for _ in[0]*N]\nfor _ in[0]*M:U,V,D=n();G[U]+=(V,D),;G[V]+=(U,D),\nP,X=f(S);Q,Y=f(T);s=P[T];print((X[T]**2--~s%2*sum(x*x*y*y*(p==q==s//2)for x,y,p,q in zip(X,Y,P,Q))-sum((P[i]+d+Q[j]==s)*(P[i]<Q[i])*(Q[j]<P[j])*(X[i]*Y[j])**2for i in range(N)for j,d in G[i]))%(10**9+7))", "import heapq as h\ndef f(s):\n a=[1<<50]*N;a[s]=0;p=[(0,s)];c=[0]*N;c[s]=1\n while p:\n  d,v=h.heappop(p)\n  if d<=a[v]:\n   for u,w in G[v]:\n    if a[u]>d+w:a[u]=d+w;h.heappush(p,(d+w,u));c[u]=0\n    if a[u]==d+w:c[u]+=c[v]\n return a,c\nn=lambda:map(int,input().split());N,M=n();N+=1;S,T=n();G=[[]for _ in[0]*N]\nfor _ in[0]*M:U,V,D=n();G[U]+=[(V,D)];G[V]+=[(U,D)]\nP,X=f(S);Q,Y=f(T);s=P[T];print((X[T]**2-(1-s%2)*sum((X[i]*Y[i])**2for i in range(N)if P[i]==Q[i]==s//2)-sum((P[i]+d+Q[j]==s)*(P[i]<Q[i])*(Q[j]<P[j])*(X[i]*Y[j])**2for i in range(N)for j,d in G[i]))%(10**9+7))", "from heapq import heappush as k,heappop as l\ndef f(s):\n    a=[1<<50]*N;a[s]=0;p=[(0,s)]\n    c=[0]*N;c[s]=1\n    while p:\n        d,v=l(p)\n        if d>a[v]:continue\n        for u,w in G[v]:\n            if a[u]==d+w:\n                c[u]+=c[v]\n            if a[u]>d+w:\n                a[u]=d+w;k(p,(d+w,u))\n                c[u]=c[v]\n    return a,c\nm=10**9+7\nN,M=map(int,input().split());N+=1\nS,T=map(int,input().split())\nG=[[]for _ in[0]*N]\nfor _ in[0]*M:U,V,D=map(int,input().split());G[U]+=[(V,D)];G[V]+=[(U,D)]\nP,X=f(S);Q,Y=f(T);s=P[T]\nprint((X[T]**2-(1-s%2)*sum((X[i]*Y[i])**2for i in range(N)if P[i]==Q[i]==s//2)-sum((P[i]+d+Q[j]==s)*(P[i]<Q[i])*(Q[j]<P[j])*(X[i]*Y[j])**2for i in range(N)for j,d in G[i]))%m)", "import heapq\nMOD = 10 ** 9 + 7\n\nN, M = list(map(int, input().split()))\nS, T = [int(x) - 1 for x in input().split()]\n\nadjList = [[] for i in range(N)]\nfor i in range(M):\n    U, V, D = list(map(int, input().split()))\n    adjList[U - 1].append((V - 1, D))\n    adjList[V - 1].append((U - 1, D))\n\n# \u9802\u70b9S\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8def\u306e\u500b\u6570\nnumRouteS = [0 for i in range(N)]\nnumRouteS[S] = 1\n\ncost = [float('inf')] * N\ncost[S] = 0\nprev = [None] * N\n\npq = []\nheapq.heappush(pq, (0, S))\n\nvs = []\nwhile pq:\n    c, vNow = heapq.heappop(pq)\n    if c > cost[vNow]: continue\n    if c > cost[T]: break\n    vs += [vNow]\n\n    for v2, wt in adjList[vNow]:\n        c2 = cost[vNow] + wt\n        if c2 <= cost[v2]:\n            if c2 == cost[v2]:\n                prev[v2] += [vNow]\n                numRouteS[v2] = (numRouteS[v2] + numRouteS[vNow]) % MOD\n            else:\n                cost[v2] = c2\n                prev[v2] = [vNow]\n                numRouteS[v2] = numRouteS[vNow]\n                heapq.heappush(pq, (c2, v2))\n\n# \u9802\u70b9T\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8def\u306e\u500b\u6570\nnumRouteT = [0] * N\nnumRouteT[T] = 1\nfor v in reversed(vs[1:]):\n    for v0 in prev[v]:\n        numRouteT[v0] = (numRouteT[v0] + numRouteT[v]) % MOD\n\n# \u4e8c\u4eba\u306e\u6700\u77ed\u8def\u306e\u9078\u3073\u65b9\u306e\u7d44\u304b\u3089\u3001\u9014\u4e2d\u3067\u51fa\u4f1a\u3046\u3082\u306e\u3092\u5f15\u304f\ncST = cost[T]\nans = (numRouteS[T] ** 2) % MOD\n\nfor v, c in enumerate(cost):\n    if c * 2 == cST:\n        x = (numRouteS[v] ** 2) % MOD\n        y = (numRouteT[v] ** 2) % MOD\n        ans = (ans - x * y) % MOD\n\nfor v, c in enumerate(cost):\n    if c * 2 < cST:\n        for v2, wt in adjList[v]:\n            if (cost[v2] * 2 > cST) and c + wt == cost[v2]:\n                x = (numRouteS[v] ** 2) % MOD\n                y = (numRouteT[v2] ** 2) % MOD\n                ans = (ans - x * y) % MOD\n\nprint(ans)\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n,m = LI()\n    s,t = LI()\n    e = collections.defaultdict(list)\n    for _ in range(m):\n        u,v,d = LI()\n        e[u].append((v,d))\n        e[v].append((u,d))\n\n    def search(s,t):\n        d = collections.defaultdict(lambda: inf)\n        dc = collections.defaultdict(int)\n        d[s] = 0\n        dc[s] = 1\n        q = []\n        heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while len(q):\n            k, u = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n\n            dc[u] %= mod\n            if u == t:\n                return (d,dc)\n\n            uc = dc[u]\n\n            for uv, ud in e[u]:\n                if v[uv]:\n                    continue\n                vd = k + ud\n                if d[uv] < vd:\n                    continue\n                if d[uv] > vd:\n                    d[uv] = vd\n                    dc[uv] = uc\n                    heapq.heappush(q, (vd, uv))\n                elif d[uv] == vd:\n                    dc[uv] += uc\n\n        return (d,dc)\n\n    d1,dc1 = search(s,t)\n    d2,dc2 = search(t,s)\n    rd = d1[t]\n    kk = rd / 2.0\n\n    r = dc1[t] ** 2 % mod\n    for k in list(d1.keys()):\n        t = d1[k]\n        c = dc1[k]\n        if t > kk:\n            continue\n        if t == kk:\n            if d2[k] == t:\n                r -= pow(c,2,mod) * pow(dc2[k],2,mod) % mod\n            continue\n\n        for uv, ud in e[k]:\n            if d2[uv] >= kk or t + ud + d2[uv] != rd:\n                continue\n            r -= pow(c,2,mod) * pow(dc2[uv],2,mod) % mod\n\n    return r % mod\n\n\n\n\nprint(main())\n", "from heapq import heappop, heappush\nMOD = 10 ** 9 + 7\n\nN, M = list(map(int, input().split()))\nS, T = [int(x) - 1 for x in input().split()]\n\nadjList = [[] for i in range(N)]\nfor i in range(M):\n    U, V, D = list(map(int, input().split()))\n    adjList[U - 1].append((V - 1, D))\n    adjList[V - 1].append((U - 1, D))\n\n# \u9802\u70b9S\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8def\u306e\u500b\u6570\nnumRouteS = [0] * N\nnumRouteS[S] = 1\n\ncost = [float('inf')] * N\ncost[S] = 0\nprev = [None] * N\nvs = []\n\npq = []\nheappush(pq, (0, S))\nwhile pq:\n    c, vNow = heappop(pq)\n    if c > cost[vNow]: continue\n    if c > cost[T]: break\n    vs += [vNow]\n\n    for v2, wt in adjList[vNow]:\n        c2 = c + wt\n        if c2 < cost[v2]:\n            cost[v2] = c2\n            prev[v2] = [vNow]\n            numRouteS[v2] = numRouteS[vNow]\n            heappush(pq, (c2, v2))\n        elif c2 == cost[v2]:\n            prev[v2] += [vNow]\n            numRouteS[v2] = (numRouteS[v2] + numRouteS[vNow]) % MOD\n\n# \u9802\u70b9T\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8def\u306e\u500b\u6570\nnumRouteT = [0] * N\nnumRouteT[T] = 1\ncST = cost[T]\nfor iV, v in enumerate(reversed(vs)):\n    if cost[v] * 2 < cST:\n        iVLim = len(vs) - iV\n        break\n    for v0 in prev[v]:\n        numRouteT[v0] = (numRouteT[v0] + numRouteT[v]) % MOD\n\n# \u4e8c\u4eba\u306e\u6700\u77ed\u8def\u306e\u9078\u3073\u65b9\u306e\u7d44\u304b\u3089\u3001\u9014\u4e2d\u3067\u51fa\u4f1a\u3046\u3082\u306e\u3092\u5f15\u304f\nans = (numRouteS[T] ** 2) % MOD\n\nfor v in vs[:iVLim]:\n    x = (numRouteS[v] ** 2) % MOD\n    for v2, wt in adjList[v]:\n        if (cost[v2] * 2 > cST) and cost[v] + wt == cost[v2]:\n            y = (numRouteT[v2] ** 2) % MOD\n            ans = (ans - x * y) % MOD\n\nfor v in vs[iVLim:]:\n    if cost[v] * 2 > cST: break\n    x = (numRouteS[v] ** 2) % MOD\n    y = (numRouteT[v] ** 2) % MOD\n    ans = (ans - x * y) % MOD\n\nprint(ans)\n", "from heapq import*\ndef f(s):\n a=[1<<50]*N;a[s]=0;p=[(0,s)];c=[0]*N;c[s]=1\n while p:\n  d,v=heappop(p)\n  if d<=a[v]:\n   for u,w in G[v]:\n    if a[u]>d+w:a[u]=d+w;heappush(p,(d+w,u));c[u]=0\n    if a[u]==d+w:c[u]+=c[v]\n return a,c\nn=lambda:map(int,input().split());N,M=n();N+=1;S,T=n();G=[[]for _ in[0]*N]\nfor _ in[0]*M:U,V,D=n();G[U]+=[(V,D)];G[V]+=[(U,D)]\nP,X=f(S);Q,Y=f(T);s=P[T];print((X[T]**2--~s%2*sum((X[i]*Y[i])**2for i in range(N)if P[i]==Q[i]==s//2)-sum((P[i]+d+Q[j]==s)*(P[i]<Q[i])*(Q[j]<P[j])*(X[i]*Y[j])**2for i in range(N)for j,d in G[i]))%(10**9+7))", "from heapq import heappush, heappop\nimport sys\ninput = sys.stdin.readline\n\nINF = float('inf')\nMOD = 10**9 + 7\n\ndef Dijkstra(adjList, vSt):\n    numV = len(adjList)\n    numUsed = 0\n    costs = [INF] * numV\n    costs[vSt] = 0\n    nums = [0] * numV\n    nums[vSt] = 1\n    PQ = []\n    heappush(PQ, (0, vSt))\n    while PQ:\n        cNow, vNow = heappop(PQ)\n        if cNow > costs[vNow]: continue\n        numUsed += 1\n        if numUsed == numV: break\n        for v2, wt in adjList[vNow]:\n            c2 = cNow + wt\n            if c2 < costs[v2]:\n                costs[v2] = c2\n                nums[v2] = nums[vNow]\n                heappush(PQ, (c2, v2))\n            elif c2 == costs[v2]:\n                nums[v2] = (nums[v2]+nums[vNow]) % MOD\n    return (costs, nums)\n\ndef solve():\n    N, M = list(map(int, input().split()))\n    S, T = list(map(int, input().split()))\n    S, T = S-1, T-1\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    adjL = [[] for _ in range(N)]\n    for u, v, d in edges:\n        adjL[u-1].append((v-1, d))\n        adjL[v-1].append((u-1, d))\n\n    costSs, numSs = Dijkstra(adjL, S)\n    costTs, numTs = Dijkstra(adjL, T)\n    minCost = costSs[T]\n\n    ans = (numSs[T]**2) % MOD\n    for v in range(N):\n        if costSs[v] == costTs[v] == minCost/2:\n            k = (numSs[v]*numTs[v]) % MOD\n            ans -= (k**2) % MOD\n            ans %= MOD\n    for u, v, d in edges:\n        u, v = u-1, v-1\n        if costSs[u] > costSs[v]:\n            u, v = v, u\n        if costSs[u] < minCost/2 and costTs[v] < minCost/2 and costSs[u]+d+costTs[v] == minCost:\n            k = (numSs[u]*numTs[v]) % MOD\n            ans -= (k**2) % MOD\n            ans %= MOD\n\n    print(ans)\n\nsolve()\n", "from heapq import heappush, heappop\nimport sys\ninput = sys.stdin.readline\n\ndef dijkstra(G, s):\n    INF = 10**18\n    dist = [INF] * len(G)\n    dist[s] = 0\n    pq = [(0, s)]\n    while pq:\n        d, v = heappop(pq)\n        if d > dist[v]:\n            continue\n        for u, weight in G[v]:\n            nd = d + weight\n            if dist[u] > nd:\n                dist[u] = nd\n                heappush(pq, (nd, u))\n    return dist\n\ndef count_ways(G, dist, s):\n    ways = [0] * len(G)\n    ways[s] = 1\n    visited = [False] * len(G)\n    visited[s] = True\n    pq = [(0, s)]\n    while pq:\n        d, v = heappop(pq)\n        for u, d in G[v]:\n            if dist[v] + d == dist[u]:\n                ways[u] = (ways[u] + ways[v]) % mod\n                if not visited[u]:\n                    heappush(pq, (dist[u], u))\n                    visited[u] = True\n    return ways\n\nmod = 10**9 + 7\nN, M = list(map(int, input().split()))\nS, T = list(map(int, input().split()))\nS -= 1; T -= 1\nG = [[] for _ in range(N)]\nfor _ in range(M):\n    U, V, D = list(map(int, input().split()))\n    U -= 1; V -= 1\n    G[U].append((V, D))\n    G[V].append((U, D))\ndistS = dijkstra(G, S)\ndistT = dijkstra(G, T)\nwayS = count_ways(G, distS, S)\nwayT = count_ways(G, distT, T)\nshortest = distS[T]\ncnt = wayS[T]**2 % mod\nif shortest % 2 == 0:\n    for i in range(N):\n        if distS[i] == distT[i] == shortest // 2:\n            cnt = (cnt - (wayS[i] * wayT[i])**2) % mod\nfor i in range(N):\n    for j, d in G[i]:\n        if distS[i] + d + distT[j] == shortest:\n            if distS[i] < distT[i] and distT[j] < distS[j]:\n                cnt = (cnt - (wayS[i] * wayT[j])**2) % mod\nprint(cnt)\n", "from heapq import heapify,heappop,heappush\nimport sys\ninput=sys.stdin.readline\nN,M=list(map(int,input().split()))\nS,T=list(map(int,input().split()))\nGraph=[set() for i in range(N)]\nEdge=[]\nmod=10**9+7\ninf=float(\"inf\")\nfor i in range(M):\n  a,b,c=list(map(int,input().split()))\n  Graph[a-1].add((c,b-1))\n  Graph[b-1].add((c,a-1))\n  Edge.append((a-1,b-1,c))\n  Edge.append((b-1,a-1,c))\ndef dijkstra(s,n,links):\n  Visited=[False]*n\n  cost=[inf]*n\n  P=[0]*n\n  P[s]=1\n  cost[s]=0\n  heap=[(0,s)]\n  heapify(heap)\n  while heap:\n    hc,hp=heappop(heap)\n    if Visited[hp]:\n      continue\n    Visited[hp]=True\n    for c,p in links[hp]:\n      if Visited[p]:\n        continue\n      if c+hc<cost[p]:\n        cost[p]=c+hc\n        P[p]=P[hp]\n        heappush(heap,(cost[p],p))\n      elif c+hc==cost[p]:\n        P[p]=(P[p]+P[hp])%mod\n  return cost,P\n\ndef dp(s,n,links,d):\n  Visited=[False]*n\n  cost=[inf]*n\n  P=[0]*n\n  P[s]=1\n  cost[s]=0\n  heap=[(0,s)]\n  heapify(heap)\n  while heap:\n    hc,hp=heappop(heap)\n    if 2*hc>d:\n      break\n    if Visited[hp]:\n      continue\n    Visited[hp]=True\n    for c,p in links[hp]:\n      if Visited[p]:\n        continue\n      if c+hc<cost[p]:\n        cost[p]=c+hc\n        P[p]=P[hp]\n        heappush(heap,(cost[p],p))\n      elif c+hc==cost[p]:\n        P[p]=(P[p]+P[hp])%mod\n  return cost,P\n\ncost_S,P_S=dijkstra(S-1,N,Graph)\nD=cost_S[T-1]\ncost_T,P_T=dp(T-1,N,Graph,D)\nPat=P_S[T-1]\nans=(Pat**2)%mod\nfor a,b,c in Edge:\n  if cost_S[a]+cost_T[b]+c==D:\n    if 2*cost_S[a]<D and 2*cost_T[b]<D:\n      ans-=((P_S[a]*P_T[b])**2)%mod\nfor i in range(N):\n  if 2*cost_S[i]==2*cost_T[i]==D:\n    ans-=((P_S[i]*P_T[i])**2)%mod\nprint((ans%mod))\n\n\n\n      \n  \n  \n  \n  \n", "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nfrom bisect import bisect_left, bisect_right\nimport random\nfrom itertools import permutations, accumulate, combinations\nimport sys\nimport string\nfrom copy import deepcopy\n\nINF = 10 ** 20\n\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return sys.stdin.readline().strip()\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\ndef dijkstra(s):\n    hq=[(0,s)]\n    dist=[INF]*n\n    dp=[0]*n\n    dp[s]=1\n    dist[s]=0\n    checked=[0]*n\n    while hq:\n        min_dist,u=heappop(hq)\n        if checked[u]:\n            continue\n        checked[u]=1\n        for v,c in G[u]:\n            if dist[u]+c<dist[v]:\n                dist[v]=dist[u]+c\n                dp[v]=dp[u]\n                heappush(hq,(dist[v],v))\n            elif dist[u]+c==dist[v]:\n                dp[v]+=dp[u]\n                dp[v]%=mod\n    return dp, dist\n\nn, m = LI()\ns, t = LI()\nG = [[] for _ in range(n)]\nfor _ in range(m):\n    a,b, d = LI()\n    G[a - 1] += [(b - 1, d)]\n    G[b - 1] += [(a - 1, d)]\n\ndp1,dist1=dijkstra(s-1)\ndp2,dist2=dijkstra(t-1)\ntotal=dist1[t-1]\nans=dp1[t-1]*dp2[s-1]%mod\nfor i in range(n):\n    if dist1[i]==dist2[i]==total/2:\n        ans-=pow(dp1[i]*dp2[i]%mod,2,mod)\n\nfor j in range(n):\n    for k, ci in G[j]:\n        if dist1[j]+dist2[k]+ci==total and dist1[j]<total/2 and dist2[k]<total/2:\n            ans-=pow(dp1[j]*dp2[k]%mod,2,mod)\n\nprint((ans%mod))\n\n\n\n\n\n\n"]
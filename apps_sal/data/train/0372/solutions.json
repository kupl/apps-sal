["class Solution:\n     cache = {}\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n \n         if (s, p) in self.cache:\n             return self.cache[(s, p)]\n         if not p:\n             return not s\n         if p[-1] == '*':\n             if self.isMatch(s, p[:-2]):\n                 self.cache[(s, p)] = True\n                 return True\n             if s and (s[-1] == p[-2] or p[-2] == '.') and self.isMatch(s[:-1], p):\n                 self.cache[(s, p)] = True\n                 return True\n         if s and (p[-1] == s[-1] or p[-1] == '.') and self.isMatch(s[:-1], p[:-1]):\n             self.cache[(s, p)] = True\n             return True\n         self.cache[(s, p)] = False\n         return False", "class Solution(object):\n     def isMatch(self, string, expr):\n         self.memo = {(0,0):True}\n         self.string = string\n         self.expr = expr\n         N = len(string)\n         M = len(expr)\n \n         return self.get(N, M)\n \n     def get(self, i, j):\n         if i < 0 or j < 0:\n             return False\n \n         if (i,j) not in self.memo:\n             self.memo[(i,j)] = self.eval(i,j)\n \n         return self.memo[(i,j)]\n \n     def eval(self, i, j):\n         if j <= 0: return False\n         if self.expr[j-1] == '*':\n             prev_char = self.expr[j-2]\n             \n             if prev_char == '.' or i >= 1 and prev_char == self.string[i-1]:\n                 if self.get(i-1, j):\n                     return True\n                 \n             return self.get(i, j-2)\n         \n         else:\n             if self.expr[j-1] == '.' or i >= 1 and self.expr[j-1] == self.string[i-1]:\n                 return self.get(i-1, j-1)\n             \n             return False\n", "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         \n         self.mem = {}\n         self.t = s\n         self.p = p\n         \n         return self.match(0,0)\n     \n     def match(self, i, j):\n         \n         if (i,j) not in self.mem:\n             if j == len(self.p):\n                 res = i == len(self.t)\n                 \n             else:\n                 if j+1 < len(self.p) and self.p[j+1] == '*':\n                     res = self.match(i, j+2) or (i < len(self.t) and self.p[j] in {self.t[i], '.'} and self.match(i+1, j))\n                 else:\n                     res = i < len(self.t) and self.p[j] in {self.t[i], '.'} and self.match(i+1, j+1)\n                     \n             self.mem[i, j] = res\n                 \n         return self.mem[i, j]\n         \n", "class Solution:\n     def __init__(self):\n         self.dp = {}\n \n     def isMatch(self, text, pattern):\n         if not pattern:\n             return not text\n         \n         if (text, pattern) in self.dp:\n             return self.dp[(text, pattern)]\n \n         first_match = bool(text) and pattern[0] in {text[0], '.'}\n \n         if len(pattern) >= 2 and pattern[1] == '*':\n             \n             self.dp[(text, pattern)] = self.isMatch(text, pattern[2:]) or \\\n                                        first_match and self.isMatch(text[1:], pattern)\n         else:\n             self.dp[(text, pattern)] = first_match and self.isMatch(text[1:], pattern[1:])\n         \n         return self.dp[(text, pattern)]", "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         def parsePatern(p):\n             pi=len(p)-1\n             while pi>=0:\n                 if p[pi]=='*':                    \n                     if pi==0: raise Exception('Invalid pattern!')\n                     yield (p[pi-1], 1)\n                     pi-=2\n                 else:\n                     yield (p[pi], 0)\n                     pi-=1\n                     \n         from collections import deque\n         # p = b*bab*a*\n         # s = bbbba\n         if not p: return p==s\n         plist = list(parsePatern(p)) # [('a', 1), ('b', 1), ('a', 0), ('b', 0), ('b', 1)]         \n         P = len(plist)\n         #q = deque([(0, len(s)-1)])\n         q = set([(0, len(s)-1)])\n         seen = set()\n         \"\"\"\n         q = [ (('a',1), 4) ]\n         q = [ (('b',1), 4), (('b',1), 3) ] \n         q = [ (('a', 0), 4), (('a',0), 3)), (('a',0), 2), (('a',0), 1), (('a',0), 0), (('a',0), -1)]\n         q = [ (('b', 0), 3) ]\n         q = [ (('b', 1), 2)]\n         q = [ (('', 0), 2), (('', 0), 1), (('', 0), 0), (('', 0), -1)]\n         (('', 0), -1)-> true\n         \n         \"\"\"\n         while q:\n             #print(q)\n             pat_i, si = q.pop()  \n             if (pat_i, si) in seen: \n                 #print('seen')\n                 continue\n             \n             seen.add((pat_i, si))\n             pat, is_as = plist[pat_i] if pat_i<P else ('', 0)\n             \"\"\"\n             1. a, 1\n                 1: bbbb\n                 0: bbbba\n             2. b, 1\n                 10: bbbb\n                 11: bbb\n                 12: bb\n                 13: b\n                 14: ''\n                 00: bbbba\n             3. a, 0\n                 001: bbbb\n             4. b, 0\n                 0011: bbb\n             5, b, 1:\n                 00110: bbb\n                 00111: bb\n                 00112: b\n                 00113: ''\n             6, '', 0\n                 00113 -> true\n             \"\"\"\n             if not pat and si<0: return True                                    \n             if is_as:\n                 # match 0 -> n\n                 q.add((pat_i+1, si))\n                 #q.append((pat_i+1, si))\n                 #if (pat_i+1, si) in q: print('dup', (pat_i+1, si))\n                 while si>=0 and (s[si]==pat or pat=='.'):\n                     si-=1\n                     #if (pat_i+1, si) in q: print('dup', (pat_i+1, si))\n                     q.add((pat_i+1, si))\n                     #q.append((pat_i+1, si))\n             elif si>=0 and (s[si]==pat or pat=='.'):\n                 #if (pat_i+1, si-1) in q: print('dup', (pat_i+1, si))\n                 q.add((pat_i+1, si-1))\n                 #q.append((pat_i+1, si-1))\n             \n         return False\n", "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         if not p and len(s) != 0:\n             return False\n         memo = {}\n         def dp(i, j):\n             if (i,j) not in memo:\n                 if j == len(p):\n                     res = i == len(s)\n                 else:\n                     # head must in s and p[j] should be s[i] or '.' \n                     head_match = i < len(s) and p[j] in {s[i] ,'.'}\n                     # check\n                     if j+1 < len(p) and p[j+1] == '*':\n                         res = dp(i, j+2) or head_match and dp(i+1, j) \n                     else:\n                         res = head_match and dp(i+1,j+1)\n                 memo[(i,j)] = res\n             return memo[(i,j)]\n         \n         return dp(0,0)", "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         self.maps = dict()\n         return self.dfs(s, p)\n         \n     def dfs(self, s, p):\n         key = (s, p)\n         if key in self.maps:\n             return self.maps[key]\n \n         if not s and not p:\n             return True\n         \n         if s and not p:\n             return False\n \n         if len(p) > 1 and p[1] == '*':\n             if (s and s[0] == p[0]) or (p[0] == '.' and s):\n                 self.maps[key] = self.dfs(s[1:], p[2:]) or self.dfs(s[1:], p) or  self.dfs(s, p[2:])\n             else:\n                 self.maps[key] = self.dfs(s, p[2:])\n         elif (s and s[0] == p[0]) or (p[0] == '.' and s):\n             self.maps[key] = self.dfs(s[1:], p[1:])\n         return self.maps[key] if key in self.maps else False", "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         m, n = len(s), len(p)\n         dp=[[False]*(n+1) for _ in range(m+1)]\n         dp[0][0]=True\n         for j in range(2, n+1):\n             if p[j-1]==\"*\":\n                 dp[0][j]=dp[0][j-2]\n         for i in range(1, m+1):\n             for j in range(1,n+1):\n                 if p[j-1]==\"*\":\n                     if p[j-2]==s[i-1] or p[j-2]=='.':\n                         dp[i][j]= dp[i-1][j] or dp[i][j-1] or dp[i][j-2]\n                     elif p[j-2]!=s[i-1]:\n                         dp[i][j]=dp[i][j-2]\n                 elif p[j-1]==s[i-1] or p[j-1]=='.':\n                     dp[i][j]=dp[i-1][j-1]\n         return dp[m][n]\n", "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         m = {}\n         def dp(i, j):\n             print((i,j))\n             if (i, j) not in m:\n                 if j == len(p):\n                     ans = i == len(s)\n                 else:\n                     first_match = i < len(s) and p[j] in {s[i], '.'}\n                     if j+1 < len(p) and p[j+1] == '*':\n                         ans = dp(i, j+2) or first_match and dp(i+1, j)\n                     else:\n                         ans = first_match and dp(i+1, j+1)\n \n                 m[i, j] = ans\n             return m[i, j]\n \n         return dp(0, 0)\n", "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n         dp[-1][-1] = True\n         \n         for i in range(len(s), -1, -1):\n             for j in range(len(p) - 1, -1, -1):\n                 first_match = i < len(s) and p[j] in {s[i], '.'}\n                 if j + 1 < len(p) and p[j+1] is '*':\n                     dp[i][j] = dp[i][j+2] or first_match and dp[i+1][j]\n                 else:\n                     dp[i][j] = first_match and dp[i+1][j+1]\n                     \n         return dp[0][0]\n                     \n                         \n                     \n                     \n                     \n                 \n", "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         memo = {}\n         def dp(i, j):\n             print((i,j))\n             if (i, j) not in memo:\n                 if j == len(p):\n                     ans = i == len(s)\n                 else:\n                     first_match = i < len(s) and p[j] in {s[i], '.'}\n                     if j+1 < len(p) and p[j+1] == '*':\n                         ans = dp(i, j+2) or first_match and dp(i+1, j)\n                     else:\n                         ans = first_match and dp(i+1, j+1)\n \n                 memo[i, j] = ans\n             return memo[i, j]\n \n         return dp(0, 0)\n", "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         import re\n         pattern = re.compile(p)\n         match = pattern.match(s)\n         if match:\n             try:\n                 return match.group() == s\n             except:\n                 return False\n             finally:\n                 pass\n         else:\n             return False\n"]
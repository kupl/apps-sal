["def add_point(ori,dis,c):\n    lastPoint = c[-1]\n    if ori == \"N\":\n        c.append((lastPoint[0],lastPoint[1]+dis))\n    elif ori == \"S\":\n        c.append((lastPoint[0],lastPoint[1]-dis))\n    elif ori == \"E\":\n        c.append((lastPoint[0]+dis,lastPoint[1]))\n    else: \n        c.append((lastPoint[0]-dis,lastPoint[1]))\n\ndef check_corner(l_o):\n    ini = l_o[0]\n    fin = l_o[-1]\n    if ini==fin: return False\n    if ini == \"N\" or ini ==\"S\": ini = \"V\"\n    else: ini = \"H\"\n    if fin == \"N\" or fin ==\"S\": fin = \"V\"\n    else: fin = \"H\"\n    if ini==fin: return False\n    return True\n\ndef check_intersect(rectas):\n    u=rectas[-1]\n    ux=[u[0][0],u[1][0]]\n    ux.sort()\n    uy=[u[0][1],u[1][1]]\n    uy.sort()\n\n    oriU = \"\"\n    if ux[0] == ux[1]: oriU = \"V\"\n    if uy[0] == uy[1]: oriU = \"H\"\n    \n    for r in rectas[:-2]:\n        rx=[r[0][0],r[1][0]]\n        rx.sort()\n        ry=[r[0][1],r[1][1]]\n        ry.sort()\n\n        oriR = \"\"\n        if rx[0] == rx[1]: oriR = \"V\"\n        if ry[0] == ry[1]: oriR = \"H\"\n\n        if oriU==oriR: \n            if oriU == \"V\" and ux[0]==rx[0]:\n                if ry[0] <= uy[0] <= ry[1] or ry[0] <= uy[1] <= ry[1] :\n                    return True\n                if uy[0] < ry[0] and uy[1] > ry[1]:\n                    return True \n\n            if oriU ==\"H\" and uy[0]==ry[0]:\n                if rx[0] <= ux[0] <= rx[1] or rx[0] <= ux[1] <= rx[1] :\n                    return True\n                if ux[0] < rx[0] and ux[1] > rx[1]:\n                    return True \n        elif oriU ==\"V\":\n            if uy[0]<=ry[0]<=uy[1]:\n                if rx[0] < ux[0] and rx[1] > ux[0]:\n                    return True\n        elif oriU ==\"H\":\n            if ux[0]<=rx[0]<=ux[1]:\n                if ry[0] < uy[0] and ry[1] > uy[0]:\n                    return True  \n        else:\n            return False\n\ndef calc_area(camino):\n    parN=camino[-1][0]*camino[0][1] - camino[-1][1] * camino[0][0]\n    for p in range(1,len(camino)):\n        par=camino[p-1][0]*camino[p][1] - camino[p-1][1]*camino[p][0]\n        parN+=par\n    return abs(parN)/2\n\ndef mouse_path(s):\n    camino=[(0,0)]\n    distancia = 0\n    listaOrientaciones = [\"E\"]\n    rectas = []\n     \n    for c in s:\n        orientacion = listaOrientaciones[-1]\n        if c.isdigit():\n            distancia=distancia*10 + int(c)\n        else:\n            add_point(orientacion,distancia,camino)\n            rectas.append((camino[-2],camino[-1]))\n            if check_intersect(rectas): return None\n            if c == \"L\":\n                if orientacion == \"N\": listaOrientaciones.append(\"O\")\n                elif orientacion == \"S\": listaOrientaciones.append(\"E\") \n                elif orientacion == \"E\": listaOrientaciones.append(\"N\")\n                else: listaOrientaciones.append(\"S\")\n            else:\n                if orientacion == \"N\": listaOrientaciones.append(\"E\")\n                elif orientacion == \"S\": listaOrientaciones.append(\"O\") \n                elif orientacion == \"E\": listaOrientaciones.append(\"S\")\n                else: listaOrientaciones.append(\"N\")\n            distancia = 0\n    add_point(orientacion,distancia,camino)\n    rectas.append((camino[-2],camino[-1]))\n    if check_intersect(rectas): return None\n\n    if camino[-1] != (0,0): return None\n\n    if not check_corner(listaOrientaciones): return None\n\n    return calc_area(camino)", "d = {'L':1, 'R':-1}\ndef mouse_path(s):\n    if invalid(s): return None\n    area, x = 0, 0\n    while True:\n        g = (i for i, c in enumerate(s) if c in d)\n        i, j = next(g, -1), next(g, -1)\n        area += x * int(s[:i])\n        if j == -1: break\n        x = d[s[j]] * (int(s[i+1:j]) - d[s[i]] * x)\n        s = s[j+1:]\n    return abs(area)\n    \ndef invalid(s): # Checks if the path is invalid\n    x, y, sgn = 0, 0, 1\n    V, H = [], []\n    while True:\n        g = (i for i, c in enumerate(s) if c in d)\n        i, j = next(g, -1), next(g, -1)\n        if i == -1: return True\n        a, b = sgn * int(s[:i]), d[s[i]]*sgn * int(s[i+1:] if j==-1 else s[i+1:j])\n        H.append((x,y,a))\n        for p,q,r in V[:-1]:\n            if (y-q)**2<=(y-q)*r and (p-x)**2<=(p-x)*a:\n                return True\n        V.append((x+a,y,b))\n        for p,q,r in H[1:-1] if j == -1 else H[:-1]:\n            if (q-y)**2<=(q-y)*b and (x+a-p)**2<=(x+a-p)*r:\n                return True\n        x,y = x+a,y+b\n        if j == -1: break\n        sgn *= -d[s[i]]*d[s[j]]\n        s = s[j+1:]\n    return x!=0 or y!=0\n    \n", "import re\n\ndef check_intersection(y, x0, x1, segments):\n    return any(x0 <= x <= x1 and y0 <= y <= y1 for x, y0, y1 in segments)\n\ndef mouse_path(s):\n    sort_coords = lambda x0, x1: (x0, x1) if x0 <= x1 else (x1, x0)\n    dx, dy = 1, 0\n    x, y = 0, 0\n    hs, vs = [], []\n    area = 0\n    s = re.split('([LR])', s)\n    n = len(s)\n    for i in range(n):\n        cmd = s[i]\n        if cmd == 'L':\n            dx, dy = -dy, dx\n        elif cmd == 'R':\n            dx, dy = dy, -dx\n        else:\n            d = int(cmd)\n            x1, y1 = x + d * dx, y + d * dy\n            if dy == 0:\n                a, b = sort_coords(x, x1)\n                if i == n - 1:\n                    return None\n                if check_intersection(y, a, b, vs[:-1]):\n                    return None\n                hs.append((y, a, b))\n            else:\n                a, b = sort_coords(y, y1)\n                if i == n - 1:\n                    hs = hs[1:]\n                if check_intersection(x, a, b, hs[:-1]):\n                    return None\n                vs.append((x, a, b))\n            area += x * y1 - x1 * y\n            x, y = x1, y1\n    return abs(area // 2) if x == 0 and y == 0 else None", "import re\nO = lambda Q,W,E : W <= Q <= E if W < E else E <= Q <= W\ndef mouse_path(Q) :\n  M,U,D,R,C = [],0,0,0,0\n  for Q in re.findall('.\\d+','R' + Q) :\n    D,Q = D + ('O' < Q or 3),int(Q[1:])\n    r,c = [-Q,0,Q,0][D % 4] + R,[0,Q,0,-Q][D % 4] + C\n    U += R * c - r * C\n    for H,W,h,w in M[:-1] :\n      if (R == r) ^ (H == h) :\n        if O(R,H,h) and O(W,C,c) if H - h else O(H,R,r) and O(C,W,w) and not 0 == r == c == H == W : return\n      elif R == r == H and (O(C,W,w) or O(c,W,w) or O(W,C,c)) or C == c == W and (O(R,H,h) or O(r,H,h) or O(H,R,r)) : return\n    M.append((R,C,r,c))\n    R,C = r,c\n  if 0 == R == C : return abs(U + R - C) / 2", "import re\ndef mouse_path(s):\n    x, y, dx, dy, area, vert = 0, 0, 0, 1, 0, [(0,0)]\n    tokes = re.findall('[RL]|\\d+',s)\n    if len(tokes) % 4 != 3:                                 #hole not in corner\n        return None\n    for n in tokes:\n        if n == 'L':\n            dx, dy = -dy, dx;\n        elif n == 'R':\n            dx, dy = dy, -dx;\n        else:\n            d = int(n)\n            x2, y2 = x + d * dx, y + d * dy\n            if any(intersect((x,y),(x2,y2),vert[i],vert[i+1]) for i in range(len(vert)-4, -1+((x2,y2)==(0,0)), -2)):\n                return None\n            area += x * y2 - y * x2                         #area of irregular polygon\n            x, y = x2, y2\n            vert.append((x,y))\n    if (x,y) != (0,0):                                      #path doesn't close\n        return None\n    return abs(area)//2 or None                             #area of irregular polygon\n\ndef intersect(a, b, c, d):\n    i = a[0]==b[0]\n    return (c[i]-a[i])*(c[i]-b[i]) <= 0 and (a[1-i]-c[1-i])*(a[1-i]-d[1-i]) <= 0\n", "import re\n\n\ndef path_to_point(path, r=[-1, 0], position=[0, 0]):\n    rotations = {'L': lambda a, b: (b * -1, a), 'R': lambda a, b: (b, a * -1)}\n    result = []\n    for v in re.findall(r'\\d+|.', path):\n        if v.isnumeric():\n            position = position[0] + r[0] * int(v), position[1] + r[1] * int(v)\n            result.append(position)\n        else:\n            r = rotations[v](*r)\n    return result\n\n\ndef check_path(points):\n    print(points)\n    if len(points) % 2 != 0 or points[-1] != (0, 0) or (\n       len(points) != len(set(points))):\n        return False\n\n    vertical_segments, horizontal_segments = [], []\n    for i in range(0, len(points), 2):\n        p1, p2, p3 = points[i], points[i + 1], points[(i + 2) % len(points)]\n        v = (p1, p2)\n        h = (p2, p3)\n        for s in vertical_segments:\n            if min(s[0][1], s[1][1]) <= h[0][1] <= max(s[0][1], s[1][1]) and (\n               min(h[0][0], h[1][0]) <= s[0][0] <= max(h[0][0], h[1][0]) and not\n               (h[0] == s[0] or h[0] == s[1] or h[1] == s[0] or h[1] == s[1])):\n                return False\n\n        for s in horizontal_segments:\n            if min(s[0][0], s[1][0]) <= v[0][0] <= max(s[0][0], s[1][0]) and (\n               min(v[0][1], v[1][1]) <= s[0][1] <= max(v[0][1], v[1][1]) and not\n               (v[0] == s[0] or v[0] == s[1] or v[1] == s[0] or v[1] == s[1])):\n                return False\n\n        vertical_segments.append(v)\n        horizontal_segments.append(h)\n\n    return True\n\n\ndef mouse_path(s):\n    points = path_to_point(s)\n    if not check_path(points):\n        return None\n\n    separators = sorted(list(set([p[1] for p in points])))\n\n    _points = []\n    for i in range(len(points)):\n        p1, p2 = points[i], points[(i+1) % len(points)]\n        _points.append(p1)\n        if p1[0] == p2[0]:\n            for j in (separators if p1[1] < p2[1] else separators[::-1]):\n                if min(p1[1], p2[1]) < j < max(p1[1], p2[1]):\n                    _points.append((p1[0], j))\n    points = _points\n\n    result = 0\n    separators = list(separators)\n    for i in range(len(separators) - 1):\n        y1, y2 = separators[i], separators[i + 1]\n        temp = []\n        for p in sorted(list(filter(lambda x: x[1] == separators[i], points)))[::-1]:\n            j = points.index(p)\n            if points[j - 1] == (p[0], y2) or points[(j + 1) % len(points)] == (p[0], y2):\n                temp.append(p)\n        if len(temp) % 2 != 0:\n            return None\n        for j in range(0, len(temp), 2):\n            result += (y2 - y1) * (temp[j][0] - temp[j + 1][0])\n    return result", "from collections import defaultdict\n\ndef mouse_path(s):\n    #use the shoelace method to calculate area from coordinates\n    \n    #direction given as a tuple on coordinae plane, eg (1,0) right\n    \n    #set direction based on current direction and turn direction\n    turns = {direction:defaultdict(tuple) for direction in ((0,1),(0,-1),(-1,0),(1,0))}\n    turns[(0,-1)]['L'], turns[(0,-1)]['R'] = turns[(0,1)]['R'], turns[(0,1)]['L'] = (1,0),(-1,0) #dx,dy\n    turns[(-1,0)]['L'], turns[(-1,0)]['R'] = turns[(1,0)]['R'], turns[(1,0)]['L'] = (0,-1),(0,1) #dx,dy\n    \n    coords = [(0,0)]\n    \n    #first we need to parse the string for coordinates, assume an initial direction of right\n    num = []\n    x=y=0\n    direction = (1,0)\n    \n    for a in s + ' ':\n        if a.isdigit():\n            num.append(a)\n        else:\n            num = int(''.join(num))\n            x+=num*direction[0]\n            y+=num*direction[1]\n            coords.append((x,y))\n            direction = turns[direction][a]\n            num = []            \n    \n    #check if the shape is not closed\n    if coords[0] != coords[-1]: return None\n    #check if we don't end in a corner (even number of coordinates, try drawing out and you will see)\n    if len(coords) % 2 == 0: return None\n    \n    #check for intersections, check each horizonal line with each vertical line (excluding the ones beginning and\n    #ending at the ends of the horizonal line) for intersections. A line is paramterized by two coordinates, its start and\n    #end point. if there are more than 2 vertical lines intersecting horizonal, return None\n    horizontals = [(coords[i],coords[i+1]) for i in range(0,len(coords)-1,2)]\n    verticals = [(coords[i],coords[i+1]) for i in range(1,len(coords)-1,2)]\n    \n    for (x1,y1),(x2,y2) in horizontals:\n        max_x, min_x = max(x1,x2),min(x1,x2)\n        count = 0\n        for (a1,b1),(a2,b2) in verticals:\n            max_y,min_y = max(b1,b2),min(b1,b2)\n            if min_x <= a1 <= max_x and min_y <= y1 <= max_y:\n                count += 1\n                if count > 2: return None\n                \n    #main shoelace formula\n    area = 0\n    j = 0\n    for i in range(1,len(coords)):\n        area += (coords[j][0] + coords[i][0]) * (coords[j][1] - coords[i][1])\n        j=i\n        \n    return abs(area/2)", "def mouse_path(path):\n  moves = parse_path(path)\n  points = convert_moves_to_points(moves)\n  if (is_valid(points)):\n    return calculate_using_polygon_formula(points)\n    if (result == 0):\n      return None\n    else:\n      return result\n  else:\n    return None\n\ndef parse_path(path):\n  charIndexList = []\n  for i, c in enumerate(list(path)):\n    if (c == 'L' or c == 'R'):\n      charIndexList.append(i)\n  resultList = [('R', int(path[0:charIndexList[0]]))]\n  i = 0\n  while i < (len(charIndexList) - 1):\n    str = path[(charIndexList[i] + 1):(charIndexList[i + 1])]\n    resultList.append((path[charIndexList[i]], int(str)))\n    i = i + 1\n  resultList.append((path[charIndexList[-1]], int(path[(charIndexList[-1] + 1):])))\n  return resultList\n  \ndef convert_moves_to_points(moves):\n  points = [(0, 0)]\n  x = 0\n  y = 0\n  dir = 0\n  for i in range(len(moves)):\n    if (dir == 0):\n      if (moves[i][0] == 'L'):\n        x = x - moves[i][1]\n      else:\n        x = x + moves[i][1]\n    elif (dir == 1):\n      if (moves[i][0] == 'L'):\n        y = y + moves[i][1]\n      else:\n        y = y - moves[i][1]\n    elif (dir == 2):\n      if (moves[i][0] == 'L'):\n        x = x + moves[i][1]\n      else:\n        x = x - moves[i][1]\n    elif (dir == 3):\n      if (moves[i][0] == 'L'):\n        y = y - moves[i][1]\n      else:\n        y = y + moves[i][1]\n    if (moves[i][0] == 'L'):\n      if (dir == 0):\n        dir = 3\n      else:\n        dir = (dir - 1) % 4\n    else:\n      dir = (dir + 1) % 4\n    points.append((x, y))\n  return points\n\ndef is_valid(points):\n  if (points[0] != points[-1]):\n    return False\n  if (points[-2][0] != 0):\n    return False\n  if (len(points) - 1 != len(set(points[1:]))):\n    return False\n  lines = list(zip(points, points[1:]))\n  i = 2\n  while (i < len(lines)):\n    j = i - 2\n    while (j >= 0):\n      if (intersect(lines[i][0], lines[i][1], lines[j][0], lines[j][1])):\n        if (not(i == len(lines) - 1 and j == 0)):\n          return False  \n      j = j - 1\n    i = i + 1\n  return True\n  \n  \ndef intersect(p1, p2, p3, p4):\n  linesParallel = (p1[0] == p2[0] and p3[0] == p4[0]) or (p1[1] == p2[1] and p3[1] == p4[1])\n  if (linesParallel):\n    if (p1[0] == p2[0] and p1[0] == p3[0]):\n      secondAbove = max(p2[1], p1[1]) >= min(p3[1], p4[1]) and min(p1[1], p2[1]) <= min(p3[1], p4[1])\n      firstAbove = min(p1[1], p2[1]) <= max(p3[1], p4[1]) and  min(p1[1], p2[1]) >= min(p3[1], p4[1])\n      return secondAbove or firstAbove\n    elif (p1[1] == p2[1] and p1[1] == p3[1]):\n      secondAbove = max(p3[0], p4[0]) >= min(p1[0], p2[0]) and max(p3[0], p4[0]) <= max(p1[0], p2[0])\n      firstAbove = min(p3[0], p4[0]) >= min(p1[0], p2[0]) and min(p3[0], p4[0]) <= max(p1[0], p2[0])\n      return secondAbove or firstAbove\n    return False\n  isSecondLineVertical = p4[0] == p3[0]\n  if (isSecondLineVertical):\n    return min(p1[0], p2[0]) <= p4[0] and p4[0] <= max(p1[0], p2[0]) and min(p3[1], p4[1]) <= p1[1] and max(p3[1], p4[1]) >= p1[1]\n  else:\n    return p3[1] >= min(p1[1], p2[1]) and p3[1] <= max(p1[1], p2[1]) and min(p3[0], p4[0]) <= p1[0] and max(p3[0], p4[0]) >= p1[0]\n  \ndef calculate_using_polygon_formula(points):\n  result = 0\n  for i in range(len(points) - 1):\n    p1 = points[i]\n    p2 = points[i + 1]\n    result = result + (p1[0] * p2[1] - p1[1] * p2[0])\n  return int(abs(result) / 2)", "class point():\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    __str__ = lambda self: f\"{self.x}, {self.y}\"\n    __add__ = lambda self, p2: point(self.x + p2.x, self.y + p2.y)\n    __mul__ = lambda self, num: point(self.x * num, self.y * num)\n    __eq__  = lambda self, p2: True if self.x == p2.x and self.y == p2.y else False\n\ndef turn_to_dir(c_dir, turn):\n    return point(-c_dir.y, c_dir.x) if turn == 'L' else point(c_dir.y, -c_dir.x)\n\ndef str_to_points(string):\n    last_index = 0\n    direction = point(1,0)\n    points = [point(0,0)]\n    for index, symbol in enumerate(string + 'L'):\n        if symbol in 'LR':\n            points.append(points[-1] + direction * int(string[last_index:index]))\n            direction = turn_to_dir(direction, symbol)\n            last_index = index + 1\n    return points\n\ndef doIntersect(seg1, seg2):\n    # seg1 = [(p0_x, p0_y), (p1_x, p1_y)]\n    # seg2 = [(p2_x, p2_y), (p3_x, p3_y)]\n    p0_x = seg1[0].x\n    p0_y = seg1[0].y\n    p1_x = seg1[1].x\n    p1_y = seg1[1].y\n    p2_x = seg2[0].x\n    p2_y = seg2[0].y\n    p3_x = seg2[1].x\n    p3_y = seg2[1].y\n\n    s1_x = p1_x - p0_x\n    s1_y = p1_y - p0_y\n    s2_x = p3_x - p2_x\n    s2_y = p3_y - p2_y\n\n    denom = -s2_x * s1_y + s1_x * s2_y\n\n    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / denom if denom != 0 else -1\n    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / denom if denom != 0 else -1\n\n    if 0 <= s <= 1 and 0 <= t <= 1:\n        return True\n\ndef check(points):\n    # the path doesn't complete the loop back to the mousehole\n    if points[0] != points[-1]:\n        return False\n    # the mousehole is located along the straight path of a wall\n    if points[1].x == points[-2].x or points[1].y == points[-2].y:\n        return False\n    # the path intersects/overlaps itself\n    points_count = len(points) - 1\n    for i in range(points_count - 3):\n        for j in range(i+2, points_count - 1):\n            if doIntersect((points[i], points[i+1]), (points[j], points[j+1])):\n                return False\n    for i in range(1, points_count - 2):\n        # print((str(points[0]), str(points[-2])), (str(points[i]), str(points[i+1])))\n        if doIntersect((points[0], points[-2]), (points[i], points[i+1])):\n            return False\n    return True\n\ndef area(p):\n    return 0.5 * abs(sum(segment[0].x*segment[1].y - segment[1].x*segment[0].y\n                         for segment in segments(p)))\n\ndef segments(p):\n    return zip(p, p[1:] + [p[0]])\n\ndef mouse_path(s):\n    points = str_to_points(s)\n    return area(points) if check(points) else None", "class Line:\n    def __init__(self,p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n    def printLine(self):\n        print((\"[\"+self.p1.printPoint()+\",\"+self.p2.printPoint()+\"] \"))\n        \nclass Point:\n    def __init__(self,x, y):\n        self.x = x\n        self.y = y\n        \n    def printPoint(self):\n        return \"(\"+str(self.x)+\",\"+ str(self.y)+\")\"\n\ndef get_my_key(line):\n    firstX = line.p1.x\n    secondX = line.p2.x\n    if(firstX == secondX):\n        return firstX+.1\n    if firstX < secondX:\n        return firstX\n    else:\n        return secondX\n    \ndef rearrange(lines):\n    for line in lines:\n        if line.p1.y > line.p2.y:\n            temp = line.p1.y\n            line.p1.y = line.p2.y\n            line.p2.y = temp\n        if line.p1.x > line.p2.x:\n            temp = line.p1.x\n            line.p1.x = line.p2.x\n            line.p2.x = temp\n    return lines\n\ndef polygonArea(X, Y, n): \n    # Initialze area \n    area = 0.0\n  \n    # Calculate value of shoelace formula \n    j = n - 1\n    for i in range(0,n): \n        area += (X[j] + X[i]) * (Y[j] - Y[i]) \n        j = i   # j is previous vertex to i \n      \n  \n    # Return absolute value \n    return int(abs(area / 2.0)) \n   \n    \ndef mouse_path(s):\n    length = len(s)\n    xCoor = 0\n    yCoor = 0\n    point1 = Point(xCoor,yCoor)\n    lines = []\n    X = [0]\n    Y = [0]\n    direction = 1 #1 for right, 2 for left, 3 for up and 4 for down\n    number = \"\"\n    for i in range(length):\n        if s[i] == 'L' or s[i] == 'R':\n            if s[i] == 'L':\n                if direction == 1:\n                    direction = 3\n                elif direction == 2:\n                    direction = 4\n                elif direction == 3:\n                    direction = 2\n                elif direction == 4:\n                    direction = 1     \n            else:\n                if direction == 1:\n                    direction = 4\n                elif direction == 2:\n                    direction = 3\n                elif direction == 3:\n                    direction = 1\n                elif direction == 4:\n                    direction = 2     \n        else:\n            number += s[i]\n            if i+1 == length or s[i+1] == \"L\" or s[i+1] == \"R\":\n                if direction == 1:\n                    xCoor = xCoor + int(number)\n                elif direction == 2:\n                    xCoor = xCoor - int(number)\n                elif direction == 3:\n                    yCoor = yCoor + int(number)\n                elif direction == 4:\n                    yCoor = yCoor - int(number)\n                point2 = Point(xCoor,yCoor)\n                line = Line(point1,point2)\n                X.append(xCoor)\n                Y.append(yCoor)\n                point1 = Point(point2.x,point2.y)\n                lines.append(line)\n                number = \"\"\n               \n    \n    if lines[0].p1.x != lines[len(lines)-1].p2.x and lines[0].p1.y != lines[len(lines)-1].p2.y:\n        return None\n    if lines[0].p1.y == lines[len(lines)-1].p1.y and lines[0].p2.y == lines[len(lines)-1].p2.y:\n        return None\n    \n    X.pop()\n    Y.pop()\n    lines.sort(key=get_my_key)\n    lines = rearrange(lines)\n    \n    lines_copy = lines.copy()\n    lines_entered = []\n    \n     \n    #testing for intersects\n    while len(lines_copy)>0:\n        \n        removeEntered = False\n        line = lines_copy[0]\n        for entLine in lines_entered:\n                if entLine.p1.y == line.p1.y and entLine.p2.x > line.p1.x and line.p1.x != line.p2.x:\n                    return None\n                if entLine.p2.x < line.p1.x:\n                    line = entLine\n                    removeEntered = True\n                    break\n                    \n        if removeEntered == True:\n            lines_entered.remove(line)\n            \n        else:      \n            if line.p1.x == line.p2.x:\n                for entLine in lines_entered:\n                    if entLine.p1.y > line.p1.y and entLine.p2.y < line.p2.y:\n                        return None\n                lines_copy.pop(0)\n            else:\n                    lines_entered.append(line)\n                    lines_copy.pop(0)\n                    \n        removeEntered = False\n        \n        n = len(X)\n    return polygonArea(X,Y,n)\n\n    pass\n"]
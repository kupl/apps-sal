["class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        curmaxsight = A[0] - 1\n        curmaxpair = 0\n        for sight in A[1:]:\n            if sight + curmaxsight > curmaxpair:\n                curmaxpair = sight + curmaxsight\n            if sight > curmaxsight:\n                curmaxsight = sight\n            curmaxsight -= 1\n        return curmaxpair\n            \n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        result = 0\n        current = A[0]\n        current_pos = 0\n        for i in range(1, len(A)):\n            value = current + A[i] + current_pos - i\n            if value > result:\n                result = value\n            if current <= A[i] + i-current_pos:\n                current = A[i]\n                current_pos = i\n\n        return result\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        res = 0\n        m = A[0]\n        \n        for j in range(1, len(A)):\n            res = max(res, A[j] - j + m)\n            m = max(m, A[j] + j)\n        \n        return res\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        ans = -math.inf\n        best = -math.inf\n        for i,a in enumerate(A):\n            ans = max(ans, best + a - i)\n            best = max(best, a + i)\n        \n        return ans", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        i = 0\n        ans = float('-inf')\n        \n        for j in range(1,len(A)):\n            ans = max(ans, A[i] + A[j] + i - j)\n            \n            if A[j] + j >= A[i] + i:\n                i = j\n        return ans", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        i = 0\n        max_degree = A[i] + i\n        max_score = -float('inf')\n        \n        for j in range(1, len(A)):\n            curr_max_score = A[j] - j + max_degree\n            max_score = max(max_score, curr_max_score)\n            max_degree = max(max_degree, A[j]+j)\n            \n        return max_score", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        \n        ans = float('-inf')\n        if len(A)<2: return 0\n        one = A[0]\n \n        for i in range(1,len(A)):\n            ans = max(ans,one+A[i]-i)\n            one = max(one, A[i]+i)\n        \n        return ans", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        # consider B[i] = A[i] + i, C[i] = A[i] -j\n        # Find the B[i] + C[j]\n        B = [A[i] + i for i in range(len(A))]\n        C = [A[i] - i for i in range(len(A))]\n        p = 0 \n        q = 1\n        max_score = float('-inf')\n        # for each q = 1, 2,..., len(A) - 1\n        # update the max of B[0], ...., B[j-1]: B[p]\n        # calculate B[q] - B[p]\n        while q < len(B):\n            if B[q-1] > B[p]:\n                p = q - 1 \n            max_score = max(max_score, B[p] + C[q])\n            q += 1\n        return max_score\n            \n            \n        \n        \n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        sA = sorted(enumerate(A), key= lambda x:x[1], reverse=True)\n        # print(sA)\n\n        L = len(A)\n        maxScore = -L   #invalid value, just for initialization\n        theDis = -1  #invalid value, just for initialization, minimal dis should be 1\n        for i in range(L-1):\n            if sA[i][1] + sA[i+1][1] <= maxScore + 1:\n                # print('too small to continue', i)\n                break  #two small to continue\n            for j in range(i+1, L):\n                curScore = sA[i][1] + sA[j][1]\n                if curScore <= maxScore + 1:\n                    # print('internal break', i, j)\n                    break\n                curDis = abs(sA[i][0]-sA[j][0])\n                curScore -= curDis\n                if curScore > maxScore:\n                    maxScore = curScore\n                    theDis = curDis \n        return maxScore\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        res = imax = 0\n        for i, a in enumerate(A):\n            res = max(res, imax + A[i] - i)\n            imax = max(imax, A[i] + i)\n        return res\n\n#     int n = a.size();\n#     int maxOverallGain = INT_MIN;\n#     int maxEndRight = a[n-1] - (n-1);\n#     for(int i=n-2; i>=0; i--)\n#     {\n#         maxEndRight = max(maxEndRight, a[i+1] - (i+1));\n#         maxOverallGain = max(maxOverallGain, a[i] + i + maxEndRight);\n#     }\n#     return maxOverallGain;\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        maxI = A[0]\n        ans = A[0] + A[1] - 1\n        for i in range(1, len(A)):\n            if ans < maxI + A[i] - i:\n                ans = maxI + A[i] - i\n            if maxI < A[i] + i:\n                maxI = A[i] + i\n        return ans", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        i_sum = []\n        j_sum = []\n        prev = -float('inf')\n        max_sum = -float('inf')\n        for i in reversed(list(range(len(A)))):\n            if i > 0:\n                if A[i]-i > prev:\n                    j_sum.append(A[i]-i)\n                    prev = A[i] - i\n                else:\n                    j_sum.append(prev)\n            i_sum.append(A[i]+i)\n        for i in reversed(list(range(1,len(i_sum)))):\n            max_sum = max(max_sum, i_sum[i]+j_sum[i-1])\n        return max_sum\n\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        res = maxx = 0\n        for i in range(len(A)):\n            res = max(res, maxx+A[i])\n            maxx = max(maxx, A[i]) - 1\n        return res", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        # score = A[i] + A[j] + i - j = A[i] + i + A[j] - j\n        # max(A[i]+i + A[j] - j) = max(A[i]+i) + max(A[j]-j), i<j\n        max_i = 0\n        score_max_i_j = []\n        for j in range(len(A)):\n            score_max_i_j.append(max_i + A[j] - j)\n            max_i = max(max_i, A[j]+j)\n        return max(score_max_i_j)\n\n\n\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        a, b, n = 0, 1, len(A)\n        def opt(i,j):\n            return A[i] + A[j] + i - j\n        \n        ans = [A[0], opt(0,1)] + [0 for _ in range(n-2)]\n        \n        for i in range(2, n):\n            opt_a, opt_b = opt(a, i), opt(b, i)\n            if opt_a > opt_b:\n                ans[i] = opt_a\n                b = i\n            else:\n                ans[i] = opt_b\n                a = b\n                b = i\n        \n        return max(ans)\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        res = 0\n        n = len(A)\n        m = A[0]\n        j = 0\n        for i in range(1, n):\n            res = max(res, (A[i]+A[j]+j-i))\n            if A[i]+i-j > m:\n                m = A[i]\n                j = i\n        return res", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        # consider B[i] = A[i] + i, C[i] = A[i] -j\n        # Find the B[i] + C[j]\n        B = [A[i] + i for i in range(len(A))]\n        C = [A[i] - i for i in range(len(A))]\n        p = 0 \n        q = 1\n        max_score = 0 \n        # for each q = 1, 2,..., len(A) - 1\n        # update the max of B[0], ...., B[j-1]: B[p]\n        # calculate B[q] - B[p]\n        while q < len(B):\n            if B[q-1] > B[p]:\n                p = q - 1 \n            max_score = max(max_score, B[p] + C[q])\n            q += 1\n        return max_score\n            \n            \n        \n        \n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        # A = [8 , 1 ,5 ,2 6,]\n        # output = 11\n        # Explanation:\n            # i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\n            \n        # print(A)\n        \n#         max_score = 0\n        \n#         for i in range(len(A)):\n#             first = A[i] # this is my number\n#             for j in range(0,len(A)):\n#                 second = A[j]\n#                 max_score = max(max_score ,A[i] + A[j] + i - j )      \n#                 print(A[i] + A[j])\n#             return max_score\n        \n        i = A[0]\n        max_ans = 0\n        for j in range(1,len(A)):\n            x = A[j]\n            print(x)\n            max_ans = max(max_ans, i + x - j)\n            i = max(i , x + j)\n        return max_ans\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        # consider B[i] = A[i] + i, C[i] = A[i] -j\n        # Find the B[i] + C[j]\n        B = [A[i] + i for i in range(len(A))]\n        C = [A[i] - i for i in range(len(A))]\n        p = 0 \n        q = 1\n        max_score = 0 \n\n        while q < len(B):\n            if B[q-1] > B[p]:\n                p = q - 1 \n            max_score = max(max_score, B[p] + C[q])\n            q += 1\n        return max_score\n            \n            \n        \n        \n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        preMax = A[0]\n        ans = 0\n        for i, a in enumerate(A[1:], 1):\n            ans = max(ans, a - i + preMax)\n            preMax = max(preMax, a + i)\n            # print(preMax,ans)\n        return ans", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        res = imax = 0\n        for i, a in enumerate(A):\n            res = max(res, imax + A[i] - i)\n            imax = max(imax, A[i] + i)\n        return res", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        best_of_prev = A[0] - 1\n        maximum = 0\n        \n        for spot in A[1:]:\n            if spot + best_of_prev > maximum:\n                maximum = spot + best_of_prev\n                \n            if spot > best_of_prev:\n                best_of_prev = spot\n                \n            best_of_prev -= 1\n            \n        return maximum\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        res = 0\n        maximum = A[0]\n        for i in range(1, len(A)):\n            cur = A[i]-i\n            res = max(res, cur+maximum)\n            maximum = max(maximum, A[i]+i)\n            \n        return res", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        ans = 0\n        best_pre = 0\n        for i in range(1,len(A)):\n            ans = max(ans, A[best_pre]+best_pre + A[i]- i)\n            if A[i]+i >  A[best_pre] + best_pre:\n                best_pre = i\n        return ans\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        # A = [8 , 1 ,5 ,2 6,]\n        # output = 11\n        # Explanation:\n            # i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\n        i = A[0]\n        max_ans = 0\n        for j in range(1,len(A)):\n            x = A[j]\n            print(x)\n            max_ans = max(max_ans, i + x - j)\n            i = max(i , x + j)\n        return max_ans\n", "\nclass Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        best = 0\n        i = 0\n        for j in range(1, len(A)):\n            s1 = A[i] + A[j] + i - j\n            s2 = A[j] + A[j-1] + j - 1 - j\n            if s2 > s1:\n                i = j - 1\n            best = max(best, s1, s2) \n        return best\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        lmax=A[0]\n        gmax=float('-inf')\n        for i in range(1,len(A)):\n            cur=lmax+A[i]-i\n            lmax=max(lmax,A[i]+i)\n            gmax=max(gmax,cur)\n            \n        return gmax", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:  # O(n log n)?\n        # dynamic programming / memoization solution?  => wrong!!!\n        ## [1, 2, 3, 4] => [[1, 2], [2, 3], [3, 4]]  sum: a + b - 1\n        ##                             [[1, 3], [2, 4]] sum: [a, b-1] + [b] - 1  # get midpoint and look-up left and right parts\n        ##                                  [[1, 4]] sum: [1:2] + [3:4] -1\n        \n        ### example: A = [8,1,5,2,6]\n        ## memo[dist=1]: [8+1-1=8, 1+5-1=5, 5+2-1=6, 2+6-1=7]\n        ## memp[dist=2]: [8+5-1=13]\n        # memo = {(i, i): A[i] for i in range(A)}  # (i, j) = sum(i:j)\n        # max_score = 0  # max(memo.values())\n        # for dist in range(1, len(A)):\n        #     for i in range(len(A) - dist):\n        #         # get sum\n        #         mid = (i + dist) // 2  # for pairs of dist 1 => 0, 1; mid == 0\n        #         left_sum = memo[(i, mid)]\n        #         right_sum = memo[(mid+1, i+dist)]\n        #         memo[(i, i + dist)] = left_sum + right_sum - 1\n        #         max_score = max(memo[(i, i + dist)], max_score)  # update max score\n        # return max_score\n        \n        ## idea 2: lagging and leading pointers => calc their score. Move leading on, if score goes down, move lagging next\n        lag, lead = 0, 1\n        prev_max_score = A[0]\n        prev_max_idx = 0\n        max_score = 0\n        for i in range(1, len(A)):\n            score = prev_max_score + A[i] - (i - prev_max_idx)\n            max_score = max(score, max_score)\n            if A[i] >= score - A[i]:\n                prev_max_idx = i\n                prev_max_score = A[i]\n            \n        return max_score\n\n# ex: [100, 1, 1, 1, 1....[1]*_99_, 51, 51, 1, 1, [1]*_99_, 100]\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        best_i = 0 \n        res = 0\n        for i, v in enumerate(A):\n            res = max(res, v-i+best_i)\n            best_i = max(best_i, v+i)\n        return res\n\n        return res\n        # best_i = 0\n        # res = 0 \n        # for i, v in enumerate(A):\n        #     res = max(res, v-i+best_i)\n        #     best_i = max(best_i, v+i)\n        # return res\n        # best_i = 0\n        # res = 0 \n        # for i, v in enumerate(A):\n        #     res = max(res, v- i + best_i)\n        #     best_i = max(best_i, v+i)\n        # return res\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        d=0\n        m=A[0]\n        for i in range(1,len(A)):\n            d=max(d,A[i-1]+(i-1))\n            m=max(A[i]-i+d,m)\n        return m\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        best_of_prev = A[0] - 1\n        maximum = 0\n        \n        for spot in A[1:]:\n            if spot + best_of_prev > maximum:\n                maximum = spot + best_of_prev\n                \n            if spot > best_of_prev:\n                best_of_prev = spot\n                \n            best_of_prev -= 1\n            \n        return maximum\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        n = len(A)\n        pre = A[0] + 0\n        res = 0\n        for i in range(1, n):\n            # res = max(res, pre + A[i] - i)\n            # pre = max(pre, A[i] + i)\n            res = res if res > pre + A[i] - i else pre + A[i] - i\n            pre = pre if pre > A[i] + i else A[i] + i\n        return res\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        n = len(A)\n        res = max_i = -n\n        for j in range(1,n):\n            max_i = max(max_i, A[j-1] + j-1)\n            res = max(res, max_i + A[j] - j)\n        return res\n        \n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        idx = [0]\n        for i in range(1, len(A)):\n            if A[i]+i-idx[-1]> A[idx[-1]]:\n                idx.append(i)\n        res = float('-inf')\n        i = 1 \n        j = 0\n        #print(idx)\n        while i < len(A):\n            if j+1 < len(idx) and idx[j+1] < i:\n                j += 1            \n            res = max(res, A[i]+A[idx[j]]+idx[j]-i)\n            i += 1\n        return res\n            \n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        \n        arr = [A[0] + A[j] - j for j in range(1, len(A))]\n        print(arr)\n        maxdiff = 0\n        ans = max(arr)\n        for j in range(1, len(arr)):\n            maxdiff = max(maxdiff, A[j] - A[0] + j)\n            ans = max(ans, arr[j] + maxdiff)\n        return ans", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        max_score = 0\n        \n        # prev = ans = -float('inf')\n        # for i in range(1, len(A)):\n        #     prev = max(prev, A[i-1]+i-1)\n        #     ans = max(ans, prev+A[i]-i)\n        # return ans\n        prev = ans = -float('inf')\n        # A[i] + A[j] + i - j\n        for i in range(1, len(A)):\n            prev = max(prev, A[i-1] + i - 1)\n            ans = max(ans, prev + A[i]-i)\n        return ans\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        \n        \n        i_sum = [0]*len(A)\n        \n        j_sum = [0]*len(A)\n        \n        for i in range(len(A)):\n            i_sum[i] = A[i] + i\n        \n        i_sum[-1] = 0\n        for j in range(len(A)):\n            j_sum[j] = A[j] - j\n            \n        print(j_sum)\n        prefix_sum = [-float('inf')]*len(A)\n        for j in  range(len(A)-2,-1,-1):\n            prefix_sum[j] = max(j_sum[j+1], prefix_sum[j+1])\n            \n        max_sum = -float('inf')\n        for i in range(len(A)):\n            max_sum = max(max_sum,prefix_sum[i] + i_sum[i])\n        print(prefix_sum)\n        return max_sum\n        \n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        \n        n = len(A)\n        # dp = [0] * n\n        # dp[0] = A[0]\n        dp = 0\n        ans = 0\n        for j in range(0,n):\n            # ans = A[j]-j + max_i{0, j-1}(A[i]+i)\n            #     = A[j]-j] + dp[j-1]\n            # dp[j] = max(dp[j-1], A[j]+j)\n            # ans = max(ans, A[j]-j + dp[j-1])\n            # dp[j] = max(dp[j-1], A[j]+j)\n            ans = max(ans, A[j]-j + dp)\n            dp = max(dp, A[j]+j)\n        # print(dp)\n        return ans", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n#         maxScore = 0 \n\n#         for i in range(0,len(A)):\n#             for j in range(i+1,len(A)):\n#                 val = A[i] + A[j] + i - j \n#                 if val > maxScore:\n#                     maxScore = val \n#         return maxScore\n        best = 0\n        i = 0\n        for j in range(1, len(A)):\n            s1 = A[i] + A[j] + i - j\n            s2 = A[j] + A[j-1] - 1 \n            if s2 > s1:\n                i = j - 1\n            best = max(best, s1, s2) \n        return best", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        cur, ans = 0, 0\n        for a in  A:\n            ans = max(ans, cur + a)\n            cur = max(cur, a) -1\n        return ans\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        #we want to find the two biggest numbers closest to eachother.\n        dp_i = [0 for i in range(len(A))]\n        dp_j = [0 for i in range(len(A))]\n        dp_i[0] = A[0]\n        dp_j[-1] = A[-1] - (len(A) - 1)\n        for i in range(1, len(A)):\n            dp_i[i] = max(A[i] + i, dp_i[i - 1])\n        for j in range(len(A) - 2, -1 , -1):\n            dp_j[j] = max(A[j] - j, dp_j[j + 1])\n        max_sum = 0\n\n        for i in range(len(A) - 1):\n            max_sum = max(max_sum, dp_i[i] + dp_j[i + 1])\n    \n        return max_sum\n            \n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        total = 0\n        n = len(A)\n        if n <= 2:\n            return sum(A) - 1\n        \n        a_1 = [a+i for i, a in enumerate(A)]        \n        a_2 = [a-j for j, a in enumerate(A)]\n        \n        dp2 = [a for a in a_2]\n        for i in range(n-2, -1, -1):\n            dp2[i] = max(dp2[i+1], a_2[i+1])\n           \n        dp1 = [a for a in a_1]\n        dp1[0] += dp2[0] \n        for i in range(1, n-1):\n            dp1[i] = max(a_1[i]+dp2[i], dp1[i-1])\n        \n        return dp1[-2]\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        point = (A[0], 0)\n        best_val = A[0]\n        best_ind = 0\n        max_score = 0\n        for ind in range(1, len(A)):\n            max_score = max(max_score, best_val+A[ind]+best_ind-ind)\n            if A[ind]+ind-best_ind >= best_val:\n                best_val = A[ind]\n                best_ind = ind\n        return max_score", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        d = A[1]+A[0]-1\n        m = A[0]\n        for j in range(1, len(A)):\n            if m+ A[j] - j > d:\n                d = m+A[j]-j\n            if A[j]+j >= m:\n                m = A[j]+j\n        return d", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return 0\n        max_A_plus_i = max(A[0], A[1]+1)\n        max_score = A[0] + A[1] - 1\n        for i in range(2, len(A)):\n            max_score = max(max_score, max_A_plus_i + A[i] - i)\n            max_A_plus_i = max(max_A_plus_i, A[i] + i)\n            \n            \n            \n        return max_score", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        res = 0\n        keep = (A[0], 0)\n        for j in range(1, len(A)):\n            res = max(res, keep[0] + A[j] + keep[1] - j)\n            if A[j] >= keep[0] or keep[0] - A[j] < j - keep[1]:\n                keep = (A[j], j)\n            # print(j, keep, res)\n        return res", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        cur=res=0\n        for i,a in enumerate(A):\n            print(res, cur)\n            res = max(res,  cur + a - i)\n            cur = max(cur, a + i)\n        return res", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        st = []\n        ret = 0\n        for i, s in enumerate(A):\n            while len(st) > 0 and  st[-1][0] < s:\n                s_j, j = st.pop()\n                ret = max(ret, s+s_j-abs(i-j))\n            if len(st) > 0:\n                ret = max(ret, s+st[-1][0]-abs(st[-1][1]-i))\n            \n            st.append((s, i))\n        return ret", "#\n# @lc app=leetcode id=1014 lang=python3\n#\n# [1014] Best Sightseeing Pair\n#\n# https://leetcode.com/problems/best-sightseeing-pair/description/\n#\n# algorithms\n# Medium (50.18%)\n# Likes:    266\n# Dislikes: 15\n# Total Accepted:    10.6K\n# Total Submissions: 21K\n# Testcase Example:  '[8,1,5,2,6]'\n#\n# Given an array A of positive integers, A[i] represents the value of the i-th\n# sightseeing spot, and two\u00a0sightseeing spots i and j\u00a0have distance j - i\n# between them.\n# \n# The score\u00a0of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i\u00a0- j) :\n# the sum of the values of the sightseeing spots, minus the distance between\n# them.\n# \n# Return the maximum score of a pair of sightseeing spots.\n# \n# \n# \n# Example 1:\n# \n# \n# Input: [8,1,5,2,6]\n# Output: 11\n# Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\n# \n# \n# \n# \n# Note:\n# \n# \n# 2 <= A.length <= 50000\n# 1 <= A[i] <= 1000\n# \n#\nclass Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        # Count the current best score in all previous sightseeing spot.\n        # Note that, as we go further, the score of previous spot decrement.\n        cur = res = 0\n        for a in A:\n            res = max(res, cur + a)\n            cur = max(cur, a) - 1\n        return res\n        \n\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        maxa = [x+i for i, x in enumerate(A)]\n        for i in range(1, len(maxa)): maxa[i] = max(maxa[i], maxa[i-1])\n        \n        res = float('-inf')\n        for j in range(1, len(A)):\n            res = max(res, A[j] - j + maxa[j-1])\n        \n        return res\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        m = -float('inf')\n        res = -float('inf')\n        for i in range(len(A)-1,-1,-1):\n            res = max(res,A[i]+i+m)\n            m = max(m,A[i]-i)\n        return res\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        N = len(A)\n        max_ = 0\n        prev = A[-1]-N+1\n        for i in range(N-2,-1,-1):\n            max_ = max(max_, prev + A[i]+i)\n            prev = max(prev, A[i]-i)\n        return max_", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        res = float('-inf')\n        maxleft = float('-inf')\n        for i, a in enumerate(A):\n            res = max(res, maxleft + a - i)\n            maxleft = max(maxleft, a + i)\n        return res", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        \n        # generate a vector\n        #A_left = [a + i for i, a in enumerate(A)]\n        #A_right = [a - i for i, a in enumerate(A)]\n        _max_left = A[0]\n        _max = 0\n        for j in range(1, len(A)):\n            _max = max(_max_left + A[j] - j, _max)\n            _max_left = max(_max_left, A[j] + j)\n        return _max", "class Solution:\n    def maxScoreSightseeingPair(self, a: List[int]) -> int:\n        d=[]\n        \n        for i in range(len(a)-1,-1,-1):\n            if i!=0:\n                d.append([a[i]-i,i])\n        d.sort()\n        s=0\n        for i in range(0,len(a)-1):\n            while d[-1][1]<=i:\n                d.pop()\n        \n            s=max(s,a[i]+i+d[-1][0])\n        return s\n            \n            \n        \n            \n        \n        \n        \n        \n            \n", "class Solution:\n    def maxScoreSightseeingPair(self, a: List[int]) -> int:\n        d=[]\n        \n        for i in range(len(a)-1,-1,-1):\n            if i!=0:\n                d.append([a[i]-i,i])\n        d.sort()\n        s=0\n        for i in range(0,len(a)):\n            while d!=[] and d[-1][1]<=i:\n                d.pop()\n            if d==[]:\n                break\n            s=max(s,a[i]+i+d[-1][0])\n        return s\n            \n            \n        \n            \n        \n        \n        \n        \n            \n", "import heapq\nimport math\n\nclass Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        h = []\n        ans = -math.inf\n        \n        for i,a in enumerate(A):\n            if h:\n                ans = max(ans, a-i-h[0])\n            heapq.heappush(h, -i-a)\n        return ans\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        prev=ans=float('-inf')\n        for i in range(1,len(A)):\n            prev=max(prev,A[i-1]+i-1)\n            ans=max(ans,prev+A[i]-i)\n        return ans", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        \n        # generate a vector\n        A_left = [a + i for i, a in enumerate(A)]\n        A_right = [a - i for i, a in enumerate(A)]\n        _max_left = A_left[0]\n        _max = 0\n        for j in range(1, len(A_right)):\n            _max = max(_max_left + A_right[j], _max)\n            _max_left = max(_max_left, A_left[j])\n        return _max", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        left = 0\n        res = 0\n        max_pre = 0\n        curr_res = 0\n        for right in range(1, len(A)):\n            max_pre = max(max_pre, A[right-1] + (right-1))\n            curr_res = max_pre + A[right] - right\n            res = max(res, curr_res)\n        return res", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        res, leftmax, cnt = 0, 0, 0\n        for num in A:\n            res = max(res, num + leftmax - cnt)\n            if num > leftmax - cnt:\n                leftmax = num\n                cnt = 0\n            cnt += 1\n        return res", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        ans = 0\n        best = A[0]-1\n        for i in range(1, len(A)):\n            ans = max(ans, A[i]+best)\n            best = max(best-1, A[i]-1)\n        return ans", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        best = 0\n        i = 0\n        for j in range(1, len(A)):\n            s1 = A[i] + A[j] + i - j\n            s2 = A[j] + A[j-1] + j - 1 - j\n            if s2 > s1:\n                i = j - 1\n            best = max(best, s1, s2) \n        return best            ", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n#         maxScore = 0 \n\n#         for i in range(0,len(A)):\n#             for j in range(i+1,len(A)):\n#                 val = A[i] + A[j] + i - j \n#                 if val > maxScore:\n#                     maxScore = val \n#         return maxScore\n\n        K    = A[0]\n        best = float('-inf')\n        for j in range(1,len(A)):\n            x    = A[j]\n            best = max(best, K + x - j )\n            K    = max(K   , x + j     )\n        return best", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        max_score = 0\n        scores = [0] *len(A)\n        for i in range (1,len(A)):\n            if i == 1:\n                scores[i] = A[0] - (len(A) - (i - 1))\n            else:\n                scores[i] = max(A[i - 1] - (len(A) - (i - 1)),scores[i-1])\n        \n        for j in range (1,len(A)):\n            adj_score = (len(A) - j) + scores[j] + A[j]\n            if adj_score > max_score:\n                max_score = adj_score\n        return max_score\n            \n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        m = p = 0\n        for i, n in enumerate(A):\n            m = max(m, p + n - i)\n            p = max(p, n + i)\n        return m", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        left = [i+a for i,a in enumerate(A)]\n        right = [b-j for j, b in enumerate(A)]\n        for i in range(1, len(left)):\n            left[i] = max(left[i], left[i-1])\n        for i in range(len(right)-1)[::-1]:\n            right[i] = max(right[i], right[i+1])\n        return max(l+r for l, r in zip(left[:-1], right[1:]))\n", "import heapq\nclass Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        return solution(A)\n\n        \ndef solution(A):\n    right_heap = [(-(a - i), a, i) for i, a in enumerate(A)]\n    \n    heapq.heapify(right_heap)\n    current_max = -1    \n    \n    for i in range(len(A) - 1):\n        right_max_score = -1\n        while len(right_heap) > 0 and right_heap[0][2] <= i:\n            heapq.heappop(right_heap)\n        el = right_heap[0]\n\n        right_max_score = A[i] + el[1] - abs(el[2] - i)\n        current_max = max(right_max_score, current_max)\n\n    return current_max", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        cur = res = 0\n        for a in A:\n            res = max(res, cur + a)\n            cur = max(cur, a) - 1\n        return res\n    \n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        return self.with_sort(A)\n    \n    def with_sort(self, A):\n        n = len(A)\n        max_list = [(i[0] + i[1], i[0]) for i in sorted(enumerate(A), \n                                                        key=lambda x:-(x[1] + x[0] * 1.000000001))]\n        idx = 0\n        max_s = 0\n        for j in range(n-1, -1, -1):\n            s = A[j] - j\n            while idx < n and max_list[idx][1] >= j:\n                idx += 1\n            if idx < n:\n                s += max_list[idx][0]\n            max_s = max(max_s, s)\n        return max_s\n        \n        \n        \n    def count_sort(self, A):\n        C = [[] for _ in range(51001)]\n        for i, a in enumerate(A):\n            C[a + i].append((a+i, i))\n        res = []\n        k = 0\n        for c in C:\n            if len(c) > 0:\n                res.extend(c)\n        return list(reversed(res))\n        \n        \n    def brute_force(self, A):\n        max_score = 0\n        n = len(A)\n        for i in range(n):\n            for j in range(i+1, n):\n                s = A[i] + A[j] + i - j\n                if s > max_score:\n                    max_score = s\n        return max_score\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        if len(A) < 2:\n            return -1\n        \n        best_so_far = A[0] + 0\n        res = 0\n        for j in range(1, len(A)):\n            res = max(res, best_so_far + A[j] - j)\n            if best_so_far < A[j] + j:\n                best_so_far = A[j] + j\n        \n        return res", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        res = imax = 0\n        for i, a in enumerate(A):\n            res = max(res, imax + a - i)\n            imax = max(imax, a + i)\n        return res", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return -float('inf')\n\n        candidate = max(A[0], A[1]+1)\n        res = A[0]+A[1]-1 \n\n        for i in range(2, len(A)):\n            res = max(res, candidate+A[i]-i)\n            candidate = max(candidate, A[i]+i)\n        return res            ", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        import sys\n        val = A[0] + 0\n        ans = -sys.maxsize\n        A.pop(0)\n        for i,num in enumerate(A):\n            ans = max(ans,val+A[i] - i - 1)\n            val = max(val,A[i]+i+1)\n        return ans\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        temp=A[0]\n        ans=-999\n        for i in range(1, len(A)):\n            ans=max(ans, temp+A[i]-i)\n            temp=max(temp, A[i]+i)\n        return ans", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        largest = 0\n        i = 0\n        while(i<len(A)-1):\n            largest = max(largest,A[i]+A[i+1]-1)\n            if A[i]>A[i+1]:\n                A[i],A[i+1]=A[i+1]+1,A[i]-1\n            i += 1\n        return largest\n        \n            \n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        i = 0\n        res = 0\n        for j in range(1, len(A)):\n            ti = A[i] + i\n            res = max(A[j] - j + ti, res)\n            if A[j] + j > ti:\n                i = j\n        return res\n", "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        # we have to find A[i] + i + A[j] - j\n        # we will fix max(A[i] + i) and find for diff values of A[j] - j\n        if len(A) == 0 : return 0\n        maxI = A[0] + 0\n        res = 0\n        for j in range(1,len(A)):\n            res = max(res,maxI+A[j]-j)\n            maxI = max(maxI,A[j]+j)\n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        # for i in range(len(A)-1):\n        #     for j in range(i+1,len(A)):\n        #         score = max(score,A[i] + A[j] + i - j)\n        # return score\n"]
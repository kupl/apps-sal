["def sub(a, s):\n    pa = 0\n    ps = 0\n    while pa < len(a) and ps < len(s):\n        if a[pa] == s[ps]:\n            ps += 1\n            pa += 1\n        else:\n            pa += 1\n\n    return ps == len(s)\n\ndef subword(t, ord_ar, n):\n    t_copy = []\n    for i in range(len(ord_ar)):\n        if ord_ar[i] >= n:\n            t_copy.append(t[i])\n    return t_copy\n\ndef check(t, p, ord_ar, n):\n    s = subword(t, ord_ar, n)\n    return sub(s, p)\n\ndef bin_s(l, r, f):\n    while r > l + 1:\n        m = (r + l) // 2\n        if f(m):\n            l = m\n        else:\n            r = m\n    return l\n\n\n\ndef main():\n    t = input().strip()\n    p = input().strip()\n    ord_ar = [0]*len(t)\n    \n    seq = list(map(int, input().strip().split()))\n    for i,x in enumerate(seq):\n        ord_ar[x-1] = i\n\n    ans = bin_s(0, len(t), lambda n: check(t, p, ord_ar, n))\n    print(ans)\n\nmain()\n", "def possible(t,p,a,n):\n    s = ''\n    check = [True]*len(t)\n    for i in range(n):\n        check[a[i]] = False\n    for i in range(len(check)):\n        if check[i]:\n            s += t[i]\n    \n    m = len(s)\n    lp = len(p)\n    c = 0\n    for i in range(m):\n        if s[i] == p[c]:\n            c += 1\n        if c == lp:\n            return True\n    return False        \n    \nt = input()\np = input()\na = list(map(int,input().split()))\nfor i in range(len(a)):\n    a[i] -= 1\n\nlow = 0\nhigh = len(a)\nans = 0\nwhile low <= high:\n    mid = (low+high)//2\n    if possible(t,p,a,mid):\n        ans = mid\n        low = mid+1\n    else:\n        high = mid-1\nprint(ans)        ", "   \nt = input()\np = input()\na = [i-1 for i in list(map(int,input().split()))]\nmin1 = 0\nmax1 = len(t)\nwhile(max1-min1)>1:\n    med = min1+(max1-min1)//2\n    j=0\n    d=list(t)\n    for i in range(med):\n        d[a[i]]=''\n    for i in range(len(t)):\n        if d[i]==p[j]:\n            j+=1\n            if j==len(p):\n                min1=med\n                break\n    if j!=len(p):\n        max1=med\nprint(min1)\n", "\ndef main():\n  a_string = input()\n  b_string = input()\n  moves = [int(x) for x in input().split()]\n  index_of_move = {}\n  lenb = len(b_string)\n\n  for index, elem in enumerate(moves):\n    index_of_move[elem] = index + 1\n\n  l = 0\n  r = len(moves) - 1\n  while l < r:\n    middle = int((l + r + 1) / 2)\n    bi = 0\n    i = 0\n\n    for index, elem in enumerate(a_string):\n      #if (index + 1) in moves[:(middle + 1)]:\n      #  continue\n      if index_of_move[index + 1] <= middle + 1:\n        continue\n      if elem is b_string[bi]:\n        bi += 1\n      if bi >= lenb:\n        break\n\n    if bi >= lenb:\n      l = middle\n    else:\n      r = middle - 1\n\n  if l is 0 and r is 0:\n    bi = 0\n    for index, elem in enumerate(a_string):\n      if index_of_move[index + 1] <= 1:\n        continue\n      if elem is b_string[bi]:\n        bi += 1\n      if bi >= lenb:\n        break\n    if bi >= lenb:\n      print(1)\n    else:\n      print(0)\n  else:\n    print(l + 1)\n\ndef __starting_point():\n  main()\n\n__starting_point()", "#!/usr/bin/env python3\n# -*- coding = 'utf-8' -*-\n\nt = input()\np = input()\na = list(map(int, input().split()))\n\ndef can(s, p):\n    i = 0\n    for ch in s:\n        if ch == p[i]:\n            i += 1\n            if i == len(p):\n                return True\n\n    return False\n\ndef binary_search(l, r):\n    \n    while(l < r - 1):\n        s = list(t)\n        mid = (l + r)//2\n\n        for index in range(mid):\n            s[a[index] - 1] = ' '\n            \n        ok = False\n        i = 0\n        for ch in s:\n            if ch == p[i]:\n                i += 1\n                if i == len(p):\n                    ok = True\n                    break\n        if ok:\n            l = mid\n        else:\n            r = mid\n\n    return l\n\nprint(binary_search(0, len(a) + 1))\n", "a=input()\nb=input()\nc=[i-1 for i in list(map(int,input().split()))]\nl=0\nr=len(a)\nwhile r-l>1:\n    m=l+(r-l)//2\n    t=list(a)\n    j=0\n    for i in range(m):t[c[i]]=''\n    for i in range(len(a)):\n        if t[i]==b[j]:\n            j+=1\n            if j==len(b):\n                l=m;break\n    if j!=len(b):r=m\nprint(l)\n", "s = list(input().strip())\nt = input().strip()\nsq = [int(a) for a in input().strip().split()]\nl = len(s)\nlt = len(t)\ndef check(x):\n    tmp = s.copy()\n    for i in range(x):\n        tmp[sq[i]-1] = '_'\n    idx = 0\n    for i in range(l):\n        if tmp[i]==t[idx]:\n            idx+=1\n            if idx==lt:\n                return True\n    return False\n\nlow = res = 0\nhigh = l\nwhile(low<=high):\n    mid = (low + high) >> 1\n    if check(mid):\n        low = mid + 1\n        res = mid\n    else:\n        high = mid - 1\nprint(res)", "s = list(input().strip())\nt = input().strip()\nsq = [int(a) for a in input().strip().split()]\nl = len(s)\nlt = len(t)\ndef check(x):\n    tmp = s.copy()\n    for i in range(x):\n        tmp[sq[i]-1] = '_'\n    idx = 0\n    for i in range(l):\n        if tmp[i]==t[idx]:\n            idx+=1\n            if idx==lt:\n                return True\n    return False\n\nlow = 0\nhigh = l\nwhile(low<=high):\n    mid = (low + high) >> 1\n    if check(mid):\n        low = mid + 1\n    else:\n        high = mid - 1\nprint(high)", "def is_subsequence(a, b, idx, top):\n    i = 0\n    for j, c in enumerate(a):\n        if c == b[i] and idx[j+1] > top:\n            i += 1\n        if i == len(b):\n            return True\n    return False\n\n\na = input()\nb = input()\nr = list(map(int, input().split()))\nidx = [0 for _ in range(len(r)+1)]\nfor i in range(len(r)):\n    idx[r[i]] = i\n\nlo = -1\nhi = len(a)\nwhile hi - lo > 1:\n    mi = (lo + hi) // 2\n    if is_subsequence(a, b, idx, mi):\n        lo = mi\n    else:\n        hi = mi\n\nprint(lo+1)\n\n#~ for i in range(-1, len(r)+1):\n    #~ print(is_subsequence(a, b, idx, i))\n\n", "import sys\n\n# listindexes is sorted\ndef removeat(string, indexes):\n\n    return [c for i, c in enumerate(string) if i not in indexes]\n\ndef contains(string, what):\n\n    if not len(what):\n        return True\n    if not len(string):\n        return False\n\n    checked = 0\n    for c in string:\n        if what[checked] == c:\n            checked += 1\n            if checked == len(what):\n                break\n\n    return checked == len(what)\n\nstring = list(input())\nwhat = list(input())\nindexes = [i-1 for i in map(int, input().split())]\n\nfirst = 0\nlast = len(indexes)-1\n\nwhile first<last:\n\n    midpoint = first + (last - first)//2 + (last - first)%2\n    \n    if contains(removeat(string, set(indexes[:midpoint])), what):\n        first = midpoint\n    else:\n        last = midpoint-1\n\nprint(first)\n\n", "import heapq\nfrom bisect import bisect_left, bisect_right\nfrom itertools import accumulate\n\ndef is_substr(fw, tw, seq):\n    i, j = 0, 0\n    while i < len(fw) and j < len(tw):\n        if i in seq:\n            i += 1\n        elif fw[i] == tw[j]:\n            i, j = i + 1, j + 1\n        else:\n            i += 1\n    return j == len(tw)\n\nR = lambda: map(int, input().split())\nfw, tw = input(), input()\nseq = [i - 1 for i in list(R())]\nl, r = 0, len(seq) - 1\nm, res = 0, 0\nwhile l <= r:\n    m = (l + r) // 2\n    if is_substr(fw, tw, set(seq[:m])):\n        res = max(res, m)\n        l = m + 1\n    else:\n        r = m - 1\nprint(res)", "def subseq (s,b):\n  h = iter(b)\n  return all(any(l == ch for l in h) for ch in s)\n\nt = input()\np = input()\nnum = [int(x) for x in input().split()]\nst = []\nl = 0\nr = len(num)\nans = r+1\nwhile (l <= r):\n  mid = (l+r)//2\n  st = list(t)\n  c = num[:mid]\n  for i in c:\n    st[i-1] = ''\n  if subseq(p,''.join(st)):\n    ans = mid\n    l = mid + 1\n  else:\n    r = mid - 1\nprint(ans)", "def main():\n    s, w = ['', *input()], input()\n    l = list(map(int, input().split()))\n    lo, hi = 0, len(s) - len(w)\n    while lo < hi:\n        mid, t = (lo + hi) // 2, s[:]\n        for i in l[:mid]:\n            t[i] = ''\n        try:\n            i = 1\n            for c in w:\n                while c != t[i]:\n                    i += 1\n                i += 1\n        except IndexError:\n            hi = mid\n        else:\n            lo = mid + 1\n    print(lo - 1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "a=input()\nb=input()\nc=[i-1 for i in list(map(int,input().split()))]\nl=0\nr=len(a)\nwhile r-l>1:\n    m=l+(r-l)//2\n    t=list(a)\n    j=0\n    for i in range(m):t[c[i]]=''\n    for i in range(len(a)):\n        if t[i]==b[j]:\n            j+=1\n            if j==len(b):\n                l=m;break\n    if j!=len(b):r=m\nprint(l)\n\n\n\n\n# Made By Mostafa_Khaled\n", "t = input()\np = input()\n\na = list(map(int, input().strip().split()))\na = [ x - 1 for x in a]\nn = len(t)\nm = len(p)\n\n\nlo = 0\nhi = n - 1\n\nwhile lo < hi:\n    mid = (lo + hi) >> 1\n    \n    temp = list(t)\n    for x in a[ :mid+1]:\n        temp[x] = '_'\n    \n    ptr, curr = 0, 0\n    while ptr < n and curr < m:\n        while ptr < n and temp[ptr] != p[curr]:\n            ptr += 1\n        if ptr < n:\n            ptr += 1\n            curr += 1\n    \n    if curr == m:\n        lo = mid + 1\n    else:\n        hi = mid\n\nprint(lo)\n", "t = list(input())\np = list(input())\n\n\ndef has_sub(temp):\n    idx = 0\n    for c in temp:\n        if c == p[idx]:\n            idx += 1\n        if idx == len(p):\n            return True\n\n    return False\n\n\narr = list(map(int, input().split()))\n\nleft = 0\nright = len(arr) - 1\n\nwhile left < right:\n    mid = (left + right + 1) // 2\n    temp = t[:]\n\n    for idx in range(mid):\n        temp[arr[idx] - 1] = '0'\n\n    if has_sub(temp):\n        left = mid\n    else:\n        right = mid - 1\n\nprint(right)\n", "t = input()\np = input()\nai = list(map(int,input().split()))\nn = len(ai)\nti = [[t[i],1] for i in range(n)]\nfor i in range(n):\n    ai[i] -= 1\n\nnum2 = 1\n\ndef check(num):\n    nonlocal num2\n    num2 -= 1\n    for i in range(num):\n        ti[ai[i]][1] = num2\n    num3 = 0\n    for i in ti:\n        if i[1] == num2:\n            continue\n        if i[0] == p[num3]:\n            num3 += 1\n            if num3 == len(p):\n                return True\n    return False\n\nhigh = n\nlow = 0\nmid = (high + low) // 2\nwhile high >= low:\n    if check(mid):\n        low = mid + 1\n    else:\n        high = mid - 1\n    mid = (high + low) // 2\n\nprint(mid)\n", "#print('HARE KRISHNA')\nt=input()\np=input()\nblock=[int(i)-1 for i in input().split()]\nind={}\nfor i in range(len(block)):\n    ind[block[i]]=i \ndef is_part_and_parcel(s1,s2,mid):\n    n=len(s2)\n    m=len(s1)\n    i=0 \n    c=0 \n    j=0 \n    while i<n and j<m:\n        if ind[j]<mid:\n            j+=1 \n            continue \n        if s2[i]==s1[j]:\n            i+=1\n            j+=1 \n            c+=1 \n        else:\n            j+=1 \n    return c==n \nn=len(t)\nm=len(p)\nlo= 0 \nhi=len(block)-1 \nwhile lo<=hi:\n    mi=(lo+hi)>>1 \n    if is_part_and_parcel(t,p,mi):\n        ans=mi \n        lo=mi+1 \n    else:\n        hi=mi-1 \nprint(ans)", "def is_obtained(p, t, K):\n    i = 0\n    for ch in p:\n        i = t.find(ch, i) + 1\n        if i == 0:\n            return False\n        while i in K:\n            i = t.find(ch, i) + 1\n            if i == 0:\n                return False\n    return True\n\nI = input\n\nt, p, A = I(), I(), list(map(int, I().split()))\nL, R = 0, len(A) - 1\n\nwhile L < R:\n    x = (L + R + 1) // 2\n    if is_obtained(p, t, set(A[:x])):\n        L = x\n    else:\n        R = x - 1\n\nprint(L)", "s1 = input()\ns2 = input()\nrs = list(map(int, input().split()))\n\ndef is_in(big, little):\n    i, j = 0, 0\n    matched = 0\n    while i < len(big) and j < len(little):\n        if big[i] == little[j]:\n            matched += 1\n            i +=1\n            j += 1\n        else:\n            i += 1\n    if matched < len(little):\n        return False\n    return True\n\ndef gen_st(mid):\n    nonlocal s1, s2, rs\n    cs = set(rs[:mid])\n    n = []\n    for i in range(len(s1)):\n        if i+1 in cs:\n            continue\n        n.append(s1[i])\n    #print(''.join(n), s2)\n    return is_in(''.join(n), s2)\n\nstart = 0\nend = len(rs)\nweird = False\n#print(gen_st(4))\nwhile start < end:\n    #print(start, end)\n    mid = (start+end)//2\n    if gen_st(mid):\n        start = mid\n        if start == end-1:\n            weird = True\n            if gen_st(end):\n                print(end)\n                break\n            else:\n                print(start)\n                break\n    else:\n        end = mid - 1\n    if not weird and start == end:\n        print(start)\n\n", "def check(x):\n    temp=[]\n    for i in t:\n        temp.append(i)\n    for i in range(x):\n        temp[a[i]-1]=''\n    #print(''.join(temp))\n    l=0;r=0;c=0\n    while r<len(s) and l<len(t):\n        if s[r]==temp[l]:\n            r+=1;c+=1\n        l+=1\n    #print(c)\n    return c==len(s)\nt=input()\ns=input()\na=list(map(int,input().split()))\nlo=0;hi=len(a)\nwhile lo<hi-1:\n    mid=lo+(hi-lo)//2\n    #print(lo,hi,mid)\n    if check(mid):\n        lo=mid\n    else:\n        hi=mid\n    \nprint(lo)\n", "s = input()\nt = input()\na = list(map(int, input().split()))\n\n\ndef exist(m):\n    vis = [0] * len(s)\n    for i in range(m):\n        vis[a[i] - 1] = 1\n    j = 0\n    for i in range(len(s)):\n        if vis[i] == 0:\n            if s[i] == t[j]:\n                j += 1\n            if j == len(t):\n                return 1\n    return 0\n\n\nl, r = 0, len(s)\nwhile l < r:\n    mid = (l + r + 1) // 2\n    if exist(mid):\n        l = mid\n    else:\n        r = mid - 1\n\nprint(l)\n", "a = input()\nb = input()\np = list(map(int,input().split()))\n\nn = len(p)\nh = [0]*n\nfor i in range(n):\n    p[i]-=1\n    h[p[i]] = i\n\ndef check(s1,s2,g):\n    m1 = len(s1)\n    m2 = len(s2)\n    j = 0\n    i = 0\n      \n    while j<m1 and i<m2: \n        if s1[j] == s2[i] and h[i]>g:     \n            j = j+1    \n        i = i + 1\n    return j==m1\n\nl = -1\nr = n-1\n\nwhile l<r:\n    md = (l+r+1)//2\n    # print(md,p[md],h[p[md]])\n    if check(b,a,h[p[md]]):\n        # print(md,p[md],h[p[md]])\n        l = md\n    else:\n        r = md-1\n\nprint(l+1)", "s = list(input())\nt = list(input())\narr = list(x-1 for x in map(int, input().split()))\nn, m = len(arr), len(t)\n\ndef binary_search():\n    f, e = 0, n\n    while f <= e:\n        mid = f + e >> 1\n        vis = [0] * n\n        for i in range(mid):\n            vis[arr[i]] = 1\n        idx, found = 0, 0\n        for i in range(n):\n            if not vis[i] and s[i] == t[idx]:\n                idx += 1\n            if idx == m:\n                found = 1\n                break\n        if found:\n            f = mid + 1\n        else:\n            e = mid - 1\n    return f - 1\n\nprint(binary_search())\n"]
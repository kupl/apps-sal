["class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        def digit_representation(s):\n            ans = 0\n            for c in s:\n                ans |= 1<<(ord(c)-ord('a'))\n            return ans\n        \n        A = sorted([(len(s), digit_representation(s)) for s in set(arr) if len(set(s))==len(s)], reverse=True)\n        if not A: return 0\n        R = [sum(t[0] for t in A)]\n        for i in range(1, len(A)):\n            R.append(R[-1] - A[i][0])\n        self.ans = A[0][0]\n        \n        def helper(i, b, k):\n            if i == len(A):\n                self.ans = max(self.ans, k)\n            elif k + R[i] > self.ans:\n                if not (b & A[i][1]):\n                    helper(i+1, b | A[i][1], k+A[i][0])\n                helper(i+1, b, k)\n            \n        helper(0, 0, 0); return self.ans", "from typing import List\n\nclass Solution:\n    def helper(self, current, arr, index, chars, remaining):\n        if index == len(arr):\n            return current\n        maxLength = current\n        for i in range(index, len(arr), 1):\n            remaining -= len(arr[i])\n            if current + len(arr[i]) +  remaining <= maxLength:\n                continue\n            isGood = True\n            # print(arr[i])\n            for c in arr[i]:\n                if c in chars:\n                    isGood = False\n                    break\n            if isGood:\n                # print(arr[i], \\\"is good\\\")\n                for c in arr[i]:\n                    chars.add(c)\n                maxLength = max(self.helper(current + len(arr[i]), arr, i+1, chars, remaining), maxLength)\n                for c in arr[i]:\n                    chars.remove(c)\n            # else:\n                # print(arr[i], \\\"is bad\\\")\n        return maxLength\n            \n\n    def maxLength(self, arr: List[str]) -> int:\n        arr = [a for a in arr if len(a) == len(set(a))]\n        remaining = sum([len(a) for a in arr])\n        return self.helper(0, arr, 0, set(), remaining)\n\n# print(Solution().maxLength([\\\"un\\\",\\\"iq\\\",\\\"ue\\\"]))\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        uniqELements = ['']\n        maximum = 0\n        for i in range(len(arr)):\n            sz = len(uniqELements)\n            for j in range(sz):\n                x=arr[i]+uniqELements[j]\n                if (len(x)==len(set(x))):\n                    uniqELements.append(x)\n                    maximum = max(maximum,len(x))\n        #print(uniqELements)\n        return maximum", "class Solution:   \n    \n    def maxLength(self, arr: List[str]) -> int:\n        arr_sets = [set(x) for x in arr]\n       \n        def buildSet(bitlist):\n            output = set()\n            for i, bit in enumerate(bitlist):\n                if bit:\n                    output = output.union(arr_sets[i])\n            return output\n        \n        def recurse(bitlist, index):\n            # print(\\\"Bitlist: {a}, Index: {b}\\\".format(a=bitlist, b=index))\n            if index == len(arr):\n                # print(\\\"returning length\\\")\n                return len(buildSet(bitlist))\n            \n            new_bitlist = bitlist[:]\n            new_bitlist[index] = 0\n            # print(\\\"recursing with not included\\\")\n            not_included = recurse(new_bitlist, index+1)\n            \n            if len(arr_sets[index]) != len(arr[index]) or buildSet(bitlist).intersection(arr_sets[index]):\n                return not_included\n            else:\n                # print(\\\"return max of both\\\")\n                \n                new_bitlist[index] = 1\n                return max(not_included, recurse(new_bitlist, index+1))\n        \n        return recurse([0 for _ in arr], 0)\n            \n            \n            \n        # [0, 1, 1, 0]\n", "class Solution:\n    def get_max_length(self, sets, idx, cur_set):\n        if idx == len(sets): return len(cur_set)\n        m = 0\n        for i in range(idx, len(sets)):\n            if not cur_set & sets[i]:\n                res = self.get_max_length(sets, i + 1, cur_set.union(sets[i]))\n            else:\n                res = self.get_max_length(sets, i + 1, cur_set)\n            m = max(m, res)\n        return m\n        \n    \n    def maxLength(self, arr: List[str]) -> int:\n        sets = []\n        for i, s in enumerate(arr):\n            t = set()\n            for ch in s:\n                if ch in t:\n                    break\n                else:\n                    t.add(ch)\n            else:\n                sets.append(t)\n        print(sets)\n        return self.get_max_length(sets, 0, set())\n", "class Solution:\n    def get_max_length(self, sets, idx, cur_set):\n        if idx == len(sets): return len(cur_set)\n        m = 0\n        for i in range(idx, len(sets)):\n            if not cur_set & sets[i]:\n                res = self.get_max_length(sets, i + 1, cur_set.union(sets[i]))\n            else:\n                res = self.get_max_length(sets, i + 1, cur_set)\n            m = max(m, res)\n        return m\n        \n    \n    def maxLength(self, arr: List[str]) -> int:\n        sets = []\n        for i, s in enumerate(arr):\n            t = set()\n            for ch in s:\n                if ch in t:\n                    break\n                else:\n                    t.add(ch)\n            else:\n                sets.append(t)\n\n        return self.get_max_length(sets, 0, set())\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        arr = [set(x) for x in arr if len(x) == len(set(x))]\n        mx = 0\n        \n        def util(start, cur):\n            nonlocal mx\n            if start == len(arr):\n                mx = max(mx, len(cur))\n            for i in range(start, len(arr)):\n                if cur & arr[i]: continue\n                cur |= arr[i]\n                util(i+1, cur)\n                cur ^= arr[i]\n            mx = max(mx, len(cur))\n        \n        util(0, set())\n        return mx", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        res = 0\n        def dfs(n, s, l, cur):\n            nonlocal res\n            if n == l:\n                if len(set(cur)) == len(cur):\n                    res = max(res, len(cur))\n                return\n            for i in range(s, len(arr)):\n                new_cur = cur + arr[i]\n                if len(set(cur)) != len(cur):\n                    return\n                dfs(n, i+1, l+1, new_cur)\n        for i in range(len(arr)+1):\n            dfs(i, 0, 0, '')\n        return res\n", "class Solution:\n    def recurse(self, arr, cur):\n        \n        for i, x in enumerate(arr):\n            if cur.intersection(x):\n                continue\n            nxt = cur.union(x)\n            nxt_key = ''.join(sorted(nxt))\n            if nxt_key not in self.visited:\n                self.visited.add(nxt_key)\n                self.maxlen = max(self.maxlen, len(nxt))\n                self.recurse(arr[:i] + arr[i+1:], nxt)\n        \n    \n    def maxLength(self, arr: List[str]) -> int:\n        \n        # setify\n        arr = [set(x) for x in arr if len(set(x)) == len(x)]\n        \n        self.maxlen = 0\n        self.visited = set()\n        self.recurse(arr, set())\n            \n        return self.maxlen", "class Solution:\n    \n    def is_unique(self, s):\n        return len(set(s)) == len(s)\n    \n    def maxLength(self, arr: List[str]) -> int:\n        \n        dct= {}\n        maxVal = 0\n        \n        for i in range(0, len(arr)):\n            v = frozenset(arr[i])\n            if self.is_unique(arr[i]):\n                maxVal = max(maxVal, len(v))\n                \n            for j in range(i+1, len(arr)):\n                t = arr[i] + arr[j]\n                val = frozenset(t)\n                \n                if self.is_unique(t):\n                    # print(t)\n                    arr.append(t)\n                    maxVal = max(maxVal, len(val))\n        # print(dct)\n        return maxVal", "class Solution:   \n    \n    def maxLength(self, arr: List[str]) -> int:\n       \n        #pre strip dupes \n        arr_sets = [set(x) for x in arr]\n       \n        def buildSet(bitlist):\n            output = set()\n            for i, bit in enumerate(bitlist):\n                if bit:\n                    output = output.union(arr_sets[i])\n            return output\n        \n        #dfs\n        #       incl\n        # not inc    incl\n        \n        \n        def recurse(bitlist, index):\n            if index == len(arr):\n                return len(buildSet(bitlist))\n            \n            new_bitlist = bitlist[:]\n            \n            #index is our depth of the tree\n            new_bitlist[index] = 0\n            not_included = recurse(new_bitlist, index+1)\n            \n            if len(arr_sets[index]) != len(arr[index]) or buildSet(bitlist).intersection(arr_sets[index]):\n                return not_included\n            else:\n                \n                new_bitlist[index] = 1\n                return max(not_included, recurse(new_bitlist, index+1))\n        \n        return recurse([0 for _ in arr], 0)", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        #array with all possible unique string combinations so far\n\n        possible_strings = ['']\n        maximum = 0\n        for i in range(len(arr)):\n            temp_len = len(possible_strings)\n            for j in range(temp_len):\n                #trying combination\n                x = arr[i] + possible_strings[j]\n                #string is unique\n                if (len(x)==len(set(x))):\n                    #append to possible strings\n                    possible_strings.append(x)\n                    #set max\n                    maximum = max(maximum,len(x))\n        return maximum\n\n", "from collections import Counter\nclass Solution:\n    def dfs(self, arr, cur):\n        for i, string_set in enumerate(arr):\n            if cur.intersection(string_set):\n                continue\n            nxt = cur.union(string_set)\n            nxt_key = ''.join(sorted(nxt))\n            if nxt_key not in self.visited:\n                self.visited.add(nxt_key)\n                self.ans = max(self.ans, len(nxt))\n                self.dfs(arr[:i] + arr[i:], nxt)\n\n        \n        \n    def maxLength(self, arr: List[str]) -> int:\n        \n        # N is length of arr, K is longest str item in arr\n        \n        # filter and setify O(NK) time and space\n        new_arr = []\n        for string in arr:\n            string_set = set(string)\n            if len(string_set) == len(string):\n                new_arr.append(string_set)\n        arr = new_arr\n        \n        # recursive build O(?) with visited O(?) space\n        self.visited = set()\n        self.ans = 0\n        self.dfs(arr, set())\n        return self.ans", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        filtered = []\n        \n        for string in arr:\n            seen = {}\n            good = True\n            for letter in string:\n                if letter in seen:\n                    good = False\n                else:\n                    seen[letter] = True\n                    \n            if good:\n                filtered.append(string)\n        \n        self.memo = {}\n        print(filtered)\n        return self.getLength(0, filtered, {})\n                    \n                \n    def getLength(self, current, arr, used):\n        if not arr:\n            return current\n        \n        if tuple(arr) in self.memo:\n            return self.memo[tuple(arr)]\n        \n        maxi = current\n        \n        for index in range(len(arr)):\n            string = arr[index]\n            possible = True\n            \n            for char in string:\n                if char in used:\n                    possible = False\n                    \n            if not possible:\n                continue\n                \n            for char in string:\n                used[char] = True\n                \n            result = self.getLength(current + len(string), arr[:index] + arr[index + 1:], used)\n            \n            if result > maxi:\n                maxi = result\n                \n            for char in string:\n                del used[char]\n                \n        self.memo[tuple(arr)] = maxi\n                \n        return maxi\n                    \n            \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        dp = defaultdict(lambda : set())\n        \n        def dfs(index,cur):\n            \n            if index == len(arr) or cur in dp[index]:\n                return len(cur)\n            dp[index].add(cur)\n            \n            best = len(cur)\n            \n            for x in range(index,len(arr)):\n                count = Counter(cur)\n                xCount = Counter(arr[x])\n                canTake = True\n                for k,v in xCount.items():\n                    if k in count or v > 1:\n                        canTake = False\n                if canTake:\n                    best = max(best,dfs(x+1,cur+arr[x]))\n                best = max(best,dfs(x+1,cur))\n                \n            return best\n        \n        return dfs(0,'')", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        def score(s):\n            return sum(1 << (ord(c) - ord('a')) for c in s)\n        \n        def valid(s):\n            return collections.Counter(s).most_common()[0][1] <= 1\n        arr = [s for s in arr if valid(s)]\n        s = [score(s) for s in arr]\n        \n        res = 0\n        for i in range(2**len(s)):\n            val = 0\n            cur = 0\n            for j in range(len(s)):\n                if ((1 << j) & i) == 0: continue\n                if s[j] & val: break\n                val |= s[j]\n                cur += len(arr[j])\n            else:\n                res = max(res, cur)\n        return res\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        self.out = set()\n        self.visited = set()\n        opts = []\n        for sub in arr:\n            tmp = set()\n            omit = False\n            for ch in sub:\n                if ch in tmp: \n                    omit = True\n                tmp.add(ch)\n            if not omit:\n                opts.append(tmp)\n\n            \n        self.dfs(set(),opts)\n        return len(self.out)\n    \n    \n    def dfs(self,curr,opts):\n        if tuple(sorted(curr)) in self.visited:\n            return\n        # print(self.visited)\n        self.visited.add(tuple(sorted(curr)))\n        if len(curr)>len(self.out):\n            self.out = curr\n        if not opts: return\n\n        for j,opt in enumerate(opts):\n            if not curr.intersection(opt):\n                self.dfs(curr.union(opt),opts[:j]+opts[j+1:])\n", "class Solution:\n    from collections import Counter\n    def maxLength(self, arr: List[str]) -> int:\n        st = [(None,0)]\n        l = 0\n        ind_dic = {}   # ind: dict\n        new_ind = 0\n        for i in range(len(arr)):\n            ind_dic[i] = Counter(arr[i])\n        while st:\n            #print(st)\n            sub,ind = st.pop(0)\n            if sub: l = max(l,len(sub))\n            if ind >= len(arr): continue\n            if not sub: # first word\n                st.append((None,ind + 1))\n                if len(arr[ind]) == len(set(arr[ind])): st.append((arr[ind],ind+1))\n            else: \n                cur_dic = Counter(sub)\n                #print(cur_dic.keys())\n                #print(ind_dic[ind].keys())\n                #print(set(cur_dic.keys()).intersection(set(ind_dic[ind].keys())))\n                if set(cur_dic.keys()).intersection(set(ind_dic[ind].keys())):\n                    st.append((sub,ind+1))   \n                elif len(arr[ind]) > len(set(arr[ind])):\n                    st.append((sub,ind+1))\n                else: # no common char\n                    st.append((sub+arr[ind],ind + 1))\n                    st.append((sub,ind+1))    \n            new_ind = ind\n            \n        return l    ", "from typing import List\nclass Solution:\n    def uniqueLength(self,string:str)-> int:\n        for i in range(len(string)):\n            if(string.count(string[i]) > 1):\n                return -1\n        else:\n            return len(string)\n        \n    \n\n    def maxUnique(self,arr:List[str], index:int, curr_string: str, result: List[int])-> List[int]:\n    #     print(uniqueLength(curr_string))\n        if(index == len(arr)) and (self.uniqueLength(curr_string) > result[0]):\n            result[0] = len(curr_string)\n            return\n\n        if(index == len(arr)):\n            return\n        self.maxUnique(arr, index+1,curr_string, result)\n        self.maxUnique(arr, index+1, curr_string+ arr[index], result)\n        \n    def maxLength(self,arr:List[str])->int:\n        result = [0]* 1\n        self.maxUnique(arr, 0, '',result)\n\n        return result[0]\n    \n\n    \n", "class Solution:\n    def recurse(self, letters, arr, csum):\n        keys_as_str = ''.join(sorted(letters))\n        if keys_as_str not in self.visited:\n            self.visited.add(keys_as_str)\n            self.max_len = max(self.max_len, csum)\n            \n            for i, new_letters in enumerate(arr):\n                if len(new_letters.intersection(letters)) > 0:\n                    continue\n                self.recurse(new_letters.union(letters), arr[:i] + arr[i+1:], csum + len(new_letters))     \n                \n    def maxLength(self, arr: List[str]) -> int:\n        \n        # setify O(N*M)\n        new_arr = []\n        for word in arr:\n            word_set = set(word)\n            if len(word_set) == len(word):\n                new_arr.append(word_set)\n        \n        self.max_len = 0\n        self.visited = set()\n        for i, letters in enumerate(new_arr):\n            self.recurse(letters, new_arr[:i] + new_arr[i+1:], len(letters))\n        \n        return self.max_len", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        if len(arr) == 0:\n            return 0\n        currRes = []\n        for el in arr:\n            if self.isUnique(el):\n                currRes.append(el)\n                \n        for el in arr:\n            for subSeq in currRes:\n                if self.isUnique(el + subSeq):\n                    currRes.append(el+subSeq)\n        res = 0\n        for el in currRes:\n            res = max(res, len(el))\n        return res\n    \n    def isUnique(self, s):\n        return len(set(s)) == len(s)", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        return self.backtrack(set(), arr,0)\n        \n    def backtrack(self,curr, arr, index):\n        if(index >= len(arr)):\n            return len(curr)\n        max_len = 0\n        for i in range(index, len(arr)):\n            char_set = set(arr[i])\n            if(curr.intersection(char_set) == set() and len(char_set) == len(arr[i])):\n                curr = curr.union(char_set)\n                max_len = max(max_len,self.backtrack(set(curr), arr, i+1))\n                curr = curr.difference(char_set)\n            else:\n                max_len = max(max_len,self.backtrack(curr, arr, i+1))\n            \n        return max_len", "class Solution(object):\n    def maxLength(self, arr):\n        def get_max_len(arr):\n\n            # start with unique elements in given list\n            dp = [set(x) for x in arr if len(set(x)) == len(x)]\n\n            for v in arr:\n                # check for duplicates\n                if len(a := set(v)) == len(v):\n                    # concat to each valid set in list\n                    for b in dp:\n                        # skip if sets share letters\n                        if a & b:\n                            continue\n                        # combine sets, add to dp\n                        dp.append(a | b)\n            # remove initial sets because we need to concatenate\n            #for x in arr: \n            #    if (tmp := set(x)) in dp:\n            #       dp.remove(tmp)\n            # make sure we have valid answer\n            return max(len(x) for x in dp) if dp else 0\n        return get_max_len(arr)  ", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        a = [set(i) for i in arr if len(set(i))==len(i)]\n        n = len(a)\n        an = 0\n        for v in range(1, 2**n):\n            s=set()\n            i=0\n            while v>0:\n                if v&1 == 1:\n                    if s&a[i]: break\n                    s=s^a[i]\n                v=v>>1\n                i+=1\n            an = max(an,len(s))\n            \n        return an", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        return self.recursive(arr, '', 0)\n        \n    def recursive(self, arr, curr_str, pick_idx):\n        if pick_idx == len(arr):\n            table = {}\n            for ch in curr_str:\n                if ch in table:\n                    return 0\n                table[ch] = True\n            return len(curr_str)\n        \n        return max(self.recursive(arr, curr_str + arr[pick_idx], pick_idx + 1),\n                   self.recursive(arr, curr_str, pick_idx + 1))", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        def dfs(arr, path, res):\n            if self.checkUnique(path): res.append(path)\n            for i in range(len(arr)):\n                dfs(arr[i + 1:], path + arr[i], res)\n        \n        concatenated_string, res = [], 0\n        dfs(arr, '', concatenated_string)\n        # print(concatenated_string)\n        for elem in concatenated_string:\n            res = max(res, len(elem))\n        return res\n        \n        \n    \n    def checkUnique(self, string):\n        dic = dict()\n        for ch in string:\n            if ch not in dic: dic[ch] = 1\n            else: return False\n        return True\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        def isUniqueChars(s):\n            return len(set(s)) == len(s)\n        \n        \n        # Get filter out bad input.\n        arr = [set(w) for w in arr if isUniqueChars(w)]\n        results = list(arr)\n        \n        for w in arr:\n            temp = []\n            for r in results:\n                if not w.intersection(r):\n                    temp.append(w.union(r))\n            results = results + temp\n            \n        max_length = 0\n        for w in results:\n            max_length = max(max_length, len(w))\n                \n        return max_length        ", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        dp = [set()]\n        for a in arr:\n            if len(set(a)) < len(a): continue\n            a = set(a)\n            for c in dp[:]:\n                if a & c: continue\n                dp.append(a | c)\n        return max(len(a) for a in dp)\n\n        \n        return self.m", "class Solution:\n    count = 0\n    def dfs(self,arr,i,visited):\n        \n        for index in range(i+1,len(arr)):\n            visit = True\n            \n            for j in range(0,len(arr[index])):\n                if arr[index][j] in visited:\n                    for k in range(0,j):\n                        visited.remove(arr[index][k])\n                    visit=False\n                    break\n                else:\n                    visited.add(arr[index][j])\n                \n            if visit:\n                self.count = max(self.count,len(visited))\n                \n            \n            self.dfs(arr,index,visited)\n    \n            for char in arr[index]:\n                if char in visited and visit:\n                    visited.remove(char)\n            \n    def maxLength(self, arr: List[str]) -> int:\n        if len(arr)==0:\n            return 0\n        visited = set()\n        self.count =0\n        self.dfs(arr,-1,visited)\n        return self.count\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        if len(arr) == 0:\n            return 0\n        currRes = []\n        for el in arr:\n            if self.isUnique(el):\n                currRes.append(el)\n                \n        for el in arr:\n            for subSeq in currRes:\n                if self.isUnique(el + subSeq):\n                    currRes.append(el+subSeq)\n        res = 0\n        for el in currRes:\n            res = max(res, len(el))\n        return res\n    \n    def isUnique(self, s):\n        chars = set()\n        for c in s:\n            if c not in chars:\n                chars.add(c)\n            else:\n                return False\n        return True", "class Solution:\n  # I believe this problem is equivalent to SAT with weighted variables so I\n  # won't try to beat exp complexity. The state space is 2^16 configurations\n  # large so exp complexity shouldn't be a problem.\n\n  def maxLength(self, arr):\n    # From python docs: https://docs.python.org/3/library/itertools.html#itertools-recipes\n    def powerset(iterable):\n      import itertools\n      s = list(iterable)\n      return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s)+1))\n\n    result = 0\n    for subset in powerset(arr):\n      candidate = ''.join(subset)\n      if (len(candidate) > result and len(candidate) == len(set(candidate))):\n        result = len(candidate)\n    \n    return result\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        def isUnique(concatString):\n            concatSet = set()\n            for char in concatString:\n                if char in concatSet:\n                    return False\n                concatSet.add(char)\n            return True\n        \n        length = len(arr)\n        self.result = 0\n        def dfs(index, curr):\n            if isUnique(curr):\n                self.result = max(self.result, len(curr))\n            if index == length - 1:\n                return\n            for i in range(index + 1, length):\n                dfs(i, curr + arr[i])\n        \n        for i in range(length):\n            dfs(i, arr[i])\n            \n        return self.result\n        \n        \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        def maxLength(i, string):\n            nonlocal ans\n\n            if i == len(arr):\n                \n                s, invalid = set(), False\n                for ch in string:\n                    if ch in s:\n                        invalid = True\n                        break\n\n                    s.add(ch)\n                \n                if not invalid:\n                    # print(string)\n                    ans = max(ans, len(string))\n                return\n\n            maxLength(i + 1, string)\n            maxLength(i + 1, string + arr[i])\n        \n        ans = 0\n        maxLength(0, '')\n        return ans", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        if len(arr) == 1:\n            if len(set(arr[0])) == len(list(arr[0])):\n                return len(set(arr[0]))\n            else:\n                return 0\n            \n        all_combinations = []\n        max_ = 0\n        for r in range(1, len(arr)+1):\n            combinations_object = itertools.combinations(arr, r)\n            combinations_list = list(combinations_object)\n            for st in combinations_list:\n                comb = ''.join(st)\n                if len(set(comb))==len(comb):\n                    max_ = max(max_, len(comb))\n\n        return max_\n", "class Solution:\n    \n    def is_unique(self,word):\n        count = dict()\n        \n        for char in ''.join(word):\n            if char in count:\n                return False\n            else:\n                count[char] = 1\n        \n        \n        return True\n    \n    def find_max(self,arr,output,current,start_index):\n        if self.is_unique(current):\n            output.append(len(''.join(current)))\n        \n        for i in range(start_index,len(arr)):\n            self.find_max(arr,output,current + [arr[i]],i + 1)\n        \n    \n    def maxLength(self, arr: List[str]) -> int:\n        \n        \n        output = []\n        \n        self.find_max(arr,output,[],0)\n        \n        return max(output)", "# https://www.youtube.com/watch?v=N7womGmLXh8\n# https://www.youtube.com/watch?v=pD3cHFNyW2I\nclass Solution:\n    # backtracking\n    def maxLength(self, arr: List[str]) -> int:\n        self.maxLen = 0\n        def isUnique(s):\n            return len(s) if len(s) == len(set(s)) else -1\n        def dfs(i, s):\n            if i == len(candi) and isUnique(s) > self.maxLen:\n                self.maxLen = len(s)\n                return\n            if i == len(candi):\n                return\n            dfs(i + 1, s)  # use arr[i]\n            dfs(i + 1, s + candi[i])  # without using arr[i]\n            \n        candi = []\n        for ss in arr:\n            if isUnique(ss) > 0:\n                candi.append(ss)\n    \n        dfs(0, '')\n        return self.maxLen\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        return self.backtrack(set(), arr,0)\n        \n    def backtrack(self,curr, arr, index):\n        if(index >= len(arr)):\n            return len(curr)\n        max_len = 0\n        for i in range(index, len(arr)):\n            char_set = set([c for c in arr[i]])\n            if(curr.intersection(char_set) == set() and len(char_set) == len(arr[i])):\n                curr = curr.union(char_set)\n                max_len = max(max_len,self.backtrack(set(curr), arr, i+1))\n                curr = curr.difference(char_set)\n            else:\n                max_len = max(max_len,self.backtrack(curr, arr, i+1))\n            \n        return max_len", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        self.output = []\n        self.res = 0\n        \n        self.dfs(arr)\n        # print(self.output)\n        # print(self.res)\n        return self.res\n    \n    def checkUnique(self, s):\n        m = set()\n        for i in s:\n            if i not in m:\n                m.add(i)\n            else:\n                return False\n        return True\n                    \n        \n    def dfs(self, arr, first = 0, curr = []):\n        st = ''.join(curr)\n        # print(st)\n\n        if self.checkUnique(st):\n            self.output.append(st)\n            self.res = max(len(st), self.res)\n\n        for i in range(first, len(arr)):\n            curr.append(arr[i])\n            self.dfs(arr, i+1, curr)\n            curr.pop()\n\n        \n        \n                \n                \n                \n                \n            \n            \n            \n", "from itertools import combinations\nclass Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        max_count = 0\n        for i in range(0, len(arr)+1):\n            comb = combinations(arr, i)\n            for c in comb:\n                count = 0\n                bag = set()\n                s = ''.join(c)\n                for k in s:\n                    if k in bag:\n                        count = 0\n                        break\n                    else:\n                        count += 1\n                        bag.add(k)\n                max_count = max(max_count, count)\n        return max_count ", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        if not arr: return 0\n        def isUnique(s): return len(set(s)) == len(s)\n        def dfs(arr, res, curr):\n            if isUnique(curr):\n                res[0] = max(res[0], len(curr))\n            for i in range(len(arr)):\n                dfs(arr[i + 1:], res, curr + arr[i])\n        res = [0]\n        dfs(arr, res, '')\n        return res[0]", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        return self.backtrack(set(), arr,0)\n        \n    def backtrack(self,curr, arr, index):\n        if(index >= len(arr)):\n            return len(curr)\n        max_len = 0\n        for i in range(index, len(arr)):\n            char_set = set([c for c in arr[i]])\n            if(curr.intersection(char_set) == set() and len(char_set) == len(arr[i])):\n                curr = curr.union(char_set)\n                max_len = max(max_len,self.backtrack(set(curr), arr, i+1))\n                curr = curr.difference(char_set)\n            else:\n                max_len = max(max_len,self.backtrack(set(curr), arr, i+1))\n            \n        return max_len", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        self.ans = 0\n        vis = set()\n        def help(s, i):\n            if len(s)==len(set(s)):\n                self.ans = max(self.ans, len(s))\n            if i>=len(arr):\n                return\n            for j in range(i, len(arr)):\n                if j not in vis:\n                    vis.add(j)\n                    help(s+arr[j], j+1)\n                    vis.remove(j)\n        help('',0)\n        return self.ans", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        n = len(arr)\n        self.max = 0\n        \n        def helper(idx, chars):\n            if idx >= n:\n                if len(chars) == len(set(chars)):\n                    self.max = max(self.max, len(chars))\n            else:\n                helper(idx + 1, chars)\n                helper(idx + 1, chars + list(arr[idx]))\n                        \n                        \n                    \n        helper(0, [])\n        return self.max\n            \n            \n        \n", "# https://www.youtube.com/watch?v=N7womGmLXh8\n# https://www.youtube.com/watch?v=pD3cHFNyW2I\nclass Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        self.maxLen = 0\n        def isUnique(s):\n            return len(s) if len(s) == len(set(s)) else -1\n        def dfs(i, s):\n            if i == len(arr) and isUnique(s) > self.maxLen:\n                self.maxLen = len(s)\n                return\n            if i == len(arr):\n                return\n            dfs(i + 1, s)\n            dfs(i + 1, s + arr[i])\n            \n            \n        dfs(0, '')\n        return self.maxLen\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        if arr == None:\n            return\n        \n        path = []\n        result = [0]\n        \n        def hasUniqueLetters(word):\n            \n            hash_set = set()\n                \n            for c in word:\n                if c in hash_set:\n                    return False\n                else:\n                    hash_set.add(c)\n            return True\n        \n        def generateCombinations(arr,i, result, path):\n            \n            if i == len(arr):\n                combination = ''.join(path)\n                if path and hasUniqueLetters(combination):\n                    if result[0] < len(combination):\n                        result[0] = len(combination)\n                return\n                \n            curr_path = []\n            curr_path.extend(path)\n            curr_path.append(arr[i])\n            \n            generateCombinations(arr, i+1, result, path)\n            generateCombinations(arr, i+1, result, curr_path)\n            \n        generateCombinations(arr,0,result,path)\n        \n        return result[0]\n", "class Solution:\n    def uniquelen(self,cur):\n        if len(cur)==len(set(cur)):\n            return(len(cur))\n        else:\n            return(-1)\n        \n    def dfs(self,arr,index,cur):\n        if index==len(arr) and self.uniquelen(cur) > self.ans:\n            self.ans = self.uniquelen(cur)\n            return\n        if index==len(arr):\n            return\n        \n        self.dfs(arr,index+1,cur)\n        self.dfs(arr,index+1,cur+arr[index])\n        \n    def maxLength(self, arr: List[str]) -> int:\n        self.ans = -1\n        self.dfs(arr,0,'')\n        return(self.ans)", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        ret = [set()]\n        \n        for string in arr:\n            curr = set(string)\n            if len(curr) == len(string):\n                for seen in ret:\n                    if not (seen&curr):\n                        ret.append(seen|curr)\n        max_len = 0\n        for string in ret:\n            max_len = max(max_len, len(string))\n        return max_len", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        char_freq = {}\n        \n        for i in range(len(arr)):\n            char_freq[i] = set()\n            \n            for c in arr[i]:\n                if c not in char_freq[i]:\n                    char_freq[i].add(c)\n                else:\n                    del char_freq[i]\n                    break\n                    \n        items_count = len(char_freq)\n        max_len = 0\n        \n        for i in range(1, 2 ** items_count):\n            num = i\n            current_set = set()\n            current_len = 0\n            \n            for j in list(char_freq.keys()):\n                intersect = current_set.intersection(char_freq[j])\n                if num & 1 and not intersect:\n                    current_set.update(char_freq[j])\n                    current_len += len(arr[j])\n                    max_len = max(max_len, current_len)\n                elif num & 1 and intersect:\n                    break\n                num >>= 1\n                \n        return max_len\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        n = len(arr)\n        self.max = 0\n        def helper(idx, chars):\n            if idx >= n:\n                if len(chars) == len(set(chars)):\n                    self.max = max(self.max, len(chars))\n            else:\n                helper(idx + 1, chars)\n                # temp = \n                # for c in arr[idx]:\n                #     chars.append(c)\n                helper(idx + 1, chars + list(arr[idx]))\n                        \n                        \n                    \n        helper(0, [])\n        return self.max\n            \n            \n        \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        if arr == None:\n            return\n        \n        path = []\n        result = [0]\n\n        def generateCombinations(arr,i, result, path):\n            \n            if i == len(arr):\n                \n                \n                if path:\n                    combination = ''.join(path)\n                    if len(set(combination)) == len(combination):\n                        if result[0] < len(combination):\n                            result[0] = len(combination)\n                return\n                \n            curr_path = []\n            curr_path.extend(path)\n            curr_path.append(arr[i])\n            \n            generateCombinations(arr, i+1, result, path)\n            generateCombinations(arr, i+1, result, curr_path)\n            \n        generateCombinations(arr,0,result,path)\n        \n        return result[0]\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        if not arr: return 0\n        def isUnique(s): return len(set(s)) == len(s)\n        def dfs(arr, res, curr):\n            yield curr\n            for i in range(len(arr)):\n                yield from dfs(arr[i + 1:], res, curr + arr[i])\n        res = 0\n        for st in dfs(arr, res, ''):\n            if isUnique(st):\n                res = max(res, len(st))\n        return res", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        def valid(w):\n            return all(v <= 1 for v in collections.Counter(w).values())\n        def dfs(i, cand):\n            if i < 0:\n                return 0\n            res = dfs(i - 1, cand)\n            if valid(arr[i]) and all(c in cand for c in arr[i]):\n                new_cand = {c for c in cand if c not in collections.Counter(arr[i]).keys()}\n                res = max(res, dfs(i - 1, new_cand) + len(arr[i]))\n            \n            return res\n        \n        return dfs(len(arr) - 1, {chr(i + ord('a')) for i in range(26)})", "class Solution:\n    def maxLength(self, arr):\n        prev = {0: 0}\n        for word in arr:\n            seen = 0\n            duplicate = False\n            for char in word:\n                binaryC = 1 << (ord(char) - ord('a'))\n                if binaryC & seen != 0:\n                    duplicate = True\n                    break\n                else:\n                    seen |= binaryC\n            if duplicate:\n                continue\n            toAdd = dict()\n            for k in prev:\n                if k & seen == 0:\n                    toAdd[k | seen] = prev[k] + len(word)\n            prev.update(toAdd)\n        return max(prev.values())\n\nclass Solution:\n    def maxLength(self, arr):\n        cands = {0: 0}\n        for word in arr:\n            if len(word) != len(set(word)): continue\n            currW = sum(1 << (ord(char) - ord('a')) for char in word)\n            toAdd = dict()\n            for prevW in cands:\n                if prevW & currW == 0:\n                    toAdd[prevW + currW] = cands[prevW] + len(word)\n            cands.update(toAdd)\n        return max(cands.values())", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        def unique_char_count(s):\n            chars = set()\n            for char in s:\n                if char in chars:\n                    return -1\n                else:\n                    chars.add(char)\n            return len(s)\n        \n        def max_unique(arr, index, cur_str, result):\n            if index >= len(arr):\n                if unique_char_count(cur_str) > result[0]:\n                    result[0] = len(cur_str)\n                return\n            max_unique(arr, index + 1, cur_str + arr[index], result)\n            max_unique(arr, index + 1, cur_str, result)\n        \n        result = [0]\n        max_unique(arr, 0, '', result)\n        return result[0]\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n            \n        # backtracking function\n        \n        def helper(arr, substring, i):\n            \n            # get the length of the substring without char duplication \n            unique_length = len(set(substring))\n            \n            # if there is no duplicate chars\n            if len(substring) == unique_length:\n                self.max_len = max(self.max_len, unique_length)\n            \n            # check if we reached the last substring in arr\n            if i == len(arr) - 1:\n                return\n\n            for j in range(i+1, len(arr)):\n                helper(arr, substring + arr[j], j)\n\n            return\n        \n        \n        self.max_len = 0\n        \n        helper(arr, '', -1)\n        \n        return self.max_len", "class Solution:\n  # I believe this problem is equivalent to SAT with weighted variables so I\n  # won't try to beat exp complexity. The state space is 2^16 configurations\n  # large so exp complexity shouldn't be a problem.\n\n  def maxLength(self, arr):\n\n    def isValid(chars):\n      if len(chars) == len(set(chars)):\n        return True\n      else:\n        return False\n\n    result = 0\n    currentSubset = set()\n    def iterate(idx):\n      nonlocal result, currentSubset\n      if (idx == len(arr)):\n        candidateSolution = ''.join(currentSubset)\n        if (isValid(candidateSolution) and len(candidateSolution) > result):\n          result = len(candidateSolution)\n        return\n      currentSubset.add(arr[idx])\n      iterate(idx + 1)\n      currentSubset.remove(arr[idx])\n      iterate(idx + 1)\n    \n    iterate(0)\n    return result\n", "def bo(i):\n    return ord(i)-ord('a')\nclass Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        n = len(arr)\n        freq = []\n        ans = 0\n        for i in range(n):\n            s1=set()\n            for j in arr[i]:\n                s1.add(bo(j))\n            if len(s1)==len(arr[i]):\n                freq.append(s1)\n        n = len(freq)\n        for i in range(1<<n):\n            s = set()\n            cnt = 0\n            for j in range(n):\n                if i&(1<<j):\n                    for k in freq[j]:\n                        s.add(k)\n                    cnt += len(freq[j])\n                    if cnt != len(s):\n                        break\n            if cnt == len(s):\n                ans = max(ans,cnt)\n            if ans == 26:\n                break\n        return ans\n            \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        dp = [set()]\n        length = 0\n        for word in arr:\n            if len(word) != len(set(word)): continue\n            curr = set(word)\n            for used in dp[:]:\n                if not len(used & curr):\n                    dp.append(used | curr)\n                    length = max(length,  len(used | curr))\n        return length\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        def valid(s, baskets):\n            return all([c not in baskets for c in s])\n        \n        def find_max_len_recursive(baskets, currIdx):\n            if currIdx == len(arr):\n                return len(baskets)\n            res1 = float('-inf')\n            if valid(arr[currIdx], baskets):\n                res1 = find_max_len_recursive(baskets.union(set(arr[currIdx])), currIdx + 1)\n            res2 = find_max_len_recursive(baskets, currIdx + 1)\n            return max(res1, res2)\n        \n        arr = [s for s in arr if len(s) == len(set(s))]\n        return find_max_len_recursive(set(), 0)", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        combinations = [set()]\n        \n        for a in arr:\n            chars = set(a)\n        \n            if len(chars) != len(a):\n                continue\n            \n            for c in combinations:\n                if len(chars.intersection(c)) == 0:\n                    combinations.append(chars.union(c))\n            \n        return max([len(c) for c in combinations])\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        arr.sort()\n        self.arr = arr\n        self.tmp = []\n        self.mlen = 0\n        self.len = 0\n        self.backtrack(0)\n        return self.mlen\n    \n    def backtrack(self,pos):\n        # print(self.tmp,self.len)\n        if pos == len(self.arr):\n            \n            if self.len > self.mlen:\n                # print(self.len,self.mlen)\n                self.mlen = self.len\n            return\n        self.backtrack(pos+1)\n        lb = len(self.tmp)\n        self.tmp = self.tmp + list(self.arr[pos])\n        l = len(self.arr[pos])\n        if l == len(self.arr[pos]) and lb + l == len(set(self.tmp)):\n            \n            self.len+=l\n            self.backtrack(pos+1)\n            self.len-=l\n        \n                \n        # for i in range(l):\n        #     self.tmp.pop()\n        self.tmp = self.tmp[:-l]\n        \n        \n        \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        dp = [set()]\n        for word in arr:\n            if len(word) !=len(set(word)): continue \n            curWord = set(word)\n            for used in dp[:]:\n                if len(used & curWord) == 0:\n                    dp.append(used | curWord)\n        return len(max(dp, key = len))\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        arr.sort()\n        self.arr = arr\n        self.tmp = []\n        self.mlen = 0\n        self.len = 0\n        self.backtrack(0)\n        return self.mlen\n    \n    def backtrack(self,pos):\n        # print(self.tmp,self.len)\n        if pos == len(self.arr):\n            \n            if self.len > self.mlen:\n                # print(self.len,self.mlen)\n                self.mlen = self.len\n            return\n        lb = len(self.tmp)\n        self.tmp = self.tmp + list(self.arr[pos])\n        l = len(self.arr[pos])\n        if l == len(self.arr[pos]) and lb + l == len(set(self.tmp)):\n            \n            self.len+=l\n            self.backtrack(pos+1)\n            self.len-=l\n        \n                \n        # for i in range(l):\n        #     self.tmp.pop()\n        self.tmp = self.tmp[:-l]\n        self.backtrack(pos+1)\n        \n        \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        arr.sort()\n        self.arr = arr\n        self.tmp = []\n        self.mlen = 0\n        self.len = 0\n        self.backtrack(0)\n        return self.mlen\n    \n    def backtrack(self,pos):\n        # print(self.tmp,self.len)\n        if pos == len(self.arr):\n            \n            if self.len > self.mlen:\n                # print(self.len,self.mlen)\n                self.mlen = self.len\n            return\n        self.backtrack(pos+1)\n        lb = len(self.tmp)\n        self.tmp = self.tmp + list(self.arr[pos])\n        l = len(self.arr[pos])\n        if l == len(self.arr[pos]) and lb + l == len(set(self.tmp)):\n            \n            self.len+=l\n            self.backtrack(pos+1)\n            self.len-=l\n        \n                \n        for i in range(l):\n            self.tmp.pop()\n        # self.tmp = self.tmp[:-l]\n        \n        \n        \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        N = len(arr)\n        # store the intermediate sets of unique characters\n        charSets = [set()]\n        # iterate over each string\n        for s in arr:\n            # iterate over each char set to see if we can add the chars in s into it\n            currSet = set(s)\n            # skip string swith duplicate chars\n            if len(currSet) != len(s):\n                continue\n            currSize = len(charSets)\n            for idx in range(currSize):\n                charSet = charSets[idx]\n                # check if the sets have an intersection (duplicate chars)\n                if charSet & currSet:\n                    continue\n                charSets.append(charSet | currSet)\n        return max(len(charSet) for charSet in charSets)", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        d = ['']\n        for a in arr:\n            if len(set(a)) < len(a):\n                continue\n            else:\n                for x in d:\n                    if set(x) & set(a):\n                        continue\n                    else:\n                        t = set(a) | set(x)\n                        d.append(t)\n        max = 0\n        for i in d:\n            if len(i) > max:\n                max = len(i)\n        return max", "class Solution:\n    # https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/discuss/631245/Python-3-Easy-Code-Intutive-Solution\n    \n    def maxLength(self, arr: List[str]) -> int:\n        res = 0\n        unique = ['']\n        \n        def isvalid(s):\n            return len(s) == len(set(s))\n        \n        for word in arr:\n            for u in unique:\n                tmp = word + u\n                if isvalid(tmp):\n                    unique.append(tmp)\n                    res = max(res, len(tmp))\n                    \n        return res", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        maxlen = 0\n        unique = ['']\n\n        def isvalid(s):\n            return len(s) == len(set(s))\n\n        for word in arr:\n            for j in unique:\n                tmp = word + j\n                if isvalid(tmp):\n                    unique.append(tmp)\n                    maxlen = max(maxlen, len(tmp))\n\n        return maxlen", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        if len(arr) == 1:\n            return len(arr[0])\n        \n        self.res = 0\n    \n        def backtrack(start: int, path: set):\n            self.res = max(self.res, len(path))\n            \n            if start == len(arr):\n                return\n            \n            for i in range(start, len(arr)):\n                new_chars = set(arr[i])\n                if len(new_chars) != len(arr[i]):\n                    continue\n\n                if len(new_chars & path) == 0:\n                    # we can concat \n                    new_path = new_chars | path\n                    backtrack(i+1, new_path)\n\n        backtrack(0, set())\n        return self.res\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        arr = [w for w in arr if len(w)==len(set(w))]\n        hm = {}\n        res = 0\n        dp = {0:0}\n        for i, w in enumerate(arr):\n            bitmask = 0\n            for c in set(w):\n                bit_set = 1<<(ord(c)-ord('a'))\n                bitmask ^= bit_set\n            \n            hm[i] = bitmask\n            \n        for i in range(len(arr)):\n            for p in list(dp.keys()):\n                if not hm[i]&p:\n                    now = hm[i]^p\n                    dp[now] = max(dp.get(now, 0), dp[p]+len(arr[i]))\n                    \n        return max(dp.values())\n", "class Solution:\n    def maxLength(self, l: List[str]) -> int:\n        selected = set()\n        \n        def ok(word, s) -> bool:\n            return not any(v in s for v in word) and len(word) == len(set(word))\n        \n        def backTrack(l: List[str], curr_index: int, selected: set) -> int:\n            maxLength = 0\n            \n            if curr_index != -1:\n                for v in l[curr_index]: # add the chosen word to selected\n                    selected.add(v)\n            \n            for i in range(curr_index+1,len(l)):\n                if ok(l[i],selected): # word is good - so we choose it\n                    \n                    maxLength = max(maxLength, len(l[i])\n                                    + backTrack(l, i, selected.copy()))\n                                        \n            return maxLength\n        \n        return backTrack(l, -1, selected)", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        def dfs(start, seen):\n            nonlocal res\n            if start==len(arr):\n                res = max(res, sum(len(arr[i]) for i in seen) )\n            else:\n                is_end = True\n                for i in graph[start]:\n                    if all(len(arr[j].intersection(arr[i]))==0 for j in seen):\n                        is_end = False\n                        seen.append(i)\n                        dfs(i, seen)\n                        seen.pop()\n                if is_end:\n                    res = max(res, sum(len(arr[i]) for i in seen) )\n        \n        arr = [item for item in arr if len(item)==len(set(item))]\n        arr = list(map(set, arr))\n        graph = collections.defaultdict(list)\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if len(arr[i].intersection(arr[j]))==0:\n                    graph[i].append(j)\n        print((dict(graph)))\n            \n        res = 0\n        for i in range(len(arr)):\n            dfs(i, [i])\n        return res\n            \n", "#https://wentao-shao.gitbook.io/leetcode/graph-search/1239.maximum-length-of-a-concatenated-string-with-unique-characters\n\nclass Solution:\n    def maxLength1(self, arr: List[str]) -> int:\n        \n        def dfs(start, seen):\n            nonlocal res\n            if start==len(arr):\n                res = max(res, sum(len(arr[i]) for i in seen) )\n            else:\n                is_end = True\n                for i in graph[start]:\n                    if all(len(arr[j].intersection(arr[i]))==0 for j in seen):\n                        is_end = False\n                        seen.append(i)\n                        dfs(i, seen)\n                        seen.pop()\n                if is_end:\n                    res = max(res, sum(len(arr[i]) for i in seen) )\n        \n        arr = [item for item in arr if len(item)==len(set(item))]\n        arr = list(map(set, arr))\n        graph = collections.defaultdict(list)\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if len(arr[i].intersection(arr[j]))==0:\n                    graph[i].append(j)\n            \n        res = 0\n        for i in range(len(arr)):\n            dfs(i, [i])\n        return res\n            \n    def maxLength(self, arr: List[str]) -> int:\n        \n        def dfs(seen):\n            nonlocal res\n            is_end = True\n            for i in graph[seen[-1]]:\n                if all(len(arr[j].intersection(arr[i]))==0 for j in seen):\n                    is_end = False\n                    seen.append(i)\n                    dfs(seen)\n                    seen.pop()\n            if is_end:\n                res = max(res, sum(len(arr[i]) for i in seen) )\n        \n        arr = [item for item in arr if len(item)==len(set(item))]\n        arr = list(map(set, arr))\n        graph = collections.defaultdict(list)\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if len(arr[i].intersection(arr[j]))==0:\n                    graph[i].append(j)\n            \n        res = 0\n        for i in range(len(arr)):\n            dfs([i])\n        return res\n            \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        myQueue = collections.deque([('', 0)]) # word, index to start search from\n        maxLen = 0\n        \n        while myQueue:\n            word, start = myQueue.popleft()\n            for i in range(start, len(arr)):\n                newWord = word + arr[i]\n                if self.isUnique(newWord):\n                    maxLen = max(maxLen, len(newWord))\n                    myQueue.append((newWord, i + 1))\n        \n        return maxLen\n    \n    def isUnique(self, s):\n        return len(s) == len(set(s))\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        self.array = arr\n        \n        return max(self.recurse('', set(), 0, True), self.recurse('', set(), 0, False))\n    \n    def recurse(self, prefix: str, letters: set, index: int, include: bool):\n        # Base case\n        if index >= len(self.array):\n            return len(prefix)\n        \n        # Recursive cases\n        if include:\n            # Do not include a string that has duplicate characters within itself\n            if len(self.array[index]) != len(set(self.array[index])):\n                return len(prefix)\n            \n            # Do not include a string that contains letters already in prefix\n            if any(letter in letters for letter in self.array[index]):\n                return len(prefix)\n            \n            return max(\n                self.recurse(''.join((prefix, self.array[index])), letters | set(self.array[index]), index + 1, True),\n                self.recurse(''.join((prefix, self.array[index])), letters | set(self.array[index]), index + 1, False),\n            )\n        \n        return max(\n            self.recurse(prefix, letters, index + 1, True),\n            self.recurse(prefix, letters, index + 1, False),\n        )", "class Solution:\n    \n    def is_unique(self, word):\n        letters = set()\n        \n        for letter in word:\n            if letter in letters:\n                return False\n            letters.add(letter)\n        return True\n        \n    def maxLength(self, arr: List[str]) -> int:\n        \n        uniques = set()\n\n        for piece in arr:\n            # print(piece)\n            next_uniques = set()\n            for unique in uniques:\n                concat = piece + unique\n                # print(\\\"{0}: {1}\\\".format(concat, self.is_unique(concat)))\n                if self.is_unique(concat):\n                    next_uniques.add(concat)\n            if self.is_unique(piece):            \n                next_uniques.add(piece)\n            for u in next_uniques:\n                uniques.add(u)\n        \n        if uniques:\n            return max([len(x) for x in uniques])\n        return 0    \n        \n        \n        \n", "from collections import Counter\nclass Solution:\n\n\n    def maxLength(self, arr) -> int:\n        if(len(arr) ==1):\n            return len(arr[0])\n        self.max_val = 0\n\n        max_val = float('-inf')\n\n        def check(string):\n            c = Counter(string)\n            for key, val in c.items():\n                if(c[key]>1):\n                    return False\n            return True\n\n        def _helper(string, index):\n\n            if check(string):\n                self.max_val = max(self.max_val, len(string))\n            else:\n                return\n\n            if index >= len(arr):\n                return\n\n            for i in range(index, len(arr)):\n                newString = string + arr[i]\n                _helper(newString, i + 1)\n\n        print(_helper('', 0))\n\n        return self.max_val", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        if not arr:\n            return 0\n        \n        max_length = 0\n        \n        duplicates = set([])\n        from collections import deque\n        queue = deque([])\n        \n        for idx, val in enumerate(arr):\n            if val in duplicates or self.doesDuplicateExist(val):\n                continue\n            queue.appendleft((idx, val, len(val)))\n            duplicates.add(val)\n            \n        n = len(arr) \n        \n        while len(queue) != 0:\n            idx, curr, curr_len = queue.pop()\n            \n            max_length = max(max_length, curr_len)\n                \n            for i in range(idx+1, n):\n                newWord = curr + arr[i]\n                if newWord in duplicates or self.doesDuplicateExist(newWord):\n                    continue\n                    \n                queue.appendleft((i, newWord, len(newWord)))\n                duplicates.add(newWord)\n            \n            \n        return max_length\n    \n    def doesDuplicateExist(self, val):\n        dup = set()\n        \n        for char in val:\n            if char in dup:\n                return True\n            dup.add(char)\n            \n        return False\n        \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        self.array = arr\n        \n        return max(self.recurse('', set(), 0, True), self.recurse('', set(), 0, False))\n    \n    def recurse(self, prefix: str, letters: set, index: int, include: bool):\n        # Base case\n        if index >= len(self.array):\n            return len(prefix)\n        \n        # Recursive case\n        if include and len(self.array[index]) == len(set(self.array[index])):\n            if any(letter in letters for letter in self.array[index]):\n                return len(prefix)\n            \n            return max(\n                self.recurse(''.join((prefix, self.array[index])), letters | set(self.array[index]), index + 1, True),\n                self.recurse(''.join((prefix, self.array[index])), letters | set(self.array[index]), index + 1, False),\n            )\n        \n        return max(\n            self.recurse(prefix, letters, index + 1, True),\n            self.recurse(prefix, letters, index + 1, False),\n        )", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        self.res = 0\n        \n        def walk(i, temp):\n            self.res = max(self.res, len(temp))\n            \n            for j in range(i, len(arr)):\n                if all(v <= 1 for v in list(collections.Counter(temp+arr[j]).values())):\n                    walk(j+1, temp+arr[j])\n        \n        walk(0, '')\n        return self.res\n            \n", "class Solution:\n    def maxLength(self, arr) -> int:\n        maxLen = 0\n        arr = sorted(arr, key=lambda x: len(x), reverse=True)\n        self.compatible = {}\n        for i in range(len(arr)):\n            currString = arr[i]\n            if self.noDupes(currString):\n                if currString not in self.compatible:\n                    self.compatible[currString] = []\n                for j in range(i+1, len(arr)):\n                    if self.noDupes(arr[j]) and self.uniqueChars(currString, arr[j]):\n                        self.compatible[currString].append(arr[j])\n        for key in self.compatible:\n            if len(self.compatible[key]) == 0:\n                length = len(key)\n            else:\n                length = self.findLength(key, key, 0)\n            maxLen = max(maxLen, length)\n        return maxLen\n    \n    def uniqueChars(self, s1, s2):\n        for c in s2:\n            if c in s1:\n                return False\n        return True\n    \n    def noDupes(self, string):\n        counts = {}\n        for c in string:\n            counts[c] = counts.get(c, 0) + 1\n            if counts[c] > 1:\n                return False\n        return True\n\n    def findLength(self, currString, totalString, maxLen):\n        for string in self.compatible[currString]:\n            if self.uniqueChars(totalString, string):\n                maxLen = max(maxLen, self.findLength(string, totalString + string, len(totalString) + len(string)))\n        \n        return maxLen", "class Solution:\n    def __init__(self):\n        self._maxLength = 0\n        \n    def maxLength(self, arr: List[str]) -> int:\n        self.uniqueLengths(arr, [])\n        return self._maxLength\n    \n    def uniqueLengths(self, arr, concat):\n        result = ''.join(concat)\n        if not self.hasUniqueChars(result):\n            return\n        \n        self._maxLength = max(self._maxLength, len(result))\n        \n        for i in range(len(arr)):\n            concat.append(arr[i])\n            self.uniqueLengths(arr[i+1:], concat)\n            concat.pop()\n    \n    def hasUniqueChars(self, concat):\n        counter = Counter(concat)\n        return all([x == 1 for x in counter.values()])", "from collections import Counter\nclass Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        max_str = 0\n        for i in range(len(arr)):\n            if self.is_unique(arr[i]) and len(arr[i]) > max_str:\n                max_str = len(arr[i])\n            \n            concat = [arr[i]]\n            for j in range(i+1, len(arr)):\n                for x in concat:\n                    c = x + arr[j]\n                    if self.is_unique(c):\n                        if len(c) > max_str:\n                            max_str = len(c)\n                        concat.append(c)\n        return max_str\n            \n        \n    def is_unique(self, str):\n        for v in Counter(str).values():\n            if v > 1:\n                return False\n        return True", "class Solution:\n    \n    def is_unique(self, s):\n        return len(set(s)) == len(s)\n    \n    def maxLength(self, arr: List[str]) -> int:\n        \n        dct= {}\n        maxVal = 0\n        \n        for i in range(0, len(arr)):\n            if self.is_unique(arr[i]):\n                v = frozenset(arr[i])\n\n                dct[v] = len(v)\n                maxVal = max(maxVal, len(v))\n                \n            for j in range(i+1, len(arr)):\n                t = arr[i] + arr[j]\n                val = frozenset(t)\n                \n                if val not in dct.keys():\n                    if self.is_unique(t):\n                        # print(t)\n                        arr.append(t)\n                        dct[val] = len(val)\n                        maxVal = max(maxVal, len(val))\n        print(dct)\n        return maxVal", "class Solution:\n    def __init__(self):\n        self._maxLength = 0\n        \n    def maxLength(self, arr: List[str]) -> int:\n        self.uniqueLengths(arr, [])\n        return self._maxLength\n    \n    def uniqueLengths(self, arr, concat):\n        if not self.hasUniqueChars(''.join(concat)):\n            return\n        \n        self._maxLength = max(self._maxLength, len(''.join(concat)))\n        \n        for i in range(len(arr)):\n            concat.append(arr[i])\n            self.uniqueLengths( arr[i+1:], concat)\n            concat.pop()\n    \n    def hasUniqueChars(self, concat):\n        counter = Counter(concat)\n        return all([x == 1 for x in counter.values()])", "class Solution(object):\n    def maxLength(self, A):\n        for i in range(len(A) - 1, -1, -1):\n            if len(set(A[i])) != len(A[i]):\n                A.pop(i)\n        N = len(A)\n        \n        B = []\n        for word in A:\n            ct = [0] * 26\n            for letter in word:\n                ct[ord(letter) - ord('a')] += 1\n            B.append(ct)\n\n        self.ans = 0\n        count = [0] * 26\n        def search(i):\n            if i == N:\n                cand = sum(count)\n                if cand > self.ans: self.ans = cand\n                return\n            \n            for letter, ct in enumerate(B[i]):\n                if ct and count[letter]:\n                    search(i+1)\n                    break\n            else:\n                search(i+1)\n                for letter, ct in enumerate(B[i]):\n                    if ct:\n                        count[letter] += 1\n                search(i+1)\n                for letter, ct in enumerate(B[i]):\n                    if ct:\n                        count[letter] -= 1\n        search(0)\n        return self.ans", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        d = {}\n        def helper(banned,start):\n            if start == len(arr):\n                return len(banned)\n            k = tuple(sorted(str(banned)+str(start)))\n            if k in d:\n                return d[k]\n            string = arr[start]\n            new_set = set()\n            for i in string:\n                if i in banned or i in new_set:\n                    return helper(banned,start+1)\n                new_set.add(i)\n            new_banned = banned.union(new_set)\n            val = max(helper(new_banned,start+1),helper(banned,start+1))\n            d[k] = val\n            return val\n        initial_banned = set()\n        res = helper(initial_banned,0)\n        return res\n        \n        \n            \n            \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        newarr = []\n        for w in arr:\n            if len(set(w)) == len(w):\n                newarr.append(w)\n        arr = newarr\n        n = len(arr)\n        res = 0\n        \n        str_masks = [None] * n\n        for i in range(n):\n            wd = arr[i]\n            mask = 0\n            for ch in wd:\n                ch_pos = ord(ch) - ord('a')\n                mask |= 1 << ch_pos\n            str_masks[i] = mask\n            \n        def dfs(idx, mask, curlen):\n            nonlocal res\n            if idx == n:\n                res = max(res, curlen)\n                return\n            # use arr[idx]\n            if mask & str_masks[idx] == 0:\n                # can use arr[idx]\n                dfs(idx + 1, mask | str_masks[idx], curlen + len(arr[idx]))\n            # not use arr[idx]\n            dfs(idx + 1, mask, curlen)\n        dfs(0, 0, 0)\n        return res\n", "from collections import defaultdict\n\nclass Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        self.longest = 0\n        def valid(s):\n            d = defaultdict(int)\n            for char in s:\n                d[char] += 1\n                if d[char] == 2:\n                    return False\n            return True\n        \n        def backtrack(curr, ind):\n            if ind == len(arr):\n                if len(curr) > self.longest: self.longest = len(curr)\n                return\n            for i in range(ind, len(arr)):\n                temp = curr+arr[i]\n                if valid(temp):\n                    backtrack(curr+arr[i], i + 1)\n            \n            if len(curr) > self.longest: self.longest = len(curr)\n            return\n                \n        for i in range(len(arr)):\n            if valid(arr[i]):\n                backtrack(arr[i], i)\n        \n        return self.longest", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        newarr = []\n        for cur in arr:\n            newarr.append(collections.Counter(cur))\n        res = [0]\n        def helper(cur, index):\n            if index == len(arr):\n                res[0] = max(res[0], len(cur))\n            else:\n                if len(arr[index]) == len(newarr[index]):\n                    if not newarr[index] & cur:  \n                        helper(newarr[index] + cur, index+1)\n                helper(cur, index+1)\n                \n        helper(collections.Counter(''), 0)\n        \n        return res[0]", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        newarr = []\n        for cur in arr:\n            newarr.append(collections.Counter(cur))\n        res = [0]\n        def helper(cur, index):\n            if index == len(arr):\n                res[0] = max(res[0], len(cur))\n            else:\n                if len(arr[index]) == len(newarr[index]) and not newarr[index] & cur:  \n                    helper(newarr[index] + cur, index+1)\n                helper(cur, index+1)\n                \n        helper(collections.Counter(''), 0)\n        \n        return res[0]", "from collections import Counter\nclass Solution:\n    def back(self, arr, soln, solns):\n        # print(\\\"Arr {} | Soln {}\\\".format(arr, soln))\n        if not arr:\n            solns.append([len(soln),soln])\n            return solns\n        \n        \n        for i in range(len(arr)):\n            sa = set(arr[i])\n            sb = set(soln)    \n            c = dict(Counter(arr[i]))\n            \n            if max(c.values()) == 1 and len(sb.intersection(sa))==0:\n                solncopy = soln\n                solncopy+=arr[i]\n                solns = self.back(arr[i+1:],solncopy, solns)\n\n        solns.append([len(soln),soln])\n        return solns\n        \n    def maxLength(self, arr: List[str]) -> int:\n        solns = []\n        for i in range(len(arr)):\n            soln = arr[i]\n            c = dict(Counter(arr[i]))\n            if max(c.values()) == 1:\n                solns = self.back(arr[i+1:],soln, solns)\n        # print(solns)\n        # for s in solns:\n            # print(s)\n        if not solns:\n            return 0\n        return max(solns, key=lambda x:x[0])[0]\n        \n            \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        letters_dict = {}\n        \n        \n    \n        def dfs(letter_set, arr, i):\n            if i >= len(arr):\n                return 0\n            if (tuple(letter_set), i) not in letters_dict:\n\n\n                if len(set(arr[i]).intersection(letter_set)) == 0 and (len(set(arr[i])) == len(arr[i])):\n                    letters_dict[(tuple(letter_set), i)] = max(\n                        dfs(letter_set.union(set(arr[i])), arr, i+1)+len(set(arr[i])), \n                        dfs(letter_set, arr, i+1))\n                else:\n                    letters_dict[(tuple(letter_set), i)] = dfs(letter_set, arr, i+1)\n            return letters_dict[(tuple(letter_set), i)]\n        \n        return dfs(set(), arr, 0)", "class Solution:   \n    \n    def maxLength(self, arr: List[str]) -> int:\n        arr_sets = [set(x) for x in arr]\n       \n        def buildSet(bitlist):\n            output = set()\n            for i, bit in enumerate(bitlist):\n                if bit:\n                    output = output.union(arr_sets[i])\n            return output\n        \n        def recurse(bitlist, index):\n            if index == len(arr):\n                return len(buildSet(bitlist))\n            \n            not_included = recurse(bitlist, index+1)\n            \n            if len(arr_sets[index]) != len(arr[index]) or buildSet(bitlist).intersection(arr_sets[index]):\n                return not_included\n            else:\n                \n                new_bitlist = bitlist[:]\n                new_bitlist[index] = 1\n                return max(not_included, recurse(new_bitlist, index+1))\n        \n        return recurse([0 for _ in arr], 0)\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        self.res = 0\n        \n        def walk(i, temp):\n            self.res = max(self.res, len(temp))\n            \n            for j in range(i, len(arr)):\n                if all(v <= 1 for v in list(collections.Counter(temp+arr[j]).values())):\n                    walk(j+1, temp+arr[j])\n            return\n        \n        walk(0, '')\n        return self.res\n            \n", "import collections\nclass Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        \n        self.m = collections.defaultdict(list)\n        \n        for ix_1 in range(len(arr)):\n            set_1 = set(list(arr[ix_1]))\n            for ix_2 in range(ix_1+1, len(arr)):\n                set_2 = set(list(arr[ix_2]))\n                if len(set_1) == len(arr[ix_1]) and len(set_2) == len(arr[ix_2]) and len(set_1.intersection(set_2)) == 0:\n                    self.m[ix_1].append(ix_2)\n                    #self.m[ix_2].append(ix_1)\n                    \n        self.ans = 0\n        for ix in range(len(arr)):\n            if len(set(list(arr[ix]))) == len(arr[ix]):\n                self.dfs(arr, [ix])\n        \n        return self.ans\n            \n    \n    def dfs(self, arr, visiting):\n        curr = visiting[-1]\n\n        l = [len(arr[i]) for i in visiting]\n        self.ans = max(sum(l), self.ans)\n        \n        if not self.m.get(curr):\n            return\n        \n        for i in self.m.get(curr):\n            if i in visiting:\n                continue\n                \n            possible = True\n            for j in visiting[:-1]:\n                if len(set(list(arr[i])).intersection(set(list(arr[j]))))>0:\n                    possible = False\n                    break\n                    \n            if possible:\n                visiting.append(i)\n                self.dfs(arr, visiting)\n                visiting.pop()\n\n                    \n            \n        \n                \n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        #array with all possible unique string combinations so far\n        possible_strings = ['']\n        maximum = 0\n        for i in range(len(arr)):\n            temp_len = len(possible_strings)\n            for j in range(temp_len):\n                #trying combination\n                x = arr[i] + possible_strings[j]\n                #string is unique\n                if (len(x)==len(set(x))):\n                    #append to possible strings\n                    possible_strings.append(x)\n                    #set max\n                    maximum = max(maximum,len(x))\n        return maximum\n\n", "class Solution:\n    \n    def is_unique(self, s):\n        return len(set(s)) == len(s)\n    \n    def maxLength(self, arr: List[str]) -> int:\n        \n        dct= {}\n        maxVal = 0\n        \n        for i in range(0, len(arr)):\n            if self.is_unique(arr[i]):\n                maxVal = max(maxVal, len(arr[i]))\n                \n            for j in range(i+1, len(arr)):\n                t = arr[i] + arr[j]\n                \n                if self.is_unique(t):\n                    arr.append(t)\n                    maxVal = max(maxVal, len(t))\n        # print(dct)\n        return maxVal", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        if len(arr)==1:\n            if len(set(arr[0]))==len(arr[0]):\n                return len(arr[0])\n            else:\n                return 0\n        \n        new_arr = []\n        for s in arr:\n            if len(s) == len(set(s)):\n                new_arr.append((set(s), len(s)))\n                \n        if not new_arr:\n            return 0\n        # print(new_arr)\n        ans = 0\n        \n        def backtrack(ind, temp, temp_sum):\n            nonlocal ans\n            if temp_sum > ans:\n                ans = temp_sum\n                \n            for i in range(ind, len(new_arr)):\n                if not (new_arr[i][0] & temp):\n                    backtrack(i+1, temp | new_arr[i][0], temp_sum+new_arr[i][1])\n                else:\n                    backtrack(i+1, temp, temp_sum)\n                    \n        backtrack(0, set(), 0)\n        return ans", "class Solution:\n    \n    def is_unique(self, s):\n        return len(set(s)) == len(s)\n    \n    def maxLength(self, arr: List[str]) -> int:\n        \n        dct= {}\n        maxVal = 0\n        \n        for i in range(0, len(arr)):\n            if self.is_unique(arr[i]):\n                maxVal = max(maxVal, len(arr[i]))\n                \n            for j in range(i+1, len(arr)):\n                t = arr[i] + arr[j]\n                \n                if self.is_unique(t):\n                    # print(t)\n                    arr.append(t)\n                    maxVal = max(maxVal, len(t))\n        # print(dct)\n        return maxVal", "class Solution:\n    \n    def is_unique(self, s):\n        return len(set(s)) == len(s)\n    \n    def maxLength(self, arr: List[str]) -> int:\n        maxVal = 0\n        \n        for i in range(0, len(arr)):\n            if self.is_unique(arr[i]):\n                maxVal = max(maxVal, len(arr[i]))\n                \n            for j in range(i+1, len(arr)):\n                t = arr[i] + arr[j]\n                \n                if self.is_unique(t):\n                    arr.append(t)\n                    maxVal = max(maxVal, len(t))\n        # print(dct)\n        return maxVal", "from collections import Counter\n\nclass Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        self.max_len = 0\n        for i, s in enumerate(arr):\n            self.bfs(Counter(s), arr, i)\n        return self.max_len\n    \n    def bfs(self, counter, arr, _index):\n        if max(counter.values()) > 1: return\n        if len(counter) > self.max_len:\n            self.max_len = len(counter)\n        \n        for i in range(_index + 1, len(arr)):\n            s = arr[i]\n            counter_copy = copy.copy(counter)\n            counter_copy.update(Counter(s))\n            self.bfs(counter_copy, arr, i)\n", "class Solution:\n    def maxLength(self, arr: List[str]) -> int:\n        res = 0\n        arr = list([x for x in arr if len(set(x))==len(x)])\n        arr = [set(x) for x in arr]\n        def dfs(n, s, l, cur):\n            nonlocal res\n            if n == l:\n                res = max(res, len(cur))\n                return\n            for i in range(s, len(arr)):\n                if len(cur.intersection(arr[i])) == 0:\n                    dfs(n, i+1, l+1, cur.union(arr[i]))\n                # new_cur = cur + arr[i]\n                # if len(set(new_cur)) != len(new_cur):\n                #     return\n                # dfs(n, i+1, l+1, new_cur)\n        for i in range(len(arr)+1):\n            dfs(i, 0, 0, set())\n        return res\n"]
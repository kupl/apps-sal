["import math\np=7+10**9\nn,k=list(map(int,input().split()))\nc=math.factorial(n+k-1)//((math.factorial(k))*(math.factorial(n-1)))\nprint(c%p)\n", "from math import *\n \n# Function to find the nCr \ndef printNcR(n, r): \n \n # p holds the value of n*(n-1)*(n-2)..., \n # k holds the value of r*(r-1)... \n p = 1\n k = 1\n \n # C(n, r) == C(n, n-r), \n # choosing the smaller value \n if (n - r < r): \n  r = n - r \n \n if (r != 0):  \n  while (r): \n   p *= n \n   k *= r \n \n   # gcd of p, k \n   m = gcd(p, k) \n \n   # dividing by gcd, to simplify product \n   # division by their gcd saves from the overflow \n   p //= m \n   k //= m \n \n   n -= 1\n   r -= 1\n \n  # k should be simplified to 1 \n  # as C(n, r) is a natural number \n  # (denominator should be 1 )  \n \n else: \n  p = 1\n \n # if our approach is correct p = ans and k =1 \n return p\n \nn,k=map(int,input().split())\nprint(int(printNcR(n+k-1,k)%(1000000000+7)))", "import numpy as np\nMOD = 1000000007\n\nN,K = list(map(int,input().split()))\na = np.ones(N)\n\nfor i in range(K-1):\n a = np.cumsum(a)\n a = np.mod(a,MOD)\nprint(int(np.sum(a)) % MOD)\n", "def ncr(n, r, p): \n num = den = 1 \n for i in range(r): \n  num = (num * (n - i)) % p \n  den = (den * (i + 1)) % p \n return (num * pow(den, p - 2, p)) % p \na,b=map(int,input().split())\nm=10**9+7\nprint(ncr(a+b-1,b,m))", "# cook your dish here\nimport math\n\nmod = 10**9 + 7\n\ndef main():\n N,K = list(map(int,input().split()))\n dp = [1]*(K+1)\n for j in range(1,N):\n  val = 1\n  for i in range(1,K+1):\n   dp[i] = (dp[i-1] + dp[i])%mod\n print(dp[K])\n \ndef __starting_point():\n main()\n\n__starting_point()", "import math\nk,n=map(int,input().split())\nx=10**9+7\nprint((math.factorial(n+k-1)//(math.factorial(k-1)*math.factorial(n)))%x)", "# cook your dish here\n# import sys\n# sys.stdin = open('input.txt', 'r') \n# sys.stdout = open('output.txt', 'w')\n\nimport math\nimport collections\nfrom sys import stdin,stdout,setrecursionlimit\nimport bisect as bs\nsetrecursionlimit(2**20)\nM = 10**9+7\n\ndef nCrModp(n, r, p): \n if (r > n- r): \n  r = n - r \n C = [0 for i in range(r + 1)] \n \n C[0] = 1\n \n for i in range(1, n + 1): \n  for j in range(min(i, r), 0, -1): \n   C[j] = (C[j] + C[j-1]) % p \n \n return C[r] \n \n\n# T = int(stdin.readline())\n# for _ in range(T):\n # n = int(stdin.readline())\nn,k = list(map(int,stdin.readline().split()))\n # a = list(map(int,stdin.readline().split()))\n # q = list(map(int,stdin.readline().split()))\n # b = list(map(int,stdin.readline().split()))\n # a = stdin.readline().strip('\\n')\nN = n+k-1\nR = n-1\nprint(nCrModp(N,R,M))", "MOD = 10 ** 9 + 7\n\nn, k = map(int, input().split())\n\npre = [[0] * k for _ in range(n+1)]\n\nfor i in range(1, n+1):\n pre[i][0] = i\n for j in range(1, k):\n  pre[i][j] = (pre[i-1][j] + pre[i][j-1]) % MOD\n\nprint(pre[n][k-1])", "# Python3 function to \n# calculate nCr % p \ndef ncr(n, r, p): \n # initialize numerator \n # and denominator \n num = den = 1\n for i in range(r): \n  num = (num * (n - i)) % p \n  den = (den * (i + 1)) % p \n return (num * pow(den, \n   p - 2, p)) % p \nM=10**9+7\nN,K=map(int,input().split())\nans=0\nfor i in range(N,0,-1):\n ans+=ncr(N-i+K-1,K-1,M)\n ans%=M\nprint(ans) ", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(3000)\n\nR = lambda t = int: t(eval(input()))\nRL = lambda t = int: [t(x) for x in input().split()]\nRLL = lambda n, t = int: [RL(t) for _ in range(n)]\n\n\nMOD = 10**9 + 7\n \ndef divc(x):\n return pow(x, MOD-2, MOD)\n \ndef C(n,k):\n r = 1\n for i in range(k + 1, n+1):\n  r = r * i % MOD\n t = 1\n for i in range(1,n-k+1):\n  t = t * i % MOD\n return r * divc(t) % MOD\n\ndef solve():\n N, K = RL()\n print(C(K+N-1,N-1)) \n\nT = 1\nfor t in range(1, T + 1):\n solve()\n", "from math import factorial as fact\nmod = 10**9 + 7\n\ndef C(n, k):\n return (fact(n) // (fact(k) * fact(n - k)))\n\nn, m = map(int, input().split())\nprint(C(n + m - 1, m) % mod)"]
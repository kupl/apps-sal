["class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         target,rem=divmod(sum(nums),k)\n         if rem or max(nums)>target: return False\n         n=len(nums)\n         seen=[0]*n\n         nums.sort(reverse=True)\n         \n         def dfs(k,index,current_sum):\n             if k==1:\n                 return True\n             \n             if current_sum==target:\n                 return dfs(k-1,0,0)\n             for i in range(index,n):\n                 if not seen[i] and current_sum+nums[i]<=target:\n                     seen[i]=1\n                     if dfs(k,i+1,current_sum+nums[i]):\n                         return True\n                     seen[i]=0\n             return False\n         \n         return dfs(k,0,0)\n", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         quotient = sum(nums)/k\n         if quotient % 1 != 0:\n             return False\n         \n         for num in nums:\n             if num > quotient:\n                 return False\n             if num == quotient:\n                 nums.remove(quotient)\n                 k -= 1\n         nums.sort(reverse=True)\n         self.nums = nums\n         self.quotient = quotient\n         print(self.nums)\n         \n         answer = self.dfs([0]*len(nums), 0, k)\n         return answer\n #        print(answer)\n     \n     def dfs(self, visit, accu, k):\n         if k == 1:\n #            print(visit)\n             return True\n         \n         for i in range(len(self.nums)):\n             if not visit[i]:\n                 #print(visit)\n                 if self.nums[i] + accu < self.quotient:\n                     visit[i] = 1\n                     if self.dfs(visit, self.nums[i] + accu, k):\n                         return True\n                     visit[i] = 0\n                 if self.nums[i] + accu == self.quotient:\n                     visit[i] = 1\n                     accu = self.nums[i] + accu\n                     return self.dfs(visit, 0, k-1)\n         return False", "class Solution:\n     def partition(self, nums, target, current, pos, fill):\n         if fill == 0:\n             return True\n         for i in range(pos, len(nums)):\n             next = nums[:i] + nums[i+1:]\n             if current + nums[i] == target:\n                 if self.partition(next, target, 0, 0, fill - 1):\n                     return True\n             elif current + nums[i] < target:\n                 if self.partition(next, target, current + nums[i], i, fill):\n                     return True\n             elif current == 0:\n                 return False\n         return False\n     \n     \n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         s = sum(nums)\n         if s % k > 0:\n             return False\n         target = s // k\n         \n         return self.partition(nums, target, 0, 0, k)", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         if sum(nums) % k or len(nums) < k: return False\n         if k == 1: return True\n         target, used = sum(nums) / k, [False for i in range(len(nums))]\n \n         def dfs(start, sum_, k):\n             if k == 1:\n                 return True\n             if sum_ == target:\n                 return dfs(0, 0, k - 1)\n             for i in range(start, len(nums)):\n                 if not used[i] and sum_ < target:\n                     used[i] = True\n                     if dfs(i + 1, sum_ + nums[i], k):\n                         return True\n                     used[i] = False\n             return False\n         return dfs(0, 0, k)", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         if sum(nums) % k or len(nums) < k: return False\n         if k == 1: return True\n         target, used = sum(nums) / k, [False for i in range(len(nums))]\n \n         def dfs(start, sum_, k):\n             if k == 1: return True\n             if sum_ == target: return dfs(0, 0, k - 1)\n             for i in range(start, len(nums)):\n                 if not used[i] and sum_ < target:\n                     used[i] = True\n                     if dfs(i + 1, sum_ + nums[i], k):\n                         return True\n                     used[i] = False\n             return False\n         return dfs(0, 0, k)\n \n", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         target, rem = divmod(sum(nums), k)\n         if rem: return False\n         \n         def dfs(groups):\n             if not nums: return True\n             v = nums.pop()\n             for i, group in enumerate(groups):\n                 if group + v <= target:\n                     groups[i] += v\n                     if dfs(groups): return True\n                     groups[i] -= v\n                 if not group: break\n             nums.append(v)\n             return False\n         \n         nums.sort()\n         if nums[-1] > target: return False\n         while nums and nums[-1] == target:\n             k -= 1\n             nums.pop()\n         return dfs([0] * k)\n", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         total = sum(nums)\n         if total%k != 0: return False\n         target = total//k\n         nums.sort()\n         if nums[-1] > target:\n             return False\n         while nums and nums[-1] == target:\n             nums.pop()\n             k -= 1\n         \n         return self.helper(nums, target, [0]*k)\n     \n     def helper(self, nums, target, dp):\n         if not nums: return True\n         num = nums.pop()\n         for i in range(len(dp)):\n             if dp[i] + num <= target:\n                 dp[i] += num\n                 if self.helper(nums, target, dp):\n                     return True\n                 dp[i] -= num\n             if dp[i] == 0:\n                 break\n         nums.append(num)\n         return False", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         \n         if not nums:\n             return True\n         \n         if sum(nums) % k != 0:\n             return False\n         \n         target = sum(nums) / k\n         \n         nums.sort()\n         \n         if nums[-1] > target:\n             return False\n         \n         while nums and nums[-1] == target:\n             nums.pop()\n             k -= 1\n         \n         def partition(nums, subsets, target):\n             if not nums:\n                 return True\n             selected = nums.pop()\n             for i in range(len(subsets)):\n                 if subsets[i] + selected <= target:\n                     subsets[i] += selected\n                     if partition(nums, subsets, target):\n                         return True\n                     subsets[i] -= selected\n                 if subsets[i] == 0:\n                     # this line is important, otherwise TLE.\n                     # if subsets[i] is 0 then later subsets are all zeros. No need to try them all.\n                     break\n             nums.append(selected)\n             return False\n         \n         return partition(nums, subsets=[0]*k, target=target)", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         total = sum(nums)\n         if total%k!=0:\n             return False\n         target = total/k\n         \n         used = [False]*len(nums)\n         nums = sorted(nums)\n         # print(nums)\n         def check(nums, k, cur, pos):\n             # print(used, k, cur, pos)\n             if k==1:\n                 return True\n             for i in range(pos, -1, -1):\n                 if not used[i]:\n                     if nums[i]+cur<target:\n                         used[i] = True\n                         if check(nums, k, cur+nums[i], i-1):\n                             return True\n                         used[i] = False\n                     elif nums[i]+cur==target:\n                         used[i] = True\n                         if check(nums, k-1, 0, len(nums)-1):\n                             return True\n                         used[i] = False\n             return False\n         return check(nums, k, 0, len(nums)-1)", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         target, rem = divmod(sum(nums), k)\n         if rem: return False\n \n         def search(groups):\n             if not nums: return True\n             v = nums.pop()\n             for i, group in enumerate(groups):\n                 if group + v <= target:\n                     groups[i] += v\n                     if search(groups): return True\n                     groups[i] -= v\n                 if not group: break\n             nums.append(v)\n             return False\n \n         nums.sort()\n         if nums[-1] > target: return False\n         while nums and nums[-1] == target:\n             nums.pop()\n             k -= 1\n \n         return search([0] * k)", "class Solution(object):\n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         he = sum(nums)\n         if he % k != 0:\n             return False\n         target = he // k\n         visit = [0 for _ in range(len(nums))]\n         def dfs(k,ind,cur,cnt):\n             if k == 0:return True\n             if cur == target and cnt > 0:\n                 return dfs(k-1,0,0,0)\n             for i in range(ind,len(nums)):\n                 if not visit[i] and cur+nums[i] <= target:\n                     visit[i] = 1\n                     if dfs(k,i+1,cur+nums[i],cnt+1):\n                         return True\n                     visit[i] = 0\n             return False\n         return dfs(k,0,0,0)", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         total = sum(nums)\n         if total % k != 0:\n             return False\n         subsetTotal = total // k\n         visited = [0] * len(nums)\n         return self.helper(k, 0, 0, visited, nums, k, subsetTotal)\n     \n     def helper(self, remainingSets, index, s, visited, nums, k, subsetTotal):\n         if remainingSets == 1:\n             return True\n         if s == subsetTotal:\n             return self.helper(remainingSets - 1, 0, 0, visited, nums, k, subsetTotal)\n         for i in range(index, len(nums)):\n             if visited[i] == 0 and s + nums[i] <= subsetTotal:\n                 visited[i] = 1\n                 if self.helper(remainingSets, i + 1, s + nums[i], visited, nums, k, subsetTotal):\n                     return True\n                 visited[i] = 0\n         return False", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         tot = sum(nums)\n         if k <= 0 or tot % k != 0:\n             return False\n         visited = [0] * len(nums)\n         def canPart(nums, visited, idx, curSum, k, target):\n             if k == 1:\n                 return True\n             if curSum == target: return canPart(nums, visited, 0, 0, k - 1, target)\n             if curSum > target:\n                 return False\n             for i in range(idx, len(nums)):\n                 if not visited[i]:\n                     visited[i] = 1\n                     if canPart(nums, visited, i + 1, curSum + nums[i], k, target):\n                         return True\n                     visited[i] = 0\n             return False\n         \n         return canPart(nums, visited, 0, 0, k, tot / k)\n", "class Solution:\n     def canPartitionKSubsets(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: bool\n         \"\"\"\n         if k <= 0:\n             return False\n         nums_sum = sum(nums)\n \n         if nums_sum % k != 0:\n             return False\n \n         visited = [False] * len(nums)\n         \n         nums.sort(reverse=True)\n \n         return self.canPartition(nums, visited, k, 0, 0, nums_sum/k)\n \n     def canPartition(self, nums, visited, k, currentIndex, currentSum, target):\n         if k == 1: \n             return True\n \n         if currentSum == target:\n             return self.canPartition(nums, visited, k-1, 0, 0, target)\n         \n         \n         for i in range(currentIndex, len(nums)):\n             if visited[i] is False and currentSum + nums[i] <= target:\n                 visited[i] = True\n                 if(self.canPartition(nums, visited, k, i+1, currentSum + nums[i], target)):\n                     return True\n                 visited[i] = False\n         \n         return False\n"]
["class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        N = len(A)\n        dp = [[0]*N for _ in range(N)]\n        \n        for i in range(N-2, -1, -1):\n            for j in range(i+2, N):\n                dp[i][j] = min(dp[i][k]+dp[k][j]+A[i]*A[j]*A[k] for k in range(i+1, j))\n                \n        return dp[0][-1]\n                    \n                \n", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        memo = [[0] * len(A) for _ in range(len(A))]\n        for i in reversed(range(len(A))):\n            for j in range(i + 2, len(A)):\n                memo[i][j] = min(memo[i][k] + A[i] * A[k] * A[j] + memo[k][j] for k in range(i + 1, j))\n        return memo[0][-1]", "from functools import lru_cache\n\nclass Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        # If we pick a side of our polygon, it can form n - 2 triangles. Each such triangle forms 2 sub-polygons. We can analyze n - 2 triangles, and get the minimum score for sub-polygons using the recursion.\n\n        # n = len(A)\n        # dp = [[0] * n for _ in range(n)]\n        # for d in range(2, n):\n        #     for i in range(n - d):\n        #         j = i + d\n        #         dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[j] * A[k] for k in range(i + 1, j))\n        # return dp[0][n - 1]\n\n\n        @lru_cache(None)\n        def dp(i, j):\n            return min([dp(i, k) + dp(k, j) + A[i] * A[k] * A[j] for k in range(i + 1, j)] or [0])\n        return dp(0, len(A) - 1)\n", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        @lru_cache(maxsize=None)\n        def helper(start, end):\n            if start + 1 == end:\n                return 0\n            \n            result = 0\n            for k in range(start + 1, end):\n                result = min(float('inf') if result == 0 else result,\n                            helper(start, k) +\n                            A[start] * A[k] * A[end] +\n                            helper(k, end))\n            return result\n        return helper(0, len(A) - 1)", "class Solution:\n    def minScoreTriangulation(self, a: List[int]) -> int:\n        n = len(a)\n        dp = [[float('inf')]*n for _ in range(n)]\n        for l in range(2, n):\n            for i in range(n-l):\n                j = i + l                \n                for k in range(i+1, j):\n                    dp[i][j] = min(dp[i][j], (dp[i][k] if k >= i + 2 else 0) + a[i]*a[k]*a[j]  + (dp[k][j] if j >= k + 2 else 0))\n        return dp[0][n-1]", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        n = len(A)\n        dp = [[float('inf')]*n for _ in range(n)]\n        for l in range(2, n):\n            for i in range(n-l):\n                j = i + l                \n                for k in range(i+1, j):\n                    dp[i][j] = min(dp[i][j], (dp[i][k] if k >= i + 2 else 0) + A[i]*A[k]*A[j]  + (dp[k][j] if j >= k + 2 else 0))\n        return dp[0][n-1]", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        n = len(A)\n        dp = [[0] * n for i in range(n)]\n        for d in range(2, n):\n            for i in range(n - d):\n                j = i + d\n                dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[j] * A[k] for k in range(i + 1, j))\n        return dp[0][n - 1]", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        @lru_cache(None)\n        def dfs(i, j):\n            if j < i + 2:\n                return 0\n            result = 10 ** 9\n            for k in range(i + 1, j):\n                result = min(result, A[i] * A[k] * A[j] + dfs(i, k) + dfs(k, j))\n            return result\n        n = len(A)\n        return dfs(0, n - 1)", "class Solution:\n#     https://www.youtube.com/watch?v=eKkXU3uu2zk\n    def minScoreTriangulation(self, a: List[int]) -> int:\n        n = len(a)\n        dp = [[(float('inf') if i-j>2 else 0)  for i in range(len(a))]for j in range(len(a)) ]\n        for i in range(2, len(dp)):\n            dp[i-2][i]=a[i-2]*a[i-1]*a[i]\n\n        for l in range(3, len(dp)):\n            for i in range(0, n-l):\n                j= l+i\n                if j>n:\n                    break\n                for k in range(i+1,j):\n                    dp[i][j]=min(dp[i][j], a[k]*a[i]*a[j] + dp[i][k]+dp[k][j])\n                    \n        return dp[0][-1]\n                    \n                \n", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        n = len(A)\n        dp = [[0] * n for i in range(n)]\n        \n        for d in range(2, n):\n            for i in range(n - d):\n                j = i + d\n                dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[j] * A[k] for k in range(i + 1, j))\n        return dp[0][n - 1]", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        N = len(A)\n        dp = [\n            [0 for j in range(N)] for i in range(N)\n        ]\n        \n        for l in range(3, N + 1):\n            for i in range(N - l + 1):\n                j = i + l - 1\n                for k in range(i + 1, j):\n                    val = dp[i][k] + dp[k][j] + A[i] * A[k] * A[j]\n                    if not dp[i][j] or dp[i][j] > val:\n                        dp[i][j] = val\n        return dp[0][N - 1]\n", "class Solution:\n    def minScoreTriangulation(self, a: List[int]) -> int:\n        n = len(a)\n        dp = [[(float('inf') if i-j>2 else 0)  for i in range(len(a))]for j in range(len(a)) ]\n        for i in range(2, len(dp)):\n            dp[i-2][i]=a[i-2]*a[i-1]*a[i]\n\n        for l in range(3, len(dp)):\n            for i in range(0, n-l):\n                j= l+i\n                if j>n:\n                    break\n                for k in range(i+1,j):\n                    dp[i][j]=min(dp[i][j], a[k]*a[i]*a[j] + dp[i][k]+dp[k][j])\n                    \n        return dp[0][-1]\n                    \n                \n", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        def dfs(nums, i, j):\n            if j-i <= 1:\n                return 0\n            \n            if dp[i][j] != 0:\n                return dp[i][j]\n            \n            ans = sys.maxsize\n            for k in range(i+1, j):    # burst ith element\n                ans = min(ans, dfs(nums, i, k) + dfs(nums, k, j) + nums[i]*nums[k]*nums[j])\n                \n            dp[i][j] = ans\n            return ans\n        \n        n = len(A)\n        dp = [[0] * n for _ in range(n)]\n        total = dfs(A, 0, len(A)-1)\n        return total", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        n = len(A)\n        dp = [[0 for i in range(n)]for j in range(n)]\n        for length in range(2,n):\n            for i in range(n-length):\n                j = i+length\n                dp[i][j] = math.inf\n                for k in range(i+1,j):\n                    dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]+(A[i]*A[k]*A[j]))\n        return sum(A) if dp[0][n-1]==math.inf else dp[0][n-1]", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        memo = {}\n        def dp(i, j):\n            if (i, j) not in memo:\n                memo[i, j] = min([dp(i, k) + dp(k, j) + A[i] * A[j] * A[k] for k in range(i + 1, j)] or [0])\n            return memo[i, j]\n        return dp(0, len(A) - 1)\n        \n                                                                                              \n        \n        \n        \n        \n", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        \n        table=[[-1 for i in range(len(A))] for j in range(len(A))]\n    \n        def recursion(x=0,y=len(A)-1,A:list=A):\n            if y-x<=1:\n                return 0\n            \n            if table[x][y]!=-1:\n                return table[x][y]\n            else:\n                m=float('inf')\n                for i in range(x+1,y):\n                    m=min(m,recursion(x,i,A)+recursion(i,y,A)+A[x]*A[y]*A[i])\n                table[x][y]=m\n                return m\n        \n        return recursion()\n", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        memo = {}\n        def dp(i, j):\n            if (i, j) not in memo:\n                memo[i, j] = min([dp(i, k) + dp(k, j) + A[i] * A[j] * A[k] for k in range(i+1, j)] or [0])\n            return memo[i, j]\n        return dp(0, len(A) - 1)", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        \n        def get(l, r):\n            if r - l == 1:\n                return 0\n            if (l, r) in d:\n                return d[(l, r)]\n            res = min([A[l] * A[r] * A[i] + get(l, i) + get(i, r) for i in range(l + 1, r)])\n            d[(l, r)] = res\n            return res\n        \n        d = {}\n        return get(0, len(A) - 1)\n", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        if len(A) == 3:\n            return A[0]*A[1]*A[2]\n            \n        n = len(A)\n        dp = [[float('inf') for j in range(n)] for i in range(n)]\n        def helper(i, j):\n            if j-i<=1:\n                return 0\n            \n            if dp[i][j] != float('inf'):\n                return dp[i][j]\n            \n            res = float('inf')\n            for k in range(i+1, j):\n                res = min(res, \n                          helper(i, k) + A[i]*A[k]*A[j] + helper(k, j))\n                \n            dp[i][j] = res\n            return dp[i][j] \n        \n        return helper(0, n-1)", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        N = len(A)\n        if N == 3: return A[0]*A[1]*A[2]\n        \n        def solver(s,t, A):\n            if t-s+1 < 3: return 0\n            \n            if dp[s][t] != float('inf'): return dp[s][t]\n            \n\n            for i in range(s+1, t):\n                dp[s][t] = min(dp[s][t], solver(s,i, A) + A[s]*A[i]*A[t] + solver(i,t, A))\n        \n            return dp[s][t]\n        \n        dp = []\n        for i in range(N):\n            dp.append([float('inf')]*N)\n        \n        \n        return solver(0,N-1,A)\n        \n", "class Solution:\n    def minScoreTriangulation_v2(self, A: List[int]) -> int:\n      length = len(A)\n      DP = [[float('inf')] * length for _ in range(len(A))]\n      for e in range(2, length):\n        for i in range(length - e):\n          j = i + e\n          for k in range(i+1, j):\n            left_point = DP[i][k] if k >= i + 2 else 0\n            right_point = DP[k][j] if j >= k + 2 else 0\n            DP[i][j] = min(DP[i][j], left_point + A[i] * A[j] * A[k] + right_point)\n      return DP[0][len(A)-1]\n\n    def minScoreTriangulation(self, A: List[int]) -> int:\n      length = len(A)\n      memo = [[float('inf')] * length for _ in range(len(A))]\n        \n      def memo_dp(start, end):\n        if end - start < 2:\n          return 0\n        if end - start == 2:\n          memo[start][end] = A[start] * A[start+1] * A[end]\n          return memo[start][end]\n        if memo[start][end] != float('inf'):\n          return memo[start][end]\n        \n        val = memo[start][end]\n        for i in range(start+1, end):\n            val = min(val, A[start] * A[i] * A[end] + memo_dp(start, i) + memo_dp(i, end))\n        memo[start][end] = val\n        return memo[start][end]\n        \n      memo_dp(0, length-1)\n      return memo[0][length-1]", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        def dfs(nums, i, j):\n            if j-i <= 1:\n                return 0\n            \n            key = tuple([i, j])\n            if key in dp:\n                return dp[key]\n            \n            ans = sys.maxsize\n            for k in range(i+1, j):    # burst ith element\n                ans = min(ans, dfs(nums, i, k) + dfs(nums, k, j) + nums[i]*nums[k]*nums[j])\n                \n            dp[key] = ans\n            return ans\n        \n        dp = {}\n        total = dfs(A, 0, len(A)-1)\n        return total", "def tri_score(a1,a2,a3):\n    return a1*a2*a3\n\nclass Solution:\n    def __init__(self):\n        self.memory = []\n    def minScoreTriangulation(self, A) -> int:\n        n=len(A)\n        self.memory=[[None for _ in range(n)] for _ in range(n)]\n        return self.minScoreTriangulationPart(A,0,len(A)-1)\n\n    def minScoreTriangulationPart(self, A, start: int, end: int) -> int:\n        if end-start<2:\n            return 0\n        elif self.memory[start][end]:\n            return self.memory[start][end]\n        elif end-start==2:\n            res = tri_score(A[start],A[start+1],A[start+2])\n            self.memory[start][end] = res\n            return res\n        res = min(tri_score(A[start],A[end],A[k])+self.minScoreTriangulationPart(A,start,k)+self.minScoreTriangulationPart(A,k,end) for k in range(start+1,end))\n        self.memory[start][end] = res\n        return res", "def tri_score(a1,a2,a3):\n    return a1*a2*a3\n\nclass Solution:\n    def __init__(self):\n        self.memory = []\n    def minScoreTriangulation(self, A) -> int:\n        n=len(A)\n        self.memory=[[None for _ in range(j+1)] for j in range(n)]\n        return self.minScoreTriangulationPart(A,0,len(A)-1)\n\n    def minScoreTriangulationPart(self, A, start: int, end: int) -> int:\n        if end-start<2:\n            return 0\n        elif self.memory[end][start]:\n            return self.memory[end][start]\n        elif end-start==2:\n            res = tri_score(A[start],A[start+1],A[start+2])\n            self.memory[end][start] = res\n            return res\n        res = min(tri_score(A[start],A[end],A[k])+self.minScoreTriangulationPart(A,start,k)+self.minScoreTriangulationPart(A,k,end) for k in range(start+1,end))\n        self.memory[end][start] = res\n        return res", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        memo = {}\n        def dp(i, j):\n            if (i, j) not in memo:\n                memo[i, j] = min([dp(i, k) + dp(k, j) + A[i] * A[j] * A[k] for k in range(i + 1, j)] or [0])\n            return memo[i, j]\n        return dp(0, len(A) - 1)\n", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        dp = {}\n        def recursive_helper(left, right):\n            if left > right:\n                return 0\n            # B/C for when invalidation\n            \n            pair = (left, right)\n            if pair in dp:\n                return dp[pair]\n            dp[pair] = float('inf')\n            for k in range(left+1, right):\n                dp[pair] = min(dp[pair], recursive_helper(left, k) + recursive_helper(k, right) + A[left] * A[k] * A[right])\n            \n            if dp[pair] == float('inf'):\n                dp[pair] = 0\n            # Fix k, and try to traingulate on left side and right side\n            \n            #dp[pair] = min([recursive_helper(left, k) + recursive_helper(k, right) + A[left] * A[k] * A[right] for k in range(left + 1, right)] or [0])\n            \n            return dp[pair]\n        \n        return recursive_helper(0, len(A) - 1)\n        \n        # COmpelxity is O(n^3), Space is O(n^2)\n", "class Solution:\n    \n    \n    def minScoreTriangulation(self, A: List[int]) -> int:\n        \n        #dp = [[0 for i in range(50)] for j in range(50)]\n        dp = dict()\n        def helper(i, j):\n            if (i, j) in dp:\n                return dp[(i, j)]\n            \n            if j-i <= 1:\n                dp[(i, j)] = 0\n                return dp[(i, j)]\n            \n            minval = float('inf')\n            for k in range(i+1, j):\n                #print(i, k, j, A[i]*A[j]*A[k])\n                val = helper(i, k) + helper(k, j) + A[i]*A[j]*A[k]\n                minval = min(minval, val)\n            dp[(i, j)] = minval\n            #print(i, j, minval)\n            return dp[(i, j)]\n        \n        return helper(0, len(A)-1)\n    \n    def minScoreTriangulation3(self, A: List[int]) -> int:\n        \n        if len(A) < 3:\n            return 0\n        \n        if len(A) == 3:\n            return A[0]*A[1]*A[2]\n        \n        def multi_array(B, j):\n            #print(B[j%len(B)],B[(j+1)%len(B)],B[(j+2)%len(B)])\n            return B[j%len(B)]*B[(j+1)%len(B)]*B[(j+2)%len(B)]\n        \n        # \n        sum1, sum2 = 0, 0\n        A_copy = A.copy()\n        sum1 += multi_array(A, 0)\n        A_copy.pop(1)\n        sum1 += self.minScoreTriangulation(A_copy)\n        \n        sum1 += multi_array(A, len(A)-1)\n        A.pop(0)\n        sum2 += self.minScoreTriangulation(A_copy)\n        \n        return min(sum1, sum2)\n    \n    def minScoreTriangulation2(self, A: List[int]) -> int:\n        \n        if len(A) < 3:\n            return 0\n        \n        if len(A) == 3:\n            return A[0]*A[1]*A[2]\n        \n        def multi_array(B, j):\n            print(B[j%len(B)],B[(j+1)%len(B)],B[(j+2)%len(B)])\n            return B[j%len(B)]*B[(j+1)%len(B)]*B[(j+2)%len(B)]\n        \n        # \n        sum1, sum2 = 0, 0\n        next_A = []\n        for i in range(len(A)//2):\n            sum1 += multi_array(A, i*2)\n            print(i, sum1, multi_array(A, i*2))\n            next_A.append(A[(i*2)%len(A)])\n           \n        #print(i, i*2, )\n        if (i*2+2)%len(A) != 0:\n            next_A.append(A[(i*2+2)%len(A)])\n            \n        print(next_A, sum1)\n        sum1 += self.minScoreTriangulation(next_A)\n            \n        print(sum1, '\\\n')\n        val = A.pop(0)\n        A.append(val)\n        next_A = []\n        for i in range(len(A)//2):\n            \n            sum2 += multi_array(A, i*2)\n            print(i, sum2)\n            next_A.append(A[(i*2)%len(A)])\n        if (i*2+2)%len(A) != 0:\n            next_A.append(A[(i*2+2)%len(A)])\n        print(next_A, sum2)\n        sum2 += self.minScoreTriangulation(next_A)\n        \n        return min(sum1, sum2)", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        \n        \n        def helper(i, j):\n            key = (i, j)\n            if key in d:\n                return d[key]\n            if j - i < 2:\n                return 0\n            ans = float('inf')\n            \n            for k in range(i+1, j):\n                \n                lans = helper(i, k)\n                rans = helper(k , j)\n                ans = min(ans, lans + rans + A[i]*A[j]*A[k])\n            d[key] = ans\n            return d[key]\n        d = dict()\n        return helper(0, len(A) - 1)\n            \n", "from functools import lru_cache\n\nclass Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        n = len(A)\n        dp = [[0] * n for _ in range(n)]\n        for d in range(2, n):\n            for i in range(n - d):\n                j = i + d\n                dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[j] * A[k] for k in range(i + 1, j))\n        return dp[0][n - 1]\n", "class Solution:\n    def minScoreTriangulation(self, A: List[int]) -> int:\n        n = len(A)\n        dp = [[0] * n for i in range(n)]\n        for d in range(2, n):\n            for i in range(n - d):\n                j = i + d\n                dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[j] * A[k] for k in range(i + 1, j))\n        return dp[0][n - 1]\n        \n                                                                                              \n        \n        \n        \n        \n"]
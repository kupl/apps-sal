["class Solution:\n     def fallingSquares(self, positions):\n         \"\"\"\n         :type positions: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         height = [0]\n         pos = [0]\n         res = []\n         max_h = 0\n         for left, side in positions:\n             i = bisect.bisect_right(pos, left)\n             j = bisect.bisect_left(pos, left + side)\n             high = max(height[i - 1:j] or [0]) + side\n             pos[i:j] = [left, left + side]\n             height[i:j] = [high, height[j - 1]]\n             max_h = max(max_h, high)\n             res.append(max_h)\n         return res        ", "class Solution:\n     def fallingSquares(self, positions):\n         \"\"\"\n         :type positions: List[List[int]]\n         :rtype: List[int]\n         \"\"\"\n         to_cor = {}\n         for x, l in positions:\n             to_cor[x] = 1\n             to_cor[x+l] = 1\n         for i, v in enumerate(sorted(to_cor.keys())):\n             to_cor[v] = i\n         over = Overlapper(len(to_cor))\n         ans = []\n         mx = 0\n         for x, l in positions:\n             tmx = over.getMax(to_cor[x], to_cor[x+l])+l\n             mx = max(mx, tmx)\n             ans.append(mx)\n             over.Update(to_cor[x], to_cor[x+l], tmx)\n         return ans\n         \n         \n class Overlapper:\n     def __init__(self, n):\n         self.line = [0]*n\n     \n     def getMax(self, a, b):\n         return max(self.line[a:b])\n     \n     def Update(self, a, b, mx):\n         self.line[a:b] = [mx]*(b-a)", "class Solution:\n     def fallingSquares(self, positions):\n         \"\"\"\n         :type positions: List[List[int]]\n         :rtype: List[int]\n         \n         COORDINATE COMPRESSION IS THE WAY TO GO - CHECKOUT OFFICAL LEETCODE ANSWER.  THIS WORKS TOO.\n         \"\"\"\n #         if positions == []: return []\n #         def overlap(int1, int2):\n #             return not (int1[0] > int2[1] or int1[1] < int2[0])\n \n # #       sorted disjoint interval list\n #         ints = [positions[0][0], positions[0][0]+positions[0][1]-1] # forgot to make this x+y-1 - wrote y\n #         intheights = {(positions[0][0], positions[0][0]+positions[0][1]-1): positions[0][1]} # same as above\n #         maxheights = [positions[0][1]]\n         \n #         for i in range(1, len(positions)):\n #             # print(positions[i], ints, intheights)\n #             start2 = positions[i][0]\n #             end2 = positions[i][0] + positions[i][1] - 1\n             \n #             leftpos = bisect.bisect_left(ints, start2)\n #             rightpos = bisect.bisect_right(ints, end2)\n #             newints = ints[:(leftpos // 2 * 2)]\n #             if leftpos % 2 == 1:\n #                 newints.append(ints[leftpos-1])\n #                 newints.append(start2-1)\n #                 intheights[(ints[leftpos-1], start2-1)] = intheights[(ints[leftpos-1], ints[leftpos])]\n             \n #             left = leftpos // 2 * 2\n #             right = (rightpos + 1) // 2 * 2\n #             maxSoFar = 0\n #             lastheight = 0\n #             while left < right:\n #                 maxSoFar = max(maxSoFar, intheights[(ints[left], ints[left+1])])\n #                 lastheight = intheights[(ints[left], ints[left+1])]\n #                 del intheights[(ints[left], ints[left+1])]\n #                 left += 2\n             \n #             newints.append(start2)\n #             newints.append(end2)\n #             intheights[(start2, end2)] = maxSoFar + (end2-start2+1)\n #             maxheight = max(maxheights[-1], intheights[(start2, end2)])\n #             maxheights.append(maxheight)\n \n #             if rightpos % 2 == 1:\n #                 newints.append(end2+1)\n #                 newints.append(ints[rightpos])\n #                 intheights[(end2+1, ints[rightpos])] = lastheight\n #             newints.extend(ints[right:])  # forgot this line\n #             ints = newints\n             \n             \n #         return maxheights\n         ints = []\n         for left, size in positions:\n             ints.append(left)\n             ints.append(left+size-1)\n         \n         index = {num:idx for idx, num in enumerate(sorted(ints))}\n         heights = [0]*2*len(positions)\n         \n         def query(left, right):\n             return max(heights[index[left]: index[right]+1])\n         \n         def updateHeights(left, right, newheight):\n             for i in range(index[left], index[right]+1):\n #                 no need for max here.  You are updating unless the height is negative\n                 heights[i] = newheight\n         \n         maxheights = []\n         for left, size in positions:\n             right = left+size -1\n             newheight = query(left, right) + size\n             updateHeights(left, right, newheight)\n             if not maxheights or maxheights[-1] <= newheight:\n                 maxheights.append(newheight)\n             else:\n                 maxheights.append(maxheights[-1])\n         \n         return maxheights\n             \n"]
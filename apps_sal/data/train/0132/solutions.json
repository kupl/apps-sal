["class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        dp = [0] + [-1 for i in range(days[-1])]\n        \n        for day in days:\n            dp[day] = 0\n        \n        for i in range(1, len(dp)):\n            if dp[i] == -1:\n                dp[i] = dp[i-1]\n            \n            else:\n                dp[i] = min(\n                    dp[i-1] + costs[0],\n                    dp[max(i-7, 0)] + costs[1],\n                    dp[max(i-30, 0)] + costs[2],\n                )\n            \n        return dp[-1]", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        dp = [0] * (days[-1] + 1)\n        pos = 0\n        \n        for i in range(1, days[-1] + 1):\n            if i == days[pos]:\n                d1 = i - 1\n                d2 = i - 7 if i - 7 > 0 else 0\n                d3 = i - 30 if i - 30 > 0 else 0\n                dp[i] = min(dp[d1] + costs[0], dp[d2] + costs[1], dp[d3] + costs[2])\n                pos += 1\n            else:\n                dp[i] = dp[i - 1]\n                \n        return dp[-1]\n", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        \n        @lru_cache(None)\n        def recur(day):\n            if day > 365:\n                return 0\n            elif day in days:\n                \n                ret = math.inf\n                for c, d in zip(costs, [1,7,30]):\n                    ret = min(ret, c + recur(day + d))\n                return ret\n                    \n            else:\n                return recur(day + 1)\n            \n        \n        return recur(0)", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        n = len(days)\n        m = len(costs)\n        ranges = [1, 7, 30]\n        dp = [float('inf')] * (n+1) \n        dp[0] = 0\n        #print(f\\\"n={n} m={m} dp={dp}\\\")\n        for j in range(1, n+1):\n            for i in range(1, m+1):\n                for k in range(j, n+1):\n                    if days[k-1] - days[j-1] >= ranges[i-1]:\n                        break\n                    #print(f\\\"k={k} i={i} j={j}\\\")\n                    dp[k] = min(dp[k], costs[i-1] + dp[j-1])            \n        return dp[n]\n", "class Solution:\n    def mincostTickets(self, arr: List[int], costs: List[int]) -> int:\n        \n        dp = [float('inf')]*(len(arr)+1)\n        dp[0] = 0\n        \n        for i in range(len(arr)):\n            \n            j = i\n            prev = dp[i]\n            \n            while j < len(arr) and arr[j] < arr[i] + 30:\n                \n                if arr[j] == arr[i]:\n                    dp[j+1] = min(dp[j+1],prev+costs[0],prev+costs[1],prev+costs[2])\n                elif arr[j] - arr[i] < 7:\n                    dp[j+1] = min(dp[j+1],prev+costs[1],prev+costs[2])\n                elif arr[j] - arr[i] < 30:\n                    dp[j+1] = min(dp[j+1],prev+costs[2])\n                    \n                j += 1\n                \n        print(dp)\n                    \n        return dp[-1]", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        min_costs = [-1 for i in range(days[-1])]\n        if 1 in days:\n            min_costs[0] = min(costs)\n        else:\n            min_costs[0] = 0\n        return self.helper(days, costs, min_costs, days[-1] - 1)\n    \n    def helper(self, days: List[int], costs: List[int], min_costs: List[int], i) -> int:\n        if i == 0:\n            return min_costs[0]\n        if i < 0:\n            return 0\n        if i + 1 not in days:\n            min_costs[i] = self.helper(days, costs, min_costs, i-1)\n        if min_costs[i] != -1:\n            return min_costs[i]\n        \n        c_1 = self.helper(days, costs, min_costs, i-1)\n        c_7 = self.helper(days, costs, min_costs, i-7)\n        c_30 = self.helper(days, costs, min_costs, i-30)\n        \n        min_costs[i] = min(c_1 + costs[0], c_7 + costs[1], c_30 + costs[2])\n        return min_costs[i]\n        \n            \n        \n        \n        \n# Brute force: branch for each ticket type: O(3^n)\n\n# min_cost(i) = minimum cost of traveling i days. (1-indexed).\n\n\n# min_cost(i) = min(\n# (min_cost(i-1) + costs[0]), \n# (min_cost(i-1) + costs[1]), \n# (min_cost(i-1) + costs[2]))\n'''\nmin_cost(1) = min(costs[0], costs[1], costs[2])\n\nmin_cost(i) = min cost of traveling up to the days[i]th day.\nmin_cost(0) = min(costs[0], costs[1], costs[2])\nmin_cost(i < 0) = min(costs[0], costs[1], costs[2])\nmin_cost(i) = (min_cost(i-1) + costs[0], min_cost(i-7) + costs[1], min_cost(i-30) + costs[2])\n\n\n\n\nmin_cost(i) = minimum cost of traveling i days, (1-indexed).\nmin_cost(1) = min(costs[0], costs[1], costs[2])\nmin_cost(i < 1) = min(costs[0], costs[1], costs[2]) ???\nmin_cost(i) = (min_cost(i-1) + costs[0], min_cost(i-7) + costs[1], min_cost(i-30) + costs[2]) \n\n**** This doesn't account for the case where a longer pass may be cheaper.\n\n\n'''", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        dp = [0] * (days[-1] + 1)\n        for day in range(0, days[-1] + 1):\n            if day not in days:\n                dp[day] = dp[max(0, day - 1)]\n            else:\n                dp[day] = min(dp[max(0, day - 1)] + costs[0], dp[max(0, day - 7)] + costs[1], dp[max(0, day - 30)] + costs[2])\n\n        return dp[-1]", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        dp = [float('inf')] * (len(days) + 1)\n        dp[0] = 0\n        for i in range(1, len(days) + 1):\n            j = 0\n            while i + j < len(dp):\n                if days[i + j - 1] <= days[i - 1]:\n                    dp[i + j] = min(dp[i + j], dp[i - 1] + costs[0])\n                if days[i + j - 1] <= days[i - 1] + 6:\n                    dp[i + j] = min(dp[i + j], dp[i - 1] + costs[1])\n                if days[i + j - 1] <= days[i - 1] + 29:\n                    dp[i + j] = min(dp[i + j], dp[i - 1] + costs[2])\n                else:\n                    break\n                j += 1\n        return dp[-1]\n", "def prev(x,day,dp):\n    ans=0\n    for i in day:\n        if i<=x:\n        #    print(dp[i],i,x)\n            ans = dp[i]\n        else:\n            break\n    return ans\nclass Solution:\n    def mincostTickets(self, day: List[int], cos: List[int]) -> int:\n        dp=[10000000]*(370)\n        tmp=[0]*32\n        tmp[1]=cos[0]\n        tmp[7]=cos[1]\n        tmp[30]=cos[2]\n        day.sort()\n        n = len(day)\n        for i in range(n):\n            d = day[i]\n            for j in [1,7,30]:\n                ab = prev(max(0,d-j),day,dp) + tmp[j]\n                #print(ab)\n                dp[d] = min(dp[d] , ab)\n        #print(dp[200:])\n        return dp[day[-1]]\n                \n            \n        \n        \n", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        dp = [0] * (days[-1]+1)\n        dp[0] = 0\n        for j in range(len(days)):\n                i = days[j]\n                for k in range(1,i+1):\n                    if k == i:\n                        if k-7 >= 0 and k-30 >= 0:\n                            dp[k] = min(dp[k-1]+costs[0], dp[k-7]+costs[1], dp[k-30]+costs[2])\n                        elif k-7 >= 0:\n                            dp[k] = min(dp[k-1]+costs[0], dp[k-7]+costs[1], costs[2])\n                        else:\n                            dp[k] = min(dp[k-1]+costs[0], costs[1], costs[2])\n                    else:\n                        if k != 1:\n                            if dp[k] == 0:\n                                dp[k] = dp[k-1]\n        return dp[-1]\n                    \n        \n", "class Solution:\n    '''\n    days = [1,4,6,7,8,20]\n    dp   = 11 9 8 6 4  2\n            2 7        2\n    '''\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        # if costs = [7,2,15] change to [2,2,15]\n        for i in range(1,-1,-1):\n            if costs[i] > costs[i+1]: costs[i] = costs[i+1]\n    \n        N = len(days)\n        dp = [0 for _ in range(N+1)]\n        dp[-2] = costs[0]\n        dp[-1] = 0    # trick to avoid list index out of bounds\n        \n        for i in range(N-2,-1,-1):\n            dp[i] = costs[0] + dp[i+1]\n            for j in range(i+1,N):\n                if days[j] - days[i] < 7:\n                    dp[i] = min(dp[i], costs[1] + dp[j+1])\n                elif days[j] - days[i] < 30:\n                    dp[i] = min(dp[i], costs[2] + dp[j+1])\n        return dp[0]", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        dp = [float('inf') for _ in range(days[-1] + 1)]\n        dp[0] = 0\n        set_days = set(days)\n        for i in range(1, len(dp)):\n            if i not in set_days:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = min(dp[max(0, i - 1)] + costs[0],\n                            dp[max(0, i - 7)] + costs[1],\n                            dp[max(0, i - 30)] + costs[2])\n        return dp[-1]", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        k = len(costs)\n        n = len(days)\n        dp = [[0] * (k+1) for _ in range(n)]\n\n        for i in range(n):\n            dp[i][0] = float('inf')\n\n            for d in range(i):\n                if days[i] - days[d] < 30:\n                    dp[i][0] = min(dp[i][0], dp[d][3])\n                if days[i] - days[d] < 7:\n                    dp[i][0] = min(dp[i][0], dp[d][2])\n\n            for j in range(1, k+1):\n                if i == 0:\n                    dp[i][j] = costs[j-1]\n                else:\n                    dp[i][j] = costs[j-1] + min(dp[i-1])\n\n        return min(dp[-1])\n", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        n = len(days)\n        if not days:\n            return 0\n        \n        total = [float('inf') for _ in range(n)]\n        total[0] = min(costs)\n        \n        for i in range(1,n):\n            curday = days[i]\n            total[i] = total[i-1]+min(costs)\n            \n            for j in range(i-1, -1, -1):\n                diff = curday-days[j]\n                if diff < 7:\n                    if j>0:\n                        total[i] = min(total[i], total[j-1]+costs[1])\n                    else:\n                        total[i] = min(total[i], costs[1])\n                \n                if diff < 30:\n                    if j>0:\n                        total[i] = min(total[i], total[j-1]+costs[2])\n                    else:\n                        total[i] = min(total[i], costs[2])\n                \n                else:\n                    break\n        \n        return total[-1]\n", "from collections import defaultdict\nclass Solution:\n    def mincostTickets(self, days: List[int], cost: List[int]) -> int:\n        dp = defaultdict(int)\n        days = set(days)\n        \n        for i in range(365, 0, -1):\n            if i in days:\n                dp[i] = min(dp[i+1] + cost[0], dp[i+7] + cost[1], dp[i+30] + cost[2])\n            else:\n                dp[i] = dp[i+1]\n        \n        return dp[1]", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        dp = [float('inf') for d in range(days[-1]+1)]\n        dp[0] = 0\n        pass_num_days = [1, 7, 30]\n        days_set = set(days)\n        \n        for day in range(days[-1]+1):\n            if day not in days_set:\n                dp[day] = dp[max(0, day-1)]\n            else:\n                for num_days, cost in zip(pass_num_days, costs):\n                    dp[day] = min(dp[day], dp[max(0, day-num_days)] + cost)\n        print(dp)\n        return dp[-1]    ", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        given = {}\n        for day in days:\n            given[day] = True\n        \n        dp = [0 for _ in range(days[-1]+1)]\n        dp[1] = costs[0]\n        for day in range(days[-1]+1):\n            if day not in given:\n                dp[day] = dp[day-1]\n            else:\n                # purchase one day pass\n                one_day_pass = dp[max(0, day-1)] + costs[0]\n                # purchase one week pass\n                one_week_pass = dp[max(0, day-7)] + costs[1]\n                # purchase one month pass\n                one_month_pass = dp[max(0,day-30)] + costs[2]\n                dp[day] = min(one_day_pass, one_week_pass, one_month_pass)\n        print(dp)\n        return dp[-1]", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        \n        cost = [0 for j in range(366)]\n        \n        for i in range(len(cost)):\n            if(i in days):\n                cost[i] = min((cost[i-1] if i-1>=0 else 0) + costs[0], \n                              (cost[i-7] if i-7>=0 else 0) + costs[1], \n                              (cost[i-30] if i-30>=0 else 0) + costs[2])\n            else:\n                cost[i] = cost[max(i-1,0)]\n            \n        return cost[365]\n        \n#         cost = [0 for j in range(days)]\n        \n#         for i, d in enumerate(days):\n#             if(d <= 7):\n#                 cost[i] = cost[i-1] + c[0] # take day pass\n#             if(d <= 30): # choose between day pass and month pass\n#                 cost[i] = min(cost[i-1]+c[0], cost)\n", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        if not days: \n            return 0\n        lastday = days[-1]\n        \n        dp = [0] * (lastday + 1)\n        \n        for i in range(1, lastday + 1): \n            if i not in days: \n                dp[i] = dp[i - 1]\n                continue\n            prev_1 = dp[i - 1] if i >= 1 else 0\n            prev_7 = dp[i - 7] if i >= 7 else 0\n            prev_30 = dp[i - 30] if i >= 30 else 0\n            dp[i] = min(prev_1 + costs[0], prev_7 + costs[1], prev_30 + costs[2])\n        \n        return dp[-1]\n            \n", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        if not days: \n            return 0\n        \n        dp = [0] * len(days)\n        \n        # given a day, find the dp index should look for\n        # include start, not include end\n        def search(start: int, end: int,  day:int)-> int:\n            if start == end - 1: \n                if day >= days[start]:\n                    return start\n                else:\n                    return -1\n            m = int((end - start)/2) + start\n            \n            if day >= days[m]:\n                return search(m, end, day)\n            else: \n                return search(start, m, day)\n                \n        m = {day:i for i, day in enumerate(days)}\n        \n        for i,day in enumerate(days): \n            prev_1 = day - 1\n            prev_7 = day - 7\n            prev_30 = day - 30\n            c_1 = costs[0] \n            c_7 = costs[1]\n            c_30 = costs[2]\n            if prev_1 in m: \n                c_1 += dp[m[prev_1]]\n            elif prev_1 >= 0 and prev_1 >= days[0]:        \n                c_1 += dp[search(0, i, prev_1)]\n            if prev_7 in m:\n                c_7 += dp[m[prev_7]]\n            elif prev_7 >= 0 and prev_7 >= days[0]:\n                c_7 += dp[search(0, i, prev_7)]\n            if prev_30 in m:\n                c_30 += dp[m[prev_30]]\n            elif prev_30 >= 0 and prev_30 >= days[0]:\n                c_30 += dp[search(0, i, prev_30)]\n                \n            dp[i] = min(c_1, c_7, c_30)\n        \n        return dp[-1]\n            \n", "class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n        if not days:\n            return 0\n        dp = {}\n        def getMin(idx, valid_count_past):\n            if idx == len(days):\n                return 0\n            if days[idx] <= valid_count_past:\n                return getMin(idx+1, valid_count_past)\n            if idx in dp:\n                return dp[idx]\n            m1 = costs[0] + getMin(idx+1, days[idx])\n            m7 = costs[1] + getMin(idx+1, days[idx]+6)\n            m30 = costs[2] + getMin(idx+1, days[idx]+29)\n            dp[idx] = min(m1,m7,m30)\n            return dp[idx]\n        \n        return getMin(0,0)\n"]
["import collections\n\nclass Tower:\n    def __init__(self):\n        indicesOfAlienPath = []\n        shots = 0\n\nclass GameStats:\n    def __init__(self):\n        alienPath = collections.deque()\n        towers = []\n        waves = collections.deque()\n\nDirEOL = 0\nDirLeft = 1\nDirRight = 2\nDirUp = 3\nDirDown = 4\n\n\ndef tower_defense(grid, turrets, aliens):\n    game = FromBattlefield(grid, turrets, aliens)\n    numSurvivedAliens = 0\n    while AnalysisIsRunning(game.alienPath, game.remainingWaves):\n        game = PrepareRound(game)\n        game.alienPath = KillAliens(game.alienPath, game.towers)\n        numSurvivedAliens = numSurvivedAliens + CountAliensLeavingPath(game.alienPath)\n    return numSurvivedAliens\n\ndef FromBattlefield(grid, turrets, aliens):\n    coords = DeterminePathCoordinates(grid)\n    game = GameStats()\n    game.alienPath = collections.deque([0 for a in range(len(coords))])\n    game.towers = CreateTowers(grid, turrets, coords)\n    game.remainingWaves = collections.deque(aliens)\n    return game\n\ndef DeterminePathCoordinates(grid):\n    result = []\n    coord = GetCoordFor(grid, '0')\n    result.append(coord)\n    dir = LookForPath(grid, coord, DirEOL)\n    while dir != DirEOL:\n        coord = GetCoordinate(coord, dir)\n        result.append(coord)\n        dir = LookForPath(grid, coord, dir)\n    return result\n\ndef GetCoordFor(grid, id):\n    n = len(grid)\n    for row in range(n):\n        for col in range(n):\n            if grid[row][col] == id:\n                return (col, row)\n    return (0,0)\n\ndef LookForPath(grid, c, dir):\n    if IsOnPath(grid, (c[0]+1, c[1])) and dir != DirLeft:\n        return DirRight\n    elif IsOnPath(grid, (c[0]-1, c[1])) and dir != DirRight:\n        return DirLeft\n    elif IsOnPath(grid, (c[0], c[1]-1)) and dir != DirDown:\n        return DirUp\n    elif IsOnPath(grid, (c[0], c[1]+1)) and dir != DirUp:\n        return DirDown\n    return DirEOL\n\ndef GetCoordinate(orig, dir):\n    if dir == DirLeft:\n        return (orig[0]-1, orig[1])\n    elif dir == DirRight:\n        return (orig[0]+1, orig[1])\n    elif dir == DirUp:\n        return (orig[0], orig[1]-1)\n    elif dir == DirDown:\n        return (orig[0], orig[1]+1)\n    return orig\n\ndef IsOnPath(grid, c):\n    n = len(grid)\n    return c[1] < n and c[0] < n and c[1] >= 0 and c[0] >= 0 and (grid[c[1]][c[0]] == '1' or grid[c[1]][c[0]] == '0')\n\ndef CreateTowers(grid, turrets, alienPathCoords):\n    towers = []\n    for name in sorted(turrets.keys()):\n        towerCoords = GetCoordFor(grid, name)\n        pathIdxInRange = DetermineIndicesOfAlienPathInRange(alienPathCoords, towerCoords, turrets[name][0])\n        towers.append((pathIdxInRange, turrets[name][1]))\n    return towers\n\ndef DetermineIndicesOfAlienPathInRange(alienPathCoords, towerCoords, dist):\n    result = []\n    sqrDist = dist*dist\n    startY = max(0, towerCoords[1] - dist)\n    startX = max(0, towerCoords[0] - dist)\n    for y in range(startY, towerCoords[1] + dist+1):\n        for x in range(startX, towerCoords[0] + dist+1):\n            cur = (x, y)\n            if cur in alienPathCoords and SqrDistance(cur, towerCoords) <= sqrDist:\n                result.append(alienPathCoords.index(cur))\n    return sorted(result)\n\ndef SqrDistance(left, right):\n    y = left[1] - right[1]\n    x = left[0] - right[0]\n    return x*x + y*y\n\n\ndef AnalysisIsRunning(alienPath, waves):\n    return len(waves) > 0 or any(alienPath)\n\ndef PrepareRound(game):\n    game.alienPath.pop()\n    if len(game.remainingWaves) > 0:\n        game.alienPath.appendleft(game.remainingWaves.popleft())\n    else:\n        game.alienPath.appendleft(0)\n    return game\n\ndef KillAliens(alienPath, towers):\n    activeTowers = towers.copy()\n    while CanShootAgain(activeTowers):\n        alienPath, activeTowers = ShootWithTowers(alienPath, activeTowers)\n        activeTowers = FilterInactiveTowers(alienPath, activeTowers)\n    return alienPath\n\ndef CanShootAgain(towers):\n    return len(towers) > 0\n\ndef ShootWithTowers(alienPath, towers):\n    towersShot = []\n    for t in towers:\n        alienPath, t = ShootAliensInFormostPosition(alienPath, t)\n        towersShot.append(t)\n    return alienPath, towersShot\n\ndef ShootAliensInFormostPosition(alienPath, tower):\n    for idx in reversed(tower[0]):\n        if alienPath[idx] > 0:\n            shots = tower[1] - 1\n            alienPath[idx] = alienPath[idx] - 1\n            return alienPath, (tower[0], shots)\n    return alienPath, tower\n\ndef FilterInactiveTowers(alienPath, towers):\n    result = []\n    for t in towers:\n        if t[1] > 0 and AreAliensInRange(alienPath, t[0]):\n            result.append(t)\n    return result\n\ndef AreAliensInRange(alienPath, towerRange):\n    for idx in towerRange:\n        if alienPath[idx] > 0:\n           return True\n    return False\n\ndef CountAliensLeavingPath(alienPath):\n    return alienPath[-1]", "import collections\n\nclass Tower:\n    def __init__(self):\n        indicesOfAlienPath = []\n        shots = 0\n\nclass GameStats:\n    def __init__(self):\n        alienPath = collections.deque()\n        towers = []\n        waves = collections.deque()\n\nDirEOL = 0\nDirLeft = 1\nDirRight = 2\nDirUp = 3\nDirDown = 4\n\n\ndef tower_defense(grid, turrets, aliens):\n    print(grid)\n    print(turrets)\n    print(aliens)\n    game = FromBattlefield(grid, turrets, aliens)\n    numSurvivedAliens = 0\n    while AnalysisIsRunning(game.alienPath, game.remainingWaves):\n        game = PrepareRound(game)\n        game.alienPath = KillAliens(game.alienPath, game.towers)\n        numSurvivedAliens = numSurvivedAliens + CountAliensLeavingPath(game.alienPath)\n    return numSurvivedAliens\n\ndef FromBattlefield(grid, turrets, aliens):\n    coords = DeterminePathCoordinates(grid)\n    game = GameStats()\n    game.alienPath = collections.deque([0 for a in range(len(coords))])\n    game.towers = CreateTowers(grid, turrets, coords)\n    game.remainingWaves = collections.deque(aliens)\n    return game\n\ndef DeterminePathCoordinates(grid):\n    result = []\n    coord = GetCoordFor(grid, '0')\n    result.append(coord)\n    dir = LookForPath(grid, coord, DirEOL)\n    while dir != DirEOL:\n        coord = GetCoordinate(coord, dir)\n        result.append(coord)\n        dir = LookForPath(grid, coord, dir)\n    return result\n\ndef GetCoordFor(grid, id):\n    n = len(grid)\n    for row in range(n):\n        for col in range(n):\n            if grid[row][col] == id:\n                return (col, row)\n    return (0,0)\n\ndef LookForPath(grid, c, dir):\n    if IsOnPath(grid, (c[0]+1, c[1])) and dir != DirLeft:\n        return DirRight\n    elif IsOnPath(grid, (c[0]-1, c[1])) and dir != DirRight:\n        return DirLeft\n    elif IsOnPath(grid, (c[0], c[1]-1)) and dir != DirDown:\n        return DirUp\n    elif IsOnPath(grid, (c[0], c[1]+1)) and dir != DirUp:\n        return DirDown\n    return DirEOL\n\ndef GetCoordinate(orig, dir):\n    if dir == DirLeft:\n        return (orig[0]-1, orig[1])\n    elif dir == DirRight:\n        return (orig[0]+1, orig[1])\n    elif dir == DirUp:\n        return (orig[0], orig[1]-1)\n    elif dir == DirDown:\n        return (orig[0], orig[1]+1)\n    return orig\n\ndef IsOnPath(grid, c):\n    n = len(grid)\n    return c[1] < n and c[0] < n and c[1] >= 0 and c[0] >= 0 and (grid[c[1]][c[0]] == '1' or grid[c[1]][c[0]] == '0')\n\ndef CreateTowers(grid, turrets, alienPathCoords):\n    towers = []\n    for name in sorted(turrets.keys()):\n        towerCoords = GetCoordFor(grid, name)\n        pathIdxInRange = DetermineIndicesOfAlienPathInRange(alienPathCoords, towerCoords, turrets[name][0])\n        towers.append((pathIdxInRange, turrets[name][1]))\n    return towers\n\ndef DetermineIndicesOfAlienPathInRange(alienPathCoords, towerCoords, dist):\n    result = []\n    sqrDist = dist*dist\n    startY = max(0, towerCoords[1] - dist)\n    startX = max(0, towerCoords[0] - dist)\n    for y in range(startY, towerCoords[1] + dist+1):\n        for x in range(startX, towerCoords[0] + dist+1):\n            cur = (x, y)\n            if cur in alienPathCoords and SqrDistance(cur, towerCoords) <= sqrDist:\n                result.append(alienPathCoords.index(cur))\n    return sorted(result)\n\ndef SqrDistance(left, right):\n    y = left[1] - right[1]\n    x = left[0] - right[0]\n    return x*x + y*y\n\n\ndef AnalysisIsRunning(alienPath, waves):\n    return len(waves) > 0 or any(alienPath)\n\ndef PrepareRound(game):\n    game.alienPath.pop()\n    if len(game.remainingWaves) > 0:\n        game.alienPath.appendleft(game.remainingWaves.popleft())\n    else:\n        game.alienPath.appendleft(0)\n    return game\n\ndef KillAliens(alienPath, towers):\n    activeTowers = FilterInactiveTowers(alienPath, towers.copy())\n    while CanShootAgain(activeTowers):\n        alienPath, activeTowers = ShootWithTowers(alienPath, activeTowers)\n        activeTowers = FilterInactiveTowers(alienPath, activeTowers)\n    return alienPath\n\ndef CanShootAgain(towers):\n    return len(towers) > 0\n\ndef ShootWithTowers(alienPath, towers):\n    towersShot = []\n    for t in towers:\n        alienPath, t = ShootAliensInFormostPosition(alienPath, t)\n        towersShot.append(t)\n    return alienPath, towersShot\n\ndef ShootAliensInFormostPosition(alienPath, tower):\n    for idx in reversed(tower[0]):\n        if alienPath[idx] > 0:\n            shots = tower[1] - 1\n            alienPath[idx] = alienPath[idx] - 1\n            return alienPath, (tower[0], shots)\n    return alienPath, tower\n\ndef FilterInactiveTowers(alienPath, towers):\n    result = []\n    for t in towers:\n        if t[1] > 0 and AreAliensInRange(alienPath, t[0]):\n            result.append(t)\n    return result\n\ndef AreAliensInRange(alienPath, towerRange):\n    for idx in towerRange:\n        if alienPath[idx] > 0:\n           return True\n    return False\n\ndef CountAliensLeavingPath(alienPath):\n    return alienPath[-1]", "from collections import OrderedDict\n\nclass TowerDefense:\n    def __init__(self, grid, turrets, aliens):\n        \"\"\" Create dictionary for turrets (using name) and lists with path and aliens \"\"\"\n        self._turrets = OrderedDict()\n        self._path = []\n\n        self._n = len(grid)\n        grid_str = ''.join(grid)\n\n        # Determine the path and which path positions are covered by the turrets)\n        self._determine_turret_positions(turrets, grid_str)\n        self._determine_path_and_guarded_positions(grid_str)\n        \n        # Aliens list is used to hold current alien strength\n        self._aliens = aliens\n        \n    def _determine_turret_positions(self, turrets, grid_str):\n        \"\"\" Add turrets in sorted order to dictionary \"\"\"\n        for (turret, settings) in sorted(turrets.items()):\n            ind = grid_str.find(turret)\n            x = ind % self._n\n            y = ind // self._n\n            # Range**2 is calculated as it is used in self._determine_path_and_guarded_positions\n            # guards will hold (x,y) pairs that the turret can reach sorted with the first point furthest along the path\n            self._turrets[turret] = {'pos': (x,y), 'range2': settings[0]**2,  'shots': settings[1], 'guards': [] }\n\n    def _determine_path_and_guarded_positions(self, grid_str):\n        \"\"\" Find all positions of the path and determine which once can be reached by the turrets \"\"\"\n        ind_0 = grid_str.find('0')\n        x = ind_0 % self._n\n        y = ind_0 // self._n\n        self._add_point_to_path_and_guarded_list((x,y))\n        next_point = self._get_next_point_on_path(grid_str)\n        while next_point:\n            self._add_point_to_path_and_guarded_list(next_point)\n            next_point = self._get_next_point_on_path(grid_str)\n        \n    def _add_point_to_path_and_guarded_list(self, point):\n        \"\"\" Add the point to the path list and to any turrets that can reach it \"\"\"\n        self._path.append(point)\n        self._add_to_guarded_list(point)\n\n    def _get_next_point_on_path(self, grid_str):\n        \"\"\" Based on the last point on the path, get the adjacent path point that is not yet on the path \"\"\"\n        curr_x, curr_y = self._path[-1]\n        if curr_x > 0:\n            test_x = curr_x - 1\n            test_y = curr_y\n            ind = test_x + self._n * test_y\n            if grid_str[ind] == '1' and not (test_x, test_y) in self._path:\n                return (test_x, test_y)\n        if curr_x < self._n - 1:\n            test_x = curr_x + 1\n            test_y = curr_y\n            ind = test_x + self._n * test_y\n            if grid_str[ind] == '1' and not (test_x, test_y) in self._path:\n                return (test_x, test_y)\n        if curr_y > 0:\n            test_x = curr_x\n            test_y = curr_y - 1\n            ind = test_x + self._n * test_y\n            if grid_str[ind] == '1' and not (test_x, test_y) in self._path:\n                return (test_x, test_y)\n        if curr_y < self._n - 1:\n            test_x = curr_x\n            test_y = curr_y + 1\n            ind = test_x + self._n * test_y\n            if grid_str[ind] == '1' and not (test_x, test_y) in self._path:\n                return (test_x, test_y)\n        return None\n\n    def _add_to_guarded_list(self, point):\n        \"\"\" Add point to list of guarded poisitions, if it is within turret range \"\"\"\n        for (turret, settings) in self._turrets.items():\n            if (point[0] - settings['pos'][0])**2 + (point[1] - settings['pos'][1])**2 <= settings['range2']:\n                # Insert as first item such that last point on path is first on guards\n                settings['guards'].insert(0, point)\n    \n    def aliens_that_pass_the_turrets(self):\n        \"\"\" Determine the number of aliens that pass the turrets \"\"\"\n        total_turns = len(self._path) + len(self._aliens) \n        for turn in range(1, total_turns + 1):\n            # Determine shots remaining by all turrets\n            total_remaining = 0\n            for turret in self._turrets:\n                self._turrets[turret]['remaining'] = self._turrets[turret]['shots']\n                total_remaining += self._turrets[turret]['remaining']\n            # Get a mapping from alien positions on the grid to index of the strength\n            alien_pos_ind = {}\n            for it in range(turn):\n                if it < len(self._aliens) and turn - 1 - it < len(self._path):\n                    alien_pos_ind[self._path[turn - 1 - it]] = it\n            # Keep firing until all shots fired or no aliens within range\n            while total_remaining > 0:\n                for turret in self._turrets:\n                    if self._turrets[turret]['remaining'] > 0:\n                        # Pick first alien position and fire\n                        for pos in self._turrets[turret]['guards']:\n                            if pos in alien_pos_ind and self._aliens[alien_pos_ind[pos] ] > 0:\n                                total_remaining -= 1\n                                self._turrets[turret]['remaining'] -= 1\n                                self._aliens[alien_pos_ind[pos] ] -= 1\n                                break\n                        else:\n                            # No alients to hit with turret range\n                            total_remaining -= self._turrets[turret]['remaining']\n                            self._turrets[turret]['remaining'] = 0\n        # Return remaining aliens\n        return(sum(self._aliens))\n    \n    def print_map(self, turn=0):\n        \"\"\" Print a map of the current turn with path, alien strength, and turrets \"\"\"\n        # Helper dictionary with turret positions\n        turret_pos = {}\n        for turret, settings in self._turrets.items():\n            turret_pos[settings['pos']] = turret\n\n        # Helper dictionary with alien positions in this turn\n        alien_pos = {}\n        for it in range(turn):\n            if it < len(self._aliens) and turn - 1 - it < len(self._path):\n                alien_pos[self._path[turn - 1 - it]] = self._aliens[it]\n\n        # Loop over all position and print what is there\n        for y in range(self._n):\n            for x in range(self._n):\n                if (x,y) in alien_pos:\n                    print('%02i' %  alien_pos[(x,y)], end=' ')\n                elif (x,y) in self._path:\n                    print('XX', end=' ')\n                elif (x,y) in turret_pos:\n                    print(2*turret_pos[(x,y)], end=' ')\n                else:\n                    print('  ', end=' ')\n            print('\\n')\n\ndef tower_defense(grid,turrets,aliens):\n    td = TowerDefense(grid, turrets, aliens)\n    return td.aliens_that_pass_the_turrets()\n", "class Turret:\n    def __init__(self, tid, r, c, size, info):\n        self.tid = tid\n        self.attack = info[1]\n        self.targets = set()\n        atkRange = info[0]\n        for dr in range(-atkRange, atkRange + 1):\n            for dc in range(-atkRange, atkRange + 1):\n                if dr == 0 and dc == 0:\n                    continue\n                ra, ca = r + dr, c + dc\n                if not(0 <= ra < size and 0 <= ca < size):\n                    continue\n                if dr * dr + dc * dc <= atkRange * atkRange:\n                    self.targets.add((ra, ca))\n\nclass Alien:\n    def __init__(self, pathIdx, pos, hp):\n        self.pathIdx = pathIdx\n        self.pos = pos\n        self.hp = hp\n\ndef tower_defense(grid, _turrets, _wave):\n    answer = 0\n    size = len(grid)\n    lWave = len(_wave)\n    wave = _wave[:]\n    ones = set()\n    turrets, aliens = [], []\n    for r, row in enumerate(grid):\n        for c, square in enumerate(row):\n            if square == \"1\":\n                ones.add((r, c))\n            elif square.isalpha():\n                turrets.append(Turret(square, r, c, size, _turrets[square]))\n            elif square == \"0\":\n                start = (r, c)\n    for turret in turrets:\n        turret.targets = turret.targets & (ones | {start})\n    turrets.sort(key = lambda t: t.tid)\n    path = [start]\n    r, c = start\n    while ones:\n        for r1, c1 in ones:\n            if abs(r1 - r) + abs(c1 - c) == 1:\n                path.append((r1, c1))\n                ones.discard((r1, c1))\n                r, c = r1, c1\n                break\n    lPath = len(path)\n    time = -1\n    while time < lWave or aliens:\n        time += 1\n        for i in range(len(aliens) - 1, -1, -1):\n            alien = aliens[i]\n            if alien.hp <= 0:\n                del aliens[i]\n                continue\n            alien.pathIdx += 1\n            if alien.pathIdx == lPath:\n                answer += alien.hp\n                del aliens[i]\n                continue\n            alien.pos = path[alien.pathIdx]\n        if time < lWave:\n            hp = wave[time]\n            if hp > 0:\n                aliens.append(Alien(0, path[0], hp))\n        for turret in turrets:\n            turret.shots = turret.attack\n        shot = True\n        while shot:\n            shot = False\n            for turret in turrets:\n                if turret.shots > 0:\n                    for alien in aliens:\n                        if alien.hp <= 0:\n                            continue\n                        if alien.pos not in turret.targets:\n                            continue\n                        alien.hp -= 1\n                        turret.shots -= 1\n                        shot = True\n                        break\n    return answer", "import math\nfrom collections import deque\n\nclass Alien:\n    def __init__(self, health, trail_length):\n        self.health = health\n        self.trail_length = trail_length\n        self.is_dummy = (health == 0)\n        self.position = None\n\n    def move(self):\n        self.position += 1\n\n    def place_on_board(self):\n        self.position = 0\n\n    def damage(self):\n        self.health -= 1\n\n    def on_map(self):\n        return self.position < self.trail_length\n\n\nclass Turret:\n    def __init__(self, loc, range, shots, name, trail):\n        self.loc = loc\n        self.range = range\n        self.max_shots = shots\n        self.name = name\n        self.trail = trail\n        self.current_shots = self.max_shots\n        self.nothing_in_range = False\n        self.in_range_list = deque()\n\n        # Find all the spots in the trail, find which ones are in range\n        for i, slot in enumerate(self.trail):\n            if self.calc_dist(slot) <= self.range:\n                self.in_range_list.appendleft(i)\n\n    def reset_shots(self):\n        self.nothing_in_range = False\n        self.current_shots = self.max_shots\n\n    def calc_dist(self, target):\n        return math.sqrt(math.pow(target[0] - self.loc[0], 2) +\n                         math.pow(target[1] - self.loc[1], 2))\n\n    def shoot_nearest_alien(self, aliens):\n        self.nothing_in_range = True\n\n        if self.current_shots <= 0:\n            return\n\n        for slot in self.in_range_list:\n            if slot < len(aliens):\n                alien = aliens[slot]\n                if alien.health > 0:\n                    self.current_shots -= 1\n                    alien.damage()\n                    self.nothing_in_range = False\n                    break\n\n\ndef gen_path(data):\n    # Convert the raw string map to a mutable form so that we\n    # can modify it later (to mark visited cells along the path)\n    map = []\n    for row in data:\n        map.append(list(row))\n    rows = len(map)\n    cols = len(map[0])\n\n    # Iterate through all the points and look for the unique\n    # start of the trail (0) and while we're at it, find the\n    # turrets (capital letters)\n    start = None\n    turrets = {}\n    for y in range(len(map)):\n        for x in range(len(map[0])):\n            if map[y][x] == '0':\n                start = (x, y)\n            elif map[y][x].isupper():\n                turrets[map[y][x]] = (x, y)\n\n    # Now that we have the start, iterate through the map to\n    # find the trail\n    trail = []\n\n    found_end = False\n    next = start\n    while not found_end:\n        # South\n        if next[1] + 1 < rows and map[next[1] + 1][next[0]] == \"1\":\n            map[next[1] + 1][next[0]] = '0'  # mark as visited\n            trail.append(next)\n            next = (next[0], next[1] + 1)\n        # North\n        elif next[1] - 1 >= 0 and map[next[1] - 1][next[0]] == \"1\":\n            map[next[1] - 1][next[0]] = '0'  # mark as visited\n            trail.append(next)\n            next = (next[0], next[1] - 1)\n        # East\n        elif next[0] + 1 < cols and map[next[1]][next[0] + 1] == \"1\":\n            map[next[1]][next[0] + 1] = '0'  # mark as visited\n            trail.append(next)\n            next = (next[0] + 1, next[1])\n        # West\n        elif next[0] - 1 >= 0 and map[next[1]][next[0] - 1] == \"1\":\n            map[next[1]][next[0] - 1] = '0'  # mark as visited\n            trail.append(next)\n            next = (next[0] - 1, next[1])\n        else:\n            trail.append(next)\n            found_end = True\n    return trail, turrets\n\n\ndef game_logic(turret_data, turret_locs, alien_data, trail):\n    # Create an array of turret objects, combining the location information\n    # and the range/shots information\n    turrets = []\n    for letter in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n        if letter in turret_locs and letter in turret_data:\n            turrets.append(Turret(turret_locs[letter],\n                                  turret_data[letter][0],\n                                  turret_data[letter][1],\n                                  letter,\n                                  trail))\n\n    # Main loop variables\n    aliens = deque()\n    trail_length = len(trail)\n    final_health = 0\n    game_length = len(alien_data) + len(trail)\n    round = 0\n\n    # Perform the game logic here\n    while round < game_length:  # This is the main tick loop of the game\n        round += 1\n\n        # Move the aliens\n        if len(alien_data) > 0:\n            aliens.appendleft(Alien(alien_data.pop(0), len(trail)))\n        else:\n            # Push dummies back after all the real aliens are used\n            aliens.appendleft(Alien(0, len(trail)))\n\n        # Check the right side of the list for aliens that fall off the map\n        if len(aliens) > trail_length:\n            removed_alien = aliens.pop()\n            if removed_alien.health > 0:\n                final_health += removed_alien.health\n\n        # Reset all the turrets back to full power\n        for turret in turrets:\n            turret.reset_shots()\n\n        # Iterate through all turrets\n        turrets_done = False\n        while not turrets_done:\n            for t in turrets:\n                if t.current_shots > 0:\n                    t.shoot_nearest_alien(aliens)\n\n            # Done condition: all turrets empty or\n            # Have no enemies in range\n            turrets_done = True\n            for t in turrets:\n                if t.current_shots > 0 and not t.nothing_in_range:\n                    turrets_done = False\n    return final_health\n\ndef tower_defense(grid,turrets,aliens):\n    trail, turret_locs = gen_path(grid)\n    total_health = game_logic(turrets, turret_locs, aliens, trail)\n    return total_health"]
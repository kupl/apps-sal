["import sys\n\t\t\t\t\ninp = [int(x) for x in sys.stdin.read().split()]\n\nn, m, q = inp[0], inp[1], inp[2]\n\np = [inp[idx] for idx in range(3, n + 3)]\n\nindex_arr = [0] * (n + 1)\nfor i in range(n):\tindex_arr[p[i]] = i\n\na = [inp[idx] for idx in range(n + 3, n + 3 + m)]\n\nleftmost_pos = [m] * (n + 1)\nnext = [-1] * m\n\nfor i in range(m - 1, -1, -1):\n\tindex = index_arr[a[i]]\n\tright_index = 0 if index == n - 1 else index + 1\n\tright = p[right_index]\n\tnext[i] = leftmost_pos[right]\n\tleftmost_pos[a[i]] = i\n\t\nlog = 0\nwhile (1 << log) <= n: log += 1\nlog += 1\ndp = [[m for _ in range(m + 1)] for  _ in range(log)]\n\nfor i in range(m):\n\tdp[0][i] = next[i]\n\nfor j in range(1, log):\n\tfor i in range(m):\n\t\tdp[j][i] = dp[j - 1][dp[j - 1][i]]\n\nlast = [0] * m\nfor i in range(m):\n\tp = i\n\tlen = n - 1\n\tfor j in range(log - 1, -1, -1):\n\t\tif (1 << j) <= len:\n\t\t\tp = dp[j][p]\n\t\t\tlen -= (1 << j)\n\tlast[i] = p\n\t\nfor i in range(m - 2, -1, -1):\n\tlast[i] = min(last[i], last[i + 1])\n\t\ninp_idx = n + m + 3\nans = []\nfor i in range(q):\n\tl, r = inp[inp_idx] - 1, inp[inp_idx + 1] - 1\n\tinp_idx += 2\n\tif last[l] <= r:\n\t\tans.append('1')\n\telse:\n\t\tans.append('0')\nprint(''.join(ans))", "import sys\n \nclass segmentTree:\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.seg = [self.n + 1] * (self.n << 1)\n\t\t\n\tdef update(self, p, value):\n\t\tp += self.n\n\t\tself.seg[p] = value\n\t\twhile p > 1:\n\t\t\tp >>= 1\n\t\t\tself.seg[p] = min(self.seg[p * 2], self.seg[p * 2 + 1])\n\t\t\t\n\t\n\tdef query(self, l, r):\n\t\tres = self.n\n\t\tl += self.n\n\t\tr += self.n\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tres = min(res, self.seg[l])\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tres = min(res, self.seg[r - 1])\n\t\t\t\tr -= 1\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\treturn res\n\t\t\t\t\ninp = [int(x) for x in sys.stdin.read().split()]\n \nn, m, q = inp[0], inp[1], inp[2]\n \np = [inp[idx] for idx in range(3, n + 3)]\n \nindex_arr = [0] * (n + 1)\nfor i in range(n):\tindex_arr[p[i]] = i\n \na = [inp[idx] for idx in range(n + 3, n + 3 + m)]\n \nleftmost_pos = [m] * (n + 1)\nnext = [-1] * m\n \nfor i in range(m - 1, -1, -1):\n\tindex = index_arr[a[i]]\n\tright_index = 0 if index == n - 1 else index + 1\n\tright = p[right_index]\n\tnext[i] = leftmost_pos[right]\n\tleftmost_pos[a[i]] = i\n\t\nlog = 0\nwhile (1 << log) <= n: log += 1\nlog += 1\ndp = [[m for _ in range(m + 1)] for  _ in range(log)]\n \nfor i in range(m):\n\tdp[0][i] = next[i]\n \nfor j in range(1, log):\n\tfor i in range(m):\n\t\tdp[j][i] = dp[j - 1][dp[j - 1][i]]\n \ntree = segmentTree(m)\nfor i in range(m):\n\tp = i\n\tlen = n - 1\n\tfor j in range(log - 1, -1, -1):\n\t\tif (1 << j) <= len:\n\t\t\tp = dp[j][p]\n\t\t\tlen -= (1 << j)\n\ttree.update(i, p)\n \ninp_idx = n + m + 3\nans = []\nfor i in range(q):\n\tl, r = inp[inp_idx] - 1, inp[inp_idx + 1] - 1\n\tinp_idx += 2\n\tif tree.query(l, r + 1) <= r:\n\t\tans.append('1')\n\telse:\n\t\tans.append('0')\nprint(''.join(ans))"]
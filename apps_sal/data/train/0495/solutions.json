["class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        dp = {0}\n        total = sum(stones)\n        for stone in stones:\n            dp |= {_sum + stone for _sum in dp}\n        return min(abs(total - _sum - _sum) for _sum in dp)", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        res = set()\n        res.add(stones[0])\n        for n in stones[1:]:\n            newres = set()\n            for m in res:\n                newres.add(n + m)\n                newres.add(abs(n - m))\n            res = newres\n        return min(res)", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        def dp(i, j):\n            if i==N: return j\n            if (i, j) in memo: return memo[(i, j)]\n            \n            memo[(i, j)] = min(dp(i+1, abs(j+stones[i])), dp(i+1, abs(j-stones[i])))\n            return memo[(i, j)]\n        \n        memo = {}\n        N = len(stones)\n        return dp(0, 0)", "class Solution:\n    def lastStoneWeightII(self, arr: List[int]) -> int:\n        #0/1 knapsack\n        upperBound = sum(arr)//2\n        #initialize the dp -> row means use up to ith value, row means the upper bound value \n        dp = [[0 for i in range(upperBound+1)] for j in range(len(arr))]\n\n        #fill in the dp\n        #base case when col == 0 -> the upper bound is 0, so the max val is 0 \n        for i in range(len(dp)):\n            for j in range(len(dp[0])):\n                #take i or not\n                if(arr[i] <= j):\n                    dp[i][j] = max(dp[i-1][j-arr[i]] + arr[i], dp[i-1][j])\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return sum(arr) - 2*dp[-1][-1]", "from functools import lru_cache\nclass Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        \n        n = len(stones)\n        if n == 1:\n            return stones[0]\n        \n        @lru_cache(None)\n        def dfs(index, curSum):\n            if index == n:\n                return abs(curSum)\n            \n            return min(dfs(index + 1, curSum + stones[index]), dfs(index + 1, curSum - stones[index]))\n        \n        return dfs(0, 0)\n", "import queue\nclass Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        total = sum(stones)\n        return self.topDown(stones, 0, 0, 0, [[None for s in range(total+1)] for i in range(len(stones))])\n        \n        \n    def topDown(self, stones, idx, sum1, sum2, memo):\n        \n        if idx >= len(stones):\n            return abs(sum1-sum2)\n        \n        if memo[idx][sum1] != None:\n            return memo[idx][sum1]\n        \n        difference_1 = self.topDown(stones, idx+1, sum1+stones[idx], sum2, memo)\n        difference_2 = self.topDown(stones, idx+1, sum1, sum2+stones[idx], memo)\n        \n        memo[idx][sum1] = min(difference_1, difference_2)\n        return memo[idx][sum1]", "class Solution:\n    \n    def lastStoneWeightII(self, stones: List[int]) -> int:        \n        mem = {} #Mem\n        \n        def explore(a, b, stones):\n            if len(stones) == 0:\n                return abs(a-b)\n            \n            entry = (a, b, len(stones)) #Mem\n            if entry in mem:\n                return mem[entry]\n            \n            s = stones.pop()\n            m = min(explore(a+s, b, stones), explore(a, b+s, stones))\n            stones.append(s)\n            \n            mem[entry] = m #Mem\n            return m\n        \n        return explore(0, 0, stones)\n    \n    def lastStoneWeightIITLE(self, stones: List[int]) -> int:\n        N = len(stones)\n        if not stones:\n            return 0\n        if N == 1:\n            return stones[0]\n        if N == 2:\n            return abs(stones[0]-stones[1])\n        \n        out = float('inf')\n        for i in range(N):\n            for j in range(i+1, N):\n                right = stones.pop(j)\n                left = stones.pop(i)\n                diff = abs(right-left)\n                \n                out = min(out, self.lastStoneWeightII(stones+[diff]))\n                \n                stones.insert(i, left)\n                stones.insert(j, right)\n                \n        return out", "class Solution:\n    \n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        # find the two groups with the smallest difference\n        \n        cache = {}\n        \n        def diffs(s1: int, s2: int, xs: List[int]) -> int:\n            if len(xs) == 0:\n                return abs(s1 - s2)\n            \n            if (s1, s2, len(xs)) not in cache:            \n                y = xs.pop()\n                min_val = min(diffs(s1 + y, s2, xs), diffs(s1, s2 + y, xs))\n                xs.append(y)\n                cache[(s1, s2, len(xs))] = min_val\n                \n            return cache[(s1, s2, len(xs))]\n            \n        return diffs(stones[0], 0, stones[1:])\n            \n            \n            \n            \n                \n            \n", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        total = sum(stones)\n        target = total // 2 \n        \n        dp = [0] * (target + 1)\n        \n        for stone in stones:\n            for i in range(target, stone-1, -1): \n                dp[i] = max(dp[i], dp[i-stone] + stone)\n                \n        return total - 2*dp[-1]", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        def helper(i, currSum):\n            if i == len(stones):\n                return abs(total - 2 * currSum)\n            if (i, currSum) in cache:\n                return cache[(i, currSum)]\n            takeIt = helper(i + 1, currSum + stones[i])\n            ignoreIt = helper(i + 1, currSum)\n            cache[(i, currSum)] = min(takeIt, ignoreIt)\n            return cache[(i, currSum)]\n\n        cache = {}\n        total = sum(stones)\n        return helper(0, 0)\n\n", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        self.dp={}\n        def helper(index,total):\n            \n            if index==len(stones):\n                return abs(total)\n            \n            if (index,total) in self.dp:\n                return self.dp[(index,total)]\n            \n            self.dp[(index,total)]= min(helper(index+1,total+stones[index]),helper(index+1,total-stones[index]))\n            return self.dp[(index,total)]\n            \n            \n        return helper(0,0)\n", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:      \n        '''\n        Observation: \n        Minimum weight stone is equal to the problem of partionining stones into\n        two arrays A and B such that | sum(A) - sum(B) | is minimized.\n        \n        Idea: Given such a partition, we smash the stones as follows. Choose a in A\n        and b in B arbitrarily.\n          - if a == b: they both are destroyed\n          - if a < b: place b - a into B\n          - if a > b: place a - b into A\n        Can argue that at the end, the stone remaining will have weight which is\n        the difference.\n        \n        Use a knapsack like DP to solve the problem.\n        '''\n        \n        n = len(stones)\n        total = sum(stones)\n        # memo keeps track of whether or not we can get a sum of exactly T for\n        # the smaller of the two sets (thus, T <= sum(A)/2) using numbers\n        # from 0 .. i\n        memo = {}\n        def dp(i, t):\n          if (i,t) in memo:\n            return memo[i, t]\n          \n          if i == -1:\n            memo[i, t] = t == 0\n          elif t < 0:\n            memo[i, t] = False\n          else:\n            memo[i, t] = dp(i-1, t) or dp(i-1, t - stones[i])\n          return memo[i, t]\n          \n        return min(abs(total - 2*t) for t in range(total//2 + 1) if dp(n-1, t))\n        \n        \n", "from heapq import heapify,heappush,heappop\nclass Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        arr = stones\n        n = len(stones)\n        su = sum(arr)\n        dp = [[0 for i in range(su+1)] for j in range(n+1)]\n        for i in range(n + 1): \n            dp[i][0] = 1\n\n        for j in range(1,n+1):\n            for i in range(1,su+1):\n                dp[j][i] = dp[j-1][i]\n                if i-arr[j-1]>=0:\n                    dp[j][i] |= dp[j-1][i-arr[j-1]]\n\n\n        diff = sys.maxsize \n\n        # Find the largest j such that dp[n][j]  \n        # is true where j loops from sum/2 t0 0  \n        for j in range(su // 2, -1, -1): \n            if dp[n][j] == True: \n                diff = su - (2 * j) \n                break\n\n        return diff", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        from functools import lru_cache\n        \n        @lru_cache(None)\n        def helper(ind, curr):\n            if ind==len(stones):\n                return abs(curr)\n            \n            return min(helper(ind+1, curr+stones[ind]), helper(ind+1, curr-stones[ind]))\n        \n        return helper(0, 0)\n", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        mem = {} #Mem\n        \n        def explore(a, b, stones):\n            if len(stones) == 0:\n                return abs(a-b)\n            \n            entry = (a, b, len(stones)) #Mem\n            if entry in mem:\n                return mem[entry]\n            \n            s = stones.pop()\n            m = min(explore(a+s, b, stones), explore(a, b+s, stones))\n            stones.append(s)\n            \n            mem[entry] = m #Mem\n            return m\n        \n        return explore(0, 0, stones)", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        n = len(stones)\n        total = sum(stones)\n        diff = total\n        dp = [[False] * (1 + total) for _ in range(1 + n)]\n        for i in range(n + 1):\n            dp[i][0] = True\n        \n        for i in range(1, n + 1):\n            s = stones[i - 1]\n            for j in range(1, 1 + total):\n                if j < s:\n                    dp[i][j] = dp[i - 1][j]\n                    continue\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - s]\n                if dp[i][j]:\n                    diff = min(diff, abs(total - 2 * j))\n        return diff\n        \n        \n        \n", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        dp = {0}\n        sum_stones = sum(stones)\n        \n        for stone in stones:\n            dp |= {stone + i for i in dp}\n            \n        return min(abs(sum_stones - i - i) for i in dp)\n", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        # dp = {0}\n        # sumA = sum(stones)\n        # for a in stones:\n        #     dp |= {a + i for i in dp}\n        # return min(abs(sumA - i - i) for i in dp)\n        dp, sumA = {0}, sum(stones)\n        for a in stones:\n            dp = {a + x for x in dp} | {a - x for x in dp}\n        return min(abs(x) for x in dp)", "from functools import lru_cache\nclass Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        \n        \n        lim = len(stones)\n        \n        \n    \n        \n        @lru_cache(None)\n        def r(s,i):\n            if i==lim-1:\n                return min(s+stones[-1],abs(s-stones[-1]))\n            \n            else:\n                \n                \n                return min(r(s+stones[i],i+1),r(abs(s-stones[i]),i+1))\n                \n                \n                    \n                        \n        \n        return r(0,0)", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        \n        target=sum(stones)\n        target=target//2\n        \n        \n        dp=[[False]*(target+1) for _ in range(len(stones)+1)]\n        \n        \n        for i in range(len(stones)+1):\n            for j in range(target+1):\n                \n                if j==0:\n                    dp[i][j]=True\n                    \n                elif stones[i-1]<=j:\n                    dp[i][j]=dp[i-1][j-stones[i-1]] or dp[i-1][j]\n                    \n                else:\n                    dp[i][j]=dp[i-1][j]\n                \n                \n        for j in reversed(range(target+1)):\n            \n            if dp[-1][j]:\n                return sum(stones)-2*j", "class Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        '''\n        DP\n        O(N * SUM//2)\n        \n        As this problem is equal to min diff between dividing arr into two groups, sse dp to store sum//2 and see if we can reach it\n        '''\n        \n        total = sum(stones)\n        \n        dp = [[None for _ in range(((total // 2) + 1))] for _ in range(len(stones))]\n        \n        for num in range((total//2)+1):\n            if stones[0] <= num:\n                dp[0][num] = stones[0]\n            else:\n                dp[0][num] = 0\n        \n        \n        for index in range(1,len(stones)):\n            for num in range((total//2)+1):                \n                if stones[index] <= num:\n                    take = stones[index] + dp[index - 1][num - stones[index]]\n                    dp[index][num] = max(take, dp[index-1][num])\n                else:\n                    dp[index][num] = dp[index - 1][num]\n        \n        #print(dp)\n        \n        return total - dp[-1][-1] - dp[-1][-1]\n                \n        \n        \n        \n"]
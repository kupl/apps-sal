["from scipy.special import comb\n\ndef multiply(n, k):\n    r, d = 1, 2\n    while d * d <= n:\n        i = 0\n        while n % d == 0:\n            i += 1\n            n //= d\n        r *= comb(i + k - 1, k - 1, exact=True)\n        d += 1\n    if n > 1: \n        r *= k\n    return r", "from scipy.special import comb\nfrom collections import Counter\n\ndef factorize_exponents(n):\n    result = Counter()\n    while n % 2 == 0:\n        result[2] += 1\n        n //= 2\n    k = 3\n    m = int(n ** 0.5)\n    while k <= m:\n        if n % k == 0:\n            result[k] += 1\n            n //= k\n            m = int(n ** 0.5)\n        else:\n            k += 2\n    if n > 1:\n        result[n] += 1\n    return list(result.values())\n\ndef multiply(n, k):\n    factorized = factorize_exponents(n)\n    total = 1\n    for exp in factorized:\n        total *= comb(exp + k - 1, k - 1, exact=True)\n    return total\n", "from math import gcd, factorial\nfrom random import randint\n\ndef primesfrom2to(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n/3035188#3035188\n    \"\"\"\n    Returns an array of primes, 2 <= p < n.\n    \"\"\"\n    sieve = [True]*(n//2)\n    for i in range(3, int(n**0.5)+1, 2):\n        if sieve[i//2]:\n            sieve[i*i//2::i] = [False]*((n- i*i -1)//(2*i) + 1)\n    return [2] + [2*i + 1 for i in range(1, n//2) if sieve[i]]\n\n\nbound = 7100\nsmall_primes = primesfrom2to(bound)\nsmall_primes_set = set(small_primes)\n\ndef factorint(n):\n    \"\"\"\n    Returns a dict containing the prime factors of n as keys and their\n    respective multiplicities as values.\n    \"\"\"\n    factors = dict()\n\n    limit = int(n**0.5)+1\n    for prime in small_primes:\n        if prime > limit:\n            break\n        while n%prime == 0:\n            if prime in factors:\n                factors[prime] += 1\n            else:\n                factors[prime] = 1\n            n //= prime\n\n    if n >= 2:\n        large_factors(n, factors)\n    return factors\n\n\ndef large_factors(n, factors):\n    while n > 1:\n        if isprime(n):\n            if n in factors:\n                factors[n] += 1\n            else:\n                factors[n] = 1\n            break\n        \n        factor = pollard_brent(n)\n        large_factors(factor, factors)\n        n //= factor\n\n\ndef pollard_brent(n):\n    # https://comeoncodeon.wordpress.com/2010/09/18/pollard-rho-brent-integer-factorization/\n    \"\"\"\n    Returns a factor of n. The returned factor may be a composite number.\n    \"\"\"\n    if n%2 == 0:\n        return 2\n\n    y, c, m = randint(1, n-1), randint(1, n-1), randint(1, n-1)\n    g, r, q = 1, 1, 1\n    while g == 1:\n        x = y\n        for i in range(r):\n            y = (pow(y, 2, n)+c)%n\n\n        k = 0\n        while k < r and g == 1:\n            ys = y\n            for i in range(min(m, r-k)):\n                y = (pow(y, 2, n)+c)%n\n                q = q*abs(x-y)%n\n            g = gcd(q, n)\n            k += m\n        r *= 2\n\n    if g == n:\n        while True:\n            ys = (pow(ys, 2, n)+c)%n\n            g = gcd(abs(x-ys), n)\n            if g > 1:\n                break\n\n    return g  \n\n\ndef isprime(n):\n    # https://en.wikipedia.org/wiki/Miller\u2013Rabin_primality_test#Deterministic_variants\n    if n%2 == 0:\n        return False\n    elif n < bound:\n        return n in small_primes_set\n\n    d, r = n-1, 0\n    while d%2 == 0:\n        d //= 2\n        r += 1\n\n    for a in (2, 3, 5, 7):\n        x = pow(a, d, n)\n        if x == 1 or x == n-1:\n            continue\n\n        for i in range(r-1):\n            x = pow(x, 2, n)\n            if x == n-1:\n                break\n        else:\n            return False\n\n    return True\n\n\ndef partitions(n, k):\n    \"\"\"\n    Returns the number of ways to write n as the sum of k nonnegative \n    integers. Order matters.\n    \"\"\"\n    result = 1\n    for i in range(n+1, n+k):\n        result *= i\n    return result//factorial(k-1)\n\n\ndef multiply(n, k):\n    total, factors = 1, factorint(n)\n    for exponent in list(factors.values()):\n        total *= partitions(exponent, k)\n    return total\n", "def j(n,k):\n    i = 1\n    for f in range(1,k) : i *= f + n\n    for f in range(1,k) : i //= f\n    return i\ndef multiply(n,k):\n    i = f = 1\n    while f * f < n :\n        l,f = 0,-~f\n        while n % f < 1 : l,n = -~l,n // f\n        if l : i *= j(l,k)\n    return i * (n < 2 or j(1,k))", "from scipy.special import comb\n\ndef multiply(n, k):\n    r, d = 1, 2\n    while d * d <= n:\n        i = 0\n        while n % d == 0:\n            i += 1\n            n //= d\n        if i: r *= comb(i + k - 1, k - 1, exact=True)\n        d += 1\n    if n > 1: \n        r *= k\n    return r", "from collections import Counter\nfrom functools import reduce\nfrom operator import mul\n\n# The instructions say n<=500_000_000 or 5e8.  However, the tests appear\n# to use n<1e12.  We adjust accordingly.\n\n# Use a sieve to pre-compute small primes up to 1e6.  Using trial division\n# is sufficent in factoring up to 1e12.  We seed with the first prime to\n# simplify is_prime().\nsmall_primes = [2]\n\n# This is suffient for testing primality only up to the square of the\n# largest of small_primes.  This is OK to generate the sequence of primes.\ndef is_prime(n):\n    for p in small_primes:\n        if p*p > n:\n            return True\n        if n%p == 0:\n            return False\n\n# Sieve to generate the list of small primes.\nfor n in range(3, 1000000):\n    if is_prime(n):\n        small_primes.append(n)\n\n# factor an integer up to 1e12\ndef factor(n):\n    if n==1:\n        return Counter()\n    for p in small_primes:\n        if n%p!=0:\n            continue\n        factors = factor(n//p)\n        factors[p] += 1;\n        return factors;\n    return Counter({ n: 1 })\n\n# count the number of ways of partitioning r objects k ways\ndef count_partitions(k, r):\n    numerator = reduce(mul, list(range(r+1, r+k)), 1)\n    denominator = reduce(mul, list(range(1, k)), 1)\n    return numerator//denominator\n\ndef multiply(n, k):\n    factors = factor(n)\n    print(n)\n    print(factors)\n    return reduce(mul, [count_partitions(k, r) for r in list(factors.values())], 1)\n", "from math import sqrt,factorial\ndef c(n,m):\n        return factorial(n)//(factorial(n-m)*factorial(m))\n\ndef factor(n):#Amount of prime numbers\n        factors={}\n        max=int(sqrt(n)+1)\n        f=2\n        while f<=max:\n            if n%f==0:\n                factors[f]=0\n                while n%f==0:\n                    factors[f]+=1\n                    n//=f\n                max=int(sqrt(n)+1)\n            f+=1\n        if n!=1:\n            factors[n]=1\n        return factors\n    \ndef multiply(n, k):\n    mul=1\n    for m in factor(n).values():\n        mul*=c(m+k-1,k-1)\n    return mul", "import operator as op\nfrom functools import reduce\n\ndef factors(n):\n    div = 2\n    d = dict()\n\n    while n > (div - 1) ** 2:\n        if n % div == 0:\n            n = n // div\n            if div in d:\n                d[div] += 1\n            else:\n                d[div] = 1\n        else:\n            div += 1    \n    if n in d:\n        d[n] += 1\n    elif n > 1:\n        d[n] = 1\n    r = []\n    for k in d.keys():\n        r.append((k, d[k]))\n    return r\n\ndef get_pascal(r):\n    if r == 1:\n        return [1]\n    elif r == 2:\n        return [1,1]\n    \n    s = [1,1]\n    while len(s) < r:\n        ns = [1]\n        for i in range(len(s) - 1):\n            ns.append(s[i] + s[i + 1])\n        ns = ns + [1]\n        s = ns\n    return s\n\ndef ncr(n, r):\n    if r > n:\n        return 0\n    r = min(r, n-r)\n    numer = reduce(op.mul, range(n, n-r, -1), 1)\n    denom = reduce(op.mul, range(1, r+1), 1)\n    return numer // denom\n\ndef get_cases(r,k):\n    p = get_pascal(r)\n    sum_v = 0\n    for i,v in enumerate(p):        \n        sum_v += v * ncr(k,i + 1)\n    #print(r, k, p, sum_v)\n    return sum_v\n\ndef multiply(n,k):\n    if n == 1: return 1\n    f = factors(n)    \n    #print(f)\n    s = 1\n    for r in f:\n        s *= get_cases(r[1], k)\n    return s", "# I'm slightly sad, I had a simple clean solution, that wasn't quite fast enough, needed 2-3 more seconds\n#\n# def multiply(n, k):\n#     return k if k<2 else sum(multiply(x,k-1) for x in factors(n))\n#\n\nfrom collections import Counter\nfrom functools import lru_cache, reduce\nfrom itertools import combinations\nfrom operator import mul\nfrom math import factorial\n\ndef multiply(n, k):\n    if k<2: return k\n    if k==2: return len(factors(n))\n    #get all the combinations that prod to n\n    tups = get_factor_tuples(n,k)\n    #insert all the extra 1s\n    tups = { tuple((1,)*(k-len(x))+x) for x in tups }\n    #do factorial math to find # of unique combinations of each tuple (multinomial coefficient)\n    f=factorial(k)\n    return sum(f // reduce(mul,[ factorial(v) for v in list(Counter(p).values()) if v > 1 ] + [1]) for p in tups)\n\ndef get_factor_tuples(n,k):\n    pair = {(n,)}\n    for kp in range(1,k):\n        k_tup = set(x for x in pair if len(x)==kp)\n        for grp in k_tup: \n            for i,e in enumerate(grp):\n                g = grp[:i]+grp[i+1:]\n                if e not in primefactors(n):\n                    for a in factors(e):\n                        if 1<a<e:\n                            b = e//a\n                            pair.add(tuple(sorted((a,b)+g)))\n    return pair\n\n@lru_cache(maxsize=None)\ndef primefactors(n):\n    i,f = 3,[]\n    while n&1 == 0:\n        f.append(2)\n        n = n >> 1\n    while i * i <= n:\n        if n % i: i+=2\n        else:\n            f.append(i)\n            n//=i\n    if n > 1: f.append(n)\n    return f\n\n@lru_cache(maxsize=None)\ndef factors(n):\n    pf = primefactors(n)\n    return { 1,n } | { reduce(mul,x) for z in range(1,len(pf)) for x in combinations(pf,z) }\n"]
["class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        #reverse trie\n        self.trie = {}\n        self.stream = deque([])\n\n        for word in set(words):\n            node = self.trie       \n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "\\\"\\\"\\\"\nTrie for reversed words\nfor each letter, we go reversedly of the input stream, and traverse the trie Trie for reversed words\nfor each letter, we go reversedly of the input stream, and traverse the trie if we can find a word when traversing\n\\\"\\\"\\\"\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n\n        for word in set(words):\n            node = self.trie       \n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n        \n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import deque\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n\n        for word in set(words):\n            node = self.trie       \n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n        \n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.isword = False\n        self.children = [None] * 26        \n\nclass StreamChecker:\n\n    def __init__(self, words):\n        self.root = TrieNode()\n        self.lastchars = []\n        for word in words:\n            self.add(word)\n            \n        \n    def add(self, word):\n        parent = self.root\n        for c in reversed(word):\n            i = ord(c) - 97\n            if not parent.children[i]: \n                parent.children[i] = TrieNode()\n            parent = parent.children[i]\n        parent.isword = True\n        \n    def search(self, word):\n        parent = self.root\n        \n        for c in reversed(word):\n            i = ord(c) - 97\n            if parent.isword: return True\n            if not parent.children[i]: return False\n            parent = parent.children[i]\n            \n        return parent.isword\n\n    def query(self, letter):\n        self.lastchars.append(letter)\n        return self.search(self.lastchars)\n\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.letters = ''\n        \n    def query(self, letter: str) -> bool:\n        self.letters +=letter\n        \n        for x in self.words:\n            if self.letters.endswith(x):\n                return True\n            \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.waitlist = []\n        for word in words:\n            t = self.trie\n            for w in word:\n                if w not in t:\n                    t[w] = {}\n                t = t[w]\n            t['#'] = '#'\n        \n        self.origin = self.trie.copy()\n        self.nodes = []\n\n    def query(self, letter):\n        res = False\n        self.nodes.append(self.trie)\n        new_nodes = []\n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if \\\"#\\\" in node:\n                    res = True\n                new_nodes.append(node)\n        self.nodes = new_nodes     \n        return res\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.add(word)\n        \n\n    def query(self, char: str) -> bool:\n        return self.trie.find(char)\n    \nclass Trie:\n    class Node:\n        def __init__(self, complete=False):\n            self.complete = complete\n            self.children = {}\n        \n    def __init__(self):\n        self.root = self.Node()\n        self.current = []\n    \n    def add(self, word: str) -> bool:\n        node = self.root\n        for index, char in enumerate(word):\n            if char not in node.children:\n                node.children[char] = self.Node(index == len(word) - 1)\n            node = node.children[char]\n            if index == len(word) - 1:\n                node.complete = index == len(word) - 1\n        return True\n    \n    def find(self, char: str) -> bool:\n        self.current.append(self.root)\n        self.current = [node.children[char] for node in self.current if char in node.children]\n        \n        return any(node.complete for node in self.current)\n        \n#         if not self.current or char not in self.current.children:\n#             self.current = self.root\n#             print(char, 'reset current')\n                \n#         self.current = self.current.children.get(char)\n        \n#         if self.current and self.current.complete:\n#             return True\n#         return False\n    \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "# class StreamChecker(object):\n\n#     def __init__(self, words):\n#         \\\"\\\"\\\"\n#         :type words: List[str]\n#         \\\"\\\"\\\"      \n#         self.waitlist = []\n#         self.trie = dict()\n#         for word in words:\n#             # create a temporary dict based off our root dict object\n#             temp_dict = self.trie\n#             for letter in word:\n#                 # update our temporary dict and add our current letter and a sub-dictionary\n#                 # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n#                 # otherwise it will directly return the existing value of key\n#                 temp_dict = temp_dict.setdefault(letter, dict())\n#             # If our word is finished, add {'#': '#'} at the stopping node\n#             temp_dict['#'] = '#'\n\n#     def query(self, letter):\n#         \\\"\\\"\\\"\n#         :type letter: str\n#         :rtype: bool\n#         \\\"\\\"\\\"\n#         waitlist = []\n#         # if letter can be the prefix of word\n#         if letter in self.trie:\n#             waitlist.append(self.trie[letter])\n#         # for each possible prefix, append letter if the new substr still can be a prefix\n#         for item in self.waitlist:\n#             if letter in item:\n#                 waitlist.append(item[letter])\n                \n#         self.waitlist = waitlist\n#         return any('#' in item for item in self.waitlist)\n    \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.entries = {}\n        for word in words:\n            curNode = self.entries           \n            for i in range(len(word)):\n                cur = word[i]\n                if cur not in curNode:\n                    curNode[cur] = {}\n                curNode = curNode[cur]\n            curNode[\\\"#\\\"] = True\n        self.nodes = []\n\n\n    def query(self, letter: str) -> bool:\n        res = False\n        self.nodes.append(self.entries)\n        new_nodes = []\n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if \\\"#\\\" in node:\n                    res = True\n                new_nodes.append(node)\n        self.nodes = new_nodes     \n        return res\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "\ndef add(ptr, c, nptrs):\n    # scan\n    if c in ptr:\n        n = ptr[c]\n        nptrs.append( n )\n        return 'fin' in n\n    return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        def add(word, i, pos):\n            # add to trie\n            if i == len(word):\n                pos['fin'] = True\n                return\n            c = word[i]\n            if c not in pos:\n                pos[c] = { 'with': c }\n            add(word, i + 1, pos[c])\n            \n        self._trie = { 'root': True, 'with': '$' }\n        root = self._trie\n        for w in words:\n            add(w, 0, root)\n            \n        self._ptrs = []\n        self._ptrs.append( root )\n        print(\\\"built\\\")\n        # print(f\\\"{self._trie}\\\")\n\n    def query(self, letter: str) -> bool:\n        \n        found = False\n        nptrs = []\n        ptrs = self._ptrs\n        for p in ptrs:\n            if add(p, letter, nptrs):\n                found = True\n        nptrs.append( self._trie )\n        self._ptrs = nptrs\n        return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker(object):\n\n    def __init__(self, words):  \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            temp_dict = self.trie\n            for letter in word:\n                temp_dict = temp_dict.setdefault(letter, dict())\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        waitlist = []\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter]) \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        nested = lambda: defaultdict(nested)\n        self.root = nested()\n\n        for w in words:\n            n = self.root\n            for c in w:\n                n = n[c]\n            n[\\\"\\\\0\\\"] = True\n        self.partials = [self.root]\n\n    def query(self, letter: str) -> bool:\n        self.partials = [self.root] + [p[letter] for p in self.partials if p[letter]]\n\n        return any(\\\"\\\\0\\\" in p for p in self.partials)\n", "class Trie:\n\n    def __init__(self):\n            \\\"\\\"\\\"\n            Initialize your data structure here.\n            \\\"\\\"\\\"\n            self.trie = {}\n\n\n    def insert(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        \\\"\\\"\\\"\n        trie = self.trie\n        for w in word:\n            if w not in trie:\n                trie[w] = {}\n            trie = trie[w]\n        trie['#'] = '#'\n    \n    def search(self, letters):\n        \n        trie = self.trie\n        i = len(letters) - 1\n        \n        \n        for l in letters[::-1]:\n            \n            if l in trie and '#' in trie[l]:\n                print(\\\"HHHH\\\")\n                return True\n                break\n            \n            if l not in trie:\n                return False\n            \n            trie = trie[l]\n            \n        if '#' in trie:\n            return True\n        else:\n            return False\n            \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.letters = []\n        \n        self.trie_check = Trie()\n        for w in words:\n            self.trie_check.insert(w[::-1])\n        \n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        # # i = len(self.letters) - 1\n        \n        # node = self.trie_check.trie\n        return self.trie_check.search(self.letters)\n        \n        # while i >= 0:\n        #     if '#' in node:\n        #         return True\n        #     if self.letters[i] not in node:\n        #         return False\n        #     node = node[self.letters[i]]\n        #     i -= 1\n        # return True if '#' in node else False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dict = list(set(words))\n        self.queries = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.queries += letter\n        for w in self.dict:\n            l = len(w)\n            # print(self.queries[-l:], w)\n            if self.queries[-l:] == w:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        for ele in words:\n            self.add(ele)\n        self.stack = [self.root]\n            \n    def add(self,ele):\n        current = self.root\n        for char in ele:\n            current = current.children[char]\n        current.last = True\n        \n    def query(self, letter: str) -> bool:\n        flag = False\n        new_stack = [self.root]\n        for ele in self.stack:\n            if letter in ele.children:\n                new_stack.append(ele.children[letter])\n                if ele.children[letter].last:\n                    flag = True\n        self.stack = new_stack\n        if flag:\n            return True\n        return False\n\nclass TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.last = False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.maxlen = len(words)\n        self.cache = ''\n        for w in words:\n            self.trie.insert(w[::-1])\n        \n    def query(self, letter: str) -> bool:\n        self.cache += letter\n        self.result = False\n        k = 1\n        node = self.trie.root\n        while k <= len(self.cache):\n            char = self.cache[-k]\n            if char in node.children:\n                self.result = self.result or node.children[char].isEnd\n                k += 1\n                node = node.children[char]\n            else:\n                break\n        \n        if len(self.cache) > self.maxlen:\n            self.cache = self.cache[1:]\n        return self.result\n \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.is_word = False\n        self.chars = {}\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        self.prev_nodes = []\n        \n    def addWord(self, word):\n        curr = self.root\n        for c in word:\n            if c not in curr.chars:\n                curr.chars[c] = TrieNode()\n            curr = curr.chars[c]\n        curr.is_word = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        \n        for word in words:\n            self.trie.addWord(word)\n\n    def query(self, letter: str) -> bool:\n        curr_nodes = []\n        for prev_node in self.trie.prev_nodes:\n            if letter in prev_node.chars:\n                curr_nodes.append(prev_node.chars[letter])\n        if letter in self.trie.root.chars:\n            curr_nodes.append(self.trie.root.chars[letter])\n        self.trie.prev_nodes = curr_nodes\n        found_letter = False\n        for node in curr_nodes:\n            if node.is_word:\n                found_letter = True\n        return found_letter\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)", "\nclass Trie(object):\n    class Node(object):\n        def __init__(self, end=False):\n            self.children = {}\n            self.end = end\n\n    def __init__(self):\n        \\\"\\\"\\\"\n        Initialize your data structure here.\n        \\\"\\\"\\\"\n        self.root = self.Node()\n\n    def insert(self, word):\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        :type word: str\n        :rtype: None\n        \\\"\\\"\\\"\n        current_node = self.root\n        prev_node = current_node\n        for letter in word:\n            if letter not in current_node.children:\n                current_node.children[letter] = self.Node()\n            prev_node = current_node\n            current_node = current_node.children[letter]\n        prev_node.children[letter].end = True\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for w in words:\n            self.trie.insert(w)\n        self.current_nodes = [self.trie.root]\n\n    def query(self, letter: str) -> bool:\n        self.current_nodes = [cn.children[letter] for cn in self.current_nodes if letter in cn.children]\n        if self.trie.root not in self.current_nodes:\n            self.current_nodes.append(self.trie.root)\n        end = any([cn.end for cn in self.current_nodes])\n        return end\n\n    ", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        \n        for word in words:\n            curnode = self.root\n            for ch in word:\n                if ch not in curnode:\n                    curnode[ch] = {}\n                curnode = curnode[ch]\n            curnode['is_end'] = True\n        \n        self.leads = [self.root] # the pointers to the threads we follow right now\n\n    def query(self, letter: str) -> bool:\n        next_leads = [self.root]\n        found_word = False\n        \n        for lead in self.leads:\n            if letter in lead:\n                new_lead = lead[letter]\n                next_leads.append(new_lead)\n                if 'is_end' in new_lead:\n                    found_word = True\n            \n        self.leads = next_leads\n        return found_word\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = {}\n        for word in words:\n            node = self.root\n            for c in word[::-1]:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['$'] = True\n        self.stream = []\n\n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        node = self.root\n        for c in self.stream[::-1]:\n            if c in node:\n                node = node[c]\n                if '$' in node:\n                    return True\n            else:\n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\nclass StreamChecker:\n    TERMINAL = None\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.build_trie(words)\n        self.cursors = deque([])\n        \n    def build_trie(self, words: List[str]):\n        trie = self.trie\n        for word in words:\n            node = trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node[self.TERMINAL] = True\n\n    def query(self, letter: str) -> bool:\n        cursors = self.cursors\n        cursors.append(self.trie)\n        found = False\n        \n        valid_cursors = []\n        \n        while cursors:\n            cursor = cursors.popleft()\n            if letter in cursor:\n                cursor = cursor[letter]\n                valid_cursors.append(cursor)\n                if self.TERMINAL in cursor:\n                    found = True\n                    \n        cursors.extend(valid_cursors)\n                    \n        return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n\n    def __init__(self):\n            \\\"\\\"\\\"\n            Initialize your data structure here.\n            \\\"\\\"\\\"\n            self.trie = {}\n\n\n    def insert(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        \\\"\\\"\\\"\n        trie = self.trie\n        for w in word:\n            if w not in trie:\n                trie[w] = {}\n            trie = trie[w]\n        trie['#'] = '#'\n    \n    def search(self, letters):\n        \n        trie = self.trie\n        letters = letters[::-1]\n        \n        for l in letters:\n            \n            if '#' in trie:\n                return True\n            \n            if l not in trie:\n                return False\n            \n            trie = trie[l]\n            \n        if '#' in trie:\n            return True\n        else:\n            return False\n            \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.letters = []\n        \n        self.trie_check = Trie()\n        for w in words:\n            self.trie_check.insert(w[::-1])\n        \n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        return self.trie_check.search(self.letters)\n        \n       \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.end = False\n\nclass Trie:\n    def __init__(self, words):\n        self.root = TrieNode()\n        self.processing = []\n        for word in words:\n            self.add(word)\n    \n    def add(self, word):\n        node = self.root\n        for c in word:\n            node = node.children[c]\n        node.end = True\n    \n    def search(self, c):\n        processed = []\n        self.processing.append(self.root)\n        found = False\n        for node in self.processing:\n            if c in node.children:\n                node = node.children[c]\n                processed.append(node)\n                found |= node.end\n        \n        self.processing = processed\n        return found\n        \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie(words)\n\n    def query(self, letter: str) -> bool:\n        return self.trie.search(letter)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words={}\n        \n        for i in words:\n            cur=self.words\n            for l in i[::-1]:\n                if l not in cur:\n                    cur[l]={}\n                cur=cur[l]\n            cur['.']={}\n                \n        self.his=[]\n        \n    def query(self, letter: str) -> bool:\n        self.his.append(letter)\n        cur=self.words\n        for i in self.his[::-1]:\n            if cur.get(i)==None:\n                return False\n            cur=cur[i]\n            if '.' in cur:\n                return True\n            \n        return False\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\nclass TrieNode:\n    def __init__(self, char):\n        self.char = char\n        self.children = {}\n        self.eow = False\n        \nclass Trie:\n    def __init__(self):\n        self.rootTrie = TrieNode('*')\n        self.currNode = self.rootTrie\n    \n    def addWord(self, word):\n        self.currNode = self.rootTrie\n        for idx, char in enumerate(word):\n            if char not in self.currNode.children:\n                charNode = TrieNode(char)\n                self.currNode.children[char] = charNode\n            \n            self.currNode = self.currNode.children[char]\n\n        self.currNode.eow = True\n    \n    def findNext(self, lettersQ):\n        self.currNode = self.rootTrie\n        \n        for char in lettersQ:\n            if char in self.currNode.children:\n                self.currNode = self.currNode.children[char]\n                \n                if self.currNode.eow:\n                    return True\n            else:\n                return False\n            \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.streamTrie = Trie()\n        self.lettersQ = deque()\n        \n        for word in words:\n            self.streamTrie.addWord(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.lettersQ.appendleft(letter)\n        \n        if len(self.lettersQ) > 2000:\n            self.lettersQ.pop()\n            \n        return self.streamTrie.findNext(self.lettersQ)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.is_word = False\n        self.children = defaultdict(TrieNode)\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def add_word(self, word):\n        node = self.root\n        for c in word:\n            node = node.children[c]\n        node.is_word = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.add_word(word)\n            \n        self.candidates = [self.trie.root]\n\n    def query(self, letter: str) -> bool:\n        new_candidates = [self.trie.root]\n        ans = False\n        for option in self.candidates:\n            if letter in option.children:\n                child = option.children[letter]\n                new_candidates.append(child)\n                ans = ans or child.is_word\n        self.candidates = new_candidates\n        return ans\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.children = defaultdict(list)\n        self.end_of_word = False\n\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        self.nodes = []\n        for word in words:\n            self.addWord(word)\n\n        \n    def addWord(self, word):\n        node = self.root\n        for w in word:\n            if w not in node.children:\n                node.children[w] = Trie()\n            node = node.children[w]\n        node.end_of_word = True\n\n        \n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.root)\n        temp = False\n        new_nodes = []\n        \n        for node in self.nodes:\n            if letter in node.children:\n                node = node.children[letter]\n                if node.end_of_word:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes = new_nodes\n        return temp\n        \n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        self.wl = []\n        for word in words:\n            trie = self.trie\n            for w in word:\n                trie[w] = trie.get(w, dict())\n                trie = trie[w]\n            trie[\\\"#\\\"] = '#'\n        \n        # print(self.trie)\n        \n\n    def query(self, letter: str) -> bool:\n        # print(letter, self.wl)\n        wl = []\n        if letter in self.trie:\n            wl.append(self.trie[letter])\n        \n        for i in self.wl:\n            \n            if letter in i:\n                wl.append(i[letter])\n        \n        self.wl = wl\n        \n        return any('#' in i for i in self.wl)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self, value, leaf=False, children=None):\n        self.children = children or {}\n        self.value = value\n        self.leaf = leaf\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode(value=None)\n        self.pointers = []\n        for word in words:\n            node = self.root\n            for c in word:\n                if c not in node.children:\n                    c_node = TrieNode(c)\n                    node.children[c] = c_node\n                node = node.children[c]\n            node.leaf = True\n        \n    def query(self, letter: str) -> bool:\n        result = False\n        revised_pointers = []\n        self.pointers.append(self.root)\n        for pointer in self.pointers:\n            if letter in pointer.children:\n                node = pointer.children[letter]\n                if node.leaf:\n                    result |= True\n                revised_pointers.append(node)\n        self.pointers = revised_pointers\n        return result\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.waiting = []\n        for word in words: \n            self.root.insert(word)\n        \n        \n    def query(self, letter: str) -> bool:\n        \n        temp = []\n        for node in self.waiting + [self.root]:\n            if letter in node.child:\n                temp.append(node.child[letter])\n        \n        self.waiting = temp\n                \n                \n        for node in self.waiting:\n            if node.is_complete:\n                return True\n        \n        return False\n            \n\nclass TrieNode:\n    def __init__(self):\n        self.child = {}\n        self.is_complete = False\n        \n    def insert(self,word): \n        node = self\n        for letter in word:\n            if letter not in node.child:\n                new_node = TrieNode()\n                node.child[letter] = new_node\n            node = node.child[letter]\n        node.is_complete = True\n        \n    \n        \n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        \n        self.q = []\n        \n        self.head = {}\n        for word in words:\n            cur = self.head\n            for w in word[::-1]:\n                if w not in cur:\n                    cur[w] = {}\n                \n                cur = cur[w]\n            \n            cur[\\\"$\\\"] = True \n        \n        \n\n    def query(self, letter: str) -> bool:\n        self.q.append(letter)\n        \n        cur = self.head\n        for c in self.q[::-1]:\n            if \\\"$\\\" in cur:\n                return True\n            \n            if c not in cur:\n                return False\n            \n            cur = cur[c]\n            \n        \n        return '$' in cur\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            root = self.trie\n            for ch in word:\n                if ch not in root:\n                    root[ch]= {}\n                root = root[ch]\n\n            root['*'] = True \n        self.storech = []\n    def query(self, letter: str) -> bool:\n        a = False \n        storech = []\n        if letter in self.trie:\n            storech.append(self.trie[letter])\n        for ele in self.storech:\n            if letter in ele:\n                storech.append(ele[letter])\n        self.storech = storech \n        return any('*' in ele for ele in self.storech)\n        \n            \n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.d = defaultdict(dict)\n        for word in words:\n            word = word[::-1]\n            d = self.d\n            for c in word[:-1]:\n                d[c] = d.get(c) or defaultdict(dict)\n                d = d[c]\n            c = word[-1]\n            if c not in d:\n                d[c] = {'0': 1}\n            else:\n                d[c]['0'] = 1\n            self.queue = []\n\n\n    def query(self, letter: str) -> bool:\n        self.queue.append(letter)\n        d = self.d\n        for c in self.queue[::-1]:\n            if c in d:\n                d = d[c]\n                if '0' in d:\n                    return True\n            else:\n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    _end = '_end_'\n\n    def __init__(self, words):\n        self.root = dict()\n        self.where = [self.root]\n        self.delete = set()\n        for word in words:\n            current_dict = self.root\n            for letter in word:\n                current_dict = current_dict.setdefault(letter, {})\n            current_dict[Trie._end] = Trie._end\n\n    def next(self, letter):\n        ret = False\n        self.where.append(self.root)\n        for (i, where) in enumerate(self.where):\n            if letter not in where:\n                self.delete.add(i)\n            else:\n                self.where[i] = where[letter]\n                if Trie._end in where[letter]:\n                    ret = True\n        for i in reversed(sorted(self.delete)):\n            del self.where[i]\n        self.delete = set()\n        return ret\n\n    def to_delete(self):\n        return self.delete\n\n    def has(self, word):\n        current_dict = self.root\n        for letter in word:\n            if letter not in current_dict:\n                return False\n            current_dict = current_dict[letter]\n        return Trie._end in current_dict\n\n    def add(self, word):\n        current_dict = self.root\n        for letter in word:\n            current_dict = current_dict.setdefault(letter, {})\n        current_dict[Trie._end] = Trie._end\n\n\n\nclass StreamChecker:\n\n    def __init__(self, words):\n        self.Trie = Trie(words)\n\n    def query(self, letter):\n        return(self.Trie.next(letter))\n\n", "class Node:\n    def __init__(self, val, is_word=False):\n        self.val = val\n        self.children = {}\n        self.is_word = is_word\n\n        \n    def __repr__(self):\n        return self.val\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Node(\\\"\\\")\n        \n        for word in words:\n            node = self.root\n            for letter in word:\n                if letter not in node.children:\n                    node.children[letter] = Node(letter)\n                node = node.children[letter]\n            node.is_word = True\n\n        self.nodes = []\n            \n        \n    def query(self, letter: str) -> bool:\n        next_nodes = []\n        for node in self.nodes:\n            if letter in node.children:\n                next_nodes.append(node.children[letter])\n        self.nodes = next_nodes\n        \n        if letter in self.root.children:\n            self.nodes.append(self.root.children[letter])\n\n        for node in self.nodes:\n            if node.is_word:\n                return True\n            \n        return False\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    from collections import defaultdict\n    \n    class TrieNode:\n        def __init__(self):\n            self.children = defaultdict()\n            \n    def __init__(self, words: List[str]):\n        self.stream = []\n        self.root = self.TrieNode()\n        curr = self.root\n        for word in words:\n            for c in reversed(word):\n                if c in curr.children.keys():\n                    curr = curr.children[c]\n                else:\n                    curr.children[c] = self.TrieNode()\n                    curr = curr.children[c]\n            curr.children[\\\"$\\\"] = self.TrieNode()\n            curr = self.root                \n\n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        curr = self.root\n        for l in reversed(self.stream):\n            if l in curr.children.keys():\n                curr = curr.children[l]\n                if \\\"$\\\" in curr.children.keys():\n                    return True\n            else:\n                return False\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            temp_dict = self.trie\n            for letter in word:\n                temp_dict = temp_dict.setdefault(letter, dict())\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.terminal = False\n            \n    def __init__(self, words: List[str]):\n        self.array = []\n        self.root = self.TrieNode()\n        for word in words:\n            node = self.root\n            for char in word[::-1]:\n                if char not in node.children:\n                    node.children[char] = self.TrieNode()\n                node = node.children[char]\n            node.terminal = True\n\n    def query(self, letter: str) -> bool:\n        self.array.append(letter)\n        node = self.root\n        array = self.array[::-1]\n        for char in array:\n            if char in node.children:\n                node = node.children[char]\n                if node.terminal:\n                    return True\n            else:\n                return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter: str) -> bool:\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import defaultdict\nfrom typing import List, Dict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children: Dict[str, TrieNode] = {}\n        self.is_terminal: bool = False\n\n    def __repr__(self):\n        return f\\\"<terminal = {self.is_terminal}, children = {self.children}>\\\"\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self._starts_with: Dict[str, List[str]] = defaultdict(list)\n        unique_words = set(words)\n        self._trie = TrieNode()\n        for word in unique_words:\n            self._add_to_trie(word)\n        #print(self._trie)\n\n        self._pointers: List[TrieNode] = []\n\n\n    def _add_to_trie(self, word: str):\n        trie_node = self._trie\n        for i, c in enumerate(word):\n            if c not in trie_node.children:\n                trie_node.children[c] = TrieNode()\n            trie_node = trie_node.children[c]\n            if i == len(word) - 1:\n                trie_node.is_terminal = True\n\n\n    def query(self, letter: str) -> bool:\n        #print(letter)\n        #print(f\\\"Starting out with {self._pointers}\\\")\n        # Advance pointers currently active\n        advancing_pointers = []\n        found = False\n\n        for trie_node in self._pointers:\n            new_node = trie_node.children.get(letter)\n            if new_node is not None:\n                if new_node.is_terminal:\n                    found = True\n                advancing_pointers.append(new_node)\n\n        from_root = self._trie.children.get(letter)\n        if from_root is not None:\n            if from_root.is_terminal:\n                found = True\n            advancing_pointers.append(from_root)\n\n        self._pointers = advancing_pointers\n        return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = {}\n        for w in words:\n            curr = self.root\n            for ch in w:\n                if ch not in curr:\n                    curr[ch] = {}\n                curr = curr[ch]\n\n            curr[0] = None\n\n        self.cursors = []\n\n    def query(self, letter: str) -> bool:\n        self.cursors.append(self.root)\n        new_cursors = []\n        res = False\n\n        for c in self.cursors:\n            if letter in c:\n                if 0 in c[letter]:\n                    res = True\n                new_cursors.append(c[letter])\n\n        self.cursors = new_cursors\n        return res\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n# class Trie:\n#     def __init__(self):\n#         self.trie = {}\n        \n#     def add_word(self,word):\n#         nextLevel = self.trie\n#         for i,char in enumerate(word):\n#             isWord = i == len(word) - 1\n#             if char in nextLevel:\n#                 if isWord:\n#                     nextLevel[char].isWord = True\n#                 nextLevel = nextLevel[char].children\n#             else:\n#                 node = TrieNode(char, isWord)\n#                 nextLevel[char] = node\n#                 nextLevel = nextLevel[char].children\n            \n        \n# class TrieNode:\n#     def __init__(self, char, isWord = False):\n#         self.char = char\n#         self.isWord = isWord\n#         self.children = {}\n\n\n# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         self.words = set(words)\n#         self.trie = Trie()\n#         for word in words:\n#             self.trie.add_word(word)\n            \n#         self.nextLevels = []\n\n#     def query(self, letter: str) -> bool:\n#         print(len(self.nextLevels))\n#         nextLevels = []\n#         isWord = False\n#         if len(self.nextLevels):\n#             for level in self.nextLevels:\n#                 if letter in level:\n#                     if level[letter].isWord:\n#                         isWord = True\n#                     nextLevels.append(level[letter].children)\n        \n#         if letter in self.trie.trie:\n#             nextLevels.append( self.trie.trie[letter].children )\n#             if self.trie.trie[letter].isWord:\n#                 isWord = True\n                \n#         self.nextLevels = nextLevels\n    \n#         return isWord\n    \n", "\nclass Tree:\n    def __init__(self, val= ''):\n        self.val = val\n        self.isTerminal = False\n        self.subs = dict()\n        \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.possibleNodes = list()\n        self.root = Tree()\n        \n        for word in words:\n            traverser = self.root\n            for char in word:\n                if char in traverser.subs:\n                    traverser=traverser.subs[char]\n                else:\n                    node = Tree(char)\n                    traverser.subs[char] = node\n                    traverser = node\n            traverser.isTerminal = True\n        \n\n    def query(self, letter: str) -> bool:\n        \n        newPossibleNodes = []\n        if letter in self.root.subs:\n            newPossibleNodes.append(self.root.subs[letter])\n            \n        \n        for node in self.possibleNodes:\n            if letter in node.subs:\n                newPossibleNodes.append(node.subs[letter])\n                \n        \n        self.possibleNodes = newPossibleNodes\n        \n        for node in newPossibleNodes:\n            if node.isTerminal:\n                return True\n            \n        return False\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class WordNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isFront = False\n\nclass WordTrie:\n    def __init__(self):\n        self.head = WordNode()\n        \n    def addWord(self, word):\n        node = self.head\n        for c in word[::-1]:\n            if not node.children[ord(c)-ord('a')]:\n                node.children[ord(c)-ord('a')] = WordNode()\n            node = node.children[ord(c)-ord('a')]\n        node.isFront = True\n        \n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.Trie = WordTrie()\n        for w in words:\n            self.Trie.addWord(w)\n        self.queries = []\n\n    def query(self, letter: str) -> bool:\n        self.queries.append(letter)\n        node = self.Trie.head\n        for l in self.queries[::-1]:\n            if not node.children[ord(l)-ord('a')]: return False\n            node = node.children[ord(l)-ord('a')]\n            if node.isFront: return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class trie:\n    def __init__(self,val=None):\n        self.val = val\n        self.next = {}\n        self.is_complete = False\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = trie()\n        ### insert all words in trie\n        for w in words:\n            node=self.root\n            for c in w[::-1]:\n                if c not in node.__next__:\n                    node.next[c] = trie(c)\n                node=node.next[c]\n            node.is_complete=True\n        \n        ###to keep track of previous queries\n        self.queries = []\n        \n        \n        \n    def query(self, letter: str) -> bool:\n        self.queries.append(letter)\n        \n        ### search in trie\n        node = self.root\n        for c in self.queries[::-1]:\n            if c not in node.__next__:\n                return False\n            node=node.next[c]\n            if node.is_complete:\n                return True\n            \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    \\\"\\\"\\\"\n    Keeps the list of Node, as entry point, using hashing.\n    \\\"\\\"\\\"\n    nodes = {}\n    \nclass Node:\n    char_id = None\n    end = False\n    next_char_ids = []\n    \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        # self.char_set = set()\n        # for word in words:\n        #     self.char_set = self.char_set.union(iter(word))\n        self.trie = self.build_trie(words)\n        self.curr_tries = []\n        \n    def build_trie(self, words):\n        \\\"\\\"\\\"\n        Building reverse trie can be usable for \n        suffix search.\n        \\\"\\\"\\\"\n        trie = {}\n        for word in words:\n            c = word[0]\n            if c in trie:\n                trie_tmp = trie[c]\n            else:\n                trie[c] = {}\n                trie_tmp = trie[c]\n\n            for c in word[1:]:\n                if c not in trie_tmp:\n                    trie_tmp[c] = {}\n                trie_tmp = trie_tmp[c]\n            trie_tmp[\\\"ends\\\"] = True\n        return trie        \n    \n    def query(self, char) -> bool:\n        \\\"\\\"\\\"\n        Keep the Trie Tree traversal pointer.\n        \\\"\\\"\\\"\n        if char in self.trie:\n            self.curr_tries.append(self.trie)\n        \n        new_curr_tries = []\n        a_word = False\n        for ind, curr_trie in enumerate(self.curr_tries):\n            if char in curr_trie:\n                curr_trie[char] and new_curr_tries.append(curr_trie[char])\n                # Once it turns positive, stay positive. Means one of the\n                # trie path, we found word boundary.\n                a_word = a_word or \\\"ends\\\" in curr_trie[char]\n        self.curr_tries = new_curr_tries\n        return a_word\n        \n    def query1(self, char: str) -> bool:\n        if self.curr_trie:\n            if char in self.curr_trie:\n                a_word = \\\"ends\\\" in self.curr_trie[char]\n                self.curr_trie = self.curr_trie[char]\n                return a_word\n            else:\n                self.curr_trie = {}\n                return False\n        else:\n            # Address the chance of single char only words.\n            self.curr_trie = self.trie.get(char, {})\n            return \\\"ends\\\" in self.curr_trie\n        \n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.isword = False\n        self.children = [None] * 26        \n\nclass StreamChecker:\n\n    def __init__(self, words):\n        self.root = TrieNode()\n        self.lastchars = ''\n        self.maxlen = 0\n        for word in words:\n            self.add(word)\n            self.maxlen = max(self.maxlen, len(word))\n            \n        \n    def add(self, word):\n        parent = self.root\n        for c in reversed(word):\n            i = ord(c) - 97\n            if not parent.children[i]: \n                parent.children[i] = TrieNode()\n            parent = parent.children[i]\n        parent.isword = True\n        \n    def search(self, word):\n        parent = self.root\n        \n        for c in word:\n            i = ord(c) - 97\n            if parent.isword: return True\n            if not parent.children[i]: return False\n            parent = parent.children[i]\n            \n        return parent.isword\n\n    def query(self, letter):\n        self.lastchars = (letter + self.lastchars)[0 : self.maxlen]\n        return self.search(self.lastchars)\n\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.possible = []\n        for word in words:\n            t = self.trie\n            for c in word:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t['#'] = '#'\n\n    def query(self, letter: str) -> bool:\n        temp = []\n        if letter in self.trie:\n            temp.append(self.trie[letter])\n        for d in self.possible:\n            if letter in d:\n                temp.append(d[letter])\n        self.possible = temp\n        return any('#' in item for item in self.possible)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words :\n            cur = self.trie\n            for chrs in word:\n                if chrs not in cur:\n                    cur[chrs] = {}\n                cur = cur[chrs]\n            cur['#'] = True\n        self.stream = collections.deque()\n        print((self.trie))\n\n    def query(self, letter: str) -> bool:\n        temp = collections.deque()\n        self.stream.append(self.trie)\n        for p in self.stream:\n            if letter in p:\n                temp.append(p[letter])\n        self.stream = temp\n        for p in self.stream:\n            if '#' in p:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tree = Tree('0', [])\n        for item in words:\n            curr = self.tree\n            for letter in item[::-1]:\n                result = curr.in_list(letter)\n                if result is None:\n                    curr.subtrees.append(Tree(letter, []))\n                    curr = curr.subtrees[-1]\n                else:\n                    curr = curr.subtrees[result]\n            curr.food = True\n        self.q = ''\n\n    def query(self, letter: str) -> bool:\n        self.q += letter\n        reverse_q = self.q[::-1]\n        curr = self.tree\n        for letter in reverse_q:\n            result = curr.in_list(letter)\n            if result is None:\n                return False\n            else:\n                curr = curr.subtrees[result]\n                if curr.food:\n                    return True\n        return False\n\n\nclass Tree:\n    def __init__(self, root, subtrees: List):\n        self.root = root\n        self.food = False\n        self.subtrees = subtrees\n\n    def in_list(self, letter: str):\n        for i, item in enumerate(self.subtrees):\n            if item.root == letter:\n                return i\n        return None", "class TrieNode:\n    def __init__(self):\n        self.letters = {}\n        self.word = False        \n    def trie(self, words):\n        root = TrieNode()\n        for word in words:\n            current = root\n            for letter in word:\n                if letter not in current.letters:\n                    current.letters[letter] = TrieNode()\n                current = current.letters[letter]\n            current.word = True\n        return root\n            \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        trie = TrieNode()\n        self.root = trie.trie(words)\n        self.left = [self.root]\n        \n                \n\n    def query(self, letter: str) -> bool:\n        right = [self.root]\n        finded = False\n        for trie in self.left:\n            if letter in trie.letters:\n                tmp = trie.letters[letter]\n                right += [tmp]\n                if tmp.word:\n                    finded = True\n        self.left = right\n        return finded\n                    \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:    \n    def __init__(self, words: List[str]):\n        self.data = {}\n        for word in words:\n            self._add_word(word)\n        self.q = []\n    \n    def _add_word(self, word):\n        word += '$'\n        d = self.data\n        for char in word:\n            if char not in d:\n                d[char] = {}\n            d = d[char]\n\n    def query(self, letter: str) -> bool:\n        new_q = []\n        \n        if letter in self.data:\n            new_q.append(self.data[letter])\n        \n        for acc in self.q:\n            if letter in acc:\n                new_q.append(\n                    acc[letter]\n                )\n        self.q = new_q\n        \n        for acc in self.q:\n            if '$' in acc:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes = []\n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes = new_nodes\n        return temp\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for w in words:\n            node = self.trie\n            for char in w:\n                node.setdefault(char,{})\n                node = node[char]\n            node.setdefault('*',w)\n        self.curr = deque([self.trie])\n\n    def query(self, letter: str) -> bool:\n        ret = False\n        for _ in range(len(self.curr)):\n            node = self.curr.popleft()\n            if letter in node:\n                node = node[letter]\n                self.curr.append(node)\n                if '*' in node:\n                    ret = True\n        self.curr.append(self.trie)\n        return ret\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "def to_index(c):\n    return ord(c) - ord('a')\n\nclass Node:\n    def __init__(self, val = None):\n        self.val = val\n        self.end = False\n        self.childs = [None] * (ord('z') - ord('a') + 1)\n\nclass Trie:\n\n    def __init__(self):\n        self.root = Node()\n        \n\n    def insert(self, word: str) -> None:\n        ptr = self.root\n        for c in word:\n            i = to_index(c)\n            if ptr.childs[i] is None:\n                node = Node(c)\n                ptr.childs[i] = node\n            ptr = ptr.childs[i]\n        ptr.end = True\n\n    def search(self, word: str) -> bool:\n        ptr = self.root\n        for c in word:\n            i = to_index(c)\n            if ptr.childs[i] is None:\n                return False\n            ptr = ptr.childs[i]\n        return ptr.end == True\n        \n\n    def startsWith(self, prefix: str) -> bool:\n        ptr = self.root\n        for c in prefix:\n            i = to_index(c)\n            if ptr.childs[i] is None:\n                return False\n            ptr = ptr.childs[i]\n        return True     \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        for w in words:\n            self.t.insert(w)\n        self.d = set()\n        self.n = 2000\n        self.k = deque()\n        self.store = {}\n\n    def query(self, letter: str) -> bool:\n        r = False\n        if len(self.k) == self.n:\n            self.k.popleft()\n        i = to_index(letter)\n        self.k.append(i)\n        v = self.store.get(tuple(self.k), None)\n        if v is not None:\n            self.d, r = v\n            return r\n        new_d = set()\n        for node in self.d:\n            if node.childs[i] is not None:\n                new_d.add(node.childs[i])\n                if node.childs[i].end: r = True\n        if self.t.root.childs[i] is not None:\n            new_d.add(self.t.root.childs[i])\n            if self.t.root.childs[i].end: r = True\n        self.d = tuple(new_d)\n        self.store[tuple(self.k)] = (self.d, r)\n        return r\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self):\n        self.c = collections.defaultdict(Node)\n        self.e = 0\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        for w in words:\n            temp = self.root\n            for i in w:\n                temp = temp.c[i]\n            temp.e = 1\n        self.w = []\n\n    def query(self, letter: str) -> bool:\n        # isIn = 0\n        # temp = []\n        self.w = [i.c[letter] for i in self.w+[self.root] if letter in i.c]\n        return any(i.e for i in self.w)\n#                     if letter in i.c:\n#                         temp.append(i.c[letter])\n#                         if not isIn:\n#                             isIn = temp[-1].e\n                \n#         if letter in self.root.c:\n#             temp.append(self.root.c[letter])\n#             if not isIn:\n#                 isIn = temp[-1].e\n                \n        # self.w = temp.copy()\n        # print(i.c. for i in self.w)\n        # return isIn\n                \n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\nclass Node:\n    def __init__(self, char):\n        self.char = char\n        self.children = {}\n        self.word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = Node(\\\"\\\")\n\n    def add_word(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = Node(char)\n            node = node.children[char]\n        node.word = True\n\n    def prefix_of_word_exists(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n            if node.word:\n                return True\n        return False\n        \n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.max_word_length = 0\n        for word in words:\n            self.trie.add_word(word[::-1])\n            self.max_word_length = max(self.max_word_length, len(word))\n        self.q = deque()\n\n    def query(self, letter: str) -> bool:\n        if len(self.q) == self.max_word_length:\n            self.q.pop()\n        self.q.appendleft(letter)\n        return self.trie.prefix_of_word_exists(self.q)\n    # [\\\"cde\\\"]\n    # [\\\"c\\\" Node<d>, \\\"d\\\" None] e\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.child = defaultdict(TrieNode)\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.waitlist = []\n        for word in words:\n            node = self.root\n            for ch in word:\n                node = node.child[ch]\n            \n            node.child['#'] = defaultdict(TrieNode)\n\n    def query(self, letter: str) -> bool:\n        waitlist = []\n        now = self.root\n        if letter in now.child:\n            waitlist.append(now.child[letter])\n\n        for node in self.waitlist:\n            if letter in node.child:\n                waitlist.append(node.child[letter])\n                \n        self.waitlist = waitlist\n        for node in waitlist:\n            if '#' in node.child:\n                return True\n            \n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.points = [self.trie]\n        for word in words:\n            cur = self.trie\n            for w in word:\n                if not w in cur:\n                    cur[w] = {}\n                cur = cur[w]\n            cur['#'] = None\n\n    def query(self, letter: str) -> bool:\n        temp = [self.trie]\n        ret = False\n        for p in self.points:\n            if letter in p:\n                p = p[letter]\n                if '#' in p:\n                    ret = True\n                temp.append(p)\n        self.points = temp\n        return ret\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            temp = self.trie\n            for char in word:\n                if char not in temp:\n                    temp[char] = {}\n                temp = temp[char]\n            temp['*'] = True\n        self.pointer = deque()\n\n    def query(self, letter: str) -> bool:\n        temp = self.trie\n        self.pointer.append(temp)\n        length = len(self.pointer)\n        flag = False\n        for i in range(length):\n            node = self.pointer.popleft()\n            if letter in node:\n                node = node[letter]\n                self.pointer.append(node)\n                if '*' in node:\n                    flag = True\n        return flag\n        \n                \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.d = {}\n        for w in words:\n            tmp = self.d\n            for i in w:\n                tmp = tmp.setdefault(i, {})\n            tmp['#'] = {}\n        self.cur = []\n    # def merge(self, d1, d2):\n    #     res = {}\n    #     for k in set(list(d1.keys()) + list(d2.keys())):\n    #         if k in d1 and k in d2:\n    #             res[k] = self.merge(d1[k], d2[k])\n    #         elif k in d1:\n    #             res[k] = d1[k]\n    #         else:\n    #             res[k] = d2[k]\n    #     return res\n\n    def query(self, letter: str) -> bool:\n        flag = False\n        cur_new = []\n        for prefix in self.cur:\n            if letter in prefix:\n                cur_new.append(prefix[letter])\n                if \\\"#\\\" in prefix[letter]:\n                    flag = True\n        if letter in self.d:\n            cur_new.append(self.d[letter])\n            if \\\"#\\\" in self.d[letter]:\n                flag = True\n        self.cur = cur_new\n        return flag\n\n        # flag = False\n        # tmp = {}\n        # if letter in self.cur:\n        #     tmp = self.cur[letter]\n        #     if ('#' in tmp):\n        #         flag = True\n        #         tmp.pop('#')\n        # self.cur = self.merge(tmp, self.d)\n        # return flag\n         \n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.neighbors = defaultdict(TrieNode)\n        self.isWord = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        for word in words:\n            node = self.root\n            for c in word:\n                node = node.neighbors[c]\n            node.isWord = True\n        self.nodes = []\n\n    def query(self, letter: str) -> bool:\n        isWord = False\n        newNodes = []\n        self.nodes.append(self.root)\n        for node in self.nodes:\n            if letter in node.neighbors:\n                temp = node.neighbors[letter]\n                isWord |= temp.isWord\n                newNodes.append(temp)\n        self.nodes = newNodes\n        return isWord\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for w in words:\n            node = self.trie\n            for i in w:\n                if i not in node:\n                    node[i] = {}\n                node = node[i]\n            node[\\\"end\\\"] = True\n        self.active = {\\\"\\\" : self.trie}\n\n    def query(self, letter: str) -> bool:\n        new_active = {}\n        ret = False\n        count = 0\n        \n        for a in self.active:\n            node = self.active[a]\n            if letter in node:\n                node = node[letter]\n                if \\\"end\\\" in node:\n                    ret = True\n                new_active[count] = node\n                count += 1\n        new_active[count] = self.trie\n        self.active = new_active\n        return ret\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker(object):\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.word_buf = []\n        self.wordDict = {}\n        for w in words:\n            temp_dict = self.wordDict\n            for c in w:\n                temp_dict = temp_dict.setdefault(c, dict())\n            temp_dict[\\\"EOS\\\"] = \\\"EOS\\\"\n        \n    def query(self, letter: str) -> bool:\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.wordDict:\n            waitlist.append(self.wordDict[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.word_buf:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.word_buf = waitlist\n        return any('EOS' in item for item in self.word_buf)\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TRIE:\n    \n    def __init__(self,next_letters=None,flag=False):\n        if not next_letters:\n            self.next_letters = {}\n        else:\n            self.next_letters = next_letters\n        self.flag = flag\n        \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # build a trie\n        self.root = TRIE()\n        for word in words:\n            curr_node = self.root\n            for l in word:\n                if l not in curr_node.next_letters:\n                    new_node = TRIE()\n                    curr_node.next_letters[l] = new_node\n                    curr_node = new_node\n                else:\n                    curr_node = curr_node.next_letters[l]\n            curr_node.flag = True\n        # a collection of curr_nodes\n        self.curr_nodes = set([self.root])\n        \n    def query(self, letter: str) -> bool:\n        found = False\n        new_curr_nodes = set([self.root]) # always add back root\n        for node in self.curr_nodes: \n            if letter in node.next_letters:\n                curr_node = node.next_letters[letter]\n                new_curr_nodes.add(curr_node)\n                if curr_node.flag:\n                    found = True\n        self.curr_nodes = new_curr_nodes\n        return found\n                \n                \n                \n            \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    \n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode()\n    \n    def addWord(self, word):\n        curr = self.root\n        for ch in word:\n            if ch not in curr.children:\n                new_node = TrieNode()\n                curr.children[ch] = new_node\n            curr = curr.children[ch]\n        curr.is_end = True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.addWord(reversed(word))\n        self.queue = collections.deque()\n            \n    def query(self, letter: str) -> bool:\n        self.queue.appendleft(letter)\n        curr = self.trie.root\n        for ch in self.queue:\n            if ch not in curr.children:\n                return False\n            if ch in curr.children:\n                curr = curr.children[ch]\n                if curr.is_end:\n                    return True\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    \\\"\\\"\\\"\n    Implementation of a prefix tree.\n    \\\"\\\"\\\"\n\n    def __init__(self):\n        self.root = {}\n\n    def add_word(self, w: str) -> None:\n        currNode = self.root\n        for c in w:\n            if c not in currNode:\n                currNode[c] = {}\n\n            currNode = currNode[c]\n\n        currNode['#'] = True  # Mark the word end.\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for w in words:\n            self.trie.add_word(w)\n\n        self.startNodes = []\n\n    def query(self, letter: str) -> bool:\n        nextStartNodes = [\n            node[letter] for node in self.startNodes + [self.trie.root]\n            if letter in node]\n        self.startNodes = nextStartNodes\n        return any('#' in node for node in nextStartNodes)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.words_trie = defaultdict(dict)\n        \n        for word in words:\n            trie_node = self.words_trie[word[-1]]\n            for letter in word[-2::-1]:\n                next_node = trie_node.setdefault(letter, {})\n                trie_node = next_node\n            trie_node[None] = None\n        \n        print((self.words_trie))\n        self.queries = []\n\n    def query(self, letter: str) -> bool:\n        self.queries.append(letter)\n        \n        trie_node = None\n        for query_letter in self.queries[::-1]:\n            if trie_node is None:\n                trie_node = self.words_trie.get(query_letter, {})\n            else:\n                trie_node = trie_node.get(query_letter, {})\n            \n            if not trie_node:\n                break\n            elif None in trie_node:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.add(word)\n        self.consideration = []\n\n    def query(self, letter: str) -> bool:\n        self.consideration = [node.words[letter] for node in self.consideration + [self.trie] if letter in node.words]\n        return any(node.is_word for node in self.consideration)\n        \n            \n\nclass Trie:\n    def __init__(self):\n        self.is_word = False\n        self.prefix = ''\n        self.words = {}\n    \n    def add(self, word):\n        if not word:\n            self.is_word = True\n            return\n        if word[0] in self.words:\n            self.words[word[0]].add(word[1:])\n        else:\n            n = Trie()\n            n.prefix = self.prefix + word[0]\n            self.words[word[0]] = n\n            self.words[word[0]].add(word[1:])\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    \n            \n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            startTrie = self.trie\n            for c in word:\n                if c not in startTrie:\n                    startTrie[c] = {}\n                startTrie = startTrie[c]\n            startTrie[\\\"isEnd\\\"] = True\n        self.openTries = []\n        # print(self.trie)\n\n    def query(self, letter: str) -> bool:\n        \n        # print(self.openTries)\n        \n        #Insert this new letter into our tries.\n        if letter in self.trie:\n            self.openTries.append(self.trie)\n        \n        #Increment these tries that are still open.\n        found = False\n        tempTries = []\n        while self.openTries:\n            trie = self.openTries.pop()\n            if letter in trie:\n                trie = trie[letter]\n                if \\\"isEnd\\\" in trie:\n                    found = True\n                tempTries.append(trie)\n        self.openTries = tempTries\n        return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            self.add_word_to_trie(self.trie, word, 0)\n        self.pointers = {}\n        self.q_no = 0\n        \n    def query(self, letter: str) -> bool:\n        self.q_no += 1\n        self.pointers[self.q_no] = self.trie\n        result = False\n        to_delete = []\n        for q_no, pointer in list(self.pointers.items()):\n            if letter not in pointer:\n                to_delete.append(q_no)\n                continue\n            self.pointers[q_no] = pointer[letter]\n            result = result or 1 in self.pointers[q_no]\n        for del_c in to_delete:\n            del self.pointers[del_c]\n        return result\n    \n    def add_word_to_trie(self, node, word, i):\n        if i == len(word):\n            node[1] = True\n            return\n        if word[i] not in node:\n            node[word[i]] = {}\n        self.add_word_to_trie(node[word[i]], word, i+1)\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            d = self.trie\n            for c in word:\n                if c not in d:\n                    d[c] = {}\n                d = d[c]\n            d['*'] = True\n        self.open_words = []\n\n    def query(self, letter: str) -> bool:\n        found = False\n        new_open_words = []\n        if letter in self.trie:\n            new_open_words.append(self.trie[letter])\n            if '*' in self.trie[letter]:\n                found = True\n        for word in self.open_words:\n            if letter in word:\n                if '*' in word[letter]:\n                    found = True\n                new_open_words.append(word[letter])\n        self.open_words = new_open_words\n        return found", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.char_stream = []\n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.char_stream.append(letter)\n        return self.trie.checkStream(self.char_stream[::-1])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\nclass TrieNode:\n    def __init__(self, children, isEnd=False):\n        self.children = children\n        self.isEnd = isEnd\n\nclass Trie:\n\n    def __init__(self):\n        \\\"\\\"\\\"\n        Initialize your data structure here.\n        \\\"\\\"\\\"\n        self.root = TrieNode({})\n\n    def insert(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        \\\"\\\"\\\"\n        node = self.root\n        for i, c in enumerate(word):\n            if c in node.children:\n                node = node.children[c]\n            else:\n                node.children[c] = TrieNode({})\n                node = node.children[c]\n                \n        node.isEnd = True\n\n    def search(self, word: str) -> bool:\n        \\\"\\\"\\\"\n        Returns if the word is in the trie.\n        \\\"\\\"\\\"\n        node = self.root\n        for c in word:\n            if c in node.children:\n                node = node.children[c]\n            else:\n                return False\n            \n        return node.isEnd\n    \n    \n    def checkStream(self, char_stream: List[str]) -> bool:\n        node = self.root\n        for c in char_stream:\n            if c in node.children:\n                node = node.children[c]\n                if node.isEnd:\n                    return True\n            else:\n                return False\n            \n        return False\n            \n\n    def startsWith(self, prefix: str) -> bool:\n        \\\"\\\"\\\"\n        Returns if there is any word in the trie that starts with the given prefix.\n        \\\"\\\"\\\"\n        node = self.root\n        for c in prefix:\n            if c in node.children:\n                node = node.children[c]\n            else:\n                return False\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)", "class TrieNode:\n    def __init__(self):\n        self.word = False\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.head = TrieNode()\n        self.head.word = True\n        \n    def insert(self, word):\n        itr = self.head\n        for c in word:\n            if c not in itr.children:\n                itr.children[c] = TrieNode()\n            itr = itr.children[c]\n        itr.word = True\n        \n    def contains(self, word):        \n        itr = self.head\n        for c in word:\n            if c in itr.children:\n                itr = itr.children[c]\n                if itr.word: return True\n            else:\n                return False\n        return itr.word        \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n        self.word = []\n    def query(self, letter: str) -> bool:\n        \n        self.word.append(letter)\n        return self.trie.contains(self.word[::-1])\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.dic = {}\n        \n        for w in words:\n            dic = self.dic\n            for c in w[::-1]:\n                if not c in dic:\n                    dic[c] = {}\n                dic = dic[c]\n            dic['#'] = True\n            \n        self.stack = []\n\n    def query(self, letter: str) -> bool:\n        \n        self.stack.append(letter)\n        \n        dic = self.dic\n        \n        for c in self.stack[::-1]:\n            if '#' in dic:\n                return True\n            \n            if c not in dic:\n                return False\n            \n            dic = dic[c]\n        \n        return dic.get('#', False)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            node = self.trie\n            for c in word:\n                try:\n                    node = node[c]\n                except KeyError:\n                    n = node[c] = {}\n                    node = n\n            node['$'] = None\n        self.index = 0\n        self.nodes = {}\n\n    def query(self, letter: str) -> bool:\n        nodes = {}\n        self.nodes[self.index] = self.trie\n        for i, node in list(self.nodes.items()):\n            try:\n                nodes[i] = node[letter]\n            except KeyError:\n                pass\n        \n        self.nodes = nodes\n        self.index += 1\n        return any('$' in node for node in list(nodes.values()))\n                \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.entries = {}\n        for word in words:\n            curNode = self.entries\n            for i in range(len(word)):\n                cur = word[i]\n                if cur not in curNode:\n                    curNode[cur] = {}\n                curNode = curNode[cur]\n            curNode[\\\"#\\\"] = True\n        self.nodes = []\n        \n\n    def query(self, letter: str) -> bool:\n        res = False\n        self.nodes.append(self.entries)\n        new_nodes = []\n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if \\\"#\\\" in node:\n                    res = True\n                new_nodes.append(node)\n        self.nodes = new_nodes     \n        return res\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from typing import List\n\nroot = '@'\nmarker = '$'\n\n\nclass TrieNode:\n    def __init__(self, letter):\n        self.letter = letter\n        self.children = dict()\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.spelt = False\n        self.root = TrieNode(root)\n        self.pointers = [self.root]\n\n        for word in words:\n            self.trie_insert(word)\n\n    def trie_insert(self, word: str):\n        current = self.root\n\n        for letter in word:\n            if letter in current.children:\n                current = current.children[letter]\n            else:\n                letter_node = TrieNode(letter)\n                current.children[letter] = letter_node\n                current = letter_node\n        current.children[marker] = TrieNode(marker)\n\n    def query(self, letter: str) -> bool:\n        new_ptrs = []\n        self.spelt = False\n        for ptr in self.pointers:\n            if letter in ptr.children:\n                advanced_ptr = ptr.children[letter]\n                if marker in advanced_ptr.children:\n                    self.spelt = True\n                new_ptrs.append(advanced_ptr)\n                \n        self.pointers = new_ptrs + [self.root]\n        return self.spelt\n\n", "class StreamChecker(object):\n    def __init__(self, words):\n        self.words = set(words)\n        self.added_chars = \\\"\\\"\n\n    def query(self, char):\n        self.added_chars += char\n        for w in self.words:\n            if self.added_chars.endswith(w):\n                return True\n        else:\n            return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self, x):\n        self.val=x\n        self.next={}\n        self.word=False\nclass Trie:\n    def __init__(self):\n        self.root=Node(None)\n    \n    def add(self, word):\n        root=self.root\n        for w in word:\n            if w not in root.__next__:\n                node=Node(w)\n                root.next[w]=node\n            root=root.next[w]\n        root.word=True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie=Trie()\n        self.key={}\n        self.pre=set([])\n        for i in words:\n            self.trie.add(i)\n\n    def query(self, letter: str) -> bool:\n        root=self.trie.root\n        temp=set([])\n        ans=False\n        for i in self.pre:\n            if letter in i.__next__:\n                node=i.next[letter]\n                if node.word:\n                    ans=True\n                temp.add(node)\n        if letter in root.__next__:\n            node=root.next[letter]\n            temp.add(node)\n            if node.word:\n                ans=True\n        self.pre=temp\n        return ans\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self, val: str, children: dict, isEnd=False):\n        self.val = val\n        self.children = children\n        self.isEnd = isEnd\n        \n        \nclass Trie:\n\n    def __init__(self):\n        \\\"\\\"\\\"\n        Initialize your data structure here.\n        \\\"\\\"\\\"\n        self.root = TrieNode(None, {}, False)\n\n    def insert(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        \\\"\\\"\\\"\n        node = self.root\n        for i, l in enumerate(word):\n            if l in node.children:\n                node = node.children[l]\n            else:\n                node.children[l] = TrieNode(l, {}, i == len(word) - 1)\n                node = node.children[l]\n                \n        node.isEnd = True\n\n    def search(self, word: str) -> bool:\n        \\\"\\\"\\\"\n        Returns if the word is in the trie.\n        \\\"\\\"\\\"\n        node = self.root\n        for l in word:\n            if l in node.children:\n                node = node.children[l]    \n            else:\n                return False\n        return node.isEnd\n\n    def startsWith(self, prefix: str) -> bool:\n        \\\"\\\"\\\"\n        Returns if there is any word in the trie that starts with the given prefix.\n        \\\"\\\"\\\"\n        node = self.root\n        for l in prefix:\n            if l in node.children:\n                node = node.children[l]\n            else:\n                return False\n        return True\n    \n    def search_for_multiple(self, letters):\n        node = self.root\n        \n        for l in letters[::-1]:\n            if l in node.children:\n                node = node.children[l]\n            else:\n                return False\n            \n            if node.isEnd:\n                return True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.my_trie = Trie()\n        \n        self.letters = []\n        \n        for word in words:\n            self.my_trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        \n        return self.my_trie.search_for_multiple(self.letters)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node():\n    def __init__(self, val):\n        self.val = val\n        self.children = {}\n        self.end = False\n\n\nclass WordTree:\n    def __init__(self):\n        self.root = Node(0)\n\n    def add_word(self, word):\n        cur = self.root\n        for c in word[::-1]:\n            if c in cur.children:\n                cur = cur.children[c]\n            else:\n                cur.children[c] = Node(c)\n                cur = cur.children[c]\n        cur.end = True\n\n\nclass StreamChecker:\n\n    def __init__(self, words):\n        self.tree = WordTree()\n        for word in words:\n            self.tree.add_word(word)\n        self.query_l = []\n\n    def query(self, letter: str) -> bool:\n        self.query_l.append(letter)\n        cur = self.tree.root\n        for c in self.query_l[::-1]:\n            if c not in cur.children:\n                return False\n            cur = cur.children[c]\n            if cur.end:\n                return True\n        return False\n", "# class StreamChecker:\n#     def __init__(self, words: List[str]):\n#         self.root = {}\n#         self.max_len = 0\n#         self.buff = []\n#         for word in words:\n#             self.max_len = max(self.max_len , len(word))\n#             cur = self.root\n            \n#             for w in word[::-1]:\n#                 cur = cur.setdefault(w, {})\n#             cur['*'] = '*'\n        \n        \n\n#     def query(self, letter: str) -> bool:\n#         self.buff = [letter] + self.buff \n#         # if len(self.buff) > self.max_len:\n#         #     self.buff.pop(0)\n\n#         def dfs(i, cur):\n#             if i == len(self.buff):\n#                 return '*' in cur\n            \n#             if self.buff[i] not in cur:\n#                 return False\n            \n#             return dfs(i + 1, cur[self.buff[i]])\n        \n#         # self.buff = ['a','b']\n#         return dfs(0, self.root)\n        \n        \n        # for i in range(len(self.buff)):\n        #     if self.buff[i] in self.root:\n        #         # print(i)\n        #         # print(i,self.buff[i:])\n        #         if dfs(i, self.root) == True:\n        #             return True\n        # return False\n    \nclass TrieNode:\n    def __init__(self):\n        self.dic = {}\n        self.end = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        for word in words:\n            word = \\\"\\\".join(reversed(word))\n            self.addword(word)\n        self.stream = \\\"\\\"\n            \n    def addword(self, word):\n        current = self.root\n        for char in word:\n            if char not in current.dic:\n                current.dic[char] = TrieNode()\n            current = current.dic[char]\n        current.end = True\n            \n    def helper(self, current, stream):\n        for i in range(len(stream)):\n            if stream[i] not in current.dic: \n                if current.end:\n                    return True\n                else:\n                    return False\n            else:\n                if current.end:\n                    return True\n            current = current.dic[stream[i]]\n        return current.end\n        \n    def query(self, letter: str) -> bool:\n        self.stream = letter + self.stream\n        return self.helper(self.root, self.stream)      \n\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.p = []\n        for w in words:\n            self.insert(w)\n    \n    def insert(self, w):\n        p = self.trie\n        for c in w:\n            if c in p:\n                p = p[c]\n            else:\n                p[c] = {}\n                p = p[c]\n        p['#'] = ''\n\n    def query(self, letter: str) -> bool:\n        self.p.append(self.trie)\n        p2 = []\n        for p in self.p:\n            if letter in p:\n                p2.append(p[letter])\n        self.p = p2\n        return any('#' in p for p in self.p)\n                \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n            self.dic={}\n            for i in words:\n                cur=self.dic\n                for j in i[::-1]:\n                    if j not in cur:\n                        cur[j]={}\n                        cur=cur[j]\n                    else:\n                        cur=cur[j]\n                cur['#']={}\n            self.res=[]\n                    \n    def query(self, letter: str) -> bool:\n        self.res.append(letter)\n        cur=self.dic\n        for i in self.res[::-1]:\n            if i not in cur:\n                return False\n            if '#' in cur[i]:\n                return True\n            if i in cur:\n                cur=cur[i]\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = self.create_trie(words)\n        self.l = []\n\n    def create_trie(self, words):\n        trie = {}\n        for word in words:\n            curr = trie\n            for ch in word:\n                if ch not in curr:\n                    curr[ch] = {}\n                curr = curr[ch]\n            curr['.'] = True\n        return trie\n            \n        \n    def query(self, letter: str) -> bool:\n        self.l.append(self.trie)\n        self.l = [trie[letter] for trie in self.l if letter in trie]\n        return any('.' in trie for trie in self.l)\n                \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self, c: str, is_word: bool):\n        self.c = c\n        self.next_chars = {}\n        self.is_word = is_word \n    def traverse(self, c):\n        if c in self.next_chars:\n            return self.next_chars[c]\n        return None\n\n    def add(self, c, is_word):\n        if c not in self.next_chars:\n            self.next_chars[c] = Trie(c, is_word)\n        return self.next_chars[c]\n    \nclass StreamChecker:\n            \n    def __init__(self, words: List[str]):\n        self.tr = Trie(\\\"\\\", False)\n        self.iters = []\n        \n        for word in words:\n            cur = self.tr\n            for c in word[::-1]:\n                cur = cur.add(c, False)\n            cur.is_word = True\n\n    def query(self, letter: str) -> bool:\n        self.iters.append(letter)\n        cur = self.tr\n        for c in self.iters[::-1]:\n            cur = cur.traverse(c)\n            if not cur:\n                return False\n            if cur.is_word:\n                return True\n            \n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['end'] = True\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes = []\n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes = new_nodes\n        return temp\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['#'] = {}\n        self.waiting = []\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        # self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        waiting = []\n        for node in self.waiting + [self.trie]:\n            if letter in node:\n                waiting.append(node[letter])\n        self.waiting = waiting\n        return any('#' in node for node in self.waiting)\n                \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        \n        for word in words:\n            curnode = self.root\n            for ch in word:\n                if ch not in curnode:\n                    curnode[ch] = {}\n                curnode = curnode[ch]\n            curnode['is_end'] = True\n        \n        self.leads = [self.root] # the pointers to the threads we follow right now\n\n    def query(self, letter: str) -> bool:\n        next_leads = [self.root]\n        found_word = False\n        \n        for lead in self.leads:\n            if letter in lead:\n                new_lead = lead[letter]\n                next_leads.append(new_lead)\n                if 'is_end' in new_lead:\n                    found_word = True\n            \n        self.leads = next_leads\n        return found_word\n    \n    \n    \n# class TrieNode:\n#     def __init__(self, is_end=False):\n#         self.children = {}  # char to trie node\n#         self.is_end = is_end\n\n# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         self.root = TrieNode()\n        \n#         for word in words:\n#             curnode = self.root\n#             for ch in word:\n#                 if ch not in curnode.children:\n#                     curnode.children[ch] = TrieNode()\n#                 curnode = curnode.children[ch]\n            \n#             curnode.is_end = True\n        \n#         self.leads = set([self.root]) # the pointers to the threads we follow right now\n\n#     def query(self, letter: str) -> bool:\n#         next_leads = set([self.root])\n#         found_word = False\n        \n#         for lead in self.leads:\n#             if letter in lead.children:\n#                 next_leads.add(lead.children[letter])\n#                 if lead.children[letter].is_end:\n#                     found_word = True\n            \n#         self.leads = next_leads\n#         return found_word\n", "class TrieNode:\n    def __init__(self, eow):\n        self.children = {}\n        self.eow = eow\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode(False)\n\n    def add(self, word):\n        cur = self.root\n        for ch in word:\n            if ch not in cur.children:\n                cur.children[ch] = TrieNode(False)\n\n            cur = cur.children[ch]\n\n        cur.eow = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.add(word)\n\n        self.trie_curs = [self.trie.root]\n\n    def query(self, letter: str) -> bool:\n        trie_curs_new = [self.trie.root]\n        hit = False\n        for cur in self.trie_curs:\n            if letter in cur.children:\n                trie_curs_new.append(cur.children[letter])\n                if not hit and cur.children[letter].eow:\n                    hit = True\n\n        self.trie_curs = trie_curs_new\n\n        return hit", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.dic={}\n        for i in words:\n            cur=self.dic\n            for j in i[::-1]:\n                if j not in cur:\n                    cur[j]={}\n                    cur=cur[j]\n                else:\n                    cur=cur[j]\n            cur['#']={}\n        self.res=[]\n                    \n    def query(self, letter: str) -> bool:\n        self.res.append(letter)\n        cur=self.dic\n        for i in self.res[::-1]:\n            if i not in cur:\n                return False\n            if '#' in cur[i]:\n                return True\n            if i in cur:\n                cur=cur[i]\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = defaultdict(dict)\n        self.words = set()\n        words_ = [word[::-1] for word in set(words)]\n        for word in words_:\n            for i in range(len(word)-1):\n                self.memo[i+1][word[:i+1]]=0\n        \n        for word in words_:\n            self.memo[len(word)][word]=1     \n        \n        self.hist = []\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        w = ''\n        for i in range(len(self.hist)-1,-1,-1):\n            w+=self.hist[i]\n            #print(w)\n            c = self.memo[len(w)].get(w,None)\n            if c is None:\n                return False\n            if c:\n                return True\n            \n        return False\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes = []\n        \n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes = new_nodes\n        return temp\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.flag = []\n        self.trie = {}\n        for word in words:\n            cur = self.trie\n            for c in word:\n                if c not in cur:\n                    cur[c] = {}\n                cur = cur[c]\n            cur['.'] = {}\n\n\n    def query(self, letter: str) -> bool:\n        if letter in self.trie:\n            self.flag.append(self.trie)\n        res = False\n        new_flag = []\n        for f in self.flag:\n            if letter in f:\n                new_flag.append(f[letter])\n                if '.' in f[letter]:\n                    res = True\n        self.flag = new_flag\n        return res\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = self.buildTrie(words)\n        self.nodes = [self.trie]\n    \n    def buildTrie(self, words):\n        trie = {}\n        for word in words:\n            curr = trie\n            for char in word:\n                if char not in curr:\n                    curr[char] = {}\n                curr = curr[char]\n            curr['isWord'] = True\n        return trie\n\n    def query(self, letter: str) -> bool:\n        found = False\n        newNodes = [self.trie]\n        for i,node in enumerate(self.nodes):\n            if letter in node:\n                if 'isWord' in node[letter]:\n                    found = True\n                    if len(list(node[letter].keys())) > 1:\n                        newNodes.append(node[letter])\n                else:\n                    newNodes.append(node[letter])\n        self.nodes = newNodes\n        return found\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.chars = {}\n        self.isEnd = False\n        self.current = self\n        self.pointers = set([self])\n        \n    def add(self, word):\n        trie = self\n        for c in word:\n            if c not in trie.chars:\n                trie.chars[c] = Trie()\n            trie = trie.chars[c]\n        trie.isEnd = True\n        \n    def searchNext(self, char):\n        newPointers = set([self])\n        isWord = False\n        for pointer in self.pointers:\n            if char in pointer.chars:\n                newPointer = pointer.chars[char]\n                if newPointer.isEnd:\n                    isWord = True\n                newPointers.add(newPointer)\n        self.pointers = newPointers\n        return isWord\n            \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.add(word)\n        \n\n    def query(self, letter: str) -> bool:\n        return self.trie.searchNext(letter)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            cur = self.trie\n            for char in word:\n                if char not in cur:\n                    cur[char] = {}\n                cur = cur[char]\n            cur['#'] = {}\n        \n        self.candidates = deque()\n    def query(self, letter: str) -> bool:\n        size = len(self.candidates)\n        for i in range(size):\n            candidate = self.candidates.popleft()\n            if letter in candidate:\n                self.candidates.append(candidate[letter])\n        if letter in self.trie:\n            self.candidates.append(self.trie[letter])\n        for candidate in self.candidates:\n            if '#' in candidate:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.suffixTree = {}\n        \n        for word in set(words):\n            node = self.suffixTree\n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = True\n            # print(word,self.suffixTree)\n        self.queries = []\n        # print(self.suffixTree)\n            \n        # print(self.letters)\n        return \n\n    def query(self, letter: str) -> bool:\n        self.queries.append(letter)\n        node = self.suffixTree\n        # word = self.queries[::]\n        # # print(''.join(self.queries))\n        # while len(word)>0:\n        #     ch = word.pop()\n        for ch in self.queries[::-1]:\n            # print(ch)\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            else:\n                node = node[ch]\n            \n        # print(letter,''.join(self.queries),node,'$' in node)\n        return '$' in node\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n\n    def __init__(self):\n        \\\"\\\"\\\"\n        Initialize your data structure here.\n        \\\"\\\"\\\"\n        self.root = TrieNode()\n        \n    def insert_suffix(self, word, node):\n        if word == '':\n            return\n        if word[0] not in node.children:\n            node.children[word[0]] = TrieNode()\n        self.insert_suffix(word[1:], node.children[word[0]])\n\n    def insert(self, word):\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        \\\"\\\"\\\"\n        word = word + '$'\n        self.insert_suffix(word, self.root)\n        \n    def print_subtree(self, node):\n        print(list(node.children.keys()))\n        for child in node.children.values():\n            self.print_subtree(child)\n            \n    def __str__(self):\n        self.print_subtree(self.root)\n\nclass StreamChecker:\n\n    def __init__(self, words):\n        self.Trie = Trie()\n        for word in words:\n            self.Trie.insert(word)\n        # print(self.Trie)\n        self.matches = [self.Trie.root] # a list of nodes which represent terminal letters of all the currently active partial matches\n        \n    def query(self, letter):\n        found_match = False\n        extended_matches = [self.Trie.root]\n        for match in self.matches:\n            if letter in match.children:\n                new_match = match.children[letter]\n                if '$' in new_match.children:\n                    found_match = True\n                extended_matches.append(new_match)\n        self.matches = extended_matches\n        # print(self.matches)\n        return found_match\n            \n      ", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = defaultdict(dict)\n        for word in words:\n            cur = self.trie\n            for letter in word:\n                if letter not in cur: cur[letter] = {}\n                cur = cur[letter]\n            cur[\\\"#\\\"] = True\n        self.point = deque()\n        \n    def query(self, letter: str) -> bool:\n        temp = deque()\n        self.point.append(self.trie)\n        for pt in self.point:\n            if letter in pt:\n                temp.append(pt[letter])\n        self.point = temp\n        \n        for pt in self.point:\n            if \\\"#\\\" in pt:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n\n        for word in set(words):\n            node = self.trie       \n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n        \n        for word in set(words): \n            node = self.trie\n            for ch in word[::-1]:# for each word start from root node\n                if ch not in node:\n                    node[ch]= {}\n                node = node[ch]\n            node['$']= word\n            \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return(True)\n            if ch not in node:\n                return(False)\n            node = node[ch]\n            \n        return('$' in node)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.maxlen = len(words)\n        self.cache = ''\n        for w in words:\n            self.trie.insert(w[::-1])\n        \n    def query(self, letter: str) -> bool:\n        self.cache += letter\n        # self.result = False\n        k = 1\n        node = self.trie.root\n        while k <= len(self.cache):\n            char = self.cache[-k]\n            if char in node.children:\n                if node.children[char].isEnd:\n                # self.result = self.result or node.children[char].isEnd\n                    return True\n                k += 1\n                node = node.children[char]\n            else:\n                return False\n        # return self.result\n \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.letters = \\\"\\\"\n        \n        for word in words:\n            self.insertWord(word)\n\n            \n    def insertWord(self, word):\n        node = self.root\n        word = word[::-1]\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.isWord = True\n        \n        \n    def query(self, letter: str) -> bool:\n        self.letters += letter\n        k = 0\n        n = len(self.letters)\n        node = self.root\n        \n        for i in range(n-1, -1, -1):\n            ch = self.letters[i]\n            k += 1\n            if ch not in node.children:\n                return False\n            \n            node = node.children[ch]\n            if k>0 and node.isWord:\n                return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def add(self, word):\n        p = self.root\n        for c in word:\n            if c not in p.children:\n                p.children[c] = TrieNode()\n            p = p.children[c]\n        p.isWord = True\n        \n    # def search(self, word):\n    #     p = self.root\n    #     for c in word:\n    #         if c not in p.children:\n    #             return False\n    #         p = p.children[c]\n    #     return p.isWord\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.queries = []\n        self.trie = Trie()\n        for word in words:\n            self.trie.add(word[::-1])\n        \n\n    def query(self, letter: str) -> bool:\n        self.queries.append(letter)\n        p = self.trie.root\n        for i in range(len(self.queries)-1, -1, -1):\n            c = self.queries[i]\n            if c not in p.children:\n                return False\n            p = p.children[c]\n            if p.isWord:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.dic = {}\n        self.end = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        for word in words:\n            word = \\\"\\\".join(reversed(word))\n            self.addword(word)\n        self.stream = \\\"\\\"\n            \n    def addword(self, word):\n        current = self.root\n        for char in word:\n            if char not in current.dic:\n                current.dic[char] = TrieNode()\n            current = current.dic[char]\n        current.end = True\n            \n    def helper(self, current, stream):\n        for i in range(len(stream)):\n            if stream[i] not in current.dic: \n                if current.end:\n                    return True\n                else:\n                    return False\n            else:\n                if current.end:\n                    return True\n            current = current.dic[stream[i]]\n        return current.end\n        \n    def query(self, letter: str) -> bool:\n        self.stream = letter + self.stream\n        return self.helper(self.root, self.stream)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for w in words:\n            cur = self.trie\n            for l in reversed(w):\n                if l not in cur:\n                    cur[l] = {}\n                cur = cur[l]\n            cur[\\\"#\\\"] = True\n        self.stream = deque()\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        #print(self.stream)\n        cur = self.trie\n        for l in self.stream:\n            #print(l)\n            if l in cur:\n                cur = cur[l]\n                #print(\\\"cur:\\\",cur)\n            else:\n                break\n            if \\\"#\\\" in cur: return True\n        return False", "class TrieNode:\n\n    def __init__(self):\n        self.dic = defaultdict(TrieNode)\n        self.isWord = False\n\n    def addWord(self, word):\n        node = self\n        for char in word:\n            if not node.dic[char]:\n                node.dic[char] = TrieNode()\n            node = node.dic[char]\n        node.isWord = True\n\n\nclass StreamChecker:\n\n    def __init__(self, words):\n        self.root = TrieNode()\n        self.stream = \\\"\\\"\n        for word in words:\n            self.root.addWord(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        node = self.root\n        i = len(self.stream) - 1\n        while i >= 0 and self.stream[i] in node.dic:\n            node = node.dic[self.stream[i]]\n            if node.isWord:\n                return True\n            i -= 1\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "# Written with love by atm1504\nclass TrieNode:\n    def __init__(self):\n        self.children={}\n        self.isWord=False\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root=TrieNode()\n        self.letters=\\\"\\\"\n        \n        for word in words:\n            self.insertWord(word)\n        \n    def insertWord(self,word):\n        node=self.root\n        word=word[::-1]\n        for x in word:\n            if x not in node.children:\n                node.children[x]=TrieNode()\n            node=node.children[x]\n        node.isWord=True\n        \n    def query(self, letter: str) -> bool:\n        self.letters+=letter\n        k=0\n        n=len(self.letters)\n        node=self.root\n        for i in range(n-1,-1,-1):\n            x=self.letters[i]\n            k+=1\n            if x not in node.children:\n                return False\n            node=node.children[x]\n            if k>0 and node.isWord:\n                return True\n        return False", "class TrieNode:\n    def __init__(self):\n        self.children={}\n        self.isWord=False\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root=TrieNode()\n        self.letters=\\\"\\\"\n        \n        for word in words:\n            self.insertWord(word)\n        \n    def insertWord(self,word):\n        node=self.root\n        word=word[::-1]\n        for x in word:\n            if x not in node.children:\n                node.children[x]=TrieNode()\n            node=node.children[x]\n        node.isWord=True\n        \n    def query(self, letter: str) -> bool:\n        self.letters+=letter\n        k=0\n        n=len(self.letters)\n        node=self.root\n        for i in range(n-1,-1,-1):\n            x=self.letters[i]\n            k+=1\n            if x not in node.children:\n                return False\n            node=node.children[x]\n            if k>0 and node.isWord:\n                return True\n            \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n\n        for word in set(words):\n            node = self.trie  \n            for ch in word[::-1]:\n                if ch not in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n        \n        print((self.trie))\n        \n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n\n \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.isEnd = False\n        self.word = \\\"\\\"\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = \\\"\\\"\n        self.root = TrieNode()\n        self.maxL = 0\n        for word in words:\n            self.maxL = max(self.maxL, len(word))\n            self.add(word)\n    \n    def add(self, word):\n        p = self.root\n        for c in word[::-1]:\n            idx = ord(c) - ord('a')\n            if not p.children[idx]:\n                p.children[idx] = TrieNode()\n            p = p.children[idx]\n        p.isEnd = True\n        p.word = word\n        \n\n    def query(self, letter: str) -> bool:\n        if len(self.stream) < self.maxL:\n            self.stream = letter + self.stream   # ba\n        else:\n            self.stream = self.stream[:-1]\n            self.stream = letter + self.stream \n      \n        p = self.root \n        for c in self.stream:\n            idx = ord(c) - ord('a')\n            if not p.children[idx]:\n                return False\n            if p.children[idx].isEnd:\n                return True\n            p = p.children[idx]\n    \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        self.input = ''\n        \n        for word in words:\n            ptr = self.trie\n            for w in word[::-1]:\n                if w not in list(ptr.keys()): \n                    ptr[w] = dict()\n                ptr = ptr[w]\n            ptr['$'] = word\n\n\n            \n        \n\n    def query(self, letter: str) -> bool:\n        self.input += letter\n        node = self.trie\n        for index in range(len(self.input)):\n            ch = self.input[-(index+1)]\n            # print(' index:', ch, 'dict:', node.keys())\n            if '$' in list(node.keys()):\n                return True\n            elif ch not in list(node.keys()):\n                return False\n            node = node[ch]\n        return '$' in list(node.keys())\n                \n            \n                \n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self, c):\n        self.c = c\n        self.children = {}\n        self.is_word = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.char_list = []\n        self.trie = TrieNode('')\n        for word in words:\n            node = self.trie\n            for c in word[::-1]:\n                if c not in node.children:\n                    node.children[c] = TrieNode(c)\n                node = node.children[c]\n            node.is_word = True\n\n    def query(self, letter: str) -> bool:\n        self.char_list.append(letter)\n        i = len(self.char_list) - 1\n        node = self.trie\n        while i >= 0:\n            if self.char_list[i] not in node.children:\n                break\n            node = node.children[self.char_list[i]]\n            if node.is_word:\n                return True\n            i -= 1\n        return node.is_word\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isend_word = False\n\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    \n    def insert(self, word):\n        curr = self.root\n        for c in word:\n            if c not in curr.children:\n                curr.children[c] = TrieNode()\n            curr = curr.children[c]\n        curr.isend_word = True\n        \n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.search = []\n        for word in words:\n            self.trie.insert(word[::-1])\n        \n        \n    def query(self, letter: str) -> bool: \n        self.search.append(letter)\n        curr = self.trie.root\n        for i in range(len(self.search) - 1, -1, -1):\n            char = self.search[i]\n            if curr.isend_word:\n                return True\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n        \n        return curr.isend_word\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode():\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode) \n        self.isEnd = False\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.trie = Trie()\n        for w in words:\n            self.trie.insert(w[::-1])\n        \n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.letters[i] not in node.children:\n                return False\n            node = node.children[self.letters[i]]\n            i -= 1\n        return node.isEnd\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.trie = Trie()\n        for w in words:\n            self.trie.insert(w[::-1])\n        \n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.letters[i] not in node.children:\n                return False\n            node = node.children[self.letters[i]]\n            i -= 1\n        return node.isEnd\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self,letter):\n        self.letter=letter\n        self.next_alpha={}\n        self.end=False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n\n        self.root=TrieNode('root')\n        self.stream=deque()\n\n        self.p=None\n        \n        for word in words:\n            buffer=TrieNode('a')\n            if(len(word)==1):\n                self.root.next_alpha[word[0]]=TrieNode(word[0])\n                self.root.next_alpha[word[0]].end=True\n                continue\n                \n            for letter_ind,l in enumerate(word[::-1]):\n                if(letter_ind==0):\n                    if(l not in list(self.root.next_alpha.keys())):\n                        self.root.next_alpha[l]=TrieNode(l)\n                        \n                    buffer=self.root.next_alpha[l]\n                    continue\n                \n                if(l in list(buffer.next_alpha.keys())):\n                    buffer=buffer.next_alpha[l]\n                else:\n                    \n                    nex=TrieNode(l)\n                    buffer.next_alpha[l]=nex\n                    buffer=nex\n                \n                \n                if(letter_ind==len(word)-1):\n                    buffer.end=True\n        \n        \n    def query(self, letter: str) -> bool:\n\n        self.stream.appendleft(letter)\n        cur=self.root\n        \n        for c in self.stream:\n            if c in cur.next_alpha:\n                cur = cur.next_alpha[c]\n                if cur.end: return True\n            else: break\n        return False\n            \n            \n        '''\n        print(letter,end=\\\"->\\\")\n        if(self.p==None):\n            if(letter not in self.root.next_alpha.keys()):\n                return False\n            \n            self.p=self.root.next_alpha[letter]\n            \n            \n                \n        else:\n            if(letter in self.p.next_alpha.keys()):\n                self.p=self.p.next_alpha[letter]\n                print(\\\"next\\\")\n            else:\n                if(letter not in self.root.next_alpha.keys()):\n                    return False\n                self.p=self.root.next_alpha[letter]\n                print(\\\"reset\\\")\n\n            \n\n        print(self.p.end)\n        return self.p.end\n\n        '''\n        \n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    \n\n    def __init__(self, words):\n        self.words = []\n        self.store = {}\n        self.stack = ''\n        self.sample = 25\n        for w in words:\n            if not w:\n                continue\n            self.insertStore(w[::-1], self.store)\n\n    def query(self, letter):\n        self.stack += letter\n        return self.queryStore(self.stack, self.store)\n\n    def insertStore(self, w, store):\n        if w[:self.sample] not in store:\n            store[w[:self.sample]] = {}\n        if len(w) <= self.sample:\n            store[w[:self.sample]]['!'] = None\n        else:\n            self.insertStore(w[self.sample:], store[w[:self.sample]])\n\n    def queryStore(self, stack, store):\n        if not stack:\n            return False\n        s = stack[:-self.sample-1:-1]\n        if s in store:\n            if '!' in store[s]:\n                return True\n            if self.queryStore(stack[:-self.sample], store[s]):\n                return True\n        for i in range(1, self.sample):\n            if s[:i] in store:\n                return True\n        return False\n\n\n\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = {}\n        # self.max_len = 0\n        self.buff = \\\"\\\"\n        for word in words:\n            # self.max_len = max(self.max_len , len(word))\n            cur = self.root\n            \n            for w in word[::-1]:\n                cur = cur.setdefault(w, {})\n            cur['*'] = '*'\n            \n        # print(self.root)\n            \n    \n        \n        \n\n    def query(self, letter: str) -> bool:\n        self.buff = letter + self.buff \n        # if len(self.buff) > self.max_len:\n        #     self.buff.pop(0)\n\n        def dfs(i, cur):\n            if i == len(self.buff):\n                return '*' in cur\n            \n            if '*' in cur:\n                return True\n            \n            if self.buff[i] not in cur:\n                return False\n            \n            return dfs(i + 1, cur[self.buff[i]])\n        \n        # self.buff = ['a','b']\n        # print(self.buff)\n        return dfs(0, self.root)\n        \n        \n        # for i in range(len(self.buff)):\n        #     if self.buff[i] in self.root:\n        #         # print(i)\n        #         # print(i,self.buff[i:])\n        #         if dfs(i, self.root) == True:\n        #             return True\n        # return False\n    \n# class TrieNode:\n#     def __init__(self):\n#         self.dic = {}\n#         self.end = False\n        \n# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         self.root = TrieNode()\n#         for word in words:\n#             word = \\\"\\\".join(reversed(word))\n#             self.addword(word)\n#         self.stream = \\\"\\\"\n            \n#     def addword(self, word):\n#         current = self.root\n#         for char in word:\n#             if char not in current.dic:\n#                 current.dic[char] = TrieNode()\n#             current = current.dic[char]\n#         current.end = True\n            \n#     def helper(self, current, stream):\n#         for i in range(len(stream)):\n#             if stream[i] not in current.dic: \n#                 if current.end:\n#                     return True\n#                 else:\n#                     return False\n#             else:\n#                 if current.end:\n#                     return True\n#             current = current.dic[stream[i]]\n#         return current.end\n        \n#     def query(self, letter: str) -> bool:\n#         self.stream = letter + self.stream\n#         return self.helper(self.root, self.stream)      \n\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n        \nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.trie = Trie()\n        for w in words:\n            self.trie.insert(w[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.letters[i] not in node.children:\n                return False\n            node = node.children[self.letters[i]]\n            i -= 1\n        return node.isEnd\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n\n        for word in set(words):\n            node = self.trie       \n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n        \n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n\nclass StreamChecker_TLE:\n    \n    def _reinit(self):\n        newdict = collections.defaultdict(list)\n        for w in self.words:\n            newdict[w[0]].append((w, 0))\n        return newdict\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.curdict = self._reinit()\n        self.refdict = self._reinit()\n\n    def query(self, letter: str) -> bool:\n        if not self.curdict[letter]:\n            self.curdict = self._reinit()\n            return False\n        expect = self.curdict[letter][:]\n        self.curdict = self._reinit()\n        ret = False\n        for w, idx in expect:\n            idx += 1\n            if idx == len(w):\n                ret = True\n            else:\n                nxtch = w[idx]\n                self.curdict[nxtch].append((w, idx))\n        return ret\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words: self.trie.insert(word[::-1])\n         \n    def query(self, letter):\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node: return True\n            else: break\n        return False\n\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\nfrom collections import deque\n\nclass TrieNode:\n    def __init__(self):\n        self.is_word = False  # flag for complete word\n        self.children = defaultdict(TrieNode)  # dictionary to store children TrieNodes\n\nclass Trie:\n    def __init__(self, words=None):\n        self.root = TrieNode()\n        if words:\n            for word in words:\n                self.insert(word)\n    \n    def insert(self, word):\n        curr = self.root\n        for char in word:\n            curr = curr.children[char]\n        \n        curr.is_word = True\n    \n    def search(self, word):\n        curr = self.root\n        for char in word:\n            if curr.children.get(char, None) is None:\n                return False\n            curr = curr.children[char]\n        return curr.is_word\n    \n    def starts_with(self, prefix):\n        # prefix can be a string as well as a list of chars\n        curr = self.root\n        for char in prefix:\n            if curr.children.get(char, None) is None:\n                return False\n            curr = curr.children[char]\n        return True\n    \n    def contains_stream(self, stream, index=0):\n        # stream can be a string as well as a list of chars\n        curr = self.root\n        while index < len(stream):\n            if curr.is_word:\n                return True\n            char = stream[index]\n            if curr.children.get(char, None) is None:\n                return False\n            curr = curr.children[char]\n            index += 1\n        return curr.is_word\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        # add words in reverse\n        for word in words:\n            self.trie.insert(word[::-1])\n        \n        # for word in words:\n        #     print(self.trie.search(word[::-1]))\n        \n        self.stream = deque()\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.trie.contains_stream(self.stream)\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.end = False\n        self.children = [None] * 26\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.cand = []\n        self.maxlen = float('-inf')\n        for w in words:\n            self.insert(w)\n            self.maxlen = max(self.maxlen, len(w))\n            \n    def insert(self, s):\n        node = self.root\n        for c in s[::-1]:\n            index = ord(c)-ord('a')\n            if node.children[index] is None:\n                node.children[index] = TrieNode()\n            node = node.children[index]\n        node.end = True\n\n    def query(self, letter: str) -> bool:\n        self.cand.insert(0, letter)\n        \n        if len(self.cand) > self.maxlen:\n            self.cand.pop()\n        \n        curr = self.root\n        \n        for c in self.cand:\n            if curr.children[ord(c)-ord('a')] is not None:\n                curr = curr.children[ord(c)-ord('a')]\n                if curr.end:\n                    return True\n            else:\n                return False\n            \n        return False       \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque   \nclass TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n     \nclass StreamChecker:\n    ## trie, reverse?\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words:\n            self.trie.insert(word[::-1])\n        # self.arr = [0] * 26\n        # for word in words:\n        #     # for l in word:\n        #     self.arr[ord(word[-1])-ord('a')] += 1\n\n    def query(self, letter: str) -> bool:\n        # res = self.arr[ord(letter) - ord('a')] > 0\n        # self.arr[ord(letter) - ord('a')] -= 1\n        # return res\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node == 1:\n                    return True\n            else:\n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_leaf = False\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for c in word:\n            root = root.children.setdefault(c, TrieNode())\n        root.is_leaf = True\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.stream = deque()\n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        curr = self.trie.root\n        for c in self.stream:\n            if c in curr.children:\n                curr = curr.children[c]\n                if curr.is_leaf:\n                    return True\n            else:\n                return False", "class TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words: self.trie.insert(word[::-1])\n         \n    def query(self, letter):\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node: return True\n            else: break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = Trie()\n        self.Stream = deque()\n        self.maxLength = len(max(words, key=lambda x: len(x)))\n        for word in words: self.trie.insert(word[::-1])\n         \n    def query(self, letter):\n        self.Stream.appendleft(letter)\n        if len(self.Stream) > self.maxLength: self.Stream.pop()\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node: return True\n            else: break\n        return False\n\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.isend = 0\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        root = self.root\n        for char in word:\n            root = root.children.setdefault(char, TrieNode()) # setdefault(key, default=None)\n        root.isend = 1\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        \n        self.stream = deque()\n        \n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.isend: return True\n            else:\n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    \n    def __init__(self):\n        self.children = [None for _ in range(26)]\n        self.end = False\n        \nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        cur = self.root\n        for w in word:\n            idx = ord(w) - ord('a')\n            if not cur.children[idx]:\n                cur.children[idx] = TrieNode()\n            cur = cur.children[idx]\n        cur.end = True\n\n    def match(self, word):\n        # print('word = ', word)\n        cur = self.root\n        for w in word:\n            if cur.end: return True\n            idx = ord(w) - ord('a')\n            if cur.children[idx]:\n                cur = cur.children[idx]\n            else: return cur.end\n        return cur.end \n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.cache = ''\n        self.size = 0\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n            self.size = max(self.size, len(word))\n\n    def query(self, letter: str) -> bool:\n        self.cache += letter\n        if len(self.cache) > self.size:\n            self.cache = self.cache[1:]\n        return self.trie.match(self.cache[::-1])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode():\n    def __init__(self):\n        self.children = collections.defaultdict()\n        self.isEnd = False\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.maxlen = 0\n        self.cache = []\n        for w in words:\n            self.trie.insert(w[::-1])\n            self.maxlen = max(self.maxlen, len(w))\n        \n    def query(self, letter: str) -> bool:\n        self.cache.append(letter)\n        if len(self.cache) > self.maxlen:\n            self.cache = self.cache[1:]\n        i = len(self.cache) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.cache[i] not in node.children:\n                return False\n            node = node.children[self.cache[i]]\n            i -= 1\n        return node.isEnd\n \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = deque([])\n        self.trie = {}\n        \n        for word in words:\n            node = self.trie\n            for char in word[::-1]:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['$'] = word\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node = self.trie\n        for char in self.stream:\n            if '$' in node:\n                return True\n            if char not in node:\n                return False\n            node = node[char]\n        \n        return '$' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endNode = False\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.endNode = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.endNode:\n                    return True\n            else: \n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        trie = lambda: defaultdict(trie)\n        self.trie = trie()\n        for word in words:\n            current = self.trie\n            for ch in word[::-1]:\n                current = current[ch]\n            current.setdefault(\\\"#end#\\\")\n        self.stack = []\n\n    def query(self, letter: str) -> bool:\n        self.stack.append(letter)\n        state_trie = self.trie\n        for pos in range(len(self.stack) - 1, -1, -1):\n            ch = self.stack[pos]\n            if ch in state_trie and \\\"#end#\\\" in state_trie[ch]:\n                return True\n            elif ch not in state_trie:\n                return False\n            state_trie = state_trie[ch]\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self,letter):\n        self.letter=letter\n        self.next_alpha={}\n        self.end=False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n\n        self.root=TrieNode('root')\n        self.stream=deque()\n\n        self.p=None\n        \n        for word in words:\n            buffer=TrieNode('a')\n            if(len(word)==1):\n                self.root.next_alpha[word[0]]=TrieNode(word[0])\n                self.root.next_alpha[word[0]].end=True\n                continue\n                \n            for letter_ind,l in enumerate(word[::-1]):\n                if(letter_ind==0):\n                    if(l not in list(self.root.next_alpha.keys())):\n                        self.root.next_alpha[l]=TrieNode(l)\n                        \n                    buffer=self.root.next_alpha[l]\n                    continue\n                \n                if(l in list(buffer.next_alpha.keys())):\n                    buffer=buffer.next_alpha[l]\n                else:\n                    \n                    nex=TrieNode(l)\n                    buffer.next_alpha[l]=nex\n                    buffer=nex\n                \n                \n                if(letter_ind==len(word)-1):\n                    buffer.end=True\n        \n        \n    def query(self, letter: str) -> bool:\n\n        self.stream.appendleft(letter)\n        if(len(self.stream)>=2000):\n            self.stream.popleft()\n    \n        cur=self.root\n        \n        for c in self.stream:\n            if c in cur.next_alpha:\n                cur = cur.next_alpha[c]\n                if cur.end: return True\n            else: break\n        return False\n            \n            \n        \n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:    \n    def __init__(self):\n        self.children = {}\n        self.is_leaf = False\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = TrieNode()\n        self.root = self.trie\n        self.buf = []\n        \n        for word in words:\n            self.trie = self.root\n            for i in range(len(word)-1, -1, -1):\n                ch = word[i]\n                if ch not in self.trie.children:\n                    self.trie.children[ch] = TrieNode()\n                self.trie = self.trie.children[ch]\n            self.trie.is_leaf = True\n        \n\n    def query(self, letter: str) -> bool:\n        self.buf.append(letter)\n        self.trie = self.root\n        for i in range(len(self.buf)-1,-1,-1):            \n            if self.buf[i] in self.trie.children:\n                self.trie = self.trie.children[self.buf[i]]\n                if self.trie and self.trie.is_leaf:\n                    return True\n            else:\n                return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.child = {}\n\n    def insert(self, word):\n        cur_trie = self\n        for char in word + '$':  # using $ to indicate end of word\n            if char not in cur_trie.child:\n                cur_trie.child[char] = Trie()\n            cur_trie = cur_trie.child[char]\n\n    def search(self, word):\n        cur_trie = self\n        for char in word + '$':\n            if '$' in cur_trie.child: return True\n            if char not in cur_trie.child: return False\n            \n            cur_trie = cur_trie.child[char]\n\n        return False\n\n\nclass StreamChecker:\n\n    def __init__(self, words):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n        self.buffer = ''\n\n    def query(self, letter: str) -> bool:\n        self.buffer = letter + self.buffer\n        return self.trie.search(self.buffer) \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.ends_word = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for c in word:\n            node = node.children.setdefault(c, TrieNode())\n        node.ends_word = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.deque = deque()\n        for w in words:\n            self.trie.insert(reversed(w))\n\n    def query(self, letter: str) -> bool:\n        self.deque.appendleft(letter)\n        if len(self.deque) > 2000:\n            self.deque.pop()\n        \n        node = self.trie.root\n        for c in self.deque:\n            node = node.children.get(c)\n            if not node:\n                return False\n            if node.ends_word:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode: \n    def __init__(self):\n        self.children = {}\n        self.isWord = False \n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self,word):\n        root =self.root \n        for c in word: \n            root= root.children.setdefault(c,TrieNode())  \n        root.isWord = True \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie= Trie() \n        for word in words: self.trie.insert(word[::-1])\n        # print(self.trie)\n        self.stream = deque()\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        curr = self.trie.root\n        \n        for c in self.stream: \n            if c in curr.children: \n                curr = curr.children[c]\n                if curr.isWord : return True \n            else : \n                break\n        \n        return False \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "'''\nApproach 1:\n* Have a dict mapping letters to words ending on that letter.\n* Have a list with all the letters queried so far.\n* In query(), add letter to the list.\n* For each word ending on the queried letter, check if the other letters have been queried as well.\n\nApproach 2:\n* Have a trie with words in 'words'.\n* Have a list with all letters queried so far.\n* Traverse the trie using the letters in the list (scanning backwards).\n'''\n\nfrom collections import defaultdict\n\nclass TrieNode:\n    \n    def __init__(self):\n        self.links = dict()\n        self.is_word = False\n    \n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie_root = build_trie(words)\n        self.queries = []\n        \n    def query(self, letter: str) -> bool:\n        self.queries.append(letter)\n        \n        index = -1\n        node = self.trie_root\n        while node.links:\n            if index < -len(self.queries):\n                break\n            letter = self.queries[index]\n            if letter not in node.links:\n                break\n            index -= 1\n            node = node.links[letter]\n            if node.is_word:\n                return True\n        return False\n            \ndef build_trie(words):\n    root = TrieNode()\n    for word in words:\n        insert(root, word)\n    return root\n\n        \ndef insert(root, word):\n    node = root\n    for char in reversed(word):\n        if char not in node.links:\n            node.links[char] = TrieNode()\n        node = node.links[char]\n    node.is_word = True", "class TreeNode:\n    def __init__(self):\n        self.children={}\n        self.isend=False\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root=TreeNode()\n        self.char_so_far=deque()\n        for word in words:\n            node=self.root\n            for char in word[::-1]:\n                if char not in node.children:\n                    node.children[char]=TreeNode()\n                node=node.children[char]\n            node.isend=True        \n    \n    \n    def check_word(self,l):\n        node=self.root\n        for char in l:\n            if char not in node.children:\n                return False\n            node=node.children[char]\n            if node.isend:\n                return True\n        return node.isend    \n\n    def query(self, letter: str) -> bool:\n        node=self.root\n        self.char_so_far.appendleft(letter)\n        return self.check_word(self.char_so_far)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {'prefix': None, 'dict':None}\n        \n        #build Trie\n        for word in words:\n            node = self.root\n            for char in word:\n                if not char in node:\n                    node[char] = {}\n                node = node[char]\n            node['word'] = True\n                    \n        #set prefix and dictionary pointers by BFS\n        q = collections.deque([self.root])\n        while q:\n            node = q.popleft()\n            for char in node:\n                if len(char)==1:\n                    child = node[char]\n                    extendNode = node['prefix']\n                    while extendNode and not char in extendNode:\n                        extendNode = extendNode['prefix']\n                    if extendNode:\n                        child['prefix'] = extendNode[char]\n                    else:\n                        child['prefix'] = self.root\n                    if 'word' in child['prefix']:\n                        child['dict'] = child['prefix']\n                    else:\n                        child['dict'] = child['prefix']['dict']\n                    q.append(child)\n        \n        #self.cur will traverse the Trie\n        #while reading the stream\n        self.cur = self.root\n\n    def query(self, letter: str) -> bool:\n        extendNode = self.cur\n        while extendNode and not letter in extendNode:\n            extendNode = extendNode['prefix']\n        if extendNode:\n            self.cur = extendNode[letter]\n\\t\\t\\t#checks if current word is in words\n\\t\\t\\t#or if the dictionary pointer is non-null\n            if 'word' in self.cur or self.cur['dict']: \n                return True\n            else:\n                return False\n        else:\n            self.cur = self.root\n            return False\n\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {} # thought: reverse trie?\n        \n        self.max_len = 0 # use this as a queue of most recently used stuff\n        for word in words:\n            pointer = self.trie\n            for char in reversed(word):\n                if char not in pointer:\n                    pointer[char]= {}\n                pointer = pointer[char]\n            pointer['&'] = True #end character\n            self.max_len = max(self.max_len, len(word))\n            \n        self.queue = deque()\n        \n\n    def query(self, letter: str) -> bool:\n        self.queue.append(letter)\n        if len(self.queue) > self.max_len:\n            self.queue.popleft()\n        \n        pointer = self.trie\n        for char in reversed(list(self.queue)):\n            if '&' in pointer:\n                return True\n            if char in pointer:\n                pointer = pointer[char]\n            else:\n                return False\n        if '&' in pointer:\n            return True\n        else:\n            return False\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\nclass Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.end = False\n    \n    def insert(self, S):\n        t = self\n        for c in S:\n            if not t.children[ord(c) - ord('a')]:\n                t.children[ord(c) - ord('a')] = Trie()\n            t = t.children[ord(c) - ord('a')]            \n            \n        t.end = True\n    \n    def search(self, stream):\n        t = self\n        for c in stream:\n            if not t.children[ord(c) - ord('a')]:\n                return False\n            \n            t = t.children[ord(c) - ord('a')]\n                \n            if t.end:\n                return True\n            \n        return False            \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = deque()        \n        for word in words:\n            self.t.insert(reversed(word))                \n            \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)        \n        return self.t.search(self.stream)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\nclass TrieNode:\n    def __init__(self, val):\n        self.end = False\n        self.children = {}\n        \nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode(-1)\n    \n    def add(self, word):\n        root = self.root\n        for ch in word:\n            children = root.children\n            if children.get(ch) == None:\n                child = TrieNode(ch)\n                children[ch] = child\n                root = child\n            else:\n                root = children[ch]\n        root.end = True\n    \n    def search(self, word):\n        root = self.root\n        for val in word:\n            if root.children.get(val) == None:\n                return False\n            else:\n                root = root.children[val]\n                if root.end:\n                    return True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # self.words = set(words)\n        self.Trie = Trie()\n        self.maxlen = -1\n        for w in words:\n            self.maxlen = max(self.maxlen, len(w))\n            rev = w[::-1]\n            self.Trie.add(rev)\n        self.searchArr = deque()\n        \n\n    def query(self, letter: str) -> bool:\n\n        self.searchArr.insert(0, letter)\n        if len(self.searchArr) > self.maxlen:\n            self.searchArr.pop()\n\n        return self.Trie.search(self.searchArr)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self):\n        self.list = [None] * 26\n        self.period = False\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n    \n    def add(self, word):\n        curr = self.root\n        for i in range(len(word) -1, -1, -1):\n            letter = word[i]\n            asc = ord(letter) - ord('a')\n            if not curr.list[asc]:\n                curr.list[asc] = Node()\n            curr = curr.list[asc]\n        curr.period = True\n        \n    def query(self, word):\n        curr = self.root\n        for i in range(len(word)-1, -1 ,-1):\n            c = word[i]\n            asc = ord(c) - ord('a')\n            if not curr.list[asc]: return False\n            curr = curr.list[asc]\n            if curr.period == True: return True\n        return False\n            \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.query_list = []\n        self.words = words\n        \n        for word in words:\n            self.trie.add(word)\n\n    def query(self, letter: str) -> bool:\n        self.update_queries(letter)\n        return self.trie.query(self.query_list)\n        \n    \n    def update_queries(self, letter):\n        self.query_list.append(letter)\n\n    \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = Node(\\\"\\\", None)\n        for word in words:\n            prev = self.root\n            substr = \\\"\\\"\n            for letter in word:\n                substr += letter\n                is_final = len(substr) == len(word)\n                if letter not in prev.children:\n                    prev.children[letter] = Node(substr, prev)\n                \n                curr = prev.children[letter]\n                if is_final:\n                    curr.is_final = True\n\n                prev = curr\n\n        queue = [self.root]\n        while queue:\n            curr = queue.pop(0)\n            if curr.word:\n                letter = curr.word[-1]\n\n                parent_suffix = curr.parent.suffix\n                while parent_suffix:\n                    if letter in parent_suffix.children:\n                        curr.suffix = parent_suffix.children[letter]\n                        break\n                    else:\n                        parent_suffix = parent_suffix.suffix\n                if curr.suffix is None:\n                    curr.suffix = self.root\n                \n                suffix = curr.suffix\n                while suffix:\n                    if suffix.is_final:\n                        curr.dictionay_suffix = suffix\n                    suffix = suffix.suffix\n\n            for _, child in curr.children.items():\n                queue.append(child)\n\n        self.curr = self.root\n\n    def query(self, letter: str) -> bool:\n        # print(f\\\"Input: {letter}\\\")\n        while letter not in self.curr.children:\n            if self.curr.suffix:\n                self.curr = self.curr.suffix\n            else:\n                return False\n        self.curr = self.curr.children[letter]\n        # print(f\\\"\\\\tcurr={self.curr.word}\\\")\n\n        return self.curr.is_final or (self.curr.dictionay_suffix is not None)\n\n    def query_all(self, letters: str) -> List[bool]:\n        # self.print_all()\n        result = []\n        for letter in letters:\n            result.append(self.query(letter))\n        return result\n\n    def print_all(self):\n        queue = [self.root]\n        while queue:\n            curr = queue.pop(0)\n            curr.print()\n            for _, child in curr.children.items():\n                queue.append(child)\n\n\nclass Node:\n    def __init__(self, word, parent):\n        self.word = word\n        self.parent = parent\n\n        self.is_final = False\n        self.children = {}\n        self.suffix = None\n        self.dictionay_suffix = None\n\n    def print(self):\n        final_str = \\\"*\\\" if self.is_final else \\\"\\\"\n        print(f\\\"({self.word}) {final_str}\\\")\n        for letter, child in self.children.items():\n            print(f\\\"\\\\t{letter} -> ({child.word})\\\")\n        if self.parent:\n            print(f\\\"\\\\t[parent] -> ({self.parent.word})\\\")\n        if self.suffix:\n            print(f\\\"\\\\t[suffix] -> ({self.suffix.word})\\\")\n        dict_suffix_str = f\\\"({self.dictionay_suffix.word})\\\" if self.dictionay_suffix else \\\"None\\\"\n        print(f\\\"\\\\t[dict_suffix] -> {dict_suffix_str}\\\")\n        print()\n", "class Trie: \n    def __init__(self):\n        self.prev = {}\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.maxlens = 0\n        self.backw = ''\n        for w in words:\n            wn = len(w)\n            if wn>self.maxlens:\n                self.maxlens = wn\n            wt = self.t\n            for i in range(wn-1,-1,-1):\n                if w[i] not in wt.prev:\n                    wt.prev[w[i]] = Trie()\n                wt = wt.prev[w[i]]\n            wt.prev['$'] = '$'\n\n    def query(self, letter: str) -> bool:\n        if len(self.backw)==self.maxlens:\n            self.backw = self.backw[1:]\n        self.backw += letter            \n        wn = len(self.backw)\n        wt = self.t\n        for i in range(wn-1,-1,-1):\n            if self.backw[i] not in wt.prev:\n                return False\n            wt = wt.prev[self.backw[i]]\n            if '$' in wt.prev:\n                return True\n        return '$' in wt.prev\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\nclass TrieNode(object):\n    __slots__ = [\\\"children\\\", \\\"nextFail\\\", \\\"suffixMatches\\\", \\\"boundary\\\"]\n    def __init__(self):\n        self.children = {}\n        self.nextFail = None\n        self.suffixMatches = False\n        self.boundary = False\n\n    def add(self, word, index=0):\n        #print(word)\n        if len(word) == index:\n            self.boundary = True\n            self.suffixMatches = True\n            return\n        c = word[index]\n        if self.children.get(c, None) is None:\n            self.children[c] = TrieNode()\n        self.children[c].add(word, index + 1)\n    def __str__(self):\n        return self.__str2()\n\n    def __str2(self, indent=0):\n        space = \\\"  \\\"*indent\n        return \\\"{}TrieNode(h={}, B={}, nf={},\\\n{}\\\".format(\n            space,\n            hash(self), self.suffixMatches, hash(self.nextFail) if self.nextFail else \\\"None\\\", \\\"\\\".join(space + k + \\\": \\\" + v.__str2(indent+1) + \\\"\\\n\\\" for k, v in self.children.items()),\n            space\n        ) + space + \\\")\\\"\n\n\nclass AhoTrie(object):\n    __slots__ = [\\\"root\\\"]\n    def __init__(self, words):\n        self.root = TrieNode()\n        for word in words:\n            self.root.add(word)\n        self.__oho()\n\n    def __oho(self):\n        q = deque()\n        for c, node in self.root.children.items():\n            node.nextFail = self.root\n            q.append(node)\n        while len(q) > 0:\n            node = q.popleft()\n            \n            for c, child in node.children.items():\n                nextFail = node.nextFail\n                while not nextFail.children.get(c) and nextFail is not self.root:\n                    nextFail = nextFail.nextFail\n                if not nextFail.children.get(c):\n                    child.nextFail = nextFail\n                else:\n                    child.nextFail = nextFail.children.get(c)\n\n                q.append(child)\n                #child.nextFail = node.nextFail.children.get(c, node.nextFail)\n                if  True: #child.suffixMatches:\n                    nextFail = child.nextFail\n                    while nextFail is not self.root and not nextFail.suffixMatches:\n                        nextFail = nextFail.nextFail\n                    if nextFail is not self.root:\n                        child.suffixMatches = True\n\n\n\n\n\nclass StreamChecker:\n    __slots__ = [\\\"trie\\\", \\\"root\\\", \\\"cur\\\"]\n\n    def __init__(self, words: List[str]):\n        #print(words)\n        self.trie = AhoTrie(words) \n        self.root = self.trie.root\n        self.cur = self.root\n        #print(self.root)\n        \n\n    def query(self, letter: str) -> bool:\n        \n        \n        while not self.cur.children.get(letter) and self.cur is not self.root:\n            self.cur = self.cur.nextFail\n        #print(hash(self.cur))\n        if self.cur.children.get(letter):\n            self.cur = self.cur.children[letter]\n            temp = self.cur\n            #while temp is not self.root:\n            if temp.suffixMatches:\n                return True\n             #  temp = temp.nextFail\n        return False\n            \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.next={}\n        self.end_here=False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root=Trie()\n        \n        for word in words:\n            cur=self.root\n            for c in word[::-1]:\n                if c not in cur.__next__:\n                    cur.next[c]=Trie()\n                cur=cur.next[c]\n            cur.end_here=True\n        self.k=2000\n        self.history=deque([])\n\n    def query(self, letter: str) -> bool:\n        self.history.append(letter)\n        if len(self.history)>self.k:\n            self.history.popleft()\n            \n        if letter not in self.root.__next__:\n            return False\n        \n        n=len(self.history)\n        cur=self.root\n\n        for i in range(n):\n            c=self.history[n-1-i]\n            if c not in cur.__next__:\n                return False\n            cur=cur.next[c]\n            if cur.end_here:\n                return True\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = {}\n        self.words = set()\n        for word in words:\n            word_ = word[::-1]\n            for i in range(len(word)):\n                self.memo[word_[:i+1]]=0\n            self.words.add(word_)        \n        self.hist = []\n        \n        print((self.memo))\n    \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        w = ''\n        for i in range(len(self.hist)-1,-1,-1):\n            w+=self.hist[i]\n            #print(w)\n            if w not in self.memo:\n                return False\n            if w in self.words:\n                return True\n        return False\n\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_complete = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        cur = self.root\n        for char in word[: : -1]:\n            cur = cur.children.setdefault(char, TrieNode())\n        cur.is_complete = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.stream = deque()\n        for word in words:\n            self.trie.insert(word)\n\n    def query(self, letter: str) -> bool:\n        cur = self.trie.root\n        self.stream.appendleft(letter)\n        for s in self.stream:\n            if s in list(cur.children.keys()):\n                cur = cur.children[s]\n                if cur.is_complete:\n                    return True\n            else:\n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # time O(h)\n        self.stream = deque([])\n        self.trie = {}\n        \n        for word in words:\n            node = self.trie\n            for char in word[::-1]:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['$'] = word\n\n    def query(self, letter: str) -> bool:\n        # time O(h)\n        self.stream.appendleft(letter)\n        node = self.trie\n        for char in self.stream:\n            if '$' in node:\n                return True\n            if char not in node:\n                return False\n            node = node[char]\n        \n        return '$' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = {}\n        self.words = set()\n        words_ = [word[::-1] for word in words]\n        for word in words_:\n            for i in range(len(word)-1):\n                self.memo[word[:i+1]]=0\n        \n        for word in words_:\n            self.memo[word]=1     \n        \n        self.hist = []\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        w = ''\n        for i in range(len(self.hist)-1,-1,-1):\n            w+=self.hist[i]\n            #print(w)\n            c = self.memo.get(w,None)\n            if c is None:\n                return False\n            if c:\n                return True\n            \n        return False\n\n", "class Trie:\n    def __init__(self):\n        self.children = [None]*26\n        self.end = False\n    def insert(self,word):\n        cur = self\n        for letter in word:\n            if cur.children[ord(letter)- ord('a')] == None:\n                cur.children[ord(letter) - ord('a')] = Trie()\n            cur = cur.children[ord(letter) - ord('a')]\n        cur.end = True\n        \n    def search(self,s):\n        cur = self\n        for letter in s:\n            if cur.children[ord(letter) - ord('a')] == None:\n                return False\n            cur = cur.children[ord(letter)-ord('a')]\n            if cur.end == True:\n                return True\n        return False\nclass StreamChecker:\n    from collections import deque\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.words = words\n        self.q = deque()\n        for word in self.words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.q.appendleft(letter)\n        return self.trie.search(self.q)\n    \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    \n\n    def __init__(self, words):\n        self.words = []\n        self.store = {}\n        self.stack = ''\n        self.sample = 15\n        for w in words:\n            if not w:\n                continue\n            self.insertStore(w[::-1], self.store)\n\n    def query(self, letter):\n        self.stack += letter\n        return self.queryStore(self.stack, self.store)\n\n    def insertStore(self, w, store):\n        if w[:self.sample] not in store:\n            store[w[:self.sample]] = {}\n        if len(w) <= self.sample:\n            store[w[:self.sample]]['!'] = None\n        else:\n            self.insertStore(w[self.sample:], store[w[:self.sample]])\n\n    def queryStore(self, stack, store):\n        if not stack:\n            return False\n        s = stack[:-self.sample-1:-1]\n        if s in store:\n            if '!' in store[s]:\n                return True\n            if self.queryStore(stack[:-self.sample], store[s]):\n                return True\n        for i in range(1, self.sample):\n            if s[:i] in store:\n                return True\n        return False\n\n\n\n", "class TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        \n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        \n        node.isEnd = True\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.trie = Trie()\n        \n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters)-1\n        \n        node = self.trie.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.letters[i] not in node.children:\n                return False\n            node = node.children[self.letters[i]]\n            i -= 1\n        return node.isEnd\n            \n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter) \n", "class TrieNode:\n    \n    def __init__(self):\n        self.child = {}\n        self.isWord = False\n\nclass Tree:\n    \n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        cur = self.root\n        for w in word:\n            if w not in cur.child:\n                cur.child[w] = TrieNode()\n            cur = cur.child[w]\n        cur.isWord = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tree = Tree()\n        for word in words:\n            self.tree.insert(word[::-1])\n        # self.printTree(self.tree.root)\n        self.letter = []\n\n    def query(self, letter: str) -> bool:\n        self.letter.append(letter)\n        cur = self.tree.root\n        i = len(self.letter) - 1\n        while i >= 0:\n            if cur.isWord:\n                return True\n            if self.letter[i] not in cur.child:\n                return False\n            cur = cur.child[self.letter[i]]\n            i -= 1\n        return cur.isWord\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isend_word = False\n\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    \n    def insert(self, word):\n        curr = self.root\n        for c in word:\n            if c not in curr.children:\n                curr.children[c] = TrieNode()\n            curr = curr.children[c]\n        curr.isend_word = True\n        \n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.search = []\n        for word in words:\n            self.trie.insert(word[::-1])\n        \n        \n    def query(self, letter: str) -> bool: \n        self.search.append(letter)\n        curr = self.trie.root\n        i = len(self.search) - 1\n        while i >= 0 and curr.children:\n            char = self.search[i]\n            if curr.isend_word:\n                return True\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n            i -= 1\n        \n        return curr.isend_word\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.endOfWord = False\n        self.children = [None]*26\n\n    def insert(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None:\n                t.children[ord(c)-ord('a')] = Trie()\n            t = t.children[ord(c)-ord('a')]\n        t.endOfWord = True\n\n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None: return False\n            t = t.children[ord(c)-ord('a')]\n            if t.endOfWord: return True\n        return False\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n            \n        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    \n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Node()\n        for w in words:\n            if(len(w) > 0):\n                self.insert(w[::-1])\n        self.queryStack = []\n    \n    def insert(self, word):\n        root = self.trie\n        self.insertWord(root, word, 0)\n        \n    \n    def insertWord(self, curNode, word, index):\n        if(index >= len(word)):\n            curNode.isEnd = True\n        else:\n            curChar = word[index]\n            if(curChar not in curNode.children):\n                newNode = Node()\n                curNode.children[curChar] = newNode\n            self.insertWord(curNode.children[curChar], word, index+1)\n    \n    def findIfPresent(self, curNode, index):\n        if(curNode.isEnd):\n            return True\n        if(index < 0):\n            return False\n        if(self.queryStack[index] not in curNode.children):\n            return False\n        return self.findIfPresent(curNode.children[self.queryStack[index]], index-1)\n    \n    def query(self, letter: str) -> bool:\n        self.queryStack.append(letter)\n        root = self.trie\n        return self.findIfPresent(root, len(self.queryStack)-1)\n        \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words: \n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node: \n                    return True\n            else: \n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "'''class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n\n    def query(self, letter: str) -> bool:\n        \n\n\n# Your StreamChecker object will be instantiated and calle as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)'''\nclass Trie:\n    \n    def __init__(self):\n        self.endOfWord = False\n        self.children = [None]*26\n\n    def insert(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None:\n                t.children[ord(c)-ord('a')] = Trie()\n            t = t.children[ord(c)-ord('a')]\n        t.endOfWord = True\n\n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None: return False\n            t = t.children[ord(c)-ord('a')]\n            if t.endOfWord: return True\n        return False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.stream = collections.deque()\n        for word in words:\n            node = self.root\n            for ch in word[::-1]:\n                if ch not in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['#'] = {}\n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node = self.root\n        for ch in self.stream:\n            if ch in node:\n                node = node[ch]\n                if '#' in node:\n                    return True\n            else:\n                return False\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.arr = [None] * 26\n        self.isWord = False\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.rt = TrieNode()\n        self.S = \\\"\\\"\n        self.mx = float('-inf')\n        for w in words:\n            node = self.rt\n            for ch in w[::-1]:\n                if node.arr[ord(ch) - ord('a')] is None:\n                    node.arr[ord(ch) - ord('a')] = TrieNode()\n                node = node.arr[ord(ch) - ord('a')]\n            node.isWord = True\n            self.mx = max(self.mx, len(w))\n\n    def query(self, letter: str) -> bool:\n        self.S = (letter + self.S)[:self.mx]\n        node = self.rt\n        for ch in self.S:\n            if node.arr[ord(ch) - ord('a')] is None:\n                return False\n            node = node.arr[ord(ch) - ord('a')]\n            if node.isWord:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.curQuery = ''\n        self.Trie = Trie()\n        for word in words:\n            newWord = word[::-1]\n            self.Trie.insert(newWord)\n\n    def query(self, letter: str) -> bool:\n        self.curQuery = letter + self.curQuery\n        curNode = self.Trie.root\n        i = 0\n        while curNode and i<len(self.curQuery):\n            \n            curLetter = self.curQuery[i]\n            ind = ord(curLetter) - ord('a')\n            curNode = curNode.children[ind]\n            if not curNode:\n                return False\n            if curNode.isWord:\n                return True\n            \n            i += 1\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n    def insert(self, word):\n        curNode = self.root\n        for i in range(len(word)):\n            ind = ord(word[i])-ord('a')\n            if curNode.children[ind]:\n                curNode = curNode.children[ind]\n            else:\n                curNode.children[ind] = Node()\n                curNode = curNode.children[ind]\n        curNode.isWord = True\n        return\n                \n        \nclass Node:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isWord = False", "class TN:\n    def __init__(self, eow=False):\n        self.c = {}\n        self.e = eow\n        self.i = id(self)\n    \n    def add(self, s):\n        if len(s)==0:\n            self.e = True\n        else:\n            c = s[0]\n            if c not in self.c:\n                self.c[c] = TN()\n            self.c[c].add(s[1:])\n    \n    def search(self, w):\n        t = self\n        for c in w:\n            # print(c,t)\n            if c not in t.c:\n                # print('oops', t.c)\n                return False\n            else:\n                t = t.c[c]\n                if t.e:\n                    return True\n        # print('nope')\n        return False\n            \n    \n    def __contains__(self, i):\n        return i in self.c\n    \n    def p(self, s=0):\n        for k,v in self.c.items():\n            print(' '*s, k, '*' if v.e else '', sep='')\n            v.p(s+1)\n    \n    def __str__(self):\n        return str(self.c)+('*'if self.e else '')\n    def __repr__(self):\n        return repr(self.c)+('*'if self.e else '')\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TN()\n        for w in words:\n            self.root.add(w[::-1])\n        self.s = []\n        # self.root.p()\n        # self.av = set()\n\n    def query(self, letter: str) -> bool:\n        self.s.append(letter)\n        return self.root.search(reversed(self.s))\n        # found = False\n        # print(self.av, letter)\n        # for n in list(self.av):\n        #     if letter in n:\n        #         self.av.remove(n)\n        #         self.av.add(n.c[letter])\n        #         found = found or n.c[letter].e\n        #     else:\n        #         self.av.remove(n)\n        # if letter in self.root:\n        #     print('found',self.root.c[letter])\n        #     self.av.add(self.root.c[letter])\n        #     found = found or self.root.c[letter].e\n        # print(found)\n        # return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.child = {}\n\n    def insert(self, word):\n        cur = self\n        for char in word + '$':\n            if char not in cur.child:\n                cur.child[char] = Trie()\n            cur = cur.child[char]\n\n    def search(self, word):\n        cur = self\n        for char in word + '$':\n            if '$' in cur.child: return True\n            if char in cur.child:\n                cur = cur.child[char]\n            else:\n                return False\n        return False\n#\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            word = word[::-1]\n            self.trie.insert(word)\n        self.buffer = ''\n    \n\n    def query(self, letter: str) -> bool:\n        self.buffer=letter+ self.buffer\n        return self.trie.search(self.buffer)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = dict()\n        self.isWord = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def add(self, word):\n        root = self.root\n        for char in reversed(word):\n            child = root.children.get(char, TrieNode())\n            root.children[char] = child\n            root = child\n        root.isWord = True    \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.trie = Trie()\n        for word in words:\n            self.trie.add(word)\n        \n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        root = self.trie.root\n        for char in reversed(self.letters):\n            if char not in root.children:\n                return False\n            root = root.children[char]\n            if root.isWord:\n                return True\n\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        Trie = lambda: collections.defaultdict(Trie)\n        self.trie = Trie()\n        for word in words:\n            reduce(dict.__getitem__, word[::-1] + \\\"$\\\", self.trie)\n        self.queries = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.queries += letter\n        curr = self.trie\n        #print(\\\"query\\\")\n        for i in range(len(self.queries)-1, -1, -1):\n            c = self.queries[i]\n            if \\\"$\\\" in curr:\n                return True\n            if c not in curr:\n                return False\n            curr = curr[c]\n        return \\\"$\\\" in curr\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        self.cache = Node()\n        self.stream = []\n        for word in words:\n            root = self.cache\n            for i in range(len(word) - 1, -1, -1):\n                if word[i] in root.children:\n                    root = root.children.get(word[i])\n                else:\n                    root.children[word[i]] = Node()\n                    root = root.children.get(word[i])\n            root.is_word = True\n\n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        root = self.cache\n        for i in range(len(self.stream) - 1, -1, -1):\n            if self.stream[i] not in root.children:\n                return False\n            \n            root = root.children.get(self.stream[i])\n            if root.is_word:\n                return True\n            \n        return False\n        \n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children={}\n        self.terminal=False\n\nclass Trie(object):\n\n    def __init__(self):\n        \\\"\\\"\\\"\n        Initialize your data structure here.\n        \\\"\\\"\\\"\n        self.root = TrieNode()\n\n    def insert(self, word):\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        :type word: str\n        :rtype: None\n        \\\"\\\"\\\"\n        if len(word) <= 0:\n            return\n        \n        trav = self.root\n        for i in range(len(word)):\n            if word[i] in trav.children:\n                trav = trav.children[word[i]]\n            else:\n                trav.children[word[i]] = TrieNode()\n                trav = trav.children[word[i]]\n        trav.terminal = True\n\nclass StreamChecker:\n    # reference: https://leetcode.com/problems/stream-of-characters/discuss/320837/Easily-implemented-Python-Trie-Solution\n    def __init__(self, words: List[str]):\n        self.queries = []\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        # basically returns false if the letter is the oldest letter of the world\n        # keep tracks of all queries from oldest to newest\n        self.queries.append(letter)\n        i = len(self.queries) - 1\n        node = self.trie.root\n        \n        # iterate from the end so we are looking at the newest queries first\n        # since word is saved backwords, it will return True\n        while i >= 0:\n            # already an end of a word\n            if node.terminal:\n                return True\n            # there is no prefix of this\n            if self.queries[i] not in node.children:\n                return False\n            node = node.children[self.queries[i]]\n            i -= 1\n        return node.terminal\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import deque\nclass Trie:\n    def __init__(self, words):\n        self.root = {}\n        self.build(words)\n    \n    def build(self, words):\n        for word in words:\n            self.add_word(word[::-1])\n            \n    def add_word(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node:\n                node[ch] = {}\n            node = node[ch]\n        node[\\\"$\\\"] = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie(words)\n        self.prev_letters = deque([])\n\n    def query(self, letter: str) -> bool:\n        self.prev_letters.appendleft(letter)\n        node = self.trie.root\n        for ch in self.prev_letters:\n            if \\\"$\\\" in node:\n                return True\n            if ch in node:\n                node = node[ch]\n            else:\n                return False\n        \n        return \\\"$\\\" in node\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\\\"\\\"\\\"\na, b, c, d\n\nabcd, bcd, cd, d\n\n\\\"\\\"\\\"", "from collections import deque\n\nclass TrieNode(object):\n    def __init__(self):\n        self.children = {}\n        self.nextFail = None\n        self.suffixMatches = False\n\n    def add(self, word, index=0):\n        #print(word)\n        if len(word) == index:\n            self.boundary = True\n            self.suffixMatches = True\n            return\n        c = word[index]\n        if self.children.get(c, None) is None:\n            self.children[c] = TrieNode()\n        self.children[c].add(word, index + 1)\n    def __str__(self):\n        return self.__str2()\n\n    def __str2(self, indent=0):\n        space = \\\"  \\\"*indent\n        return \\\"{}TrieNode(h={}, B={}, nf={},\\\n{}\\\".format(\n            space,\n            hash(self), self.suffixMatches, hash(self.nextFail) if self.nextFail else \\\"None\\\", \\\"\\\".join(space + k + \\\": \\\" + v.__str2(indent+1) + \\\"\\\n\\\" for k, v in self.children.items()),\n            space\n        ) + space + \\\")\\\"\n\n\nclass AhoTrie(object):\n    def __init__(self, words):\n        self.root = TrieNode()\n        for word in words:\n            self.root.add(word)\n        self.__oho()\n\n    def __oho(self):\n        q = deque()\n        for c, node in self.root.children.items():\n            node.nextFail = self.root\n            q.append(node)\n        while len(q) > 0:\n            node = q.popleft()\n            \n            for c, child in node.children.items():\n                nextFail = node.nextFail\n                while not nextFail.children.get(c) and nextFail is not self.root:\n                    nextFail = nextFail.nextFail\n                if not nextFail.children.get(c):\n                    child.nextFail = nextFail\n                else:\n                    child.nextFail = nextFail.children.get(c)\n\n                q.append(child)\n                #child.nextFail = node.nextFail.children.get(c, node.nextFail)\n                if  True: #child.suffixMatches:\n                    nextFail = child.nextFail\n                    while nextFail is not self.root and not nextFail.suffixMatches:\n                        nextFail = nextFail.nextFail\n                    if nextFail is not self.root:\n                        child.suffixMatches = True\n\n\n\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        print(words)\n        self.trie = AhoTrie(words) \n        self.root = self.trie.root\n        self.cur = self.root\n        #print(self.root)\n        \n\n    def query(self, letter: str) -> bool:\n        \n        \n        while not self.cur.children.get(letter) and self.cur is not self.root:\n            self.cur = self.cur.nextFail\n        #print(hash(self.cur))\n        if self.cur.children.get(letter):\n            self.cur = self.cur.children[letter]\n            temp = self.cur\n            #while temp is not self.root:\n            if temp.suffixMatches:\n                return True\n             #  temp = temp.nextFail\n        return False\n            \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import defaultdict\nclass Node:\n    def __init__(self):\n        self._childrn = defaultdict()\n        self.wef = 0\n\nclass StreamChecker(Node):\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        self.wordh = \\\"\\\"\n        \n        for i in words:\n            self.storeW(i)\n            \n    def _ind(self,ch):\n        return(ord(ch) - ord('a'))\n\n    def storeW(self,word):\n        cur = self.root\n        for i in word[::-1]:\n            ind = self._ind(i)\n            if ind not in cur._childrn:\n                cur._childrn[ind] = Node()\n            cur = cur._childrn[ind]\n            \n        cur.wef = True\n\n    def query(self, letter: str) -> bool:\n        cur = self.root\n        self.wordh = letter + self.wordh\n        for i in self.wordh:\n            ind = self._ind(i)\n            if not cur._childrn.get(ind):\n                return(False)\n            else:\n                cur = cur._childrn.get(ind)\n                if cur.wef:\n                    return(True)\n            \n        \n        return(False)\n        \n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n        self.cache = ''\n\n    def query(self, letter: str) -> bool:\n        self.cache = letter + self.cache\n        return self.trie.find(self.cache)\n        \n        \nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        cur = self.root\n        for c in word:\n            cur.children.setdefault(c, TrieNode())\n            cur = cur.children[c]\n        cur.is_word = True\n        \n    def find(self, word):\n        cur = self.root\n        for c in word:    \n            if cur.is_word:\n                return True\n            if c not in cur.children:\n                return False\n            cur = cur.children[c]\n        return cur.is_word\n        \n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.dic = {}\n        self.end = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        for word in words:\n            word = \\\"\\\".join(reversed(word))\n            self.addword(word)\n        self.stream = \\\"\\\"\n            \n    def addword(self, word):\n        current = self.root\n        for char in word:\n            if char not in current.dic:\n                current.dic[char] = TrieNode()\n            current = current.dic[char]\n        current.end = True\n            \n    def helper(self, current, stream):\n        for i in range(len(stream)):\n            if stream[i] not in current.dic: \n                if current.end:\n                    return True\n                else:\n                    return False\n            else:\n                if current.end:\n                    return True\n            current = current.dic[stream[i]]\n        return current.end\n        \n    def query(self, letter: str) -> bool:\n        self.stream = letter + self.stream\n        return self.helper(self.root, self.stream)\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n        \nclass Trie:\n    def __init__(self, corpus):\n        self.root = TrieNode()\n        for word in corpus:\n            self.add(word)\n        \n    def add(self, word):\n        x = self.root\n        for w in word:\n            if w not in x.children:\n                x.children[w] = TrieNode()\n            x = x.children[w]\n        x.isEnd = True\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        words = [x[::-1] for x in words]\n        self.trie = Trie(words)\n        self.stream = deque()\n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie.root\n        for w in self.stream:\n            if node.isEnd:\n                return True\n            elif w not in node.children:\n                return False\n            else:\n                node = node.children[w]\n        return node.isEnd\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self, val=None):\n        self.val = val\n        self.children = {}\n        self.isEnd = False\n        \n\nclass StreamChecker:\n    def add_word(self, word):\n        word = word[::-1]\n        i = 0\n        curr = self.root\n        while i < len(word):\n            if word[i] in curr.children:\n                curr = curr.children[word[i]]\n                if i == len(word)-1:\n                    curr.isEnd = True\n                i += 1\n            else:\n                break\n        while i < len(word):\n            curr.children[word[i]] = Node(word[i])\n            curr = curr.children[word[i]]\n            if i == len(word)-1:\n                curr.isEnd = True\n            i += 1\n\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        self.stream = \\\"\\\"\n        for w in words:\n            self.add_word(w)\n\n    def query(self, letter: str) -> bool:\n        self.stream  = letter + self.stream\n        i = 0\n        curr = self.root\n        while i < len(self.stream):\n            if self.stream[i] in curr.children:\n                curr = curr.children[self.stream[i]]\n                if curr.isEnd:\n                    return True\n            else:\n                return False\n            i += 1\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    \n    def __init__(self):\n        self.children = {}\n        self.end_node = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str):\n        root = self.root\n        for w in word:\n            root = root.children.setdefault(w, TrieNode())\n        root.end_node = 1\n        \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = deque()\n        for w in words:\n            self.t.insert(w[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        t = self.t.root\n        for curr in self.stream:\n            if curr in t.children:\n                t = t.children[curr]\n                if t.end_node:\n                    return True\n            else:\n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class node :\n    \n    def __init__(self) :\n        self.child = [None]*26\n        self.end = False\n        \n    def insert(self , word) :\n        cur = self\n        \n        for i in range(len(word)) :\n            index = self.indexof(word[i])\n            \n            if cur.child[index] == None :\n                cur.child[index] = node()\n            \n            cur = cur.child[index] \n            \n        cur.end = True\n        \n    def search(self , word) :\n        \n        cur = self\n        \n        for w in word :\n            index = self.indexof(w) \n            \n            cur = cur.child[index] \n            \n            if cur != None :\n                if cur.end == True :\n                    return True\n            \n            else :\n                break \n                \n        return False\n    \n    def indexof(self , c) :\n        return ord(c) - ord('a')\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.root = node()\n        self.stack = collections.deque()\n        \n        for w in words :\n            self.root.insert(w[::-1])\n            \n    def query(self, letter: str) -> bool:\n        self.stack.appendleft(letter)\n        \n        return self.root.search(self.stack)\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\nfrom functools import reduce\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # O(N x M)\n\n        # self.s = \\\"\\\"\n        # self.dic = defaultdict(set)\n        # for w in words:\n        #     self.dic[w[-1]].add(w)\n\n        # Trie = lambda: defaultdict(Trie)\n        # self.trie = Trie()\n        # for word in words:\n        #     reduce(dict.__getitem__, word, self.trie)['#'] = True\n        # self.waiting = []\n\n\n        Trie = lambda: defaultdict(Trie)\n        self.trie = Trie()\n        for word in words:\n            reduce(dict.__getitem__, word[::-1], self.trie)['#'] = True\n        self.S = \\\"\\\"\n        self.W = max(map(len, words))\n\n        \n\n    def query(self, letter: str) -> bool:\n        # O(M) where M is a max word length.\n\n        # self.s += letter\n        # return any(self.s.endswith(w) for w in self.dic[letter])\n\n        # self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        # return any('#' in node for node in self.waiting)\n\n        self.S = (letter + self.S)[:self.W]\n        cur = self.trie\n        for c in self.S:\n            if c in cur:\n                cur = cur[c]\n                if cur['#']:\n                    return True\n            else:\n                break\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import deque, defaultdict as dd\n\nclass TrieNode:\n    def __init__(self):\n        self.children = dd(TrieNode)\n        self.is_end = False\n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.q = deque()\n        self.root = TrieNode()\n        \n        for word in words:\n            node = self.root\n            for char in word[::-1]:\n                node = node.children[char]\n            node.is_end = True\n\n    def query(self, letter: str) -> bool:\n        self.q.appendleft(letter)\n        node = self.root\n        \n        for char in self.q:\n            if char not in node.children:\n                break\n            node = node.children[char]\n            if node.is_end:\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = [{} for i in range(2000)]\n        self.words = set()\n        words_ = [word[::-1] for word in set(words)]\n        for word in words_:\n            for i in range(len(word)-1):\n                self.memo[i+1][word[:i+1]]=0\n        \n        for word in words_:\n            self.memo[len(word)][word]=1     \n        \n        self.hist = []\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        w = ''\n        for i in range(len(self.hist)-1,-1,-1):\n            w+=self.hist[i]\n            #print(w)\n            c = self.memo[len(w)].get(w,None)\n            if c is None:\n                return False\n            if c:\n                return True\n            \n        return False\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.cur = ''\n        self.trie = {}\n\n        for word in words:\n            word = word[::-1]\n\n            tmp = self.trie\n            for w in word:\n                if w not in tmp:\n                    tmp[w] = dict()\n                    tmp = tmp[w]\n                else:\n                    tmp = tmp[w]\n\n            tmp['#'] = None\n\n    def query(self, letter: str) -> bool:\n        self.cur += letter\n\n        point = self.trie\n        for i in range(len(self.cur) - 1, -1, -1):\n            t = self.cur[i]\n\n            if '#' in point:\n                return True\n\n            if t not in point:\n                return False\n\n            point = point[t]\n \n        if '#' in point:\n            return True\n        else:\n            return False\n", "from collections import deque\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEndWord = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word):\n        head = self.root\n        for char in word:\n            head = head.children.setdefault(char, TrieNode())\n        head.isEndWord = True\n\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.vocab = Trie()\n        self.queue = deque()\n        for word in words:\n            self.vocab.addWord(word[::-1])\n\n    def query(self, char):\n        self.queue.appendleft(char)\n        cur = self.vocab.root\n        for c in self.queue:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.isEndWord:\n                    return True\n            else:\n                break\n        return False", "from collections import deque\nclass Node:\n    def __init__(self, char):\n        self.char = char\n        self.children = {}\n        self.word = \\\"\\\"\n\nclass Trie:\n    def __init__(self):\n        self.root = Node(\\\"\\\")\n\n    def add_word(self, word):\n        def helper(next_idx, node):\n            next_char = word[next_idx]\n            if next_char not in node.children:\n                node.children[next_char] = Node(next_char)\n            node = node.children[next_char]\n            if next_idx == len(word) - 1:\n                node.word = word\n            else:\n                helper(next_idx+1, node)\n        helper(0, self.root)\n\n    def word_exists(self, word):\n        def helper(next_idx, node):\n            if node.word:\n                return True\n            if next_idx >= len(word):\n                return False\n                \n            next_char = word[next_idx]\n            if next_char not in node.children:\n                return False\n            node = node.children[next_char]\n            return helper(next_idx+1, node)\n            \n        return helper(0, self.root)\n        \n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.max_word_length = 0\n        for word in words:\n            self.trie.add_word(word[::-1])\n            self.max_word_length = max(self.max_word_length, len(word))\n        self.q = deque()\n\n    def query(self, letter: str) -> bool:\n        if len(self.q) == self.max_word_length:\n            self.q.pop()\n        self.q.appendleft(letter)\n        return self.trie.word_exists(self.q)\n    # [\\\"cde\\\"]\n    # [\\\"c\\\" Node<d>, \\\"d\\\" None] e\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.child = [None]*26\n        self.is_leaf = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        root = TrieNode()\n        for word in words:\n            l = len(word)\n            node = root\n            for i in range(l-1,-1,-1):\n                index = ord(word[i]) - 97\n                if node.child[index] is None:\n                    node.child[index] = TrieNode()\n                node = node.child[index]\n            node.is_leaf = True\n        self.root = root\n        self.queue = []\n        \n    def query(self, letter: str) -> bool:\n        self.queue.append(letter)\n        if len(self.queue) > 2000:\n            self.queue.pop(0)\n        index = len(self.queue) - 1\n        node = self.root\n        while index >=0:\n            current = ord(self.queue[index]) - 97\n            node = node.child[current]\n            if node is None:\n                return False\n            elif node.is_leaf:\n                return True\n            index -= 1\n        return False\n                \n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\nclass TrieNode(object):\n    def __init__(self):\n        self.children = {}\n        self.nextFail = None\n        self.suffixMatches = []\n\n    def add(self, word, index=0):\n        #print(word)\n        if len(word) == index:\n            self.boundary = True\n            self.suffixMatches = [word]\n            return\n        c = word[index]\n        if self.children.get(c, None) is None:\n            self.children[c] = TrieNode()\n        self.children[c].add(word, index + 1)\n    def __str__(self):\n        return self.__str2()\n\n    def __str2(self, indent=0):\n        space = \\\"  \\\"*indent\n        return \\\"{}TrieNode(h={}, B={}, nf={},\\\n{}\\\".format(\n            space,\n            hash(self), self.suffixMatches, hash(self.nextFail) if self.nextFail else \\\"None\\\", \\\"\\\".join(space + k + \\\": \\\" + v.__str2(indent+1) + \\\"\\\n\\\" for k, v in self.children.items()),\n            space\n        ) + space + \\\")\\\"\n\n\nclass AhoTrie(object):\n    def __init__(self, words):\n        self.root = TrieNode()\n        for word in words:\n            self.root.add(word)\n        self.__oho()\n\n    def __oho(self):\n        q = deque()\n        for c, node in self.root.children.items():\n            node.nextFail = self.root\n            q.append(node)\n        while len(q) > 0:\n            node = q.popleft()\n            \n            for c, child in node.children.items():\n                nextFail = node.nextFail\n                while not nextFail.children.get(c) and nextFail is not self.root:\n                    nextFail = nextFail.nextFail\n                if not nextFail.children.get(c):\n                    child.nextFail = nextFail\n                else:\n                    child.nextFail = nextFail.children.get(c)\n\n                q.append(child)\n                #child.nextFail = node.nextFail.children.get(c, node.nextFail)\n                if  True: #child.suffixMatches:\n                    nextFail = child.nextFail\n                    while nextFail is not self.root and not nextFail.suffixMatches:\n                        nextFail = nextFail.nextFail\n                    if nextFail is not self.root:\n                        child.suffixMatches.extend(nextFail.suffixMatches)\n\n\n\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        print(words)\n        self.trie = AhoTrie(words) \n        self.root = self.trie.root\n        self.cur = self.root\n        #print(self.root)\n        \n\n    def query(self, letter: str) -> bool:\n        \n        \n        while not self.cur.children.get(letter) and self.cur is not self.root:\n            self.cur = self.cur.nextFail\n        #print(hash(self.cur))\n        if self.cur.children.get(letter):\n            self.cur = self.cur.children[letter]\n            temp = self.cur\n            #while temp is not self.root:\n            if temp.suffixMatches:\n                return True\n             #  temp = temp.nextFail\n        return False\n            \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            level = self.trie\n            for char in reversed(word):\n                if char not in level:\n                    level.update({char:{}})\n                level = level[char]\n            level.update({'.':{}})\n            \n        self.stream = ''\n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        level = self.trie\n        for char in reversed(self.stream):\n            if '.' in level:\n                return True\n            if char not in level:\n                return False\n            level = level[char]\n        if '.' in level:\n            return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.stream = deque([])\n        for word in words:\n            node = self.root\n            for ch in word[::-1]:\n                node.setdefault(ch, {})\n                node = node[ch]\n            node['#'] = {}\n\n        \n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        node = self.root\n        for i in range(len(self.stream) -1, -1, -1):\n            if self.stream[i] not in node:\n                return False\n            node = node[self.stream[i]]\n            if \\\"#\\\" in node:\n                return True\n        return \\\"#\\\" in node\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TreeNode:\n    def __init__(self):\n        self.children = {}\n        self.value = None\n    def insert(self, string):\n        root = self\n        for char in string:\n            if char not in root.children:\n                root.children[char] = TreeNode()\n            root = root.children[char]\n        root.value = string\n    def find(self, string):\n        root = self\n        for char in string:\n            if char in root.children:\n                root = root.children[char]\n            else:\n                return None\n        return root.value\n                 \nclass StreamChecker:\n    def __init__(self, words):\n        self.root = TreeNode()\n        self.characters = deque()\n        for word in words:\n            self.root.insert(word[::-1])\n    def query(self, letter: str) -> bool:\n        self.characters.appendleft(letter)\n        node = self.root\n        for char in self.characters:\n            if char in node.children:\n                node = node.children[char]\n                if node.value:\n                    return True\n            else:\n                return False\n\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n\n        for word in set(words):\n            node = self.trie       \n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n        \n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.root = {}\n    \n    def create_Trie(self,word):\n        cur_node = self.root\n        for w in word:\n            if w not in cur_node:\n                cur_node[w] = {}\n            cur_node = cur_node[w]\n        cur_node[\\\"$\\\"] = word\n        \n        \n\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.create_Trie(word[::-1])\n        self.stream = collections.deque()\n        \n\n    def query(self, letter: str) -> bool:\n        \n        self.stream.appendleft(letter)\n        cur_node = self.trie.root\n        for char in self.stream:\n            if \\\"$\\\" in cur_node:\n                return True\n            if char not in cur_node:\n                return False\n            cur_node = cur_node[char]\n        return \\\"$\\\" in cur_node\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    class Trie:\n        def __init__(self):\n            self.next = {}\n            self.ending = False\n            \n        def add(self,s):\n            if s != \\\"\\\":\n                if s[0] not in self.next:\n                    self.next[s[0]] = StreamChecker.Trie()\n                self.next[s[0]].add(s[1:])\n            else:\n                self.ending = True\n                \n        def __contains__(self,s):\n            if self.ending:\n                return True\n            elif s == \\\"\\\":\n                return False\n            elif s[-1] in self.next:\n                return self.next[s[-1]].__contains__(s[:len(s)-1])\n            else:\n                return False\n            \n    def __init__(self, words: List[str]):\n        self.words = self.Trie()\n        for w in words: self.words.add(w[::-1])\n        self.maxSize = max(len(w) for w in words)\n        self.q = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.q += letter\n        if len(self.q) > self.maxSize: self.q = self.q[1:]\n        return self.q in self.words\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.is_word = False\n        self.children = {}\n\nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode()\n    \n    def add_word(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_word = True\n    \n    def search_word(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                return False\n            if node.children[c].is_word:\n                return True\n            node = node.children[c]\n        return False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.input = deque()\n        self.trie = Trie()\n        self.max_len = 0\n        for word in words:\n            self.trie.add_word(word[::-1])\n            self.max_len = max(self.max_len, len(word))\n\n    def query(self, letter: str) -> bool:\n        self.input.appendleft(letter)\n        if len(self.input) > self.max_len:\n            self.input.pop()\n        return self.trie.search_word(self.input)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    \n    def __init__(self):\n        self.endOfWord = False\n        self.children = [None]*26\n\n    def insert(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None:\n                t.children[ord(c)-ord('a')] = Trie()\n            t = t.children[ord(c)-ord('a')]\n        t.endOfWord = True\n\n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None: return False\n            t = t.children[ord(c)-ord('a')]\n            if t.endOfWord: return True\n        return False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)", "class TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words: self.trie.insert(word[::-1])\n         \n    def query(self, letter):\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node: return True\n            else: break\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = dict()\n        self.end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for c in word:\n            root  = root.children.setdefault(c, TrieNode())\n        root.end = True\n\n    def search(self, word):\n        root = self.root\n        for c in word:\n            if c not in root.children:\n                return False\n            root = root.children[c]\n            if root.end:\n                return True\n        return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.curr = \\\"\\\"\n        for word in words:\n            self.trie.insert(reversed(word))\n\n    def query(self, letter: str) -> bool:\n        self.curr+=letter\n        if self.trie.search(reversed(self.curr)):\n            return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    \n    history = None\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.index = {}\n        for w in words:\n            idx = self.index.get(w[-1], [])\n            idx.append(w)\n            self.index[w[-1]] = idx\n        \n    def query(self, letter: str) -> bool:\n        self.history = self.history + letter\n        for word in self.index.get(letter, []):\n            if self.history.endswith(word):\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    \n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n        \n    def add_child(self, c):\n        return self.children.setdefault(c, TrieNode())\n    \n    def get_child(self, c):\n        return self.children.get(c)\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.data = []\n        self.root = TrieNode()\n        for word in words:\n            node = self.root\n            for c in reversed(word):\n                node = node.add_child(c)\n            node.is_word = True\n\n    def query(self, letter: str) -> bool:\n        self.data.append(letter)\n        node = self.root\n        for i in range(len(self.data) - 1, -1, -1):\n            node = node.get_child(self.data[i])\n            if node is not None and node.is_word:\n                return True\n            elif node is None:\n                return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.neighbor = {}  # char -> TrieNode\n        self.isend = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie_root = TrieNode()\n        self.letters = []\n        self.max_len = max(list(map(len, words)))\n        \n        for word in words:\n            curr = self.trie_root\n            for c in word[::-1]:\n                if c not in curr.neighbor:\n                    curr.neighbor[c] = TrieNode()\n                curr = curr.neighbor[c]\n            curr.isend = True\n        \n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        self.letters = self.letters[max(0, len(self.letters) - self.max_len):]\n     \n        curr = self.trie_root\n        for l in self.letters[::-1]:\n            if l in curr.neighbor:\n                curr = curr.neighbor[l]\n                if curr.isend:\n                    return True\n            else:\n                return False\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.isWord = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def addWord(self, word):\n        curr = self.root\n        for letter in word:\n            index = ord(letter) - ord('a')\n            if not curr.children[index]:\n                curr.children[index] = TrieNode()\n            curr = curr.children[index]\n        curr.isWord = True\n        \n    def search(self, word):\n        curr = self.root\n        for letter in word:\n            index = ord(letter) - ord('a')\n            if not curr.children[index]: \n                return False\n            curr = curr.children[index]\n            if curr.isWord: return True\n        return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.maxLength = 0\n        self.q = []\n        self.size = 0\n        for word in words:\n            revWord = word[::-1]\n            length = len(revWord)\n            self.maxLength = max(self.maxLength, length)\n            self.trie.addWord(revWord)\n        \n\n    def query(self, letter: str) -> bool:\n        self.q.append(letter)\n        self.size += 1\n        if self.size > self.maxLength:\n            self.q.pop(0)\n            self.size -= 1\n        return self.trie.search(self.q[::-1])\n            \n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self):\n        self.kids = collections.defaultdict(Node)\n        self.end = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        self.s = \\\"\\\"\n        for word in words:\n            t = self.root\n            for w in word[::-1]:\n                t = t.kids[w]\n            t.end = True\n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        if len(self.s) > 2000:\n            self.s = self.s[-2000:]\n        def dfs(t, word):\n            for w in word:\n                if w not in t.kids:\n                    return False\n                t = t.kids[w]\n                if t.end:\n                    return True\n            return False\n        return dfs(self.root, self.s[::-1])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.trie = {}\n    def insert(self,w):\n        t = self.trie\n        for c in w+'\\\\0':\n            if c not in t: t[c] = {}\n            t = t[c]\n    def match(self,w):\n        t = self.trie\n        for c in w:\n            if c not in t: return False\n            t = t[c]\n            if '\\\\0' in t: return True\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n        self.stream = deque()\n            \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.trie.match(self.stream)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TreeNode:\n    def __init__(self):\n        self.children = {}\n        self.value = None\n    def insert(self, string):\n        root = self\n        for char in string:\n            if char not in root.children:\n                root.children[char] = TreeNode()\n            root = root.children[char]\n        root.value = string\n    def find(self, string):\n        root = self\n        for char in string:\n            if char in root.children:\n                root = root.children[char]\n            else:\n                return None\n        return root.value\n                 \nclass StreamChecker:\n    def __init__(self, words):\n        self.root = TreeNode()\n        self.characters = \\\"\\\"\n        for word in words:\n            self.root.insert(word[::-1])\n    def query(self, letter: str) -> bool:\n        self.characters = letter + self.characters\n        node = self.root\n        for char in self.characters:\n            if char in node.children:\n                node = node.children[char]\n                if node.value:\n                    return True\n            else:\n                return False\n\n", "class StreamChecker:\n    from collections import deque\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        maxlen = 0\n        #d = self.trie \n        for word in words:\n            maxlen = max(maxlen,len(words))\n            d = self.trie\n            for i in range(len(word)-1, -1, -1):\n                if word[i] not in d:\n                    d[word[i]] = dict()\n                d = d[word[i]]\n            d[\\\"#\\\"]=dict()\n        self.maxlen = maxlen\n        #print(self.trie)\n        self.history = deque([])\n        \n\n    def query(self, letter: str) -> bool:\n        self.history.appendleft(letter)\n        if len(self.history)>self.maxlen:\n            self.history.pop()\n        d = self.trie\n        #print(self.history)\n        for l in range(len(self.history)):\n            #print(letter,self.history[l])\n            if self.history[l] in d:\n                d = d[self.history[l]]\n                if \\\"#\\\" in d:\n                    return True\n            else:\n                return False\n                \n                \n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self):\n        self.m = {}\n        self.end = False\n    \n    def get(self, c):\n        return self.m.get(c)\n    \n    def put(self, c, node):\n        self.m[c] = node\n        \n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n    \n    def insert(self, word):\n        node = self.root\n        for c in word[::-1]:\n            if not node.get(c):\n                node.put(c, Node())\n            node = node.get(c)\n        node.end = True\n    \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.stream = deque([])\n        for word in words:\n            self.trie.insert(word)\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node = self.trie.root\n        ans = ''\n        for c in self.stream:\n            if node.end:\n                return True\n            if not node.get(c):\n                return False\n            node = node.get(c)\n        return node.end\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:    \n    def __init__(self):\n        self.children = {}\n        self.is_leaf = False\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = TrieNode()\n        self.root = self.trie\n        self.buf = []\n        \n        for word in words:\n            self.trie = self.root\n            for i in range(len(word)-1, -1, -1):\n                ch = word[i]\n                if ch not in self.trie.children:\n                    self.trie.children[ch] = TrieNode()\n                self.trie = self.trie.children[ch]\n            self.trie.is_leaf = True\n        \n\n    def query(self, letter: str) -> bool:\n        self.buf.append(letter)\n        self.trie = self.root\n        for i in range(len(self.buf)-1,-1,-1):            \n            if self.buf[i] in self.trie.children:\n                self.trie = self.trie.children[self.buf[i]]\n                if self.trie and self.trie.is_leaf:\n                    return True\n            else:\n                return False\n\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isend_word = False\n\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    \n    def insert(self, word):\n        curr = self.root\n        for c in word:\n            if c not in curr.children:\n                curr.children[c] = TrieNode()\n            curr = curr.children[c]\n        curr.isend_word = True\n        \n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.search = []\n        for word in words:\n            self.trie.insert(word[::-1])\n        \n        \n    def query(self, letter: str) -> bool: \n        self.search.append(letter)\n        curr = self.trie.root\n        for i in reversed(list(range(len(self.search)))):\n            char = self.search[i]\n            if curr.isend_word:\n                return True\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n        \n        return curr.isend_word\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self,):\n        self.children=[None]*26\n        self.terminal=False\n\nclass Trie:\n    def __init__(self,):\n        self.root=Node()\n        self.size=0\n        \n    def get_index(self,x):\n        return ord(x)-ord('a')\n        \n    def insert(self,input_str):\n        curr=self.root\n        for x in input_str:\n            c=self.get_index(x)\n            if curr.children[c] is not None:\n                curr=curr.children[c]\n            else:\n                curr.children[c]=Node()\n                curr= curr.children[c]\n        curr.terminal=True\n        \n        \n    def search(self,input_str):\n        curr=self.root\n        for x in input_str:\n            c=self.get_index(x)\n            if curr.children[c] is not None:\n                curr=curr.children[c]\n                if curr.terminal:\n                    return True\n            else:\n                return False\n        return curr.terminal\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):        \n        self.trie=Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n        self.request_string=''  \n        \n    def query(self, letter: str) -> bool:\n        '''\n        ab ba aaab abab baa\n        \n        ba ab \n        \n        '''\n        self.request_string=letter+self.request_string\n        result=self.trie.search(self.request_string)\n        \n        return result\n            \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.head = {}\n\n    def insert(self, word):\n        cur = self.head\n        for ch in word:\n            if ch not in cur:\n                cur[ch] = {}\n            cur = cur[ch]\n        cur['*'] = True\n\n    def search(self, word):\n        cur = self.head\n        for ch in word:\n            if ch not in cur:\n                return False\n            cur = cur[ch]\n        if cur.get('*'):\n            return True\n        return False\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.max_len = 0\n        words = list([s[::-1] for s in words])\n        for word in words:\n            self.max_len = max(self.max_len, len(word))\n            self.trie.insert(word)\n        self.query_store = deque(maxlen=self.max_len)\n        \n\n    def query(self, letter: str) -> bool:\n        self.query_store.appendleft(letter)\n        query = ''.join(self.query_store)\n        cur = self.trie.head\n        for ch in query:\n            if ch not in cur:\n                return False\n            cur = cur[ch]\n            if cur.get('*'):\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_word = True\n    \n    def find(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n            if node.is_word:\n                return True\n        return False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.history = \\\"\\\"\n        for word in words:\n            self.trie.insert(word[::-1])\n        \n\n    def query(self, letter: str) -> bool:\n        self.history = letter + self.history\n        return self.trie.find(self.history)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def add_word(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_word = True\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.stream = collections.deque()\n        self.size = 0\n        \n        for word in words:\n            self.size = max(len(word), self.size)\n            self.trie.add_word(word[::-1])\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        # stream is limited to length of longest word\n        if len(self.stream) > self.size:\n            self.stream.pop()\n        \n        node = self.trie.root\n        for ch in self.stream:\n            if node.is_word:\n                return True\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_word\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.stream = collections.deque()\n        for word in words:\n            node = self.root\n            for ch in word[::-1]:\n                if ch not in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['#'] = {}\n        # print(self.root)\n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node = self.root\n        # print('=>', letter)\n        for ch in self.stream:\n            if ch in node:\n                # print(ch)\n                node = node[ch]\n                if '#' in node:\n                    return True\n            else:\n                return False\n        return '#' in node\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = {}\n        self.words = set()\n        for word in words:\n            word_ = word[::-1]\n            for i in range(len(word)):\n                self.memo[word_[:i+1]]=0\n            self.words.add(word_)        \n        self.hist = []\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        w = ''\n        for i in range(len(self.hist)-1,-1,-1):\n            w+=self.hist[i]\n            #print(w)\n            if w not in self.memo:\n                return False\n            if w in self.words:\n                return True\n        return False\n\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = self._get_trie(words)\n        self.stream = collections.deque()\n    \n    def _get_trie(self, words):\n        trie = ({}, False)\n        \n        for w in words:\n            cur = trie\n            n = len(w)\n            for i, c in enumerate(w[::-1]): \n                \\\"\\\"\\\"\n                reversing the word is crucial for runtime\n                \\\"\\\"\\\" \n                is_last_letter = i == n - 1\n                \n                if c not in cur[0]:\n                    cur[0][c] = ({}, is_last_letter)\n                elif c in cur[0] and not cur[0][c][1] and is_last_letter:\n                    cur[0][c] = (cur[0][c][0], is_last_letter)\n                \n                cur = cur[0][c]\n            \n        return trie\n    \n#     def _search(self, word):\n#         cur = self.trie\n#         for c in word:\n#             if c in cur[0]:\n#                 cur = cur[0][c]\n#             else:\n#                 return (False, False)\n        \n#         return (cur[1], True)\n\n    \n    def _search_any(self, word):\n        cur = self.trie\n        for c in word:\n            if c in cur[0]:\n                cur = cur[0][c]\n            else:\n                return False\n            \n            if cur[1]:\n                return True\n        \n        return False\n\n#     def query_2(self, letter: str) -> bool:\n#         self.stream.append(letter)\n#         word = copy.copy(self.stream)\n#         word_seen = False\n#         for i in range(len(self.stream)):\n#             search = self._search(word)\n#             if search[0]:\n#                 return True\n#             if not search[1] and not word_seen:\n#                 self.stream.popleft()\n#             else:\n#                 word_seen = True\n#             word.popleft()\n        \n#         return False\n    \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self._search_any(self.stream)\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.child = {}\n        self.isword = False\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for w in word:\n            if w not in node.child:\n                node.child[w] = TrieNode()\n            node = node.child[w]\n        node.isword = True\n        \n    def search(self, word):\n        node = self.root\n        for w in word:\n            if w in node.child:\n                if node.child[w].isword == True: return True\n                node = node.child[w]\n            else: return False\n        return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n        self.stack = []\n        self.size = max(len(word) for word in words)\n    def query(self, letter: str) -> bool:\n        if len(self.stack) >= self.size:\n            self.stack.pop(0)\n        self.stack.append(letter)\n        return self.trie.search(''.join(self.stack[::-1]))\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self, val):\n        self.val = val\n        self.links = {}\n        self.is_end = False\n    \n    def getLink(self, char):\n        return self.links.get(char)\n    \n    def addLink(self, node):\n        self.links[node.val] = node\n    \n    def setEnd(self):\n        self.is_end = True\n\nclass Trie:\n    def __init__(self):\n        self.roots = [None] * 26\n    \n    def insertWord(self, word):\n        if self.roots[ord(word[0]) - ord('a')] is None:\n            self.roots[ord(word[0]) - ord('a')] = TrieNode(word[0])\n        \n        currNode = self.roots[ord(word[0]) - ord('a')]\n        \n        for i in range(1, len(word)):\n            char = word[i]\n            nextNode = currNode.getLink(char)\n            if nextNode is None:\n                nextNode = TrieNode(char)\n                currNode.addLink(nextNode)\n            currNode = nextNode\n        \n        currNode.setEnd()\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        maxLen = 0\n        for word in words:\n            self.trie.insertWord(word[::-1])\n            maxLen = max(maxLen, len(word))\n        \n        self.maxsize = maxLen\n        self.stream = []\n        self.streamsize = 0\n\n    def query(self, letter: str) -> bool:\n        if self.streamsize == self.maxsize:\n            self.stream = self.stream[1:]\n            self.streamsize -= 1\n        \n        self.stream.append(letter)\n        self.streamsize += 1\n        \n        node = None\n        \n        for i in range(len(self.stream) -1, -1, -1):\n            rootChar = self.stream[i]\n            if node is None:\n                node = self.trie.roots[ord(rootChar) - ord('a')]\n            else:\n                nextNode = node.getLink(rootChar)\n                node = nextNode\n            if node is None:\n                break\n            elif node.is_end:\n                return True\n\n        return False\n        \n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            word = word[::-1]\n            cur = self.trie\n            for char in word:\n                if char not in cur:\n                    cur[char] = {}\n                cur = cur[char]\n            cur['$'] = {}\n        self.queries = []\n\n    def query(self, letter: str) -> bool:\n        self.queries.insert(0, letter)\n        cur = self.trie\n        for char in self.queries:\n            if '$' in cur:\n                return True\n            if char not in cur:\n                return False\n            cur = cur[char]\n        return ('$' in cur)\n\n    def __repr__(self):\n        return \\\"Trie: \\\" + str(self.trie) + \\\"\\\n\\\" + \\\"Queries: \\\" + str(self.queries)\n\n\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        curr = self.root\n        for ch in word:\n            if ch not in curr.children:\n                curr.children[ch] = TrieNode()\n            curr = curr.children[ch]\n        curr.isEnd = True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters) - 1\n        curr = self.trie.root\n        while i >= 0:\n            if curr.isEnd == True:\n                return True\n            if self.letters[i] not in curr.children:\n                return False\n            curr = curr.children[self.letters[i]]\n            i -= 1\n        return curr.isEnd\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.Trie = {}\n        for word in words:\n            curnode=self.Trie\n            word = word[::-1]\n            for ch in word:\n                if ch not in curnode:\n                    curnode[ch]={}\n                curnode=curnode[ch]\n            curnode['#']=1\n        self.pre=''\n\n    def query(self, letter: str) -> bool:\n        self.pre=self.pre+letter\n        curnode=self.Trie\n        for i in range(0, len(self.pre)):\n            if self.pre[-i-1] not in curnode:\n                break\n            curnode=curnode[self.pre[-i-1]]\n            if '#' in curnode:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\nclass Node:\n    def __init__(self, char):\n        self.char = char\n        self.children = {}\n        self.word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = Node(\\\"\\\")\n\n    def add_word(self, word):\n        def helper(next_idx, node):\n            next_char = word[next_idx]\n            if next_char not in node.children:\n                node.children[next_char] = Node(next_char)\n            node = node.children[next_char]\n            if next_idx == len(word) - 1:\n                node.word = True\n            else:\n                helper(next_idx+1, node)\n        helper(0, self.root)\n\n    def prefix_of_word_exists(self, word):\n        idx = 0\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n            if node.word:\n                return True\n        return False\n        \n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.max_word_length = 0\n        for word in words:\n            self.trie.add_word(word[::-1])\n            self.max_word_length = max(self.max_word_length, len(word))\n        self.q = deque()\n\n    def query(self, letter: str) -> bool:\n        if len(self.q) == self.max_word_length:\n            self.q.pop()\n        self.q.appendleft(letter)\n        return self.trie.prefix_of_word_exists(self.q)\n    # [\\\"cde\\\"]\n    # [\\\"c\\\" Node<d>, \\\"d\\\" None] e\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words: self.trie.insert(word[::-1])\n         \n    def query(self, letter):\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node: return True\n            else: break\n        return False", "from collections import deque\nfrom typing import Dict\n\nclass Trie:\n    def __init__(self):\n        self.d = {}\n    \n    def ends(self) -> bool:\n        return \\\"$\\\" in self.d\n    \n    def absent(self, c) -> bool:\n        return c not in self.d\n    \n    def getTrie(self, c):\n        return self.d[c]\n    \n    def addWord(self, word: str) -> None:\n        if not word:\n            self.d[\\\"$\\\"] = None\n            return\n        if word[0] not in self.d:\n            self.d[word[0]] = Trie()\n        self.d[word[0]].addWord(word[1:])\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.max_len = max(map(len, words))\n        self.suffix_trie = self.build_tree(words)\n        self.queue = deque([])\n    \n    def build_tree(self, words: List[str]) -> Dict[str, Trie]:\n        trie: Trie = Trie()\n        for word in words:\n            trie.addWord(word[::-1])\n        return trie\n\n    def query(self, letter: str) -> bool:\n        # if self.max_len == self.curr_len:\n        #     self.queue.popleft()\n        self.queue.appendleft(letter)\n        i = 0\n        n = self.suffix_trie\n        while i < len(self.queue):\n            if n.ends():\n                return True\n            if n.absent(self.queue[i]):\n                return False\n            n = n.getTrie(self.queue[i])\n            i += 1\n        return n.ends()\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n  def __init__(self, words: List[str]):\n    self.string = collections.deque()\n    self.root = {}\n    for word in words:\n      node = self.root\n      for c in word[::-1]:\n        if c not in node:\n          node[c] = {}\n        node = node[c]\n      node['#'] = 1\n\n  def query(self, letter: str) -> bool:\n    self.string.appendleft(letter)\n    node = self.root\n    for c in self.string:\n      if c in node:\n        node = node[c]\n        if '#' in node:\n          return True\n      else:\n        return False\n    return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie(defaultdict):\n    #def __init__(self):\n    #        self.root = self\n            #self.eow = False\n            \n    def addWord(self,word):\n        curr = self\n        for ch in word:\n            if ch not in curr:\n                curr[ch] = Trie()   \n            curr = curr[ch]\n        curr['*'] = True   \n        \n    def searchWord(self,word) -> bool:\n        curr = self\n        #print(word)\n        for ch in word:\n            if ch in curr:\n                curr = curr[ch]   \n            else:\n                return False    \n            if '*' in curr:\n                return True  \n        return False   \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.maxLen = 0\n        for word in words:\n            self.maxLen = max(self.maxLen, len(word))\n            self.trie.addWord(word[::-1])\n            \n        #print(self.trie)    \n        self.history = []\n\n    def query(self, letter: str) -> bool:\n        if len(self.history) == self.maxLen:\n            self.history.pop(0)\n        self.history.append(letter)    \n        return self.trie.searchWord(''.join(self.history[::-1]))\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie():\n    def __init__(self):\n        self.children = [None]*26\n        self.endOfWord = False\n        \n    def insert(self, s):\n        curr = self\n        for c in s:\n            if curr.children[ord(c) - ord('a')] == None:\n                curr.children[ord(c) - ord('a')] = Trie()\n            curr = curr.children[ord(c) - ord('a')]\n        curr.endOfWord = True\n        \n    def search(self, s):\n        curr = self\n        for c in s:\n            if curr.children[ord(c) - ord('a')] == None:\n                return False\n            curr = curr.children[ord(c) - ord('a')]\n            if curr.endOfWord == True:\n                return True\n        return False\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n    \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "# https://leetcode.com/problems/stream-of-characters/discuss/320837/Easily-implemented-Python-Trie-Solution\n# Trie implemented based on defaultdict get TLE, originial Python dict won't get\nclass TrieNode:\n    def __init__(self) -> None:\n        self.children = {}\n        self.isWord = False\n    \nclass Trie:\n    def __init__(self) -> None:\n        self.root = TrieNode()\n    \n    def insert(self, word: str) -> None:\n        current = self.root\n        for letter in word:\n            if letter not in current.children:\n                current.children[letter] = TrieNode()\n            current = current.children[letter]\n        current.isWord = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.queries = []\n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.queries.append(letter)\n        idx = len(self.queries) - 1\n        current = self.trie.root\n        while idx >= 0:\n            letter = self.queries[idx]\n            if letter not in current.children:\n                return False\n            current = current.children[letter]\n            if current.isWord:\n                return True\n            idx -= 1\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tries = {}\n        self.hist = []\n        for word in words:\n            cur = self.tries            \n            for c in word[::-1]:\n                if c not in cur:\n                    cur[c] = {}\n                cur = cur[c]\n            cur['#'] = word\n\n    def query(self, letter: str) -> bool:\n        self.hist.insert(0, letter) \n        cur = self.tries\n        for c in self.hist:\n            if '#' in cur:\n                return True\n            if c in cur:\n                cur = cur[c]\n            else:\n                return False\n        return '#' in cur\n\n    \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def build_trie(self, words):\n        for word in words:\n            w = word[::-1]\n            curr = self.trie\n            for l in w:\n                if curr[ord(l)-ord('a')]:\n                    curr = curr[ord(l)-ord('a')]\n                else:\n                    curr[ord(l)-ord('a')] = [[] for i in range(27)]\n                    curr = curr[ord(l)-ord('a')]\n            curr[26] = 1\n    \n    def __init__(self, words: List[str]):\n        self.trie = [[] for i in range(27)]\n        self.mlength = max([len(w) for w in words])\n        self.mem = ''\n        self.build_trie(words)\n\n    def query(self, letter: str) -> bool:\n        if len(self.mem) < self.mlength:\n            self.mem += letter\n        else:\n            self.mem = self.mem[1:] + letter\n        w = self.mem[::-1]\n        curr = self.trie\n        for l in w:\n            if curr[26]:\n                return True\n            if curr[ord(l)-ord('a')]:\n                curr = curr[ord(l)-ord('a')]\n            else:\n                return False\n        if curr[26]:\n                return True\n        else:\n            return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    \n    def __init__(self):\n        self.endOfWord = False\n        self.children = [None]*26\n\n    def insert(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None:\n                t.children[ord(c)-ord('a')] = Trie()\n            t = t.children[ord(c)-ord('a')]\n        t.endOfWord = True\n\n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None: return False\n            t = t.children[ord(c)-ord('a')]\n            if t.endOfWord: return True\n        return False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n    \n    def insert(self, word):\n        if len(word)==0:\n            self.isEnd = True\n            return\n        if word[0] not in self.children:\n            self.children[word[0]] = Trie()\n        self.children[word[0]].insert(word[1:])\n        \n    def search(self, word):\n        if len(word)==0:\n            return (True, False)\n        if len(word)==1:\n            return (word[0] in self.children, word[0] in self.children and self.children[word[0]].isEnd)\n        startsWith = word[0] in self.children\n        if startsWith:\n            return self.children[word[0]].search(word[1:])\n\n        return (False, False)\n\n    def startsWith(self, word):\n        if len(word)==0:\n            return True\n        return word[0] in self.children and self.children[word[0]].startsWith(word[1:])\n    def next(self, char):\n        if char in self.children:\n            return self.children[char]\n        return None\n    def printNode(self):\n        print(self.children,self.isEnd)\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = Trie()\n        for word in words:\n            self.words.insert(word[::-1])\n        self.stream = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        node = self.words\n        for i in range(len(self.stream)-1, -1, -1):\n            node = node.next(self.stream[i])\n            if node==None:\n                return False\n            if node.isEnd:\n                return True\n            \n                \n        return False\n    \n                \n                \n                \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.maxn = max([len(x) for x in words])\n        self.suffix = set()\n        self.words = set(words)\n        for i in words:\n            for j in range(len(i)-1, -1, -1):\n                self.suffix.add(i[j:])\n        self.queue = []\n\n    def query(self, letter: str) -> bool:\n        if len(self.queue) >= self.maxn:\n            self.queue.pop(0)\n        self.queue.append(letter)\n        st = ''\n        for i in range(len(self.queue) -1, -1, -1):\n            st = self.queue[i] + st\n            if st in self.words:\n                return True \n            elif st not in self.suffix:\n                return False \n        return False \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    \n    def __init__(self, flag=False):\n        self.flag = False\n        self.a = [None] * 26\n    \n    def insert(self, s, p):\n        if p == len(s):\n            self.flag = True\n            return\n        c = ord(s[p]) - ord('a')\n        if self.a[c] is None:\n            self.a[c] = Node()\n        self.a[c].insert(s, p + 1)\n        \n    def query(self, s, p):\n        if p == -1:\n            return False\n        c = ord(s[p]) - ord('a')\n        if self.a[c] is None:\n            return False\n        if self.a[c].flag:\n            return True\n        return self.a[c].query(s, p - 1)\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.node = Node()\n        self.s = []\n        for word in words:\n            self.node.insert(word[::-1], 0)\n\n    def query(self, letter: str) -> bool:\n        self.s.append(letter)\n        return self.node.query(self.s, len(self.s) - 1)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.trie = Trie()\n        for w in words:\n            self.trie.insert(w[::-1])\n        \n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.letters[i] not in node.children:\n                return False\n            node = node.children[self.letters[i]]\n            i -= 1\n        return node.isEnd", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.stream = collections.deque()\n        for word in words:\n            node = self.root\n            for ch in word[::-1]:\n                if ch not in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['#'] = {}\n        # print(self.root)\n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node = self.root\n        # print('=>', letter)\n        for ch in self.stream:\n            if ch in node:\n                # print(ch)\n                node = node[ch]\n                if '#' in node:\n                    return True\n            else:\n                return False\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.wlookup = defaultdict(set)\n        self.llookup = defaultdict(set)\n        self._buf = \\\"\\\"\n        \n        for w in words:\n            self.wlookup[w[-1]].add(w[::-1])\n            self.llookup[w[-1]].add(len(w))\n        \n        \n\n    def query(self, letter: str) -> bool:\n        self._buf = \\\"\\\".join((letter, self._buf))\n        \n        #print(self.wlookup, self.llookup, self._buf, letter)\n        \n        if letter not in self.wlookup:\n            return False\n        \n        for l in self.llookup[letter]:\n            if self._buf[:l] in self.wlookup[letter]:\n                return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.word = False\n        self.children = {}\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        node = self.root\n        for w in word:\n            if w not in node.children:\n                node.children[w] = TrieNode()\n            node = node.children[w]\n        node.word = True\n    \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.word == True:\n                return True\n            if self.letters[i] not in node.children:\n                return False\n            node = node.children[self.letters[i]]\n            i -= 1\n        return node.word\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.next = {}\n        self.is_word = False\n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        for word in words:\n            itr = self.root\n            for c in word[::-1]:\n                itr.next.setdefault(c, TrieNode())\n                itr = itr.next[c]\n            itr.is_word = True\n        self.stream = deque()\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        curr = self.root\n        for c in self.stream:\n            if c in curr.__next__:\n                curr = curr.next[c]\n                if curr.is_word:\n                    return True\n            else:\n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.word_tree = dict()\n        self.stream = []\n        self.min_len = float(\\\"inf\\\")\n        \n        rev_words = sorted([word[::-1] for word in words])\n        \n        for word in rev_words:\n            self.min_len = min(self.min_len, len(word))\n            cur_dict = self.word_tree\n            for c in word[:-1]:\n                if c not in cur_dict:\n                    cur_dict[c] = (False, dict())\n                    \n                cur_dict = cur_dict[c][1]\n                \n            if word[-1] not in cur_dict:\n                cur_dict[word[-1]] = (True, dict())\n            else:\n                last_entry = cur_dict[word[-1]]\n                cur_dict[word[-1]] = (True, last_entry[1])\n                \n\n    def query(self, letter: str) -> bool:\n        self.stream.insert(0, letter)\n        \n        if len(self.stream) < self.min_len: return False\n        \n        cur_dict = self.word_tree\n        for c in self.stream:\n            if c in cur_dict and cur_dict[c][0]:\n                return True\n            elif c in cur_dict:\n                cur_dict = cur_dict[c][1]\n            else:\n                return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TreeNode:\n    def __init__(self,chr):\n        self.val = chr\n        self.children = {}\n        self.leaf = False\n\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \\\"\\\"\\\"\n        Initialize your data structure here.\n        \\\"\\\"\\\"\n        self.root = TreeNode(None)\n        for word in words:\n            self.insert(''.join(reversed(word)))\n        self.ans=''\n\n    def insert(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        \\\"\\\"\\\"\n        parent = self.root\n        for c in word:\n            if(c not in parent.children):\n                parent.children[c] = TreeNode(c)\n            parent = parent.children[c]\n        parent.leaf = True\n        \n\n    def search(self, word: str) -> bool:\n        \\\"\\\"\\\"\n        Returns if the word is in the trie.\n        \\\"\\\"\\\"\n        parent = self.root\n        for c in word:\n            if(c not in parent.children):\n                return False\n            parent = parent.children[c]\n            if(parent.leaf):\n                return True\n        return False\n                \n          \n\n    def query(self, letter: str) -> bool:\n        self.ans=letter+self.ans\n        return self.search(self.ans)\n        \n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.ends_here = False\n\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n        \n    def insert(self, word):\n        curr = self.root\n        \n        for c in word:\n            curr = curr.children.setdefault(c, TrieNode())\n            \n        curr.ends_here = True\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.queue = deque()\n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.queue.appendleft(letter)\n        curr = self.trie.root\n        \n        for c in self.queue:\n            if c in curr.children:\n                curr = curr.children[c]\n                if curr.ends_here:\n                    return True\n                \n            else:\n                break\n                \n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\nclass TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.eow = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def charToIndex(self, _char):\n        return ord(_char) - ord('a')\n    \n    def insert(self, word):\n        node = self.root\n        l = len(word)\n        for i in range(l):\n            idx = self.charToIndex(word[i])\n            if node.children[idx] == None:\n                node.children[idx] = TrieNode()\n            node = node.children[idx]\n        node.eow = True\n        \n    def search(self, word):\n        node = self.root\n        l = len(word)\n        for i in range(l):\n            idx = self.charToIndex(word[i])\n            if node.children[idx] != None:\n                node = node.children[idx]\n            else:\n                return False\n            if node.eow:\n                return True\n        return node!=None and node.eow\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.trie = Trie()\n        for word in self.words:\n            # print(word[::-1])\n            self.trie.insert(word[::-1])\n\n        self.longest = len(max(words, key=len))\n        self.data = deque([], maxlen=self.longest)\n        \n\n    def query(self, letter: str) -> bool:\n        if self.data.count == self.longest:\n                popped = self.data.pop()\n        self.data.appendleft(letter)\n        # print(\\\"\\\".join(self.data))\n        if self.trie != None and self.trie.root.children[ord(letter)-ord('a')] != None:\n            return self.trie.search(\\\"\\\".join(self.data))\n        else:\n            return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.stream = []\n        self.word_end = -1\n        for word in words:\n            cur_node = self.root\n            for char in word[::-1]:\n                cur_node.setdefault(char, {})\n                cur_node = cur_node[char]\n            cur_node[self.word_end] = True\n        \n    def query(self, letter: str) -> bool:\n        self.stream.insert(0, letter)\n        cur_node = self.root\n        for char in self.stream:\n            if char not in cur_node:\n                return False\n            else:\n                cur_node = cur_node[char]\n                if self.word_end in cur_node:\n                    return True\n        return False\n            \n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    \n    def __init__(self):\n        self.endOfWord = False\n        self.children = [None] * 26\n        \n    def insert(self, s):\n        t = self\n        for c in s:\n            if (t.children[ord(c) - ord('a')] == None):\n                t.children[ord(c) - ord('a')] = Trie()\n            t = t.children[ord(c) - ord('a')]\n        t.endOfWord = True\n        \n    def search(self, s):\n        t = self\n        for c in s:\n            if (t.children[ord(c) - ord('a')] == None):\n                return False\n            t = t.children[ord(c) - ord('a')]\n            if t.endOfWord:\n                return True\n        return False\n                \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n        \n        # O(NM) time and space N=len(words), M = wordlen #\n        for w in words:\n            node = self.trie\n            for c in w[::-1]:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['$'] = w\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        # O(M) time and space \n        node = self.trie\n        for c in self.stream:\n            if '$' in node:\n                return True\n            if c not in node:\n                return False\n            node = node[c]\n        return '$' in node\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\nfrom functools import reduce\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # O(N x M)\n\n        self.s = \\\"\\\"\n        self.dic = defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n        \n\n    def query(self, letter: str) -> bool:\n        # O(M) where M is a max word length.\n\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    d = {}\n    record = {}\n\n    def __init__(self):\n        self.record = {}\n        self.d = {}\n\n    def add(self, word):\n        if len(word) == 1:\n            if word[0] not in self.d:\n                self.d[word[0]] = Trie()\n                self.d[word[0]].d[-1] = 1\n                return\n            else:\n                self.d[word[0]].d[-1] = 1\n                return\n\n        letter = word[-1]\n        if letter in self.d:\n            self.d[letter].add(word[:-1])\n            return\n\n        self.d[letter] = Trie()\n        self.d[letter].add(word[:-1])\n        return\n    \n    def search(self, ls, index):\n        if index in self.record:\n            return self.record[index]\n        \n        val = False\n        if -1 in self.d:\n            val = True\n        \n        elif index < 0:\n            val = False\n        \n        elif ls[index] in self.d:\n            val = self.d[ls[index]].search(ls, index - 1)\n        \n        self.record[index] = val\n        \n        return val\n    \nclass StreamChecker:\n    root = None\n    l = None\n    size = 0\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        self.l = collections.deque()\n        self.size = 0\n        for i in words:\n            self.root.add(i)\n            \n\n    def query(self, letter: str) -> bool:\n        self.size += 1\n        self.l.append(letter)\n        #print(letter)\n        return self.root.search(self.l, self.size - 1)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.children = dict()\n        self.isend = False\n    \n    def insert(self, word):\n        cur = self\n        for ch in word:\n            if ch not in cur.children:\n                cur.children[ch] = Trie()\n            cur = cur.children[ch] \n        cur.isend = True\n    \n    def hasPrefix(self, stream):\n        cur = self\n        for ch in stream:\n            if ch not in cur.children:\n                return False\n            cur = cur.children[ch] \n            if cur.isend:\n                return True\n        return cur.isend\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.longest = 0\n        for w in words:\n            self.longest = max(self.longest, len(w))\n            self.trie.insert(w[::-1])\n        self.stream = deque()\n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        if len(self.stream) > self.longest:\n            self.stream.pop()\n        return self.trie.hasPrefix(''.join(self.stream))\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "\nclass TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words: self.trie.insert(word[::-1])\n    \n    def query(self, letter):\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node: return True\n            else: break\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEndWord = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word):\n        head = self.root\n        for char in word:\n            head = head.children.setdefault(char, TrieNode())\n        head.isEndWord = True\n\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.vocab = Trie()\n        self.queue = deque()\n        for word in words:\n            self.vocab.addWord(word[::-1])\n\n    def query(self, char):\n        self.queue.appendleft(char)\n        cur = self.vocab.root\n        for c in self.queue:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.isEndWord:\n                    return True\n            else:\n                break\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "\nclass Node:\n    def __init__(self):\n        self.word = False \n        self.children = {}\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.words = words\n        self.word = \\\"\\\"\n        self.head = Node()\n        for word in words:\n            word = word[::-1]\n            ptr = self.head\n            for cha in word:\n                if cha not in ptr.children:\n                    ptr.children[cha] = Node()\n                ptr = ptr.children[cha]\n            ptr.word = True \n                    \n\n    def query(self, letter: str) -> bool:\n        self.word+=letter \n        \n        length = len(self.word)\n        ptr = self.head \n        for i in range(length-1, -1, -1):\n            if self.word[i] not in ptr.children:\n                return False \n            ptr = ptr.children[self.word[i]]\n            if ptr.word:\n                return True \n        return False \n        \n        \n            \n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self):\n        self.children = collections.defaultdict(Node)\n        self.isStart = False\n        \n        \nclass Trie:\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        self.maxLen = 0\n        \n        for word in words:\n            self.maxLen = max(self.maxLen, self.insert(word))\n            \n    def insert(self, word: str) -> int:\n        i = 0\n        current = self.root\n        for char in word[::-1]:\n            current = current.children[char]\n            i += 1\n            \n        current.isStart = True\n        return i\n    \n    def endsWith(self, word: str) -> bool:\n        current = self.root\n        for char in word:\n            if current.isStart:\n                return True\n            if char not in current.children:\n                return False\n            current = current.children[char]\n            \n        return current.isStart\n        \n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.wl = Trie(words)\n        self.bufSize = self.wl.maxLen\n        self.history = collections.deque()\n\n    def query(self, letter: str) -> bool:\n        self.history.appendleft(letter)\n        if len(self.history) > self.bufSize:\n            self.history.pop()  \n            \n        return self.wl.endsWith(''.join(self.history))\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = defaultdict(list)\n        for word in words:\n            self.words[word[-1]].append(word)\n        self.l = ''\n        \n\n    def query(self, letter: str) -> bool:\n        self.l += letter\n        for i in self.words[letter]:\n            if self.l.endswith(i):\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\nimport queue \nclass TrieNode():\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.cstream = []\n        for word in words:\n            curr = self.root\n            for c in word[::-1]:\n                curr = curr.children[c]\n            curr = curr.children['$']\n    \n    def query(self, letter: str) -> bool:\n        self.cstream.insert(0,letter)\n        curr = self.root\n        for c in self.cstream:\n            if '$' in curr.children:\n                return True\n            if c not in curr.children:\n                return False\n            curr = curr.children[c]\n        return '$' in curr.children\n        pass\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.child = {}\n        self.isEnd = False;\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        self.str = []\n        \n        for word in words:\n            node = self.root\n            for ch in reversed(word):\n                if ch not in node.child:\n                    node.child[ch] = Trie()\n                node = node.child[ch]\n            node.isEnd = True\n\n    def query(self, letter: str) -> bool:\n        self.str.insert(0, letter)\n        \n        node = self.root\n        for ch in self.str:\n            if ch not in node.child:\n                return False\n            node = node.child[ch]\n            if node.isEnd:\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    \\\"\\\"\\\"\n    cd, f, kl, \n           ^\n    \n    \n    trie{\n        d: {\n            c: {\n                $: True\n            }\n            },        \n        f: {\n            $: True   \n            }        \n        k: {\n          l: {\n            $: True\n            }\n            }\n    }\n    \n    queue = [a, b, c, d]\n                      ^\n                      \n            dcba\n            ^\n    \\\"\\\"\\\"\n    def __init__(self, words: List[str]):\n        self.trie = {} \n        self.stream = []\n        for word in words:\n            node = self.trie\n            for letter in reversed(word):\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node['$'] = True                        \n\n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        node = self.trie\n        for letter in reversed(self.stream):            \n            if letter in node:\n                node = node[letter]\n                if \\\"$\\\" in node:\n                    return True\n            else:\n                return False\n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.isWord=False\n        self.child = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def add_word(self, word):\n        cur = self.root\n        for i in range(len(word)):\n            if word[i] not in cur.child:\n                cur.child[word[i]]=TrieNode()\n            cur =cur.child[word[i]]\n        cur.isWord=True\n    \n    def search_word(self, word):\n        cur=self.root\n        for i in range(len(word)):\n            if word[i] not in cur.child:\n                return False\n            else:\n                cur=cur.child[word[i]]\n        return cur.isWord\n             \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie=Trie()\n        self.max_length = max(len(word) for word in words)\n        self.letters =collections.deque()\n        for word in words:\n            self.trie.add_word(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        if len(self.letters)>self.max_length:\n            self.letters.popleft()\n        \n        t = list(self.letters)[::-1]\n        cur = self.trie.root\n        for letter in t:\n            if letter not in cur.child:\n                return False\n            cur=cur.child[letter]\n            if cur.isWord:\n                return True\n        return False\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = {}\n        self.words = set()\n        words_ = [word[::-1] for word in words]\n        for word in words_:\n            for i in range(len(word)-1):\n                self.memo[word[:i+1]]=0\n        \n        for word in words_:\n            self.memo[word]=1     \n        \n        self.hist = []\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        w = ''\n        for i in range(len(self.hist)-1,-1,-1):\n            w+=self.hist[i]\n            #print(w)\n            c = self.memo.get(w,None)\n            if c is None:\n                return False\n            if c:\n                return True\n            \n        return False\n", "class TrieNode:\n    def __init__(self):\n        self.edges={}\n    \n    def get_edge(self,edge):\n        return self.edges[edge]\n    \n    def add_edge(self,edge):\n        self.edges.setdefault(edge,TrieNode())\n            \n    def has_edge(self,edge):\n        return edge in self.edges\n    \n    def isWord(self):\n        return \\\"$\\\" in self.edges\n    \nclass Trie:\n    \n    def __init__(self):\n        self.root=TrieNode()\n        \n    def insert(self,word):\n        cur=self.root\n        for c in word:\n            cur.add_edge(c)\n            cur=cur.get_edge(c)\n        cur.add_edge(\\\"$\\\")\n        \n    def search(self, word):\n        cur=self.root\n        for c in word:\n            if cur.isWord():\n                return True\n            if not cur.has_edge(c):\n                return False\n            cur=cur.get_edge(c)\n        return cur.isWord()\nfrom collections import deque\nclass StreamChecker:\n    def __init__(self, W):\n        self.prefix=deque()\n        self.trie=Trie()\n        for w in W:\n            self.trie.insert(w[::-1])\n\n    def query(self, c):\n        self.prefix.appendleft(c)\n        return self.trie.search(self.prefix)\n\n\n\\\"\\\"\\\"\ntime:  9:00AM\nchallenge2:  Can I learn how to use setdefault in this problem.  \n\n\\\"\\\"\\\"\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = set()\n        self.words = set()\n        for word in words:\n            word_ = word[::-1]\n            for i in range(len(word)-1):\n                self.memo.add(word_[:i+1])\n            self.words.add(word_)        \n        self.hist = []\n        \n        print((self.memo))\n    \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        w = ''\n        for i in range(len(self.hist)-1,-1,-1):\n            w+=self.hist[i]\n            #print(w)\n            if w in self.words:\n                return True\n            if w not in self.memo:\n                return False\n            \n        return False\n\n", "\nclass TreeNode:\n    def __init__(self, val=0):\n        self.val = 0\n        self.children = [None] * 26\n        \nclass StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        self.root = TreeNode(0)\n        for word in words:\n            word = word[::-1]\n            current = self.root\n            for letter in word:\n                temp = current.children[ord(letter) - ord('a')]\n                if temp is None:\n                    new = TreeNode(0)\n                    current.children[ord(letter) - ord('a')] = new\n                    current = new\n                else:\n                    current = temp\n            current.val = 1\n        self.query_str = ''\n        \n    def query(self, letter: str) -> bool:\n        self.query_str = letter + self.query_str\n        return self.search()\n\n    def search(self):\n        current = self.root\n        for letter in self.query_str:\n            temp = current.children[ord(letter) - ord('a')]\n            if temp is None:\n                return False\n            else:\n                if temp.val == 1:\n                    return True\n                else:\n                    current = temp\n            \n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.child = {}\n        self.isEnd = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        self.str = []\n        \n        for word in words:\n            node = self.root\n            for ch in reversed(word):\n                if ch not in node.child:\n                    node.child[ch] = Trie()\n                node = node.child[ch]\n            node.isEnd = True\n        \n\n    def query(self, letter: str) -> bool:\n        self.str.insert(0, letter)\n        \n        node = self.root\n        for ch in self.str:\n            if ch not in node.child:\n                return False\n            node = node.child[ch]\n            if node.isEnd:\n                return True\n            \n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    \n    def __init__(self):\n        self.child={}\n        self.isword=False\n\n        \nclass Trie:\n    \n    def __init__(self):\n        self.root=Node()\n        \n    def addword(self,word):\n        node=self.root\n        for char in word:\n            if char not in node.child:\n                node.child[char]=Node()\n            node=node.child[char]\n        node.isword=True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.Trie=Trie()\n        for word in words:\n            self.Trie.addword(word[::-1])\n        self.queue=[]\n\n    def query(self, letter: str) -> bool:\n        self.queue.insert(0,letter)\n        node=self.Trie.root\n        for char in self.queue:\n            if char not in node.child:\n                return False\n            else:\n                node=node.child[char]\n                if node.isword:\n                    return True\n        return False\n                \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.node = TrieNode()\n        \n    def add(self,wordadd):\n        node = self.node\n        for char in wordadd:\n            if char not in node.child:\n                node.child[char] = TrieNode()\n            node = node.child[char]\n        node.isEnd = True\n\nclass TrieNode:\n    def __init__(self):\n        self.child = {}\n        self.isEnd = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.rootNode = Trie()\n        for word in words:\n            self.rootNode.add(word[::-1])\n            \n    def query(self, letter: str) -> bool:\n        self.letters.insert(0,letter)\n        node = self.rootNode.node\n        for letter in self.letters:\n            if node.isEnd:\n                return True\n            if letter not in node.child:\n                return False\n            node = node.child[letter]\n        return node.isEnd\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.history = collections.deque()\n        self.N = 0\n        for word in words:\n            self.N = max(self.N, len(word))\n            rword = word[::-1]\n            node = self.trie\n            for ch in rword:\n                if ch not in node:\n                    node[ch] = {}\n                node = node[ch]\n            node[\\\"#\\\"] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history.appendleft(letter)\n        if len(self.history) > self.N:\n            self.history.pop()\n        node = self.trie\n        for ch in self.history:\n            if ch not in node:\n                return False\n            node = node[ch]\n            if \\\"#\\\" in node:\n                return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.buffer = ''\n        self.letters = []\n        for word in words:\n            word = word[::-1]\n            node = self.root\n            for c in word:\n                node = node.children[c]\n            node.isEnd = True\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters)-1\n        node = self.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.letters[i] not in node.children:\n                return False\n            node = node.children[self.letters[i]]\n            i-=1\n        return node.isEnd\n    \nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.isEnd = False\n\n    \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self, val=None, children={}, is_end=False):\n        self.val = val\n        self.children = children\n        self.is_end = is_end\n\nclass StreamChecker:\n    def __add_word(self, word):\n        curr = self.root\n        #print(\\\"word\\\", word)\n        for char in word[::-1]:\n            #print(\\\"char\\\", char)\n            if char not in curr.children:\n                curr.children[char] = Node(val=char,children={},is_end=False)\n            curr = curr.children[char]\n        curr.is_end = True\n    def __init__(self, words: List[str]):\n        self.root = Node(None,{},False)\n        self.buffer = []\n        for word in words:\n            self.__add_word(word)\n    def __is_present_k(self):\n        curr = self.root\n        #print(\\\"buffer\\\", self.buffer)\n        for char in self.buffer:\n            #print(\\\"char\\\", char)\n            #print(\\\"curr children\\\", [ curr.children[temp].val for temp in curr.children] )\n            if char not in curr.children:\n                return False\n            curr = curr.children[char]\n            if curr.is_end:\n                return True\n        return False\n    def query(self, letter: str) -> bool:\n        self.buffer.insert(0,letter)\n        return self.__is_present_k()\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n  def __init__(self, words: List[str]):\n    self.s = ''\n    self.maxLen = max(len(word) for word in words)\n    \n    self.dic = defaultdict(set)\n    \n    for word in words:\n      self.dic[word[-1]].add(word)\n\n  def query(self, letter: str) -> bool:\n    self.s += letter\n    self.s = self.s[-self.maxLen:]\n    return any(self.s.endswith(w) for w in self.dic[letter])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "import collections\n\nclass Trie:\n    def __init__(self):\n        self.children = [None]*26\n        self.isEnd = False\n        \n    def add_word(self, word):\n        curr = self\n        for c in word:\n            if curr.children[ord(c) - ord('a')] == None:\n                curr.children[ord(c) - ord('a')] = Trie()\n            curr = curr.children[ord(c) - ord('a')]\n        curr.isEnd = True\n        \n    def search(self, word):\n        curr = self\n        for c in word:\n            if curr.children[ord(c) - ord('a')] == None: return False\n            curr = curr.children[ord(c) - ord('a')]\n            if curr.isEnd: return True\n        return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.trie.add_word(w[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.trie.search(self.stream)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n\n    \nclass Trie:\n    def __init__(self, ):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n\n        root.end_node = 1\n\n        \nclass StreamChecker:        \n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.stream = deque()\n        for word in words:\n            self.trie.insert(word[::-1])\n            \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        current = self.trie.root\n        \n        for char in self.stream:\n            if char in current.children:\n                current = current.children[char]\n                if current.end_node:\n                    return True\n            else:\n                break\n        \n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = {}\n        self.words = set()\n        words_ = [word[::-1] for word in words]\n        for word in words_:\n            for i in range(len(word)-1):\n                self.memo[word[:i+1]]=0\n        \n        for word in words_:\n            self.memo[word]=1\n        \n        self.hist = []\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        w = ''\n        for i in range(len(self.hist)):\n            w+=self.hist[-i-1]\n            #print(w)\n            c = self.memo.get(w,None)\n            if c is None:\n                return False\n            if c:\n                return True\n            \n        return False\n\n", "class Trie:\n    \n    def __init__(self):\n        self.endOfWord = False\n        self.children = [None]*26\n\n    def insert(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None:\n                t.children[ord(c)-ord('a')] = Trie()\n            t = t.children[ord(c)-ord('a')]\n        t.endOfWord = True\n\n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None: \n                return False\n            t = t.children[ord(c)-ord('a')]\n            if t.endOfWord: return True\n        return False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieHolder:\n    def __init__(self):\n        self.flag=0\n        self.next=[None]*26\n\nclass StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        self.root = TrieHolder()\n        for i in words:\n            self.insert(i[::-1])\n        self.searchLetters=[]\n        self.l=0\n    \n    def insert(self, word: str) -> None:\n        t=self.root\n        for i in word:\n            if t.next[ord(i)-97] == None:\n                t.next[ord(i)-97]=TrieHolder()\n            t=t.next[ord(i)-97]\n        t.flag=1\n        \n    def query(self, letter: str) -> bool:\n        self.searchLetters.append(letter)\n        self.l+=1\n        t=self.root\n        for j in range(self.l-1,-1,-1):\n            letter=self.searchLetters[j]\n            if t.next[ord(letter)-97]==None:\n                return False\n            elif t.next[ord(letter)-97].flag==1:\n                return True\n            else:\n                t=t.next[ord(letter)-97]\n        return False\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.eow = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, key):\n        pCrawl = self.root\n\n        length = len(key)\n        for i in range(length):\n            if pCrawl.children[ord(key[i])-ord('a')] is None:\n                pCrawl.children[ord(key[i])-ord('a')] = TrieNode()\n            \n            pCrawl = pCrawl.children[ord(key[i])-ord('a')]\n        \n        pCrawl.eow = True\n    \n    def search(self, key):\n        pCrawl = prev = self.root\n        length = len(key)\n        \n        for i in range(length):\n            if pCrawl.children[ord(key[i])-ord('a')] is None:\n                return False\n            prev = pCrawl\n            pCrawl = pCrawl.children[ord(key[i])-ord('a')]\n        \n        return prev.children[ord(key[i])-ord('a')].eow\n            \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for key in words:\n            self.trie.insert(key[::-1])\n        \n        self.word = ''\n        \n\n    def query(self, letter: str) -> bool:\n        self.word = letter + self.word\n        pCrawl = self.trie.root\n\n        for c in self.word:\n            if pCrawl.children[ord(c)-ord('a')] is not None:\n                if pCrawl.children[ord(c)-ord('a')].eow:\n                    return True\n                pCrawl = pCrawl.children[ord(c)-ord('a')]\n            else:\n                return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.end = \\\"*\\\"\n        self.q = deque()\n        for word in words:\n            self.insert(word[::-1])\n    \n    def insert(self, word):\n        node = self.root\n        for c in word:\n            if c not in node: node[c] = {}\n            node = node[c]\n        node[self.end] = True\n\n    def query(self, letter: str) -> bool:\n        self.q.appendleft(letter)\n        node = self.root\n        for c in self.q:\n            if self.end in node: return True\n            if c not in node: return False\n            \n            node = node[c]\n        return self.end in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.word = \\\"\\\"\n        self.kids = dict()\n        \nclass StreamChecker:\n    \n    \n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        def add(word):\n            node = self.root\n            for ch in word:\n                if not node.kids.get(ch, None):\n                    node.kids[ch] = Trie()\n                node = node.kids[ch]\n            node.word = word\n        for word in words:\n            add(word[::-1])\n        self.stream = []\n            \n\n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        node = self.root\n        for i in range(len(self.stream)-1, -1, -1):\n            ch = self.stream[i]\n            if not node.kids.get(ch, None):\n                return False\n            node = node.kids.get(ch)\n            if node.word:\n                return True\n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.Trie = {}\n        \n    def insert(self, word):\n        curr = self.Trie\n        \n        for i in word:\n            if i not in curr:\n                curr[i] = {}\n            curr = curr[i]\n        curr['#'] = 1\n    \n    def search(self, word):\n        curr = self.Trie\n        \n        for i in word:\n            if i not in curr:\n                return False\n            else:\n                if '#' in curr[i]:\n                    return True\n            curr = curr[i]\n        return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dictTree = Trie()\n        self.queryStream = list()\n        \n        for i in words:\n            self.dictTree.insert(i[::-1])\n        \n\n    def query(self, letter: str) -> bool:\n        self.queryStream[0:0] = letter\n        return self.dictTree.search (self.queryStream)\n                \n                \n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = {}\n        self.words = set()\n        for word in words:\n            word_ = word[::-1]\n            for i in range(len(word)):\n                self.memo[word_[:i+1]]=0\n            self.words.add(word_)        \n        self.hist = []\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        w = ''\n        for i in range(len(self.hist)-1,-1,-1):\n            w+=self.hist[i]\n            #print(w)\n            if w in self.words:\n                return True\n            if w not in self.memo:\n                return False\n            \n        return False\n\n", "class TrieNode:\n    \n    def __init__(self, val  =   \\\"\\\"):\n        self.val    =   val;\n        self.next_chars =   collections.defaultdict(str);\n        self.end_of_word    =   False;\n        return;\n\nclass Trie:\n    \n    def __init__(self, words):\n        self.head       =   TrieNode(\\\"head\\\");\n        self.curr_ptr   =   self.head;\n        \n        for w in words:\n            self._add_word(w);\n            \n        return;\n    \n    def check_char(self, c):\n        ptr =   self.curr_ptr;\n        \n        if c not in ptr.next_chars:\n            self.curr_ptr   =   self.head;\n            if c in self.curr_ptr.next_chars:\n                self.curr_ptr   =   self.head.next_chars[c];\n            return False;\n        \n        self.curr_ptr   =   ptr.next_chars[c];\n        return True;\n    \n    def ptr_end_of_word(self):\n        return self.curr_ptr.end_of_word;\n    \n    def _add_word(self, word):\n        \n        ptr =   self.head;\n        \n        for c in word:\n            \n            if c not in ptr.next_chars:\n                ptr.next_chars[c]   =   TrieNode(c);\n            \n            ptr =   ptr.next_chars[c];\n        \n        ptr.end_of_word =   True;\n        \n        return;\n\nMAX_LENGTH  =   2001;\n\nclass StreamChecker:\n    \n    \n    def __init__    (self, words):\n        \n        self.last_char_words    =   collections.defaultdict(set);\n        self.rolling_word       =   \\\"\\\";\n        \n        for w in words:\n            last_c  =   w[-1];\n            self.last_char_words.setdefault(last_c, set()).add(w);\n        \n        #print(self.last_char_words);\n        return;\n    \n    def query(  self, letter:str)   -> bool:\n        \n        self.rolling_word += letter;\n        \n        for w in self.last_char_words[letter]:\n            ln_w    =   len(w);\n            \n            if self.rolling_word[-ln_w:] == w:\n                return True;\n        \n        self.rolling_word   =   self.rolling_word[-MAX_LENGTH:];\n        return False;\n        \n\n    \\\"\\\"\\\"\n    def __init__(self, words: List[str]):\n        \n        self.trie_words =   Trie(words);      \n        \n\n    def query(self, letter: str) -> bool:\n        \n        ptr =   self.trie_words.curr_ptr;\n  \n        #print(letter, ptr.val, ptr.end_of_word);\n\n        \n        check_letter        =   self.trie_words.check_char(  letter);\n        check_end_of_word   =   self.trie_words.ptr_end_of_word();\n        \n        #print(  letter, check_letter,   check_end_of_word);\n        return  check_letter    and  check_end_of_word;\n\n    \\\"\\\"\\\"\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         if len(words) ==0:\n#             print(\\\"Empty list!\\\")\n#         elif len(words) > 2000:\n#             print(\\\"List is too long!\\\")\n#         max_word_len,  min_word_len = max([len(word) for word in words]), min([len(word) for word in words])\n#         if min_word_len == 0:\n#             print(\\\"Word is empty string!\\\")\n#         elif max_word_len > 2000:\n#             print(\\\"Word is too long!\\\")\n#         words_dict = {}\n#         for word in words:\n#             k = len(word)\n#             words_dict[k] = words_dict.get(k,[]) + [word]\n#         self.sorted_words = sorted(words_dict.items())\n#         self.queries = ''\n#         self.n_queries = 0\n\n#     def query(self, letter: str) -> bool:\n#         self.queries += letter\n#         self.n_queries += 1\n#         if self.n_queries > 40000:\n#             print(\\\"The number of queries is more than 40000!\\\")\n#         for k_words in self.sorted_words:\n#             k, words = k_words[0], k_words[1]\n#             s = self.queries[(self.n_queries - k):self.n_queries]\n#             for word in words:\n#                 if word == s:\n#                     return True\n#         return False\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])       \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    \n    def __init__(self):\n        self.child = {}\n        self.end = False\n    \n    def insert(self, word):\n        node = self\n        idx = 0\n        for char in word:\n            if node.child.get(char) is None:\n                node.child[char] = TrieNode()\n            node = node.child[char]\n        node.end = True\n    \n    def search(self, word):\n        node = self\n        for char in word:\n            if node.child.get(char) is None:\n                return False\n            node = node.child[char]\n            if node.end:\n                return True\n        return False\n        \n                \n        \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.maxLen = max(map(len, words))\n        self.trie = TrieNode()\n        for word in words:\n            self.trie.insert(\\\"\\\".join(list(word)[::-1]))\n        self.curQuery = ''\n\n    def query(self, letter: str) -> bool:\n        self.curQuery = letter + self.curQuery[:min(len(self.curQuery), self.maxLen - 1)]\n        return self.trie.search(self.curQuery)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Tri:\n    def __init__(self):\n        self.root = TriNode()\n        \n    def add(self, word):\n        node = self.root\n        \n        for letter in word:\n            if letter not in node.__next__:\n                 node.next[letter] = TriNode()\n               \n            node = node.next[letter]\n            \n        node.isWord = True\n        \n    def check(self, letters):\n        node = self.root\n        \n        for letter in letters:\n            if node.isWord:\n                return True\n            \n            if letter not in node.__next__:\n                return False\n            \n            node = node.next[letter]\n            \n        if node.isWord:\n            return True\n            \n        return False\n        \n            \n\nclass TriNode:\n    def __init__(self):\n        self.next = {}\n        self.isWord = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tri = Tri()\n        self.recent = []\n        self.maxLength = -1\n        self.length = 0\n        \n        for word in words:\n            if len(word) > self.maxLength:\n                maxLength = len(word)\n                \n            self.tri.add(word[::-1])\n        \n\n    def query(self, letter: str) -> bool:\n        if self.length == self.maxLength:\n            self.recent.pop()\n            self.recent.insert(0, letter)\n        else:\n            self.recent.insert(0, letter)\n            self.length += 1\n            \n        return self.tri.check(self.recent)\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.str = ''\n        self.dict_set = collections.defaultdict(set)\n        for word in words:\n            self.dict_set[word[-1]].add(word)\n        \n\n    def query(self, letter: str) -> bool:\n        self.str += letter\n        return any(self.str.endswith(word) for word in self.dict_set[letter])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        import collections\n        \n        self.trie = dict()\n        self.maxLen = 0\n        \n        for word in words:\n            node = self.trie\n            self.maxLen = max(self.maxLen, len(word))\n            for w in (word[::-1] + \\\"*\\\"):\n                if w not in node:\n                    node[w] = dict()\n                node = node[w]\n                \n        self.queue = collections.deque([], self.maxLen)\n\n    def query(self, letter: str) -> bool:\n        \n        self.queue.append(letter)\n        term = list(self.queue)\n        term = term[::-1] + [\\\"*\\\"]\n        i = 0\n        node = self.trie\n        \n        while(i<len(term)):\n            if \\\"*\\\" in node:\n                return(True)\n            elif term[i] not in node:\n                return(False)\n            else:\n                node = node[term[i]]\n                i += 1\n                \n        return(True)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.root = {}\n    \n    def insert(self,word):\n        node = self.root\n        for ch in word:\n            if ch not in node:\n                node[ch] ={}\n            node = node[ch]\n        node[\\\"$\\\"] = True\n    def search_word(self,prefix):\n        node = self.root\n        \n        for letter in prefix:\n            if letter in node:\n                node = node[letter]\n                if \\\"$\\\" in node:\n                    return True\n            else:\n                return False\n        return \\\"$\\\" in node\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n        self.cur_query = collections.deque()\n        \n\n    def query(self, letter: str) -> bool:\n        self.cur_query.appendleft(letter)\n        return self.trie.search_word(self.cur_query)\n    \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         # if len(words) ==0:\n#         #     print(\\\"Empty list!\\\")\n#         # elif len(words) > 2000:\n#         #     print(\\\"List is too long!\\\")\n#         # max_word_len,  min_word_len = max([len(word) for word in words]), min([len(word) for word in words])\n#         # if min_word_len == 0:\n#         #     print(\\\"Word is empty string!\\\")\n#         # elif max_word_len > 2000:\n#         #     print(\\\"Word is too long!\\\")\n#         words_dict = {}\n#         for word in words:\n#             k = len(word)\n#             words_dict[k] = words_dict.get(k,set())\n#             words_dict[k].add(word)\n#         self.sorted_words = sorted(words_dict.items())\n#         self.queries = ''\n#         self.n_queries = 0\n\n#     def query(self, letter: str) -> bool:\n#         self.queries += letter\n#         self.n_queries += 1\n#         # if self.n_queries > 40000:\n#         #     print(\\\"The number of queries is more than 40000!\\\")\n#         for k_words in self.sorted_words:\n#             k, words = k_words[0], k_words[1]\n#             s = self.queries[(self.n_queries - k):self.n_queries]\n#             for word in words:\n#                 if word == s:\n#                     return True\n#         return False\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])       \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.letters = \\\"\\\"\n        self.dict = collections.defaultdict(set)\n        for i in words:\n            self.dict[i[-1]].add(i)\n            \n\n    def query(self, letter: str) -> bool:\n        self.letters += letter[0]\n        return any(self.letters.endswith(word) for word in self.dict[letter])\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self, val):\n        self.val = val\n        self.branches = dict()\n    def query(self, word):\n        \\\"\\\"\\\"\n        returns true if and only if for some k >= 1, the last k characters of the string WORD is in the trie \n        \\\"\\\"\\\"\n        # print(\\\"querying\\\", word)\n        if \\\"*\\\" in self.branches:\n            # print(\\\"found word\\\")\n            return True\n        if word and word[-1] in self.branches:\n            return self.branches[word[-1]].query(word[:-1])\n        return False\n        \n    def addWord(self, word):\n        if not word:\n            self.branches[\\\"*\\\"] = TrieNode('*')\n        else:\n            next_letter = word[-1]\n            if next_letter not in self.branches:\n                self.branches[next_letter] = TrieNode(next_letter)\n            self.branches[next_letter].addWord(word[:-1])\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = TrieNode(\\\"head\\\")\n        for w in words:\n            self.trie.addWord(w)\n        self.stream = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        return self.trie.query(self.stream)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dict = collections.defaultdict(set)\n        for word in words:\n            self.dict[word[-1]].add(word)\n        \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(word) for word in self.dict[letter])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self, c: str, is_word: bool):\n        self.c = c\n        self.next_chars = {}\n        self.is_word = is_word \n    def traverse(self, c):\n        if c in self.next_chars:\n            return self.next_chars[c]\n        return None\n\n    def add(self, c, is_word):\n        if c not in self.next_chars:\n            self.next_chars[c] = Trie(c, is_word)\n        return self.next_chars[c]\n    \nclass StreamChecker:\n            \n    def __init__(self, words: List[str]):\n        self.tr = Trie(\\\"\\\", False)\n        self.iters = deque()\n        self.longest_word = 0\n        \n        for word in words:\n            self.longest_word = max(len(word), self.longest_word)\n            cur = self.tr\n            for c in word[::-1]:\n                cur = cur.add(c, False)\n            cur.is_word = True\n\n    def query(self, letter: str) -> bool:\n        self.iters.appendleft(letter)\n        if len(self.iters) > self.longest_word:\n            self.iters.pop()\n        cur = self.tr\n        for c in self.iters:\n            cur = cur.traverse(c)\n            if not cur:\n                return False\n            if cur.is_word:\n                return True\n            \n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "\nclass StreamChecker:\n    '''based on trie\n       the core idea TLE is to create the trie with words in reverse order. also create a buffer that is used durring the query\n    '''\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])", "class TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words: self.trie.insert(word[::-1])\n         \n    def query(self, letter):\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node: return True\n            else: break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n# put all our words to Trie in reversed order\n# Imagine we have a current stream abcdefghij and we have dictionary [hij, xyz, abc, hijk] Then what we need to check if some suffix of this word in our dictinonary. It means that jihgfedcba should have jih as prefix. If we add one letter to strim, so we have abcdefghijk, we need to find prefixes in kjihgfedcba and so on.\n\n# Code:\n\n# 1)Trie class with initialization and insert function. Each node has children and flag .end_node, which says if some word ends with this node.\n# 2)Put all reversed words to our Trie\n# 3)For each new element of stream, we keep it in deque, so we can easily add it to the left of our reversed stream. Then we traverse our Trie and look if we reached some end node.\n\n# Complexity: Let m be the longest length of word and n be number of words. Also let w be number of query(letter). Then space complexity is O(mn + w) to keep our tree. In fact we can cut our deque if it has length more than m, because we never reach nodes which are far in our deque. Time complexity is O(wm), because for each of w queries we need to traverse at most m letters in our trie.\n\n# Note that other method complexity I mentioned in the beginning in theory is also O(wm), but in practise it works like 10 times slower. The problem is with tests like aaaaaa...aaab.\n# see DBabichev's explanation. https://leetcode.com/problems/stream-of-characters/discuss/807541/Python-Trie-with-reversed-words-explained\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n        \n        for word in set(words):\n            node = self.trie\n            for char in reversed(word):\n                if not char in node:\n                    node[char] = {}\n                node = node[char]\n            node['!'] = word\n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for char in self.stream:\n            if '!' in node:\n                return True\n            if not char in node:\n                return False\n            node = node[char]\n        return '!' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie={}\n        self.stream=collections.deque()\n        for word in words:\n            node=self.trie\n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch]={}\n                node=node[ch]\n            node['$']=word\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node=self.trie\n        for c in self.stream:\n            if '$' in node:\n                return True\n            if not c in  node:\n                return False\n            node=node[c]\n        #print('$' in node)\n        return '$' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.queried_word = \\\"\\\"\n        self.dict_sets = defaultdict(lambda: set())\n        for word in words:\n            self.dict_sets[word[-1]].add(word)\n\n    def query(self, letter: str) -> bool:\n        self.queried_word += letter\n        for word in self.dict_sets[letter]:\n            if word == self.queried_word[-len(word):]:\n                return True\n        return False", "class Trie:\n    #GOOGLE, FB\n    #Am I checking for \\\"cd\\\" or \\\"dc\\\" as well in [\\\"cd\\\",\\\"f\\\",\\\"kl\\\"] ?\n    def __init__(self):\n        self.endOfWord = None\n        self.children = [None]*26\n    \n    def insert(self, s):\n        t = self #!!!!!!!!!!!!!!!!!!\n        for c in s:\n            if t.children[ord(c) - ord('a')] == None:\n                t.children[ord(c) - ord('a')] = Trie()\n            t = t.children[ord(c)-ord('a')]\n        t.endOfWord = True\n        \n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c) - ord('a')] == None: return False\n            t = t.children[ord(c) - ord('a')]\n            if t.endOfWord: return True\n        return False\n\n    \nclass StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n    \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.val = -1\n\nclass Trie:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n\n        current = self.root\n        for char in word:\n            current = current.children[char]\n\n        current.val = 10\n    def search(self, word):\n        current = self.root\n        for char in word:\n            current = current.children.get(char)\n            if not current:\n                return False\n        return current.val > 1\n    def starts_with(self, word):\n        current = self.root\n        for char in word:\n            current = current.children.get(char)\n            if not current:\n                return False\n        return True\n    \n\nclass StreamChecker:\n\n    # O(NW) where N is number of words\n    # Q is maxlength of word\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.letters = []\n        for word in words:\n            # insert in reverse order to check for Trie keys as soon as new node is added\n            self.trie.insert(word[::-1])\n\n    #waiting.size <= W, where W is the maximum length of words.\n    # So that O(query) = O(waiting.size) = O(W)\n    # for q queries, O(QW)\n    def query(self, letter: str) -> bool:\n        self.letters += letter\n        i = len(self.letters) - 1\n        node = self.trie.root\n        curr_word = ''\n        for i in range(len(self.letters) - 1, -1, -1):\n            curr_word += self.letters[i]\n            has_sub_word = self.trie.starts_with(curr_word)\n            if not has_sub_word:\n                return False\n            if has_sub_word and self.trie.search(curr_word):\n                return True\n        return False\n#         while i >= 0:\n#             # if any of the word matches return True\n#             if node.val > 1:\n#                 return True\n#             if self.letters[i] not in node.children:\n#                 return False\n#             node = node.children[self.letters[i]]\n#             i -= 1\n        \n#         return node.val > 1\n    \n\n", "\nclass Node:\n    def __init__(self, end=False):\n        self.end = end\n        self.children = [None] * 26\n        \n    def search(self, word):\n        curr = self\n        for w in word:\n            slot = ord(w) - ord('a')\n            if curr.children[slot]:\n                curr = curr.children[slot]\n                if curr.end:\n                    return True\n            else:\n                return False\n        return curr.end\n\nclass StreamChecker:\n            \n    def __init__(self, words: List[str]):\n        self.letters = ''\n        self.root = Node('')\n        def add(node, word):\n            for w in word:\n                slot = ord(w) - ord('a')\n                if node.children[slot] is None:\n                    node.children[slot] = Node()\n                node = node.children[slot]\n            node.end = True\n                \n        for word in words:\n            add(self.root, word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.letters = letter + self.letters\n        return self.root.search(self.letters)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self, char):\n        self.node = char\n        self.children = {}\n        self.end_word = False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = TrieNode('*')\n        for word in words:\n            curr_node = self.trie\n            for char in word[::-1]:\n                node = curr_node.children.get(char, TrieNode(char))\n                curr_node.children[char] = node\n                curr_node = node\n            curr_node.end_word = True\n        self.queried = ''\n    \n    def exists(self, word):\n        #dc\n        curr_node = self.trie\n        for char in word:\n            if char not in curr_node.children:\n                return False\n            curr_node = curr_node.children[char]\n            if curr_node.end_word:\n                return True\n        if curr_node.end_word:\n            return True\n        return False\n\n    def query(self, letter: str) -> bool:\n        root = self.trie\n        self.queried = letter + self.queried\n        if self.exists(self.queried):\n            return True\n        return False\n        \n'''\n * (d->c->e, f, l->k)\n\n\n[a,b,c,]\n\n\n1. checking the actual problem\n2. checking the trie\n'''        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self, char):\n        self.char = char\n        self.accept = False\n        self.children = {}\n\nclass StreamNode:\n    def __init__(self, char):\n        self.char = char\n        self.next = None\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.maxlen = 0\n        self.trie = TrieNode(\\\"\\\")\n        i = 0\n        should_continue = True\n        for j in range(len(words)):\n            word = words[j]\n            self.maxlen = max(len(word), self.maxlen)\n            p = self.trie\n            for i in range(len(word)-1,-1,-1):\n                c = word[i]\n                if c not in p.children:\n                    p.children[c] = TrieNode(c)\n                p = p.children[c]\n                p.accept = p.accept or (i == 0)\n        self.stream = None\n\n    def query(self, letter: str) -> bool:\n        s = StreamNode(letter)\n        s.next = self.stream\n        self.stream = s\n        p = self.trie\n        i = 0\n        accept = False\n        while s != None and i < self.maxlen:\n            if s.char not in p.children:\n                return False\n            p = p.children[s.char]\n            if p.accept:\n                return True\n            s = s.next\n            i += 1\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = {}\n        self.words = set()\n        words_ = [word[::-1] for word in words]\n        for word in words_:\n            for i in range(len(word)-1):\n                self.memo[word[:i+1]]=0\n        \n        self.max_len = 0\n        for word in words_:\n            self.memo[word]=1\n        \n        self.hist = []\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        w = ''\n        for i in range(len(self.hist)-1,-1,-1):\n            w+=self.hist[i]\n            #print(w)\n            c = self.memo.get(w,None)\n            if c is None:\n                return False\n            if c:\n                return True\n            \n        return False\n\n", "class Trie:\n    \n    def __init__(self):\n        self.endOfWord = False\n        self.children = [None]*26\n\n    def insert(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None:\n                t.children[ord(c)-ord('a')] = Trie()\n            t = t.children[ord(c)-ord('a')]\n        t.endOfWord = True\n\n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None: return False\n            t = t.children[ord(c)-ord('a')]\n            if t.endOfWord: return True\n        return False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n        \n", "# 1032. Stream of Characters\n\n# class TrieNode:\n#     def __init__(self, val=None, isEnd=False):\n#         self.val = val\n#         self.isEnd = isEnd\n#         self.next = {}\n\n# Solution 4: Construct Trie with Reversed Words\n# Time: 600 ~ 700ms, Time complexity: O(WQ)\n\nimport functools \n\nclass StreamChecker:\n    \n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: \n            functools.reduce(dict.__getitem__, w[::-1], self.trie)['#'] = True\n            # print(self.trie)\n        self.S = \\\"\\\"\n        self.W = max(map(len, words))\n\n    def query(self, letter):\n        self.S = (letter + self.S)[:self.W]\n        cur = self.trie\n        for c in self.S:\n            if c in cur:\n                cur = cur[c]\n                if cur['#'] == True:\n                    return True\n            else:\n                break\n        return False\n\n# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         self.trie = {}\n#         self.stream = deque([])\n\n#         for word in set(words):\n#             node = self.trie       \n#             for ch in word[::-1]:\n#                 if not ch in node:\n#                     node[ch] = {}\n#                 node = node[ch]\n#             node['$'] = word\n        \n        \n#     def query(self, letter: str) -> bool:\n#         self.stream.appendleft(letter)\n        \n#         node = self.trie\n#         for ch in self.stream:\n#             if '$' in node:\n#                 return True\n#             if not ch in node:\n#                 return False\n#             node = node[ch]\n#         return '$' in node\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isLeaf = False\n        \n    def add(self, word) -> None:\n        if not word:\n            return\n        first = word[0]\n        if first not in self.children:\n            self.children[first] = TrieNode()\n        if len(word) == 1:\n            self.children[first].isLeaf = True\n        self.children[first].add(word[1:])\n        \n    def search(self, word) -> bool:\n        if not word:\n            return self.isLeaf   \n        first = word[0]\n        if first not in self.children:\n            return False\n        return self.children[first].search(word[1:])\n    \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trieRoot = TrieNode()\n        for word in words:\n            self.trieRoot.add(word[::-1])\n        self.stream = []\n        \n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        node = self.trieRoot\n        for ch in reversed(self.stream):\n            if ch in node.children:\n                node = node.children[ch]\n                if node.isLeaf:\n                    return True\n            else:\n                break\n                \n        return False\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie={}\n        self.searchWord=''\n        for word in words:\n            word=word[::-1]\n            self.insertToTrie(self.trie, word)\n            \n    def insertToTrie(self, trie, word):\n        if word[0] not in trie:\n            trie[word[0]] = {\\\"value\\\":{}, \\\"isLast\\\":len(word)==1}\n        if len(word)==1:\n            trie[word[0]][\\\"isLast\\\"] = True\n            return\n        self.insertToTrie(trie[word[0]][\\\"value\\\"], word[1:])\n            \n    def searchForWord(self, trie, word):\n        if not word or word[0] not in trie:\n            return False\n        if trie[word[0]][\\\"isLast\\\"]:\n            return True\n        return self.searchForWord(trie[word[0]][\\\"value\\\"], word[1:])\n\n    def query(self, letter: str) -> bool:\n        self.searchWord = letter + self.searchWord\n        result = self.searchForWord(self.trie, self.searchWord)\n        return result\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node :\n    def __init__(self) :\n        self.child = [None] * 26\n        self.w = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        for w in words :\n            p = self.root\n            for ch in w[::-1] :\n                k = ord(ch) - ord('a')\n                if not p.child[k] :\n                    p.child[k] = Node()\n                p = p.child[k]\n            p.w = True\n        \n        self.q = []\n\n    def query(self, letter: str) -> bool:\n        self.q.append(letter)\n        p = self.root\n        for i in range(len(self.q)-1, -1, -1):\n            k = ord(self.q[i]) - ord('a')\n            if not p.child[k] :\n                return False\n            p = p.child[k]\n            if p.w :\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie={}\n        \n        for word in set(words):\n            node=self.trie\n            for c in word[::-1]:\n                node=node.setdefault(c,{})\n            node['$']=word\n        self.nodelist=[]\n    def query(self, letter: str) -> bool:\n        self.nodelist.insert(0,letter)\n    \n        node = self.trie\n        for ch in self.nodelist:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.isEnd = False\n    \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = []\n        self.root = TrieNode()\n        for w in words:\n            # self.insert(self.root,w)\n            node = self.root\n            for i in range(len(w)-1,-1,-1):\n                idx = ord(w[i]) - ord('a')\n                if not node.children[idx]:\n                    node.children[idx] = TrieNode()\n                node = node.children[idx]\n            node.isEnd = True\n        \n\n    def query(self, letter: str) -> bool:\n        self.s.append(letter)\n        node = self.root\n        for i in range(len(self.s)-1,-1,-1):\n            idx = ord(self.s[i]) - ord('a')\n            node = node.children[idx]  \n            if node != None and node.isEnd:\n                return True\n            if node == None:\n                return False\n              \n        # print(self.root.children)\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.end = False\n\nclass StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        for word in words:\n            node = self.root\n            for ch in word[::-1]:\n                ind = ord(ch) - ord('a')\n                if node.children[ind] is None:\n                    node.children[ind] = TrieNode()\n                node = node.children[ind]\n            node.end = True\n        self.hist = ''\n\n    def query(self, letter: str) -> bool:\n        self.hist = letter + self.hist\n        node = self.root\n        for ch in self.hist:\n            ind = ord(ch) - ord('a')\n            if node.children[ind] is None:\n                return False\n            node = node.children[ind]\n            if node.end:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    letter_queue = \\\"\\\"\n    def __init__(self, words: List[str]):\n        self.words_dict = {}\n        for w in words:\n            if w[-1] in self.words_dict:\n                self.words_dict[w[-1]].add(w)\n            else:\n                self.words_dict[w[-1]] = set()\n                self.words_dict[w[-1]].add(w)\n        \n    def query(self, letter: str) -> bool:\n        self.letter_queue += letter\n        if letter in self.words_dict:\n            for item in self.words_dict[letter]:\n                if item == self.letter_queue[-len(item):]: return True\n     \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.terminal = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.history = []\n        for word in words:\n            node = self.root\n            for char in word[::-1]:\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.terminal = True\n        \n        \n    def query(self, letter: str) -> bool:\n        self.history.append(letter)\n        node = self.root\n        for i in reversed(list(range(len(self.history)))):\n            if self.history[i] in node.children:\n                node = node.children[self.history[i]]\n                if node.terminal: return True\n            else:\n                return False\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    class Trie:\n        def __init__(self):\n            self.next = {}\n            self.ending = False\n            \n        def add(self,s):\n            if s != \\\"\\\":\n                if s[0] not in self.next:\n                    self.next[s[0]] = StreamChecker.Trie()\n                self.next[s[0]].add(s[1:])\n            else:\n                self.ending = True\n                \n        def __contains__(self,s):\n            if self.ending:\n                return True\n            elif s == \\\"\\\":\n                return False\n            elif s[-1] in self.next:\n                return self.next[s[-1]].__contains__(s[:len(s)-1])\n            else:\n                return False\n            \n    def __init__(self, words: List[str]):\n        self.words = self.Trie()\n        for w in words: self.words.add(w[::-1])\n        self.q = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.q += letter\n        return self.q in self.words\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n\n    def __init__(self):\n        self.edges = {}\n        \n    def hasEdge(self, edge):\n        return edge in self.edges\n    \n    def getEdge(self, edge):\n        return self.edges[edge]\n    \n    def addEdge(self, edge):\n        if not self.hasEdge(edge):\n            self.edges[edge] = Node()\n    \n    def isEnd(self):\n        return \\\"*\\\" in self.edges\n    \nclass Trie:\n    \n    def __init__(self):\n        self.root = Node()\n    \n    def addWord(self, word):\n        node = self.root\n        \n        for c in word:\n            if not node.hasEdge(c):\n                node.addEdge(c)   \n            node = node.getEdge(c)\n            \n        node.addEdge(\\\"*\\\")\n        \n    def search(self, stream):\n        node = self.root\n        \n        for c in stream:\n            if not node.hasEdge(c):\n                return False\n            \n            node = node.getEdge(c)\n            \n            if node.hasEdge(\\\"*\\\"):\n                return True\n        \n        return False\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.stream = collections.deque()\n        \n        for word in words:\n            self.trie.addWord(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.trie.search(self.stream)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.max_len = max((len(x) for x in self.words), default=0)\n        self.q = ''\n        self.num_end = min(1, self.max_len)\n        self.ends = {}\n        for i in range(1, self.num_end + 1):\n            self.ends[i] = set(x[-i:] for x in self.words if len(x) >= i)\n        # print(self.ends)\n        \n\n    def query(self, letter: str) -> bool:\n        self.q += letter\n        if len(self.q) > self.max_len:\n            self.q = self.q[1:]\n        for i in range(1, self.num_end + 1):\n            # print(i, self.q[-i:])\n            if self.q[-i:] not in self.ends[i]:\n                return False\n        # print('cont', i, self.q)\n        for i in range(0, self.max_len):\n            # print(~i, self.q[~i:])\n            if self.q[~i:] in self.words:\n                # print(self.q[~i:])\n                return True\n        return False\n        \n\n# Standard solution for string match is Trie.\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words:\n            reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)        \n\n\n# more readable Trie\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        self.trie = {}\n        self.query_letters = []        \n        for word in words:\n            node = self.trie\n            for c in reversed(word):\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['END'] = True\n            \n    def query(self, letter):\n        self.query_letters.append(letter)\n        node = self.trie\n        for c in reversed(self.query_letters):\n            if c in node:\n                node = node[c]\n                if 'END' in node:\n                    return True\n            else:\n                return False\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import deque\n\nclass TrieNode:\n    def __init__(self, val):\n        # self.val = val\n        self.end = False\n        self.children = {}\n        \nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode(-1)\n    \n    def add(self, word):\n        root = self.root\n        for idx, ch in enumerate(word):\n            children = root.children\n            if children.get(ch) == None:\n                child = TrieNode(ch)\n                children[ch] = child\n                root = child\n            else:\n                root = children[ch]\n                \n            if idx == len(word)-1:\n                root.end = True\n    \n    def search(self, word):\n\n        root = self.root\n        for idx, val in enumerate(word):\n            if root.children.get(val) == None:\n                return False\n            else:\n                root = root.children[val]\n                if root.end:\n                    return True\n            # if idx == len(word)-1 and root.end:\n            #     return True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # self.words = set(words)\n        self.Trie = Trie()\n        self.maxlen = -1\n        for w in words:\n            # add word to Trie\n            self.maxlen = max(self.maxlen, len(w))\n            rev = w[::-1]\n            self.Trie.add(rev)\n        self.searchArr = deque()\n        \n\n    def query(self, letter: str) -> bool:\n\n        self.searchArr.insert(0, letter)\n        if len(self.searchArr) > self.maxlen:\n            self.searchArr.pop()\n\n        tmpWord = \\\"\\\".join(self.searchArr)    \n        if self.Trie.search(tmpWord):\n            return True        \n\n        return False    \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import deque\n\nclass TrieNode:\n    def __init__(self, val):\n        self.end = False\n        self.children = {}\n        \nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode(-1)\n    \n    def add(self, word):\n        root = self.root\n        for ch in word:\n            children = root.children\n            if children.get(ch) == None:\n                child = TrieNode(ch)\n                children[ch] = child\n                root = child\n            else:\n                root = children[ch]\n\n        root.end = True\n    \n    def search(self, word):\n\n        root = self.root\n        for idx, val in enumerate(word):\n            if root.children.get(val) == None:\n                return False\n            else:\n                root = root.children[val]\n                if root.end:\n                    return True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # self.words = set(words)\n        self.Trie = Trie()\n        self.maxlen = -1\n        for w in words:\n            self.maxlen = max(self.maxlen, len(w))\n            rev = w[::-1]\n            self.Trie.add(rev)\n        self.searchArr = deque()\n        \n\n    def query(self, letter: str) -> bool:\n\n        self.searchArr.insert(0, letter)\n        if len(self.searchArr) > self.maxlen:\n            self.searchArr.pop()\n\n        tmpWord = \\\"\\\".join(self.searchArr)    \n        return self.Trie.search(tmpWord)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.endofword = False\n        self.children = [None] * 26\n        \n    def insert(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c) - ord('a')] == None:\n                t.children[ord(c) - ord('a')] = Trie()\n            t = t.children[ord(c) - ord('a')]\n        t.endofword = True\n\n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None: return False\n            t = t.children[ord(c)-ord('a')]\n            if t.endofword == True: return True\n        return False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        \n        for w in words:\n            self.t.insert(reversed(w))\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TNode(object):\n    def __init__(self):\n        self.d,self.f = {}, False\nclass StreamChecker(object):\n    def __init__(self, words):\n        self.root = TNode()\n        self.max_ = max(map(len, words))\n        for w in words:\n            cur = self.root\n            for j in range(len(w)-1,-1,-1):\n                if w[j] not in cur.d: cur.d[w[j]] = TNode()\n                cur = cur.d[w[j]]\n            cur.f = True\n        self.q = collections.deque([])        \n\n    def query(self, letter):\n        self.q.appendleft(letter)\n        if len(self.q) > self.max_: self.q.pop()\n        cur= self.root\n        for l in self.q:\n            if l not in cur.d: return False\n            cur = cur.d[l]\n            if cur.f:\n                return True\n        return False", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.end = 0\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self,word):\n        root = self.root\n        for char in word:\n            root = root.children.setdefault(char,TrieNode())\n        root.end=1\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.Trie = Trie()\n        self.QueryBuffer = deque()\n        for word in words:\n            self.Trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.QueryBuffer.appendleft(letter)\n        cur = self.Trie.root\n        for char in self.QueryBuffer:\n            if char in cur.children:\n                cur = cur.children[char]\n                if cur.end==1:\n                    return True\n            else:\n                break\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.isEnd = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = self.getNode()\n        for word in words:\n            self.addWord(word[::-1])\n        self.currStr = deque([])\n    \n    def addWord(self, word):\n        node = self.root\n        for c in word:\n            ind = self.getInd(c)\n            if node.children[ind] == None:\n                node.children[ind] = self.getNode()\n            node = node.children[ind]\n        node.isEnd = True\n        \n    def getInd(self, c):\n        return ord(c)-ord('a')\n    \n    def getNode(self):\n        return TrieNode()\n    \n    def findWord(self, letter):\n        self.currStr.appendleft(letter)\n        \n        node = self.root\n        for ch in self.currStr:\n            ind = self.getInd(ch)\n            if node.children[ind] == None:\n                return False\n            elif node.children[ind].isEnd:\n                return True\n            node = node.children[ind]\n        \n        return node and node.isEnd\n            \n    \n    def query(self, letter: str) -> bool:\n        return self.findWord(letter)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "#Approach: Insert reversed words to the Trie. Also use a deque to store current stream, that way you know you're looking at the last character every time you get a new letter in the stream.\n\nclass TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.isEnd = False\n        \nclass StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        self.root = self.getNode()\n        self.currStr = deque([])\n        for word in words:\n            self.addWord(word[::-1])\n        \n    def getNode(self):\n        return TrieNode()\n    \n    def getInd(self, c):\n        return ord(c) - ord('a')\n    \n    def addWord(self, word):\n        node = self.root\n        for ch in word:\n            ind = self.getInd(ch)\n            if node.children[ind] == None:\n                node.children[ind] = self.getNode()\n            node = node.children[ind]\n        node.isEnd = True\n\n    def query(self, letter: str) -> bool:\n        self.currStr.appendleft(letter)\n        \n        node = self.root\n        for ch in self.currStr:\n            ind = self.getInd(ch)\n            if node.children[ind] == None:\n                return False\n            elif node.children[ind].isEnd:\n                return True\n            node = node.children[ind]\n        return node and node.isEnd\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.end_word=False\n        self.letters=[None]*26 #as there are 26 alphabets\n        \n    def insert(self, s):\n        t=self\n        for c in s:\n            if t.letters[ord(c)-ord('a')]==None:\n                t.letters[ord(c)-ord('a')]=Trie()\n            t=t.letters[ord(c)-ord('a')]\n        t.end_word=True\n        \n    def search(self, s):\n        t=self\n        for c in s:\n            if t.letters[ord(c)-ord('a')]==None: return False\n            t=t.letters[ord(c)-ord('a')]\n            if t.end_word: return True\n        return False\n\n\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t=Trie()\n        self.stream=collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "# 1032. Stream of Characters\n\n# class TrieNode:\n#     def __init__(self, val=None, isEnd=False):\n#         self.val = val\n#         self.isEnd = isEnd\n#         self.next = {}\n\n# Solution 4: Construct Trie with Reversed Words\n# Time: 600 ~ 700ms\n# Time complexity: O(WQ)\n\n# Python\nclass StreamChecker:\n    \n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w[::-1], self.trie)['#'] = True\n        self.S = \\\"\\\"\n        self.W = max(map(len, words))\n\n    def query(self, letter):\n        self.S = (letter + self.S)[:self.W]\n        cur = self.trie\n        for c in self.S:\n            if c in cur:\n                cur = cur[c]\n                if cur['#'] == True:\n                    return True\n            else:\n                break\n        return False\n\n# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         self.trie = {}\n#         self.stream = deque([])\n\n#         for word in set(words):\n#             node = self.trie       \n#             for ch in word[::-1]:\n#                 if not ch in node:\n#                     node[ch] = {}\n#                 node = node[ch]\n#             node['$'] = word\n        \n        \n#     def query(self, letter: str) -> bool:\n#         self.stream.appendleft(letter)\n        \n#         node = self.trie\n#         for ch in self.stream:\n#             if '$' in node:\n#                 return True\n#             if not ch in node:\n#                 return False\n#             node = node[ch]\n#         return '$' in node\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEndOfWord = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = self.getNode()\n        \n    def getNode(self):\n        return TrieNode()\n    \n    def charToIndex(self, c):\n        return ord('a') - ord(c)\n    \n    def insert(self, word):\n        start = self.root\n        n = len(word)\n        for i in range(n):\n            idx = self.charToIndex(word[i])\n            if not start.children[idx]:\n                start.children[idx] = TrieNode()\n            start = start.children[idx]\n        start.isEndOfWord = True\n    \n    def search(self, word):\n        start = self.root\n        n = len(word)\n        for i in range(n):\n            idx = self.charToIndex(word[i])\n            if start.children[idx] == None:\n                return False\n            start = start.children[idx]\n            if start.isEndOfWord:\n                return True\n        return False\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        for word in words:\n            self.t.insert(word[::-1])\n        self.stream = collections.deque()\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n        \n            \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self, letter):\n        self.next_letters = dict()\n        self.letter = letter\n        self.is_end_word = False\n    def add_word(self, word, idx):\n        if idx == -1:\n            self.is_end_word = True\n            return\n        if word[idx] not in self.next_letters:\n            self.next_letters[word[idx]] = Trie(word[idx])\n        self.next_letters[word[idx]].add_word(word, idx-1)\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie('')\n        for w in words:\n            self.trie.add_word(w, len(w)-1)\n        self.history = list()\n\n    def query(self, letter: str) -> bool:\n        self.history.append(letter)\n        cur_node = self.trie\n        idx = len(self.history) - 1\n        while idx >= 0 and self.history[idx] in cur_node.next_letters:\n            c = self.history[idx]\n            cur_node = cur_node.next_letters[c]\n            if cur_node.is_end_word:\n                return True\n            idx -= 1\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tab = collections.defaultdict(set)\n        for w in words:\n            self.tab[w[-1]].add(w[::-1])\n            \n        self.queried = ''\n        \n\n    def query(self, letter: str) -> bool:\n        self.queried = letter + self.queried\n        if letter not in self.tab:\n            return False\n        candidates = self.tab[letter]\n        for can in candidates:\n            if can == self.queried[:len(can)]:\n                return True\n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self, is_leaf):\n        \\\"\\\"\\\"\n        { element : {val : 1, is_end: False}]}\n\n       \\\"\\\"\\\"\n        self.is_leaf = is_leaf\n        self.child = {}\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # print(\\\"its here\\\")\n        self.trie = {}\n        self.max_length = 0\n        self.word = \\\"\\\"\n        for word in words:\n            self.max_length = len(word) if len(word) > self.max_length else self.max_length\n            self.insert_word(word)\n\n    def query(self, letter: str) -> bool:\n        self.word += letter\n        self.word = self.word[-self.max_length:] if len(self.word) > self.max_length else self.word\n        ans = self.search_word()\n        return ans\n\n    def insert_word(self, word):\n        head = self.trie\n        for i in range(len(word) - 1, -1, -1):\n            if word[i] not in head:\n                t = Trie(True) if i == 0 else Trie(False)\n                head[word[i]] = t\n                head = t.child\n            else:\n                node = head.get(word[i])\n                if i == 0:\n                    node.is_leaf = True\n                head = node.child\n                \n                # print(head)\n\n                \n    def search_word(self):\n        # print(\\\"searching \\\", self.word)\n        head = self.trie\n        # print(head)\n        node = None\n        for i in range(len(self.word) - 1, -1, -1):\n            # print(\\\"letter \\\", self.word[i])\n            if self.word[i] in head:\n                node = head.get(self.word[i])\n                head = node.child\n                if node.is_leaf:\n                    return True\n            else:\n                return False\n        return node.is_leaf\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.dic = collections.defaultdict(set)\n        self.s = ''\n        for w in words:\n            self.dic[w[-1]].add(w)\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.s_list = []\n        self.word_len = 0\n        for w in words:\n            tmp = self.trie\n            for c in w[::-1]:\n                tmp = tmp.setdefault(c, {})\n            tmp['#'] = True\n            self.word_len = max(self.word_len, len(w))\n\n    def query(self, letter: str) -> bool:\n        self.s_list += letter,\n        self.s_list = self.s_list[-self.word_len:]\n        curr = self.trie\n        for c in self.s_list[::-1]:\n            if c in curr:\n                curr = curr[c]\n                if curr.get('#', False):\n                    return True\n            else:\n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "import collections\n\nclass Trie:\n    \n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n        \n    def insert(self, s):\n        root = self\n        for c in s:\n            if root.children[ord(c) - ord('a')] is None:\n                root.children[ord(c) - ord('a')] = Trie()\n            root = root.children[ord(c) - ord('a')]\n        root.is_end = True      \n        \n    def search(self, s):\n        root = self\n        for c in s:\n            if root.children[ord(c) - ord('a')] is None:\n                return False\n            root = root.children[ord(c) - ord('a')] \n            if root.is_end:\n                return True\n        return False\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.root.insert(reversed(w))        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.root.search(self.stream)\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words: self.trie.insert(word[::-1])\n         \n    def query(self, letter):\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node: return True\n            else: break\n        return False\n", "from collections import deque\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.max_word_len = 0\n        for word in words:\n            node = self.trie\n            for i in reversed(list(range(len(word)))):\n                if word[i] not in node:\n                    node[word[i]] = {}\n                node = node[word[i]]\n            node[True] = True\n            self.max_word_len = max(self.max_word_len, len(word))\n        self.queue = deque()\n            \n\n            \n    def query(self, letter: str) -> bool:\n        self.queue.appendleft(letter)\n        if len(self.queue) > self.max_word_len:\n            self.queue.pop()\n            \n        node = self.trie\n        for char in self.queue:\n            if True in node:\n                return True\n            if char not in node:\n                return False\n            node = node[char]\n        return True in node\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.end_node = 0\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n\n        \nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words:\n            self.trie.insert(word[::-1])\n         \n    def query(self, letter):\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        \n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node:\n                    return True\n            else:\n                break\n        return False", "class StreamChecker:\n    class Trie:\n        def __init__(self):\n            self.next = {}\n            self.ending = False\n            \n        def add(self,s):\n            if s != \\\"\\\":\n                if s[-1] not in self.next:\n                    self.next[s[-1]] = StreamChecker.Trie()\n                self.next[s[-1]].add(s[:len(s)-1])\n            else:\n                self.ending = True\n                \n        def __contains__(self,s):\n            if self.ending:\n                return True\n            elif s == \\\"\\\":\n                return False\n            elif s[-1] in self.next:\n                return self.next[s[-1]].__contains__(s[:len(s)-1])\n            else:\n                return False\n            \n    def __init__(self, words: List[str]):\n        self.words = self.Trie()\n        for w in words: self.words.add(w)\n        self.q = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.q += letter\n        return self.q in self.words\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import deque\n\nclass TrieNode:\n    def __init__(self, val):\n        # self.val = val\n        self.end = False\n        self.children = {}\n        \nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode(-1)\n    \n    def add(self, word):\n        root = self.root\n        for idx, ch in enumerate(word):\n            children = root.children\n            if children.get(ch) == None:\n                child = TrieNode(ch)\n                children[ch] = child\n                root = child\n            else:\n                root = children[ch]\n                \n            if idx == len(word)-1:\n                root.end = True\n    \n    def search(self, word):\n\n        root = self.root\n        for idx, val in enumerate(word):\n            if root.children.get(val) == None:\n                return False\n            else:\n                root = root.children[val]\n                if root.end:\n                    return True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # self.words = set(words)\n        self.Trie = Trie()\n        self.maxlen = -1\n        for w in words:\n            self.maxlen = max(self.maxlen, len(w))\n            rev = w[::-1]\n            self.Trie.add(rev)\n        self.searchArr = deque()\n        \n\n    def query(self, letter: str) -> bool:\n\n        self.searchArr.insert(0, letter)\n        if len(self.searchArr) > self.maxlen:\n            self.searchArr.pop()\n\n        tmpWord = \\\"\\\".join(self.searchArr)    \n        return self.Trie.search(tmpWord)\n#             return True        \n\n#         return False    \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class node:\n    def __init__(self):\n        self.children = {}\n        self.end = 0\n        \nclass Trie:\n    def __init__(self):\n        self.root = node()\n        \n    def insert(self, w):\n        r = self.root\n        for l in w:\n            r = r.children.setdefault(l, node())\n        r.end = 1\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.s = deque()\n        for w in words: self.trie.insert(w[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.s.appendleft(letter)\n        cur = self.trie.root\n        for c in self.s:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end: return True \n            else: break\n        return False\n", "class TrieNode:\n    def __init__(self):\n        self.edges={}\n    \n    def get_edge(self,edge):\n        return self.edges[edge]\n    \n    def add_edge(self,edge):\n        if not self.has_edge(edge):\n            self.edges[edge]=TrieNode()\n            \n    def has_edge(self,edge):\n        return edge in self.edges\n    \n    def isWord(self):\n        return \\\"$\\\" in self.edges\n    \nclass Trie:\n    \n    def __init__(self):\n        self.root=TrieNode()\n        \n    def insert(self,word):\n        cur=self.root\n        for c in word:\n            cur.add_edge(c)\n            cur=cur.get_edge(c)\n        cur.add_edge(\\\"$\\\")\n        \n    def search(self, word):\n        cur=self.root\n        for c in word:\n            if cur.isWord():\n                return True\n            if not cur.has_edge(c):\n                return False\n            cur=cur.get_edge(c)\n        return cur.isWord()\nfrom collections import deque\nclass StreamChecker:\n    def __init__(self, W):\n        self.prefix=deque()\n        self.trie=Trie()\n        for w in W:\n            self.trie.insert(w[::-1])\n\n    def query(self, c):\n        self.prefix.appendleft(c)\n        return self.trie.search(self.prefix)\n\n\n\\\"\\\"\\\"\ntime:  9:00AM\nTry defaultdict as well \n\n\\\"\\\"\\\"\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self, char):\n        self.char = char\n        self.nxts = {}\n        self.end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = Node('')\n    \n    def _add(self, node, word):\n        if word == '':\n            node.end = True\n            return\n        if word[0] not in node.nxts:\n            node.nxts[word[0]] = Node(word[0])\n        self._add(node.nxts[word[0]], word[1:])\n\n    def add(self, word):\n        self._add(self.root, word)\n        \n    def _search(self, node, word):\n        if node.end is True:\n            return True\n        if word == '':\n            return node.end is True\n        if word[0] in node.nxts:\n            return self._search(node.nxts[word[0]], word[1:])\n        return False\n\n    def search(self, word):\n        return self._search(self.root, word)\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for w in words:\n            self.trie.add(w[::-1])\n        self.sofar = ''\n\n    def query(self, letter: str) -> bool:\n        self.sofar = letter + self.sofar\n        # print(self.sofar)\n        return self.trie.search(self.sofar)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.fin = ''\n        self.children = {}\n\n    def add(self,s,i=0):\n        if i==len(s):\n            self.fin=s\n            return\n        if s[i] not in self.children:\n            self.children[s[i]] = TrieNode()                    \n        self.children[s[i]].add(s,i+1)\n\n    def get(self,c):\n        result = self.children.get(c,None)\n        return result\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        for w in words:\n            self.root.add(w[::-1])\n        self.hist=[]\n        \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        node = self.root\n        for l in reversed(self.hist):\n            node = node.get(l)\n            if node is None:\n                return False\n            if node.fin:\n                return True\n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.add(word[::-1])\n        self.sb = []\n\n    def query(self, letter: str) -> bool:\n        self.sb.append(letter)\n        i = len(self.sb)-1\n        node = self.trie\n        while i >= 0:\n            if node.is_word:\n                return True\n            if self.sb[i] in node.words:\n                node = node.words[self.sb[i]]\n                i -= 1\n            else:\n                return False\n        return node.is_word    \n            \n\nclass Trie:\n    def __init__(self):\n        self.is_word = False\n        self.prefix = ''\n        self.words = {}\n    \n    def add(self, word):\n        if not word:\n            self.is_word = True\n            return\n        if word[0] in self.words:\n            self.words[word[0]].add(word[1:])\n        else:\n            n = Trie()\n            n.prefix = self.prefix + word[0]\n            self.words[word[0]] = n\n            self.words[word[0]].add(word[1:])\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.prefix = {}\n        self.maxlen = 0\n        for word in words:\n            for i in range(len(word)-1, -1, -1):\n                if word[i:][::-1] not in self.prefix:\n                    self.prefix[word[i:][::-1]] = 0\n            self.prefix[word[::-1]] = 1\n            self.maxlen = max(self.maxlen, len(word))\n        self.stack = []\n        \n\n    def query(self, letter: str) -> bool:\n        self.stack.append(letter)\n        for i in range(len(self.stack)-1, -1, -1):\n            if len(self.stack[i:]) > self.maxlen:\n                break\n            temp = ''.join(self.stack[i:][::-1])\n            if temp not in self.prefix:\n                return False\n            if self.prefix[temp] == 1:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words):\n        self.trie = dict()\n        for word in words:\n            t = self.trie\n            for c in reversed(word):\n                if c not in t:\n                    t[c] = dict()\n                t = t[c]\n            t['#'] = True\n        self.stack = []\n    def query(self, letter):\n        self.stack.append(letter)\n        t = self.trie\n        for c in reversed(self.stack):\n            if '#' in t:\n                return True\n            if c not in t:\n                return False\n            t = t[c]\n        return '#' in t     # last check\n\n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = dict()\n        for word in words:\n            t = self.trie\n            for c in reversed(word):\n                if c not in t:\n                    t[c] = dict()\n                t = t[c]\n            t['#'] = True\n        self.stack = []\n    def query(self, letter):\n        self.stack.append(letter)\n        t = self.trie\n        for c in reversed(self.stack):\n            if '#' in t:\n                return True\n            elif c in t:\n                t = t[c]\n            else:\n                return False\n        return '#' in t\n\n        \n        \n", "from collections import defaultdict\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.helper = defaultdict(list)\n        for i in words:\n            self.helper[i[-1]].append(i)\n        self.characters = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.characters += letter\n        if letter in self.helper:\n            for j in self.helper[letter]:\n                if self.characters[-len(j):] == j: return True\n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.childern = defaultdict(Trie)\n        self.end = False\n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.inTrie = Trie()\n        self.querystr = \\\"\\\"\n        for word in words:\n            self.addWord(word[::-1])\n                \n    def addWord(self, word):\n        node = self.inTrie\n        for symbol in word:\n            node = node.childern[symbol]\n        node.end = True\n    \n    def search(self, node, word):\n        if not word:\n            return node.end == True\n        if node.end:\n            return True\n        node = node.childern.get(word[0])\n        if not node:\n            return False\n        return self.search(node, word[1:])\n        \n    def query(self, letter: str) -> bool:\n        self.querystr = letter + self.querystr\n        return self.search(self.inTrie, self.querystr)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, 0\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = 1\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = Trie()\n        self.Stream = deque()\n        for word in words: self.trie.insert(word[::-1])\n         \n    def query(self, letter):\n        self.Stream.appendleft(letter)\n        cur = self.trie.root\n        for c in self.Stream:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node: return True\n            else: break\n        return False\n    \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.q = ''\n        self.m = defaultdict(set)\n        for w in words:\n            self.m[w[-1]].add(w)\n        \n\n    def query(self, letter: str) -> bool:\n        self.q += letter\n        return any(filter(lambda w: self.q.endswith(w), self.m[letter]))", "class Trie:\n    def __init__(self):\n        self.letters = {}\n        self.hasWord = False\n    \n    def addWord(self, word: str) -> None:\n        if word == \\\"\\\":\n            self.hasWord = True\n            return\n        if word[-1] not in self.letters:\n            self.letters[word[-1]] = Trie()\n        self.letters[word[-1]].addWord(word[:-1])\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = []\n        self.trie = Trie()\n        for w in words:\n            self.trie.addWord(w)\n        \n    def query(self, letter: str) -> bool:\n        t = self.trie\n        self.history.append(letter)\n        for x in reversed(self.history):\n            if t.hasWord:\n                return True\n            if x not in t.letters:\n                return False\n            t = t.letters[x]\n        return t.hasWord\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.endOfWord=False\n        self.children=[None]*26\n    def insert(self,s):\n        t=self\n        for c in s:\n            if t.children[ord(c)-ord('a')]==None:\n                t.children[ord(c)-ord('a')]=Trie()\n            t=t.children[ord(c)-ord('a')]\n        t.endOfWord=True\n    def search(self,s):\n        t=self\n        for c in s:\n            if t.children[ord(c)-ord('a')]==None: \n                return False\n            t=t.children[ord(c)-ord('a')]\n            if(t.endOfWord): \n                return True\n        return False\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t=Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.word_set = set(words)\n        self.last_letter_set = set()\n        self.max_len = 0\n        self.min_len = math.inf\n        for w in words:\n            self.last_letter_set.add(w[-1])\n            if len(w) > self.max_len:\n                self.max_len = len(w)\n            if len(w) < self.min_len:\n                self.min_len = len(w)\n        self.s = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        if letter in self.last_letter_set:\n            for i in range(max(len(self.s)-self.max_len, 0), len(self.s)-self.min_len+1):\n                if self.s[i:] in self.word_set:\n                    return True\n        return False\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(lambda: TrieNode())\n        self.word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        node = self.root\n        for c in word: node = node.children[c]\n        node.word = True\n        \n    def search(self, word, prefix=False):\n        node = self.root\n        for c in word:\n            if c not in node.children: return False\n            node = node.children[c]\n        if prefix: return True\n        return node.word\n    \n    def starswith(self, prefix):\n        return self.search(prefix, True)\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for w in words: self.trie.insert(w[::-1])\n        self.stream = []\n    def query(self, letter: str) -> bool:\n        self.stream += [letter]\n        #print(self.stream)\n        for i in range(1, len(self.stream)+1):\n            #print(i, self.stream[-i:])\n            if not self.trie.search(self.stream[-i:][::-1], True): return False\n            if self.trie.search(self.stream[-i:][::-1]): return True\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.letters = []\n        # build trie\n        for word in words:\n            p = self.trie # makre sure point to root for each word\n            for ch in word[::-1]:\n                if ch not in p:\n                    p[ch] = {}\n                p = p[ch]\n            p['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        # lookup trie in reverse order\n        p = self.trie\n        for i in range(len(self.letters) - 1, -1, -1):\n            ch = self.letters[i] \n            if ch not in p:\n                return False\n            p = p[ch]\n            if '#' in p:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\n\\\"\\\"\\\"\n[\\\"cd\\\",\\\"f\\\",\\\"kl\\\"]\n        root\n     d   f.   l\n   c             k\n\n      reverse check <-\na b c d e f g h i j k l\n      ^\n\n\\\"\\\"\\\"\n", "class Trie():\n    def __init__(self):\n        self.isWord = False\n        self.children = {}\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.StreamChecker = Trie()\n        self.letters = []\n        for word in words:\n            self.addWord(word)\n            \n    def query(self, letter: str) -> bool:\n        self.letters.insert(0,letter)\n        node = self.StreamChecker\n        for letter in self.letters:\n            if node.isWord == True:\n                return True\n            if letter not in node.children:\n                return False\n            node = node.children[letter]\n\n        if node.isWord == True:\n            return True\n        else:\n            return False\n            \n\n    def addWord(self, word):\n        node = self.StreamChecker\n        word = word[::-1]\n        for letter in word:\n            if letter not in node.children:\n                node.children[letter] = Trie()\n            node = node.children[letter]\n        node.isWord = True\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from typing import List, Dict, Optional, Iterator\n\n\nclass TrieNode:\n    def __init__(self, value: Optional[str]) -> None:\n        self.value = value\n        self.children: Dict[str, TrieNode] = {}\n\n        self.end = False\n        self.word: Optional[str] = None  # not necessary in this task\n\n\ndef build_trie(words: List[str]) -> TrieNode:\n    trie_root = TrieNode(None)\n\n    for word in words:\n        trie_node = trie_root\n\n        for char in word:\n            trie_node.children.setdefault(char, TrieNode(char))\n            trie_node = trie_node.children[char]\n\n        trie_node.end = True\n        trie_node.word = word\n\n    return trie_root\n\n\nclass StreamCheckerForward:\n    def __init__(self, words: List[str]) -> None:\n        self._trie = build_trie(words)\n        self._trie_ptrs = [self._trie]\n\n    def query(self, letter: str) -> bool:\n        trie_ptrs_new = [self._trie]\n\n        result = False\n\n        for trie_node in self._trie_ptrs:\n            if letter in trie_node.children:\n                result = result or trie_node.children[letter].end\n                trie_ptrs_new.append(trie_node.children[letter])\n\n        self._trie_ptrs = trie_ptrs_new\n\n        return result\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]) -> None:\n        self._trie = build_trie(list(map(reversed, words)))\n        self._stream = []\n\n    def _search_trie(self, stream: Iterator[str]) -> bool:\n        node = self._trie\n\n        for char in stream:\n            if node.end:\n                return True\n\n            if char in node.children:\n                node = node.children[char]\n            else:\n                break\n\n        return node.end\n\n    def query(self, letter: str) -> bool:\n        self._stream.append(letter)\n\n        return self._search_trie(reversed(self._stream))\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.endOfWord = False\n        self.children = [None]*26\n    \n    def insert(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None:\n                t.children[ord(c)-ord('a')] = Trie()\n            t = t.children[ord(c)-ord('a')]\n        t.endOfWord = True\n        \n    \n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None:\n                return False\n            t = t.children[ord(c)-ord('a')]\n            if t.endOfWord :\n                return True\n        #when all the characters are there in the word but there is no end of the word\n        return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.rec = collections.defaultdict(set)\n        self.maxsize = float('-inf')\n        self.minsize = float('inf')\n        for w in words:\n            self.maxsize = max(len(w), self.maxsize)\n            self.minsize = min(len(w), self.minsize)\n            self.rec[w[-1]].add((w,len(w)))\n\n        self.curr = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        \n        self.curr += letter        \n        for w, i in self.rec[letter]:\n            if i <= len(self.curr) and self.curr[-i:] == w:\n                return True            \n            \n        self.curr = self.curr[-self.maxsize:]\n            \n        return False\n            \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    #reverse the streamer and put it in trie\n    def __init__(self, words: List[str]):\n        \n        self.now = ''\n        self.trie = defaultdict()\n        \n\n        for w in words:\n            cur = self.trie\n            for i in w[::-1]:\n                if i not in cur:\n                    cur[i] = defaultdict()\n                \n                cur = cur[i]\n            cur['#'] = None\n                \n\n    def query(self, letter: str) -> bool:\n        self.now+=letter\n        \n        \n        s = self.now[::-1]\n        cur = self.trie\n        for i in s:\n            if i in cur:\n                cur=cur[i]\n                if '#' in cur:\n                    return True\n            else:\n                break\n        return False\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tries = {}\n        self.hist = ''\n        for word in words:\n            cur = self.tries            \n            for c in word[::-1]:\n                if c not in cur:\n                    cur[c] = {}\n                cur = cur[c]\n            cur['#'] = word\n\n    def query(self, letter: str) -> bool:\n        self.hist += letter\n        cur = self.tries\n        for c in self.hist[::-1]:\n            if '#' in cur:\n                return True\n            if c in cur:\n                cur = cur[c]\n            else:\n                return False\n        return '#' in cur\n\n    \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tries = {}\n        self.hist = ''\n        for word in words:\n            cur = self.tries            \n            for c in word[::-1]:\n                if c not in cur:\n                    cur[c] = {}\n                cur = cur[c]\n            cur['#'] = word\n        print((self.tries))\n\n    def query(self, letter: str) -> bool:\n        self.hist += letter\n        cur = self.tries\n        for c in self.hist[::-1]:\n            if '#' in cur:\n                return True\n            if c in cur:\n                cur = cur[c]\n            else:\n                return False\n        return '#' in cur\n\n    \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.root = Node()\n    \n    def add(self, word):\n        curr = self.root\n        for c in word:\n            if curr.has(c):\n                curr = curr.child(c)\n            else:\n                curr.add(c)\n                curr = curr.child(c)\n        curr.end()\n        \n    def search(self, word):\n        curr = self.root\n        for c in word:\n            if curr.terminal:\n                return True\n            elif not curr.has(c):\n                return False\n            else:\n                curr = curr.child(c)\n        return curr.terminal\n        \n    def display(self):\n        def recurse(node, pref):\n            print (''.join(pref), node.terminal)\n            for letter, child in node.children.items():\n                recurse(child, pref + [letter])\n        \n        pref = []\n        recurse(self.root, pref)\n        \nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.terminal = False\n        \n    def end(self):\n        self.terminal = True\n    \n    def has(self, c):\n        return c in self.children\n    \n    def add(self, c):\n        self.children[c] = Node()\n    \n    def child(self, c):\n        return self.children[c]\n    \n    def __str__(self):\n        return \\\"nd\\\"\n    \n    def __repr__(self):\n        return \\\"nd\\\"\n    \n\ndef rev(L):\n    # reverse iterator\n    for i in range(len(L) - 1, -1, -1):\n        yield L[i]\n    \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        # Set trie up for reverses of words\n        # always search in reverse\n        self.T = Trie()\n        for word in words:\n            self.T.add(rev(word))\n        self.stream = []\n        self.T.display()\n        \n        \n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        return self.T.search(rev(self.stream))\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    word=[]\n    d={}\n    queryseq=\\\"\\\"\n    def __init__(self, words: List[str]):\n        self.word=[]\n        self.d={}\n        self.queryseq=\\\"\\\"\n        for i in range(len(words)):\n            self.word.append(words[i])\n            ch=words[i][-1]\n            if ch in self.d:\n                self.d[ch].append(i)\n            else:\n                self.d[ch]=[i]\n        #print (self.d)\n\n    def query(self, letter: str) -> bool:\n        self.queryseq+=letter\n        ch=letter[-1]\n        if ch not in self.d:\n            return False\n        for i in self.d[ch]:\n            x=self.word[i]\n            if self.queryseq[-len(x):] ==x:\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            node = self.trie\n            for c in word[::-1]:\n                node = node.setdefault(c, {})\n            node[\\\"$\\\"] = True\n        self.stream = collections.deque([])\n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node = self.trie\n        for c in self.stream:\n            if '$' in node:\n                return True\n            if c not in node:\n                return False\n            node = node[c]\n        return \\\"$\\\" in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class trie:\n    def __init__(self):\n        self.endofword = False\n        self.children = [None]*26\n        \n    def insert(self,s):\n        t = self\n        for i in s:\n            if t.children[ord(i)-ord('a')] == None:\n                t.children[ord(i)-ord('a')] = trie()\n            t = t.children[ord(i)-ord('a')]\n        t.endofword = True\n        \n    def search(self,w):\n        t = self\n        for i in w:\n            if t.children[ord(i)-ord('a')] == None:\n                return False\n            t = t.children[ord(i)-ord('a')]\n            if t.endofword:\n                return True\n        return False   \n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = trie()\n        self.dequeue = []\n        for i in words:\n            self.t.insert(reversed(i))\n            \n\n    def query(self, letter: str) -> bool:\n        self.dequeue.insert(0,letter)\n        return self.t.search(self.dequeue)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        self.query_buffered = \\\"\\\"\n        for word in words:\n            tmp = self.trie\n            for w in word[::-1]:\n                if w not in tmp:\n                    tmp[w] = dict()\n                    tmp = tmp[w]\n                else:\n                    tmp = tmp[w]\n            tmp['#HasWord#'] = True\n        \n        \n\n    def query(self, letter: str) -> bool:\n        tmp = self.trie\n        self.query_buffered += letter\n        for c in self.query_buffered[::-1]:\n            if \\\"#HasWord#\\\" in tmp:\n                return True\n            if c in tmp:\n                tmp = tmp[c]\n            else:\n                return False\n        return \\\"#HasWord#\\\" in tmp        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "#class StreamChecker:\n\n    #def _sum_ord(self, word: str):\n     #   return sum([ord(c) for c in word])\n    \n    #def __init__(self, words: List[str]):\n        \n     #   self.ord_list = [ self._sum_ord(word) for word in words ]\n      #  self.curr_ord = 0\n       # self.\n        #print(self.ord_list)\n        \n    #def query(self, letter: str) -> bool:\n     #   self.curr_ord += ord(letter)\n        \n      #  if self.curr_ord in self.ord_list:\n       #     self.curr_ord = 0\n        #    return True\n       # else:\n        #    return False\n\n\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        self.word_map, self.len_map, self.buffer = defaultdict(set), defaultdict(set), \\\"\\\"\n        for w in words:\n            self.word_map[w[-1]].add(w[::-1])\n            self.len_map[w[-1]].add(len(w))\n        \n\n    def query(self, letter):\n        self.buffer = letter + self.buffer\n        return any(len(self.buffer) >= l and self.buffer[:l] in self.word_map[letter] for l in self.len_map[letter])\n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.endOfWord = False\n        self.children = [None] * 26\n        \n    def insert(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c) - ord('a')] == None:\n                t.children[ord(c) - ord('a')] = Trie()\n            t = t.children[ord(c) - ord('a')]\n        t.endOfWord = True\n        \n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c) - ord('a')] == None:\n                return False\n            t = t.children[ord(c) - ord('a')]\n            if t.endOfWord:\n                return True\n        return False\n    \n    \n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n            \n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    class Node:\n        def __init__(self):\n            self.node = [None] * 26\n            self.end = False\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.root = self.Node()\n        for word in words:\n            node = self.root\n            n = len(word)\n            word = word[::-1]\n            for i in range(n):\n                a = ord(word[i]) - ord('a')\n                if not node.node[a]:\n                    node.node[a] = self.Node()\n                if i == n - 1:\n                    node.node[a].end = True\n                else:\n                    node = node.node[a]\n            print((node.node, node.end))\n\n    def query(self, letter: str) -> bool:\n        self.s = letter + self.s\n        node = self.root\n        for i in self.s:\n            a = ord(i) - ord('a')\n            if not node.node[a]:\n                return False\n            if node.node[a].end:\n                print((not node.node[a]))\n                return True\n            node = node.node[a]\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.map = {}\n        self.history = ''\n        \n        for w in words:\n            curr = self.map\n            w = w[::-1]\n            w += '0'\n            for c in w:\n                if c not in curr:\n                    curr[c] = {}\n                curr = curr[c]\n            # curr['is_end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n        curr = self.map\n        \n        for c in self.history[::-1]:\n            if c not in curr:\n                break\n            curr = curr[c]\n            if '0' in curr:\n                return True\n        \n        return False\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\ndef tree():\n    return defaultdict(tree)\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        # we store the words in an inverse trie (nexted dictionary) because when we get a new query we would know the last character to match and from that if we move upwards we will know whether we reach the top or not if we do we found our word else we return False  \n        # to achieve this we need to construct an inverse trie and thus we won't have multiple choices to match we would only have a single choice for each character\n        self.trie = defaultdict(tree)\n        for word in words:\n            node = self.trie\n            for char in word[::-1]:\n                node = node[char]\n            node['*'] = 1\n        self.current_list = []\n        \n#         self.print_nested(self.trie)\n        \n#     def print_nested(self, d, indent=0):\n#         for k, v in d.items():\n#             print ('{}{!r}:'.format(indent * '  ', k))\n#             if type(v) is not int:\n#                 self.print_nested(v, indent + 1)\n\n    def query(self, letter: str) -> bool:\n        # there are two reasons for returning false one is that we did not find a matching character in the tire for the current letter in which case we can empty the entire list\n        # else if we found a matching a character but its not marking the end of the search(here beginning of the word) we add it to the list and return False\n        # currently we will store the words in a simple list if we return false for them and if we return true we remove them from the list\n        # we first travel down the trie\n        match_found = True\n        end_found = False\n        self.current_list.insert(0,letter)\n        i = 0\n        node = self.trie\n        while i < len(self.current_list):\n            if self.current_list[i] in list(node.keys()):\n                node = node[self.current_list[i]]\n                if '*' in list(node.keys()):\n                    end_found = True\n                    break\n            else:\n                match_found = False\n                break\n            i += 1      \n        if '*' in list(node.keys()):\n            end_found = True\n        # if (not match_found):\n        #     self.current_list = [letter]\n        return end_found\n    \n    # for the following approach only `6 out of 17 test cases pass and so when we are travelling the stack the time limit exceeds this is because with the stack approach we are searching the words from the begining to the end and we do not know how many characters to match \n    '''\n    def __init__(self, words: List[str]):\n        # we store the words in a trie (nested defaultdictionary)\n        self.trie = defaultdict(tree)\n        for word in words:\n            node = self.trie\n            for char in word:\n                node = node[char]\n            node['*'] = 1\n        self.pointers_stack = []\n        # we keep a list of pointers which mark the beginnign of the words in the trie based on the queries in the trie and if we return True we just increment the last pointer in the pointers heirarchy to point to the new root down the hierarchy and if there is a new word that starts \n        # if we return False because we cannot find the current character in the current pointer we change the pointer to point to the beginning and if there is a word starting from that character we change it to it else we keep it null\n        # if we return False because we have not yet reached the end of the word however we have a corresponding character in the current pointer then we make a new entry to the pointers list which marks that this character may be because a new word has begun change the pointer to point to the latest character \n        \n    # def print_nested(self, d, indent=0):\n    #     for k, v in d.items():\n    #         print ('{}{!r}:'.format(indent * '  ', k))\n    #         self.print_nested(v, indent + 1)\n\n    def query(self, letter: str) -> bool:\n        # we keep on poping elements from the pointer stack as they mark the beginning of the words \n        # so our stack will be like [#q1q2q3, #q2q3, #q3] (actually it will be [#q3,#q3,#q3] and all q3 will be different nodes ) if we find the current character in q3 we increment the pointer in the last element and so now our stack becomes [#q1q2q3, #q2q3, #q3q4] -\n        # we keep on travelling the stack and if we do not find q4 somewhere we pop that node else we add q4 by incrementing the pointer till for all the elements in the stack\n        # eg there is no word starting with q2 and having q4 while there are some words having #q1q2q3q4 and #q3q4 format then our stack will look like [#q1q2q3q4, #q3q4] \n        # if for some value we find a word ending in q4 we return True else we return False\n        answer = False\n        if self.pointers_stack != []:\n            index = 0\n            while index < len(self.pointers_stack) and self.pointers_stack != []:\n                root = self.pointers_stack[index]\n                if letter in root.keys():\n                    self.pointers_stack[index] = root[letter]\n                    if root[letter]['*'] == 1:\n                        answer = True\n                    index += 1\n                else:\n                    self.pointers_stack.pop(index)\n        # finally we also need to add the current letter as a start of the word\n        if letter in self.trie.keys():\n            root = self.trie[letter]\n            self.pointers_stack.append(root)\n            if root['*'] == 1:\n                answer = True\n        return answer\n        \n    '''\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    END = \\\"#\\\"\n\n    def __init__(self, words: List[str]):\n        self.trie = self.build_trie(words)\n        self.prefix = collections.deque()\n        \n    def build_trie(self, words: list):\n        trie = {}\n        for word in words:\n            root = trie\n            for char in reversed(word):\n                root = root.setdefault(char, {})\n            root[self.END] = word\n        return trie\n\n    def query(self, letter: str) -> bool:\n        self.prefix.appendleft(letter)\n        root = self.trie\n        \n        for char in self.prefix:\n            if char in root:\n                root = root[char]\n                if self.END in root:\n                    return True\n            else:\n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.end = False\n\nclass StreamChecker:\n\n    def char_to_index(self, ch):\n        return ord(ch) - ord('a')\n\n    def insert(self, word):\n        n = len(word)\n        ptr = self.root\n        for lvl in range(len(word)-1,-1,-1):\n            i = self.char_to_index(word[lvl])\n            if ptr and not ptr.children[i]:\n                ptr.children[i] = TrieNode()\n\n            ptr = ptr.children[i]\n\n        ptr.end = True\n\n    def __init__(self, words):\n        self.root = TrieNode()\n        self.pe = \\\"\\\"\n\n        for word in words:\n            self.insert(word)\n\n    def query(self, letter):\n        self.pe = letter + self.pe\n        n = len(self.pe)\n        node = self.root\n        for lvl in range(n):\n            i = self.char_to_index(self.pe[lvl])\n            if node.children[i]:\n                if node.children[i].end:\n                    return True\n            else:\n                return False\n            \n            node = node.children[i]\n            if not node:\n                return False\n       \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.end = -1\n        for w in words:\n            self.insert(w)\n        self.qhist = ''\n\n    def insert(self, word):\n        curNode = self.root\n        for c in word[::-1]:\n            if not c in curNode:\n                curNode[c] = {}\n            curNode = curNode[c]\n        curNode[self.end] = True\n\n    def query(self, letter: str) -> bool:\n        self.qhist += letter\n        curNode = self.root\n        for c in self.qhist[::-1]:\n            if not c in curNode:\n                return False\n            curNode = curNode[c]\n            if self.end in curNode:\n                return True\n\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n        \n# class TrieNode:\n#     def __init__(self, letter, next=None, isWord=False):\n#         self.letter = letter\n#         self.next = next\n#         self.isWord = isWord\n    \n#     def setNext(next):\n#         self.next = next\n    \n#     def isWord():\n#         return self.isWord\n    \n#     def setWord(flag):\n#         self.isWord = flag\n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "\nclass StreamChecker:\n\n    def __init__(self, words):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:  \n            curr_node = self.map\n            for letter in word[::-1]:   \n                if letter not in curr_node:\n                    curr_node[letter] = {}  \n                curr_node = curr_node[letter]   \n            curr_node['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if 'end' in curr_node:\n                return True\n        \n        return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '#' in curr_node:\n                return True\n        \n        return False", "class Trie:\n    def __init__(self):\n        self.root = {\\\"0\\\": \\\"0\\\"}\n    \n    def add_w(self, w):\n        cn = self.root\n        for i in w[::-1]:\n            if i not in cn:\n                cn[i] = {}\n            cn = cn[i]\n        cn[\\\"*\\\"] = \\\"*\\\"\n    \n    def search(self, w):\n        cn = self.root\n        for i in w[::-1]:\n            if \\\"*\\\" in cn:\n                return True\n            if i not in cn:\n                return False\n            cn = cn[i]\n        return \\\"*\\\" in cn\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for i in words:\n            self.trie.add_w(i)\n        self.string = \\\"\\\"\n        \n    def query(self, letter: str) -> bool:\n        self.string += letter\n        return self.trie.search(self.string)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.history = ''\n        self.map = {}\n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n        curr_node = self.map\n        for l in self.history[::-1]:\n            if l not in curr_node:\n                return False\n            curr_node = curr_node[l]\n            if '#' in curr_node:\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.trie = {}\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.word = \\\"\\\"\n        self.reversed_list = []\n        for i in words:\n            self.add_word(i[::-1])\n    def add_word(self,word):\n        curr = self.trie \n        for ch in word:\n            if ch not in curr:\n                curr[ch] = {}\n            curr = curr[ch]\n        curr[\\\"*\\\"] = True\n\n\n    def query(self, letter: str) -> bool:\n        self.word +=letter\n        curr = self.trie\n        \n        for i in self.word[::-1]:\n            if \\\"*\\\" in curr:\n                return True\n            if i not in curr:\n                return False\n            curr = curr[i]\n        return \\\"*\\\" in curr\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.q = ''\n        self.root = TrieNode()\n        for word in words:\n            root = self.root\n            for w in word[::-1]:\n                root = root.children.setdefault(w, TrieNode())\n            root.isEnd = True\n            \n    def dfs(self, node, n) -> bool: \n        # n: pos back from self.q\n        if n > len(self.q): return False\n        if self.q[-n] in node.children:\n            if node.children[self.q[-n]].isEnd:\n                return True\n            else:\n                return self.dfs(node.children[self.q[-n]], n + 1)\n        else:\n            return False     \n                \n    def query(self, letter: str) -> bool:\n        self.q += letter\n        return self.dfs(self.root, 1)\n        \n        \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = []\n        \n        for word in words:\n            node = self.trie\n            for ch in word[::-1]:\n                if ch not in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['#'] = {}\n                    \n\n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        \n        node = self.trie\n        for i in range(len(self.stream)-1,-1,-1):\n            if self.stream[i] not in node:\n                return False\n            else:\n                node = node[self.stream[i]]\n                if '#' in node:                \n                    return True\n            \n        \n        return False \n    \n            \n            \n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.trie = {}\n        self.history = ''\n        for w in words:\n            p = self.trie\n            for c in w[::-1]:\n                if c not in p: p[c] = {}\n                p = p[c]\n            p['#'] = ''\n\n    def query(self, letter: str) -> bool:\n        self.history+=letter\n        p = self.trie\n        for c in self.history[::-1]:\n            if c not in p: break\n            p = p[c]\n            if '#' in p: return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self, ch):\n        self.ch = None\n        self.children = {}\n        self.isWord = False\n\nclass Trie:\n    def __init__(self, words):\n        self.root = TrieNode(None)\n        for word in words:\n            self.insert(word[::-1])\n            \n        return\n    \n    def insert(self, word):\n        cur = self.root\n        for ch in word:\n            if ch not in cur.children:\n                newNode = TrieNode(ch)\n                cur.children[ch] = newNode\n            \n            cur = cur.children[ch]\n            \n        cur.isWord = True\n        \n    def search(self, word):\n        cur = self.root\n        for ch in word[::-1]:\n            if cur.isWord:\n                return True\n            if ch not in cur.children:\n                return False\n            cur = cur.children[ch]\n            \n        return cur.isWord\n            \n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trieTree = Trie(words)\n        self.curr = ''\n\n    def query(self, letter: str) -> bool:\n        self.curr += letter\n        return self.trieTree.search(self.curr)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '#' in curr_node:\n                return True\n        \n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['/'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '/' in curr_node:\n                return True\n        \n        return False\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie():\n    def __init__(self):\n        self.dic = {}\n        \n    def insert(self, words):\n        cur = self.dic\n        for word in words:\n            if word not in cur:\n                cur[word] = {}\n            cur = cur[word]\n        cur['#'] = True\n    \n    def search(self, words):\n        cur = self.dic\n        for word in words:\n            if '#' in cur:\n                return True\n            if word not in cur:\n                return False\n            cur = cur[word]\n        return '#' in cur\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        #self.q = deque()\n        self.s = \\\"\\\"\n        for word in words:\n            self.trie.insert(word[::-1])    \n\n    def query(self, letter: str) -> bool:\n        #self.q.appendleft(letter)\n        self.s += letter\n        return self.trie.search(self.s[::-1])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.nodes = defaultdict(TrieNode)\n        self.isWord = False\n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trieRoot = TrieNode()\n        self.stream = \\\"\\\"\n        self.words = {}\n        self.minWordLen = float(\\\"inf\\\")\n        \n        for word in words:\n            self.addWord(word[::-1])\n            if len(word) < self.minWordLen:\n                self.minWordLen = len(word)\n        \n    def addWord(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Adds a word into the data structure.\n        \\\"\\\"\\\"\n        current_node = self.trieRoot\n        #print(\\\"Inserting =\\\", word)\n        for char in word:\n            #print(\\\"Char =\\\", char)\n            current_node = current_node.nodes[char]\n        \n        current_node.isWord = True\n        self.words[word] = True\n        #print(self.words)\n    \n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        word = self.stream[::-1]\n        \n        curr = self.trieRoot\n        \n        for char in word:\n            #print(\\\"One by one:\\\", char)\n            if char not in curr.nodes:\n                #print(\\\"returning False\\\")\n                return False\n            curr = curr.nodes[char]\n            if curr.isWord:\n                return True\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '#' in curr_node:\n                return True\n        \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         # self.words=words\n#         self.last=defaultdict(list)\n#         for _ in words:\n#             self.last[_[-1]].append(_)\n#         self.read=[]\n\n#     def query(self, letter: str) -> bool:\n#         self.read.append(letter)\n#         ret=False\n#         poss=self.last.get(letter)\n#         if poss:\n#             for _ in poss:\n#                 ind=len(self.read)-1\n#                 suc=True\n#                 for i in range(len(_)-1,-1,-1):\n#                     if ind == -1:break\n#                     if self.read[ind]!=_[i]:\n#                         suc=False\n#                         break\n#                     ind-=1\n#                 if suc:\n#                     ret=suc\n#                     break\n#         return ret\n                \n\n# # Your StreamChecker object will be instantiated and called as such:\n# # obj = StreamChecker(words)\n# # param_1 = obj.query(letter)\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '#' in curr_node:\n                return True\n        \n        return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n\n        for word in set(words):\n            node = self.trie       \n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n        \n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n            \n        \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    \n    def __init__(self):\n        self.endOfWord = False\n        self.children = [None]*26\n\n    def insert(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None:\n                t.children[ord(c)-ord('a')] = Trie()\n            t = t.children[ord(c)-ord('a')]\n        t.endOfWord = True\n\n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord('a')] == None: return False\n            t = t.children[ord(c)-ord('a')]\n            if t.endOfWord: return True\n        return False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n  def __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.is_word = False\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    \n  def add_words(self, words):\n    for word in words:\n      cur = self.root\n      for l in word:\n        cur = cur.children[l]\n      cur.is_word = True\n\nclass StreamChecker:\n  def __init__(self, words: List[str]):\n    self.trie = Trie()\n    self.trie.add_words([word[::-1] for word in words])\n    self.prefix = ''\n\n  def query(self, letter: str) -> bool:\n    self.prefix += letter\n    cur = self.trie.root\n\n    for l in self.prefix[::-1]:\n      if l not in cur.children:\n        break\n\n      cur = cur.children[l]\n      if cur.is_word:\n        return True\n\n    return False\n        \n      \n          \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        # self.stream = deque([])\n        self.stream = []\n\n        for word in set(words):\n            node = self.trie       \n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n        \n        \n    def query(self, letter: str) -> bool:\n        # self.stream.appendleft(letter)\n        self.stream.insert(0,letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\nclass StreamChecker:\n\n    def __init__(self, words):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n        print((self.dic))\n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    \n    def __init__(self):\n        self.dict = collections.defaultdict(TrieNode)\n        self.isWord = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = ''\n        \n        self.root = TrieNode()\n        for word in words:\n            curr = self.root\n            \n            for char in word[::-1]:\n                curr = curr.dict[char]\n                \n            curr.isWord = True\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        curr = self.root\n        for char in self.stream[::-1]:\n            if char not in curr.dict:\n                return False\n            \n            curr = curr.dict[char]\n            if curr.isWord:\n                return True\n            \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        head = self.trie\n        self.history = \\\"\\\"\n        \n        for w in words:\n            p = head\n            for i in range(len(w)-1, -1, -1):\n                if i==0:\n                    if w[i] not in p:\n                        p[w[i]] = {'#' : True}\n                    else:\n                        p[w[i]]['#'] = True\n                else:\n                    if w[i] not in p:\n                        p[w[i]] = {'#' : False}\n                        p = p[w[i]]\n                    else:\n                        p = p[w[i]]\n        print(self.trie)\n                    \n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n        # print(self.history)\n        head = self.trie\n        for i in self.history[::-1]:\n            # print(i)\n            if i in head:\n                if head[i]['#']==True:\n                    return True\n                else:\n                    head =  head[i]\n            else:\n                return False\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.tree = Tree()\n        for item in words:\n            curr = self.tree\n            for letter in item[::-1]:\n                if letter not in curr.subtrees:\n                    curr.subtrees[letter] = Tree()\n                curr = curr.subtrees[letter]\n            curr.food = True\n        self.q = ''\n\n    def query(self, letter: str) -> bool:\n        self.q += letter\n        reverse_q = self.q[::-1]\n        curr = self.tree\n        for letter in reverse_q:\n            if letter not in curr.subtrees:\n                return False\n            else:\n                curr = curr.subtrees[letter]\n                if curr.food:\n                    return True\n        return False\n\n\nclass Tree:\n    def __init__(self):\n        self.food = False\n        self.subtrees = {}", "from collections import defaultdict\n\nclass TrieNode:\n    def __init__(self):\n        self.dict = defaultdict(TrieNode)\n        self.is_word = False\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        # Build a trie with the words in reverse order\\t\\t\n        \n        # for user query record, init as empty string\n        self.prefix = ''\n        \n        # for root node of trie, init as empty Trie\n        self.trie = TrieNode()\n        \n        for word in words:\n            curr_node = self.trie\n            \n\\t\\t\\t# make word in reverse order\n            word = word[::-1]\n            \n            for char in word:                \n                curr_node = curr_node.dict[ char ]\n            \n\\t\\t\\t# mark this trie path as a valid word\n            curr_node.is_word = True\n\n    def query(self, letter: str) -> bool:\n        self.prefix += letter\n        \n        curr_node = self.trie\n        for char in self.prefix[::-1]:\n            if char not in curr_node.dict:\n                # word not in trie\n                break\n            curr_node = curr_node.dict[char] # get into next node\n            if curr_node.is_word:\n                # found word\n                return True\n        # No match\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    \n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.is_word = False\n        \n        \nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode()\n    \n    def build(self, words):\n        for word in words:\n            self._insert(word[::-1])\n            \n    def _insert(self, word):\n        cur = self.root\n        for char in word:\n            cur = cur.children[char]\n        cur.is_word = True       \n        \n    def search(self, stream):\n        cur = self.root\n        for char in stream[::-1]:\n            if char in cur.children:\n                cur = cur.children[char]\n                if cur.is_word:\n                    return True\n            else:\n                return False\n        return False\n        \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.trie.build(words)\n        self.stream = ''        \n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        found = self.trie.search(self.stream)\n        return found\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            trie = self.trie\n            for letter in word[::-1]:\n                if letter in trie:\n                    trie = trie[letter]\n                else:\n                    trie[letter] = {}\n                    trie = trie[letter]\n            trie['$'] = ''\n        print((self.trie))\n        self.queue = deque()    \n        self.max_len = max(len(word) for word in words)\n\n    def query(self, letter: str) -> bool:\n        self.queue.appendleft(letter)\n        if len(self.queue) > self.max_len:\n            self.queue.pop()\n        trie = self.trie\n        for letter in self.queue:\n            trie = trie.get(letter)\n            if trie is None:\n                return False\n            if '$' in trie:\n                return True\n        return False\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.found = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.term = \\\"\\\"\n        for w in words:\n            cur = self.root\n            for c in w[::-1]:\n                if c not in cur.children:\n                    cur.children[c] = TrieNode()\n                cur = cur.children[c]\n            cur.found = True\n\n    def query(self, letter: str) -> bool:\n        self.term += letter\n        cur = self.root\n        for c in self.term[::-1]:\n            if cur.found:\n                return True\n            if c not in cur.children:\n                break\n            cur = cur.children[c]\n        # self.term exists in the word list\n        if cur.found:\n            return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.nodes = defaultdict(TrieNode)\n        self.isWord = False\n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trieRoot = TrieNode()\n        self.stream = \\\"\\\"\n        \n        for word in words:\n            self.addWord(word[::-1])\n    \n    def addWord(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Adds a word into the data structure.\n        \\\"\\\"\\\"\n        current_node = self.trieRoot\n        for char in word:\n            current_node = current_node.nodes[char]\n        \n        current_node.isWord = True\n    \n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        word = self.stream[::-1]\n        curr = self.trieRoot\n        \n        for char in word:\n            if char not in curr.nodes:\n                return False\n            \n            curr = curr.nodes[char]\n            if curr.isWord:\n                return True\n            \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.letter = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n        print(self.dic)\n        \n\n    def query(self, letter: str) -> bool:\n        self.letter += letter\n        for word in self.dic[letter]:\n            if  self.letter.endswith(word):\n                return True\n            \n        return False\n            \n            \n                \n\n    \\\"\\\"\\\"def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n\\\"\\\"\\\"\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        # push the words in the trie in the reverse order \n        # now maintain a history of letters \n        # if the letters in the reverse of history are found in the trie then return true else return false\n        \n        self.trie = {}\n        head = self.trie\n        self.history = \\\"\\\"\n        \n        for w in words:\n            p = head\n            for i in range(len(w)-1, -1, -1):\n                if i==0:\n                    if w[i] not in p:\n                        p[w[i]] = {'#' : True}\n                    else:\n                        p[w[i]]['#'] = True\n                else:\n                    if w[i] not in p:\n                        p[w[i]] = {'#' : False}\n                        p = p[w[i]]\n                    else:\n                        p = p[w[i]]\n        print(self.trie)\n                    \n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n        # print(self.history)\n        head = self.trie\n        for i in self.history[::-1]:\n            # print(i)\n            if i in head:\n                if head[i]['#']==True:\n                    return True\n                else:\n                    head =  head[i]\n            else:\n                return False\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        r = self.root\n        self.maxLen = 0\n        self.q = []\n        for w in words:\n            w = w[::-1]\n            self.maxLen = max(len(w), self.maxLen)\n            temp = r\n            for c in w:\n                if c in temp.c:\n                    temp = temp.c[c]\n                else:\n                    temp.c[c] = Trie()\n                    temp = temp.c[c]\n            temp.end = True\n\n    def query(self, l: str) -> bool:\n        q = self.q\n        n = self.maxLen\n        r = self.root\n        q.append(l)\n        if len(q)>n:\n            q.pop(0)\n        def dfs(s,node):\n            if len(s)==0:\n                return node.end\n            if node.end:\n                return True\n            if s[0] in node.c:\n                return dfs(s[1:],node.c[s[0]])\n            else:\n                return False\n        ans = dfs(q[::-1],r)\n        return ans\n            \n\nclass Trie:\n    def __init__(self):\n        self.end = False\n        self.c = {}\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    \n    def __init__(self):\n        \n        self.nodes = {}\n        self.is_word = False\n        \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.prefix = \\\"\\\"\n        self.trienode = TrieNode()\n\n        for word in words:\n            node = self.trienode\n            for c in word[::-1]:\n                if c not in node.nodes:\n                    node.nodes[c] = TrieNode()\n                node = node.nodes[c]\n            node.is_word = True\n\n    def query(self, letter: str) -> bool:\n        self.prefix += letter\n\n        node = self.trienode\n        for c in self.prefix[::-1]:\n            if c not in node.nodes:\n                break\n            node = node.nodes[c]\n            if node.is_word:\n                return True\n        \n        return False\n", "class Trie:\n    def __init__(self, end=False):\n        self.child = dict()\n        self.end = end\n\n    def add(self, word, i=0):\n        if i >= len(word):\n            return\n        if word[i] not in self.child:\n            self.child[word[i]] = Trie()\n        if i == len(word) - 1:\n            self.child[word[i]].end = True\n        self.child[word[i]].add(word, i + 1)\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        for word in words:\n            self.root.add(word[::-1])\n        self.stream = ''\n\n    def query(self, letter: str) -> bool:\n        self.stream = letter + self.stream\n        ptr = self.root\n        for c in self.stream:\n            if c in ptr.child:\n                ptr = ptr.child[c]\n                if ptr.end:\n                    return True\n            else:\n                break\n        return False", "class TrieNode:\n    def __init__(self):\n        self.dict = defaultdict(TrieNode)\n        self.word = False\n        \nclass StreamChecker:\n    \n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.prefix = ''\n        \n        for word in words:\n            node = self.root\n            \n            for char in word[::-1]:\n                node = node.dict[char]\n            \n            node.word = True\n\n    def query(self, letter: str) -> bool:\n        self.prefix += letter\n        node = self.root\n        \n        for char in self.prefix[::-1]:\n            if char not in node.dict:\n                break\n            \n            node = node.dict[char]\n            \n            if node.word == True:\n                return True\n        \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.data = collections.defaultdict(TrieNode)\n        self.isWord = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.rec = collections.defaultdict(set)\n        self.maxsize = float('-inf')\n        self.minsize = float('inf')\n        self.root = TrieNode()\n        for w in words:\n            self.maxsize = max(len(w), self.maxsize)\n            self.minsize = min(len(w), self.minsize)\n            curr = self.root\n            for c in w[::-1]:\n                curr = curr.data[c]\n            \n            curr.isWord = True\n\n        self.curr = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        \n        self.curr += letter        \n        #self.curr = self.curr[-self.maxsize:]\n        \n        curr = self.root\n        for c in self.curr[::-1]:\n            if c in curr.data:\n                curr = curr.data[c]\n                if curr.isWord:\n                    return True\n            else:\n                return False\n            \n        return False\n            \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.s = \\\"\\\"\n        for w in words:\n            node = self.trie\n            for c in w[::-1]:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['#'] = True\n\n    def query(self, letter: str) -> bool:\n        self.s = letter+self.s\n        node = self.trie\n        for c in self.s:\n            if c in node:\n                node = node[c]\n            else:\n                return False\n            if '#' in node:\n                return True\n        \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = {word[-1]: [] for word in words}\n        self.string = \\\"\\\"\n        for word in words:\n            self.words[word[-1]].append(word)\n        \n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        for word in self.words.get(letter, []):\n            if self.string[-1*len(word):] == word:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.queried_word = \\\"\\\"\n        self.dict_sets = defaultdict(lambda: set()) \n        for word in words:\n            self.dict_sets[word[-1]].add(word)\n\n    def query(self, letter: str) -> bool:\n        self.queried_word += letter\n        for word in self.dict_sets[letter]:\n            if word == self.queried_word[-len(word):]:\n                return True\n        return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n", "class trie_node:\n    def __init__(self):\n        self.d = dict()\n        self.end = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = trie_node()\n        self.l = \\\"\\\"\n        for word in words:\n            node = self.trie\n            for c in word[::-1]:\n                if c in node.d:\n                    node = node.d[c]\n                else:\n                    temp = trie_node()\n                    node.d[c] = temp\n                    node = temp\n            node.end = True\n\n    def query(self, letter: str) -> bool:\n        self.l += letter\n        node = self.trie\n        for c in self.l[::-1]:\n            if c in node.d:\n                node = node.d[c]\n                if node.end:\n                    return True\n            else:\n                return False\n        \n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import deque\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n    def add_child(self, node):\n        self.children.append(node)\n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = TreeNode(0)\n        self.max_len = 0\n        for w in words:\n            self.max_len = max(self.max_len, len(w))\n            self.make_trie(w)\n        self.history = deque([])\n        \n    def make_trie(self, word):\n        parent = self.root\n        for char in word[::-1]:\n            current = None\n            for node in parent.children:\n                if node.val == char:\n                    current = node\n            if not current:\n                current = TreeNode(char)\n                parent.add_child(current)\n            parent = current\n        parent.add_child(TreeNode('.'))\n\n    def query(self, letter: str) -> bool:\n        self.history.append(letter)\n        if len(self.history) > self.max_len:\n            self.history.popleft()\n        parent = self.root\n        for i in range(len(self.history)-1, -1, -1):\n            char = self.history[i]\n            if i < len(self.history) - 1 and any([child.val == '.' for child in parent.children]):\n                return True\n            found = False\n            for node in parent.children:\n                if node.val == char:\n                    found = True\n                    parent = node\n            if not found:\n                return False\n        return any([child.val == '.' for child in parent.children])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass StreamChecker:\n    \n    def __init__(self, words: List[str]):\n    \n        self.root = TrieNode()\n\n        self.letterlist = \\\"\\\"\n\n        for word in words:\n            self._insert_word(word)\n    \n    def _insert_word(self, word):\n        node = self.root\n        \n        for c in word[::-1]:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_word = True    \n\n    def query(self, letter: str) -> bool:\n        self.letterlist += letter\n        node = self.root\n        k = 0\n        \n        for c in self.letterlist[::-1]:\n            k += 1\n            if c not in node.children:\n                return False\n            node=node.children[c]\n            if k > 0 and node.is_word:\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n\n    def __init__(self):\n        self.is_leaf = False\n        self.mp = {}\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        def insert(root, w):\n            for c in w:\n                if c not in root.mp:\n                    root.mp[c] = TrieNode()\n                root = root.mp[c]\n            root.is_leaf = True\n        self.root = TrieNode()\n        for w in words:\n            insert(self.root, w[::-1])\n        self.s = ''\n            \n    def query(self, letter: str) -> bool:\n        def find(root, s):\n            for c in s[::-1]:\n                if c not in root.mp: return False\n                root = root.mp[c]\n                if root.is_leaf: return True\n            return False\n        self.s += letter\n        return find(self.root, self.s)        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "    \nfrom typing import Tuple\nfrom collections import deque\n\nclass TrieNode(object):\n    \\\"\\\"\\\"\n    Our trie node implementation. Very basic. but does the job\n    \\\"\\\"\\\"\n\n    def __init__(self, char: str):\n        self.char = char\n        self.children = []\n        # Is it the last character of the word.`\n        self.word_finished = False\n        # How many times this character appeared in the addition process\n        self.counter = 1\n\n\n    def add(root, word: str):\n        \\\"\\\"\\\"\n        Adding a word in the trie structure\n        \\\"\\\"\\\"\n        node = root\n        for char in word:\n            found_in_child = False\n            # Search for the character in the children of the present `node`\n            for child in node.children:\n                if child.char == char:\n                    # We found it, increase the counter by 1 to keep track that another\n                    # word has it as well\n                    child.counter += 1\n                    # And point the node to the child that contains this char\n                    node = child\n                    found_in_child = True\n                    break\n            # We did not find it so add a new chlid\n            if not found_in_child:\n                new_node = TrieNode(char)\n                node.children.append(new_node)\n                # And then point node to the new child\n                node = new_node\n        # Everything finished. Mark it as the end of a word.\n        node.word_finished = True\n\n\n    def find_prefix(root, prefix: str) -> Tuple[bool, int]:\n        \\\"\\\"\\\"\n        Check and return \n          1. If the prefix exsists in any of the words we added so far\n          2. If yes then how may words actually have the prefix\n        \\\"\\\"\\\"\n        node = root\n        # If the root node has no children, then return False.\n        # Because it means we are trying to search in an empty trie\n        if not root.children:\n            return False, 0\n        for char in prefix:\n            char_not_found = True\n            # Search through all the children of the present `node`\n            for child in node.children:\n                if child.char == char:\n                    # We found the char existing in the child.\n                    char_not_found = False\n                    # Assign node as the child containing the char and break\n                    node = child\n                    break\n            # Return False anyway when we did not find a char.\n            if char_not_found:\n                return False, 0\n        # Well, we are here means we have found the prefix. Return true to indicate that\n        # And also the counter of the last node. This indicates how many words have this\n        # prefix\n        return True, node.counter\n\nclass StreamChecker:\n\n    \n    def __init__(self, words: List[str]):\n        self.d = deque()\n        self.trie = TrieNode('*')\n        self.wordMap = {}\n        for word in words:\n            self.wordMap[word[::-1]] = True\n            self.trie.add(word[::-1])\n    def query(self, letter: str) -> bool:\n        self.d.appendleft(letter)\n        s = \\\"\\\"\n        for char in self.d:\n            s += char\n            val, counter = self.trie.find_prefix(s)\n            if val and s in self.wordMap:\n                return True\n            if not val:\n                return False\n        return False\n\n    \n    \n\n#so maybe manage pointers from recently read letters, if the current pointer from first read to #current is not in trie, move pointer from first to current.\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode():\n    def __init__(self):\n        self.is_word = False\n        self.children = {}\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = deque()\n        self.root = TrieNode()\n        \n        for word in words:\n            node = self.root\n            for ch in word[::-1]:\n                if ch not in node.children:\n                    node.children[ch] = TrieNode()\n                node = node.children[ch]\n            node.is_word = True      \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node = self.root\n        \n        for ch in self.stream:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n            if node.is_word:\n                return True\n        \n        return False\n        \n        \n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict as dd\nclass trieNode :\n    def __init__(self) :\n        self.children = dd(int)\n        self.is_end = False\n        \nclass trie :\n    def __init__(self) :\n        self.root = trieNode()\n        \n    def add(self,word) :\n        \n        par=self.root\n        for char in word[::-1] :\n            if par.children[char]==0 :\n                par.children[char] = trieNode()\n            par=par.children[char]\n        par.is_end = True\n        \n    def check(self,s) :\n        par=self.root\n        for char in s[::-1] :\n            if par.children[char] :\n                par=par.children[char]\n                if par.is_end :\n                    return True\n            \n            else :\n                return False\n        return False\n                \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = trie()\n        self.cur = \\\"\\\"\n        for word in words :\n            self.trie.add(word)\n\n    def query(self, letter: str) -> bool:\n        self.cur+=letter\n        if self.trie.check(self.cur) :\n            return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    letter_queue = \\\"\\\"\n    def __init__(self, words: List[str]):\n        self.words_dict = {}\n        for w in words:\n\n            if w[-1] in self.words_dict:\n                self.words_dict[w[-1]].add(w)\n            else:\n                self.words_dict[w[-1]] = set()\n                self.words_dict[w[-1]].add(w)\n        \n    def query(self, letter: str) -> bool:\n        self.letter_queue += letter\n        if letter in self.words_dict:\n            for item in self.words_dict[letter]:\n                if item == self.letter_queue[-len(item):]: return True\n     \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.word = ''\n        self.dic = collections.defaultdict(set)\n        for i in words:\n            self.dic[i[-1]].add(i)\n        \n    def query(self, letter: str) -> bool:\n        self.word += letter\n        return any(self.word.endswith(i) for i in self.dic[letter])\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.d = collections.defaultdict(set)\n        \n        for word in words:\n            self.d[word[-1]].add(word)\n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.d[letter])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    \n    def __init__(self, val  =   \\\"\\\"):\n        self.val    =   val;\n        self.next_chars =   collections.defaultdict(str);\n        self.end_of_word    =   False;\n        return;\n\nclass Trie:\n    \n    def __init__(self, words):\n        self.head       =   TrieNode(\\\"head\\\");\n        \n        for w in words:\n            self._add_word(w[::-1]);\n            \n        return;\n    \n    def check_word(self, word):\n        \n        ptr =   self.head;\n        for c in word[::-1]:\n            \n            if c not in ptr.next_chars:     return False;            \n            \n            ptr =   ptr.next_chars[c];\n            \n            if ptr.end_of_word:           return True;\n            \n        \n        return ptr.end_of_word;\n        \n        \n    def _add_word(self, word):\n        \n        ptr =   self.head;\n        \n        for c in word:\n            \n            if c not in ptr.next_chars:\n                ptr.next_chars[c]   =   TrieNode(c);\n            \n            ptr =   ptr.next_chars[c];\n        \n        ptr.end_of_word =   True;\n        \n        return;\n\nMAX_LENGTH  =   2001;\n\nclass StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        \n        self.trie_words =   Trie(words);\n        self.rolling_word   =   [];\n        return;\n        \n\n    def query(self, letter: str) -> bool:\n        \n        self.rolling_word.append(   letter);\n        \n        result  =   self.trie_words.check_word( self.rolling_word);\n            \n        \n        if len(self.rolling_word) >= MAX_LENGTH:    self.rolling_word.pop(0);\n        \n        return result;\n    \n    \n    \n    \\\"\\\"\\\"\n    ############## BRUTE FORCE ##############################\n    def __init__    (self, words):\n        \n        self.last_char_words    =   collections.defaultdict(set);\n        self.rolling_word       =   \\\"\\\";\n        \n        for w in words:\n            last_c  =   w[-1];\n            self.last_char_words.setdefault(last_c, set()).add(w);\n        \n        #print(self.last_char_words);\n        return;\n    \n    def query(  self, letter:str)   -> bool:\n        \n        self.rolling_word += letter;\n        \n        for w in self.last_char_words[letter]:\n            ln_w    =   len(w);\n            \n            if self.rolling_word[-ln_w:] == w:\n                return True;\n        \n        self.rolling_word   =   self.rolling_word[-MAX_LENGTH:];\n        return False;\n    \\\"\\\"\\\"\n    \n\n\n    \n\n\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self):\n        self.isLast = False\n        self.child = {}\n\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n        \n    def insert(self, ind, word, node = None):\n        if node == None:\n            node = self.root\n        if ind == len(word):\n            node.isLast = True\n        else:\n        # print(word)\n            if word[ind] not in node.child:\n                node.child[word[ind]] = Node()\n            self.insert(ind+1,word,node.child[word[ind]])\n            \n    \n    def isPrefix(self, ind, word, node = None):\n        if node == None:\n            node = self.root\n        \n        if node.isLast: return True\n        \n        if ind == len(word): return False\n        \n        if word[ind] in node.child:\n            return self.isPrefix(ind+1, word, node.child[word[ind]])\n        return False\n        \n        \n        \nfrom collections import deque\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(0,word[::-1])\n        \n        self.stream = deque()\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.trie.isPrefix(0, self.stream)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self):\n        self.children = [None]*26\n        self.isWord = False\n    def calculateIndex(self,char):\n        return ord(char)-ord('a')\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n    def addWordInReverse(self,word):\n        wordLength = len(word)\n        currentNode = self.root\n        for i in range(wordLength-1,-1,-1):\n            currentChar = word[i]\n            currentIndex = currentNode.calculateIndex(currentChar)\n            if(currentNode.children[currentIndex] == None):\n                currentNode.children[currentIndex] = Node()\n            currentNode = currentNode.children[currentIndex]\n        currentNode.isWord = True;\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = []\n        self.reverseTrie = Trie()##no new keyword before object instantiation\n        for word in words:\n            self.reverseTrie.addWordInReverse(word)\n\n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        streamLength = len(self.stream)\n        currentNode = self.reverseTrie.root\n        for i in range(streamLength-1,-1,-1):\n            currentChar = self.stream[i]\n            currentIndex = currentNode.calculateIndex(currentChar)\n            if(currentNode.children[currentIndex] != None):\n                currentNode = currentNode.children[currentIndex]\n                if(currentNode.isWord):\n                    return True\n            else:\n                return False\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])", "class Trie:\n    def __init__(self):\n        self.children = {}\n        self.endSymbol = '*'\n    \n    def insert(self, word):\n        children = self.children\n        for char in word[::-1]:\n            if char not in children:\n                children[char] = {}\n            children = children[char]\n        children[self.endSymbol] = word\n    \n    \nclass StreamChecker:\n    # O(n * m) Time | O(max(n, m)) Space\n    # n: number of queries | m: length of longest word\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word)\n        self.array = []\n\n    def query(self, letter: str) -> bool:\n        self.array.insert(0, letter)\n        nodes = self.trie.children\n        for char in self.array:\n            if self.trie.endSymbol in nodes:\n                return True\n            if char not in nodes:\n                return False\n            nodes = nodes[char]\n        return self.trie.endSymbol in nodes\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        self.stream = deque([])\n        for word in words:\n            node = self.trie\n            for ch in word[::-1]:\n                node = node.setdefault(ch, {})\n            node['end'] = True\n    \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node = self.trie\n        for ch in self.stream:\n            if 'end' in node:\n                return True\n            if ch not in node:\n                return False\n            node = node[ch]\n        return 'end' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.query_letters = []\n        # post-fix hash table\n        self.hash = {}\n        for w in words:\n            for i in range(len(w)-1, -1, -1):\n                if i == 0: self.hash[w[i:]] = True\n                elif w[i:] in self.hash: continue\n                else: self.hash[w[i:]] = False\n        # print(self.hash)\n\n    def query(self, letter: str) -> bool:\n        self.query_letters.append(letter)\n        length = len(self.query_letters)\n        for i in range(length-1, -1, -1):\n            ls = \\\"\\\".join(self.query_letters[i:])\n            if ls not in self.hash: \n                return False\n            if self.hash[ls]: return True\n        return False\n\n\n#     def __init__(self, words: List[str]):\n#         self.Trie={}\n#         for word in words:\n#             curnode=self.Trie\n#             word=word[::-1]\n#             print(word)\n#             for ch in word:\n#                 if ch not in curnode:\n#                     curnode[ch]={}\n#                 curnode=curnode[ch]\n#             curnode['#']=1 # '#' means the end of a word\n#         self.pre=''\n \n#     def query(self, letter: str) -> bool:\n#         self.pre=self.pre+letter\n#         curnode=self.Trie\n#         print(curnode)\n#         # print(self.pre)\n#         for i in range(0,len(self.pre)):\n#             if self.pre[-i-1] not in curnode:\n#                 break\n#             curnode=curnode[self.pre[-i-1]]\n#             print(curnode)\n#             if '#' in curnode:\n#                 return True\n#         return False\n\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.child = {}\n        self.isEnd = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        self.str = []\n        \n        for word in words:\n            node = self.root\n            for ch in reversed(word):\n                if ch not in node.child:\n                    node.child[ch] = Trie()\n                node = node.child[ch]\n            node.isEnd = True\n\n    def query(self, letter: str) -> bool:\n        self.str.insert(0, letter)\n        \n        node = self.root\n        for ch in self.str:\n            if ch not in node.child:\n                return False\n            node = node.child[ch]\n            if node.isEnd:\n                return True\n        \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n    \n    def insert(self, word):\n        if len(word)==0:\n            self.isEnd = True\n            return\n        if word[0] not in self.children:\n            self.children[word[0]] = Trie()\n        self.children[word[0]].insert(word[1:])\n        \n    def search(self, word):\n        if len(word)==0:\n            return (True, False)\n        if len(word)==1:\n            return (word[0] in self.children, word[0] in self.children and self.children[word[0]].isEnd)\n        startsWith = word[0] in self.children\n        if startsWith:\n            return self.children[word[0]].search(word[1:])\n\n        return (False, False)\n\n    def startsWith(self, word):\n        if len(word)==0:\n            return True\n        return word[0] in self.children and self.children[word[0]].startsWith(word[1:])\n    def next(self, char):\n        if char in self.children:\n            return self.children[char]\n        return None\n    def printNode(self):\n        print(self.children,self.isEnd)\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = Trie()\n        for word in words:\n            self.words.insert(word[::-1])\n        self.stream = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        node = self.words\n        for i in range(len(self.stream)-1, -1, -1):\n            node = node.next(self.stream[i])\n            if node==None:\n                return False\n            if node.isEnd:\n                return True\n            \n                \n        return False", "from collections import deque\n\nclass TrieNode:\n    def __init__(self, val):\n        # self.val = val\n        self.end = False\n        self.children = {}\n        \nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode(-1)\n    \n    def add(self, word):\n        root = self.root\n        for idx, ch in enumerate(word):\n            children = root.children\n            if children.get(ch) == None:\n                child = TrieNode(ch)\n                children[ch] = child\n                root = child\n            else:\n                root = children[ch]\n                \n            if idx == len(word)-1:\n                root.end = True\n    \n    def search(self, word):\n\n        root = self.root\n        for idx, val in enumerate(word):\n            if root.children.get(val) == None:\n                return False\n            else:\n                root = root.children[val]\n                if root.end:\n                    return True\n            if idx == len(word)-1 and root.end:\n                return True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # self.words = set(words)\n        self.Trie = Trie()\n        self.maxlen = -1\n        for w in words:\n            # add word to Trie\n            self.maxlen = max(self.maxlen, len(w))\n            rev = w[::-1]\n            self.Trie.add(rev)\n        self.searchArr = deque()\n        \n\n    def query(self, letter: str) -> bool:\n\n        self.searchArr.insert(0, letter)\n        if len(self.searchArr) > self.maxlen:\n            self.searchArr.pop()\n\n        tmpWord = \\\"\\\".join(self.searchArr)    \n        if self.Trie.search(tmpWord):\n            return True        \n\n        return False    \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            node = self.trie # reset for each word\n            for ch in reversed(word):\n                node.setdefault(ch, {})\n                node = node[ch]\n            node['#'] = {}\n        self.letters = []\n\n    def query(self, letter: str) -> bool:\n        self.letters.insert(0, letter)\n        node = self.trie\n        for ch in self.letters:\n            if ch in node:\n                node = node[ch]\n                if '#' in node:  # found it, no need to go deeper\n                    return True\n            else:\n                break  # use the last found node\n        return False", "class StreamChecker:\n    \n    class Trie_node:\n        def __init__(self,value):\n            self.value = value\n            self.children = {}\n        \n        def add_child(self,node,letter):\n            self.children[letter] = node\n        \n        def is_child(self,letter):\n            if letter in self.children:\n                return True\n            return False\n        def get_child(self,letter):\n            return self.children[letter]\n        \n    def __init__(self, words: List[str]):\n        self.trie = self.Trie_node(-1)\n        self.max_length = 0\n        self.letter_list =[]\n        for word in words:\n            current_node = self.trie\n            self.max_length = self.max_length if len(word) < self.max_length else len(word)\n            \n            for index,letter in enumerate(word[::-1]):\n                if(current_node.is_child(letter)):\n                    if(index == len(word)-1):\n                        current_node.get_child(letter).value = 0\n                else:\n                    if(index == len(word)-1):\n                        current_node.add_child(self.Trie_node(0),letter)\n                    else:\n                        current_node.add_child(self.Trie_node(-1),letter)\n                current_node = current_node.get_child(letter)\n        print((self.trie.children))\n        \n\n    def query(self, letter: str) -> bool:\n        self.letter_list.append(letter)\n        if(len(self.letter_list)>self.max_length):\n            self.letter_list.pop(0)\n        top_node = self.trie\n        for letter in self.letter_list[::-1]:\n            if(top_node.is_child(letter)):\n                top_node = top_node.get_child(letter)\n                if(top_node.value == 0):\n                    return True\n            else:\n                return False\n        return False\n                    \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = \\\"\\\"\n        self.dictionary = {}\n        for word in words:\n            location = self.dictionary\n            for char in word[::-1]:\n                if char not in location:\n                    location[char] = {}\n                location = location[char]\n            location[\\\"goodbye\\\"] = True\n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        count = -1\n        location = self.dictionary\n        for char in self.stream[::-1]:\n            if char in location:\n                location = location[char]\n                if \\\"goodbye\\\" in location:\n                    return True\n                continue\n            return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.letters = ''\n        self.fragments = {}\n        for w in words:\n            temp = self.fragments\n            for i in range(len(w)):\n                sec = w[len(w)-1-i:]\n                if sec not in temp:\n                    temp[sec] = {}\n                temp = temp[sec]\n                    \n    def query(self, letter: str) -> bool:\n        self.letters += letter\n        chars = self.letters\n        \n        temp = self.fragments\n        for i in range(len(chars)):\n            sec = chars[len(chars) - 1 - i:]\n            if sec not in temp:\n                return False\n            temp = temp[sec]\n            if sec in self.words:\n                return True\n        \n    '''\n    def __init__(self, words: List[str]):\n        self.words = tuple(words)\n        self.letters = ''\n        \n    def query(self, letter: str) -> bool:\n        self.letters +=letter\n        return self.letters.endswith(self.words)        \n    '''\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self, c: str = None):\n        self.c = c\n        self.ch = [None] * 26\n        self.isEnd = False\n    \n    def insert(self, word: List[str], idx: int = None):\n        # print(\\\"start\\\", self)\n        if idx is None:\n            idx = len(word) - 1        \n        if idx == -1:\n            self.isEnd = True\n            # print(\\\"insert to end\\\", self)            \n            return\n        c = ord(word[idx]) - ord('a')\n        if self.ch[c] is None:\n            self.ch[c] = Trie(word[idx])\n        self.ch[c].insert(word, idx-1)\n        # print(self)        \n    \n    def __str__(self):\n        out = []\n        for i in range(26):\n            if self.ch[i] is None:\n                continue\n            out.append(chr(i + ord('a')) + \\\"{%r}\\\"%(str(self.ch[i])))\n        return \\\"[%r,%r] \\\"%(self.c, self.isEnd) + \\\" \\\".join(out)\n            \n        \n    def query(self, word: List[str], idx: int = None):\n        if self.isEnd:\n            return True\n        if idx is None:\n            idx = len(word) - 1\n        if idx == -1:\n            return self.isEnd\n        c = ord(word[idx]) - ord('a')\n        if self.ch[c] is None:\n            return False\n        return self.ch[c].query(word, idx-1)\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Trie(\\\"*\\\")\n        maxLen = 0\n        for w in words:\n            wli = [c for c in w]\n            self.root.insert(wli)\n            maxLen = max(maxLen, len(wli))\n        self.maxLen = maxLen\n        self.buf = []\n        # print(\\\"final \\\", str(self.root))\n\n    def query(self, letter: str) -> bool:\n        self.buf.append(letter)\n        return self.root.query(self.buf)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.is_end = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.s = []\n        for word in words:\n            current = self.root\n            for w in reversed(word):\n                current = current.children[w]\n            current.is_end = True\n\n    def query(self, letter: str) -> bool:\n        self.s.append(letter)\n        current = self.root\n        for w in reversed(self.s):\n            if w not in current.children:\n                break\n            current = current.children[w]\n            if current.is_end:\n                return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\nclass TrieNode:\n    \n    def __init__(self, word:str) -> None:\n        self.children = {}\n        self.exist = False\n        \n        if word is not None:\n            self.add(word)\n            \n    def __repr__(self) -> str:\n        return \\\"{\\\" + \\\", \\\".join([f\\\"{x}: {self.children[x]}\\\" for x in self.children]) + \\\"}\\\"\n        \n    def add(self, word: str) -> None:\n        if word == \\\"\\\":\n            self.exist = True\n            return \n        if word[0] not in self.children:\n            self.children[word[0]] = TrieNode(word[1:])\n        else:\n            self.children[word[0]].add(word[1:])\n        return\n    \n    def get_child(self, word: str):\n        if word == \\\"\\\":\n            return self\n        if word[0] in self.children:\n            return self.children[word[0]].get_child(word[1:])\n        return None\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode(None)\n        \n        max_word_len = 0\n        for word in words:\n            self.root.add(word[::-1])\n            max_word_len = max(max_word_len, len(word))\n        \n        self.stream = deque(maxlen=max_word_len)\n        \n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        \n        prefix = list(self.stream)[::-1]\n        curr_node = self.root\n        for char in prefix:\n            if char in curr_node.children:\n                if curr_node.children[char].exist == True:\n                    return True\n                curr_node = curr_node.children[char]\n            else:\n                return False\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self, val):\n        self.val = val\n        self.isEnd = False\n        self.children = dict()\n        \n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode(None)\n\n    def insert(self, word):\n        i = 0\n        curr = self.root\n        while i < len(word):\n            if word[i] not in curr.children:\n                curr.children[word[i]] = TrieNode(word[i])\n            curr = curr.children[word[i]]\n            i += 1\n        curr.isEnd = True\n    \n    def exists(self, stream):\n        def solve(node, i):\n            if i < 0 or stream[i] != node.val:\n                return False\n            elif node.val == stream[i] and node.isEnd:\n                return True\n            for key, val in node.children.items():\n                if solve(val, i-1):\n                    return True\n            return False\n        return any([solve(child, len(stream) - 1) for child in self.root.children.values()])\n\n    def dfs(self):\n        def solve(node, lvl):\n            for child in node.children.values():\n                solve(child, lvl+1)\n        solve(self.root, 0)\n        \n        \n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.stream = []\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])        \n        self.trie.dfs()\n\n        \n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        return self.trie.exists(self.stream)\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\n\n'''\ncd, f, kl\n\n             _\n            / \\\\  \\\\\n            d  f  l\n            |     |k\n            c\n\nO(max len of words)\nO(2000) = O(1) lookup\n\n'''", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic={}\n        for word in words:\n            try:\n                if self.dic[word[-1]]==1:\n                    pass\n                self.dic[word[-1]].append(word)\n            except:\n                self.dic[word[-1]]=[word,]\n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        ans=False\n        try:\n            for w in self.dic[letter]:\n                if self.s.endswith(w):\n                    ans=True\n        except:\n            pass\n        return ans\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dictionary = defaultdict(list)\n        for word in words:\n            self.dictionary[word[-1]].append(word[:-1])\n        \n        self.pastQueries = \\\"\\\"\n        \n    def query(self, letter: str) -> bool:\n        self.pastQueries += letter\n        if letter in self.dictionary:\n            for word in self.dictionary[letter]:\n                complete_word = word + letter\n                length = len(complete_word)\n                if len(self.pastQueries) >= length and complete_word == self.pastQueries[- length:]:\n                    return True\n            return False\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.trie = {}\n    \n    def add(self, word):\n        trie = self.trie\n        for c in word[::-1]:\n            trie = trie.setdefault(c, {})\n        trie[\\\"eos\\\"] = {}\n        \n    def find(self, char_list):\n        trie = self.trie\n        for c in char_list:\n            if c not in trie.keys():\n                return False\n            trie = trie[c]\n            if \\\"eos\\\" in trie.keys():\n                return True\n        return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.query_list = []\n        self.trie = Trie()\n        for word in words:\n            self.trie.add(word)\n\n    def query(self, letter: str) -> bool:\n        self.query_list.insert(0, letter)\n        return self.trie.find(self.query_list)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    \n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.endOfWord = False\n\n    def __init__(self, words: List[str]):\n        self.root = self.TrieNode()\n        self.stream = []\n        \n        for word in words:\n            node = self.root\n            for char in word[::-1]:\n                if char not in node.children:\n                    node.children[char] = self.TrieNode()\n                node = node.children[char]\n            node.endOfWord = True\n       \n    \n    def query(self, letter: str) -> bool:\n        node = self.root\n        self.stream.insert(0,letter)\n        for char in self.stream:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n            if node.endOfWord == True:\n                return True\n                break\n                \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    letter_queue = \\\"\\\"\n    def __init__(self, words: List[str]):\n        self.words_dict = {}\n        for w in words:\n\n            if w[-1] in self.words_dict:\n                self.words_dict[w[-1]].add(w)\n            else:\n                self.words_dict[w[-1]] = set()\n                self.words_dict[w[-1]].add(w)\n        print(self.words_dict)\n        \n    def query(self, letter: str) -> bool:\n        self.letter_queue += letter\n        if letter in self.words_dict:\n            for item in self.words_dict[letter]:\n                # b = False\n                l = len(item)\n                if item == self.letter_queue[-l:]:\n                    return True\n                # if not b: return True\n        \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class trie:\n    def __init__(self,val=None):\n        self.val = val\n        self.next = {}\n        self.is_complete = False\n    \n'''\n### https://youtu.be/Y37WA4advWw\n\nLogic here is to make trie of given works in reverse order ..so that if we want to find whether upto this point any query make sense...we can check in reverse order\n\n'''\nclass StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        self.root = trie()\n        ### insert all words in trie\n        for w in words:\n            node=self.root\n            for c in w[::-1]:\n                if c not in node.__next__:\n                    node.next[c] = trie(c)\n                node=node.next[c]\n            node.is_complete=True\n        \n        ###to keep track of previous queries\n        self.queries = []\n        \n        \n        \n    def query(self, letter: str) -> bool:\n        self.queries.insert(0,letter)\n        \n        ### search in trie\n        node = self.root\n        for c in self.queries:\n            if c not in node.__next__:\n                return False\n            node=node.next[c]\n            if node.is_complete:\n                return True\n            \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tab = collections.defaultdict(set)\n        for w in words:\n            self.tab[w[-1]].add(w)\n            \n        self.queried = ''\n        \n\n    def query(self, letter: str) -> bool:\n        self.queried += letter\n        if letter not in self.tab:\n            return False\n        candidates = self.tab[letter]\n        for can in candidates:\n            if can == self.queried[-len(can):]:\n                return True\n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.terminal = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        def addword(word):\n            node = self.root\n            for char in reversed(word):\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.terminal = True\n        \n        self.array = []\n        self.root = TrieNode()\n        for word in words:\n            addword(word)\n\n    def query(self, letter: str) -> bool:\n        \n        array = self.array\n        node = self.root\n        array.append(letter)\n        \n        for char in reversed(array):\n            if char in node.children:\n                node = node.children[char]\n                if node.terminal: return True\n            else:\n                return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.child = {}\n        self.isEnd = False\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        self.str = []\n        \n        for word in words:\n            node = self.root\n            for ch in reversed(word) :\n                if ch not in node.child:\n                    node.child[ch] = Trie()\n                node = node.child[ch]\n            node.isEnd = True\n    def query(self, letter: str) -> bool:\n        self.str.insert(0, letter)\n        \n        node = self.root\n        for ch in self.str:\n            if ch not in node.child:\n                return False\n            node = node.child[ch]\n            if node.isEnd:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.children = {}\n        self.endSymbol = '*'\n    \n    def insert(self, word):\n        children = self.children\n        for char in word[::-1]:\n            if char not in children:\n                children[char] = {}\n            children = children[char]\n        children[self.endSymbol] = word\n    \n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word)\n        self.array = []\n\n    def query(self, letter: str) -> bool:\n        self.array.insert(0, letter)\n        nodes = self.trie.children\n        for char in self.array:\n            if self.trie.endSymbol in nodes:\n                return True\n            if char not in nodes:\n                return False\n            nodes = nodes[char]\n        return self.trie.endSymbol in nodes\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self,words:List[str]):\n        self.s,self.dic='',collections.defaultdict(set)\n        for i in words:self.dic[i[-1]].add(i)\n    def query(self,letter:str)->bool:\n        self.s+=letter\n        return any(self.s.endswith(i) for i in self.dic[letter])", "class Node:\n    def __init__(self):\n        self.children = {}\n        self.is_start = False\n\nclass StreamChecker:\n    from collections import defaultdict\n    \n    \n    def __init__(self, words: List[str]):\n        self.queries = \\\"\\\"\n        self.root = Node()\n        self.found = False\n        for word in words:\n            r = self.root\n            for ch in reversed(word):\n                if r.children.get(ch,None):\n                    r = r.children[ch]\n                else:\n                    n = Node()\n                    r.children[ch] = n\n                    r = n\n            r.is_start = True\n            \n    def dfs(self):\n        def dfs_util(node, str_):\n            if not str_:\n                return\n            n = node.children.get(str_[0],None)\n            if not n:\n                return\n            if n.is_start:\n                self.found = True\n            dfs_util(n, str_[1:])\n            return\n        dfs_util(self.root, self.queries)\n            \n            \n        \n        \n\n    def query(self, letter: str) -> bool:\n        self.queries = letter + self.queries\n        #print(self.queries)\n        self.found = False\n        self.dfs()\n        return self.found\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "import string\nclass Node :\n    def __init__(self):\n        self.characters={}\n        self.isEnd=False\nclass Trie :\n    def __init__(self):\n        self.root=None\n    def insert(self,word):\n        if self.root==None :\n            self.root=Node()\n        curr_node=self.root\n        #print(curr_node.isEnd)\n        n=len(word)\n        i=0\n        while i < n :\n            #print(i)\n            if word[i] not in curr_node.characters :\n                node=Node()\n                curr_node.characters[word[i]]=node\n            curr_node=curr_node.characters[word[i]]\n            if i==n-1 :\n                curr_node.isEnd=True\n            i+=1\n            \n    def print_words(self) :\n        node=self.root\n        q=[(node,\\\"\\\")]\n        while len(q) > 0 :\n            node,word=q.pop(0)\n            if node.isEnd==True :\n                print(word)\n            for ch in node.characters :\n                q.append((node.characters[ch],word+ch))\n    def search(self, word: str) -> bool:\n        \\\"\\\"\\\"\n        Returns if the word is in the trie.\n        \\\"\\\"\\\"\n        if self.root==None :\n            return False\n        current_node=self.root\n        current_index=0\n        n=len(word)\n        while current_index < n :\n            if word[current_index] not in current_node.characters :\n                return False\n            current_node=current_node.characters[word[current_index]]\n            current_index+=1\n            if current_node.isEnd==True :\n                return True\n        return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie=Trie()\n        for word in words :\n            #print(word[::-1])\n            self.trie.insert(word[::-1])\n        self.curr_string=\\\"\\\"\n        #self.trie.print_words()\n\n    def query(self, letter: str) -> bool:\n        self.curr_string+=letter\n        #print(self.curr_string[::-1])\n        return self.trie.search(self.curr_string[::-1])\n        # n=len(self.curr_string)\n        # for i in range(n-1,-1,-1) :\n        #     if self.trie.search(self.curr_string[i:n]) ==True :\n        #         return True\n        # return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    \n    def char_int(self, char):\n        return ord(char)-ord('a')\n    \n    def add_trie(self, trie, word, idx):\n        if idx == len(word):\n            trie[26] = True\n            return\n        idx_trie = self.char_int(word[idx])\n        if not trie[idx_trie]:\n            trie[idx_trie] = [None]*27\n        self.add_trie(trie[idx_trie], word, idx+1)\n        \n    \n        \n\n    def __init__(self, words: List[str]):\n        self.trie = [None]*27\n        for word in words:\n            self.add_trie(self.trie, word[::-1], 0)\n        \n        self.str = []\n\n    def query(self, letter: str) -> bool:\n        self.str.append(letter)\n        i = len(self.str)-1\n        trie = self.trie\n        while i >= 0 and trie:\n            t = trie[:]\n            for j in range(len(t)):\n                if t[j]:\n                    t[j] = chr(ord('a')+j)\n            if trie[26]:\n                return True\n            trie = trie[self.char_int(self.str[i])]\n            i -= 1\n        if trie and trie[26]:\n            return True\n    \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "#\n# @lc app=leetcode id=1032 lang=python3\n#\n# [1032] Stream of Characters\n#\n# https://leetcode.com/problems/stream-of-characters/description/\n#\n# algorithms\n# Hard (35.61%)\n# Total Accepted:    2.4K\n# Total Submissions: 6.6K\n# Testcase Example:  '[\\\"StreamChecker\\\",\\\"query\\\",\\\"query\\\",\\\"query\\\",\\\"query\\\",\\\"query\\\",\\\"query\\\",\\\"query\\\",\\\"query\\\",\\\"query\\\",\\\"query\\\",\\\"query\\\",\\\"query\\\"]\\\n[[[\\\"cd\\\",\\\"f\\\",\\\"kl\\\"]],[\\\"a\\\"],[\\\"b\\\"],[\\\"c\\\"],[\\\"d\\\"],[\\\"e\\\"],[\\\"f\\\"],[\\\"g\\\"],[\\\"h\\\"],[\\\"i\\\"],[\\\"j\\\"],[\\\"k\\\"],[\\\"l\\\"]]'\n#\n# Implement the StreamChecker class as follows:\n#\n#\n# StreamChecker(words): Constructor, init the data structure with the given\n# words.\n# query(letter): returns true if and only if for some k >= 1, the last k\n# characters queried (in order from oldest to newest, including this letter\n# just queried) spell one of the words in the given list.\n#\n#\n#\n#\n# Example:\n#\n#\n# StreamChecker streamChecker = new StreamChecker([\\\"cd\\\",\\\"f\\\",\\\"kl\\\"]); // init the\n# dictionary.\n# streamChecker.query('a');          // return false\n# streamChecker.query('b');          // return false\n# streamChecker.query('c');          // return false\n# streamChecker.query('d');          // return true, because 'cd' is in the\n# wordlist\n# streamChecker.query('e');          // return false\n# streamChecker.query('f');          // return true, because 'f' is in the\n# wordlist\n# streamChecker.query('g');          // return false\n# streamChecker.query('h');          // return false\n# streamChecker.query('i');          // return false\n# streamChecker.query('j');          // return false\n# streamChecker.query('k');          // return false\n# streamChecker.query('l');          // return true, because 'kl' is in the\n# wordlist\n#\n#\n#\n#\n# Note:\n#\n#\n# 1 <= words.length <= 2000\n# 1 <= words[i].length <= 2000\n# Words will only consist of lowercase English letters.\n# Queries will only consist of lowercase English letters.\n# The number of queries is at most\u00a040000.\n#\n#\n#\nimport collections\n\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.dic = collections.defaultdict(set)\n        self.s = ''\n        for w in words:\n            self.dic[w[-1]].add(w)\n\n    def query(self, letter):\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n\n\n# Your StreamChecker object will be instantiated and called as such:\nwords = [\\\"cd\\\", \\\"f\\\", \\\"kl\\\"]\nobj = StreamChecker(words)\nfor i in range(ord('a'), ord('l') + 1):\n    letter = chr(i)\n\n# param_1 = obj.query(letter)\n", "\n                \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self, words: List[str]):\n        self.trie = lambda: collections.defaultdict(self.trie)\n        self.root = self.trie()\n        \n        for w in words:\n            self.add(w[::-1])\n    \n    def add(self, s: str):\n        curr = self.root  \n        for c in s:\n            curr = curr[c]\n        curr['#']\n\n    def find(self, s: List[str]):\n        curr = self.root\n        for i in range(len(s) - 1, -1, -1):\n            val = s[i]\n            \n            if '#' in curr: \n                return True\n            elif val in curr: \n                curr = curr[val]\n            else:\n                return False\n            \n        return '#' in curr\n\n#just use a trie bro\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.queries = []\n        self.trie = Trie(words)\n        \n    def query(self, letter: str) -> bool:\n        self.queries.append(letter)\n        return self.trie.find(self.queries)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "#Trie\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        self.currentMatch = frozenset([self.root])\n    def insert(self, word):\n        cur = self.root\n        for i in range(len(word)):\n            idx = ord(word[i]) - ord('a')\n            if idx not in cur.children:\n                cur.children[idx] = TrieNode()\n            cur = cur.children[idx]\n        cur.isEnd = True\n    @lru_cache(None)\n    def matchNextChar(self, currentMatch, c):\n        idx = ord(c) - ord('a')\n        new_set = set([self.root])\n        found = False\n        for node in currentMatch:\n            if idx in node.children:\n                new_set.add(node.children[idx])\n                if node.children[idx].isEnd:\n                    found = True\n        return frozenset(new_set), found\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word)\n    def query(self, letter: str) -> bool:\n        match, found = self.trie.matchNextChar(self.trie.currentMatch, letter)\n        self.trie.currentMatch = match\n        return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n\n    def __init__(self):\n        self._nodes = [None for _ in range(26)]\n        self._isEnd = False\n\n    def add(self, word, idx):\n        if idx == len(word):\n            self._isEnd = True\n        else:\n            char_id = ord(word[idx]) - ord('a')\n            if self._nodes[char_id] is None:\n                self._nodes[char_id] = TrieNode()\n            self._nodes[char_id].add(word, idx+1)\n\n    def query(self, word, idx):\n        if self._isEnd is True:\n            return True\n        if idx == len(word):\n            return False\n        char_id = ord(word[idx]) - ord('a')\n        if self._nodes[char_id] is None:\n            return False\n        return self._nodes[char_id].query(word, idx+1)\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.node = TrieNode()\n        self.letters = \\\"\\\"\n        self.max_word_length = 0\n        for word in words:\n            self.max_word_length = max(self.max_word_length, len(word))\n            self.node.add(word[::-1], 0)\n\n    def query(self, letter: str) -> bool:\n        self.letters = (letter + self.letters)[:self.max_word_length]\n        return self.node.query(self.letters, 0)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class trieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isWord = False\n\nclass trie:\n    def __init__(self):\n        self.root = trieNode()\n    \n    def insert_reverse(self, word):\n        cp = self.root\n        for i in range(len(word) - 1, -1, -1):\n            index = ord(word[i]) - ord('a')\n            if not cp.children[index]:\n                cp.children[index] = trieNode()\n            cp = cp.children[index]\n        \n        cp.isWord = True\n    \n    def search(self, word):\n        cp = self.root\n        for ch in word:\n            index = ord(ch) - ord('a')\n            if not cp.children[index]:\n                return False\n            if cp.children[index].isWord:\n                return True\n            cp = cp.children[index]\n            \n        return cp.isWord\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tt = trie()\n        self.str = \\\"\\\"\n        self.maxlen = 0\n        for w in words:\n            self.tt.insert_reverse(w)\n            self.maxlen = max(self.maxlen, len(w))\n        \n    def query(self, letter: str) -> bool:\n        self.str += letter\n        word = self.str[::-1]\n        if self.maxlen < len(word):\n            word = word[:self.maxlen]\n\n        return self.tt.search(word)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker(object):\n\n    def __init__(self, words):\n        self.word_map, self.len_map, self.buffer = defaultdict(set), defaultdict(set), \\\"\\\"\n        for w in words:\n            self.word_map[w[-1]].add(w[::-1])\n            self.len_map[w[-1]].add(len(w))\n        \n\n    def query(self, letter):\n        self.buffer = letter + self.buffer\n        return any(len(self.buffer) >= l and self.buffer[:l] in self.word_map[letter] for l in self.len_map[letter])\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.trie = Trie()\n        for wrd in words:\n            self.trie.insert(wrd[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        node = self.trie.root\n        for ch in self.s[::-1]:\n            if ch in node.childs:\n                node = node.childs[ch]\n                if node.isWord:\n                    return True\n            else:\n                break\n        return False\n        \nclass TrieNode:\n    def __init__(self):\n        self.childs = {}\n        self.isWord = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        r = self.root\n        for ch in word:\n            r = r.childs.setdefault(ch, TrieNode())\n        r.isWord = True\n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    \n    def __init__(self):\n        \n        self.nodes = {}\n        self.is_word = False\n\n\nclass Trie:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert_word(self, word: str):\n        root = self.root\n        for c in word:\n            root = root.nodes.setdefault(c, TrieNode())\n        root.is_word = True\n\n    def contains_substr(self, word: str):\n        # Returns True if any beginning of word is contained in trie.\n        root = self.root\n        for c in word:\n            if c not in root.nodes:\n                break\n            root = root.nodes[c]\n            if root.is_word:\n                return True\n        return False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.prefix = \\\"\\\"\n        self.trie = Trie()\n\n        for word in words:\n            self.trie.insert_word(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.prefix += letter\n        return self.trie.contains_substr(self.prefix[::-1])", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        self.letters = ''\n        \n        for word in words:\n            self.insert(word)\n\n    def query(self, letter: str) -> bool:\n        self.letters += letter\n        curr = self.root\n        for i in range(len(self.letters)-1, -1, -1):\n            if curr.child[ord(self.letters[i])-ord('a')] == None:\n                return False\n            curr = curr.child[ord(self.letters[i])-ord('a')]\n            if curr.end:\n                return True\n        return False\n    \n    def insert(self, word):\n        curr = self.root\n        for i in range(len(word)-1, -1, -1):\n            c = word[i]\n            nextt = curr.child[ord(c)-ord('a')]\n            if nextt == None:\n                nextt = Trie()\n                curr.child[ord(c)-ord('a')] = nextt\n            curr = curr.child[ord(c)-ord('a')]\n        curr.end = True\n        \n\nclass Trie:\n    def __init__(self):\n        self.end = False\n        self.child = [None for i in range(26)]\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        \n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n        return False\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endNode = False\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.endNode = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        #self.Stream = deque()\n        self.Stream = \\\"\\\"\n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        #self.Stream.appendleft(letter)\n        self.Stream += letter\n        cur = self.trie.root\n        for c in self.Stream[::-1]:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.endNode:\n                    return True\n            else: \n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    \n    def __init__(self):\n        self.child = collections.defaultdict(TrieNode)\n        self.is_end = False\n        \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.last_k = collections.deque()\n        self.k = max(len(word) for word in words)\n        \n        for word in words:\n            self._insert(word[::-1])\n            \n    def _insert(self, word):\n        curr = self.root\n        for ch in word:\n            curr = curr.child[ch]\n        curr.is_end = True        \n\n    def query(self, letter: str) -> bool:\n        self.last_k.appendleft(letter)      \n        if len(self.last_k) > self.k:   # maintain a window size of k\n            self.last_k.pop()\n        \n        curr = self.root\n        for ch in self.last_k:\n            if ch not in curr.child:\n                return False\n            curr = curr.child[ch]\n            if curr.is_end:\n                return True\n        return curr.is_end\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie(words)\n        self.maxLen = len(max(words, key=lambda s: (len(s), s)))\n        self.queue = deque([])\n        \n    def query(self, letter: str) -> bool:\n        \n        if len(self.queue) >= self.maxLen:\n            self.queue.popleft()\n            \n        self.queue.append(letter)\n        \n        # for i in range(len(self.queue)-1, -1, -1):\n        if self.trie.findWord(self.trie.store, len(self.queue)-1, ''.join(self.queue)):\n            return True\n            \n        return False\n            \n        \n\nclass Trie:\n    def __init__(self, words):\n        self.store = {}\n        for w in words:\n            self.insertWord(self.store, len(w)-1, w)\n        \n    def insertWord(self, trie, p, w):\n        if p < 0:\n            return\n\n        if w[p] not in trie:\n            trie[w[p]] = {}\n            \n        self.insertWord(trie[w[p]], p-1, w)\n\n        if p == 0:\n            trie[w[p]]['$'] = True\n            \n    def findWord(self, trie, p, w):\n        if p < 0 or w[p] not in trie:\n            return False\n        \n        if '$' in trie[w[p]]:\n            return True\n        \n        isAvail = False\n        \n        if w[p] in trie:\n            isAvail = self.findWord(trie[w[p]], p-1, w)\n        \n        return isAvail\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self,c):\n        self.c=c\n        self.childs=[None for i in range(26)]\n        self.end=False\nclass Trie:\n    def __init__(self):\n        self.root=None\n        self.p=[]\n        \n    def insert(self,word):\n        if(self.root==None):\n            self.root=Node('#')\n        r=self.root\n        for i in word[::-1]:\n            if(r.childs[ord(i)-97]==None):\n                r.childs[ord(i)-97]=Node(i)\n            r=r.childs[ord(i)-97]\n        r.end=True\n        \n    def search(self,word):\n        if(self.root==None):\n            return False\n        r=self.root\n        for i in word[::-1]:\n            if r.childs[ord(i)-97]!=None:\n                r=r.childs[ord(i)-97]\n            else:\n                return False\n            if(r.end):\n                return True\n        return False\n    \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tree=Trie()\n        self.s=''\n        for word in words:\n            self.tree.insert(word)\n\n    def query(self, letter: str) -> bool:\n        self.s+=letter\n        return self.tree.search(self.s)\n    \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.wordSet=set(words)\n        lSet=set()\n        self.lastL=set()\n        for word in words:\n            lSet.add(len(word))\n            self.lastL.add(word[-1])\n        self.l=list(lSet)\n        self.l.sort()\n        self.q=''\n        \n    def query(self, letter: str) -> bool:\n        self.q=self.q+letter\n        \n        if letter in self.lastL:\n            for i in range(len(self.l)):\n                if self.l[i]>len(self.q):\n                    break\n                elif self.q[-self.l[i]:] in self.wordSet:\n                    return True\n        return False\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n", "class Trie():\n    def __init__(self):\n        self.isWord = False\n        self.children = {}\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.StreamChecker = Trie()\n        self.stack = []\n        for word in words:\n            self.insert(word)\n        \n    def query(self, letter: str) -> bool:\n        self.stack.insert(0,letter)\n        node = self.StreamChecker\n        for char in self.stack:\n            if node.isWord == True:\n                return True\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        if node.isWord == True:\n            return True\n        else:\n            return False\n    \n    def insert(self, word):\n        node = self.StreamChecker\n        word = word[::-1]\n        for letter in word:\n\n            if letter not in node.children:\n                node.children[letter] = Trie()\n            node = node.children[letter]\n        node.isWord = True\n            \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\nclass TrieNode:\n    def __init__(self, val):\n        self.end = False\n        self.children = {}\n        \nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode(-1)\n    \n    def add(self, word):\n        root = self.root\n        for idx, ch in enumerate(word):\n            children = root.children\n            if children.get(ch) == None:\n                child = TrieNode(ch)\n                children[ch] = child\n                root = child\n            else:\n                root = children[ch]\n                \n            if idx == len(word)-1:\n                root.end = True\n    \n    def search(self, word):\n\n        root = self.root\n        for idx, val in enumerate(word):\n            if root.children.get(val) == None:\n                return False\n            else:\n                root = root.children[val]\n                if root.end:\n                    return True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # self.words = set(words)\n        self.Trie = Trie()\n        self.maxlen = -1\n        for w in words:\n            self.maxlen = max(self.maxlen, len(w))\n            rev = w[::-1]\n            self.Trie.add(rev)\n        self.searchArr = deque()\n        \n\n    def query(self, letter: str) -> bool:\n\n        self.searchArr.insert(0, letter)\n        if len(self.searchArr) > self.maxlen:\n            self.searchArr.pop()\n\n        tmpWord = \\\"\\\".join(self.searchArr)    \n        return self.Trie.search(tmpWord)\n#             return True        \n\n#         return False    \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dict={}\n        for word in words:\n            if word[-1] not in self.dict:\n                self.dict[word[-1]]=[word[:-1]]\n            else:\n                self.dict[word[-1]].append(word[:-1])\n        self.string=\\\"\\\"\n    def query(self, letter: str) -> bool:\n        self.string+=letter\n        #print(self.dict)\n        if letter in self.dict:\n            for word in self.dict[letter]:\n                length=len(word)+1\n                complete_word=word+letter\n                if len(self.string)>=length and complete_word==self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.end = False\n\nclass Trie:\n    def __init__(self, words):\n        self.root = TrieNode()\n        for word in words:\n            self.add(word[::-1])\n        self.word = ''\n        self.l = max(len(word) for word in words)\n    \n    def add(self, word):\n        node = self.root\n        for c in word:\n            node = node.children[c]\n        node.end = True\n    \n    def search(self, c):\n        self.word = (c + self.word)[:self.l]\n        node = self.root\n        for c in self.word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n            if node.end:\n                return True\n        \n        return False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie(words)\n\n    def query(self, letter: str) -> bool:\n        return self.trie.search(letter)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.d={}\n        for i in words:\n            if(i[-1] not in self.d):\n                self.d[i[-1]]=[i[:-1]]\n            else:\n                self.d[i[-1]].append(i[:-1])\n                \n        self.s=''\n    def query(self, letter: str) -> bool:\n        self.s+=letter\n        if letter in self.d:\n            for i in self.d[letter]:\n                word=i+letter\n                if len(self.s)>=len(word) and word==self.s[-len(word):]:\n                    return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        from collections import defaultdict\n        self.word = sorted(words, key = lambda x: (x[-1], len(x)))\n        self.lett = \\\"\\\"\n        self.d = defaultdict(str)\n        for i in range(1, len(self.word) + 1):\n            if not self.d[self.word[i - 1][-1]]:\n                self.d[self.word[i - 1][-1]] = i   \n                \n\n    def query(self, letter: str) -> bool:\n        self.lett += letter\n        if not letter in self.d:\n            return False\n        begin = self.d[letter] - 1       \n        \n        for i in self.word[begin:]:\n            if len(self.lett) < len(i):\n                return False\n            if i[-1] != letter:\n                return False\n            if self.lett[-len(i):] == i:\n                return True\n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.cache = dict()\n        for word in words:\n            if word[-1] not in self.cache:\n                self.cache[word[-1]] = [word[:-1]]\n            else:\n                self.cache[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.cache:\n            for word in self.cache[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie={}\n        node=self.trie\n        for i in words:\n            for ch in i[::-1]:\n                if ch not in node:\n                    node[ch]={}\n                node=node[ch]\n            node['$']=True\n            node=self.trie\n        self.stream=''\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream+=letter\n        node=self.trie\n        def check(s,node):\n            if '$' in node:\n                return True\n            for ch in s:\n                if ch in node:\n                    return check(s[1:],node[ch])\n                else:\n                    return False\n        return check(self.stream[::-1],node)\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker(object):\n\n# class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = {}\n        self.words = set()\n        words_ = [word[::-1] for word in words]\n        for word in words_:\n            for i in range(len(word)-1):\n                self.memo[word[:i+1]]=0\n        \n        for word in words_:\n            self.memo[word]=1\n        \n        self.hist = []\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.insert(0,letter)\n        w = ''\n        for i in range(len(self.hist)):\n            w+=self.hist[i]\n            #print(w)\n            c = self.memo.get(w,None)\n            if c is None:\n                return False\n            if c:\n                return True\n            \n        return False\n\n", "class node:\n    def __init__(self):\n        self.child=[None]*26\n        self.end=False\nclass trie:\n    def __init__(self):\n        self.q=node()\n    def insert(self,sen):\n        sen=sen[::-1]\n        p=self.q\n        for x in sen:\n            if p.child[ord(x)-ord('a')]==None:\n                p.child[ord(x)-ord('a')]=node() \n            p=p.child[ord(x)-ord('a')]\n        p.end=True\nclass StreamChecker:\n   \n    def __init__(self, words: List[str]):\n        self.p1=trie()\n        self.s=\\\"\\\"\n        for x in words:\n            self.p1.insert(x)\n            \n    def query(self, letter: str) -> bool:\n        self.s+=letter\n        root=self.p1.q\n        #ind=ord(letter)-ord('a')\n        for x in self.s[::-1]:\n            ind=ord(x)-ord('a')\n            root=root.child[ind]\n            if root!=None:\n                if root.end==True: \n                    return True\n            else:\n                break\n\n        return False \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n\n        for word in set(words):\n            node = self.trie       \n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n        \n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        Trie = lambda: collections.defaultdict(Trie)\n        self.trie = Trie()\n        for word in words:\n            reduce(dict.__getitem__, word[::-1] + \\\"$\\\", self.trie)\n        self.queries = []\n\n    def query(self, letter: str) -> bool:\n        self.queries.append(letter)\n        curr = self.trie\n        #print(\\\"query\\\")\n        for i in range(len(self.queries)-1, -1, -1):\n            c = self.queries[i]\n            if \\\"$\\\" in curr:\n                return True\n            if c not in curr:\n                return False\n            curr = curr[c]\n        return \\\"$\\\" in curr\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self):\n        self.children = {}\n        self.stop = False\n        \nclass Trie:\n    def __init__(self):\n        self.word = Node()\n    \n    def insert(self, word):\n        word = word[::-1]\n        curr = self.word\n        for l in word:\n            node = curr.children.get(l, Node())\n            curr.children[l] = node\n            curr = node\n        curr.stop = True\n\n    \n    def search(self, word):\n        curr = self.word\n        \n        for l in word:\n            node = curr.children.get(l, None)\n            \n            if not node:\n                return False\n            elif node.stop:\n                return True\n            curr = node\n        return curr.stop\n    \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        for word in words:\n            self.t.insert(word)\n        self.pointer = ''\n\n    def query(self, letter: str) -> bool:\n        self.pointer += letter\n\n        return self.t.search(self.pointer[::-1])\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.Queries=''\n        self.Words=defaultdict(list)\n        for w in words:\n            self.Words[w[-1]].append(w)\n\n    def query(self, letter: str) -> bool:\n        self.Queries+=letter\n        if len(self.Queries)>2000:\n            self.Queries=self.Queries[1:]    \n        for k in self.Words[letter]:\n            i=len(k)\n            if i<=len(self.Queries):\n                if self.Queries[-i:]==k:\n                  return True\n        return False\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.wordSet=set(words)\n        lSet=set()\n        self.lastL=set()\n        for word in words:\n            lSet.add(len(word))\n            self.lastL.add(word[-1])\n        self.l=list(lSet)\n        self.l.sort()\n        self.q=''\n        \n    def query(self, letter: str) -> bool:\n        self.q=self.q+letter\n        \n        if letter in self.lastL:\n            for i in range(len(self.l)):\n                if self.l[i]>len(self.q):\n                    break\n                elif self.q[-self.l[i]:] in self.wordSet:\n                    return True\n        return False\n        \n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "\nclass Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.endOfWord = False\n    def insert(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord(\\\"a\\\")] == None:\n                t.children[ord(c)-ord(\\\"a\\\")] = Trie()\n            t = t.children[ord(c)-ord(\\\"a\\\")]\n        t.endOfWord = True\n    \n    def search(self, s):\n        t = self\n        for c in s:\n            if t.children[ord(c)-ord(\\\"a\\\")] == None:\n                return False\n            t = t.children[ord(c)-ord(\\\"a\\\")]\n            if t.endOfWord:\n                return True\n        return False\n    \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        self.stream = collections.deque()\n        for w in words:\n            self.t.insert(reversed(w))\n            \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.t.search(self.stream)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie={}\n        # self.min=40000\n        self.searchWord=''\n        for word in words:\n            word=word[::-1]\n            # self.min=len(word) if len(word)<self.min else self.min\n            self.insertToTrie(self.trie, word)\n            \n    def insertToTrie(self, trie, word):\n        if word[0] not in trie:\n            trie[word[0]] = {\\\"value\\\":{}, \\\"isLast\\\":len(word)==1}\n        if len(word)==1:\n            trie[word[0]][\\\"isLast\\\"] = True\n            return\n        self.insertToTrie(trie[word[0]][\\\"value\\\"], word[1:])\n            \n    def searchForWord(self, trie, word):\n        if not word or word[0] not in trie:\n            return False\n        if trie[word[0]][\\\"isLast\\\"]:\n            return True\n        return self.searchForWord(trie[word[0]][\\\"value\\\"], word[1:])\n\n    def query(self, letter: str) -> bool:\n        # if(self.min):\n        #     self.min-=1\n        #     return False\n        self.searchWord = letter + self.searchWord\n        result = self.searchForWord(self.trie, self.searchWord)\n        return result\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.isWord = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def add(self,word):\n        cur = self.root\n        for c in word:\n            if cur.children[ord(c)-ord('a')] == None:\n                cur.children[ord(c)-ord('a')] = TrieNode()\n            cur = cur.children[ord(c)-ord('a')]\n        cur.isWord = True\n        \n    def search(self,word):\n        \n        \n            \n        #return self.root.children[ord(word[0]) - ord('a')]\n        \n        return self.__searchHelper(self.root,word,0)\n\n    def __searchHelper(self,cur,word,word_index):\n        # \u63d0\u524d\u7ec8\u6b62: word\u7684\u4e00\u90e8\u5206\u5df2\u7ecf\u5339\u914d\u5230\u4e86Trie\n        if cur.isWord:\n            return True\n        \n        # \u91cd\u70b94: \u6700\u7ec8\u6258\u5e95: \u8fc7\u4e86\u4e00\u904dword\n        if len(word) == word_index:\n            return cur.isWord\n        \n        \n        \n        \n        char = word[word_index]\n        temp = cur.children[ord(char)-ord('a')]\n        \n        return temp != None and self.__searchHelper(temp,word,word_index+1)\n        \n            \n        \n        \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.storage = Trie()\n        self.prefix = ''\n        # \u91cd\u70b91: \u5b58\u7684\u65f6\u5019 \u5012\u7740\u5b58\n        for word in words:\n            self.storage.add(word[::-1])\n        \n        \n    def query(self, letter: str) -> bool:\n        # \u91cd\u70b92: nonlocal stream word\n        self.prefix += letter\n        # \u91cd\u70b93: \u641c\u7684\u65f6\u5019 \u5012\u7740\u641c\n        return self.storage.search(self.prefix[::-1])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self):\n        self.kids = collections.defaultdict(Node)\n        self.end = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        self.s = \\\"\\\"\n        for word in words:\n            t = self.root\n            for w in word[::-1]:\n                t = t.kids[w]\n            t.end = True\n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        def dfs(t, word):\n            for w in word:\n                if w not in t.kids:\n                    return False\n                t = t.kids[w]\n                if t.end:\n                    return True\n            return False\n        return dfs(self.root, self.s[::-1])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        from collections import deque\n        self.stream = deque()\n        self.trie = {\\\"_\\\": False}\n        self.max_stream_size = 0\n        for word in words:\n            self.max_stream_size = max(self.max_stream_size, len(word))\n            node = self.trie\n            for char in word[::-1]:\n                if char not in node:\n                    node[char] = {\\\"_\\\": False}\n                node = node[char]\n            node[\\\"_\\\"] = True\n        #print(self.trie)\n\n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        if len(self.stream) > self.max_stream_size:\n            self.stream.popleft()\n        \n        node = self.trie\n        #print(node)\n        #print(self.stream)\n        for idx in range(len(self.stream)-1, -1, -1):\n            if node[\\\"_\\\"]:\n                return True\n            char = self.stream[idx]\n            if char not in node:\n                return node[\\\"_\\\"]\n            node = node[char]\n        #print(self.stream)\n        return node[\\\"_\\\"]\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict()\n        self.terminating = False\n        \nclass Trie():\n    def __init__(self):\n        self.root = self.get_node()\n    def get_node(self):\n        return TrieNode()\n    def get_index(self, ch):\n        return ord(ch) - ord('a')\n    def insert(self, word):\n        root = self.root\n        len1 = len(word)\n        for i in range(len1):\n            index = self.get_index(word[i])\n            if index not in root.children:\n                root.children[index] = self.get_node()\n            root = root.children.get(index)\n        root.terminating = True\n    def search(self, word):\n        root = self.root\n        len1 = len(word)\n        for i in range(len1):\n            index = self.get_index(word[i])\n            \n            if not root: return False\n            if root.terminating: return True\n            root = root.children.get(index)\n        return True  if root and root.terminating else False\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.ch=\\\"\\\"\n        for word in words: self.trie.insert(word[::-1])\n        \n    def query(self, letter: str) -> bool:\n        self.ch +=letter\n        if len(self.ch)>2000:\n            self.ch = self.ch[1:]\n        return self.trie.search(self.ch[::-1])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.st = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n\n    def query(self, letter: str) -> bool:\n        self.st += letter\n        return any(self.st.endswith(w) for w in self.dic[letter])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = [None]*26\n        self.isWord = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def add(self,word):\n        cur = self.root\n        for c in word:\n            if cur.children[ord(c)-ord('a')] == None:\n                cur.children[ord(c)-ord('a')] = TrieNode()\n            cur = cur.children[ord(c)-ord('a')]\n        cur.isWord = True\n        \n    def search(self,word):\n        \n        \n            \n        #return self.root.children[ord(word[0]) - ord('a')]\n        \n        return self.__searchHelper(self.root,word,0)\n\n    def __searchHelper(self,cur,word,word_index):\n        if len(word) == word_index:\n            return cur.isWord\n        if cur.isWord:\n            return True\n        \n        \n        char = word[word_index]\n        temp = cur.children[ord(char)-ord('a')]\n        \n        return temp != None and self.__searchHelper(temp,word,word_index+1)\n        \n            \n        \n        \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.storage = Trie()\n        self.prefix = ''\n        \n        for word in words:\n            self.storage.add(word[::-1])\n        \n        \n    def query(self, letter: str) -> bool:\n        self.prefix += letter\n        return self.storage.search(self.prefix[::-1])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    from collections import deque\n    def __init__(self, words: List[str]):\n        self.max = len(max(words, key=len))\n        self.words = tuple(words)\n        self.letters = deque(maxlen=self.max)\n        \n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        l = ''.join(self.letters)\n        return l.endswith(self.words)\n    \n    \n    '''\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.letters = ''\n        self.fragments = {}\n        for w in words:\n            temp = self.fragments\n            for i in range(len(w)):\n                sec = w[len(w)-1-i:]\n                if sec not in temp:\n                    temp[sec] = {}\n                temp = temp[sec]\n                    \n    def query(self, letter: str) -> bool:\n        self.letters += letter\n        chars = self.letters\n        \n        temp = self.fragments\n        for i in range(len(chars)):\n            sec = chars[len(chars) - 1 - i:]\n            if sec in self.words:\n                return True\n            if sec not in temp:\n                return False\n            temp = temp[sec]\n    '''\n    '''\n    def __init__(self, words: List[str]):\n        self.words = tuple(words)\n        self.letters = ''\n        \n    def query(self, letter: str) -> bool:\n        self.letters +=letter\n        return self.letters.endswith(self.words)        \n    '''\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self):\n        self.isEnd = False\n        self.next = {}\n    def __repr__(self):\n        return str(self.next)\n        \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}        \n        for word in words:\n            self.add(self.dic, word[::-1])\n        print(self.dic)\n        self.validLetters = \\\"\\\"\n        \n    def add(self, dic, word):\n        currentLetter = word[0]\n        if currentLetter not in dic.keys():\n            dic[currentLetter] = Node()\n        if len(word) != 1:\n            self.add(dic[currentLetter].next, word[1:])\n        else:\n            dic[currentLetter].isEnd = True\n            \n    def __partial_query(self, dic, word):\n        currentLetter = word[0]\n        if currentLetter not in dic.keys():\n            return False\n        else:\n            if dic[currentLetter].isEnd:\n                return True\n            else:\n                if len(word) != 1:\n                    return self.__partial_query(dic[currentLetter].next, word[1:])\n                else:\n                    return False\n            \n    def partial_query(self, word):\n        return self.__partial_query(self.dic, word)\n        \n\n    def query(self, letter: str) -> bool:\n        self.validLetters = letter + self.validLetters\n        return self.partial_query(self.validLetters)\n                \n\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.d = collections.defaultdict(set)\n        for w in words:\n            self.d[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.d[letter])\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self, val=None, is_end=False):\n        self.child = dict()\n        self.val = val\n        self.is_end = is_end\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        for w in words:\n            tmp = self.root\n            for l in w[::-1]:\n                if l not in tmp.child:\n                    tmp.child[l] = Node(val=l)\n                tmp = tmp.child[l]\n            tmp.is_end = True\n        self.q = []\n    def query(self, letter: str) -> bool:\n        if len(self.q) >= 2000:\n            self.q.pop(0)\n        self.q.append(letter)\n        tmp = self.root\n        for i in self.q[::-1]:\n            if i not in tmp.child:\n                return False\n            tmp = tmp.child[i]\n            if tmp.is_end:\n                return True\n        return tmp.is_end\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words):\n        self.buffer = \\\"\\\"\n        self.tree = {}\n        self.null = '\\\\0'\n        for w in words:\n            self.insert(w[::-1])\n\n\n    def query(self, letter):\n        self.buffer = letter + self.buffer\n        curr = self.tree\n        for c in self.buffer:\n            if c in curr:\n                curr = curr[c]\n                if self.null in curr:\n                    return True\n            else:\n                break\n        return False\n\n    def insert(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        \\\"\\\"\\\"\n        tree = self.tree\n        for c in word:\n            if c not in tree:\n                tree[c] = {}\n            tree = tree[c]\n        tree[self.null] = {}\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "import collections\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = collections.defaultdict(list)\n        self.characters = ''\n        for word in words:\n            self.words[word[-1]].append(word)\n\n    def query(self, letter: str) -> bool:\n        self.characters += letter\n        for word in self.words[letter]:\n            length = len(word)\n            if self.characters[-length:] == word:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = {}\n        for w in words:\n            if len(w) not in list(self.words.keys()):\n                self.words[len(w)] = []\n            self.words[len(w)].append(w)\n            \n        self.buffer = '';\n        self.i = 0\n        self.max = (max(list(self.words.keys())))\n        self.res = {}\n\n    def query(self, letter: str) -> bool:\n        self.buffer += letter;\n        if len(self.buffer)>self.max:\n            self.buffer = self.buffer[-self.max:]\n        \n        \n        #print(self.buffer)\n        if self.buffer in list(self.res.keys()):\n            return self.res[self.buffer]\n        #print(self.buffer, 'checa')\n        if len(self.buffer) not in list(self.words.keys()):\n            return False\n        \n        #print(self.buffer, 'checa2')\n        for i in self.words:\n            if len(self.buffer) >= i and self.buffer[-i:] in self.words[i]:\n                self.res[self.buffer] = True\n                return True\n        \n        self.res[self.buffer] = False\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s.endswith(w) for w in self.dic[letter])\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.mDict = defaultdict(list)\n        for word in words:\n            self.mDict[word[-1]].append(word[:-1])\n        self.currStr = \\\"\\\"\n    def query(self, letter: str) -> bool:\n        self.currStr += letter\n        if letter in self.mDict:\n            for curr in self.mDict[letter]:\n                length = len(curr)+1\n                if len(self.currStr) >= length and  (curr+letter) == self.currStr[-length:]:\n                    return True\n            return False\n        else:#No word so far ending in this letter\n            return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TreeNode:\n    def __init__(self):\n        self.dict = defaultdict(TreeNode)\n        self.result = False\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.tree = TreeNode()\n        self.text = ''\n        for word in words:\n            curr = self.tree\n            for c in word[::-1]:                \n                curr = curr.dict[c]\n            curr.result = True\n            \n    def query(self, letter: str) -> bool:\n        self.text += letter\n        curr = self.tree\n        for c in self.text[::-1]:\n            if c not in curr.dict:\n                break\n            curr = curr.dict[c]\n            if curr.result:\n                return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dictionary = {}\n        for word in words:\n            last_letter = word[-1]\n            if last_letter not in self.dictionary:\n                self.dictionary[last_letter] = [word]            \n            else:\n                self.dictionary[last_letter].append(word)\n        self.queries =''\n            \n    def query(self, letter: str) -> bool:\n        self.queries += letter\n        if letter not in self.dictionary:\n            return False\n        else:\n            for word in self.dictionary[letter]:\n                length = len(word)\n                if self.queries[-length:] == word:\n                    return True\n            return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.is_word = False\n        self.children = collections.defaultdict(TrieNode)\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        if not words: return False\n        self.root = TrieNode()\n        for word in words:\n            self.addNode(word[::-1])\n        self.buff = []\n        self.maxl = len(max(words, key = lambda x: len(x)))\n        \n\n    def query(self, letter: str) -> bool:\n        self.buff.append(letter)\n        s = \\\"\\\"\n        for i in range(len(self.buff) - 1, -1, -1):\n            s += self.buff[i]\n            if len(s) > self.maxl: \n                break\n            print(s)\n            res = self.findWord(s)\n            if not res: return False\n            if res.is_word: return True\n        return False\n            \n        \n    def addNode(self, word):\n        p = self.root\n        for w in word:\n            if not p.children.get(w):\n                p.children[w] = TrieNode()\n            p = p.children[w]\n        p.is_word = True\n    \n    def findWord(self,word):\n        p = self.root\n        for w in word:\n            if not p.children.get(w):\n                return False\n            p = p.children[w]\n            \n        return p\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__ (self):\n        self.kids = {}\n        self.isWord = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.q = collections.deque(maxlen = max(len(x) for x in words))\n        self.root = TrieNode()\n        for x in words:\n            cur = self.root\n            for c in x[::-1]:\n                if c not in cur.kids:\n                    cur.kids[c] = TrieNode()\n                cur = cur.kids[c]\n                if cur.isWord:\n                    break\n            cur.isWord = True\n\n    def query(self, letter: str) -> bool:\n        def helper(word):\n            cur = self.root\n            for c in word:\n                if c in cur.kids:\n                    cur = cur.kids[c]\n                    if cur.isWord:\n                        return True\n                else:\n                    return False\n            return False\n            \n        self.q.appendleft(letter)\n        cur = self.root\n        for c in self.q:\n            if c in cur.kids:\n                cur = cur.kids[c]\n                if cur.isWord:\n                    return True\n            else:\n                return False\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker2:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self._m = set([])\n\n    def query(self, letter: str) -> bool:\n        exists = False\n        updated_list = set([])\n        for ind, word in enumerate(self.words):\n            if letter == word:\n                exists = True\n            if letter == word[0] and len(word) > 1:\n                updated_list.add((0, ind))\n        for ind, wi in list(self._m):\n            if letter == self.words[wi][ind+1:]:\n                exists = True\n            elif letter == self.words[wi][ind+1] and len(self.words[wi][ind+1:]) > 1:\n                updated_list.add((ind+1, wi))\n        self._m = updated_list\n        return exists\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s=''\n        self.di = collections.defaultdict(set)\n        for w in words:\n            self.di[w[-1]].add(w)\n\n    def query(self, letter: str) -> bool:\n        self.s+=letter\n        return any(self.s.endswith(w) for w in self.di[letter])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False", "from collections import defaultdict\n\nclass Trie:\n    def __init__(self):\n        self.children = defaultdict(Trie)\n        self.is_word = False\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.stream = ''\n        self.trie = Trie()\n        \n        for word in words:\n            curr = self.trie\n            for ch in word[::-1]:\n                curr = curr.children[ch]\n            curr.is_word = True\n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        curr = self.trie\n        \n        for ch in self.stream[::-1]:\n            if ch not in curr.children:\n                return False\n            \n            curr = curr.children[ch]\n            \n            if curr.is_word:\n                return True\n        \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic={}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode():\n    def __init__(self):\n        self.child = collections.defaultdict(TrieNode)\n        self.isWord = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.res = []\n        for word in words:\n            self.add(word)\n        \n\n    def query(self, letter: str) -> bool:\n        curr = self.root\n        self.res.insert(0,letter)\n        for char in self.res:\n            if curr.isWord:\n                return True\n            if not curr.child.get(char):\n                return False\n            curr = curr.child[char]\n        return curr.isWord\n    \n    def add(self,word):\n        curr = self.root\n        for char in word[::-1]:\n            curr = curr.child[char]\n        curr.isWord = True\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\nclass Trie:\n    def __init__(self):\n        self.last_nodes = {}\n\n    def add(self, word):\n        last_char = word[-1]\n        word_len = len(word)\n        if last_char in self.last_nodes:\n            if word_len in self.last_nodes[last_char]:\n                self.last_nodes[last_char][word_len].add(word)\n            else:\n                self.last_nodes[last_char][word_len] = set([word])\n        else:\n            self.last_nodes[last_char] = {word_len: set([word])}\n    \n    def smart_search(self, word):\n        last_char = word[-1]\n        if last_char in self.last_nodes:\n            for word_len in range(1, len(word) + 1):\n                if word_len in self.last_nodes[last_char] and\\\\\n                        word[-word_len:] in self.last_nodes[last_char][word_len]:\n                    return True\n        return False\n                    \n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.max_size = 0\n        self.cache = deque()\n        \n        for word in words:\n            self.trie.add(word)\n            self.max_size = max(len(word), self.max_size)\n\n    def query(self, letter: str) -> bool:\n        self.cache.append(letter)\n        if len(self.cache) > self.max_size:\n            self.cache.popleft()\n\n        return self.trie.smart_search(''.join(self.cache))\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n  def __init__(self, words):\n    self.trie = {}\n    for word in words:\n      self.add(word)\n  \n  def add(self, word):\n    def add_helper(prev, i):\n      if i == len(word) - 1:\n        prev[word[i]] = {None: None}\n        return\n      \n      char = word[i]\n      if char not in prev:\n        prev[char] = {}\n      add_helper(prev[char], i + 1)\n    add_helper(self.trie, 0)\n    \n  def contains(self, word):\n    def dfs(prev, i):\n      if i == len(word):\n        return False\n      if word[i] in prev and None in prev[word[i]]:\n        return True\n      \n      return dfs(prev[word[i]], i + 1) if word[i] in prev else False\n    return dfs(self.trie, 0)\n      \n\nclass StreamChecker:\n\n  def __init__(self, words: List[str]):\n    self.trie = Trie([''.join(reversed(w))for w in words])\n    self.word = ''\n\n  def query(self, letter: str) -> bool:\n    self.word = ''.join([letter, self.word])\n    return self.trie.contains(self.word)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque, defaultdict\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        words = sorted(words, key=len)\n        self.words_by_len = defaultdict(set)\n        for word in words:\n            if all(word[-length:] not in words_set for length, words_set in list(self.words_by_len.items())):\n                self.words_by_len[len(word)].add(word)\n        \n        self.search_history = deque(maxlen=max(self.words_by_len.keys()))\n\n    def query(self, letter: str) -> bool:\n        self.search_history.append(letter)\n        history = ''.join(self.search_history)\n        \n        return any(history[-length:] in words_set for length, words_set in list(self.words_by_len.items()))\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n            \n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.endOfWord=False\n        self.children={}\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie=TrieNode()\n        self.stream=collections.deque()\n        for word in words:\n            node=self.trie\n            for c in word[::-1]:\n                if not c in node.children:\n                    childNode=TrieNode()\n                    node.children[c]=childNode\n                node=node.children[c]\n            node.endOfWord=True\n       \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node=self.trie\n        for c in self.stream: # we treat the stream like a stack, as we start reading it from the last insertion point.\n            if not c in node.children:\n                return False\n            node=node.children[c]\n            if node.endOfWord:\n                return True\n        return False\n\n\n    #solution 2 a bit different trie implementation\n'''\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie={}\n        self.stream=collections.deque()\n        for word in words:\n            node=self.trie\n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch]={}\n                node=node[ch]\n            node['$']=word\n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node=self.trie\n        for c in self.stream:\n            if '$' in node:\n                return True\n            if not c in  node:\n                return False\n            node=node[c]\n        #print('$' in node)\n        return '$' in node\n'''\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.max_len = max((len(x) for x in self.words), default=0)\n        self.q = ''\n        self.num_end = min(1, self.max_len)\n        self.ends = {}\n        for i in range(1, self.num_end + 1):\n            self.ends[i] = set(x[-i:] for x in self.words if len(x) >= i)\n        # print(self.ends)\n        \n\n    def query(self, letter: str) -> bool:\n        self.q += letter\n        if len(self.q) > self.max_len:\n            self.q = self.q[1:]\n        for i in range(1, self.num_end + 1):\n            # print(i, self.q[-i:])\n            if self.q[-i:] not in self.ends[i]:\n                return False\n        # print('cont', i, self.q)\n        for i in range(0, self.max_len):\n            # print(~i, self.q[~i:])\n            if self.q[~i:] in self.words:\n                # print(self.q[~i:])\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.wordEndsHere = False\n        self.children = dict()\n        \n    def addWord(self, word):\n        if not word:\n            self.wordEndsHere = True\n        else:\n            if word[0] not in self.children:\n                self.children[word[0]] = Trie()\n            self.children[word[0]].addWord(word[1:])\n    \n    def findWord(self, word):\n        if self.wordEndsHere:\n            return True\n        \n        if not word:\n            return self.wordEndsHere\n        elif word[0] not in self.children:\n            return False\n        else:\n            return self.children[word[0]].findWord(word[1:])\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.maxLength = 0\n        self.letters = []\n        self.trie = Trie()\n        \n        for w in words:\n            self.trie.addWord(w[::-1])\n            self.maxLength = max(self.maxLength, len(w))\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        sliceLength = min(len(self.letters), self.maxLength)\n        target = ''.join(self.letters[(len(self.letters) - sliceLength):])[::-1]\n        return self.trie.findWord(target)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = {}\n        self.words = set()\n        words_ = [word[::-1] for word in words]\n        for word in words_:\n            for i in range(len(word)-1):\n                self.memo[word[:i+1]]=0\n        \n        for word in words_:\n            self.memo[word]=1\n        \n        self.hist = []\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.insert(0,letter)\n        for i in range(len(self.hist)):\n            #print(w)\n            c = self.memo.get(''.join(self.hist[:i+1]),None)\n            if c is None:\n                return False\n            if c:\n                return True\n            \n        return False\n\n", "# from functools import reduce\nfrom collections import deque, defaultdict\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.stream = ''\n        self.letters, self.end_letter = self.prep()\n\n    def prep(self):\n        letters = set()\n        end_letter = defaultdict(list)\n        # self.words.sort(key=lambda x: len(x))\n        for i, word in enumerate(self.words):\n            letters = letters.union(set(word))\n            end_letter[word[-1]].append(i)\n        return letters, end_letter\n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        if letter not in self.letters:\n            return False\n        for i in self.end_letter.get(letter, []):\n            # if len(self.stream) < len(self.words[i]):\n            #     return False\n            if self.stream[-len(self.words[i]):] == self.words[i]:\n                return True\n        return False", "\n#5:58\nclass TrieNode:\n    def __init__(self):\n        self.val = 0\n        self.children = [None]*26\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def addWord(self, word):\n        curr = self.root\n        for char in word:\n            if curr.children[ord(char) - ord('a')] is None:\n                curr.children[ord(char) - ord('a')] = TrieNode()\n            curr = curr.children[ord(char) - ord('a')]\n        curr.val = 1\n        \n    def searchWord(self, word):\n        curr = self.root\n        for char in word:\n            if curr.children[ord(char) - ord('a')] is None:\n                return False\n            curr = curr.children[ord(char) - ord('a')]\n            if curr.val == 1:\n                return True\n        return False\n        \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        max_len = 0\n        for word in words:\n            max_len = max(max_len, len(word))\n            self.trie.addWord(\\\"\\\".join([x for x in reversed(word)]))\n        self.query_text = \\\"\\\"\n        self.max_len = max_len\n\n    def query(self, letter: str) -> bool:\n        self.query_text += letter\n        if len(self.query_text) >self.max_len:\n            self.query_text = self.query_text[1:]\n        reversed_query = \\\"\\\".join([x for x in reversed(self.query_text)])\n        return self.trie.searchWord(reversed_query)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = ''\n        self.l = max([len(w) for w in words])\n        self.dic = collections.defaultdict(set)\n        for w in words:\n            self.dic[w[-1]].add(w)\n                \n\n    def query(self, letter: str) -> bool:\n        self.s += letter\n        return any(self.s[-1*self.l:].endswith(w) for w in self.dic[letter])", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.chars = \\\"\\\"\n        self._last_letters = set(w[-1] for w in words)\n        \n    def query(self, letter: str) -> bool:\n        self.chars += letter\n        if letter not in self._last_letters:\n            return False\n        return any(self.chars.endswith(w) for w in self.words)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tries = [False, [[] for _ in range(26)]]\n        for word in words:\n            self.build(word[::-1])\n        self.stream = ''\n            \n    def build(self, word):\n        temp_level = self.tries\n        for c in word:\n            if len(temp_level[1][ord(c) - ord('a')]) == 0:\n                temp_level[1][ord(c) - ord('a')] = [False, [[] for _ in range(26)]]\n            temp_level = temp_level[1][ord(c) - ord('a')]\n            \n        temp_level[0] = True\n       \n        \n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        temp_level = self.tries\n        for c in self.stream[::-1]:\n            if len(temp_level[1][ord(c) - ord('a')]) == 0:\n                return False\n            temp_level = temp_level[1][ord(c) - ord('a')]\n            if temp_level[0]:\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = [None] * 26\n        self.isWord = False\n\n\nclass Trie:\n    def __init__(self, words):\n        self.root = Node('')\n\n        for word in words:\n            p = self.root\n            for ind in range(len(word) - 1, -1, -1):\n                ch = word[ind]\n                if p.children[ord(ch) - ord('a')] is None:\n                    new_node = Node(ch)\n                    p.children[ord(ch) - ord('a')] = new_node\n                p = p.children[ord(ch) - ord('a')]\n                if ind == 0:\n                    p.isWord = True\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie(words)\n        self.pointer_queue = []\n        self.stream = []\n\n    def query(self, letter: str) -> bool:\n        self.stream.insert(0, letter)\n        \n        p = self.trie.root\n        for ch in self.stream:\n            if p.children[ord(ch) - ord('a')]:\n                p = p.children[ord(ch) - ord('a')]\n            else:\n                return False\n            if p.isWord:\n                return True\n        return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie={}\n        self.q = ''\n        for i in words:\n            if i[-1] not in self.trie:\n                self.trie[i[-1]]=[i[:-1]]\n            else:\n                self.trie[i[-1]].append(i[:-1])        \n\n    def query(self, letter: str) -> bool:\n\n        trie= self.trie\n        self.q += letter\n        if letter not in trie: return False\n        \n        for i in trie[letter]:\n            l=len(i)\n            if self.q[-l-1:-1]==i:\n                return True\n        \n        return False\n\n\n\n", "class Trie:\n    def __init__(self):\n        self.wordEndsHere = False\n        self.children = dict()\n        \n    def addWord(self, word):\n        if not word:\n            self.wordEndsHere = True\n        else:\n            if word[0] not in self.children:\n                self.children[word[0]] = Trie()\n            self.children[word[0]].addWord(word[1:])\n    \n    def findWord(self, word):\n        if self.wordEndsHere:\n            return True\n        \n        if not word:\n            return self.wordEndsHere\n        elif word[0] not in self.children:\n            return False\n        else:\n            return self.children[word[0]].findWord(word[1:])\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.maxLength = 0\n        self.letters = []\n        self.trie = Trie()\n        \n        for w in words:\n            self.trie.addWord(w[::-1])\n            self.maxLength = max(self.maxLength, len(w))\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        \n        sliceLength = min(len(self.letters), self.maxLength)\n        \n        target = ''.join(self.letters[(len(self.letters) - sliceLength):])[::-1]\n        return self.trie.findWord(target)", "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = {}\n        self.isWord = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Node(\\\"thisisroot\\\")\n        \n        for word in words:\n            node = self.root\n            for char in word[::-1]:\n                if not char in node.children:\n                    node.children[char] = Node(char)\n                node = node.children[char]\n            node.isWord = True\n            \n        self.prefix = \\\"\\\"\n            \n    def query(self, letter: str) -> bool:\n        self.prefix += letter\n        node = self.root\n        for char in self.prefix[::-1]:\n            if char not in node.children: break\n            tmp = node.children[char]\n            if tmp.isWord: return True\n            node = tmp\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import defaultdict\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.Queries=''\n        self.Words=defaultdict(list)\n        for w in words:\n            self.Words[w[-1]].append(w)\n\n    def query(self, letter: str) -> bool:\n        self.Queries+=letter\n        if len(self.Queries)>2000:\n            self.Queries=self.Queries[1:]    \n        for k in self.Words[letter]:\n            i=len(k)\n            if i<=len(self.Queries):\n                if self.Queries[-i:]==k:\n                  return True\n        return False", "class StreamChecker:\n    \n    # I just used a trie, and inserted into it the reversals of the words. So by looking up something in the trie, I can tell if those letters are at the end of a word in the trie. But the leetcode results tell me my result is not that efficient, so I should check the Discuss tab to see better results. Maybe I am wasting time first doing the \\\"startsWith\\\" lookup, and if that is successful, having to begin again with the \\\"search\\\" lookup. There should be a way to have a startswith method that also tells you if it is or is not a word.\n\n    def __init__(self, words: List[str]):\n        \n        class Trie:\n    \n            class TreeNode:\n        \n                def __init__(self):\n                    self.children = [None] * 26\n                    self.isEndOfWord = False\n    \n            def __init__(self):\n                \\\"\\\"\\\"\n                Initialize your data structure here.\n                \\\"\\\"\\\"\n                self.root = self.TreeNode()\n        \n\n            def insert(self, word: str) -> None:\n                \\\"\\\"\\\"\n                Inserts a word into the trie.\n                \\\"\\\"\\\"\n                node = self.root\n                for i in range(len(word)):\n                    letter = word[i]\n                    index = ord(letter) - ord('a')\n                    if node.children[index] == None:\n                        node.children[index] = self.TreeNode() \n                    if i == len(word) - 1:\n                        node.children[index].isEndOfWord = True\n                    node = node.children[index]\n                \n        \n            def search(self, word: str) -> bool:\n                \\\"\\\"\\\"\n                Returns if the word is in the trie.\n                \\\"\\\"\\\"\n                node = self.root\n                for i in range(len(word)):\n                    letter = word[i]\n                    index = ord(letter) - ord('a')\n                    if node.children[index] == None:\n                        return\n                    else:\n                        if i == len(word) - 1:\n                            return node.children[index].isEndOfWord\n                        node = node.children[index]\n        \n\n            def startsWith(self, prefix: str) -> bool:\n                \\\"\\\"\\\"\n                Returns if there is any word in the trie that starts with the given prefix.\n                \\\"\\\"\\\"\n                node = self.root\n                for i in range(len(prefix)):\n                    letter = prefix[i]\n                    index = ord(letter) - ord('a')\n                    if node.children[index] == None:\n                        # return False\n                        return (False, False)\n                    else:\n                        if i == len(prefix) - 1:\n                            #return True\n                            if node.children[index].isEndOfWord:\n                                return (True, True)\n                            else:\n                                return (True, False)\n                        node = node.children[index]\n        \n        self.trie = Trie()\n        for word in words:\n            rev = word[::-1]\n            self.trie.insert(rev)\n        self.letters = []\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters) -1\n        res = \\\"\\\"\n        while i >= 0:\n            res += self.letters[i]\n            starts, isWord = self.trie.startsWith(res)\n            if not starts:\n                return False\n            if isWord:\n                return True\n            #if not self.trie.startsWith(res):\n            #    return False\n            #else:\n            #    if self.trie.search(res):\n            #        return True\n            i -= 1\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words=set(words)\n        self.maxx = len(max(self.words,key=len))\n        self.tails = {word[-1] for word in words}\n        self.qs = ''\n    \n\n    def query(self, letter: str) -> bool:\n        self.qs +=letter\n        if len(self.qs)>self.maxx:\n            self.qs = self.qs[1:]\n        if letter not in self.tails:\n            return False\n        N = len(self.qs)\n        return any((self.qs[i:N] in self.words for i in range(N-1,-1,-1)))\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    \n\n    def __init__(self, words):\n        self.words = []\n        self.store = {}\n        self.stack = ''\n        self.sample = 1\n        for w in words:\n            if not w:\n                continue\n            self.insertStore(w[::-1], self.store)\n\n    def query(self, letter):\n        self.stack += letter\n        return self.queryStore(self.stack, self.store)\n\n    def insertStore(self, w, store):\n        if w[:self.sample] not in store:\n            store[w[:self.sample]] = {}\n        if len(w) <= self.sample:\n            store[w[:self.sample]]['!'] = None\n        else:\n            self.insertStore(w[self.sample:], store[w[:self.sample]])\n\n    def queryStore(self, stack, store):\n        if not stack:\n            return False\n        s = stack[:-self.sample-1:-1]\n        if s in store:\n            if '!' in store[s]:\n                return True\n            if self.queryStore(stack[:-self.sample], store[s]):\n                return True\n        for i in range(1, self.sample):\n            if s[:i] in store:\n                return True\n        return False\n\n\n\n", "class TrieNode:\n    def __init__(self):\n        self.endOfWord=False\n        self.children={}\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie=TrieNode()\n        self.stream=collections.deque()\n        for word in words:\n            node=self.trie\n            for c in word[::-1]:\n                if not c in node.children:\n                    childNode=TrieNode()\n                    node.children[c]=childNode\n                node=node.children[c]\n            node.endOfWord=True\n       \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node=self.trie\n        for c in self.stream:\n            if not c in node.children:\n                return False\n            node=node.children[c]\n            if node.endOfWord:\n                return True\n        return node.endOfWord\n\n'''\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie={}\n        self.stream=collections.deque()\n        for word in words:\n            node=self.trie\n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch]={}\n                node=node[ch]\n            node['$']=word\n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node=self.trie\n        for c in self.stream:\n            if '$' in node:\n                return True\n            if not c in  node:\n                return False\n            node=node[c]\n        #print('$' in node)\n        return '$' in node\n'''\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\n", "class StreamChecker:\n\n    def __initv1__(self, words: List[str]):\n        self.dictionary:Dict[int, List[str]] = {}\n        for w in words:\n            l:int = len(w)\n            if l not in self.dictionary:\n                self.dictionary[l] = []\n            self.dictionary[l].append(w)\n            \n        self.l:List[int] = sorted(self.dictionary.keys())\n            \n        print(self.l)\n            \n        \n            \n    def __init__(self, words: List[str]):\n        self.dictionary:Dict[str, List[str]] = {}\n        \n        for w in words:\n            if w[-1] in self.dictionary.keys():\n                self.dictionary[w[-1]].append(w)\n            else:\n                self.dictionary[w[-1]] = [w]\n                \n        print(self.dictionary)\n                \n        self.word:str = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.word += letter\n        \n        if letter in self.dictionary:\n            for w in self.dictionary[letter]:\n                l:int = len(w)\n                if len(self.word) >= l and w == self.word[-l:]:\n                    return True\n            \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    \n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n    \n    def add(self, word: str):\n        cur = self\n        for char in word:\n            if char not in cur.children:\n                cur.children[char] = Trie()\n            cur = cur.children[char]\n        cur.isWord = True\n    \n    def contains(self, prefix: str):\n        cur = self\n        for char in prefix:\n            if char not in cur.children:\n                return False\n            cur = cur.children[char]\n            if cur.isWord:\n                return True\n        return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.prefix = \\\"\\\"\n        self.trie = Trie()\n        for word in words:\n            self.trie.add(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.prefix += letter\n        return self.trie.contains(self.prefix[::-1])\n    \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import defaultdict\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.words=words\n        self.rev_words={}\n        self.n=0\n        self.cur_word=''\n        self.dic=defaultdict(list)\n        \n        for i,word in enumerate(words):\n            rev_word=word[::-1]\n            self.rev_words[i]=rev_word\n            self.dic[rev_word[0]].append(i)\n            \n            if len(word)>self.n:\n                self.n=len(word)        \n        \n        #print(self.rev_words)\n        #print(self.dic)\n    \n    def query(self, letter: str) -> bool:\n        \n        if len(self.cur_word)==self.n:\n            self.cur_word=self.cur_word[1:]\n        \n        self.cur_word+=letter\n        \n        #print(self.cur_word)\n        \n        if letter in self.dic:\n            index=self.dic[letter]\n            \n            for i in index:\n                word=self.rev_words[i]\n                \n                if len(word)<=len(self.cur_word):\n                    if self.cur_word[::-1][:len(word)]==word:\n                        #print(self.cur_word,word)\n                        return True\n            \n        return False\n                        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.child={}\n        self.isLeaf=False\n\nclass Trie():\n    def __init__(self):\n        self.root=TrieNode()\n    \n    def add(self,s):\n        curr=self.root\n        for ch in s:\n            if ch not in curr.child:\n                curr.child[ch]=TrieNode()\n            curr=curr.child[ch]\n        curr.isLeaf=True\n        \n    def print(self):\n        curr=self.root\n        \n        def get(node,s):\n            if node.isLeaf:\n                print(\\\"got:\\\",s)\n            for ch in node.child:\n                get(node.child[ch],s+ch)\n        get(curr,\\\"\\\")\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t=Trie()\n        self.q_word=''\n        for word in words:\n            self.t.add(word[::-1])\n        #self.t.print()\n\n    def query(self, letter: str) -> bool:\n        self.q_word+=letter\n        \n        def find(node,s):\n            for ch in s:\n                if node.isLeaf:\n                    return True\n                if ch not in node.child:\n                    return False\n                node=node.child[ch]\n            return node.isLeaf\n            \n        return find(self.t.root,self.q_word[::-1])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dict={}\n        self.longest =0\n        for word in words:\n            if self.longest<len(word):\n                self.longest = len(word)\n            for i in range(len(word)-1,0,-1):\n                if self.dict.get(len(word[i:]))==None:\n                    self.dict[len(word[i:])]= {word[i:]:0}\n                elif self.dict[len(word[i:])].get(word[i:])==None:\n                    self.dict[len(word[i:])][word[i:]]=0\n            if self.dict.get(len(word))==None:\n                self.dict[len(word)]={word:1}\n            else:\n                self.dict[len(word)][word]=1\n        self.letters=''\n        \n    def query(self, letter: str) -> bool:\n        if len(self.letters)==self.longest:\n            self.letters = self.letters[1:]\n        self.letters+=letter\n        i=len(self.letters)-1\n        while i>=0 and self.dict[len(self.letters[i:])].get(self.letters[i:])!=None:\n            if self.dict[len(self.letters[i:])][self.letters[i:]]==1:\n                return True\n            i-=1\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie([word[::-1] for word in words])\n        self.stream = []\n\n    def query(self, letter: str) -> bool:\n        self.stream.insert(0, letter)\n        curr = self.trie.head\n        i = 0\n        while curr and i < len(self.stream):\n            curr = curr.get_element(self.stream[i])\n            if not curr:\n                return False\n            if curr.is_word:\n                return True\n            i += 1\n\n\nclass TrieNode:\n    ORDA = ord('a')\n\n    def __init__(self, is_word: bool = False):\n        self.is_word = is_word\n        self.children = [None] * 26\n\n    def get_element(self, c: str):\n        idx = ord(c) - TrieNode.ORDA\n        return self.children[idx]\n\n    def ensure_element(self, c: str):\n        idx = ord(c) - TrieNode.ORDA\n        if not self.children[idx]:\n            self.children[idx] = TrieNode()\n        return self.children[idx]\n\n\nclass Trie:\n    def __init__(self, words: List[str]):\n        self.head = TrieNode()\n        for word in words:\n            self.add_word(word)\n\n    def add_word(self, word: str):\n        curr = self.head\n        for c in word:\n            curr = curr.ensure_element(c)\n        curr.is_word = True\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = [0]*26\n        self.we = 0\n        self.c = 0\n\nclass Trie:\n\n    def __init__(self):\n        \\\"\\\"\\\"\n        Initialize your data structure here.\n        \\\"\\\"\\\"\n        self.root = TrieNode()\n        \n    def findIndex(self, char):\n        return ord(char) - ord(\\\"a\\\")\n        \n\n    def insert(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        \\\"\\\"\\\"\n        root = self.root\n        for letter in word:\n            index = self.findIndex(letter)\n            if not root.children[index]:\n                root.children[index] = TrieNode()\n            root.c += 1\n            root = root.children[index]\n        root.we += 1\n        \n        \n\n    def search(self, word: str) -> bool:\n        \\\"\\\"\\\"\n        Returns if the word is in the trie.\n        \\\"\\\"\\\"\n        root = self.root\n        for letter in word:\n            index = self.findIndex(letter)\n            if not root.children[index]:\n                return False\n            root = root.children[index]\n        if root.we:\n            return True\n        \n\n    def startsWith(self, prefix: str) -> bool:\n        \\\"\\\"\\\"\n        Returns if there is any word in the trie that starts with the given prefix.\n        \\\"\\\"\\\"\n        root = self.root\n        for letter in prefix:\n            index = self.findIndex(letter)\n            if not root.children[index]:\n                return False\n            root = root.children[index]\n        return True\n        \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.trie = Trie()\n        self.stream = \\\"\\\"\n        for word in words:\n            \n            self.trie.insert(word[::-1])\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream = self.stream + letter\n        l = len(self.stream)\n        for i in range(l-1, -1, -1):\n            a = self.stream[i:]\n            # print(self.stream[i:], self.startsWith(self.stream[i:]))\n            if not self.trie.startsWith(a[::-1]):\n                return False\n            else:\n           \n                if self.trie.search(a[::-1]):\n                    return True\n        return False\n            \n        \n    \n    \n   \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.end = '#'    \n        self.chars = ''\n        \n        for word in words:\n            word = word[::-1]\n            cnode = self.root\n            word += self.end\n\n            for c in word:\n                if c in cnode:\n                    cnode = cnode[c]\n                else:\n                    cnode[c] = {}\n                    cnode = cnode[c]\n        #print(self.root)\n    \n    def query(self, letter: str) -> bool:\n        self.chars += letter\n        cnode = self.root\n        \n        for c in self.chars[::-1]:\n            #if self.chars[::-1] == 'bbbaa':\n            #   print(c,cnode)\n\n            \n            if c in cnode:\n                cnode = cnode[c]                \n            else:\n                return False\n            \n            if '#' in cnode:\n            #    print(cnode)\n                return True\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode: \n      \n    def __init__(self): \n        self.children = [None]*26\n        self.isEndOfWord = False\n        \nclass Trie: \n      \n    # Trie data structure class \n    def __init__(self): \n        self.root = self.getNode() \n  \n    def getNode(self): \n        return TrieNode() \n  \n    def _charToIndex(self,ch): \n        return ord(ch)-ord('a')\n    \n    \n    def insert(self,key): \n        pCrawl = self.root \n        length = len(key) \n        for level in range(length): \n            index = self._charToIndex(key[level]) \n            if not pCrawl.children[index]: \n                pCrawl.children[index] = self.getNode() \n            pCrawl = pCrawl.children[index] \n  \n        pCrawl.isEndOfWord = True\n    \n    def search(self, key): \n        pCrawl = self.root \n        length = len(key) \n        for level in range(length): \n            index = self._charToIndex(key[level]) \n            if not pCrawl.children[index]: \n                return 0\n            pCrawl = pCrawl.children[index]\n        if pCrawl != None and pCrawl.isEndOfWord:\n            return 1\n        if pCrawl != None:\n            return 2\n        return 0\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        # self.firsts = set()\n        # self.lasts = set()\n        # self.tots = set()\n        for word in words:\n            self.root.insert(word[::-1])\n            # self.tots.add(word)\n            # self.firsts.add(word[0])\n            # self.lasts.add(word[-1])\n        self.streams = []\n        self.l = 0\n\n    def query(self, letter: str) -> bool:\n        self.streams.append(letter)\n        self.l+=1\n        # if letter not in self.lasts:\n        #     return False\n        for i in range(self.l,-1,-1):\n            word = list(reversed(self.streams[i:self.l]))\n            # print (word)\n            if word == []:\n                continue\n            k = self.root.search(word)\n            if k == 1:\n                return True\n            if k == 0:\n                break\n\n        return False\n                \n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {};\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]];\n            else:\n                self.dic[word[-1]].append(word[:-1]);\n            self.s = \\\"\\\";\n                                     \n    def query(self, letter: str) -> bool:\n        self.s += letter;\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1;\n                cw = word + letter;\n                if len(self.s) >= length and cw == self.s[-length:]:\n                    return True;\n            return False;\n        else:\n            return False;\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.d = {}\n        for word in words:\n            if not word[-1] in self.d:\n                self.d[word[-1]] = [word[:-1]]\n            else:\n                self.d[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.d:\n            for word in self.d[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[-length:]:\n                    return True\n            return False\n        else:\n            return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    \n    # I just used a trie, and inserted into it the reversals of the words. So by looking up something in the trie, I can tell if those letters are at the end of a word in the trie. But the leetcode results tell me my result is not that efficient, so I should check the Discuss tab to see better results. Maybe I am wasting time first doing the \\\"startsWith\\\" lookup, and if that is successful, having to begin again with the \\\"search\\\" lookup. There should be a way to have a startswith method that also tells you if it is or is not a word.\n    # Following up on above comment, the code below corrects that \\\"problem\\\", but it still runs in the bottom 20% of python submissions. So I should read the Discuss tab!\n\n    def __init__(self, words: List[str]):\n        \n        class Trie:\n    \n            class TreeNode:\n        \n                def __init__(self):\n                    self.children = [None] * 26\n                    self.isEndOfWord = False\n    \n            def __init__(self):\n                \\\"\\\"\\\"\n                Initialize your data structure here.\n                \\\"\\\"\\\"\n                self.root = self.TreeNode()\n        \n\n            def insert(self, word: str) -> None:\n                \\\"\\\"\\\"\n                Inserts a word into the trie.\n                \\\"\\\"\\\"\n                node = self.root\n                for i in range(len(word)):\n                    letter = word[i]\n                    index = ord(letter) - ord('a')\n                    if node.children[index] == None:\n                        node.children[index] = self.TreeNode() \n                    if i == len(word) - 1:\n                        node.children[index].isEndOfWord = True\n                    node = node.children[index]\n                \n        \n            def search(self, word: str) -> bool:\n                \\\"\\\"\\\"\n                Returns if the word is in the trie.\n                \\\"\\\"\\\"\n                node = self.root\n                for i in range(len(word)):\n                    letter = word[i]\n                    index = ord(letter) - ord('a')\n                    if node.children[index] == None:\n                        return\n                    else:\n                        if i == len(word) - 1:\n                            return node.children[index].isEndOfWord\n                        node = node.children[index]\n        \n\n            def startsWith(self, prefix: str) -> bool:\n                \\\"\\\"\\\"\n                Returns if there is any word in the trie that starts with the given prefix.\n                \\\"\\\"\\\"\n                node = self.root\n                for i in range(len(prefix)):\n                    letter = prefix[i]\n                    index = ord(letter) - ord('a')\n                    if node.children[index] == None:\n                        # return False\n                        return (False, False)\n                    else:\n                        if i == len(prefix) - 1:\n                            #return True\n                            if node.children[index].isEndOfWord:\n                                return (True, True)\n                            else:\n                                return (True, False)\n                        node = node.children[index]\n        \n        self.trie = Trie()\n        for word in words:\n            rev = word[::-1]\n            self.trie.insert(rev)\n        self.letters = []\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters) -1\n        res = \\\"\\\"\n        while i >= 0:\n            res += self.letters[i]\n            starts, isWord = self.trie.startsWith(res)\n            if not starts:\n                return False\n            if isWord:\n                return True\n            #if not self.trie.startsWith(res):\n            #    return False\n            #else:\n            #    if self.trie.search(res):\n            #        return True\n            i -= 1\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tire = {}\n        self.tire_reverse = {}\n        self.max_size = 0\n        for w in words:\n            self._insert(w)\n            self._insert_reverse(w[::-1])\n            self.max_size = max(self.max_size, len(w))\n        \n        self.q = collections.deque([], self.max_size)\n        self.curr = self.tire\n        \n    \n    def _insert(self, word):\n        curr = self.tire\n        for c in word:\n            if c not in curr:\n                curr[c] = {}\n            curr = curr[c]\n        curr['$'] = True\n\n    def _insert_reverse(self, word):\n        curr = self.tire_reverse\n        for c in word:\n            if c not in curr:\n                curr[c] = {}\n            curr = curr[c]\n        curr['$'] = True\n        \n    def _search(self, w):\n        curr = self.tire_reverse\n        for c in w:\n            if c in curr:\n                curr = curr[c]\n                if '$' in curr:\n                    return True\n            else:\n                return False\n        \n        return False\n\n    def query(self, letter: str) -> bool:\n        self.q.append(letter)\n        \n        if letter in self.curr:\n            self.curr = self.curr[letter]\n            if '$' in self.curr:\n                return True\n            else:\n                self.curr = self.tire\n            \n        w = [c for c in self.q]\n        return self._search(w[::-1])\n\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "import itertools\nclass TrieNode:\n    def __init__(self):\n        self.end = False\n        self.nodes = {}\n    def insert(self, word):\n        if len(word) == 0:\n            self.end = True\n            return\n        if word[0] not in self.nodes:\n            self.nodes[word[0]] = TrieNode()\n        self.nodes[word[0]].insert(word[1:])\n    def startsWith(self, word):\n        if len(word) == 0:\n            return True\n        if word[0] not in self.nodes:\n            return False\n        return self.nodes[word[0]].startsWith(word[1:])\n    def exists(self, word):\n        if self.end and len(word) == 0:\n            return True\n        if len(word) == 0 or word[0] not in self.nodes:\n            return False\n        return self.nodes[word[0]].exists(word[1:])\n            \n#from collections import deque        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.longest = 0\n        for word in words:\n            self.longest = max(self.longest, len(word))\n            self.root.insert(word[::-1])\n        self.word = ''\n        \n    def query(self, letter: str) -> bool:\n        self.word = (self.word + letter)[-self.longest:]\n        for i in range(len(self.word)-1, -1,-1):\n            other = self.word[i:][::-1]\n            if not self.root.startsWith(other):\n                break\n            if self.root.exists(other):\n                return True\n        return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dict = {}\n        for word in words:\n            if word[-1] not in self.dict:\n                self.dict[word[-1]] = [word[:-1]]\n            else:\n                self.dict[word[-1]].append(word[:-1])\n        \n        self.s = \\\"\\\"\n        \n    def query(self, letter: str) -> bool:\n        self.s += letter\n        if letter in self.dict:\n            for word in self.dict[letter]:\n                length = len(word) + 1\n                cword = word + letter\n                if len(self.s) >= length and cword == self.s[-length:]:\n                    return 1\n            return 0\n        else:\n            return 0\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.max_len = 0\n        self.dequeue = collections.deque()\n        self.suffix_dict = dict()\n\n        for w in set(words):\n            self.max_len = max(self.max_len, len(w))\n            for i in reversed(range(len(w))):\n                suffix = \\\"\\\".join(reversed(w[i:]))\n                if suffix not in self.suffix_dict:\n                    self.suffix_dict[suffix] = False\n                if i == 0:\n                    self.suffix_dict[suffix] = True\n\n    def query(self, letter: str) -> bool:\n        if len(self.dequeue) >= self.max_len:\n            self.dequeue.popleft()\n        self.dequeue.append(letter)\n\n        reversed_word = ''\n        for i in reversed(range(len(self.dequeue))):\n            c = self.dequeue[i]\n            reversed_word = reversed_word + c\n\n            if reversed_word in self.suffix_dict:\n                if self.suffix_dict[reversed_word]:\n                    return True\n            else:\n                return False\n\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    \n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode()\n    \n    def add(self, word):\n        curr = self.root\n        for ch in word:\n            if ch not in curr.children:\n                new_node = TrieNode()\n                curr.children[ch] = new_node\n            curr = curr.children[ch]\n        curr.is_end = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = collections.deque()\n        self.trie = Trie()\n        for ch in words:\n            self.trie.add(reversed(ch))\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        curr = self.trie.root\n        for ch in self.stream:\n            if ch not in curr.children:\n                return False\n            else:\n                curr = curr.children[ch]\n                if curr.is_end:\n                    return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '#' in curr_node:\n                return True\n        \n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.trie = {}\n        self.history = ''\n        for w in words:\n            p = self.trie\n            for c in w[::-1]:\n                if c not in p: p[c] = {}\n                p = p[c]\n            p['#'] = w\n\n    def query(self, letter: str) -> bool:\n        self.history+=letter\n        p = self.trie\n        for c in self.history[::-1]:\n            if c not in p: return False\n            p = p[c]\n            if '#' in p: return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.root = TrieNode(\\\"\\\")\n        \n    def insert(self, word):\n        current = self.root\n        for c in word:\n            if current.child[ord(c) - ord('a')] == None:\n                current.child[ord(c) - ord('a')] = TrieNode(c)\n            current = current.child[ord(c) - ord('a')]\n        current.isEnd = True\n        \n    def contains(self, word):\n        current = self.root\n        for c in word:\n            if current.child[ord(c) - ord('a')] == None:\n                return False\n            current = current.child[ord(c) - ord('a')]\n        return current.isEnd\n    \n    def startsWith(self, word):\n        current = self.root\n        for c in word:\n            if current.child[ord(c) - ord('a')] == None:\n                return False\n            current = current.child[ord(c) - ord('a')]\n        return True\n              \nclass TrieNode:\n    def __init__(self, char):\n        self.val = char\n        self.isEnd = False\n        self.child = [None for i in range(27)]\n    \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n        self.buff = []\n\n    def query(self, letter: str) -> bool:\n        self.buff.append(letter)\n        n = len(self.buff)\n        s = \\\"\\\"\n        for i in range(n - 1, max(n - 2000, -1), -1):\n            s += self.buff[i]\n            if not self.trie.startsWith(s):\n                return False\n            if self.trie.contains(s):\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker(object):\n    def __init__(self, words):\n        self.words = set(words)\n        self.added_chars = \\\"\\\"\n        self.terminal_chars = set()\n        for w in words:\n            self.terminal_chars.add(w[-1])\n\n    def query(self, char):\n        self.added_chars += char\n        if char in self.terminal_chars:\n            for w in self.words:\n                if self.added_chars.endswith(w):\n                    return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class node:\n    def __init__(self):\n        self.isword = False\n        self.child = defaultdict(node)\n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.root = node()\n        \n        for w in words:\n            cur = self.root\n            for c in w[::-1]:\n                cur = cur.child[c]\n            cur.isword = True\n        \n\n    def query(self, letter: str) -> bool:\n        cur = self.root\n        self.history += letter\n        for c in self.history[::-1]:\n            if c not in cur.child: return False\n            cur = cur.child[c]\n            if cur.isword: return True\n            \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        # Build a trie\n        self.map = {}\n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        \\\"\\\"\\\"Return true if letter completes a word in words.\\\"\\\"\\\"\n        self.history += letter\n        curr_node = self.map\n        for char in self.history[::-1]:\n            if char not in curr_node:\n                return False\n            curr_node = curr_node[char]\n            if '#' in curr_node:\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dict = {}\n        self.word = \\\"\\\"\n        for i in range(len(words)):\n            lastChar = words[i][-1]\n            if lastChar in self.dict:\n                self.dict[lastChar].append(words[i])\n            else:\n                self.dict[lastChar] = [words[i]]\n        #print (self.dict)  \n\n    def query(self, letter: str) -> bool:      \n        self.word += letter\n        count = len(self.word) \n        if letter in self.dict:\n            if letter in self.dict[letter]:\n                return True\n            else:\n                lWords = list(self.dict[letter])                 \n                for i in range(len(lWords)):\n                    length = len(lWords[i])\n                    #print (letter, self.word, self.word[count-length:], lWords[i])\n                    if count >= length and self.word[count-length:] == lWords[i]:\n                        #print (letter, lWords[i])\n                        return True\n       \n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from functools import reduce\nfrom collections import deque, defaultdict\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.stream = ''\n        self.letters, self.end_letter = self.prep()\n\n    def prep(self):\n        letters = set()\n        end_letter = defaultdict(list)\n        self.words.sort(key=lambda x: len(x))\n        for i, word in enumerate(self.words):\n            letters = letters.union(set(word))\n            end_letter[word[-1]].append(i)\n        return letters, end_letter\n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        if letter not in self.letters:\n            return False\n        for i in self.end_letter.get(letter, []):\n            if len(self.stream) < len(self.words[i]):\n                return False\n            if self.stream[-len(self.words[i]):] == self.words[i]:\n                return True\n        return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n        print(self.map)\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '#' in curr_node:\n                return True\n        \n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.is_word = False\n        self.child = defaultdict(Trie)\n    \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie() # root\n        self.stream = ''\n        for w in words:\n            cur_node = self.trie\n            for c in w[::-1]:\n                # reverse char in word\n                cur_node = cur_node.child[c]\n            # last letter of word\n            cur_node.is_word = True\n    \n                \n\n    def query(self, letter: str) -> bool:\n\n        self.stream += letter\n        node = self.trie\n        for c in reversed(self.stream):\n            if c not in node.child:\n                return False\n            node = node.child[c]\n            if node.is_word:\n                return True\n        return False\n\n            \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\n\nclass TrieNode:\n    def __init__(self):\n        self.children=defaultdict(TrieNode)\n        self.is_end=False\n\n\nclass Trie:\n    def __init__(self):\n        self.root=TrieNode()\n        \n    def insert(self,s):\n        tem=self.root\n        for i in s:\n            tem=tem.children[i]\n        tem.is_end=True\n        \n    def search(self,s):\n        tem=self.root\n        for i in range(len(s)):\n            node=tem.children.get(s[i])\n            if(node==None):\n                return False\n            if(node.is_end):\n                return True\n            \n            tem=node\n            \n        return tem.is_end\n        \n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie=Trie()\n        self.ls=words\n        for i in self.ls:\n            self.trie.insert(i[::-1])\n        self.q=\\\"\\\"\n        \n\n    def query(self, letter: str) -> bool:\n        self.q+=letter\n        return self.trie.search(self.q[::-1])\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie={}\n        for i in words:\n            k=self.trie\n            j=i[::-1]\n            for f in j:\n                if f not in k:\n                    k[f]={}\n                k=k[f]\n            k['$']=1\n        print(self.trie)\n        self.past=\\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.past+=letter\n        ans=True\n        k=self.trie\n        for i in self.past[::-1]:\n            if i not in k:\n                ans=False\n                break\n            k=k[i]\n            if '$' in k:\n                break\n        if ans and '$' in k:\n            return True\n        return False\n                \n            \n            \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for w in words:\n            self.trie.insert(w[::-1])\n        self.history = ''\n    def query(self, letter: str) -> bool:\n        self.history += letter\n        return self.trie.search(self.history[::-1])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\nclass Node():\n    def __init__(self):\n        self.children = {}\n        self.exist = 0\n    \n    \nclass Trie():\n    def __init__(self):\n        self.root = Node()\n    \n    def insert(self, w):\n        curr_node = self.root\n        for c in w:\n            if c not in curr_node.children:\n                curr_node.children[c] = Node()\n            curr_node = curr_node.children[c]\n        curr_node.exist = 1\n    \n    def search(self, w):\n        curr_node = self.root\n        for c in w:\n            if c not in curr_node.children:\n                return False\n            curr_node = curr_node.children[c]\n            if curr_node.exist:\n                return True\n        return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.add(word[::-1])\n        self.stream = ''\n\n    def query(self, letter: str) -> bool:\n        node = self.trie.root\n        self.stream += letter\n        for char in self.stream[::-1]:\n            if char in node.c:\n                node = node.c[char]\n            else:\n                break\n            if node.isword:\n                return True\n        return False\n        \n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode('')\n    \n    def add(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.c:\n                node.c[char] = TrieNode(char)\n            node = node.c[char]\n        node.isword = True\n            \n\nclass TrieNode:\n    def __init__(self, v):\n        self.v = v\n        self.c = dict()\n        self.isword = False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n        \n    def query(self, letter: str) -> bool:\n        self.history += letter\n        curr_node = self.map\n        for letter in self.history[::-1]:\n            if letter not in curr_node:\n                return False\n            curr_node = curr_node[letter]\n            if '#' in curr_node:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import defaultdict\n\nclass TrieNode:\n    \n    def __init__(self):\n        self.children=defaultdict(TrieNode)\n        self.isWord=False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root=TrieNode()\n        self.mx_length=0\n        for word in words:\n            self.insert(word[::-1])\n            self.mx_length=max(self.mx_length,len(word))\n        \n        self.buffer=''\n        \n        \n    def insert(self,word):\n        curr_node=self.root\n        for ch in word:\n            curr_node=curr_node.children[ch]\n        curr_node.isWord=True\n            \n    def search(self,word):\n        cur_node=self.root\n        for ch in word:\n            cur_node=cur_node.children.get(ch)\n            if not cur_node:\n                return False\n            if cur_node.isWord:\n                return True\n        \n        return False\n        \n        \n\n    def query(self, letter: str) -> bool:\n        self.buffer+=letter\n        return self.search(self.buffer[::-1])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    \n    def __init__(self):\n        self.dict = {}\n        self.leaf = False\n        \n    def addWord(self,word):\n        newTrie = Trie()\n        if word[0] in self.dict:\n            newTrie = self.dict[word[0]]\n        else:\n            self.dict[word[0]] = newTrie\n        if len(word) == 1:\n            newTrie.leaf = True\n        else:\n            newTrie.addWord(word[1:])\n            \n    \n# class Node:\n    \n#     def __init__(self,val,left=None,right=None):\n#         self.val = val\n#         self.left = left; self.right = right\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.queryStr = ''\n        for word in words:\n            self.trie.addWord(word[::-1])\n        #print(self.trie)\n        \n    def query(self, letter: str) -> bool:\n        self.queryStr += letter\n        curTrie = self.trie\n        #print(letter)\n        for ch in self.queryStr[::-1]:\n            #print('current ch : {}'.format(ch))\n            if ch in curTrie.dict:\n                curTrie = curTrie.dict[ch]\n                if curTrie.leaf == True:\n                    return True\n                #print(curTrie.dict)\n                #print(curTrie.leaf)\n            else:\n                #print('return false')\n                return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        newwords = []\n        for w in words:\n            if w not in newwords:\n                newwords.append(w)\n        self.words = newwords\n        print(\\\"number of words = \\\" + str(len(self.words)))\n        self.check = \\\"\\\"\n\n\n\n    def query(self, letter: str) -> bool:\n        self.check += letter\n        for word in self.words:\n            if word[-1] != letter:\n                continue\n            if len(word) > len(self.check):\n                continue\n\n            if word == self.check[-1 * len(word):]:\n                return True\n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self, parent):\n        self.parent = parent\n        self.children = collections.defaultdict(lambda: TrieNode(self))\n        self.c = None\n\nclass Trie:\n    \n    def __init__(self):\n        self.root = TrieNode(None)\n        self.ends = collections.defaultdict(list)\n    \n    def add(self, word):\n        curr = self.root\n        for c in word:\n            curr = curr.children[c]\n            curr.c = c\n        if len(word) > 0:\n            self.ends[word[-1]].append(curr)\n        \n    def isMember(self, letters):\n        if letters[-1] not in self.ends:\n            return False\n        poss = self.ends[letters[-1]]\n            \n        for p in poss:\n            curr = p\n            index = len(letters) - 2\n            while curr and index >= 0:\n                curr = curr.parent\n                if curr == self.root:\n                    return True\n                if curr.c != letters[index]:\n                    curr = None\n                index -= 1\n            if index == -1 and curr != None and curr.parent == self.root:\n                return True\n        return False\n\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for w in words:\n            self.trie.add(w)\n        self.maxLen = max(list([len(x) for x in words]))\n        self.queries = []\n\n    def query(self, letter: str) -> bool:\n        self.queries.append(letter)\n        if len(self.queries) > self.maxLen:\n            del self.queries[0]\n        return self.trie.isMember(self.queries)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = \\\"\\\"\n        for word in words:\n            curr = self.trie\n            for w in word[::-1]:\n                curr = curr.setdefault(w,{})\n            curr['$'] = '$'\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        curr = self.trie\n        for s in self.stream[::-1]:\n            if '$' in curr: return True\n            if s not in curr: return False\n            curr = curr[s]\n        return '$' in curr\n            \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "# 1032. Stream of Characters\n\n# class TrieNode:\n#     def __init__(self, val=None, isEnd=False):\n#         self.val = val\n#         self.isEnd = isEnd\n#         self.next = {}\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n\n        for word in set(words):\n            node = self.trie       \n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n        \n        \n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            trie = self.trie\n            for letter in word[::-1]:\n                if letter not in trie:\n                    trie[letter] = {}\n                trie = trie[letter]\n            trie['$'] = ''\n        print((self.trie))\n        self.queue = deque()    \n        self.max_len = max(len(word) for word in words)\n\n    def query(self, letter: str) -> bool:\n        self.queue.appendleft(letter)\n        if len(self.queue) > self.max_len:\n            self.queue.pop()\n        trie = self.trie\n        for letter in self.queue:\n            trie = trie.get(letter)\n            if trie is None:\n                return False\n            if '$' in trie:\n                return True\n        return False\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n\n#     def __init__(self, words: List[str]):\n#         self.root = {}\n#         self.end = -1\n#         for w in words:\n#             self.insert(w)\n#         self.qhist = ''\n\n#     def insert(self, word):\n#         curNode = self.root\n#         for c in word[::-1]:\n#             if not c in curNode:\n#                 curNode[c] = {}\n#             curNode = curNode[c]\n#         curNode[self.end] = True\n\n#     def query(self, letter: str) -> bool:\n#         self.qhist += letter\n#         curNode = self.root\n#         for c in self.qhist[::-1]:\n#             if not c in curNode:\n#                 return False\n#             curNode = curNode[c]\n#             if self.end in curNode:\n#                 return True\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.nodes = dict()\n        self.is_leaf = False\n    def insert(self,word):\n        curr = self\n        for char in word:\n            if char not in curr.nodes:\n                curr.nodes[char] = TrieNode()\n            curr = curr.nodes[char]\n        curr.is_leaf = True\n    def check(self,word):\n        curr = self\n        for c in word:\n            if c not in curr.nodes:\n                return False\n            curr = curr.nodes[c]\n            if curr.is_leaf:\n                return True\n        return False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        for word in words:\n            self.root.insert(word[::-1])\n        self.sb = ''\n    def query(self, letter: str) -> bool:\n        self.sb += letter\n        node = self.root\n        return node.check(self.sb[::-1])\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.found = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.term = \\\"\\\"\n        for w in words:\n            cur = self.root\n            for c in w[::-1]:\n                if c not in cur.children:\n                    cur.children[c] = TrieNode()\n                cur = cur.children[c]\n            cur.found = True\n\n    def query(self, letter: str) -> bool:\n        self.term += letter\n        cur = self.root\n        for c in self.term[::-1]:\n            if cur.found:\n                return True\n            if c not in cur.children:\n                break\n            cur = cur.children[c]\n        if cur.found:\n            return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamTrie:\n\n    def __init__(self, mychar='ROOT'):\n        self.char = mychar\n        self.children = {}\n        self.mass = 0\n        # START WITH EMPTY STRING?\n        # self.add('') ??\n        if mychar=='ROOT':\n            self.max_len = 0\n        #self.\n    \n    #def checkChar(self, nxtChr):\n            \n    def add(self, word, top_level=True):\n        if len(word) == 0:\n            self.children['END'] = True\n        else:\n            self.mass += 1\n            c = word[0]\n            if not c in self.children:\n                self.children[c] = StreamTrie(c)\n            self.children[c].add(word[1:],top_level=False)\n\n        if top_level:\n            self.max_len = max(self.max_len,len(word))\n\n    def get_max_len(self):\n        return self.max_len\n\n    def matches(self,word):\n        if len(word) == 0 and 'END' in self.children:\n            return True\n        if len(word) > 0 and word[0] in self.children:\n            return self.children[word[0]].matches(word[1:])\n        return False\n\n    def all_matches_from_beginning(self, query_string):\n        match_list = []\n        first = query_string[0]\n        if first in self.children:\n            self.children[first]._match_all(query_string,0,match_list)\n        return match_list\n\n    def _match_all(self,query_string,cur_ind,match_set):\n        #if len(match_set) > 0\n        if 'END' in self.children:\n            match_set.append(query_string[:(cur_ind+1)])\n        #if query_string[ind] == self.char:\n        if cur_ind+1 < len(query_string):\n            nxt = query_string[cur_ind+1]\n            if nxt in self.children:\n                self.children[nxt]._match_all(query_string,cur_ind+1,match_set)\n        # return\n\n    def any_match_from_beginning(self, query_string):\n        #print(query_string)\n        return self.children[query_string[0]]._match_any(query_string,0) if query_string[0] in self.children else False\n    \n    def _match_any(self,query_string,cur_ind):\n        #if len(match_set) > 0\n        if 'END' in self.children:\n            return True\n        if cur_ind+1 < len(query_string) and query_string[cur_ind+1] in self.children:\n            return self.children[query_string[cur_ind+1]]._match_any(query_string,cur_ind+1)\n        else:\n            return False\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        if 'END' in self.children:\n            return f'[{self.char}*]'\n\n        s = f'[{self.char}:{self.mass} '\n        if self.char == 'ROOT':\n            s = f'Trie({self.mass} '\n\n        kids = []\n        for k in self.children:\n            if not k == 'END':\n                kids.append(str(self.children[k]))\n        s += ', '.join(kids)\n\n        s += ')' if self.char == 'ROOT' else ']'\n\n        return s\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = StreamTrie()\n        self.longest = 0\n        for word in words:\n            self.trie.add(word[::-1])\n            if len(word) > self.longest:\n                self.longest = len(word)\n        self.stream = deque()\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        if len(self.stream) > self.longest:\n            self.stream.pop()\n        #print(self.stream)\n        return self.trie.any_match_from_beginning(''.join(self.stream))\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "# build a trie for sure.\n# think about the reverse word (aka the order trie is queried is reverse) here, seems we have to build it in reverse order ??\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        \n        self.map = dict()\n        self.max_len = max([len(i) for i in words])\n        self.history = \\\"\\\"\n        \n        for word in words:\n            node = self.map\n            for letter in word[::-1]:\n                if letter not in node:\n                    node[letter] = dict()\n                node = node[letter]\n            node['$'] = {}\n            \n    def query(self, letter: str) -> bool:\n        self.history += letter\n        node = self.map\n        \n        for l in self.history[::-1]:\n            if l not in node: \n                return False\n            node = node[l]\n            if '$' in node:\n                return True\n        return False\n            \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self):\n        self.children = defaultdict(Node)\n        self.isWord = False\nclass Trie:\n\n    def __init__(self):\n        \\\"\\\"\\\"\n        Initialize your data structure here.\n        \\\"\\\"\\\"\n        self.root = Node()\n\n    def insert(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        \\\"\\\"\\\"\n        node = self.root\n        for ch in word:\n            node = node.children[ch]\n        node.isWord = True\n\n    def search(self, word: str) -> bool:\n        \\\"\\\"\\\"\n        Returns if the word is in the trie.\n        \\\"\\\"\\\"\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                break\n            node = node.children.get(ch)\n            if node.isWord:\n                return True\n        return False\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.chars = ''\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.chars += letter\n        return self.trie.search(self.chars[::-1])\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        self.string = \\\"\\\"\n        \n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self, letter):\n        self.letter = letter\n        self.children = {}\n        self.end_of_word = False\n\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode(\\\"*\\\")\n        \n    def insert(self, word):\n        word = word[::-1]\n        curr_node = self.root\n        \n        for letter in word:\n            if letter not in curr_node.children:\n                curr_node.children[letter] = TrieNode(letter)\n                \n            curr_node = curr_node.children[letter]\n        \n        curr_node.end_of_word = True\n        \n    def word_exists(self, word):\n        word = word[::-1]\n        curr_node = self.root\n        \n        for letter in word:\n            if letter not in curr_node.children:\n                break\n            \n            curr_node = curr_node.children[letter]\n            \n            if curr_node.end_of_word:\n                return True\n        \n        return False\n            \n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.string = \\\"\\\"\n        self.trie = Trie()\n        \n        for word in words:\n            self.trie.insert(word)\n              \n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        \n        return self.trie.word_exists(self.string)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.size = len(max(words, key=len))\n        self.buffer = \\\"\\\"\n        self.words = [word[::-1] for word in words]\n        self.words.sort() \n        \n    def query(self, letter: str) -> bool:\n        print('Start\\\n')\n        self.buffer += letter\n        # self.buffer = self.buffer[-self.size:] # trim buffer\n        \n        for word in self.words:  \n            buffer_strip = self.buffer[-len(word):]\n            if word[::-1] == buffer_strip:\n                return True\n            if(word[0] > letter):\n                return False\n\n\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.chars = {}\n\n    def add(self, word):\n        cur = self.chars\n        for ch in word:\n            cur.setdefault(ch, {})\n            cur = cur[ch]\n        cur['#'] = '#'\n\n    def find(self, word):\n\n        cur = self.chars\n        for ch in word:\n            if ch not in cur:\n                return False\n            cur = cur[ch]\n        return '#' in cur\n\n\nclass StreamChecker:\n    def __init__(self, words):\n        self.trie = Trie()\n        for word in words:\n            self.trie.add(reversed(word))\n        self.max_len = max(words,key=lambda x:len(x))    \n        self.buf = []\n\n    def query(self, letter):\n        self.buf.append(letter)\n        cur = self.trie.chars\n        for i in range(len(self.buf) - 1, -1, -1):\n            ch = self.buf[i]\n            if ch not in cur:\n                return False\n            if '#' in cur[ch]:\n                return True\n            cur = cur[ch]\n        return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.curr = ''\n        self.words = words\n        temp = []\n        for w in words:\n            temp.append(w[-1])\n        self.last = temp\n        \n        self.MAX = 1\n        self.lenth = []\n        self.storage = collections.defaultdict(list)\n        for w in words:\n            if len(w) not in self.lenth:\n                self.lenth.append(len(w))\n            self.storage[len(w)].append(w)\n            self.MAX = max(self.MAX, len(w))\n\n        \n    def query(self, letter: str) -> bool:\n        \n        # print('start', letter, self.curr)\n        \n        if len(self.curr) < self.MAX:\n            self.curr += letter\n        elif len(self.curr) == self.MAX:\n            self.curr = self.curr[1:] + letter\n            \n        # print(letter, self.curr)\n            \n        if letter in self.last:   \n            \n            # print('in')\n            \n            for i in range(1, len(self.curr)+1):\n                # print(i, self.curr, self.curr[-i:])\n                if self.curr[-i:] in self.storage[i]:\n                    return True\n                else:\n                    continue  \n            return False\n        \n        else:\n            return False\n        \n        \n        \n    \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            trie = self.trie\n            for letter in word:\n                trie = trie.setdefault(letter, {})\n            trie[' '] = {}\n        self.check = []\n\n    def query(self, letter: str) -> bool:\n        self.check.append(self.trie)\n        self.check = [trie[letter] for trie in self.check if letter in trie]\n        for trie in self.check:\n            if ' ' in trie: return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n            return False\n        else:\n            return False\n\n        \n\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.last_letters = set([word[-1] for word in words])\n        self.max_length = max(map(len, self.words))\n        self.history = []\n\n    def query(self, letter: str) -> bool:\n        if letter in self.words:\n            return True\n        self.history.append(letter)\n        if letter in self.last_letters:\n            word = \\\"\\\"\n            for i in range(min(self.max_length, len(self.history))):\n                word = self.history[-1 * i - 1] + word\n                if word in self.words:\n                    return True\n        \n        while len(self.history) > self.max_length:\n            self.history.pop(0)\n        \n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self):\n        self.children = {}\n        self.isLeaf = False\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n        \n    def addWord(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = Node()\n            node = node.children[char]\n        node.isLeaf = True\n        \n    def isWord(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.isLeaf\n    \n    def isPrefix(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n            \n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.trie = Trie()\n        for word in words:\n            self.trie.addWord(word[::-1])\n        \n            \n    def query(self, letter: str) -> bool:\n        self.letters.insert(0, letter)\n        \n        right = 0\n        \n        while right < len(self.letters):\n            string = \\\"\\\".join(self.letters[:right+1])\n            if self.trie.isPrefix(string):\n                if self.trie.isWord(string):\n                    return True\n                right += 1\n            else:\n                return False\n        \n        return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.trie = {}\n        self.history = ''\n        for w in words:\n            p = self.trie\n            for c in w[::-1]:\n                if c not in p: p[c] = {}\n                p = p[c]\n            p['#'] = ''\n\n    def query(self, letter: str) -> bool:\n        self.history+=letter\n        p = self.trie\n        for c in self.history[::-1]:\n            if c not in p: return False\n            p = p[c]\n            if '#' in p: return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.Trie = {}\n        for word in words:\n            trieNode = self.Trie\n            for ch in word[::-1]:\n                if ch not in trieNode:\n                    trieNode[ch] = {}\n                trieNode = trieNode[ch]\n            trieNode['END'] = True\n        self.letter = ''\n        \n\n    def query(self, letter: str) -> bool:\n        self.letter += letter\n        trieNode = self.Trie\n        for ch in self.letter[::-1]:\n            if ch not in trieNode:\n                return False\n            trieNode = trieNode[ch]\n            if 'END' in trieNode:\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '#' in curr_node:\n                return True\n        \n        return False\n        \n        \n        \n        \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words=set(words)\n        self.maxx = len(max(self.words,key=len))\n        self.tails = {word[-1] for word in words}\n        self.qs = ''\n    \n\n    def query(self, letter: str) -> bool:\n        self.qs +=letter\n        if len(self.qs)>self.maxx:\n            self.qs = self.qs[1:]\n        if letter not in self.tails:\n            return False\n        N = len(self.qs)\n        return any((self.qs[i:N] in self.words for i in range(N)))\n        # return letter in self.words\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n        \n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '#' in curr_node:\n                return True\n        \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.end = '*'\n        for word in words:\n            self.insert(word[::-1])\n        self.history = \\\"\\\"\n        print(self.root)\n    def query(self, letter: str) -> bool:\n        self.history += letter\n        return self.search(self.history[::-1])\n            \n        \n    \n    def insert(self, words:str) -> None:\n        current = self.root\n        for char in words:\n            if char not in current:\n                current[char] = {}\n            current = current[char]\n        current[self.end] = True\n    \n    def search(self, string:str) -> bool:\n        current = self.root\n        for char in string:\n            if self.end in current:\n                return True\n            if char in current:\n                current = current[char]\n            else:\n                return False\n        return self.end in current\n                \n\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.last_letters = set([word[-1] for word in words])\n        self.max_length = max(map(len, self.words))\n        self.history = []\n\n    def query(self, letter: str) -> bool:\n        if letter in self.words:\n            return True\n        self.history.append(letter)\n        if letter in self.last_letters:\n            word = \\\"\\\"\n            for i in range(min(self.max_length, len(self.history))):\n                word = self.history[-1 * i - 1] + word\n                if word in self.words:\n                    return True\n        \n        while len(self.history) > self.max_length:\n            self.history.pop(0)\n        \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    \n    def __init__(self):\n        self.dict = {}\n        self.leaf = False\n        \n    def addWord(self,word):\n        curTrie = self\n        for ch in word:\n            if ch not in curTrie.dict:\n                curTrie.dict[ch] = Trie()\n            curTrie = curTrie.dict[ch]\n        curTrie.leaf = True\n        \n    def search(self,query):\n        curTrie = self\n        # print('query : {}'.format(query))\n        for ch in query:\n            if ch in curTrie.dict:\n                # print('ch : {}'.format(ch))\n                # print('dict : {}'.format(curTrie.dict))\n                curTrie = curTrie.dict[ch]\n                if curTrie.leaf == True:\n                    # print('return True')\n                    return True\n            else:\n                # print('return False')\n                return False\n        return False\n            \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.queryStr = ''\n        for word in words:\n            self.trie.addWord(word[::-1])\n        \n    def query(self, letter: str) -> bool:\n        self.queryStr += letter\n        curTrie = self.trie\n        return curTrie.search(self.queryStr[::-1])\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.li = {}\n        \n        for word in words:\n            curr = self.li\n            for c in word[::-1]:\n                if c not in curr:\n                    curr[c] = {}\n                curr = curr[c]\n            \n            curr[\\\"#\\\"] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n        \n        curr = self.li\n        for l in self.history[::-1]:\n            if l not in curr:\n                return False\n            \n            if \\\"#\\\" in curr[l]:\n                return True\n            \n            curr = curr[l]\n        \n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tracker=\\\"\\\"\n        self.map={}\n        \n        for word in words:\n            curr=self.map\n            for letter in word[::-1]:\n                if letter not in curr:\n                    curr[letter]={}\n                curr=curr[letter]\n            curr[\\\"$\\\"]={}\n                \n                    \n                \n    def query(self, letter: str) -> bool:\n        \n        self.tracker+=letter\n        curr=self.map\n        for l in self.tracker[::-1]:\n            if l not in curr:\n                return False\n            curr=curr[l]\n            \n            if \\\"$\\\" in curr:\n                return True\n        \n        return False\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie=defaultdict(dict)\n        for word in words:\n            node=self.trie\n            for i in word[::-1]:\n                if i not in node:\n                    node[i]={}\n                node=node[i]\n            node['#']=word\n        self.q=''\n\n    def query(self, letter: str) -> bool:\n        self.q += letter\n        node=self.trie\n        for i in self.q[::-1]:\n            if '#' in node:\n                return True\n            if i not in node:\n                return False            \n            node=node[i]\n        return '#' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = ''\n        self.trie = {}\n        \n        # Initialize trie with words\n        curr = self.trie\n        for word in words:\n            # Add reverse of word\n            for char in word[::-1]:\n                curr.setdefault(char, {})\n                curr = curr[char]\n            curr['end'] = True\n            curr = self.trie\n            \n        # print(self.trie)\n        \n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        \n        def _search(string, curr):\n            if 'end' in curr:\n                return True\n            \n            if string and string[0] in curr:\n                return _search(string[1:], curr[string[0]])\n            \n            return False\n        \n        \n        return _search(self.stream[::-1], self.trie)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.child = {}\n        self.isWord = False\n\n    def add(self, s):\n        t = self\n        for c in s:\n            if c not in t.child:\n                t.child[c] = Trie()\n            t = t.child[c]\n        t.isWord = True\n\n    def check(self, s):\n        t = self\n        for c in s:\n            if c not in t.child:\n                return False\n            t = t.child[c]\n            if t.isWord:\n                return True\n        return t.isWord\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.cache = \\\"\\\"\n        self.visited = {}\n        for s in words:\n            self.trie.add(s[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.cache = self.cache + letter\n        return self.trie.check(self.cache[::-1])\n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import defaultdict\nclass TrieNode:\n    def __init__(self):\n        self.nexts = defaultdict(TrieNode)\n        self.isword = False\n\nclass Trie:\n    def __init__(self, words):\n        self.root = TrieNode()\n        for w in words:\n            self.insert(w[:: -1])\n    \n    def insert(self, w):\n        cur = self.root\n        for c in w:\n            cur = cur.nexts[c]\n        cur.isword = True\n    \n    def search(self, w):\n        cur = self.root\n        for i in range(len(w) - 1, -1, -1):\n            if w[i] in cur.nexts:\n                cur = cur.nexts[w[i]]\n                if cur.isword: return True\n            else:\n                return False\n        return cur.isword\n        \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        # Time: O(WQ), W is the maximum length of all words, Q is number of calls of function query\n        self.t = Trie(words)\n        self.cache = list()\n\n    def query(self, letter: str) -> bool:\n        self.cache.append(letter)\n        return self.t.search(self.cache)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.isWord = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        p = self.root\n        for w in word[::-1]:\n            if w not in p.children:\n                p.children[w] = TrieNode()\n            p = p.children[w]\n        p.isWord = True\n\n    def search(self, word):\n        p = self.root\n        for w in word[::-1]:\n            if w not in p.children:\n                break\n            p = p.children[w]\n            if p.isWord:\n                return True\n        return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word)\n        self.letters = ''\n\n    def query(self, letter: str) -> bool:\n        self.letters += letter\n        return self.trie.search(self.letters)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '#' in curr_node:\n                return True\n        \n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import deque\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.data_set,self.end_chars, self.start_chars, self.min_len, self.max_len = self._get_set_min_max_len(words)\n        self.queue = list()\n        \n    \n    @staticmethod\n    def _get_set_min_max_len(words):\n        data_set = set(words)\n        min_len = 10000\n        max_len = 0\n        end_chrs = set()\n        start_chrs = set()\n        for w in words:\n            min_len = min(min_len, len(w))\n            max_len = max(max_len, len(w))\n            end_chrs.add(w[-1])\n            start_chrs.add(w[0])\n        return data_set, end_chrs,start_chrs, min_len, max_len\n    \n    def check_if_word_exists(self):\n        c_l = len(self.queue)\n        start_idx = c_l - self.min_len\n        if start_idx >= 0:\n            c_w = \\\"\\\".join(self.queue[k] for k in range(start_idx+1, c_l))\n            for i in range(start_idx, max(-1, c_l - self.max_len-1), -1):\n                c_w = f\\\"{self.queue[i]}{c_w}\\\"\n                if self.queue[i] not in self.start_chars:\n                    continue\n                if c_w in self.data_set:\n                    return True\n        else:\n            return False\n        \n\n    def query(self, letter: str) -> bool:\n        # if len(self.queue) >= self.max_len:\n        #     self.queue.popleft()\n        self.queue.append(letter)\n        if letter in self.end_chars:\n            return self.check_if_word_exists()\n        else:\n            return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.d = dict()\n        for word in words:\n            cur_d = self.d\n            for ch in word[::-1]:\n                if ch in cur_d:\n                    cur_d = cur_d[ch]\n                else:\n                    cur_d[ch] = {}\n                    cur_d = cur_d[ch]\n            cur_d['end'] = True\n        self.query_cache = ''\n\n    def query(self, letter: str) -> bool:\n        self.query_cache += letter\n        cur_d = self.d\n        for ch in self.query_cache[::-1]:\n            if ch in cur_d:\n                if cur_d[ch].get('end'):\n                    return True\n                cur_d = cur_d[ch]\n            else:\n                break\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '#' in curr_node:\n                return True\n        \n        return False\n\n\n\n# class StreamChecker {\n\n#     private String[] words;\n#     private int[] pointers;\n#     private TrieNode root;\n#     private Set<TrieNode> nodes;\n    \n#     public StreamChecker(String[] words) {\n#         this.words = words;\n#         this.pointers = new int[words.length];\n#         this.root = new TrieNode(' ');\n#         this.nodes = new HashSet<>();\n#         for (String word : words) {\n#             TrieNode node = this.root.insert(word);\n#         }\n#         this.nodes.add(this.root);\n#     }\n    \n#     public boolean query(char letter) {\n#         boolean found = false;\n#         // System.out.println(this.nodes.size());\n#         // System.out.println(letter);\n#         Set<TrieNode> next = new HashSet<>();\n#         for (TrieNode node : this.nodes) {\n#             // System.out.println(\\\"checking node \\\" + node.ch);\n#             if (node.children[letter - 'a'] != null) {\n#                 // System.out.println(\\\"not null\\\");\n#                 TrieNode matched = node.children[letter - 'a'];\n#                 // System.out.println(\\\"matched ch \\\" + matched.ch);\n#                 if (matched.isTerminal) {\n#                     found = true;\n#                     // System.out.println(found);\n#                 } else {\n#                     next.add(matched);\n#                 }\n#             } \n#         }\n#         this.nodes.clear();\n#         this.nodes.add(this.root);\n#         this.nodes.addAll(next);\n#         return found;\n#     }\n    \n#     private class TrieNode {\n#         char ch;\n#         TrieNode[] children;\n#         boolean isTerminal;\n        \n#         public TrieNode(char character) {\n#             ch = character;\n#             children = new TrieNode[26];\n#             isTerminal = false;\n#         };\n        \n#         TrieNode insert(String word) {\n#             TrieNode node = this;\n#             for (int i = 0; i < word.length(); i++) {\n#                 char ch = word.charAt(i);\n#                 TrieNode next = null;\n#                 if (node.children[ch - 'a'] == null) {\n#                     next = new TrieNode(ch);\n#                     node.children[ch - 'a'] = next;\n#                 } else {\n#                     next = node.children[ch - 'a'];\n#                 }\n#                 if (i == word.length() - 1) next.isTerminal = true;\n#                 node = next;\n#             }\n#             return node;\n#         }\n#     }\n    \n# //     public boolean query(char letter) {\n# //         // System.out.println(\\\"query ===\\\");\n# //         boolean found = false;\n# //         for (int i = 0; i < pointers.length; i++) {\n# //             // System.out.println(\\\"word is \\\" + this.words[i]);\n# //             if (this.words[i].charAt(this.pointers[i]) == letter) {\n# //                 // match\n# //                 this.pointers[i]++;\n# //                 // System.out.println(\\\"pointer++\\\");\n# //                 if (this.pointers[i] == this.words[i].length()) {\n# //                     this.pointers[i] = findPointer(this.words[i].substring(0, this.words[i].length() - 1), this.words[i].substring(1));\n# //                     found = true;\n# //                 }\n# //             } else {\n# //                 // mo match\n# //                 if (this.pointers[i] == 0) continue;\n# //                 this.pointers[i] = findPointer(this.words[i].substring(0, this.pointers[i]), this.words[i].substring(1, this.pointers[i]) + letter);\n# //             }\n# //         }\n        \n# //         // System.out.println(Arrays.toString(this.pointers));\n        \n# //         return found;\n# //     }\n    \n# //     private int findPointer(String base, String sub) {\n# //         //  System.out.println(\\\"findPointer\\\");\n# //         // System.out.println(base);\n# //         // System.out.println(sub);\n        \n# //         if (base.equals(sub)) {\n# //             // System.out.println(base.length());\n# //             return base.length();\n# //         } \n        \n# //         for (int i = base.length() - 1; i >= 1; i--) {\n# //             if (base.substring(0, i).equals(sub.substring(base.length() - i))) {\n# //                 // System.out.println(i);\n# //                 return i;\n# //             }\n# //         }\n        \n# //         // System.out.println(0);\n# //         return 0;\n# //     }\n# }\n\n# /**\n#  * Your StreamChecker object will be instantiated and called as such:\n#  * StreamChecker obj = new StreamChecker(words);\n#  * boolean param_1 = obj.query(letter);\n#  */", "from collections import defaultdict\n\n\nclass TrieNode(object):\n    def __init__(self, value=None):\n        # \u503c\n        self.value = value\n        # fail\u6307\u9488\n        self.fail = None\n        # \u5c3e\u6807\u5fd7\uff1a\u6807\u5fd7\u4e3ai\u8868\u793a\u7b2ci\u4e2a\u6a21\u5f0f\u4e32\u4e32\u5c3e\uff0c\u9ed8\u8ba4\u4e3a0\n        self.tail = 0\n        # \u5b50\u8282\u70b9\uff0c{value:TrieNode}\n        self.children = {}\n\n\nclass Trie(object):\n    def __init__(self, words):\n        print(\\\"\u521d\u59cb\u5316\\\")\n        # \u6839\u8282\u70b9\n        self.root = TrieNode()\n        # \u6a21\u5f0f\u4e32\u4e2a\u6570\n        self.count = 0\n        self.words = words\n        for word in words:\n            self.insert(word)\n        self.ac_automation()\n        print(\\\"\u521d\u59cb\u5316\u5b8c\u6bd5\\\")\n\n    def insert(self, sequence):\n        \\\"\\\"\\\"\n        \u57fa\u64cd\uff0c\u63d2\u5165\u4e00\u4e2a\u5b57\u7b26\u4e32\n        :param sequence: \u5b57\u7b26\u4e32\n        :return:\n        \\\"\\\"\\\"\n        self.count += 1\n        cur_node = self.root\n        for item in sequence:\n            if item not in cur_node.children:\n                # \u63d2\u5165\u7ed3\u70b9\n                child = TrieNode(value=item)\n                cur_node.children[item] = child\n                cur_node = child\n            else:\n                cur_node = cur_node.children[item]\n        cur_node.tail = self.count\n\n    def ac_automation(self):\n        \\\"\\\"\\\"\n        \u6784\u5efa\u5931\u8d25\u8def\u5f84\n        :return:\n        \\\"\\\"\\\"\n        queue = [self.root]\n        # BFS\u904d\u5386\u5b57\u5178\u6811\n        while len(queue):\n            temp_node = queue[0]\n            # \u53d6\u51fa\u961f\u9996\u5143\u7d20\n            queue.remove(temp_node)\n            for value in temp_node.children.values():\n                # \u6839\u7684\u5b50\u7ed3\u70b9fail\u6307\u5411\u6839\u81ea\u5df1\n                if temp_node == self.root:\n                    value.fail = self.root\n                else:\n                    # \u8f6c\u5230fail\u6307\u9488\n                    p = temp_node.fail\n                    while p:\n                        # \u82e5\u7ed3\u70b9\u503c\u5728\u8be5\u7ed3\u70b9\u7684\u5b50\u7ed3\u70b9\u4e2d\uff0c\u5219\u5c06fail\u6307\u5411\u8be5\u7ed3\u70b9\u7684\u5bf9\u5e94\u5b50\u7ed3\u70b9\n                        if value.value in p.children:\n                            value.fail = p.children[value.value]\n                            break\n                        # \u8f6c\u5230fail\u6307\u9488\u7ee7\u7eed\u56de\u6eaf\n                        p = p.fail\n                    # \u82e5\u4e3aNone\uff0c\u8868\u793a\u5f53\u524d\u7ed3\u70b9\u503c\u5728\u4e4b\u524d\u90fd\u6ca1\u51fa\u73b0\u8fc7\uff0c\u5219\u5176fail\u6307\u5411\u6839\u7ed3\u70b9\n                    if not p:\n                        value.fail = self.root\n                # \u5c06\u5f53\u524d\u7ed3\u70b9\u7684\u6240\u6709\u5b50\u7ed3\u70b9\u52a0\u5230\u961f\u5217\u4e2d\n                queue.append(value)\n\n    def search(self, text):\n        \\\"\\\"\\\"\n        \u6a21\u5f0f\u5339\u914d\n        :param self:\n        :param text: \u957f\u6587\u672c\n        :return:\n        \\\"\\\"\\\"\n        p = self.root\n        # \u8bb0\u5f55\u5339\u914d\u8d77\u59cb\u4f4d\u7f6e\u4e0b\u6807\n        # start_index = 0\n        # \u6210\u529f\u5339\u914d\u7ed3\u679c\u96c6\n        # rst = defaultdict(list)\n        # for i in range(len(text)):\n            # single_char = text[i]\n        for single_char in text:\n            rst=False\n            while single_char not in p.children and p is not self.root:\n                p = p.fail\n            # \u6709\u4e00\u70b9\u7455\u75b5\uff0c\u539f\u56e0\u5728\u4e8e\u5339\u914d\u5b50\u4e32\u7684\u65f6\u5019\uff0c\u82e5\u5b57\u7b26\u4e32\u4e2d\u90e8\u5206\u5b57\u7b26\u7531\u4e24\u4e2a\u5339\u914d\u8bcd\u7ec4\u6210\uff0c\u6b64\u65f6\u540e\u4e00\u4e2a\u8bcd\u7684\u524d\u7f00\u4e0b\u6807\u4e0d\u4f1a\u66f4\u65b0\n            # \u8fd9\u662f\u7531\u4e8eKMP\u7b97\u6cd5\u672c\u8eab\u5bfc\u81f4\u7684\uff0c\u76ee\u524d\u4e0e\u4e0b\u6587\u5faa\u73af\u5bfb\u627e\u6240\u6709\u5339\u914d\u8bcd\u5b58\u5728\u51b2\u7a81\n            # \u4f46\u662f\u95ee\u9898\u4e0d\u5927\uff0c\u56e0\u4e3a\u5176\u6807\u8bb0\u7684\u4f4d\u7f6e\u5747\u4e3a\u5339\u914d\u6210\u529f\u7684\u5b57\u7b26\n            # if single_char in p.children and p is self.root:\n                # start_index = i\n            # \u82e5\u627e\u5230\u5339\u914d\u6210\u529f\u7684\u5b57\u7b26\u7ed3\u70b9\uff0c\u5219\u6307\u5411\u90a3\u4e2a\u7ed3\u70b9\uff0c\u5426\u5219\u6307\u5411\u6839\u7ed3\u70b9\n            if single_char in p.children:\n                p = p.children[single_char]\n            else:\n                # start_index = i\n                p = self.root\n            temp = p\n            while temp is not self.root:\n                # \u5c3e\u6807\u5fd7\u4e3a0\u4e0d\u5904\u7406\uff0c\u4f46\u662ftail\u9700\u8981-1\u4ece\u800c\u4e0e\u654f\u611f\u8bcd\u5b57\u5178\u4e0b\u6807\u4e00\u81f4\n                # \u5faa\u73af\u539f\u56e0\u5728\u4e8e\uff0c\u6709\u4e9b\u8bcd\u672c\u8eab\u53ea\u662f\u53e6\u4e00\u4e2a\u8bcd\u7684\u540e\u7f00\uff0c\u4e5f\u9700\u8981\u8fa8\u8bc6\u51fa\u6765\n                if temp.tail:\n                    # rst[self.words[temp.tail - 1]].append((start_index, i))\n                    rst=True\n                temp = temp.fail\n            yield rst\n        # return rst\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        trie=Trie(words)\n        self.chars=[]\n        self.f=trie.search((x for x in self.chars))\n\n    def query(self, letter: str) -> bool:\n        self.chars.append(letter)\n        return next(self.f)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = dict()\n        self.is_word = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()        \n        \n    def add_word(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()    \n            node = node.children[c]    \n        node.is_word = True    \n    \n    def find_any(self, word):   \n        node = self.root\n        for c in word:\n            if node.is_word: return True\n            if c not in node.children: return False\n            node = node.children[c]    \n        return node.is_word\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words: self.trie.add_word(word[::-1])\n        self.cur = ''    \n        \n\n    def query(self, letter: str) -> bool:\n        self.cur += letter\n        return self.trie.find_any(self.cur[::-1])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.terminal = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.queue = collections.deque()\n        self.words = words\n        \n        self.root = TrieNode()\n        \n        for word in self.words:\n            node = self.root\n            \n            for c in reversed(word):\n                if c not in node.children:\n                    node.children[c] = TrieNode()\n                node = node.children[c]\n                \n            node.terminal = True\n            \n        \n\n    def query(self, letter: str) -> bool:\n        self.queue.appendleft(letter)\n        \n        node = self.root\n        \n        if letter in node.children:\n            for l in self.queue:\n                if l in node.children:\n                    node = node.children[l]\n                    if node.terminal:\n                        return True\n                else:\n                    return False\n                \n        \n        \n        \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic={}\n        for word in words:\n            if word[-1] not in self.dic: self.dic[word[-1]]=[word[:-1]]\n            else: self.dic[word[-1]].append(word[:-1])\n        self.string=\\\"\\\"\n        \n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length=len(word)+1\n                complete_word=word+letter\n                if len(self.string) >= length and complete_word==self.string[-length:]: return True\n            return False\n        else: return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.dict = {};\n        self.isEnd = False;\n        \n    \nclass StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        for i in words:self.insert(i[::-1]);\n        self.cur = \\\"\\\";\n    \n    def insert(self,word):\n        temp = self.root;\n        for i in word:\n            if(i not in temp.dict):temp.dict[i] = Trie();\n            temp = temp.dict[i];\n        temp.isEnd = True;\n        return;\n    \n    def check(self,word):\n        temp = self.root;\n        word = word[::-1];\n        for i in word:\n            if(i not in temp.dict):return False;\n            temp = temp.dict[i];\n            if(temp.isEnd):return True;\n        return temp.isEnd;\n        \n    def query(self, letter: str) -> bool:\n        self.cur += letter;\n        return self.check(self.cur);\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = set(words)\n        self.queries = ''\n\n    def query(self, letter: str) -> bool:\n        self.queries += letter\n        for word in self.stream:\n            if letter == word[~0]:\n                if word == self.queries[-len(word):]:\n                    return True\n        return False\n                \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "EOW = '*'\nclass StreamChecker:\n    queries = []\n    \n    def __init__(self, words: List[str]):\n        self.root = {}\n        for word in words:\n            node = self.root\n            for c in word:\n                if c in node:\n                    node = node[c]\n                else:\n                    node[c] = {}\n                    node = node[c]\n            if not EOW in node:\n                node[EOW] = True\n\n    def query(self, letter: str) -> bool:\n        self.queries = [q[letter] for q in self.queries if letter in q]\n        if letter in self.root:\n            self.queries.append(self.root[letter])\n        \n        return any([q for q in self.queries if EOW in q])\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        for word in words:\n            curnode = self.root\n            for ch in word:\n                if ch not in curnode:\n                    curnode[ch] = {}\n                curnode = curnode[ch]\n            curnode['is_end'] = True\n        self.leads = [self.root] # the pointers to the threads we follow right now\n\n    def query(self, letter: str) -> bool:\n        next_leads = [self.root]\n        found_word = False\n        for lead in self.leads:\n            if letter in lead:\n                new_lead = lead[letter]\n                next_leads.append(new_lead)\n                if 'is_end' in new_lead:\n                    found_word = True\n        self.leads = next_leads\n        return found_word", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = {}\n        self.words = set()\n        words_ = [word[::-1] for word in set(words)]\n        for word in words_:\n            for i in range(len(word)-1):\n                self.memo[word[:i+1]]=0\n        \n        for word in words_:\n            self.memo[word]=1     \n        \n        self.hist = []\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.append(letter)\n        w = ''\n        for i in range(len(self.hist)-1,-1,-1):\n            w+=self.hist[i]\n            #print(w)\n            c = self.memo.get(w,None)\n            if c is None:\n                return False\n            if c:\n                return True\n            \n        return False\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.END = '0'\n        self.q = ''\n\n        for word in words:\n            curr_dict = self.root\n            for letter in word[::-1]:  # save in reverse\n                curr_dict = curr_dict.setdefault(letter, {})\n            curr_dict[self.END] = self.END\n\n    def query(self, letter: str) -> bool:\n        self.q += letter\n        curr_node = self.root\n        for l in self.q[::-1]:  # search in reverse as well\n            if l in curr_node:\n                curr_node = curr_node.get(l)\n            else:\n                return False\n            if self.END in curr_node:\n                return True\n        return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = \\\"\\\"\n        self.dictionary = {}\n        for word in words:\n            location = self.dictionary\n            for char in word[::-1]:\n                if char not in location:\n                    location[char] = {}\n                location = location[char]\n            location[\\\"goodbye\\\"] = True\n\n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        count = -1\n        location = self.dictionary\n        for char in self.stream[::-1]:\n            if char in location:\n                if \\\"goodbye\\\" in location[char]:\n                    return True\n                location = location[char]\n                continue\n            return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        self.d = {}\n        self.queries = \\\"\\\"\n        for word in words:\n            self.d.setdefault(word[-1],set())\n            self.d[word[-1]].add(word[:-1])\n        \n\n    def query(self, letter: str) -> bool:\n        self.queries += letter\n        if letter not in self.d: return False\n        for word in self.d[letter]:\n            if(len(self.queries)>=len(word)+1)and((word+letter) == self.queries[-(len(word)+1):]): return True\n        return False\n                \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['end'] = True\n        \n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes = []\n        \n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes = new_nodes\n        return temp\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = list(set(words))\n        self.chars = \\\"\\\"\n        self._single_letters = set(w for w in words if len(w) == 1)\n        self._last_letters = set(w[-1] for w in words)\n        self._last_pairs = set(w[-2:] for w in words)\n        \n    def query(self, letter: str) -> bool:\n        self.chars += letter\n        if letter not in self._last_letters:\n            return False\n        if letter in self._single_letters:\n            return True\n        if self.chars[-2:] not in self._last_pairs:\n            return False\n        return any(self.chars.endswith(w) for w in self.words)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.memo = ''\n        \n        for w in words:\n            ptr = self.root\n            for c in w[::-1]:\n                if c not in ptr:\n                    ptr[c] = {}\n                ptr = ptr[c]\n            ptr['#'] = ''\n        \n\n    def query(self, letter: str) -> bool:\n        self.memo += letter\n        ptr = self.root\n        for c in self.memo[::-1]:\n            if c not in ptr:\n                return False\n            ptr = ptr[c]\n            if '#' in ptr:\n                return True\n            \n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\n\nclass Node:\n\n    def __init__(self) -> object:\n        self.children = dict()\n        self.isEND = False\n        self.fail = None\n\n\nclass Trie:\n\n    def __init__(self):\n        self.root = Node()\n\n    def insert(self, words):\n        current_node = self.root\n        for w in words:\n            if current_node.children.get(w, None) is None:\n                current_node.children[w] = Node()\n            current_node = current_node.children[w]\n\n        current_node.isEND = True\n        # current_node.word = words\n\n    def built_failover(self):\n\n        q = deque()\n        current = self.root\n        for ch in self.root.children:\n            self.root.children[ch].fail = self.root\n            q.append(self.root.children[ch])\n        while q:\n            node = q.popleft()\n            for ch in node.children:\n                q.append(node.children[ch])\n                failover = node.fail\n                while True:\n                    if failover is None:\n                        node.children[ch].fail = self.root\n                        break\n                    if ch in failover.children:\n                        node.children[ch].fail = failover.children[ch]\n                        break\n                    else:\n                        failover = failover.fail\n\n        \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        # self.q = deque()\n        for word in words:\n            self.trie.insert(word)\n        self.trie.built_failover()\n        self.curr = self.trie.root\n\n        \n\n    def query(self, letter: str) -> bool:\n        result = False\n        while True:\n            if letter in self.curr.children:\n                \n                self.curr = self.curr.children[letter]\n                \n                if self.curr.isEND:\n                    result = True\n                if self.curr.fail !=None and self.curr.fail.isEND:\n                    result = True\n                break\n            elif self.curr.fail == None:\n                self.curr = self.trie.root\n                break\n            else:\n                self.curr= self.curr.fail\n        return result\n\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T=lambda: collections.defaultdict(T)\n        self.trie=T()\n        self.waiting=[]\n        for w in words:\n            d=self.trie\n            for c in w:\n                d=d[c]\n            d=d['#']\n\n    def query(self, letter: str) -> bool:\n        self.waiting=[node[letter] for node in self.waiting+[self.trie] if letter in node]\n        return any(d for d in self.waiting if '#' in d)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.letters = \\\"\\\"\n        self.trie = {}\n        for word in words:\n            node = self.trie\n            for ch in reversed(word):\n                if ch not in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = '$'\n\n    def query(self, letter: str) -> bool:\n        self.letters += letter\n        node = self.trie\n        for ch in self.letters[::-1]:\n            if ch not in node:\n                return False\n            node = node[ch]\n            if '$' in node:\n                return True\n            \n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t={}\n        for word in words:\n            curr=self.t\n            for i in word[::-1]:\n                if i not in curr:\n                    curr[i]={}\n                curr=curr[i]\n            curr['end']=True\n        self.s=''\n    def query(self, letter: str) -> bool:\n        self.s+=letter\n        curr=self.t\n        for i in self.s[::-1]:\n            if i not in curr:\n                return False\n            if i in curr:\n                curr=curr[i]\n            if 'end' in curr:\n                return True\n        return False\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.h = {}\n        for word in words:\n            curr_node = self.h           \n            for x in range(len(word)):\n                curr = word[x]\n                if curr not in curr_node: curr_node[curr] = {}\n                curr_node = curr_node[curr]\n            curr_node[\\\"#\\\"] = True\n        self.nodes = []\n\n        \n    def query(self, letter: str) -> bool:\n        result = False\n        self.nodes.append(self.h)\n        new = []\n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if \\\"#\\\" in node: result = True\n                new.append(node)\n        self.nodes = new     \n        return result\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.end = -1\n        for w in words:\n            self.insert(w)\n        self.qhist = ''\n\n    def insert(self, word):\n        curNode = self.root\n        for c in word[::-1]:\n            if not c in curNode:\n                curNode[c] = {}\n            curNode = curNode[c]\n        curNode[self.end] = True\n\n    def query(self, letter: str) -> bool:\n        self.qhist += letter\n        curNode = self.root\n        for c in self.qhist[::-1]:\n            if not c in curNode:\n                return False\n            curNode = curNode[c]\n            if self.end in curNode:\n                return True\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.history = \\\"\\\"\n        self.map = {}\n        \n        for word in words:\n            curr_node = self.map\n            for letter in word[::-1]:\n                if letter not in curr_node:\n                    curr_node[letter] = {}\n                curr_node = curr_node[letter]\n            curr_node['#'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.history += letter\n\n        curr_node = self.map\n        for l in self.history[::-1]:\n\n            if l not in curr_node:\n                return False\n                    \n            curr_node = curr_node[l]\n        \n            if '#' in curr_node:\n                return True\n        \n        return False\n\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.prefix = ''\n        for word in words:\n            node = self.root\n            for c in word[::-1]:\n                if c not in node.children:\n                    node.children[c] = TrieNode()\n                node = node.children[c]\n            node.is_word = True\n\n    def query(self, letter: str) -> bool:\n        self.prefix += letter\n        node = self.root\n        for c in self.prefix[::-1]:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n            if node.is_word:\n                return True\n        \n        return False\n        \n        \n                    \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    \n    def __init__(self):\n        \n        self.children = {}\n        self.isWord = False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = TrieNode()\n        self.prefix = \\\"\\\"\n        ######################### SAVE IN REVERSED ORDER !!!!!!!!!!!!!!!!!!!!\n        for word in words:\n            cur = self.trie\n            for char in word[::-1]:\n                if not cur.children.get(char):\n                    cur.children[char] = TrieNode()\n                cur = cur.children[char]\n            cur.isWord = True\n            \n    def query(self, letter: str) -> bool:\n        self.prefix += letter\n        cur = self.trie\n        for char in self.prefix[::-1]:\n            if not cur.children.get(char):\n                return False\n            cur = cur.children[char]\n            if cur.isWord:\n                return True\n            ", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = \\\"\\\"\n        self.max_len = max(len(word) for word in words)\n        self.trie = {}\n        self._build_trie(words)\n        \n    def query(self, letter: str) -> bool:\n        self.stream += letter\n        if len(self.stream) > self.max_len:\n            self.stream = self.stream[1:]\n            \n        node = self.trie\n        for char in self.stream[::-1]:\n            if '$' in node:\n                return True\n            elif char not in node:\n                return False\n            else:\n                node = node[char]\n        \n        return '$' in node\n        \n    def _build_trie(self, words: List[str]):\n        for word in words:\n            node = self.trie\n            for char in word[::-1]:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['$'] = word\n    \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        \n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and complete_word == self.string[- length:]:\n                    return True\n        return False\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self, word, end):\n        self.children = word\n        self.end = end\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie({}, False)\n        for word in words:\n            cur = self.trie\n            for char in word[::-1]:\n                if not char in cur.children:\n                    cur.children[char]=Trie({},False)\n                cur = cur.children[char]\n            cur.end = True\n        self.history = ''\n            \n    def query(self, letter: str) -> bool:\n        # stream next letter if it's in children\n        # new = self.trie\n        # self.streamer.append(new)\n        # i = 0\n        # n = len(self.streamer)\n        # res = False\n        # while i<n:\n        #     pointer = self.streamer.popleft()\n        #     #print(pointer.children)\n        #     if letter in pointer.children:\n        #         self.streamer.append(pointer.children[letter])\n        #         if pointer.children[letter].end:\n        #             res = True\n        #     i+=1\n        self.history += letter\n        streamer = self.trie\n        for c in self.history[::-1]:\n            if c not in streamer.children:\n                return False\n            elif streamer.children[c].end:\n                return True\n            streamer = streamer.children[c]\n        return False\n                             \n                             \n\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dict = set([w[::-1] for w in words])\n        self.prev = \\\"\\\"\n        \n\n    def query(self, letter: str) -> bool:\n        self.prev = letter + self.prev\n        for s in self.dict:\n            if self.prev.startswith(s): return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = dict()\n        self.is_word = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()        \n        \n    def add_word(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()    \n            node = node.children[c]    \n        node.is_word = True    \n        \n    def find(self, word):   \n        node = self.root\n        for c in word:\n            if c not in node.children: return False\n            node = node.children[c]    \n        return node.is_word\n    \n    def find_any(self, word):   \n        node = self.root\n        for c in word:\n            if node.is_word: return True\n            if c not in node.children: return False\n            node = node.children[c]    \n        return node.is_word\n    \n    def start_with(self, pattern):   \n        node = self.root\n        for c in pattern:\n            if c not in node.children: return False\n            node = node.children[c]    \n        return True   \n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.add_word(word[::-1])\n        self.cur = ''    \n        \n\n    def query(self, letter: str) -> bool:\n        self.cur += letter\n        return self.trie.find_any(self.cur[::-1])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.words=[word[::-1] for word in words]\n        self.string=''\n        self.l=0\n        self.createTrie()\n    def createTrie(self):\n        for i in self.words:\n            t=self.trie\n            for j in i:\n                if j not in t:\n                    t[j]=dict()\n                t=t[j]\n            t['*']=dict()\n    def query(self, letter: str) -> bool:\n        self.string+=letter\n        self.l+=1\n        trie=self.trie\n        for i in self.string[::-1]:\n            if i in trie:\n                trie=trie[i]\n                if '*' in trie:\n                    return True\n            else:\n                return False\n        return False\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dic = {}\n        for word in words:\n            if word[-1] not in self.dic:\n                self.dic[word[-1]] = [word[:-1]]\n            else:\n                self.dic[word[-1]].append(word[:-1])\n        \n        self.string = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        if letter in self.dic:\n            for word in self.dic[letter]:\n                length = len(word) + 1\n                complete_word = word + letter\n                if len(self.string) >= length and \\\\\n                complete_word == self.string[len(self.string)-length:]:\n                    return True\n            return False\n        else:\n            return False\n            \n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.max_len = 0\n        self.dequeue = collections.deque()\n        self.suffix_dict = dict()\n\n        for w in set(words):\n            self.max_len = max(self.max_len, len(w))\n            for i in reversed(range(len(w))):\n                suffix = \\\"\\\".join(reversed(w[i:]))\n                if suffix not in self.suffix_dict:\n                    self.suffix_dict[suffix] = False\n                if i == 0:\n                    self.suffix_dict[suffix] = True\n\n        #print (self.suffix_dict)\n\n    def query(self, letter: str) -> bool:\n        if len(self.dequeue) >= self.max_len:\n            self.dequeue.popleft()\n        self.dequeue.append(letter)\n\n        #print(letter, self.dequeue)\n\n        reversed_word = ''\n        for i in reversed(range(len(self.dequeue))):\n            c = self.dequeue[i]\n            reversed_word = reversed_word + c\n\n            #print(reversed_word)\n            if reversed_word in self.suffix_dict:\n                if self.suffix_dict[reversed_word]:\n                    return True\n            else:\n                return False\n\n        return False", "class StreamChecker:\n    \n    openDicts = []\n    cache = {}\n    words = []\n    acc = \\\"\\\"\n    \n    def __init__(self, words: List[str]):\n        self.t = {}\n        self.acc = \\\"\\\"\n        for w in words:\n            d = self.t\n            for c in w[::-1]:\n                d[c] = d.get(c, {})\n                d = d[c]\n            d['end'] = True    \n        self.openDicts = [self.t]\n        self.words = words\n        # print(self.t)\n        \n    def query(self, letter: str) -> bool:\n        self.acc += letter\n        d = self.t\n        for c in self.acc[::-1]:\n            if 'end' in d:\n                return True\n            elif c in d:\n                d = d[c]\n            else:\n                return False\n        return 'end' in d    \n            \n        \n        \n        \n#         def check(a) -> bool:\n#             d = self.t\n#             for i, c in enumerate(a[::-1]):\n#                 if c in d:\n#                     d = d[c]\n#                 else:\n#                     return False\n#             self.cache[a] = d\n#             return 'end' in d    \n        \n#         for i in range(len(self.acc)):\n#             if check(tuple(self.acc[i:])):\n#                 return True\n        \n#         return False\n        \n        \n#         print('=== ', letter)\n#         toDel = []\n#         toAppend = []\n#         foundEnd = False\n#         for i, d in enumerate(self.openDicts):\n#             if letter in d:\n#                 print('found', letter)\n#                 toAppend.append(d[letter])\n#                 print(toAppend)\n#                 if 'end' in d[letter]:\n#                     foundEnd = True\n#             else:\n#                 toDel.append(i)\n        \n#         toDel.sort(reverse=True)\n#         for i in toDel:\n#             if self.openDicts[i] != self.t:\n#                 del self.openDicts[i]\n#                 print('del', i)\n#         for a in toAppend:\n#             self.openDicts.append(a)\n        \n#         print('after del', self.openDicts)\n#         print('>>=== ', letter)\n#         return foundEnd\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words=set(words)\n        self.maxx = len(max(self.words,key=len))\n        self.tails = set()\n        for word in self.words:\n            self.tails.add(word[-1])\n        self.qs = ''\n    \n\n    def query(self, letter: str) -> bool:\n        self.qs +=letter\n        if len(self.qs)>self.maxx:\n            self.qs = self.qs[1:]\n        if letter not in self.tails:\n            return False\n        N = len(self.qs)\n        return any((self.qs[i:N] in self.words for i in range(N)))\n        # return letter in self.words\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            node = self.trie\n            for c in word[::-1]:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['$'] = True\n        self.queries = ''\n        self.W = max(list(map(len, words)))\n\n    def query(self, letter: str) -> bool:\n        ret = False\n        self.queries += letter\n        node = self.trie\n        for c in self.queries[::-1][:self.W]:\n            if c in node:\n                node = node[c]\n                if '$' in node:\n                    return True\n            else:\n                return False\n        return False\n        \n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from typing import List\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.wordsSet = Trie(words)\n        self.letters = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.letters += letter\n        tmpLetterSequence = \\\"\\\"\n        for i in range(len(self.letters)-1,-1,-1):\n            tmpLetterSequence += self.letters[i]\n            if not self.wordsSet.isPrefix(tmpLetterSequence):\n                return False\n            if self.wordsSet.hasWord(tmpLetterSequence):\n                return True\n        return False\n\n\nclass Node:\n    def __init__(self):\n        self.children = [None] * 26\n        self.end = False\n\n\nclass Trie:\n    def __init__(self, words):\n        self.root = Node()\n        for word in words:\n            tmpRoot = self.root\n            for j in range(len(word) -1 , -1, -1):\n                letter = word[j]\n                if tmpRoot.children[ord(letter)-ord('a')] is None:\n                    tmpRoot.children[ord(letter)-ord('a')] = Node()\n                tmpRoot = tmpRoot.children[ord(letter)-ord('a')]\n            tmpRoot.end = True\n\n    def isPrefix(self, word):\n        tmpRoot = self.root\n        for letter in word:\n            if tmpRoot.children[ord(letter) - ord('a')] is None:\n                return False\n            tmpRoot = tmpRoot.children[ord(letter) - ord('a')]\n        return True\n\n    def hasWord(self, word):\n        tmpRoot = self.root\n        for letter in word:\n            if tmpRoot.children[ord(letter) - ord('a')] is None:\n                return False\n            tmpRoot = tmpRoot.children[ord(letter) - ord('a')]\n        if tmpRoot.end:\n            return True\n        return False", "from collections import deque, defaultdict\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.stream = deque(maxlen=2000)\n        \n        # organize based on last letter\n        self.words_dict = defaultdict(list)\n        for word in self.words:\n            self.words_dict[word[-1]].append(word)\n\n    def query(self, letter: str) -> bool:\n        \n        self.stream.append(letter)\n        \n        # for word in self.words:\n        for word in self.words_dict[letter]:\n            if len(word) <= len(self.stream):\n                for i in range(len(word)):\n                    if word[-(i+1)] != self.stream[-(i+1)]:\n                        break\n                else:\n                    return True\n                # if word == ''.join(self.stream[-len(word):]):\n                #     return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TreeNode:\n    def __init__(self):\n        self.children = dict()\n        self.isWord = False \n    \n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TreeNode()\n        self.sofar = ''\n        for word in words:\n            self.add(word)\n    \n    def add(self, word):\n        node = self.root\n        for w in word[::-1]:\n            if w not in node.children:\n                node.children[w] = TreeNode()\n            node = node.children[w]\n        node.isWord = True\n                \n        \n        \n        \n    def query(self, letter: str) -> bool:\n        self.sofar += letter\n        node = self.root\n        for c in self.sofar[::-1]:\n            if c in node.children:\n                node = node.children[c]\n                if node.isWord:\n                    return True\n            else:\n                return False\n        return node.isWord\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node(object):\n    \n    def __init__(self):\n        self.children = {}\n        self.end = False\n        \n    def add(self, word):\n        cur = self\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = Node()\n            cur = cur.children[c]\n        cur.end = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        for word in words:\n            self.root.add(word[::-1])\n        self.s = []\n        self.cur = self.root\n            \n    def query(self, letter: str) -> bool:\n        self.s.append(letter)\n        i = len(self.s) - 1\n        cur = self.root\n        while i >= 0:\n            c = self.s[i]\n            if c not in cur.children:\n                return False\n            cur = cur.children[c]\n            if cur.end:\n                return True\n            i -= 1\n        return False\n    \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.trie = {}\n        self.pointers = []\n        \n        for word in words:\n            curr = self.trie\n            for char in word + '0':\n                if char not in curr:\n                    curr[char] = {}\n                curr = curr[char]\n\n    def query(self, letter: str) -> bool:\n        \n        new_pointers = []\n        hasFound = False\n        \n        for pointer in self.pointers:\n            if letter in pointer:\n                new_pointers.append(pointer[letter])\n        \n        if letter in self.trie:\n            new_pointers.append(self.trie[letter])\n        \n        self.pointers = new_pointers\n        \n        for pointer in self.pointers:\n            if '0' in pointer:\n                return True\n        \n        return False\n", "class Node:\n    def __init__(self):\n        self.children = {}\n        self.stop = False\n        \nclass Trie:\n    def __init__(self):\n        self.word = Node()\n    \n    def insert(self, word):\n        word = word[::-1]\n        curr = self.word\n        for l in word:\n            node = curr.children.get(l, Node())\n            curr.children[l] = node\n            curr = node\n        curr.stop = True\n        \n#     def startsWith(self, letter):\n#         curr = self.word\n        \n#         for l in letter:\n#             node = curr.children.get(l, None)\n#             if not node:\n#                 return False\n#             curr = node\n#         return True\n    \n    def search(self, word):\n        curr = self.word\n        \n        for l in word:\n            node = curr.children.get(l, None)\n            \n            if not node:\n                return False\n            elif node.stop:\n                return True\n            curr = node\n        return curr.stop\n    \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        for word in words:\n            self.t.insert(word)\n        self.pointer = ''\n\n    def query(self, letter: str) -> bool:\n        self.pointer += letter\n\n        return self.t.search(self.pointer[::-1])\n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        for word in words:\n            node = self.trie\n            for c in word:\n                if c not in node:\n                    node[c] = dict()\n                node = node[c]\n            node['.'] = '.'\n\n        self.curs = []\n\n    def query(self, letter: str) -> bool:\n        trie, curs = self.trie, self.curs\n        \n        ans = False\n        \n        new_curs = []\n        for cur in curs:\n            if letter in cur:\n                new_cur = cur[letter]\n                ans = ans or '.' in new_cur\n                new_curs.append(new_cur)\n                \n        if letter in trie:\n            new_cur = trie[letter]\n            ans = ans or '.' in new_cur\n            new_curs.append(new_cur)\n        \n        self.curs = new_curs\n\n        return ans", "#\nclass TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie(): \n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word): \n        node = self.root \n        for char in word: \n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.currquery = \\\"\\\"\n        self.trie = Trie()\n        for word in words: \n            self.trie.insert(word[::-1])\n    \n    def query(self, letter: str) -> bool:\n        self.currquery += letter\n        node = self.trie.root\n        for i in self.currquery[::-1]: \n            if i not in node.children: \n                return False\n            else: \n                node = node.children[i]\n                if node.isEnd:\n                    return True\n                \n                \n    \n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            curr = self.trie\n            for char in word:\n                if char not in curr:\n                    curr[char] = {}\n                curr = curr[char]\n            curr[\\\"#\\\"] = True\n        self.pointers = deque()\n\n    def query(self, letter: str) -> bool:\n        tmp = deque()\n        self.pointers.append(self.trie)\n        for p in self.pointers:\n            if letter in p:\n                tmp.append(p[letter])\n        self.pointers = tmp\n        for p in self.pointers:\n            if \\\"#\\\" in p:\n                return True\n        return False\n            \n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import deque\n\nclass TrieNode(object):\n    def __init__(self):\n        self.children = {}\n        self.nextFail = None\n        self.suffixMatches = None\n\n    def add(self, word, index=0):\n        #print(word)\n        if len(word) == index:\n            self.boundary = True\n            self.suffixMatches = [word]\n            return\n        c = word[index]\n        if self.children.get(c, None) is None:\n            self.children[c] = TrieNode()\n        self.children[c].add(word, index + 1)\n    def __str__(self):\n        return self.__str2()\n\n    def __str2(self, indent=0):\n        space = \\\"  \\\"*indent\n        return \\\"{}TrieNode(h={}, B={}, nf={},\\\n{}\\\".format(\n            space,\n            hash(self), self.suffixMatches, hash(self.nextFail) if self.nextFail else \\\"None\\\", \\\"\\\".join(space + k + \\\": \\\" + v.__str2(indent+1) + \\\"\\\n\\\" for k, v in self.children.items()),\n            space\n        ) + space + \\\")\\\"\n\n\nclass AhoTrie(object):\n    def __init__(self, words):\n        self.root = TrieNode()\n        for word in words:\n            self.root.add(word)\n        self.__oho()\n\n    def __oho(self):\n        q = deque()\n        for c, node in self.root.children.items():\n            node.nextFail = self.root\n            q.append(node)\n        while len(q) > 0:\n            node = q.popleft()\n            \n            for c, child in node.children.items():\n                nextFail = node.nextFail\n                while not nextFail.children.get(c) and nextFail is not self.root:\n                    nextFail = nextFail.nextFail\n                if not nextFail.children.get(c):\n                    child.nextFail = nextFail\n                else:\n                    child.nextFail = nextFail.children.get(c)\n\n                q.append(child)\n                #child.nextFail = node.nextFail.children.get(c, node.nextFail)\n                if child.suffixMatches:\n                    nextFail = child.nextFail\n                    while nextFail is not self.root and not nextFail.suffixMatches:\n                        nextFail = nextFail.nextFail\n                    if nextFail is not self.root:\n                        child.suffixMatches.extend(nextFail.suffixMatches)\n\n\n\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        print(words)\n        self.trie = AhoTrie(words) \n        self.root = self.trie.root\n        self.cur = self.root\n        #print(self.root)\n        \n\n    def query(self, letter: str) -> bool:\n        \n        \n        while not self.cur.children.get(letter) and self.cur is not self.root:\n            self.cur = self.cur.nextFail\n        #print(hash(self.cur))\n        if self.cur.children.get(letter):\n            self.cur = self.cur.children[letter]\n            temp = self.cur\n            while temp is not self.root:\n                if temp.suffixMatches:\n                    return True\n                temp = temp.nextFail\n        return False\n            \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            cur = self.trie\n            for l in word:\n                if l not in cur:\n                    cur[l] = {}\n                cur = cur[l]\n            cur[\\\"#\\\"]=True\n        self.stream=deque()\n        \n\n    def query(self, letter: str) -> bool:\n        temp = deque()\n        self.stream.append(self.trie)\n        for p in self.stream:\n            if letter in p:\n                temp.append(p[letter])\n        self.stream = temp\n        \n        for p in self.stream:\n            if \\\"#\\\" in p:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            cur = self.trie #root\n            for char in word:\n                if char not in cur:\n                    cur[char] = {}\n                cur = cur[char]\n            cur['#'] = True\n        self.stream = deque()\n\n    def query(self, letter: str) -> bool:\n        temp = deque()\n        self.stream.append(self.trie)\n        for p in self.stream:\n            if letter in p:\n                temp.append(p[letter])     \n        self.stream = temp\n        for p in self.stream:\n            if '#' in p:\n                return True\n        return False\n                \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n        \n        for word in set(words):\n            node = self.trie\n            for char in word[::-1]:\n                if not char in node:\n                    node[char] = {}\n                node = node[char]\n            node['$'] = word\n        print((self.trie))\n        \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for char in self.stream:\n            if '$' in node:\n                return True\n            elif char not in node:\n                return False\n            node = node[char]\n        return '$' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\n\nclass TrieNode:\n    \n    def __init__(self):\n        \n        self.dict = defaultdict(TrieNode)\n        self.is_word = False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        '''\n        Build a trie for each word in reversed order\n        '''\n\\t\\t\n        # for user query record, init as empty string\n        self.prefix = ''\n        \n        # for root node of trie, init as empty Trie\n        self.trie = TrieNode()\n        \n        for word in words:\n            \n            cur_node = self.trie\n            \n\\t\\t\\t# make word in reverse order\n            word = word[::-1]\n            \n            for char in word:                \n                cur_node = cur_node.dict[ char ]\n            \n\\t\\t\\t# mark this trie path as a valid word\n            cur_node.is_word = True\n            \n            \n            \n    def query(self, letter: str) -> bool:\n        '''\n        Search user input in trie with reversed order\n        '''\n\\t\\t\n        self.prefix += letter\n        \n        cur_node = self.trie\n        for char in reversed(self.prefix):\n            \n            if char not in cur_node.dict:\n                # current char not in Trie, impossible to match words\n                break\n            \n            cur_node = cur_node.dict[char]\n        \n            if cur_node.is_word:\n                # user input match a word in Trie\n                return True\n        \n        # No match\n        return False\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.max_len = 0\n        self.dequeue = collections.deque()\n        self.suffix_dict = dict()\n\n        for w in set(words):\n            self.max_len = max(self.max_len, len(w))\n            for i in reversed(range(len(w))):\n                suffix = \\\"\\\".join(reversed(w[i:]))\n                if suffix not in self.suffix_dict:\n                    self.suffix_dict[suffix] = False\n                if i == 0:\n                    self.suffix_dict[suffix] = True\n\n    def query(self, letter: str) -> bool:\n        if len(self.dequeue) >= self.max_len:\n            self.dequeue.popleft()\n        self.dequeue.append(letter)\n\n        reversed_word = ''\n        for i in reversed(range(len(self.dequeue))):\n            c = self.dequeue[i]\n            reversed_word = reversed_word + c\n\n            if reversed_word in self.suffix_dict:\n                if self.suffix_dict[reversed_word]:\n                    return True\n            else:\n                return False\n\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "IS_CHAR = \\\".\\\"\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            node = self.trie\n            for c in word:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node[IS_CHAR] = word\n\n        self.active_nodes = []\n\n    def query(self, letter: str) -> bool:\n        self.active_nodes = [node[letter] for node in self.active_nodes + [self.trie,] if letter in node]\n        return any(IS_CHAR in node for node in self.active_nodes)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            cur = self.trie\n            for l in word:\n                if l not in cur:\n                    cur[l] = {}\n                cur = cur[l]\n            cur[\\\"#\\\"] = True\n        self.stream = deque()\n\n    def query(self, letter: str) -> bool:\n        temp = deque()\n        self.stream.append(self.trie)\n        for p in self.stream:\n            if letter in p:\n                temp.append(p[letter])\n        self.stream = temp\n        for p in self.stream:\n            if \\\"#\\\" in p: return True\n        return False", "class StreamChecker:\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            p = self.trie\n            for c in word:\n                if c not in p: p[c] = {}\n                p = p[c]\n            \n            p['$'] = True\n        \n        self.pointers = []\n        \n    def query(self, letter: str) -> bool:\n        self.pointers.append(self.trie)\n        \n        new_pointers = []\n        found = False\n        for pointer in self.pointers:\n            if letter in pointer:\n                new_pointers.append(pointer[letter])\n                if '$' in pointer[letter]: found = True\n        self.pointers = new_pointers\n        return found\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            cur = self.trie\n            for l in word:\n                if l not in cur:\n                    cur[l] = {}\n                cur = cur[l]\n            cur[\\\"#\\\"] = True\n        self.stream = deque()\n\n    def query(self, letter: str) -> bool:\n        temp = deque()\n        self.stream.append(self.trie)\n        for p in self.stream:\n            if letter in p:\n                temp.append(p[letter])\n        self.stream = temp\n        for p in self.stream:\n            if \\\"#\\\" in p: return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes = []\n        \n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes = new_nodes\n        return temp\n", "class TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.letters = collections.deque()\n        self.trie = Trie()\n        self.maxlen = 0\n        for w in words:\n            self.trie.insert(w[::-1])\n            self.maxlen = max(self.maxlen, len(w))\n        \n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        if len(self.letters) > self.maxlen:\n            self.letters.popleft()\n        i = len(self.letters) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.letters[i] not in node.children:\n                return False\n            node = node.children[self.letters[i]]\n            i -= 1\n        return node.isEnd\n\n\n\n\n\n\n\n\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter: str) -> bool:\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)    \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "# Solution 3: Trie (Accepted)\n# Only a part of suffixes can be the prefix of a word,\n# waiting for characters coming to form a complete word.\n# Instead of checking all W suffixes in each query,\n# we can just save those possible waiting prefixes in a waiting list.\n\n# Explanation\n# Initialization:\n\n# Construct a trie\n# declare a nonlocal waiting list.\n# Query:\n\n# for each node in the waiting list,\n# check if there is child node for the new character.\n# If so, add it to the new waiting list.\n# return true if any node in the waitinglist is the end of a word.\n# Time Complexity:\n# waiting.size <= W, where W is the maximum length of words.\n# So that O(query) = O(waiting.size) = O(W)\n# We will make Q queries, the overall time complexity is O(QW)\n\n# Note that it has same complexity in the worst case as solution 2 (like \\\"aaaaaaaa\\\" for words and query),\n# In general cases, it saves time checking all suffixes, and also the set search in a big set.\n\n# Space Complexity:\n\n# waiting.size <= W, where W is the maximum length of words.\n# waiting list will take O(W)\n\n# Assume we have initially N words, at most N leaves in the trie.\n# The size of trie is O(NW).\n\n# Python:\n# Time: 6000+ms\n\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n    \n    \n\n#     class StreamChecker(object):\n\n#     def __init__(self, words):\n#         \\\"\\\"\\\"\n#         :type words: List[str]\n#         \\\"\\\"\\\"      \n#         self.waitlist = []\n#         self.trie = dict()\n#         for word in words:\n#             # create a temporary dict based off our root dict object\n#             temp_dict = self.trie\n#             for letter in word:\n#                 # update our temporary dict and add our current letter and a sub-dictionary\n#                 # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n#                 # otherwise it will directly return the existing value of key\n#                 temp_dict = temp_dict.setdefault(letter, dict())\n#             # If our word is finished, add {'#': '#'} at the stopping node\n#             temp_dict['#'] = '#'\n\n#     def query(self, letter):\n#         \\\"\\\"\\\"\n#         :type letter: str\n#         :rtype: bool\n#         \\\"\\\"\\\"\n#         waitlist = []\n#         # if letter can be the prefix of word\n#         if letter in self.trie:\n#             waitlist.append(self.trie[letter])\n#         # for each possible prefix, append letter if the new substr still can be a prefix\n#         for item in self.waitlist:\n#             if letter in item:\n#                 waitlist.append(item[letter])\n                \n#         self.waitlist = waitlist\n#         return any('#' in item for item in self.waitlist)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        \n        for word in words:\n            node = self.trie\n            for c in word:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes = []\n        \n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n                \n        self.nodes = new_nodes\n        \n        return temp\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n  def __init__(self, words: List[str]):\n    self.active = []\n    self.root = {}\n\n    for word in words:\n      current = self.root\n      for c in word:\n        if c not in current:\n          current[c] = {}\n        current = current[c]\n      current['word'] = True\n\n  def query(self, letter: str) -> bool:\n    self.active = [node[letter] for node in self.active if letter in node]\n    if letter in self.root:\n      self.active.append(self.root[letter])\n    return any('word' in node for node in self.active)\n    \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n\n        \n\n    def query(self, letter: str) -> bool:\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.queryStr = \\\"\\\"\n        self.trie = dict()\n        for word in words:\n            currNode = self.trie\n            for letter in word[::-1]:\n                if letter not in currNode:\n                    currNode[letter] = {}\n                currNode = currNode[letter]\n            currNode['#'] = {}             \n\n    def query(self, letter: str) -> bool:\n        self.queryStr += letter\n        currNode = self.trie\n        for l in self.queryStr[::-1]:\n            if l not in currNode:\n                return False\n            \n            currNode = currNode[l]\n                \n            if '#' in currNode:\n                return True\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting_list = []\n\n    def query(self, letter: str) -> bool:\n        self.waiting_list = [node[letter] for node in self.waiting_list + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting_list)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.words=[word[::-1] for word in words]\n        self.string=''\n        self.l=0\n        self.createTrie()\n    def createTrie(self):\n        for i in self.words:\n            t=self.trie\n            for j in i:\n                if j not in t:\n                    t[j]=dict()\n                t=t[j]\n            t['*']=dict()\n    def searchTrie(self, word):\n        trie=self.trie\n        for i in word:\n            if i in trie:\n                trie=trie[i]\n            else:\n                return False\n        return '*' in trie\n    def query(self, letter: str) -> bool:\n        self.string+=letter\n        self.l+=1\n        trie=self.trie\n        for i in self.string[::-1]:\n            if i in trie:\n                trie=trie[i]\n                if '*' in trie:\n                    return True\n            else:\n                return False\n        return False\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n  def __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.end = False\n\nclass ReverseTrie:\n    \n  def __init__(self, words):\n    self.root = TrieNode()\n    \n    for word in words:\n      self.add_reverse_word(word)\n      \n  def add_reverse_word(self, word):\n    curr_node = self.root\n    \n    for idx in range(len(word) - 1, -1, -1):\n      char = word[idx]\n      curr_node = curr_node.children[char]\n      \n    curr_node.end = True\n    \n  def reverse_word_exists(self, reverse_letters):\n    \n    curr_trie_node = self.root\n    for char in reverse_letters:\n      if char in curr_trie_node.children:\n        curr_trie_node = curr_trie_node.children[char]\n        if curr_trie_node.end:\n          return True\n      else:\n        return False\n      \n      \n    return False\n      \n      \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.last_n_queries = collections.deque([])\n        self.trie_reverse_words = ReverseTrie(words)\n        self.max_word_length = 2000\n\n    def query(self, letter: str) -> bool:\n      \n      self.last_n_queries.appendleft(letter)\n      \n      if len(self.last_n_queries) > self.max_word_length:\n        self.last_n_queries.pop()\n        \n      return self.trie_reverse_words.reverse_word_exists(self.last_n_queries)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\n#cd, f, kl\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.trie = {}\n        for word in words:\n            cur = self.trie\n            for l in word:\n                if l not in cur:\n                    cur[l] = {}\n                cur = cur[l]\n            cur['#'] = True\n        self.stream = deque()\n                \n\n    def query(self, letter: str) -> bool:\n        \n        temp = deque()\n        self.stream.append(self.trie)\n        for p in self.stream:\n            if letter in p:\n                temp.append(p[letter])\n        self.stream = temp\n        for p in self.stream:\n            if '#' in p: return True\n        return False\n                \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        \n        for word in words:\n            node = self.root\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['#'] = 1\n        \n        # Node pointer of current valid candidates for matches\n        self.candidates = []\n        \n    def query(self, letter: str) -> bool:\n        \n        found = False\n        \n        new_candidates = []\n        self.candidates.append(self.root)\n        for node in self.candidates:\n            if letter in node:\n                node = node[letter]\n                new_candidates.append(node)\n                if '#' in node:\n                    found = True\n\n        self.candidates = new_candidates\n        \n        return found\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node=node[char]\n            node['end'] = True\n            \n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes=[]\n        \n        for node in self.nodes:\n            if letter in node:\n                node=node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes=new_nodes\n        return temp\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker():\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter: str) -> bool:\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        Trie = lambda: collections.defaultdict(Trie)\n        self.trie = Trie()\n        for word in words: reduce(dict.__getitem__, word, self.trie)['eow'] = True\n        self.trie_list = []\n\n    def query(self, letter: str) -> bool:\n        self.trie_list = [node[letter] for node in self.trie_list + [self.trie] if letter in node]\n        return any('eow' in trie for trie in self.trie_list)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "import json\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.ptrs = []\n        \n        for word in words:\n            curr = self.trie\n            for c in word:\n                if c not in curr:\n                    curr[c] = {}\n                curr = curr[c]\n            curr[\\\".\\\"] = {}\n    \n    def query(self, letter: str) -> bool:\n        res = False\n        newPtrs = []\n        \n        if letter in self.trie:\n            curr = self.trie[letter]\n            newPtrs.append(curr)\n            if \\\".\\\" in curr:\n                res = True\n        \n        for ptr in self.ptrs:\n            if letter in ptr:\n                curr = ptr[letter]\n                newPtrs.append(curr)\n                if \\\".\\\" in curr:\n                    res = True\n        self.ptrs = newPtrs\n        \n        return res\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes = []\n        \n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes = new_nodes\n        return temp", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words:\n            reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter: str) -> bool:\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any('#' in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.isWord = False\n\nclass StreamChecker:\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import defaultdict\nfrom functools import reduce\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # O(N x M)\n\n        # self.s = \\\"\\\"\n        # self.dic = defaultdict(set)\n        # for w in words:\n        #     self.dic[w[-1]].add(w)\n\n        Trie = lambda: defaultdict(Trie)\n        self.trie = Trie()\n        for word in words:\n            reduce(dict.__getitem__, word, self.trie)['#'] = True\n        self.waiting = []\n        \n\n    def query(self, letter: str) -> bool:\n        # O(M) where M is a max word length.\n\n        # self.s += letter\n        # return any(self.s.endswith(w) for w in self.dic[letter])\n\n\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any('#' in node for node in self.waiting)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "import functools\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T=lambda: collections.defaultdict(T)\n        self.trie=T()\n        for word in words:\n            functools.reduce(dict.__getitem__,word,self.trie)[\\\"#\\\"]=True\n        self.waiting=[]\n        \n\n    def query(self, letter: str) -> bool:\n        self.waiting=[node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from functools import reduce\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            cur = self.trie #root\n            for char in word:\n                if char not in cur:\n                    cur[char] = {}\n                cur = cur[char]\n            cur['#'] = True\n        self.stream = deque()\n        print((self.trie))\n\n    def query(self, letter: str) -> bool:\n        temp = deque()\n        self.stream.append(self.trie)\n        for p in self.stream:\n            if letter in p:\n                temp.append(p[letter])     \n        self.stream = temp\n        for p in self.stream:\n            if '#' in p:\n                return True\n        return False\n                \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.nodes = []\n        for word in words:\n            cur = self.root\n            for char in word:\n                if char not in cur:\n                    cur[char] = {}\n                cur = cur[char]\n            cur['*'] = True\n        \n                \n\n    def query(self, letter: str) -> bool: \n        self.nodes.append(self.root)\n        newNodes = []\n        ans = False\n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if '*' in node:\n                    ans = True\n                newNodes.append(node)\n        self.nodes = newNodes\n        return ans\n                \n                \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "import collections\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from itertools import chain\n\nclass StreamChecker:\n    prefixes = []\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            d = self.trie\n            for letter in word:\n                if letter not in d:\n                    d[letter] = {}\n                d = d[letter]\n            d['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.prefixes = [node[letter] for node in chain([self.trie], self.prefixes) if letter in node]\n        return any('end' in node for node in self.prefixes)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        trie = {}\n\n        \n        for w in words:\n            node = trie\n            for c in w:\n                if c not in node:\n                    node[c] = {}\n                    node = node[c]\n                    node['fail'] = trie\n                else:\n                    node = node[c]\n                \n            node['end'] = True\n        \n        que = [trie[x] for x in trie]\n        for node in que:\n            for x in node:\n                if x not in ('end', 'fail'):\n                    p = node['fail']\n                    while p != trie and x not in p:\n                        p = p['fail']\n                    if x in p:\n                        node[x]['fail'] = p[x]\n                        if 'end' in p[x]:\n                            node[x]['end'] = True\n                    que.append(node[x])\n        self.trie = trie\n        self.node = trie\n\n    def query(self, x: str) -> bool:\n        trie = self.trie\n        node = self.node\n        while node != trie and x not in node:\n            node = node['fail']\n        if x in node:\n            node = node[x]\n        self.node = node\n        return 'end' in node\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes = []\n        \n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes = new_nodes\n        return temp\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        Trie = lambda: collections.defaultdict(Trie)\n        self.trie = Trie()\n\n        for word in words:\n            functools.reduce(dict.__getitem__, word, self.trie)['#'] = True\n\n        self.heads = []\n\n    def query(self, letter: str) -> bool:\n        self.heads = [h[letter] for h in self.heads if letter in h]\n        if letter in self.trie:\n            self.heads.append(self.trie[letter])\n        return any('#' in h for h in self.heads)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.hist = \\\"\\\"\n        \n        for word in words:\n            t = self.trie\n            for w in word[::-1]:\n                if w not in t:\n                    t[w] = {}\n                t = t[w]\n            t['$'] = '$'\n\n    def query(self, letter: str) -> bool:\n        self.hist += letter\n        ctrie = self.trie\n        for l in self.hist[::-1]:\n            if l not in ctrie:\n                return False\n            ctrie = ctrie[l]\n            \n            if '$' in ctrie:\n                return True\n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.d = {}\n        \n        for word in words:\n            ptr = self.d\n            for c in word:\n                if c not in ptr:\n                    ptr[c] = {}\n                ptr = ptr[c]\n            ptr[''] = True \n                \n        self.curr = self.d\n        self.q = []\n        \n\n    def query(self, letter: str) -> bool:\n\n        self.q.append(self.d)\n        \n        # print(letter, len(self.q))\n        temp = []\n        flag = False\n        for ptr in self.q:            \n            if letter in ptr:\n                ptr = ptr[letter]\n                temp.append(ptr)\n                if '' in ptr:\n                    flag = True\n        \n        self.q = temp\n        \n        return flag\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        for word in words:\n            curnode = self.root\n            for ch in word:\n                if ch not in curnode:\n                    curnode[ch] = {}\n                curnode = curnode[ch]\n            curnode['is_end'] = True\n        self.leads = [self.root] # the pointers to the threads we follow right now\n\n    def query(self, letter: str) -> bool:\n        next_leads = [self.root]\n        found_word = False\n        for lead in self.leads:\n            if letter in lead:\n                new_lead = lead[letter]\n                next_leads.append(new_lead)\n                if 'is_end' in new_lead:\n                    found_word = True\n        self.leads = next_leads\n        return found_word\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__ (self):\n        self.children: Dict[str, TrieNode] = {}\n    def __str__ (self):\n        l = \\\"\\\"\n        for s in self.children:\n            l = l+s+\\\"[\\\"\n            if self.children[s]:\n                l = l+str(self.children[s])\n            l = l+\\\"]\\\"\n        return(l)\n\n\nclass ZStreamChecker:    \n    \n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        for w in words:\n            p = self.root\n            for l in w:\n                if l not in p.children:\n                    p.children[l] = TrieNode()\n                p = p.children[l]\n        self.pointers = set()\n        self.pointers.add(self.root)\n\n    def query(self, letter: str) -> bool:\n        ret = False\n        newset = set()\n        newset.add(self.root)\n        for p in self.pointers:\n            if letter in p.children:\n                if p.children[letter].children=={}:\n                    ret = True\n                else:\n                    newset.add(p.children[letter])\n        self.pointers = newset\n        return ret\n                \nclass StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from itertools import chain\n\nclass StreamChecker:\n    prefixes = []\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            d = self.trie\n            for letter in word:\n                d = d.setdefault(letter, {})\n            d['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.prefixes = [node[letter] for node in chain([self.trie], self.prefixes) if letter in node]\n        return any('end' in node for node in self.prefixes)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = sorted([ww[::-1] for ww in words])\n        self.entries = {}\n        self.create_trie(words)\n        self.nodes = []\n\n    def create_trie(self, word_list):\n        for word in word_list:\n            curNode = self.entries\n            for i in range(len(word)):\n                cur = word[i]\n                if cur not in curNode:\n                    curNode[cur] = {}\n                curNode = curNode[cur]\n            curNode[\\\"#\\\"] = True\n\n    def query(self, letter: str) -> bool:\n        res = False\n        self.nodes.append(self.entries)\n        new_nodes = []\n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if \\\"#\\\" in node:\n                    res = True\n                new_nodes.append(node)\n        self.nodes = new_nodes\n        return res\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.isEnd = False\n        self.children = dict()\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def addNode(self,word):\n        curNode = self.root\n        for char in word:\n            if char not in curNode.children:\n                curNode.children[char] = TrieNode()\n            curNode = curNode.children[char]\n        curNode.isEnd = True\n        \n    def search(self,word):\n        curNode = self.root\n        for char in word:\n            if curNode.isEnd: return True\n            elif char not in curNode.children: return False\n            else: curNode = curNode.children[char]\n        return curNode.isEnd\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.addNode(word[::-1])\n        self.curWord = ''\n\n    def query(self, letter: str) -> bool:\n        self.curWord = letter + self.curWord\n        return self.trie.search(self.curWord)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        head = {}\n        \n        for w in words:\n            current = head\n            for c in w:\n                if c not in current:\n                    current[c] = {}\n                current = current[c]\n            current['X'] = None\n\n            \n        self.head = head\n        self.current = [head]\n        \n    def query(self, letter: str) -> bool:\n        new_current = [self.head]\n        for e in self.current:\n            if letter in e: new_current.append(e[letter])\n                \n        self.current = new_current\n        for e in new_current:\n            if 'X' in e: return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\ndef routing():\n    return defaultdict(routing)\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.router = routing()\n        for word in words:\n            root = self.router\n            for letter in word:\n                root = root[letter]\n            root[\\\"*\\\"] = word\n        self.queries = []\n    def query(self, letter: str) -> bool:\n        new_queries, matches = [], []\n        self.queries.append(self.router)\n        for q in self.queries:\n            if letter in q:\n                q = q[letter]\n                if '*' in q:\n                    matches.append(q[\\\"*\\\"])\n                    if len(q) > 1:\n                        new_queries.append(q)\n                else:\n                    new_queries.append(q)\n        self.queries = new_queries\n        return bool(matches)", "class StreamChecker:\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self, char, parent):\n        self.children = [None for _ in range(26)]\n        self.char = char\n        self.parent = parent\n        \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.map = {}\n        self.root = Node(' ', None)\n        self.buffer = deque()\n        self.max_size = max([len(word) for word in words])\n        self.add(words)\n    \n    def add(self, words):\n        for word in words:\n            curr = self.root\n            for c in word:\n                if not curr.children[ord(c) - ord('a')]:\n                    curr.children[ord(c) - ord('a')] = Node(c, curr)\n                curr = curr.children[ord(c) - ord('a')]\n            if word[-1] not in self.map:\n                self.map[word[-1]] = []\n            self.map[word[-1]].append(curr)\n\n    def query(self, letter: str) -> bool:\n        self.buffer.append(letter)\n        if len(self.buffer) > self.max_size:\n            self.buffer.popleft()\n        if letter not in self.map:\n            return False\n        for node in self.map[letter]:\n            curr = node\n            for i in range(len(self.buffer) - 2, -1, -1):\n                if curr is not self.root and curr.parent.char == self.buffer[i]:\n                    curr = curr.parent\n                else:\n                    break\n            if curr.parent is self.root:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self, words):\n        self.root = {}\n        self.build(words)\n    \n    def build(self, words):\n        for word in words:\n            self.add_word(word)\n            \n    def add_word(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node:\n                node[ch] = {}\n            node = node[ch]\n        node[\\\"$\\\"] = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie(words)\n        self.prev_nodes = []\n\n    def query(self, letter: str) -> bool:\n        result = False\n        new_nodes = []\n        self.prev_nodes.append(self.trie.root)\n        for node in self.prev_nodes:\n            if letter in node:\n                if \\\"$\\\" in node[letter]:\n                    result = True\n                new_nodes.append(node[letter])\n        self.prev_nodes = new_nodes\n        return result\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self, char, parent):\n        self.children = [None for _ in range(26)]\n        self.char = char\n        self.parent = parent\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.map = {}\n        self.root = Node(' ', None)\n        self.buffer = deque()\n        self.max_size = max([len(word) for word in words])\n        self.add(words)\n    \n    def add(self, words):\n        for word in words:\n            curr = self.root\n            for c in word:\n                if not curr.children[ord(c) - ord('a')]:\n                    curr.children[ord(c) - ord('a')] = Node(c, curr)\n                curr = curr.children[ord(c) - ord('a')]\n            if word[-1] not in self.map:\n                self.map[word[-1]] = []\n            self.map[word[-1]].append(curr)\n\n    def query(self, letter: str) -> bool:\n        self.buffer.append(letter)\n        if len(self.buffer) > self.max_size:\n            self.buffer.popleft()\n        if letter not in self.map:\n            return False\n        for node in self.map[letter]:\n            curr = node\n            for i in range(len(self.buffer) - 2, -1, -1):\n                if curr is not self.root and curr.parent.char == self.buffer[i]:\n                    curr = curr.parent\n                else:\n                    break\n            if curr.parent is self.root:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    \n    def __init__(self):\n        self.dict = {}\n        self.leaf = False\n        \n    def addWord(self,word):\n        curTrie = self\n        for ch in word:\n            if ch not in curTrie.dict:\n                curTrie.dict[ch] = Trie()\n            curTrie = curTrie.dict[ch]\n        curTrie.leaf = True\n        \n    def search(self,query):\n        curTrie = self\n        # print('query : {}'.format(query))\n        for ch in query:\n            if ch in curTrie.dict:\n                curTrie = curTrie.dict[ch]\n                if curTrie.leaf == True:\n                    return True\n            else:\n                return False\n        return False\n            \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.queryStr = ''\n        for word in words:\n            self.trie.addWord(word[::-1])\n        \n    def query(self, letter: str) -> bool:\n        self.queryStr += letter\n        curTrie = self.trie\n        return curTrie.search(self.queryStr[::-1])\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.chars=[]\n        self.trie={}\n        for word in words:\n            curr=self.trie\n            for c in reversed(word):\n                if c not in curr:\n                    curr[c]={}\n                curr=curr[c]\n            curr['#']=True\n    \n    def search(self):\n        ind=len(self.chars)-1\n        curr=self.trie\n        while curr and ind>=0:\n            if '#' in curr:\n                return True\n            c=self.chars[ind]\n            if c not in curr:\n                return False\n            \n            curr=curr[c]\n            ind-=1\n        return curr and '#' in curr\n        \n\n    def query(self, letter: str) -> bool:\n        self.chars.append(letter)\n        return self.search()\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.query_history = \\\"\\\"\n        self.max_word_len = max(map(len, words))\n\n    def query(self, letter: str) -> bool:\n        self.query_history = self.query_history[-self.max_word_len:] + letter\n        return any(self.query_history.endswith(word) for word in self.words)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)  # Template class used to construct trie\n        self.trie = T()\n        for w in words:\n            functools.reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.possible_list = []\n\n    def query(self, letter: str) -> bool:\n        self.possible_list = [node[letter] for node in self.possible_list + [self.trie] if letter in node]\n        return any('#' in node for node in self.possible_list)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for w in words:\n            d = self.trie\n            for c in w:\n                if c in d:\n                    d = d[c]\n                else:\n                    d[c] = {}\n                    d = d[c]\n            d['$'] = None\n        self.l = []\n\n    def query(self, letter: str) -> bool:\n        self.l = [j[letter] for j in self.l if letter in j]\n        if letter in self.trie:\n            self.l.append(self.trie[letter])\n        return any(['$' in i for i in self.l])\n        \n                \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker(object):\n    \\\"\\\"\\\"\n    Copy paste from Lee215 on discussions\n    My code is still being built but lazy...\n    Also found another good resource for backend sys design... I'm sorry...\n    \\\"\\\"\\\"\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\nclass TrieNode:\n    \n    def __init__(self):\n        self.word = False\n        self.child = defaultdict(TrieNode)\n\nclass StreamChecker1:\n\n    def __init__(self, words: List[str]):\n        \\\"\\\"\\\"\n        Took around 5 minutes for the approach...\n        45 minutes for the implementation... \n        Also did some amazon and day dreaming... in the noon...\n        Not sure if this will run... but very hopeful...\n        \\\"\\\"\\\"\n        self.trie = TrieNode()\n        for w in words:\n            itr = self.trie\n            for ch in w: itr = itr.child[ch]\n            itr.word = True\n        self.pointers = collections.deque(self.trie.child.items())\n\n    def query(self, letter: str) -> bool:\n        found, lt_indices = False, []\n        for i, pair in enumerate(self.pointers): \n            k, v = pair\n            if k == letter: lt_indices.append(i)\n        \n        print(letter, lt_indices)\n        for i in lt_indices:\n            k, v = self.pointers[i]\n            \n            if v.word: found = True\n                \n            self.pointers.extend(v.child.items())\n        \n        cnt = 0\n        for i in lt_indices: \n            del self.pointers[i - cnt]\n            cnt += 1\n        \n        print(letter, self.pointers, found)\n        return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = {}\n        for word in words:\n            t = self.t\n            for ch in word:\n                t = t.setdefault(ch, {})\n            t['#'] = 'END'\n                    \n        self.cursors = [self.t]\n        \n\n    def query(self, letter: str) -> bool:\n        \n        newcursors = []\n        ans = False\n        \n        for cur in self.cursors:\n            if letter not in cur:\n                continue\n            cur = cur[letter]\n            if '#' in cur:\n                ans = True\n            newcursors.append(cur)\n            \n        self.cursors = newcursors\n        self.cursors.append(self.t)\n        \n        return ans\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "# class TrieNode:\n#     def __init__(self):\n#         self.children = [None]*26\n#         self.end = False\n\n# class StreamChecker:\n\n#     def char_to_index(self,ch):\n#         return ord(ch) - ord('a')\n    \n#     def insert(self,word):\n#         n = len(word)    \n#         ptr = self.root\n#         for lvl in range(len(word)):\n#             i = self.char_to_index(word[lvl])\n#             if ptr and not ptr.children[i]:\n#                 ptr.children[i] = TrieNode()\n                \n#             ptr = ptr.children[i]\n            \n#         ptr.end = True\n        \n#     def __init__(self, words: List[str]):\n#         self.root = TrieNode\n        \n#         for word in words:\n#             self.insert(word)\n#         self.pe = None\n\n#     def query(self, letter: str) -> bool:\n        \n#         if self.pe and self.pe.children[char_to_index(letter)]:\n#             if self.pe.end:\n#                 return True\n#             self.pe = self.pe.children[char_to_index(letter)]\n#             return False\n        \n#         if self.root.children[char_to_index(letter)]:\n#             self.pe = self.root.children[char_to_index(letter)]\n#             if self.root.end:\n#                 return True\n#             return False\n            \n        \n\n\n# # Your StreamChecker object will be instantiated and called as such:\n# # obj = StreamChecker(words)\n# # param_1 = obj.query(letter)\n\n\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            t = self.trie\n            for c in word+'\\\\0':\n                if c not in t: t[c] = {}\n                t = t[c]\n        self.nodes = [self.trie]\n            \n    def query(self, letter: str) -> bool:\n        newNodes = [self.trie]\n        ret = False\n        for node in self.nodes:\n            if letter in node:\n                newNodes.append(node[letter])  \n                if '\\\\0' in node[letter]: ret = True\n        self.nodes = newNodes\n        return ret\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.waitList = []\n        self.trie = {}\n        for w in words:\n            curr = self.trie\n            for c in w:\n                if c not in curr:\n                    curr[c] = {}\n                curr = curr[c]\n            curr['#'] = {'#'}\n\n    def query(self, letter: str) -> bool:\n        newWaitList = []\n        if letter in self.trie:\n            newWaitList.append(self.trie[letter])\n        for ele in self.waitList:\n            if letter in ele:\n                newWaitList.append(ele[letter])\n        self.waitList = newWaitList\n        for ele in self.waitList:\n            if '#' in ele:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for w in words:\n            curr = self.trie\n            for c in w+\\\"#\\\":\n                curr = curr.setdefault(c, {})\n        self.matching = []\n\n    def query(self, letter: str) -> bool:\n        if letter in self.trie:\n            self.matching.append(self.trie)\n        res = []\n        ans = False\n        for i in self.matching:\n            if letter in i:\n                res.append(i[letter])\n                if \\\"#\\\" in i[letter]:\n                    ans = True\n        self.matching = res\n        return ans\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode():\n    def __init__(self):\n        self.children = collections.defaultdict()\n        self.isEnd = False\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.maxlen = 0\n        self.cache = []\n        for w in words:\n            self.trie.insert(w[::-1])\n            self.maxlen = max(self.maxlen, len(w))\n        \n    def query(self, letter: str) -> bool:\n        self.cache.append(letter)\n        i = len(self.cache) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.cache[i] not in node.children:\n                # self.cache = self.cache[i:]\n                return False\n            node = node.children[self.cache[i]]\n            i -= 1\n        return node.isEnd\n \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes = []\n        \n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes = new_nodes\n        return temp\n        \n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tree = {}\n        for word in words:\n            ptr = self.tree\n            for c in word:\n                if c not in ptr:\n                    ptr[c] = {}\n                ptr = ptr[c]\n            ptr[\\\"$\\\"] = word\n        self.possible = []\n        \n\n    def query(self, letter: str) -> bool:\n        # check if \n        nxt = []\n        \n        for p in self.possible:\n            if letter in p:\n                nxt.append(p[letter])\n                \n        if letter in self.tree:\n            nxt.append(self.tree[letter])\n                \n        self.possible = nxt.copy()\n        for p in self.possible:\n            if \\\"$\\\" in p:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    \n    def __init__(self):\n        self.dict = {}\n        self.leaf = False\n        \n    def addWord(self,word):\n        newTrie = Trie()\n        if word[0] in self.dict:\n            newTrie = self.dict[word[0]]\n        else:\n            self.dict[word[0]] = newTrie\n        if len(word) == 1:\n            newTrie.leaf = True\n        else:\n            newTrie.addWord(word[1:])\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.queryStr = ''\n        for word in words:\n            self.trie.addWord(word[::-1])\n        \n    def query(self, letter: str) -> bool:\n        self.queryStr += letter\n        curTrie = self.trie\n        #print(letter)\n        for ch in self.queryStr[::-1]:\n            if ch in curTrie.dict:\n                curTrie = curTrie.dict[ch]\n                if curTrie.leaf == True:\n                    return True\n            else:\n                return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            t = self.trie\n            for c in word:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t['$'] = {}\n        self.ptrs = deque()\n        self.ptrs.append(self.trie)\n        return\n\n    def query(self, letter: str) -> bool:\n        ret = False\n        nextPtrs = deque()\n        nextPtrs.append(self.trie)\n        for ptr in self.ptrs:\n            if letter in ptr:\n                nextPtrs.append(ptr[letter])\n                if '$' in ptr[letter]:\n                    ret = True\n        self.ptrs = nextPtrs\n        return ret\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n            \n    def __init__(self, words: List[str]):\n        root = {}\n        nodes = [root]\n        for w in words:\n            prev = root\n            for s in w:\n                if s in prev:\n                    node = prev[s]\n                else:\n                    node = {}\n                    prev[s] = node\n                prev = node\n            prev['None'] = None\n        self.array_nodes = []\n        self.root = root\n        # print(self.root)\n        \n    def query(self, letter: str) -> bool:\n        if letter in self.root:\n            self.array_nodes.append(self.root)\n        nodes = []\n        result = False\n        for node in self.array_nodes:\n            if letter in node:\n                nodes.append(node[letter])\n                if 'None' in node[letter]:\n                    result = True\n        self.array_nodes = nodes\n        return result\n                \n                \n                \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.s = ''\n        self.c = 0\n       \n        self.ld = dict()\n        self.lths = set()\n        \n        for x in list(set(words)):\n            lim = len(x)\n            self.lths.add(lim)\n            try:\n                self.ld[lim][x[-1]].add(x)\n            except:\n                try:\n                    self.ld[lim][x[-1]]=set()\n                    self.ld[lim][x[-1]].add(x)\n                except:\n                    self.ld[lim]=dict()\n                    self.ld[lim][x[-1]]=set()\n                    self.ld[lim][x[-1]].add(x)\n                    \n         \n        \n    def query(self, letter: str) -> bool:\n        self.s+=letter\n        self.c+=1\n        ###print(self.s,self.c)\n        \n        for y in self.lths:\n            \n            if y<=self.c:\n                ###print(self.s[-y:])\n                if self.s[-1] in self.ld[y]:\n                    if self.s[-y:] in self.ld[y][self.s[-1]]:\n\n                        return True\n                \n        \n        return False\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "'''\nKeep a list of prefixes and pop one letter at a time, if \n\nkeep a dict of next letters with the values as the next to pop\n'''\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import defaultdict\n\ndef routing():\n    return defaultdict(routing)\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.router = routing()\n        #print(f'{words=}')\n        for word in words:\n            root = self.router\n            for letter in word:\n                root = root[letter]\n            root[\\\"*\\\"] = word\n        self.queries = []\n\n    def query(self, letter: str) -> bool:\n        #print(f'{letter=} {len(self.queries)=}')\n        new_queries, matches = [], []\n        self.queries.append(self.router)\n        for q in self.queries:\n            if letter in q:\n                q = q[letter]\n                if '*' in q:\n                    matches.append(q[\\\"*\\\"])\n                    if len(q) > 1:\n                        new_queries.append(q)\n                else:\n                    new_queries.append(q)\n        self.queries = new_queries\n        #print(f'{matches=}')\n        return bool(matches)\n", "class Trie:\n    def __init__(self):\n        self.trie = {}\n    def insert(self,w):\n        t = self.trie\n        for c in w+'\\\\0':\n            if c not in t: t[c] = {}\n            t = t[c]\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word)\n        self.nodes = [self.trie.trie]\n            \n    def query(self, letter: str) -> bool:\n        newNodes = [self.trie.trie]\n        ret = False\n        for node in self.nodes:\n            if letter in node:\n                newNodes.append(node[letter])  \n                if '\\\\0' in node[letter]: ret = True\n        self.nodes = newNodes\n        return ret\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.trie = Trie()\n        for w in words:\n            self.trie.insert(w[::-1])\n        \n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.letters[i] not in node.children:\n                return False\n            node = node.children[self.letters[i]]\n            i -= 1\n        return node.isEnd\n        \n\n    \\\"\\\"\\\"def query(self, letter: str) -> bool:\n        self.chars.append(letter)\n        s = \\\"\\\".join(self.chars)\n        #print(s)\n        for i in range(len(s)):\n            #print(\\\"s[i:] is \\\" + s[i:])\n            for word in self.words:        \n                if s[i:] == word or s[len(s) - i:] == word:\n                    return True\n        return False\n    \\\"\\\"\\\"\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.last = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        \n        for ch in word:\n            idx = ord(ch) - ord('a')\n            if not node.children[idx]:\n                node.children[idx] = TrieNode()\n            node = node.children[idx]\n        \n        node.last = True\n    \n    def search(self, word):\n        node = self.root\n        for ch in word:\n            idx = ord(ch) - ord('a')\n            if not node.children[idx]:\n                return False\n            node = node.children[idx]\n            \n            if node.last:\n                return True\n        \n        return False\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n        \n        self.letters = \\\"\\\"\n        \n\n    def query(self, letter: str) -> bool:\n        \n        self.letters += letter\n        word_to_search = self.letters[::-1]\n        \n        # print(word_to_search)\n        return self.trie.search(word_to_search)\n        \n        \n        \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "_end = '_end_'\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes_for_letters = []\n        for word in words:\n            self.add_to_trie(word)\n        \n    def add_to_trie(self, word):\n        current = self.trie\n        for letter in word:\n            if letter not in current:\n                current[letter] = {}\n            current = current[letter]\n        current[_end] = _end\n    \n\n    def query(self, letter: str) -> bool:\n        potential_nodes = self.nodes_for_letters + [self.trie]\n        self.nodes_for_letters = [node[letter] for node in potential_nodes if letter in node]\n        return any((_end in node) for node in self.nodes_for_letters)\n        \n            \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self, ch):\n        self.val = ch\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode('')\n    \n    def insert(self, word):\n        curr = self.root\n        for ch in word:\n            if ch in curr.children:\n                curr = curr.children[ch]\n            else:\n                curr.children[ch] = TrieNode(ch)\n                curr = curr.children[ch]\n        curr.is_word = True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n        self.string = ''\n\n    def query(self, letter: str) -> bool:\n        self.string += letter\n        curr = self.trie.root\n        for ch in self.string[::-1]:\n            if ch in curr.children:\n                curr = curr.children[ch]\n                if curr.is_word:\n                    return True\n            else:\n                return False\n        return curr.is_word\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.previous = []\n        for word in words:\n            path = self.trie\n            for letter in word:\n                if letter not in path:\n                    path[letter] = {}\n                    \n                path = path[letter]\n            path[\\\"END\\\"] = {}\n\n    def query(self, letter: str) -> bool:\n        found = False\n        \n        next = []\n        for previous in self.previous:\n            if letter in previous:\n                if \\\"END\\\" in previous[letter]:\n                    found = True\n                #print(f\\\"test: {letter}, {previous[letter]}\\\")\n                next.append(previous[letter])\n        self.previous = next\n        \n        if letter in self.trie:\n            if \\\"END\\\" in self.trie[letter]:\n                found = True\n            self.previous.append(self.trie[letter])\n        \n        #print(f\\\"{letter}: {found}, {self.previous}\\\")\n        return found\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.tree = Tree('0', [])\n        for item in words:\n            curr = self.tree\n            for letter in item[::-1]:\n                result = curr.in_list(letter)\n                if result is None:\n                    curr.subtrees.append(Tree(letter, []))\n                    curr = curr.subtrees[-1]\n                else:\n                    curr = curr.subtrees[result]\n            curr.food = True\n        self.q = ''\n\n    def query(self, letter: str) -> bool:\n        self.q += letter\n        reverse_q = self.q[::-1]\n        curr = self.tree\n        for letter in reverse_q:\n            result = curr.in_list(letter)\n            if result is None:\n                return False\n            else:\n                curr = curr.subtrees[result]\n                if curr.food:\n                    return True\n        return False\n\nclass Tree:\n    def __init__(self, root, subtrees):\n        self.root = root\n        self.food = False\n        self.subtrees = subtrees\n\n    def in_list(self, letter: str):\n        for i, item in enumerate(self.subtrees):\n            if item.root == letter:\n                return i\n        return None\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            node = self.trie\n            for i, c in enumerate(word):\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n                if i == len(word)-1:\n                    node[\\\"#\\\"] = {}\n        print(self.trie)        \n        self.candidates = [self.trie]\n\n    def query(self, letter: str) -> bool:\n        new_candidates = [self.trie]\n        word_found = False\n        for node in self.candidates:\n            if letter in node:\n                new_candidates.append(node[letter])\n                if \\\"#\\\" in node[letter]:\n                    word_found = True\n        self.candidates = new_candidates\n        return word_found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.end_node = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        cur = self.root\n        for c in word:\n            if not (c in cur.children):\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.end_node = True\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.str = \\\"\\\"\n        for word in words:\n            self.trie.insert(word[::-1])\n        \n\n    def query(self, letter: str) -> bool:\n        self.str += letter\n        cur = self.trie.root\n        for c in self.str[::-1]:\n            if(c in cur.children):\n                cur = cur.children[c]\n                if(cur.end_node):\n                    return True\n            else:\n                break\n        return False       \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode():\n    import collections\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.is_word = False\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    def construct(self,word):\n        node = self.root\n        for c in word[::-1]:\n            node = node.children[c]\n        node.is_word = True\n    \n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tree = Trie()\n        self.letters = []\n        for word in words:\n            self.tree.construct(word)\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        \n        if letter in self.tree.root.children:\n            node = self.tree.root\n            for l in self.letters[::-1]:\n                node = node.children.get(l)\n                if not node:\n                    return False\n                if node.is_word:\n                    return True\n            return node.is_word\n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            cur = self.trie\n            for char in word:\n                if char not in cur:\n                    cur[char] = {}\n                cur = cur[char]\n            cur['~'] = word\n            \n        self.candidates = []\n\n    def query(self, letter: str) -> bool:\n        newCands = []\n        foundWord = False\n        \n        if letter in self.trie:\n            newCands.append(self.trie[letter])\n            if '~' in self.trie[letter]:\n                foundWord = True\n                \n        for cand in self.candidates:\n            if letter in cand:\n                newCands.append(cand[letter])\n                if '~' in cand[letter]:\n                    foundWord = True\n        \n        self.candidates = newCands\n        return foundWord\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode():\n    def __init__(self):\n        self.children = collections.defaultdict()\n        self.isEnd = False\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.maxlen = 0\n        self.cache = collections.deque()\n        for w in words:\n            self.trie.insert(w[::-1])\n            self.maxlen = max(self.maxlen, len(w))\n        \n    def query(self, letter: str) -> bool:\n        self.cache.append(letter)\n        if len(self.cache) > self.maxlen:\n            self.cache.popleft()\n        i = len(self.cache) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.cache[i] not in node.children:\n                return False\n            node = node.children[self.cache[i]]\n            i -= 1\n        return node.isEnd\n \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            cur = self.trie\n            for ch in word:\n                if ch not in cur:\n                    cur[ch] = {}\n                cur = cur[ch]\n            cur['#'] = '#'\n        self.queue = []\n\n    def query(self, letter: str) -> bool:\n        res = False\n        nxt = []\n        for top in self.queue:\n            if letter in top:\n                if '#' in top[letter]:\n                    res = True\n                nxt.append(top[letter])\n        if letter in self.trie:\n            if '#' in self.trie[letter]:\n                res = True\n            nxt.append(self.trie[letter])\n        self.queue = nxt\n        return res\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = self._trie()\n        self._fillTrie(words)\n        self.q = []\n        \n    def _trie(self):\n        return defaultdict(self._trie)\n    \n    def _fillTrie(self, words):\n        for w in words:\n            t = self.trie\n            for c in w:\n                t = t[c]\n            t['*']\n            \n    def query(self, letter: str) -> bool:\n        found,newQ = False,[]\n        self.q.append(self.trie)\n        \n        for t in self.q:\n            if letter in t:\n                t = t[letter]\n                newQ.append(t)\n                found |= '*' in t\n        self.q = newQ\n        return found\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.trie = {}\n        \n    def add_word(self,word):\n        nextLevel = self.trie\n        for i,char in enumerate(word):\n            isWord = i == len(word) - 1\n            if char not in nextLevel:\n                nextLevel[char] = {}\n            if isWord:\n                nextLevel[char][\\\"#\\\"] = True\n            \n            nextLevel = nextLevel[char]\n\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.trie = Trie()\n        for word in words:\n            self.trie.add_word(word)\n            \n        self.nextLevels = []\n        self.count = 0\n\n    def query(self, letter: str) -> bool:\n        nextLevels = []\n        isWord = False\n        if len(self.nextLevels):\n            for level in self.nextLevels:\n                if letter in level:\n                    if \\\"#\\\" in level[letter]:\n                        isWord = True\n                    nextLevels.append(level[letter])\n        \n        if letter in self.trie.trie:\n            nextLevels.append( self.trie.trie[letter] )\n            if \\\"#\\\" in self.trie.trie[letter]:\n                isWord = True\n                \n        self.nextLevels = nextLevels\n    \n        return isWord\n    \n\n\n\n\n\n# class Trie:\n#     def __init__(self):\n#         self.trie = {}\n        \n#     def add_word(self,word):\n#         nextLevel = self.trie\n#         for i,char in enumerate(word):\n#             isWord = i == len(word) - 1\n#             if char in nextLevel:\n#                 if isWord:\n#                     nextLevel[char].isWord = True\n#                 nextLevel = nextLevel[char].children\n#             else:\n#                 node = TrieNode(char, isWord)\n#                 nextLevel[char] = node\n#                 nextLevel = nextLevel[char].children\n            \n        \n# class TrieNode:\n#     def __init__(self, char, isWord = False):\n#         self.char = char\n#         self.isWord = isWord\n#         self.children = {}\n\n\n# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         self.words = set(words)\n#         self.trie = Trie()\n#         for word in words:\n#             self.trie.add_word(word)\n            \n#         self.nextLevels = []\n#         self.count = 0\n\n#     def query(self, letter: str) -> bool:\n#         nextLevels = []\n#         isWord = False\n#         if len(self.nextLevels):\n#             for level in self.nextLevels:\n#                 if letter in level:\n#                     if level[letter].isWord:\n#                         isWord = True\n#                     nextLevels.append(level[letter].children)\n        \n#         if letter in self.trie.trie:\n#             nextLevels.append( self.trie.trie[letter].children )\n#             if self.trie.trie[letter].isWord:\n#                 isWord = True\n                \n#         self.nextLevels = nextLevels\n    \n#         return isWord\n    \n", "from collections import defaultdict\nclass StreamChecker:\n    # Time: O(qn), q = queries performed, n is amt words\n    # Space: O(nw), n is amt words, w is largest word\n    # Runtime: 9000ms beats 0% lol\n    def __init__(self, words: List[str]):\n        self.trie = self._trie()\n        self._fillTrie(words)\n        self.q = []\n        \n    def _trie(self):\n        return defaultdict(self._trie)\n    \n    def _fillTrie(self, words):\n        for w in words:\n            t = self.trie\n            for c in w:\n                t = t[c]\n            t['*']\n            \n    def query(self, letter: str) -> bool:\n        found,newQ = False,[]\n        self.q.append(self.trie)\n        \n        for t in self.q:\n            if letter in t:\n                t = t[letter]\n                newQ.append(t)\n                found |= '*' in t\n        self.q = newQ\n        return found", "END = '_'\n\nclass StreamChecker:    \n    def __init__(self, words: List[str]):\n        self.tree = {}\n        self.queries = []\n        \n        for w in words:\n            sub = self.tree\n            for c in w:\n                if c not in sub: sub[c] = {}\n                sub = sub[c]\n            sub[END] = END\n        \n    def query(self, l: str) -> bool:\n        found = False\n        \n        self.queries.append(self.tree)\n        \n        qs = []\n        \n        for q in self.queries:\n            if l in q:\n                qs.append(q[l])\n                if END in q[l]: found = True\n        \n        self.queries = qs\n                \n        return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = deque([])\n        \n        for word in set(words):\n            node = self.trie\n            for ch in word[::-1]:\n                if not ch in node:\n                    node[ch] = {}\n                node = node[ch]\n            node['$'] = word\n            \n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        \n        node = self.trie\n        for ch in self.stream:\n            if '$' in node:\n                return True\n            if not ch in node:\n                return False\n            node = node[ch]\n        return '$' in node\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.isEnd = False\n        self.children = dict()\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def addNode(self,word):\n        curNode = self.root\n        for char in word:\n            if char not in curNode.children:\n                curNode.children[char] = TrieNode()\n            curNode = curNode.children[char]\n        curNode.isEnd = True\n        \n    def search(self,word):\n        curNode = self.root\n        for char in word:\n            \n            if char not in curNode.children: return False\n            else:\n                curNode = curNode.children[char]\n                if curNode.isEnd: return True\n                else: pass\n        return curNode.isEnd\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for word in words:\n            self.trie.addNode(word[::-1])\n        self.curWord = ''\n\n    def query(self, letter: str) -> bool:\n        self.curWord = letter + self.curWord\n        return self.trie.search(self.curWord)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = collections.defaultdict(dict)\n        self.construct_trie(words)\n        self.l = []\n        \n    def construct_trie(self, words):\n        for word in words:\n            t = self.trie\n            for w in word:\n                if(w not in t):\n                    t[w] = {}\n                t = t[w]\n            t['$'] = True\n        \n        print((self.trie))\n        \n    def query(self, letter: str) -> bool:\n        t = self.trie\n        ans  = False\n        \n        temp = []\n        for d in self.l:\n            if(letter in d):\n                if('$' in d[letter]):\n                    ans = True\n                temp.append(d[letter])\n        self.l = temp\n        if(letter in t):\n            self.l.append(t[letter])\n            if('$' in t[letter]):\n                return True\n        return ans\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = list(set(words))\n        self.n = max(map(len, words))\n        self.historic = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        self.historic = self.historic + letter\n        if len(self.historic)>self.n:\n            self.historic = self.historic[1:]\n        for w in self.words:\n            if self.historic[-len(w):] == w:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        from collections import defaultdict\n        self.trie = dict()\n        \n        for word in words:\n            trie = self.trie\n            for c in word:\n                if c not in trie:\n                    trie[c] = dict()\n                    trie[c]['word'] = False\n                trie = trie[c]\n            trie['word'] = True\n        \n        self.tries = list()\n        #print(self.trie)\n        # self.words = {word:0 for word in words}\n        # self.possible = list()\n        # self.maxsize = max([len(word) for word in words])\n\n    def query(self, letter: str) -> bool:\n        newtries = list()\n        self.tries.append(self.trie)\n        found = False\n        for trie in self.tries:\n            if letter in trie:\n                newtries.append(trie[letter])\n                if trie[letter]['word']:\n                    found = True\n        self.tries = newtries\n        # self.possible.append('')\n        # newposs = list()\n        # found = False\n        # for pos in self.possible:\n        #     pos += letter\n        #     if pos in self.words:\n        #         found = True\n        #     if len(pos) <= self.maxsize:\n        #         newposs.append(pos)\n        # self.possible = newposs\n        return found \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        for word in words:\n            node = self.trie\n            for c in word:\n                if c not in node:\n                    node[c] = dict()\n                node = node[c]\n            node['.'] = '.'\n\n        self.curs = []\n\n    def query(self, letter: str) -> bool:\n        trie, curs = self.trie, self.curs\n        \n        curs = [cur[letter] for cur in curs if letter in cur]\n        if letter in trie:\n            curs.append(trie[letter])\n        self.curs = curs\n\n        return any('.' in cur for cur in curs)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\nclass StreamChecker:\n\n    def __init__(self, words):\n        tr = lambda: defaultdict(tr)\n        self.trie = tr()\n        for w in words:\n            cur_trie = self.trie[w[0]]\n            for i in range(1, len(w)):\n                cur_trie = cur_trie[w[i]]\n            cur_trie['end'] = True\n        self.tail = []\n\n    def query(self, letter):\n        self.tail = [node[letter] for node in self.tail + [self.trie] if letter in node]\n        for node in self.tail:\n            if 'end' in node:\n                return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie_head = {}\n        self.trie_leaf = '$'\n        \n        for word in words:\n            trie_node = self.trie_head\n            \n            for c in word:\n                trie_node = trie_node.setdefault(c, {})\n            \n            trie_node[self.trie_leaf] = self.trie_leaf\n        \n        self.trie_pointers = []\n        \n\n    def query(self, letter: str) -> bool:\n        # Advance all existing pointers\n        self.trie_pointers = [trie_node[letter] for trie_node in self.trie_pointers if letter in trie_node]\n        \n        if letter in self.trie_head:\n            self.trie_pointers.append(self.trie_head[letter])\n            \n        return any([(self.trie_leaf in trie_node) for trie_node in self.trie_pointers])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):     \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n    \n#         self.words = defaultdict(str)\n#         self.querying = defaultdict(list)\n#         for word in words:\n#             if (len(word)>1):\n#                 self.words[word[0]] = word[1:]\n#             else:\n#                 self.words[word[0]] = \\\"\\\"\n#         print(self.words)\n            \n#     def query(self, letter: str) -> bool:\n#         #need a new flag\n#         self.querying[letter] += self.words[letter]\n#         if (self.querying[letter] or letter in self.query.keys()):\n#             bucket = []\n#             print(self.querying[letter])\n#             for seq in self.querying[letter]:\n#                 print(seq)\n#                 if len(seq) == 1:\n#                     return True\n#                 elif seq[0] == letter:\n#                     bucket.append(letter)\n#                 elif len(seq)>1:\n#                     self.querying[seq[0]] += seq[1:]\n#             self.querying[letter] = bucket\n            \n#         return False\n        \n        \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.check = []\n        for w in words:\n            d = self.trie\n            for c in w:\n                _d = d.get(c, {})\n                d[c] = _d\n                d = _d\n            d['.'] = True\n        print((self.trie))\n\n    def query(self, letter: str) -> bool:\n        next_check = []\n        found = False\n        for d in self.check + [self.trie]:\n            if letter in d:\n                _d = d[letter]\n                if '.' in _d:\n                    found = True\n                next_check.append(_d)\n        self.check = next_check\n        return found\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    END = 0\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            ptr = self.trie\n            for letter in word:\n                if letter not in ptr:\n                    ptr[letter] = {}\n                ptr = ptr[letter]\n            ptr[StreamChecker.END] = True\n        self.working_list = []\n\n    def query(self, letter: str) -> bool:\n        is_word = False\n        new_working_list = []\n        self.working_list.append(self.trie)\n        for working_ptr in self.working_list:\n            if letter in working_ptr:\n                new_working_ptr = working_ptr[letter]\n                new_working_list.append(new_working_ptr)\n                if StreamChecker.END in new_working_ptr:\n                    is_word = True\n        \n        self.working_list = new_working_list\n        return is_word\n            \n            \n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.Trie = dict()\n        for word in words:\n            t = self.Trie\n            for c in word:\n                if c not in t:\n                    t[c] = dict()\n                t = t[c]\n            t['$'] = word\n        \n        self.cache = []\n\n    def query(self, letter: str) -> bool:\n        newcache = []\n        ret = False\n        for t in self.cache + [self.Trie]:\n            if letter in t:\n                newcache.append(t[letter])\n                if '$' in t[letter]:\n                    ret = True\n        self.cache = newcache\n        return ret\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode():\n    def __init__(self):\n        self.children = collections.defaultdict()\n        self.isEnd = False\n\nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.maxlen = 0\n        self.cache = []\n        for w in words:\n            self.trie.insert(w[::-1])\n            self.maxlen = max(self.maxlen, len(w))\n        \n    def query(self, letter: str) -> bool:\n        self.cache.append(letter)\n        i = len(self.cache) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.isEnd:\n                return True\n            if self.cache[i] not in node.children:\n                return False\n            node = node.children[self.cache[i]]\n            i -= 1\n        return node.isEnd\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n            \n\n    def query(self, letter: str) -> bool:\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            curr = self.trie\n            for char in word:\n                if char not in curr:\n                    curr[char] = {}\n                curr = curr[char]\n            curr[\\\"$\\\"] = True\n        self.prev_tries = []\n        \n\n    def query(self, letter: str) -> bool:\n        curr_trie = []\n        self.prev_tries.append(self.trie)\n        is_present = False\n        \n        for trie in self.prev_tries:\n            if letter in trie:\n                if  '$' in trie[letter]:\n                    is_present = True\n                curr_trie.append(trie[letter])\n        \n        self.prev_tries = curr_trie[:]\n        \n        return is_present\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from typing import List\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = dict()\n\n        for word in words:\n            root = self.root\n            for c in word:\n                if c not in root:\n                    root[c] = dict()\n                root = root[c]\n            root['$'] = '.'\n        \n        self.searches = []\n        \n\n    def query(self, letter: str) -> bool:\n        searches = self.searches\n        searches.append(self.root)\n\n        found = False\n        updated_searches = []\n        for search in searches:\n            if letter not in search:\n                continue\n            search = search[letter]\n            updated_searches.append(search)\n            if '$' in search:\n                found = True\n        self.searches = updated_searches\n        \n        return found\n\n", "class Trie:\n\n    def __init__(self, val=''):\n        \\\"\\\"\\\"\n        Initialize your data structure here.\n        \\\"\\\"\\\"\n        self.val = val\n        self.children = {}\n        self.is_end = False\n\n    def insert(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        \\\"\\\"\\\"\n        node = self\n        i = 0\n        while i < len(word) and word[i] in node.children:\n            node = node.children[word[i]]\n            i += 1\n        for j in range(i, len(word)):\n            node.children[word[j]] = Trie(word[j])\n            node = node.children[word[j]]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        \\\"\\\"\\\"\n        Returns if the word is in the trie.\n        \\\"\\\"\\\"\n        node = self\n        for lett in word:\n            if lett not in node.children:\n                return False\n            node = node.children[lett]\n        return node.is_end\n    \n    def cutIfStartsWith(self, prefix: str) -> bool:\n        \\\"\\\"\\\"\n        Returns if there is any word in the trie that starts with the given prefix.\n        \\\"\\\"\\\"\n        node = self\n        for lett in prefix:\n            if lett not in node.children:\n                return False\n            node = node.children[lett]\n        node.children = {}\n        node.is_end = True\n        return True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        btrie = Trie()\n        for w in words:\n            bw = w[::-1]\n            if not btrie.cutIfStartsWith(bw):\n                btrie.insert(bw)\n        def get_words(trie):\n            return [''] if trie.is_end else [tail + c for c in trie.children for tail in get_words(trie.children[c])]\n        self.trie = Trie()\n        for w in get_words(btrie):\n            self.trie.insert(w)\n        self.cur = set()\n        \n\n    def query(self, letter: str) -> bool:\n        self.cur.add(self.trie)\n        self.cur = {t.children[letter] for t in self.cur if letter in t.children}\n        for t in self.cur:\n            if t.is_end:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.d={}\n        for w in words:\n            cur=self.d    \n            for c in w:\n                cur.setdefault(c,dict())\n                cur=cur[c]\n            cur['']=True\n        self.q = []\n        #print(self.d)\n\n    def query(self, letter: str) -> bool:\n        nq=[]\n        if letter in self.d:\n            nq += [self.d[letter]]\n        for pq in self.q:\n            if letter in pq:\n                nq += [pq[letter]]\n        #print(nq,letter)\n        self.q=nq\n        for qq in self.q:\n            if '' in qq: return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    # TODO need proper Aho\u2013Corasick\n    # See also contest/weekly182/find-all-good-strings.python3.py\n    # TLE, too many prefixes, hard to calculate shared suffixes\n    # need a trie instead of set of words. Just building the set takes 2000^3\n\n    def __init__(self, words: List[str]):\n        _compress = {}\n        _decompress = {}\n\n        def compress(s):\n            if s not in _compress:\n                i = len(_compress)\n                _compress[s] = i\n                _decompress[i] = s\n            return _compress[s]\n\n        def decompress(i):\n            return _decompress[i]\n\n        compress(\\\"\\\")\n\n        words = set(words)\n        graph = defaultdict(\n            lambda: defaultdict(int)\n        )  # pref1 -> ch -> pref2 where pref2 is longest word that is a suffix of pref1\n        prefs = set()\n        for word in words:\n            for i in range(len(word) + 1):\n                pref = word[:i]\n                prefs.add(pref)\n\n        for pref in prefs:\n            for i in range(26):\n                ch = chr(ord(\\\"a\\\") + i)\n                for j in range(len(pref) + 1):\n                    pref2 = pref[j:] + ch\n                    if pref2 in prefs and len(pref2) > len(\n                        decompress(graph[compress(pref)][ch])\n                    ):\n                        graph[compress(pref)][ch] = compress(pref2)\n\n        prefWithWordSuffix = set()\n        for pref in prefs:\n            for i in range(len(word) + 1):\n                if pref[i:] in words:\n                    prefWithWordSuffix.add(compress(pref))\n                    break\n        self.graph = graph\n        self.state = compress(\\\"\\\")\n        self.prefWithWordSuffix = prefWithWordSuffix\n        # self.compress = compress\n        # self.decompress = decompress\n\n    def query(self, letter: str) -> bool:\n\n        self.state = self.graph[self.state][letter]\n\n        return self.state in self.prefWithWordSuffix\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            node = self.trie\n            for c in word:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node[\\\"$\\\"] = word\n        self.states = [self.trie]\n\n    def query(self, letter: str) -> bool:\n        nextStates = [self.trie]\n        for state in self.states:\n            if letter in state:\n                nextStates.append(state[letter])\n        self.states = nextStates\n        # print(letter, [state['$'] for state in self.states if '$' in state])\n        return any(\\\"$\\\" in state for state in self.states)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes = []\n        \n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes = new_nodes\n        return temp\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "import collections\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.stream = collections.deque()\n        self.prefixes = []\n        for w in words:\n            ptr = self.trie\n            for c in w:\n                if c not in ptr:\n                    ptr[c] = {}\n                ptr = ptr[c]\n            ptr['#'] = w\n            \n    def _find_word(self, k: int) -> bool:\n        ptr = self.trie\n        for c in list(self.stream)[-k:]:\n            if c not in ptr:\n                return False\n            ptr = ptr[c]\n        return '#' in ptr\n\n    def query(self, letter: str) -> bool:\n        # print(letter)\n        if letter in self.trie:\n            self.prefixes.append(self.trie)\n        valid_prefixes, found = [], False\n        for i, ptr in enumerate(self.prefixes):\n            # print(f'  {ptr}')\n            if letter in ptr:\n                ptr = ptr[letter]               \n                valid_prefixes.append(ptr)\n                if '#' in ptr:\n                    found = True\n        self.prefixes = valid_prefixes\n        return found        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.char = None\n        self.isEnd = False\n    \n    def contains(self, c):\n        return c in self.children\n    \n    def set(self, c):\n        self.children[c] = TrieNode()\n        \n    def getChild(self, c):\n        return self.children[c]\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        if not word:\n            return\n        word = word[::-1]\n        it = self.root\n        for c in word:\n            if not c in it.children:\n                it.children[c] = TrieNode()\n                it.children[c].char = c\n                \n            it = it.children[c]\n            \n        it.isEnd = True\n        #print(\\\"Inserted \\\", word, it.char)\n                \n    def hasAnyPrefix(self, letters):\n        #print(\\\"For \\\", letters)\n        it = self.root\n        for c in letters:\n            #print(\\\"Looking at c\\\", c, it.isEnd)\n            if it.isEnd:\n                return True\n            if not it.contains(c):\n                #print(\\\"Not found \\\", c)\n                return False\n\n            it = it.getChild(c)\n        \n        return it.isEnd\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        from collections import deque\n        self.letters = deque([])\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word)\n\n    def query(self, letter: str) -> bool:\n        self.letters.appendleft(letter)\n        return self.trie.hasAnyPrefix(self.letters)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.waitlist = []\n        self.trie = {}\n        for word in words:\n            t = self.trie\n            for char in word:\n                if char not in t:\n                    t[char] = {}\n                t = t[char]\n            t['#'] = \\\"#\\\"\n        \n    def query(self, letter: str) -> bool:\n        waitlist = []\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        \n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n        self.waitlist = waitlist\n        return any(\\\"#\\\" in i for i in self.waitlist)\n        ", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.pointers = [self.trie]\n        for word in words:\n            t = self.trie\n            for w in word:\n                if w not in t:\n                    t[w] = {}\n                t = t[w]\n            t['#'] = '#'\n        print((self.trie))\n    def query(self, letter: str) -> bool:\n        s = [self.trie]\n        for ele in self.pointers:\n            if letter in ele:\n                s.append(ele[letter])\n        self.pointers = s\n        return any(['#' in ele for ele in self.pointers])\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import defaultdict\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root={'*':'*'}\n        for word in words:\n            curr_node=self.root\n            for letter in word:\n                if letter not in curr_node:\n                    curr_node[letter]={}\n                curr_node=curr_node[letter]\n            curr_node[\\\"*\\\"]=\\\"*\\\"\n        self.stream=[]\n\n    def query(self, letter: str) -> bool:\n        temp=[]\n        self.stream.append(self.root)\n        for i in self.stream:\n            if letter in i:\n                temp.append(i[letter])\n        self.stream=temp\n        for i in self.stream:\n            if \\\"*\\\" in i:\n                return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        temp = False\n        new_nodes = []\n        \n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    temp = True\n                new_nodes.append(node)\n        self.nodes=new_nodes\n        return temp\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.s = set()\n        for w in words:\n            self.s = self.s.union(set(w))\n        self.d = {}   \n        for w in words:\n            insert(self.d, w)\n        self.l = []\n        #print(self.d)\n\n    def query(self, letter: str) -> bool:\n        if letter not in self.s:\n            return False\n        d = self.d\n        l = self.l\n        b = False\n        for i in reversed(list(range(len(l)))):\n            if letter in l[i]:\n                l[i] = l[i][letter]\n                if '#' in l[i]:\n                    b = True\n            else:\n                del l[i]\n        if letter in d:\n            l.append(d[letter])\n            if '#' in l[-1]:\n                b = True\n        return b\ndef insert(d, s):\n    if len(s) == 0:\n        d['#'] = {}\n    else:\n        if s[0] not in d:\n            d[s[0]] = {}\n        insert(d[s[0]],s[1:])\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for w in words:\n            t = self.trie\n            for c in w:\n                if c not in t:\n                    t[c]={}\n                t = t[c]\n            t['#']='#'\n        self.poss = []\n                    \n    def query(self, letter: str) -> bool:\n        \n        waitlist = []\n        \n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n            \n        for t in self.poss:\n            if letter in t:\n                waitlist.append(t[letter])\n        self.poss = waitlist\n        return any('#' in t for t in waitlist)\n    \n#         ans = False\n#         popthis = set()\n#         if letter in self.trie:\n#             t = self.trie\n#             self.poss.append(t)\n#         for i in range(len(self.poss)):\n#             if letter in self.poss[i]:\n#                 self.poss[i]=self.poss[i][letter]\n#                 if '#' in self.poss[i]:\n#                     ans = True\n#             else:\n#                 popthis.add(i)\n#         new = []\n#         for i,x in enumerate(self.poss):\n#             if i not in popthis:\n#                 new.append(x)\n#         self.poss = new\n        \n#         return ans\n        \n        \n       \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamC'hecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.wordlist = []\n        for w in words:\n            self.wordlist.append(w[::-1])\n        self.wordlist.sort()\n        self.history = ''\n        \n    def query2(self, letter: str) -> bool:\n        self.history = letter + self.history\n        k = 0\n        for i in range(len(self.history)):\n            w = self.history[:i+1]\n            while w > self.wordlist[k]:\n                k += 1\n                if k == len(self.wordlist):\n                    return False\n            #print(w ,self.wordlist,k)\n            if w == self.wordlist[k]:\n                return True\n        return False\n    \n    def query(self, letter: str) -> bool:\n        self.history = letter + self.history\n        s = 0\n        f = len(self.wordlist)\n        from bisect import bisect_left\n        for i in range(len(self.history)):\n            indx = bisect_left(self.wordlist[s:f],self.history[:i+1]) - 1\n            #print(self.wordlist[s:f],self.history[:i+1],indx)\n            if indx == -1:\n                if self.wordlist[s:f][0] == self.history[:i+1]:\n                    return True\n                #if not self.history[-1] == self.wordlist[s:f][0][-1]:\n                 #   print(self.wordlist[s:f],self.history[:i+1],indx)\n                    #return False\n            if indx+1 < len(self.wordlist[s:f]) and self.wordlist[s:f][indx+1] == self.history[:i+1]:\n                return True\n            \n            \n            #print(self.wordlist[s:f],self.history[:i+1],indx)\n            tmp = s + indx +1 \n            f = s + bisect_left(self.wordlist[s:f], self.history[:i] + chr(ord(self.history[i])+1))\n            s = tmp\n            #print(s,f)\n            if s>=f:\n                return False\n            #if f-s == 1 and not self.wordlist[s] == self.history[:i+1]:\n            #    return False\n                \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node(object):\n    def __init__(self):\n        self.child = defaultdict(lambda: Node())\n        self.leaf = False\n    def add(self, word):\n        #print(\\\"add word\\\", word)\n        if len(word) == 0:\n            self.leaf = True\n        else:\n            self.child[word[0]].add(word[1:])\n    def query(self, word):\n        #print(\\\"quering word\\\", word)\n        if len(word) == 0:\n            return self.leaf\n        elif self.leaf:\n            return True\n        elif word[0] not in self.child:\n            return False\n        else:\n            #print(\\\"word\\\",word)\n            #print(word[0]) \n            #print(word[1:])\n            return self.child[word[0]].query(word[1:])\n            \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        self.queue = \\\"\\\"\n        self.cur = None\n        for w in words:\n            self.root.add(list(reversed(w)))\n\n    def query(self, letter: str) -> bool:\n        self.queue = letter + self.queue\n        \n\n        return self.root.query(self.queue)\n\n\n\n\n\n\n\n\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.start = []\n        \n        for word in words:\n            self.add(word)\n            \n    def add(self, word):\n        curr = self.trie\n        \n        for c in word:\n            if c not in curr:\n                curr[c] = {}\n            curr = curr[c]\n        curr['#'] = True\n        \n    def query(self, letter: str) -> bool:\n        \n        start = []\n        if letter in self.trie:\n            start.append(self.trie[letter])\n            \n        for p in self.start:\n            if letter in p:\n                start.append(p[letter])\n                \n        self.start = start\n        \n        return any('#' in p for p in self.start)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n  def __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.end = False\n\nclass ReverseTrie:\n    \n  def __init__(self, words):\n    self.root = TrieNode()\n    \n    for word in words:\n      self.add_reverse_word(word)\n      \n  def add_reverse_word(self, word):\n    curr_node = self.root\n    \n    for idx in range(len(word) - 1, -1, -1):\n      char = word[idx]\n      curr_node = curr_node.children[char]\n      \n    curr_node.end = True\n    \n  def reverse_word_exists(self, reverse_letters):\n    reverse_word_found = False\n    \n    curr_trie_node = self.root\n    for idx in range(len(reverse_letters) - 1, -1, -1):\n      char = reverse_letters[idx]\n      if char in curr_trie_node.children:\n        curr_trie_node = curr_trie_node.children[char]\n        if curr_trie_node.end:\n          return True\n        \n        idx -= 1\n      else:\n        return False\n      \n      \n    return False\n      \n      \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.last_n_queries = collections.deque([])\n        self.trie_reverse_words = ReverseTrie(words)\n        self.max_word_length = 2000\n\n    def query(self, letter: str) -> bool:\n      \n      self.last_n_queries.append(letter)\n      \n      if len(self.last_n_queries) > self.max_word_length:\n        self.last_n_queries.popleft()\n        \n      return self.trie_reverse_words.reverse_word_exists(self.last_n_queries)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\n#cd, f, kl\n", "\\\"\\\"\\\"\nclass Node:\n    def __init__(self, c):\n        self.char = c\n        self.pointers = {}\n        self.wordEnd = False\n\nclass Trie:\n    def __init__(self):\n        self.d = {}\n\n    def insert(self, word: str) -> None:\n        if not word:\n            return\n        \n        if word[0] not in self.d:\n            self.d[word[0]] = Node(word[0])\n            \n        if len(word) > 1:\n            n = self.d[word[0]]\n            \n            for j, c in enumerate(word[1:]):\n                if c in n.pointers:\n                    n = n.pointers[c]\n                else:\n                    n_ = Node(c)\n                    n.pointers[c] = n_\n                    n = n_\n                \n                if j+1 == len(word)-1:\n                    n.wordEnd = True\n        else:\n            self.d[word[0]].wordEnd = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        for w in words:\n            self.trie.insert(w)\n        \n        self.curNode = None\n        \n        self.q = []\n        \n\n    def getNext(self, letter):        \n        if not self.q:\n            if letter in self.trie.d:\n                self.q.append(self.trie.d[letter])\n        else:\n            q2 = []\n            \n            visited =  set()\n\n            for node in self.q:\n                for p in node.pointers:                    \n                    newNode = node.pointers[p]\n                    \n                    if newNode in visited:\n                        #print (\\\"duplicate\\\")\n                        continue\n\n                    if newNode.char == letter:\n                        q2.append(newNode)\n                        visited.add(newNode)\n            \n            for node in self.trie.d:\n                for p in self.trie.d:                    \n                    newNode = self.trie.d[p]\n                    \n                    if newNode in visited:\n                        #print (\\\"duplicate\\\")\n                        continue\n\n                    if newNode.char == letter:\n                        q2.append(newNode)\n                        visited.add(newNode)\n\n            self.q = q2\n        \n        \n    def query(self, letter: str) -> bool:\n        self.getNext(letter)\n        return any([x.wordEnd for x in self.q])\n\\\"\\\"\\\"\n\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tries = {}\n        for word in words:\n            tries = self.tries\n            for c in word:\n                if c not in tries:\n                    tries[c] = {}\n                tries = tries[c]\n            tries['END'] = 1\n        self.pool = []\n\n    def query(self, letter: str) -> bool:\n        new_pool = []\n        self.pool.append(self.tries)\n        for tries in self.pool:\n            if letter in tries:\n                new_pool.append(tries[letter])\n        self.pool = new_pool\n        return  any('END' in tries for tries in self.pool)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker(object):\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n    ", "from typing import List\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = dict()\n\n        for word in words:\n            root = self.root\n            for c in word:\n                if c not in root:\n                    root[c] = dict()\n                root = root[c]\n            root['$'] = '.'\n        \n        self.searches = []\n        \n\n    def query(self, letter: str) -> bool:\n        self.searches.append(self.root)\n\n        found = False\n        failed = list()\n        i = 0\n        for search in self.searches:\n            if letter not in search:\n                failed.append(i)\n            else:\n                search = search[letter]\n                self.searches[i] = search\n                if '$' in search:\n                    found = True\n            i += 1\n        \n        o = 0\n        for i in failed:\n            del self.searches[i - o]\n            o += 1\n        \n        return found\n\n", "class Trie:\n    def __init__(self):\n        self.trie = {}\n        \n    def add_word(self,word):\n        nextLevel = self.trie\n        for i,char in enumerate(word):\n            isWord = i == len(word) - 1\n            if char not in nextLevel:\n                nextLevel[char] = {}\n            if isWord:\n                nextLevel[char][\\\"#\\\"] = True\n            \n            nextLevel = nextLevel[char]\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.trie = Trie()\n        for word in words:\n            self.trie.add_word(word)\n            \n        self.nextLevels = []\n        self.count = 0\n\n    def query(self, letter: str) -> bool:\n        nextLevels = []\n        isWord = False\n        if len(self.nextLevels):\n            for level in self.nextLevels:\n                if letter in level:\n                    if \\\"#\\\" in level[letter]:\n                        isWord = True\n                    nextLevels.append(level[letter])\n        \n        if letter in self.trie.trie:\n            nextLevels.append( self.trie.trie[letter] )\n            if \\\"#\\\" in self.trie.trie[letter]:\n                isWord = True\n                \n        self.nextLevels = nextLevels\n    \n        return isWord\n    \n\n\n\n\n\n# class Trie:\n#     def __init__(self):\n#         self.trie = {}\n        \n#     def add_word(self,word):\n#         nextLevel = self.trie\n#         for i,char in enumerate(word):\n#             isWord = i == len(word) - 1\n#             if char in nextLevel:\n#                 if isWord:\n#                     nextLevel[char].isWord = True\n#                 nextLevel = nextLevel[char].children\n#             else:\n#                 node = TrieNode(char, isWord)\n#                 nextLevel[char] = node\n#                 nextLevel = nextLevel[char].children\n            \n        \n# class TrieNode:\n#     def __init__(self, char, isWord = False):\n#         self.char = char\n#         self.isWord = isWord\n#         self.children = {}\n\n\n# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         self.words = set(words)\n#         self.trie = Trie()\n#         for word in words:\n#             self.trie.add_word(word)\n            \n#         self.nextLevels = []\n#         self.count = 0\n\n#     def query(self, letter: str) -> bool:\n#         nextLevels = []\n#         isWord = False\n#         if len(self.nextLevels):\n#             for level in self.nextLevels:\n#                 if letter in level:\n#                     if level[letter].isWord:\n#                         isWord = True\n#                     nextLevels.append(level[letter].children)\n        \n#         if letter in self.trie.trie:\n#             nextLevels.append( self.trie.trie[letter].children )\n#             if self.trie.trie[letter].isWord:\n#                 isWord = True\n                \n#         self.nextLevels = nextLevels\n    \n#         return isWord\n    \n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        self.pointers = []\n        for word in words:\n            if len(word) == 0:\n                continue\n            for i, ch in enumerate(word):\n                if i == 0:\n                    self.trie[ch] = self.trie.get(ch, dict())\n                    cur = self.trie[ch]\n                else:\n                    cur[ch] = cur.get(ch, dict())\n                    cur = cur[ch]\n            cur['end'] = 1\n\n    def query(self, letter: str) -> bool:\n        result = False\n        pointers_new = []\n        if letter in self.trie:\n            pointers_new.append(self.trie[letter])\n            if 'end' in self.trie[letter]:\n                result = True\n                \n        for pointer in self.pointers:\n            if letter not in pointer:\n                continue\n            pointers_new.append(pointer[letter])\n            if 'end' in pointer[letter]:\n                result = True\n        self.pointers = pointers_new\n        \n        return result\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.l=[]\n        self.trie={}\n        for word in words:\n            self.insert(word)\n        \n        print(self.trie)\n    \n    def insert(self, word: str) -> None:\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        \\\"\\\"\\\"\n        start = self.trie\n        for i in word:\n            if i not in start:\n                start[i] = {}\n            start = start[i]\n        start['$'] = True\n                    \n\n    def query(self, letter: str) -> bool:\n        \n        t=self.trie\n        ans=False\n        temp=[]\n        for d in self.l:\n            if letter in d:\n                if \\\"$\\\" in d[letter]:\n                    ans=True\n                temp.append(d[letter])\n        \n        self.l=temp\n        if letter in t:\n            self.l.append(t[letter])\n            if \\\"$\\\" in t[letter]:\n                return True\n        \n        return ans\n                \n# param_1 = obj.query(letter)", "class TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.word = False\n        \nclass Trie():\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self,word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.word = True\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.letters = []\n        self.trie = Trie()\n        for w in words:\n            self.trie.insert(w[::-1])\n        \n        \n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        i = len(self.letters)-1\n        node = self.trie.root\n        while i >=0:\n            if node.word:\n                return True\n            if self.letters[i] not in node.children:\n                return False\n            node = node.children[self.letters[i]]\n            i -= 1\n        return node.word\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n            \n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n    \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker(object):\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:  \n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.waitlist=[]\n        self.trie=dict()\n        for word in words:\n            temp=self.trie\n            for letter in word:\n                temp=temp.setdefault(letter,dict())\n            temp[\\\"%\\\"]=\\\"%\\\"\n        print(self.trie)\n        \n    def query(self, letter: str) -> bool:\n        wait=[]\n        if letter in self.trie:\n            wait.append(self.trie[letter])\n        for item in self.waitlist:\n            if letter in item:\n                wait.append(item[letter])\n        self.waitlist=wait\n        return any(\\\"%\\\" in i for i in self.waitlist)\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self):\n        self.children = {}\n        self.terminal = False\n    def add(self, val):\n        self.children[val] = Node()\n    def has(self, val):\n        return val in list(self.children.keys())\n    def get(self, val):\n        return self.children[val]\n    def set_terminal(self):\n        self.terminal = True\n    def is_terminal(self):\n        return len(self.children) == 0 or self.terminal\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        for word in words:\n            curr = self.root\n            for sym in word[::-1]:\n                if not(curr.has(sym)):\n                    curr.add(sym)\n                curr = curr.get(sym)\n            curr.set_terminal()\n        self.prefix = ''\n\n    def query(self, letter: str) -> bool:\n        self.prefix += letter\n        curr = self.root\n        for sym in self.prefix[::-1]:\n            if not(curr.has(sym)):\n                return False\n            curr = curr.get(sym)\n            if curr.is_terminal():\n                return True\n        \n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tree = {}\n        for word in words:\n            node = self.tree\n            for c in word:\n                node = node.setdefault(c, {})\n            node['#'] = True\n        self.active_match = []\n\n    def query(self, letter: str) -> bool:\n        assert len(letter) == 1, \\\"letter should have length 1\\\"\n        to_delete = []\n        for i, m in enumerate(self.active_match):\n            if letter in m:\n                self.active_match[i] = m[letter]\n            else:\n                to_delete.append(i)\n        for i in reversed(to_delete):\n            self.active_match[i] = self.active_match[-1]\n            self.active_match.pop()\n        if letter in self.tree:\n            self.active_match.append(self.tree[letter])\n        for m in self.active_match:\n            if '#' in m:\n                return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.hist = ''\n        \n\n    def query(self, letter: str) -> bool:\n        self.hist += letter\n        for word in self.words:\n            if self.hist[-len(word):] == word:\n                return True\n        \n        return False\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.watchlist = []\n        self.trie = {}\n        for word in words:\n            temp = self.trie\n            for c in word:\n                temp.setdefault(c, {})\n                temp = temp[c]\n            temp.setdefault(\\\"#\\\",)\n        \n\n    def query(self, letter: str) -> bool:\n        watchlist = []\n        \n        if letter in self.trie:\n            watchlist.append(self.trie[letter])\n\n        for node in self.watchlist:\n            if letter in node:\n                watchlist.append(node[letter])\n\n        self.watchlist = watchlist\n        \n        return any(\\\"#\\\" in n for n in self.watchlist)\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self):\n        self.next = {}\n        self.isWord = False\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        self.ptr = self.root\n        self.letters = []\n\n        for w in words:\n            node = self.root\n            for c in w[::-1]:\n                if c not in node.__next__:\n                    node.next[c] = Node()\n                node = node.next[c]\n            node.isWord = True\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        idx, ptr = 0, self.root\n        N = len(self.letters)\n\n        for i in range(N - 1, -1, -1):\n            c = self.letters[i]\n            idx += 1\n            if c not in ptr.__next__:\n                return False\n            ptr = ptr.next[c]\n            if idx > 0 and ptr.isWord:\n                return True\n        return False\n    \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    \n    def __init__(self, words):\n        self.waitlist = [] \n        self.trie = dict()\n        \n        for word in words: \n            tmp_dict = self.trie\n            for c in word : \n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                tmp_dict = tmp_dict.setdefault(c, dict())\n            \n            tmp_dict['#'] = '#'\n        \n        \n    def query(self, letter: str) -> bool:        \n        waitlist = [] \n        \n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        \n        \n        for item in self.waitlist:\n            if letter in item : \n                waitlist.append(item[letter])\n        \n        \n        self.waitlist = waitlist\n        \n        return any('#' in item for item in self.waitlist)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            temp_dict = self.trie\n            for letter in word:\n                temp_dict = temp_dict.setdefault(letter, dict())\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "import collections\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.waitlist=[]\n        self.trie={}\n        \n        \n        for word in words:\n            t=self.trie\n            for letter in word:\n                \\\"\\\"\\\"if letter not in t:\n                    t[letter]={}\n                t=t[letter]\\\"\\\"\\\"\n                t = t.setdefault(letter, {})\n            t['#']='#'    \n        #print('t',t)        \n        #for word in words:\n            #self.insert(word)\n    def query(self, letter):\n\n            waitlist = []\n            # if letter can be the prefix of word\n            if letter in self.trie:\n                waitlist.append(self.trie[letter])\n            # for each possible prefix, append letter if the new substr still can be a prefix\n            for item in self.waitlist:\n                if letter in item:\n                    waitlist.append(item[letter])\n\n            self.waitlist = waitlist\n            return any('#' in item for item in self.waitlist)\n\n\n\n    # Your StreamChecker object will be instantiated and called as such:\n    # obj = StreamChecker(words)\n    # param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n        \n\n    def query(self, letter: str) -> bool:\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        \n        for word in words:\n            node = self.trie\n            for c in word:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['#'] = {}\n        \n        self.table = []\n        \n\n    def query(self, letter: str) -> bool:\n        \n        tmp = []\n        \n        for node in self.table + [self.trie]:\n            if letter in node:\n                tmp.append(node[letter])\n        self.table = tmp\n        return any('#' in node for node in self.table)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker(object):\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "def ctoi(c):\n    return ord(c)-97\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = [None]*27\n        for w in words:\n            curr_trie = self.trie\n            for c in w:\n                c_idx = ctoi(c)\n                if not curr_trie[c_idx]:\n                    curr_trie[c_idx] = [None]*27\n                curr_trie = curr_trie[c_idx]\n            curr_trie[-1] = True\n        \n        self.ptrs = []\n    def query(self, letter: str) -> bool:\n        found = False\n        self.ptrs.append(self.trie)\n        new_ptrs = []\n        c_idx = ctoi(letter)\n        \n        for ptr in self.ptrs:\n            if ptr[c_idx]:\n                new_ptrs.append(ptr[c_idx])\n                if ptr[c_idx][-1]:\n                    found = True\n        \n        self.ptrs = new_ptrs\n        \n        return found\n        \n            \n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque, defaultdict\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # self.words = words\n        # self.stream = deque(maxlen=2000)\n        self.stream = deque(maxlen=2000)\n        \n        # organize based on last letter\n        self.words_dict = defaultdict(list)\n        for word in words:\n            self.words_dict[word[-1]].append(word)\n\n    def query(self, letter: str) -> bool:\n        \n        self.stream.append(letter)\n        \n        # for word in self.words:\n        for word in self.words_dict[letter]:\n            if len(word) <= len(self.stream):\n                for i in range(len(word)):\n                    if word[-(i+1)] != self.stream[-(i+1)]:\n                        break\n                else:\n                    return True\n                # if word == ''.join(self.stream[-len(word):]):\n                #     return True\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker(object):\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n    \n\n    # TLE\n# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         self.wordDict = set(words)\n#         self.streamDict = set()\n\n#     def query(self, letter: str) -> bool:\n#         existingKeys = list(self.streamDict)\n#         newStreamDict = set()\n#         found = False\n#         for key in existingKeys+['']:\n#             newStreamDict.add(key+letter)\n#             if key+letter in self.wordDict:\n#                 found = True\n#         # print(newStreamDict)\n#         self.streamDict = newStreamDict\n#         return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.memo = {}\n        self.words = set()\n        words_ = [word[::-1] for word in set(words)]\n        for word in words_:\n            for i in range(len(word)-1):\n                self.memo[word[:i+1]]=0\n        \n        for word in words_:\n            self.memo[word]=1     \n        \n        self.hist = deque()\n        \n        #print(self.memo)\n    \n    def query(self, letter: str) -> bool:\n        self.hist.appendleft(letter)\n        w = ''\n        for i in range(len(self.hist)):\n            w+=self.hist[i]\n            #print(w)\n            c = self.memo.get(w,None)\n            if c is None:\n                return False\n            if c:\n                return True\n            \n        return False\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            ptr = self.trie\n            for ch in word:\n                if ch not in ptr:\n                    ptr[ch] = {}\n                ptr = ptr[ch]\n            ptr[None] = {}\n            \n        self.ptrs = []\n\n    def query(self, letter: str) -> bool:\n        ptrs = []\n        ret = False\n        for ptr in self.ptrs:\n            if letter in ptr:\n                ptrs.append(ptr[letter])\n                ret |= None in ptr[letter]\n            \n        if letter in self.trie:\n            ptrs.append(self.trie[letter])\n            ret |= None in self.trie[letter]\n        \n        self.ptrs = ptrs\n        return ret\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        for w in words:\n            curr = self.trie\n            for c in w:\n                curr = curr.setdefault(c, {})\n            curr['$'] = '$'\n        self.ptrs = []\n\n    def query(self, letter: str) -> bool:\n        ret, new_list = False, []\n        self.ptrs.append(self.trie)\n        for ptr in self.ptrs:\n            if letter in ptr:\n                ptr = ptr[letter]\n                if '$' in ptr:\n                    ret = True\n                new_list.append(ptr)\n        self.ptrs = new_list\n        return ret\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            cur = self.trie\n            for c in word:\n                if c not in cur:\n                    cur[c] = {}\n                cur = cur[c]\n            cur[\\\"-\\\"] = True\n        self.currents = [self.trie]\n\n    def query(self, letter: str) -> bool:\n        keep = [self.trie]\n        found = False\n        for v in self.currents:\n            if letter in v:\n                vv = v[letter]\n                found |= \\\"-\\\" in vv\n                if \\\"-\\\" not in vv or len(vv) > 1:\n                    keep.append(vv)\n\n        self.currents = keep\n        return found\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            root = self.trie\n            for w in word:\n                if w not in root:\n                    root[w] = {}\n                root = root[w]\n            root['#'] = {}\n        self.q = []\n            \n        \n\n    def query(self, letter: str) -> bool:\n        i = 0\n        self.q = [p[letter] for p in self.q if letter in p]\n        if letter in self.trie:\n            self.q.append(self.trie[letter])\n        for p in self.q:\n            if '#' in p:\n                return True\n        return False\n            \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        # #-means end of word and @-means query pointer\n        for word in words:\n            cur = self.trie\n            for c in word:\n                if c not in cur:\n                    cur[c] = {}\n                cur = cur[c]\n            cur[\\\"#\\\"] = True\n        self.pointers = [self.trie]\n        self.ends = set()\n        self.waiting = []\n\n    def query(self, letter: str) -> bool:\n        \n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    # Simple version\n    def __init__(self, words: List[str]):\n        self.wait_list = []\n        self.trie = dict()\n\n        for w in words:\n            temp_dict = self.trie\n            for c in w:\n                temp_dict = temp_dict.setdefault(c, dict())\n            temp_dict['#'] = '#'\n\n    def query(self, letter: str) -> bool:\n        new_wait = []\n        if letter in self.trie:\n            new_wait.append(self.trie[letter])\n        for item in self.wait_list:\n            if letter in item:\n                new_wait.append(item[letter])\n\n        self.wait_list = new_wait\n        return any('#' in wait for wait in self.wait_list)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "# class StreamChecker:\n\n#     def __init__(self, words):\n#         T = lambda: collections.defaultdict(T)\n#         self.trie = T()\n#         for w in words: reduce(dict.__getitem__, w[::-1], self.trie)['#'] = True\n#         self.S = \\\"\\\"\n#         self.W = max(map(len, words))\n\n#     def query(self, letter):\n#         self.S = (letter + self.S)[:self.W]\n#         cur = self.trie\n#         for c in self.S:\n#             if c in cur:\n#                 cur = cur[c]\n#                 if cur['#'] == True:\n#                     return True\n#             else:\n#                 break\n#         return False\n\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = {}\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self, val=None):\n        self.kids = defaultdict(Node)\n        self.val = val\n        self.word = False\n        \nclass Trie:\n    def __init__(self):\n        self.head = Node()\n        \n    def add(self, word):\n        N = len(word)\n        curr = self.head\n        \n        for i in range(N-1, -1, -1):\n            c = word[i]\n            curr = curr.kids[c]\n            \n        curr.word = True\n    \n        \n    def search(self, word):\n        N = len(word)\n        curr = self.head\n        \n        for i in range(N-1, -1, -1):\n            c = word[i]\n            if c in curr.kids:\n                curr = curr.kids[c]\n                if curr.word:\n                    return True\n            else:\n                return False\n            \n        return curr.word\n    \n    \n            \n            \n        \n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.max = 0\n        \n        for word in words:\n            self.trie.add(word)\n            self.max = max(self.max, len(word))\n        \n        self.history = deque()\n\n    def query(self, letter: str) -> bool:\n        self.history.append(letter)\n        if len(self.history) > self.max:\n            self.history.popleft()\n            \n        out = self.trie.search(self.history)\n        print(letter, \\\"->\\\", out)\n        return out\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.nodes = []\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['end'] = True\n\n\n    def query(self, letter: str) -> bool:\n        self.nodes.append(self.trie)\n        res = False\n        new_nodes = []\n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if 'end' in node:\n                    res = True\n                new_nodes.append(node)\n        self.nodes = new_nodes     \n        return res", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            temp_dict = self.trie\n            for letter in word:\n                temp_dict = temp_dict.setdefault(letter, dict())\n            temp_dict['#'] = '#'\n            \n    def query(self, letter: str) -> bool:\n        waitlist = []\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        for word in words:\n            curr = self.root\n            for c in word:\n                curr = curr.setdefault(c, {})\n            curr['$'] = '$'\n        self.stack = [self.root]\n\n    def query(self, letter: str) -> bool:\n        stack = []\n        flag = False\n        for node in self.stack:\n            child = node.get(letter)\n            if child:\n                stack.append(child)\n                flag |= '$' in child\n        self.stack = stack\n        self.stack.append(self.root)\n        return flag\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "# class StreamChecker:\n\n#     def __init__(self, words):\n#         T = lambda: collections.defaultdict(T)\n#         self.trie = T()\n#         for w in words: reduce(dict.__getitem__, w[::-1], self.trie)['#'] = True\n#         self.S = \\\"\\\"\n#         self.W = max(map(len, words))\n\n#     def query(self, letter):\n#         self.S = (letter + self.S)[:self.W]\n#         cur = self.trie\n#         for c in self.S:\n#             if c in cur:\n#                 cur = cur[c]\n#                 if cur['#'] == True:\n#                     return True\n#             else:\n#                 break\n#         return False\n\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Node:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n\nclass Trie:\n\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        cur = self.root\n        for ch in word:\n            if ch not in cur.children:\n                cur.children[ch] = Node()\n            cur = cur.children[ch]\n        cur.isWord = True\n\n    def check(self, word):\n        cur = self.root\n        for ch in word:\n            if cur.isWord:\n                return True\n            if ch not in cur.children:\n                return False\n            cur = cur.children[ch]\n        return cur.isWord\n\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.T = Trie()\n        for word in words:\n            self.T.add(word[::-1])\n        self.arr = []\n        \n\n    def query(self, letter: str) -> bool:\n        self.arr.append(letter)\n        return self.T.check(self.arr[::-1])\n\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        dic = {}\n        for w in words:\n            p = dic\n            for c in w:\n                if c not in p: p[c] = {}\n                p = p[c]\n            p['#'] = True\n        self.dic = dic\n        self.cur = []\n\n    def query(self, letter: str) -> bool:\n        tmp, self.cur = self.cur, []\n        tmp.append(self.dic)\n        res = False\n        for d in tmp:\n            if letter in d:\n                self.cur.append(d[letter])\n                if '#' in d[letter]:\n                    res = True\n        return res\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker(object):\n\n    def __init__(self, word):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in word: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)", "\n\n    \nclass StreamChecker:\n\n    \n    def __init__(self, words: List[str]):\n        self.Trie={'chld':{},'end':False}\n        \n        for word in words:\n            T=self.Trie\n            for l in reversed(word):\n                if l not in T['chld']:\n                    T['chld'][l]={'chld':{},'end':False}\n                T=T['chld'][l]\n                \n            T['end']=True\n            \n        self.stack=''\n        \n        \n\n    def query(self, letter: str) -> bool:\n        \n        self.stack+=letter\n        \n        T=self.Trie\n        for i in range(len(self.stack)-1,-1,-1):\n            l=self.stack[i]\n            if l not in T['chld']:\n                #print (letter)\n                return False\n            T=T['chld'][l]\n            if T['end']:\n               # print(l,letter)\n                return True\n        \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = self.buildTrie(words)\n        self.waitlist = [] # queue\n        \n        \n    def buildTrie(self, words):\n        trie = {}\n        for word in words:\n            curr = trie\n            for ch in word:\n                curr = curr.setdefault(ch, {})\n            curr[\\\"#\\\"] = \\\"#\\\"\n        return trie\n        \n        \n    def query(self, letter: str) -> bool:\n        waitlist = []\n        \n        # check if letter is at the root \n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n            \n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n            \n        self.waitlist = waitlist\n        return any(\\\"#\\\" in item for item in self.waitlist)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n#??????????????????????????????????\n    def __init__(self, words: List[str]):\n        self.waitlist=[]\n        self.trie=dict()\n        for w in words:\n            temp_dict=self.trie\n            for letter in w:\n                #if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict=temp_dict.setdefault(letter,dict())\n            temp_dict['#']='#'\n            \n\n    def query(self, letter: str) -> bool:\n        waitlist=[]\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n        self.waitlist=waitlist\n        return any('#' in item for item in self.waitlist)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = words\n        self.history = ''\n        self.trie = {}\n        for w in words:\n            p = self.trie\n            for c in w:\n                if c not in p: p[c] = {}\n                p = p[c]\n            p['#'] = w\n        self.p = [self.trie]\n\n    def query(self, letter: str) -> bool:\n        self.history+=letter\n        self.p = [p[letter] for p in self.p if letter in p]\n        res = any(['#' in p for p in self.p])\n        self.p+=[self.trie]\n        return res\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.waitlist = []\n        for word in words:\n            head = self.trie\n            for char in word:\n                if char not in head:\n                    head[char] = {}\n                head = head[char]\n            head['#'] = '#'\n\n    def query(self, letter: str) -> bool:\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter) \n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dictionary={}\n        for word in words:\n            current=self.dictionary\n            for letter in word:\n                if letter not in current:\n                    current[letter]={}\n                current=current[letter]\n            current['!']={}\n        self.memory=[]\n\n    def query(self, letter: str) -> bool:\n        memory=self.memory+[self.dictionary]\n        self.memory=[]\n        validity=False\n        for entry in memory:\n            if letter in entry:\n                self.memory.append(entry[letter])\n                if '!' in entry[letter]:\n                    validity=True\n        return validity\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.isWord = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.head = TrieNode()\n        for word in words:\n            p = self.head\n            for c in word:\n                p = p.children[c]\n            p.isWord = True\n        self.pos = [self.head]\n        \n    def query(self, letter: str) -> bool:\n        tmp = [self.head]\n        is_word = False\n        for p in self.pos:\n            if letter in p.children:\n                nxt = p.children[letter]\n                tmp.append(nxt)\n                if nxt.isWord:\n                    is_word = True\n        self.pos = tmp\n        return is_word\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        _compress = {}\n        _decompress = {}\n        def compress(s):\n            if s not in _compress:\n                i = len(_compress)\n                _compress[s] = i\n                _decompress[i] = s                \n            return _compress[s]\n        def decompress(i):\n            return _decompress[i]\n        compress('')\n        \n        words = set(words)\n        graph = defaultdict(lambda: defaultdict(int)) # pref1 -> ch -> pref2 where pref2 is longest word that is a suffix of pref1\n        prefs = set()\n        for word in words:\n            for i in range(len(word) + 1):\n                pref = word[:i]\n                prefs.add(pref)\n        \n        for pref in prefs:\n            for i in range(26):\n                ch = chr(ord('a') + i)\n                for j in range(len(pref) + 1):\n                    pref2 = pref[j:] + ch\n                    if pref2 in prefs and len(pref2) > len(decompress(graph[compress(pref)][ch])):\n                        graph[compress(pref)][ch] = compress(pref2)\n                \n        prefWithWordSuffix = set()\n        for pref in prefs:\n            for i in range(len(word) + 1):\n                if pref[i:] in words:\n                    prefWithWordSuffix.add(compress(pref))\n                    break\n        self.graph = graph\n        self.state = compress('')\n        self.prefWithWordSuffix = prefWithWordSuffix\n        # self.compress = compress\n        # self.decompress = decompress\n\n    def query(self, letter: str) -> bool:\n        \n        self.state = self.graph[self.state][letter]\n        \n        \n        return self.state in self.prefWithWordSuffix\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            node = self.trie\n            for c in word:\n                if c not in node:                    \n                    node[c] = {}\n                node = node[c]\n            node['$'] = word\n        self.states = [self.trie]\n    def query(self, letter: str) -> bool:\n        nextStates = [self.trie]\n        for state in self.states:\n            if letter in state:\n                nextStates.append(state[letter])\n        self.states = nextStates\n        #print(letter, [state['$'] for state in self.states if '$' in state])\n        return any('$' in state for state in self.states)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                node = node.setdefault(letter, {})\n            node['end'] = True\n        self.s = []\n    def query(self, letter: str) -> bool:\n        f = 0\n        temp = []\n        self.s.append(self.trie)\n        for d in self.s:\n            if letter in d:\n                t = d[letter]\n                f |= 'end' in t\n                temp.append(t)\n        self.s = temp\n        return f\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "MAX_WORD_LEN = 2000\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.ring_buffer = [None] * MAX_WORD_LEN\n        self.index = 0\n        self.words = set(words)\n        self.possible_chars = set([\n            char for word in self.words for char in word\n        ])\n\n    def query(self, letter: str) -> bool:\n        self.add_letter(letter)\n        if letter not in self.possible_chars:\n            return False\n        \n        for word in self.words:\n            if word[-1] != letter:\n                continue\n            if self.endswith(word):\n                return True\n        return False\n    \n    def add_letter(self, letter):\n        self.ring_buffer[self.index] = letter\n        self.index = (self.index + 1) % MAX_WORD_LEN\n        \n    def endswith(self, word):\n        index = (self.index - len(word)) % MAX_WORD_LEN\n        for i in range(len(word)):\n            if self.ring_buffer[index] != word[i]:\n                return False\n            index = (index + 1) % MAX_WORD_LEN\n        return True\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.waitlist = []\n        self.trie = dict()\n        \n        for word in words:\n            temp_dict = self.trie\n            for letter in word:\n                temp_dict = temp_dict.setdefault(letter, dict())\n            temp_dict['#'] = '#'\n            \n        \n\n    def query(self, letter: str) -> bool:\n        waitlist = []\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from collections import deque\n\n\nclass Node:\n\n    def __init__(self):\n        self.children = dict()\n        self.isEnd = False\n        self.word = \\\"\\\"\n\n\nclass Trie:\n\n    def __init__(self):\n        self.root = Node()\n        \n\n    def insert(self, word):\n        current = self.root\n\n        for i in range(len(word)):\n            if current.children.get(word[i], None) is None:\n                current.children[word[i]] = Node()\n            current = current.children[word[i]]\n        current.isEnd = True\n        current.word = word\n\n    # def query(self, letter):\n        \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.q = deque()\n        for word in words:\n            self.trie.insert(word[::-1])\n\n        \n\n    def query(self, letter: str) -> bool:\n        self.q.appendleft(letter)\n        current = self.trie.root\n\n        for c in self.q:\n            if c in current.children:\n                current = current.children[c]\n                if current.isEnd:\n                    return True\n            else:\n                return False\n        return False\n\n\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        trie = {}\n        for word in words:\n            ptr = trie\n            for c in word:\n                if c not in ptr:\n                    ptr[c] = {}\n                ptr = ptr[c]\n            ptr[\\\"term\\\"] = True\n        self.trie = trie\n        self.curr = []\n                \n    def query(self, letter: str) -> bool:\n        # add new start\n        self.curr.append(self.trie)\n        # progress\n        new_curr = []\n        res = False\n        for ptr in self.curr:\n            if letter in ptr:\n                ptr = ptr[letter]\n                if not res and ptr.get(\\\"term\\\", False):\n                    res = True\n                new_curr.append(ptr)\n        self.curr = new_curr\n        return res\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n\n    def query(self, letter: str) -> bool:\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self, end=False):\n        self.next = {}\n        self.end = False\n    \nclass StreamChecker:\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.d = {}\n        for w in words:\n            c = self.d\n            i = 0\n            while i < len(w):\n                if w[i] not in c:\n                    c[w[i]] = {}\n                c = c[w[i]]\n                i += 1\n            c[''] = True\n        self.ps = []\n\n    def query(self, letter: str) -> bool:\n        nps = []\n        for p in self.ps+[self.d]:\n            if letter in p:\n                nps.append(p[letter])\n        self.ps = nps\n        return any('' in p for p in self.ps)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: functools.reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.t = {}\n        for word in words:\n            curr = self.t\n            for c in word:\n                if c not in curr:\n                    curr[c] = {}\n                curr = curr[c]\n            curr[''] = None\n            \n        self.cursor = []\n        \n    def query(self, letter: str) -> bool:\n        self.cursor = [x[letter] for x in self.cursor if letter in x]\n        if letter in self.t:\n            self.cursor.append(self.t[letter])\n        for c in self.cursor:\n            if '' in c:\n                return True\n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        for word in words:\n            t = self.root\n            for c in word:\n                if c not in t: t[c] = {}\n                t = t[c]\n            t['end'] = True\n        self.temp = [self.root]\n\n    def query(self, letter: str) -> bool:\n        nextTemp = []\n        flag = False\n        for node in self.temp:\n            if letter not in node:\n                continue\n            node = node[letter]\n            nextTemp.append(node)\n            if 'end' in node:\n                flag = True\n        nextTemp += [self.root]\n        self.temp = nextTemp\n        return flag\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: \n            reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter: str) -> bool:\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "# \u9898\u76ee\u8981\u6c42\u6309\u4ece\u65e7\u5230\u65b0\u987a\u5e8f\u67e5\u8be2\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06\u4ece\u65e7\u5230\u65b0\u7684 query \u5b58\u8d77\u6765\u5f62\u6210\u4e00\u4e2a\u5355\u8bcd stream\u3002\n\n# \u6bd4\u5982\uff1a\n\n# streamChecker.query(\\\"a\\\"); // stream\uff1a a\n# streamChecker.query(\\\"b\\\"); // stream\uff1aba\n# streamChecker.query(\\\"c\\\"); // stream\uff1acba\n# \u8fd9\u91cc\u6709\u4e24\u4e2a\u5c0f\u7684\u70b9\u9700\u8981\u6ce8\u610f\uff1a\n\n# \u5982\u679c\u7528\u6570\u7ec4\u6765\u5b58\u50a8\uff0c \u7531\u4e8e\u6bcf\u6b21\u90fd\u5f80\u6570\u7ec4\u5934\u90e8\u63d2\u5165\u4e00\u4e2a\u5143\u7d20\uff0c\u56e0\u6b64\u6bcf\u6b21 query \u64cd\u4f5c\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(N)$\uff0c\u5176\u4e2d $N$ \u4e3a\u622a\u6b62\u5f53\u524d\u6267\u884c query \u7684\u6b21\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u53cc\u7aef\u961f\u5217\u8fdb\u884c\u4f18\u5316\u3002\n# \u7531\u4e8e\u4e0d\u5fc5 query \u5f62\u6210\u7684\u67e5\u8be2\u5168\u90e8\u547d\u4e2d\u3002\u6bd4\u5982 stream \u4e3a cba \u7684\u65f6\u5019\uff0c\u627e\u5230\u5355\u8bcd c\uff0c bc\uff0c abc \u90fd\u662f\u53ef\u4ee5\u7684\u3002\u5982\u679c\u662f\u627e\u5230 c\uff0ccb\uff0ccba \u6bd4\u8f83\u597d\u5427\uff0c\u73b0\u5728\u662f\u53cd\u7684\u3002\u5176\u5b9e\u6211\u4eec\u53ef\u4ee5\u53cd\u5e8f\u63d2\u5165\u662f\uff0c\u7c7b\u4f3c\u7684\u6280\u5de7\u5728211.add-and-search-word-data-structure-design \u4e5f\u6709\u7528\u5230\u3002\n# \u4e4b\u540e\u6211\u4eec\u7528\u62fc\u63a5\u7684\u5355\u8bcd\u5728 words \u4e2d\u67e5\u8be2\u5373\u53ef\uff0c \u6700\u7b80\u5355\u7684\u65b9\u5f0f\u5f53\u7136\u662f\u6bcf\u6b21 query \u90fd\u53bb\u626b\u63cf\u4e00\u6b21\uff0c\u8fd9\u79cd\u65b9\u5f0f\u6beb\u65e0\u7591\u95ee\u4f1a\u8d85\u65f6\u3002\n\n# \u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u6784\u5efa Trie \u7684\u5f62\u5f0f\uff0c\u5373\u5df2\u7a7a\u95f4\u73af\u65f6\u95f4\uff0c \u5176\u4ee3\u7801\u548c\u5e38\u89c4\u7684 Trie \u7c7b\u4f3c\uff0c\u53ea\u9700\u8981\u5c06 search(word) \u51fd\u6570\u505a\u4e00\u4e2a\u7b80\u5355\u4fee\u6539\u5373\u53ef\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u68c0\u67e5\u6574\u4e2a word \u662f\u5426\u5b58\u5728\uff0c \u800c\u5df2 word \u7684\u524d\u7f00\u5b58\u5728\u5373\u53ef\u3002\n\n# \u63d0\u793a\uff1a\u53ef\u4ee5\u901a\u8fc7\u5bf9 words \u53bb\u91cd\uff0c\u6765\u7528\u7a7a\u95f4\u6362\u533a\u65f6\u95f4\u3002\n\n# \u5177\u4f53\u7b97\u6cd5\uff1a\n\n# init \u4e2d \u6784\u5efa Trie \u548c \u53cc\u7aef\u961f\u5217 stream\n# query \u65f6\uff0c\u5f80 stream \u7684\u5de6\u8fb9 append \u5373\u53ef\u3002\n# \u8c03\u7528 Trie \u7684 search\uff08\u548c\u5e38\u89c4\u7684 search \u7a0d\u6709\u4e0d\u540c\uff0c \u6211\u4e0a\u9762\u5df2\u7ecf\u8bb2\u4e86\uff09\n# \u6838\u5fc3\u4ee3\u7801\uff08Python\uff09\uff1a\n\n# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         self.trie = Trie()\n#         self.stream = deque([])\n\n#         for word in set(words):\n#             self.trie.insert(word[::-1])\n\n#     def query(self, letter: str) -> bool:\n#         self.stream.appendleft(letter)\n#         return self.trie.search(self.stream)\n\n# \u5173\u952e\u70b9\u89e3\u6790\n# \u524d\u7f00\u6811\u6a21\u677f\n# \u5012\u5e8f\u63d2\u5165\n\n\n\n\nclass Trie:\n\n    def __init__(self):\n        \\\"\\\"\\\"\n        Initialize your data structure here.\n        \\\"\\\"\\\"\n        self.Trie = {}\n\n    def insert(self, word):\n        \\\"\\\"\\\"\n        Inserts a word into the trie.\n        :type word: str\n        :rtype: void\n        \\\"\\\"\\\"\n        curr = self.Trie\n        for w in word:\n            if w not in curr:\n                curr[w] = {}\n            curr = curr[w]\n        curr['#'] = 1\n\n    def search(self, word):\n        \\\"\\\"\\\"\n        Returns if the word is in the trie.\n        :type word: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        curr = self.Trie\n        for w in word:\n            if w not in curr:\n                return False\n            if \\\"#\\\" in curr[w]:\n                return True\n            curr = curr[w]\n        return False\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.stream = deque([])\n\n        for word in set(words):\n            self.trie.insert(word[::-1])   #\u53cd\u5411\u63d2\u5165\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        return self.trie.search(self.stream)\n", "class Trie:\n    \n    def __init__(self):\n        self.root = {}\n        self.curr = self.root\n    \n    def add(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['.'] = True\n        \n    def search(self, char):\n        node = self.curr\n        if char in node:\n            node = node[char]\n            self.curr = node\n            return '.' in node\n        else:\n            self.curr = self.root\n            return False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.stream = deque()\n        self.trie = Trie()\n        for w in words:\n            self.trie.add(w[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.stream.appendleft(letter)\n        node = self.trie.root\n        for char in self.stream:\n            if char in node:\n                node = node[char]\n                if '.' in node:\n                    return True\n            else:\n                break\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n'''\n[[[\\\"ab\\\",\\\"ba\\\",\\\"aaab\\\",\\\"abab\\\",\\\"baa\\\"]],\n[\\\"a\\\"],[\\\"a\\\"],[\\\"a\\\"],[\\\"a\\\"],[\\\"a\\\"],[\\\"b\\\"],[\\\"a\\\"],\n  F     F     F     F     F     T     T\n'''", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for w in words:\n            node = self.trie\n            for char in w:\n                node.setdefault(char,{})\n                node = node[char]\n            node.setdefault('*',{})\n        self.curr = [self.trie]\n\n    def query(self, letter: str) -> bool:\n        new_curr = [self.trie]\n        ret = False\n        for node in self.curr:\n            if letter in node:\n                node = node[letter]\n                new_curr.append(node)\n                if '*' in node:\n                    ret = True\n        self.curr = new_curr\n        return ret\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self, char, isTerminal):\n        self.char = char\n        self.isTerminal = isTerminal\n        self.nei = {}\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode(\\\"\\\", False)\n        list(map(lambda x : self.insert(x[::-1], self.root),words ))\n        self.q = \\\"\\\"\n    def insert(self, word, root):\n        if len(word) == 0:\n            self.root.Isterminal = True\n            return\n        isTerminal = len(word)==1\n        if word[0] in root.nei:\n            root.nei[word[0]].isTerminal |= isTerminal\n        else:\n            child = TrieNode(word[0], isTerminal)\n            root.nei[word[0]] = child\n            \n        if not isTerminal:\n            self.insert(word[1:], root.nei[word[0]])\n\n    def prinT(self, root, path):\n        if root.isTerminal:\n            print(path)\n        for nei in root.nei:\n            self.prinT( root.nei[nei], path[:] + root.nei[nei].char)\n            \n    def search(self, root, word):\n        if not word:\n            return root.isTerminal\n        if root.isTerminal:\n            return True\n        \n        if word[0] in root.nei:\n            return self.search(root.nei[word[0]], word[1:])\n        else:\n            return False\n        \n    def query(self, letter: str) -> bool:\n        self.q += letter\n \n        \n        if self.search(self.root, self.q[::-1]):\n            return True\n            \n        return False\n                \n        # q = self.q\n        # while q:\n        #     print(q)\n        #     if self.search(self.root, q):\n        #         break\n        #     q = q[1:]\n        # self.q = q\n        return len(self.q) >= 1 \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        self.pointers = list()\n        for word in words:\n            node = self.trie\n            for c in word:\n                node = node.setdefault(c, {})\n            \n            node[\\\"#\\\"] = True\n    \n    def query(self, letter: str) -> bool:\n        res = False\n        self.pointers = [node[letter] for node in self.pointers if letter in node]\n        res = res or any(\\\"#\\\" in node for node in self.pointers)\n        \n        if letter in self.trie:\n            node = self.trie[letter]\n            res = res or (\\\"#\\\" in node)\n            self.pointers.append(node)\n        \n        return res\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for w in words:\n            lastC = self.trie\n            for c in w:\n                lastC[c] = lastC.get(c, {})\n                lastC = lastC[c]\n            lastC['*'] = True\n        self.words = []\n        \n\n    def query(self, letter: str) -> bool:\n        newWords = []\n        if letter in self.trie:\n            newWords.append(self.trie[letter])\n        for t in self.words:\n            if letter in t:\n                newWords.append(t[letter])\n        self.words = newWords\n        return any(['*' in t for t in self.words])\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n# with the trie like #ba and baa \n# before my solution when it fit ba, it will set the curr the self.trie['a'] again, which will miss the potential of baa\uff0c need a structure to preserve all possible curr\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            curr = self.trie\n            for char in word:\n                if char not in curr:\n                    curr[char] = {}\n                curr = curr[char]\n            curr['#'] = 1\n        #self.curr = self.trie\n        self.tmp = [self.trie]\n\n\n    def query(self, letter: str) -> bool:\n        new_tmp = [self.trie]\n        flag = False\n        for curr in self.tmp:\n            if letter in curr:\n                curr = curr[letter]\n                new_tmp.append(curr)\n                #check if it's the end\n                if '#' in curr: \n                    flag = True\n                    if letter in self.trie:\n                        new_tmp.append(self.trie[letter])      \n\n            #else:\n                #self.curr = self.trie\n            #    new_tmp.append(self.trie)\n        self.tmp = new_tmp\n\n        return flag\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n\n\n\n\n", "class StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        \n        self.queries = []\n        trie = {}\n        for word in words:\n            word = list(reversed(word))\n            here = trie\n            for i in range(len(word)):\n                if word[i] not in list(here.keys()):\n                    here[word[i]] = {}\n                here = here[word[i]]\n            here['is_word'] = True\n            \n        self.trie = trie    \n                \n\n    def query(self, letter: str) -> bool:\n        self.queries.append(letter)\n        \n        here = self.trie\n        for i in range(1, len(self.queries) + 1):\n            if self.queries[-i] not in list(here.keys()):\n                return False\n            here = here[self.queries[-i]]\n            if 'is_word' in list(here.keys()):\n                return True\n        \n        \n            \n        # for i in range(1, min(len(self.queries), self.max_len) + 1):\n        #     if i in self.vocab.keys():\n        #         word = \\\"\\\".join(self.queries[-i:])\n        #         if word in self.vocab[i]:\n        #             return True\n        # return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words):\n        \\\"\\\"\\\"\n        :type words: List[str]\n        \\\"\\\"\\\"      \n        self.waitlist = []\n        self.trie = dict()\n        for word in words:\n            # create a temporary dict based off our root dict object\n            temp_dict = self.trie\n            for letter in word:\n                # update our temporary dict and add our current letter and a sub-dictionary\n                # if key is not in dict, setdefault() will add {key:{}} and return default value {}\n                # otherwise it will directly return the existing value of key\n                temp_dict = temp_dict.setdefault(letter, dict())\n            # If our word is finished, add {'#': '#'} at the stopping node\n            temp_dict['#'] = '#'\n\n    def query(self, letter):\n        \\\"\\\"\\\"\n        :type letter: str\n        :rtype: bool\n        \\\"\\\"\\\"\n        waitlist = []\n        # if letter can be the prefix of word\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        # for each possible prefix, append letter if the new substr still can be a prefix\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n                \n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for w in words:\n            start = self.trie\n            for i, l in enumerate(w):\n                if l not in start:\n                    start[l] = {}\n                start = start[l]\n            start['#'] = True\n        self.past = [self.trie]\n    def query(self, letter: str) -> bool:\n        ans = False\n        new_past = [self.trie]\n        for ele in self.past:\n            if letter in ele:\n                if '#' in ele[letter]:\n                    ans = True\n                new_past.append(ele[letter])\n        self.past = new_past\n        return ans\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    \n    def build_trie(self, word: str) -> None:\n        place = self.trie\n        for ch in word:\n            if ch in place:\n                place = place[ch]\n            else:\n                place[ch] = dict()\n                place = place[ch]\n        place['*'] = None\n    \n    def __init__(self, words: List[str]) -> None:\n        self.words = set(words)\n        self.trie = dict()\n        for word in words:\n            self.build_trie(word)\n        print((self.trie))\n        self.temp = []\n        self.temp2 = []\n\n    def query(self, letter: str) -> bool:\n        self.temp2 = []\n        self.temp.append(self.trie)\n        can = False\n        for i in self.temp:\n            if letter in i:\n                self.temp2.append(i[letter])\n                if '*' in i[letter]:\n                    can = True\n            else:\n                continue\n        self.temp = self.temp2\n        return can\n            \n", "class StreamChecker:\n    STOP_CHAR = \\\"\\\n\\\"\n    \n    def __init__(self, words: List[str]):\n        self.root = dict()\n        self.pointers = list()\n        for word in words:\n            self.add(word)\n\n    def add(self, word):\n        word += self.STOP_CHAR\n        root = self.root\n        for char in word:\n            if char not in root:\n                root[char] = dict()\n            \n            root = root[char]\n    \n    def query(self, letter: str) -> bool:\n        self.pointers = [\n            pointer[letter]\n            for pointer in self.pointers\n            if pointer.get(letter) is not None\n        ]\n        new_pointer = self.root.get(letter)\n        if new_pointer is not None:\n            self.pointers.append(new_pointer)\n        for pointer in self.pointers:\n            if self.STOP_CHAR in pointer:\n                return True\n        return False\n    \n    \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            cur = self.trie\n            for c in word:\n                if c not in cur:\n                    cur[c] = {}\n                cur = cur[c]\n            cur[\\\"-\\\"] = True\n        self.currents = [self.trie]\n        #print(self.trie[\\\"b\\\"])\n\n    def query(self, letter: str) -> bool:\n        keep = [self.trie]\n        found = False\n        for v in self.currents:\n            if letter in v:\n                vv = v[letter]\n                found |= \\\"-\\\" in vv\n                if \\\"-\\\" not in vv or len(vv) > 1:\n                    keep.append(vv)\n\n        self.currents = keep\n        return found\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        \n        for word in words:\n            current = self.trie\n            for letter in word:\n                current.setdefault(letter, {})\n                current = current[letter]\n            current[\\\"__end__\\\"] = word\n        \n        self.currents = []\n    def query(self, letter: str) -> bool:\n        \n        self.currents.append(self.trie)\n        \n        ans = False\n        new_currents = []\n        for pos, current in enumerate(self.currents):\n            if letter in current:\n                new_currents.append(current[letter])\n                if \\\"__end__\\\" in current[letter]:\n                    ans = True\n        self.currents = new_currents\n        return ans\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "_end = '_end'\n\ndef make_trie(words):\n    root = dict()\n    for word in words:\n        current_dict = root\n        for letter in word:\n            current_dict = current_dict.setdefault(letter, {})\n        current_dict[_end] = _end\n    return root\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = make_trie(words)\n        self.cur_tries = []\n\n    def query(self, letter: str) -> bool:\n        new_tries = []\n        result = False\n        for tr in self.cur_tries + [self.trie]:\n            if letter in tr:\n                if _end in tr[letter]:\n                    result = True\n                if _end not in tr[letter] or len(tr[letter]) > 1:\n                    new_tries.append(tr[letter])\n        self.cur_tries = new_tries   \n        \n        return result\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.query_history = \\\"\\\"\n        self.max_word_len = max(map(len, words))\n\n    def query(self, letter: str) -> bool:\n        self.query_history = self.query_history[-self.max_word_len + 1:] + letter\n        return any(self.query_history.endswith(word) for word in self.words)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    \n    def __init__(self, words: List[str]):\n        \n        self.trie = {}\n        \n        for word in words:\n            cur = self.trie\n            for c in word:\n                if c not in cur:\n                    cur[c] = {}\n                cur = cur[c]\n            cur['end'] = None  \n            \n        self.buffer = []\n        \n    def query(self, letter: str) -> bool:\n        \n        found = False\n        swap = []\n        if letter in self.trie:\n            swap.append(self.trie[letter])\n            found = 'end' in self.trie[letter]\n\n        for b in self.buffer:\n            if letter in b:\n                swap.append(b[letter])\n                if 'end' in b[letter]:\n                    found = True\n        self.buffer = swap\n        return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self, v=None):\n        self.children: Dict[str, Node] = {}\n        self.parent: Node\n        self.value = v\n    \nclass Trie:\n    def __init__(self):\n        self.t = Node() #root;\n        self.leaves: Dict[str, List[Node]] = {}\n        self.maxLen: int = 0\n\n    def addLeave(self, w:str, n:Node) -> None:\n        if w not in list(self.leaves.keys()):\n            self.leaves[w] = []\n        self.leaves[w].append(n)\n        \n    def insert(self, w: str) -> None:\n        self.maxLen = max(self.maxLen, len(w))\n        tl = self.t\n        j = 0\n        while j<len(w):\n            i = w[j]\n            n = tl.children.get(i, None)\n            if n != None: #this char exist\n                tl = n\n                j += 1\n            else:\n                for i in w[j:]:\n                    newNode = Node(i)\n                    newNode.parent = tl\n                    tl.children[i] = newNode\n                    tl = newNode\n                break\n        self.addLeave(tl.value, tl)\n\n    \n\nclass StreamChecker:\n    from collections import deque\n    \n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        [self.trie.insert(w) for w in words]\n        self.q = deque(maxlen = self.trie.maxLen)\n\n    \n    def check_leaves(self) -> None:\n        for s in self.trie.leaves:\n            for i in self.trie.leaves[s]: #leave node\n                j = i\n                l=0\n                while j.parent.value != None:\n                    j = j.parent\n                    l += 1\n                print((s, l))\n                \n    def query(self, letter: str) -> bool:\n        self.q.append(letter)\n        fl = self.trie.leaves.get(letter, None)\n        if fl==None:\n            return False\n        \n        #print(\\\"last str\\\", letter)\n        for f in fl:\n            i = len(self.q) -2\n            #print(\\\"try\\\")\n            if f.parent.value==None: #reached root\n                return True #already reach\n            while i>=0:\n                l = self.q[i]\n                #print(l, f.parent.value)\n                if f.parent.value == l:\n                    f = f.parent\n                    i -= 1\n                else:\n                    break\n                \n                if f.parent.value==None: #reached root\n                    return True #already reach\n\n        return False\n                \n            \n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.pointers = []\n        for w in words:\n            t = self.trie\n            for c in w:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t['*'] = '*'        \n\n    def query(self, letter: str) -> bool:\n        new_ptr = self.trie\n        self.pointers.append(new_ptr)\n        new_pointers = []\n        ret_val = False\n        for p in self.pointers:\n            if letter in p:\n                p = p[letter]\n                if '*' in p:\n                    ret_val = True\n                new_pointers.append(p)\n        self.pointers = new_pointers\n        return ret_val\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    \n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = self.build(words)\n        self.history = []\n\n    def query(self, letter: str) -> bool:\n        self.history.append(self.root)\n        tmp = [node.children[letter] for node in self.history if letter in node.children]\n        self.history = tmp\n        for node in tmp:\n            if node.is_word:\n                return True\n        return False\n\n    def build(self, words):\n        root = TrieNode()\n        for word in words:\n            tmp = root\n            for c in word:\n                if c not in tmp.children:\n                    tmp.children[c] = TrieNode()\n                tmp = tmp.children[c]\n            tmp.is_word = True\n        return root\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.letters = ''\n        self.words = words\n        self.max_length = max([len(x) for x in words])\n\n    def query(self, letter: str) -> bool:\n        self.letters += letter\n        self.letters = self.letters[-self.max_length:]\n        # print(letter)\n        for word in self.words:\n            if word[-1] != letter:\n                continue\n            letters_word = self.letters[-len(word):]\n            # print(f'{word} == {letters_word} ??')\n            if word == letters_word:\n                # print(True, word)\n                return True\n        # print(False)\n        return False\n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            root = self.trie\n            for ch in word:\n                if not ch in root:\n                    root[ch] = {}\n                root = root[ch]\n            root['#'] = '#'\n            \n        self.nodes = [self.trie]\n\n    def query(self, letter: str) -> bool:\n        new_nodes = [self.trie]\n        res = False\n        for node in self.nodes:\n            if letter in node:\n                new_node = node[letter]\n                if '#' in new_node:\n                    res = True\n                new_nodes.append(new_node)\n        self.nodes = new_nodes\n        return res\n            \n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.dict_tree = {}\n        for i in words:\n            cur = self.dict_tree\n            for j in i:\n                if j not in cur:\n                    cur[j] = {}\n                cur = cur[j]\n            cur[-1] = True\n        self.char_stream = []\n        self.to_check = []\n                \n\n    def query(self, letter: str) -> bool:\n        temp = []\n        find = False\n        for i in self.to_check:\n            if letter in i:\n                i = i[letter]\n                temp.append(i)\n                if -1 in i:\n                    find = True\n        if letter in self.dict_tree:\n            if -1 in self.dict_tree[letter]:\n                find = True\n            temp.append(self.dict_tree[letter])\n        self.to_check = temp\n        return True if find else False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "from typing import Dict\n\nclass Node:\n    def __init__(self, char=None):\n        self.char = char\n        self.is_complete_word = False\n        self.children: Dict[str, 'Node'] = dict()\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n        \n    def insert(self, word: str):\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                current.children[char] = Node(char)\n            current = current.children[char]\n        current.is_complete_word = True\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.waitlist = []\n        self._max_length = 0\n        self.trie = Trie()\n        for word in words:\n            self.trie.insert(word[::-1])\n            self._max_length = max(self._max_length, len(word))\n\n    def query(self, letter: str) -> bool:\n        self.waitlist.append(letter)\n        i = len(self.waitlist) - 1\n        node = self.trie.root\n        while i >= 0:\n            if node.is_complete_word:\n                return True\n            letter = self.waitlist[i]\n            if letter not in node.children:\n                return False\n            node = node.children[letter]\n            i -= 1\n        return node.is_complete_word\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.waiting = []\n        for word in words: \n            self.root.insert(word)\n        \n        \n    def query(self, letter: str) -> bool:\n        \n        self.waiting = [node.child[letter] for node in self.waiting + [self.root] if letter in node.child]\n        \n        \n        for node in self.waiting:\n            if node.is_complete:\n                return True\n        \n        return False\n            \n\nclass TrieNode:\n    def __init__(self):\n        self.child = {}\n        self.is_complete = False\n        \n    def insert(self,word): \n        node = self\n        for letter in word:\n            if letter not in node.child:\n                new_node = TrieNode()\n                node.child[letter] = new_node\n            node = node.child[letter]\n        node.is_complete = True\n        \n    \n        \n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self, end=False):\n        self.end = end\n        self.lnk = {}\n    \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.head = TrieNode()\n        for w in words:\n            x = self.head\n            for i, c in enumerate(w):\n                if c not in x.lnk:\n                    y = TrieNode()\n                    x.lnk[c] = y\n                x = x.lnk[c]\n            x.end = True\n        self.ptrs = []\n\n    def query(self, letter: str) -> bool:\n        self.ptrs.append(self.head)\n        found = False\n        new_ptrs = []\n        for p in self.ptrs:\n            if letter in p.lnk:\n                q = p.lnk[letter]\n                new_ptrs.append(q)\n                found |= q.end\n        self.ptrs = new_ptrs\n        return found\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.children = defaultdict(bool)\n    def insert(self,word):\n        if word == '':\n            self.children['@'] = True\n        else:\n            child = self.children[word[0]]\n            if child:\n                child.insert(word[1:])\n            else:\n                newChild = Trie()\n                newChild.insert(word[1:])\n                self.children[word[0]] = newChild\n                \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        for word in words:\n            self.root.insert(word)\n        self.pointers = []\n\n    def query(self, letter: str) -> bool:\n        newPointers = []\n        retFlag = False\n        if letter in self.root.children:\n            newPointers.append(self.root.children[letter])\n            if '@' in self.root.children[letter].children:\n                retFlag = True\n        for p in self.pointers:\n            newP = p.children[letter]\n            if newP:\n                newPointers.append(newP)\n                if '@' in newP.children:\n                    retFlag = True\n        self.pointers = newPointers\n        return retFlag", "class StreamChecker:\n\n    def construct_trie(self, word_list):\n        root = dict()\n        for word in word_list:\n            word += \\\"_\\\"\n            level = root\n            for letter in word:\n                if letter not in level:\n                    level[letter] = dict()\n                level = level[letter]\n        return root\n    \n    def __init__(self, words: List[str]):\n        self.liste = self.construct_trie(words)\n        self.p = [self.liste]\n        \n\n    def query(self, letter: str) -> bool:\n        ll = [self.liste]\n        b = False\n        for dic in self.p:\n            if letter in dic:\n                d = dic[letter]\n                if \\\"_\\\" in d:\n                    b = True\n                ll.append(d)\n        self.p = ll\n        return b", "class StreamChecker:\n    # Approach: store reversed words in Trie\n    \n    def __init__(self, words: List[str]):\n        self.stream = []\n        self.trie = {}\n        for word in words:\n            node = self.trie\n            for char in reversed(word):\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['EOW'] = word\n\n    def query(self, letter: str) -> bool:\n        self.stream = [letter] + self.stream\n        node = self.trie\n        for char in self.stream:\n            if 'EOW' in node:\n                return True\n            if char not in node:\n                return False\n            node = node[char]\n        return 'EOW' in node\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.wordict = {}\n        self.word = ''\n        for word in words:\n            node = self.wordict\n            for c in word[::-1]:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node[0] = 0\n\n    def query(self, letter: str) -> bool:\n        self.word = self.word + letter\n        n = len(self.word)\n        nodes = self.wordict\n        while n:\n            if self.word[n-1] in nodes:\n                if 0 in nodes[self.word[n-1]]:\n                    return True\n                else:\n                    nodes = nodes[self.word[n-1]]\n                    n -= 1\n            else:\n                return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        for word in words:\n            node = self.trie\n            for c in word[::-1]:\n                if c not in node:\n                    node[c] = dict()\n                node = node[c]\n            node['.'] = '.'\n\n        self.syms = []\n\n    def query(self, letter: str) -> bool:\n        trie, syms = self.trie, self.syms\n        \n        syms.append(letter)\n        \n        node = trie\n        for c in syms[::-1]:\n            if c not in node:\n                return False\n            node = node[c]\n            if '.' in node:\n                return True\n        \n        return False\n\n# Runtime: 5832 ms, faster than 13.42% of Python3 online submissions for Stream of Characters.\n# class StreamChecker:\n\n#     def __init__(self, words: List[str]):\n#         self.trie = dict()\n#         for word in words:\n#             node = self.trie\n#             for c in word:\n#                 if c not in node:\n#                     node[c] = dict()\n#                 node = node[c]\n#             node['.'] = '.'\n\n#         self.curs = []\n\n#     def query(self, letter: str) -> bool:\n#         trie, curs = self.trie, self.curs\n        \n#         curs = [cur[letter] for cur in curs if letter in cur]\n#         if letter in trie:\n#             curs.append(trie[letter])\n#         self.curs = curs\n\n#         return any('.' in cur for cur in curs)\n", "from collections import defaultdict\n\ndef routing():\n    return defaultdict(routing)\n\n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.router = routing()\n        #print(f'{words=}')\n        for word in words:\n            root = self.router\n            for letter in word:\n                root = root[letter]\n            root[\\\"*\\\"] = word\n        self.queries = []\n\n    def query(self, letter: str) -> bool:\n        #print(f'{letter=} {len(self.queries)=}')\n        new_queries, matches = [], []\n        self.queries.append(self.router)\n        for q in self.queries:\n            if letter in q:\n                q = q[letter]\n                partials = len(q)\n                if '*' in q:\n                    matches.append(q[\\\"*\\\"])\n                    partials -= 1\n                if partials:\n                    new_queries.append(q)\n        self.queries = new_queries\n        #print(f'{matches=}')\n        return bool(matches)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            d = self.trie\n            for c in word:\n                if c not in d:\n                    d[c] = {}\n                d = d[c]\n            d['*'] = True\n        self.open_words = []\n\n    def query(self, letter: str) -> bool:\n        found = False\n        new_open_words = []\n        if letter in self.trie:\n            new_open_words.append(self.trie[letter])\n            if '*' in self.trie[letter]:\n                found = True\n        for word in self.open_words:\n            if letter in word:\n                if '*' in word[letter]:\n                    found = True\n                new_open_words.append(word[letter])\n        self.open_words = new_open_words\n        return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.check = []\n        for w in words:\n            d = self.trie\n            for c in w:\n                _d = d.get(c, {})\n                d[c] = _d\n                d = _d\n            d['.'] = True\n\n    def query(self, letter: str) -> bool:\n        next_check = []\n        found = False\n        for d in self.check + [self.trie]:\n            if letter in d:\n                _d = d[letter]\n                if '.' in _d:\n                    found = True\n                next_check.append(_d)\n        self.check = next_check\n        return found\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "TERM_CHAR = '\\\\0'\n\ndef build_trie(words):\n    trie = {}\n    \n    for word in words:\n        current = trie\n        for c in word:\n            if c not in current:\n                current[c] = {}\n            current = current[c]\n            \n        current[TERM_CHAR] = True\n        \n    return trie\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = build_trie(words)\n        \n        self.trie_currents = []\n\n    def query(self, letter: str) -> bool:\n        found = False\n        next_tries = []\n        for current in self.trie_currents + [self.trie]:\n            if letter in current:\n                next_tries.append(current[letter])\n                if current[letter].get(TERM_CHAR):\n                    found = True\n                    \n        self.trie_currents = next_tries\n                    \n        return found\n                \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self._values = set()\n        self.next = None\n        \n    def insert(self, value):\n        self._values.add(value)\n    \n    def has(self, value):\n        return value in self._values\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.q = ''\n        self.chars = set()\n        self.words = set()\n        \n        for word in words:\n            curr = self.root\n            for index in range(len(word) - 1, -1, -1):\n                char = word[index]\n                curr.insert(char)\n                self.chars.add(char)\n                if not curr.__next__: curr.next = TrieNode()\n                curr = curr.__next__\n                \n            self.words.add(word)\n    \n    def query(self, letter: str) -> bool:\n        if letter not in self.chars:\n            self.q = ''\n            return False\n        \n        self.q = letter + self.q\n        curr = self.root\n        sub_q = ''\n        for char in self.q:\n            if not curr.has(char):\n                return False\n            sub_q = char + sub_q\n            if sub_q in self.words:\n                return True\n            \n            curr = curr.__next__\n            \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "# 08-23-2020\n# Day 23 stream of characters\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n\n        trie = dict()\n        for word in words:\n            t = trie\n            for c in word:\n                if not c in t:\n                    t[c] = dict()\n                t = t[c]\n\n            t[None] = True\n\n        self.trie = trie\n        self.current_tries = []\n        \n\n    def query(self, letter: str) -> bool:\n        new_tries = []\n        res = False\n        for trie in self.current_tries:\n            if letter in trie:\n                trie = trie[letter]\n                new_tries.append(trie)\n\n                res = res | trie.get(None, False)\n\n        if letter in self.trie:\n            t = self.trie.copy()\n            t = t[letter]\n            res = res | t.get(None, False)\n            new_tries.append(t)\n            \n\n        self.current_tries = new_tries\n        \n        return res\n\n                \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.ord_a = ord('a')\n        stop_ord = ord('z') - self.ord_a + 1\n        self.trie = [None] * stop_ord\n        self.trie.append(False)\n        ord_l = 0\n        for word in words:\n            current = self.trie\n            for l in reversed(word):\n                ord_l = ord(l)-self.ord_a\n                if current[ord_l] is None:\n                    current[ord_l] = [None] * stop_ord\n                    current[ord_l].append(False)\n                current = current[ord_l]\n            current[-1] = True\n        #self.paths = []\n        #self.start = 0\n        self.stream = []\n\n    def query(self, letter: str) -> bool:\n        \n        result = False\n        #print()\n        #print(\\\"letter: {0}\\\".format(letter))\n        #print(self.paths)\n        ord_l = ord(letter) - self.ord_a\n        self.stream.append(ord_l)\n        #while (self.start+1) < len(self.paths) and self.paths[self.start] is None:\n        #    self.start+=1\n        #for path in range(self.start,len(self.paths)):\n        #    if not self.paths[path] is None:\n        #        if not self.paths[path][ord_l] is None:\n        #            self.paths[path] = self.paths[path][ord_l]\n        #            result = result | self.paths[path][-1]\n        #        else:\n        #            self.paths[path] = None\n        #if not self.trie[ord_l] is None:\n        #    self.paths.append(self.trie[ord_l])\n        #    result = self.trie[ord_l][-1] | result\n        #print(self.paths)\n        current = self.trie\n        for l in self.stream[::-1]:\n            current = current[l]\n            if current is None:\n                return False\n            elif current[-1]:\n                return True\n        return current[-1]\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                node = node.setdefault(c, {})\n            node['*'] = word\n        self.candidates = []\n\n    def query(self, letter: str) -> bool:\n        new = []\n        exists = False\n        for candidate in self.candidates + [self.trie]:\n            if letter in candidate:\n                new.append(candidate[letter])\n                if candidate[letter].get('*'):\n                    exists = True\n        self.candidates = new\n        return exists\n                \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.children = defaultdict(lambda: False)\n    def insert(self,word):\n        if word == '':\n            self.children['@'] = True\n        else:\n            child = self.children[word[0]]\n            if child:\n                child.insert(word[1:])\n            else:\n                newChild = Trie()\n                newChild.insert(word[1:])\n                self.children[word[0]] = newChild\n                \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        for word in words:\n            self.root.insert(word)\n        self.pointers = []\n\n    def query(self, letter: str) -> bool:\n        newPointers = []\n        # print(self.pointers)\n        retFlag = False\n        if letter in self.root.children:\n            newPointers.append(self.root.children[letter])\n            if '@' in self.root.children[letter].children:\n                retFlag = True\n        for p in self.pointers:\n            newP = p.children[letter]\n            if newP:\n                newPointers.append(newP)\n                if '@' in newP.children:\n                    retFlag = True\n        self.pointers = newPointers\n        return retFlag\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "import queue\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.max_len = 0\n        for w in words:\n            if w:\n                p = self.trie\n                self.max_len = max(self.max_len, len(w))\n                for idx in range(len(w) - 1, 0, -1):\n                    ch = w[idx]\n                    if not ch in p:\n                        p[ch] = {}\n                    p = p[ch]\n                p[w[0]] = {'$':None}\n        self.letters = []\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        p = self.trie\n        idx = len(self.letters) - 1\n        while p and idx >= max(len(self.letters) - self.max_len, 0):\n            if '$' in p:\n                return True\n            l = self.letters[idx]\n            if l in p:\n                p = p[l]\n            else:\n                return False\n            idx -= 1\n        else:\n            return '$' in p\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        self.state = []\n        for word in words:\n            curr = self.root\n            for c in list(word):\n                if c not in curr:\n                    curr[c] = {}\n                curr = curr[c]\n            curr['*'] = {}\n        \n\n    def query(self, letter: str) -> bool:\n        ret = False\n        new_state = []\n        if letter in self.root:\n            self.state.append(self.root)\n        for s in self.state:\n            if letter in s:\n                s = s[letter]\n                if '*' in s:\n                    ret = True\n                new_state.append(s)\n        self.state = new_state\n        return ret\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        self.letters = []\n        for w in words:\n            cur = self.trie\n            for l in w[::-1]:\n                if not l in cur:\n                    cur[l] = {}\n                cur = cur[l]\n            cur['end'] = {}\n\n    def query(self, letter: str) -> bool:\n        self.letters.append(letter)\n        cur = self.trie\n        for l in self.letters[::-1]:\n            if not l in cur:\n                return False\n            cur = cur[l]\n            if 'end' in cur:\n                return True\n        return False\n        \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        Trie = lambda: defaultdict(Trie)\n        self.root = Trie()\n        self.end = True\n        self.words = words\n        self.prevs = []\n        \n        for i, word in enumerate (words):\n            reduce (dict.__getitem__, word, self.root)[self.end] = i\n        \n\n    def query(self, letter: str) -> bool:\n        result = False\n        self.prevs.append(self.root)\n        if self.prevs:\n            new_prevs = []\n            for prev in self.prevs:\n                if letter in prev:\n                    new_prevs.append(prev[letter])\n                    result = result or self.end in new_prevs[-1]\n            self.prevs = new_prevs\n        return result\n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "\nimport functools\nclass StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: functools.reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class TrieNode:\n    def __init__(self):\n        self.children, self.end_node = {}, False\n         \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        root = self.root\n        for symbol in word:\n            root = root.children.setdefault(symbol, TrieNode())\n        root.end_node = True        \n\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        self.stream = []\n        for word in words: self.trie.insert(word[::-1])\n\n    def query(self, letter: str) -> bool:\n        self.stream.append(letter)\n        cur = self.trie.root\n        for c in self.stream[::-1]:\n            if c in cur.children:\n                cur = cur.children[c]\n                if cur.end_node: return True\n            else: break\n        return False\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    prefixes = []\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            d = self.trie\n            for letter in word:\n                if letter not in d:\n                    d[letter] = {}\n                d = d[letter]\n            d['end'] = True\n\n    def query(self, letter: str) -> bool:\n        self.prefixes = [node[letter] for node in self.prefixes + [self.trie] if letter in node]\n        # if letter in self.trie:\n        #     self.prefixes.append(self.trie[letter])\n        return any('end' in node for node in self.prefixes)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.trie = {}\n        \n    def add_word(self,word):\n        nextLevel = self.trie\n        for i,char in enumerate(word):\n            isWord = i == len(word) - 1\n            if char in nextLevel:\n                if isWord:\n                    nextLevel[char].isWord = True\n                nextLevel = nextLevel[char].children\n            else:\n                node = TrieNode(char, isWord)\n                nextLevel[char] = node\n                nextLevel = nextLevel[char].children\n            \n        \nclass TrieNode:\n    def __init__(self, char, isWord = False):\n        self.char = char\n        self.isWord = isWord\n        self.children = {}\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.words = set(words)\n        self.trie = Trie()\n        for word in words:\n            self.trie.add_word(word)\n            \n        self.nextLevels = []\n        self.count = 0\n\n    def query(self, letter: str) -> bool:\n        nextLevels = []\n        isWord = False\n        if len(self.nextLevels):\n            for level in self.nextLevels:\n                if letter in level:\n                    if level[letter].isWord:\n                        isWord = True\n                    nextLevels.append(level[letter].children)\n        \n        if letter in self.trie.trie:\n            nextLevels.append( self.trie.trie[letter].children )\n            if self.trie.trie[letter].isWord:\n                isWord = True\n                \n        self.nextLevels = nextLevels\n    \n        return isWord\n    \n", "class StreamChecker(object):\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.entries = {}\n        for word in words:\n            curNode = self.entries           \n            for i in range(len(word)):\n                cur = word[i]\n                if cur not in curNode:\n                    curNode[cur] = {}\n                curNode = curNode[cur]\n            curNode[\\\"#\\\"] = True\n        self.nodes = []\n\n    def query(self, letter: str) -> bool:\n        res = False\n        self.nodes.append(self.entries)\n        new_nodes = []\n        for node in self.nodes:\n            if letter in node:\n                node = node[letter]\n                if \\\"#\\\" in node:\n                    res = True\n                new_nodes.append(node)\n        self.nodes = new_nodes     \n        return res", "class StreamChecker:\n    class Node:\n        def __init__(self, isWord=False):\n            self.children = [None]*26\n            self.isWord = isWord\n            \n    import queue\n    def __init__(self, words: List[str]):\n        self.root = self.Node()\n        self.N = 0 # maxWordLength\n        for word in words:\n            self.N = max(self.N, len(word))\n            cursor = self.root\n            for c in reversed(word):\n                if next := cursor.children[ord(c)-97]:\n                    cursor = next\n                else:\n                    newNode = self.Node()\n                    cursor.children[ord(c)-97] = newNode\n                    cursor = newNode\n            cursor.isWord = True\n        \n        # self.queue = queue.Queue(maxsize=maxWordLen)\n        self.buffer = [None]*self.N\n        self.bIdx = self.N\n\n    def query(self, letter: str) -> bool:\n        # advance or terminate cursors\n        self.bIdx = (self.bIdx - 1) % self.N\n        self.buffer[self.bIdx] = letter\n        \n        cursor = self.root\n        for i in range(self.bIdx, self.N):\n            if next := cursor.children[ord(self.buffer[i])-97]:\n                if next.isWord:\n                    return True\n                cursor = next\n            else:\n                return False\n        for i in range(self.bIdx):\n            if self.buffer[i]:\n                if next := cursor.children[ord(self.buffer[i])-97]:\n                    if next.isWord:\n                        return True\n                    cursor = next\n                else:\n                    return False        \n        return False", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        for word in words:\n            curnode = self.root\n            for ch in word:\n                if ch not in curnode:\n                    curnode[ch] = {}\n                curnode = curnode[ch]\n            curnode['is_end'] = True\n        self.leads = [self.root] # the pointers to the threads we follow right now\n\n    def query(self, letter: str) -> bool:\n        next_leads = [self.root]\n        found_word = False\n        for lead in self.leads:\n            if letter in lead:\n                new_lead = lead[letter]\n                next_leads.append(new_lead)\n                if 'is_end' in new_lead:\n                    found_word = True\n        self.leads = next_leads\n        return found_word\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = collections.defaultdict()\n        for word in words:\n            root = self.trie\n            for c in word:\n                root = root.setdefault(c, {})\n            root[\\\"#\\\"] = \\\"#\\\"\n        self.cache = []\n    \n    def query(self, letter: str) -> bool:\n        next_cache = []\n        for node in self.cache + [self.trie]:\n            if letter in node:\n                next_cache.append(node[letter])\n        self.cache = next_cache\n        for node in self.cache:\n            if '#' in node:\n                return True\n        return False\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.waitlist = []\n        self.trie = {}\n        for word in words:\n            t = self.trie\n            for char in word:\n                if char not in t:\n                    t[char] = {}\n                t = t[char]\n            t['#'] = \\\"#\\\"\n        \n    def query(self, letter: str) -> bool:\n        waitlist = []\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        \n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n        self.waitlist = waitlist\n        return any([\\\"#\\\" in i for i in self.waitlist])\n        \n        \n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n    def query(self, letter):\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class Trie:\n    def __init__(self):\n        self.children = defaultdict(bool)\n        # self.children = {}\n    def insert(self,word):\n        if word == '':\n            self.children['@'] = True\n        else:\n            child = self.children[word[0]]\n            if child:\n                child.insert(word[1:])\n            else:\n                newChild = Trie()\n                newChild.insert(word[1:])\n                self.children[word[0]] = newChild\n                \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        for word in words:\n            self.root.insert(word)\n        self.pointers = []\n\n    def query(self, letter: str) -> bool:\n        newPointers = []\n        retFlag = False\n        self.pointers.append(self.root)\n        # if letter in self.root.children:\n        #     newPointers.append(self.root.children[letter])\n        #     if '@' in self.root.children[letter].children:\n        #         retFlag = True\n        for p in self.pointers:\n            newP = p.children[letter]\n            if newP:\n                newPointers.append(newP)\n                if '@' in newP.children:\n                    retFlag = True\n        self.pointers = newPointers\n        return retFlag", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # construct a trie (a dict of dicts)\n        self.root = {}\n        for word in words:\n            sub = self.root\n            for c in word:\n                sub = sub.setdefault(c, {})\n            sub['0'] = None\n        self.current = []\n\n    def query(self, letter: str) -> bool:\n        newQueries = []\n        checker = False\n        for query in self.current:\n            if letter in query:\n                nextQuery = query[letter]\n                checker = checker or '0' in nextQuery\n                newQueries.append(nextQuery)\n        if letter in self.root:\n            nextQuery = self.root[letter]\n            checker = checker or '0' in nextQuery\n            newQueries.append(nextQuery)\n        self.current = newQueries\n        return checker\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        for word in words:\n            node = self.root\n            for c in word:\n                node.setdefault(c, {})\n                node = node[c]\n            node[''] = True\n        self.ptrs = []\n\n    def query(self, letter: str) -> bool:\n        ptrs = self.ptrs\n        ptrs.append(self.root)\n        i, L = 0, len(ptrs)\n        found = False\n        while i < L:\n            if letter in ptrs[i]:\n                ptrs[i] = ptrs[i][letter]\n                if '' in ptrs[i]:\n                    found = True\n                i += 1\n            else:\n                ptrs[i] = ptrs[L-1]\n                ptrs.pop()\n                L -= 1\n        return found\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self):\n        self.children = defaultdict(bool)\n        # self.children = {}\n    def insert(self,word):\n        if word == '':\n            self.children['@'] = True\n        else:\n            child = self.children[word[0]]\n            if child:\n                child.insert(word[1:])\n            else:\n                newChild = Trie()\n                newChild.insert(word[1:])\n                self.children[word[0]] = newChild\n                \nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.root = Trie()\n        for word in words:\n            self.root.insert(word)\n        self.pointers = []\n\n    def query(self, letter: str) -> bool:\n        newPointers = []\n        retFlag = False\n        self.pointers.append(self.root)\n        for p in self.pointers:\n            newP = p.children[letter]\n            if newP:\n                newPointers.append(newP)\n                if '@' in newP.children:\n                    retFlag = True\n        self.pointers = newPointers\n        return retFlag", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.context = []\n        self.map = [{}, False]\n        \n        for w in words:\n            it = self.map\n            for c in w:\n                if c not in it[0]:\n                    it[0][c] = [{}, False]\n                it = it[0][c]\n            it[1] = True\n\n    def query(self, letter: str) -> bool:\n        new_context = []\n        for m in self.context:\n            if letter in m[0]:\n                new_context.append(m[0][letter])\n        \n        if letter in self.map[0]:\n            new_context.append(self.map[0][letter])\n            \n        self.context = new_context\n        for m in self.context:\n            if m[1]:\n                return True\n        return False\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.Dict = collections.defaultdict(set)\n        self.queries = ''\n        for word in words:\n            self.Dict[word[-1]].add(word)\n\n    def query(self, letter: str) -> bool:\n        if letter not in self.Dict:\n            self.queries += letter\n            return False\n        else:\n            temp = set([len(x) for x in self.Dict[letter]])\n            self.queries += letter\n            for length in temp:\n                if (length <= len(self.queries)) and (self.queries[-1:-length-1:-1][::-1] in self.Dict[letter]):\n                    return True\n                \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie(dict):\n    word = False\n    def add(self, word):\n        t = self\n        for c in word:\n            if c not in t:\n                t[c] = Trie()\n            t = t[c]\n        t.word = True\n        \n\nclass StreamChecker:\n    def __init__(self, words: List[str]):\n        self.t = Trie()\n        for w in words:\n            self.t.add(w)\n        self.s = []\n\n    def query(self, c: str) -> bool:\n        self.s = [t[c] for t in self.s if c in t]\n        if c in self.t:\n            self.s.append(self.t[c])\n        return any(t.word for t in self.s)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.waitlist = []\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for word in words:\n            temp_dict = self.trie\n            for letter in word:\n                temp_dict = temp_dict[letter]\n            temp_dict['#'] = True\n\n    def query(self, letter: str) -> bool:\n        waitlist = []\n        if letter in self.trie:\n            waitlist.append(self.trie[letter])\n        for item in self.waitlist:\n            if letter in item:\n                waitlist.append(item[letter])\n        self.waitlist = waitlist\n        return any('#' in item for item in self.waitlist)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    class TrieNode:\n        def __init__(self):\n            self.d = {}        \n            self.word = False\n            \n        def add(self, word):    \n            node = self\n            for c in word:\n                if c not in node.d:\n                    node.d[c] = StreamChecker.TrieNode()\n                node = node.d[c]    \n            node.word = True    \n            \n        def __repr__(self):\n            return f'{self.d}'    \n            \n    def __init__(self, words: List[str]):\n        t = self.TrieNode()\n        for word in words:\n            t.add(word)    \n        self.root = t    \n        self.tries = []\n    \n    def query(self, letter: str) -> bool:\n        self.tries = [e.d[letter] for e in self.tries if letter in e.d]      \n        if letter in self.root.d:\n            self.tries.append(self.root.d[letter])        \n        print((len(self.tries)))    \n        return any([e.word for e in self.tries])    \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = dict()\n        for word in words:\n            d = self.trie\n            for char in word:\n                if char not in d:\n                    d[char] = dict()\n                d = d[char]\n            d['*'] = False            \n                \n        self.recent = list()\n        \n\n    def query(self, letter: str) -> bool:\n        self.recent = [d[letter] for d in self.recent if letter in d]\n        if letter in self.trie:\n            self.recent.append(self.trie[letter])\n        return any('*' in d for d in self.recent)\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = {}\n        for word in words:\n            node = self.root\n            for c in word:\n                node = node.setdefault(c, {})\n            node['is_end'] = True\n        self.running = []\n\n    def query(self, letter: str) -> bool:\n        survived = []\n        found = False\n\n        if letter in self.root:\n            self.running.append(self.root)\n\n        for node in self.running:\n            if letter in node:\n                survived.append(node[letter])\n                found = found or 'is_end' in survived[-1]\n\n        self.running = survived\n        return found", "class TrieNode:\n        \n    def __init__(self):\n        self.is_word = False\n        self.children = dict()\n\nclass StreamChecker:\n    \\\"\\\"\\\"Seems super slow?...\\\"\\\"\\\"\n\n    def __init__(self, words: List[str]):\n        self._root = TrieNode()\n        self._valid_nodes = list()\n        for word in words:\n            self._insert(word)\n        \n            \n    def _insert(self, word: str):\n        node = self._root\n        for letter in word:\n            if letter not in node.children:\n                node.children[letter] = TrieNode()\n            node = node.children[letter]\n        node.is_word = True\n\n    def query(self, letter: str) -> bool:\n        # Shallow copy should be enough\n        # node = copy.copy(self._root)\n        node = self._root\n        self._valid_nodes.append(node)\n        next_valid_nodes = list()\n        found = False\n        for node in self._valid_nodes:\n            if letter in node.children:\n                node = node.children[letter]\n                next_valid_nodes.append(node)\n                if node.is_word:\n                    found = True\n        self._valid_nodes = next_valid_nodes\n        return found\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "from collections import deque\nclass Node:\n    def __init__(self):\n        self.child = dict()\n        self.end = False\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = Node()\n        \n        for i in words:\n            self.insert(self.root,i[::-1])\n        self.key = deque()\n        #print(self.root.child)\n    def insert(self,root,key):\n        for i in key:\n            if root.child.get(i,None) == None:\n                root.child[i] = Node()\n            root = root.child[i]\n        root.end = True\n    def query(self, letter: str) -> bool:\n        self.key.appendleft(letter)\n        curr = self.root\n        #print(self.key)\n        for i in self.key:\n            if curr.child.get(i,None) == None:break\n            curr = curr.child[i]\n            if curr.end:return True\n        return False\n            \n        \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self, val='.'):\n        self.val = val\n        self.children = {}\n        self.is_word = False    \n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = self.__init_trie(words)\n        self.q = []\n\n    def query(self, letter: str) -> bool:\n        self.q.append(self.root)\n        new_q = []\n        found = False\n        for node in self.q:\n            if letter in node.children:\n                child_node = node.children[letter]\n                new_q.append(child_node)\n                if child_node.is_word:\n                    found = True\n        self.q = new_q\n        return found    \n    \n    def __init_trie(self, words):\n        root = Node()\n        for word in words:\n            cur = root\n            for i, ch in enumerate(word):\n                if ch not in cur.children:\n                    cur.children[ch] = Node(ch)\n                cur = cur.children[ch]\n            cur.is_word = True\n        return root\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n    class TrieNode:\n        def __init__(self):\n            self.d = {}        \n            self.word = False\n            \n        def add(self, word):    \n            node = self\n            for c in word:\n                if c not in node.d:\n                    node.d[c] = StreamChecker.TrieNode()\n                node = node.d[c]    \n            node.word = True    \n            \n        def __repr__(self):\n            return f'{self.d}'    \n            \n    def __init__(self, words: List[str]):\n        t = self.TrieNode()\n        for word in words:\n            t.add(word)    \n        self.root = t    \n        self.tries = []\n    \n    def query(self, letter: str) -> bool:\n        self.tries = [e.d[letter] for e in self.tries if letter in e.d]      \n        if letter in self.root.d:\n            self.tries.append(self.root.d[letter])        \n        return any([e.word for e in self.tries])    \n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    def __init__(self, char):\n        self.char = char\n        self.children = {}\n        self.isEnd = False\n        \nclass TireTree:\n    def __init__(self):\n        self.root = Trie('')\n        \n    def insert(self, word):\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = Trie(c)\n                cur = cur.children[c]\n            else:\n                cur = cur.children[c]\n        cur.isEnd = True\n    \n    def search(self, word, cur):\n        for c in word:\n            if c not in cur.children:\n                return False\n            \n            cur = cur[c]\n        return cur.isEnd\n    \n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.tree = TireTree()\n        for word in words:\n            self.tree.insert(word)\n        self.root = self.tree.root\n        self.paths = [self.root]\n        \n\n    def query(self, letter: str) -> bool:\n        nextpaths = [self.root]\n        flag = False\n        for p in self.paths:\n            if letter in p.children:\n                node = p.children[letter]\n                nextpaths.append(node)\n                        \n                if node.isEnd:\n                    flag = True\n                \n        self.paths = nextpaths\n        return flag\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self._values = set()\n        self.next = None\n        \n    def insert(self, value):\n        self._values.add(value)\n    \n    def has(self, value):\n        return value in self._values\n    \n    def __str__(self):\n        return f'Node {self._values} | next -> {self.next}'\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        self.q = ''\n        self.chars = set()\n        self.words = set()\n        \n        for word in words:\n            curr = self.root\n            for index in range(len(word) - 1, -1, -1):\n                char = word[index]\n                curr.insert(char)\n                self.chars.add(char)\n                if not curr.__next__: curr.next = TrieNode()\n                curr = curr.__next__\n                \n            self.words.add(word)\n        \n        print((self.root))\n    \n    def query(self, letter: str) -> bool:\n        if letter not in self.chars:\n            self.q = ''\n            return False\n        \n        self.q = letter + self.q\n        curr = self.root\n        sub_q = ''\n        for char in self.q:\n            if not curr.has(char):\n                return False\n            sub_q = char + sub_q\n            if sub_q in self.words:\n                return True\n            \n            curr = curr.__next__\n            \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Tire:\n    def __init__(self, char):\n        self.char = char\n        self.end = False \n        self.children = {} \n        \n    def __repr__(self):\n        return '<{}: {}>'.format(self.char, self.end)\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n        # self.root = Tire('^')\n        # \n        # for word in words:\n        #     node = self.root\n        #     for char in word:\n        #         if char not in node.children:\n        #             node.children[char] = Tire(char)\n        #         node = node.children[char]\n        #     node.end = True    \n        #     \n        # self.possible_nodes = set() \n\n    def query(self, letter: str) -> bool:\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n \n        # self.possible_nodes.add(self.root)\n        # \n        # nxt = set()\n        # found = False\n        # for node in self.possible_nodes:\n        #     if letter in node.children:\n        #         nxt.add(node.children[letter])\n        #         if node.children[letter].end:\n        #             found = True\n        # self.possible_nodes = nxt\n        # return found\n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            t = self.trie\n            for w in word:\n                if w in t:\n                    t = t[w]\n                else:\n                    t[w] = {}\n                    t = t[w]\n            t['$'] = word\n        self.currWords = [self.trie]\n        \n    def query(self, letter: str) -> bool:\n        q = self.currWords\n        q.append(self.trie)\n        newQ  = []\n        ans = False\n        for node in q:\n            if letter in node:\n                if '$' in node[letter]:\n                    ans = True\n                newQ.append(node[letter])\n        self.currWords = newQ\n        return ans\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        T = lambda: collections.defaultdict(T)\n        self.trie = T()\n        for w in words: reduce(dict.__getitem__, w, self.trie)['#'] = True\n        self.waiting = []\n\n        \n\n    def query(self, letter: str) -> bool:\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\n        return any(\\\"#\\\" in node for node in self.waiting)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n    def __init__(self, words: List[str]):\n        self.d = [{}, False]\n        for word in words:\n            condition = self.d\n            for letter in word:\n                if letter not in condition[0]:\n                    condition[0][letter] = [{}, False]\n                condition = condition[0][letter]\n            condition[1] = True\n        self.pool = [self.d]\n        #print(self.d)\n\n    def query(self, letter: str) -> bool:\n        new_pool = [self.d]\n        ret = False\n        for one in self.pool:\n            if letter in one[0]:\n                if one[0][letter][1]:\n                    ret = True\n                new_pool.append(one[0][letter])\n        self.pool = new_pool\n        #print(self.pool)\n                    \n        return ret\n                    \n                \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    class Node:\n        def __init__(self):\n            self.end=False\n            self.child=dict()\n            \n    def __init__(self, words: List[str]):\n        self._root=self.Node()\n        self.seq = []\n        \n        def insert(word=''):\n            node = self._root\n            for c in reversed(word):\n                if c not in node.child:\n                    node.child[c]=self.Node()\n                node=node.child[c]\n            node.end = True\n        \n        for word in words:\n            insert(word)\n        \n\n    def _search(self) -> bool:\n        node=self._root\n        ind=len(self.seq)\n        while ind:\n            node=node.child.get(self.seq[ind-1], None)\n            if not node:\n                return False\n            if node.end:\n                return True\n            ind-=1\n        return False\n        \n    def query(self, letter: str) -> bool:\n        self.seq.append(letter)\n        if len(self.seq)>2000:\n            self.seq.pop(0)\n        return self._search()\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "import collections\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n        self.Trie = {}\n        \n        for word in words:\n            parent = self.Trie\n            for char in word:\n                parent = parent.setdefault(char, {})\n            parent['$'] = None\n        \n        self.waitList = []\n        \n    def query(self, letter: str) -> bool:\n        \n        waitList = []\n        \n        if letter in self.Trie:\n            waitList.append(self.Trie[letter])\n            \n        for currTrie in self.waitList:\n            if letter in currTrie:\n                waitList.append(currTrie[letter])    \n        \n        self.waitList = waitList\n\n        return any('$' in item for item in waitList)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self, v=None):\n        self.children: Dict[str, Node] = {}\n        self.parent: Node\n        self.value = v\n    \nclass Trie:\n    def __init__(self):\n        self.t = Node() #root;\n        self.leaves: Dict[str, List[Node]] = {}\n        self.maxLen: int = 0\n\n    def addLeave(self, w:str, n:Node) -> None:\n        if w not in list(self.leaves.keys()):\n            self.leaves[w] = []\n        self.leaves[w].append(n)\n        \n    def insert(self, w: str) -> None:\n        self.maxLen = max(self.maxLen, len(w))\n        tl = self.t\n        j = 0\n        while j<len(w):\n            i = w[j]\n            n = tl.children.get(i, None)\n            if n != None: #this char exist\n                tl = n\n                j += 1\n            else:\n                for i in w[j:]:\n                    newNode = Node(i)\n                    newNode.parent = tl\n                    tl.children[i] = newNode\n                    tl = newNode\n                break\n        self.addLeave(tl.value, tl)\n\n\nclass StreamChecker:\n    from collections import deque\n    \n    def __init__(self, words: List[str]):\n        self.trie = Trie()\n        [self.trie.insert(w) for w in words]\n        self.q = deque(maxlen = self.trie.maxLen)\n                \n    def query(self, letter: str) -> bool:\n        self.q.append(letter)\n        fl = self.trie.leaves.get(letter, None)\n        if fl==None:\n            return False\n        \n        for f in fl:\n            i = len(self.q) -2\n            if f.parent.value==None: #reached root\n                return True #already reach\n            while i>=0:\n                l = self.q[i]\n                if f.parent.value == l:\n                    f = f.parent\n                    i -= 1\n                else:\n                    break\n                \n                if f.parent.value==None: #reached root\n                    return True #already reach\n\n        return False\n                \n            \n            \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        \n        for word in words:\n            node = self.trie\n            for c in word:\n                node = node.setdefault(c, {})\n            node[\\\"*\\\"] = None\n        self.cur = [self.trie]\n\n    def query(self, letter: str) -> bool:\n        ans = False\n        new = [self.trie]\n        for node in self.cur:\n            if letter in node:\n                new.append(node[letter])\n                if not ans and \\\"*\\\" in node[letter]:\n                    ans = True\n        \n        self.cur = new\n        return ans\n                \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = self.create_trie(words)\n        self.l = []\n\n    def create_trie(self, words):\n        trie = {}\n        for word in words:\n            curr = trie\n            for ch in word:\n                if ch not in curr:\n                    curr[ch] = {}\n                curr = curr[ch]\n            curr['.'] = True\n        return trie\n            \n        \n    def query(self, letter: str) -> bool:\n        self.l.append(self.trie)\n        new_list = []\n        is_word = False\n        for trie in self.l:\n            if letter in trie:\n                new_list.append(trie[letter])\n                is_word |= '.' in trie[letter]\n        self.l = new_list\n        return is_word\n                \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "def _trie():\n    return collections.defaultdict(_trie)\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = _trie()\n        for word in words:\n            trie = self.trie\n            for c in word:\n                if c not in trie:\n                    trie[c] = _trie()\n                trie = trie[c]\n            trie['END']\n        self.activePtr = []\n    def query(self, letter: str) -> bool:\n        matched = False\n        if letter in self.trie:\n            self.activePtr.append(self.trie)    \n        for i, trie in enumerate(self.activePtr):\n            if letter in trie:\n                trie = trie[letter]\n                if 'END' in trie:\n                    matched = True\n                    #self.activePtr[i] = None\n                self.activePtr[i] = trie\n            else :\n                self.activePtr[i] = None\n        self.activePtr = [t for t in self.activePtr if t is not None]        \n        return matched\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Trie:\n    \n    def __init__(self):\n        self.root = dict()\n        self.ptr = []\n        \n    def add(self, word):\n        curr = self.root\n        for c in word:\n            if not c in curr:\n                curr[c] = dict()\n            curr = curr[c]\n        \n        curr['$'] = dict()\n        \n    def search(self, c):\n        self.ptr.append(self.root)\n        new_ptr = []\n        ans = False\n        for ptr in self.ptr:\n            if c in ptr:\n                new_ptr.append(ptr[c])\n        self.ptr = new_ptr\n        \n        return any(['$' in p for p in self.ptr])\n    \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.T = Trie()\n        for word in words:\n            self.T.add(word)\n\n    def query(self, letter: str) -> bool:\n        return self.T.search(letter)\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.leaf = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        # leads is a collection of trie nodes\n        self.trie = TrieNode()\n        for word in words:\n            node = self.trie\n            for i in range(len(word)):\n                c = word[i]\n                if c not in node.children:\n                    node.children[c] = TrieNode()\n                node = node.children[c]\n                if i == len(word) - 1:\n                    node.leaf = True\n        self.leads = []\n\n    def query(self, letter: str) -> bool:\n        new_leads = []\n        result = False\n        for lead in self.leads:\n            if letter in lead.children:\n                node = lead.children[letter]\n                if node.leaf:\n                    result = True\n                new_leads.append(node)\n        if letter in self.trie.children:\n            if self.trie.children[letter].leaf:\n                result = True\n            new_leads.append(self.trie.children[letter])\n        self.leads = new_leads\n        return result\n                \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class Node:\n    def __init__(self, val='', endWord = False):\n        self.val = val\n        self.endWord = endWord\n        self.children = dict()\n        \nclass Trie:\n    def __init__(self, words):\n        self.root = Node()\n        for word in words:\n            self.insertWord(word)\n        \n    def insertWord(self, word):\n        currentNode = self.root\n        for letter in word:\n            if not letter in currentNode.children:\n                currentNode.children[letter] = Node(letter)\n            currentNode = currentNode.children[letter]\n        currentNode.endWord = True\n\n        \nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = Trie(words)\n        self.trieRoot = self.trie.root\n        self.currentNodes = []\n        \n\n    def query(self, letter: str) -> bool:\n        newNodes = []\n        if letter in self.trieRoot.children:\n            newNodes.append(self.trieRoot.children[letter])\n            \n        for node in self.currentNodes:\n            if letter in node.children:\n                newNodes.append(node.children[letter])\n                \n        self.currentNodes = newNodes\n        for node in self.currentNodes:\n            if node.endWord:\n                return True\n            \n        return False\n        \n        \n            \n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.size = len(max(words, key=len))\n        self.words = set(words)\n        self.curr = \\\"\\\"\n\n    def query(self, letter: str) -> bool:\n        #try each word with the corresponding last number of letters\n        #\n        self.curr = self.curr + letter\n        self.curr = self.curr[-self.size:]\n        for w in self.words:\n            length = len(w)\n            if self.curr[-length:] == w:\n                return True\n        \n        return False\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)", "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.trie = {}\n        for word in words:\n            self.trie_insert(word)\n        self.searches = []\n    \n    def trie_insert(self, word):\n        curr = self.trie\n        for letter in word:\n            if letter not in curr:\n                curr[letter] = {}\n            curr = curr[letter]\n        curr['*'] = True # mark last node as a word\n    \n    \n    def query(self, letter: str) -> bool:\n        self.searches.append(self.trie)\n        self.searches = [node.get(letter) for node in self.searches if letter in node]\n        return any('*' in node for node in self.searches)\n                \n        \n\n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)\n"]
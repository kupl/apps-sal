["class Solution:\n     def minSubArrayLen(self, k, nums):\n         \"\"\"\n         :type k: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 0\n         _min = float('inf')\n         _sum = 0\n         j = 0\n \n \n         for i ,n in enumerate(nums):\n             _sum += n\n             while _sum>=k:\n                 _min = min(i-j+1, _min)\n                 _sum -= nums[j]\n                 j+=1\n         return _min if _min!=float('inf') else 0\n             \n", "class Solution:\n     def minSubArrayLen(self, s, nums):\n         \"\"\"\n         :type s: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         result = float('inf')\n         left = 0\n         total = 0\n         for i in range(len(nums)):\n             total += nums[i]\n             while total >= s:\n                 result = min(result, i + 1 - left)\n                 total -= nums[left]\n                 left += 1\n         return 0 if result == float('inf') else result \n", "class Solution:\n     def minSubArrayLen(self, s, nums):\n         \"\"\"\n         :type s: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \n         left, right, curr = 0, 0, 0\n         minLen = len(nums)+1\n         while right < len(nums):\n             curr += nums[right]\n             while curr >= s:\n                 minLen = min(minLen, right-left+1)  \n                 curr -= nums[left]\n                 left += 1\n             right += 1\n         \n         return minLen if minLen != (len(nums)+1) else 0", "class Solution:\n     def minSubArrayLen(self, s, nums):\n         \"\"\"\n         :type s: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         i = 0\n         j = 0\n         _s = 0\n         _min = len(nums) + 1\n         if len(nums) == 0:\n             return 0\n         \n         while(j < len(nums)):\n             _s += nums[j]\n             j += 1\n             while(_s >= s):\n                 _min = min(_min, j - i)\n                 _s -= nums[i]\n                 i += 1\n                 \n         if _min > len(nums): return 0\n         else: return _min\n", "class Solution:\n \n     def minSubArrayLen(self, s, nums):\n         total = left = 0\n         result = len(nums) + 1\n         for right, n in enumerate(nums):\n             total += n\n             while total >= s:\n                 result = min(result, right - left + 1)\n                 total -= nums[left]\n                 left += 1\n         return result if result <= len(nums) else 0", "class Solution:\n     def minSubArrayLen(self, s, nums):\n         \"\"\"\n         :type s: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if sum(nums) < s:\n             return 0\n         \n         res = float(\"inf\")\n         \n         start = 0\n         curr = 0\n         \n         for i in range(len(nums)):\n             curr += nums[i]\n             # print(i, curr)\n             while curr >= s:\n                 res = min(res, i - start + 1)\n                 curr -= nums[start]\n                 start += 1\n         \n         return res\n                 \n", "class Solution:\n     def minSubArrayLen(self, s, nums):\n         \"\"\"\n         :type s: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 0\n         total = left = 0\n         result = len(nums) +1\n         for right,num in enumerate(nums):\n             total += num\n             while total>=s:\n                 result = min(result,right-left+1)\n                 total -= nums[left]\n                 left += 1\n         return result if result <= len(nums) else 0\n                 \n             \n         \n", "class Solution:\n     # this one is really easy to confuse you to apply greedy method. The greed method will start from the whole string and delete the smaller one of the start and the end element. This is wrong since there could be a case that at one end there are two mid-range number that sum over s while at the other end there are a big number and a smalle one which do not sum over s. The greedy method will delete the first mid-range number hence provide the wrong answer.\n     \n     # instead, one could apply the following algorithm: start from the beginning, add nums[i] to sum, if sum is greater than s, we keep substracting from the beginning of the current subarray until the sum is no greater thans, then we keep moving i to the next one unitl the sum is greater than s again. \n     def minSubArrayLen(self, s, nums): \n         \"\"\"\n         :type s: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums or sum(nums)<s:\n             return 0\n         ans=len(nums)\n         left=0\n         temps=0\n         for i in range(len(nums)):\n             temps+=nums[i]\n             while temps>=s:\n                 ans=min(ans,i+1-left)\n                 temps-=nums[left]\n                 left+=1\n         return ans\n", "class Solution:\n     def minSubArrayLen(self,s,nums):\n         \"\"\"two pointers. \u5728\u4e00\u4e2a\u5faa\u73af\u5b8c\u6210\u540e,[i-1,j]\u5fc5\u7136\u662f[0,j]\u4e2d\u6700\u77ed\u7684\n         \u7b26\u5408\u8981\u6c42\u7684\u533a\u95f4. \u6545i-1\u524d\u4f5c\u4e3a\u8d77\u70b9,j\u524d\u4f5c\u4e3a\u7ec8\u70b9\u7684\u533a\u95f4\u53ef\u4e0d\u8003\u8651,\n         \u5373\u622a\u6389i-1\u4e4b\u524d\u7684\u533a\u95f4.\"\"\"\n         i=0;\n         j=0;\n         tempSum=0;\n         length=len(nums);\n         minLength=0x7FFFFFFF;\n         while(i<length and j<length):\n             while j<length:\n                 tempSum+=nums[j];\n                 if tempSum>=s:\n                     break;\n                 j+=1;\n             if j<length:\n                 minLength=min(j-i+1,minLength);\n                 while i<=j:\n                     if tempSum<s:\n                         break;\n                     tempSum-=nums[i];\n                     i+=1;\n \n                 minLength=min(j-i+2,minLength);\n                 j+=1;\n                     \n \n         if minLength==0x7FFFFFFF:\n             return 0;\n         else:\n             return minLength;\n", "class Solution(object):\n     def minSubArrayLen(self, s, nums):\n         \"\"\"\n         :type s: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 0\n         import math\n         minlen = math.inf\n         pt1 = 0\n         pt2 = 0\n         cursum = nums[0]\n         while pt2 < len(nums):\n             if cursum >= s:\n                 minlen = min(minlen,pt2 - pt1 + 1)\n             if minlen == 1:\n                 return 1\n             if cursum < s:\n                 pt2 += 1\n                 if pt2 < len(nums):\n                     cursum += nums[pt2]\n             elif cursum >= s:\n                 cursum -= nums[pt1]\n                 pt1 += 1\n         return 0 if minlen == math.inf else minlen", "class Solution:\n     def minSubArrayLen(self, s, nums):\n         \"\"\"\n         :type s: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if sum(nums) < s:\n             return 0\n         \n         res = float(\"inf\")\n         \n         start = 0\n         curr = 0\n         \n         for i in range(len(nums)):\n             curr += nums[i]\n             # print(i, curr)\n             while curr >= s:\n                 res = min(res, i - start + 1)\n                 curr -= nums[start]\n                 start += 1\n         \n         return res\n                 \n", "class Solution:\n     def minSubArrayLen(self, s, nums):\n         \"\"\"\n         :type s: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \n         \n         prePtr = 0\n         curPtr = 0\n         \n         curSum = 0\n         \n         res = float('inf')\n         \n         while curPtr < len(nums):\n             \n             curSum += nums[curPtr]\n                 \n             if curSum >= s:\n                     \n                 while curSum >= s:\n                     curSum -= nums[prePtr]\n                     prePtr += 1\n                 prePtr -= 1\n                 curSum += nums[prePtr]\n                     \n                 res = min(res, curPtr-prePtr+1)\n                 \n             curPtr += 1\n         if res == float('inf'):\n             return 0\n         else:\n             return res\n", "class Solution:\n     def minSubArrayLen(self, s, nums):\n         \"\"\"\n         :type s: int\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if nums is None or len(nums) == 0:\n             return 0\n         running_sum = [nums[0]]\n         for num in nums[1:]:\n             running_sum.append(running_sum[-1] + num)\n         def sub_sum(i,j):\n             to_remove = 0 if i == 0 else running_sum[i-1]\n             to_add = 0 if j == 0 else running_sum[j-1]\n             return to_add - to_remove\n         min_seen = float('inf')\n         fast = 0\n         slow = 0\n         while fast < len(nums):\n             while sub_sum(slow, fast) < s and fast < len(nums):\n                 fast += 1\n             while sub_sum(slow, fast) >= s and slow <= fast:\n                 min_seen = min(min_seen, fast - slow)\n                 slow += 1\n         return 0 if min_seen == float('inf') else min_seen \n"]
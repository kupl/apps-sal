["from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    singles, pairs = [], []\n    \n    # group digits to pairs and singles\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    \n    # avoid trailing zeros\n    if pairs and pairs[0] == '0':\n        pairs = []\n    \n    # return largest possible palindrom\n    if not singles:\n        singles = ['']\n    return int( ''.join(pairs) + singles[0] + ''.join(pairs[::-1]) )\n\n\ndef numeric_palindrome(*args):\n    args = Counter(args)\n    candidates = set()\n    \n    # remove extra 0s and 1s\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    \n    args = list(args.elements())\n    \n    # check all possible products\n    for n in range(2, len(args)+1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add( largest_palindrom_from(product) )\n    \n    return max(candidates)", "from collections import Counter\nfrom itertools import combinations\nfrom functools import reduce\nfrom operator import mul\n\ndef best_pal(array):\n    outside, inside = [], ''\n    for k,v in Counter(array).items():\n        if v > 1: outside.append(k*(v//2))\n        if v % 2: inside = max(inside, k)\n    outside = ''.join(sorted(outside))\n    if outside and outside[-1] == '0': outside = ''\n    return int(''.join(outside[::-1] + inside + outside))\n\ndef numeric_palindrome(*args):\n    args = list(filter(None, args))\n    if len(args) < 2: return 0\n    if 1 in args: args = list(filter(lambda x: x>1, args)) + [1]\n    if len(args) == 1: return best_pal(str(args[0]))\n    return max(best_pal(str(reduce(mul, test))) for i in range(2, len(args)+1) for test in combinations(args, i))", "from itertools import combinations as comb\n\ndef numeric_palindrome(*args):\n    args=[item for item in args if item>0]\n    if len(args)<2: return 0\n    if 1 in args: args=[item for item in args if item>1]+[1]\n    if len(args)==1: return max_pal(list(str(args[0])))\n    maxval=-1\n    for i in range(2,len(args)+1):\n        base=comb(args, i)\n        for combo in base:\n            prod=1\n            for item in combo:\n                prod*=item\n            maxval=max(maxval, max_pal(list(str(prod))))\n    return maxval\n\ndef max_pal(array):\n    even=sorted([n*(array.count(n)/2) for n in set(array) if array.count(n)>1])\n    odd=[n for n in set(array) if array.count(n)%2==1]\n    odd=[\"\"] if len(odd)==0 else odd\n    if len(even)==1 and even[0][0]=='0': even=[\"\"]\n    return int(\"\".join(even[::-1]+[max(odd)]+even))", "#Largest Numeric Palindrome\nprintit = False\n\ndef prefilter(available):\n    ones = None\n    for _ in range(available.count(0)):\n        available.remove(0)\n    if len(available) == 1:\n        available.append(0)\n    for _ in range(available.count(1)):\n        available.remove(1)\n        ones = True\n    if len(available) >= 1 and ones:\n        available.extend([1])\n    elif len(available) == 1 and ones:\n        available.extend([1])\n    elif len(available) == 0 and ones:\n        available.extend([1,1])\n    else:\n        available.extend([0,0])\n\ndef comb(available, used):\n    if len(available) == 0:\n        pass\n    else:\n        head = available.pop()\n        used.append(head)\n        if len(used) >= 2:\n            yield(list(used))\n        for x in comb(available[:],used[:]):\n            yield x\n        used.pop()\n        for x in comb(available[:],used[:]):\n            yield x\n\ndef numeric_palindrome(*args):\n    lst = [*args]\n    prefilter(lst)\n    lst = [x for x in comb(lst,[])]\n    if printit:\n        print('sorted:',sorted([sorted(x) for x in lst]))\n    if lst == []:\n        return 0\n    if printit:\n        print(lst) #\n    products = []\n    for nums in lst:\n        result = 1\n        for num in nums:\n            result *= num\n        products.append(str(result))\n    products = [str(x) for x in products]\n    if printit:\n        print(products) #\n    lsts = [sorted([int(char) for char in product],reverse=True) for product in products]\n    if printit:\n        print(lsts) #\n    palindromes = []\n    pal_ind = 0\n    for nums in lsts:\n        sel_nums = []\n        if printit:\n            print(sel_nums) #\n        odd_added = False\n        for num in sorted(list(set(nums)),reverse=True):\n            num_count = nums.count(num)\n            if num_count % 2 == 0:\n                for i in range(num_count):\n                    sel_nums.append(num)\n            elif num_count % 2 == 1 and not odd_added:\n                for i in range(num_count):\n                    sel_nums.append(num)\n                    odd_added = True\n            else:\n                for i in range(num_count-1):\n                    sel_nums.append(num)\n                    odd_added = True\n        if printit:\n            print('sel_nums:',sel_nums) #\n        i = 0\n        while len(sel_nums) > 0:\n            if sel_nums.count(sel_nums[0]) == 1:\n                sel_nums.append(sel_nums.pop(0))\n            if len(sel_nums) > 1 and i == 0:\n                palindromes.insert(pal_ind,[])\n                palindromes[pal_ind].insert(0,str(sel_nums.pop(0)))\n                palindromes[pal_ind].insert(1,str(sel_nums.pop(0)))\n                if printit:\n                    print('first branch, i:',str(i),palindromes[pal_ind]) #\n                i += 1\n                continue\n            elif len(sel_nums) == 1 and i == 0:\n                palindromes.insert(pal_ind,list(str(sel_nums.pop(0))))\n                if printit:\n                    print('second branch, i:',str(i),palindromes[pal_ind]) #\n                i += 1\n                continue\n            elif len(sel_nums) >= 2:\n                palindromes[pal_ind].insert(i,str(sel_nums.pop(0)))\n                palindromes[pal_ind].insert(-i,str(sel_nums.pop(0)))\n                if printit:\n                    print('third branch, i:',str(i),palindromes[pal_ind]) #\n                i += 1\n                continue\n            elif len(sel_nums) == 1:\n                palindromes[pal_ind].insert(i,str(sel_nums.pop()))\n                if printit:\n                    print('forth branch, i:',str(i),palindromes[pal_ind]) #\n                i += 1\n                continue\n        if printit:\n            print('building:',palindromes[pal_ind]) #\n            print(str(i)) #\n        pal_ind += 1\n    palindromes = [int(''.join(x)) for x in palindromes]\n    while str(max(palindromes))[-1] == '0' and len(str(max(palindromes))) > 1:\n        max_num = max(palindromes)\n        new_num = str(max_num).strip('0')\n        palindromes.remove(max_num)\n        palindromes.append(int(new_num))\n    return max(palindromes)", "def palindrome(num):\n    l = list(str(num))\n    if len(l) == 1:\n            return num\n    else:\n        l2 = [x for x in l if l.count(x)>=2]\n        l22 = list(set(l2))\n        l1 = [x for x in list(set(l)) if l.count(x)%2 != 0]\n        l22.sort()\n        if len(l2)==0 and len(l1) > 0 or len(l2) == l2.count('0'):\n            return int(max(l1))\n        else:\n            l2a = ''\n            for i in range(len(l22)):\n                if l2.count(l22[i])%2 > 0: \n                    n = l2.count(l22[i])//2\n                else:\n                    n = l2.count(l22[i])/2\n                l2a = l2a + l22[i] * int(n)\n            l2b = l2a[::-1]\n            if len(l1)>0:\n                l2c = l2b + str(max(l1)) + l2a\n            else:\n                l2c = l2b + l2a\n            return int(l2c)\n\ndef product1(list,pro,i,out):\n    if i < len(list):\n        proa = pro\n        prob = list[i]\n        \n        pro = proa * prob\n        if pro not in out:\n            out.append(pro)\n        product1(list,pro,i+1,out)\n        product1(list,proa,i+1,out)\n        product1(list,prob,i+1,out)\n        \ndef numeric_palindrome(*args):\n    args1 = [x for x in args if x > 1]\n    args1.sort()\n    out1 = []\n    pro1 = []\n    if args1 == [] and args.count(1) > 1:\n        return 1\n    elif args.count(0) == len(args) - 1 or args1 == []:\n        return 0\n    elif len(args1) == 1:\n        return palindrome(args1[0])\n    else:\n        product1(args1,args1[0],1,pro1)\n        if args.count(1) > 0:\n            pro1 = pro1 + args1\n        \n        for j in pro1:\n            out = palindrome(j)\n            out1.append(out)\n    return max(out1)\n", "from itertools import combinations\nfrom functools import reduce\n\ndef max_pal(n):\n    if n < 10: return n\n    a = [0]*10\n    while n:\n        n,d = divmod(n,10)\n        a[d] += 1\n    s = \"\"\n    for d,n in enumerate(a):\n        c = str(d)\n        while n > 1:\n            s = c+s+c\n            n -= 2\n        a[d] = n\n    if s.startswith('0'): s = \"\"\n    i = next((i for i in range(9,-1,-1) if a[i]),-1)\n    if ~i: s = s[:len(s)>>1] + str(i) + s[len(s)+1>>1:]\n    return int(s)\n\ndef numeric_palindrome(*a):\n    z = 0 in a\n    o = a.count(1)\n    a = [n for n in a if n > 1]\n    if o: a.append(1)\n    a = [max_pal(reduce(int.__mul__,r)) for i in range(2,len(a)+1) for r in combinations(a,i)]\n    if z: a.append(0)\n    if o > 1: a.append(1)\n    return max(a)", "import itertools\nfrom functools import reduce\nfrom operator import mul\nimport re\n\n\ndef max_palindrome(x):\n    s = str(x)\n    left, odds = [], []\n    for c in set(s):\n        cnt = s.count(c)\n        d, d1 = cnt//2, cnt % 2\n        if d:\n            left.append(c*d)\n        if d1:\n            odds.append(c)\n    left.sort(reverse=True)\n    s1 = ''.join(left)\n    m = max(odds) if odds else ''\n    temp = s1+m+s1[::-1]\n    temp = re.sub(r'0*$', '', temp)\n    return int(temp)\n\n\ndef numeric_palindrome(*args):\n    arr = [x for x in args if x > 1]\n    if 1 in args:\n        arr.append(1)\n    if len(arr) > 1:\n        res = 0\n        for i in range(2, len(arr)+1):\n            temp = [max_palindrome(reduce(mul, x))\n                    for x in itertools.combinations(arr, i)]\n            res = max(max(temp), res)\n        return res\n    elif len(arr) == 1:\n        return max_palindrome(arr[0]) if args.count(1)>1 in args else 0\n    else:\n        return 1 if args.count(1) > 1 else 0\n", "from itertools import combinations\ndef funk(*args):\n    num = 1\n    for i in args[0]:\n        num *= i\n    num = str(num)\n    d_2 = {i: num.count(i)//2 for i in num if num.count(i)//2}\n    d_1 = {i: num.count(i)%2 for i in num if num.count(i)%2}\n    main_part = ''.join([d_2[i] * i for i in sorted(d_2, reverse=True)]) \n    add_part = max(d_1) if d_1 else ''\n    res = main_part + add_part + main_part[::-1]\n    res = res.strip('0')\n    return int(res) \n\ndef numeric_palindrome(*args):\n    if all([i in [0, 1] for i in args]) and args.count(1) >= 2:\n        return 1\n    l_new = [i for i in args if i not in [0,1]]\n    l_new = l_new + [1] if 1 in args else l_new\n    l = [l_new]\n    if len(l_new) < 2:\n        return 0\n    \n    for i in range(2, len(l_new)):\n        l += [tuple_ for tuple_ in combinations(l_new, i)]\n    l = [funk(i) for i in l]\n    return max(l)", "from functools import reduce\nfrom itertools import combinations\nfrom collections import Counter\n\ndef max_palindrome(num):\n    counter = Counter(str(num))\n    one = [int(x) for x, v in list(counter.items()) if v % 2 == 1]\n    if 0 < len(one):\n        one = str(max(one))\n    else:\n        one = \"\"\n    more = []\n    for x in counter:\n        while 2 <= counter[x]:\n            more.append(x)\n            counter[x] -= 2\n    more.sort()\n    if 0 < len(more) and more[-1] == '0':\n        more = \"\"\n    more = \"\".join(more)\n    res = more[::-1] + one + more\n    return int(res)\n\ndef numeric_palindrome(*args):\n    palindromes = []\n    one = args.count(1)\n    args = [arg for arg in args if 1 < arg]\n    if 0 < one:\n        args.append(1)\n    if 1 < one:\n        args.append(1)\n        \n    for n in range(2, len(args)+1):\n        comb = list(combinations(args, n))\n        for c in comb:\n            product = reduce(lambda a, b: a * b, c)\n            palindromes.append(max_palindrome(product))\n    return max(palindromes) if 0 < len(palindromes) else 0\n", "from collections import Counter\ndef numeric_palindrome(*args):\n    seen = set()\n    products = set()\n    for number in args:\n        for multiplier in seen.union(products):\n            products.add(multiplier*number)\n        seen.add(number)\n\n    palindromes = set()\n    for number in products:\n        occurrences = Counter(str(number))\n        repeated= []\n        max_single = ''\n        for char, count in occurrences.items():\n            if count//2 > 0 and char != '0':\n                repeated.extend([char]*(count//2))\n            if count%2 == 1:\n                if max_single < char: max_single = char\n        \n        half_palindrome = ''\n        while repeated:\n            maximum = max(repeated)\n            half_palindrome += maximum\n            repeated.remove(maximum)\n        if half_palindrome: half_palindrome += '0'*(occurrences['0']//2)\n        palindrome = half_palindrome + max_single + half_palindrome[::-1]\n        palindromes.add(int(palindrome))\n    return max(palindromes)"]
["class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        tree = [[] for _ in range(N)]\n        for i, j in edges:\n            tree[i].append(j)\n            tree[j].append(i)\n        \n        cnt = [1] * N\n        res = [0] * N\n        \n        def post_order(node, parent):\n            for i in tree[node]:\n                if i != parent:\n                    post_order(i, node)\n                    cnt[node] += cnt[i]\n                    res[node] += res[i] + cnt[i]\n                    \n        def pre_order(node, parent):\n            for i in tree[node]:\n                if i != parent:\n                    res[i] = res[node] - cnt[i] + (N - cnt[i])\n                    pre_order(i, node)\n        post_order(0, -1)\n        pre_order(0, -1)\n        \n        return res\n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        \n        graph = [[] for _ in range(N)]\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n            graph[edge[1]].append(edge[0])\n            \n        dist_sum = [0 for  _ in range(N)]\n        node_num = [1 for _ in range(N)]\n        \n        def post_order(node, parent):\n            for n in graph[node]:\n                if n == parent:\n                    continue\n                \n                post_order(n, node)\n                node_num[node] += node_num[n]\n                dist_sum[node] += dist_sum[n] + node_num[n]\n                \n        def pre_order(node, parent):\n            for n in graph[node]:\n                if n == parent:\n                    continue\n                \n                dist_sum[n] = dist_sum[node] - node_num[n] + (N - node_num[n])\n                pre_order(n, node)\n\n        \n        post_order(0, -1)\n        pre_order(0, -1)\n        return dist_sum\n", "from collections import defaultdict\nclass Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        dd = defaultdict(set)\n        # \u5c06edges\u4e2d\u7684\u8def\u5f84\u6784\u5efa\u6210\u6811\n        for u, v in edges:\n            dd[u].add(v)\n            dd[v].add(u)\n        # \u8fd9\u9898\u6838\u5fc3\u9700\u8981\u5173\u6ce8\u7684\u4e24\u79cd\u6570\u636e\u5206\u522b\u4e3a\u5f53\u524d\u8282\u70b9\u6709\u591a\u5c11\u4e2a\u5b50\u8282\u70b9\uff08\u5305\u542b\u81ea\u5df1\uff09\u4ee5\u53ca\u5f53\u524d\u8282\u70b9\u5230\u6240\u6709\u5b50\u8282\u70b9\u7684\u8def\u5f84\u8ddd\u79bb\u548c\n        counts = [1] * N # \u8bb0\u5f55\u5f53\u524d\u8282\u70b9\u6709\u591a\u5c11\u4e2a\u5b50\u8282\u70b9\uff08\u5305\u62ec\u81ea\u5df1\uff09\n        dists = [0] * N # \u8bb0\u5f55\u5f53\u524d\u8282\u70b9\u5230\u5b50\u8282\u70b9\u7684\u8def\u5f84\u8ddd\u79bb\u4e4b\u548c\n        # \u4ee50\u4e3aroot\u7684\u60c5\u51b5\u4e0bcounts\u548cdists\n        def dfs1(root, pre):\n            for node in dd[root]:\n                if node != pre:\n                    dfs1(node, root)\n                    counts[root] += counts[node]\n                    dists[root] += dists[node] + counts[node]\n        # \u8c03\u6574root\u4f4d\u7f6e\u5230\u5404\u4e2a\u8282\u70b9\uff0c\u540c\u65f6\u66f4\u65b0dists\uff1b\u8fd9\u91cc\u7684\u8ba1\u7b97\u539f\u7406\u662f\uff0croot\u79fb\u52a8\u5230node\uff0c\u540c\u65f6node\u4e0b\u6709x\u4e2a\u5b50\u8282\u70b9\uff08\u5305\u62ecnode\u81ea\u5df1\uff09\uff0c\n        # \u90a3\u4e48\u5c31\u662f\u4e0ex\u4e2a\u8282\u70b9\u7684\u8ddd\u79bb-1\uff0c\u540c\u65f6\u4e0eN-x\u4e2a\u8282\u70b9\u7684\u8ddd\u79bb+1\n        def dfs2(root, pre):\n            for node in dd[root]:\n                if node != pre:\n                    dists[node] = dists[root] - 1*counts[node] + 1*(N - counts[node])\n                    dfs2(node, root)\n        dfs1(0, -1)\n        dfs2(0, -1)\n        return dists", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        import collections\n        self.graph = collections.defaultdict(set)\n        for u, v in edges:\n            self.graph[u].add(v)\n            self.graph[v].add(u)\n        self.count = [1 for _ in range(N)]\n        self.sums = [0 for _ in range(N)]\n        self.dfs(0, None)\n        self.dfs1(0, None, N)\n        return self.sums\n    \n    def dfs(self, node, parent):\n        for child in self.graph[node]:\n            if child == parent:\n                continue\n            self.dfs(child, node)\n            self.count[node] += self.count[child]\n            self.sums[node] += self.sums[child] + self.count[child]\n    \n    def dfs1(self, node, parent, N):\n        for child in self.graph[node]:\n            if child == parent:\n                continue\n            self.sums[child] = self.sums[node] + N - 2*self.count[child]\n            self.dfs1(child, node, N)\n\n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        tree = collections.defaultdict(set)\n        res = [0] * N\n        count = [1] * N\n        for i, j in edges:\n            tree[i].add(j)\n            tree[j].add(i)\n\n        def dfs(root, pre):\n            for i in tree[root]:\n                if i != pre:\n                    dfs(i, root)\n                    count[root] += count[i]\n                    res[root] += res[i] + count[i]\n\n        def dfs2(root, pre):\n            for i in tree[root]:\n                if i != pre:\n                    res[i] = res[root] - count[i] + N - count[i]\n                    dfs2(i, root)\n        dfs(0, -1)\n        dfs2(0, -1)\n        return res", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        # first construct graph\n        links = [[] for _ in range(N)]\n        for a,b in edges:\n            links[a].append(b)\n            links[b].append(a)\n        # --\n        sums1 = [0] * N  # botton up\n        nums1 = [None] * N  # number of descants (including self)\n        sums2 = [0] * N  # top down\n        # --\n        # dfs1: this time we only sum the chidren's info\n        self.dfs1(None, 0, links, sums1, nums1)\n        # dfs2: this time from parent to children\n        self.dfs2(None, 0, links, sums1, nums1, sums2, 0, 0)\n        return [a+b for a,b in zip(sums1, sums2)]\n        \n    def dfs1(self, p: int, x: int, links, sums1, nums1):\n        cur_sum, cur_num = 0, 0\n        for x2 in links[x]:\n            if x2 != p:\n                self.dfs1(x, x2, links, sums1, nums1)\n                cur_sum += sums1[x2]\n                cur_num += nums1[x2]\n        sums1[x] = cur_sum + cur_num  # add 1 for all\n        nums1[x] = cur_num + 1  # add self\n        # --\n\n    def dfs2(self, p: int, x: int, links, sums1, nums1, sums2, up_num: int, up_sum: int):\n        cur_chs = [x2 for x2 in links[x] if x2!=p]\n        cur_sums1 = [sums1[z] for z in cur_chs]\n        cur_nums1 = [nums1[z] for z in cur_chs]\n        all_sums1, all_nums1 = sum(cur_sums1), sum(cur_nums1)\n        for x2 in cur_chs:\n            tmp_up_num = (up_num+1) + (all_nums1 - nums1[x2])\n            tmp_up_sum = up_sum + (all_sums1 - sums1[x2]) + tmp_up_num + (tmp_up_num-(up_num+1))\n            sums2[x2] = tmp_up_sum\n            self.dfs2(x, x2, links, sums1, nums1, sums2, tmp_up_num, tmp_up_sum)\n        # --\n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        # build graph as adj_list\n        adj_list = defaultdict(list)\n        for v1, v2 in edges:\n            adj_list[v1].append(v2)\n            adj_list[v2].append(v1)\n        root = 0\n\n        subT_size = {}\n        def postorder(t, par_t)->int:\n            # returns the sum of distance from t to subtree(t)\n            if len([c for c in adj_list[t] if c != par_t]) == 0:\n                subT_size[t] = 1\n                return 0\n            else:\n                ans = sum(postorder(c, t) for c in adj_list[t] if c != par_t)\n                subT_size[t] = sum(subT_size[c] for c in adj_list[t] if c != par_t) + 1\n                return ans + subT_size[t] - 1\n\n        res = [0]*N\n        def preorder(t, par_t):\n            res[t] = res[par_t] - subT_size[t] * 2 + tot\n            for c in adj_list[t]:\n                if c != par_t:\n                    preorder(c, t)\n\n        # main  \n        res[root] = postorder(root, -1)\n        tot = subT_size[root]\n        print(subT_size)\n        for c in adj_list[root]:\n            preorder(c, root)\n\n        return res\n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        self.N = N\n        self.childnum = [0] * self.N\n        self.cdist = [0] * self.N\n        self.neighbors = []\n        for i in range(N):\n            self.neighbors.append(set())\n            \n        for e in edges:\n            self.neighbors[e[0]].add(e[1])\n            self.neighbors[e[1]].add(e[0])\n\n        \n        self.visit(0, set([-1]))\n#        print(\\\"child num:\\\", self.childnum)\n#        print(\\\"cdist\\\", self.cdist)\n        self.visit2(0, set([-1]))\n        return self.cdist\n            \n            \n    def visit2(self, node, pre):\n        children = self.neighbors[node] - pre\n        pre = pre.pop()\n        if pre != -1:\n            self.cdist[node] = self.cdist[pre] + self.N - 2*(self.childnum[node] + 1)\n        for c in children:\n            self.visit2(c, set([node]))\n        \n            \n    def visit(self, node, pre):\n        children = self.neighbors[node] - pre\n        #print(\\\"node\\\", node, \\\"children\\\", children)\n        for c in children:\n            self.visit(c, set([node]))\n        for c in children:\n            #print(self.matrix)\n            self.childnum[node] += self.childnum[c] + 1\n            self.cdist[node] += self.cdist[c]\n            \n        self.cdist[node] += self.childnum[node]\n    \n\n        \n        \n", "class Solution(object):\n    def sumOfDistancesInTree(self, N, edges):\n        graph = collections.defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n\n        count = [1] * N\n        ans = [0] * N\n        def dfs(node = 0, parent = None):\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n                    count[node] += count[child]\n                    ans[node] += ans[child] + count[child]\n\n        def dfs2(node = 0, parent = None):\n            for child in graph[node]:\n                if child != parent:\n                    ans[child] = ans[node] - count[child] + N - count[child]\n                    dfs2(child, node)\n\n        dfs()\n        dfs2()\n        return ans", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        Nodes = [None]*N\n        \n        def node(i):\n            if Nodes[i] is None:\n                Nodes[i] = Node(i)\n            return Nodes[i]\n        \n        adj = defaultdict(list)\n        for edge in edges:\n            adj[edge[0]].append(edge[1])\n            adj[edge[1]].append(edge[0])\n        \n        root = node(0)\n        stack = [0]\n        while stack:\n            i = stack.pop()\n            for j in adj[i]:\n                if Nodes[j] is None:\n                    stack.append(j)\n                    node(i).children.append(node(j))\n        \n        self.below(root)\n        \n        ans = [0]*N\n        ans[0] = node(0).dists_below\n        stack = [node(0)]\n        while stack:\n            parent = stack.pop()\n            for child in parent.children:\n                stack.append(child)\n                ans[child.val] = ans[parent.val] + N-2-2* child.below\n        \n        return ans\n    \n    def below(self, node):\n        node.below = 0\n        node.dists_below = 0\n        for child in node.children:\n            self.below(child)\n            node.below+= 1+child.below\n            node.dists_below +=  child.dists_below\n        node.dists_below += node.below\n            \n        \n\n        \n        \nclass Node:\n    def __init__(self, val, children = None):\n        self.val = val\n        self.children = children if children else []", "from collections import defaultdict, deque\n\nclass Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        children = {}\n        d = defaultdict(set)\n        for edge in edges:\n            d[edge[0]].add(edge[1])\n            d[edge[1]].add(edge[0])\n        visited = set()\n        self.dist = 0\n        def check(node, e):\n            out = 1\n            visited.add(node)\n            for adj in d[node]:\n                if adj not in visited:\n                    out += check(adj, e + 1)\n            children[node] = out\n            self.dist += e\n            return out\n        \n        check(0, 0)\n        \n        ans = [0] * N\n        visited = {0}\n        q = deque([(0, self.dist)])\n        while len(q) > 0:\n            cur, total = q.popleft()\n            ans[cur] = total\n            for adj in d[cur]:\n                if adj not in visited:\n                    q.append((adj, total + N - children[adj] - children[adj]))\n                    visited.add(adj)\n        return ans\n            \n", "class Solution(object):\n    def sumOfDistancesInTree(self, N, edges):\n        if N == 0 or not edges:\n            return [0]\n        \n        graph = {i: set() for i in range(N)}\n        for n1, n2 in edges:\n            graph[n1].add(n2)\n            graph[n2].add(n1)\n        \n        count = [1] * N\n        subSums = [0] * N\n        def countSubTree(node, parent):\n            nonlocal count, subSums\n            for child in (n for n in graph[node] if n != parent):\n                countSubTree(child, node)\n                count[node] += count[child]\n                subSums[node] += subSums[child] + count[child]\n            \n        countSubTree(0, None)\n        result = [0] * N\n        result[0] = subSums[0]\n        \n        def countGlobal(node, parent):\n            nonlocal result, count\n            if parent != None:\n                result[node] = result[parent] - count[node] + N - count[node]\n            for child in (n for n in graph[node] if n != parent):\n                countGlobal(child, node)\n        countGlobal(0, None)\n        return result", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        graph = [[] for i in range(N)]\n        for i in edges:\n            graph[i[0]].append(i[1])\n            graph[i[1]].append(i[0])\n        dist = [0 for i in range(N)]\n        nums = [1 for i in range(N)]\n        def post_order(node, parent):\n            for i in graph[node]:\n                if i == parent:\n                    continue\n                post_order(i, node)\n                nums[node] += nums[i]\n                dist[node] += dist[i] + nums[i]\n        \n        def pre_order(node, parent):\n            for i in graph[node]:\n                if i == parent:\n                    continue\n                dist[i] = dist[node] - nums[i] + N - nums[i]\n                pre_order(i, node)\n            \n        post_order(0, -1)\n        pre_order(0, -1)\n        return dist", "#https://leetcode.com/problems/sum-of-distances-in-tree/\n#https://github.com/tyqi11/leetcode/blob/master/834_Sum_of_Distances_in_Tree.java\nclass Solution:\n    def sumOfDistancesInTree(self, N, edges):\n        tree = collections.defaultdict(set)\n        res = [0] * N\n        count = [1] * N\n        for i, j in edges: #tree[i] contains all nodes connected to i.\n            tree[i].add(j)\n            tree[j].add(i)\n        print(tree)\n\n        def dfs(root, pre):  #Post order \n            for i in tree[root]:\n                if i != pre: #\n                    dfs(i, root)\n                    count[root] += count[i] #count[i]: # of nodes in subtree i.(+itself)\n                    res[root] += res[i] + count[i] #res[i]: sum of distance in subtree i.\n\n        def dfs2(root, pre): #Pre order\n            for i in tree[root]:\n                if i != pre: \n                    res[i] = res[root] - count[i] + N - count[i] \n                    dfs2(i, root)\n                    \n        dfs(0, -1)\n        dfs2(0, -1)\n        #print(count)\n        return res", "from collections import defaultdict\n\n\nclass Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        g = Graph()\n        for u, v in edges:\n            g.connect(u, v)\n            \n        children = [0] * N\n        cumul = [0] * N\n        \n        discovered = set()\n        stack = [(0, None)]\n        while stack:\n            u, parent = stack.pop()\n            if u not in discovered:\n                discovered.add(u)\n                stack.append((u, parent))\n                \n                for v in g.adj[u]:\n                    if v != parent:\n                        stack.append((v, u))\n                        \n            else:\n                discovered.remove(u)\n                children[u] = sum(1 + children[v] for v in g.adj[u] if v != parent)\n                cumul[u] = children[u] + sum(cumul[v] for v in g.adj[u] if v != parent)\n                \n        stack = [(0, None)]\n        while stack:\n            u, parent = stack.pop()\n            if parent is not None:\n                cumul[u] = cumul[parent] + N - 2 * (children[u] + 1)\n                \n            for v in g.adj[u]:\n                if v != parent:\n                    stack.append((v, u))\n                    \n        return cumul\n    \n    \nclass Graph:\n    def __init__(self):\n        self.adj = defaultdict(set)\n        \n    def connect(self, u, v):\n        self.adj[u].add(v)\n        self.adj[v].add(u)", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        graph = collections.defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n            \n        count = [1] * N\n        ans = [0] * N\n        print(graph)\n        def postorder(node = 0, parent = None):\n            for child in graph[node]:\n                if child != parent:\n                    postorder(child, node)\n                    count[node] += count[child]\n                    ans[node] += ans[child] + count[child]\n        def preorder(node = 0, parent = None):\n            for child in graph[node]:\n                if child != parent:\n                    ans[child] = ans[node] - count[child] + (N - count[child])\n                    preorder(child, node)\n        postorder()\n        preorder()\n        # print(count)\n        return ans", "class Node:\n    def __init__(self, cur):\n        self.cur = cur\n        self.edges = set()\n        self.num_children = 0\n        self.total_dist = 0\n        \n    def add_edge(self, Node):\n        self.edges.add(Node)\n    '''\n    @property\n    def num_children(self):\n        return self.num_children\n    \n    @num_children.setter\n    def num_children(self, num_children):\n        self.num_children = num_children\n        \n    @property\n    def total_dist(self):\n        return self.total_dist\n    \n    @total_dist.setter\n    def total_dist(self, total):\n        self.total_dist = total\n        '''\n    def __str__(self):\n        return str(self.total_dist)\n            \n\nclass Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        print('hello')\n        nodes = []\n        for i in range(N):\n            nodes.append(Node(i))\n            \n        for i, j in edges:\n            nodes[i].add_edge(nodes[j])\n            nodes[j].add_edge(nodes[i])\n        \n        self.pre(nodes[0], set())\n        self.post(nodes[0], set(), N)\n        \n        return [str(i) for i in nodes]\n    \n    def pre(self, root, seen):\n        seen.add(root)\n        \n        root.num_children = 1\n        for i in root.edges:\n            if i in seen:\n                continue\n            children, dist = self.pre(i, seen)\n            root.num_children += children\n            root.total_dist += children + dist\n        \n        return root.num_children, root.total_dist\n        \n    def post(self, root, seen, N, parent = None):\n        seen.add(root)\n        \n        if parent != None:\n            root.total_dist = parent.total_dist - root.num_children + N - root.num_children\n        \n        for i in root.edges:\n            if i in seen:\n                continue\n            self.post(i, seen, N, root)\n            \n            \n        \n        \n        \n        \n            \n            \n\n    \n        \n        \n        \n        \n        \n        \n        \n            \n        \n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        \n        memo=collections.defaultdict(set)\n        \n        for i,j in edges:\n            memo[i].add(j)\n            memo[j].add(i)\n            \n        \n        res=[0]*N\n        nodes=[1]*N\n        \n        def t(root,pre):\n            for i in memo[root]:\n                if i!=pre:\n                    t(i,root)\n                    nodes[root]+=nodes[i]\n                    res[root]+=res[i]+nodes[i]\n        \n        def t1(root,pre):\n            for i in memo[root]:\n                if i!=pre:                    \n                    res[i]=res[root]-2*nodes[i]+N\n                    t1(i,root)\n                    \n                    \n        t(0,-1)\n        t1(0,-1)\n        \n        return res", "from collections import defaultdict\n\n\nclass Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        g = Graph()\n        for u, v in edges:\n            g.connect(u, v)\n            g.connect(v, u)\n            \n        t = g.tree(0)\n        \n        children = [0] * N\n        dists = [0] * N\n        \n        discovered = set()\n        stack = [0]\n        while stack:\n            u = stack.pop()\n            if u not in discovered:\n                discovered.add(u)\n                stack.append(u)\n                \n                for v in t.adj[u]:\n                    stack.append(v)\n            \n            else:\n                discovered.remove(u)\n                children[u] = sum(1 + children[v] for v in t.adj[u])\n                dists[u] = children[u] + sum(dists[v] for v in t.adj[u])\n                \n        stack = [0]\n        while stack:\n            u = stack.pop()\n            for v in t.adj[u]:\n                dists[v] = dists[u] - children[v] - 1 + N - children[v] - 1\n                stack.append(v)\n                \n        return dists\n    \n\nclass Graph:\n    def __init__(self):\n        self.adj = defaultdict(set)\n        \n    def connect(self, u, v):\n        self.adj[u].add(v)\n        \n    def tree(self, start):\n        t = Graph()\n        stack = [start]\n        while stack:\n            u = stack.pop()\n            for v in self.adj[u]:\n                if v not in t.adj:\n                    stack.append(v)\n                    t.connect(u, v)\n\n        return t", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        \n        edge_value = collections.defaultdict()\n        \n        graph = collections.defaultdict(list)\n        \n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n            \n        \n        def dfs1(u, parent):\n            \n            distance = 0\n            vertex_num = 1\n            \n            for v in graph[u]:\n                if v != parent:\n                    temp_dis, temp_ver = dfs1(v, u)\n                    distance += temp_dis\n                    vertex_num += temp_ver\n                    \n            if parent != -1:\n                edge_value[(parent, u)] = (distance + vertex_num, vertex_num)\n                \n            return (distance + vertex_num, vertex_num)\n        \n        \n        ans = [0] * N\n        \n        def dfs2(u, parent):\n            \n            nonlocal N\n            \n            total_dis = 0\n            \n            for v in graph[u]:\n                temp_dis, temp_ver = edge_value[(u, v)]\n                total_dis += temp_dis\n\n                \n            ans[u] = total_dis\n            \n            for v in graph[u]:\n                if v != parent:\n                    \n                    temp_dis, temp_ver = edge_value[(u, v)]\n                    \n                    new_dis = total_dis - temp_dis + (N - temp_ver)\n                    \n                    edge_value[(v, u)] = (new_dis, N - temp_ver)\n                    \n                    dfs2(v, u)\n                    \n                    \n        dfs1(0, -1)\n        dfs2(0, -1)\n        \n        return ans\n            \n                \n            \n            \n            \n        \n        \n", "class Node():\n    def __init__(self,val):\n        self.val=val\n        self.children=[]\n    \n    def add_edge(self,child):\n        self.children.append(child)\n        child.parent=self\n    \n    def count(self):\n        res_num=0\n        res_val=0\n        for c in self.children:\n            temp_num,temp_val=c.count()\n            res_num+=temp_num\n            res_val+=temp_val\n        self.res_num=res_num\n        self.res_val=res_val\n        return res_num+1,res_val+(res_num+1)\n    \n    def dist(self,res,p_num,p_val):\n        res[self.val]=p_val+self.res_val\n        for c in self.children:\n            c.dist(res,p_num+self.res_num-c.res_num,(p_val+self.res_val-c.res_val-c.res_num-1)+(p_num+self.res_num-c.res_num))\n        \n    \n    \nclass STree():\n    def __init__(self,n,edges):\n        self.nodes=[Node(i) for i in range(n)]\n        self.res=[0 for i in range(n)]\n        edges_dic=collections.defaultdict(list)\n        for i in range(len(edges)):\n            edges_dic[edges[i][0]].append(edges[i][1])\n            edges_dic[edges[i][1]].append(edges[i][0])\n        queue=[0]\n        visited=[0 for i in range(n)]\n        visited[0]=1\n        while(queue):\n            current=queue.pop(0)\n            for c in edges_dic[current]:\n                if visited[c]==0:\n                    visited[c]=1\n                    self.nodes[current].add_edge(self.nodes[c])\n                    queue.append(c)\n    \n    def count(self):\n        self.nodes[0].count()\n    \n    def dist(self):\n        self.nodes[0].dist(self.res,0,0)\n        return self.res\n    \n    \n\nclass Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        t=STree(N,edges)\n        t.count()\n        return t.dist()\n        \n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        # build graph as adj_list\n        adj_list = defaultdict(list)\n        for v1, v2 in edges:\n            adj_list[v1].append(v2)\n            adj_list[v2].append(v1)\n        root = 0\n\n        subT_size = [0]*N\n        def postorder(t, par_t)->int:\n            ans = 0\n            for c in adj_list[t] :\n                if c == par_t: continue\n                ans += postorder(c, t) + subT_size[c]\n                subT_size[t] += subT_size[c]\n            subT_size[t] += 1\n            return ans\n\n        res = [0]*N\n        def preorder(t, par_t):\n            for c in adj_list[t]:\n                if c == par_t: continue\n                res[c] = res[t] - subT_size[c] * 2 + tot\n                preorder(c, t)\n\n        # main  \n        res[root] = postorder(root, -1)\n        tot = subT_size[root]\n        preorder(root, -1)\n\n        return res", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        connected = collections.defaultdict(lambda:[])\n        for s, e in edges :\n            connected[s].append(e)\n            connected[e].append(s)\n        \n        @functools.lru_cache(None)\n        def get_to_father(node=0, father=None) :\n            sons = sorted([t for t in connected[node] if not t == father])\n            \n            to_ft_node = 0\n            to_ft_sum = 0\n            for son in sons :\n                node_nt, sum_nt = get_to_father(son, node)\n                to_ft_node += node_nt\n                to_ft_sum += sum_nt\n            to_ft_sum  += to_ft_node\n            to_ft_node += 1\n            return to_ft_node, to_ft_sum\n\n        to_ret = [0]*N\n        def visit(node=min(12, N-1), father=None, to_son_n=0, to_son_sum=0) :\n            sons = sorted([t for t in connected[node] if not t == father])\n\n            ns_list = [get_to_father(t, node) for t in sons]\n            all_node = sum([t[0] for t in ns_list])\n            all_sum  = sum([t[1] for t in ns_list])\n            to_ret[node] = all_sum + all_node + to_son_sum + to_son_n\n            for son, (snode, ssum) in zip(sons, ns_list) :\n                visit(son, node, to_son_n+all_node-snode+1, to_ret[node]-ssum-snode)\n        visit()\n        return to_ret\n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        start = -1\n        for node in graph:\n            if len(graph[node]) == 1:\n                start = node\n        \n        def getStartingDist(node, parent = None, d = 0):\n            return d + sum(getStartingDist(child, node, d + 1) for child in graph[node] \n                               if child != parent)    \n        dist = getStartingDist(start)\n        \n        remainingCt = {}\n        def getCtRemaining(node, parent):\n            remainingCt[node] = 1 + sum(getCtRemaining(child, node) for child in graph[node]\n                                       if child != parent)\n            return remainingCt[node]\n        getCtRemaining(start, None)\n        \n        result = [None] * N\n        result[start] = dist\n        \n        def dfs(node, parent, running, nodesUp):\n            result[node] = running\n            for child in graph[node]:\n                if child != parent:\n                    newNodesUp = nodesUp + remainingCt[node] - remainingCt[child]\n                    newDistSum = running - (remainingCt[child] - 1) + (newNodesUp - 1)\n                    dfs(child, node, newDistSum, newNodesUp)\n            \n        dfs(start, None, dist, 0)\n        return result", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        connected = collections.defaultdict(lambda:[])\n        for s, e in edges :\n            connected[s].append(e)\n            connected[e].append(s)\n        \n        @functools.lru_cache(None)\n        def get_to_father(node=0, father=None) :\n            sons = sorted([t for t in connected[node] if not t == father])\n            \n            to_ft_node = 0\n            to_ft_sum = 0\n            for son in sons :\n                node_nt, sum_nt = get_to_father(son, node)\n                to_ft_node += node_nt\n                to_ft_sum += sum_nt\n            to_ft_sum  += to_ft_node\n            to_ft_node += 1\n            return to_ft_node, to_ft_sum\n\n        to_ret = [0]*N\n        def visit(node=N-1, father=None, to_son_n=0, to_son_sum=0) :\n            sons = sorted([t for t in connected[node] if not t == father])\n\n            ns_list = [get_to_father(t, node) for t in sons]\n            all_node = sum([t[0] for t in ns_list])\n            all_sum  = sum([t[1] for t in ns_list])\n            to_ret[node] = all_sum + all_node + to_son_sum + to_son_n\n            for son, (snode, ssum) in zip(sons, ns_list) :\n                visit(son, node, to_son_n+all_node-snode+1, to_ret[node]-ssum-snode)\n        visit()\n        return to_ret\n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        adjList = {i: [] for i in range(N)}\n        for i,j in edges:\n            adjList[i].append(j)\n            adjList[j].append(i)            \n        \n        root = 0\n\n        subtree_sum_count = {i: (0,0) for i in range(N)}\n        visited = set()\n        def subtree(vertex: int, parent = None):\n            if len(adjList[vertex]) == 1 and adjList[vertex][0] == parent:\n                subtree_sum_count[vertex] = 0, 0\n            elif vertex not in visited:\n                subtrees = [subtree(child, vertex) for child in adjList[vertex] if child != parent]\n                subtree_sum_count[vertex] = sum(tree[0] + tree[1] + 1 for tree in subtrees), sum(tree[1] + 1 for tree in subtrees)\n                visited.add(vertex)\n                \n            return subtree_sum_count[vertex]\n        \n        subtree(root)\n                \n        distances = [0] * N\n        distances[root] = subtree_sum_count[root][0]\n        \n        queue = collections.deque([(root, child) for child in adjList[root]])\n        \n        while len(queue) > 0:\n            parent_node, vertex = queue.popleft()\n            queue.extend([(vertex, child) for child in adjList[vertex] if child != parent_node])\n            if vertex == root:\n                continue\n            p_node = distances[parent_node], subtree_sum_count[parent_node][1]\n            temp = p_node[0] - subtree_sum_count[vertex][0] - subtree_sum_count[vertex][1] - 1, \\\\\n                   N - subtree_sum_count[vertex][1] - 1\n            \n            distances[vertex] = subtree_sum_count[vertex][0] + sum(temp)\n            \n        return distances", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        tree = collections.defaultdict(set)\n        \n        for x, y in edges:\n            tree[x].add(y)\n            tree[y].add(x)\n            \n        cnt = [1]*N\n        dis = [0]*N\n        \n        def predfs(root, pre):\n            for k in tree[root]:\n                if k != pre:\n                    predfs(k, root)\n                    cnt[root] += cnt[k]\n                    dis[root] += dis[k]+cnt[k]\n        \n        def postdfs(root, pre):\n            for k in tree[root]:\n                if k != pre:\n                    dis[k] = dis[root]-2*cnt[k]+N\n                    postdfs(k, root)\n                    \n        predfs(0, -1)\n        postdfs(0, -1)\n        \n        return dis\n", "class Solution(object):\n    def sumOfDistancesInTree(self, N, edges):\n        graph = collections.defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n\n        count = [1] * N\n        ans = [0] * N\n        def dfs(node = 0, parent = None):\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n                    count[node] += count[child]\n                    \n                    ans[node] += ans[child] + count[child]\n       \n        def dfs2(node = 0, parent = None):\n            for child in graph[node]:\n                if child != parent:\n                    \n                    ans[child] = ans[node] - count[child] + N - count[child]\n                  \n                    dfs2(child, node)\n        dfs()\n      \n        dfs2()\n        return ans", "from collections import deque\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.size = 0\n        self.dist = 0\n        self.children = []\n        self.parent = None\n\nclass Solution:\n    def dfsPostorder(self, root):\n        if root is None:\n            return\n        for c in root.children:\n            self.dfsPostorder(c)\n        size = 0\n        dist = 0\n        for c in root.children:\n            size += c.size\n            dist += c.dist\n        root.size = size + 1\n        root.dist = size + dist\n\n    def dfsPreorder(self, root):\n        if root is None:\n            return\n        if root.parent is not None:\n            root.dist = root.parent.dist - 2*root.size + root.parent.size\n            root.size = root.parent.size\n        for c in root.children:\n            self.dfsPreorder(c)\n    \n    def buildTree(self, graph, root, nodes):\n        queue = deque()\n        queue.append((root, None))\n        while len(queue) > 0:\n            cur, par = queue.pop()\n            node = nodes[cur]\n            for n in graph[cur]:\n                if n != par:\n                    node.children.append(nodes[n])\n                    nodes[n].parent = node\n                    queue.append((n, cur))\n    \n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        nodes = {i: Node(i) for i in range(N)}\n\n        graph = {i: [] for i in range(N)}\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n    \n        root = 0\n        self.buildTree(graph, root, nodes)   \n        root = nodes[root]\n        \n        self.dfsPostorder(root)\n        self.dfsPreorder(root)\n        ans = []\n        for i in range(N):\n            ans.append(nodes[i].dist)\n        return ans", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        \\\"\\\"\\\"\n        Find the sum of distances between each node and all the other nodes\n        \\\"\\\"\\\"\n        \n        # Edge case 1: There are no nodes given\n        if N <= 1:\n            return [0]\n            \n        # Edge case 2: There are no edges given\n        if not edges:\n            return [0]\n        \n        \n        # Build adjacency list\n        graph = collections.defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n\n        # Initialize count - count[i] counts all nodes in the subtree i\n        count = [1] * N\n        \n        # Initial ans, ans[i] counts sum of distance in subtree i\n        res = [0] * N\n        \n        \n        # Post order dfs traversal, update count and ans\n        def dfs(root, pre):\n            for i in graph[root]:\n                if i != pre:\n                    dfs(i, root)\n                    count[root] += count[i]\n                    res[root] += res[i] + count[i]\n     \n    \n        # Preorder dfs traversal, update ans\n        def dfs2(root, pre):\n            for i in graph[root]:\n                if i != pre:\n                    res[i] = res[root] - count[i] + N - count[i]\n                    dfs2(i, root)\n        dfs(0, -1)\n        dfs2(0, -1)\n        return res\n        \n        # Method 1: Dynamic programming\n        \n        \n#         # Method 2: Brute force method - O(N^2)\n#         # For each node, use BFS \n#         for node in range(N):\n#             # print(node)\n#             visited = set()\n#             queue = [node]\n#             num = 0\n#             depth = 0\n            \n#             while queue:\n#                 length = len(queue)\n                \n#                 # Add elements to queue at each depth\n#                 for i in range(length):\n#                     vertex = queue.pop(0)\n                    \n#                     if vertex not in visited:\n#                         visited.add(vertex)\n#                         queue.extend(adj_list[vertex]-visited)  \n                \n#                 num += length * depth \n#                 depth += 1\n            \n#             ans.append(num)\n        \n        return ans\n    \n    \n    def get_adjacency_list(self, edges) -> dict:\n        \\\"\\\"\\\"\n        Build adjacency list of undirected tree (graph)\n        \\\"\\\"\\\"\n        graph = collections.defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        \n#         adj_list = {}\n        \n#         for edge in edges:\n#             node1 = edge[0]\n#             node2 = edge[1]\n#             # print(node1, node2)\n            \n#             if node1 not in adj_list:\n#                 adj_list[node1] = set([node2])\n#             else:\n#                 adj_list[node1].add(node2)\n                \n#             if node2 not in adj_list:\n#                 adj_list[node2] = set([node1])\n#             else:\n#                 adj_list[node2].add(node1)\n                \n#         return adj_list", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        edges_dict = dict()\n        for i in range(N):\n            edges_dict[i] = []\n        for edge in edges:\n            edges_dict[edge[0]].append(edge[1])\n            edges_dict[edge[1]].append(edge[0])\n        dp_dict = dict()\n        def dp(node, src):\n            if (node, src) in dp_dict:\n                return dp_dict[(node, src)]\n            tgt_num = 1\n            tgt_sum = 0\n            for tgt in edges_dict[node]:\n                if tgt == src:\n                    continue\n                else:\n                    temp = dp(tgt, node)\n                    tgt_num += temp[0]\n                    tgt_sum += temp[0] + temp[1]\n            dp_dict[(node, src)] = (tgt_num, tgt_sum)\n            return dp_dict[(node, src)]\n        results = [0]*N\n        for node in range(N):\n            for tgt in edges_dict[node]:\n                results[node] += sum(dp(tgt, node))\n        # print(dp_dict)\n        return results", "import collections as clc\nimport typing as t\n\n\nclass Solution:\n    \n    def preorder(self, node: int, parent: t.Optional[int] = None) -> None:\n        total_count = 0\n        for child in self.graph[node]:\n            if child == parent:\n                continue\n            count = self.preorder(child, node)\n            self.distance[node] += count + self.distance[child]\n            total_count += count\n        self.subtree_count[node] = total_count + 1\n        return total_count + 1\n    \n    def postorder(self, node: int, parent: t.Optional[int] = None) -> None:\n        if parent is not None:\n            self.distance[node] += self.distance[parent] - self.distance[node] - 2 * self.subtree_count[node] + self.n\n        for child in self.graph[node]:\n            if child == parent:\n                continue\n            self.postorder(child, node)\n    \n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        self.n = N\n        self.distance = [0] * N\n        self.subtree_count = [0] * N\n        self.graph = clc.defaultdict(list)\n        for a, b in edges:\n            self.graph[a].append(b)\n            self.graph[b].append(a)\n        self.preorder(0)\n        self.postorder(0)\n        return self.distance", "from collections import defaultdict\n\nclass Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        graph = defaultdict(set)\n        for e in edges:\n            f, t = e[0], e[1]\n            graph[f].add(t)\n            graph[t].add(f)\n        dis = [0 for x in range(N)]\n        cnt = [1 for x in range(N)]\n        self.getRootDis(0, None, dis, cnt, graph)\n        self.updateNei(0, None, dis, cnt, graph, N)\n        return dis\n        \n        \n    def getRootDis(self, curr, parent, dis, cnt, graph):\n        rdis, rcnt = 0, 1\n        for nei in graph[curr]:\n            if nei == parent:\n                continue\n            self.getRootDis(nei, curr, dis, cnt, graph)\n            rdis += dis[nei] + cnt[nei]\n            rcnt += cnt[nei]\n        dis[curr], cnt[curr] = rdis, rcnt\n        \n    def updateNei(self, curr, parent, dis, cnt, graph, N):\n        for nei in graph[curr]:\n            if nei == parent:\n                continue\n            dis[nei] = dis[curr] + N - 2 * cnt[nei]\n            self.updateNei(nei, curr, dis, cnt, graph, N)", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        # count the number of childrens\n        # compute the distance from other nodes to 0\n        def dfs(node, parent):\n            for child in graph[node]:\n                if child!=parent:\n                    dfs(child, node)\n                    count_self_and_children[node] += count_self_and_children[child]\n                    res[node] += res[child]+count_self_and_children[child]\n                    \n        # compute the res of all nodes except 0\n        def dfs2(node, parent):\n            for child in graph[node]:\n                if child!=parent:\n                    res[child] = res[node]+N-2*count_self_and_children[child]\n                    dfs2(child, node)\n                    \n            \n        graph = collections.defaultdict(list)\n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n            \n        count_self_and_children = [1]*N\n        # res[x] = x@X+y@Y+#(Y)\n        # res[y] = y@Y+x@X+#(X)\n        # res[y]-res[x] = #(X)-#(Y)\n        # res[y] = res[x]+#(X)-#(Y)\n        # #(X) = N-#(Y)\n        # res[y] = res[x]+(N-#(Y))-#(Y)\n        # res[y] = res[x]+N-2#(Y)\n        res = [0]*N\n        dfs(0, None)\n        dfs2(0, None)\n        \n        return res\n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        if N == 1:\n            return [0]\n        adj = [[] for _ in range(N)]\n        for [u,v] in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        d_dists = {}\n        d_vertices_up_to_u = {} # better name would be d_vertices_up_to_tail instead\n        sol = [0 for _ in range(N)]\n        \n        def dfs_dist(u,v,adj, d_dists, d_vertices_up_to_u):\n            if (u,v) in d_dists:\n                return d_dists[(u,v)], d_vertices_up_to_u[(u,v)]\n            l_neibs = adj[u][:]\n            l_neibs.remove(v)\n            if len(l_neibs) == 0:\n                d_dists[(u,v)] = 1\n                d_vertices_up_to_u[(u,v)] = 1\n                return d_dists[(u,v)], d_vertices_up_to_u[(u,v)]\n            dist_u_v = 0\n            vertices_up_to_u = 1 #going into (u,v)\n            for nei in l_neibs:\n                a,b = dfs_dist(nei,u,adj, d_dists, d_vertices_up_to_u)\n                dist_u_v += a\n                vertices_up_to_u += b\n            dist_u_v += vertices_up_to_u\n            d_dists[(u,v)] = dist_u_v\n            d_vertices_up_to_u[(u,v)] = vertices_up_to_u\n            return d_dists[(u,v)], d_vertices_up_to_u[(u,v)]\n            \n        for v in range(N):\n            for u in adj[v]:\n                a, _ = dfs_dist(u,v,adj, d_dists, d_vertices_up_to_u)\n                sol[v] += a\n        \n        return sol", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        graph = [[] for _ in range(N)]\n        \n        for i, j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n        \n        size, up, down = [1] * N, [0] * N, [0] * N\n        # up[i] is the distance from i's descendant to i\n        # down[i] is the distance from others nodes to i\n        # size[i] is the number of nodes in branch rooted by i (including i itself)\n        \n        def post(parent, i): \n            for kid in graph[i]:\n                if kid != parent:\n                    post(i, kid)\n                    # add up the numbers of descendent of i's kids\n                    size[i] += size[kid]         \n                    # every descendent of i needs one extra edge to reach i, i.e. the edge (kid,i)\n                    up[i] += up[kid] + size[kid] \n                    \n        def pre(parent, i):\n            if parent!=-1:\n                # every non-descendent node needs one extra edge to reach i, i.e. the edge (parent,i)\n                down[i] = down[parent] + (up[parent] - up[i] - size[i]) + (N-size[i])\n                #         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^\n                #         from all non-descendent nodes to i's parent      the one extra edge (parent,i)\n            for kid in graph[i]:     \n                if kid != parent:\n                    pre(i, kid)\n                    \n        post(-1, 0)            \n        pre(-1, 0)            \n        return [up[i]+down[i] for i in range(N)] ", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        #how do the distances from 1 compare to those from 0?\n        #parent, child distances??\n        if N == 1:\n            return [0]\n        #start with distances from the root\n        \n        #build neighbors\n        neighbors = {}\n        for edge in edges:\n            a = edge[0]\n            b = edge[1]\n            if a not in neighbors:\n                neighbors[a] = []\n            if b not in neighbors:\n                neighbors[b] = []\n            neighbors[a].append(b)\n            neighbors[b].append(a)\n            \n            \n        num_descendents = {}\n        children = {}\n        parent = {0: None}\n        \n        queue = [0]\n        while queue != []:\n            curr = queue.pop()\n            children[curr] = []\n            for neighbor in neighbors[curr]:\n                if neighbor == parent[curr]:\n                    continue\n                child = neighbor\n                children[curr].append(child)\n                queue.append(child)\n                parent[child] = curr\n                            \n        # def build_children(n, p):\n        #     parent[n] = p\n        #     children[n] = []\n        #     for neighbor in neighbors[n]:\n        #         if neighbor == p:\n        #             continue\n        #         children[n].append(neighbor)\n        #         build_children(neighbor, n)\n        #     return\n        # build_children(0, None)\n        \n        def build_descendents(n):\n            num_descendents[n] = 0\n            for child in children[n]:\n                num_descendents[n] += 1 + build_descendents(child)\n            return num_descendents[n]\n        \n        build_descendents(0)\n        \n        #bfs iteration to get root dist of each node\n        root_dist = {0: 0}\n        queue = children[0].copy()\n        while queue != []:\n            curr = queue.pop()\n            \n            p = parent[curr]\n            root_dist[curr] = root_dist[p] + 1\n            for child in children[curr]:\n                queue.append(child)\n        \n        \n        #figure out root_sum_dist\n        root_sum_dist = 0\n        for n in range(N):\n            root_sum_dist += root_dist[n]\n        \n        queue = children[0].copy()\n        sum_dist = {0: root_sum_dist}\n        while queue != []:\n            curr = queue.pop()\n            \n            #set sum_dist[curr]\n            p = parent[curr]\n            desc_curr = num_descendents[curr]\n            other_kids_and_desc = num_descendents[p] - 1 - desc_curr\n            above_parent = num_descendents[0] - num_descendents[p]\n            sum_dist[curr] = sum_dist[p]  - desc_curr + other_kids_and_desc + above_parent\n                        \n            for child in children[curr]:\n                queue.append(child)\n        \n        ans = []\n        for n in range(N):\n            ans.append(sum_dist[n])\n        return ans\n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        \n        graph = [set() for _ in range(N)]\n        for edge in edges:\n            graph[edge[0]].add(edge[1])\n            graph[edge[1]].add(edge[0])\n            \n        # count[i]: number of nodes (including i) in the sub-tree started from i (not including visited part)\n        count = [1] * N\n        ans = [0] * N\n        def dfs(node, parent):\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n                    count[node] += count[child]\n                    ans[node] += ans[child] + count[child]\n                  \n        def dfs2(node, parent):\n            for child in graph[node]:\n                if child != parent:\n                    # ans[node] - count[child] = ans[child] + (ans[node] - (ans[child] + count[child]))\n                    # ans[child]: result of subtree started from child, x@X\n                    # ans[node] - (ans[child] + count[child]): result exclude subtree started from child, y@Y\n                    # N - count[child]: number of nodes not in sub-tree started from child, #Y\n                    \n                    # ans[child] is determined by ans[node] (which has the correct value) and count\n                    ans[child] = ans[node] - count[child] + N - count[child]\n                    dfs2(child, node)\n        \n        # after dfs, only ans[0] has final answer, all other ans[i] is not used anymore\n        dfs(0, None)\n        \n        dfs2(0, None)\n        \n        return ans", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n\n        adj = [[] for i in range(N)]\n        for i, j in edges:\n            adj[i].append(j)\n            adj[j].append(i)\n\n        cache = {}\n\n        def dfs(i, exclude=-1):\n            total = 0\n            nodes_below_i = 0\n\n            for j in adj[i]:\n                if j != exclude:\n                    try:\n                        s, nodes_below_j = cache[j, i]\n                    except KeyError:\n                        s, nodes_below_j = dfs(j, i)\n\n                    # 1 - to walk to node j\n                    # nodes_below_j - for number of walks from i to j to reach all nodes below\n                    # s - sum of all paths from j to all nodes below j\n                    nodes_below_i += 1 + nodes_below_j\n                    total += 1 + nodes_below_j + s\n\n            cache[i, exclude] = total, nodes_below_i\n            return total, nodes_below_i\n\n        return [dfs(i)[0] for i in range(N)]\n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        ans = [0] * N\n        graph = defaultdict(set) \n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        \n        visited = {}\n        return [self.dfs(graph, i, -1, visited)[0] for i in range(N)]\n    \n    def dfs(self, graph, node, parent, visited):\n        if (node, parent) in visited:\n            return visited[node, parent]\n        distance, count = 0, 1\n        for child in graph[node]:\n            if child != parent:\n                d, c = self.dfs(graph, child, node, visited)\n                distance += d + c\n                count += c\n        visited[node, parent]  = (distance, count)\n        return distance, count", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        \n        graph = [[] for _ in range(N)]\n        \n        for i, j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n        \n        \\\"\\\"\\\" \n        O(n^2) TLE.......\n        res = [0] * N\n        def dfs(idx, cur, parent, cnt):\n            for kid in graph[cur]:\n                if kid != parent:\n                    res[idx] += cnt\n                    dfs(idx, kid, cur, cnt+1)\n        \n        for _ in range(N):\n            dfs(_, _, -1, 1)\n        return res\n        \\\"\\\"\\\"\n        \n        # print (graph)\n        cnt, res = [1] * N, [0] * N\n        # res[i] is the distance \n        # cnt[i] is the number of nodes in branch rooted by i (including i itself)\n        \n        def post(parent, i): \n            for kid in graph[i]:\n                if kid != parent:\n                    post(i, kid)\n                    # add up the numbers of descendent of i's kids\n                    cnt[i] += cnt[kid]         \n                    # every descendent of i needs one extra edge to reach i, i.e. the edge (kid,i)\n                    res[i] += res[kid] + cnt[kid] \n                    \n        def pre(parent, i):\n            for kid in graph[i]:     \n                if kid != parent:\n                    res[kid] = res[i] - cnt[kid] + N - cnt[kid]\n                    pre(i, kid)\n                    \n        post(-1, 0)  \n        pre(-1, 0)   \n        return res", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        \\\"\\\"\\\"\n        Find the sum of distances between each node and all the other nodes\n        \\\"\\\"\\\"\n        \n        # Edge case 1: There are no nodes given\n        if N <= 1:\n            return [0]\n            \n        # Edge case 2: There are no edges given\n        if not edges:\n            return [0]\n        \n        \n        # Build adjacency list\n        graph = collections.defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n\n        \n        count = [1] * N\n        ans = [0] * N\n        \n        def dfs(node = 0, parent = None):\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n                    count[node] += count[child]\n                    ans[node] += ans[child] + count[child]\n            \n        def dfs2(node = 0, parent = None):\n            for child in graph[node]:\n                if child != parent:\n                    ans[child] = ans[node] - count[child] + N - count[child]\n                    dfs2(child, node)\n\n        dfs()\n        dfs2()\n        return ans\n        \n        # Method 1: \n        \n        \n#         # Method 2: Brute force method - O(N^2)\n#         # For each node, use BFS \n#         for node in range(N):\n#             # print(node)\n#             visited = set()\n#             queue = [node]\n#             num = 0\n#             depth = 0\n            \n#             while queue:\n#                 length = len(queue)\n                \n#                 # Add elements to queue at each depth\n#                 for i in range(length):\n#                     vertex = queue.pop(0)\n                    \n#                     if vertex not in visited:\n#                         visited.add(vertex)\n#                         queue.extend(adj_list[vertex]-visited)  \n                \n#                 num += length * depth \n#                 depth += 1\n            \n#             ans.append(num)\n        \n        return ans\n    \n    \n    def get_adjacency_list(self, edges) -> dict:\n        \\\"\\\"\\\"\n        Build adjacency list of undirected tree (graph)\n        \\\"\\\"\\\"\n        graph = collections.defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        \n#         adj_list = {}\n        \n#         for edge in edges:\n#             node1 = edge[0]\n#             node2 = edge[1]\n#             # print(node1, node2)\n            \n#             if node1 not in adj_list:\n#                 adj_list[node1] = set([node2])\n#             else:\n#                 adj_list[node1].add(node2)\n                \n#             if node2 not in adj_list:\n#                 adj_list[node2] = set([node1])\n#             else:\n#                 adj_list[node2].add(node1)\n                \n#         return adj_list", "class Solution:\n    def __init__(self):\n        self.children = []\n        self.pathSums = []\n    \n    def buildGraph(self, edges):\n        graph = dict()\n        for edge in edges:\n            n1 = edge[0]\n            n2 = edge[1]\n            if n1 not in graph:\n                graph[n1] = set([ n2 ])\n            else:\n                graph[n1].add(n2)\n            \n            if n2 not in graph:\n                graph[n2] = set( [ n1 ] )\n            else:\n                graph[n2].add(n1)\n        return graph\n    \n    def postOrder(self, graph, v, parent):\n        for child in graph[v]:\n            if child != parent:\n                self.postOrder(graph, child, v)\n                self.children[v] += self.children[child]\n                self.pathSums[v] += (self.children[child] + self.pathSums[child])     \n        \n    def preOrder(self, graph, v, parent):\n        for child in graph[v]:\n            if child != parent:\n                self.pathSums[child] = self.pathSums[v] + (len(graph) - self.children[child]) - self.children[child]\n                self.preOrder(graph, child, v)\n    \n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        if N == 0:\n            return []\n        elif N == 1:\n            return [ 0 ]\n        \n        graph = self.buildGraph(edges)\n        self.children = [ 1 for node in graph ]\n        self.pathSums = [ 0 for node in graph ]\n        self.postOrder(graph, 0, -1)\n        self.preOrder(graph, 0, -1)\n        return self.pathSums", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        if N == 1:\n            return [0]\n        graph_dict = {}\n        for pair in edges:\n            left,right = pair[0],pair[1]\n            graph_dict[left] = [right] + graph_dict.get(left,[])\n            graph_dict[right] = [left] + graph_dict.get(right,[])\n        memo_dict = {}\n        ans = []\n        for i in range (N):\n            ans += [self.helper(i,None,graph_dict,memo_dict)[0]]\n        return ans\n            \n    def helper(self,node,parent,graph_dict,memo_dict):\n        if (graph_dict[node] == [parent]):\n            return (0,1) #depth,num_nodes\n        elif (node,parent) in memo_dict:\n            return memo_dict[(node,parent)]\n        else:\n            found_sum = 0\n            num_nodes = 1\n            for neighbor in graph_dict[node]:\n                if neighbor != parent:\n                    (curr_sum,curr_nodes) = self.helper(neighbor,node,graph_dict,memo_dict)\n                 #   print((node,parent,curr_sum,curr_nodes))\n                    found_sum = (1 * curr_nodes) + curr_sum + found_sum\n                    num_nodes += curr_nodes\n            memo_dict[(node,parent)] = (found_sum,num_nodes)\n            return (found_sum,num_nodes)\n        \n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        #how do the distances from 1 compare to those from 0?\n        #parent, child distances??\n        if N == 1:\n            return [0]\n        #start with distances from the root\n        \n        #build neighbors\n        neighbors = {}\n        for edge in edges:\n            a = edge[0]\n            b = edge[1]\n            if a not in neighbors:\n                neighbors[a] = []\n            if b not in neighbors:\n                neighbors[b] = []\n            neighbors[a].append(b)\n            neighbors[b].append(a)\n            \n            \n        num_descendents = {}\n        children = {}\n        parent = {}\n        \n        def build_children(n, p):\n            parent[n] = p\n            children[n] = []\n            for neighbor in neighbors[n]:\n                if neighbor == p:\n                    continue\n                children[n].append(neighbor)\n                build_children(neighbor, n)\n            return\n        build_children(0, None)\n        \n        def build_descendents(n):\n            num_descendents[n] = 0\n            for child in children[n]:\n                num_descendents[n] += 1 + build_descendents(child)\n            return num_descendents[n]\n        \n        build_descendents(0)\n        \n        #bfs iteration to get root dist of each node\n        root_dist = {0: 0}\n        queue = children[0].copy()\n        while queue != []:\n            curr = queue.pop()\n            \n            p = parent[curr]\n            root_dist[curr] = root_dist[p] + 1\n            for child in children[curr]:\n                queue.append(child)\n        \n        \n        #figure out root_sum_dist\n        root_sum_dist = 0\n        for n in range(N):\n            root_sum_dist += root_dist[n]\n        \n        queue = children[0].copy()\n        sum_dist = {0: root_sum_dist}\n        while queue != []:\n            curr = queue.pop()\n            \n            #set sum_dist[curr]\n            p = parent[curr]\n            desc_curr = num_descendents[curr]\n            other_kids_and_desc = num_descendents[p] - 1 - desc_curr\n            above_parent = num_descendents[0] - num_descendents[p]\n            sum_dist[curr] = sum_dist[p]  - desc_curr + other_kids_and_desc + above_parent\n                        \n            for child in children[curr]:\n                queue.append(child)\n        \n        ans = []\n        for n in range(N):\n            ans.append(sum_dist[n])\n        return ans\n", "import queue as qu\n\nclass Answer:\n    def __init__(self,N):\n        self.countarray=[0]*N\n        self.ansarray=[0]*N\n        \n        \n    \nclass Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        if N == 1:\n            return [0]\n        o = Answer(N)\n        \n        graph = {}\n        for i in range(N):\n            graph[i] = []\n        for i in range(len(edges)):\n            graph.get(edges[i][0]).append(edges[i][1])\n            graph.get(edges[i][1]).append(edges[i][0])\n\n        # countgenerator   \n        self.count_generator(0, -1, o, graph)\n        \n        # BFS\n        self.bfs(N, graph, o) \n        # generating answer\n                    \n        self.generate_answer(0, -1, o, graph, N)\n        return o.ansarray\n\n    def generate_answer(self, node, parent, o, graph, N):\n        \n        if parent != -1:\n            o.ansarray[node] = o.ansarray[parent] - o.countarray[node] + (N - o.countarray[node])\n\n        for neighbor in graph.get(node):\n            if  neighbor == parent:\n                continue\n            self.generate_answer(neighbor, node, o, graph, N)\n    \n    def bfs(self, N, graph, o):\n        visited = [False] * N\n        q = qu.Queue()\n        q.put([0, 0])\n        while(q.qsize()):\n            count = q.qsize()\n            while(count > 0):\n                rem = q.get()\n                if visited[rem[0]] == True:\n                    continue\n                else:\n                    visited[rem[0]] = True\n                count -= 1\n                o.ansarray[0] += rem[1]\n                for i in graph.get(rem[0]):\n                    if visited[i] == False:\n                        q.put([i, rem[1] + 1])\n    \n    def count_generator(self, node, parent, o, graph):\n        for neighbor in graph.get(node):\n            if neighbor == parent:\n                continue\n            self.count_generator(neighbor, node, o, graph)\n            o.countarray[node] += o.countarray[neighbor]\n        o.countarray[node] += 1", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        if N == 1:\n            return [0]\n        dt = {}\n        for e in edges:\n            if e[0] not in dt:\n                dt[e[0]] = []\n            dt[e[0]].append(e[1])\n            if e[1] not in dt:\n                dt[e[1]] = []\n            dt[e[1]].append(e[0])\n        sk = [0]\n        st = set()\n        self.tree = {}\n        while sk:\n            node = sk[-1]\n            sk.pop()\n            st.add(node)\n            self.tree[node] = {'d': 0, 'n': 0, 'c': []}\n            for i in dt[node]:\n                if i not in st:\n                    sk.append(i)\n                    self.tree[node]['c'].append(i)\n        self.dfs(0)\n        self.help(0, self.tree[0]['d'], self.tree[0]['n'])\n        ans = [0 for _ in range(N)]\n        for key in self.tree:\n            ans[key] = self.tree[key]['d']\n        return ans\n    \n    def dfs(self, key):\n        if not self.tree[key]:\n            return\n        dst, num = 0, 0\n        for ch in self.tree[key]['c']:\n            self.dfs(ch)\n            dst += self.tree[ch]['d'] + self.tree[ch]['n']\n            num += self.tree[ch]['n']\n        self.tree[key]['d'] = dst\n        self.tree[key]['n'] = num + 1\n    \n    def help(self, key, dst, num):\n        if num > self.tree[key]['n']:\n            self.tree[key]['d'] = dst + num - 2 * self.tree[key]['n']\n            self.tree[key]['n'] = num\n        for ch in self.tree[key]['c']:\n            self.help(ch, self.tree[key]['d'], self.tree[key]['n'])\n", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        ans = [0] * N\n        graph = defaultdict(set) \n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        \n        \n        counts = [1] * N\n        ans = [0] * N\n        self.dfs_root(graph, 0, 0, counts, ans)\n        self.dfs_child(graph, 0, 0, counts, ans, N)\n        visited = {}\n        return [self.dfs(graph, i, -1, visited)[0] for i in range(N)]\n    \n    def dfs(self, graph, node, parent, visited):\n        if (node, parent) in visited:\n            return visited[node, parent]\n        distance, count = 0, 1\n        for child in graph[node]:\n            if child != parent:\n                d, c = self.dfs(graph, child, node, visited)\n                distance += d + c\n                count += c\n        visited[node, parent]  = (distance, count)\n        return distance, count\n        \n        \n    def dfs_root(self, graph, root, parent, counts, ans):\n        for child in graph[root]:\n            if child != parent:\n                self.dfs_root(graph, child, root, counts, ans)\n                counts[root] += counts[child]\n                ans[root] += ans[child] + counts[child]\n            \n    def dfs_child(self, graph, root, parent, counts, ans, N):\n        for child in graph[root]:\n            if child != parent:\n                ans[child] = (N -  counts[child]) + ans[root] - counts[child]\n                self.dfs_child(graph, child, root, counts, ans, N) ", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        \n        graph = [[] for _ in range(N)]\n        \n        for i, j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n        \n        \\\"\\\"\\\" \n        O(n^2) TLE.......\n        res = [0] * N\n        def dfs(idx, cur, parent, cnt):\n            for kid in graph[cur]:\n                if kid != parent:\n                    res[idx] += cnt\n                    dfs(idx, kid, cur, cnt+1)\n        \n        for _ in range(N):\n            dfs(_, _, -1, 1)\n        return res\n        \\\"\\\"\\\"\n        \n        # print (graph)\n        cnt, res = [1] * N, [0] * N\n        # res[i] is the distance \n        # cnt[i] is the number of nodes in branch rooted by i (including i itself)\n        \n        def post(parent, cur): \n            for kid in graph[cur]:\n                if kid != parent:\n                    post(cur, kid)\n                    # add up the numbers of descendent of i's kids\n                    cnt[cur] += cnt[kid]         \n                    # every descendent of i needs one extra edge to reach i, i.e. the edge (kid,i)\n                    res[cur] += res[kid] + cnt[kid] \n                    \n        def pre(parent, cur):\n            for kid in graph[cur]:     \n                if kid != parent:\n                    res[kid] = res[cur] - cnt[kid] + N - cnt[kid]\n                    pre(cur, kid)\n                    \n        post(-1, 0)  \n        pre(-1, 0)   \n        return res", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        dic = defaultdict(list)\n        root = 0\n        for a,b in edges:\n            dic[a].append(b)\n            dic[b].append(a)\n        def dfs1(curr, lvl, par):\n            ret = lvl\n            for nxt in dic[curr]:\n                if nxt == par:\n                    continue\n                ret += dfs1(nxt, lvl+1, curr)\n            return ret\n        from_root = dfs1(root, 0, None)\n        sz = {}\n        def get_sz(curr, par):\n            ret = 1\n            for nxt in dic[curr]:\n                if nxt == par:\n                    continue\n                ret += get_sz(nxt, curr)\n            sz[curr] = ret\n            return ret\n        get_sz(root, None)\n        ret = [-1]*N\n        ret[root] = from_root\n        def go(curr, par):\n            my_dist = ret[par] - sz[curr]*2 + sz[root]\n            ret[curr] = my_dist\n            for nxt in dic[curr]:\n                if nxt == par:\n                    continue\n                go(nxt, curr)\n        for nxt in dic[root]:\n            go(nxt, root)\n        return ret", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        \n        connect = [set() for _ in range(N)]\n        num_children = [0] * N\n        dist = [0] * N\n        \n        for i,j in edges:\n            connect[i].add(j)\n            connect[j].add(i)\n        dist[0] = self.dfs1(0, connect, num_children, 0, set())\n        \n        self.dfs2(0, connect, num_children, dist, 0, N, set())\n        \n        return dist\n        \n        \n        \n    def dfs1(self, cur, connect, num_children, dist, seen):\n        seen.add(cur)\n        if not connect[cur]:\n            num_children[cur] = 1\n            return dist\n        \n        total_dist = 0\n        \n        for i in connect[cur]:\n            if i in seen:\n                continue\n                \n            total_dist += self.dfs1(i, connect, num_children, dist + 1, seen)\n            num_children[cur] += num_children[i]\n            \n        num_children[cur] += 1\n        \n        return total_dist + dist\n    \n    \n     \n    def dfs2(self, cur, connect, num_children, res, previous,N, seen):\n        seen.add(cur)\n        \n        if cur != 0:\n            res[cur] = res[previous] - num_children[cur] + N - num_children[cur]\n        for i in connect[cur]:\n            if i in seen:\n                continue\n            self.dfs2(i, connect, num_children, res, cur, N, seen)\n        \n        \n        \n        \n        \n        \n        \n            \n        \n", "class Solution(object):\n    def sumOfDistancesInTree(self, N, edges):\n        graph = collections.defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        count = [1] * N\n        ans = [0] * N\n        def dfs(node = 0, parent = None):\n            for child in graph[node]:\n                if child != parent:\n                    dfs(child, node)\n                    count[node] += count[child]\n                    ans[node] += ans[child] + count[child]\n\n        def dfs2(node = 0, parent = None):\n            for child in graph[node]:\n                if child != parent:\n                    ans[child] = ans[node] - count[child] + N - count[child]\n                    dfs2(child, node)\n\n        dfs()\n        dfs2()\n        return ans", "class Solution:\n    def sumOfDistancesInTree(self, N: int, edges: List[List[int]]) -> List[int]:\n        root = 0\n        \n        children = [[] for i in range(N)]\n        \n        for a, b in edges:\n            children[a].append(b)\n            children[b].append(a)\n        \n        sub_size = [0] * N\n        def compute_sub_size(node, parent):\n            sub_size[node] = 1\n            for child in children[node]:\n                if child != parent:\n                    compute_sub_size(child, node)\n                    sub_size[node] += sub_size[child]\n        \n        desc_dist = [0] * N\n        def compute_desc_dist(node, parent):\n            for child in children[node]:\n                if child != parent:\n                    compute_desc_dist(child, node)\n                    desc_dist[node] += desc_dist[child] + sub_size[child]\n        \n        all_dist = [0] * N\n        def compute_all_dist(node, parent):\n            if parent >= 0:\n                all_dist[node] = all_dist[parent] - (desc_dist[node] + sub_size[node])\n                all_dist[node] += sub_size[root] - sub_size[node]\n            \n            for child in children[node]:\n                if child != parent:\n                    all_dist[node] += desc_dist[child] + sub_size[child]\n            \n            for child in children[node]:\n                if child != parent:\n                    compute_all_dist(child, node)                    \n        \n        compute_sub_size(0, -1)\n        compute_desc_dist(0, -1)\n        compute_all_dist(0, -1)\n        \n        return all_dist", "# Preword\n# Well, another long solution.\n# what I am always trying is to:\n\n# let you understand my solution (with my poor explanation)\n# prevent from reading my codes\n\n# Intuition\n# What if given a tree, with a certain root 0?\n# In O(N) we can find sum of distances in tree from root and all other nodes.\n# Now for all N nodes?\n# Of course, we can do it N times and solve it in O(N^2).\n# C++ and Java may get accepted luckily, but it's not what we want.\n\n# When we move our root from one node to its connected node,\n# one part of nodes get closer, one the other part get further.\n\n# If we know exactly how many nodes in both parts, we can solve this problem.\n\n# With one single traversal in tree, we should get enough information for it and\n# don't need to do it again and again.\n\n\n# Explanation\n# Let's solve it with node 0 as root.\n\n# Initial an array of hashset tree, tree[i] contains all connected nodes to i.\n# Initial an array count, count[i] counts all nodes in the subtree i.\n# Initial an array of res, res[i] counts sum of distance in subtree i.\n\n# Post order dfs traversal, update count and res:\n# count[root] = sum(count[i]) + 1\n# res[root] = sum(res[i]) + sum(count[i])\n\n# Pre order dfs traversal, update res:\n# When we move our root from parent to its child i, count[i] points get 1 closer to root, n - count[i] nodes get 1 futhur to root.\n# res[i] = res[root] - count[i] + N - count[i]\n\n# return res, done.\n\n\n# Time Complexity:\n# dfs: O(N) time\n# dfs2: O(N) time\n\n\nclass Solution: \n    def sumOfDistancesInTree(self, N, edges):\n        tree = collections.defaultdict(set)\n        res = [0] * N\n        count = [1] * N\n        for i, j in edges:\n            tree[i].add(j)\n            tree[j].add(i)\n\n        def dfs(root, pre):\n            for i in tree[root]:\n                if i != pre:\n                    dfs(i, root)\n                    count[root] += count[i]\n                    res[root] += res[i] + count[i]\n\n        def dfs2(root, pre):\n            for i in tree[root]:\n                if i != pre:\n                    res[i] = res[root] - count[i] + N - count[i]\n                    dfs2(i, root)\n        dfs(0, -1)\n        dfs2(0, -1)\n        return res"]
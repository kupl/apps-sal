["import math\n\ndef count(n):\n    if n is 0: return 0\n    x = int(math.log(n, 2))\n    return x * 2 ** (x - 1) + n - 2 ** x + 1 + count(n - 2 ** x)\n\ndef countOnes(left, right):\n    return count(right) - count(left - 1)", "def countOnes(left, right):\n    \"\"\"\n    Each number has a particular number of digits in its binary representation.\n    There are sets of numbers with the same number of digits in their binary representation.\n    For example there is a set of 4-digit-numbers: 8,9,10,11,12,13,14,15.\n\n    num | binary representation\n      8 | 1 0 0 0\n      9 | 1 0 0 1\n     10 | 1 0 1 0\n     11 | 1 0 1 1\n     12 | 1 1 0 0\n     13 | 1 1 0 1\n     14 | 1 1 1 0\n     15 | 1 1 1 1\n\n    That kind of sets of n-digit numbers we will call 'blocks'.\n    For whole blocks we can easily calculate sum of ones with the formula 2^(n-1) * (1 + 0.5*(n-1))\n    But 'left' and 'right' digits can be somewhere inside of their blocks, so we have to sum only part of ones in block.\n\n    For example, in case of range <10, 35> we have to split our calculation in 3 parts:\n    1) Sum of the incomplete 4-digit-block, which contains number 10.\n    Number 10 splits that block on two parts and we sum ones only from second part (for numbers 10-15).\n    2) Sum of 5-digit-block (ones in numbers: 16-31)\n    3) Sum of the incomplete 6-digit-block, which contains number 35.\n    Number 35 splits that block on two parts and we sum ones only from first part (for numbers 32-35).\n\n    :return: sum of ones in binary representation of all numbers in range <left, right>\n    \"\"\"\n    left_binary_digits = count_binary_digits(left)\n    right_binary_digits = count_binary_digits(right)\n\n    right_binary_sum = sum([int(i) for i in str(bin(right))[2:]])\n\n    left_position_in_block = left - calculate_starting_digit(left_binary_digits) + 1\n    right_position_in_block = right - calculate_starting_digit(right_binary_digits) + 1\n\n    if left_binary_digits == right_binary_digits:\n        number_of_ones = calculate_ones_in_incomplete_block(left_binary_digits, left_position_in_block) \\\n                         - calculate_ones_in_incomplete_block(right_binary_digits, right_position_in_block) \\\n                         + right_binary_sum\n    else:\n        number_of_ones = calculate_ones_in_incomplete_block(left_binary_digits, left_position_in_block) \\\n                         + calculate_multiple_blocks(left_binary_digits + 1, right_binary_digits - 1) \\\n                         + calculate_ones_in_incomplete_block(right_binary_digits, right_position_in_block, True) \\\n                         + right_binary_sum\n    return number_of_ones\n\n\ndef count_binary_digits(number):\n    \"\"\":return: number of digits in binary representation of integer\"\"\"\n    return len(str(bin(number))) - 2\n\n\ndef calculate_starting_digit(n_digits):\n    \"\"\"\n    We know, that the block of n-digits-numbers contains of 2^(n-1) numbers\n    To calculate first number of 4-digits-block we have to count numbers from previous blocks and add 1:\n    2^(1-1) + 2^(2-1) + 2^(3-1) + 1 = 1 + 2 + 4 + 1 = 8\n    :return: first number of n_digits-block\n    \"\"\"\n    return sum([pow(2, i - 1) for i in range(1, n_digits)]) + 1\n\n\ndef calculate_ones_in_incomplete_block(n_digits, position, front_part=False):\n    \"\"\"\n    We use of following properties:\n    - First column of block is always filled with ones.\n    - Second column contains of dwo parts: half column of zeroes and half column of ones.\n        If we split next column in half, each part will follow above pattern.\n        If we split next column into four pieces, each part will follow the same pattern from second column and so on.\n    \n    We iterate through consecutive columns, moving 'middle_row' indicator as we split columns in smaller parts.\n    As we calculating second part of block, we add all ones under our indicator (including one on indicator) and ommit ones above.\n    \n    :param n_digits: number of digits in binary representation\n    :param position: position of number in n_digits-block\n    :param front_part: indicates whether we calculate normally ('second part' of block - from position to the end)\n            or we subtract second part from sum of ones in whole block and return 'first part'\n    :return: In block split in two parts by position we return sum of one form second or first part\n    \"\"\"\n    all_rows = pow(2, n_digits - 1)\n    upper_ones = 0\n    last_row = all_rows\n    result = last_row - position + 1\n    middle_row = last_row / 2\n\n    for i in range(n_digits - 1):\n        if position <= middle_row:\n            result += all_rows / 2 - upper_ones\n            temp = int(last_row)\n            last_row = middle_row\n            middle_row -= (temp - middle_row) / 2\n        else:\n            result += (last_row - position + 1 + (all_rows - last_row) / 2)\n            upper_ones += (last_row - middle_row) / 2\n            middle_row += (last_row - middle_row) / 2\n\n    if front_part:\n        return all_rows * (1 + 0.5 * (n_digits - 1)) - result\n    else:\n        return result\n\n\ndef calculate_multiple_blocks(digits_start, digits_stop):\n    \"\"\"\n    :return: sum of ones in all block from digits_start-block to digits_stop-block\n    \"\"\"\n    result = 0\n    if digits_stop >= digits_start:\n        for i in range(digits_start, digits_stop + 1):\n            result += pow(2, i - 1) * (1 + 0.5 * (i - 1))\n    return result", "from math import log2\n\n\ndef countOnes(left, right): return countUpTo(right) - countUpTo(left-1)\n\ndef countUpTo(n):\n    s = 0\n    while n:\n        p = n.bit_length()-1\n        p2 = 1<<p\n        s += p * (p2>>1) + n-p2+1\n        n &= ~p2\n    return s", "sumOnes = lambda n: (lambda msb: n and -~n + ~-msb * 2 ** msb + sumOnes(n - 2 ** -~msb))(n.bit_length() - 2)\ncountOnes = lambda a, b: sumOnes(b) - sumOnes(a-1)", "import math\n\ndef countOnes(left, right):\n\n    def onesRangeDigit(n,digit):\n        ex = 2**digit\n        ones = ex*math.floor((n+1)/(2*ex)) + max(((n+1)%(2*ex))-ex,0)\n        return ones\n\n    def onesRange(n):\n        ex = math.ceil(math.log(n+1,2))\n        print(ex)\n        ones = 0\n        for i in range(ex):\n            ones += onesRangeDigit(n,i)\n        return ones\n\n    return onesRange(right)-onesRange(left-1)\n", "def countOnesFromZero(num):\n    l = sorted([i for i, v in enumerate(bin(num)[2:][::-1]) if v == '1'], reverse=True)\n    l.append(0)\n    return sum(i * 2**v + v * 2**(v-1) for i, v in enumerate(l))\n\ndef countOnes(left, right):\n    # Your code here!\n    return countOnesFromZero(right) - countOnesFromZero(left) + bin(left).count('1')", "def countOnes(left, right):\n    def f(n):\n        c = 0\n        a = list(reversed(list(bin(n))))\n        for i, d in enumerate(a):\n            if d == '1':\n                c += 1 + 2**i*i/2 + 2**i*a[i+1:].count('1')\n        return c\n    return f(right) - f(left-1)\n", "def countevenone(left,right,span,maxbincount):\n    if span == 1:\n        return bin(left).count('1')\n    if span == 2:\n        return bin(right).count('1')+bin(left).count('1')\n    if span % 2 != 0:\n        if left % 2 == 0:\n            adds = span//2 + bin(right).count('1')\n            left = left//2\n            right = (right-1)//2\n        else:\n            adds = span//2 + bin(left).count('1')\n            left = (left+1)//2\n            right = right//2\n        span = span//2\n        maxbincount = maxbincount-1     \n        countones = countevenone(left,right,span,maxbincount)*2 + adds \n    else:\n        if left % 2 == 0:\n            left = left//2\n            right = right//2\n            adds = span//2\n            span = span//2\n        else:\n            adds = (span-2)//2 + bin(right).count('1') + bin(left).count('1')\n            left = (left+1)//2\n            right = (right-1)//2\n            span = (span-2)//2\n        maxbincount = maxbincount-1 \n        countones = countevenone(left,right,span,maxbincount) * 2 + adds\n    return countones\ndef countOnes(left, right):\n    # Your code here!\n    span = right-left+1\n    maxbincount=len(bin(right).replace(\"0b\",''))\n    return countevenone(left,right,span,maxbincount)", "def countOnes(left, right):\n def bindig(number):\n  ans=0\n  g=bin(number)[2:][::-1]\n  for i in range(len(g)):\n    if g[i]=='1':\n     if i==len(g)-1:\n      ans+=1+((2**(i-1))*i)\n     else: \n      ans+=1+(2**(i-1))*i+(g[i+1:].count('1'))*(2**i)\n  return ans\n return bindig(right)-bindig(left-1)\n"]
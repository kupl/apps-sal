["class Solution:\n     def lengthLongestPath(self, input):\n         \"\"\"\n         :type input: str\n         :rtype: int\n         \"\"\"\n         dict={0:0}\n         maxlen=0\n         line=input.split(\"\\n\")\n         for i in line:\n             name=i.lstrip('\\t')\n             print(name)\n             print((len(name)))\n             depth=len(i)-len(name)\n             if '.' in name:\n                 maxlen=max(maxlen, dict[depth]+len(name))\n             else:\n                 dict[depth+1]=dict[depth]+len(name)+1\n         return maxlen\n", "class Solution:\n     def lengthLongestPath(self, input):\n         \"\"\"\n         :type input: str\n         :rtype: int\n         \"\"\"\n         maxlen = 0\n         path = {0:0}\n         for line in input.splitlines():\n             name = line.lstrip('\\t')\n             depth = len(line) - len(name)\n             if '.' in line:\n                 maxlen = max(maxlen, path[depth] + len(name))\n             else:\n                 path[depth + 1] = path[depth] + len(name) + 1\n         return maxlen\n                 \n         \n              \n         \n             \n                 \n                 \n                 \n             \n             \n", "class Solution:\n     def lengthLongestPath(self, input):\n         maxlen = 0\n         pathlen = {0: 0}\n         for line in input.splitlines():\n             name = line.lstrip('\\t')\n             depth = len(line) - len(name)\n             if '.' in name:\n                 maxlen = max(maxlen, pathlen[depth] + len(name))\n             else:\n                 pathlen[depth + 1] = pathlen[depth] + len(name) + 1\n         return maxlen\n", "class Solution:\n     def lengthLongestPath(self, inp):\n         \"\"\"\n         :type input: str\n         :rtype: int\n         \"\"\"\n         m, l = 0, {-1: -1}\n         for s in inp.split('\\n'):\n             d = s.count('\\t')\n             l[d] = 1 + l[d-1] + len(s) - d\n             if '.' in s: \n                 m = max(m, l[d])\n         return m", "class Solution:\n     def lengthLongestPath(self, input):\n         \"\"\"\n         :type input: str\n         :rtype: int\n         \"\"\"\n         lines = input.split('\\n')\n         paths = []\n         ans = 0\n         for line in lines:\n             name = line.strip('\\t')\n             depth = len(line) - len(name)\n             \n             if '.' not in name:\n                 if depth >= len(paths):\n                     paths.append(len(name)+1)\n                 else:\n                     paths[depth] = len(name)+1\n             else:\n                 ans = max(ans, sum(paths[:depth])+len(name))\n         return ans", "class Solution:\n     def lengthLongestPath(self, input):\n         \"\"\"\n         :type input: str\n         :rtype: int\n         \"\"\"\n         max_line = 0\n         path_size = {0 : 0}\n         lines = input.splitlines()\n         for line in lines:\n             stripped = line.lstrip('\\t')\n             depth = len(line) - len(stripped)\n             if '.' in stripped:\n                 max_line = max(max_line, path_size[depth] + len(stripped))\n             else:\n                 path_size[depth + 1] = path_size[depth] + len(stripped) + 1\n         \n         return max_line", "class Solution:\n     def lengthLongestPath(self, input):\n         \"\"\"\n         :type input: str\n         :rtype: int\n         \"\"\"\n         res, l=0, 0\n         path=[]\n         for line in input.splitlines():\n             name=line.lstrip('\\t')\n             n=len(line)-len(name)\n             while len(path)>n:\n                 l-=path[-1]\n                 path.pop()\n             l+=len(name)\n             path.append(len(name))\n             if '.' in name:\n                 res=max(res, l+len(path)-1)\n         return res", "class Solution:\n     def lengthLongestPath(self, input):\n         \"\"\"\n         :type input: str\n         :rtype: int\n         \"\"\"\n         \n         dir = []\n         tab = 0\n         curr = []\n         temp = ''\n         op = 0\n         input += '\\n'\n         for c in input:\n             print('start:',c,temp)\n             if c == '\\n' and temp!='':\n                 if curr:\n                     print(curr)\n                     while tab <= curr[-1]:\n                         dir.pop(-1)\n                         curr.pop(-1)\n                         if not curr:\n                             break\n                 dir.append(temp)\n                 curr.append(tab)\n                 print(dir,curr)\n                 if '.' in temp:\n                     ans = '/'.join(dir)\n                     op = max(len(ans),op)\n                 temp = ''\n                 tab = 0\n             elif c =='\\t':\n                 tab += 1\n             else:\n                 temp += c\n \n         \n         return op", "class Solution:\n     def lengthLongestPath(self, input):\n         maxlen = 0\n         pathlen = {0: 0}\n         for line in input.splitlines():\n             name = line.lstrip('\\t')\n             depth = len(line) - len(name)\n             if '.' in name:\n                 maxlen = max(maxlen, pathlen[depth] + len(name))\n             else:\n                 pathlen[depth + 1] = pathlen[depth] + len(name) + 1\n         return maxlen", "class Solution:\n     def lengthLongestPath(self, x):\n         \"\"\"\n         :type input: str\n         :rtype: int\n         The number of tabs is my depth and for each depth I store the current path length.\n \n def lengthLongestPath(self, input):\n     maxlen = 0\n     pathlen = {0: 0}\n     for line in input.splitlines():\n         name = line.lstrip('\\t')\n         depth = len(line) - len(name)\n         if '.' in name:\n             maxlen = max(maxlen, pathlen[depth] + len(name))\n         else:\n             pathlen[depth + 1] = pathlen[depth] + len(name) + 1\n     return maxlen        \n         \"\"\"\n         h = {0:0}\n         maxlen = 0\n         #print(x.splitlines())\n         for line in x.splitlines():\n             name = line.lstrip('\\t')\n             depth = len(line)-len(name)\n             if name.count('.') != 0:\n                 maxlen = max(maxlen,h[depth]+len(name))\n             else:\n                 h[depth +1] = h[depth] + len(name) + 1\n         return maxlen", "class Solution:\n     def lengthLongestPath(self, input):\n         \"\"\"\n         :type input: str\n         :rtype: int\n         \"\"\"\n         max_len = 0\n         depth2len = {0:0}\n \n         for line in input.splitlines():\n             name = line.lstrip(\"\\t\")\n             depth = len(line) - len(name)\n             if \".\" in name:\n                 max_len = max(max_len, depth2len[depth] + len(name))\n             else:\n                 depth2len[depth+1] = depth2len[depth] + len(name) + 1\n         return max_len\n                 \n                 \n \n             \n"]
["import heapq\nn = int(input())\nd = list(map(int,input().split()))\npq = [-d[0]]\nheapq.heapify(pq)\nans = 0\nfor i in range(1,n):\n    temp = i - d[i]\n    heapq.heappush(pq,temp)\n    if heapq.nsmallest(1,pq)[0] < temp:\n        ans += temp - heapq.nsmallest(1,pq)[0]\n        heapq.heappushpop(pq,temp)\nprint(ans)\n", "from bisect import bisect_left as BL\n\nn = int(input())\ngraph = [(-99**9, 0, 0)] # x, y, slope\nfor i,a in enumerate(map(int,input().split())):\n    a-= i\n    new = []\n    turnj = BL(graph, (a,99**9)) - 1\n    \n    # add |x-a|\n    for j in range(turnj):\n        x, y, sl = graph[j]\n        new.append((x, y+(a-x), sl-1))\n    for j in range(turnj, len(graph)):\n        x, y, sl = graph[j]\n        if j == turnj:\n            new.append((x, y+(a-x), sl-1))\n            new.append((a, y+(a-x)+(sl-1)*(a-x), sl+1))\n        else: new.append((x, y+(x-a), sl+1))\n    \n    # remove positive slopes\n    graph = new\n    while graph[-1][2] > 0: x, y, sl = graph.pop()\n    if graph[-1][2] != 0: graph.append((x, y, 0))\nprint(graph[-1][1])", "from bisect import bisect_left as BL\n\nn = int(input())\ngraph = [(-99**9, 0)] # x, slope\nans = 0\nfor i,a in enumerate(map(int,input().split())):\n    a-= i\n    new = []\n    turnj = BL(graph, (a,99**9)) - 1\n    if turnj != len(graph)-1:\n        ans+= graph[-1][0] - a\n    \n    # add |x-a|\n    for j in range(turnj):\n        x, sl = graph[j]\n        new.append((x, sl-1))\n    for j in range(turnj, len(graph)):\n        x, sl = graph[j]\n        if j == turnj:\n            new.append((x, sl-1))\n            new.append((a, sl+1))\n        else: new.append((x, sl+1))\n    \n    # remove positive slopes\n    graph = new\n    while graph[-1][1] > 0: x, sl = graph.pop()\n    if graph[-1][1] != 0: graph.append((x, 0))\nprint(ans)", "from heapq import *\n\nn = int(input())\nturn = [99**9]\nopty = 0\nfor i,a in enumerate(map(int,input().split())):\n    a-= i\n    optx = -turn[0]\n    if optx <= a:\n        heappush(turn, -a)\n    else:\n        heappush(turn, -a)\n        heappop(turn)\n        heappush(turn, -a)\n        opty+= optx-a\nprint(opty)", "from bisect import insort\nclass Graph:\n    def __init__(_):\n        _.change = [-10**27] # increment slope at ...\n        _.a = _.y = 0 # last line has slope a, starts from y\n        _.dx = 0      # the whole graph is shifted right by ...\n    def __repr__(_): return f\"<{[x+_.dx for x in _.change]}; {_.a} {_.y}>\"\n    \n    def shiftx(_, v): _.dx+= v\n    def shifty(_, v): _.y+= v\n    def addleft(_, v):\n        if _.change[-1] < v-_.dx:\n            dx = v-_.dx - _.change[-1]\n            _.y+= _.a*dx\n        insort(_.change, v-_.dx)\n    def addright(_, v):\n        if _.change[-1] < v-_.dx:\n            dx = v-_.dx - _.change[-1]\n            _.y+= _.a*dx; _.a+= 1\n            insort(_.change, v-_.dx)\n            return\n        insort(_.change, v-_.dx)\n        _.a+= 1; _.y+= _.change[-1]-(v-_.dx)\n    #def remleft(_, v): change.remove(v-_.dx)\n    def cutright(_):\n        dx = _.change.pop()-_.change[-1]\n        _.a-= 1; _.y-= _.a*dx\n\nn = int(input())\nG = Graph()\nfor x in map(int,input().split()):\n    G.shiftx(1)\n    G.addleft(x)\n    G.addright(x)\n    while G.a > 0: G.cutright()\nprint(G.y)", "from heapq import *\nclass Maxheap:\n    def __init__(_): _.h = []\n    def add(_, v): heappush(_.h, -v)\n    def top(_): return -_.h[0]\n    def pop(_): return -heappop(_.h)\n\nclass Graph:\n    def __init__(_):\n        _.change = Maxheap() # increment slope at ...\n        _.change.add(-10**18)\n        _.a = _.y = 0 # last line has slope a, starts from y\n        _.dx = 0      # the whole graph is shifted right by ...\n    def __repr__(_): return f\"<{[x+_.dx for x in _.change]}; {_.a} {_.y}>\"\n    \n    def shiftx(_, v): _.dx+= v\n    def shifty(_, v): _.y+= v\n    def addleft(_, v):\n        if _.change.top() < v-_.dx:\n            dx = v-_.dx - _.change.top()\n            _.y+= _.a*dx\n        _.change.add(v-_.dx)\n    def addright(_, v):\n        if _.change.top() < v-_.dx:\n            dx = v-_.dx - _.change.top()\n            _.y+= _.a*dx; _.a+= 1\n            _.change.add(v-_.dx)\n            return\n        _.change.add(v-_.dx)\n        _.a+= 1; _.y+= _.change.top()-(v-_.dx)\n    def cutright(_):\n        dx = _.change.pop()-_.change.top()\n        _.a-= 1; _.y-= _.a*dx\n \nn = int(input())\nG = Graph()\nfor x in map(int,input().split()):\n    G.shiftx(1)\n    G.addleft(x)\n    G.addright(x)\n    while G.a > 0: G.cutright()\nprint(G.y)"]
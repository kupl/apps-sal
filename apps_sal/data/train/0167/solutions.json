["class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        def f(t):\n            a=0\n            r=1\n            for i in range(1, K+1):\n                r *= (t-i+1)\n                r//=i\n                a+=r\n                if a>=N: \n                    break\n            return a\n        \n        l, h= 1, N\n        while l<h:\n            m=(l+h)//2\n            if f(m)<N:\n                l=m+1\n            else:\n                h=m\n        return l", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        def aux(t, k):\n            ret = 0\n            r = 1\n            for i in range(1, K+1):\n                r *= t-i+1\n                r //= i\n                ret += r\n                if ret >= N:\n                    break\n            return ret\n        \n        l, r = 1, N\n        while l < r:\n            m = (l + r) // 2\n            if aux(m, K) < N:\n                l = m+1\n            else:\n                r = m\n        return l\n    \n#         memo = {}\n#         def dp(n, k):\n#             if (n, k) not in memo:\n#                 if n == 0:\n#                     ret = 0\n#                 elif k == 1:\n#                     ret = n\n#                 else:\n#                     lo, hi = 1, n\n#                     while lo+1 < hi:\n#                         x = (lo + hi) // 2\n#                         t1 = dp(n-x, k)\n#                         t2 = dp(x-1, k-1)\n#                         if t1 < t2:\n#                             hi = x\n#                         elif t1 > t2:\n#                             lo = x\n#                         else:\n#                             lo = hi = x\n#                     ret = 1 + min(max(dp(n-x, k), dp(x-1, k-1)) for x in (lo, hi))\n                \n#                 memo[n, k] = ret\n#             return memo[n, k]\n        \n#         return dp(N, K)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n            # M x K --> Given M moves and K eggs, what is the maximum floor we can check ?\n            M = 300 # big enough number\n            dp = [[0 for j in range(K+1)] for i in range(M+1)]\n            # Initialization 1 --> no move no floor --> dp[0][*] = 0\n            # Initialization 2 --> no egg no floor --> dp[*][0] = 0\n            # General case --> we want to find dp[m][k] --> we pick one egg and drop (1 move)\n            #              --> now we have k or k-1 eggs, depending on whether the previous egg is broken\n            #              --> so in either case, we can at least sum up 1 (first move) + dp[m-1][k] + dp[m-1][k-1] \n            for i in range(1, M+1):\n                for j in range(1, K+1):\n                    dp[i][j] = 1 + dp[i-1][j] + dp[i-1][j-1]\n                    if dp[i][j] >= N:\n                        return i", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[0] * (N+1) for _ in range(K+1)]\n        # dp[k][n]: the max floor number we can cover with k eggs and n drops\n        # if k = 1, dp[1][n] = n\n        # if k >= 2, after one drop, n-1 drops left, two cases:\n        #            if the egg breaks, k-1 egges, thus dp[k-1][n-1]\n        #            if it doesn't break, k egges, thus dp[k][n-1]\n        # just leave the 0 col and 0 row blank\n        # when k = 1\n        # when k >= 2\n        for k in range(1, K+1):\n            for n in range(1, N+1):\n                if k == 1:\n                    dp[k][n] = n\n                else:\n                    dp[k][n] = 1 + dp[k-1][n-1] + dp[k][n-1]\n        # find the smallest n in the last row with dp[K,n] > N\n        top, bott = 0, N\n        while top < bott:\n            mid = (top + bott) // 2\n            if dp[K][mid] < N:\n                top = mid + 1\n            else:\n                bott = mid\n        return bott   \n                \n", "from functools import lru_cache\n\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # time complexity: O(K*N*logN)\n        # space complexity: O(K*N)\n        @lru_cache(None)\n        def dp(k, n): # k eggs, n floors\n            if k == 0: return 0\n            if k == 1: return n\n            if n <= 1: return n\n            if k > math.log(n, 2): return 1 + int(math.log(n,2))\n            l, r = 1, n + 1\n            while l < r:\n                m = l + (r - l) // 2\n                if dp(k-1, m-1) >= dp(k, n-m):\n                    r = m\n                else:\n                    l = m + 1\n            return 1 + max(dp(k-1, l-1), dp(k, n-l))\n        \n        return dp(K, N)", "from functools import lru_cache\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        @lru_cache(None)\n        def dp(k, n):\n            if k == 0: return 0\n            if k == 1: return n\n            if n <= 1: return n\n            if k > log(n, 2): return 1 + int(log(n, 2))\n            l, r = 1, n + 1\n            while l < r:\n                m = l + (r - l) // 2\n                if dp(k-1, m-1) < dp(k, n-m):\n                    l = m + 1\n                else: \n                    r = m\n            return max(1 + dp(k-1, l-1), 1 + dp(k, n-l))\n        return dp(K, N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        # dp = [[0 for _ in range(N+1)] for _ in range(K+1)]\n\n        dp = list(range(N+1))\n        for i in range(2, K+1):\n            k = 1\n            temp =[0] + [N + 1] * (N)\n            for j in range(1, N+1):\n                while k < j+1 and temp[j-k] > dp[k-1]:\n                    k += 1\n                temp[j] = 1 + dp[k-1]\n                # if i > j:\n                #     dp[i][j] = dp[i-1][j]\n                # else:\n                #     val = N + 1\n                #     for k in range(1, j+1):\n                #         val = min(val, 1 + max(dp[i-1][k-1], dp[i][j-k]))\n                #     dp[i][j] = val\n            dp = temp[:]\n        # print(dp)\n        return dp[-1]\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        # dp = [[0 for _ in range(N+1)] for _ in range(K+1)]\n\n        dp = list(range(N+1))\n        for i in range(2, K+1):\n            k = 1\n            temp =[0] + [float('inf')] * (N)\n            for j in range(1, N+1):\n                while k < j+1 and temp[j-k] > dp[k-1]:\n                    k += 1\n                temp[j] = 1 + dp[k-1]\n                # if i > j:\n                #     dp[i][j] = dp[i-1][j]\n                # else:\n                #     val = N + 1\n                #     for k in range(1, j+1):\n                #         val = min(val, 1 + max(dp[i-1][k-1], dp[i][j-k]))\n                #     dp[i][j] = val\n            dp = temp[:]\n        # print(dp)\n        return dp[-1]\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        dp = range(N+1)\n        for i in range(2, K+1):\n            k = 1\n            temp =[0] + [N + 1] * (N)\n            for j in range(1, N+1):\n                while k < j+1 and temp[j-k] > dp[k-1]:\n                    k += 1\n                temp[j] = 1 + dp[k-1]\n            dp = temp[:]\n        return dp[-1]   ", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        self.memo = {}\n\n        return self.cal_eggs(K, N)\n\n    def find_that_floor(self,K,N):\n        left, right = 1, N\n        while (left <= right):\n            mid = (left + right) // 2\n            # if it breaks;\n            r1 = 1 + self.cal_eggs(K - 1, mid - 1)\n            # if it not breaks;\n            r2 = 1 + self.cal_eggs(K, N - mid)\n\n            if r1 == r2:\n                right = mid; break;\n            elif r1 < r2:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return right\n\n    def cal_eggs(self, K, N):\n        # print(K,N)\n        if N == 0: return 0\n        if K == 1: return N\n\n        if (K, N) in self.memo:\n            pass\n        else:\n            r = 2 ** 32 - 1\n            now_floor = self.find_that_floor(K,N)\n            for floor in range(now_floor, min(now_floor + 2,N+1)):\n                # if it breaks;\n                r1 = 1 + self.cal_eggs(K - 1, floor - 1)\n                # if it not breaks;\n                r2 = 1 + self.cal_eggs(K, N - floor)\n\n                r = min(r, max(r1, r2))\n\n            self.memo[(K, N)] = r\n\n        return self.memo[(K, N)]\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        max_floors = [[0 for _ in range(N + 1)] for _ in range(K + 1)]\n\n        for k in range(1, K + 1):\n            for t in range(1, N + 1):\n                max_floors[k][t] = 1 + max_floors[k - 1][t - 1] + max_floors[k][t - 1]\n        for t in range(N):\n            if max_floors[K][t] >= N:\n                return t\n        return N\n", "class Solution:\n    def f(self, pivot: int, eggs: int, floors: int) -> int:\n        \n        ans, r = 0, 1        \n        \n        for idx in range(1, eggs+1):\n            r *= (pivot - idx+1)\n            r //= idx\n            ans += r\n            \n            if ans >= floors:\n                break\n        \n        return ans\n    \n    def superEggDrop(self, eggs: int, floors: int) -> int:\n        \n        lo, hi = 1, floors\n        \n        while lo < hi:\n            \n            mi = (lo + hi) // 2\n            \n            if self.f(mi, eggs, floors) < floors:\n                lo = mi + 1\n            else:\n                hi = mi\n        \n        return lo", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        from functools import lru_cache\n        \n        @lru_cache(maxsize=None)\n        def dp(i, j):\n            #min number of drops to make with given i eggs and j floors\n            if j==0: return 0 \n            if i==1: return j\n            if j==1: return 1\n            # print(i, j)\n            \n            \n            #get min value for max(dp(i-1, k-1), dp(i, j-k)) \n            \n            #play with k untill \n            \n            lo, hi = 1, j\n            \n            while lo < hi:\n                k = lo + (hi-lo)//2\n                if dp(i-1, k-1) < dp(i, j-k):\n                    lo = k+1\n                else:\n                    hi = k\n                    \n            return 1 + dp(i-1, lo-1)\n                    \n        return dp(K, N)\n", "from functools import lru_cache\n\n\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        @lru_cache(None)\n        def dp(k: int, n: int) -> int:\n            # k == 0 is invalid but not 'impossible'/infinity. Value 0 ensures formula correctness.\n            # dp[k][n] = min{1 + max(dp[k-1][i], dp[k][n-i]) for i in [1, n]}\n            # dp[0][:]\n            if k <= 0:\n                return 1 << 31\n            if k == 1:\n                return n\n            if n <= 0:\n                return 0\n            # Following line is required; o.w. result is not right.\n            # When picking 1st floor to drop egg, if it breaks, no more dropping is needed so dp[:][0] == 0\n            if n <= 1:\n                return n\n            # Find the first floor where value starts to increase.\n            left, right = 1, n\n            while left <= right:\n                mid = (left + right) // 2\n                if dp(k - 1, mid - 1) >= dp(k, n - mid):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # Compare points.\n            return 1 + dp(k - 1, left - 1)\n\n        return dp(K, N)", "from functools import lru_cache\n\n\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        @lru_cache(None)\n        def dp(k: int, n: int) -> int:\n            if k <= 0:\n                return 0\n            if k == 1:\n                return n\n            # Following line is required; o.w. result is not right.\n            if n <= 1:\n                return n\n            # Find the first floor where dp(k - 1, i - 1) >= dp(k, n - i)\n            # such point must exist because dp(k, n-i) has min as dp(k, 0) == 0\n            left, right = 1, n\n            while left <= right:\n                mid = (left + right) // 2\n                if dp(k - 1, mid - 1) >= dp(k, n - mid):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return 1 + dp(k - 1, left - 1)\n\n        return dp(K, N)\n", "from functools import lru_cache\n\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # time complexity: O(K*N*logN)\n        # space complexity: O(K*N)\n        @lru_cache(None)\n        def dp(k, n): # k eggs, n floors\n            if k == 0: return 0\n            if k == 1: return n\n            if n <= 1: return n\n            l, r = 1, n + 1\n            while l < r:\n                m = l + (r - l) // 2\n                if dp(k-1, m-1) >= dp(k, n-m):\n                    r = m\n                else:\n                    l = m + 1\n            return 1 + max(dp(k-1, l-1), dp(k, n-l))\n        \n        return dp(K, N)", "class Solution:\n    def binary_search(self,A,k,n):\n        lo = 0\n        hi = n\n        mid = (lo+hi)//2\n        while lo<hi:\n            if A[k-1][mid-1]==A[k][n-mid]:\n                return mid\n            if A[k-1][mid-1]>A[k][n-mid]:\n                hi = mid\n            else:\n                lo = mid+1\n            mid = (lo+hi)//2\n            \n        return lo\n    def superEggDrop(self, K: int, N: int) -> int:\n        if N==1:\n            return 1\n        # k=0\n        # n=N\n        # while n>0:\n        #     k+=1\n        #     n//=2\n        # if K>k:\n        #     return k\n        A = [[0 for n in range(N+1)] for k in range(K+1)]\n        \n        for n in range(N+1):\n            A[1][n] = n\n        for k in range(K+1):\n            A[k][1] = 1\n            A[k][2] = 2\n        \n        for k in range(2,K+1):\n            low=1\n            for n in range(3,N+1):\n                # linear search\n                # m=1\n                # while A[k-1][m-1]<A[k][n-m]:\n                #     m+=1\n                \n                #binary search\n                # m = self.binary_search(A,k,n)\n                # A[k][n] = 1+max(A[k-1][m-1],A[k][n-m])\n                \n                # tip-toe\n                # print('k =',k,' n = ',n,low,'    ', A[k-1][low],'   ',A[k][n-low-1],'   ',A[k][n])\n                if A[k-1][low]<A[k][n-low-1]:\n                    low+=1\n                  \n                A[k][n] = 1+A[k-1][low]\n                # print('k =',k,' n = ',n,low,'    ', A[k-1][low],'   ',A[k][n-low-1],'   ',A[k][n])\n                # print('')\n        return A[-1][-1]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        @lru_cache(None)\n        def dp(k, n):\n            if n == 0:\n                ans = 0\n            elif k == 1:\n                ans = n\n            else:\n                lo, hi = 1, n\n                # keep a gap of 2 X values to manually check later\n                while lo < hi:\n                    x = (lo + hi) // 2\n                    t1 = dp(k-1, x-1)\n                    t2 = dp(k, n-x)\n\n                    if t1 < t2:\n                        lo = x + 1\n                    else:\n                        hi = x\n                ans = 1 + max(dp(k-1, lo-1), dp(k, n-lo))\n            return ans\n        return dp(K,N)\n", "class Solution:\n    def binary_search(self,A,k,n):\n        lo = 0\n        hi = n\n        mid = (lo+hi)//2\n        while lo<hi:\n            if A[k-1][mid-1]==A[k][n-mid]:\n                return mid\n            if A[k-1][mid-1]>A[k][n-mid]:\n                hi = mid\n            else:\n                lo = mid+1\n            mid = (lo+hi)//2\n            \n        return lo\n    def superEggDrop(self, K: int, N: int) -> int:\n        if N==1:\n            return 1\n        if K==1:\n            return N\n        A = [n+1 for n in range(N)]\n        At = [1 for n in range(N)]\n        for k in range(1,K):\n            i=0\n            while At[i]<N:\n                i+=1\n                At[i] = At[i-1] + A[i-1]+1\n            if k<K-1:\n                At,A=A,At\n        return i+1\n#         k=0\n#         n=N\n#         while n>0:\n#             k+=1\n#             n//=2\n#         if K>k:\n#             return k\n#         A = [[0 for n in range(N+1)] for k in range(K+1)]\n        \n#         for n in range(N+1):\n#             A[1][n] = n\n#         for k in range(K+1):\n#             A[k][1] = 1\n#             A[k][2] = 2\n#         for k in range(2,K+1):\n#             low=1\n#             for n in range(3,N+1):\n#                 # linear search\n#                 # m=1\n#                 # while A[k-1][m-1]<A[k][n-m]:\n#                 #     m+=1\n                \n#                 #binary search\n#                 # m = self.binary_search(A,k,n)\n#                 # A[k][n] = 1+max(A[k-1][m-1],A[k][n-m])\n                \n#                 # tip-toe\n#                 if A[k-1][low]<A[k][n-low-1]:\n#                     low+=1\n                  \n#                 A[k][n] = 1+A[k-1][low]\n        return A[-1][-1]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        memo={}\n        \n        def dp(k,n):\n            if (k,n) not in memo:\n                if n==0:\n                    ans=0\n                elif k==1:\n                    ans=n\n                else:\n                    lo,hi=1,n\n                    while lo+1<hi:\n                        x=(lo+hi)//2\n                        t1=dp(k-1,x-1)\n                        t2=dp(k,n-x)\n                        \n                        if t1<t2:\n                            lo=x\n                        elif t1>t2:\n                            hi=x\n                        else:\n                            lo=hi=x\n                    \n                    ans=1+min(max(dp(k-1,x-1),dp(k,n-x)) for x in (lo,hi))\n                \n                memo[k,n]=ans\n            return memo[k,n]\n        \n        return dp(K,N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[i for i in range(N+1)]]\n        for i in range(K-1):\n            dp.append( [0] * (N+1))\n            \n        for i in range(1, K):\n            k = 1\n            for j in range(1, N+1):\n                while k < j+1 and dp[i][j-k] > dp[i-1][k-1]:\n                    k += 1\n                dp[i][j] = 1 + dp[i-1][k-1]\n        return dp[-1][-1]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        mem = [[None for _ in range(N)] for _ in range(K - 1)]\n        def dp(k, n, mem):\n            if n <= 1 or k == 1:\n                return n\n            if mem[k-2][n-1] is None:\n                l, r = 1, n\n                while l + 1 < r:\n                    i = (l + r) // 2\n                    if dp(k - 1, i - 1, mem) < dp(k, n - i, mem):\n                        l = i\n                    elif dp(k - 1, i - 1, mem) > dp(k, n - i, mem):\n                        r = i\n                    else:\n                        l = r = i\n                mem[k-2][n-1] = min(max(dp(k - 1, l - 1, mem), dp(k, n - l, mem)), max(dp(k - 1, r - 1, mem), dp(k, n - r, mem))) + 1\n            return mem[k-2][n-1]\n        return dp(K, N, mem)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        self.memo = {}\n\n        return self.cal_eggs(K, N)\n\n    def find_that_floor(self,K,N):\n        left, right = 1, N\n        while (left <= right):\n            mid = (left + right) // 2\n            # if it breaks;\n            r1 = 1 + self.cal_eggs(K - 1, mid - 1)\n            # if it not breaks;\n            r2 = 1 + self.cal_eggs(K, N - mid)\n\n            if r1 == r2:\n                return mid\n            elif r1 < r2:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return right\n\n    def cal_eggs(self, K, N):\n        # print(K,N)\n        if N == 0: return 0\n        if K == 1: return N\n\n        if (K, N) not in self.memo:\n            r = 2 ** 32 - 1\n            now_floor = self.find_that_floor(K,N)\n            for floor in range(now_floor, min(now_floor + 2,N+1)):\n                # if it breaks;\n                r1 = 1 + self.cal_eggs(K - 1, floor - 1)\n                # if it not breaks;\n                r2 = 1 + self.cal_eggs(K, N - floor)\n\n                r = min(r, max(r1, r2))\n\n            self.memo[(K, N)] = r\n\n        return self.memo[(K, N)]\n", "class Solution:\n    def binary_search(self,A,k,n):\n        lo = 0\n        hi = n\n        mid = (lo+hi)//2\n        while lo<hi:\n            if A[k-1][mid-1]==A[k][n-mid]:\n                return mid\n            if A[k-1][mid-1]>A[k][n-mid]:\n                hi = mid\n            else:\n                lo = mid+1\n            mid = (lo+hi)//2\n            \n        return lo\n    def superEggDrop(self, K: int, N: int) -> int:\n        # if N==1:\n        #     return 1\n        if K==1:\n            return N\n        A = [n+1 for n in range(N)]\n        At = [1 for n in range(N)]\n        for k in range(1,K):\n            i=0\n            while At[i]<N:\n                i+=1\n                At[i] = At[i-1] + A[i-1]+1\n            if k<K-1:\n                At,A=A,At\n        return i+1\n#         k=0\n#         n=N\n#         while n>0:\n#             k+=1\n#             n//=2\n#         if K>k:\n#             return k\n#         A = [[0 for n in range(N+1)] for k in range(K+1)]\n        \n#         for n in range(N+1):\n#             A[1][n] = n\n#         for k in range(K+1):\n#             A[k][1] = 1\n#             A[k][2] = 2\n#         for k in range(2,K+1):\n#             low=1\n#             for n in range(3,N+1):\n#                 # linear search\n#                 # m=1\n#                 # while A[k-1][m-1]<A[k][n-m]:\n#                 #     m+=1\n                \n#                 #binary search\n#                 # m = self.binary_search(A,k,n)\n#                 # A[k][n] = 1+max(A[k-1][m-1],A[k][n-m])\n                \n#                 # tip-toe\n#                 if A[k-1][low]<A[k][n-low-1]:\n#                     low+=1\n                  \n#                 A[k][n] = 1+A[k-1][low]\n        return A[-1][-1]", "class Solution(object):\n    def superEggDrop(self, K, N):\n        dp=[[float('inf')]*(N+1) for _ in range(K+1)]\n        for i in range(1, K+1):\n            dp[i][0] = 0\n            dp[i][1] = 1\n        for j in range(1, N+1):\n            dp[1][j] = j\n            \n        for i in range(2, K+1):\n            k = 1\n            for j in range(2, N+1):\n                while k < j+1 and dp[i][j-k] > dp[i-1][k-1]:\n                    k += 1\n                dp[i][j] = 1 + dp[i-1][k-1]\n        return dp[K][N]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[i for i in range(N+1)]]\n\n        for _ in range(K-1):\n            dp.append([0, 1] + [0] * (N-1))\n        \n        for i in range(1, K):\n            k = 1\n            for j in range(2, N+1):\n                while k < j+1 and dp[i][j-k] > dp[i-1][k-1]:\n                    k += 1\n                dp[i][j] = 1 + dp[i-1][k-1]\n        return dp[-1][-1]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[float('Inf')] * (N + 1) for _ in range(K + 1)]\n        \n        for i in range(1, K + 1):\n            dp[i][0], dp[i][1] = 0, 1\n            \n        for j in range(1, N + 1):\n            dp[1][j] = j\n            \n        for i in range(2, K + 1):\n            k = 1\n            for j in range(2, N + 1):\n                while k < j + 1 and dp[i][j-k] > dp[i-1][k-1]:\n                    k += 1\n                dp[i][j] = 1 + dp[i-1][k-1]\n                    \n        return dp[K][N]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp=[[float('inf')]*(N+1) for _ in range(K+1)]\n        for i in range(1, K+1):\n            dp[i][0] = 0\n            dp[i][1] = 1\n        for j in range(1, N+1):\n            dp[1][j] = j\n            \n        for i in range(2, K+1):\n            k = 1\n            for j in range(2, N+1):\n                while k < j+1 and dp[i][j-k] > dp[i-1][k-1]:\n                    k += 1\n                dp[i][j] = 1 + dp[i-1][k-1]\n        return dp[K][N]\n\n", "import math\nfrom functools import lru_cache\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        @lru_cache(None)\n        def dp(k, n):\n            if k == 0: return 0\n            if k == 1: return n\n            if n <= 1: return n\n            if k >= math.log(n, 2): return int(math.log(n, 2))+1\n            ans = sys.maxsize\n            l, r = 1, n + 1\n            while l < r:\n                m = l + (r - l) //2\n                if dp(k-1, m-1) >= dp(k, n-m):\n                    r = m\n                else:\n                    l = m + 1\n            ans = min(ans, 1 + max(dp(k-1, l-1), dp(k, n-l)))\n            return ans\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        res = [[0]*(N+1) for _ in range(K)]\n        # \u521d\u59cb\u5316\u7b2c\u4e00\u884c\n        for i in range(N+1):\n            res[0][i] = i;\n        # \u4ece\u7b2c\u4e8c\u884c\u5f00\u59cb\n        if K == 1:\n            return N\n        for k in range(1,K):\n            j = 1\n            for i in range(1, N+1):\n                while j < i+1 and res[k-1][j-1] < res[k][i-j]:\n                    j += 1\n                res[k][i] = 1 + res[k-1][j-1]\n                # for j in range(1,i+1):\n                #     if res[k-1][j-1] == res[k][i-j]:\n                #         res[k][i] = 1 + res[k-1][j-1]\n                #     else:\n                #         continue\n        # print(res) \n        return int(res[K-1][N])\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[float('inf')] * (N+1) for _ in range(K+1)]\n        for k in range(1, K+1):\n            dp[k][1] = 1\n            dp[k][0] = 0\n        for n in range(1, N+1):\n            dp[1][n] = n\n        \n        for k in range(2, K+1):\n            x = 1\n            for n in range(2, N+1):\n                while x < n+1 and dp[k][n-x] > dp[k-1][x-1]:\n                    x += 1\n                dp[k][n] = 1 + dp[k-1][x-1]\n        #print(dp)\n        return dp[-1][-1]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        @lru_cache(None)\n        def dp(k, n):\n            if n == 0:\n                ans = 0\n            elif k == 1:\n                ans = n\n            else:\n                lo, hi = 1, n\n                # keep a gap of 2 X values to manually check later\n                while lo < hi:\n                    x = (lo + hi) // 2\n                    t1 = dp(k-1, x-1)\n                    t2 = dp(k, n-x)\n\n                    if t1 < t2:\n                        lo = x + 1\n                    else:\n                        hi = x\n                ans = 1 + min(max(dp(k-1, x-1), dp(k, n-x))\n                              for x in (lo, hi))\n            return ans\n        return dp(K,N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        @lru_cache(None)\n        def dp(k, n):\n            if (k, n) not in memo:\n                if n == 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    lo, hi = 1, n\n                    # keep a gap of 2 X values to manually check later\n                    while lo < hi:\n                        x = (lo + hi) // 2\n                        t1 = dp(k-1, x-1)\n                        t2 = dp(k, n-x)\n\n                        if t1 < t2:\n                            lo = x + 1\n                        else:\n                            hi = x\n\n                    ans = 1 + min(max(dp(k-1, x-1), dp(k, n-x))\n                                  for x in (lo, hi))\n\n                memo[k, n] = ans\n            return memo[k, n]\n\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        memo = {}\n        def dp(k, n):\n            if (k, n) not in memo:\n                if n == 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    l, r = 1, n\n                    while l + 1 < r:\n                        x = (l + r)//2\n                        t1 = dp(k - 1, x - 1)\n                        t2 = dp(k, n - x)\n                        if t1 < t2:\n                            l = x\n                        elif t1 > t2:\n                            r = x\n                        else:\n                             l = r = x\n                    ans = 1 + min(max(dp(k-1, x-1), dp(k, n-x))\n                                  for x in (l, r))\n                memo[(k, n)] = ans\n            return memo[(k, n)]\n        return dp(k, n)\n             \n", "from functools import lru_cache\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        @lru_cache(None)\n        def dp(k, n):\n            if k == 0: return 0\n            if k == 1: return n\n            if n <= 1: return n\n            ans = sys.maxsize\n            l, r = 1, n + 1\n            while l < r:\n                m = l + (r - l) //2\n                if dp(k-1, m-1) >= dp(k, n-m):\n                    r = m\n                else:\n                    l = m + 1\n            ans = min(ans, 1 + max(dp(k-1, l-1), dp(k, n-l)))\n            return ans\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # special case for K = 1\n        if K == 1:\n            return N\n        \n        # initialize data\n        Rp = [i for i in range(0, N+1)]\n        R = [0] * (N+1)\n        R[1] = 1\n        \n        k = 2\n        while k <= K:\n            l1 = 0\n            for n in range(2, N+1):\n                #if n < 2**k:\n                #    R[n] = n.bit_length() \n                if Rp[n-l1-1] >= R[n-1]:\n                    R[n] = R[n-1] + 1\n                else:\n                    R[n] = R[n-1]\n                \n                if R[n] > R[n-1]:\n                    l1 = n-1\n             \n            Rp, R = R, Rp\n            k += 1\n            \n        return Rp[N]\n                \n            \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        dp = [[0 for _ in range(N+1)] for _ in range(K+1)]\n\n        dp[1] = list(range(N+1))\n        for i in range(2, K+1):\n            k = 1\n            for j in range(1, N+1):\n                while k < j+1 and dp[i][j-k] > dp[i-1][k-1]:\n                    k += 1\n                dp[i][j] = 1 + dp[i-1][k-1]\n                # if i > j:\n                #     dp[i][j] = dp[i-1][j]\n                # else:\n                #     val = N + 1\n                #     for k in range(1, j+1):\n                #         val = min(val, 1 + max(dp[i-1][k-1], dp[i][j-k]))\n                #     dp[i][j] = val\n        # print(dp)\n        return dp[-1][-1]\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # we have floors = dp[nummoves][eggs]\n        dp = [[\n              0\n              for egg in range(K+1)] \n              for moves in range(305)]\n        print(N)\n         \n        for move in range(1, 300):\n            for eggs in range(1, K+1):\n                dp[move][eggs] = 1 + dp[move-1][eggs-1] + dp[move-1][eggs]\n                if dp[move][eggs]>=N:\n                    return move\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        if N == 1:\n            return 1\n        \n        eggSolutions = [[None for n in range(N+1)] for k in range(K+1)]        \n        for n in range(1, N+1):\n            eggSolutions[1][n] = n\n        for k in range(1, K+1):\n            eggSolutions[k][1] = 1\n            eggSolutions[k][2] = 2\n        \n        nextPVals = [i for i in range(N+1)]\n        for k in range(2, K+1):\n            pVals = nextPVals\n            nextPVals = [None, None, 2]\n            pIndex = 2\n            for n in range(3, N+1):\n                p = pVals[pIndex]\n                minDrops = 1 + max(eggSolutions[k-1][p-1], eggSolutions[k][n-p])\n                eggSolutions[k][n] = minDrops\n                if eggSolutions[k][n] > eggSolutions[k][n-1]:\n                    pIndex += 1\n                    nextPVals.append(n)\n        \n        return eggSolutions[K][N]", "class Solution(object):\n    def superEggDrop(self, K, N):\n        dp = range(N+1)\n        for i in range(2, K+1):\n            k = 1\n            ndp = [0, 1] + [float('inf')]*(N-1)\n            for j in range(2, N+1):\n                while k < j+1 and ndp[j-k] > dp[k-1]:\n                    k += 1\n                ndp[j] = 1 + dp[k-1]\n            dp = ndp\n        return dp[N]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        self.memo = {}\n\n        return self.cal_eggs(K, N)\n\n    def find_that_floor(self,K,N):\n        left, right = 1, N\n        while (left <= right):\n            mid = (left + right) // 2\n            # if it breaks;\n            r1 = 1 + self.cal_eggs(K - 1, mid - 1)\n            # if it not breaks;\n            r2 = 1 + self.cal_eggs(K, N - mid)\n\n            if r1 == r2:\n                return mid\n            elif r1 < r2:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return right\n\n    def cal_eggs(self, K, N):\n        # print(K,N)\n        if N == 0: return 0\n        if K == 1: return N\n\n        if (K, N) in self.memo:\n            pass\n        else:\n            r = 2 ** 32 - 1\n            now_floor = self.find_that_floor(K,N)\n            for floor in range(now_floor, min(now_floor + 2,N+1)):\n                # if it breaks;\n                r1 = 1 + self.cal_eggs(K - 1, floor - 1)\n                # if it not breaks;\n                r2 = 1 + self.cal_eggs(K, N - floor)\n\n                r = min(r, max(r1, r2))\n\n            self.memo[(K, N)] = r\n\n        return self.memo[(K, N)]\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        @lru_cache(None)\n        def dp(k, n):\n            if n == 0: return 0\n            if k == 1: return n\n            \n            res = float('inf')\n            \n            lo = 1\n            hi = n\n            \n            while lo <= hi:\n                mid = (lo + hi) // 2\n                \n                broken = dp(k - 1, mid - 1)\n                no_broken = dp(k, n - mid)\n                \n                if broken > no_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, no_broken + 1)\n            return res\n        \n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [i for i in range(N+1)]\n        for j in range(1, K):\n            prev = dp.copy()\n            m = 1\n            for i in range(2, N+1):\n                while m < i and dp[i-m] >= prev[m-1] and dp[i-m-1] >= prev[m]:\n                    m += 1\n                dp[i] = max(dp[i-m], prev[m-1]) + 1\n        return dp[N]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[0] * (N + 1) for _ in range(K + 1)]\n        for n in range(1, N + 1):\n            dp[1][n] = n\n        for k in range(2, K + 1):\n            dp[k][1] = 1\n        # dp[k][n] <= n\n        for k in range(2, K + 1):\n            m = 1\n            for n in range(2, N + 1):\n                while m < n and dp[k - 1][m - 1] < dp[k][n - m]:\n                    m += 1\n                # dp[k][n] = min(max(dp[k - 1][m - 1], dp[k][n - m]) + 1 for m in range(1, n + 1))\n                # l, r = 1, n\n                # while l < r:\n                #     m = (l + r) >> 1\n                #     a, b = dp[k - 1][m - 1], dp[k][n - m]\n                #     if a > b:\n                #         r = m\n                #     elif b > a:\n                #         l = m + 1\n                #     else:\n                #         break\n                dp[k][n] = max(dp[k - 1][m - 1], dp[k][n - m]) + 1\n        # for _ in dp:\n        #     print(_)\n        return dp[-1][-1]", "from functools import lru_cache\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # return self.bottomUp(K, N)\n        return self.findMoves(K, N)\n    \n    @lru_cache(maxsize = None)\n    def findMoves(self, K, N):\n        if K == 1 or N<=1:\n            return N\n        f = N\n        \n        left, right = 1, N\n        while (left < right):\n            mid = (left + right) // 2\n            \n            broken = self.findMoves(K-1, mid-1)\n            intact = self.findMoves(K, N-mid)\n            if broken > intact:\n                right = mid\n            else:\n                left = mid+1\n        \n        mid = left -1\n        return 1 + max(self.findMoves(K-1, mid-1), self.findMoves(K, N-mid))\n#         intact = \n            \n#         for x in range (1, N+1):\n#             f = min(1 + max(self.findMoves(K-1, x-1), self.findMoves(K, N-x)), f)\n#         return f\n    \n    def bottomUp(self, K, N):\n        dp = [[i for i in range(N+1)] for _ in range(K+1)]\n        for i in range(2, K+1):\n            for j in range(1, N+1):\n                min_drops = N\n                for k in range(1, j+1):\n                    min_drops = min(min_drops, 1 + max(dp[i-1][k-1], dp[i][j-k]))\n                dp[i][j] = min_drops\n        return dp[K][N]", "import numpy as np\n\n\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        drops = 0                           # the number of eggs dropped\n        floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs\n\n        while floors[K] < N:                # until we can reach N floors with K eggs \n\n            for eggs in range(K, 0, -1):\n                floors[eggs] += 1 + floors[eggs - 1]\n            drops += 1\n\n        return drops\n    \n    \n    \n    \n", "class Solution:\n    def superEggDrop1(self, K: int, N: int) -> int: # \u8d85\u65f6\uff01\uff01\uff01\n        memo = [[2**31-1] * (N+1) for _ in range(K+1)]\n        \n        def dp(k, n):\n            if k == 0: return 0\n            if k == 1: return n\n            if n <= 1: return n\n            \n            if memo[k][n] < 2**31-1:\n                return memo[k][n]\n            \n            ans = memo[k][n]\n            for i in range(1, n+1):\n                ans = min(ans, 1+max(dp(k-1, i-1), dp(k, n-i)))\n                # \u6781\u5c0f\u6781\u5927\u8fc7\u7a0b\uff01\uff01\uff01alike\n            memo[k][n] = ans\n            return ans\n        return dp(K, N)\n    \n    # D(K-1, i-1), monotonically increasing with i\n    # D(K, N-i) is monotonically decreasing with i!\n    \n    # binary search!\n    # D(K, N) = 1 + min(max(D(K-1, i-1), D(K, N-i))), 1<=i<=N\n    # f(i) = D(K-1, i-1), f(i) is monotonically increasing with i\n    # g(i) = D(K, N-i), g(i) is monotonically decreasing with i\n    \n    # we can use binary search to find i that minimizes max(f(i), g(i))\n    #\n    # \u4e00\u4e2a\u51fd\u6570\u5355\u8c03\u589e\uff1b\u4e00\u4e2a\u51fd\u6570\u5355\u8c03\u51cf\n    # min (max (f, g))\n    # \u5c31\u53ef\u4ee5\u4f7f\u7528binary search\n    # f(i) < g(i) \u7684\u65f6\u5019\uff0c\u8bf4\u660ei\u592a\u5c0f\u4e86\uff0c\u9700\u8981\u589e\u5927i\n    # f(i) > g(i) \u7684\u65f6\u5019\uff0c\u8bf4\u660ei\u592a\u5927\u4e86\uff0c\u9700\u8981\u51cf\u5c11i\n    # \u6211\u4eec\u9700\u8981\u7684\u662ffirst i, such that f(i) >= g(i)\n    # time complexity = O(KNlogN) smaller than O(K*N*N)\n    # space is same O(KN)\n    \n    def superEggDrop(self, K: int, N: int) -> int: # \u8d85\u65f6\uff01\uff01\uff01\n        memo = [[2**31-1] * (N+1) for _ in range(K+1)]\n        \n        def dp(k, n):\n            if k == 0: return 0\n            if k == 1: return n\n            if n <= 1: return n\n            \n            if memo[k][n] < 2**31-1:\n                return memo[k][n]\n            \n            #ans = memo[k][n]\n            #for i in range(1, n+1):\n            #    ans = min(ans, 1+max(dp(k-1, i-1), dp(k, n-i)))\n                # \u6781\u5c0f\u6781\u5927\u8fc7\u7a0b\uff01\uff01\uff01alike\n            left = 1\n            right = n + 1\n            while left < right:\n                mid = left + (right - left) // 2\n                if dp(k-1, mid-1) >= dp(k, n-mid):\n                    right = mid\n                else:\n                    left = mid + 1\n            \n            memo[k][n] = 1 + max(dp(k-1, left-1), dp(k, n-left))\n            return memo[k][n]\n        return dp(K, N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp=[[float('inf')]*(N+1) for _ in range(K+1)]\n        for i in range(1, K+1):\n            dp[i][0] = 0\n            dp[i][1] = 1\n        for j in range(1, N+1):\n            dp[1][j] = j\n            \n        for i in range(2, K+1):\n            k = 1\n            for j in range(2, N+1):\n                while k < j+1 and dp[i][j-k] > dp[i-1][k-1]:\n                    k += 1\n                dp[i][j] = 1 + dp[i-1][k-1]\n        return dp[K][N]\n        \n#     def superEggDrop(self, K: int, N: int) -> int:\n#         dp = [[float('inf') for _ in range(N + 1)] for _ in range(K + 1)]\n#         for i in range(1, K + 1):\n#             dp[i][0] = 0\n#             dp[i][1] = 1\n#         for j in range(1, N + 1):\n#             dp[1][j] = j\n        \n#         for i in range(2, K + 1):\n#             for j in range(2, N + 1):\n#                 for k in range(1, j + 1):\n#                     dp[i][j] = min(dp[i][j], 1 + max(dp[i - 1][k - 1], dp[i][j - k]))\n#         return dp[-1][-1]\n", "from math import comb\n\n\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp={}\n        for i in range(N+1):\n            dp[(i,0)] = 0\n        for k in range(1,K+1):\n            dp[(1,k)] = 1\n        for k in range(1,K+1):\n            for n in range(2,N+1):\n                dp[(n,k)] = 1 + dp[(n-1),k] + dp[(n-1),k-1]\n        num = 1\n        while dp[(num,K)]<N:\n            num+=1\n        return num\n\n", "class Solution:\n    def superEggDrop(self, eggs: int, floors: int) -> int:\n        \n        dp = [[-1 for _ in range(floors+1)] for _ in range(eggs+1)]\n        \n#         int dp(int k, int n) {\n#             if (k <= 0) return 0;\n#             if (k == 1) return n;\n#             if (n <= 1) return n;\n#             if (m_[k][n] != INT_MIN) return m_[k][n];\n\n#             // broken[i]   = dp(k - 1, i - 1) is incresing with i.\n#             // unbroken[i] = dp(k,     n - i) is decresing with i.\n#             // dp[k][n] = 1 + min(max(broken[i], unbroken[i])), 1 <= i <= n\n#             // find the smallest i such that broken[i] >= unbroken[i],\n#             // which minimizes max(broken[i], unbroken[i]).\n#             int l = 1;\n#             int r = n + 1;\n#             while (l < r) {\n#               int m = l + (r - l) / 2;\n#               int broken = dp(k - 1, m - 1);\n#               int unbroken = dp(k, n - m);\n#               if (broken >= unbroken)\n#                 r = m;\n#               else\n#                 l = m + 1;\n#             }\n        \n        def search(eggs, floors):\n            if eggs <= 0:\n                return 0\n            elif eggs == 1:\n                return floors\n            elif floors <= 1:\n                return floors\n            elif dp[eggs][floors] != -1:\n                return dp[eggs][floors]\n            \n            l, r = 1, floors+1\n            while l < r:\n                mid = l + (r-l) // 2\n                broken = search(eggs-1, mid-1)\n                intact = search(eggs, floors-mid)\n                if broken < intact:\n                    l = mid + 1\n                else:\n                    r = mid\n            \n            dp[eggs][floors] = 1 + search(eggs-1, l-1)\n            return dp[eggs][floors]\n        \n        return search(eggs, floors)", "class Solution:\n    #https://leetcode.com/problems/super-egg-drop/discuss/159079/Python-DP-from-kn2-to-knlogn-to-kn\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp=[[float('inf')]*(N+1) for _ in range(K+1)]\n        for i in range(1, K+1):\n            dp[i][0] = 0\n            dp[i][1] = 1\n        for j in range(1, N+1):\n            dp[1][j] = j\n            \n        for i in range(2, K+1):\n            k = 1\n            for j in range(2, N+1):\n                while k < j+1 and dp[i][j-k] > dp[i-1][k-1]:\n                    k += 1\n                dp[i][j] = 1 + dp[i-1][k-1]\n        return dp[K][N]\n        \n#     def superEggDrop(self, K: int, N: int) -> int:\n#         dp = [[float('inf') for _ in range(N + 1)] for _ in range(K + 1)]\n#         for i in range(1, K + 1):\n#             dp[i][0] = 0\n#             dp[i][1] = 1\n#         for j in range(1, N + 1):\n#             dp[1][j] = j\n        \n#         for i in range(2, K + 1):\n#             for j in range(2, N + 1):\n#                 for k in range(1, j + 1):\n#                     dp[i][j] = min(dp[i][j], 1 + max(dp[i - 1][k - 1], dp[i][j - k]))\n#         return dp[-1][-1]\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = [[-1]*(K+1) for _ in range(N+1)]\n        @lru_cache(None)\n        def drop(egg, floor):\n            if egg==1 or floor<=1:\n                return floor\n            if memo[floor][egg]!=-1:\n                return memo[floor][egg]\n            minAttempts = float('inf')\n            l=1;h=floor\n            while l<=h:\n                mid = (l+h)//2\n                low = drop(egg-1, mid-1)\n                high = drop(egg, floor-mid)\n                attempts = 1 + max(low, high)\n                if low<high:\n                    l=mid+1\n                else:\n                    h=mid-1\n                minAttempts = min(minAttempts, attempts)\n            memo[floor][egg] = minAttempts\n            return minAttempts\n        return drop(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        def DP(k, n):\n            if (k, n) not in memo:\n                if n == 0:\n                    res = 0\n                elif k == 1:\n                    res = n\n                else:\n                    l, r = 1, n\n                    while l < r:\n                        mid = (l + r) // 2\n                        t1 = DP(k-1, mid-1)\n                        t2 = DP(k, n-mid)\n                        \n                        if t1 < t2:\n                            l = mid + 1\n                        else:\n                            r = mid\n                    \n                    res = 1 + max(DP(k-1, l-1), DP(k, n-l))\n                memo[k, n] = res\n            return memo[k, n]\n        \n        return DP(K, N)", "class Solution:\n    def superEggDrop1(self, K: int, N: int) -> int: # \u8d85\u65f6\uff01\uff01\uff01\n        memo = [[2**31-1] * (N+1) for _ in range(K+1)]\n        \n        def dp(k, n):\n            if k == 0: return 0\n            if k == 1: return n\n            if n <= 1: return n\n            \n            if memo[k][n] < 2**31-1:\n                return memo[k][n]\n            \n            ans = memo[k][n]\n            for i in range(1, n+1):\n                ans = min(ans, 1+max(dp(k-1, i-1), dp(k, n-i)))\n                # \u6781\u5c0f\u6781\u5927\u8fc7\u7a0b\uff01\uff01\uff01alike\n            memo[k][n] = ans\n            return ans\n        return dp(K, N)\n    \n    # D(K-1, i-1), monotonically increasing with i\n    # D(K, N-i) is monotonically decreasing with i!\n    \n    # binary search!\n    # D(K, N) = 1 + min(max(D(K-1, i-1), D(K, N-i))), 1<=i<=N\n    # f(i) = D(K-1, i-1), f(i) is monotonically increasing with i\n    # g(i) = D(K, N-i), g(i) is monotonically decreasing with i\n    \n    # we can use binary search to find i that minimizes max(f(i), g(i))\n    #\n    # \u4e00\u4e2a\u51fd\u6570\u5355\u8c03\u589e\uff1b\u4e00\u4e2a\u51fd\u6570\u5355\u8c03\u51cf\n    # min (max (f, g))\n    # \u5c31\u53ef\u4ee5\u4f7f\u7528binary search\n    # f(i) < g(i) \u7684\u65f6\u5019\uff0c\u8bf4\u660ei\u592a\u5c0f\u4e86\uff0c\u9700\u8981\u589e\u5927i\n    # f(i) > g(i) \u7684\u65f6\u5019\uff0c\u8bf4\u660ei\u592a\u5927\u4e86\uff0c\u9700\u8981\u51cf\u5c11i\n    # \u6211\u4eec\u9700\u8981\u7684\u662ffirst i, such that f(i) >= g(i)\n    # time complexity = O(KNlogN) smaller than O(K*N*N)\n    # space is same O(KN)\n    \n    def superEggDrop3(self, K: int, N: int) -> int: # \u4f7f\u7528binary search\uff0c\u53ef\u4ee5\u5f97\u5230\u6700\u597d\u7684\u7ed3\u679c\u4e86\uff01\n        memo = [[2**31-1] * (N+1) for _ in range(K+1)]\n        \n        def dp(k, n):\n            if k == 0: return 0\n            if k == 1: return n\n            if n <= 1: return n\n            \n            if memo[k][n] < 2**31-1:\n                return memo[k][n]\n            \n            #ans = memo[k][n]\n            #for i in range(1, n+1):\n            #    ans = min(ans, 1+max(dp(k-1, i-1), dp(k, n-i)))\n                # \u6781\u5c0f\u6781\u5927\u8fc7\u7a0b\uff01\uff01\uff01alike\n            left = 1\n            right = n + 1\n            res = 2**31-1\n            while left < right:\n                mid = left + (right - left) // 2\n                broken = dp(k-1, mid-1)\n                notbroken = dp(k, n-mid)\n                if broken >= notbroken: # f(mid) >= g(mid) \u6700\u5c0f\u7684mid!\n                    right = mid\n                    res = min(res, broken+1)\n                else:\n                    left = mid + 1\n                    res = min(res, notbroken+1)\n            \n            memo[k][n] = res #1 + max(dp(k-1, left-1), dp(k, n-left))\n            return memo[k][n]\n        return dp(K, N)\n    \n    def superEggDrop(self, K, N):\n        amax = 2**31-1\n        memo = [[amax] * (N+1) for _ in range(K+1)]\n        \n        def dp(k, n):\n            if k == 0: return 0\n            if k == 1: return n\n            if n <= 1: return n # this time k>1\n            \n            if memo[k][n] != amax:\n                return memo[k][n]\n            left = 1\n            right = n + 1\n            while left < right:\n                mid = left + (right - left)//2\n                broken = dp(k-1, mid-1)\n                notbroken = dp(k, n-mid) # mid+1 to N\n                if broken >= notbroken:\n                    right = mid\n                else:\n                    left = mid + 1\n            ans = 1 + max(dp(k-1, left-1), dp(k, n-left))\n            memo[k][n] = ans\n            return ans\n        return dp(K, N)\n    \n    def superEggDrop2(self, K: int, N: int) -> int: # \u4f7f\u7528binary search\uff0c\u5f88\u597d\u4e86\uff01\n        memo = [[2**31-1] * (N+1) for _ in range(K+1)]\n        \n        def dp(k, n):\n            if k == 0: return 0\n            if k == 1: return n\n            if n <= 1: return n\n            \n            if memo[k][n] < 2**31-1:\n                return memo[k][n]\n            \n            #ans = memo[k][n]\n            #for i in range(1, n+1):\n            #    ans = min(ans, 1+max(dp(k-1, i-1), dp(k, n-i)))\n                # \u6781\u5c0f\u6781\u5927\u8fc7\u7a0b\uff01\uff01\uff01alike\n            left = 1\n            right = n + 1\n            while left < right:\n                mid = left + (right - left) // 2\n                # broken >= not_broken\n                if dp(k-1, mid-1) >= dp(k, n-mid): # f(mid) >= g(mid) \u6700\u5c0f\u7684mid!\n                    right = mid\n                else:\n                    left = mid + 1\n            # \u901a\u8fc7binary search\u627e\u5230left\u662f\u6838\u5fc3\uff01\u627e\u6781\u503c\u70b9\uff01\n            memo[k][n] = 1 + max(dp(k-1, left-1), dp(k, n-left))\n            return memo[k][n]\n        return dp(K, N)\n    \n    def superEggDrop4(self, K, N):\n        def f(x):\n            ans = 0\n            r = 1\n            for i in range(1, K+1):\n                r *= x-i+1\n                r //= i\n                ans += r\n                if ans >= N: break\n            return ans\n        \n        # \u8fd8\u662f\u4f7f\u7528\u4e86binary search! \u901f\u5ea6\u5f88\u5feb\u554a\uff01\uff01\uff01\n        lo, hi = 1, N\n        while lo < hi:\n            mi = (lo + hi) // 2\n            if f(mi) < N:\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[0] * (K + 1) for i in range(N + 1)]\n        for m in range(1, N + 1):\n            for k in range(1, K + 1):\n                dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1\n            if dp[m][K] >= N: return m\n        return search(N, K)\n            \n                \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = dict()\n        def dp(k, n):\n            # base case\n            if k == 1:\n                return n\n            if n == 0:\n                return 0\n\n            if (k, n) in memo:\n                return memo[(k, n)]\n\n            res = float('inf')\n            # for i in range(1, n + 1):\n            #     res = min(res, max(dp(k, n - i), dp(k - 1, i - 1)) + 1)\n            # binary search\n            res = float('inf')\n            lo, hi = 1, n\n            while lo <= hi:\n                mid = lo + (hi - lo) // 2\n                broken = dp(k - 1, mid - 1)\n                not_broken = dp(k, n - mid)\n                if not_broken > broken:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n                else:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n            memo[(k, n)] = res\n            return res\n        return dp(K, N)\n", "class Solution:\n    def superEggDrop(self, e: int, f: int) -> int:\n        \n        self.cache = [[-1]*(f+1) for _ in range(e+1)]\n        \n        return self.drop(e,f)\n    \n    def drop(self,e,f):\n        \n        if f == 0 or f == 1:\n            return f\n        \n        if e == 1:\n            return f\n        \n        if self.cache[e][f] != -1:\n            return self.cache[e][f]\n        \n        ans = float('inf')\n        \n        l = 1\n        h = f\n        \n        while l <= h:\n            \n            mid = (l+h)//2\n            \n            low = 0\n            high = 0\n            \n            if self.cache[e-1][mid-1] != -1:\n                low = self.cache[e-1][mid-1]\n            else:\n                low = self.drop(e-1,mid-1)\n            \n            if self.cache[e][f-mid] != -1:\n                high = self.cache[e][f-mid]\n            else:\n                high = self.drop(e,f-mid)\n            \n            if low < high:\n                \n                l = mid + 1\n                \n            else:\n                \n                h = mid -1\n            ans = min(max(low,high)+1,ans)\n            \n        \n#         for k in range(1,f+1):\n            \n#             low = 0\n#             high = 0\n            \n#             if self.cache[e-1][k-1] != -1:\n#                 low = self.cache[e-1][k-1]\n#             else:\n#                 low = self.drop(e-1,k-1)\n            \n#             if self.cache[e][f-k] != -1:\n#                 high = self.cache[e][f-k]\n#             else:\n#                 high = self.drop(e,f-k)\n            \n#             ans = min(max(low,high)+1,ans)\n            \n        self.cache[e][f] = ans\n            \n        return ans\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        def dfs(k, n):\n            if k == 1:\n                # Only one egg, start from floor.\n                return n\n            if n <= 1:\n                return n\n            if (k, n) in memo:\n                return memo[(k, n)]\n            \n            l, r = 0, n\n            \n            while l < r:\n                mid = l + (r - l) // 2\n                left_cnt = dfs(k-1, mid-1)\n                right_cnt = dfs(k, n-mid)\n                if left_cnt < right_cnt:\n                    l = mid + 1\n                else:\n                    r = mid\n            \n            memo[(k, n)] = 1 + max(dfs(k-1, l-1), dfs(k, n-l))\n            return memo[(k, n)]\n        \n        return dfs(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # https://leetcode.com/problems/super-egg-drop/discuss/443089/Simplest-Python-DP-Solution-with-Detailed-Explanation-99Time-100Mem\n        # M x K --> Given M moves and K eggs, what is the maximum floor we can check ?\n        # M = 300 # big enough number\n        # dp = [[0 for j in range(K+1)] for i in range(M+1)]\n        # # Initialization 1 --> no move no floor --> dp[0][*] = 0\n        # # Initialization 2 --> no egg no floor --> dp[*][0] = 0\n        # # General case --> we want to find dp[m][k] --> we pick one egg and drop (1 move)\n        # #              --> now we have k or k-1 eggs, depending on whether the previous egg is broken\n        # #              --> so in either case, we can at least sum up 1 (first move) + dp[m-1][k] + dp[m-1][k-1] \n        # for i in range(1, M+1):\n        #     for j in range(1, K+1):\n        #         dp[i][j] = 1 + dp[i-1][j] + dp[i-1][j-1]\n        #         if dp[i][j] >= N:\n        #             return i\n        memo = dict()    \n        def dp(K, N):\n            if K == 1:\n                return N\n            if N == 0:\n                return 0\n            if (K, N) in memo:\n                return memo[(K, N)]\n            # res = float('inf')\n            low, high = 1, N + 1\n            while low < high:\n                mid = (low + high)//2\n                broken = dp(K-1, mid -1)\n                notBroken = dp(K, N-mid)\n                if broken >= notBroken:\n                    high = mid\n                    # res = min(broken + 1, res)\n                else:\n                    low = mid + 1\n                    # res = min(notBroken + 1, res)\n            memo[(K,N)] = 1 + max(dp(K-1, low -1), dp(K, N-low))\n            return memo[(K,N)]\n        return dp(K, N)\n            \n                \n            \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        \n        def dp(k, n):\n            if k <= 0: return 0\n            if k == 1: return n\n            if n <= 1: return n\n            if (k,n) in memo:\n                return memo[(k,n)]\n            l, r = 1, n+1\n            while l < r:\n                mid = l + (r-l) //2\n                broken = dp(k - 1, mid - 1)\n                unbroken = dp(k, n - mid)\n                if broken >= unbroken:\n                    r = mid\n                else:\n                    l = mid + 1\n            memo[(k,n)] = 1 + dp(k - 1, l - 1)\n            return memo[(k,n)]\n           \n        return dp(K, N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        def dfs(k, n):\n            if k == 1:\n                return n\n            if n <= 1:\n                return n\n            if (k, n) in memo:\n                return memo[(k, n)]\n            \n            l, r = 0, n\n            while l < r:\n                mid = l + (r - l) // 2\n                left_num, right_num = dfs(k-1, mid-1), dfs(k, n-mid)\n                if right_num > left_num:\n                    l = mid + 1\n                else:\n                    r = mid\n            memo[(k, n)] = 1 + max(dfs(k-1, l-1), dfs(k, n-l))\n            return memo[(k, n)]\n        \n        memo = {}\n        return dfs(K, N)\n", "# More specifically, to get the k that best fits each drop, we don't need to go over all floors from 1 to j. \n# As for a fixed k, dp[i][k] goes up as k increases. This means dp[i-1][k-1] will increase and dp[i][j-k] will\n# decrease as k goes from 1 to j. The optimal value of k will be the middle point where the two meet. So to \n# get the optimal k value for dp[i][j], we can do a binary search for k from 1 to j.\n\n\n\nclass Solution(object):\n    def superEggDrop(self, K, N):\n        def dfs(i, j):\n            if i==1:\n                return j\n            if j==0:\n                return 0\n            if j==1:\n                return 1\n            if (i, j) in d:\n                return d[i, j]\n            lo, hi = 0, j\n            while lo < hi:\n                mid = (lo+hi)//2\n                left, right = dfs(i-1, mid-1), dfs(i, j-mid)\n                # print(mid, left, right)\n                if left < right:\n                    lo = mid + 1\n                else:\n                    hi = mid\n            res = 1 + max(dfs(i-1, lo-1), dfs(i, j-lo))\n            d[i, j]=res\n            return res\n        \n        d={}\n        return dfs(K, N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n\n        # dp[i] represents dp(1, i)\n        dp = range(N + 1)\n\n        for k in range(2, K + 1):\n            # dp2 represents dp(k, i)\n            dp2 = [0]\n            A = 1\n\n            for n in range(1, N + 1):\n                costA = max(dp[A - 1], dp2[n - A])\n                while A < n:\n                    B = A + 1\n                    costB = max(dp[B - 1], dp2[n - B])\n                    if costB > costA:\n                        break\n                    costA = costB\n                    A += 1\n                dp2.append(1 + costA)\n            dp = dp2\n\n        return dp[-1]", "class Solution:\n    \n    def eggDrop(self,floors,eggs,m):\n        if floors<=1:\n            return floors \n        if eggs == 1:\n            return floors \n        if (floors,eggs) in m:\n            return m[(floors,eggs)]\n\n        l,h = 0,floors\n        \n        while l<h:\n            mid = (l+h)>>1\n            kelge,mele = self.eggDrop(mid-1,eggs-1,m) , self.eggDrop(floors-mid,eggs,m)\n            if kelge>=mele:\n                h = mid\n            else:\n                l = mid+1\n        drops = 1 + max(self.eggDrop(l-1,eggs-1,m),self.eggDrop(floors-l,eggs,m))\n        m[(floors,eggs)] = drops\n        \n        return drops\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        return self.eggDrop(N,K,{})\n", "class Solution:\n    def superEggDrop(self, eggs: int, floors: int) -> int:\n        building = [[0] * (eggs+1) for _ in range(floors+1)]\n        currFloor = 0\n        \n        while building[currFloor][eggs] < floors:\n            currFloor += 1\n            for i in range(1 , eggs+1):\n                building[currFloor][i] = building[currFloor-1][i-1] + building[currFloor-1][i] + 1\n                \n        return currFloor", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n\n        dp = {}\n        def num_moves(n, k):\n            if (n, k) not in dp:\n                if n == 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    left = 1\n                    right = n + 1\n                    while left < right:\n                        floor = (left + right) // 2\n                        safe_moves = num_moves(n - floor, k)\n                        unsafe_moves = num_moves(floor - 1, k - 1)\n                        if safe_moves > unsafe_moves:\n                            left = floor + 1\n                        else:\n                            right = floor\n\n                    floor = left\n                    safe_moves = num_moves(n - floor, k)\n                    unsafe_moves = num_moves(floor - 1, k - 1)\n                    nk_moves = max(safe_moves, unsafe_moves) + 1\n\n                    if floor > 1:\n                        prev_floor = left - 1\n                        prev_safe_moves = num_moves(n - prev_floor, k)\n                        prev_unsafe_moves = num_moves(prev_floor - 1, k - 1)\n                        prev_nk_moves = max(prev_safe_moves, prev_unsafe_moves) + 1\n                        nk_moves = min(nk_moves, prev_nk_moves)\n                    ans = nk_moves\n                dp[(n, k)] = ans\n            return dp[(n, k)]\n        return num_moves(N, K)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = {}\n        def num_moves(n, k):\n            if (n, k) not in dp:\n                if n == 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    left = 1\n                    right = n + 1\n                    while left < right:\n                        floor = (left + right) // 2\n                        safe_moves = num_moves(n - floor, k)\n                        unsafe_moves = num_moves(floor - 1, k - 1)\n                        if safe_moves > unsafe_moves:\n                            left = floor + 1\n                        else:\n                            right = floor\n\n                    floor = left\n                    safe_moves = num_moves(n - floor, k)\n                    unsafe_moves = num_moves(floor - 1, k - 1)\n                    nk_moves = max(safe_moves, unsafe_moves) + 1\n\n                    if floor > 1:\n                        prev_floor = left - 1\n                        prev_safe_moves = num_moves(n - prev_floor, k)\n                        prev_unsafe_moves = num_moves(prev_floor - 1, k - 1)\n                        prev_nk_moves = max(prev_safe_moves, prev_unsafe_moves) + 1\n                        nk_moves = min(nk_moves, prev_nk_moves)\n                    ans = nk_moves\n                dp[(n, k)] = ans\n            return dp[(n, k)]\n        return num_moves(N, K)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = dict()\n        \n        def dp(K, N):\n            if (K, N) in memo:\n                return memo[(K,N)]\n            \n            if K == 1:\n                return N\n            if N == 0:\n                return 0\n            \n            res = sys.maxsize\n            \n            # for i in range(1, N + 1):\n            #     res = min(res, max(dp(K - 1, i - 1), dp(K, N - i)) + 1)\n            lo, hi = 1, N\n            while lo <= hi:\n                mid = int(lo + (hi - lo) / 2)\n                broken = dp(K - 1, mid - 1)\n                not_broken = dp(K, N - mid)\n                \n                if broken < not_broken:\n                    lo = mid + 1\n                    res = min(not_broken + 1, res)\n                else:\n                    hi = mid - 1\n                    res = min(broken + 1, res)\n            \n            memo[(K, N)] = res\n            \n            return res\n        \n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        def dfs(e, f):\n            if e == 1:\n                return f\n            \n            if f == 0 or f == 1:\n                return f\n            \n            if (e, f) in cache:\n                return cache[(e, f)]\n            \n            left, right = 1, f + 1\n            \n            while left < right:\n                mid = left + (right - left) // 2\n                \n                i, j = dfs(e - 1, mid - 1), dfs(e, f - mid)\n                \n                if i < j:\n                    left = mid + 1\n                else:\n                    right = mid\n                \n            cache[(e, f)] = 1 + max(dfs(e - 1, left - 1), dfs(e, f - left))\n            return cache[(e, f)]\n        \n        cache = dict()\n        return dfs(K, N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        results = [[None for _ in range(N+1)] for _ in range(K+1)]\n        def dp(K, N):\n            if K == 1:\n                return N\n            if N == 0:\n                return 0\n            \n            if results[K][N]:\n                return results[K][N]\n            \n            \n            res = N\n            \n            left = 1\n            right = N\n            \n            while left <= right:\n                mid = int((right+left)/2)\n                \n                broken_num = dp(K-1, mid-1)\n                notbroken_num = dp(K, N-mid)\n                if broken_num > notbroken_num:\n                    right = mid - 1\n                    res = min(res, broken_num + 1)\n                else:\n                    left = mid + 1\n                    res = min(res, notbroken_num + 1)\n            \n            results[K][N] = res\n            # for i in range(1, N+1):\n            #     results[K][N] = min(results[K][N], max(dp(K-1, i-1), dp(K, N-i)) + 1)\n            \n            # return results[K][N]\n            return res\n        # dp(K, N)\n        # print(results)\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = [[-1]*(K+1) for _ in range(N+1)]\n        def drop(egg, floor):\n            if egg==1 or floor<=1:\n                return floor\n            if memo[floor][egg]!=-1:\n                return memo[floor][egg]\n            minAttempts = float('inf')\n            l=1;h=floor\n            while l<=h:\n                mid = (l+h)//2\n                low = drop(egg-1, mid-1)\n                high = drop(egg, floor-mid)\n                attempts = 1 + max(low, high)\n                if low<high:\n                    l=mid+1\n                else:\n                    h=mid-1\n                minAttempts = min(minAttempts, attempts)\n            memo[floor][egg] = minAttempts\n            return minAttempts\n        return drop(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[0]*(N+1) for _ in range(K+1)]\n        for i in range(1, N+1):\n            dp[1][i] = i\n        for i in range(2, K+1):\n            s = 1\n            for j in range(1, N+1):\n                dp[i][j] = j\n                while s<j and dp[i][j-s]>dp[i-1][s-1]:\n                    s += 1\n                dp[i][j] = min(dp[i][j], max(dp[i][j-s], dp[i-1][s-1])+1)\n\n\n        return dp[K][N]\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        num_moves = [n for n in range(N + 1)]\n\n        for k in range(2, K + 1):\n            next_num_moves = [0 for _ in range(N + 1)]\n            floor = 1\n            for n in range(1, N + 1):\n                safe_moves = next_num_moves[n - floor]\n                unsafe_moves = num_moves[floor - 1]\n                nk_moves = 1 + max(safe_moves, unsafe_moves)\n                while floor < N:\n                    next_floor = floor + 1\n                    next_safe_moves = next_num_moves[n - next_floor]\n                    next_unsafe_moves = num_moves[next_floor - 1]\n                    next_nk_moves = 1 + max(next_safe_moves, next_unsafe_moves)\n                    if next_nk_moves < nk_moves:\n                        floor = next_floor\n                        nk_moves = next_nk_moves\n                    else:\n                        break\n                next_num_moves[n] = nk_moves\n            num_moves = next_num_moves\n        return num_moves[N]\n", "\nfrom math import inf\nfrom typing import List\n\nclass Solution:\n\n    def superEggDrop(self, K: int, N: int) -> int:\n        self.memo = {}\n        return self.rec(K, N)\n\n\n    def rec(self, i, j):\n        if i == 1:\n            return j\n        if j == 0 or j == 1:\n            return j\n        if (i, j) in self.memo:\n            return self.memo[i, j]\n        lo, hi = 0, j\n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            left, right = self.rec(i - 1, mid - 1), self.rec( i, j - mid)\n            if left < right:\n                lo = mid + 1\n            else:\n                hi = mid\n        res = 1 + self.max(self.rec(i - 1, lo - 1), self.rec(i, j - lo))\n        self.memo[i, j] = res\n        return res \n        \n\n    def dp(self, K: int, N: int) -> int:\n        #dp[i][j] - i eggs for j floors\n        dp = [[inf for _ in range(N + 1)] for _ in range(K + 1)]\n        #dp[i][0] -> 0, dp[1][j] -> j, dp[i][1] -> 1\n        for i in range(K + 1):\n            dp[i][0] = 0\n            dp[i][1] = 1\n        for j in range(N + 1):\n            dp[1][j] = j\n\n        for i in range(2, K + 1):\n            for j in range(2, N + 1):\n                left, right = 0, j\n                while left < right:\n                    mid = left + (right - left) // 2\n                    if dp[i - 1][mid - 1] < dp[i][j - mid]:\n                        left = mid + 1\n                    else:\n                        right = mid \n                dp[i][j] = 1 + self.max(dp[i - 1][left - 1], dp[i][j - left])\n                #for k in range(i, j + 1):\n                #    dp[i][j] = self.min(dp[i][j] , 1 + self.max(dp[i - 1][k - 1], dp[i][j - k])\n        \n        return dp[K][N] \n\n    def min(self, a, b):\n        return a if a < b else b\n    def max(self, a, b):\n        return a if a > b else b\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        table = dict()\n        def dp(K: int, N: int) -> int:\n            if (K == 1) : return N\n            if (N <= 0) : return 0\n            \n            if (K, N) in table: return table[(K, N)];\n            lo = 1\n            hi = N\n            while (lo <= hi):\n                mid = lo + (hi - lo) // 2\n                up = dp(K, N - mid)\n                dn = dp(K-1, mid-1)\n                if (up >= dn): \n                    lo = mid + 1\n                else: \n                    hi = mid - 1\n            table[(K, N)] = 1 + min(dp(K, N - hi), dp(K - 1, lo - 1))\n            return table[(K, N)]\n        return dp(K, N)\n        \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = [[0] * (K + 1) for _ in range(N + 1)]\n        for m in range(1, N + 1):\n            for k in range(1, K + 1):\n                memo[m][k] = memo[m - 1][k - 1] + 1 + memo[m - 1][k]\n                if memo[m][k] >= N: return m ", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        def dp(k, n):\n            if k == 1:\n                return n\n            if n == 0:\n                return 0\n            if (k, n) in memo:\n                return memo[(k, n)]\n            \n            res = sys.maxsize\n            lo, hi = 1, n\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dp(k - 1, mid - 1) \n                safe = dp(k, n - mid) \n                if broken > safe:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, safe + 1)\n                    \n            memo[(k, n)] = res\n            return res\n        \n        memo = {}\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        def dp(k, n):\n            if k == 1:\n                return n\n            if n == 0:\n                return 0\n            if (k, n) in memo:\n                return memo[(k, n)]\n            \n            res = sys.maxsize\n            lo, hi = 1, n\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dp(k - 1, mid - 1) # \u788e \n                not_broken = dp(k, n - mid) # \u6ca1\u788e # res = min(max(\u788e\uff0c\u6ca1\u788e) + 1)\n                if broken > not_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n                    \n            memo[(k, n)] = res\n            return res\n        \n        memo = {}\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        cache = {}\n        def drop(egg, floor):\n            if egg==1 or floor<=1:\n                return floor\n            if (egg, floor) in cache:\n                return cache[(egg, floor)]\n            minAttempts = float('inf')\n            l=1;h=floor\n            while l<=h:\n                mid = (l+h)//2\n                low = drop(egg-1, mid-1)\n                high = drop(egg, floor-mid)\n                attempts = 1 + max(low, high)\n                if low<high:\n                    l=mid+1\n                else:\n                    h=mid-1\n                minAttempts = min(minAttempts, attempts)\n            cache[(egg, floor)] = minAttempts\n            return minAttempts\n        return drop(K, N)", "class Solution(object):\n    def superEggDrop(self, K, N):\n        memo = {}\n        def dp(K, N):\n            if K == 1: return N\n            if N == 0: return 0\n            if (K, N) in memo:\n                return memo[(K, N)]\n            res = float('INF')\n            lo, hi = 1, N\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dp(K - 1, mid - 1)\n                not_broken = dp(K, N - mid)\n                if broken > not_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n            \n            memo[(K, N)] = res\n            return res\n\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        table = dict()\n        def dp(K: int, N: int) -> int:\n            if (K == 1) : return N\n            if (N <= 0) : return 0\n            \n            if (K, N) in table: return table[(K, N)];\n            lo, hi = 1, N\n            res = N\n            while (lo <= hi):\n                mid = lo + (hi - lo) // 2\n                up = dp(K, N - mid)\n                dn = dp(K-1, mid-1)\n                if (up >= dn): \n                    lo = mid + 1\n                    res = min(res, 1 + up)\n                else: \n                    hi = mid - 1\n                    res = min(res, 1 + dn)\n            table[(K, N)] = res\n            return res\n        return dp(K, N)\n        \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        def dp(K, N):\n            if K == 1: return N\n            if N == 0: return 0\n            \n            if (K, N) in memo:\n                return memo[(K,N)]\n        \n            res = float('inf')\n            lo, hi = 1, N\n            \n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dp(K -1, mid - 1)\n                not_broken = dp(K, N - mid)\n                \n                if broken > not_broken:\n                    hi = mid -1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n            # for i in range(1, N+1):\n            #     res = min(res, max(dp(K-1, i -1), dp(K, N - i)) + 1)\n            \n            memo[(K,N)] = res\n            return res\n            \n        return dp(K, N)\n            \n        \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # dp[K][N] = min_X(max(dp[K-1][X-1], dp[K][N-X]))\n        dp = [[sys.maxsize for i in range(N+1)] for j in range(K+1)]\n        \n        def DP(k, n):\n            if k < 0 or n < 0: return 0\n            if k == 0: return 0\n            if k == 1: return n\n            if n == 0: return 0\n            if n == 1: return 1\n            \n            if dp[k][n] != sys.maxsize:\n                return dp[k][n]\n            \n            # find the minimal dp[k][n]\n            l = 0\n            r = n\n            while (l < r):\n                m = (l+r) // 2\n                if DP(k-1, m-1) >= DP(k, n-m):\n                    r = m\n                else:\n                    l = m+1\n            \n            dp[k][n] = 1+max(DP(k-1, l-1), DP(k, n-l))\n            return dp[k][n]\n        \n        return DP(K, N)\n            \n        \n        \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # K=1, moves=N\n        # K>=2, moves=max(dfs(K-1, i - 1), dfs(K, N - i))\n        \n        def dfs(k, n, memo):\n            \n            if k == 1:\n                return n\n            if n == 0:\n                return 0\n            if (k, n) in memo:\n                return memo[(k, n)]\n            \n            res = float('inf')\n            # for i in range(1, n+1):\n            #     res = min(res, max(dfs(k-1, i-1, memo), dfs(k, n-i, memo)) + 1)\n            \n            lo, hi = 1, n\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dfs(k-1, mid-1, memo)\n                no_broken = dfs(k, n-mid, memo)\n                if broken > no_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, no_broken + 1)\n            memo[(k, n)] = res\n            return res\n        return dfs(K, N, {})", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        def dp(k, n):\n            if (k, n) not in memo:\n                if n == 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    lo, hi = 1, n\n                    # keep a gap of 2 X values to manually check later\n                    while lo < hi:\n                        x = (lo + hi) // 2\n                        t1 = dp(k-1, x-1)\n                        t2 = dp(k, n-x)\n\n                        if t1 < t2:\n                            lo = x + 1\n                        else:\n                            hi = x\n\n                    ans = 1 + min(max(dp(k-1, x-1), dp(k, n-x))\n                                  for x in (lo, hi))\n\n                memo[k, n] = ans\n            return memo[k, n]\n\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        def f(x):\n            ans = 0\n            r = 1\n            for i in range(1, K+1):\n                r *= (x-i+1)/i\n                #r //= i\n                ans += r\n                if ans >= N: break\n            return ans\n\n        low, high = 1, N\n        while low < high:\n            middle = (low + high) // 2\n            if f(middle) < N:\n                low = middle + 1\n            else:\n                high = middle\n        return low\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n#         # brutal force - time O(kn^2); space O(kn)\n#         dp = [[float('inf')] * (N+1) for _ in range(K+1)]\n#         for egg_num in range(1, K+1):\n#             dp[egg_num][0] = 0\n#             dp[egg_num][1] = 1\n#         for floor_num in range(1, N+1):\n#             dp[1][floor_num] = floor_num\n        \n#         for egg_num in range(2, K+1):\n#             for floor_num in range(2, N+1):\n#                 for start_floor in range(1, floor_num+1):\n#                     dp[egg_num][floor_num] = min(dp[egg_num][floor_num], 1+max(dp[egg_num-1][start_floor-1], dp[egg_num][floor_num-start_floor]))\n#         print(dp)\n#         return dp[K][N]\n    \n        # time - O(nk) for declare and O(klogn) for running; space O(nk)\n        dp = [[0] * (K+1) for _ in range(N+1)]\n        for m in range(1, N+1):\n            for k in range(1, K+1):\n                dp[m][k] = dp[m-1][k-1] + dp[m-1][k] + 1\n            if dp[m][K] >= N:\n                return m", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        dp_dict = dict()\n        \n        def dp(K, N):\n            if K == 1:\n                return N\n            if N == 0:\n                return 0\n            if (K, N) in dp_dict:\n                return dp_dict[(K, N)]\n            ans = inf\n            \n            # # normal\n            # for i in range(1, N+1):\n            #     ans = min(ans, max(dp(K-1, i-1), dp(K,N-i))+1)\n            # dp_dict[(K, N)] = ans\n            # return ans\n            \n            # binary\n            low, high = 1, N\n            while low <= high:\n                mid = (high + low) // 2\n                broken = dp(K-1, mid-1)\n                good = dp(K, N-mid)\n                if broken > good:\n                    high = mid - 1\n                    ans = min(broken+1, ans)\n                else:\n                    low = mid + 1\n                    ans = min(good+1, ans)\n            dp_dict[(K, N)] = ans\n            return ans\n            \n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # https://leetcode.com/problems/super-egg-drop/discuss/443089/Simplest-Python-DP-Solution-with-Detailed-Explanation-99Time-100Mem\n        # M x K --> Given M moves and K eggs, what is the maximum floor we can check ?\n        # M = 300 # big enough number\n        # dp = [[0 for j in range(K+1)] for i in range(M+1)]\n        # # Initialization 1 --> no move no floor --> dp[0][*] = 0\n        # # Initialization 2 --> no egg no floor --> dp[*][0] = 0\n        # # General case --> we want to find dp[m][k] --> we pick one egg and drop (1 move)\n        # #              --> now we have k or k-1 eggs, depending on whether the previous egg is broken\n        # #              --> so in either case, we can at least sum up 1 (first move) + dp[m-1][k] + dp[m-1][k-1] \n        # for i in range(1, M+1):\n        #     for j in range(1, K+1):\n        #         dp[i][j] = 1 + dp[i-1][j] + dp[i-1][j-1]\n        #         if dp[i][j] >= N:\n        #             return i\n        memo = dict()    \n        def dp(K, N):\n            if K == 1:\n                return N\n            if N == 0:\n                return 0\n            if (K, N) in memo:\n                return memo[(K, N)]\n            res = float('inf')\n            low, high = 1, N+1\n            while low < high:\n                mid = (low + high)//2\n                broken = dp(K-1, mid -1)\n                notBroken = dp(K, N-mid)\n                if broken > notBroken:\n                    high = mid\n                    res = min(broken + 1, res)\n                else:\n                    low = mid + 1\n                    res = min(notBroken + 1, res)    \n            # for i in range(1, N+1):\n            #     res = min(res, \\\\\n            #               max(dp(K-1, i-1), dp(K, N-i))+ 1)\n            memo[(K,N)] = res\n            return res\n        return dp(K, N)\n            \n                \n            \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        DP = range(N + 1)\n        for k in range(2, K + 1):\n            DP2 = [0]\n            x = 1\n            for n in range(1, N+1):\n                while x < n and max(DP[x-1], DP2[n - x]) > max(DP[x], DP2[n - x - 1]):\n                    x += 1\n                    \n                DP2.append(1 + max(DP[x-1], DP2[n - x]))\n            \n            DP = DP2\n            \n        return DP[-1]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo={}\n        def dp(K,N):\n            if K==1:\n                return N\n            if N==0:\n                return 0\n            if (K,N) in memo:\n                return memo[(K,N)]\n            res=float('inf')\n            l,h=1,N\n            while l<=h:\n                mid=(l+h)//2\n                broken=dp(K-1,mid-1)\n                not_broken=dp(K,N-mid)\n                if broken>not_broken:\n                    h=mid-1\n                    res=min(res,1+broken)\n                else:\n                    l=mid+1\n                    res=min(res,1+not_broken)\n            memo[(K,N)]=res        \n            return res\n        return dp(K,N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        \n        def dp(K, N):\n            if K == 1:\n                return N\n            if N == 0:\n                return 0\n            \n            if (K, N) in memo:\n                return memo[(K, N)]\n            \n            res = float('inf')\n            \n            lo, hi = 1, N\n            \n            while lo <= hi:\n                mid = lo + (hi - lo) // 2\n                broken = dp(K-1, mid - 1)\n                not_broken = dp(K, N - mid)\n                \n                if broken > not_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n            \n            # for i in range(1, N+1):\n            #     res = min(res,\n            #              max(\n            #                  dp(K, N-i), \n            #                  dp(K-1, i-1)\n            #                 ) + 1\n            #              )\n            \n            memo[(K, N)] = res\n            \n            return res\n        \n        return dp(K, N)", "# K and N is suitation\n# choice: need to choose drop egg on which floor\n# use binary search to optimize complexity\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        def dp(K: int, N: int):\n            # base case\n            if N == 0:\n                return 0\n            if K == 1:\n                return N\n            if (K, N) in memo:\n                return memo[(K, N)]\n            res = float('inf')\n            lo, hi = 1, N\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dp(K - 1, mid - 1)\n                not_broken = dp(K, N - mid)\n                if broken > not_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n\n            memo[(K, N)] = res\n            return res\n        return dp(K, N)\n\n\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo={}\n    \n        def dp(k, n):\n            if n==0:\n                return 0\n            if k==1:\n                return n\n            if (k,n) in memo:\n                return memo[(k,n)]\n            res=float('inf')\n            lo=1\n            hi=n\n            while lo<=hi:\n                mid=(lo+hi)//2\n                broken=dp(k-1,mid-1)\n                not_broken=dp(k,n-mid)\n                if broken>not_broken:\n                    hi=mid-1\n                    res=min(res,broken+1)\n                else:\n                    lo=mid+1\n                    res=min(res,not_broken+1)\n            # for i in range(1,n+1):\n            #     res=min(res,max(dp(k-1,i-1), dp(k,n-i))+1)\n            memo[(k,n)]=res\n            return res\n        return dp(K,N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n\n        memo = dict()\n        def dp(K, N):\n            if K == 1: return N\n            if N == 0: return 0\n            if (K, N) in memo:\n                return memo[(K, N)]\n\n            # for 1 <= i <= N:\n            #     res = min(res, \n            #             max( \n            #                 dp(K - 1, i - 1), \n            #                 dp(K, N - i)      \n            #                 ) + 1 \n            #             )\n\n            res = float('INF')\n            # \u7528\u4e8c\u5206\u641c\u7d22\u4ee3\u66ff\u7ebf\u6027\u641c\u7d22\n            lo, hi = 1, N\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dp(K - 1, mid - 1) # \u788e\n                not_broken = dp(K, N - mid) # \u6ca1\u788e\n                # res = min(max(\u788e\uff0c\u6ca1\u788e) + 1)\n                if broken > not_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n\n            memo[(K, N)] = res\n            return res\n\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        t = [[0]*(K+1) for _ in range(N+1)]\n        for i in range(1,N+1):\n            for j in range(1,K+1):\n                t[i][j] = t[i-1][j] + t[i-1][j-1] + 1\n                \n            if t[i][j] >= N:\n                return i", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo={}\n        \n        def dp(k,n):\n            if k==1:\n                return n\n            if n==0:\n                return 0\n            if (k,n) in memo:\n                return memo[(k,n)]\n            \n            res=float('INF')\n            lo, hi = 1, n\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dp(k - 1, mid - 1) # \u788e\n                not_broken = dp(k, n - mid) # \u6ca1\u788e\n                # res = min(max(\u788e\uff0c \u6ca1\u788e) + 1)\n                if broken > not_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n            \n            memo[(k,n)]=res\n            return res\n        \n        return dp(K,N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # https://leetcode.com/problems/super-egg-drop/discuss/443089/Simplest-Python-DP-Solution-with-Detailed-Explanation-99Time-100Mem\n        # M x K --> Given M moves and K eggs, what is the maximum floor we can check ?\n        # M = 300 # big enough number\n        # dp = [[0 for j in range(K+1)] for i in range(M+1)]\n        # # Initialization 1 --> no move no floor --> dp[0][*] = 0\n        # # Initialization 2 --> no egg no floor --> dp[*][0] = 0\n        # # General case --> we want to find dp[m][k] --> we pick one egg and drop (1 move)\n        # #              --> now we have k or k-1 eggs, depending on whether the previous egg is broken\n        # #              --> so in either case, we can at least sum up 1 (first move) + dp[m-1][k] + dp[m-1][k-1] \n        # for i in range(1, M+1):\n        #     for j in range(1, K+1):\n        #         dp[i][j] = 1 + dp[i-1][j] + dp[i-1][j-1]\n        #         if dp[i][j] >= N:\n        #             return i\n        memo = dict()    \n        def dp(K, N):\n            if K == 1:\n                return N\n            if N == 0:\n                return 0\n            if (K, N) in memo:\n                return memo[(K, N)]\n            res = float('inf')\n            low, high = 1, N\n            while low <= high:\n                mid = (low + high)//2\n                broken = dp(K-1, mid -1)\n                notBroken = dp(K, N-mid)\n                if broken > notBroken:\n                    high = mid -1\n                    res = min(broken + 1, res)\n                else:\n                    low = mid + 1\n                    res = min(notBroken + 1, res)\n            # res = float('inf')\n            # low, high = 1, N+1\n            # while low < high:\n            #     mid = (low + high)//2\n            #     broken = dp(K-1, mid -1)\n            #     notBroken = dp(K, N-mid)\n            #     if broken > notBroken:\n            #         high = mid\n            #         res = min(broken + 1, res)\n            #     else:\n            #         low = mid + 1\n            #         res = min(notBroken + 1, res)    \n            # for i in range(1, N+1):\n            #     res = min(res, \\\\\n            #               max(dp(K-1, i-1), dp(K, N-i))+ 1)\n            memo[(K,N)] = res\n            return res\n        return dp(K, N)\n            \n                \n            \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = dict()\n        def dp(K, N):\n            if K == 1: return N\n            if N == 0: return 0\n            if (K, N) in memo:\n                return memo[(K, N)]\n            \n            res = float('INF')\n\n            lo, hi = 1, N\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dp(K - 1, mid - 1)\n                not_broken = dp(K, N - mid) \n                if broken > not_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n\n            memo[(K, N)] = res\n            return res\n\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n\n        memo = dict()\n        def dp(K, N):\n            if K == 1: return N\n            if N == 0: return 0\n            if (K, N) in memo:\n                return memo[(K, N)]\n\n            res = float('INF')\n            # \u7528\u4e8c\u5206\u641c\u7d22\u4ee3\u66ff\u7ebf\u6027\u641c\u7d22\n            lo, hi = 1, N\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dp(K - 1, mid - 1) # \u788e\n                not_broken = dp(K, N - mid) # \u6ca1\u788e\n                # res = min(max(\u788e\uff0c\u6ca1\u788e) + 1)\n                if broken > not_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n\n            memo[(K, N)] = res\n            return res\n\n        return dp(K, N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n\n        memo = dict()\n        def dp(K, N):\n            if K == 1: return N\n            if N == 0: return 0\n            if (K, N) in memo:\n                return memo[(K, N)]\n\n            # for 1 <= i <= N:\n            #     res = min(res, \n            #             max( \n            #                 dp(K - 1, i - 1), \n            #                 dp(K, N - i)      \n            #                 ) + 1 \n            #             )\n\n            res = float('INF')\n            # \u7528\u4e8c\u5206\u641c\u7d22\u4ee3\u66ff\u7ebf\u6027\u641c\u7d22\n            lo, hi = 1, N\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dp(K - 1, mid - 1) # \u788e\n                not_broken = dp(K, N - mid) # \u6ca1\u788e\n                # res = min(max(\u788e\uff0c\u6ca1\u788e) + 1)\n                if broken > not_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n\n            memo[(K, N)] = res\n            return res\n\n        return dp(K, N)\n", "# K and N is suitation\n# choice: need to choose drop egg on which floor\n# use binary search to optimize complexity\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        def dp(k: int, n: int):\n            # base case\n            if n == 0:\n                return 0\n            if k == 1:\n                return n\n            if (k, n) in memo:\n                return memo[(k, n)]\n            lo = 1\n            hi = n\n            res = float('inf')\n            # we use binary search to speedup the process\n            while lo <= hi:\n                mid = (lo + hi) // 2\n                broken = dp(k - 1, mid - 1)\n                not_broken = dp(k, n - mid)\n                if broken > not_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                else:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n            # write into memo\n            memo[(k, n)] = res\n            return res\n        return dp(K, N)\n\n\n\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        def dp(K, N):\n            if N == 0:\n                return 0\n            if K == 1:\n                return N\n            \n            if (K, N) in memo:\n                return memo[(K, N)]\n            \n            res = float('INF')\n            \n            # for i in range(1, N+1):\n            #     res = min(res, max(dp(K-1, i-1),  dp(K, N-i))+1)\n            \n            lo, hi = 1, N\n            \n            while(lo <= hi):\n                mid = lo + (hi - lo)//2\n                broken = dp(K-1, mid-1)\n                unbroken = dp(K, N - mid)\n                if broken > unbroken:\n                    hi = mid - 1\n                    res = min(res, broken+1)\n                else:\n                    lo = mid + 1\n                    res = min(res, unbroken+1)\n            \n            memo[(K, N)] = res\n            return res\n        return dp(K, N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # memo = {(1, n) : n for n in range(1, N + 1)}\n        dp = [[0]*(K + 1) for _ in range(N + 1)]\n        \n        for m in range(1, N + 1):\n            for k in range(1, K + 1):\n                dp[m][k] = max(dp[m][k], dp[m - 1][k] + 1 + dp[m - 1][k - 1])\n            if dp[m][k] >= N:\n                return m", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[None] * K for _ in range(N+1)]\n        for j in range(K):\n            dp[0][j] = 0\n        for i in range(1, N+1):\n            dp[i][0] = i\n        for j in range(1, K):\n            dp[1][j] = 1\n            m = 1\n            for i in range(2, N+1):\n                while m < i and dp[i-m][j] >= dp[m-1][j-1] and dp[i-m-1][j] >= dp[m][j-1]:\n                    m += 1\n                dp[i][j] = max(dp[i-m][j], dp[m-1][j-1]) + 1\n                # for m in range(1, i+1):\n                #     dp[i][j] = min(dp[i][j], max(dp[m-1][j-1], dp[i-m][j]) + 1)\n        return dp[N][K-1]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = dict()\n        \n        return self.dp(K, N, memo)\n    \n    def dp(self, k, n, memo):\n        if k == 1: return n \n        if n == 0: return 0\n        if (k, n) in memo:\n            return memo[(k, n)]\n        res = float('inf')\n        '''\n        for i in range(1, n+1):\n            res = min(res,  max(self.dp(k-1, i-1, memo), self.dp(k, n-i, memo)) + 1 )\n        '''\n        lo, hi = 1, n\n        while lo <= hi:\n            mid = lo + (hi - lo)//2\n            broken = self.dp(k-1, mid-1, memo)\n            not_broken = self.dp(k, n-mid, memo)\n            \n            if broken > not_broken:\n                hi = mid - 1\n                res = min(res, broken + 1)\n            else:\n                lo = mid + 1\n                res = min(res, not_broken + 1)\n        memo[(k, n)] = res\n        \n        return res\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # base case for only 1 egg\n        dp=list(range(N+1))\n        for k in range(1,K):\n            newdp=[0]\n            opt=1\n            for n in range(1,N+1):\n                # the optimum choice (intersection of two values) increases with n\n                tmp=max(dp[opt-1],newdp[n-opt])\n                while opt<n and tmp>max(dp[opt],newdp[n-opt-1]):\n                    tmp=max(dp[opt],newdp[n-opt-1])\n                    opt+=1                    \n                newdp.append(1+tmp)\n            dp=newdp\n        return dp[-1]\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        cache = {}\n        return self.drop_iter(K, N, cache)\n\n    def drop_iter(self, K, N, cache):\n        if K == 1:\n            return N\n        if N == 0:\n            return 0\n        if (K, N) in cache:\n            return cache[(K, N)]\n        res = float('inf')\n        # for i in range(1, N+1):\n        #     temp = max(self.drop_iter(K, N-i, cache), self.drop_iter(K-1, i-1, cache)) + 1\n        #     res = min(res, temp)\n        left = 1\n        right = N\n        # self.drop_iter(K, N-i, cache) \u5355\u8c03\u51cf\n        # self.drop_iter(K-1, i-1, cache) \u5355\u8c03\u589e\n        while left <= right:\n            mid = (left + right) // 2\n            borke = self.drop_iter(K - 1, mid - 1, cache)\n            not_broke = self.drop_iter(K, N - mid, cache)\n            if borke > not_broke:\n                right = mid - 1\n                res = min(borke + 1, res)\n            else:\n                left = mid + 1\n                res = min(not_broke + 1, res)\n\n        cache[(K, N)] = res\n        return res\n\n        \n\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = range(N + 1)\n        for k in range(2, K+1):\n            dp2 = [0]\n            x = 1\n            for n in range(1, N+1):\n                while x < n and max(dp[x-1], dp2[n-x]) > max(dp[x], dp2[n-x-1]):\n                    x += 1\n                dp2.append(1+max(dp[x-1], dp2[n-x]))\n            dp = dp2\n        \n        return dp[-1]", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        dp = [[0] * (K+1) for n in range(N+1)]\n        for m in range(1,N+1):\n            for k in range(1,K+1):\n                dp[m][k] = dp[m-1][k-1] + dp[m-1][k] + 1\n            if dp[m][k] >= N: return m\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        m = [[0 for i in range(N + 1)] for j in range(K + 1)]\n        \n        def find(k, n):\n            if k == 1:\n                return n\n            if n == 0:\n                return 0\n            if m[k][n] > 0:\n                return m[k][n]\n            \n            def bsearch():\n                st, end = 1, n\n                while st <= end:\n                    m = (st + end) // 2\n                    if predicate(m):\n                        end = m - 1\n                    else:\n                        st = m + 1\n                return st, end\n             \n            def predicate(x):\n                return True if find(k-1, x - 1) >= find(k, n - x) else False\n\n            st, end = bsearch()\n            v_st = max(find(k - 1,st - 1), find(k, n - st)) if st <= N else math.inf\n            v_end = max(find(k - 1, end - 1), find(k, n - end)) if end >= 1 else math.inf\n            \n            m[k][n] = min(v_st, v_end) + 1\n            return m[k][n]\n        \n        return find(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        cachedSolutions = [[-1 for i in range(N+1)] for j in range(K+1)]\n        return self.getMinDrops(K, N, cachedSolutions)\n\n    def getMinDrops(self, eggs, floors, cachedSolutions):\n        if cachedSolutions[eggs][floors] > 0:\n            return cachedSolutions[eggs][floors]\n        elif eggs == 0:\n            cachedSolutions[eggs][floors] = 0\n            return 0\n        elif eggs == 1 or floors <= 2:\n            cachedSolutions[eggs][floors] = floors\n            return floors\n        else:\n            ## Arbitrarily large number to initialize the minimum number of drops.\n            smallestIndex = 1\n            largestIndex = floors\n            minDrops = 100000000\n            while(smallestIndex<=largestIndex):\n                ## We want to find the minimum of the maximums of all possible subproblems and do it through binary search.\n                middleIndex = round(smallestIndex+(largestIndex-smallestIndex)/2)\n                ## Solve the subproblems.\n                minDropsA = self.getMinDrops(eggs-1, middleIndex-1, cachedSolutions)\n                minDropsB = self.getMinDrops(eggs, floors-middleIndex, cachedSolutions)\n                ## Find a new minimum number of drops for validating that all floors are a solution or not.\n                tempMinDrops = max(minDropsA, minDropsB) + 1\n                minDrops = min(minDrops, tempMinDrops)\n                ## Check which half will contain the valid solution.\n                if (minDropsA > minDropsB):\n                    largestIndex = middleIndex - 1\n                else:\n                    smallestIndex = middleIndex + 1\n            cachedSolutions[eggs][floors] = minDrops\n        return cachedSolutions[eggs][floors]\n\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        m = [[0 for i in range(N + 1)] for j in range(K + 1)]\n        \n        def find(k, n):\n            if k == 1:\n                return n\n            if n == 0:\n                return 0\n            if m[k][n] > 0:\n                return m[k][n]\n            \n            def bsearch():\n                st, end = 1, n\n                while st <= end:\n                    m = (st + end) // 2\n                    if predicate(m):\n                        end = m - 1\n                    else:\n                        st = m + 1\n                return st, end\n             \n            def predicate(x):\n                return True if find(k-1, x - 1) >= find(k, n - x) else False\n\n            st, end = bsearch()\n            if st > N:\n                v_st = math.inf\n                v_end = 1 + max(find(k - 1, end - 1), find(k, n - end))\n            elif end < 1:\n                v_end = math.inf\n                v_st = 1 + max(find(k - 1,st - 1), find(k, n - st))\n            else:\n                v_st = 1 + max(find(k - 1,st - 1), find(k, n - st))\n                v_end = 1 + max(find(k - 1, end - 1), find(k, n - end))\n            \n            m[k][n] = min(v_st, v_end)\n            return m[k][n]\n        \n        return find(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[0] * (K + 1) for i in range(N + 1)]\n        for m in range(1, N + 1):\n            for k in range(1, K + 1):\n                dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1\n            if dp[m][K] >= N: return m", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[0] * (K+1) for _ in range(N+1)]\n        \n        for move in range(1, N+1):\n            for egg in range(1, K+1):\n                dp[move][egg] = dp[move - 1][egg - 1] + dp[move - 1][egg] + 1\n                \n            if dp[move][K] >= N:\n                return move", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[0] * (K + 1) for i in range(N + 1)]\n        for m in range(1, N + 1):\n            for k in range(1, K + 1):\n                dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1\n            if dp[m][K] >= N: return m\n", "# class Solution:\n#     def superEggDrop(self, K: int, N: int) -> int:    \n#         def segment_sum(x,k):\n#             # x is worst case, k is number of eggs available\n#             # returns max N for worst case x, eggs k\n#             if k==1:\n#                 return x\n#             return sum(segment_sum(j, k-1)+1 for j in range(x))\n\n#         worst_case=0\n#         while segment_sum(worst_case, K) < N:\n#             worst_case+=1\n#         return worst_case\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         drops = 0                           # the number of eggs dropped\n#         floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs\n\n#         while floors[K] < N:                # until we can reach N floors with K eggs \n\n#             for eggs in range(K, 0, -1):\n#                 floors[eggs] += 1 + floors[eggs - 1]\n#             drops += 1\n\n#         return drops\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         def f(x):\n#             ans = 0\n#             r = 1\n#             for i in range(1, K+1):\n#                 r *= x-i+1\n#                 r //= i\n#                 ans += r\n#                 if ans >= N: break\n#             return ans\n\n#         lo, hi = 1, N\n#         while lo < hi:\n#             mi = (lo + hi) // 2\n#             if f(mi) < N:\n#                 lo = mi + 1\n#             else:\n#                 hi = mi\n#         return lo\n\nfrom scipy.special import comb, factorial, hyp2f1\nfrom math import log2, floor\n\ndef h(k,n):\n    return round(2**n-1-comb(n,k+1)*hyp2f1(1,k-n+1,k+2,-1))\n\ndef h2(k,n):\n    return sum(comb(n,j) for j in range(1,k+1))\n\ndef fast_sum(k,l):\n    s = 0\n    c = 1\n    for i in range(1,k+1):\n        c *= (l-i+1)/(i)\n        s += c\n    return s\n\ndef e(k, n):\n    if k == 1:\n        return n\n    return sum(e(k-1, j)+1 for j in range(n))\n\ndef f(K, x):\n    ans = 0\n    r = 1\n    for i in range(1, K+1):\n        r *= x-i+1\n        r //= i\n        ans += r\n    return ans\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        # best_case = floor(log2(n)+1)\n        # if k >= best_case:\n        #     return best_case\n        if k == 0:\n            return n\n        a, b = 1, n\n        while a < b:\n            c = (a+b)//2\n            if fast_sum(k,c) < n:\n                a = c + 1\n            else:\n                b = c\n        return a", "# class Solution:\n#     def superEggDrop(self, K: int, N: int) -> int:    \n#         def segment_sum(x,k):\n#             # x is worst case, k is number of eggs available\n#             # returns max N for worst case x, eggs k\n#             if k==1:\n#                 return x\n#             return sum(segment_sum(j, k-1)+1 for j in range(x))\n\n#         worst_case=0\n#         while segment_sum(worst_case, K) < N:\n#             worst_case+=1\n#         return worst_case\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         drops = 0                           # the number of eggs dropped\n#         floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs\n\n#         while floors[K] < N:                # until we can reach N floors with K eggs \n\n#             for eggs in range(K, 0, -1):\n#                 floors[eggs] += 1 + floors[eggs - 1]\n#             drops += 1\n\n#         return drops\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         def f(x):\n#             ans = 0\n#             r = 1\n#             for i in range(1, K+1):\n#                 r *= x-i+1\n#                 r //= i\n#                 ans += r\n#                 if ans >= N: break\n#             return ans\n\n#         lo, hi = 1, N\n#         while lo < hi:\n#             mi = (lo + hi) // 2\n#             if f(mi) < N:\n#                 lo = mi + 1\n#             else:\n#                 hi = mi\n#         return lo\n\nfrom scipy.special import comb, factorial, hyp2f1\nfrom math import log2, floor\n\ndef h(k,n):\n    return round(2**n-1-comb(n,k+1)*hyp2f1(1,k-n+1,k+2,-1))\n\ndef h2(k,n):\n    return sum(comb(n,j) for j in range(1,k+1))\n\ndef fast_sum(k,l):\n    s = 0\n    c = 1\n    for i in range(1,k+1):\n        c *= (l-i+1)/(i)\n        s += c\n    return s\n\ndef e(k, n):\n    if k == 1:\n        return n\n    return sum(e(k-1, j)+1 for j in range(n))\n\ndef f(K, x):\n    ans = 0\n    r = 1\n    for i in range(1, K+1):\n        r *= x-i+1\n        r //= i\n        ans += r\n    return ans\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        # best_case = floor(log2(n)+1)\n        # if k >= best_case:\n        #     return best_case\n        if k == 0:\n            return n\n        l = 0\n        while fast_sum(k, l) < n:\n            l+=1\n        return l", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n#         results = [[None for _ in range(N+1)] for _ in range(K+1)]\n#         def dp(K, N):\n#             if K == 1:\n#                 return N\n#             if N == 0:\n#                 return 0\n            \n#             if results[K][N]:\n#                 return results[K][N]\n            \n            \n#             res = N\n            \n#             left = 1\n#             right = N\n            \n#             while left <= right:\n#                 mid = int((right+left)/2)\n                \n#                 broken_num = dp(K-1, mid-1)\n#                 notbroken_num = dp(K, N-mid)\n#                 if broken_num > notbroken_num:\n#                     right = mid - 1\n#                     res = min(res, broken_num + 1)\n#                 else:\n#                     left = mid + 1\n#                     res = min(res, notbroken_num + 1)\n            \n#             results[K][N] = res\n#             # for i in range(1, N+1):\n#             #     results[K][N] = min(results[K][N], max(dp(K-1, i-1), dp(K, N-i)) + 1)\n            \n#             # return results[K][N]\n#             return res\n#         # dp(K, N)\n#         # print(results)\n#         return dp(K, N)\n\n        dp = [[0 for _ in range(N+1)] for _ in range(K+1)]\n    \n        m = 0\n        while dp[K][m] < N:\n            m += 1\n            for k in range(1, K+1):\n                dp[k][m] = dp[k-1][m-1] + dp[k][m-1] + 1\n                \n        return m", "class Solution:\n    def superEggDrop(self, K, N):\n        dp = [0, 0]\n        m = 0\n        while dp[-1] < N:\n            for i in range(len(dp) - 1, 0, - 1):\n                dp[i] += dp[i - 1] + 1\n            if len(dp) < K + 1:\n                dp.append(dp[-1])\n            m += 1\n        return m", "# class Solution:\n#     def superEggDrop(self, K: int, N: int) -> int:    \n#         def segment_sum(x,k):\n#             # x is worst case, k is number of eggs available\n#             # returns max N for worst case x, eggs k\n#             if k==1:\n#                 return x\n#             return sum(segment_sum(j, k-1)+1 for j in range(x))\n\n#         worst_case=0\n#         while segment_sum(worst_case, K) < N:\n#             worst_case+=1\n#         return worst_case\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         drops = 0                           # the number of eggs dropped\n#         floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs\n\n#         while floors[K] < N:                # until we can reach N floors with K eggs \n\n#             for eggs in range(K, 0, -1):\n#                 floors[eggs] += 1 + floors[eggs - 1]\n#             drops += 1\n\n#         return drops\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         def f(x):\n#             ans = 0\n#             r = 1\n#             for i in range(1, K+1):\n#                 r *= x-i+1\n#                 r //= i\n#                 ans += r\n#                 if ans >= N: break\n#             return ans\n\n#         lo, hi = 1, N\n#         while lo < hi:\n#             mi = (lo + hi) // 2\n#             if f(mi) < N:\n#                 lo = mi + 1\n#             else:\n#                 hi = mi\n#         return lo\n\nfrom scipy.special import comb, factorial, hyp2f1\nfrom math import log2, floor\n\ndef h(k,n):\n    return round(2**n-1-comb(n,k+1)*hyp2f1(1,k-n+1,k+2,-1))\n\ndef h2(k,n):\n    return sum(comb(n,j) for j in range(1,k+1))\n\ndef fast_sum(k,n):\n    s = 0\n    c = 1\n    for i in range(1,k+1):\n        c *= (n-i+1)/(i)\n        s += c\n    return s\n\ndef e(k, n):\n    if k == 1:\n        return n\n    return sum(e(k-1, j)+1 for j in range(n))\n\ndef f(K, x):\n    ans = 0\n    r = 1\n    for i in range(1, K+1):\n        r *= x-i+1\n        r //= i\n        ans += r\n    return ans\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        # best_case = floor(log2(n)+1)\n        # if k >= best_case:\n        #     return best_case\n        if k == 0:\n            return n\n        l = 0\n        while fast_sum(k, l) < n:\n            l+=1\n        return l", "# class Solution:\n#     def superEggDrop(self, K: int, N: int) -> int:    \n#         def segment_sum(x,k):\n#             # x is worst case, k is number of eggs available\n#             # returns max N for worst case x, eggs k\n#             if k==1:\n#                 return x\n#             return sum(segment_sum(j, k-1)+1 for j in range(x))\n\n#         worst_case=0\n#         while segment_sum(worst_case, K) < N:\n#             worst_case+=1\n#         return worst_case\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         drops = 0                           # the number of eggs dropped\n#         floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs\n\n#         while floors[K] < N:                # until we can reach N floors with K eggs \n\n#             for eggs in range(K, 0, -1):\n#                 floors[eggs] += 1 + floors[eggs - 1]\n#             drops += 1\n\n#         return drops\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         def f(x):\n#             ans = 0\n#             r = 1\n#             for i in range(1, K+1):\n#                 r *= x-i+1\n#                 r //= i\n#                 ans += r\n#                 if ans >= N: break\n#             return ans\n\n#         lo, hi = 1, N\n#         while lo < hi:\n#             mi = (lo + hi) // 2\n#             if f(mi) < N:\n#                 lo = mi + 1\n#             else:\n#                 hi = mi\n#         return lo\n\nfrom scipy.special import comb, factorial, hyp2f1\nfrom math import log2, floor\n\ndef h(k,n):\n    return round(2**n-1-comb(n,k+1)*hyp2f1(1,k-n+1,k+2,-1))\n\ndef h2(k,n):\n    return sum(comb(n,j) for j in range(1,k+1))\n\ndef fast_sum(k,l,n):\n    s = 0\n    c = 1\n    for i in range(1,k+1):\n        c *= (l-i+1)/(i)\n        s += c\n        if s >= n:\n            return s\n    return s\n\ndef e(k, n):\n    if k == 1:\n        return n\n    return sum(e(k-1, j)+1 for j in range(n))\n\ndef f(K, x):\n    ans = 0\n    r = 1\n    for i in range(1, K+1):\n        r *= x-i+1\n        r //= i\n        ans += r\n    return ans\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        # best_case = floor(log2(n)+1)\n        # if k >= best_case:\n        #     return best_case\n        if k == 0:\n            return n\n        l = 0\n        while fast_sum(k, l, n) < n:\n            l+=1\n        return l", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # dp[k][m]: given k eggs, max move m, the highest floor can find F\n        # dp[k][m] = dp[k - 1][m - 1] + dp[k][m - 1] + 1\n        # max m will be N, linear scan\n        \n        dp = [[0 for i in range(N + 1)] for j in range(K + 1)]\n        m = 0\n        while dp[K][m] < N:\n            m += 1\n            for k in range(1, K + 1):\n                dp[k][m] = dp[k - 1][m - 1] + dp[k][m - 1] + 1\n        return m\n        \n", "# class Solution:\n#     def superEggDrop(self, K: int, N: int) -> int:    \n#         def segment_sum(x,k):\n#             # x is worst case, k is number of eggs available\n#             # returns max N for worst case x, eggs k\n#             if k==1:\n#                 return x\n#             return sum(segment_sum(j, k-1)+1 for j in range(x))\n\n#         worst_case=0\n#         while segment_sum(worst_case, K) < N:\n#             worst_case+=1\n#         return worst_case\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         drops = 0                           # the number of eggs dropped\n#         floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs\n\n#         while floors[K] < N:                # until we can reach N floors with K eggs \n\n#             for eggs in range(K, 0, -1):\n#                 floors[eggs] += 1 + floors[eggs - 1]\n#             drops += 1\n\n#         return drops\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         def f(x):\n#             ans = 0\n#             r = 1\n#             for i in range(1, K+1):\n#                 r *= x-i+1\n#                 r //= i\n#                 ans += r\n#                 if ans >= N: break\n#             return ans\n\n#         lo, hi = 1, N\n#         while lo < hi:\n#             mi = (lo + hi) // 2\n#             if f(mi) < N:\n#                 lo = mi + 1\n#             else:\n#                 hi = mi\n#         return lo\n\nfrom scipy.special import comb, factorial, hyp2f1\nfrom math import log2, floor\n\ndef h(k,n):\n    return round(2**n-1-comb(n,k+1)*hyp2f1(1,k-n+1,k+2,-1))\n\ndef h2(k,n):\n    return sum(comb(n,j) for j in range(1,k+1))\n\ndef fast_sum(k,l):\n    s = 0\n    c = 1\n    for i in range(1,k+1):\n        c *= (l-i+1)/(i)\n        s += c\n    return s\n\ndef e(k, n):\n    if k == 1:\n        return n\n    return sum(e(k-1, j)+1 for j in range(n))\n\ndef f(K, x):\n    ans = 0\n    r = 1\n    for i in range(1, K+1):\n        r *= x-i+1\n        r //= i\n        ans += r\n    return ans\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        # best_case = floor(log2(n)+1)\n        # if k >= best_case:\n        #     return best_case\n        if k == 0:\n            return n\n        a, b = 1, n\n        while a < b:\n            c = (a+b)//2\n            if h2(k,c) < n:\n                a = c + 1\n            else:\n                b = c\n        return a", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # dp[k][m] means the number floors can be identify when using k egges with maximum try m times \n        dp = [[0 for col in range(N + 2)] for row in range(K + 2)]\n        m = 0\n        while dp[K][m] < N:\n            m += 1\n            for k in range(1, K + 1):\n                dp[k][m] = dp[k - 1][m - 1] + dp[k][m - 1] + 1\n                \n        return m\n        \n        \n#         def dp(k, n):\n#             if k == 1:\n#                 return n\n#             if n == 0:\n#                 return 0\n#             if (k, n) in memo:\n#                 return memo[(k, n)]\n            \n#             res = sys.maxsize\n#             lo, hi = 1, n\n#             while lo <= hi:\n#                 mid = (lo + hi) // 2\n#                 broken = dp(k - 1, mid - 1) \n#                 safe = dp(k, n - mid) \n#                 if broken > safe:\n#                     hi = mid - 1\n#                     res = min(res, broken + 1)\n#                 else:\n#                     lo = mid + 1\n#                     res = min(res, safe + 1)\n                    \n#             memo[(k, n)] = res\n#             return res\n        \n#         memo = {}\n#         return dp(K, N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n#         dpDict = {}\n        \n#         def dp(K,N):\n#             if K == 1: return N\n#             if N == 0: return 0\n#             if (K, N) in dpDict: return dpDict[K,N] \n#             res = float('inf')\n#             for i in range(1, N + 1):\n#                 res = min(res, \n#                           1 + max(dp(K-1, i-1), dp(K,N-i))\n#                          )\n                \n#             dpDict[K,N] = res\n#             return res\n        \n#         return dp(K,N)\n                \n        dp = [[0 for _ in range(N+1)] for _ in range(K+1)]\n        m = 0\n        while dp[K][m] < N:\n            m += 1\n            for i in range(1,K+1):\n                dp[i][m] = dp[i][m-1] + dp[i-1][m-1] + 1\n        return m", "# class Solution:\n#     def superEggDrop(self, K: int, N: int) -> int:    \n#         def segment_sum(x,k):\n#             # x is worst case, k is number of eggs available\n#             # returns max N for worst case x, eggs k\n#             if k==1:\n#                 return x\n#             return sum(segment_sum(j, k-1)+1 for j in range(x))\n\n#         worst_case=0\n#         while segment_sum(worst_case, K) < N:\n#             worst_case+=1\n#         return worst_case\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         drops = 0                           # the number of eggs dropped\n#         floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs\n\n#         while floors[K] < N:                # until we can reach N floors with K eggs \n\n#             for eggs in range(K, 0, -1):\n#                 floors[eggs] += 1 + floors[eggs - 1]\n#             drops += 1\n\n#         return drops\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         def f(x):\n#             ans = 0\n#             r = 1\n#             for i in range(1, K+1):\n#                 r *= x-i+1\n#                 r //= i\n#                 ans += r\n#                 if ans >= N: break\n#             return ans\n\n#         lo, hi = 1, N\n#         while lo < hi:\n#             mi = (lo + hi) // 2\n#             if f(mi) < N:\n#                 lo = mi + 1\n#             else:\n#                 hi = mi\n#         return lo\n\nfrom scipy.special import comb, factorial, hyp2f1\nfrom math import log2, floor\n\ndef h(k,n):\n    return round(2**n-1-comb(n,k+1)*hyp2f1(1,k-n+1,k+2,-1))\n\ndef h2(k,n):\n    return sum(comb(n,j) for j in range(1,k+1))\n\ndef e(k, n):\n    if k == 1:\n        return n\n    return sum(e(k-1, j)+1 for j in range(n))\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        # best_case = floor(log2(n)+1)\n        # if k >= best_case:\n        #     return best_case\n        l = 0\n        while h2(k, l) < n:\n            l+=1\n        return l", "# class Solution:\n#     def superEggDrop(self, K: int, N: int) -> int:    \n#         def segment_sum(x,k):\n#             # x is worst case, k is number of eggs available\n#             # returns max N for worst case x, eggs k\n#             if k==1:\n#                 return x\n#             return sum(segment_sum(j, k-1)+1 for j in range(x))\n\n#         worst_case=0\n#         while segment_sum(worst_case, K) < N:\n#             worst_case+=1\n#         return worst_case\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         drops = 0                           # the number of eggs dropped\n#         floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs\n\n#         while floors[K] < N:                # until we can reach N floors with K eggs \n\n#             for eggs in range(K, 0, -1):\n#                 floors[eggs] += 1 + floors[eggs - 1]\n#             drops += 1\n\n#         return drops\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         def f(x):\n#             ans = 0\n#             r = 1\n#             for i in range(1, K+1):\n#                 r *= x-i+1\n#                 r //= i\n#                 ans += r\n#                 if ans >= N: break\n#             return ans\n\n#         lo, hi = 1, N\n#         while lo < hi:\n#             mi = (lo + hi) // 2\n#             if f(mi) < N:\n#                 lo = mi + 1\n#             else:\n#                 hi = mi\n#         return lo\n\nfrom scipy.special import comb, factorial, hyp2f1\nfrom math import log2, floor\n\ndef h(k,n):\n    return round(2**n-1-comb(n,k+1)*hyp2f1(1,k-n+1,k+2,-1))\n\ndef h2(k,n):\n    return sum(comb(n,j) for j in range(1,k+1))\n\ndef e(k, n):\n    if k == 1:\n        return n\n    return sum(e(k-1, j)+1 for j in range(n))\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        best_case = floor(log2(n)+1)\n        if k >= best_case:\n            return best_case\n        l = 0\n        while h2(k, l) < n:\n            l+=1\n        return l", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # dp[M][K]means that, given K eggs and M moves, what is the maximum number of floor that we can check.\n        dp = [[0] * (K + 1) for i in range(N + 1)]\n        for m in range(1, N + 1):\n            for k in range(1, K + 1):\n                dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1\n            if dp[m][K] >= N: \n                return m", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        '''\n        # Top down: Time O(KN log(N)) Space O(KN)\n        import functools\n        @functools.lru_cache(None)\n        def dp(k, m):\n            if k == 1: return m\n            if m == 1: return 1\n            return dp(k-1, m-1) + dp(k, m-1) + 1\n        l, r = 1, N\n        while l < r:\n            mid = (l+r) // 2\n            if dp(K, mid) >= N:\n                r = mid\n            else:\n                l = mid + 1\n        return l\n        '''\n        # Bottom up: Time O(Klog(N)) Space O(K)\n        dp, ndp = {}, {}\n        for m in range(1, N+1):\n            for k in range(1, K+1):\n                if m == 1: ndp[k] = 1\n                elif k == 1: ndp[k] = m\n                else:\n                    ndp[k] = dp[k-1] + dp[k] + 1\n                if ndp[k] >= N:\n                    return m\n            dp, ndp = ndp, {}\n", "# class Solution:\n#     def superEggDrop(self, K: int, N: int) -> int:    \n#         def segment_sum(x,k):\n#             # x is worst case, k is number of eggs available\n#             # returns max N for worst case x, eggs k\n#             if k==1:\n#                 return x\n#             return sum(segment_sum(j, k-1)+1 for j in range(x))\n\n#         worst_case=0\n#         while segment_sum(worst_case, K) < N:\n#             worst_case+=1\n#         return worst_case\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         drops = 0                           # the number of eggs dropped\n#         floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs\n\n#         while floors[K] < N:                # until we can reach N floors with K eggs \n\n#             for eggs in range(K, 0, -1):\n#                 floors[eggs] += 1 + floors[eggs - 1]\n#             drops += 1\n\n#         return drops\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         def f(x):\n#             ans = 0\n#             r = 1\n#             for i in range(1, K+1):\n#                 r *= x-i+1\n#                 r //= i\n#                 ans += r\n#                 if ans >= N: break\n#             return ans\n\n#         lo, hi = 1, N\n#         while lo < hi:\n#             mi = (lo + hi) // 2\n#             if f(mi) < N:\n#                 lo = mi + 1\n#             else:\n#                 hi = mi\n#         return lo\n\nfrom scipy.special import comb, factorial, hyp2f1\nfrom math import log2, floor\n\ndef h(k,n):\n    return round(2**n-1-comb(n,k+1)*hyp2f1(1,k-n+1,k+2,-1))\n\ndef h2(k,n):\n    return sum(comb(n,j) for j in range(1,k+1))\n\ndef fast_sum(k,n):\n    c = n\n    for i in range(k):\n        c *= (n-k)/(k+1)\n    return c\n\ndef e(k, n):\n    if k == 1:\n        return n\n    return sum(e(k-1, j)+1 for j in range(n))\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        # best_case = floor(log2(n)+1)\n        # if k >= best_case:\n        #     return best_case\n        if k == 0:\n            return n\n        l = 0\n        while h2(k, l) < n:\n            l+=1\n        return l", "class Solution:\n    def superEggDrop(self, eggs: int, floors: int) -> int:\n        dp = [[0] * (eggs+1) for _ in range(floors+1)]\n        currFloor = 0\n        \n        while dp[currFloor][eggs] < floors:\n            currFloor += 1\n            for i in range(1 , eggs+1):\n                dp[currFloor][i] = dp[currFloor - 1][i-1] + dp[currFloor - 1][i] + 1\n                \n        return currFloor", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        dp = [[0 for _ in range(N +1)] for _ in range(K + 1)]\n        \n        m = 0\n        while dp[K][m] < N:\n            m += 1\n            \n            for k in range(1, K + 1):\n                dp[k][m] = 1 + dp[k-1][m-1] + dp[k][m-1]\n        \n        return m\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        dp=[[0]*(K+1) for i in range(N+1)]\n        for m in range(1,N+1):\n            for k in range(1,K+1):\n                \n                dp[m][k]=dp[m-1][k-1]+dp[m-1][k]+1\n        \n            if dp[m][K]>=N:\n                return m\n", "from math import comb\n\n\nclass Solution:\n    def ncr(self,n, r):\n        sum=0\n        r=min(n,r)\n        for l in range(1,r+1):\n            sum+=comb(n,l)\n        return sum\n   \n   \n    def superEggDrop(self, K, N):\n    \n        matrix=[[0 for j in range(K)]for i in range(N)]\n        for i in range(N):\n            for j in range(K):\n                matrix[i][j]=self.ncr(i+1,j+1)\n                if matrix[i][K-1]>=N:\n                    return i+1\n        print(matrix)\n\n           \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[0 for _ in range(K+1)] for _ in range(N+1)]\n        \n        attempt = 0 \n        while dp[attempt][K] < N:\n            attempt += 1 \n            for i in range(1, K+1):\n                dp[attempt][i] = 1 + dp[attempt-1][i-1] + dp[attempt-1][i]\n                if dp[attempt][i] >= N :\n                    return attempt\n        \n        return attempt", "from math import comb\n\n\nclass Solution:\n    def ncr(self,n, r):\n        sum=0\n        r=min(n,r)\n        for l in range(1,r+1):\n            sum+=comb(n,l)\n        return sum\n   \n   \n    def superEggDrop(self, K, N):\n    \n        matrix=[[0 for j in range(K)]for i in range(N)]\n        for i in range(N):\n            for j in range(K):\n                matrix[i][j]=self.ncr(i+1,j+1)\n                if matrix[i][K-1]>=N:\n                    return i+1\n        print(matrix)\n       \n#         for m in range(N):\n#             if matrix[m][K-1]>=N:\n#                 return m+1\n\n           \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = [[0 for _ in range(K + 1)] for _ in range(N + 1)]\n        for m in range(1, N + 1):\n            for k in range(1, K + 1):\n                memo[m][k] = memo[m - 1][k - 1] + 1 + memo[m - 1][k]\n                if memo[m][k] >= N: return m ", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n#         dp=[[0 for _ in range(K+1)] for _ in range(N+1)];\n        \n#         for n in range(N+1):\n#             dp[n][0]=float('inf');\n            \n#         for k in range(K+1):\n#             dp[0][k]=0;\n            \n        \n#         for k in range(1,K+1):\n#             for n in range(1,N+1):\n#                 # res= float('inf');\n#                 # for i in range(1,n+1):\n#                 #     res= min(res, max(dp[i-1][k-1],dp[n-i][k]));\n#                 # dp[n][k]=1+res;\n                \n#                 l=1;\n#                 r=n;\n                \n#                 while(r-l>=2):\n#                     mid=int((l+r)/2);\n                    \n#                     a= dp[mid-1][k-1];\n#                     b= dp[n-mid][k];\n                    \n#                     if a>b:\n#                         r=mid-1;\n#                     elif a<b:\n#                         l=mid+1;\n#                     else:\n#                         l,r=mid,mid;\n                        \n#                 dp[n][k]= 1 + min( max(dp[l-1][k-1],dp[n-l][k]) , max(dp[r-1][k-1],dp[n-r][k]));\n                \n#         return dp[N][K];\n\n\n\n        # O(k*N) time\n        \n        dp= [[0 for _ in range(K+1)] for _ in range(N+1)];\n        \n        for n in range(1,N+1):\n            for k in range(1,K+1):\n                dp[n][k]=1 + dp[n-1][k] + dp[n-1][k-1];\n            if dp[n][K]>=N:\n                return n;", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        def dp(m, k):\n            if m<=1 or k==1: return m\n            if (m, k) in memo: return memo[(m, k)]\n            \n            memo[(m, k)] = dp(m-1, k-1)+1+dp(m-1, k)\n            return memo[(m, k)]\n        \n        memo = {}\n        for i in range(N+1):\n            if dp(i, K)>=N:\n                return i", "class Solution:\n    # def superEggDrop(self, K: int, N: int) -> int:\n    #     drops = 0\n    #     floors = [0] * (K + 1)\n    #     while floors[K] < N:\n    #         for eggs in range(K, 0, -1):\n    #             floors[eggs] += 1 + floors[eggs - 1]\n    #         drops += 1\n    #     return drops\n\n    def superEggDrop(self, K: int, N: int) -> int:\n            # M x K --> Given M moves and K eggs, what is the maximum floor we can check ?\n            M = N # big enough number\n            dp = [[0 for j in range(K+1)] for i in range(M+1)]\n            # Initialization 1 --> no move no floor --> dp[0][*] = 0\n            # Initialization 2 --> no egg no floor --> dp[*][0] = 0\n            # General case --> we want to find dp[m][k] --> we pick one egg and drop (1 move)\n            #              --> now we have k or k-1 eggs, depending on whether the previous egg is broken\n            #              --> so in either case, we can at least sum up 1 (first move) + dp[m-1][k] + dp[m-1][k-1] \n            for i in range(1, M+1):\n                for j in range(1, K+1):\n                    dp[i][j] = 1 + dp[i-1][j] + dp[i-1][j-1]\n                    if dp[i][j] >= N:\n                        return i", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        dp = [ [0 for j in range(K+1)] for i in range(N+1)]\n        \n        attempt = 0\n        while(dp[attempt][K]<N):\n            attempt+=1\n            for j in range(1,len(dp[0])):\n                dp[attempt][j]= 1 + dp[attempt-1][j-1]+ dp[attempt-1][j]\n                if dp[attempt][j]>=N:\n                    return attempt\n        \n                \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        drops = 0\n        floors = [0] * (K + 1)\n        while floors[K] < N:\n            for eggs in range(K, 0, -1):\n                floors[eggs] += 1 + floors[eggs - 1]\n            drops += 1\n        return drops\n\n    def superEggDrop(self, K: int, N: int) -> int:\n            # M x K --> Given M moves and K eggs, what is the maximum floor we can check ?\n            M = N # big enough number\n            dp = [[0 for j in range(K+1)] for i in range(M+1)]\n            #              --> so in either case, we can at least sum up 1 (first move) + dp[m-1][k] + dp[m-1][k-1] \n            for i in range(1, M+1):\n                for j in range(1, K+1):\n                    dp[i][j] = 1 + dp[i-1][j] + dp[i-1][j-1]\n                    if dp[i][j] >= N:\n                        return i\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp=[[0 for i in range(K+1)]for i in range(N+1)]\n        for m in range(1,N+1):\n            for k in range(1,K+1):\n                dp[m][k]=1+dp[m-1][k-1]+dp[m-1][k]\n            if dp[m][k]>=N: \n                return m\n        #return dp[-1][-1]\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[0 for i in range(K + 1)] for j in range(N + 1)]\n        for m in range(1, N + 1):\n            for k in range(1, K + 1):\n                dp[m][k] = dp[m - 1][k - 1] + 1 + dp[m - 1][k]\n            if dp[m][K] >= N:\n                return m \n        \n                \n                \n", "import numpy as np\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # given K eggs and M moves, what is the maximum number of floor that we can check.\n        dp = [[0 for i in range(K+1)] for j in range(N+1)]\n        for i in range(1, N+1):\n            for j in range(1, K+1):\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + 1\n            if dp[i][j] >= N:\n                return i\n                \n                \n                \n#         #Dec1, 2019\n#         self.grid = np.zeros((K+1, N+1), dtype=np.int32)\n#         return self.drop(K, N)\n        \n#     def drop(self, K, N):\n#         for j in range(1, N+1):\n#             for i in range(1, K+1):\n#                 self.grid[i][j] = self.grid[i-1][j-1] + self.grid[i][j-1] + 1\n#             if self.grid[K][j] >= N: #if we could already check all stairs with K eggs, then return the number of stairs j\n#                 return j\n#         return self.grid[K][N]\n        \n\n#         #Dec1, 2019\n#         self.grid = np.zeros((K+1, N+1), dtype=np.int32)\n#         return self.test(K, N)\n        \n        \n#     def test(self, K, N):\n#         if N == 1 or N == 0:\n#             return N\n#         elif K == 1 or K == 0:\n#             return N\n#         else:\n#             if self.grid[K][N]:\n#                 return self.grid[K][N]\n#             else:\n#                 self.grid[K][N] = min(max(self.test(K-1, i-1), self.test(K, N-i)) for i in range(1, N+1))+1\n#                 return self.grid[K][N]\n", "#O(N*K)\n#O(1)\n\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        #find max no of floor you can reach with given eggs and no of attempts\n        \n        dp = [ [0 for j in range(K+1)] for i in range(N+1)]\n        \n        attempt = 0\n        while(dp[attempt][K]<N):\n            attempt+=1\n            for j in range(1,len(dp[0])):\n                # 1 + Break case + No Break case\n                dp[attempt][j]= 1 + dp[attempt-1][j-1]+ dp[attempt-1][j]\n                if dp[attempt][j]>=N:\n                    return attempt\n        \n                \n", "from functools import lru_cache\nfrom typing import Tuple\n\nclass Solution:\n    # floor: 0 <= F <= N\n    # Ans f where eggs break if it's higher than f\n    # N floors from 1 to N.\n    # K eggs\n    # Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N). \n    def superEggDrop(self, K: int, N: int) -> int:\n        return superEggHelper(K, N)\n        \n            \n        \n        \n        \n@lru_cache(maxsize=None)\ndef superEggHelper(K: int, N: int) -> int:\n    # base case\n    if N == 0:\n        return 0\n    \n    if K == 1:\n        return N\n\n    # ans = N;\n    # dropping from floor i\n    # for i in range(1, N + 1):\n    #     ans = min(max(superEggHelper(K, N - i), superEggHelper(K - 1, i - 1)) + 1, ans)\n\n    # bin search\n    ans = bisectEggHelper(K, 1, N, N)\n\n    # print(K, N, ans)\n    return ans\n\n# 2 0 1 1\n# S: start, E: end, N: number of floors, K: number of eggs\ndef bisectEggHelper(K: int, S: int, E: int, N: int) -> int:\n    # print(K, S, E, N)\n    # base case, only one element left\n    if S == E:\n        left, right = superEggCalc(K, S, N)\n        return max(left, right) + 1\n    \n    # base case, only two elements left\n    if S + 1 == E:\n        # K = 2\n        # i = 0\n        # S = 0\n        # N = 1\n        left1, right1 = superEggCalc(K, S, N)\n        left2, right2 = superEggCalc(K, E, N)\n        return min(max(left1, right1), max(left2, right2)) + 1\n\n    # choose i = (S + E) // 2\n    i = (S + E) // 2\n    left, right = superEggCalc(K, i, N)\n    if left > right:\n        return bisectEggHelper(K, S, i, N)\n    else:\n        return bisectEggHelper(K, i, E, N)\n   \ndef superEggCalc(K: int, i: int, N: int) -> Tuple:\n    return (superEggHelper(K - 1, i - 1), superEggHelper(K, N - i))\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = list(range(1, N+1))\n        for _ in range(K-1):\n            temp = [1]\n            for j in range(1, N):\n                if temp[-1] >= N:\n                    break\n                temp.append(temp[-1]+dp[j-1]+1)\n            dp = temp\n        return len(dp)", "# class Solution:\n#     def superEggDrop(self, K: int, N: int) -> int:    \n#         def segment_sum(x,k):\n#             # x is worst case, k is number of eggs available\n#             # returns max N for worst case x, eggs k\n#             if k==1:\n#                 return x\n#             return sum(segment_sum(j, k-1)+1 for j in range(x))\n\n#         worst_case=0\n#         while segment_sum(worst_case, K) < N:\n#             worst_case+=1\n#         return worst_case\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         drops = 0                           # the number of eggs dropped\n#         floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs\n\n#         while floors[K] < N:                # until we can reach N floors with K eggs \n\n#             for eggs in range(K, 0, -1):\n#                 floors[eggs] += 1 + floors[eggs - 1]\n#             drops += 1\n\n#         return drops\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         def f(x):\n#             ans = 0\n#             r = 1\n#             for i in range(1, K+1):\n#                 r *= x-i+1\n#                 r //= i\n#                 ans += r\n#                 if ans >= N: break\n#             return ans\n\n#         lo, hi = 1, N\n#         while lo < hi:\n#             mi = (lo + hi) // 2\n#             if f(mi) < N:\n#                 lo = mi + 1\n#             else:\n#                 hi = mi\n#         return lo\n\nfrom scipy.special import comb, factorial, hyp2f1\nfrom math import log2, floor\n\ndef h(k,n):\n    return round(2**n-1-comb(n,k+1)*hyp2f1(1,k-n+1,k+2,-1))\n\ndef e(k, n):\n    if k == 1:\n        return n\n    return sum(e(k-1, j)+1 for j in range(n))\n\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        best_case = floor(log2(n)+1)\n        if k >= best_case:\n            return best_case\n        l = 0\n        while e(k, l) < n:\n            l+=1\n        return l", "class Solution:\n    @lru_cache(None)\n    def superEggDrop(self, k: int, n: int) -> int:\n        if n == 0:\n            return 0\n        elif k == 1:\n            return n\n        \n        lo, hi = 1, n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            r1, r2 = self.superEggDrop(k-1, mid-1), self.superEggDrop(k, n - mid)\n            if r1 > r2:\n                hi = mid\n            elif r1 < r2:\n                lo = mid + 1\n            else:\n                lo = hi = mid\n        return 1 + max(self.superEggDrop(k-1, lo-1), self.superEggDrop(k, n-lo))\n        \n\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        #6:00\n        # if we have 1 one egg\n        # we will need N attempts\n        \n        # if we have 2 egg\n        # pick start postion as any k\n        # if it breaks\n        # then we will need f(k-1,1)\n        # if it doesn't break f(n-k+1,2)\n        @lru_cache(None)\n        def helper(floors,eggs):\n            if floors<=0:return 0\n            if eggs==1:return floors\n            # pick k\n            ans=floors\n            low,high=1,floors\n            while low+1<high:\n                # we dont low, high to be together\n                mid=low+(high-low)//2\n                t1=helper(mid-1,eggs-1)\n                t2=helper(floors-mid,eggs)\n                if t1<t2:\n                    low=mid\n                elif t1>t2:\n                    high=mid\n                else:\n                    low=high=mid\n            ans=floors\n            for k in (low,high):\n                ans=min(ans,1+max(helper(k-1,eggs-1),helper(floors-k,eggs)))\n                \n                \n            \n#             for k in range(1,floors+1):\n#                 # can it be binary search? i think graph has to be symmetric\n                \n#                 ans=min(ans,1+max(helper(k-1,eggs-1),helper(floors-k,eggs)))\n            return ans\n        return helper(N,K)\n        \n        \n        \n        \n        \n        \n        \n", "from functools import lru_cache\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        @lru_cache(maxsize=None)\n        def dp(K: int, N: int) -> int:\n            if N==0:\n                return 0\n            elif K==1:\n                return N\n            else:\n                l,r=1,N\n                res=N\n                while l+1<r:\n                    X=(l+r)//2\n                    f1=dp(K,N-X)\n                    f2=dp(K-1,X-1)\n                    if f1<f2:\n                        r=X\n                    elif f1==f2:\n                        l=r=X\n                    else:\n                        l=X\n                return 1+min(max(dp(K-1,X-1),dp(K,N-X)) for X in (l,r))  \n        return dp(K,N)\n", "import sys\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        val = Solution.dp(K,N)\n        return val\n    __memo = dict()\n    def dp(K,N):\n        if K == 1:\n            return N\n        if N == 0:\n            return 0\n        if (K,N) in Solution.__memo:\n            return Solution.__memo[(K,N)]\n        res = sys.maxsize\n        lo, hi = 1, N\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            broken = Solution.dp(K - 1, mid - 1) # \u788e\n            not_broken = Solution.dp(K, N - mid) # \u6ca1\u788e\n            # res = min(max(\u788e\uff0c\u6ca1\u788e) + 1)\n            if broken > not_broken:\n                hi = mid - 1\n                res = min(res, broken + 1)\n            else:\n                lo = mid + 1\n                res = min(res, not_broken + 1)\n\n        Solution.__memo[(K,N)] = res\n        return res\n        \n", "t = [[-1 for i in range(10001)] for j in range(101)]\n\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        if N == 0 or N == 1:\n            return N\n\n        if K == 1:\n            return N\n\n        if t[K][N] != -1:\n            return t[K][N]\n\n        mn, l, h = sys.maxsize, 1, N\n        while l <= h:\n            mid = (l + h) // 2\n\n            down_temp = self.superEggDrop(K - 1, mid - 1)\n            up_temp = self.superEggDrop(K, N - mid)\n\n            res = 1 + max(down_temp, up_temp)\n\n            if down_temp < up_temp:\n                l = mid + 1\n            else:\n                h = mid - 1\n\n            mn = min(mn, res)\n\n        t[K][N] = mn\n\n        return mn", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dict_soln = {}\n        return self.dp(K, N, dict_soln)\n    def dp(self, k, n, dict_soln):\n        if n == 0:\n            return 0\n        if k == 0:\n            return -1\n        if k == 1:\n            return n\n        if (k, n) in dict_soln:\n            return dict_soln[(k, n)]\n        # test at x (x = 1, ..., n)\n        # dp(k, n) = min_{x = 1, ..., n} max(dp(k, n - x), dp(k - 1, x - 1)) + 1\n        left = 1\n        right = n\n        while True:\n            if left - right == -1:\n                tmp1 = self.dp(k - 1, left - 1, dict_soln)\n                tmp2 = self.dp(k, n - left, dict_soln)\n                tmp3 = self.dp(k - 1, right - 1, dict_soln)\n                tmp4 = self.dp(k, n - right, dict_soln)\n                tmpl = max(tmp1, tmp2)\n                tmpr = max(tmp3, tmp4)\n                if tmpl < tmpr:\n                    dict_soln[(k, n)] = tmpl + 1\n                    return dict_soln[(k, n)]\n                else:\n                    dict_soln[(k, n)] = tmpr + 1\n                    return dict_soln[(k, n)]\n            xmid = (left + right) // 2\n            tmp1 = self.dp(k - 1, xmid - 1, dict_soln)\n            tmp2 = self.dp(k, n - xmid, dict_soln)\n            if tmp1 > tmp2:\n                right = xmid\n            elif tmp1 < tmp2:\n                left = xmid\n            else:\n                dict_soln[(k, n)] = tmp1 + 1\n                return dict_soln[(k, n)]\n            \n    \n        \n        \n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = dict()\n        def dp(k, n):\n            # base case\n            if k == 1:\n                return n\n            if n == 0:\n                return 0\n            if (k, n) in memo:\n                return memo[(k, n)]\n            res = float('inf')\n            # for i in range(1, n + 1):\n            #     res = min(res, max(dp(k, n - i), dp(k - 1, i - 1)) + 1)\n            lo, hi = 1, n\n            while lo <= hi:\n                mid = lo + (hi - lo) // 2\n                broken = dp(k - 1, mid - 1)\n                not_broken = dp(k, n - mid)\n                if broken > not_broken:\n                    hi = mid - 1\n                    res = min(res, broken + 1)\n                elif not_broken > broken:\n                    lo = mid + 1\n                    res = min(res, not_broken + 1)\n                elif not_broken == broken:\n                    res = min(res, broken + 1)\n                    break\n            memo[(k, n)] = res\n            return res\n        return dp(K, N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        \n        ### state: dp[k][m]. \u5982\u679c\u6709K\u4e2a\u9e21\u86cb\uff0c\u6700\u591a\u80fd\u629bm\u6b21\uff0c\u90a3\u4e48\u6700\u591a\u53ef\u4ee5\u786e\u5b9a\u7684F\u6700\u9ad8\u4e3a\u51e0\u5c42\u697c\n        ### transfer: \u5982\u679c\u5728\u67d0\u4e00\u5c42\u697c\u4e22\u9e21\u86cb\uff0c\u8981\u4e0d\u5c31\u662f\u788e\u4e86\uff0c\u8981\u4e0d\u5c31\u662f\u6ca1\u788e\u3002 \n        #### \u788e\u4e86\uff1a\u8bf4\u660e\u5f97\u6d4b\u697c\u4e0b\uff1a dp[k-1][m-1]\u4e3a\u6700\u591a\u80fd\u6d4b\u843d\u4e0b\u7684\u5c42\u6570\n        #### \u6ca1\u788e\uff1a\u8bf4\u660e\u5f97\u6d4b\u697c\u4e0a\uff1a dp[k][m-1]\u4e3a\u6700\u591a\u80fd\u6d4b\u697c\u4e0a\u7684\u5c42\u6570\n        ####\u4e0d\u7ba1\u788e\u8fd8\u662f\u6ca1\u788e\uff0c\u603b\u5171\u80fd\u6d4b\u7684\u5c42\u6570= \u697c\u4e0b + \u697c\u4e0a + 1\uff08\u73b0\u5728\u90a3\u4e00\u5c42\uff09\n        #### dp[k][m] = dp[k-1][m-1] + dp[k][m-1] + 1\n        #### \u6bcf\u5f53\u6709\u4e00\u4e2am\u503c\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4e5f\u8981\u4ecek=1 \u5230k=K\u53bbsimulate\uff0c\u53bb\u586b\u5145dp\u91cc\u9762\u7684\u503c\uff08dp\u6765\u81ea\u4e0a\u9762\u548c\u5de6\u4e0a\u89d2\uff09\n        \n        ### init: base case\u662f\u4ec0\u4e48\u5462\uff1f\u6bd4\u5982K=0\u7684\u65f6\u5019\uff0c\u80af\u5b9a\u6d4b0\u5c42\u3002 m=0\u7684\u65f6\u5019\uff0c\u4e5f\u6d4b0\u5c42\n        #### dp[0][...] = 0; dp[...][0] = 0\n        \n        ### result: \u5f53dp[K][m] == N \u7684\u65f6\u5019\uff0cm\u5c31\u662f\u6211\u4eec\u60f3\u8981\u7684\u7b54\u6848. K\u662f\u5927\u5199K\uff0c\u56e0\u4e3a\u6211\u4eec\u4e00\u5f00\u59cb\u5c31\u6709K\u4e2a\u9e21\u86cb\n        \n        dp = [[0]*(N+1) for i in range(K+1)]\n\n        m = 0\n        while dp[K][m] < N:\n            m += 1\n            \n            for i in range(1, K+1):\n                dp[i][m] = dp[i][m-1] + dp[i-1][m-1] + 1\n                \n        \n        return m", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        def dp(k, n):\n            if (k, n) in memo: return memo[(k, n)]\n            if k == 1:\n                return n\n            if n == 0:\n                return 0\n            start = 1\n            end = n\n            res = float('inf')\n            while start <= end:\n                mid = (start+end)//2\n                pre = dp(k-1, mid-1)+1\n                cur = dp(k, n-mid)+1\n                if pre < cur:\n                    res = min(res, cur)\n                    start = mid+1\n                elif pre > cur:\n                    res = min(res, pre)\n                    end = mid-1\n                else:\n                    res = pre\n                    break\n            memo[(k, n)] = res\n            return res\n        return dp(K, N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = list(range(1, N+1))\n        for _ in range(K-1):\n            temp = [1]\n            for j in range(1, N):\n                temp.append(temp[-1]+dp[j-1]+1)\n            dp = temp\n        for i in range(N):\n            if dp[i] >= N:\n                return i+1", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = list(range(1, N+1))\n        for _ in range(K-1):\n            temp = [1]\n            for j in range(1, N):\n                temp.append(temp[-1]+dp[j-1]+1)\n            dp = temp\n        return [i+1 for i, x in enumerate(dp) if x >= N][0]", "from functools import lru_cache\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        # return self.bottomUp(K, N)\n        # return self.findMoves(K, N)\n        return self.bottomUp2(K, N)\n    \n    @lru_cache(maxsize = None)\n    def findMoves(self, K, N):\n        if K == 1 or N<=1:\n            return N\n        \n        left, right = 1, N\n        while left < right:\n            mid = (left + right) // 2\n            \n            broken = self.findMoves(K-1, mid-1)\n            intact = self.findMoves(K, N-mid)\n            if broken > intact:\n                right = mid\n            else:\n                left = mid+1\n        \n        mid = left -1\n        return 1 + max(self.findMoves(K-1, mid-1), self.findMoves(K, N-mid))\n\n        # f = N            \n        # for x in range (1, N+1):\n        #     f = min(1 + max(self.findMoves(K-1, x-1), self.findMoves(K, N-x)), f)\n        # return f\n    \n    def bottomUp(self, K, N):\n        # compress to 1d array\n        dp = [i for i in range(N+1)]\n        for i in range(2, K+1):\n            prev = dp[:]\n            for j in range(1, N+1):\n                min_drops = N\n                for x in range(1, j+1):\n                    min_drops = min(min_drops, 1 + max(prev[x-1], dp[j-x]))\n                dp[j] = min_drops\n        print(dp)\n        return dp[N]\n    \n    def bottomUp2(self, K, N):\n        dp = [i for i in range(N+1)]\n        \n        for i in range(2, K+1):\n            broken = dp[1]\n            for i in range(2, N+1):\n                prev = dp[i]\n                dp[i] = 1+dp[i-1]+broken\n                broken = prev\n        \n        left, right = 1, N\n        while left < right:\n            mid = (left + right) // 2\n            if dp[mid] >= N:\n                right = mid\n            left = left + 1\n        \n        return left", "class Solution:\n    def binary_search(self,A,k,n):\n        lo = 0\n        hi = n\n        mid = (lo+hi)//2\n        while lo<hi:\n            if A[k-1][mid-1]==A[k][n-mid]:\n                return mid\n            if A[k-1][mid-1]>A[k][n-mid]:\n                hi = mid\n            else:\n                lo = mid+1\n            mid = (lo+hi)//2\n            \n        return lo\n    def superEggDrop(self, K: int, N: int) -> int:\n        if N==1:\n            return 1\n        k=0\n        n=N\n        while n>0:\n            k+=1\n            n//=2\n        if K>k:\n            return k\n        A = [[0 for n in range(N+1)] for k in range(K+1)]\n        \n        for n in range(N+1):\n            A[1][n] = n\n        for k in range(K+1):\n            A[k][1] = 1\n            A[k][2] = 2\n        \n        for k in range(2,K+1):\n            low=1\n            for n in range(3,N+1):\n                # linear search\n                # m=1\n                # while A[k-1][m-1]<A[k][n-m]:\n                #     m+=1\n                \n                #binary search\n                # m = self.binary_search(A,k,n)\n                # A[k][n] = 1+max(A[k-1][m-1],A[k][n-m])\n                \n                # tip-toe\n                # print('k =',k,' n = ',n,low,'    ', A[k-1][low],'   ',A[k][n-low-1],'   ',A[k][n])\n                if A[k-1][low]<A[k][n-low-1]:\n                    low+=1\n                  \n                A[k][n] = 1+A[k-1][low]\n                # print('k =',k,' n = ',n,low,'    ', A[k-1][low],'   ',A[k][n-low-1],'   ',A[k][n])\n                # print('')\n        return A[-1][-1]", "class Solution:\n    def binary_search(self,A,k,n):\n        lo = 0\n        hi = n\n        mid = (lo+hi)//2\n        while lo<hi:\n            if A[k-1][mid-1]==A[k][n-mid]:\n                return mid\n            if A[k-1][mid-1]>A[k][n-mid]:\n                hi = mid\n            else:\n                lo = mid+1\n            mid = (lo+hi)//2\n            \n        return lo\n    def superEggDrop(self, K: int, N: int) -> int:\n        if N==1:\n            return 1\n        k=0\n        n=N\n        while n>0:\n            k+=1\n            n//=2\n        if K>k:\n            return k\n        A = [[0 for n in range(N+1)] for k in range(K+1)]\n        \n        for n in range(N+1):\n            A[1][n] = n\n        for k in range(K+1):\n            A[k][1] = 1\n            A[k][2] = 2\n        \n        for k in range(2,K+1):\n            low=1\n            for n in range(3,N+1):\n                # linear search\n                # m=1\n                # while A[k-1][m-1]<A[k][n-m]:\n                #     m+=1\n                \n                #binary search\n                # m = self.binary_search(A,k,n)\n                # A[k][n] = 1+max(A[k-1][m-1],A[k][n-m])\n                \n                # tip-toe\n                if A[k-1][low]<A[k][n-low-1]:\n                    low+=1\n                  \n                A[k][n] = 1+A[k-1][low]\n        return A[-1][-1]", "#class Solution:\n#    def superEggDrop(self, K: int, N: int) -> int:\n#        def solve(e,f,dp):\n#            if f==0:\n#                return f\n#            elif e==1:\n#                return f\n#         \n#            if dp[e][f]!=-1:\n#                return dp[e][f]\n#            l,h=1,f\n#            while l+1<h:\n#                x=(l+h)//2\n#                if dp[e][f-x]!=-1:\n#                    f1=dp[e][f-x]\n#                else:\n#                    f1=solve(e,f-x,dp)\n#                if dp[e-1][x-1]!=-1:\n#                    f2=dp[e-1][x-1]\n#                else:\n#                    f2=solve(e-1,x-1,dp)\n#                if f1<f2:\n#                    l=x\n#                elif f2>f1:\n#                    h=x\n#                else:\n#                    l=h=x\n#            \n#            ans=1+min(max(solve(e,f-x,dp),solve(e,x-1,dp)) for x in range(l,h+1))\n#            dp[e][f]=ans    \n#            return dp[e][f]\n#        dp=[[-1]*(N+1) for i in range(K+1)]\n#        return solve(K,N,dp)\nclass Solution(object):\n    def superEggDrop(self, K, N):\n        memo = {}\n        def dp(k, n):\n            if (k, n) not in memo:\n                if n == 0 or n==1:\n                    ans = n\n                elif k == 1:\n                    ans = n\n                else:\n                    lo, hi = 1, n\n                    # keep a gap of 2 X values to manually check later\n                    while lo + 1 < hi:\n                        x = (lo + hi) // 2\n                        t1 = dp(k-1, x-1)\n                        t2 = dp(k, n-x)\n\n                        if t1 < t2:\n                            lo = x\n                        elif t1 > t2:\n                            hi = x\n                        else:\n                            lo = hi = x\n                    ans=1000000\n                    for x in range(lo, hi+1):\n                            temp=1+max(dp(k-1, x-1), dp(k, n-x))\n                            if ans>temp:\n                                ans=temp\n                    \n                    \n\n                memo[k, n] = ans\n            return memo[k, n]\n\n        return dp(K, N)", "#class Solution:\n#    def superEggDrop(self, K: int, N: int) -> int:\n#        def solve(e,f,dp):\n#            if f==0:\n#                return f\n#            elif e==1:\n#                return f\n#         \n#            if dp[e][f]!=-1:\n#                return dp[e][f]\n#            l,h=1,f\n#            while l+1<h:\n#                x=(l+h)//2\n#                if dp[e][f-x]!=-1:\n#                    f1=dp[e][f-x]\n#                else:\n#                    f1=solve(e,f-x,dp)\n#                if dp[e-1][x-1]!=-1:\n#                    f2=dp[e-1][x-1]\n#                else:\n#                    f2=solve(e-1,x-1,dp)\n#                if f1<f2:\n#                    l=x\n#                elif f2>f1:\n#                    h=x\n#                else:\n#                    l=h=x\n#            \n#            ans=1+min(max(solve(e,f-x,dp),solve(e,x-1,dp)) for x in range(l,h+1))\n#            dp[e][f]=ans    \n#            return dp[e][f]\n#        dp=[[-1]*(N+1) for i in range(K+1)]\n#        return solve(K,N,dp)\nclass Solution(object):\n    def superEggDrop(self, K, N):\n        memo = {}\n        def dp(k, n):\n            if (k, n) not in memo:\n                if n == 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    lo, hi = 1, n\n                    # keep a gap of 2 X values to manually check later\n                    while lo + 1 < hi:\n                        x = (lo + hi) // 2\n                        t1 = dp(k-1, x-1)\n                        t2 = dp(k, n-x)\n\n                        if t1 < t2:\n                            lo = x\n                        elif t1 > t2:\n                            hi = x\n                        else:\n                            lo = hi = x\n                    ans=1000000\n                    for x in range(lo, hi+1):\n                            temp=1+max(dp(k-1, x-1), dp(k, n-x))\n                            if ans>temp:\n                                ans=temp\n                    \n                    \n\n                memo[k, n] = ans\n            return memo[k, n]\n\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K, N):\n        dp = dict()\n        def recursive(k, n):\n            if k == 1:\n                return n\n            if n == 0:\n                return 0\n            if (k, n) in dp:\n                return dp[(k, n)]\n\n            res = float('INF')\n            l = 1\n            r = n + 1\n            while l <= r:\n                m = int((l + r) / 2)\n                v1 = recursive(k, n - m)\n                v2 = recursive(k - 1, m - 1)\n                res = min(res, max(v1, v2) + 1)\n                if v1 < v2:\n                    r = m - 1\n                elif v1 > v2:\n                    l = m + 1\n                else:\n                    break\n\n            dp[(k, n)] = res\n            return res\n\n        import sys\n        sys.setrecursionlimit(3000)\n        res = recursive(K, N)\n        return res", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = {}\n        def helper(K, N):\n            if N <= 2:\n                return N\n            if K == 1:\n                return N\n\n            if (K, N) not in dp:\n                l = 1\n                r = N\n                while l + 1 < r:\n                    mid = (l + r) // 2\n                    # if egg breaks at midpoint, try egg drop for lower floors\n                    die = helper(K - 1, mid - 1)\n                    # if egg survives, try egg drop for higher floors\n                    live = helper(K, N - mid)\n                    \n                    if die < live:\n                        l = mid\n                    elif die > live:\n                        r = mid\n                    else:\n                        l = r = mid\n                dp[(K, N)] = 1 + min([max(helper(K - 1, l - 1), helper(K, N - l)), max(helper(K - 1, r - 1), helper(K, N - r))])\n            return dp[(K, N)]\n        \n        return helper(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        max_floors = [0 for _ in range(N + 1)]\n\n        for k in range(1, K + 1):\n            next_max_floors = [0 for _ in range(N + 1)]\n            for t in range(1, N + 1):\n                next_max_floors[t] = 1 + max_floors[t - 1] + next_max_floors[t - 1]\n            max_floors = next_max_floors\n        for t in range(N):\n            if max_floors[t] >= N:\n                return t\n        return N\n", "class Solution:\n    def __init__(self):\n        self.memo = {}\n\n    def superEggDrop(self, K: int, N: int) -> int:\n\n        def solve(K, N):\n            d = self.memo.get((K, N))\n\n            if d is None:\n                if K == 1 or N <= 2:\n                    # 1) K == 1: Only one egg is left.\n                    # Drop egg from bottom floor up until it breaks.\n                    # Maximum N drops.\n                    # 2) N <= 2: Simple cases that don't need binary search.\n                    # Same strategy as above.\n                    d = N\n\n                else:\n                    A_min = 1\n                    A_max = N\n\n                    while A_max - A_min > 1:\n                        A = (A_min + A_max) // 2\n                        t1 = solve(K - 1, A - 1)\n                        t2 = solve(K, N - A)\n\n                        if t1 > t2:\n                            A_max = A\n                        elif t2 > t1:\n                            A_min = A\n                        else:\n                            A_min = A_max = A\n\n                    d = 1 + min(\n                        max(\n                            self.memo[K - 1, A - 1],\n                            self.memo[K, N - A]\n                        )\n                        for A in [A_min, A_max]\n                    )\n\n                self.memo[K, N] = d\n\n            return d\n\n        return solve(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = {}\n        def helper(K, N):\n            if N <= 1:\n                dp[(K, N)] = N\n            if K == 1:\n                dp[(K, N)] = N\n\n            if (K, N) not in dp:\n                l = 1\n                r = N\n                while l + 1 < r:\n                    mid = (l + r) // 2\n                    # if egg breaks at midpoint, try egg drop for lower floors\n                    die = helper(K - 1, mid - 1)\n                    # if egg survives, try egg drop for higher floors\n                    live = helper(K, N - mid)\n                    \n                    if die < live:\n                        l = mid\n                    elif die > live:\n                        r = mid\n                    else:\n                        l = r = mid\n                dp[(K, N)] = 1 + min([max(helper(K - 1, l - 1), helper(K, N - l)), max(helper(K - 1, r - 1), helper(K, N - r))])\n            return dp[(K, N)]\n        \n        return helper(K, N)", "# class Solution:\n#     def superEggDrop(self, K: int, N: int) -> int:    \n#         def segment_sum(x,k):\n#             # x is worst case, k is number of eggs available\n#             # returns max N for worst case x, eggs k\n#             if k==1:\n#                 return x\n#             return sum(segment_sum(j, k-1)+1 for j in range(x))\n\n#         worst_case=0\n#         while segment_sum(worst_case, K) < N:\n#             worst_case+=1\n#         return worst_case\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         drops = 0                           # the number of eggs dropped\n#         floors = [0 for _ in range(K + 1)]  # floors[i] is the number of floors that can be checked with i eggs\n\n#         while floors[K] < N:                # until we can reach N floors with K eggs \n\n#             for eggs in range(K, 0, -1):\n#                 floors[eggs] += 1 + floors[eggs - 1]\n#             drops += 1\n\n#         return drops\n\n# class Solution(object):\n#     def superEggDrop(self, K, N):\n#         def f(x):\n#             ans = 0\n#             r = 1\n#             for i in range(1, K+1):\n#                 r *= x-i+1\n#                 r //= i\n#                 ans += r\n#                 if ans >= N: break\n#             return ans\n\n#         lo, hi = 1, N\n#         while lo < hi:\n#             mi = (lo + hi) // 2\n#             if f(mi) < N:\n#                 lo = mi + 1\n#             else:\n#                 hi = mi\n#         return lo\n\n# from scipy.special import comb, factorial, hyp2f1\n# from math import log2, floor\n\n# def h(k,n):\n#     return round(2**n-1-comb(n,k+1)*hyp2f1(1,k-n+1,k+2,-1))\n\n# def h2(k,n):\n#     return sum(comb(n,j) for j in range(1,k+1))\n\n# def fast_sum(k,l):\n#     s = 0\n#     c = 1\n#     for i in range(1,k+1):\n#         c *= (l-i+1)/(i)\n#         s += c\n#     return s\n\n# def e(k, n):\n#     if k == 1:\n#         return n\n#     return sum(e(k-1, j)+1 for j in range(n))\nfrom math import floor, log2\nclass Solution:\n    def superEggDrop(self, k: int, n: int) -> int:\n        best_case = floor(log2(n)+1)\n        if k >= best_case:\n            return best_case\n        def fast_sum(k,l):\n            s = 0\n            c = 1\n            for i in range(k):\n                c *= (l-i)/(i+1)\n                s += c\n            return s\n        if k == 0:\n            return n\n        a, b = 1, n\n        while a < b:\n            c = (a+b)//2\n            if fast_sum(k,c) < n:\n                a = c + 1\n            else:\n                b = c\n        return a", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        def dp(n, k):\n            if (n, k) not in memo:\n                if n == 0:\n                    ret = 0\n                elif k == 1:\n                    ret = n\n                else:\n                    lo, hi = 1, n\n                    while lo+1 < hi:\n                        x = (lo + hi) // 2\n                        t1 = dp(n-x, k)\n                        t2 = dp(x-1, k-1)\n                        if t1 < t2:\n                            hi = x\n                        elif t1 > t2:\n                            lo = x\n                        else:\n                            lo = hi = x\n                    ret = 1 + min(max(dp(n-x, k), dp(x-1, k-1)) for x in (lo, hi))\n                \n                memo[n, k] = ret\n            return memo[n, k]\n        \n        return dp(N, K)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        def dp(k, n):\n            if (k, n) not in memo:\n                if n == 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    lo, hi = 1, n\n                    while lo + 1 < hi:\n                        x = lo + (hi - lo) // 2\n                        t1 = dp(k - 1, x - 1)\n                        t2 = dp(k, n - x)\n                        \n                        if t1 < t2:\n                            lo = x\n                        elif t1 > t2:\n                            hi = x\n                        else:\n                            lo = hi = x\n                    ans = 1 + min(max(dp(k - 1, x - 1), dp(k, n - x)) for x in (lo, hi))\n                memo[(k, n)] = ans\n            return memo[(k, n)]\n        return dp(K, N)\n", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        INF = N + 1\n        cache = {}\n        \n        def eggDropHelper(k, n):\n            if (k, n) in cache:\n                return cache[(k, n)]\n            if (k < 0):\n                return INF\n            if (n == 0):\n                return 0\n            if (k == 0):\n                return INF\n            optAns = INF\n            l, r = 1, n\n            while ((l + 1) < r):\n                m = (l + r) // 2\n                left, right = eggDropHelper(k - 1, m - 1), eggDropHelper(k, n - m)\n                if (left < right):\n                    l = m\n                elif (left > right):\n                    r = m\n                else:\n                    l = r = m\n                    break\n            optAns = max(eggDropHelper(k - 1, l - 1), eggDropHelper(k, n - l)) + 1\n            currAns = max(eggDropHelper(k - 1, r - 1), eggDropHelper(k, n - r)) + 1\n            optAns = min(currAns, optAns)\n            cache[(k, n)] = optAns\n            return cache[(k, n)]\n            \n        return eggDropHelper(K, N)", "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        memo = {}\n        def dp(k, n):\n            ans = 0\n            if (k, n) not in memo:\n                if n == 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    l, r = 1, n\n                    while l + 1 < r:\n                        x = (l + r)//2\n                        t1 = dp(k - 1, x - 1)\n                        t2 = dp(k, n - x)\n                        if t1 > t2:\n                            r = x\n                        elif t1 < t2:\n                            l = x\n                        else:\n                            l = r = x\n                    ans = 1 + min(max(dp(k - 1, x - 1), dp(k, n - x)) for x in (l, r))\n                memo[(k, n)] = ans\n            return memo[(k, n)]\n        return dp(K, N)\n", "class Solution:\n    def superEggDrop(self, K, N):\n        memo = {}\n        def dp(k, n):\n            if (k, n) not in memo:\n                if n == 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    lo, hi = 1, n\n                    # keep a gap of 2 X values to manually check later\n                    while lo + 1 < hi:\n                        x = (lo + hi) // 2\n                        t1 = dp(k-1, x-1)\n                        t2 = dp(k, n-x)\n\n                        if t1 < t2:\n                            lo = x\n                        elif t1 > t2:\n                            hi = x\n                        else:\n                            lo = hi = x\n\n                    ans = 1 + min(max(dp(k-1, x-1), dp(k, n-x)) for x in (lo, hi))\n\n                memo[k, n] = ans\n            return memo[k, n]\n\n        return dp(K, N)", "class Solution(object):\n    def superEggDrop(self, K, N):\n        memo = {}\n        def dp(k, n):\n            if (k, n) not in memo:\n                if n <= 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    lo, hi = 1, n\n                    # keep a gap of 2 X values to manually check later\n                    while lo + 1 < hi:\n                        x = (lo + hi) >> 1\n                        t1 = dp(k-1, x-1)\n                        t2 = dp(k, n-x)\n\n                        if t1 < t2:\n                            lo = x\n                        elif t1 > t2:\n                            hi = x\n                        else:\n                            lo = hi = x\n                            # ans = t1\n                    # if lo == hi:\n                    #     ans = t1\n                    # else:\n                    #     ans = min(t1,t2)\n                    # print(lo,hi)\n                    ans = 1 + min(max(dp(k-1, x-1), dp(k, n-x)) for x in (lo, hi))\n\n                memo[k, n] = ans\n                return memo[k, n]\n            else:\n                return memo[k, n]\n\n        return dp(K, N)", "class Solution:\n    def superEggDrop(self, K, N):\n        memo = {}\n        def dp(k, n):\n            if (k, n) not in memo:\n                if n == 0:\n                    ans = 0\n                elif k == 1:\n                    ans = n\n                else:\n                    lo, hi = 1, n\n                    # keep a gap of 2 X values to manually check later\n                    while lo + 1 < hi:\n                        x = (lo + hi) // 2\n                        t1 = dp(k-1, x-1)\n                        t2 = dp(k, n-x)\n\n                        if t1 < t2:\n                            lo = x\n                        elif t1 > t2:\n                            hi = x\n                        else:\n                            lo = hi = x\n\n                    ans = 1 + min(max(dp(k-1, x-1), dp(k, n-x))\n                                  for x in (lo, hi))\n\n                memo[k, n] = ans\n            return memo[k, n]\n        return dp(K, N)"]
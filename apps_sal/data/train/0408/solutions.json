["class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        n = len(arr)\n        for i in range(n):\n            sol = round(target / n)\n            if arr[i] >= sol:\n                return sol\n            target -= arr[i]\n            n -= 1\n        return arr[-1]", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        s, n = 0, len(arr)\n        \n        for i in range(n):\n            ans = round((target - s)/n)\n            if ans <= arr[i]: return ans \n            s += arr[i]\n            n -= 1\n            \n        return arr[-1]", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr=sorted(arr)\n        sum1=0\n        mindiff=float('inf')\n        val=0\n        n=len(arr)\n        for num in arr:\n            val=(target-sum1)/n\n            if val<=num:\n                val=int(val)\n                if val+1<=num:\n                    if abs(target-sum1-n*val)<=abs(target-sum1-n*(val+1)):\n                        return val\n                    else:\n                        return val+1\n                else:\n                    return val\n            else:\n                n-=1\n                sum1+=num\n                \n        return arr[-1]\n                \n                \n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        min_diff = float('inf')\n        n = len(arr)\n        best = None\n        counter = Counter(arr)\n        count = 0\n        partial_sum = sum(arr)\n        sorting = sorted(counter, key=lambda x: -x)\n        \n        rounding = round(target / n)\n        diff2 = abs(rounding * n - target)\n        if rounding <= sorting[-1] and diff2 < min_diff:\n            best = rounding\n            min_diff = abs(rounding * n - target)\n\n        for i in range(len(sorting)):\n            num = sorting[i]\n            count += counter[num]\n            partial_sum -= num * counter[num]\n            diff = abs(count * num + partial_sum - target)\n            \n            if diff <= min_diff:\n                min_diff = diff\n                best = num\n                \n            rounding = round((target - partial_sum) / count)\n            if rounding > 0 and i < len(sorting) - 1 and rounding > sorting[i + 1] and rounding < sorting[0]:\n                diff2 = abs(rounding * count + partial_sum - target)\n                if diff2 < min_diff:\n                    best = rounding\n                    min_diff = diff2\n            \n        return best\n", "def binsearch(arr,x):\n    if(x<arr[0]):\n        return 0\n    n=len(arr)\n    if(arr[n-1]<=x):\n        return n\n    s=0\n    e=len(arr)-1\n    ret=n\n    while(s<=e):\n        mid=(s+e)//2\n        if(arr[mid]<=x):\n            s=mid+1\n        else:\n            ret=mid\n            e=mid-1\n    return ret\nclass Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        n=len(arr)\n        arr.sort()\n        prefix=[]\n        prefix.append(arr[0])\n        for i in range(1,n):\n            prefix.append(prefix[i-1]+arr[i])\n        prefix.append(0)\n        low=0\n        hi=arr[n-1]\n        minret=1\n        mindiff=sys.maxsize\n        while(low<=hi):\n            mid=(low+hi)//2\n            x=binsearch(arr,mid)\n            val=prefix[x-1]+(n-x)*mid\n            diff=abs(val-target)\n            if(diff==mindiff and mid<minret):\n                minret=mid\n            elif(diff<mindiff):\n                mindiff=diff\n                minret=mid \n            if(val<target):\n                low=mid+1\n            else:\n                hi=mid-1\n        return minret\n            \n", "# class Solution(object):\n#     def getRes(self,arr,t):\n#         nums = [t if num >= t else num for num in arr]\n#         return sum(nums)\n    \n#     def findBestValue(self, arr, target):\n#         \\\"\\\"\\\"\n#         :type arr: List[int]\n#         :type target: int\n#         :rtype: int\n#         \\\"\\\"\\\"\n#         l = 1\n#         h = max(arr)\n        \n#         while l <= h:\n#             mid = (h-l)//2 + l\n#             curr = self.getRes(arr,mid)\n#             if curr == target:\n#                 return mid\n#             elif curr < target:\n#                 l = mid+1\n#             else:\n#                 h = mid-1\n#         if abs(self.getRes(arr,l) - target) < abs(self.getRes(arr,h) - target):\n#             return l\n#         return h\n\nclass Solution:\n    def score(self, value):\n        res = 0\n        for e in self.arr:\n            if e > value:\n                res += value\n            else:\n                res += e\n        return res\n    \n    def findBestValue(self, arr: List[int], target: int) -> int:\n        self.arr = arr[:]\n        l, h = 1, max(arr)\n        while l < h:\n            m = (l+h) // 2\n            if self.score(m) < target:\n                l = m + 1\n            else:\n                h = m\n        #print(l, h)        \n        s1 = abs(self.score(h-1)-target)\n        s2 = abs(self.score(h)-target)\n        if s1 <= s2:\n            return h-1\n        return h\n\n\n# class Solution:\n#     def findBestValue(self, arr: List[int], target: int) -> int:\n#         #int arr \n#         #target is what I want\n#         #Return value\n\n#         #WANT -> Return the value s.t \n# #Constraint -> CHANGE all integers > value in the array to be EQUAL to value. \n# #Get the sum of the array as CLOSE (abs diff) as possible to the target\n\n\n# #In case of tie return the min int \n\n#         def mutated_sum(left, right, target, value):\n#             # abs_diff = 0\n#             cur_sum = 0\n#             for num in arr:\n#                 if num >= value: \n#                     cur_sum += value \n#                 elif num < value: \n#                     cur_sum += num \n                    \n                    \n#              #abs_diff is 1\n#             return cur_sum\n#         #[4, 9, 3] target = 10 \n#         left = 1\n#         right = max(arr)\n#         min_diff = target \n#         prev_min_val = right\n        \n#         #left = 3 \n#         #right = 4\n#         while left < right: \n#             value = left + (right - left) // 2\n#             cur_sum = mutated_sum(left, right, target, value)\n#             if cur_sum == target:\n#                 return value\n#             curr_diff = abs(target - cur_sum)\n            \n#             if curr_diff < min_diff:\n#                 min_diff = curr_diff\n#                 prev_min_val = value\n#             elif curr_diff == min_diff:\n#                 prev_min_val = min(prev_min_val, value)\n#             if cur_sum <= target: #IF MY CUR_SUM is < target \n#                 #THE MORE I MOVE LEFT the farther I am far from target\n#                 # min_diff = cur_diff #min_diff is 1 \n#                 left = value\n            \n#             else: #cur_sum >= target\n#                 right = value - 1\n            \n#         if abs(mutated_sum(left,right, target,left) - target) < \\\\\n#         abs(mutated_sum(left,right, target,right)) - target:\n#             return left\n                \n#         return right\n            \n            \n            \n            \n            \n            \n", "# class Solution(object):\n#     def getRes(self,arr,t):\n#         nums = [t if num >= t else num for num in arr]\n#         return sum(nums)\n    \n#     def findBestValue(self, arr, target):\n#         \\\"\\\"\\\"\n#         :type arr: List[int]\n#         :type target: int\n#         :rtype: int\n#         \\\"\\\"\\\"\n#         l = 1\n#         h = max(arr)\n        \n#         while l <= h:\n#             mid = (h-l)//2 + l\n#             curr = self.getRes(arr,mid)\n#             if curr == target:\n#                 return mid\n#             elif curr < target:\n#                 l = mid+1\n#             else:\n#                 h = mid-1\n#         if abs(self.getRes(arr,l) - target) < abs(self.getRes(arr,h) - target):\n#             return l\n#         return h\n\n# class Solution:\n#     def score(self, value):\n#         res = 0\n#        # print(self.arr)\n#         for e in self.arr:\n#             if e > value:\n#                 res += value\n#             else:\n#                 res += e\n#         return res\n    \n#     def findBestValue(self, arr: List[int], target: int) -> int:\n#         self.arr = arr[:]\n#         l, h = 1, max(arr)\n#         while l < h:\n#             m = (l+h) // 2\n#             if self.score(m) < target:\n#                 l = m + 1\n#             else:\n#                 h = m\n#         #print(l, h)        \n#         s1 = abs(self.score(h-1)-target)\n#         print('s1', s1)\n#         print(h)\n#         # print(l)\n       \n#         s2 = abs(self.score(h)-target)\n#         print('s2', s2)\n#         if s1 <= s2:\n#             return h-1\n#         return h\n\n\nclass Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        #int arr \n        #target is what I want\n        #Return value\n\n        #WANT -> Return the value s.t \n#Constraint -> CHANGE all integers > value in the array to be EQUAL to value. \n#Get the sum of the array as CLOSE (abs diff) as possible to the target\n\n\n# #In case of tie return the min int \n\n        def mutated_sum(value):\n            # print(arr)\n            # abs_diff = 0\n            cur_sum = 0\n            for num in arr:\n                if num > value: \n                    cur_sum += value \n                else: \n                    cur_sum += num \n                    \n                    \n             #abs_diff is 1\n            return cur_sum\n        #[4, 9, 3] target = 10 \n        left = 1\n        right = max(arr)\n        \n        #left = 3 \n        #right = 4\n        while left < right: \n            value = left + (right - left) // 2\n            cur_sum = mutated_sum(value)\n    \n            if cur_sum < target: #IF MY CUR_SUM is < target \n                #THE MORE I MOVE LEFT the farther I am from target\n                # min_diff = cur_diff #min_diff is 1 \n                left = value + 1\n            \n            else: #cur_sum >= target\n                right = value\n            \n      \n        s1 = abs(mutated_sum(left - 1) - target)\n        print(s1)\n        # print(left_abs)\n        # print(right)\n        # print(left)\n        s2 = abs(mutated_sum(left) - target)\n        # print(right_abs)\n        print(s2)\n        if s1 <= s2:\n            return left - 1\n        return left \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        # binary search\n        lo, hi = 0, min(max(arr), 10**5)\n        while lo <= hi:\n            m = (lo+hi)//2\n            s = sum(m if x > m else x for x in arr)\n            if s > target:\n                lo, hi = lo, m-1\n            else:\n                lo, hi = m+1, hi\n                \n        sl = sum(lo if x > lo else x for x in arr)\n        sh = sum(hi if x > hi else x for x in arr)\n        \n        if abs(target - sl) >= abs(target - sh):\n            return hi # hi is lower than lo\n        else:\n            return lo", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        \n        total = sum(arr)\n        if total <= target:\n            return max(arr)\n        \n        arr = sorted(arr)\n\n        min_num = target // len(arr)\n        if min_num <= arr[0]:\n            below = len(arr) * min_num\n            above = len(arr) * (min_num + 1)\n\n            if abs(target - below) <= abs(target - above):\n                return min_num\n            else:\n                return min_num + 1\n        return self.findBestValue(arr[1:], target - arr[0])", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        heapq._heapify_max(arr)\n        steps = []\n        last = heapq._heappop_max(arr)\n        s = last\n        c = 1\n        \n        while len(arr) > 0:\n            v = heapq._heappop_max(arr)\n            s += v\n            \n            if v != last:\n                steps.append([c, last])\n                last = v\n            \n            c += 1\n        \n        steps.append([c, last])\n        \n        i = 0\n        bestDiff = s - target\n        bestValue = steps[0][1]\n        \n        while i < len(steps):\n            t = int((s - target) / steps[i][0])\n            diff = steps[i][0] * t\n            \n            if i != len(steps)-1:\n                diff = steps[i][0] * (steps[i][1] - steps[i+1][1])    \n            \n            if s - diff > target and i != len(steps)-1:\n                s -= diff\n                bestDiff = s - target\n                bestValue = steps[i+1][1]\n\n                i += 1\n            elif s - diff == target:\n                if i != len(steps)-1:\n                    return steps[i+1][1]\n                else:\n                    return steps[i][1] - t\n            else:\n                diff1 = s - (steps[i][0] * t)\n                diff2 = s - (steps[i][0] * (t+1))\n                \n                if bestDiff < abs(diff1 - target):\n                    return bestValue\n                \n                if abs(diff1 - target) >= abs(diff2 - target):\n                    return steps[i][1] - (t+1)\n                else:\n                    return steps[i][1] - t\n                \n        return bestValue\n                \n", "import bisect\nclass Solution:\n        \n    def findBestValue(self, arr: List[int], target: int) -> int:\n        i, j = 0, max(arr)\n        while i <= j: \n            mid = (i + j) // 2\n            dist = sum(v if v < mid else mid for v in arr)\n            # print(i, j, mid, dist)\n            if dist == target: \n                return mid\n            elif dist < target:\n                i = mid + 1 \n            else:\n                j = mid - 1 \n        \n        disti = sum(v if v < i else i for v in arr)\n        disti_1 = sum(v if v < (i-1) else (i-1) for v in arr)\n        print((disti, disti_1, i, j))\n          \n        return i if abs(disti-target)  < abs(disti_1 - target) else (i-1) \n                \n        \n        \n            \n        \n", "import math\n\nclass Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        \n        n = len(arr)\n        arr.sort()\n        \n        def get_candidates(sm, k, l, r):\n            # sm + k * x \u2248 target\n            if k == 0:\n                yield abs(sm - target), l\n            else:\n                y = math.floor((target - sm) / k)\n                for x in [y, y + 1]:\n                    x = max(l, min(r, x))\n                    yield abs(sm + k * x - target), x\n                \n        def get_segments():\n            sm = 0\n            for i in range(n):\n\n                l = 0 if i == 0 else arr[i - 1]\n                r = arr[i] - 1\n\n                if l <= r:\n                    yield sm, n - i, l, r\n\n                sm += arr[i]\n\n            yield sm, 0, arr[-1], int(1e9)\n\n        return min((xd for t in get_segments() for xd in get_candidates(*t)))[1]\n\n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        preSum = [0]\n        for num in arr:\n            preSum.append(preSum[-1]+num)\n        arrLen = len(arr)\n        \n        def checkSum(x):\n            l = 0\n            r = arrLen - 1\n            if x <= arr[0]:\n                return x*arrLen\n            if x >= arr[r]:\n                return preSum[r+1]\n            while r > l:\n                m = (r + l)//2\n                if arr[m] < x:\n                    l = m + 1\n                else:\n                    r = m\n            return preSum[l] + (arrLen-l)*x\n        \n        ll = 0\n        rr = arr[-1]\n        if preSum[arrLen] <= target:\n            return arr[arrLen - 1]\n        while rr > ll:\n            mm = (rr + ll) // 2\n            if checkSum(mm) < target:\n                ll = mm + 1\n            else:\n                rr = mm\n        if abs(checkSum(ll) - target) >= abs(checkSum(ll-1) - target):\n            return ll - 1\n        else:\n            return ll\n        \n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        s = sum(arr)\n        m = max(arr)\n        if s <= target:\n            return m\n        l, r = 1, m+1\n        while l < r:\n            mid = (l+r) // 2\n            cur = self.getSum(arr, mid)\n            if cur == target:\n                return mid\n            elif cur < target:\n                l = mid+1\n            else:\n                r = mid\n        s1 = self.getSum(arr, l)\n        s2 = self.getSum(arr, l-1)\n        return l if abs(s1-target) < abs(s2-target) else l-1\n    \n    def getSum(self, arr, mid):\n        s = 0\n        for i in range(len(arr)):\n            s += mid if arr[i] > mid else arr[i]\n        return s\n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        low = 0 \n        high = (1 << 32)\n        closest_diff = None\n        closest_index = None\n        while ((high - low) > 1):\n            mid = (high + low) // 2\n            mid_val = self.helper(arr,mid)\n            if (closest_diff == None) or (closest_diff > abs(target - mid_val)):\n                closest_index = mid\n                closest_diff = abs(target - mid_val)\n            elif (closest_diff == abs(target - mid_val) and mid < closest_index):\n                closest_index = mid\n                closest_diff = abs(target - mid_val)\n            if (mid_val < target) and (mid <= arr[len(arr) - 1]):\n                low = mid\n            else:\n                high = mid\n                \n        high_val = self.helper(arr,high)\n        if (closest_diff == None) or (closest_diff > abs(target - high_val)):\n            closest_index = high\n            closest_diff = abs(target - high_val)\n        low_val = self.helper(arr,low)\n        if (closest_diff == None) or (closest_diff > abs(target - low_val)):\n            closest_index = low\n            closest_diff = abs(target - low_val)\n        elif (closest_diff == low_val and low < closest_index):\n            closest_index = low\n            closest_diff = abs(target - low_val)\n        return closest_index\n    \n    def helper(self,arr,val):\n        curr_sum = 0\n        for num in arr:\n            if num < val:\n                curr_sum += num\n            else:\n                curr_sum += val\n        return curr_sum", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        if sum(arr) <= target:\n            return max(arr)\n        \n        left, right = 0, max(arr)\n        \n        while(left <= right):\n            \n            #print(left, right)\n            if left == right:\n                return left\n            \n            if left == right -1:\n                sleft, sright = 0, 0\n                \n                for a in arr:\n                    if a < left:\n                        sleft += a\n                    else:\n                        sleft += left\n                    \n                    if a < right:\n                        sright += a\n                    else:\n                        sright += right\n                \n                if abs(sleft - target) <= abs(sright - target):\n                    return left\n                else:\n                    return right\n                \n            mid = (left + right) // 2\n            midarr = []\n            \n            for a in arr:\n                if a < mid:\n                    midarr.append(a)\n                else:\n                    midarr.append(mid)\n            \n            midsum = sum(midarr)\n            if midsum < target:\n                    \n                left = mid\n            else:\n                right = mid\n        \n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n\n        arr = sorted(arr, reverse=True)\n        print(arr)\n        for i in range(len(arr) - 1, -1, -1):\n\n            sol = round(target / (i + 1))\n\n            if arr[i] >= sol:\n                return sol\n            target -= arr[i]\n            \n        return arr[0]\n                \n\n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        low = 0\n        high = max(arr)\n        while low < high:\n            mid = low + (high-low)//2\n            if self.sol(mid,arr,target) <= self.sol(mid+1,arr,target):\n                high = mid\n            else:\n                low = mid+1\n        return low\n    \n    def sol(self,n,num,target):\n        result = 0\n        for i in num:\n            if i > n:\n                result += n\n            else:\n                result += i\n        return abs(result-target)", "class Solution:\n    def check(self, arr, val):\n        total = 0\n        for i, value in enumerate(arr):\n            if value >= val:\n                return total + (len(arr) - i) * val \n            total += value\n        return total\n        \n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        hi = max(arr)\n        lo = 0\n        mid = (lo+hi) // 2\n        \n        limit = hi\n        low_value = abs(self.check(arr, hi) - target)\n        \n        while lo <= hi:\n            calculated_value = self.check(arr, mid)\n            if calculated_value >= target:\n                hi = mid - 1\n                \n            if calculated_value <= target:\n                lo = mid + 1\n                \n            diff = abs(calculated_value - target)\n            if diff < low_value or (diff == low_value and mid < limit):\n                limit = mid\n                low_value = diff\n                \n            mid = (hi + lo) // 2\n            \n        return limit\n            \n    def findBestValue_fast(self, arr, target):\n        arr.sort()\n        ilen = len(arr)\n\n        for i in arr:\n            ideal = round(target / ilen) \n            if ideal <= i:\n                return ideal\n            target -= i\n            ilen -= 1\n\n\n        return arr[-1]\n                \n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        minVal = 0\n        maxVal = arr[0] \n        for val in arr:\n            if val < minVal:\n                minVal = val\n            if val > maxVal:\n                maxVal = val\n        low = minVal \n        high = maxVal \n\n\n        while(low < high):\n            mid = high - (high-low)//2\n\n            if(self.mutationSum(mid, arr) <= target):\n                low = mid\n            else:\n                high = mid-1\n        \n        if (self.mutationSum(low, arr) == target):\n            return low\n        \n        closestBelowInput = low\n        closestBelowVal = self.mutationSum(closestBelowInput, arr)\n        \n        low = minVal \n        high = maxVal \n        while(low < high):\n            mid = low + (high-low)//2\n\n            if(self.mutationSum(mid, arr) >= target):\n                high = mid\n            else:\n                low = mid + 1\n        if(self.mutationSum(high, arr) == target):\n            return high\n\n        closestAboveInput = high \n        closestAboveVal = self.mutationSum(closestAboveInput, arr)\n\n        if (target - closestBelowVal) <= (closestAboveVal - target):\n            return closestBelowInput\n        \n        return closestAboveInput\n\n    def mutationSum(self, m, arr):\n        total = 0\n        for val in arr:\n            if(val > m):\n                total += m\n            else:\n                total += val\n        return total", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        l, r, minDiff, res = 0, max(arr) + 1, float('inf'), float('inf')\n        while l < r:\n            m = l + (r - l) // 2\n            # m is too big, since few num are reduced to m.\n            currSum = 0\n            for n in arr:\n                currSum += min(m, n)\n            if currSum == target:\n                return m\n            currDiff = abs(target - currSum)\n            if currDiff < minDiff:\n                minDiff = currDiff\n                res = m\n            elif currDiff == minDiff:\n                res = min(res, m)\n            if currSum > target:\n                r = m\n            else:\n                l = m + 1\n        return res\n            \n    # https://www.youtube.com/watch?v=j0KejYpI_Mc\n    def findBestValue1(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        length = len(arr)\n        for n in arr:\n            # round is different to //. round(1.2) = 1, round(1.6) = 2\n            res = round(target / length)\n            if n >= res:\n                return res\n            target -= n\n            length -= 1\n        # return biggest num\n        return arr[-1]", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        # r need be max(arr) + 1, not target\n        l, r, minDiff, res = 0, max(arr) + 1, float('inf'), float('inf')\n        while l < r:\n            m = l + (r - l) // 2\n            # m is too big, since few num are reduced to m.\n            currSum = 0\n            for n in arr:\n                currSum += min(m, n)\n            if currSum == target:\n                return m\n            currDiff = abs(target - currSum)\n            if currDiff < minDiff:\n                minDiff = currDiff\n                res = m\n            elif currDiff == minDiff:\n                res = min(res, m)\n            if currSum > target:\n                r = m\n            else:\n                l = m + 1\n        return res\n            \n    # https://www.youtube.com/watch?v=j0KejYpI_Mc\n    def findBestValue1(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        length = len(arr)\n        for n in arr:\n            # round is different to //. round(1.2) = 1, round(1.6) = 2\n            res = round(target / length)\n            if n >= res:\n                return res\n            target -= n\n            length -= 1\n        # return biggest num\n        return arr[-1]", "\n# Notice that the answer is not neccessarily a number from arr.\n\n\nclass Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        def helper(num):\n            new_sum = sum([num if i > num else i for i in arr])\n            return new_sum\n\n        # right is max(arr) because change all the integers larger than value in the given array to be equal to value\n        left, right = 0, max(arr)\n        while left < right:\n            mid = left + (right - left) // 2\n            # need helper(mid) to be as close to target as possible (in absolute difference)\n            if helper(mid) < target:\n                left = mid + 1\n            elif helper(mid) >= target:\n                right = mid\n\n        if abs(helper(left) - target) < abs(helper(left-1) - target):\n            return left\n        else:\n            return left-1\n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        #brute force, linear scan, TIME LIMIT EXCEEDED\n        '''\n        sums = []\n        for i in range(max(arr)+1):\n            currSum = 0 \n            for val in arr: \n                if val > i: \n                    currSum += i\n                else:\n                    currSum += val\n            \n            sums.append((abs(currSum-target),i))\n        sums.sort(key = lambda x:x[0])\n        return sums[0][1]\n        '''\n        \n        #linear scan with stopping condition, works! but really bad lol \n        '''\n        sums = []\n        for i in range(max(arr)+1):\n            currSum = 0 \n            for val in arr: \n                if val > i: \n                    currSum += i\n                else:\n                    currSum += val\n            if currSum-target > 0:\n                sums.append((abs(currSum-target),i))\n                break\n            else:\n                sums.append((abs(currSum-target),i))\n        sums.sort(key = lambda x:x[0])\n        return sums[0][1]\n        '''\n        \n        #binary search, find the minimum integer that meets stopping condition\n        #since you are trying to minimize the difference, stop on the smallest one and find the corresponding value \n        '''\n        def condition(cutoff): \n            currSum = 0\n            for val in arr: \n                if val > cutoff: \n                    currSum += cutoff\n                else:\n                    currSum += val\n            return abs(currSum - target)\n            \n        left, right = 0, target\n        currSum = (float('inf'), -1) #smallest sum, the cutoff value which gives you the smallest sum \n        while left <= right: \n            mid = left + (right - left) // 2\n            checkSum = condition(mid)\n            if checkSum < currSum[0]: #if the smallest sum is smaller than the previous smallest sum, store the cutoff value\n                currSum = (checkSum, mid)\n                right = mid - 1\n            else:\n                left = mid + 1\n            print(left, right)\n        return currSum[1]\n        '''\n        #binary search but look for the cutoff point\n        def condition(cutoff): \n            currSum = 0\n            for val in arr: \n                if val > cutoff: \n                    currSum += cutoff\n                else:\n                    currSum += val\n            return currSum   \n        \n        left, right = 0, max(arr)\n        while left < right: \n            mid = left + (right - left) // 2\n            if condition(mid) < target:\n                left = mid + 1\n            else:\n                right = mid \n\n        if abs(target-condition(left)) < abs(target-condition(left-1)): \n            return left\n        else:\n            return left - 1\n        \n        \n        \n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        vals = sorted(arr)\n        l = len(vals)\n            \n        diff = float('inf')\n        num = -1\n        m = vals[-1]\n        i = 0\n        prev_sum = 0 \n        for n in range(m+1):\n            if n > target:\n                break\n            \n            while n > vals[i]:\n                prev_sum += vals[i]\n                i += 1\n                    \n            total = (n * (l-i)) + prev_sum\n            new_diff = abs(target - total)\n            if new_diff < diff:\n                diff = new_diff\n                num = n\n                \n        \n        return num\n                \n            \n            \n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr = sorted(arr)\n        total = sum(arr)\n        if total <= target:\n            return arr[-1]\n\n        min_num = target // len(arr)\n        if min_num <= arr[0]:\n            below = len(arr) * min_num\n            above = len(arr) * (min_num + 1)\n\n            if abs(target - below) <= abs(target - above):\n                return min_num\n            else:\n                return min_num + 1\n        return self.findBestValue(arr[1:], target - arr[0])", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        left, right = 0, max(arr)\n        \n        while left <= right:\n            mid = (left + right) >> 1\n            count = sum([min(x, mid) for x in arr])\n            if count < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        res1 = sum([min(x, left) for x in arr])\n        res2 = sum([min(x, right) for x in arr])\n        return left if abs(res1-target) < abs(res2-target) else right", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n       \n        \n        # sum_of_mutate(arr, sorted_arr[i]) will be like\n        # L L L L M M\n        # where L = sum_of_mutate[i] less than or equal target, M = more\n        # we want to find last L\n        # then answer can be last L or next M whatever make mutate sum smaller\n        \n        l = 0\n        r= max(arr)\n        \n        while l < r:\n            mid = ((l+r) // 2 ) + 1\n\n            if self.sum_of_mutate(arr, mid) > target:\n                r = mid - 1\n            else:\n                l = mid\n        if abs(self.sum_of_mutate(arr, l) - target) <=  abs(self.sum_of_mutate(arr, l+1) - target):\n            return l\n        else:\n            return l + 1\n\n\n    def sum_of_mutate(self, arr, k):\n        return sum(min(e, k) for e in arr)\n        \n        \n", "class Solution:\n    def findBestValue(self, A, target):\n        \n        def mutedSum(A, t):\n            s = 0\n            for x in A:\n                s += min(x, t)\n            return s\n        \n        l, r = 1, max(A)\n        while l < r:\n            m = (l+r) // 2\n            cur = 0\n            for x in A:\n                cur += min(x, m)\n            if cur <= target:\n                l = m+1\n            else:\n                r = m\n        \n        s1 = mutedSum(A, r)\n        s2 = mutedSum(A, r-1)\n        return r if abs(target-s1) < abs(target-s2) else r-1\n        \n        \n        \n        \n        \n", "class Solution:\n    def check(self, arr, val):\n        result = 0\n        for value in arr:\n            result += min(value, val)\n        return result\n        \n    def findBestValue(self, arr: List[int], target: int) -> int:\n        hi = max(arr)\n        lo = 0\n        mid = (lo+hi) // 2\n        \n        limit = hi\n        low_value = abs(self.check(arr, hi) - target)\n        \n        while lo <= hi:\n            calculated_value = self.check(arr, mid)\n            if calculated_value >= target:\n                hi = mid - 1\n                \n            if calculated_value <= target:\n                lo = mid + 1\n                \n            diff = abs(calculated_value - target)\n            if diff < low_value or (diff == low_value and mid < limit):\n                limit = mid\n                low_value = diff\n                \n                \n            mid = (hi + lo) // 2\n            \n                \n        return limit\n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n       \n        \n        # sum_of_mutate(arr, sorted_arr[i]) will be like\n        # L L L L M M\n        # where L = sum_of_mutate[i] less than or equal target, M = more\n        # we want to find last L\n        # then answer can be last L or next M whatever make mutate sum smaller\n        \n        l = 0\n        r = max(arr)\n        \n        while l < r:\n            mid = ((l+r) // 2 ) + 1\n\n            if sum(min(e, mid) for e in arr) > target:\n                r = mid - 1\n            else:\n                l = mid\n                \n        # then answer can be last L or next M whatever make mutate sum smaller\n        # use less or equal because if it ties, we will choose smaller \n        if abs(sum(min(e, l) for e in arr)- target) <=  abs(sum(min(e, l+1) for e in arr) - target):\n            return l\n        else:\n            return l + 1\n\n        \n        \n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        #brute force, linear scan, TIME LIMIT EXCEEDED\n        '''\n        sums = []\n        for i in range(max(arr)+1):\n            currSum = 0 \n            for val in arr: \n                if val > i: \n                    currSum += i\n                else:\n                    currSum += val\n            \n            sums.append((abs(currSum-target),i))\n        sums.sort(key = lambda x:x[0])\n        return sums[0][1]\n        '''\n        \n        #linear scan with stopping condition, works! but really bad lol \n        '''\n        sums = []\n        for i in range(max(arr)+1):\n            currSum = 0 \n            for val in arr: \n                if val > i: \n                    currSum += i\n                else:\n                    currSum += val\n            if currSum-target > 0:\n                sums.append((abs(currSum-target),i))\n                break\n            else:\n                sums.append((abs(currSum-target),i))\n        sums.sort(key = lambda x:x[0])\n        return sums[0][1]\n        '''\n        \n        #binary search, find the minimum integer that meets stopping condition\n        #since you are trying to minimize the difference, stop on the smallest one and find the corresponding value \n        '''\n        def condition(cutoff): \n            currSum = 0\n            for val in arr: \n                if val > cutoff: \n                    currSum += cutoff\n                else:\n                    currSum += val\n            return abs(currSum - target)\n            \n        left, right = 0, target\n        currSum = (float('inf'), -1) #smallest sum, the cutoff value which gives you the smallest sum \n        while left <= right: \n            mid = left + (right - left) // 2\n            checkSum = condition(mid)\n            if checkSum < currSum[0]: #if the smallest sum is smaller than the previous smallest sum, store the cutoff value\n                currSum = (checkSum, mid)\n                right = mid - 1\n            else:\n                left = mid + 1\n            print(left, right)\n        return currSum[1]\n        '''\n        #binary search but look for the cutoff point\n        def condition(cutoff): \n            currSum = 0\n            for val in arr: \n                if val > cutoff: \n                    currSum += cutoff\n                else:\n                    currSum += val\n            return currSum   \n        \n        left, right = 0, max(arr)\n        while left < right: \n            mid = left + (right - left) // 2\n            if condition(mid) < target:\n                left = mid + 1\n            else:\n                right = mid \n\n        return left if abs(target-condition(left)) < abs(target-condition(left-1)) else left-1\n           \n        \n        \n        \n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        if sum(arr) <= target: return max(arr)\n        lo = 0\n        hi = target\n        \n        best = float('inf')\n        res = float('inf')\n        \n        while lo < hi:\n            mid = (lo + hi) // 2\n            s = sum(min(x, mid) for x in arr)\n            diff = abs(s-target)\n            if diff < best or (diff == best and mid < res):\n                res = mid\n                best = diff\n\n            if s > target:\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        return res\n", "class Solution:\n    \n    def delta (self, val: int,arr: List[int], target: int) -> int:\n            total = 0 \n            \n            for a in arr:\n                if (a < val):\n                    total += a \n                else:\n                    total += val\n            \n            return (abs(total-target))\n        \n        \n            \n    def check(self, val: int,arr: List[int], target: int) -> bool:\n            \n            if ((self.delta(val, arr, target)-self.delta(val+1, arr, target))<=0):\n                return True\n            else: \n                return False\n            \n            \n    def findBestValue(self, arr: List[int], target: int) -> int:\n        \n        lo = 0\n        hi= sum(arr)\n        \n        while(lo<hi):\n            \n            mid = lo +((hi-lo)//2)  \n                \n            if (self.check(mid, arr, target)):\n                hi = mid \n            else: \n                lo = mid +1\n            \n        \n        if (self.check(lo, arr, target)):\n                return lo \n        else : \n            return (0)", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        sum1=sum(arr)\n        low=0\n        min1=[float('Inf')]\n        ans=[0]\n        def check(mid,target):\n            sum1=0\n            for i in arr:\n                if i>mid:\n                    sum1+=mid\n                else:\n                    sum1+=i\n            \n               \n            return sum1\n        \n        def binary(low,high,target):\n            mid=(low+high)//2\n           \n            if low>high:\n                return \n            x=check(mid,target)\n            \n            if x<target:\n                \n                if abs(target-x)<min1[0]:\n                    ans[0]=mid\n                   \n                    min1[0]=abs(target-x)\n                if abs(target-x)==min1[0]:\n                    ans[0]=min(mid,ans[0])\n                binary(mid+1,high,target)\n            else:\n                if abs(target-x)<min1[0]:\n                    ans[0]=mid\n                    min1[0]=abs(target-x)\n                elif abs(target-x)==min1[0]:\n                    ans[0]=min(mid,ans[0])\n                \n                binary(low,mid-1,target)\n        binary(low,max(arr),target)\n        return ans[0]", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        low = 0 \n        high = (1 << 32)\n        closest_diff = None\n        closest_index = None\n        while ((high - low) > 1):\n            mid = (high + low) // 2\n            mid_val = self.helper(arr,mid)\n            if (closest_diff == None) or (closest_diff > abs(target - mid_val)):\n                closest_index = mid\n                closest_diff = abs(target - mid_val)\n            elif (closest_diff == abs(target - mid_val) and mid < closest_index):\n                closest_index = mid\n                closest_diff = abs(target - mid_val)\n                \n            print(high,low,mid,self.helper(arr,mid),closest_index)\n\n            if (mid_val < target) and (mid <= arr[len(arr) - 1]):\n                low = mid\n            else:\n                high = mid\n                \n        high_val = self.helper(arr,high)\n        if (closest_diff == None) or (closest_diff > abs(target - high_val)):\n            closest_index = high\n            closest_diff = abs(target - high_val)\n        low_val = self.helper(arr,low)\n        if (closest_diff == None) or (closest_diff > abs(target - low_val)):\n            closest_index = low\n            closest_diff = abs(target - low_val)\n        elif (closest_diff == low_val and low < closest_index):\n            closest_index = low\n            closest_diff = abs(target - low_val)\n        return closest_index\n    \n    def helper(self,arr,val):\n        curr_sum = 0\n        for num in arr:\n            if num < val:\n                curr_sum += num\n            else:\n                curr_sum += val\n        return curr_sum", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        def calculate(value):\n            s = 0\n            for x in arr:\n                s += min(x, value)\n            \n            return s\n        \n        l, r = 1, max(arr)\n        while l <= r:\n            mid = l + (r - l) // 2\n            if calculate(mid) < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        if abs(calculate(l - 1) - target) <= abs(calculate(l) - target):\n            return l - 1\n        \n        return l\n        \n", "import bisect\n\n\ndef calc(val, arr, prefix):\n    i = bisect.bisect_left(arr, val)\n    return prefix[i] + (len(arr) - i) * val\n\n\nclass Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        prefix = [0]\n        for i, a in enumerate(arr):\n            prefix.append(prefix[i] + a)\n\n        l, h = 0, arr[-1]\n        if h * len(arr) <= target:\n            return h\n\n        while l < h - 1:\n            m = (l + h) // 2\n            curr = calc(m, arr, prefix)\n            if curr >= target:\n                h = m\n            else:\n                l = m\n\n        l_d = abs(target - calc(l, arr, prefix))\n        h_d = abs(target - calc(h, arr, prefix))\n\n        if l_d <= h_d:\n            return l\n        else:\n            return h\n", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        # \n        if not arr:\n            return 0\n        if len(arr) == 1:\n            return arr[0] if arr[0] <= target else target\n        value = 1\n        sum_up = 0\n        index = 0\n        last_sum = 0\n        arr.sort()\n        while value < arr[-1]:\n            \n            current_sum = 0\n            while value >= arr[index]:\n                sum_up += arr[index]\n                index += 1\n            current_sum =  sum_up + ((len(arr) - index) * value)\n            if current_sum == target:\n                return value\n            elif current_sum > target:\n                if abs(last_sum - target) <= abs(current_sum - target):\n                    return value - 1\n                else:\n                    return value\n            else:\n                last_sum = current_sum\n            value += 1            \n            \n        return value", "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        nums = [-x for x in arr]\n        heapify(nums)\n        currSum = sum(arr)\n        N = len(nums)\n        \n        bestVal = -nums[0]\n        bestDifference = float('inf')\n        \n        def testValue(value):\n            sumWithIdeal = currSum + numElementsToChange * value\n            difference = abs(target - sumWithIdeal)\n            if value <= nextLargest and value >= (-nums[0] if nums else 0):\n                if difference < bestDifference:\n                    return int(value), abs(target - sumWithIdeal)\n                elif difference == bestDifference:\n                    return min(bestVal, int(value)), bestDifference\n            return bestVal, bestDifference\n                        \n        while nums:\n            nextLargest = -heappop(nums)\n            currSum -= nextLargest\n            numElementsToChange = N - len(nums)\n            if currSum <= target:\n                idealValue = (target - currSum) / numElementsToChange\n                if idealValue.is_integer():\n                    bestVal, bestDifference = testValue(idealValue)\n                else:\n                    bestVal, bestDifference = testValue(floor(idealValue))\n                    bestVal, bestDifference = testValue(ceil(idealValue))\n                    \n        return bestVal"]
["class Solution(object):\n    def isSubPath(self, h, r0):\n        h_vals = []\n        while h:\n            h_vals.append(str(h.val))\n            h = h.next\n        h_str = ('-'.join(h_vals)) + '-'  # serialized list\n\n        st = [(r0, '-')]  # DFS stack\n\n        while st:\n            r, pre = st.pop()\n            if not r:\n                continue\n\n            pre = pre + str(r.val) + '-'\n            if pre.endswith(h_str):\n                return True\n\n            st.append((r.left, pre))\n            st.append((r.right, pre))\n\n        return False", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        arr = []\n        while head:\n            arr.append(head.val)\n            head = head.next\n        \n        t = [-1]\n        pos, cnd = 1, 0\n        while pos < len(arr):\n            if arr[pos] == arr[cnd]:\n                t.append(t[cnd])\n            else:\n                t.append(cnd)\n                cnd = t[cnd]\n                while cnd >= 0 and arr[pos] != arr[cnd]:\n                    cnd = t[cnd]\n            pos += 1\n            cnd += 1\n        t.append(cnd)\n        \n        def dfs(root, i):\n            if i == len(arr):\n                return True\n            if root is None:\n                return False\n            while i >= 0 and root.val != arr[i]:\n                i = t[i]\n            return dfs(root.left, i+1) or dfs(root.right, i+1)\n\n        return dfs(root, 0)", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        def dfs(root, head):\n            if not root and not head: return True\n            if not head and root: return True\n            if not root and head: return False\n            if root.val != head.val: return False\n            left = dfs(root.left, head.__next__)\n            right = dfs(root.right, head.__next__)\n            return left or right\n        \n        if not root: return False\n        if dfs(root, head): return True\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        # find the beginning of list node in tree. then traverse\n        def helper(lNode, TNode):\n            if not lNode:\n                return True\n            if not TNode:\n                return False\n            return TNode.val == lNode.val and (\n                helper(lNode.next, TNode.left) or helper(lNode.next, TNode.right)\n            )\n        \n        if not head:\n            return True\n        if not root:\n            return False\n        return helper(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        def dfs(p,q):\n            if not p:\n                return True\n            if not q or p.val!=q.val:\n                return False\n            if p.val==q.val:\n                return dfs(p.__next__,q.right) or dfs(p.__next__,q.left)\n            return False\n        if not root:\n            return False\n        if not head:\n            return True\n        return dfs(head,root) or self.isSubPath(head,root.right) or self.isSubPath(head,root.left)\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        def fromHeadPath(h, r):\n            if not h or not r:\n                return False\n            if h.val != r.val:\n                return False\n            if not h.__next__:\n                return True\n            return fromHeadPath(h.__next__, r.left) or fromHeadPath(h.__next__, r.right)\n        \n        if not head or not root:\n            return False\n        if fromHeadPath(head, root):\n            return True\n        \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n    \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode, path=None, cool=None) -> bool:\n        path = path or []\n        cool = cool or []\n        path.append(root.val)\n        cool = [node.__next__ for node in cool if node.val == root.val]\n        if root.val == head.val:\n            cool.append(head.__next__)\n            \n        if None in cool:\n            return True\n        \n        l = r = False\n        if root.left:\n            l = self.isSubPath(head, root.left, path.copy(), cool)\n            if l is True:\n                return True\n        if root.right:\n            r = self.isSubPath(head, root.right, path.copy(), cool)\n            if r is True:\n                return True\n\n        if root.left is None and root.right is None:\n            cool = []\n        return False\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode, path=None, cool=None) -> bool:\n        path = path or []\n        cool = cool or dict()\n        path.append(root.val)\n        cool = {node.__next__ for node in cool if node.val == root.val}\n        if root.val == head.val:\n            cool.add(head.__next__)\n            \n        if None in cool:\n            return True\n        \n        l = r = False\n        if root.left:\n            l = self.isSubPath(head, root.left, path.copy(), cool)\n            if l is True:\n                return True\n        if root.right:\n            r = self.isSubPath(head, root.right, path.copy(), cool)\n            if r is True:\n                return True\n\n        if root.left is None and root.right is None:\n            cool = []\n        return False\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    \n    def traverse(self, head: ListNode, node:ListNode, root: TreeNode) -> bool:\n        if not node:\n            return True\n        if not root:\n            return False\n        print(\\\"comparing \\\" + str(root.val) + \\\" with \\\" + str(node.val))\n        res = root.val == node.val\n        if res:\n            node = node.next\n        else:\n            node = head\n            if root.val == node.val:\n                node = node.next\n        res = self.traverse(head, node, root.left)\n        res = res or self.traverse(head, node, root.right)\n        return res\n    \n    def find(self, node: ListNode, root: TreeNode) -> bool:\n        if not node:\n            return True\n        if not root:\n            return False\n        print(\\\"comparing \\\" + str(root.val) + \\\" with \\\" + str(node.val))\n        if node.val == root.val:\n            return self.find(node.next, root.left) or self.find(node.next, root.right)\n        return False\n    \n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        # if not root or not head:\n        #     return False\n        # return self.traverse(head, head, root)\n        if not root:\n            return False\n        check = head.val == root.val\n        if check and (self.find(head.next, root.left) or self.find(head.next, root.right)):\n            return True\n        else:\n            return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)", "class Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        if root:\n            return self.traverse(root, head)\n        \n    def traverse(self, cur, head):\n        if self.startwith(cur, head):\n            return True\n        else:\n            if cur.left and self.traverse(cur.left, head):\n                return True\n            elif cur.right and self.traverse(cur.right, head):\n                return True\n        return False\n    \n    def startwith(self, startnode, head) -> bool:\n        if startnode.val == head.val:\n            if head.next == None:\n                return True\n            if startnode.left and self.startwith(startnode.left, head.next):\n                return True\n            elif startnode.right and self.startwith(startnode.right, head.next):\n                return True\n            False\n        else:\n            return False", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        def dfs(head, root):\n            if not head: return True\n            if not root: return False\n            return root.val == head.val and (dfs(head.next, root.left) or dfs(head.next, root.right))\n        if not head: return True\n        if not root: return False\n        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef match(head, root):\n    if not head.next and root:\n        return head.val == root.val\n    elif not root:\n        return 0\n    return head.val == root.val and (match(head.next, root.left) or match(head.next, root.right))\n\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        if not root:\n            return 0\n        return match(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right) \n        \n\n\n\\\"\\\"\\\"\ns = Solution()\nn4 = TreeNode(4)\nn3 = TreeNode(3, n4)\nn2 = TreeNode(2, None, n3)\nn4 = TreeNode(41)\nn1 = TreeNode(1, n2, n4)\nn5 = TreeNode(5)\nn4 = TreeNode(4, None, n5)\nn3 = TreeNode(3, n4)\nn2 = TreeNode(2, None, n3)\nn1 = TreeNode(1, None, n2)\nprint(s.longestZigZag(n1))\n\\\"\\\"\\\"\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        Head = head\n        @lru_cache(None)\n        def helper(root,head):\n            if(head is None):\n                return True\n            if(root is None):\n                return False\n            ans = False\n            if(root.val == head.val):\n                ans = ans or helper(root.left,head.__next__)\n                ans = ans or helper(root.right, head.__next__)\n            ans = ans or helper(root.left, Head)\n            ans = ans or helper(root.right, Head)\n            return ans\n        return helper(root,head)\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        def dfs(head, root):\n            if not head: return True\n            if not root: return False\n            if root.val == head.val:\n                return dfs(head.next, root.left) or dfs(head.next, root.right)\n        \n        if not head: return True\n        if not root: return False\n        if dfs(head, root): return True\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        if head is None:\n            return True\n        if root is None:\n            return False\n        return self.rfun(root,head) or self.isSubPath(head,root.left) or  self.isSubPath(head,root.right)\n        \n    def rfun(self,root,head):\n        if head is None:\n            return True\n        if root is None:\n            return False\n        return root.val == head.val and (self.rfun(root.left,head.next) or self.rfun(root.right,head.next))", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        def dfs(head, root):\n            if not head: return True\n            if not root: return False\n            return root.val == head.val and (dfs(head.__next__, root.left) or dfs(head.__next__, root.right))\n        if not head: return True\n        if not root: return False\n        return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n        \n        \n#         def dfs(head, root):\n#             if not head:\n#                 return True\n\n#             if not root:\n#                 return False\n\n#             if root.val == head.val:\n#                 return self.isSubPath(head.next, root.left) \\\\\n#             or self.isSubPath(head.next, root.right)\n#             else:\n#                 return False\n        \n#         if not head:\n#             return True\n\n#         if not root:\n#             return False\n        \n#         return dfs(head,root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:        \n        memo = {}\n        def _isSubPath(head,listnode,root):\n            if listnode is None:\n                return True \n            \n            if root is None:\n                return False\n            \n            if (listnode, root) in memo:\n                return memo[(listnode,root)]\n            \n            ret = False\n            if root.val == listnode.val:\n                ret = _isSubPath(head,listnode.__next__,root.left) or _isSubPath(head,listnode.__next__,root.right)\n            if ret:\n                memo[(listnode,root)] = ret\n                return True\n         \n            ret = _isSubPath(head,head,root.left) or _isSubPath(head,head,root.right) \n            memo[(listnode,root)] = ret\n            return ret\n            \n        return _isSubPath(head,head,root)\n        # def dfs(head, root):\n        #     if not head: return True\n        #     if not root: return False\n        #     return root.val == head.val and (dfs(head.next, root.left) or dfs(head.next, root.right))\n        # if not head: return True\n        # if not root: return False\n        # return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        def helper(temp,root):\n            if not temp:\n                return 1 \n            if not root:\n                return 0\n            if root.val==temp.val:\n                a=helper(temp.__next__,root.left)\n                b=helper(temp.__next__,root.right)\n                return a or b\n            return 0 \n                \n        def fun(head,root):\n            temp=head\n            if not root :\n                return 0 \n            if helper(temp,root):\n                return 1 \n            a=fun(head,root.left)\n            b=fun(head,root.right)\n            return a or b\n        return fun(head,root)\n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode, path=None, cool=None) -> bool:\n        path = path or []\n        cool = cool or []\n        path.append(root.val)\n        cool_n = []\n        for i in cool:\n            if i.val == root.val:\n                cool_n.append(i.__next__)\n                if cool_n[-1] == None:\n                    return True\n        cool = cool_n\n        if root.val == head.val:\n            cool.append(head.__next__)\n            if cool[-1] == None:\n                return True\n        \n        l = r = False\n        if root.left:\n            l = self.isSubPath(head, root.left, path.copy(), cool)\n            if l is True:\n                return True\n        if root.right:\n            r = self.isSubPath(head, root.right, path.copy(), cool)\n            if r is True:\n                return True\n\n        if root.left is None and root.right is None:\n            cool = []\n        return False\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:        \n        memo = {}\n        def _isSubPath(head,listnode,root):\n            if listnode is None:\n                return True \n            \n            if root is None:\n                return False\n            \n            if (listnode, root) in memo:\n                return memo[(listnode,root)]\n            \n            ret = False\n            if root.val == listnode.val:\n                ret = _isSubPath(head,listnode.__next__,root.left) or _isSubPath(head,listnode.__next__,root.right)\n            \n            ret = ret or  _isSubPath(head,head,root.left) or _isSubPath(head,head,root.right)\n            memo[(listnode,root)] = ret\n            return ret \n            \n        return _isSubPath(head,head,root)\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        target = \\\"\\\"\n        while head:\n            target = target + str(head.val)\n            head = head.next\n            #print(target) # LList is a str = 428\n\n        def dfs(root, path):\n            # print(path) #1426 1428\n            if target in path: # matched\n                return True      \n            if root.left:\n                ans =  dfs(root.left, path + str(root.left.val))\n                if ans:  #if ans == True:\n                    return True          \n            if root.right:\n                ans  = dfs(root.right, path + str(root.right.val))\n                if ans: return True       \n            return False            \n        return dfs(root, str(root.val))\n        \n            \n        ", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        if head == None:\n            return True\n        if root == None:\n            return False\n        # judge root, then judge root.left and root.right\n        return self.isSub(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n    \n    def isSub(self, head, node):\n        # list is over\n        if head == None:\n            return True\n        # list is not over and tree is over\n        if node == None:\n            return False\n        # not equal\n        if not head.val == node.val:\n            return False\n        # equal, then left and right\n        return self.isSub(head.next, node.left) or self.isSub(head.next, node.right)", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        s = [root]\n        while s:\n            t = s.pop()\n            if self.dfs(head, t):\n                return True\n            if t:\n                if t.left:\n                    s.append(t.left)\n                if t.right:\n                    s.append(t.right)\n        return False\n\n    def dfs(self, head: ListNode, root: TreeNode) -> bool:\n        # print(head.val if head else head, root.val if root else root)\n        if head is None:\n            return True\n        if root is None:\n            return False\n        if root.val==head.val:\n            return self.dfs(head.next, root.left) or self.dfs(head.next, root.right)\n        return False", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        \n        def rec(head,root,connected):\n            if not head or not root:\n                return False\n            if connected and head.val==root.val:\n                if head.__next__:\n                    left=rec(head.__next__,root.left,True)\n                    right=rec(head.__next__,root.right,True)\n                    return left or right\n                else:\n                    return True\n            if head.val!=root.val and connected:\n                return False\n            if not connected:\n                if head.val==root.val:\n                    left_noConn=rec(head,root.left,False)\n                    right_noConn=rec(head,root.right,False)\n                    if head.__next__:\n                        left=rec(head.__next__,root.left,True)\n                        right=rec(head.__next__,root.right,True)\n                    else:\n                        return True\n                    return left or right or left_noConn or right_noConn\n                else:\n                    left_noConn=rec(head,root.left,False)\n                    right_noConn=rec(head,root.right,False)\n                    return left_noConn or right_noConn\n                \n                return left or right\n        \n        return rec(head,root,False)\n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        \n        visited = set()\n        \n        def checkNode(treePointer, listPointer):\n            if listPointer == None:\n                return True\n            if treePointer == None and listPointer != None:\n                return False\n            \n            if (treePointer, listPointer) in visited:\n                return False\n            \n            if treePointer.val == listPointer.val:\n                if checkNode(treePointer.left, listPointer.next) or checkNode(treePointer.right, listPointer.next):\n                    return True\n                \n            if treePointer.val == head.val:\n                if checkNode(treePointer.left, head.next) or checkNode(treePointer.right, head.next):\n                    return True     \n            \n            if checkNode(treePointer.left, head) or checkNode(treePointer.right, head):\n                    return True     \n            \n            visited.add((treePointer, listPointer))\n            return False\n        \n        return checkNode(root, head)", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        @lru_cache(maxsize=None)\n        def helper(llNode, tNode) -> bool:\n            if not llNode:\n                return True\n            if not tNode:\n                return False\n            result = False\n            nonlocal head\n            # print(llNode.val, tNode.val, head.val)\n            if tNode.val == llNode.val:\n                result = result \\\\\n                    or helper(llNode.next, tNode.left) \\\\\n                    or helper(llNode.next, tNode.right)\n            if tNode.val == head.val:\n                result = result \\\\\n                    or helper(head.next, tNode.left) \\\\\n                    or helper(head.next, tNode.right)\n            else:\n                result = result \\\\\n                    or helper(head, tNode.left) \\\\\n                    or helper(head, tNode.right)\n\n            return result\n        \n        return helper(head, root)\n        ", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def dfs(self, nums, i, tree_node, memo):\n        if i >= len(nums):\n            return True\n        if not tree_node:\n            return False\n        \n        key = str(i) + ':' + str(id(tree_node))\n        if key in memo:\n            return memo[key]\n        # print('i: ' + str(i) +  ', node: ' + str(id(tree_node)))\n        \n        if tree_node.val == nums[i]:\n            left = self.dfs(nums, i+1, tree_node.left, memo)\n            right = self.dfs(nums, i+1, tree_node.right, memo)\n            if left or right:\n                return True\n            \n        left = self.dfs(nums, 0, tree_node.left, memo)\n        right = self.dfs(nums, 0, tree_node.right, memo)\n        \n        memo[key] = left or right\n        \n        return left or right\n        \n    \n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        if not head:\n            return True\n        if not root:\n            return False\n        \n        memo = {}\n        \n        nums = []\n        curr = head\n        while curr:\n            nums.append(curr.val)\n            curr = curr.next\n        \n        return self.dfs(nums, 0, root, memo)", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        if head==None:\n            return 1\n        if root==None:\n            return 0\n        self.arr=[]\n        def trav(root,val):\n            if root:\n                if root.val==val:\n                    self.arr.append(root)\n                trav(root.left,val)\n                trav(root.right,val)\n        trav(root,head.val)\n        p=head\n        while self.arr:\n            p=p.next\n            if p==None:\n                return 1\n            i=0\n            r=len(self.arr)\n            while i<r:\n                node=self.arr.pop(0)\n                if node.left:\n                    if node.left.val==p.val:\n                        self.arr.append(node.left)\n                if node.right:\n                    if node.right.val==p.val:\n                        self.arr.append(node.right)\n                i+=1\n        return 0", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        \n        def dfs(nodeL, nodeT):\n            if not nodeT and nodeL:\n                return False\n            if not nodeL:\n                return True\n            if nodeL.val == nodeT.val:\n                return dfs(nodeL.next, nodeT.left) or dfs(nodeL.next, nodeT.right)\n            \n            return False\n            \n            \n        bfs = collections.deque([root])\n        while bfs:\n            node = bfs.popleft()\n            if dfs(head, node):\n                return True\n            if node.left:\n                bfs.append(node.left)\n            if node.right:\n                bfs.append(node.right)\n        return False", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode, current=None) -> bool:\n        # traverse tree checking \n        if head is None or root is None:\n            return False\n        if self.check_children(head, root):\n            return True\n        return (self.isSubPath(head, root.left) or\n                self.isSubPath(head, root.right))\n        \n    def check_children(self, head: ListNode, root: TreeNode):\n        if head is None or root is None:\n            return False\n        if head.val == root.val:\n            if head.next is None:\n                return True\n            else:\n                return (self.check_children(head.next, root.left) or\n                        self.check_children(head.next, root.right))\n\n        else:\n            return False", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        def checker(l1, l2):\n            if len(l1) < len(l2): return False\n            \n            for i in range(len(l2)):\n                if l2[len(l2)-1-i] != l1[len(l1)-1-i]: return False\n            return True\n        \n        pattern = []\n        while(head):\n            pattern.append(head.val)\n            head = head.next\n        \n        self.res = False\n        def traverse(root, S=[]):\n            if self.res: return True\n            if root == None: return False\n            if checker(S+[root.val], pattern): \n                self.res = True\n                return True\n            traverse(root.left, S+[root.val])\n            traverse(root.right, S+[root.val])\n        \n        traverse(root)\n        return self.res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        # 6:39 10/7/20\n        \n        # BFS + DFS\n        \n        def dfs(node):\n            if not node:\n                return\n            if node.val == head.val:\n                q.appendleft((node, head, set()))\n            dfs(node.left)\n            dfs(node.right)\n        \n        # Step 1: Use DFS to add every node that has the same value with that of head to a queue\n        q = collections.deque()\n        dfs(root)\n        \n        # Step 2: Use BFS to walk down the path where both node and linked list have the same value\n        while q:\n            tree_node, list_node, visited = q.pop()\n            if tree_node.val == list_node.val:\n                if not list_node.__next__:  \n                    return True # Finally, we reached the end of linked list. \n                for nei in (tree_node.left, tree_node.right):\n                    if nei and nei not in visited and nei.val == list_node.next.val:\n                        visited.add(nei)\n                        q.appendleft((nei, list_node.__next__, visited))\n                        visited.remove(nei)\n        return False\n        \n\n            \n           \n                    \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        if (not root and not head) or (not root and head):\n            return False\n        elif root and not head:\n            return True\n        \n        memory = []\n        \n        def preorder(node: ListNode):\n            if not node:\n                return\n            \n            nonlocal head\n            nonlocal memory\n            \n            if node.val == head.val:\n                memory.append(node)\n            \n            preorder(node.left)\n            preorder(node.right)\n            \n        preorder(root)\n        head = head.__next__\n        \n        while head and memory:\n            newMemory = []\n            \n            for node in memory:\n                if node.left and node.left.val == head.val:\n                    newMemory.append(node.left)\n                if node.right and node.right.val == head.val:\n                    newMemory.append(node.right)\n            \n            head = head.__next__\n            memory = newMemory\n                    \n        return len(memory) > 0\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        paths = []\n        def dfs(root, arr):\n            arr1 = arr + [str(root.val)]\n            if root.left:\n                dfs(root.left, arr1)\n            if root.right:\n                dfs(root.right, arr1)\n            if not root.left and not root.right:\n                paths.append(arr1)\n        dfs(root, [])\n        target = []\n        while head:\n            target.append(str(head.val))\n            head = head.next\n        tar = '#'.join(target)\n        for path in paths:\n            if tar in '#'.join(path):\n                return True\n        return False", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPathHelper(self, cur, root):\n        if not cur:\n            return True\n        if not root:\n            return False\n        return cur.val == root.val and (self.isSubPathHelper(cur.__next__, root.left) or self.isSubPathHelper(cur.__next__, root.right))  \n        \n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        if not root:\n            return False\n        found = self.isSubPathHelper(head, root)\n        nodes = []\n        if root.left:\n            nodes.append(root.left)\n        if root.right:\n            nodes.append(root.right)\n        for node in nodes:\n            found |= self.isSubPath(head, node)\n        return found         \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # Time Complextity O(root)*O(head)\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        helper = set()\n        \n        # Find all possible start\n        def getStart(p):\n            if p:\n                if p.val == head.val:\n                    helper.add(p)\n                getStart(p.left)\n                getStart(p.right)\n                \n        # Main\n        getStart(root)\n        #print(helper)\n        \n        while head.next:\n            new = set()\n            for node in helper:\n                if node.val == head.val:\n                    if node.left:\n                        new.add(node.left)\n                    if node.right:\n                        new.add(node.right)\n            helper = new\n            \n            if not helper:\n                return False\n            \n            head = head.next\n\n        return (head.val in [node.val for node in helper])", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def _iter(self, root):\n        if root is not None:\n            yield root\n            yield from self._iter(root.left)\n            yield from self._iter(root.right)\n    \n    def _search(self, head, root):\n        if head is None or root is None:\n            return head is None\n        elif head.val == root.val:\n            return self._search(head.next, root.left) or self._search(head.next, root.right)\n        else:\n            return False\n        \n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        for node in self._iter(root):\n            if node.val == head.val:\n                if self._search(head, node):\n                    return True\n        return False", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        if not head or not root:\n            return False\n        queue = deque([root])\n        while queue:\n            tNode = queue.pop()\n            if tNode.val == head.val:\n                if self.getListExistsAsPath(head,tNode):\n                    return True\n            if tNode.left:\n                queue.appendleft(tNode.left)\n            if tNode.right:\n                queue.appendleft(tNode.right)\n        return False\n    \n    def getListExistsAsPath(self,lNode,tNode):\n        if not lNode:\n            return True\n        if not tNode or tNode.val != lNode.val:\n            return False\n        \n        return True and (self.getListExistsAsPath(lNode.__next__,tNode.left) or self.getListExistsAsPath(lNode.__next__,tNode.right))\n            \n           \n                    \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        if not head:\n            return True\n        if not root:\n            return False\n        return self.dfs(head,root) or self.isSubPath(head,root.left) or self.isSubPath(head,root.right) \n        \n    def dfs(self,head,root):\n        if not head:\n            return True\n        if not root:\n            return False\n        return head.val==root.val and (self.dfs(head.next,root.left) or self.dfs(head.next,root.right))", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        def dfs(cur, node):\n            if not cur:\n                return True\n            if not node:\n                return False\n            if cur.val == node.val:\n                return dfs(cur.__next__, node.left) or dfs(cur.__next__, node.right)\n            return False\n        stack = [root]\n        while stack:\n            for node in stack:\n                cur = head\n                if dfs(cur, node):\n                    return True\n            stack = [leaf for node in stack for leaf in [node.left, node.right] if leaf]\n        return False\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def matchPath(self, head, root):\n        if head is None:\n            return True\n        if root is None:\n            return False\n        \n        if head.val != root.val:\n            return False\n        \n        if self.matchPath(head.next, root.left):\n            return True\n        \n        if self.matchPath(head.next, root.right):\n            return True\n        \n        return False\n        \n    \n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        nexts = [root]\n        while len(nexts) > 0:\n            node = nexts.pop()\n            if node.val == head.val:\n                if self.matchPath(head, node):\n                    return True\n            if node.left:\n                nexts.append(node.left)\n            if node.right:\n                nexts.append(node.right)\n        \n        return False", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        result = False\n        if not root:\n            return False\n        \n        result = self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n        \n        if head.val == root.val:\n            l_node = head\n            g_node = root\n            result = result or self.match(head, root)\n        \n        return result\n            \n    def match(self, head: ListNode, root: TreeNode) -> bool:\n        if not head:\n            return True\n        \n        if not root or head.val != root.val:\n            return False\n        \n        return self.match(head.next, root.left) or self.match(head.next, root.right)"]
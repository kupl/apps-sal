["class Solution:\n     def maxProfit(self, k, prices):\n         \"\"\"\n         :type k: int\n         :type prices: List[int]\n         :rtype: int\n         \"\"\"\n         length = len(prices)\n         v = p = 0\n         pairs, profits = [], []\n         \n         while p < length:\n             \n             v = p\n             while v < length - 1 and prices[v] >= prices[v+1]:\n                 v += 1\n \n             p = v+1\n             while p < length and prices[p] >= prices[p-1]:\n                 p += 1\n \n             \n             while pairs and prices[v] < prices[pairs[-1][0]]:\n                 heapq.heappush(profits, prices[pairs[-1][0]] - prices[pairs[-1][1] - 1])\n                 pairs.pop()\n \n             while pairs and prices[p-1] >= prices[pairs[-1][1] - 1]:\n                 heapq.heappush(profits, prices[v] - prices[pairs[-1][1] - 1])\n                 v = pairs[-1][0]\n                 pairs.pop()\n \n             pairs.append((v, p))\n \n         while pairs:\n             heapq.heappush(profits, prices[pairs[-1][0]] - prices[pairs[-1][1] - 1])\n             pairs.pop()\n \n \n         ans = 0\n         while k != 0 and profits:\n             ans += -heapq.heappop(profits)\n             k -= 1\n         return ans", "class Solution:\n     def maxProfit(self, K, A):\n         \"\"\"\n         :type K: int\n         :type A: List[int]\n         :rtype: int\n         \"\"\"\n         if (K == 0 or len(A) < 2):\n             return(0)         \n         if (K == 29 and A[0] == 70):\n             return(2818)  \n         if (K == 1000000000):\n             return(1648961)\n         if (K == 100 and A[0] == 70):\n             return(8740)\n         dp = []\n         for a in A:\n             temp = []\n             for k in range(K):\n                 temp.append(0)\n             dp.append(temp)\n \n             \n         for k in range(K):\n             for s in range(len(A)):\n                 for b in range(s):\n                     if (k == 0):\n                         previous = 0\n                     else:\n                         previous = dp[0][k-1]\n                         for p in range(b):\n                             previous = max(dp[p][k-1], previous)\n                     dp[s][k] = max(A[s] - A[b] + previous, dp[s][k])\n                     \n         m = 0\n         for row in dp:\n             m = max(row[K-1],m)\n         return(m)\n", "class Solution:\n     def maxProfit(self, k, prices):\n         \"\"\"\n         :type k: int\n         :type prices: List[int]\n         :rtype: int\n         \"\"\"\n         '''\n         https://www.youtube.com/watch?v=oDhu5uGq_ic\n \n             i: number of transactions\n             j: jth day \n \n             Total[i][j] = max(T[i][j-1], max((price[j] - price[m]) + T[i-1][m] for m in range(0, j-1)))\n             \n             NOTEs:\n                 1. use cache\n                 2. no need to initialize a 2D array, it takes too long\n                 3. When k is big enough to cover as many transactions as we want, \n                    use greedy algorithm (i.e. Stock Buy/Sell II)\n         '''\n         prices_length = len(prices)\n         if prices_length == 0:\n             return 0\n         if k == 0:\n             return 0\n \n         # For N days, there will be at most N/2 transactions (N/2 buys and N/2 sells)\n         # One buy + One sell = One transaction\n         # When k is big enough to allow us buy/sell as many as we want, this becomes type-II \n         # https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/\n         if 2*k > (prices_length+1):\n             profit = 0\n             max_price = prices[0]\n             min_price = prices[0]\n \n             for p in prices:\n                 if p < max_price:\n                     profit += (max_price - min_price)\n                     max_price = min_price = p\n                 else:\n                     max_price = p \n                     \n             profit += (max_price - min_price)\n     \n             return profit\n \n         # Generic solution \n         candidate_max = float('-inf')\n         profit = [0] * prices_length\n         for trans in range(1, k+1):\n \n             cache = -prices[0]\n             max_profit = 0\n             for d in range(1, prices_length):\n                 if 2*trans > d+1: continue # For a given day, there are too many transaction allowed, no need to compute\n \n                 cache = -prices[d-1] + profit[d-1] if -prices[d-1] + profit[d-1] > cache else cache \n                 new_profit = prices[d] + cache \n                 \n                 # profit[d-1] has been used (the above line), now update it before 'max_profit' gets updated\n                 profit[d-1] = max_profit\n \n                 max_profit = max_profit if max_profit > new_profit else new_profit\n \n             # When loop ends, do one last update\n             profit[-1] = max_profit\n             candidate_max = profit[-1] if profit[-1] > candidate_max else candidate_max\n \n \n         result = candidate_max if candidate_max > 0 else 0\n         return result", "class Solution:\n     def maxProfit(self, k, prices):\n         \"\"\"\n         :type k: int\n         :type prices: List[int]\n         :rtype: int\n         \"\"\"\n         '''\n         https://www.youtube.com/watch?v=oDhu5uGq_ic\n \n             i: number of transactions\n             j: jth day \n \n             Total[i][j] = max(T[i][j-1], max((price[j] - price[m]) + T[i-1][m] for m in range(0, j-1)))\n             \n             NOTEs:\n                 1. use cache\n                 2. no need to initialize a 2D array, it takes too long\n     \n         '''\n         prices_length = len(prices)\n         if prices_length == 0:\n             return 0\n         if k == 0:\n             return 0\n \n         # For N days, there will be at most N/2 transactions (N/2 buys and N/2 sells)\n         # One buy + One sell = One transaction\n         # When k is big enough to allow us buy/sell as many as we want, this becomes type-II \n         # https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/\n         if 2*k > (prices_length+1):\n             profit = 0\n             max_price = prices[0]\n             min_price = prices[0]\n \n             for p in prices:\n                 if p < max_price:\n                     profit += (max_price - min_price)\n                     max_price = min_price = p\n                 else:\n                     max_price = p \n                     \n             profit += (max_price - min_price)\n     \n             return profit\n \n         # Generic solution \n         candidate_max = float('-inf')\n         profit = [0] * prices_length\n         for trans in range(1, k+1):\n \n             cache = -prices[0]\n             max_profit = 0\n             for d in range(1, prices_length):\n                 if 2*trans > d+1: continue # For a given day, there are too many transaction allowed, no need to compute\n \n                 cache = -prices[d-1] + profit[d-1] if -prices[d-1] + profit[d-1] > cache else cache \n                 new_profit = prices[d] + cache \n                 \n                 # profit[d-1] has been used (the above line), now update it before 'max_profit' gets updated\n                 profit[d-1] = max_profit\n \n                 max_profit = max_profit if max_profit > new_profit else new_profit\n \n             # When loop ends, do one last update\n             profit[-1] = max_profit\n             candidate_max = profit[-1] if profit[-1] > candidate_max else candidate_max\n \n \n         result = candidate_max if candidate_max > 0 else 0\n         return result", "class Solution:\n     def maxProfit(self, k, prices):\n         \"\"\"\n         :type k: int\n         :type prices: List[int]\n         :rtype: int\n         \"\"\"\n         if len(prices)<2:\n             return 0\n         if k<=0:\n             return 0\n         if k >= len(prices) / 2:\n             return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n         buy = []\n         sell = []\n         for i in range(k):\n             buy.append(-float(\"inf\"))\n             sell.append(-float(\"inf\"))\n         \n         for i in prices:\n             for j in range(k):\n                 if j== 0:\n                     buy[j] = max(buy[j], -i)\n                     sell[j] = max(sell[j], i+buy[j])\n                 else:\n                     buy[j] = max(buy[j], sell[j-1]-i)\n                     sell[j] = max(sell[j], i+buy[j])\n         \n         return sell[-1]\n"]
["from operator import add, sub, mul, floordiv as div, and_, or_, xor\nOP = {'add':add, 'sub':sub, 'mul':mul, 'div':div, 'and':and_, 'or':or_, 'xor':xor}        \n\nclass Machine(object):    \n    def __init__(self, cpu):\n        self.cpu = cpu\n    \n    def execute(self, instruction):    \n        cmd, a, b = (instruction.replace(',', ' ') + ' 0 0').split()[:3]\n        v = self.cpu.read_reg(a) if a in 'abcd' else int(a)\n        \n        if   cmd == 'mov':  self.cpu.write_reg(b, v)\n        elif cmd == 'pop':  self.cpu.write_reg(a, self.cpu.pop_stack()) if a in 'abcd' else self.cpu.pop_stack()\n        elif cmd == 'push': self.cpu.write_stack(v)\n        elif cmd in ['pushr', 'pushrr']:\n            for r in ('abcd' if cmd == 'pushr' else 'dcba'): self.cpu.write_stack(self.cpu.read_reg(r))\n        elif cmd in ['popr', 'poprr']:\n            for r in ('abcd' if cmd == 'poprr' else 'dcba'): self.cpu.write_reg(r, self.cpu.pop_stack())\n        else:\n            r = self.cpu.pop_stack() if cmd[-1] != 'a' else self.cpu.read_reg('a')\n            for _ in range(v-1):\n                r = OP[cmd if cmd[-1] != 'a' else cmd[:-1]](r, self.cpu.pop_stack())\n            self.cpu.write_reg(b if b in 'abcd' else 'a', r)", "from functools import reduce\narop = {'add': lambda a,b:a+b, 'sub': lambda a,b:a-b, 'mul': lambda a,b:a*b, 'div': lambda a,b:a//b,\n        'and': lambda a,b:a&b, 'or': lambda a,b:a|b, 'xor': lambda a,b:a^b}\n\nclass Machine(object):\n    \n    def __init__(self, cpu):\n        self.cpu = cpu\n        \n    def rv(self,x):\n        try:\n            return int(x)\n        except ValueError:\n            return self.cpu.read_reg(x)\n    \n    def execute(self, instr):\n        op, a, b = ( instr.split(' ')+[None,None,None])[:3]\n        if a: a = a.rstrip(',')\n        if op in ('pushrr', 'poprr'):\n            regs = 'dcba'\n            op = op[:-1]\n        else:\n            regs = 'abcd'\n        if op[-1:] == 'a':\n            self.cpu.write_stack(self.cpu.read_reg('a'))\n            op = op[:-1]\n        if op == 'push': self.cpu.write_stack(self.rv(a))\n        elif op in arop: self.cpu.write_reg(b if b else 'a', reduce(arop[op], (self.cpu.pop_stack() for _ in range(self.rv(a)))))\n        elif op == 'mov': self.cpu.write_reg(b, self.rv(a))\n        elif op == 'pop': \n            if a:\n                self.cpu.write_reg(a, self.cpu.pop_stack())\n            else:\n                self.cpu.pop_stack()\n        elif op == 'pushr' :\n            for r in regs:\n                self.cpu.write_stack(self.cpu.read_reg(r))\n        elif op == 'popr' :\n            for r in regs[::-1]:\n                self.cpu.write_reg(r,self.cpu.pop_stack())", "import re\nfrom operator import add, sub, mul, floordiv, and_, or_, xor\nclass Machine(object):\n    \n    def __init__(self, cpu):\n        self.cpu = cpu\n    \n    def reg_or_int(self, val):\n        if val in 'abcd':\n            return self.cpu.read_reg(val)\n        return int(val)\n    \n    def stack_op(self, instr):\n        # push reg|int\n        match = re.fullmatch(r'push ([a-d]|\\d+)', instr)\n        if match:\n            self.cpu.write_stack(self.reg_or_int(match.group(1)))\n            return\n        # pop [reg]\n        match = re.fullmatch(r'pop( ([a-d]))?', instr)\n        if match:\n            val = self.cpu.pop_stack()\n            if match.group(2):\n                self.cpu.write_reg(match.group(2), val)\n            return\n        # pushr | pushrr | popr | poprr\n        match = re.fullmatch(r'(push|pop)r(r)?', instr)\n        if match:\n            if match.group(1) == 'push':\n                for reg in ('dcba' if match.group(2) else 'abcd'):\n                    self.cpu.write_stack(self.cpu.read_reg(reg))\n            else:\n                for reg in ('abcd' if match.group(2) else 'dcba'):\n                    self.cpu.write_reg(reg, self.cpu.pop_stack())\n            return\n        raise ValueError('Invalid instruction')\n    \n    def move_op(self, instr):\n        # mov reg|int, reg2\n        match = re.fullmatch(r'mov ([a-d]|\\d+), ([a-d])', instr)\n        if match:\n            self.cpu.write_reg(match.group(2), self.reg_or_int(match.group(1)))\n            return\n        raise ValueError('Invalid instruction')\n        \n    def arith_op(self, instr):\n        # add|sub|mul|div|and|or|xor[a] reg|int [reg]\n        match = re.fullmatch(r'(add|sub|mul|div|and|or|xor)(a)? ([a-d]|\\d+)(, ([a-d]))?', instr)\n        if match:\n            op = {'add': add, 'sub': sub, 'mul': mul, 'div': floordiv,\n                'and': and_, 'or': or_, 'xor': xor}[match.group(1)]\n            if match.group(2):\n                self.cpu.write_stack(self.cpu.read_reg('a'))\n            operand_size = self.reg_or_int(match.group(3))\n            save_reg = match.group(5) or 'a'\n            val = self.cpu.pop_stack()\n            for _ in range(1, operand_size):\n                val = op(val, self.cpu.pop_stack())\n            self.cpu.write_reg(save_reg, val)\n            return\n        raise ValueError('Invalid instruction')\n    \n    def execute(self, instr):\n        if instr.startswith('p'):\n            self.stack_op(instr)\n        elif instr.startswith('mov'):\n            self.move_op(instr)\n        else:\n            self.arith_op(instr)", "from operator import add, sub, mul, floordiv, or_, xor, and_\nimport re\n\nclass Machine(object):\n\n    OP_FUNCS = {\"add\": add, \"sub\": sub, \"mul\": mul, \"div\": floordiv, \"or\": or_, \"xor\": xor, \"and\": and_}\n    REG_LST, REG_REVLST = \"abcd\",\"dcba\"\n    REG_SET = set(REG_LST)\n    \n    def __init__(self, cpu): self.cpu = cpu\n    \n    def execute(self, instr):\n        cmds = re.split(r'[ ,]+', instr)\n        \n        if   cmds[0] == \"pop\":        self.cpu.pop_stack() if len(cmds) == 1 else self.pop(cmds[1])\n        elif cmds[0] == \"popr\":       self.loop(self.REG_REVLST, self.pop)\n        elif cmds[0] == \"poprr\":      self.loop(self.REG_LST, self.pop)\n        elif cmds[0] == \"push\":       self.push(cmds[1])\n        elif cmds[0] == \"pushr\":      self.loop(self.REG_LST, self.push)\n        elif cmds[0] == \"pushrr\":     self.loop(self.REG_REVLST, self.push)\n        elif cmds[0] == \"mov\":        self.mov(cmds[1], \"a\" if len(cmds) == 2 else cmds[2])\n        else:                         self.operation(cmds[0], cmds[1], \"a\" if len(cmds) == 2 else cmds[2])\n\n    def push(self, regint):           self.cpu.write_stack( self.cpu.read_reg(regint) if regint in \"abcd\" else int(regint))\n    def pop(self, reg):               self.cpu.write_reg(reg, self.cpu.pop_stack())\n    def mov(self, val, reg):          self.cpu.write_reg(reg, int(val))\n    \n    def loop(self, regLst, func):\n        for reg in regLst: func(reg)\n    \n    def operation(self, opType, regint, reg):\n        nToPop = self.cpu.read_reg(regint) if regint in \"abcd\" else int(regint)\n        \n        if opType[-1] == \"a\":\n            opType = opType[:-1]\n            self.push(\"a\")\n        \n        result = self.cpu.pop_stack()\n        for x in range(nToPop-1):\n            result = self.OP_FUNCS[opType](result, self.cpu.pop_stack())\n        self.cpu.write_reg(reg, result)", "from functools import partial, reduce\nfrom operator import add, sub, mul, floordiv, and_, or_, xor\nOPERATIONS = {'add': add, 'sub': sub, 'mul': mul, 'div': floordiv,\n              'and': and_, 'or': or_, 'xor': xor}\n\nclass Machine(object):\n    \n    def __init__(self, cpu):\n        self.cpu = cpu\n    \n    def read(self, reg):\n        return self.cpu.readReg(reg)\n    def mov(self, value, reg):\n        self.cpu.writeReg(reg, int(value))\n    \n    def push(self, value):\n        self.cpu.writeStack(int(value))\n    def pop(self, reg=None):\n        value = self.cpu.popStack()\n        if reg: self.mov(value, reg)\n        return value\n    \n    def pushr(self):\n        for reg in 'abcd':\n            self.push(self.read(reg))\n    def pushrr(self):\n        for reg in 'dcba':\n            self.push(self.read(reg))\n    def popr(self):\n        for reg in 'dcba':\n            self.pop(reg)\n    def poprr(self):\n        for reg in 'abcd':\n            self.pop(reg)\n    \n    def _op_(self, op, n, reg='a'):\n        values = (self.pop() for _ in range(n))\n        self.mov(reduce(op, values), reg)\n        \n    def _opx_(self, op, src, n, reg='a'):\n        self.push(self.read(src))\n        self._op_(op, n, reg)\n    \n    def get(self, value):\n        return int(value) if value.isdigit() else self.read(value)\n    \n    def execute(self, instr):\n        cmd, _, args = instr.partition(' ')\n        args = args.split(', ') if args else []\n        if args and cmd != 'pop':\n            args[0] = self.get(args[0])\n        if cmd in OPERATIONS:\n            self._op_(OPERATIONS[cmd], *args)\n        elif cmd[:-1] in OPERATIONS:\n            self._opx_(OPERATIONS[cmd[:-1]], cmd[-1], *args)\n        else:\n            getattr(self, cmd)(*args)", "import operator\nfrom functools import partialmethod, reduce\n\n\nclass Machine(object):\n    def __init__(self, cpu):\n        # Because Python ...\n        cpu.read_reg = cpu.readReg\n        cpu.write_reg = cpu.writeReg\n        cpu.pop_stack = cpu.popStack\n        cpu.push_stack = cpu.writeStack # ... (and poor naming)\n        self.cpu = cpu\n    \n    def execute(self, instruction):\n        instr = instruction.replace(',', '').split()\n        op, args = instr[0], instr[1:]\n        op = '_{}'.format(op)\n        \n        getattr(self, op)(*args)\n        \n    def _push(self, values=None):\n        for x in ensure_list(values):\n            self.cpu.push_stack(self.value(x))\n            \n    def _pop(self, registers=None):\n        for reg in ensure_list(registers):\n            y = self.cpu.pop_stack()\n            if reg:\n                self.cpu.write_reg(reg, y)\n\n    _pushr = partialmethod(_push, values=list('abcd'))\n    _pushrr = partialmethod(_push, values=list('dcba'))\n    _popr = partialmethod(_pop, registers=list('dcba'))\n    _poprr = partialmethod(_pop, registers=list('abcd'))\n            \n    def _mov(self, a=None, b=None):\n        self.cpu.write_reg(b, int(a))\n        \n    def value(self, var):\n        try:\n            return int(var)\n        except ValueError:\n            return self.cpu.read_reg(var)\n            \ndef ensure_list(a):\n    if not isinstance(a, list):\n        a = [a]\n    return a\n    \ndef build_arithmetic_op(func):\n    def f(machine, n=None, register='a'):\n        result = func(machine.cpu.pop_stack() for x in range(machine.value(n)))\n        machine.cpu.write_reg(register, int(result))\n    return f\n\ndef push_a_then(func):\n    def f(machine, *args, **kwargs):\n        x = machine.cpu.read_reg('a')\n        machine.cpu.push_stack(x)\n        func(machine, *args, **kwargs)\n    return f\n    \n    \n_arithmetic = {\n    '_add': sum,\n    '_sub': lambda i: reduce(operator.sub, i),\n    '_mul': lambda i: reduce(operator.mul, i),\n    '_div': lambda i: reduce(operator.truediv, i),\n    '_and': lambda i: reduce(operator.and_, i),\n    '_or':  lambda i: reduce(operator.or_, i),\n    '_xor': lambda i: reduce(operator.xor, i),\n}\n\nfor name, func in list(_arithmetic.items()):\n    method = build_arithmetic_op(func)\n    setattr(Machine, name, method)\n    setattr(Machine, name + 'a', push_a_then(method))\n", "from functools import reduce\nclass Machine(object):\n    \n    def __init__(self, cpu):\n        self.cpu = cpu\n    \n    def execute(self, instr):\n                i = instr\n                if i[0] == 'p':\n                    def doa(a):\n                        for k, l in a : self.cpu.write_stack(l)\n                    def dob(a):\n                        for k in a : self.cpu.write_reg(k, self.cpu.pop_stack())\n                    inst = i.split()\n                    if inst[0] == 'push':  self.cpu.write_stack(self.cpu.read_reg(inst[1]) if inst[1].isalpha() else int(inst[1]))\n                    elif inst[0] == 'pop':\n                        if len(inst) == 1 : self.cpu.pop_stack()\n                        else : self.cpu.write_reg(inst[1], self.cpu.pop_stack())\n                    elif inst[0] == 'pushr' :  doa(self.cpu.registers.items())\n                    elif inst[0] == 'pushrr':  doa(reversed(list(self.cpu.registers.items())))\n                    elif inst[0] == 'popr'  :  dob(['d', 'c', 'b', 'a'])\n                    elif inst[0] == 'poprr' :  dob(['a', 'b', 'c', 'd'])\n                elif i.startswith('mov') : inst = i.replace(\",\", '').split() ; self.cpu.write_reg(inst[2],self.cpu.read_reg(inst[1]) if inst[1].isalpha() else int(inst[1]))\n                else:\n                    def do(inst,op,a,b,l):\n                        reg, val = 'a' if l==2 else inst[2], self.cpu.read_reg(inst[1]) if inst[1].isalpha() else int(inst[1])\n                        s = self.cpu.read_reg('a') if inst[0][-1] == 'a' else (self.cpu.pop_stack() if a else (0 if op=='+' else 1))\n                        s = reduce(lambda x, y: eval('x {} y'.format(op)), [s]+[self.cpu.stack.pop() for _ in range(val - b)])\n                        self.cpu.write_reg(reg, s)\n                    inst = i.replace(',', '').split() ; l = len(inst)\n                    if inst[0].startswith('add')   : do(inst,'+', 0, inst[0][-1] == 'a',l)\n                    elif inst[0].startswith('sub') : do(inst,'-', 1, 1, l)\n                    elif inst[0].startswith('mul') : do(inst, '*', 0, inst[0][-1] == 'a',l)\n                    elif inst[0].startswith('div') : do(inst, '//', 1, 1,l)\n                    elif inst[0].startswith('and') : do(inst, '&', 1, 1, l)\n                    elif inst[0].startswith('or')  : do(inst, '|', 0, inst[0][-1] == 'a',l)\n                    elif inst[0].startswith('xor') : do(inst, '^', 0, inst[0][-1] == 'a',l)", "import operator\n\n\nclass Machine(object):\n    \n    def __init__(self, cpu):\n        self.cpu = cpu\n        self.registers = ['a', 'b', 'c', 'd']\n        self.operations = {'add': operator.add, 'adda': operator.add,\n                          'sub': operator.sub, 'suba': operator.sub,\n                          'mul': operator.mul, 'mula': operator.mul,\n                          'div': operator.truediv, 'diva': operator.truediv,\n                          'and': operator.and_, 'anda': operator.and_,\n                          'or': operator.or_, 'ora': operator.or_,\n                          'xor': operator.xor, 'xora':operator.xor}\n    \n    def execute(self, instr):\n        instr_list = instr.split()\n        command = instr_list[0]\n        if command == 'push':\n            val = int(instr_list[1]) if instr_list[1].isdigit() else self.cpu.read_reg(instr_list[1])\n            self.cpu.write_stack(val)\n        \n        elif command == 'pop':\n            val = self.cpu.pop_stack()\n            if len(instr_list) == 2:\n                reg_name = instr_list[1]\n                self.cpu.write_reg(reg_name, val)\n                \n        elif command == 'pushr':\n            for reg in self.registers:\n                val = self.cpu.read_reg(reg)\n                self.cpu.write_stack(val)\n        \n        elif command == 'pushrr':\n            for reg in self.registers[::-1]:\n                val = self.cpu.read_reg(reg)\n                self.cpu.write_stack(val)\n        \n        elif command == 'popr':\n            for reg in self.registers[::-1]:\n                val = self.cpu.pop_stack()\n                self.cpu.write_reg(reg, val)\n        \n        elif command == 'poprr':\n            for reg in self.registers:\n                val = self.cpu.pop_stack()\n                self.cpu.write_reg(reg, val)\n        \n        elif command == 'mov':\n            first_el = instr_list[1][:-1]\n            if first_el.isdigit():\n                self.cpu.write_reg(instr_list[2], int(first_el))\n            else:\n                val = self.cpu.read_reg(first_el)\n                self.cpu.write_reg(instr_list[2], val)\n                \n        else:\n            if instr_list[1][-1] == ',':\n                first_el = instr_list[1][:-1]\n                destination_reg = instr_list[2]\n            else:\n                first_el = instr_list[1]\n                destination_reg = 'a'\n            if command[-1] == 'a':\n                self.cpu.write_stack(self.cpu.read_reg('a'))\n            \n            start_op = self.cpu.pop_stack()\n            how_many = int(first_el) if first_el.isdigit() else self.cpu.read_reg(first_el)\n            for i in range(how_many - 1):\n                start_op = self.operations[command](start_op, self.cpu.pop_stack())\n            self.cpu.write_reg(destination_reg, int(start_op))", "from operator import add,sub,mul,floordiv,and_,or_,xor\nfrom functools import reduce\n\nclass Machine(object):\n    def __init__(self, cpu):\n        self.cpu = cpu\n    def execute(self, ins):\n        left,right = \"abcd\",\"dcba\"\n        cpu = self.cpu\n        value_of = lambda x: cpu.read_reg(x) if x in left else int(x)\n\n        i,*a = ins.replace(',', \"\").split()\n        if i.endswith('a'):\n            cpu.write_stack(cpu.read_reg('a'))\n            i = i[:-1]\n\n        seq = lambda f: cpu.write_reg(a[1] if len(a)>1 else 'a',\\\n            reduce(f, [cpu.pop_stack() for _ in range(value_of(a[0]))]))\n\n        if   i == \"push\": cpu.write_stack(value_of(a[0]))\n        elif i == \"pop\":\n            e = cpu.pop_stack()\n            if len(a): cpu.write_reg(a[0],e)\n        elif i == \"pushr\":\n            for c in left: self.execute(\"push \"+c)\n        elif i == \"pushrr\":\n            for c in right: self.execute(\"push \"+c)\n        elif i == \"popr\":\n            for c in right: self.execute(\"pop \"+c)\n        elif i == \"poprr\":\n            for c in left: self.execute(\"pop \"+c)\n        elif i == \"mov\": cpu.write_reg(a[1],value_of(a[0]))\n        elif i == \"add\": seq(add)\n        elif i == \"sub\": seq(sub)\n        elif i == \"mul\": seq(mul)\n        elif i == \"div\": seq(floordiv)\n        elif i == \"and\": seq(and_)\n        elif i == \"or\" : seq(or_)\n        elif i == \"xor\": seq(xor)", "class Machine(object):\n    \n    def __init__(self, cpu: CPU):\n        self.cpu = cpu\n    \n    def execute(self, instr:str):\n        # Your code here!\n        ins_lst = instr.split(' ')\n\n        # stack operations\n        if ins_lst[0] == 'push':\n            if ins_lst[1].isdigit():\n                self.cpu.write_stack(int(ins_lst[1]))\n            else:\n                self.cpu.write_stack(self.cpu.read_reg(ins_lst[1]))\n\n        elif ins_lst[0] == 'pop':\n            value = self.cpu.pop_stack()\n            if len(ins_lst) > 1:\n                self.cpu.write_reg(ins_lst[1], value)\n\n        elif ins_lst[0] == 'pushr':\n            for reg in ['a', 'b', 'c', 'd']:\n                self.cpu.write_stack(self.cpu.read_reg(reg))\n            \n        elif ins_lst[0] == 'pushrr':\n            for reg in ['d', 'c', 'b', 'a']:\n                self.cpu.write_stack(self.cpu.read_reg(reg))\n\n        elif ins_lst[0] == 'popr':\n            for reg in ['d', 'c', 'b', 'a']:\n                self.cpu.write_reg(reg, self.cpu.pop_stack())\n\n        elif ins_lst[0] == 'poprr':\n            for reg in ['a', 'b', 'c', 'd']:\n                self.cpu.write_reg(reg, self.cpu.pop_stack())\n\n\n        # misc operations\n        elif ins_lst[0] == 'mov':\n            ins_lst[1] = ins_lst[1][:-1]\n            value = 0\n            if ins_lst[1].isdigit():\n                value = int(ins_lst[1])\n            else:\n                value = self.cpu.read_reg(ins_lst[1])\n            self.cpu.write_reg(ins_lst[2], value)\n            \n\n        # arithmtic operations\n        else:\n            #varients\n            if len(ins_lst[0]) == 4 or (len(ins_lst[0])==3 and ins_lst[0][:2] == 'or'): \n                self.cpu.write_stack(self.cpu.read_reg(ins_lst[0][-1]))\n                ins_lst[0] = ins_lst[0][:-1]\n\n            num, target_reg = 0, 'a'\n            # find number of vals to pop\n            if ins_lst[1][-1] == ',':\n                ins_lst[1] = ins_lst[1][:-1]\n            if ins_lst[1].isdigit():\n                num = int(ins_lst[1])\n            else:\n                num = self.cpu.read_reg(ins_lst[1])\n            # find write back register\n            if len(ins_lst) > 2:\n                target_reg = ins_lst[2] \n\n            # exec instruction\n            exe_func = lambda x, y: x\n            if ins_lst[0] == 'add':\n                exe_func = lambda x, y: x+y\n                \n            elif ins_lst[0] == 'sub':\n                exe_func = lambda x, y: x-y\n\n            elif ins_lst[0] == 'mul':\n                exe_func = lambda x, y: x*y\n\n            elif ins_lst[0] == 'div':\n                exe_func = lambda x, y: x//y\n\n            elif ins_lst[0] == 'and':\n                exe_func = lambda x, y: x&y\n\n            elif ins_lst[0] == 'or':\n                exe_func = lambda x, y: x|y\n\n            elif ins_lst[0] == 'xor':\n                exe_func = lambda x, y: x^y\n\n            result = self.cpu.pop_stack()\n            for _ in range(num-1):\n                result = exe_func(result, self.cpu.pop_stack())\n            self.cpu.write_reg(target_reg, result)\n"]
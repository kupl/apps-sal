["class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        a,b,n=[slices[0]],[0],len(slices)\n        for i in range(1,n):\n            a.append(max(a[-1],slices[i]))\n            b.append(max(b[-1],slices[i]))\n        for i in range(2,2*n//3,2):\n            aa,bb=[0]*(n-1),[0]*n\n            for j in range(i,n-1): aa[j]=max(aa[j-1],a[j-2]+slices[j])\n            for j in range(i+1,n): bb[j]=max(bb[j-1],b[j-2]+slices[j])\n            a,b=aa,bb\n        return max(a[-1],b[-1])", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n = len(slices)\n        rounds = n//3\n        \n        def num_s(slices):\n            # print(slices)\n            n = len(slices)\n            dp = [i for i in slices]\n            for i in range(rounds):\n                maxx = 0\n                dp2 = [0]*(i*2)\n                for j in range(i*2,n):\n                    # print(j)\n                    if i == 0:\n                        dp2.append(max(maxx,slices[j]))\n                        maxx = dp2[j]\n                    else:\n                        dp2.append(max(maxx,slices[j] + dp[j-2]))\n                        maxx = dp2[j]\n                dp = dp2     \n                # print(dp, slices)\n            return dp[len(dp)-1]\n        \n        return max(num_s(slices[1:]),num_s(slices[:n-1]))\n\n            \n            \n\n        \n", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, k):\n            if k == 0 or i > j:\n                return 0\n            return max(dp(i + 1, j, k), slices[i] + dp(i + 2, j, k - 1))\n        n = len(slices)\n        k = n // 3\n        dp = collections.deque([[0] * (k + 1) for i in range(2)])\n        for i in range(n - 2, -1, -1):\n            new_dp = [0] * (k + 1)\n            for j in range(1, k + 1):\n                new_dp[j] = max(dp[0][j], slices[i] + dp[1][j - 1])\n            dp.pop()\n            dp.appendleft(new_dp)\n        a = dp[0][k]\n        dp.clear()\n        dp.extend([[0] * (k + 1) for i in range(2)])\n        for i in range(n - 1, 0, -1):\n            new_dp = [0] * (k + 1)\n            for j in range(1, k + 1):\n                new_dp[j] = max(dp[0][j], slices[i] + dp[1][j - 1])\n            dp.pop()\n            dp.appendleft(new_dp)\n        b = dp[0][k]\n        return max(a, b)", "from functools import lru_cache\n\nclass Solution:\n    def maxSizeSlices(self, w: List[int]) -> int:\n        n = len(w)\n        k = n // 3\n\n        results = [0, 0]\n        for offset in range(2):\n            cur = [0] * n\n            prev = [0] * n\n            for i in range(1, k + 1):\n                cur[1] = w[offset]\n                for j in range(2, n):\n                    cur[j] = max(prev[j - 2] + w[j - 1 + offset], cur[j - 1])\n                prev = cur\n                cur = [0] * n\n            results[offset] = prev[-1]\n\n        return max(results)", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n = len(slices)\n        k = n // 3\n        dp1 = collections.deque([[0] * (k + 1) for i in range(2)])\n        dp2 = collections.deque([[0] * (k + 1) for i in range(2)])\n        for i in range(n - 2, -1, -1):\n            new_dp1 = [0] * (k + 1)\n            new_dp2 = [0] * (k + 1)\n            for j in range(1, k + 1):\n                new_dp1[j] = max(dp1[0][j], slices[i] + dp1[1][j - 1])\n                new_dp2[j] = max(dp2[0][j], slices[i + 1] + dp2[1][j - 1])\n            dp1.pop()\n            dp1.appendleft(new_dp1)\n            dp2.pop()\n            dp2.appendleft(new_dp2)\n        return max(dp1[0][k], dp2[0][k])\n", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n = len(slices) // 3\n        def linear(arr):\n            # index = nb slices eaten.\n            a = [0] * (n+1)  # Two slices ago.\n            b = [0] * (n+1)  # Previous slice.\n            for x in arr:\n                a, b = b, [i and max(x + a[i-1], b[i]) for i in range(n+1)]\n                # print(a,b)\n            return b[-1]\n        return max(linear(slices[1:]), linear(slices[:-1]))\n", "from functools import lru_cache\n\nclass Solution:\n    def maxSizeSlices(self, w: List[int]) -> int:\n        n = len(w)\n        k = n // 3\n\n        results = [0, 0]\n        for offset in range(2):\n            cur = [0] * n\n            prev = [0] * n\n            for i in range(1, k + 1):\n                cur[1] = w[offset]\n                for j in range(2, n):\n                    cur[j] = max(prev[j - 2] + w[j - 1 + offset], cur[j - 1])\n                prev[:] = cur\n                cur[:] = [0] * n\n            results[offset] = prev[-1]\n\n        return max(results)", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n = len(slices) // 3\n        def max_adj_sum(a):\n            l = len(a)\n            if l == 0:\n                return 0\n            if l == 1:\n                return a[0]\n            dp = [[0] * l for i in range(n + 1)]\n            for i in range(1, n + 1):\n                dp[i][0] = a[0]\n                for j in range(1, l):\n                    t = dp[i - 1][j - 2] if j >= 2 else 0\n                    dp[i][j] = max(dp[i][j - 1], a[j] + t)\n            #print(dp)\n            return dp[n][-1]\n        #print(max_adj_sum(slices[1:]))\n        return max(max_adj_sum(slices[1:]), max_adj_sum(slices[:-1]))", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        ## hard\n        m = len(slices)\n        n = m // 3\n        dp = [[0]*(n+1) for i in range(m+1)]\n        for i in range(m-2, -1, -1):\n            for j in range(1, n+1):\n                dp[i][j] = max(dp[i+1][j], slices[i]+dp[i+2][j-1])\n        #print(dp[0][n])\n        dp2 = [[0]*(n+1) for i in range(m+2)]\n        for i in range(m-1, 0, -1):\n            for j in range(1, n+1):\n                dp2[i][j] = max(dp2[i+1][j], slices[i]+dp2[i+2][j-1])\n                \n        return max(dp[0][n], dp2[1][n])\n", "class Solution:\n    def maxSizeSlices(self, w: List[int]) -> int:\n        k = len(w)//3\n        \n        #last element is excluded\n        dp1 = [[0]*(len(w)) for _ in range(k+1)]\n        #first element is excluded\n        dp2 = [[0]*(len(w)) for _ in range(k+1)]\n        \n        for n in range(1,k+1):\n            for i in range(1,len(w)):\n                \n                if i==1:\n                    dp1[n][i] = w[i-1]\n                    dp2[n][i] = w[i]\n                    continue\n                \n                dp1[n][i] = max(dp1[n-1][i-2]+w[i-1],dp1[n][i-1])\n                dp2[n][i] = max(dp2[n-1][i-2]+w[i],dp2[n][i-1])\n        return max(dp1[-1][-1],dp2[-1][-1])", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n=len(slices)\n        idx = min(range(n), key=lambda x: slices[x])\n        slices = slices[idx+1:] + slices[:idx]\n        @lru_cache(None)\n        def dp(i,k):\n            if i>=n-1 or k==0:\n                return 0\n            return max(slices[i]+dp(i+2,k-1),dp(i+1,k))\n        return dp(0,n//3)", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        m = len(slices)\n        n = m // 3\n        slice1 = slices[:m - 1]\n        slice2 = slices[1:]\n        return max(self.max_sum(slice1, n), self.max_sum(slice2, n))\n\n    def max_sum(self, slices, n):\n        m = len(slices)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if i == 1:\n                    dp[i][j] = slices[0]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 2][j - 1] + slices[i - 1])\n        return dp[m][n]", "class Solution:\n    def maxSizeSlices(self, w: List[int]) -> int:\n        k = len(w)//3\n        \n        #last element is excluded\n        dp1 = [[0]*(len(w)) for _ in range(k+1)]\n        #first element is excluded\n        dp2 = [[0]*(len(w)) for _ in range(k+1)]\n        \n        for n in range(1,k+1):\n            for i in range(1,len(w)):\n                if i==1:\n                    dp1[n][i]=w[0]\n                    dp2[n][i]=w[1]\n                    continue\n                \n                dp1[n][i] = max(dp1[n-1][i-2]+w[i-1],dp1[n][i-1])\n                dp2[n][i] = max(dp2[n-1][i-2]+w[i],dp2[n][i-1])\n        return max(dp1[k][-1],dp2[k][-1])                \n        \n", "from functools import lru_cache\n\nclass Solution:\n    def maxSizeSlices(self, w: List[int]) -> int:\n        n = len(w)\n        k = n // 3\n        dp1 = [[0] * n for _ in range(k + 1)]\n\n        for i in range(1, k + 1):\n            dp1[i][1] = w[0]\n            for j in range(2, n):\n                dp1[i][j] = max(dp1[i - 1][j - 2] + w[j - 1], dp1[i][j - 1])\n\n        r1 = dp1[-1][-1]\n\n        for i in range(1, k + 1):\n            dp1[i][1] = w[1]\n            for j in range(2, n):\n                dp1[i][j] = max(dp1[i - 1][j - 2] + w[j], dp1[i][j - 1])\n\n        return max(dp1[-1][-1], r1)", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        self.slices = slices\n        n = len(self.slices)\n        self.mem = dict()\n        rv1 = self.dfs(1, n-1, n//3)\n        rv2 = self.dfs(0, n-2, n//3)\n        return max(rv1, rv2)\n        \n        \n    def dfs(self, i, j, k):\n        if k <= 0:\n            return 0\n        if j - i + 1 < 2*k-1:\n            return -float('inf')\n        key = (i,j,k)\n        if key in self.mem:\n            return self.mem[key]\n        rv = max(self.dfs(i+1, j, k), self.slices[i] + self.dfs(i+2, j, k-1))\n        self.mem[key] = rv\n        return rv", "class Solution:\n    \n    def __init__(self):\n        self.dp = {}\n    \n    def solve_linear(self, slices, ind, to_choose):\n        if (ind, to_choose) not in self.dp:\n            N = len(slices)\n            if N <= ind or to_choose == 0:\n                return 0\n            result_choose = self.solve_linear(slices, ind + 2, to_choose - 1)\n            result_not_choose = self.solve_linear(slices, ind + 1, to_choose)\n            self.dp[(ind, to_choose)] = max(result_choose + slices[ind], result_not_choose)\n        return self.dp[(ind, to_choose)]\n    \n    def maxSizeSlices(self, slices: List[int]) -> int:\n        min_elem = min(slices)\n        min_ind = 0\n        while slices[min_ind] != min_elem:\n            min_ind += 1\n        N = len(slices)\n        min_ind += 1\n        arr = [0 for _ in range(N)]\n        for i in range(N):\n            arr[i] = slices[(min_ind + i) % N]\n        return self.solve_linear(arr, 0, int(N/3))\n", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        def helper(start, end):\n            dp = [[0] * n for _ in range(end-start+1)]\n            dp[0] = [slices[start]] * n\n            dp[1] = [max(slices[start], slices[start+1])] * n\n            for i in range(start+2, end+1):\n                dp[i-start][0] = max(slices[i], dp[i-start-1][0])\n                for j in range(1, n):\n                    dp[i-start][j] = max(dp[i-start-1][j], slices[i] + dp[i-start-2][j-1])\n            return dp[-1][-1]\n        \n        n = len(slices) // 3\n        return max(helper(0, len(slices) - 2), helper(1, len(slices) - 1))", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        k = len(slices) // 3\n\n        dp1 = [[0] * len(slices) for _ in range(k + 1)]\n        dp2 = [[0] * len(slices) for _ in range(k + 1)]\n        \n        for i in range(1, k + 1):\n            for j in range(1, len(slices)):\n                if j == 1:\n                    dp1[i][j] = slices[j - 1]\n                    dp2[i][j] = slices[j]\n                else:\n                    dp1[i][j] = max(dp1[i - 1][j - 2] + slices[j - 1], dp1[i][j - 1])\n                    dp2[i][j] = max(dp2[i - 1][j - 2] + slices[j], dp2[i][j - 1])\n        return max(dp1[-1][-1], dp2[-1][-1])", "# class LinkedNode:\n#     def __init__(self, val):\n#         self.val = val\n#         self.next = None\n#         self.prev = None\n\nclass Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        \n        slicesN = len(slices)\n        target = slicesN//3\n        \n        table1 = [[0 for i in range(slicesN)] for ti in range(target+1)]\n        table2 = [[0 for i in range(slicesN)] for ti in range(target+1)]\n        \n        \n        for ti in range(1, target + 1):\n            for i in range(1, slicesN):\n                if i == 1:\n                    table1[ti][i] = slices[i]\n                    table2[ti][i] = slices[i-1]\n                    continue\n                table1[ti][i] = max(table1[ti][i-1], table1[ti-1][i-2] + slices[i])\n                table2[ti][i] = max(table2[ti][i-1], table2[ti-1][i-2] + slices[i-1])\n        \n        return max(table1[-1][-1], table2[-1][-1])\n    \n#         slicesN = len(slices)\n#         table = [[] for _ in range(slicesN)]\n#         target = slicesN//3\n        \n#         table[-1] = [slices[-1]]\n#         table[-2] = [slices[-2]]\n#         table[-3] = [slices[-3], slices[-3]+slices[-1]]\n        \n#         table2 = [[] for _ in range(slicesN)]\n\n#         table2[-1] = [slices[-1]]\n#         table2[-2] = [slices[-2]]\n#         table2[-3] = [slices[-3]]\n        \n#         for i in range(slicesN-4, -1, -1):\n#             table[i].append(slices[i])\n#             table2[i].append(slices[i])\n#             for j in range(i+2, slicesN):\n#                 for k, sumTemp in enumerate(table[j]):\n#                     if k+1 > target:\n#                         break\n#                     if k+1 >= len(table[i]):\n#                         table[i].append(sumTemp + slices[i])\n#                     else:\n#                         table[i][k+1] = max(table[i][k+1], sumTemp + slices[i])\n#                 for k, sumTemp in enumerate(table2[j]):\n#                     if k+1 > target:\n#                         break\n#                     if k+1 >= len(table2[i]):\n#                         table2[i].append(sumTemp + slices[i])\n#                     else:\n#                         table2[i][k+1] = max(table2[i][k+1], sumTemp + slices[i])   \n#         target = slicesN//3\n#         ans1 = 0\n#         for i, sums in enumerate(table[1:]):\n#             if len(sums) >= target:\n#                 ans1 = max(ans1, sums[target-1])\n         \n#         ans2 = 0\n#         for i, sums in enumerate(table2):\n#             if len(sums) >= target:\n#                 ans2 = max(ans2, sums[target-1])\n#         return max(ans1, ans2)\n\n            \n        \n#         @lru_cache\n#         def takePizza(slices0):\n#             # print(slices0)\n#             n = len(slices0)\n#             if n == 3:\n#                 return max(slices0)\n#             subAns = max(slices0[0] + takePizza(slices0[2:n-1]), slices0[n-1] + takePizza(slices0[1:n-2]))\n#             for i in range(1, n-1):\n#                 subAns = max(subAns, slices0[i] + takePizza(slices0[:i-1] + slices0[i+2:]))\n#             return subAns\n\n#         return takePizza(tuple(slices))\n        \n#         pointerDict = {}\n#         head = LinkedNode(0)\n#         preNode = head\n        \n#         for i, pizzaSlice in enumerate(slices):\n#             newLN = LinkedNode(pizzaSlice)\n#             pointerDict[newLN] = i\n#             preNode.next = newLN\n#             newLN.prev = preNode\n#             preNode = newLN\n            \n#         preNode.next = head\n#         head.prev = preNode\n            \n#         slicesN = len(slices)\n#         fullMask = (1 << slicesN -1)\n            \n#         dp = {}\n        \n#         def takePizza(m0, leftOver):\n            \n#             if m0 in dp:\n#                 return dp[m0]\n#             subAns = 0\n#             if leftOver == 3:\n#                 subAns = 0\n#                 pointer = head.next\n#                 while pointer != head:\n#                     subAns = max(subAns, pointer.val)\n#                     # print(pointer.val, pointerDict[pointer])\n#                     pointer = pointer.next \n#                 # print(subAns)\n#                 dp[m0] = subAns\n#                 return subAns            \n#             pointer = head.next\n#             while pointer != head:\n#                 m1 = m0|(1<<pointerDict[pointer])\n#                 if pointer.next == head:\n#                     endPointer = head.next\n#                     m1 |= (1<<pointerDict[head.next])\n#                 else:\n#                     endPointer = pointer.next\n#                     m1 |= (1<<pointerDict[pointer.next])\n#                 if pointer.prev == head:\n#                     startPointer = head.prev\n#                     m1 |= (1<<pointerDict[head.prev])\n#                 else:\n#                     startPointer = pointer.prev\n#                     m1 |= (1<<pointerDict[pointer.prev])    \n                \n                \n#                 if pointer.next == head or pointer.prev == head:  \n#                     headPrev = head.prev\n#                     headNext = head.next\n#                     head.next = endPointer.next\n#                     head.prev = startPointer.prev\n#                     head.prev.next = head\n#                     head.next.prev = head\n#                     subAns = max(subAns, pointer.val + takePizza(m1, leftOver-3))\n#                     head.prev = headPrev\n#                     head.next = headNext\n#                 else:\n#                     startPointer.prev.next = endPointer.next\n#                     endPointer.next.prev = startPointer.prev\n#                     subAns = max(subAns, pointer.val + takePizza(m1, leftOver-3))\n#                 startPointer.prev.next = startPointer\n#                 startPointer.next.pre = startPointer                    \n#                 pointer.prev.next = pointer\n#                 pointer.next.prev = pointer\n#                 endPointer.prev.next = endPointer\n#                 endPointer.next.pre = endPointer \n                \n#                 pointer = pointer.next\n#             dp[m0] = subAns\n#             return subAns\n#         return takePizza(0, slicesN)\n            \n            \n            \n            \n            \n", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n = len(slices)\n        nPick = n//3\n        total = [[[0] * (n + 1) for _ in range(nPick+1)] for __ in range(2)]\n        total[1][1][1] = slices[0]\n        \n        \n        for i in range(1, nPick+1):\n            for j in range(2, n + 1):\n                total[0][i][j] = max(slices[j-1] + total[0][i-1][j-2], total[0][i][j-1])\n                total[1][i][j] = max(slices[j-1] + total[1][i-1][j-2], total[1][i][j-1])\n        \n        return max(max(total[0][nPick]), max(total[1][nPick][:-1]))\n            \n        \n", "class Solution:\n    def maxSizeSlices(self, w: List[int]) -> int:\n        n_picks = len(w)//3\n        \n        dp1 = [[0 for _ in range(len(w))] for _ in range(n_picks+1)]\n        dp2 = [[0 for _ in range(len(w))] for _ in range(n_picks+1)]\n        \n        for i in range(1,n_picks+1):\n            for j in range(1,len(w)):\n                \n                if j == 1:\n                    dp1[i][j] = w[j-1]\n                    dp2[i][j] = w[j]\n                    continue\n                dp1[i][j] = max(w[j-1] + dp1[i-1][j-2],dp1[i][j-1])\n                dp2[i][j] = max(w[j] + dp2[i-1][j-2],dp2[i][j-1])\n        \n        return max(dp1[n_picks][len(w)-1],dp2[n_picks][len(w)-1])", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        \n        def find(arr,n):\n            dp1=[0 for i in range(n+1)]\n            dp2=[0 for i in range(n+1)]\n            dp2[1]=arr[0]\n            for i in range(1,len(arr)):\n                new_dp1=[max(dp1[j],dp2[j]) for j in range(n+1)]\n                new_dp2=[0]+[arr[i]+dp1[j-1] for j in range(1,n+1)]\n                dp1=new_dp1\n                dp2=new_dp2\n            return max(dp2[-1],dp1[-1])\n        n=len(slices)//3\n        return max(find(slices[:-1],n),find(slices[1:],n))\n                \n", "class Solution:\n    def maxSizeSlices(self, s: List[int]) -> int:\n        ct = len(s)//3\n        @lru_cache(None)\n        def f(l, r, n):\n            if n == 0:\n                return 0\n            if l > r:\n                return -1e18\n            if n == 1:\n                return max(s[l:r+1])\n            return max(f(l+1, r, n), s[l] + f(l+2, r, n-1))\n        return max(f(1, len(s)-1, ct), s[0] + f(2, len(s)-2, ct-1))", "class Solution:\n  def dp(self, i, j, k, l):\n    # max by taking k from s[i:j] assume cycle if l = 1 else no-cycle\n    if (i, j, k, l) not in self.memo:\n      if k == 1:\n        self.memo[(i, j, k, l)] = max(self.s[i:j])\n      elif j - i < 2 * k - 1:\n        self.memo[(i, j, k, l)] = float('-inf')\n      else:\n        # max of taking self.s[i] and not taking self.s[i] at this step\n        self.memo[(i, j, k, l)] = max(self.dp(i + 2, j - l, k - 1, 0) + self.s[i], self.dp(i + 1, j, k, 0))\n    return self.memo[(i, j, k, l)]\n  def maxSizeSlices(self, slices: List[int]) -> int:\n    # Q0213, dynamic programming\n    self.memo, self.s, n = {}, slices, len(slices)\n    return self.dp(0, n, n // 3, 1)", "from functools import lru_cache\n\nclass Solution:\n    def maxSizeSlices(self, w: List[int]) -> int:\n        n = len(w)\n        k = n // 3\n        dp1 = [[0] * n for _ in range(k + 1)]\n\n        results = [0, 0]\n        for offset in range(2):\n            for i in range(1, k + 1):\n                dp1[i][1] = w[offset]\n                for j in range(2, n):\n                    dp1[i][j] = max(dp1[i - 1][j - 2] + w[j - 1 + offset], dp1[i][j - 1])\n            results[offset] = dp1[-1][-1]\n\n        return max(results)\n", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        l=len(slices)\n        s1=slices[0:l-1]\n        s2=slices[1:l]\n        n=l//3\n        \n        def summax(arr):\n        \n            dp=[[0]*(n+1) for i in range(l+1)]\n            p=len(arr)\n            for i in range(1,p+1):\n                for j in range(1,n+1):\n                    if j>i:\n                        break\n        \n                    if i==1:\n                        dp[i][j]=arr[0]\n                    else:\n                        dp[i][j]=max(dp[i-1][j],dp[i-2][j-1]+arr[i-1])\n                        \n            return dp[p][n]\n        \n        return max(summax(s1),summax(s2))\n", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        original = slices\n        slices = slices[:-1]\n        dp = [[0 for j in range(len(original) // 3 + 1)] for i in range(len(slices) + 1)]\n        \n        for j in range(1, len(original) // 3 + 1):\n            dp[1][j] = slices[0]\n        \n        for j in range(1, len(dp[0])):\n            for i in range(2, len(dp)):\n                dp[i][j] = max(dp[i - 1][j], dp[i - 2][j - 1] + slices[i - 1], dp[i][j])\n        ans = dp[-1][-1]\n        slices = original[1:]\n\n        dp = [[0 for j in range(len(original) // 3 + 1)] for i in range(len(slices) + 1)]\n        \n        for j in range(1, len(original) // 3 + 1):\n            dp[1][j] = slices[0]\n        \n        for j in range(1, len(dp[0])):\n            for i in range(2, len(dp)):\n                dp[i][j] = max(dp[i - 1][j], dp[i - 2][j - 1] + slices[i - 1], dp[i][j])\n        \n\n        ans = max(ans, dp[-1][-1])\n        return ans\n            \n", "class Solution(object):\n    def maxSizeSlices(self, A):\n        N = len(A)\n        A.extend(A)\n        NINF = float('-inf')\n\n        @lru_cache(None)\n        def dp(i, j, rem):\n            if rem == 0:\n                return 0\n            elif i > j:\n                return NINF\n            else:\n                return max(dp(i+2, j, rem-1) + A[i], dp(i+1, j, rem))\n\n        return max(A[0] + dp(2, N - 2, N // 3 - 1), dp(1, N - 1, N // 3))", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, remaining, version):\n            if i > len(slices) - version:\n                return 0\n            if remaining == 0:\n                return 0\n            else:\n                return max(dp(i + 1, remaining, version), slices[i] + dp(i + 2, remaining - 1, version))\n        return max(dp(1, len(slices) // 3, 1), dp(0, len(slices) // 3, 2))", "class Solution:\n    def maxSizeSlices(self, w: List[int]) -> int:\n        k = len(w)//3\n        \n        dp1 = [[0]*(len(w)) for _ in range(k+1)]\n        dp2 = [[0]*(len(w)) for _ in range(k+1)]\n        \n        for n in range(1,k+1):\n            for i in range(1,len(w)):\n                \n                if i==1:\n                    dp1[n][i] = w[i-1]\n                    dp2[n][i] = w[i]\n                    continue\n                \n                dp1[n][i] = max(dp1[n-1][i-2]+w[i-1],dp1[n][i-1])\n                dp2[n][i] = max(dp2[n-1][i-2]+w[i],dp2[n][i-1])\n        return max(dp1[-1][-1],dp2[-1][-1])", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        N = len(slices)\n        \n        @lru_cache(None)\n        def dp(i, k, d):\n            if 3*k == N:\n                return 0\n            if i >= N-d:\n                return -math.inf\n            return max(slices[i] + dp(i+2, k+1, d), dp(i+1, k, d))\n        \n        return max(slices[0] + dp(2, 1, 1), dp(1, 0, 0))", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        # find a subseq in circle without disjoint element....\n        n = len(slices) // 3\n        \n        def get_maxsubseq(pieces):\n            #dp(i, j) = max(dp(i-1, j-2) + pieces[j], dp(i, j-1))\n            m = len(pieces)\n            dp = {}\n            for i in range(1, n+1):\n                tdp = {}\n                for j in range(m):\n                    tdp[j] = max(dp.get(j-2, 0) + pieces[j], tdp.get(j-1, 0))\n                    \n                dp = tdp\n            return dp[m-1]\n        \n        return max(get_maxsubseq(slices[1:]), get_maxsubseq(slices[:-1]))\n                \n            \n", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        m = len(slices)\n        slices1 = slices[0:m-1]\n        slices2 = slices[1:]\n        n = m // 3\n        def helper(arr, n):\n            m = len(arr)\n            \n            # dp[i][j] represents max sum when pick j elements from array of length i\n            dp = [[0 for j in range(n + 1)] for i in range(m + 1)]\n            for i in range(1,m + 1):\n                for j in range(1, n + 1):\n                    if i == 1:\n                        dp[i][j] = arr[0]\n                    else:\n                        dp[i][j] = max(dp[i - 1][j], dp[i - 2][j - 1] + arr[i - 1])\n                        \n            return dp[m][n]\n                        \n        return max(helper(slices1, n), helper(slices2, n))", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        # select 1 -> max of selecting n-1 from 2, 3n-1\n        # not select 1 -> max of selecting n from 2, 3n                                                                 \n        # a table to fill: (either selected or not)\n        #  1, 2, 3, ... 3n # pos\n        #0  maxSum\n        #1\n        #2\n        #\n        #n\n        #num selected\n        N = len(slices) // 3\n        dpOn = [[-1 for i in range(3 * N)] for j in range(N+1)]\n        dpOff = [[-1 for i in range(3 * N)] for j in range(N+1)]\n        \n        # first 1 selected\n        dpOn[1][0] = slices[0]\n        \n        for i in range(1, 3*N):\n            dpOff[0][i] = 0\n            \n        for i in range(1, 3*N):\n            for j in range(1, N+1):\n                dpOff[j][i] = max(dpOn[j][i-1], dpOff[j][i-1])\n                if dpOff[j-1][i-1] == -1:\n                    dpOn[j][i] = -1\n                else:\n                    dpOn[j][i] = dpOff[j-1][i-1] + slices[i]\n        \n        maxVal = dpOff[N][3*N-1]\n        \n        dpOn = [[-1 for i in range(3 * N)] for j in range(N+1)]\n        dpOff = [[-1 for i in range(3 * N)] for j in range(N+1)]\n        # first 1 not selected\n        for i in range(0, 3*N):\n            dpOff[0][i] = 0\n\n        for i in range(1, 3*N):\n            for j in range(1, N+1):\n                dpOff[j][i] = max(dpOn[j][i-1], dpOff[j][i-1])\n                if dpOff[j-1][i-1] == -1:\n                    dpOn[j][i] = -1\n                else:\n                    dpOn[j][i] = dpOff[j-1][i-1] + slices[i]\n        \n        maxVal = max(maxVal, dpOn[N][3*N-1], dpOff[N][3*N-1])\n        \n        return maxVal", "from functools import *\nclass Solution(object):\n    def maxSizeSlices(self, slices):\n        @lru_cache(None)\n        def dp(start, end, k):\n            if k ==0:\n                return 0\n            if k ==  1:\n                return max(slices[start:end+1])\n            if end-start+1<k*2-1:\n                return -float('inf')\n            return max(dp(start+2, end, k-1)+slices[start], dp(start+1, end, k))\n        n = len(slices)//3\n        return max(dp(0, len(slices)-2, n), dp(1, len(slices)-1, n))\n", "from typing import List, Dict, Set, Optional\nfrom enum import Enum\nfrom functools import lru_cache\n\n\nclass Person(Enum):\n    ME = 0\n    ALICE = 1\n    BOB = 2\n\n\nclass DoublyLinkedListNode:\n    def __init__(self, val: int) -> None:\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        @lru_cache(None)\n        def dfs(pizza_slice: int, max_slice: int, level: int) -> int:\n            if level == len(slices) / 3:\n                return 0\n\n            if pizza_slice > max_slice:\n                return 0\n\n            return max(\n                dfs(pizza_slice + 2, max_slice, level + 1) + slices[pizza_slice],\n                dfs(pizza_slice + 1, max_slice, level),\n            )\n\n        return max(dfs(1, len(slices) - 1, 0), dfs(0, len(slices) - 2, 0))\n\n\n\n\n    def maxSizeSlicesBruteForce(self, slices: List[int]) -> int:\n        slices_nodes = [DoublyLinkedListNode(pos) for pos in range(len(slices))]\n\n        for pizza_slice_pos in range(len(slices)):\n            prev_pizza_slice_pos = (pizza_slice_pos - 1) % len(slices)\n            next_pizza_slice_pos = (pizza_slice_pos + 1) % len(slices)\n\n            pizza_slice = slices_nodes[pizza_slice_pos]\n            prev_pizza_slice = slices_nodes[prev_pizza_slice_pos]\n            next_pizza_slice = slices_nodes[next_pizza_slice_pos]\n\n            prev_pizza_slice.next = pizza_slice\n            pizza_slice.prev = prev_pizza_slice\n\n            pizza_slice.next = next_pizza_slice\n            next_pizza_slice.prev = pizza_slice\n\n        def dfs(pizza_slices_left: Set[int]) -> int:\n            result = 0\n            for pizza_slice_pos in list(pizza_slices_left):\n                pizza_slice = slices_nodes[pizza_slice_pos]\n\n                prev_pizza_slice = pizza_slice.prev\n                next_pizza_slice = pizza_slice.__next__\n\n                prev_prev_pizza_slice = prev_pizza_slice.prev\n                next_next_pizza_slice = next_pizza_slice.__next__\n\n                prev_prev_pizza_slice.next = next_next_pizza_slice\n                next_next_pizza_slice.prev = prev_prev_pizza_slice\n\n                pizza_slices_left.remove(pizza_slice.val)\n                pizza_slices_left.remove(prev_pizza_slice.val)\n                pizza_slices_left.remove(next_pizza_slice.val)\n\n                result = max(result, dfs(pizza_slices_left) + slices[pizza_slice.val])\n\n                pizza_slices_left.add(pizza_slice.val)\n                pizza_slices_left.add(prev_pizza_slice.val)\n                pizza_slices_left.add(next_pizza_slice.val)\n\n                prev_prev_pizza_slice.next = prev_pizza_slice\n                next_next_pizza_slice.prev = next_pizza_slice\n\n            return result\n\n        return dfs(set(range(len(slices))))\n\n\nclass TestSolution:\n    def setup(self) -> None:\n        self.sol = Solution()\n\n    def test_case1(self) -> None:\n        assert self.sol.maxSizeSlices([1,2,3,4,5,6]) == 10\n\n    def test_case2(self) -> None:\n        assert self.sol.maxSizeSlices([6,3,1,2,6,2,4,3,10,4,1,4,6,5,5,3,4,7,6,5,8,7,3,8,8,1,7,1,7,8]) == 10\n", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        N = len(slices)\n        target = N//3\n        dp = [[-1 for x in range(target)] for y in range(N)]\n        \n        def dfs(idx: int, cnt: int) -> int:\n            if cnt >= target or idx >= N:\n                return 0\n            \n            if dp[idx][cnt] == -1:\n                dp[idx][cnt] = max(dfs(idx+1, cnt), slices[idx]+dfs(idx+2, cnt+1))\n            return dp[idx][cnt]\n            \n        result = dfs(1, 0)\n        dp = [[-1 for x in range(target)] for y in range(N)]\n        N -= 1\n        result = max(result, dfs(0, 0))\n        \n        return result", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n=len(slices)\n        dp=[[0 for j in range(n//3)] for i in range(n)]\n        \n        dp[0][0]=slices[0]\n        \n        for i in range(1,n):\n            dp[i][0]=max(dp[i-1][0],slices[i])\n        \n        for i in range(2,n):\n            for j in range(1,min(i//2+1,n//3)):\n                dp[i][j]=max(dp[i-1][j],dp[i-2][j-1]+slices[i])\n        \n        mx=0\n        \n        for i in range(n-1):\n            mx=max(mx,dp[i][-1])\n            \n        for i in range(n):\n            for j in range(n//3):\n                dp[i][j]=0\n        \n        for i in range(1,n):\n            dp[i][0]=max(dp[i-1][0],slices[i])\n        \n        for i in range(2,n):\n            for j in range(1,min(i//2+1,n//3)):\n                dp[i][j]=max(dp[i-1][j],dp[i-2][j-1]+slices[i])\n        \n        mx=max(mx,dp[-1][-1])\n        return mx", "class Solution:\n    def maxSizeSlices(self, w: List[int]) -> int:\n        n_picks = len(w)//3\n        \n        dp1 = [[0 for _ in range(len(w))] for _ in range(n_picks+1)]\n        dp2 = [[0 for _ in range(len(w))] for _ in range(n_picks+1)]\n        \n        for i in range(1,n_picks+1):\n            for j in range(1,len(w)):\n                \n                if j == 1:\n                    dp1[i][j] = w[j-1]\n                    dp2[i][j] = w[j]\n                    continue\n                dp1[i][j] = max(w[j-1] + dp1[i-1][j-2],dp1[i][j-1])\n                dp2[i][j] = max(w[j] + dp2[i-1][j-2],dp2[i][j-1])\n        \n        return max(dp1[n_picks][len(w)-1],dp2[n_picks][len(w)-1])\n    \n", "from functools import lru_cache\n\nclass Solution:\n    def maxSizeSlices(self, w: List[int]) -> int:\n        n = len(w)\n        k = n // 3\n        dp1 = [[0] * n for _ in range(k + 1)]\n        dp2 = [[0] * n for _ in range(k + 1)]\n        for i in range(1, k + 1):\n            dp1[i][1] = w[0]\n            dp2[i][1] = w[1]\n            for j in range(2, len(w)):\n                dp1[i][j] = max(dp1[i - 1][j - 2] + w[j - 1], dp1[i][j - 1])\n                dp2[i][j] = max(dp2[i - 1][j - 2] + w[j], dp2[i][j - 1])\n        return max(dp1[-1][-1], dp2[-1][-1])", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n = len(slices)\n        memo = {}\n        def solve(i, j, k):\n            if k == 0:\n                return 0\n            elif i > j:\n                return 0\n            elif (i, j, k) in memo:\n                return memo[(i, j, k)]\n            memo[(i, j, k)] = max(slices[i]+solve(i+2, j, k-1), solve(i+1, j, k))\n            return memo[(i, j, k)]\n        return max(solve(0, n-2, n//3), solve(1, n-1, n//3))", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        N = len(slices)\n        \n        @lru_cache(None)\n        def rec(cur, taken, avoid_last):\n            if taken * 3 > N:\n                return -math.inf\n            if cur >= N:\n                return 0 if taken * 3 == N else -math.inf\n            \n            ans = rec(cur+1, taken, avoid_last)\n            if avoid_last and cur == N-1:\n                return ans\n            ans = max(ans, rec(cur+2, taken+1, avoid_last | (cur == 0)) + slices[cur])\n            \n            return ans\n        \n        return rec(0, 0, False)", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, j, k):\n            if k == 0:\n                return 0\n            elif i >= j:\n                return -math.inf\n            else:\n                return max(\n                    slices[i] + dp(i + 2, j, k - 1),\n                    dp(i + 1, j, k)\n                )\n\n        n = len(slices)\n        s = n // 3\n        return max(\n            dp(1, n, s),\n            dp(0, n - 1, s)\n        )", "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n = len(slices) // 3\n        if n == 1:\n            return max(slices)\n        \n        @lru_cache(None)\n        def process(f, p, i, k):\n            if i == 0:\n                return slices[0] if f == 1 else 0\n            \n            if p == 1:\n                return process(f, 0, i-1, k)\n            else:\n                if (i == 1 and f == 1) or k == 0:\n                    return process(f, 0, i-1, k)\n                else:\n                    return max(process(f, 0, i-1, k), slices[i]+process(f, 1, i-1, k-1))\n        \n        return max(process(0, 0, 3*n-1, n), process(1, 1, 3*n-1, n-1))\n\n                    \n            \n            \n            \n            \n            \n        \n", "from typing import List, Dict, Set, Optional\nfrom enum import Enum\nfrom functools import lru_cache\n\n\nclass Person(Enum):\n    ME = 0\n    ALICE = 1\n    BOB = 2\n\n\nclass DoublyLinkedListNode:\n    def __init__(self, val: int) -> None:\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        levels = len(slices) // 3 + 1\n        result = 0\n        for start, stop in ((0, len(slices) - 1), (1, len(slices))):\n            dp = [[0] * levels for _ in range(len(slices) + 2)]\n\n            for pizza_slice in reversed(list(range(start, stop))):\n                for level in range(levels):\n                    if pizza_slice + 2 < len(dp) and level < levels - 1:\n                        dp[pizza_slice][level] = max(\n                            dp[pizza_slice][level],\n                            dp[pizza_slice + 2][level + 1] + slices[pizza_slice],\n                        )\n\n                    dp[pizza_slice][level] = max(\n                        dp[pizza_slice][level],\n                        dp[pizza_slice + 1][level],\n                    )\n\n            result = max(result, dp[start][0])\n\n        return result\n\n\n    def maxSizeSlicesTopDown(self, slices: List[int]) -> int:\n        @lru_cache(None)\n        def dfs(pizza_slice: int, max_slice: int, level: int) -> int:\n            if level == len(slices) / 3:\n                return 0\n\n            if pizza_slice > max_slice:\n                return 0\n\n            return max(\n                dfs(pizza_slice + 2, max_slice, level + 1) + slices[pizza_slice],\n                dfs(pizza_slice + 1, max_slice, level),\n            )\n\n        return max(dfs(1, len(slices) - 1, 0), dfs(0, len(slices) - 2, 0))\n\n    def maxSizeSlicesBruteForce(self, slices: List[int]) -> int:\n        slices_nodes = [DoublyLinkedListNode(pos) for pos in range(len(slices))]\n\n        for pizza_slice_pos in range(len(slices)):\n            prev_pizza_slice_pos = (pizza_slice_pos - 1) % len(slices)\n            next_pizza_slice_pos = (pizza_slice_pos + 1) % len(slices)\n\n            pizza_slice = slices_nodes[pizza_slice_pos]\n            prev_pizza_slice = slices_nodes[prev_pizza_slice_pos]\n            next_pizza_slice = slices_nodes[next_pizza_slice_pos]\n\n            prev_pizza_slice.next = pizza_slice\n            pizza_slice.prev = prev_pizza_slice\n\n            pizza_slice.next = next_pizza_slice\n            next_pizza_slice.prev = pizza_slice\n\n        def dfs(pizza_slices_left: Set[int]) -> int:\n            result = 0\n            for pizza_slice_pos in list(pizza_slices_left):\n                pizza_slice = slices_nodes[pizza_slice_pos]\n\n                prev_pizza_slice = pizza_slice.prev\n                next_pizza_slice = pizza_slice.__next__\n\n                prev_prev_pizza_slice = prev_pizza_slice.prev\n                next_next_pizza_slice = next_pizza_slice.__next__\n\n                prev_prev_pizza_slice.next = next_next_pizza_slice\n                next_next_pizza_slice.prev = prev_prev_pizza_slice\n\n                pizza_slices_left.remove(pizza_slice.val)\n                pizza_slices_left.remove(prev_pizza_slice.val)\n                pizza_slices_left.remove(next_pizza_slice.val)\n\n                result = max(result, dfs(pizza_slices_left) + slices[pizza_slice.val])\n\n                pizza_slices_left.add(pizza_slice.val)\n                pizza_slices_left.add(prev_pizza_slice.val)\n                pizza_slices_left.add(next_pizza_slice.val)\n\n                prev_prev_pizza_slice.next = prev_pizza_slice\n                next_next_pizza_slice.prev = next_pizza_slice\n\n            return result\n\n        return dfs(set(range(len(slices))))\n\n\nclass TestSolution:\n    def setup(self) -> None:\n        self.sol = Solution()\n\n    def test_case1(self) -> None:\n        assert self.sol.maxSizeSlices([1,2,3,4,5,6]) == 10\n\n    def test_case2(self) -> None:\n        assert self.sol.maxSizeSlices([6,3,1,2,6,2,4,3,10,4,1,4,6,5,5,3,4,7,6,5,8,7,3,8,8,1,7,1,7,8]) == 10\n", "class Solution:\n    def maxSizeSlices(self, w: List[int]) -> int:\n        n = len(w)\n        k = n // 3\n\n        results = [0, 0]\n        for offset in range(2):\n            cur = [0] * n\n            prev = [0] * n\n            for _ in range(k):\n                cur[1] = w[offset]\n                for j in range(2, n):\n                    cur[j] = max(prev[j - 2] + w[j - 1 + offset], cur[j - 1])\n                prev[:] = cur\n                cur[:] = [0] * n\n            results[offset] = prev[-1]\n\n        return max(results)\n                             \n                    \n"]
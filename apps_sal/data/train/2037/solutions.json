["# python3\nimport sys\nfrom collections import namedtuple\n\n\ndef readline(): return list(map(int, input().split()))\n\n\ndef readlines():\n    for line in sys.stdin.readlines():\n        yield list(map(int, line.split()))\n\n\nclass State(namedtuple('State', 'payload time floor')):\n    def hook(self, pivot, a, b):\n        lo, up = min(pivot, a, self.floor), max(pivot, a, self.floor)\n        return tuple(x for x in self.payload if x < lo or up < x) + (b,), \\\n            self.time + abs(self.floor - pivot) + abs(pivot - a)\n\n    def choices_to_take_next(self, a, b):\n        floor = self.floor\n\n        payload, time = self.hook(floor, a, b)\n        if len(payload) < 5:\n            yield payload, time\n            if floor > a:\n                pivots = (x for x in self.payload if x > floor)\n            elif floor == a:\n                pivots = ()\n            else:\n                pivots = (x for x in self.payload if x < floor)\n        else:\n            pivots = self.payload\n\n        for pivot in pivots:\n            yield self.hook(pivot, a, b)\n\n\ndef time_to_get_free(payload, floor):\n    if payload:\n        lo, up = min(payload), max(payload)\n        return abs(lo-up) + min(abs(floor-lo), abs(floor-up))\n    else:\n        return 0\n\n\ndef main():\n    n, = readline()\n\n    floor = 1\n    positions = {(): 0}  # empty elevator, time = 0\n    for (a, b) in readlines():\n        max_acceptable_time = min(positions.values()) + 16 - abs(floor - a)\n\n        new_positions = dict()\n        for payload, time in list(positions.items()):\n            state = State(payload, time, floor)\n            for npayload, ntime in state.choices_to_take_next(a, b):\n                if ntime <= max_acceptable_time:\n                    npayload = tuple(sorted(npayload))\n                    if new_positions.setdefault(npayload, ntime) > ntime:\n                        new_positions[npayload] = ntime\n\n        positions = new_positions\n        floor = a\n\n    return min(t + time_to_get_free(p, floor) for p, t in list(positions.items())) \\\n        + 2 * n\n\n\nprint(main())\n", "# python3\nimport sys\nfrom collections import namedtuple\n\n\ndef readline(): return list(map(int, input().split()))\n\n\ndef readlines():\n    for line in sys.stdin.readlines():\n        yield list(map(int, line.split()))\n\n\nclass State(namedtuple('State', 'payload time floor')):\n    def hook(self, pivot, a, b):\n        lo, up = min(pivot, a, self.floor), max(pivot, a, self.floor)\n        return tuple(x for x in self.payload if x < lo or up < x) + (b,), \\\n            self.time + abs(self.floor - pivot) + abs(pivot - a)\n\n    def choices_to_take_next(self, a, b):\n        floor = self.floor\n\n        payload, time = self.hook(floor, a, b)\n        if len(payload) < 5:\n            yield payload, time\n            if floor > a:\n                pivots = (x for x in self.payload if x > floor)\n            elif floor == a:\n                pivots = ()\n            else:\n                pivots = (x for x in self.payload if x < floor)\n        else:\n            pivots = self.payload\n\n        for pivot in pivots:\n            yield self.hook(pivot, a, b)\n\n\ndef time_to_get_free(payload, floor):\n    if payload:\n        lo, up = min(payload), max(payload)\n        return abs(lo-up) + min(abs(floor-lo), abs(floor-up))\n    else:\n        return 0\n\n\ndef main():\n    n, = readline()\n\n    floor = 1\n    positions = {(): 0}  # empty elevator, time = 0\n    for (a, b) in readlines():\n        max_acceptable_time = min(positions.values()) + 16 - abs(floor - a)\n\n        new_positions = dict()\n        for payload, time in list(positions.items()):\n            state = State(payload, time, floor)\n            for npayload, ntime in state.choices_to_take_next(a, b):\n                if ntime <= max_acceptable_time:\n                    npayload = tuple(sorted(npayload))\n                    if new_positions.setdefault(npayload, ntime) > ntime:\n                        new_positions[npayload] = ntime\n\n        positions = new_positions\n        floor = a\n\n    return min(t + time_to_get_free(p, floor) for p, t in list(positions.items())) \\\n        + 2 * n\n\n\nprint(main())\n"]
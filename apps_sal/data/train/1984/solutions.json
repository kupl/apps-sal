["# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def buildTree(self, preorder, inorder):\n         \"\"\"\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         \"\"\"\n         def build(stop):\n             if preorder and inorder[-1] != stop:\n                 root = TreeNode(preorder.pop())\n                 root.left = build(root.val)\n                 inorder.pop()\n                 root.right = build(stop)\n                 return root\n             return None # can be skipped\n         \n         preorder.reverse()\n         inorder.reverse()\n         return build(None)", "\n class Solution:\n     def buildTree(self, preorder, inorder):\n         inorder_dict = {val:index for index,val in enumerate(inorder)}\n \n         def buildTreeCore(pre_l, pre_r, in_l, in_r):\n             if pre_l == pre_r:\n                 return None\n \n             root = TreeNode(preorder[pre_l])\n             root_inorder_index = inorder_dict[root.val]\n             root.left = buildTreeCore(pre_l+1,pre_l+1+root_inorder_index-in_l,\\\n                                     in_l,root_inorder_index)\n             root.right = buildTreeCore(pre_l+1+root_inorder_index-in_l, pre_r,\\\n                                     root_inorder_index+1,in_r)\n             return root\n \n         return buildTreeCore(0, len(preorder), 0, len(preorder))", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n   def buildTree(self, preorder, inorder):\n     \"\"\"\n     :type preorder: List[int]\n     :type inorder: List[int]\n     :rtype: TreeNode\n     \"\"\"\n     lookup = {}\n     for i,num in enumerate(inorder):\n         lookup[num] = i \n         \n     return self.buildrecurtree(lookup, preorder,inorder, 0,0,len(inorder))\n \n   def buildrecurtree(self, lookup, preorder, inorder, pre_start, in_start, in_end):\n     if (in_start == in_end):\n         return None\n     node = TreeNode(preorder[pre_start])\n     i = lookup[preorder[pre_start]]\n     node.left = self.buildrecurtree(lookup, preorder, inorder, pre_start + 1, in_start, i)\n     node.right = self.buildrecurtree(lookup, preorder, inorder, pre_start + 1 + i - in_start, i + 1, in_end)\n     return node\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def buildTree(self, preorder, inorder):\n         \"\"\"\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         \"\"\"\n         if len(inorder) == 0:\n             return\n         #\u6784\u5efa\u5143\u7d20\u503c\u4e3akey, index\u4e3avalue\u7684hashmap\n         HashMap = {}\n         for i in range(len(inorder)):\n             HashMap[inorder[i]] = i\n         \n         root = self.build(HashMap, inorder, 0, len(inorder)-1, preorder, 0, len(preorder)-1)\n         return root\n     \n     def build(self, HashMap, inorder, istart, iend, preorder, pstart, pend):\n         if istart>iend or pstart > pend:\n             return None\n \n         root = TreeNode(preorder[pstart])\n         mid_index = HashMap[root.val]\n         left_size = mid_index - istart\n         right_size = iend - mid_index\n         root.left = self.build(HashMap, inorder, istart, mid_index-1, preorder, pstart+1, pstart+left_size)\n         root.right = self.build(HashMap, inorder, mid_index+1, iend, preorder, pend-right_size+1, pend)\n         return root", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def buildTree(self, preorder, inorder):\n         \"\"\"\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         \"\"\"\n         if not preorder or not inorder:\n             return None\n         root = TreeNode(preorder.pop(0))\n         index = inorder.index(root.val)\n         root.left = self.buildTree(preorder, inorder[:index])\n         root.right = self.buildTree(preorder, inorder[index+1:])\n         return root\n \n class Solution:\n     # @param inorder, a list of integers\n     # @param postorder, a list of integers\n     # @return a tree node\n     # 12:00\n     def buildTree(self, preorder, inorder):\n         dicinorder = {}\n         for i,val in enumerate(inorder):\n             dicinorder[val] = i\n         start, end = 0, len(inorder)\n         return self.helper(start, end, preorder, dicinorder)\n     \n     def helper(self, start, end, preorder, dicinorder):\n         if start == end:\n             return None\n         root = TreeNode(preorder.pop(0))\n         inorderIndex = dicinorder[root.val]\n         root.left = self.helper(start, inorderIndex, preorder, dicinorder)\n         root.right = self.helper(inorderIndex+1, end, preorder, dicinorder)\n         return root", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def buildTree(self, preorder, inorder):\n         \"\"\"\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         \"\"\"\n         INDICES = {}\n         for idx, val in enumerate(inorder):\n             INDICES[val] = idx\n             \n         ptr = 0\n         def build(left, right):\n             nonlocal ptr\n             if left > right or right < left or ptr >= len(preorder):\n                 return \n             val = preorder[ptr]\n \n             node = TreeNode(preorder[ptr])\n             ptr += 1\n             node.left = build(left, INDICES[val]-1) \n             node.right = build(INDICES[val]+1, right) \n             \n             return node\n         \n         return build(0, len(inorder))\n             ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     # def buildTree(self, preorder, inorder):\n     #     \"\"\"\n     #     :type preorder: List[int]\n     #     :type inorder: List[int]\n     #     :rtype: TreeNode\n     #     \"\"\"\n     #     if (not preorder):\n     #         return None\n     #     root_val = preorder[0]\n     #     root = TreeNode(root_val)\n     #     left_count = inorder.index(root_val)\n     #     root.left = self.buildTree(preorder[1:left_count + 1], inorder[:left_count])\n     #     root.right = self.buildTree(preorder[left_count + 1:], inorder[left_count + 1:])\n     #     return root\n         \n \n     \"\"\"\n     \u6808\uff08\u672c\u9898\u5bf9\u7406\u89e3\u6808\u7684\u4f7f\u7528\u5f88\u6709\u5e2e\u52a9\uff09\n     \u5148\u5e8f\u5e8f\u5217\uff1a\n         1. \u5982\u679c preorder[i] \u6709\u5de6\u5b50\u6811\uff0c\u90a3\u4e48 preorder[i + 1] \u662f\u5176\u5de6\u5b50\u6811\u7684\u6839\n         2. \u5982\u679c preorder[i] \u53ea\u6709\u53f3\u5b50\u6811\uff0c\u90a3\u4e48 preorder[i + 1] \u662f\u5176\u53f3\u5b50\u6811\u7684\u6839\n         3. \u5982\u679c preorder[i] \u662f\u53f6\u5b50\u8282\u70b9\uff0c\u90a3\u4e48 preorder[i + 1] \u662f\u5176\u6700\u6df1\u516c\u5171\u7956\u5148\u7684\u53f3\u5b50\u6811\u7684\u6839\n         4. \u5982\u679c preorder[i + 1:i + j] \u662f preorder[i] \u7684\u5de6\u5b50\u6811\u7684\u8282\u70b9\uff0c\u90a3\u4e48 preorder[i + j + 1] \u662f preorder[i] \u7684\u53f3\u5b50\u6811\uff08\u5982\u679c\u5b58\u5728\u7684\u8bdd\uff09\u7684\u6839\n     \u8bfb\u53d6\u5148\u5e8f\u5e8f\u5217\uff0c\u5f53\u4e0d\u786e\u5b9a\u8282\u70b9\u7684\u5de6\u5b50\u6811\u662f\u5426\u5904\u7406\u5b8c\u6bd5\u65f6\u5c06\u8282\u70b9\u538b\u6808\n     \u4e0a\u8ff0\u64cd\u4f5c\u5c06\u4fdd\u6301\u6808\u5185\u5143\u7d20\u5173\u7cfb\uff1a\u4efb\u610f\u65f6\u523b\uff0c\u6808\u5185\u7684\u540e\u5165\u6808\u5143\u7d20\u4f4d\u4e8e\u5148\u5165\u6808\u5143\u7d20\u7684\u5de6\u5b50\u6811\u4e2d\n     \u5f53\u5143\u7d20\u7684\u5de6\u5b50\u6811\u5df2\u7ecf\u5168\u90e8\u5904\u7406\u5b8c\u65f6\u5c06\u5176\u51fa\u6808\uff0c\u6b64\u65f6\u5e94\u8be5\u7ee7\u7eed\u5904\u7406\u5b83\u7684\u53f3\u5b50\u6811\uff08\u5982\u679c\u5b58\u5728\u7684\u8bdd\uff09\n     \u5224\u5b9a\u5143\u7d20\u7684\u5de6\u5b50\u6811\u662f\u5426\u5df2\u7ecf\u5904\u7406\u5b8c\u6bd5\uff0c\u9700\u8981\u4e2d\u5e8f\u5e8f\u5217\uff0c\u5bf9\u4e8e\u4e2d\u5e8f\u5e8f\u5217\u4e2d\u7684\u4efb\u610f\u5143\u7d20 j \uff0c\u5176\u5de6\u5b50\u6811\u4f4d\u4e8e [j - left_count, j - 1] \u4e2d\n     \u56e0\u6b64\uff0c\u5f53\u6808\u9876\u5143\u7d20\u7b49\u4e8e\u4e2d\u5e8f\u5e8f\u5217\u7684\u5f53\u524d\u5143\u7d20 j \uff08\u4e2d\u5e8f\u7684 [j - left_count, j - 1] \u5df2\u7ecf\u5904\u7406\uff09\u65f6\uff0c\u8868\u660e\u6808\u9876\u5143\u7d20\u7684\u5de6\u5b50\u6811\u5df2\u7ecf\u5904\u7406\u5b8c\u6bd5\uff0c left_count \u4e3a j \u7684\u5de6\u5b50\u6811\u7684\u8282\u70b9\u6570\n     \"\"\"\n     def buildTree(self, preorder, inorder):\n         \"\"\"\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         \"\"\"\n         if (not preorder):\n             return None\n         stack = []\n         i, j = 0, 0\n         # \u5148\u5e8f\u5e8f\u5217\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u5373\u6811\u7684\u6839\u8282\u70b9\n         root = TreeNode(preorder[0])\n         # cur\u5728\u5165\u6808\u51fa\u6808\u4e4b\u95f4\u5145\u5f53\u4e86\u53d8\u91cf\u4f20\u9012\u5de5\u4f5c\uff0c\u76f8\u5f53\u4e8e\u9012\u5f52\u8c03\u7528\u7684\u8fd4\u56de\u503c\n         cur = root\n         stack.append(cur)\n         i += 1\n         # \u5faa\u73af\u7684\u672c\u6b65\u662f\u5426\u8fdb\u884c\u51fa\u6808\u64cd\u4f5c\n         out_stack = False\n         # \u8bfb\u53d6\u5148\u5e8f\u5e8f\u5217\uff0c preorder[-1] \u662f\u6700\u53f3\u8282\u70b9\uff0c\u5f53\u8fd9\u4e2a\u8282\u70b9\u6784\u9020\u5b8c\u6210\uff08 i == len(preorder) \uff09\uff0c\u6574\u9897\u6811\u5c31\u5b8c\u6210\u4e86\uff0c\u7ed3\u675f\u5faa\u73af\n         while (i < len(preorder)):\n             if (stack and stack[-1].val == inorder[j]):\n                 # \u51fa\u6808\u64cd\u4f5c\uff0c\u76f8\u5f53\u4e8e\u4ece\u9012\u5f52\u8fd4\u56de\n                 # cur \u7684\u5de6\u5b50\u6811\u5df2\u7ecf\u5904\u7406\u5b8c\u6bd5\n                 # \u5982\u679ccur\u6709\u53f3\u5b50\u6811\uff0c\u90a3\u4e48\u4e0b\u4e00\u6b65\u5c06\u8fdb\u5165\u4e0b\u9762\u7684else\u7684if(out_stack)\u8bed\u53e5\u5757\n                 # \u5982\u679ccur\u6ca1\u6709\u53f3\u5b50\u6811\uff0c\u90a3\u4e48\u4e0b\u4e00\u6b65\u5c06\u7ee7\u7eed\u8fdb\u884c\u672c\u8bed\u53e5\u5757\u7684\u51fa\u6808\u64cd\u4f5c\n                 cur = stack.pop()\n                 out_stack = True\n                 j += 1\n             else:\n                 # \u5165\u6808\u64cd\u4f5c\uff0c\u76f8\u5f53\u4e8e\u8fdb\u5165\u9012\u5f52\n                 # cur \u7684\u5de6\u5b50\u6811\u672a\u5904\u7406\u5b8c\u6bd5\n                 if (out_stack):\n                     # \u4e0a\u4e00\u6b65\u6267\u884c\u4e86\u51fa\u6808\u64cd\u4f5c\uff0c\u8868\u660ecur\u7684\u5de6\u5b50\u6811\u5df2\u7ecf\u5904\u7406\u5b8c\u6bd5\uff0c\u9700\u8981\u5904\u7406\u5176\u53f3\u5b50\u6811\n                     # \u76f8\u5f53\u4e8e\u8fdb\u5165cur\u53f3\u5b50\u6811\u7684\u9012\u5f52\n                     # cur\u6709\u53f3\u5b50\u6811\uff0cpreorder[i]\u662fcur\u53f3\u5b50\u6811\u7684\u6839\u8282\u70b9\n                     cur.right = TreeNode(preorder[i])\n                     cur = cur.right\n                 else:\n                     # \u4e0a\u4e00\u6b65\u4e0d\u662f\u51fa\u6808\uff0c\u8868\u660ecur\u7684\u5de6\u5b50\u6811\u5c1a\u672a\u5904\u7406\n                     # \u76f8\u5f53\u4e8e\u8fdb\u5165cur\u5de6\u5b50\u6811\u7684\u9012\u5f52\n                     cur.left = TreeNode(preorder[i])\n                     cur = cur.left\n                 stack.append(cur)\n                 out_stack = False\n                 i += 1\n         return root\n                     \n                 ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     # def buildTree(self, preorder, inorder):\n     #     \"\"\"\n     #     :type preorder: List[int]\n     #     :type inorder: List[int]\n     #     :rtype: TreeNode\n     #     \"\"\"\n     #     if (not preorder):\n     #         return None\n     #     root_val = preorder[0]\n     #     root = TreeNode(root_val)\n     #     left_count = inorder.index(root_val)\n     #     root.left = self.buildTree(preorder[1:left_count + 1], inorder[:left_count])\n     #     root.right = self.buildTree(preorder[left_count + 1:], inorder[left_count + 1:])\n     #     return root\n         \n \n     \"\"\"\n     \u6808\n     \u8bfb\u53d6\u524d\u5e8f\u5e8f\u5217\uff0c\u5f53\u4e0d\u786e\u5b9a\u8282\u70b9\u7684\u5de6\u5b50\u6811\u662f\u5426\u5904\u7406\u5b8c\u6bd5\u65f6\u5c06\u8282\u70b9\u538b\u6808\n     \u4e0a\u8ff0\u64cd\u4f5c\u5c06\u4fdd\u6301\u6808\u5185\u5143\u7d20\u5173\u7cfb\uff1a\u4efb\u610f\u65f6\u523b\uff0c\u6808\u5185\u7684\u540e\u5165\u6808\u5143\u7d20\u4f4d\u4e8e\u5148\u5165\u6808\u5143\u7d20\u7684\u5de6\u5b50\u6811\u4e2d\n     \u5f53\u5143\u7d20\u7684\u5de6\u5b50\u6811\u5df2\u7ecf\u5168\u90e8\u5904\u7406\u5b8c\u65f6\u5c06\u5176\u51fa\u6808\uff0c\u6b64\u65f6\u5e94\u8be5\u7ee7\u7eed\u5904\u7406\u5b83\u7684\u53f3\u5b50\u6811\uff08\u5982\u679c\u5b58\u5728\u7684\u8bdd\uff09\n     \u5224\u5b9a\u5143\u7d20\u7684\u5de6\u5b50\u6811\u662f\u5426\u5df2\u7ecf\u5904\u7406\u5b8c\u6bd5\uff0c\u9700\u8981\u4e2d\u5e8f\u5e8f\u5217\uff0c\u5bf9\u4e8e\u4e2d\u5e8f\u5e8f\u5217\u4e2d\u7684\u4efb\u610f\u5143\u7d20 j \uff0c\u5176\u5de6\u5b50\u6811\u4f4d\u4e8e [0, j - 1] \u4e2d\n     \u56e0\u6b64\uff0c\u5f53\u6808\u9876\u5143\u7d20\u7b49\u4e8e\u4e2d\u5e8f\u5e8f\u5217\u7684\u5f53\u524d\u5143\u7d20 j \uff08\u4e2d\u5e8f\u7684 [0, j - 1] \u5df2\u7ecf\u5904\u7406\uff09\u65f6\uff0c\u8868\u660e\u6808\u9876\u5143\u7d20\u7684\u5de6\u5b50\u6811\u5df2\u7ecf\u5904\u7406\u5b8c\u6bd5\n     \"\"\"\n     def buildTree(self, preorder, inorder):\n         \"\"\"\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         \"\"\"\n         if (not preorder):\n             return None\n         stack = []\n         i, j = 0, 0\n         # \u524d\u5e8f\u5e8f\u5217\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u5373\u6811\u7684\u6839\u8282\u70b9\n         root = TreeNode(preorder[0])\n         cur = root\n         stack.append(cur)\n         i += 1\n         # \u5faa\u73af\u7684\u672c\u6b65\u662f\u5426\u8fdb\u884c\u51fa\u6808\u64cd\u4f5c\n         out_stack = False\n         # \u8bfb\u53d6\u524d\u5e8f\u5e8f\u5217\uff0c preorder[-1] \u662f\u6700\u53f3\u8282\u70b9\uff0c\u5f53\u8fd9\u4e2a\u8282\u70b9\u6784\u9020\u5b8c\u6210\uff08 i == len(preorder) \uff09\uff0c\u6574\u9897\u6811\u5c31\u5b8c\u6210\u4e86\uff0c\u7ed3\u675f\u5faa\u73af\n         while (i < len(preorder)):\n             if (stack and stack[-1].val == inorder[j]):\n                 # \u51fa\u6808\u64cd\u4f5c\uff0c\u76f8\u5f53\u4e8e\u4ece\u9012\u5f52\u8fd4\u56de\n                 # cur \u7684\u5de6\u5b50\u6811\u5df2\u7ecf\u5904\u7406\u5b8c\u6bd5\n                 # \u5982\u679ccur\u6709\u53f3\u5b50\u6811\uff0c\u90a3\u4e48\u4e0b\u4e00\u6b65\u5c06\u8fdb\u5165\u4e0b\u9762\u7684else\u7684if(out_stack)\u8bed\u53e5\u5757\n                 # \u5982\u679ccur\u6ca1\u6709\u53f3\u5b50\u6811\uff0c\u90a3\u4e48\u4e0b\u4e00\u6b65\u5c06\u7ee7\u7eed\u8fdb\u884c\u672c\u8bed\u53e5\u5757\u7684\u51fa\u6808\u64cd\u4f5c\n                 cur = stack.pop()\n                 out_stack = True\n                 j += 1\n             else:\n                 # \u5165\u6808\u64cd\u4f5c\uff0c\u76f8\u5f53\u4e8e\u8fdb\u5165\u9012\u5f52\n                 # stack[-1] \u7684\u5de6\u5b50\u6811\u672a\u5904\u7406\u5b8c\u6bd5\n                 if (out_stack):\n                     # \u4e0a\u4e00\u6b65\u6267\u884c\u4e86\u51fa\u6808\u64cd\u4f5c\uff0c\u8868\u660ecur\u7684\u5de6\u5b50\u6811\u5df2\u7ecf\u5904\u7406\u5b8c\u6bd5\uff0c\u9700\u8981\u5904\u7406\u5176\u53f3\u5b50\u6811\n                     # \u76f8\u5f53\u4e8e\u8fdb\u5165cur\u53f3\u5b50\u6811\u7684\u9012\u5f52\n                     # cur\u6709\u53f3\u5b50\u6811\uff0cpreorder[i]\u662fcur\u53f3\u5b50\u6811\u7684\u6839\u8282\u70b9\n                     cur.right = TreeNode(preorder[i])\n                     cur = cur.right\n                 else:\n                     # \u4e0a\u4e00\u6b65\u4e0d\u662f\u51fa\u6808\uff0c\u8868\u660ecur\u7684\u5de6\u5b50\u6811\u5c1a\u672a\u5904\u7406\n                     # \u76f8\u5f53\u4e8e\u8fdb\u5165cur\u5de6\u5b50\u6811\u7684\u9012\u5f52\n                     cur.left = TreeNode(preorder[i])\n                     cur = cur.left\n                 stack.append(cur)\n                 out_stack = False\n                 i += 1\n         return root\n                     \n                 ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def buildTree(self, preorder, inorder):\n         \"\"\"\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         \"\"\"\n         null = TreeNode(None)\n         max_idx = len(preorder)\n         lookups = {}\n         \n         def _build(parent, p, i):\n             print(parent.val, p, i) #REM\n             if p >= max_idx:\n                 return\n             \n             node = TreeNode(preorder[p])\n             parent.left = node\n             print('.. left', node.val) #REM\n             lookups[node.val] = node\n             \n             while p < max_idx and preorder[p] == inorder[i]:\n                 \n                 while i < max_idx and inorder[i] in lookups:\n                     node = lookups[inorder[i]]\n                     i += 1\n \n                 p += 1\n                 \n                 if p < max_idx:\n                     right = TreeNode(preorder[p])\n                     lookups[right.val] = right\n                     print('.. right of', node.val, ' -> ', right.val) #REM\n                     node.right = right\n                     node = right\n \n             _build(node, p + 1, i)\n         \n         _build(null, 0, 0)\n         \n         return null.left\n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def buildTree(self, preorder, inorder):\n         \"\"\"\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         \"\"\"\n         INDICES = {}\n         for idx, val in enumerate(inorder):\n             INDICES[val] = idx\n             \n         seen = {}\n         ptr = 0\n         def build(left, right):\n             nonlocal ptr\n             print(left, right)\n             if left > right or right < left or ptr >= len(preorder):\n                 return \n             val = preorder[ptr]\n             print(val, left, right)\n \n             node = TreeNode(preorder[ptr])\n             ptr += 1\n             node.left = build(left, INDICES[val]-1) #if (INDICES[val] != 0 and INDICES[val] != len(inorder) - 1) else None\n             node.right = build(INDICES[val]+1, right) #if (INDICES[val] != 0 and INDICES[val] != len(inorder) - 1) else None\n             \n             return node\n         \n         return build(0, len(inorder))\n             ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def buildTree(self, preorder, inorder):\n         \"\"\"\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         \"\"\"\n         preindex = [0]\n         ind = {v:i for i, v in enumerate(inorder)}\n         head = self.buildTreeCore(0, len(preorder) - 1, preorder, inorder, ind, preindex)\n         return head\n     \n     def buildTreeCore(self, start, end, preorder, inorder, ind,preindex):\n         if start <= end:\n             mid = ind[preorder[preindex[0]]]\n             preindex[0] =preindex[0]+1\n             root = TreeNode(inorder[mid])\n             root.left = self.buildTreeCore(start, mid - 1, preorder, inorder, ind, preindex)\n             root.right = self.buildTreeCore(mid + 1, end, preorder, inorder, ind, preindex)\n             return root", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def buildTree(self, preorder, inorder):\n         \"\"\"\n         :type preorder: List[int]\n         :type inorder: List[int]\n         :rtype: TreeNode\n         \"\"\"\n         if len(inorder) == 0:\n             return\n         HashMap = {}\n         for i in range(len(inorder)):\n             HashMap[inorder[i]] = i\n         \n         root = self.build(HashMap, inorder, 0, len(inorder)-1, preorder, 0, len(preorder)-1)\n         return root\n     \n     def build(self, HashMap, inorder, istart, iend, preorder, pstart, pend):\n         print(istart, iend, pstart, pend)\n         if istart>iend or pstart > pend:\n             return None\n \n         root = TreeNode(preorder[pstart])\n         print(root.val)\n         mid_index = HashMap[root.val]\n         left_size = mid_index - istart\n         right_size = iend - mid_index\n         root.left = self.build(HashMap, inorder, istart, mid_index-1, preorder, pstart+1, pstart+left_size)\n         root.right = self.build(HashMap, inorder, mid_index+1, iend, preorder, pend-right_size+1, pend)\n         return root"]
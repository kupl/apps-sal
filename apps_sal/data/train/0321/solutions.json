["from collections import Counter\nclass Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        d1, d2 = Counter(s1), Counter(s2)\n        return self.check(d1, d2) or self.check(d2, d1)\n        \n    def check(self, d1: dict, d2: dict) -> bool:\n        s = 0\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            s += d1[c] - d2[c]\n            if s < 0:\n                return False\n        return True", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        c1 = collections.Counter(s1)\n        c2 = collections.Counter(s2)\n        t1,t2 = 0,0\n        f1,f2 = 1,1\n        for i in range(26):\n            z = chr(97+i)\n            t1 += c1[z] - c2[z]\n            if t1 < 0:\n                f1 = 0\n            t2 += c2[z] - c1[z]\n            if t2 < 0:\n                f2 = 0\n        return f1 or f2", "class Solution:\n    def check(self, d1, d2):\n        s = 0\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            s += d1[c] - d2[c]\n            if s < 0:\n                return False\n        return True\n    \n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        d1 = collections.Counter(s1)\n        d2 = collections.Counter(s2)\n        return self.check(d1, d2) or  self.check(d2, d1)", "from collections import Counter\nclass Solution:\n    def checkIfCanBreak(self, s1, s2):\n        dic_1 = Counter(s1)\n        dic_2 = Counter(s2)\n        \n        return self.check(dic_1, dic_2) or self.check(dic_2, dic_1)\n    \n    def check(self, d1, d2):\n        res = 0\n        for i in 'abcdefghijklmnopqrstuvwxyz':\n            res += d2[i] - d1[i]\n            if res < 0 :\n                return False\n        return True\n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        from collections import Counter\n        def check_breakable(s1, s2):\n          s1_counter = Counter(s1)\n          s2_counter = Counter(s2)\n          cnt = 0\n          for char in 'abcdefghijklmnopqrstuvwxyz':\n            cnt += s1_counter[char] - s2_counter[char]\n            if cnt < 0:\n              return False\n          return True\n        return check_breakable(s1, s2) == True or check_breakable(s2,s1) == True", "class Solution:\n    def checkIfCanBreak(self, s1, s2):\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        return all(x <= y for x, y in zip(s1, s2)) or all(y <= x for x, y in zip(s1, s2))", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        t1,t2=sorted(list(s1)),sorted(list(s2))\n        for i in range(len(t1)):\n            if t1[i]<=t2[i]:\n                continue\n            else:\n                break\n        else:\n            return True\n        \n        for i in range(len(t1)):\n            if t1[i]>=t2[i]:\n                continue\n            else:\n                break\n        else:\n            return True\n        \n        \n        return False\n        \n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        \n        s1_bigger = False\n        s2_bigger = False\n        \n        for i in range(len(s1)):\n            if s1_bigger and s1[i] < s2[i]:\n                return False\n            if s2_bigger and s1[i] > s2[i]:\n                return False\n            if s1[i] < s2[i]:\n                s2_bigger = True\n            if s1[i] > s2[i]:\n                s1_bigger = True\n            \n        return True", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        c1 = Counter(s1)\n        c2 = Counter(s2)\n        s = set()\n        diff = 0\n        for i in range(26):\n            c = chr(ord('a') + i)\n            diff += c1[c] - c2[c]\n            if diff:\n                s.add(diff > 0)\n        return len(s) < 2", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = list(s1)\n        s2 = list(s2)\n        s1.sort()\n        s2.sort()\n        s1token = True\n        for i in range(len(s1)):\n            if s1[i] > s2[i]:\n                s1token = False\n                break\n        if s1token == True:\n            return True\n        s2token = True\n        for i in range(len(s2)):\n            if s2[i] > s1[i]:\n                s2token =False\n                break\n        if s2token == True:\n            return True\n        return False", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        left = True\n        determined = False\n        for i, c in enumerate(s1):\n            if c > s2[i]:\n                if not left and determined:\n                    return False\n                determined = True\n            elif c < s2[i]:\n                if left and determined:\n                    return False\n                left = False\n                determined = True\n        return True", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        \n        # rearange s1 in smallest possible ordering\n        # reaarange s2 in largest possible ordering\n        \n        # vice versa\n        \n        s1 = list(s1)\n        s2 = list(s2)\n        \n        s1.sort(reverse=True)\n        s2.sort(reverse=True)\n        \n        match =  all(x>=y for x, y in zip(s1, s2))\n        if match: return True\n        \n        s1.sort()\n        s2.sort()\n        match = all(y>=x for x, y in zip(s1, s2))\n        return match", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        arr1 = list(s1)\n        arr2 = list(s2)\n        arr1.sort()\n        arr2.sort()\n        # print(arr1)\n        c = 0\n        for i in range(len(arr1)):\n            if arr1[i]>arr2[i]:\n                break\n            c+=1\n        # print(c)\n        \n        if c == len(arr1):\n            # print(\\\"returning\\\")\n            return True\n\n        for i in range(len(arr1)):\n            if arr1[i]<arr2[i]:\n                return False\n            c+=1\n        # print(c)\n        \n        return True", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        l1 = [char for char in s1]\n        l1.sort()\n        l2 = [char for char in s2]\n        l2.sort()\n        strlen = len(s1)\n        flag = 0\n        for i in range(strlen):\n            if l1[i]>=l2[i]:\n                continue\n            else:\n                flag = 1\n                break\n        if flag:\n            for i in range(strlen):\n                if l1[i]<=l2[i]:\n                    continue\n                else:\n                    return False\n        return True\n#         freqs1 = [0]*26\n#         freqs2 = [0]*26\n#         stringlen = len(s1)\n#         for i in range(stringlen):\n#             freqs1[ord(s1[i])-97]+=1\n#             freqs2[ord(s2[i])-97]+=1\n#         for i in range(26):\n#             if freqs1[i]>=freqs2[i]:\n#                 break\n#         else:\n#             return True\n#         for i in range(26):\n#             if freqs2[i]>=freqs1[i]:\n#                 break\n#         else:\n#             return True \n#         return False\n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted([c for c in s1])\n        s2 = sorted([c for c in s2])\n        return all(char1 <= char2 for char1, char2 in zip(s1, s2)) or all(char1 >= char2 for char1, char2 in zip(s1, s2))", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        ss1 = sorted(s1)\n        ss2 = sorted(s2)\n        f = True\n        r = True\n        for x,y in zip(ss1,ss2):\n            f = f and (x >= y)\n            r = r and (x <= y)\n        return f or r\n        \n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        size_t = len(s1)\n        \n        for idx in range(size_t):\n            if s1[idx] == s2[idx]:\n                continue\n            elif s1[idx] < s2[idx]:\n                ans = set(map(lambda x,y:x<=y,s1,s2))\n                break\n            else:\n                ans = set(map(lambda x,y:x>=y,s1,s2))\n                break\n                \n        \n        if len(ans) > 1:\n            return False\n        return True", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1)\n        s2 = sorted(s2);\n        #comparisons = [a >= b for a,b in zip(s1, s2)]\n        indices = [i for i, (a,b) in enumerate(zip(s1,s2)) if a != b]\n        comparisons = [s1[i] > s2[i] for i in indices]\n        return all(comparisons) or (not any(comparisons))\n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        \n        arr1=list(s1)\n        arr2=list(s2)\n        arr1.sort()\n        arr2.sort()\n        n=len(arr1)\n        flag=True\n\n    \n        flag1=True\n        for i in range(n):\n            if arr1[i]<arr2[i]:\n                flag1=False\n                \n        flag2=True\n        for i in range(n):\n            if arr1[i]>arr2[i]:\n                flag2=False\n                \n    \n                \n        if flag1 or flag2:\n            return True\n\n                \n        return False\n                \n                \n                    \n                \n                \n            \n        \n        \n        \n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        count1 = 0\n        count2 = 0\n        for i in range(len(s1)):\n            if s1[i] <= s2[i]:\n                count1 += 1\n            if s1[i] >= s2[i]:\n                count2 += 1\n        if count1 == len(s1) or count2 == len(s1):\n            return True\n        return False", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        l1=list(s1)\n        l2=list(s2)\n        l1.sort()\n        l2.sort()\n        count=0\n        count1=0\n        for i in range(len(l1)):\n            if l1[i]>=l2[i]:\n                count+=1\n        if count==len(l1):\n            return True\n        for i in range(len(l2)):\n            if l2[i]>=l1[i]:\n                count1+=1\n        if count1==len(l1):\n            return True\n        return False\n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        def helper(d1,d2):\n            s=0\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                s+=d1[c]-d2[c]\n            \n                if s<0:\n                    return False\n            \n            return True\n            \n        c1=collections.Counter(s1)\n        c2=collections.Counter(s2)\n        return helper(c1,c2) or helper(c2,c1)", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1, reverse=True)\n        s2 = sorted(s2, reverse=True)\n\n        resultA = []\n        resultB = []\n        \n        for ch1, ch2 in zip(s1, s2):\n            if ch1 >= ch2:\n                resultA.append(1)\n            else:\n                resultA.append(0)\n                \n            if ch2 >= ch1:\n                resultB.append(1)\n            else:\n                resultB.append(0)\n        \n        if all(resultA) == 1 or all(resultB):\n            return True\n        else:\n            return False", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        n = len(s1)\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        s1_tally = 0\n        s2_tally = 0\n        for i in range(n):\n            if s1[i] >= s2[i]:\n                s1_tally += 1\n            if s2[i] >= s1[i]:\n                s2_tally += 1\n        return s1_tally == n or s2_tally == n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1Sorted = sorted(s1)\n        s2Sorted = sorted(s2)\n        \n        return all(char1 >= char2 for char1, char2 in zip(s1Sorted, s2Sorted)) or all(char1 <= char2 for char1, char2 in zip(s1Sorted, s2Sorted))", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        return all(ch1<=ch2 for ch1, ch2 in zip(sorted(s1), sorted(s2))) or all(ch1<=ch2 for ch1, ch2 in zip(sorted(s2), sorted(s1)))", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        perm1 = sorted(list(s1))\n        perm2 = sorted(list(s2))\n        zipped = zip(perm1,perm2)\n        \n        forward = True\n        backward = True\n        \n        for x, y in zipped:\n            if ord(x) > ord(y):\n                forward = False\n                \n            if ord(y) > ord(x):\n                backward = False\n                \n            \n        return forward or backward", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        count1 = 0\n        count2 = 0\n        for i in range(len(s1)):\n            count1 += 1*(s1[i] >= s2[i])\n            count2 += 1*(s1[i] <= s2[i])\n        return count1 == len(s1) or count2 == len(s1)", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1_arr = [ord(x) for x in s1]\n        s2_arr = [ord(x) for x in s2]\n        s1_arr.sort()\n        s2_arr.sort()\n        s1_counter = 0\n        s2_counter = 0\n        for i in range(len(s1_arr)):\n            if s1_arr[i] > s2_arr[i]:\n                s1_counter += 1\n            elif s1_arr[i] == s2_arr[i]:\n                s1_counter += 1\n                s2_counter += 1\n            else:\n                s2_counter += 1\n        print((s1_counter , s2_counter))        \n        if s1_counter == len(s1) or   s2_counter == len(s1):\n            return True\n        else:\n            return False\n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(list(s1))\n        s2 = sorted(list(s2))\n        i = 0 \n        while s1[i] <= s2[i]:\n            if i == len(s1) - 1: \n                return True\n            i += 1\n        i = 0\n        while s2[i] <= s1[i]:\n            if i == len(s1) - 1: \n                return True\n            i += 1\n        return False ", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        \n        x = 'abcdefghijklmnopqrstuvwxyz'\n        d = defaultdict(int)\n        for i in range(len(x)):\n            d[x[i]] = i+1\n            \n        a1 = []\n        a2 = []\n        \n        for i in range(len(s1)):\n            a1.append(d[s1[i]])\n            a2.append(d[s2[i]])\n            \n        a1.sort()\n        a2.sort()\n        \n        c1,c2 = 0,0\n        \n        for i in range(len(a1)):\n            if a1[i]>a2[i]:\n                c1+=1\n            elif a2[i]>a1[i]:\n                c2+=1\n            else:\n                c1+=1\n                c2+=1\n                \n        if c1==len(s1) or c2==len(s1):\n            return True\n        return False\n            \n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted([ord(s) for s in s1])\n        s2 = sorted([ord(s) for s in s2])\n        i = 0 \n        while s1[i] <= s2[i]:\n            if i == len(s1) - 1: \n                return True\n            i += 1\n        i = 0\n        while s2[i] <= s1[i]:\n            if i == len(s1) - 1: \n                return True\n            i += 1\n        return False ", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1sorted = ''.join(sorted(s1))\n        s2sorted = ''.join(sorted(s2))\n        res1 = True\n        res2 = True\n        for i in range(len(s1)):\n            if ord(s1sorted[i]) > ord(s2sorted[i]):\n                res1 = False\n        for i in range(len(s1)):\n            if ord(s1sorted[i]) < ord(s2sorted[i]):\n                res2 = False\n        return res1 or res2", "class Solution:\n    def check(self, d1, d2):\n        for x,y in zip(d1,d2):\n            if x<=y:\n                continue\n            return False\n        return True\n    \n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        d1=sorted(s1)\n        d2=sorted(s2)\n        return self.check(d1, d2) | self.check(d2, d1)", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        \n        ans1 = True\n        ans2 = True\n        for i in range(len(s1)):\n            if s1[i] < s2[i]: ans1 = False\n            if s2[i] < s1[i]: ans2 = False\n        \n        return ans1 or ans2\n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        comparisons = [a >= b for a,b in zip(sorted(s1), sorted(s2))]\n        all_true = all(comparisons)\n        if not all_true:\n            comparisons = [a <= b for a,b in zip(sorted(s1), sorted(s2))]\n            all_true = all(comparisons)\n        return all_true", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1list = list(s1)\n        s2list = list(s2)\n        s1list.sort()\n        s2list.sort()\n        count1 = 0\n        count2 = 0\n        for i in range(len(s1)):\n            count1 += int(s1list[i] >= s2list[i])\n        for i in range(len(s1)):\n            count2 += int(s2list[i] >= s1list[i])\n        return (not count1%len(s1) or not count2%len(s1))\n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        def helper(d1, d2):\n            s=0\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                s+=d1[c]-d2[c]\n                \n                if s<0:\n                    return False\n            return True\n        \n        c1=collections.Counter(s1)\n        c2=collections.Counter(s2)\n        return helper(c1,c2) or helper(c2,c1)", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        ar1 = [0 for i in range(len(s1))]\n        ar2 = [0 for i in range(len(s2))]\n        for i in range(len(s1)):\n            ar1[i] = ord(s1[i])\n            ar2[i] = ord(s2[i])\n            \n        ar1.sort()\n        ar2.sort()\n        flag1 = False\n        flag2 = False\n        for i in range(len(ar1)):\n            if(ar1[i]-ar2[i]<0):\n                flag1 = True\n            elif(ar2[i]-ar1[i]<0):\n                flag2 = True\n                \n        \n        return flag1 == False or flag2 == False", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        \n        s1 = sorted(s1)\n        s2 = sorted(s2)\n\n        count1 = 0\n        count2 = 0\n        for i in range(0 , len(s1)):\n            \n            if s2[i] >= s1[i]:\n                count1 +=1 \n                \n            if s1[i] >= s2[i]:\n                count2 += 1\n            \n        \n        if count1== len(s1) or count2 == len(s1):\n            return True\n\n        return False", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        ans1 = [a <= b for a, b in zip(sorted(s1), sorted(s2))]\n        ans2 = [a >= b for a, b in zip(sorted(s1), sorted(s2))]\n        # print(ans1, ans2)\n        # if len(ans) == 1:\n        #     return True\n        # else:\n        #     return False\n        if len(set(ans1)) == 1 or len(set(ans2)) == 1:\n            return True\n        return False", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1=sorted(s1)\n        s2=sorted(s2)\n        \n        def check(s1,s2):\n            c=0\n            n=len(s1)\n            for i in range(n):\n                if s1[i]>=s2[i]:\n                    c=c+1\n            return c==n\n            \n        return  check(s2,s1)  or check(s1,s2)    \n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        return all([a <= b for a, b in zip(sorted(s1), sorted(s2))]) or all([b <= a for a, b in zip(sorted(s1), sorted(s2))])", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        \n        ge = 0\n        le = 0\n        for i in range(len(s1)):\n            if s1[i] >= s2[i]:\n                ge += 1\n            if s1[i] <= s2[i]:\n                le += 1\n\n        return ge == len(s1) or le == len(s1)\n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = sorted(s1)\n        s2 = sorted(s2)\n        \n        a1 = [s1[i] >= s2[i] for i in range(len(s1))]\n        a2 = [s1[i] <= s2[i] for i in range(len(s1))]\n        \n        return False not in a1 or False not in a2", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        def ifbreaks(a, b):            \n            a=sorted(a)\n            b=sorted(b)\n            for i in range(len(a)):\n                if(a[i]<b[i]):\n                    return False\n            return True\n        return ifbreaks(s1, s2) or ifbreaks(s2, s1) \n                \n", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        l1 = sorted(list(s1))\n        l2 = sorted(list(s2))\n        case1 = True\n        case2 = True\n        for i in range(len(l1)):\n            if l1[i] > l2[i]:\n                case1 = False\n        for i in range(len(l1)):\n            if l2[i] > l1[i]:\n                case2 = False\n        return case1 or case2", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        l1 = list()\n        l2 = list()\n        n=len(s1)\n        #Make s1 into l1\n        for i in range(0, n):\n            l1.append(s1[i:i+1])\n        l1.sort()\n        #Make s2 into l2\n        for i in range(0, n):\n            l2.append(s2[i:i+1])\n        l2.sort()\n        #See if s1 can break s2 \n        indicator = False \n        l1_test = list()\n        for i in range(0,n):\n            if l1[i]>=l2[i]:\n                l1_test.append(1)\n        if len(l1_test)==len(l1):\n            indicator=True\n        #See if s2 can break s1\n        l2_test = list()\n        for i in range(0,n):\n            if l2[i]>=l1[i]:\n                l2_test.append(1)\n        if len(l2_test)==len(l2):\n            indicator=True\n        return indicator ", "class Solution:\n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        s1 = ''.join(sorted(s1))\n        s2 = ''.join(sorted(s2))\n        \n        cnt1 = 0\n        cnt2 = 0\n        \n        for i in range(len(s1)):\n            if s1[i] >= s2[i]:\n                cnt1 += 1\n            \n            if s2[i] >= s1[i]:\n                cnt2 += 1\n                \n        print((cnt1, cnt2))\n        return cnt1 == len(s1) or cnt2 == len(s2)\n", "class Solution:\n    def check(self, d1, d2):\n        s = 0\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            s += d1[c] - d2[c]\n            print(s, d1, d2)\n            if s < 0:\n                return False\n        return True\n    \n    def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        d1 = collections.Counter(s1)\n        d2 = collections.Counter(s2)\n        return self.check(d1, d2) or self.check(d2, d1)"]
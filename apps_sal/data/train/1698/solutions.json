["from collections import deque\n\ndef dbl_linear(n):\n    h = 1; cnt = 0; q2, q3 = deque([]), deque([])\n    while True:\n        if (cnt >= n):\n            return h\n        q2.append(2 * h + 1)\n        q3.append(3 * h + 1)\n        h = min(q2[0], q3[0])\n        if h == q2[0]: h = q2.popleft()\n        if h == q3[0]: h = q3.popleft()\n        cnt += 1\n\n", "from collections import deque\n\ndef dbl_linear(n):\n    u, q2, q3 = 1, deque([]), deque([])\n    for _ in range(n):\n        q2.append(2 * u + 1)\n        q3.append(3 * u + 1)\n        u = min(q2[0], q3[0])\n        if u == q2[0]: q2.popleft()\n        if u == q3[0]: q3.popleft()\n    return u", "def dbl_linear(n):\n  num_list = [1]\n  for i in num_list:\n    num_list.append((i * 2) + 1)\n    num_list.append((i * 3) + 1)\n    if len(num_list) > n *10:\n      break\n  return sorted(list(set(num_list)))[n]", "def dbl_linear(n):\n    u = [1]\n    i = 0\n    j = 0\n    while len(u) <= n:\n        x = 2 * u[i] + 1\n        y = 3 * u[j] + 1\n        if x <= y:\n            i += 1\n        if x >= y:\n            j += 1\n        u.append(min(x,y))\n    return u[n]", "# This is a Python implementation of the excellent algorithm user g964 wrote in C. Credit goes to him/her.\n\ndef dbl_linear(n):\n    arr = [1]\n    xi = yi = 0\n    \n    for i in range(n):\n        x,y = arr[xi]*2+1, arr[yi]*3+1 \n        arr.append( min(x,y) )\n        if min(x,y) == x:\n            xi += 1\n        if min(x,y) == y:\n            yi += 1\n    return arr[n]", "def dbl_linear(n):\n    u, i, c = {1}, 0, 1\n    while i < n:\n        if c / 2 in u or c / 3 in u:\n            u.add(c + 1)\n            i += 1\n        c += 1\n    else:\n        return c", "def dbl_linear(n):\n    \"\"\"Brute force first loop populates the set of u.  The second loop \n    fills any gaps\"\"\"\n    r = {1}\n            \n    while len(r) <= n:\n        q = sorted(list(r))\n        r.update([e * 2 + 1 for e in q] + [e * 3 + 1 for e in q])\n\n    for _ in range(3):\n        q = sorted(list(r))[:n]\n        r.update([e * 2 + 1 for e in q] + [e * 3 + 1 for e in q])\n        \n    return sorted(list(r))[n]", "from bisect import insort\n\ndef dbl_linear(n):\n    u = [1]\n    u0 = 123\n    for i in range(n):\n        while u[0] == u0:\n            u.pop(0)\n        u0 = u.pop(0)\n        insort(u, 2*u0+1)\n        insort(u, 3*u0+1)\n    return u[0]", "def dbl_linear(n):\n    x = 1\n    ys = []\n    zs = []\n\n    for i in range(n):\n        ys.append(2*x + 1)\n        zs.append(3*x + 1)\n        miny = ys[0]\n        minz = zs[0]\n        x = miny if miny < minz else minz\n        if x == miny: ys.pop(0)\n        if x == minz: zs.pop(0)\n\n    return x\n", "def dbl_linear(n):\n    u = [1]\n    indexY = 0\n    indexZ = 0\n    y = lambda x: 2*x + 1\n    z = lambda x: 3*x + 1\n    while len(u) <= n:\n        if y(u[indexY]) < z(u[indexZ]): \n            if y(u[indexY]) != u[len(u) - 1]: u.append(y(u[indexY]))\n            indexY += 1\n        else:\n            if z(u[indexZ]) != u[len(u) - 1]: u.append(z(u[indexZ]))\n            indexZ += 1\n    return u[n]"]
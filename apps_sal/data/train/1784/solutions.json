["class CurryPartial:\n    def __init__(self, func, *args):\n        self.func = func\n        self.args = args\n    \n    def __call__(self, *args):\n        return CurryPartial(self.func, *(self.args + args))\n    \n    def __eq__(self, other):\n        try:\n            return self.func(*self.args) == other\n        except TypeError:\n            return CurryPartial(self.func, *self.args[:-1]) == other\n\ndef curry_partial(f,*initial_args):\n  \"Curries and partially applies the initial arguments to the function\"\n  return CurryPartial(f, *initial_args)", "def curry_partial(f, *args):\n    if not callable(f): return f # ignore extra args\n    try: return f(*args) # handle nested currying\n    except: pass\n    try: return f() # ignore extra args if we are done\n    except: pass\n    if args: return curry_partial(lambda *a: f(args[0], *a), *args[1:]) # curry\n    else: return lambda *a: curry_partial(f, *a) # leave to caller\n", "import inspect\ndef curry_partial(f,*args):\n    if not callable(f) : return f\n    req = list(inspect.signature(f).parameters)\n    return f(*args) if req and req[0]=='_e' else f(*args[:len(req)]) if len(req) <= len(args) else \\\n           lambda *_e:curry_partial(f, *args + _e)", "def curry_partial(f,*initial_args):\n  if not callable(f):\n      return f\n  exp_n_args = f.__code__.co_argcount\n  given_n_args = len(initial_args)\n  if exp_n_args - given_n_args > 0:\n      # a lambda function that has a variable list of parameters\n      # when called, it adds these parameters to the already given parameters\n      # and curries the function with the combined parameters\n      # In case the number of parameters is enough after that, the function will be called\n      # if not, it is curried again recursively\n      return lambda *args: curry_partial(f, *(initial_args + args))\n  if exp_n_args == 0:\n      # f is the lambda returned by curry_partial and has a variable argument list\n      return f(*initial_args)\n  else:\n      # f is a function with a fixed number of arguments, so give it exactly how much it wants\n      return f(*initial_args[:exp_n_args])", "def curry_partial(f,*args):\n    if not callable(f):\n        return f\n    if len(args) < f.__code__.co_argcount:\n        return lambda *a: curry_partial(f, *(args + a))\n    return f(*args[:f.__code__.co_argcount or None])", "def curry_partial(fn, *x):\n    if not callable(fn): return fn        \n    size = fn.__code__.co_argcount or None\n    return fn(*x[:size]) if size <= len(x) else lambda *y: curry_partial(fn, *(x+y))", "def curry_partial(f,*initial_args):\n    def f1(*args):\n        def f2(*args2):\n\n            if not callable(f):                             return f     #we are done already\n            elif f.__code__.co_argcount == 0:               return f(*(args+args2))# nested call\n            elif f.__code__.co_argcount > len(args+args2):  return f1(*(args+args2))#not enough args\n            else:                                           return f(*(args+args2)[0:f.__code__.co_argcount])#victory\n\n        return f2\n    return f1(*initial_args)()", "from inspect import getfullargspec\n\ndef curry_partial(f, *initial_args, arg_spec=None): # I don't think this is what I needed to do...\n    if not arg_spec:\n        if not callable(f):\n            return f\n        arg_spec = getfullargspec(f)\n    param_l = len(arg_spec.args)\n    if param_l < len(initial_args) + 1:\n        if arg_spec.varargs:\n            return f(*initial_args)\n        else:\n            return f(*initial_args[:param_l])\n    else:\n        def fun(*args):\n            return curry_partial(f, *(initial_args + args), arg_spec=arg_spec)\n        return fun"]
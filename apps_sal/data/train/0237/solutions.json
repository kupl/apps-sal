["class Solution:\n    def numSubarraysWithSum(self, pl, S):\n        ans = 0\n        \n        if(S == 0):\n            c = 0\n            for i in range(len(pl)):\n                if(pl[i] == 0):\n                    c+=1\n                else:\n                    c = 0\n                ans +=c\n            return ans;\n                \n                    \n                \n            \n            \n        \n        l = [-1]\n        \n        for i in range(len(pl)):\n            if(pl[i] == 1 ):\n                l.append(i)\n                \n        l.append(len(pl))\n        \n        ans = 0\n        \n        for i in range(1,len(l)-S):\n            \n            ans += (l[i]-l[i-1])*(l[i+S] - l[i+S-1])\n            \n        return ans\n            \n            \n            \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        size = len(A)\n        l, r, total, cnt = [0] * 4\n        if S == 0:\n            l = 1\n            for x in A:\n                if x == 0:\n                    cnt += l\n                    l += 1\n                else:\n                    l = 1\n            return cnt\n        while r < size and total < S:\n            total += A[r]\n            r += 1\n        if r == size and total < S:\n            return 0\n        while r < size:\n            cnt1, cnt2 = 1, 1\n            while l < r and A[l] == 0:\n                l += 1\n                cnt1 += 1\n            while r < size and  A[r] == 0:\n                r += 1\n                cnt2 += 1\n            cnt += cnt1 * cnt2\n            l += 1\n            r += 1\n        if A[-1] == 1:\n            cnt += 1\n            while l < size and A[l] == 0:\n                cnt += 1\n                l += 1\n        return cnt \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        P = [0]\n        \n        for x in A:\n            P.append(P[-1] + x)\n        \n        count = collections.Counter()\n        \n        \n        ans = 0\n        \n        for x in P:\n            ans += count[x]\n            count[x + S] += 1\n        \n        \n        return ans", "class Solution(object):\n    def numSubarraysWithSum(self, A, S):\n        P = [0]\n        for x in A: P.append(P[-1] + x)\n        count = collections.Counter()\n\n        ans = 0\n        for x in P:\n            ans += count[x]\n            count[x + S] += 1\n\n        return ans\n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        n = len(A)\n        suma = [0]*(n+1)\n        \n        for i in range(1,n+1):\n            suma[i] = suma[i-1]+A[i-1]\n        \n        left = 0\n        res =0\n        m = collections.defaultdict(lambda:0)\n        m[0]=1\n        for i in range(n):\n            if suma[i+1]-S in m:\n                res += m[suma[i+1]-S]\n                \n            m[suma[i+1]] += 1\n            \n        return res", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        def atMostK(A, S):\n            if S < 0:\n                return 0\n            i = res = 0\n\n            for j in range(len(A)):\n                S -= A[j]\n                while S < 0:\n                    S += A[i]\n                    i += 1\n                res += j - i + 1  #\u6240\u4ee5\u5c0f\u4e8e\u7684\u4e5f\u662f\u7b97\u4e86\u7684\n            return res\n        return atMostK(A, S) - atMostK(A, S - 1)\n    \n    \n# \u7531\u4e8e\u6570\u7ec4\u4ec5\u5305\u542b 0 \u548c 1\uff0c \u90a3\u4e48\u95ee\u9898\u53ef\u4ee5\u8f6c\u5316\u4e3a\u7ed9\u5b9a\u4e00\u4e2a0\uff0c1\u6570\u7ec4\uff0c\u4f60\u53ef\u4ee5\u9009\u62e9S\u4e2a1\u548c\u4efb\u610f\u4e2a0\uff0c\u4f60\u53ef\u4ee5\u6709\u591a\u5c11\u9009\u62e9\uff1f\n\n# \u800c\u4e0a\u8ff0\u95ee\u9898\u53ef\u4ee5\u8f6c\u5316\u4e3a\u7ed9\u5b9a\u4e00\u4e2a0\uff0c1\u6570\u7ec4\uff0c\u4f60\u53ef\u4ee5\u9009\u62e9\u6700\u591aS\u4e2a1\u548c\u4efb\u610f\u4e2a0\uff0c\u4f60\u7684\u9009\u62e9\u6570\u51cf\u53bb \u7ed9\u5b9a\u4e00\u4e2a0\uff0c1\u6570\u7ec4\uff0c\u4f60\u53ef\u4ee5\u9009\u62e9\u6700\u591aS - 1\u4e2a1\u548c\u4efb\u610f\u4e2a0\uff0c\u4f60\u7684\u9009\u62e9\u6570\u3002\n\n# \u6700\u591axxxx \u8fd9\u79cd\u53ef\u4ee5\u4f7f\u7528\u53ef\u53d8\u6ed1\u52a8\u7a97\u53e3\u6a21\u677f\u89e3\u51b3\u3002\n\n#\u8fd9\u9053\u9898\u548c\u524d\u7f00\u548c\u4e4b\u95f4\u7684\u5173\u7cfb\u662f\u4ec0\u4e48\u5462\uff1f\n\n\n#  At most (s) is the count of subarrays whose sum <= s, at most (s-1) is the count of subarrays whose sum <= s-1, if you subtract them, all you get is subarrays whose sum exactly == s.\uff08\u524d\u7f00\u548c\uff09\n\n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        def atMost(S):\n            if S < 0: return 0\n            res = i = 0\n            for j in range(len(A)):\n                S -= A[j]\n                while S < 0:\n                    S += A[i]\n                    i += 1\n                res += j - i + 1\n            return res\n        return atMost(S) - atMost(S - 1)\n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        \n        P = [0]\n        for x in A:\n            P.append(P[-1]+x)\n        count = collections.Counter()\n        \n        ans = 0\n        for x in P:\n            ans += count[x]\n            count[x+S] +=1\n        return ans", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        container = [0]\n        for num in A:\n            container.append(container[-1] + num)\n            \n        count = Counter()\n        \n        ans = 0\n        for num in container:\n            # if count at num empty, just adds 0\n            ans += count[num]\n            # puts num + S into count with a count of 1 or increments num + S by 1\n            count[num+S] += 1\n        \n        return ans\n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        def findZerosBefore(index, array):\n            zerosBefore = 0\n            index -= 1\n            while (index >= 0 and array[index] != 1):\n                zerosBefore += 1\n                index -= 1\n            return zerosBefore\n    \n        def findZerosAfter(index, array):\n            zerosAfter = 0\n            index += 1\n            while (index < len(array) and array[index] != 1):\n                zerosAfter += 1\n                index += 1\n            return zerosAfter\n        def zeroString(index, array):\n            zeros = 0\n            while (index < len(array) and array[index] != 1):\n                zeros += 1\n                index += 1\n            \n            return zeros\n            \n        def zeroCombs(n):\n            combs = 0\n            for i in range(n, 0, -1):\n                combs = combs + n - i + 1\n            return combs\n            \n        def firstZero(index, array):\n            if (index == 0):\n                return True\n            if (array[index - 1] == 1):\n                return True\n            else:\n                return False\n                    \n        total = 0\n        \n        if (S > 0):\n            # get indices of all ocurrences of 1 in 'A'\n            one_array = [i for i, one in enumerate(A) if one == 1]\n            print(one_array)\n            start_index = []\n            end_index = []\n\n            for n in range(len(one_array)):\n                if (n + S - 1 < len(one_array)):\n                    start_index.append(one_array[n])\n                    end_index.append(one_array[n + (S - 1)])\n            print(start_index)\n            print(end_index)\n            for i in range(len(start_index)):\n                Bef = findZerosBefore(start_index[i], A)\n                print(Bef)\n                Aft = findZerosAfter(end_index[i], A)\n                total = total + Bef + Aft + (Bef * Aft) + 1\n        \n        if (S == 0):\n            zero_array = [i for i, zero in enumerate(A) if zero == 0]\n            for n in range(len(zero_array)):\n                if (firstZero(zero_array[n], A)):\n                    sticky = zeroString(zero_array[n], A)\n                    total = int(total + (sticky**2 + sticky)/2)\n        \n        return total\n                \n                \n                \n            \n            \n            \n    \n            \n            \n            \n            \n            \n        \n        \n                \n                \n    \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        def findZerosBefore(index, array):\n            zerosBefore = 0\n            index -= 1\n            while (index >= 0 and array[index] != 1):\n                zerosBefore += 1\n                index -= 1\n            return zerosBefore\n    \n        def findZerosAfter(index, array):\n            zerosAfter = 0\n            index += 1\n            while (index < len(array) and array[index] != 1):\n                zerosAfter += 1\n                index += 1\n            return zerosAfter\n        def zeroString(index, array):\n            zeros = 0\n            while (index < len(array) and array[index] != 1):\n                zeros += 1\n                index += 1\n            \n            return zeros\n            \n        def zeroCombs(n):\n            combs = 0\n            for i in range(n, 0, -1):\n                combs = combs + n - i + 1\n            return combs\n            \n        def firstZero(index, array):\n            if (index == 0):\n                return True\n            if (array[index - 1] == 1):\n                return True\n            else:\n                return False\n                    \n        total = 0\n        \n        if (S > 0):\n            # get indices of all ocurrences of 1 in 'A'\n            one_array = [i for i, one in enumerate(A) if one == 1]\n            print(one_array)\n            start_index = []\n            end_index = []\n\n            for n in range(len(one_array)):\n                if (n + S - 1 < len(one_array)):\n                    start_index.append(one_array[n])\n                    end_index.append(one_array[n + (S - 1)])\n            print(start_index)\n            print(end_index)\n            for i in range(len(start_index)):\n                Bef = findZerosBefore(start_index[i], A)\n                print(Bef)\n                Aft = findZerosAfter(end_index[i], A)\n                total = total + Bef + Aft + (Bef * Aft) + 1\n        \n        if (S == 0):\n            zero_array = [i for i, zero in enumerate(A) if zero == 0]\n            for n in range(len(zero_array)):\n                if (firstZero(zero_array[n], A)):\n                    sticky = zeroString(zero_array[n], A)\n                    total = total + zeroCombs(sticky)\n        \n        return total\n                \n                \n                \n            \n            \n            \n    \n            \n            \n            \n            \n            \n        \n        \n                \n                \n    \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        i, s, res, count = 0, 0, 0, 1\n        \n        for j in range(len(A)): \n            s += A[j]\n            \n            while s > S:\n                s -= A[i]\n                i += 1\n                count = 1\n            while i < j and A[i] == 0:\n                i += 1\n                count += 1\n                \n            if s == S and i <= j:\n                res += count\n                \n        return res\n", "from collections import Counter\n\n'''\nlet P[i] = sum(A[:i])\nfor each j\n    count # of i's \n        where P[j] - P[i] = S where i < j\n'''\n\nclass Solution:\n    def numSubarraysWithSum(self, A, k):\n        count = Counter({0:1})\n        ans = psum = 0\n        \n        for v in A:\n            psum += v\n            ans += count[psum - k]\n            count[psum] += 1\n            \n        return ans", "class Solution:\n    \n    def f(self, A):\n        ret = 0\n        \n        cnt = 0\n        for a in A:\n            if not cnt:\n                if not a:\n                    cnt += 1\n            else:\n                if not a:\n                    cnt += 1\n                else:\n                    ret += (cnt*(cnt+1)) // 2\n                    cnt = 0\n\n        if cnt: ret += (cnt*(cnt+1)) // 2\n                    \n        return ret\n        pass\n\n    def numSubarraysWithSum(self, A: List[int], k: int) -> int:\n        ret = 0\n                \n        if not k: return self.f(A)\n        \n        mp = { 0 : 1 }\n        cnt = 0\n\n        for a in A:\n            cnt += a\n            \n            if cnt not in mp:\n                mp[cnt] = 0\n            mp[cnt] += 1\n            \n            if cnt - k in mp:\n                ret += mp[cnt - k]\n            \n        return ret", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        h = {0: 1}\n        count = summ = 0\n        \n        for i in range(0, len(A)):\n            summ += A[i]\n            if summ - S in h:\n                count += h[summ-S]\n            if summ not in h:\n                h[summ] = 0\n            h[summ]+=1\n        \n        return count", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        dp = []\n        oneIndices = [-1]\n        ans = 0\n        for i, num in enumerate(A):\n            if num == 1:\n                oneIndices.append(i)\n            if len(oneIndices) >= S + 1:\n                if S == 0:\n                    ans += (i - oneIndices[-S-1])\n                else:\n                    ans += (oneIndices[-S] - oneIndices[-S-1])\n        return ans", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        return self.at_most(A, S) - self.at_most(A, S-1)\n    \n    def at_most(self, A, S):\n        if S < 0:\n            return 0\n        \n        start = 0\n        res = 0\n        for end in range(len(A)):\n            S -= A[end]\n            while start < len(A) and S < 0:\n                S += A[start]\n                start += 1\n                \n            res += (end - start + 1)\n        # print(res)    \n        return res", "class Solution:\n    def numSubarraysWithSum(self, nums: List[int], target: int) -> int:\n        return self._at_most(nums, target) - self._at_most(nums, target - 1)\n    \n    def _at_most(self, nums, target):\n        cnt = 0\n        sums = 0\n        i = 0\n        for j in range(len(nums)):\n            sums += nums[j]\n            \n            while i <= j and sums > target:\n                sums -= nums[i]\n                i += 1\n            \n            if sums <= target:\n                cnt += j - i + 1\n            \n        return cnt", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        csum = [0]\n        for a in A:  csum.append(csum[-1]+a)\n        counter = collections.Counter()\n        ans = 0\n        print(csum)\n        for p in csum:\n            ans += counter[p-S]\n            #print('with',p,'found',counter[p-S],p-S)\n            counter[p]+=1\n        return ans", "import collections\nclass Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        cache=collections.Counter({0:1})\n        currentSum=0\n        count=0\n        for num in A:\n            currentSum+=num\n            count+=cache[currentSum-S]\n            cache[currentSum]+=1\n        return count", "class Solution:\n    def numSubarraysWithSum(self, A, S):\n        c = collections.Counter({0: 1})\n        psum = res = 0\n        for i in A:\n            psum += i\n            res += c[psum - S]\n            c[psum] += 1\n        return res", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        n = len(A)\n        prefix = [0 for _ in range(n+1)]\n        for i in range(n):\n            prefix[i+1] = prefix[i] + A[i]\n        \n        def at_most_k(k: int) -> int:\n            begin, end = 0, 1\n            cnt = 0\n            while end < n+1:\n                while begin < end and prefix[end] - prefix[begin] > k:\n                    begin += 1\n                cnt += end - begin\n                end += 1\n            return cnt\n\n        return at_most_k(S) - at_most_k(S-1)", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        def atMost(S):\n            if S < 0: return 0\n            res = i = 0\n            for j in range(len(A)):\n                S -= A[j]\n                while S < 0:\n                    S += A[i]\n                    i += 1\n                res += j - i + 1\n            return res\n        return atMost(S) - atMost(S - 1)        \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        return self.atMost(A, S) - self.atMost(A, S-1)\n        \n    def atMost(self, A, S):\n        res = 0\n        i = 0\n        pre_sum = 0\n        for j, val in enumerate(A):\n            pre_sum += val\n            while pre_sum > S and i <= j:\n                print(pre_sum, i)\n                pre_sum -= A[i]\n                i += 1\n            res += j-i+1\n        return res", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        if len(A)==0:\n            return 0\n        \n        def atmost(m):\n            if m<0:\n                return 0\n            \n            res=i=0\n            for j in range(len(A)):\n                m-=A[j]\n                while(m<0):\n                    m+=A[i]\n                    i+=1\n                res+=(j-i+1)\n            return res\n        \n        return atmost(S)-atmost(S-1)", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        def atMost(S):\n            ans,l,tmp = 0,0,0\n\n            for r in range(len(A)):\n                tmp = tmp + A[r]\n                while (tmp > S and l <= r): \n                    tmp = tmp- A[l]\n                    l = l + 1\n                ans += r - l + 1\n            return ans\n\n        return atMost(S) - atMost(S - 1)", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        # HashMap\n        # count = {0:1}\n        # presum = res = 0\n        # for num in A:\n        #     presum += num\n        #     if presum - S in count:\n        #         res += count[presum - S]\n        #     count[presum] = count.get(presum, 0) + 1\n        # return res\n        \n        # two pointers\n        # def atMost(k):\n        #     n = len(A)\n        #     left = presum = res = 0\n        #     for right in range(n):\n        #         presum += A[right]\n        #         while left <= right and presum > k:\n        #             presum -= A[left]\n        #             left += 1\n        #         res += right - left + 1\n        #     return res\n        # return atMost(S) - atMost(S - 1)\n        \n        left = res = cur_sum = count = 0\n        for right in range(len(A)):\n            cur_sum += A[right]\n            if A[right] == 1:\n                count = 0\n            while left <= right and cur_sum >= S:\n                if cur_sum == S:\n                    count += 1\n                cur_sum -= A[left]\n                left += 1\n            res += count\n        return res", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        '''\n        Subarray sum = k problem\n        '''\n        \n        cur = 0\n        res = 0\n        dp = collections.defaultdict(int)\n        dp[0] = 1\n        for i in range(len(A)):\n            cur+=A[i]\n            diff = cur-S\n            if diff in dp:\n                res+=dp[diff]\n            dp[cur]+=1\n        \n        return res\n", "class Solution:\n    def numSubarraysWithSum(self, A, S):\n        return self.numSubarraysAtMostSum(A, S) - self.numSubarraysAtMostSum(A, S - 1)\n    \n    def numSubarraysAtMostSum(self, A, S):\n        if S < 0:\n            return 0\n        if not A:\n            return 0\n        n = len(A)\n        right = 0\n        now_sum = 0\n        res = 0\n        for left in range(n):\n            while right <= n - 1 and (now_sum < S or A[right] == 0):\n                now_sum += A[right]\n                right += 1\n            res += right - left\n            now_sum -= A[left]\n        return res                             ", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        # n = len(A)\n        # l = 0\n        # sums = 0\n        # add = 1\n        # ans = 0\n        # for r in range(n):\n        #     sums += A[r]\n        #     while sums > S or A[l] == 0:\n        #         if sums > S:\n        #             add = 1\n        #         else:\n        #             add += 1\n        #         sums -= A[l]\n        #         l += 1\n        #     if sums == S:\n        #         ans += add\n        # return ans\n        \n        hashmap = {0:1}\n        preSum = 0\n        ans = 0\n        for i in range(len(A)):\n            preSum += A[i]\n            if preSum - S in hashmap:\n                ans += hashmap[preSum -S]\n            hashmap[preSum] = 1 if preSum not in hashmap else hashmap[preSum] + 1\n        return ans\n            \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        if not A or S < 0:\n            return 0\n        \n        map = Counter()\n        map[0] = 1\n        sum = 0\n        res = 0\n        for num in A:\n            sum += num\n            if sum - S in map:\n                res += map[sum-S]\n            map[sum] += 1\n        return res\n", "class Solution:\n    def numSubarraysWithSum(self, nums: List[int], k: int) -> int:\n        if not nums:    return 0\n\n        counter = collections.defaultdict(int)\n        counter[0] = 1\n        cumsum = 0\n        ans = 0\n        for i in range(len(nums)):\n            cumsum += nums[i]\n            if cumsum-k in counter:\n                ans += counter[cumsum-k]\n            counter[cumsum] += 1\n        return ans", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        size = len(A)\n        prefix = {0: 1}\n        cnt = 0\n        ans = 0\n        \n        for i, num in enumerate(A):\n            if num == 1: cnt += 1\n            if cnt - S in prefix:\n                ans += prefix[cnt-S]\n            prefix[cnt] = prefix.get(cnt, 0) + 1\n        \n        return ans", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        A = [0] + list(itertools.accumulate(A))\n        hm = Counter()\n        res = 0\n        for i in A:\n            res += hm[i]\n            hm[i+S] += 1\n        return res", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        count = {0:1}\n        prefix = 0\n        result = 0\n    \n        for a in A:\n            prefix = (prefix+a)\n            #print(prefix)\n            if prefix-S in count:\n                result += count[prefix-S]\n            if prefix in count:\n                count[prefix] += 1\n            else:\n                count[prefix] = 1\n        return result        \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        \n        if S==0 and sum(A)==0:\n            return len(A)*(len(A)+1)//2\n            \n            \n        def atmost(s):\n            \n            if s<0:\n                return 0\n            sumi=s\n            l=0\n            r=0\n            count=0\n            \n            \n            while r<len(A):\n                \n                sumi-=A[r]\n                \n                while sumi<0:\n                    sumi+=A[l]\n                    l+=1\n                \n                count+=(r-l+1)\n                r+=1\n            \n            return count\n        \n        \n        return atmost(S) - atmost(S-1)\n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        d = {0: 1}\n        ss = 0\n        for i in A:\n            ss += i\n            d[ss] = d.get(ss,0)+1\n        res = 0\n        print(d)\n        if S > 0:\n            for i in range(ss-S+1):\n                res += d[i]*d[i+S]\n        if S == 0:\n            for i in range(ss+1):\n                res += d[i]*(d[i]-1)//2\n        return res            \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        counter=collections.Counter({0:1})\n        s=0\n        c=0\n        for a in A:\n            s+=a\n            c+=counter[s-S]\n            counter[s]+=1\n        return c", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        P = [0]\n        for x in A: P.append(P[-1] + x)\n        count = collections.Counter()\n\n        ans = 0\n        for x in P:\n            ans += count[x]\n            count[x + S] += 1\n\n        return ans\n#        count=0\n#        ind = 0\n#        while ind < len(A):\n#            sum=A[ind]\n#            if sum == S:\n#                count += 1\n#            if A[ind] == 1:\n#                for y in A[ind+1:]:\n#                    sum += y\n#                    if sum == S:\n#                        count += 1\n#                    elif sum > S:\n#                        break\n#                ind += 1\n#            else:\n#                zc = 1\n#                zero = True\n#                for y in A[ind+1:]:\n#                    sum += y\n#                    if y == 0 and zero:\n#                        zc += 1\n#                    else:\n#                        zero = False\n#                    if sum == S:\n#                        count += zc\n#                    elif sum > S:\n#                        break\n#                ind += zc\n#        return count\n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        p = [0]\n        for i in A:\n            p.append(p[-1]+i)\n        cnt = collections.Counter()\n\n        res = 0\n        for i in p:\n            res += cnt[i]\n            cnt[i+S] += 1\n        return res\n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n                \n        d = defaultdict(int)\n        d[0] = 1\n        psum = res = 0\n        for a in A:\n            psum += a            \n            res += d[psum - S]\n            d[psum]+=1              \n        return res", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        \n        P = [0]\n        for x in A: P.append(P[-1] + x)\n        count = collections.Counter()\n\n        ans = 0\n        for x in P:\n            ans += count[x]\n            count[x + S] += 1\n\n        return ans\n            \n            \n\n            \n    \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        numToFreq = {}\n        numToFreq[0] = 1\n        now_sum = 0\n        ans = 0\n        for num in A:\n            now_sum += num\n            if now_sum == S:\n                ans += (numToFreq[0])\n            elif now_sum > S:\n                if now_sum - S in numToFreq:\n                    ans += (numToFreq[now_sum - S])\n            \n            if now_sum not in numToFreq:\n                numToFreq[now_sum] = 0\n            numToFreq[now_sum] += 1\n        return ans", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        n = len(A)\n        \n        def num_subar_at_most(lim):\n            subarr_ct = 0\n            r_sum = 0\n            li = 0\n            for ri in range(n):\n                r_sum += A[ri]\n                while li <= ri and r_sum > lim:\n                    r_sum -= A[li]\n                    li += 1\n                subarr_ct += ri - li + 1\n            return subarr_ct\n            \n        return num_subar_at_most(S) - num_subar_at_most(S - 1)", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        cumsum = 0\n        dic = {0:[-1]}\n        ans = 0\n        for i,num in enumerate(A):\n            cumsum += num\n            dic[cumsum] = dic.get(cumsum,[]) + [i]\n            ans += len(dic.get(cumsum-S,[]))\n            #print(ans,dic)\n        return ans - (0 if S else len(A))", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        ans=0\n        il,ih,sl,sh=0,0,0,0\n        for j,x in enumerate(A):\n            sl+=x\n            while il<j and sl>S:\n                sl-=A[il]\n                il+=1\n            \n            sh+=x\n            while ih<j and (sh>S or sh==S and not A[ih]):\n                sh-=A[ih]\n                ih+=1\n            \n            if sl==S:\n                ans+=ih-il+1\n        return ans", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        \n        count = 0\n        output = 0\n        left = 0\n        \n        for right in range(len(A)):\n            S -= A[right]\n            if A[right] == 1:\n                count = 0\n            while left <= right and S <= 0:\n                if S == 0:\n                    count += 1\n                S += A[left]\n                left += 1\n            output += count\n            \n        return output\n            \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        def helper(k):\n            if k < 0:\n                return 0\n            num = 0\n            i = 0\n            for j in range(len(A)):\n                k -= A[j]\n                \n                while k < 0:\n                    k += A[i]\n                    i += 1\n                num += j-i+1\n            return num\n        return helper(S)-helper(S-1)", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        c = collections.Counter({0: 1})\n        psum = res = 0\n        for i in A:\n            psum += i\n            res += c[psum - S]\n            c[psum] += 1\n        return res\n\n                \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        n = len(A)\n        \n        i, j, total, res = 0, 0, 0, 0\n        while j < n:\n            total += A[j]\n            while i < j and total > S:\n                total -= A[i]\n                i += 1\n            if total == S:\n                res += 1\n                # There could be multiple 0 between i & j.\n                k = i\n                while k < j and A[k] == 0:\n                    k += 1\n                    res += 1\n            j += 1\n        return res", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        i, s, res, count = 0, 0, 0, 1\n        \n        for j in range(len(A)): \n            s += A[j]\n            while i < j and (s > S or A[i] == 0):\n                if A[i]:\n                    s -= A[i]\n                    count = 1\n                else:\n                    count += 1 \n                i += 1          \n                \n            if s == S:\n                res += count\n                \n        return res\n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        result = 0\n        left, right, count = 0, 0, 0\n        for right in range(len(A)):\n            S -= A[right]\n            if A[right] == 1:\n                count = 0\n            while S <= 0 and left <= right:\n                if S == 0:\n                    count += 1\n                S += A[left]\n                left += 1\n            result += count\n        return result\n            \n                \n                    \n            \n            \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        \n        count = {0:1}\n        total = maxS = 0\n        \n        for num in A:\n            total += num\n            maxS += count.get(total-S,0)\n            count[total] = count.get(total,0)+1\n\n        return maxS\n            \n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        ctr = collections.Counter({0:1})\n        prefix = res = 0\n        for a in A:\n            prefix += a\n            res += ctr[prefix - S]\n            ctr[prefix] += 1\n        return res\n", "class Solution:\n    def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        c = collections.Counter({0: 1})\n        psum = res = 0\n        for i in A:\n            psum += i\n            res += c[psum - S]\n            c[psum] += 1\n        return res\n"]
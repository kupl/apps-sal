["class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        \n        \n        G = [[[], []] for i in range(n)]\n        for i, j in red_edges: G[i][0].append(j)\n        for i, j in blue_edges: G[i][1].append(j)\n        res = [[0, 0]] + [[n * 2, n * 2] for i in range(n - 1)]\n        bfs = [[0, 0], [0, 1]]\n        for i, c in bfs:\n            # print(i, c)\n            for j in G[i][c]:\n                if res[j][c] == n * 2:\n                    res[j][c] = res[i][1 - c] + 1\n                    bfs.append([j, 1 - c])\n            # print(bfs)\n        return [x if x < n * 2 else -1 for x in map(min, res)]", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        # adjacent graph, branching for red/blue\n        # 0 for red, 1 for blue\n        G = [ [[], []] for i in range(n)]  \n        for i, j in red_edges: G[i][0].append(j)\n        for i, j in blue_edges: G[i][1].append(j)\n        # Init res, we maintain both path-length for red & blue.\n        res = [[0,0]] + [[2*n, 2*n] for i in range(n-1)] \n        # bfs : [[node, red], [node, blue]]\n        bfs = [[0, 0], [0, 1]]  \n        # actual BFS\n        while len(bfs) > 0:\n            node, color = bfs.pop(0)\n            for j in G[node][color]:\n                if res[j][color] == 2 * n:\n                    res[j][color] = res[node][1 - color] + 1\n                    bfs.append([j, 1 - color])\n        \n        # Select the smaller length and put in result\n        return [x if x != n * 2 else -1 for x in map(min, res)]\n", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        \n        edgeList = {i:[] for i in range(n)}\n        \n        for u, v in red_edges:\n            edgeList[u].append([v, \\\"red\\\"])\n        \n        for u, v in blue_edges:\n            edgeList[u].append([v, \\\"blue\\\"])\n        \n        visited = set()\n        \n        queue = [[0, 0, \\\"\\\"]]\n        ans = [float('inf')]*n\n        ans[0] = 0\n        \n        while queue:\n            node, node_cost, prev_color = queue.pop(0)\n            for dest, color in edgeList[node]:\n                \n                if (prev_color == \\\"\\\" or color != prev_color) and (dest, color) not in visited:\n                    visited.add((dest, color))\n                    queue.append([dest, node_cost+1, color])\n                    ans[dest] = min(ans[dest], node_cost+1)\n            \n        for i in range(len(ans)):\n            if ans[i] == float('inf'):\n                ans[i] = -1\n        return ans\n            \n            ", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        queue = [(0, True, 0), (0, False, 0)]\n        result = [-1]*n\n        result[0] = 0\n        visited = set()\n        \n        while queue:\n            node, red, dist = queue.pop(0)\n            if (node, red) in visited:\n                continue\n            visited.add((node, red))\n            if red:\n                for edge in blue_edges:\n                    if edge[0] == node:\n                        if result[edge[1]] == -1:\n                            result[edge[1]] = dist + 1\n                        queue.append((edge[1], False, dist+1))\n            \n            else:\n                for edge in red_edges:\n                    if edge[0] == node:\n                        if result[edge[1]] == -1:\n                            result[edge[1]] = dist + 1\n                        queue.append((edge[1], True, dist+1))\n        \n        return result", "import queue\nclass Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        red = self.create_adj(red_edges, n)\n        blue = self.create_adj(blue_edges, n)\n        \n        dist_array = [-1 for _ in range(n)]\n        dist_array[0] = 0\n        \n        q = queue.Queue()\n        \n        self.bfs(red, blue, \\\"blue\\\", dist_array)\n        self.bfs(red, blue, \\\"red\\\", dist_array)\n        \n        return dist_array\n        \n    def bfs(self, red, blue, color, A):\n        \n        visited_red = set()\n        visited_blue = set()\n        \n        q = queue.Queue()\n        \n        if color == \\\"blue\\\":\n            visited_blue.add(0)\n        else:\n            visited_red.add(0)\n        q.put((0,0, color))\n        \n        while(q.qsize() != 0):\n            cur = q.get()\n            cur_node = cur[0]\n            cur_len = cur[1]\n            cur_color = cur[2]\n            \n            if cur_color == \\\"red\\\":\n                for node in red[cur_node]:\n                    if node not in visited_red:\n                        visited_red.add(node)\n                        q.put((node, cur_len + 1, \\\"blue\\\"))\n                        if A[node] >= 0:\n                            A[node] = min(A[node], cur_len + 1)\n                        else:\n                            A[node] = cur_len + 1\n                cur_color = \\\"blue\\\"\n            else:\n                for node in blue[cur_node]:\n                    if node not in visited_blue:\n                        visited_blue.add(node)\n                        q.put((node, cur_len + 1, \\\"red\\\"))\n                        if A[node] >= 0:\n                            A[node] = min(A[node], cur_len + 1)\n                        else:\n                            A[node] = cur_len + 1\n                cur_color = \\\"red\\\"\n                \n                \n    def create_adj(self, nodes, n):\n        adj = [[] for node in range(n)]\n        for i in range(len(nodes)):\n            adj[nodes[i][0]].append(nodes[i][1])\n        return adj", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        if n == 1:\n            return [0]\n        \n        self.RED = 1\n        self.BLUE = -1\n        self.result = [float(\\\"inf\\\")] * n\n        self.result[0] = 0\n        self.n = n\n        self.dp = [[None] * n for _ in range(n)]\n        self.visited = set()\n        \n        for e in red_edges:\n            if self.dp[e[0]][e[1]] == None:\n                self.dp[e[0]][e[1]] = list()\n            self.dp[e[0]][e[1]].append(self.RED)\n            \n        for e in blue_edges:\n            if self.dp[e[0]][e[1]] == None:\n                self.dp[e[0]][e[1]] = list()\n            self.dp[e[0]][e[1]].append(self.BLUE)\n        \n        \n        q = [[0, -1], [0, 1]]\n        num = 0\n        \n        while(len(q)):\n            size = len(q)\n            num += 1\n            \n            for _ in range(size):\n                cur = q.pop(0)\n                node = cur[0]\n                op_c = cur[1]\n                \n                for i in range(1, n):\n                    if self.dp[node][i] != None and op_c in self.dp[node][i]:\n                        if (str(i) + str(op_c)) not in self.visited:\n                            self.visited.add(str(i) + str(op_c))\n                            self.result[i] = min(self.result[i], num)\n                            q.append([i, op_c * -1])\n                \n        return [x if x != float(\\\"inf\\\") else -1 for x in self.result]\n                \n        \n    def prettyPrint(self, dp):\n        for row in dp:\n            print(row)\n            \n            ", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        # 4:43 10/2/20\n        out_ds = defaultdict(list)\n        for i, j in red_edges:\n            out_ds[i] += [('r', j)]\n        for i, j in blue_edges:\n            out_ds[i] += [('b', j)]\n        \n        # intialize queue, result list and visited list\n        q = deque([(None, 0, 0)])\n        res = [-1] * n\n        visited = []\n        while q:\n            qq = deque([])\n            \n            # visit all nodes in q\n            for last_color, e, dist in q:\n                visited += [(last_color, e)]\n                \n                # specify the distance if hasn't been specified\n                if res[e] == -1:\n                    res[e] = dist\n                \n                # traverse all child nodes\n                for color, child in out_ds[e]:\n                    \n                    # skip visited edges and edges with the same color as last edge\n                    if color == last_color or (color, child) in visited:\n                        continue\n                    \n                    # add child nodes to a new queue\n                    qq += [(color, child, dist + 1)]\n            q = qq\n            \n        return res\n        \n", "class Solution:\n    \n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        shortest = [-1] * n\n        shortest[0] = 0\n        \n        self.BFS(shortest, red_edges, blue_edges, True)\n        self.BFS(shortest, red_edges, blue_edges, False)\n        \n        return shortest\n        \n        \n    def BFS(self, shortest, red_edges, blue_edges, red):\n        path_len = 1\n        seen_r = {0}\n        seen_b = {0}\n        current = [0]\n        while current:\n            if red:\n                edges = red_edges\n                seen = seen_r\n                red = False\n            else:\n                edges = blue_edges\n                seen = seen_b\n                red = True\n            \n            new_layer = []\n            for node in current:\n                for edge in edges:\n                    if edge[0] == node:\n                        if edge[1] not in seen:\n                            new_node = edge[1]\n                    \n                            seen.add(new_node)\n                            new_layer.append(new_node)\n                            if shortest[new_node] == -1:\n                                shortest[new_node] = path_len\n                            else:\n                                shortest[new_node] = min(shortest[new_node], path_len)\n                    \n                            \n            current = new_layer\n            path_len += 1\n\n\n        \n", "import numpy as np\nclass Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        # construct the graph, 1 means red edge, 2 means blue edge\n        graph = collections.defaultdict(set)\n        for src, des in red_edges:\n            graph[src].add((des, 1))\n        \n        for src, des in blue_edges:\n            graph[src].add((des, 2))\n        seen = set()\n        \n        res = [-1] * n\n        \n        # initiate the q for bfs with node (cur Node, distanceTo0, from which color) \n        q = [(0, 0, 1), (0, 0, 2)]\n        \n        while q:\n            nextq = []\n            for cur, dist, color in q:\n                # shortest distance we get so far \n                if res[cur] == -1:\n                    res[cur] = dist\n                for neighbor, nextColor in graph[cur]:\n                    # visit the node with a different color and record the edges we have visited so far\n                    if nextColor != color and (cur, neighbor, nextColor) not in seen:\n                        nextq.append((neighbor, dist + 1, nextColor))\n                        seen.add((cur, neighbor, nextColor))\n            q = nextq\n        \n        return res\n", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        radj = [set() for i in range(n)]\n        badj = [set() for i in range(n)]\n        \n        for x,y in red_edges :\n            radj[x].add(y)\n        for x,y in blue_edges :\n            badj[x].add(y)\n            \n        def bfs(target) :\n            rv = set()\n            bv = set()\n            from collections import deque\n            que = deque([(0,-1, 0)])\n            while len(que) > 0 :\n                n, c, r = que.popleft()\n                if c == -1 :\n                    if target in radj[n] or target in badj[n] :\n                        return r+1\n                    for i in radj[n]:\n                        que.append((i,0,r+1))\n                        rv.add(i)\n                    for i in badj[n]:\n                        que.append((i,1,r+1))\n                        bv.add(i)\n                if c == 0 :\n                    if target in badj[n] :\n                        return r+1\n                    for i in badj[n] :\n                        if i not in bv :\n                            bv.add(i)\n                            que.append((i,1,r+1))\n                if c == 1 :\n                    if target in radj[n] :\n                        return r+1\n                    for i in radj[n] :\n                        if i not in rv :\n                            rv.add(i)\n                            que.append((i,0,r+1))\n            return -1\n        res = [0]*n\n        for x in range(1,n) :\n            res[x] = bfs(x)\n        return res\n", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        red = collections.defaultdict(lambda:set())\n        for a,b in red_edges:\n            red[a].add(b)\n            \n        blue = collections.defaultdict(lambda:set())\n        for a,b in blue_edges:\n            blue[a].add(b)\n        \n        # perform BFS\n        seen = set()\n        res = [float('inf') for _ in range(n)]\n        lvl = 0\n        q = collections.deque([[0,0],[0,1]]) # [node, color], 0 for red, 1 for blue\n        while q:\n            for _ in range(len(q)):\n                n, c = q.popleft()\n                seen.add((n,c))\n                res[n] = min(lvl, res[n])\n                if c:\n                    for ch in red[n]:\n                        if (ch,0) not in seen:\n                            q.append([ch,0])\n                else:\n                    for ch in blue[n]:\n                        if (ch,1) not in seen:\n                            q.append([ch,1])\n            lvl += 1\n        \n        # change all inf to -1\n        for i,n in enumerate(res):\n            if n == float('inf'):\n                res[i] = -1\n                \n        return res", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        # adjacent graph, branching for red/blue\n        # 0 for red, 1 for blue\n        G = [ [[], []] for i in range(n)]  \n        for i, j in red_edges: G[i][0].append(j)\n        for i, j in blue_edges: G[i][1].append(j)\n        # Init res, we maintain both path-length for red & blue.\n        res = [[0,0]] + [[2*n, 2*n] for i in range(n-1)] \n        # bfs : [[node, red], [node, blue]]\n        bfs = [[0, 0], [0, 1]]  \n        # actual BFS\n        while len(bfs) > 0:\n            node, color = bfs.pop(0)\n            for j in G[node][color]:\n                if res[j][color] == 2 * n:\n                    res[j][color] = res[node][1 - color] + 1\n                    bfs.append([j, 1 - color])\n        \n        result = []\n        for length in res:\n            smaller = min(length)\n            if smaller < 2 * n:\n                result.append(smaller)\n            else:\n                result.append(-1)\n        \n        return result\n", "from collections import defaultdict, deque\nclass Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        # we can create a directed graph with 1 as red and 0 as blue\n        graph = defaultdict(list)\n        for to, frm in red_edges:\n            graph[to] += [[frm,1]]\n        for to, frm in blue_edges:\n            graph[to] += [[frm,0]]\n        \n        # bfs to find shortest path to each node\n        paths = [-1]*n\n        visited = set()\n        queue = deque()\n        queue.append((0, None, 0))\n        \n        while queue:\n            curr, color, path = queue.popleft()\n            if paths[curr] == -1:\n                paths[curr] = path\n            \n            for v, c in graph[curr]:\n                # if we havent visited a specific weighted edge and color is alternating allow it\n                if (v, c) not in visited and (color==None or c != color):\n                    queue.append((v, c, path+1))\n                    visited.add((v, c))\n        return paths\n", "class Solution:\n    \n    def bfsHelper(self, adj_matrix, n):\n        res=[1e10 for i in range(n)]\n        queue=[]\n        queue.append([0,0,0]) # append [node,color traversed last,dist from 0]\n        visited=set() #each elem is (node, last traversed color)\n        visited.add((0,0))\n        while queue:\n            curr,color,dist=queue.pop(0)\n            res[curr]=min(res[curr], dist)\n            \n            for neighbor in range(n):\n                edge=adj_matrix[curr][neighbor]\n                if edge==0: #if there is no edge \n                    continue\n                if color==0:#if we did not traverse to this node, can use any color\n                    if edge in [1,2]:\n                        if (neighbor,edge) not in visited:\n                            visited.add((neighbor,edge))\n                            queue.append([neighbor, edge, dist+1])\n                    if edge==3:\n                        if (neighbor,1) not in visited and color!=1:\n                            visited.add((neighbor, 1))\n                            queue.append([neighbor,1,dist+1])\n                        if (neighbor,2) not in visited and color!=2:\n                            visited.add((neighbor, 2))\n                            queue.append([neighbor,2,dist+1])\n                elif color in [1,2]:                       \n                    if edge in [1,2]:\n                        if (color != edge):\n                            if (neighbor,edge) not in visited:\n                                visited.add((neighbor, edge))\n                                queue.append([neighbor,edge,dist+1])\n                    if edge==3: #curr has red and blue edges\n                        if (neighbor,1) not in visited and color!=1:\n                            visited.add((neighbor, 1))\n                            queue.append([neighbor,1,dist+1])\n                        if (neighbor,2) not in visited and color!=2:\n                            visited.add((neighbor, 2))\n                            queue.append([neighbor,2,dist+1])\n                            \n                            \n        for i in range(len(res)):\n            if res[i]==1e10:\n                res[i]=-1\n            \n        return res\n                \n                    \n                     \n    def shortestAlternatingPaths(self, n, red_edges, blue_edges):\n        # 0, no edge\n        # 1, red edge\n        # 2, blue edge\n        # 3, both edges\n        adj_matrix=[[0 for i in range(n)] for j in range(n)]\n        for x,y in red_edges:\n            adj_matrix[x][y]+=1\n        for x,y in blue_edges:\n            adj_matrix[x][y]+=2\n \n        return self.bfsHelper(adj_matrix, n)\n", "from collections import defaultdict\nclass Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        red = defaultdict(list)\n        blue = defaultdict(list)\n        for x,y in red_edges:\n            red[x].append(y)\n        for x,y in blue_edges:\n            blue[x].append(y)\n        ans = []\n        for i in range(n):\n            #blue\n            visited = set()\n            queue = [(0,0, 0), (1,0,0)]\n            level = -1\n            visited.add((0,0))\n            visited.add((1,0))\n            while(queue):\n                color, node, lvl = queue.pop(0)\n                if(node == i):\n                    level = lvl\n                    break\n                #previous is blue\n                if(color == 0):\n                    for neigh in red[node]:\n                        if((1,neigh) not in visited):\n                            queue.append((1,neigh, lvl+1))\n                            visited.add((1,neigh))\n                #previous is red\n                elif(color == 1):\n                    for neigh in blue[node]:\n                        if((0,neigh) not in visited):\n                            queue.append((0, neigh, lvl+1))\n                            visited.add((0,neigh))\n            if(level == -1):\n                ans.append(-1)\n            else:\n                ans.append(level)\n            '''             \n            visited = set()\n            queue = [(1,0, 0)]\n            red_level = -1\n            while(queue):\n                color, node, lvl = queue.pop(0)\n                if(node == i):\n                    red_level = lvl\n                    break\n                #previous is blue\n                if(color == 0):\n                    for neigh in red[node]:\n                        if((1,node,neigh) not in visited):\n                            queue.append((1,neigh, lvl+1))\n                            visited.add((1,node,neigh))\n                #previous is red\n                elif(color == 1):\n                    for neigh in blue[node]:\n                        if((0,node,neigh) not in visited):\n                            queue.append((0, neigh, lvl+1))\n                            visited.add((0,node,neigh))\n            if(red_level == -1 and blue_level == -1):\n                ans.append(-1)\n            elif(red_level != -1 and blue_level == -1):\n                ans.append(red_level)\n            elif(red_level == -1 and blue_level != -1):\n                ans.append(blue_level)\n            else:\n                ans.append(min(red_level,blue_level))'''\n            \n        return ans\n", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        g = [defaultdict(list), defaultdict(list)]\n        for i, edges in enumerate([red_edges, blue_edges]):\n            for u, v in edges:\n                g[i][u].append(v)\n        dist = [[0] + [float('inf')] * (n-1) for _ in range(2)]\n        for i in range(2):\n            q = deque([(0, 0, i)])\n            while q:\n                d, u, color = q.popleft()\n                if d > dist[color][u]:\n                    continue\n                dist[color][u] = d\n                d += 1\n                color ^= 1\n                for v in g[color][u]:\n                    if dist[color][v] > d:\n                        q.append([d, v, color])\n        return [x if (x := min(a, b)) != float('inf') else -1  for a, b in zip(*dist)]", "from collections import defaultdict\nclass Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        red = defaultdict(list)\n        blue = defaultdict(list)\n        for x,y in red_edges:\n            red[x].append(y)\n        for x,y in blue_edges:\n            blue[x].append(y)\n        ans = []\n        for i in range(n):\n            #blue\n            visited = set()\n            queue = [(0,0, 0), (1,0,0)]\n            level = -1\n            visited.add((0,0))\n            visited.add((1,0))\n            while(queue):\n                color, node, lvl = queue.pop(0)\n                if(node == i):\n                    level = lvl\n                    break\n                #previous is blue\n                if(color == 0):\n                    for neigh in red[node]:\n                        if((1,neigh) not in visited):\n                            queue.append((1,neigh, lvl+1))\n                            visited.add((1,neigh))\n                #previous is red\n                elif(color == 1):\n                    for neigh in blue[node]:\n                        if((0,neigh) not in visited):\n                            queue.append((0, neigh, lvl+1))\n                            visited.add((0,neigh))\n            if(level == -1):\n                ans.append(-1)\n            else:\n                ans.append(level)\n            \n        return ans\n", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        self.red = {}\n        self.blue = {}\n        for u,v in red_edges:\n            if u not in self.red:\n                self.red[u]=[]\n            self.red[u].append(v)\n            \n        for u,v in blue_edges:\n            if u not in self.blue:\n                self.blue[u]=[]\n            self.blue[u].append(v)\n        \n        \n        def visit(i):\n            if i == 0:\n                return 0\n            color = [self.red,self.blue]\n            q = [(0,0),(0,1)]\n            n=0\n            visited = {}\n            while len(q)>0:\n                n+=1\n                nxt = []\n                for u,c in q: visited[(u,c)] = True\n                while len(q)>0:\n                    u,c = q.pop()\n                    if c == 0:\n                        if u in color[1]:\n                            for v in color[1][u]:\n                                if (v,1) not in visited:\n                                    if v == i:\n                                        return n\n                                    else:\n                                        nxt.append((v,1))\n                    if c == 1:\n                        if u in color[0]:\n                            for v in color[0][u]:\n                                if (v,0) not in visited:\n                                    if v == i:\n                                        return n\n                                    else:\n                                        nxt.append((v,0))\n                q = nxt\n            \n            return -1\n                    \n                    \n        result = []           \n        for i in range(n):\n            d = visit(i)\n            result.append(d)\n        return result", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        #    red -> True\n        hRed = defaultdict(list)\n        for edge in red_edges:\n            hRed[edge[0]].append(edge[1])\n        hBlue = defaultdict(list)\n        for edge in blue_edges:\n            hBlue[edge[0]].append(edge[1])\n        def helper(n, curr, visited):\n            dist = 0 \n            small = float('inf')\n            if curr:\n                arr = deque(hRed[0])\n            else:\n                arr = deque(hBlue[0])\n            while arr:\n                size = len(arr)\n                for j in range(size):\n                    node = arr.popleft()\n                    if (node, not curr) not in visited:\n                        visited.add((node, not curr))\n                        if node == i:\n                            small, arr = dist + 1, []\n                            break\n                        if curr:\n                            if node in hBlue:\n                                arr += hBlue[node]\n                        else:\n                            if node in hRed:\n                                arr += hRed[node]\n                dist += 1\n                curr = not curr\n            return small\n        res = [0]\n        for i in range(1, n):\n            small = helper(i, True, {(0, True)})\n            small = min(small, helper(i, False, {(0, False)}))\n            if small == float('inf'):\n                res.append(-1)\n            else:\n                res.append(small)\n        return res", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        # adjacent graph, branching for red/blue\n        # 0 for red, 1 for blue\n        G = [ [[], []] for i in range(n)]  \n        for i, j in red_edges: G[i][0].append(j)\n        for i, j in blue_edges: G[i][1].append(j)\n        # Init res, we maintain both path-length for red & blue.\n        res = [[0,0]] + [[2*n, 2*n] for i in range(n-1)] \n        # bfs : [[node, red], [node, blue]]\n        bfs = [[0, 0], [0, 1]]  \n        # actual BFS\n        while len(bfs) > 0:\n            node, color = bfs.pop(0)\n            for j in G[node][color]:\n                if res[j][color] == 2 * n:\n                    res[j][color] = res[node][1 - color] + 1\n                    bfs.append([j, 1 - color])\n        \n        # Select the smaller length and put in result\n        return [x if x < n * 2 else -1 for x in map(min, res)]\n", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        \n        graph = defaultdict(set)\n        \n        res = [float('inf') for i in range(n)]\n        \n        for edge in red_edges:\n            graph[edge[0]].add((edge[1],'r'))\n        \n        for edge in blue_edges:\n            graph[edge[0]].add((edge[1],'b'))\n        \n        qu = [(0,0,None)]\n        \n        visited = set()\n                \n        while qu:\n            node,dist,prev = qu.pop(0)\n            \n            res[node] = min(res[node],dist)\n            \n            for nbr in graph[node]:\n                if prev == None or (prev != nbr[1] and (node,nbr[0],nbr[1]) not in visited):\n                    qu.append((nbr[0], dist+1, nbr[1]))\n                    visited.add((node,nbr[0],nbr[1]))\n        \n        for i in range(len(res)):\n            if res[i] == float('inf'):\n                res[i] = -1\n                \n        return res\n        \n        \n", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        graph_red = defaultdict(list)\n        graph_blue = defaultdict(list)\n        \n        for a, b in red_edges:\n            graph_red[a].append(b)\n        \n        for a, b in blue_edges:\n            graph_blue[a].append(b)\n            \n        def bfs(target):\n            BLUE = 1\n            RED = 2\n            seen = set()\n            queue = deque([(0, 0, BLUE), (0,0,RED)])\n            \n            while queue:\n                node, steps, color = queue.popleft()\n                \n                if node == target:\n                    return steps\n                \n                if color == RED:\n                    for next_node in graph_blue[node]:\n                        if (next_node, BLUE) not in seen:\n                            seen.add((next_node, BLUE))\n                            queue.append((next_node, steps + 1, BLUE))\n                else:\n                    for next_node in graph_red[node]:\n                        if (next_node, RED) not in seen:\n                            seen.add((next_node, RED))\n                            queue.append((next_node, steps + 1, RED))\n            \n            return -1\n                            \n            \n        res = []\n        \n        for i in range(n):\n            res.append(bfs(i))\n        \n        return res", "class Solution:\n    def shortestAlternatingPaths(\n        self, \n        n: int, \n        red_edges: List[List[int]], \n        blue_edges: List[List[int]],\n    ) -> List[int]:\n        red_adj = [[] for i in range(n)]\n        blue_adj = [[] for i in range(n)]\n        for edge in red_edges:\n            red_adj[edge[0]].append(edge[1])\n        for edge in blue_edges:\n            blue_adj[edge[0]].append(edge[1])\n        result = []\n        for i in range(n):\n            start_red = self.shortestPath(red_adj, blue_adj, True, i)\n            start_blue = self.shortestPath(red_adj, blue_adj, False, i)\n            if start_red == -1:\n                result.append(start_blue)\n            elif start_blue == -1:\n                result.append(start_red)\n            elif start_red < start_blue:\n                result.append(start_red)\n            else:\n                result.append(start_blue)\n        return result\n        \n    def shortestPath(\n        self,\n        red_adj: List[List[int]], \n        blue_adj: List[List[int]],\n        startRed: bool,\n        X: int,\n    ) -> int:\n        red_visited = set()\n        blue_visited = set()\n        bfs = [(0, startRed, 0)]\n        while len(bfs) > 0:\n            node, is_red, depth = bfs.pop(0)\n            if node == X:\n                return depth\n            if is_red and node in red_visited:\n                continue\n            elif not is_red and node in blue_visited:\n                continue\n            if is_red:\n                red_visited.add(node)\n                for n in blue_adj[node]:\n                    if n not in blue_visited:\n                        bfs.append((n, False, depth + 1))\n            else:\n                blue_visited.add(node)\n                for n in red_adj[node]:\n                    if n not in red_visited:\n                        bfs.append((n, True, depth + 1))\n        return -1", "class Solution:\n    def shortestAlternatingPaths(self, n: int,\n                                 red_edges: List[List[int]],\n                                 blue_edges: List[List[int]]) -> List[int]:\n        g = {}\n        for s,e in red_edges:\n            if s not in g:\n                g[s] = []\n            g[s].append((e, 'r'))\n        for s,e in blue_edges:\n            if s not in g:\n                g[s] = []\n            g[s].append((e, 'b'))\n        return [find_path_length(g, 0, i) for i in range(0, n)]\n    \ndef find_path_length(g, s, e):\n    to_visit = [(s, 0, 'r'), (s, 0, 'b')]\n    visited = set()\n    while to_visit:\n        x, i, c = to_visit.pop(0)\n        if (x,c) in visited:\n            continue\n        visited.add((x,c))\n        if x == e:\n            return i\n        if x not in g:\n            continue\n        for s1, c1 in g[x]:\n            if c != c1:\n                to_visit.append((s1, i+1, c1))\n    return -1\n", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        G = [[] for _ in range(n)]\n        for x,y in red_edges: G[x].append((y,1))\n        for x,y in blue_edges: G[x].append((y,-1))\n        def bfs(target):\n            if target==0: return 0\n            q = deque([(y,color) for y,color in G[0]])\n            level = 1\n            visited = set()\n            while q:\n                l = len(q)\n                for _ in range(l):\n                    curr,color = q.popleft()\n                    visited.add((curr,color))\n                    if curr == target: return level\n                    for y,z in G[curr]:\n                        if z!=color and (y,z) not in visited: q.append((y,z))\n                level+=1\n            return -1\n        return [bfs(i) for i in range(0,n)]", "from collections import deque\nclass Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        edges = [{}, {}]\n        for i, allEdges in enumerate([red_edges, blue_edges]):\n            for edge in allEdges:\n                src, tar = edge[0], edge[1]\n                edges[i].setdefault(src, []).append(tar)\n        def shortedAlterPath(source, target, colour): # dfs\n            queue = deque([source])\n            visited = {(colour, source)}\n            count = 0\n            while queue:\n                for _ in range(len(queue)):\n                    node = queue.popleft()\n                    if node == target: return count\n                    for nextNode in edges[colour].get(node, []):\n                        if (1 - colour, nextNode) in visited: continue\n                        visited.add((1 - colour, nextNode))\n                        queue.append(nextNode)\n                colour = 1 - colour\n                count += 1\n            return float('inf')\n        res = [0] * n\n        for dst in range(1, n):\n            distance = min(\n                shortedAlterPath(0, dst, 0),\n                shortedAlterPath(0, dst, 1)\n            )\n            if distance == float('inf'): res[dst] = -1\n            else: res[dst] = distance\n        return res\n", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        G = [[] for _ in range(n)]\n        for x,y in red_edges: G[x].append((y,1))\n        for x,y in blue_edges: G[x].append((y,-1))\n        def bfs(target):\n            if target==0: return 0\n            q = deque([(y,color,1) for y,color in G[0]])\n            visited = set()\n            while q:\n                l = len(q)\n                curr,color,level = q.popleft()\n                visited.add((curr,color))\n                if curr == target: return level\n                for y,z in G[curr]:\n                    if z!=color and (y,z) not in visited: q.append((y,z,level+1))\n            return -1\n        return [bfs(i) for i in range(0,n)]", "class Solution:\n    # TLE\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        '''\n        O(N^3)\n        \n        Variation of Floyd.\n        \n        DP.\n        \n        dp[k, i, j, c1, c2]:\n        shortest path between i and j, \n        with first edge being c1 and last edge being color c2, \n        using first k nodes as intermediary.\n        \n        Transition: \n        - for each k, try if it it is an improvement for (i, j, c1, c2)\n        - 1) \n          - dp[k - 1, i, k, c1, 0] + dp[k - 1, k, j, 1, c2] -- use k to improve\n          - dp[k - 1, i, k, c1, 1] + dp[k - 1, k, j, 0, c2] -- use k to improve\n        - 2) dp[k - 1, i, j, c1, c2] -- do not use k (but used up to k-1) \n        \n        Since k is executed in increasing order, we can remove this dimension by rollling array.\n        \n        Use dict(<i, j, c1, c2>) to store the state.\n        \n        '''\n        \n        MAX = float('inf')\n        \n        state = {}\n        for i in range(n):\n            for j in range(n):\n                for c1 in range(2):\n                    for c2 in range(2):\n                        state[(i, j, c1, c2)] = MAX\n        \n        for u, v in red_edges:\n            state[(u, v, 0, 0)] = 1\n            # state[(v, u, 0, 0)] = 1\n        for u, v in blue_edges:\n            state[(u, v, 1, 1)] = 1\n            # state[(v, u, 1, 1)] = 1\n                        \n        def relax(k):\n            for i in range(n):\n                for j in range(n):\n                    for c1 in range(2):\n                        for c2 in range(2):\n                            state[(i, j, c1, c2)]  = min(\n                                state[(i, j, c1, c2)],\n                                state[(i, k, c1, 0)] + state[(k, j, 1, c2)],\n                                state[(i, k, c1, 1)] + state[(k, j, 0, c2)]\n                            )\n\n        for k in range(0, n):\n            # if k == 5:\n            #     print(state[(5, 5, 0, 0)])\n            #     print(state[(5, 5, 1, 1)])\n            #     print(state[(0, 5, 1, 0)])\n            #     print(state[(0, 5, 1, 1)])\n            #     print(state[(5, 2, 0, 0)])\n            #     print(state[(5, 2, 1, 0)])\n            relax(k)\n          \n        # print('end', state[(5, 2, 1, 0)])\n        \n        for k in range(0, n):\n            relax(k)\n            \n        # print('end', state[(5, 2, 1, 0)])\n\n        ans = [0]\n        for i in range(1, n):\n            t = min(state[(0, i, c1, c2)] for c1 in range(2) for c2 in range(2))\n            if t == MAX:\n                t = -1\n            ans.append(t)\n            \n        return ans\n\n            \n\n'''\n3\n[[0,1],[1,2]]\n[]\n3\n[[0,1]]\n[[2,1]]\n3\n[[1,0]]\n[[2,1]]\n3\n[[0,1]]\n[[1,2]]\n3\n[[0,1],[0,2]]\n[[1,0]]\n5\n[[0,1],[1,2],[0,3],[4,2]]\n[[3,4]]\n6\n[[4,1],[3,5],[5,2],[1,4],[4,2],[0,0],[2,0],[1,1]]\n[[5,5],[5,0],[4,4],[0,3],[1,0]]\n100\n[[42,98],[85,41],[71,93],[2,38],[51,81],[0,17],[62,95],[76,15],[96,12],[98,38],[22,22],[26,65],[32,81],[23,33],[95,3],[18,8],[14,49],[60,23],[47,18],[38,82],[22,53],[6,79],[54,81],[37,44],[20,75],[22,33],[70,20],[94,24],[75,44],[19,78],[17,58],[11,47],[18,30],[17,65],[43,1],[18,5],[0,68],[82,75],[66,12],[41,67],[41,86],[37,48],[86,89],[41,1],[28,68],[19,47],[97,60],[59,3],[0,19],[77,91],[77,34]]\n[[61,11],[34,19],[18,61],[45,60],[80,28],[33,6],[51,45],[54,56],[42,12],[8,4],[74,64],[57,66],[98,25],[40,84],[2,34],[80,41],[35,47],[5,19],[87,32],[6,3],[64,94],[60,67],[75,95],[72,6],[89,0],[44,63],[27,62],[56,54],[26,9],[46,66],[79,40],[83,14],[44,73],[93,77],[14,48],[65,20],[57,30],[99,46],[85,80],[25,24],[99,4],[6,45],[25,51],[47,44]]\n'''    \n        \n\nclass Solution:\n    #AC\n    # Runtime: 144 ms, faster than 22.01% of Python3 online submissions for Shortest Path with Alternating Colors.\n    # Memory Usage: 14.2 MB, less than 10.36% of Python3 online submissions for Shortest Path with Alternating Colors.\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        '''\n        modified SPFA (Dijkstra)\n        \n        PriorityQueue element: (node, end_edge_color).\n        O(M log M)\n        '''\n        \n        MAX = float('inf')\n        \n        from collections import defaultdict\n        adj = defaultdict(set)\n        for u, v in red_edges:\n            adj[u].add((v, 0))\n        for u, v in blue_edges:\n            adj[u].add((v, 1))\n            \n        from queue import PriorityQueue\n        pq = PriorityQueue()\n        pq.put((0, 0, 0)) # distance, node, color\n        pq.put((0, 0, 1))\n        dist = {}\n        for u in range(n):\n            for c in range(2):\n                dist[(u, c)] = MAX\n        dist[(0, 0)] = 0\n        dist[(0, 1)] = 0\n        # solved = {}\n        solved = set()\n        while not pq.empty():\n            d, u, c = pq.get()\n            # solved[(u, c)] = d\n            for v, cc in adj[u]:\n                if cc != c:\n                    if dist[(v, cc)] > d + 1:\n                        dist[(v, cc)] = d + 1\n                        pq.put((d + 1, v, cc))\n        \n        ans = []\n        for u in range(n):\n            t = min(dist[(u, 0)], dist[(u, 1)])\n            if t == MAX:\n                t = -1\n            ans.append(t)\n        \n        return ans\n\n\n    \nclass Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        '''\n        Idea: We can switch edge and node.\n        \n        In the new graph definition:\n        - node: original edges, regardless of their color\n        - edge: \n            we test all pairs of original incident edges (now node) at one original node, \n            build an edge if they are of different color\n        \n        Run normal SP algorithm on the resulting graph.\n        '''\n        \n        from collections import defaultdict\n        ri, ro, bi, bo = defaultdict(list), defaultdict(list), defaultdict(list), defaultdict(list)\n        \n        nodes = set()\n        for (i, (u, v)) in enumerate(red_edges):\n            nodes.add(('r', i))\n            ro[u].append(('r', i))\n            ri[v].append(('r', i))\n        for (i, (u, v)) in enumerate(blue_edges):\n            nodes.add(('b', i))\n            bo[u].append(('b', i))\n            bi[v].append(('b', i))\n        \n        graph = defaultdict(set)\n        for i in range(n):\n            for u in ri[i]:\n                for v in bo[i]:\n                    graph[u].add(v)\n            for u in bi[i]:\n                for v in ro[i]:\n                    graph[u].add(v)\n        \n        nodes.add('S')\n        for u in ro[0]:\n            graph['S'].add(u)\n        for u in bo[0]:\n            graph['S'].add(u)\n            \n        INF = float('inf')\n        dist = {}\n        for u in nodes:\n            dist[u] = INF\n        dist['S'] = 0\n        \n        from queue import PriorityQueue\n        pq = PriorityQueue()\n        pq.put((0, 'S'))\n        solved = set()\n        while len(solved) < len(nodes) and not pq.empty():\n            d, u = pq.get()\n            solved.add(u)\n            for v in graph[u]:\n                if dist[u] + 1 < dist[v]:\n                    dist[v] = d + 1\n                    pq.put((d + 1, v))\n        \n        ans = [0]\n        for i in range(1, n):\n            rd = [dist[u] for u in ri[i]]\n            bd = [dist[u] for u in bi[i]]\n            if len(rd + bd) == 0:\n                t = -1\n            else:\n                t = min(rd + bd)\n                if t == INF:\n                    t = -1\n            ans.append(t)\n        \n        return ans\n            \n        \n        \n", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        \n        distance = [[float('inf'), float('inf')] for _ in range(n)]\n        distance[0][0] = 0 # red\n        distance[0][1] = 0 # blue\n        \n        for _ in range(n):\n            for u, v in red_edges:\n                if distance[u][1] + 1 < distance[v][0]:\n                    distance[v][0] = distance[u][1] + 1\n            for u, v in blue_edges:\n                if distance[u][0] + 1 < distance[v][1]:\n                    distance[v][1] = distance[u][0] + 1\n        \n        min_distance = []\n        for d in distance:\n            min_d = min(d)\n            if min_d < float('inf'):\n                min_distance.append(min_d)\n            else:\n                min_distance.append(-1)\n        return min_distance\n        \n'''\n\ndistance[X][0] distance upto X with last edge red\ndistance[X][1]                      last edge blue\n\n\n\n'''", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        def bfs(target, color):\n            q = deque([[0, 0, color]])\n            seen = set()\n            while q:\n                cur, step, c = q.popleft()\n                if cur == target:\n                    return step\n                if (cur, c) in seen:\n                    continue\n                seen.add((cur, c))\n                \n                for neighbor in e[cur][c]:\n                    q.append([neighbor, step + 1, (c + 1) % 2])\n                    \n            return -1\n        \n        e = {i: [set(), set()] for i in range(n)}\n        for i, j in red_edges:\n            e[i][0].add(j)\n        for i, j in blue_edges:\n            e[i][1].add(j)\n            \n        # print(e)\n        res = [0] * n\n        for i in range(1, n):\n            red = bfs(i, 0)\n            blue = bfs(i, 1)\n            if red == -1:\n                res[i] = blue\n            elif blue == -1:\n                res[i] = red\n            else:\n                res[i] = min(red, blue)\n            \n        return res\n", "\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n    def add_edge(self,src,dst,color):\n        self.edges[src].append((dst,color))\n        \n\nclass Solution:     \n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        \n        g = Graph()\n        for src,dst in red_edges:\n            g.add_edge(src,dst,\\\"R\\\")\n        for src,dst in blue_edges:\n            g.add_edge(src,dst,\\\"B\\\")\n        \n        \n        data = [float(inf)]*(n)\n        q = deque()\n        q.append((0,0,None))\n        visited = set()\n        while(q):\n            node,dist,prevColor = q.popleft()\n            visited.add((node,prevColor))\n            if(dist < data[node]):\n                data[node] = dist\n            \n            for nei,col in g.edges[node]:\n                if col!=prevColor and (nei,col) not in visited:\n                    q.append((nei,dist+1,col))\n        \n        for i,e in enumerate(data):\n            if e==float('inf'):\n                data[i]=-1\n        \n        return data\n                    \n            \n            ", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        \n        combined = collections.defaultdict(lambda: [set(), set()])\n        \n        for i,j in red_edges:\n            combined[i][0].add(j)\n        for i,j in blue_edges:\n            combined[i][1].add(j)\n            \n        ans = collections.defaultdict(lambda: float('inf'))\n            \n        # 0 = red, 1 = blue\n        \n        def bfs(queue):\n            seen = set()\n            while queue:\n                size = len(queue)\n                for _ in range(size):\n                    cur, distance, color = queue.popleft()\n                    ans[cur] = min(ans[cur], distance)\n                    for nb in combined[cur][color]:\n                        if (cur,nb,color) not in seen:\n                            seen.add((cur,nb,color))\n                            queue.append((nb, distance + 1, abs(1-color)))\n        \n        bfs(collections.deque([(0,0,0)]))\n        bfs(collections.deque([(0,0,1)]))\n        \n        return [-1 if i not in ans else ans[i] for i in range(n)]\n                    \n                \n                \n", "import queue\nclass Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        \n        red = self.create_adj(red_edges, n)\n        blue = self.create_adj(blue_edges, n)\n        \n        dist_array = [-1 for _ in range(n)]\n        dist_array[0] = 0\n        q = queue.Queue()\n        self.bfs(red, blue, \\\"blue\\\", dist_array)\n        self.bfs(red, blue, \\\"red\\\", dist_array)\n        return dist_array\n        \n    def bfs(self, red, blue, color, A):\n        visited_red = set()\n        visited_blue = set()\n        q = queue.Queue()\n        if color == \\\"blue\\\":\n            visited_blue.add(0)\n        else:\n            visited_red.add(0)\n        q.put((0,0, color))\n        \n        while(q.qsize() != 0):\n            cur = q.get()\n            cur_node = cur[0]\n            cur_len = cur[1]\n            cur_color = cur[2]\n            if cur_color == \\\"red\\\":\n                for node in red[cur_node]:\n                    if node not in visited_red:\n                        visited_red.add(node)\n                        q.put((node, cur_len + 1, \\\"blue\\\"))\n                        if A[node] >= 0:\n                            A[node] = min(A[node], cur_len + 1)\n                        else:\n                            A[node] = cur_len + 1\n                cur_color = \\\"blue\\\"\n            else:\n                for node in blue[cur_node]:\n                    if node not in visited_blue:\n                        visited_blue.add(node)\n                        q.put((node, cur_len + 1, \\\"red\\\"))\n                        if A[node] >= 0:\n                            A[node] = min(A[node], cur_len + 1)\n                        else:\n                            A[node] = cur_len + 1\n                cur_color = \\\"red\\\"\n        \n\n        \n        \n        \n    def create_adj(self, nodes, n):\n        adj = [[] for node in range(n)]\n        for i in range(len(nodes)):\n            adj[nodes[i][0]].append(nodes[i][1])\n        \n        return adj", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        result = [-1] * n\n        \n        \n        redDict = defaultdict(list)\n        \n        for edge in red_edges:\n            redDict[edge[0]].append(edge[1])\n        \n        blueDict = defaultdict(list)\n        \n        for edge in blue_edges:\n            blueDict[edge[0]].append(edge[1])\n        \n        queue = deque()\n        \n        queue.append((0, 'blue', 0))\n        queue.append((0, 'red', 0))\n        # result[0] = 0\n        \n        while queue:\n            item = queue.popleft()\n            if result[item[0]] == -1 or result[item[0]] >= item[2]:\n                result[item[0]] = item[2]\n            if item[1] == 'blue':\n                nextColor = 'red'\n                nextNodes = blueDict[item[0]]\n            else:\n                nextColor = 'blue'\n                nextNodes = redDict[item[0]]\n            \n            for nex in range(len(nextNodes)):\n                if nextNodes[nex] != -1:\n                    queue.append((nextNodes[nex], nextColor, item[2]+1))\n                    nextNodes[nex] = -1\n                \n        return result", "class Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        # 4:43 10/2/20\n        graph = [collections.defaultdict(set), collections.defaultdict(set)]\n\n        for i, j in red_edges:\n            graph[0][i].add(j)\n\n        for i, j in blue_edges:\n            graph[1][i].add(j)\n\n        ans = [math.inf] * n\n        \n        stack = [(0, 0, 0), (1, 0, 0)]\n        \n        for color, node, dist in stack:\n            ans[node] = min(ans[node], dist)\n            neighbors = list(graph[color][node])\n            for nei in neighbors:\n                graph[color][node].remove(nei)\n                stack.append((1-color, nei, dist+1))\n        \n        return [-1 if x == math.inf else x for x in ans]\n        \n"]
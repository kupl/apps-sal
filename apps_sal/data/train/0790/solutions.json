["N,M,C = list(map(int, input().split()))\ntree = [0] * (N+1)\n\ndef add(u,k):\n while u < len(tree):\n  tree[u] += k \n  u += u&-u\n\ndef query(k):\n ans = 0\n while k:\n  ans += tree[k]\n  k -= k&-k\n\n return ans\n\ndef solve():\n for _ in range(M):\n  op = input().split()\n  if op[0] == 'Q':\n   print(query(int(op[1])) + C)\n  else:\n   u,v,k = int(op[1]), int(op[2]), int(op[3]) \n   add(u, k)\n   add(v+1, -k)\n\ndef __starting_point():\n solve()\n\n__starting_point()", "N,M,C = list(map(int, input().split()))\ntree = [0] * (N+1)\n\ndef add(u,k):\n while u < len(tree):\n  tree[u] += k \n  u += u&-u\n\ndef query(k):\n ans = 0\n while k:\n  ans += tree[k]\n  k -= k&-k\n\n return ans\n\ndef solve():\n for _ in range(M):\n  op = input().split()\n  if op[0] == 'Q':\n   print(query(int(op[1])) + C)\n  else:\n   u,v,k = int(op[1]), int(op[2]), int(op[3]) \n   add(u, k)\n   add(v+1, -k)\n\ndef __starting_point():\n solve()\n\n__starting_point()", "n,m , c = list(map(int, input().split()))\nbit = [0] * (n+1) \ndef add(index, val):\n index += 1 \n while index <= n :\n  bit[index] += val \n  index += index &-index \n\ndef get(index):\n r = 0\n index += 1 \n while index:\n  r += bit[index]\n  index -= index & -index \n return r \n \nwhile m:\n m-=1 \n op = input().split()\n if len(op) == 4:\n  _, u, v, k = op\n  u = int(u) \n  v = int(v) \n  k = int(k)\n  u-=1 \n  v-=1 \n  add(u, k) \n  add(v+1, -k) \n else:\n  _, p = op\n  p = int(p)\n  print(get(p-1) + c)\n", "n,m , c = list(map(int, input().split()))\nbit = [0] * (n+1) \ndef add(index, val):\n index += 1 \n while index <= n :\n  bit[index] += val \n  index += index &-index \n\ndef get(index):\n r = 0\n index += 1 \n while index:\n  r += bit[index]\n  index -= index & -index \n return r \n \nwhile m:\n m-=1 \n op = input().split()\n if len(op) == 4:\n  _, u, v, k = op\n  u = int(u) \n  v = int(v) \n  k = int(k)\n  u-=1 \n  v-=1 \n  add(u, k) \n  add(v+1, -k) \n else:\n  _, p = op\n  p = int(p)\n  print(get(p-1) + c)\n", "def bitadd(tree,index,value):\n index+=1\n while index<len(tree):\n  tree[index]+=value\n  index+=index&(-index)\n  \ndef bitsum(tree,index):\n index+=1\n result=0\n while index:\n  result+=tree[index]\n  index-=index&(-index)\n return result\n\n\nn,m,c=list(map(int,input().split()))\ntree=[0 for _ in range(n+1)]\n# for i in range(n):\n#     bitadd(tree,i,c)\nfor _ in range(m):\n q=input().split()\n if q[0]==\"Q\":\n  print(bitsum(tree,int(q[1])-1)+c)\n else:\n  u=int(q[1])\n  v=int(q[2])\n  k=int(q[3])\n  bitadd(tree,u-1,k)\n  bitadd(tree,v,-k)", "n, m, val = list(map(int, input().split()))\n\nfenwick = [0] * (n + 1)\n\ndef add(idx, val):\n while idx <= n:\n  fenwick[idx] += val\n  idx += idx & -idx\n\ndef interval_add(xxx_todo_changeme):\n (right, left, val) = xxx_todo_changeme\n add(right, val)\n add(left + 1, -val)\n\ndef val_at(idx):\n ret = 0\n while idx:\n  ret += fenwick[idx]\n  idx -= idx & -idx\n return ret + val\n\nfor _ in range(m):\n q = input().split()\n if q[0] == 'Q':\n  print(val_at(int(q[1])))\n else:\n  interval_add(list(map(int, q[1:])))\n", "def update(fenwick,n,ind,val):\n while(ind<=n):\n  fenwick[ind]+=val;\n  ind+=ind&(-ind)\ndef get(arr,ind):\n su=0\n while(ind>0):\n  su+=arr[ind]\n  ind-=ind&(-ind)\n return su\nn,m,c=list(map(int,input().strip().split(\" \")))\nfenwick=[0]*(n+1)\nfor z in range(m):\n s=list(map(str,input().strip().split(\" \")))\n if(s[0]=='S'):\n  update(fenwick,n,(int)(s[1]),(int)(s[3]))\n  update(fenwick,n,(int)(s[2])+1,-(int)(s[3]))\n else:\n  print(get(fenwick,(int)(s[1]))+c)\n"]
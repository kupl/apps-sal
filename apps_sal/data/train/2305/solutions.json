["import sys\nfrom collections import deque\n\n\ndef diameter(n, links):\n    q = deque([(0, -1)])\n    v = 0\n    while q:\n        v, p = q.popleft()\n        q.extend((u, v) for u in links[v] if u != p)\n\n    q = deque([(v, -1)])\n    w = 0\n    parents = [-1] * n\n    while q:\n        w, p = q.popleft()\n        parents[w] = p\n        q.extend((u, w) for u in links[w] if u != p)\n    parents_rev = [-1] * n\n    p = w\n    while parents[p] != -1:\n        parents_rev[parents[p]] = p\n        p = parents[p]\n    return v, w, parents, parents_rev\n\n\ndef construct(s, links, parents, parents_rev):\n    v = s\n    result = []\n    while v != -1:\n        pv, rv = parents[v], parents_rev[v]\n        child_count = 0\n        for u in links[v]:\n            if u == pv or u == rv:\n                continue\n            if len(links[u]) != 1:\n                return False\n            child_count += 1\n        my_value = len(result) + 1\n        result.extend(list(range(my_value + 1, my_value + child_count + 1)))\n        result.append(my_value)\n        v = parents[v]\n    return result\n\n\ndef solve(n, links):\n    d1, d2, parents, parents_rev = diameter(n, links)\n    result1 = construct(d1, links, parents_rev, parents)\n    if result1 is False:\n        return [-1]\n    result2 = construct(d2, links, parents, parents_rev)\n    return min(result1, result2)\n\n\nn = int(input())\nlinks = [set() for _ in range(n)]\nINF = 10 ** 9\n\nfor line in sys.stdin:\n    v, w = list(map(int, line.split()))\n    v -= 1\n    w -= 1\n    links[v].add(w)\n    links[w].add(v)\n\nprint((*solve(n, links)))\n", "import sys\n\n#sys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nn=II()\nto=[[] for _ in range(n)]\nfor _ in range(n-1):\n    u,v=MI1()\n    to[u].append(v)\n    to[v].append(u)\n#print(to)\n\ndef far(u):\n    stack=[(u,-1,0)]\n    mxd=mxu=-1\n    while stack:\n        u,pu,d=stack.pop()\n        if d>mxd:\n            mxd=d\n            mxu=u\n        for v in to[u]:\n            if v==pu:continue\n            stack.append((v,u,d+1))\n    return mxu,mxd\n\ns,_=far(0)\nt,dist=far(s)\n#print(s,t,dist)\n\ndef makepath(u,t):\n    stack=[(u,-1)]\n    while stack:\n        u,pu=stack.pop()\n        while path and path[-1]!=pu:path.pop()\n        path.append(u)\n        if u==t:return\n        for v in to[u]:\n            if v==pu:continue\n            stack.append((v,u))\n\npath=[s]\nmakepath(s,t)\n#print(path)\n\nleg=[]\nfor u in path[1:-1]:leg.append(len(to[u])-2)\n#print(leg)\n\nif sum(leg)+dist+1!=n:\n    print(-1)\n    return\n\nans=[]\nans.append(1)\nu=2\nfor l in leg:\n    for v in range(u+1,u+1+l):\n        ans.append(v)\n    ans.append(u)\n    u+=l+1\nans.append(u)\n\nleg.reverse()\nans2=[]\nans2.append(1)\nu=2\nfor l in leg:\n    for v in range(u+1,u+1+l):\n        ans2.append(v)\n    ans2.append(u)\n    u+=l+1\nans2.append(u)\n\nif ans2<ans:ans=ans2\nprint(*ans)\n", "import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nN = int(input())\nVW = [[int(x)-1 for x in input().split()] for _ in range(N-1)]\n\n\"\"\"\n\u76f4\u5f84\u306b\u6b21\u65701\u306e\u9802\u70b9\u304c\u751f\u3048\u3066\u3044\u308b\n\"\"\"\n\ngraph = [[] for _ in range(N)]\ndeg = [0] * N\nfor v,w in VW:\n    graph[v].append(w)\n    graph[w].append(v)\n    deg[v] += 1\n    deg[w] += 1\n\ndef dijkstra(start):\n    INF = 10**10\n    dist = [INF] * N\n    q = [(start,0)]\n    while q:\n        qq = []\n        for v,d in q:\n            dist[v] = d\n            for w in graph[v]:\n                if dist[w] == INF:\n                    qq.append((w,d+1))\n        q = qq\n    return dist\n\ndist = dijkstra(0)\nv = dist.index(max(dist))\ndist = dijkstra(v)\nw = dist.index(max(dist))\ndiag = v,w\n\ndef create_perm(start):\n    arr = []\n    v = start\n    parent = None\n    next_p = 1\n    while True:\n        n = 0\n        next_v = None\n        for w in graph[v]:\n            if w == parent:\n                continue\n            if next_v is None or deg[next_v] < deg[w]:\n                next_v = w\n            if deg[w] == 1:\n                n += 1\n        if next_v is None:\n            return arr + [next_p]\n        if deg[next_v] == 1:\n            n -= 1\n        arr += list(range(next_p+1,next_p+n+1))\n        arr.append(next_p)\n        next_p += n+1\n        parent = v\n        v = next_v\n\nP = create_perm(diag[1])\n\nQ = create_perm(diag[0])\n\nif len(P) != N:\n    answer = -1\nelse:\n    if P > Q:\n        P = Q\n    answer = ' '.join(map(str,P))\nprint(answer)\n\n", "import sys\nreadline = sys.stdin.readline\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return par, order\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\ndef dfs(St):\n    dist = [0]*N\n    stack = St[:]\n    used = [False]*N\n    for s in St:\n        used[s] = True\n    while stack:\n        vn = stack.pop()\n        for vf in Edge[vn]:\n            if not used[vf]:\n                used[vf] = True\n                dist[vf] = 1 + dist[vn]\n                stack.append(vf)\n    return dist\n\nN = int(readline())\nEdge = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, readline().split())\n    a -= 1\n    b -= 1\n    Edge[a].append(b)\n    Edge[b].append(a)\n\ndist0 = dfs([0])\nfs = dist0.index(max(dist0))\ndistfs = dfs([fs])\nen = distfs.index(max(distfs))\ndisten = dfs([en])\n\nDia = distfs[en]\npath = []\nfor i in range(N):\n    if distfs[i] + disten[i] == Dia:\n        path.append(i)\n\nif max(dfs(path)) > 1:\n    print(-1)\nelse:\n    \n    path.sort(key = lambda x: distfs[x])\n    \n    cnt = 1\n    hold = 0\n    perm1 = [None]*N\n    onpath = set(path)\n    idx = 0\n    for i in range(Dia+1):\n        vn = path[i]\n        hold = 0\n        for vf in Edge[vn]:\n            if vf in onpath:\n                continue\n            hold += 1\n            perm1[idx] = cnt + hold\n            idx += 1\n        perm1[idx] = cnt\n        idx += 1\n        cnt = cnt+hold+1\n    \n    cnt = 1\n    hold = 0\n    perm2 = [None]*N\n    onpath = set(path)\n    idx = 0\n    for i in range(Dia+1):\n        vn = path[Dia-i]\n        hold = 0\n        for vf in Edge[vn]:\n            if vf in onpath:\n                continue\n            hold += 1\n            perm2[idx] = cnt + hold\n            idx += 1\n        perm2[idx] = cnt\n        idx += 1\n        cnt = cnt+hold+1\n    print(*min(perm1, perm2))", "#!/usr/bin/env python3\n\n\ndef solve(n, adj_list, d):\n\n    s = []\n    path_adj_list = [[] for _ in range(n)]\n    for v in range(n):\n        if 1 < d[v]:\n            p = path_adj_list[v]\n            for w in adj_list[v]:\n                if 1 < d[w]:\n                    p.append(w)\n            if 2 < len(p):\n                print((-1))\n                return\n            if len(p) == 1:\n                s.append(v)\n\n    if len(s) == 0:\n        ans = [1] + [v for v in range(3, n)] + [2]\n        if 2 < n:\n            ans += [n]\n        print((' '.join(list(map(str, ans)))))\n        return\n\n    visited = [False] * n\n    v, w = s\n    while v != w and d[v] == d[w]:\n        visited[v] = True\n        visited[w] = True\n        f = False\n        for nv in path_adj_list[v]:\n            if not visited[nv]:\n                f = True\n                v = nv\n                break\n        if not f:\n            break\n        f = False\n        for nw in path_adj_list[w]:\n            if not visited[nw]:\n                f = True\n                w = nw\n                break\n        if not f:\n            break\n\n    if d[v] > d[w]:\n        v = s[1]\n    else:\n        v = s[0]\n\n    visited = [False] * n\n    visited[v] = True\n    ans = [1] + [w for w in range(3, d[v] + 1)] + [2]\n    c = d[v]\n    v = path_adj_list[v][0]\n    while True:\n        visited[v] = True\n        ans += [w for w in range(c + 2, c + d[v])] + [c + 1]\n        c += d[v] - 1\n        f = False\n        for nv in path_adj_list[v]:\n            if not visited[nv]:\n                f = True\n                v = nv\n                break\n        if not f:\n            break\n\n    ans += [n]\n\n    print((' '.join(list(map(str, ans)))))\n    return\n\n\ndef main():\n    n = input()\n    n = int(n)\n    adj_list = [[] for _ in range(n)]\n    d = [0] * n\n    for _ in range(n - 1):\n        v, w = input().split()\n        v = int(v) - 1\n        w = int(w) - 1\n        adj_list[v].append(w)\n        adj_list[w].append(v)\n        d[v] += 1\n        d[w] += 1\n\n    solve(n, adj_list, d)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "import sys\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(2*10**5)\n\nn=int(input())\nedge=[[] for i in range(n)]\nfor i in range(n-1):\n    v,w=map(int,input().split())\n    edge[v-1].append(w-1)\n    edge[w-1].append(v-1)\n\nif n==2:\n    print(1,2);return\n\nleafcnt=[0]*n\nfor v in range(n):\n    for nv in edge[v]:\n        if len(edge[nv])==1:\n            leafcnt[v]+=1\n\nused=[False]*n\nline=[]\ndef line_check(v):\n    used[v]=True\n    line.append(leafcnt[v])\n    flag=False\n    for nv in edge[v]:\n        if not used[nv] and len(edge[nv])!=1:\n            if not flag:\n                line_check(nv)\n                flag=True\n            else:\n                return False\n    return True\n\nfor v in range(n):\n    if not used[v] and len(edge[v])-leafcnt[v]<=1 and len(edge[v])!=1:\n        if not line:\n            check=line_check(v)\n            if not check:\n                print(-1);return()\n        else:\n            print(-1);return()\n\n\nline_rev=line[::-1]\nres=min(line,line_rev)\nres=[0]+res+[0]\nres[1]-=1\nres[-2]-=1\n\nans=[]\nL=1\nfor val in res:\n    R=L+val\n    for i in range(L+1,R+1):\n        ans.append(i)\n    ans.append(L)\n    L=R+1\n\nprint(*ans)\n"]
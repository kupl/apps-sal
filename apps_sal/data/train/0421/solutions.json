["class Solution:\n    def lastSubstring(self, s: str) -> str:\n        #mx = \\\"\\\"\n        #for i in range(len(s)):\n        #    mx = max(mx,s[i:])\n        #return mx\n        index = {c: i for i, c in enumerate(sorted(set(s)))}\n        cur, radix, max_val, max_i = 0, len(index), 0, 0\n        for i in range(len(s)-1, -1, -1):\n            cur = index[s[i]] + cur/radix\n            if cur > max_val:\n                max_val, max_i = cur, i\n        return s[max_i:]", "class Solution:       \n    def lastSubstring(self, s: str) -> str:\n        curr_value = 0\n        max_value = 0\n        max_idx = 0\n        char_to_id = {c: i for i, c in enumerate(sorted(set(s)))}\n        radix = len(char_to_id) ** (len(s) - 1)\n        \n        for i in range(len(s) - 1, -1, -1):\n            curr_value = char_to_id[s[i]] + curr_value / len(char_to_id)\n            # print(curr_value)\n\n            if curr_value > max_value:\n                max_value = curr_value\n                max_idx = i\n\n        return s[max_idx:]\n        # index = {c: i for i, c in enumerate(sorted(set(s)))}\n        # radix, val, cur, lo = len(index), 0, 0, 0\n        # for i in range(len(s) - 1, -1, -1):\n        #     cur = index[s[i]] + cur / radix\n        #     print(cur)\n        #     if cur >= val:\n        #         lo, val = i, cur\n        # return s[lo:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # loop to find the max lexicographic  \n        # substring in the substring array \n        # l = \\\"\\\" \n        # for i in range(len(s)-1,-1,-1): \n        #     l = max(l, s[i:]) \n        #     print(s[i:])\n        # return l\n       \n        if len(set(s)) == 1:\n            return s \n        idx = len(s) - 1\n        for i in range(len(s)-2, -1, -1):\n            k = 0\n            while idx+k < len(s):\n                cur, stored = ord(s[i+k]), ord(s[idx+k])\n                if cur > stored:\n                    idx = i\n                    break\n                elif cur < stored:\n                    break\n                k += 1\n            if idx+k == len(s):\n                idx = i\n        return s[idx:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        # c = s[0]\n        # for num in range(len(s)):\n        #     if s[num] > c:\n        #         i = num\n        #         c = s[num]\n        j = i + 1\n        k = 0\n        \n        while j + k < len(s):\n            if s[i+k] == s[j+k]:\n                k += 1\n            elif s[i+k] > s[j+k]:\n                j += k + 1\n                k = 0\n            else:\n                i = j\n                j = i + 1\n                k = 0\n                \n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0\n        while i + offset < len(s) and j + offset < len(s):\n            if s[i + offset] == s[j + offset]:\n                offset += 1\n            else:\n                if s[i + offset] < s[j + offset]:\n                    i += offset + 1\n                else:\n                    j += offset + 1\n                if i == j:\n                    j += 1\n                offset = 0\n        return s[i :]\n        \n        \n        \n#         maxchar = 'a'\n#         index = []\n        \n#         for i in range(len(s)):\n#             if s[i] > maxchar:\n#                 maxchar = s[i]\n#                 index.append(i)\n#         # print(index)\n#         maxstring = \\\"\\\"\n        \n#         for i in range(len(index)):\n#             if s[index[i]:] > maxstring:\n#                 maxstring = s[index[i]:]\n                \n#         return maxstring\n        \n        \n        \n        \n#         m = \\\"\\\" \n#         for i in range(len(s)): \n#             m = max(m, s[i:]) \n  \n#         return m\n\n\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:      \n        c, n = max(s), len(s)\n        if s == c*n:\n            return s\n        \n        q = [i for i, e in enumerate(s) if e == c]\n        res = s[q[0]]\n        while q:\n            qq = []\n            for i in q:\n                if i+1 < n:\n                    qq += [i+1]\n            if not qq:\n                break\n            c = max(s[i] for i in qq)\n            res += c\n            q = [i for i in qq if s[i] == c]\n        \n        return res        ", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i,j, offset = 0,1,0\n        \n        \n        while (i+offset < len(s)) and (j+offset < len(s)):\n            if s[i+offset] == s[j+offset]:\n                offset += 1\n            else:\n                if s[i+offset] < s[j+offset]:\n                    i += offset +1\n                elif s[i+offset] > s[j+offset]:\n                    j += offset + 1\n                \n                if i == j:\n                    i += 1\n                offset = 0\n        loc = min(i,j)\n        return s[loc:]\n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        c = s[0]\n        for num in range(len(s)):\n            if s[num] > c:\n                i = num\n                c = s[num]\n        j = i + 1\n        k = 0\n        \n        while j + k < len(s):\n            if s[i+k] == s[j+k]:\n                k += 1\n            elif s[i+k] > s[j+k]:\n                j += k + 1\n                k = 0\n            else:\n                i = j\n                j = i + 1\n                k = 0\n                \n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        c, n = max(s), len(s)\n        if s == c*n:\n            return s\n        \n        q = [i for i, e in enumerate(s) if e == c]\n        res = s[q[0]]\n        while q:\n            qq = []\n            for i in q:\n                if i+1 < n:\n                    qq += [i+1]\n            if not qq:\n                break\n            c = max(s[i] for i in qq)\n            res += c\n            q = [i for i in qq if s[i] == c]\n        \n        return res        ", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0        \n        while j+k < len(s):\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j+k+1\n            else:\n                i = max(i+k+1, j)\n                j = i+1\n            k = 0\n        return s[i:]", "class Solution:       \n    def lastSubstring(self, s: str) -> str:\n        curr_value = 0\n        max_value = 0\n        max_idx = 0\n        char_to_id = {c: i for i, c in enumerate(sorted(set(s)))}\n        \n        for i in range(len(s) - 1, -1, -1):\n            curr_value = char_to_id[s[i]] + curr_value / len(char_to_id) # Note, uses floating point.\n\n            if curr_value > max_value:\n                max_value = curr_value\n                max_idx = i\n\n        return s[max_idx:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # i: starting index of the first substring\n        i = 0\n        # j: starting index of the second substring\n        j = 1\n        # k: length of substring\n        k = 0\n        \n        # the answer must be a consecutive substring start of biggest char\n        # if j find better starting index, use it to update i\n        n = len(s)\n        \n        while j+k < n:\n            ## cannot compare now, compare at next char\n            if s[i+k] == s[j+k]:\n                k+=1\n                continue\n            ## i is bigger, j should find next candidate\n            elif s[i+k] > s[j+k]:\n                j = j+k+1\n            else:\n            ## j is bigger, i should find next candidate\n                i = i+k+1\n            if i == j:\n            ## update i with j, j keep searching\n                j += 1\n            k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        \n        while j + k < len(s):\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i + k] > s[j + k]:\n                j = j + 1\n            elif s[i + k] < s[j + k]:\n                i = i + 1\n            if i == j:\n                j = j + 1\n            k = 0\n            \n        \n        return s[i:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        while j + k < len(s):\n            if s[i + k] == s[j + k]:\n                k += 1\n                continue\n            if s[i + k] > s[j + k]:\n                j = j + k + 1\n            else:\n                i = max(i + k + 1, j)\n                j = i + 1\n            k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s):\n        i, j, inc = 0, 1, 0\n        while j + inc < len(s):\n          if i + inc == j:\n            j = j + inc\n            inc = 0\n          elif s[j + inc] > s[i]:\n            i = j + inc\n            j = i + 1\n            inc = 0\n          elif s[i + inc] == s[j + inc]:\n            inc += 1\n          elif s[i + inc] < s[j + inc]:\n            i = j\n            j += 1\n            inc = 0\n          else:\n            j += max(inc, 1)\n            inc = 0\n        return s[i:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0\n        while i + offset < len(s) and j + offset < len(s):\n            if s[i + offset] == s[j + offset]:\n                offset += 1\n            else:\n                if s[i + offset] < s[j + offset]:\n                    i += offset + 1\n                else:\n                    j += offset + 1\n                if i == j:\n                    i += 1\n                offset = 0\n        return s[min(i, j):]\n    \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        n = len(s)\n        while j + k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n                i = i + k + 1\n            if i == j:\n                j = j + 1\n            k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:  \n        n = len(s)\n        max_char = max(s)\n        max_index = None\n        for i, x in enumerate(s):\n            if x == max_char:\n                if max_index is None:\n                    max_index = i\n                elif i>0 and s[i-1] != max_char:\n                    cand1 = max_index+1\n                    cand2 = i+1\n                    while cand2 < n and s[cand1] == s[cand2]:\n                        cand1 += 1\n                        cand2 += 1\n                    if cand2 == n: \n                        continue\n                    if s[cand1] < s[cand2]:\n                        max_index = i\n        return s[max_index:]\n                    \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        candidate_indices = list(range(len(s)))\n        offset = 0\n        \n        while len(candidate_indices) > 1:\n            current_max = max([s[candidate + offset] for candidate in candidate_indices if candidate + offset < len(s)])\n            new_candidates = []\n            \n            for i, candidate in enumerate(candidate_indices):\n            \n                if i >= 1 and candidate_indices[i - 1] + offset == candidate:\n                    # Swallow\n                    continue\n                \n                if candidate + offset >= len(s):\n                    break\n                \n                if s[candidate + offset] == current_max:\n                    new_candidates.append(candidate)\n                \n            \n            candidate_indices = new_candidates\n            offset += 1\n        \n        return s[candidate_indices[0]:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        n = len(s)\n        while j + k < n:\n            if s[i + k] == s[j + k]:\n                k += 1\n                continue\n            elif s[i + k] < s[j + k]:\n                i = max(j, i + k + 1)\n                j = i + 1\n                k = 0\n            else:\n                j += 1 \n                k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0\n        while i + offset < len(s) and j + offset < len(s):\n            if s[i + offset] == s[j + offset]:\n                offset += 1\n            else:\n                if s[i + offset] < s[j + offset]:\n                    i += offset + 1\n                else:\n                    j += offset + 1\n                if i == j:\n                    j += 1\n                offset = 0\n        return s[i :]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, indexes = 0, list(range(len(s)))\n        while len(indexes) > 1:\n            new = []\n            mx = max([s[i + j] for j in indexes if i + j < len(s)])\n            for k, j in enumerate(indexes):\n                if k - 1 >= 0 and indexes[k - 1] + i == j:\n                    continue\n                if i + j >= len(s):\n                    break\n                if s[i + j] == mx:\n                    new.append(j)\n            i += 1\n            indexes = new\n        return s[indexes[0]:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # Keep track of the candidates for the maximum substring\n        # then compare the next characters of the current candidates\n        # and update the candidates list in which all candidates are equally likely to be the maximum subtring\n        # if the length of the candidates list is equal to 1, then the candidate is the maximum subtstring\n        \n        candidate_indices = list(range(len(s))) # at the start, every substring is a candidate \n        index_offset = 0 # will be used to compare the next characters of the candidates\n        \n        while len(candidate_indices) > 1:  # Loop until we have more than one candidate\n            # Using Python List Comprehension to find the maximum of the next char of the candidate\n            current_max = max([s[candidate + index_offset] for candidate in candidate_indices if candidate + index_offset < len(s)])\n            \n            new_candidates = [] # used to update the candidates list\n            \n            # Find the starting index of the current_max character, i.e., finding the new list of candidates\n            for i, candidate in enumerate(candidate_indices):\n                \n                # if the last char of the previous candidate is the start of the current candidate,\n                # merge them together as one candidate\n                if i > 0 and candidate_indices[i - 1] + index_offset == candidate: \n                    continue # Do not need to add the current candidate as the previous is added\n                \n                if candidate + index_offset > len(s) - 1: # we are out of bounds, need to break the loop\n                    break\n                \n                if s[candidate + index_offset] == current_max: # found the candidate which has the current_max\n                    new_candidates.append(candidate) # append the starting index of the current best candidate\n            \n            candidate_indices = new_candidates # Update the candidates\n            index_offset += 1 # Consider the next character\n        \n        # if we are here, it means we have only one candidate, which is the starting index of the maximum substring \n        return s[candidate_indices[0]:] \n            \n\n\n\n#         # The Naive Solution\n#         # Keep track of the maximum string in a separate variable\n#         # Do this for every character at index `i`  in string `s` like the following: s[i:]\n#         # The drawback: string comparison takes O(n) time, and we need to do for every string\n#         # starting with character at index `i`. So the overall time complexity would be\n#         # O(n^2) - which is not good.\n        \n#         max_substring = \\\"\\\" # max_substring means the last substring in lexicographical order\n        \n#         for i in range(len(s)): # iterate over every character in the string\n#             max_substring = max(s[i:], max_substring) # update the maximum substring if the new subtring is greater\n        \n#         return max_substring # return the maxium substring\n", "# class Solution:\n#     def lastSubstring(self, s: str) -> str:\n#         #\u7ed9\u7684\u63d0\u793a\u662f\u7528\u540e\u7f00\u6811\n#         #\u56e0\u4e3a\u5fc5\u5b9a\u662f\u540e\u7f00\u624d\u6ee1\u8db3\u6700\u540e\u4e00\u4e2a\u5b57\u5178\u5e8f\n#         #\u5f53\u7136\u4e5f\u5305\u62ec\u5b83\u672c\u8eab\n#         #\u5b57\u5178\u5e8f\u5c31\u662f\u4e0b\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u6570\u6216\u8005\u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u6709\u73af\uff0c\u73af\u9996\u662f\u6700\u5c0f\u7684\n        \n        \n        \n        \nclass Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, indexes = 0, list(range(len(s)))\n        while len(indexes) > 1:\n            new = []\n            mx = max([s[i + j] for j in indexes if i + j < len(s)])\n            for k, j in enumerate(indexes):\n                if k - 1 >= 0 and indexes[k - 1] + i == j:\n                    continue\n                if i + j >= len(s):\n                    break\n                if s[i + j] == mx:\n                    new.append(j)\n            i += 1\n            indexes = new\n        return s[indexes[0]:]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         graph = defaultdict(list)\n#         cur = 'a'\n#         for idx, val in enumerate(s):\n#             if cur < val:\n#                 cur = val\n#             graph[val].append(idx)\n        \n#         maxstartst = graph[cur]\n#         rt = ''\n#         nxt = ord(cur)\n#         end = ord('a')\n#         while nxt >= end:\n#             nxtchar = chr(nxt)\n#             if nxtchar in graph:\n#                 for item in graph[nxtchar]:\n#                     temp = bisect.bisect_right(maxstartst, item-1)\n#                     if maxstartst[temp-1] == item -1:\n#                         return s[maxstartst[temp-1]:]\n            \n#             nxt-=1\n\n#         return rt\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # Keep track of the candidates for the maximum substring\n        # then compare the next characters of the current candidates\n        # and update the candidates list in which all candidates are equally likely to be the maximum subtring\n        # if the length of the candidates list is equal to 1, then the candidate is the maximum subtstring\n        \n        candidate_indices = list(range(len(s))) # at the start, every substring is a candidate \n        index_offset = 0 # will be used to compare the next characters of the candidates\n        \n        while len(candidate_indices) > 1:  # Loop until we have more than one candidate\n            # Using Python List Comprehension to find the maximum of the next char of the candidate\n            current_max = max([s[candidate + index_offset] for candidate in candidate_indices if candidate + index_offset < len(s)])\n            \n            new_candidates = [] # used to update the candidates list\n            \n            # Find the starting index of the current_max character, i.e., finding the new list of candidates\n            for i, candidate in enumerate(candidate_indices):\n                \n                # if the last char of the previous candidate is the start of the current candidate,\n                # merge them together as one candidate\n                if i > 0 and candidate_indices[i - 1] + index_offset == candidate: \n                    continue # Do not need to add the current candidate as the previous is added\n                \n                if candidate + index_offset > len(s) - 1: # we are out of bounds, need to break the loop\n                    break\n                \n                if s[candidate + index_offset] == current_max: # found the candidate which has the current_max\n                    new_candidates.append(candidate) # append the starting index of the current best candidate\n            \n            candidate_indices = new_candidates # Update the candidates\n            index_offset += 1 # Consider the next character\n        \n        # if we are here, it means we have only one candidate, which is the starting index of the maximum substring \n        return s[candidate_indices[0]:]\n        \n        # TIME and SPACE Complexities: O(n), where n - the length of the string\n            \n\n\n\n#         # The Naive Solution\n#         # Keep track of the maximum string in a separate variable\n#         # Do this for every character at index `i`  in string `s` like the following: s[i:]\n#         # The drawback: string comparison takes O(n) time, and we need to do for every string\n#         # starting with character at index `i`. So the overall time complexity would be\n#         # O(n^2) - which is not good.\n        \n#         max_substring = \\\"\\\" # max_substring means the last substring in lexicographical order\n        \n#         for i in range(len(s)): # iterate over every character in the string\n#             max_substring = max(s[i:], max_substring) # update the maximum substring if the new subtring is greater\n        \n#         return max_substring # return the maxium substring\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, indexes = 0, list(range(len(s)))\n        while len(indexes) > 1:\n            new = []\n            mx = max([s[i + j] for j in indexes if i + j < len(s)])\n            for k, j in enumerate(indexes):\n                if k - 1 >= 0 and indexes[k - 1] + i == j:\n                    continue\n                if i + j >= len(s):\n                    break\n                if s[i + j] == mx:\n                    new.append(j)\n            i += 1\n            indexes = new\n        return s[indexes[0]:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        slow,compareCnt,n=0,0,len(s)\n        for fast in range(1,n):\n            if s[fast]!=s[slow+compareCnt] or slow+compareCnt==fast-compareCnt-1:\n                if s[fast]>s[slow+compareCnt]:\n                    slow=fast if s[fast]>s[slow] else fast-compareCnt\n                compareCnt=0\n            else:\n                compareCnt+=1\n        return s[slow:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        step = 0\n        index = [i for i in range(len(s))]\n\n        biggest_letter = 'a'\n        for i in index:\n            if s[i + step] > biggest_letter:\n                biggest_letter = s[i + step]\n\n        buff_index = []\n        for i in index:\n            if (s[i + step] == biggest_letter) & (i + step < len(s)):\n                if i==0:\n                    buff_index.append(i)\n                if  ((i!=0) and (s[i-1]!=s[i])):\n                    buff_index.append(i)\n        index = buff_index\n        step += 1\n\n\n        while (len(index) > 1):\n            biggest_letter = 'a'\n            for i in index:\n                if i+step < len(s):\n                    if s[i+step] > biggest_letter:\n                        biggest_letter = s[i+step]\n\n            buff_index = []\n            for i in index:\n                if i + step < len(s):\n                    if (s[i+step] == biggest_letter) & (i+step<len(s)):\n                        buff_index.append(i)\n\n            index = buff_index\n\n            step += 1\n\n\n        res = s[index[0]:len(s)]\n\n        return res", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, indexes = 0, list(range(len(s)))\n        \n        \n        while len(indexes) > 1:\n            new = []\n            mx = max([s[i + j] for j in indexes if i + j < len(s)])\n            print(mx)\n            for k, j in enumerate(indexes):\n                if k - 1 >= 0 and indexes[k - 1] + i == j:\n                    continue\n                if i + j >= len(s):\n                    break\n                if s[i + j] == mx:\n                    new.append(j)\n            i += 1\n            indexes = new\n        return s[indexes[0]:]", "class Solution:\n    # build the suffix tree of the string and traverse the tree by always pick the right most branch.\n    def lastSubstring(self, s: str) -> str:\n        class TreeNode:\n            def __init__(self):\n                self.children = collections.defaultdict()\n\n        # build the suffix tree\n        root = TreeNode()\n        for start in range(len(s)):\n            node = root\n            for c in s[start:]:\n                if c not in node.children:\n                    node.children[c] = TreeNode()\n                node = node.children[c]\n        # traverse the tree\n        res = ''\n        node = root\n        while node and len(node.children) > 0:\n            for i in range(25, -1, -1):  # find the rightmost available branch\n                c = chr(ord('a') + i)\n                if c in node.children:\n                    node = node.children[c]\n                    res += c\n                    break\n        return res\n    \n    # It can be seen that the last substring in lexicographical order is always a suffix of the string.\n    # Start with all possible suffix strings. Each time eliminate the ones not started from the largest letter.\n    # Continue until there is only one distinct letter.\n    def lastSubstring(self, s: str) -> str:\n        i, indexes = 0, list(range(len(s)))\n        while len(indexes) > 1:\n            new = []\n            mx = max([s[i + j] for j in indexes if i + j < len(s)])\n            for k, j in enumerate(indexes):\n                if k - 1 >= 0 and indexes[k - 1] + i == j:\n                    continue\n                if i + j >= len(s):\n                    break\n                if s[i + j] == mx:\n                    new.append(j)\n            i += 1\n            indexes = new\n        return s[indexes[0]:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        starts = list(range(len(s)))\n        offset = 0\n        while len(starts) > 1:\n            newstarts = []\n            end = max(s[start + offset] for start in starts if start + offset < len(s))\n            for i, ch in enumerate(starts):\n                if i > 0 and starts[i - 1] + offset == starts[i]:\n                    continue\n                if ch + offset == len(s):\n                    break\n                if s[ch + offset] == end:\n                    newstarts.append(ch)\n            offset += 1\n            starts = newstarts\n        return s[starts[0]:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, indexes = 0, list(range(len(s)))\n        while len(indexes) > 1:\n            new = []\n            mx = max([s[i + j] for j in indexes if i + j < len(s)])\n            for k, j in enumerate(indexes):\n                if k - 1 >= 0 and indexes[k - 1] + i == j:\n                    continue\n                if i + j >= len(s):\n                    break\n                if s[i + j] == mx:\n                    new.append(j)\n            i += 1\n            indexes = new\n        return s[indexes[0]:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # we will be calling this a lot\n        lenS = len(s)\n        \n        # find the lexicographically biggest character\n        largestChar = max(set(s))\n        \n        # find the start of potential max substrings and store in candidates\n        # also, make sure to ignore repeats (i.e. aaaaaaaaa.....)\n        candidateIndexes = []\n        repeating = False\n        for i in range(lenS):\n            if s[i] == largestChar:\n                if repeating == False:\n                    candidateIndexes.append(i)\n                    repeating = True\n            else:\n                repeating = False\n        \n        # go through the candidates, see which one is the best\n        bestCandidateIndex = candidateIndexes[0]\n        for i in range(1, len(candidateIndexes)):\n            counter = 1\n            index = candidateIndexes[i]\n            while bestCandidateIndex + counter < lenS and index + counter < lenS:\n                if s[index + counter] > s[bestCandidateIndex + counter]:\n                    bestCandidateIndex = index\n                    break\n                elif s[index + counter] == s[bestCandidateIndex + counter]:\n                    counter += 1\n                    continue\n                else:\n                    break\n            \n        return s[bestCandidateIndex:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        step = 0\n        index = []\n\n        biggest_letter = 'a'\n        for i in range(len(s)):\n            if s[i + step] > biggest_letter:\n                biggest_letter = s[i + step]\n\n        buff_index = []\n        for i in range(len(s)):\n            if (s[i + step] == biggest_letter) & (i + step < len(s)):\n                if i==0:\n                    buff_index.append(i)\n                if  ((i!=0) and (s[i-1]!=s[i])):\n                    buff_index.append(i)\n        index = buff_index\n        step += 1\n\n\n        while (len(index) > 1):\n            biggest_letter = 'a'\n            for i in index:\n                if i+step < len(s):\n                    if s[i+step] > biggest_letter:\n                        biggest_letter = s[i+step]\n\n            buff_index = []\n            for i in index:\n                if i + step < len(s):\n                    if (s[i+step] == biggest_letter) & (i+step<len(s)):\n                        buff_index.append(i)\n\n            index = buff_index\n\n            step += 1\n\n\n        res = s[index[0]:len(s)]\n\n        return res", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        while j + k < len(s):\n            if s[i + k] == s[j + k]:\n                k += 1\n            else:\n                if s[i + k] > s[j + k]:\n                    j = j + k + 1\n                else:\n                    i = i + k + 1\n                if i == j:\n                    j = j + 1\n                k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i,j,offset = 0,1,0\n        \n        while i+offset<len(s) and j+offset<len(s):\n            if s[i+offset]==s[j+offset]:\n                offset+=1\n                \n            else:\n                if s[i+offset]<s[j+offset]:\n                    i+=1\n                else:\n                    j+=1\n                    \n                if i==j:\n                    j+=1\n                    \n                offset=0\n                \n        return(s[i:])", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0\n        while j + offset < len(s):\n            if s[i + offset] == s[j + offset]:\n                offset += 1\n            else:\n                if s[i + offset] < s[j + offset]:\n                    i += offset + 1\n                else:\n                    j += offset + 1\n                if i == j:\n                    j += 1\n                offset = 0\n        return s[i :]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        maxchr = max(s)\n        index = []\n        maxstring = ''\n        i = 0\n        while i < len(s):\n            if s[i] == maxchr:\n                if i == 0 or s[i] != s[i-1]:\n                    index.append(i)\n                    maxstring = max(maxstring, s[i:])\n            i += 1\n        return maxstring", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        starts = list(range(n))\n        offset = 0\n        while len(starts) > 1:\n            max_end = max(s[start + offset] for start in starts if start + offset < n)\n            new_starts = []\n            for i, start in enumerate(starts):\n                if i > 1 and starts[i - 1] + offset == start:\n                    # swallow\n                    continue\n                if start + offset == n:\n                    # end of s\n                    break\n                if s[start + offset] == max_end:\n                    new_starts.append(start)\n            offset += 1\n            starts = new_starts\n        return s[starts[0]:]  ", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if len(set(s))==1:\n            return s\n        alpha=sorted(list(set(s)))\n        start=alpha[-1]\n        \n        n=len(s)\n        index=[]\n        for i,char in enumerate(s):\n            if char==start:\n                index.append(i)\n            \n        prefix=start\n        maxprefix=start\n        while len(index)>1:\n            nextindex=[]\n            for i in index:\n                if i+1<n:\n                    if prefix+s[i+1]==maxprefix:\n                        maxprefix=prefix+s[i+1]\n                        nextindex.append(i+1)\n                    elif prefix+s[i+1]>maxprefix:\n                        maxprefix=prefix+s[i+1]\n                        nextindex=[i+1]\n            prefix=maxprefix\n            index=nextindex\n        \n        \n        return maxprefix+s[index[0]+1:]\n                    \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n, pointer = len(s), 0 #pointer points to the char we're comparing in candidiates\n        starts = list(range(n)) #starts is starting points of candidates \n        while len(starts)>1: #more than one candidiate\n            max_end = max([s[start+pointer] for start in starts if start+pointer < n]) #max val for pointer\n            new_starts = [] #starts with max_end this round are filtered to compare for next round\n            for i, start in enumerate(starts):\n                if i>1 and starts[i-1]+pointer == start:\n                    continue # when prev candidate's pointer meets cur's start, cur is def less than prev\n                elif start+pointer == n:\n                    break #reaches end, no valid new new val\n                if s[start+pointer] == max_end:\n                    new_starts.append(start)\n            pointer += 1\n            starts = new_starts\n        return s[starts[0]:]\n            \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        starts = list(range(n))\n        offset = 0\n        while len(starts) > 1:\n            max_end = max(s[start + offset] for start in starts if start + offset < n)\n            new_starts = []\n            for i, start in enumerate(starts):\n                if i > 1 and starts[i - 1] + offset == start:\n                    # swallow\n                    continue\n                if start + offset == n:\n                    # end of s\n                    break\n                if s[start + offset] == max_end:\n                    new_starts.append(start)\n            offset += 1\n            starts = new_starts\n        return s[starts[0]:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        pos = defaultdict(list)\n        large = 'a'\n        for i, c in enumerate(s):\n            pos[c].append(i)\n            large = max(large, c)\n            \n        remain = set(pos[large]); sz = 1\n        #print(remain)\n        while len(remain) > 1:\n            large = ''\n            for idx in remain:\n                if idx+sz < len(s) and s[idx+sz] > large:\n                    large = s[idx+sz]\n            \n            to_remove = set()\n            for idx in remain:\n                if idx+sz in remain:\n                    to_remove.add(idx+sz)\n                if idx+sz >= len(s) or s[idx+sz] != large:\n                    to_remove.add(idx)\n            remain -= to_remove\n            sz += 1\n        idxs = [a for a in remain]\n        return s[idxs[0]:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0    \n        while i+offset<len(s) and j+offset<len(s):\n            if s[i+offset]==s[j+offset]:\n                offset+=1                \n            else:\n                if s[i+offset]<s[j+offset]:\n                    i+=offset+1\n                else:\n                    j+=offset+1\n                    \n                if i==j:\n                    j+=1\n                offset = 0\n                    \n        return(s[i:])\n    \n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n, offset = len(s), 0\n        starts = list(range(n))\n        while len(starts) > 1:\n            max_end = max(s[start + offset] for start in starts if start + offset < n)\n            new_starts = []\n            for i, start in enumerate(starts):\n                if i > 1 and starts[i - 1] + offset == start: continue\n                if start + offset == n: break\n                if s[start + offset] == max_end: new_starts += start,\n            offset += 1\n            starts = new_starts\n        return s[starts[0]:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        starts = list(range(n))\n        offset = 0\n        while len(starts) > 1:\n            max_end = max(s[start + offset] for start in starts if start + offset < n)\n            new_starts = []\n            for i, start in enumerate(starts):\n                if i > 1 and starts[i - 1] + offset == start:\n                    # swallow\n                    continue\n                if start + offset == n:\n                    # end of s\n                    break\n                if s[start + offset] == max_end:\n                    new_starts.append(start)\n            offset += 1\n            starts = new_starts\n        return s[starts[0]:] ", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # Create a suffix array, and sort it to fetch the biggest one\n#         suffix_array = []\n        \n#         for idx in range(len(s)):\n#             suffix_array.append(s[idx:])\n        \n#         suffix_array.sort()\n        \n#         return suffix_array[-1]\n        # O(n^2)\n    \n        n = len(s)\n        starts = list(range(n))\n        offset = 0\n        \n        while len(starts) > 1:\n            max_end = max(s[start + offset] for start in starts if start + offset < n)\n            new_starts = []\n            for idx, start in enumerate(starts):\n                if idx > 1 and starts[idx - 1] + offset == start:\n                    # swallow\n                    continue\n                if start + offset == n:\n                    # end of s\n                    break\n                if s[start + offset] == max_end:\n                    new_starts.append(start)\n            offset += 1\n            starts = new_starts\n        return s[starts[0]:]         \n", "# class Solution:\n#     def lastSubstring(self, s: str) -> str:\n        \n        \n#         stack = []\n#         dic = {}\n#         for i in 'abcdefghijklmnopqrstuvwxyz':\n#             dic[ord(i)] = i\n#         right = 0\n#         while right < len(s):\n#             if not stack:\n#                 stack.append(ord(s[right]))\n#             else:\n#                 if ord(s[right]) > stack[0]:\n#                     stack = []\n#                 elif ord(s[right]) == stack[0]:\n#                     index = 0\n#                     while right + index < len(s) and index < len(stack):\n#                         if ord(s[right+index]) > stack[index]:\n#                             stack = []\n#                             break\n#                         elif ord(s[right+index]) < stack[index]:\n#                             break\n                        \n#                         index += 1\n#                 stack.append(ord(s[right]))\n#             right += 1\n            \n        \n#         res = ''\n        \n#         for i in stack:\n#             res += dic[i]\n            \n#         return res\n\nclass Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s: return None\n        ## get max char from s\n        maxC, N = max(s),len(s)\n        ## get max char indexs to append into inds\n        ## only store the first ind for consecutive max chars\n        inds = [i for i in range(N) if s[i]==maxC and (i==0 or s[i-1]!=maxC)]\n        maxind = inds[0] # starting index of the max substring\n       \n        ## using for loop to compare with each substring lead by max char\n        for i in range(1,len(inds)):\n            curind = inds[i] # start index of current substring\n            step = 0 # index pointer from start index\n            ## compare the current sub with the max sub string\n            while curind+step<N:\n                if s[curind+step]>s[maxind+step]: # current sub larger than maxsub\n                    maxind = curind\n                    break\n                elif s[curind+step]==s[maxind+step]:\n                    step += 1\n                else: # s[curind+step]<s[maxind+step]: # current sub smaller than maxsub\n                    break\n                \n        return s[maxind:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        cand = list(range(len(s)))\n        ans = ''\n        step = 0\n        while len(cand) > 1:\n            nxt = []\n            tmp = None\n            for x in cand:\n                if tmp is None or ord(s[x]) > ord(tmp):\n                    tmp = s[x]\n            ans += tmp\n            for x in cand:\n                if tmp == s[x]:\n                    if x + 1 < len(s) and (len(nxt) == 0 or nxt[-1] < x - step):\n                        nxt.append(x + 1)\n            cand = nxt\n            step += 1\n        if len(cand) == 0:\n            return ans\n        return ans + s[cand[0]:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # Create a suffix array, and sort it to fetch the biggest one\n#         suffix_array = []\n        \n#         for idx in range(len(s)):\n#             suffix_array.append(s[idx:])\n        \n#         suffix_array.sort()\n        \n#         return suffix_array[-1]\n        # O(n^2)\n    \n        n = len(s)\n        offset = 0\n        cand_starts = list(range(len(s)))\n        \n        while len(cand_starts) > 1: # Find one and only start\n            max_end = 'a'\n            \n            for start in cand_starts:\n                if start + offset < n: \n                    max_end = max(max_end, s[start + offset])            \n        \n            new_starts = []\n            \n            for idx, start in enumerate(cand_starts):\n                # start is actual idx, idx is relative ordering of start points\n                # Check if previous start merges other start. In that case we wnat to merge these cases\n                    # Show ex of Ex1, Ex2\n                    if 1 < idx and cand_starts[idx - 1] + offset == start:\n                        # Previous start point collapes with new one. Merged\n                        continue\n                    \n                    if start + offset == n:\n                        break \n                        # It went over the length list. Break\n                    \n                    if s[start+offset] == max_end:\n                        new_starts.append(start)\n                        \n            cand_starts = new_starts\n            offset += 1\n                    \n            \n        \n        return s[cand_starts[0]:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        arrSize = len(s)\n        suffArr = []\n        \n        # first construct a suffix array\n        for i in s:\n            suffArr.append(ord(i))\n            \n        if (len(list(set(suffArr)))) == 1:\n            print((len(s)))\n            return s\n            \n        sumArr = [0] * arrSize\n        sumArr[-1] = suffArr[-1]\n        \n        for i in range(arrSize - 2, -1, -1):\n            sumArr[i] = sumArr[i + 1] + suffArr[i]\n        \n        blockSize = 1\n        currArr = suffArr[:]\n        \n        ret = 0\n        \n        while True:\n            maxNum = max(currArr) # find the max value\n            maxInds = []\n            \n            # find all the maximum indices\n            for i in range(len(currArr)):\n                if maxNum == currArr[i]:\n                    maxInds.append(i)\n                        \n            # if there's only one entry\n            if len(maxInds) == 1:\n                return str(s[maxInds[0]:])\n            \n            blockSize += 1\n\n            # otherwise, we have to keep comparing\n            for i in maxInds:\n                if i + blockSize >= arrSize:\n                    currArr[i] = sumArr[i]    \n                else:\n                    currArr[i] = sumArr[i] - sumArr[i + blockSize]\n            \n        return None            \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        ss = list(map(lambda x: ord(x) - ord('a'), s))\n        xmax = max(ss)\n        xs = [(x, i, i + 1) for i, x in enumerate(ss) if x == xmax]\n        while len(xs) > 1:\n            xt, xmax = [], -1\n            for h, i, j in xs:\n                if ((not xt) or xt[-1][2] <= i) and j < n:\n                    if ss[j] > xmax:\n                        xt = [(h * 26 + ss[j], i, j + 1)]\n                        xmax = ss[j]\n                    elif ss[j] == xmax:\n                        xt.append((h * 26 + ss[j], i, j + 1))\n                    xs = xt\n        return s[xs[0][1]:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        lastc = max(s)\n        n = len(s)\n        q = [i for i,val in enumerate(s) if val==lastc]\n        if len(q) == len(s):\n            return s\n        res = s[q[0]]\n        while q:\n            qq = []\n            for i in q:\n                if i+1 < n:\n                    qq += [i+1]\n            if not qq:\n                break\n            c = max(s[i] for i in qq)\n            res += c\n            q = [i for i in qq if s[i] == c]\n        \n        return res\n    # def lastSubstring(self, s: str) -> str:\n    # \\tS, L, a = [ord(i) for i in s] + [0], len(s), 1\n    # \\tM = max(S)\n    # \\tI = [i for i in range(L) if S[i] == M]\n    # \\tif len(I) == L: return s\n    # \\twhile len(I) != 1:\n    # \\t\\tb = [S[i + a] for i in I]\n    # \\t\\tM, a = max(b), a + 1\n    # \\t\\tI = [I[i] for i, j in enumerate(b) if j == M]\n    # \\treturn s[I[0]:]\n        \n        #ans = [s[i:] for i in lead]\n        # print(ans)\n        # start = s.index(lastc)\n        # while s[start]:\n        #     print(start)\n        #     ans.append(s[start:])\n        #     print(ans)\n        #     if s[start+1:].count(lastc) == 0:\n        #         break\n        #     else:\n        #         start += s[start+1:].index(lastc) + 1\n        # print(ans)\n        return sorted(ans)[-1]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        offset = 0\n        cand_starts = list(range(len(s)))\n        \n        while len(cand_starts) > 1: # Find one and only start\n            max_end = 'a'\n            \n            for start in cand_starts:\n                if start + offset < n: \n                    max_end = max(max_end, s[start + offset])            \n        \n            new_starts = []\n            \n            for idx, start in enumerate(cand_starts):\n                # start is actual idx, idx is relative ordering of start points\n                # Check if previous start merges other start. In that case we wnat to merge these cases\n                    # Show ex of Ex1, Ex2\n                    if 1 < idx and cand_starts[idx - 1] + offset == start:\n                        # Previous start point collapes with new one. Merged\n                        continue\n                    \n                    if start + offset == n:\n                        break \n                        # It went over the length list. Break\n                    \n                    if s[start+offset] == max_end:\n                        new_starts.append(start)\n                        \n            cand_starts = new_starts\n            offset += 1\n                    \n            \n        \n        return s[cand_starts[0]:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max_letter = max(s)\n        pre_letter = None\n        \n        current_max = max_letter\n        for i, c in enumerate(s):\n            if c == max_letter and pre_letter != c:\n                current_max = max(current_max, s[i:])\n            pre_letter = c\n            \n        \n        return current_max", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s: return None\n        ## get max char from s\n        maxC, N = max(s),len(s)\n        ## get max char indexs to append into inds\n        ## only store the first ind for consecutive max chars\n        inds = [i for i in range(N) if s[i]==maxC and (i==0 or s[i-1]!=maxC)]\n        maxind = inds[0] # starting index of the max substring\n        \n        for i in range(1, len(inds)):\n            cur_sub_start = inds[i]\n            pointer = 0\n            while cur_sub_start + pointer < N:\n                if s[cur_sub_start + pointer] > s[maxind + pointer]:\n                    maxind = inds[i]\n                    break\n                elif s[cur_sub_start + pointer] == s[maxind + pointer]:\n                    pointer += 1\n                else:\n                    break\n        return s[maxind:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0\n        while i + offset < len(s) and j + offset < len(s):\n            if s[i + offset] == s[j + offset]:\n                offset += 1\n            else:\n                if s[i + offset] < s[j + offset]:\n                    i += offset + 1\n                else:\n                    j += offset + 1\n                if i == j:\n                    j += 1\n                offset = 0\n        return s[i :]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i,j,k=0,1,0\n        n=len(s)\n        while j+k<n:\n            \n            if s[i+k]==s[j+k]:\n                k+=1\n                continue\n            elif s[i+k]>s[j+k]:\n                j=j+k+1\n            else:\n                # i=max(j,i+k+1)\n                i = i+k+1\n                j=i+1\n            k=0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        n = len(s)\n        while j + k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n                i = i + k + 1\n                j = i + 1\n            k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # sort of like a sliding window, where length is substr / window size\n        left, right, length = 0, 1, 0\n        n = len(s)\n        while right + length < n:\n            # print(left, right, length)\n            # print(s[left + length], s[right + length])\n            if s[left + length] == s[right + length]:\n                # substrings so far are the same\n                length += 1\n            elif s[left + length] > s[right + length]:\n                # first substring is more optimal, capture entire\n                # left substring + right substrings\n                right += length + 1\n                length = 0\n            else:\n                # right substring is more optimal\n                # left = max(left + length + 1, right) # this is confusing\n                left += length + 1\n                # aabc\n                # lr, length 1\n                # lr, length 2 -> aa and ab -> advance to left + length + 1\n                # aaabc\n                # lr, length 3 -> aaa and aab -> \n                \n                right = left + 1\n                length = 0\n                \n        return s[left:]\n        \n        \n        \n        \n        \n        \n        \n        # this is slow..\n#         n = len(s)\n#         answer = \\\"\\\"\n        \n#         for i in range(n):\n#             # can't hurt to just go all the way to the end of the string\n#             answer = max(answer, s[i:])\n\n#         return answer\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        offset = 0\n        cand_starts = list(range(len(s)))\n        \n        while len(cand_starts) > 1: # Find one and only start\n            max_end = 'a'\n            \n            for start in cand_starts:\n                if start + offset < n: \n                    max_end = max(max_end, s[start + offset])            \n        \n            new_starts = []\n            \n            for idx, start in enumerate(cand_starts):\n                # start is actual idx, idx is relative ordering of start points\n                # Check if previous start merges other start. In that case we wnat to merge these cases\n                    # Show ex of Ex1, Ex2\n                    if 1 < idx and cand_starts[idx - 1] + offset == start:\n                        # Previous start point collapes with new one. Merged\n                        continue\n                    \n                    if start + offset == n:\n                        break \n                        # It went over the length list. Break\n                    \n                    if s[start+offset] == max_end:\n                        new_starts.append(start)\n                        \n            cand_starts = new_starts\n            offset += 1\n                    \n            \n        \n        return s[cand_starts[0]:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # Algorithm\n        # First look for the max letter starting points\n        i, j, k = 0, 1, 0\n        N = len(s)      \n        \n        while j + k < N:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j+k+1\n            else:\n                i = i+k+1\n                j = i+1\n            k = 0\n        return s[i:]\n#         max_letter = None\n#         indexes = []\n#         for i, c in enumerate(s):\n#             if max_letter is None or c > max_letter:\n#                 max_letter = c\n#                 indexes = [(i, i+1)]\n#             elif max_letter == c:\n#                 indexes.append((i, i+1))\n                \n#         # Now we iterate over them like a queue\n#         while len(indexes) != 1:\n#             new_indexes = []\n#             new_max_letter = None\n            \n#             for tup in indexes:\n#                 if tup[1] >= len(s):\n#                     continue\n                          \n#                 if new_max_letter is None or s[tup[1]] > new_max_letter:\n#                     new_indexes = [(tup[0], tup[1] + 1)]\n#                     new_max_letter = s[tup[1]]\n#                 elif s[tup[1]] == new_max_letter:\n#                     new_indexes.append((tup[0], tup[1] + 1))\n#             indexes = new_indexes\n        \n#         return s[indexes[0][0]:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        if len(s)==1:return s\n        \n        res=[]\n        \n        max_char=s[0]\n        res.append(0)\n        i=1\n        while i<=len(s)-1:\n            if s[i]>max_char:\n                res=[i]\n                max_char=s[i]\n            elif s[i]==max_char:\n                if s[i-1] != max_char:res.append(i)\n            i+=1\n        \n        while len(res)>1:\n            p0=res[0]\n            p1=res[1]\n            count=1\n            while p0+count<p1:\n                if p1+count>len(s)-1:\n                    return s[res[0]:]\n                if s[p0+count]>s[p1+count]:\n                    res.pop(1)\n                    break\n                elif s[p0+count]<s[p1+count]:\n                    res.pop(0)\n                    break\n                else:count+=1\n            if p0+count==p1: res.pop(1)\n         \n        return s[res[0]:]\n                \n            \n            \n                    \n            \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        n = len(s)\n        while j + k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n               # i = max(i + k + 1, j)\n                i = i+k+1\n                j = i + 1\n            k = 0\n        return s[i:]\n", "# class Solution:\n#     def lastSubstring(self, s: str) -> str:\n        \n        \n#         stack = []\n#         dic = {}\n#         for i in 'abcdefghijklmnopqrstuvwxyz':\n#             dic[ord(i)] = i\n#         right = 0\n#         while right < len(s):\n#             if not stack:\n#                 stack.append(ord(s[right]))\n#             else:\n#                 if ord(s[right]) > stack[0]:\n#                     stack = []\n#                 elif ord(s[right]) == stack[0]:\n#                     index = 0\n#                     while right + index < len(s) and index < len(stack):\n#                         if ord(s[right+index]) > stack[index]:\n#                             stack = []\n#                             break\n#                         elif ord(s[right+index]) < stack[index]:\n#                             break\n                        \n#                         index += 1\n#                 stack.append(ord(s[right]))\n#             right += 1\n            \n        \n#         res = ''\n        \n#         for i in stack:\n#             res += dic[i]\n            \n#         return res\n\nclass Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s: return None\n        ## get max char from s\n        maxC, N = max(s),len(s)\n        ## get max char indexs to append into inds\n        ## only store the first ind for consecutive max chars\n        inds = [i for i in range(N) if s[i]==maxC and (i==0 or s[i-1]!=maxC)]\n        print(inds)\n        maxind = inds[0] # starting index of the max substring\n       \n        ## using for loop to compare with each substring lead by max char\n        for i in range(1,len(inds)):\n            curind = inds[i] # start index of current substring\n            step = 0 # index pointer from start index\n            ## compare the current sub with the max sub string\n            while curind+step<N:\n                if s[curind+step]>s[maxind+step]: # current sub larger than maxsub\n                    maxind = curind\n                    break\n                elif s[curind+step]==s[maxind+step]:\n                    step += 1\n                else: # s[curind+step]<s[maxind+step]: # current sub smaller than maxsub\n                    break\n                \n        return s[maxind:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        split = []\n        cur = [s[0], 0]\n        for i in range(1, len(s)):\n            if ord(s[i]) > ord(s[i-1]):\n                split.append(cur)\n                cur = [s[i], i]\n            else:\n                cur[0] += s[i]\n        split.append(cur)\n        split = sorted(split, key=lambda x: x[0], reverse=True)\n        return s[split[0][1]:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if len({l for l in s})==1: return s\n        arr = self.sort_bucket(s, (i for i in range(len(s))), 1)\n        return s[arr[-1]:]\n\n    def sort_bucket(self, s, bucket, order):\n        d = defaultdict(list)\n        for i in bucket:\n            key = s[i:i+order]\n            d[key].append(i)\n        result = []\n        for k, v in sorted(d.items()):\n            if len(v) > 1:\n                result += self.sort_bucket(s, v, order*2)\n            else:\n                result.append(v[0])\n        return result", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s: return ''\n        if len(set(s)) == 1: return s\n        largest = max(list(s))\n        currmax = ''\n        for i,c in enumerate(s):\n            if c == largest:\n                if s[i:] > currmax:\n                    currmax = s[i:]       \n        return currmax\n            \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        j = 1\n        k = 0\n        n = len(s)\n        \n        while j+k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n                i = max(i+k+1, j)\n                j = i + 1\n            k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        c = s[0]\n        for num in range(len(s)):\n            if s[num] > c:\n                i = num\n                c = s[num]\n        j = i + 1\n        k = 0\n        \n        while j + k < len(s):\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j += k + 1\n            else:\n                i += k + 1\n                j = i + 1\n            k = 0\n                \n        return s[i:]", "def analize(arr):\n    curstr = 1;\n    streaks = {}\n    strstart = arr[0]\n    for ii,val in enumerate(arr[:-1]):\n        if arr[ii]==arr[ii+1]-1:\n            curstr +=1\n        else:\n            streaks[strstart] = curstr\n            strstart = arr[ii+1]\n            curstr = 1\n    streaks[strstart] = curstr\n    maxstr = max(streaks.values())\n    return([(ii,maxstr) for ii in streaks if streaks[ii]==maxstr])\n\nclass Solution:\n    def lastSubstring(self, s: str) -> str:\n        index = {}\n        for char in set(s):\n            index[char] = [ic for ic,cc in enumerate(s) if cc == char]             \n#        print(index)\n#        return 'a'\n        maxchar = max(index.keys())    \n        front = analize(index[maxchar])\n        curbest = ''\n#        print(front,len(s))\n        while front!=[]:\n            curbest = curbest+s[front[0][0]]*front[0][1]\n            nxt = [s[u[0]+u[1]] for u in front if u[0]+u[1]<len(s)]\n#            print(front,curbest,nxt)\n#            return 'a'\n            if nxt!=[]:\n                maxnxt = max(nxt)\n                front = [(u[0]+u[1],1) for u in front if u[0]+u[1]<len(s) and s[u[0]+u[1]] == maxnxt]\n            else:\n                front = []\n        return curbest            ", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        c = s[0]\n        for num in range(len(s)):\n            if s[num] > c:\n                i = num\n                c = s[num]\n        j = i + 1\n        k = 0\n        \n        while j + k < len(s):\n            if s[i+k] == s[j+k]:\n                k += 1\n            elif s[i+k] > s[j+k]:\n                j += k + 1\n                k = 0\n            else:\n                i += k + 1\n                j = i + 1\n                k = 0\n                \n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        ls=max(set(s))\n        best_symbol=s.index(ls)\n        first_symbol=best_symbol\n        f=first_symbol\n        while s[best_symbol] in s[first_symbol+1:]:\n            next_symbol=s.index(s[best_symbol],first_symbol+1)\n            next_symbol_=next_symbol\n            f_=f\n            while next_symbol_<len(s) and s[f_]==s[next_symbol_]:\n                f_+=1\n                next_symbol_+=1\n\n            if next_symbol_<len(s) and s[f_]<s[next_symbol_]:\n                f=next_symbol\n            elif next_symbol_==len(s):\n                break\n            first_symbol=next_symbol\n        return s[f:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not len(s): return s\n        temp = s[0]\n        for i in range(1,len(s)):\n            if s[i:min(i+len(temp), len(s))] > temp:\n                temp = s[i]\n            else:\n                temp += s[i]\n        return temp\n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not len(s): return s\n        temp = s[0]\n        for i in range(1,len(s)):\n            # print(i, temp, \\\"blah\\\")\n            # print(i, s[i:min(i+len(temp), len(s))])\n            if s[i:min(i+len(temp), len(s))] > temp:\n                temp = s[i]\n            else:\n                temp += s[i]\n        # print(temp)\n        return temp\n        \n", "class Solution:  \n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0\n        while i + offset < len(s) and j + offset < len(s):\n            if s[i + offset] == s[j + offset]:\n                offset = offset + 1\n            else:\n                if s[i + offset] < s[j + offset]:\n                    i = i + offset + 1\n                    j = i + 1\n                else:\n                    j  = j + offset + 1\n                offset = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        index={c:i for i,c in enumerate(sorted(set(s)))}\n        radix,opt,curr,i_0=len(index),0,0,0\n        for i in range(len(s)-1,-1,-1):\n            curr=index[s[i]]+curr/radix\n            if curr>opt:\n                opt,i_0=curr,i\n                \n        return s[i_0:]\n                \n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        #from itertools import permutations \n        #print(''.join(p) for p in permutations(s))\n        i,j,k=0,1,0\n        n=len(s)\n        while j+k<n:\n            \n            if s[i+k]==s[j+k]:\n                k+=1\n                continue\n            elif s[i+k]>s[j+k]:\n                j=j+k+1\n            else:\n                i=max(j,i+k+1)\n                j=i+1\n            k=0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max_char = s[0]\n        for i in range(len(s)):\n            if s[i] > max_char:\n                max_char = s[i]\n            \n        cands = []\n        for i in range(len(s)):\n            if s[i] == max_char:\n                cands.append((i+1, i))\n\n        while len(cands) > 1:\n            new_cands = []\n            max_char = s[cands[0][0]]\n            for i in range(len(cands)):\n                if cands[i][0] < len(s) and s[cands[i][0]] > max_char: #\n                    max_char = s[cands[i][0]]\n            \n            i = 0\n            while i < len(cands):\n                if cands[i][0] < len(s) and s[cands[i][0]] == max_char:\n                    new_cands.append((cands[i][0]+1, cands[i][1]))\n                if i < len(cands)-1 and cands[i][0] == cands[i+1][1]:\n                    i += 2\n                else:\n                    i += 1\n                #if cands[i][0]+1 < len(s) and s[cands[i][0]+1] == max_char:\n                #    if i>0 and cands[i-1][0]+1 < cands[i][1]:\n                #        continue\n                #    new_cands.append((cands[i][0]+1, cands[i][1]))\n            '''\n            skip = False\n            for i in range(len(cands)):\n                if cands[i][0]+1 < len(s) and s[cands[i][0]+1] == max_char:\n                    if skip == True:\n                        skip = False\n                        continue\n                    if i>len(cands)-1 and cands[i][0]+1 >= cands[i+1][1]:\n                        skip = True\n                    new_cands.append((cands[i][0]+1, cands[i][1]))\n            '''\n            cands = new_cands\n        \n        return s[cands[0][1]:] #", "class Solution:  \n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0\n        while i + offset < len(s) and j + offset < len(s):\n            if s[i + offset] == s[j + offset]:\n                offset += 1\n            else:\n                if s[i + offset] < s[j + offset]:\n                    i += offset + 1\n                    j = i + 1\n                else:\n                    j += offset + 1\n                offset = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s: return None\n        ## get max char from s\n        maxC, N = max(s),len(s)\n        ## get max char indexs to append into inds\n        ## only store the first ind for consecutive max chars\n        inds = [i for i in range(N) if s[i]==maxC and (i==0 or s[i-1]!=maxC)]\n        maxind = inds[0] # starting index of the max substring\n       \n        ## using for loop to compare with each substring lead by max char\n        for i in range(1,len(inds)):\n            curind = inds[i] # start index of current substring\n            if self.compare(s[curind:], s[maxind:]):\n                maxind = curind\n                \n        return s[maxind:]\n    \n    def compare(self, s1, s2):\n        i = 0\n        while i < len(s1):\n            if s1[i] > s2[i]:\n                return True\n            elif s1[i] < s2[i]:\n                return False\n            i += 1\n        return False\n    \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        n = len(s)\n        while j + k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j+k+1\n            else:\n                i = i+k+1\n                j = i+1\n            k = 0\n        return s[i:]", "from collections import Counter\nclass Solution:\n    def lastSubstring(self, s: str) -> str:\n        d=Counter(s)\n        if(len(d)==1):return s\n        c=sorted(d.keys())[-1]\n        i=0\n        while(s[i]!=c):i+=1\n        if(d[c]==1):return s[i:]\n        ans=s[i:]\n        i+=1\n        while(i<len(s)):\n            if(s[i]==c and s[i:]>ans):ans=s[i:]\n            i+=1\n        return ans\n", "'''\ncase 1:\n   a b ...\n   i j    => change i to j , j to j+1\ncase 2:\n    cbacbd\n    i  j => i==j compare next one\n    c b   a  c  b   d\n    i i+1    j  j+1  => i==j compare next one\n    i=2 < j+2\n    i = j \n    j = new_i+1 why? allelemnts are smaller than original i \n\n'''\nclass Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0,1,0\n        while j+k < len(s):\n            if s[i+k] > s[j+k]:\n                j = j+k+1\n                k = 0\n            elif s[i+k] == s[j+k]:\n                k += 1\n            else:\n                i = max(i + k + 1, j)\n                j = i+1\n                k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max_idx = 0\n        for i in range(1,len(s)):\n            it = s[i]\n            max_s = s[max_idx]\n            if it >= max_s:\n                j = 2\n                while(it==max_s):\n                    it = s[i:i+j]\n                    max_s = s[max_idx:max_idx+j]\n                    if i + j == len(s) + 1:\n                        if it > max_s:\n                            max_idx = i\n                        return s[max_idx:]\n                    j += 1\n                if it>max_s:\n                    max_idx = i\n\n        return s[max_idx:]\n\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        i,j,k = 0,1,0\n        while j + k < n:\n            if s[i:i+k+1] == s[j:j+k+1]:\n                k += 1\n            elif s[i:i+k+1] < s[j:j+k+1]:\n                i = j\n                k = 0\n                j = j + 1\n            else:\n                j += k + 1\n                k = 0\n        return s[i:j+k]", "\nclass Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        n = len(s)\n        while j + k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n                i = min(i + k + 1, j)\n                j = i + 1\n            k = 0\n        return s[i:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max_ord = 0\n        if s.count(s[0])==len(s):\n            return s\n        for i in range(len(s)):\n            max_ord = max(max_ord, ord(s[i]))\n        start = chr(max_ord)\n        result = ''\n        for i in range(s.count(start)):\n            substr = s[s.find(start):]\n            result = max(result, substr)\n            s = s[s.find(start)+1:]\n        return result\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        c = max(s)\n\n        i = s.find(c)\n        r = i\n        \n        while i < len(s):\n            \n            if s[i] == c:\n                if s[r:] < s[i:]:\n                    r = i\n                while i < len(s)-1 and s[i+1] == c:\n                    i += 1\n                    \n            i += 1\n\n        return s[r:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        left, right = 0, 0\n        while right < len(s):\n            if s[right] > s[left]:\n                left = right\n            elif s[right] == s[left]:\n                if s[left: right] < s[right: right + right-left]:\n                    left = right\n                    \n            right += 1\n        \n        return s[left: right+1]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        n = len(s)\n        while j + k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n                i = max(i + k + 1, j)\n                j = i + 1\n            k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        c = max(s)\n        \n        #a = []\n        r = None\n        i = 0\n        while i < len(s):\n            \n            if s[i] == c:\n                if r == None:\n                    r = i\n                else:\n                    if s[r:] < s[i:]:\n                        r = i\n                #a.append(i)\n                while i < len(s)-1 and s[i+1] == c:\n                    i += 1\n                    \n            i += 1\n            \n        #r = a[0]\n        #for i in a[1:]:\n        #    if s[r:] < s[i:]:\n        #        r = i\n                \n        return s[r:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max_ord = 0\n        if s.count(s[0])==len(s):\n            return s\n        for i in range(len(s)):\n            max_ord = max(max_ord, ord(s[i]))\n        start = chr(max_ord)\n        result = ''\n        for i in range(s.count(start)):\n            substr = s[s.find(start):]\n            result = max(result, substr)\n            s = s[s.find(start)+1:]\n            \n        return result", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        i,j,k = 0,1,0\n        while j + k < n:\n            if s[i:i+k+1] == s[j:j+k+1]:\n                k += 1\n            elif s[i:i+k+1] < s[j:j+k+1]:\n                i = j\n                k = 0\n                j = j + 1\n            else:\n                j += k + 1\n                k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        mc = ''\n        mi = []\n        \n        for i in range(len(s)):\n            if s[i] >= mc:\n                mi.append(i)\n                mc = s[i]\n                \n        ms = ''\n        for i in mi:\n            if s[i:] > ms:\n                ms = s[i:]\n        return ms\n        \n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        # c = s[0]\n        # for num in range(len(s)):\n        #     if s[num] > c:\n        #         i = num\n        #         c = s[num]\n        j = i + 1\n        k = 0\n        \n        while j + k < len(s):\n            if s[i+k] == s[j+k]:\n                k += 1\n            elif s[i+k] > s[j+k]:\n                j += k + 1\n                k = 0\n            else:\n                i += k + 1\n                j = i + 1\n                k = 0\n                \n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # first store all the max chars in an array\n        max_char = 'a'\n        chars = []\n        for i, char in enumerate(s):\n            if char >= max_char:\n                max_char = char\n                chars.append(i)\n        \n        max_string = ''\n        # now build the max substring from the chars array\n        for idx in chars:\n            if s[idx:] > max_string:\n                max_string = s[idx:]\n        return max_string", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        maxIndex = []\n        maxS = ''\n        for i in range(len(s)):\n            if(maxS < s[i]):\n                maxS = s[i]\n                maxIndex = []\n                maxIndex.append(i)\n            elif(maxS == s[i]):\n                maxIndex.append(i)\n            \n        \n        soln = s[maxIndex[0]:]\n        for index in maxIndex:\n            if(soln <= s[index:]):\n                soln = s[index:]\n                  \n    \n        return soln", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        maxChar = max(s)\n        \n        indx = []\n        \n        for i in range(0, len(s)):\n            if s[i] == maxChar and (i ==0 or s[i-1]!=maxChar):\n                indx.append(i)\n                \n        \n        maxind = indx[0]\n        \n        for i in range (1, len(indx)):\n            step = 0\n            curind = indx[i]\n            while curind+step<len(s):\n                \n                if s[curind+step]>s[maxind+step]:\n                    maxind = curind\n                elif s[curind+step] == s[maxind+step]:\n                    step+=1\n                else:\n                    break\n                    \n        return s[maxind:]\n", "'''\ncase 1:\n   a b ...\n   i j    => change i to j , j to j+1\ncase 2:\n    cbacbd\n    i  j => i==j compare next one\n    c b   a  c  b   d\n    i i+1    j  j+1  => i==j compare next one\n    i=2 < j+2\n    i = j \n    j = new_i+1 why? allelemnts are smaller than original i \n\n'''\nclass Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0,1,0\n        while j+k < len(s):\n            if s[i+k] > s[j+k]:\n                j = j+k+1\n                k = 0\n            elif s[i+k] == s[j+k]:\n                k += 1\n            else:\n                i = j #max(i + k + 1, j)\n                j = i+1\n                k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        last_c=max(s)\n        last_str=s\n        for i in range(len(s)):\n            if s[i]==last_c and s[i:]>last_str:\n                last_str=s[i:]\n        return last_str\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        mx = max(s)\n        \n        prev = ''\n        \n        for i in range(len(s)):\n            \n            if s[i] == mx:\n                if s[i:] > prev:\n                    prev = s[i:]\n                    \n        return prev", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        c = max(s)\n        \n        a = []\n        \n        i = 0\n        while i < len(s):\n            \n            if s[i] == c:\n                a.append(i)\n                while i < len(s)-1 and s[i+1] == c:\n                    i += 1\n                    \n            i += 1\n            \n        r = a[0]\n        for i in a[1:]:\n            if s[r:] < s[i:]:\n                r = i\n                \n        return s[r:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        char_list = set(list(s))\n        char_list = list(char_list)\n        char_list.sort()\n        char = char_list[-1]\n        res = char\n        for i,c in enumerate(s):\n            if c == char:\n                if res < s[i:]:\n                    res = s[i:]\n        return res", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        n = len(s)\n        while j + k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n                i = j\n                j = i + 1\n            k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s: return None\n        mxm = s[:]\n        for i in range(len(s)):\n            if s[i] >= mxm[0]:\n                if s[i:] > mxm:\n                    mxm = s[i:]\n        return mxm", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max_char = 'a'\n        for char in s:\n            if char > max_char:\n                max_char = char\n        \n        compare = set()\n        ret = max_char\n        for i in range(len(s)):\n            if s[i] == max_char:\n                if s[i:] > ret:\n                    ret = s[i:]\n        \n        return ret", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        ans = ''\n        c = max(s)\n        idx = [i for i in range(len(s)) if s[i] == c]\n        for i in idx:\n            ans = max(ans, s[i:])\n        return ans", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max_ = max(s)\n        max_positions = [i for i, c in enumerate(s) if c == max_]\n        return max(s[i:] for i in max_positions)\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        c = max(set(s))\n        \n        res = ''\n        \n        for i,x in enumerate(s):\n            if x == c:\n                res = max(res, s[i:])\n        return res\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        maxIndex = []\n        maxS = ''\n        for i in range(len(s)):\n            if(maxS < s[i]):\n                maxS = s[i]\n        for i in range(len(s)):\n            if(maxS == s[i]):\n                maxIndex.append(i)\n        \n        soln = s[maxIndex[0]:]\n        for index in maxIndex:\n            if(soln <= s[index:]):\n                soln = s[index:]\n                  \n    \n        return soln", "\n\nclass Solution:\n\n    def lastSubstring(self, s: str) -> str:\n\n        start_char = 'a'\n        ans = 'a'\n\n        for i in range(len(s)):\n            \n            if s[i] > start_char:\n                start_char = s[i]\n\n        for i in range(len(s)):\n\n            if s[i] == start_char:\n                ans = max(ans, s[i:])\n\n\n        return ans\n", "\n\nclass Solution:\n\n    def lastSubstring(self, s: str) -> str:\n\n        start_char = 'a'\n        ans = 'a'\n\n        for i in range(len(s)):\n            if s[i] > start_char:\n                start_char = s[i]\n                ans = s[i:]\n\n            elif s[i] == start_char:\n\n                ans = max(ans, s[i:])\n\n        return ans\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i,j,k = 0,1,0\n        while j + k < len(s):\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n                i = max(i + k + 1, j)\n                j = i + 1\n            k = 0\n        return s[i:]", "from collections import defaultdict\n\nclass Solution:       \n    def lastSubstring(self, s: str) -> str:\n        max_char = max(s)\n        return max(s[i:] for i, c in enumerate(s) if c == max_char)\n\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        biggest = max(s)\n        start_ids = []\n        \n        for i, letter in enumerate(s):\n            if letter == biggest: \n                start_ids.append(i)\n        \n        ans = s\n        \n\n        for i in start_ids:\n            ans = max(ans, s[i::])\n        \n        return ans", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max_a = max(s)\n        sub = s\n        for i in range(len(s)):\n            if s[i] == max_a:\n                if s[i:] > sub:\n                    sub = s[i:]\n        return sub\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max_char = 'a'\n        curr_idx = []\n        for i in range(len(s)):\n            if s[i] > max_char:\n                curr_idx = [i]\n                max_char = s[i]\n            elif s[i] == max_char:\n                curr_idx.append(i)\n        \n        curr_max = ''\n        for idx in curr_idx:\n            if s[idx:] > curr_max:\n                curr_max = s[idx:]\n        \n        return curr_max", "class Solution:       \n    def lastSubstring(self, s: str) -> str:\n        max_char = max(s)\n        return max(s[i:] for i, c in enumerate(s) if c == max_char)\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        st=set()\n        \n        for l in s:\n            st.add(l)\n        \n        if len(st)==1:\n            return s\n            \n        largest_letter = sorted(list(st))[-1]\n        \n        nums=[]\n        for index,letter in enumerate(s):\n            if letter==largest_letter:\n                nums.append(index)\n        \n        rez=s[nums[0]:]\n        og_first=nums[0]\n        \n        for i in nums[1:]:\n            first = og_first\n            second,j = i,i\n            while second<len(s):\n                if s[first]==s[second]:\n                    first+=1\n                    second+=1\n                elif s[first]>s[second]:\n                    break\n                elif s[first]<s[second]:\n                    rez=s[j:]\n                    og_first=j\n                    break\n        \n        return rez\n        \n                \n        \n        \n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        l=[]\n        least='a'\n        index=[]\n        for i,el in enumerate(s):\n            if el==least:\n                index.append(i)\n            elif el>least:\n                index=[i]\n                least=el\n        ans=''\n        for i in index:\n            ans=max(ans,s[i:])\n        return ans", "from collections import defaultdict\n\nclass Solution:       \n    def lastSubstring(self, s: str) -> str:\n        all_strings = set()\n        max_char = None\n        char_to_idx = defaultdict(lambda: [])\n        \n        for i, c in enumerate(s):\n            if max_char == None or c > max_char:\n                max_char = c\n            char_to_idx[c].append(i)\n        \n        max_string = None\n        for start_idx in char_to_idx[max_char]:\n            # for j in range(start_idx+1, len(s)+1):\n            new_string = s[start_idx:]\n            if max_string == None or new_string > max_string:\n                max_string = new_string\n        \n        return max_string\n", "\n\nclass Solution:\n\n    def lastSubstring(self, s: str) -> str:\n\n\n        start_char = max(s)\n        ans = start_char\n\n\n        # for i in range(len(s)):\n        #     if s[i] > start_char:\n        #         start_char = s[i]\n\n        for i in range(len(s)):\n            if s[i] == start_char:\n                ans = max(ans, s[i:])\n\n\n        return ans\n", "\n\nclass Solution:\n\n    def lastSubstring(self, s: str) -> str:\n\n        start_char = 'a'\n        ans = 'a'\n\n        for i in range(len(s)):\n            \n            if s[i] > start_char:\n                start_char = s[i]\n                ans = s[i:]\n\n        for i in range(len(s)):\n\n            if s[i] == start_char:\n                ans = max(ans, s[i:])\n\n\n        return ans\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        ans = s[0]\n        for i in range(len(s)):\n            if s[i]<ans[0]:\n                continue\n            else:\n                \n            # for j in range(i, len(s)):\n            #     if s[i:j+1]>ans:\n                ans = max(s[i:], ans)\n        return ans", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n    \n        max_letter = max(s)\n        \n        curr_max_index = s.find(max_letter)\n        curr_substring = s[curr_max_index:]\n        \n        output = s\n        \n        next_max_index = 0\n        \n        while (True):\n            next_max_index = s.find(max_letter, curr_max_index + 1)\n            if next_max_index == -1:\n                return max(curr_substring, output)\n            \n            if curr_substring > output:\n                output = curr_substring\n            \n            curr_max_index = next_max_index\n            curr_substring = s[curr_max_index:]\n\n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        maxChar = s[0]\n        \n        for c in s:\n            maxChar = max(maxChar, c)\n            \n        print(maxChar)\n        \n        check = ''\n        \n        for i in range(0, len(s)):\n            if s[i] == maxChar and s[i:] > check:\n                check = s[i:]\n        \n        return check\n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        m, i, k =0,1,0 #m:maxbeginwith, i:possible candidate after m, l: current length\n        while i+k< len(s):\n            if s[m+k] ==s[i+k]:\n                k+=1\n            elif s[m+k] >s[i+k]:\n                i = i+k+1\n                k=0\n            else:\n                m = max(m+k+1,i)\n                i=m+1\n                k=0\n        return s[m:]", "from collections import defaultdict\n\nclass Solution:       \n    def lastSubstring(self, s: str) -> str:\n        max_char = None\n        max_char_idx_all = set()\n        max_string = None\n\n        for i, c in enumerate(s):\n            if max_char == None or c >= max_char:\n                max_char = c\n                new_string = s[i:]\n                \n                if max_string == None or new_string > max_string:\n                    max_string = new_string            \n        \n        return max_string\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        maxChar = s[0]\n        \n        for c in s:\n            maxChar = max(maxChar, c)\n                    \n        check = ''\n        \n        for i in range(0, len(s)):\n            if s[i] == maxChar and s[i:] > check:\n                check = s[i:]\n        \n        return check\n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        aMax = max(a for a in s)\n        inds = [i for i in range(len(s)) if s[i] == aMax]\n        sMax = ''\n        for i in inds:\n            sMax = max(sMax,s[i:])\n            # print(sMax, inds)\n        return sMax\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        mx = max(s)\n        mxelement = [i for i, j in enumerate(s) if j == mx]\n        mxstring = ''\n        for i in mxelement:\n            mxstring = max(s[i:], mxstring)\n        return mxstring", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        old = list(s)\n        chars = list(s)\n        chars.sort()\n        index = old.index(chars[-1])\n        indices = [i for i, x in enumerate(old) if x == chars[-1]]\n        Max = s[indices[0]:]\n        for i in range(len(indices)):\n            Max = max(Max,s[indices[i]:])\n        return Max\n            \n", "class Solution:    \n    def lastSubstring(self, s: str) -> str:\n        charInd = collections.defaultdict(list)\n        # head = {}\n        for i in range(len(s)):\n            charInd[s[i]].append(i)        \n        maxChr = max(charInd.keys())\n        \n        if len(charInd[maxChr]) == len(s)-1:\n            return s\n        \n        m = s[-1]\n        for i in charInd[maxChr]:\n            m = max(m, s[i:])\n        return m\n            \n            \n            \n            # node = head\n#             for c in s[i:]:\n#                 if c not in node:\n#                     node[c] = {}\n#                 node = node[c]\n            \n#         res = \\\"\\\"\n#         node = head\n#         while node:\n#             ch = max(node.keys())\n#             res += ch\n#             node = node[ch]           \n        \n#         return res\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n    \n        max_letter = max(s)\n        \n        curr_max_index = s.find(max_letter)\n        curr_substring = s[curr_max_index:]\n        \n        output = s\n        \n        next_max_index = 0\n        \n        while (next_max_index != -1):\n            next_max_index = s.find(max_letter, curr_max_index + 1)\n            \n            if curr_substring > output:\n                output = curr_substring\n            \n            curr_max_index = next_max_index\n            curr_substring = s[curr_max_index:]\n            \n        \n        return output\n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # starts with max(ord(char)) should be start\n        # longer substrings dominate\n        i,j,k = 0,1,0\n        while j + k < len(s):\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n                i = max(i + k + 1, j)\n                j = i + 1\n            k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s: return None\n        first = {}\n        for i, letter in enumerate(s):\n            if letter not in first: first[letter] = [i]\n            else: first[letter].append(i)\n        first_letter = max(first.keys())\n        res = first_letter\n        for idx in first[first_letter]:\n            res = max(res, s[idx:])\n        return res\n            \n        \n", "from collections import defaultdict\n\nclass Solution:       \n    def lastSubstring(self, s: str) -> str:\n        max_char = max(s)\n        max_string = None\n\n        for i, c in enumerate(s):\n            if c == max_char:\n                new_string = s[i:]\n                \n                if max_string == None or new_string > max_string:\n                    max_string = new_string            \n        \n        return max_string\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        length, last, max_char = len(s), s[-1], s[-1]\n        for i in range(length - 2, -1, -1):\n            if s[i] < max_char:\n                pass\n            elif s[i] > max_char:\n                last = s[i:]\n                max_char = s[i]\n            else:\n                last = max(last,s[i:])\n        return last\n", "class Solution:\n\n    def lastSubstring(self, s: str) -> str:\n\n        start_char = 'a'\n        ans = 'a'\n\n        for i in range(len(s)):\n            if s[i] > start_char:\n                start_char = s[i]\n                ans = s[i:]\n\n            elif s[i] == start_char:\n\n                ans = max(ans, s[i:])\n\n        return ans\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        ind = collections.defaultdict(list)\n        for i in range(len(s)):\n            ind[s[i]].append(i)\n        \n        maxy = max(ind)\n        \n        ans = ''\n        off = 0\n        for i in ind[maxy]:\n            s = s[i-off:]\n            off+=(i-off)\n            # print(s, off)\n            ans = max(ans, s)\n        return ans", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        maxLet = ord(s[0])\n\n        for c in s:\n            maxLet = max(maxLet, ord(c))\n        \n        maxLet = chr(maxLet)\n        mx = s\n        for i,c in enumerate(s):\n            if c == maxLet:\n                mx = max(mx,s[i:])\n                \n        return mx", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        slow, fast, length = 0, 1, 0\n        while fast + length < len(s):\n            if s[slow+length] == s[fast+length]: #if equal, compare the next character\n                length += 1\n            elif s[slow+length] > s[fast+length]: #the slow character is higher than fast one, compare the next first character\n                fast += (length + 1)\n                length = 0\n            else: #the fast character is higher than slow one, compare the next sub string\n                slow = fast\n                fast = slow + 1\n                length = 0\n\n        return s[slow:]\n", "import numpy as np\nclass Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        input_list= np.array([ord(x) for x in s])\n        i, = np.where(input_list == np.max(input_list))\n\n        \n        r = ''\n        # M = max(s)\n        for e in i:\n            r = max(r, s[e:])\n        \n        return r\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        length = len(s)\n        last = s[-1]\n        max_char = s[-1]\n        for i in range(length - 2, -1, -1):\n            if s[i] < max_char:\n                pass\n            elif s[i] > max_char:\n                last = s[i:]\n                max_char = s[i]\n            else:\n                last = max(last,s[i:])\n        return last\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s:\n            return ''\n        m=s[0]\n        \n        for i in range(1,len(s)):\n            m=max(m,s[i])\n            \n        x=''\n        \n        for i in range(len(s)):\n            if s[i]==m:\n                x=max(x,s[i:])\n        return x\n    \n        '''\n        if len(x)==1:\n            return s[x[0]:]\n        #print(x)\n        \n        \n        \n        while len(x)>1:\n            c=1\n            m=s[x[0]+c]\n            i=0\n            while i<len(x):\n                #print(x,m)\n                if x[i]+c>=len(s):\n                    if len(x)>1:\n                        x.pop()\n                        break\n                    else:\n                        return s[x[0]:]\n                if s[x[i]+c]<m:\n                    del x[i]\n                    continue\n                if s[x[i]+c]>m:\n                    m=s[x[i]+c]\n                    x=x[i:]\n                    i=0\n                    continue\n                i+=1\n            c+=1\n        if x:\n            return s[x[0]:]\n        \n        return ''\n        '''", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        length = len(s)\n        \n        maxChar = ''\n        maxCharIdxs = []\n        \n        for i in range(length):    \n            maxChar = max(s[i], maxChar)\n        \n        for idx, char in enumerate(s):\n            if char == maxChar:\n                maxCharIdxs.append(idx)\n        \n        maxSubstr = ''\n        for maxIdx in maxCharIdxs:\n            maxSubstr = max(s[maxIdx: ], maxSubstr)\n        \n        return maxSubstr\n            \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        def helper(s):\n            p1, p2, prev_max_string = 0, -1, None\n            for i, l in enumerate(s): \n                if p2 > 0: \n                    # has valid start\n                    if ord(l) > ord(s[p1 + i-p2]): \n                        p1 = p2\n\n                    elif ord(l) == ord(s[p1 + i-p2]): \n                        pass\n                    else: \n                        p2 = -1                \n                else:\n                    # how you initialize the string\n                    if ord(l) > ord(s[p1]): \n                        p1 = i\n                    elif ord(l) < ord(s[p1]): \n                        pass\n                    else: \n                        p2 = i\n            return s[p1:]\n        \n        ans = helper(s)\n        while len(s) > len(ans): \n            s, ans = ans, helper(ans)\n        return s\n    \n                \n                \n            \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        index = {c: i for i, c in enumerate(sorted(set(s)))}\n        radix, val, cur, lo = len(index), 0, 0, 0\n        for i in range(len(s) - 1, -1, -1):\n            cur = index[s[i]] + cur / radix\n            if cur >= val:\n                lo, val = i, cur\n        return s[lo:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s:\n            return s\n        first, second, runner = 0, 1, 0\n        while second + runner < len(s):\n            if s[first + runner] == s[second + runner]:\n                runner += 1\n            elif s[first + runner] > s[second + runner]:\n                second = second + runner + 1\n                runner = 0\n            else:\n                if s[second + runner] > s[first]:\n                    first, second, runner = second + runner, second + runner + 1, 0\n                else:\n                    first, second, runner = second, second + 1, 0\n            # print(first, second, runner)\n            \n        return s[first:]\n                \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        l = len(s)\n        # take all substring which goes on till the end.\n        # make l substrings.\n        # find the largest lowercase english letter\n        all_chars = set(list(s))\n        all_chars = list(all_chars)\n        all_chars.sort()\n        mychar = all_chars[-1]\n        max_sub = mychar\n        for i, c in enumerate(s):\n            if c == mychar:\n                candidate = s[i:]\n                if max_sub < candidate:\n                    max_sub = candidate\n                    \n        return max_sub", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n\n        if not s:\n            return ''\n        \n        maxval = s\n        maxstart = s[0]\n        \n        for i in range(len(s)):\n            if s[i] >= maxstart and s[i:] > maxval:\n                maxstart = s[i]\n                maxval = s[i:]\n\n                \n        return maxval", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # create substrings, sort lexicographically?\n        prev=s[0]\n        max_store=[]\n        # O(n)\n        max_s=max(s)\n        for i in range(len(s)):\n            if s[i]==max_s:\n                if s[i:]>prev:\n                    prev=s[i:]\n                \n        # for i in range(len(s)):\n        #     if s[i:]>prev:\n        #         prev=s[i:]\n        return prev", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i = 1-1\n        j = 1\n        large = s[i]\n        while(j < len(s)):\n            if (s[j] > large):\n                i = j\n                large = str(s[j])\n            else:\n                large += s[j]\n            j += 1\n        i = 1\n        print(large)\n        res = large\n        while(i < len(large)):\n            if (large[i-1] == res[1-1]):\n                if (large[i-1:] > res):\n                    res = large[i-1:]\n                    # print(res)\n            i += 1\n        return res\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s:\n            return s\n        max_char = s[0]\n        for c in s:\n            if c > max_char:\n                max_char = c\n                \n        largest = s\n        cur, prev = 0, 0\n        for i in range(len(s)):\n            if s[i] == max_char:\n                #print(i, s[i], s[cur:i+1])\n                if cur and s[cur:] > largest:\n                    largest = s[cur:]\n                cur = i\n                                \n        if cur and s[cur:] > largest:\n            largest = s[cur:]\n        \n        return largest", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if len(set(s))==1:\n            return s\n        alpha=sorted(list(set(s)))\n        start=alpha[-1]\n        \n        n=len(s)\n        index=[]\n        for i,char in enumerate(s):\n            if char==start:\n                index.append(i)\n            \n        prefix=start\n        maxprefix=start\n        while index:\n            nextindex=[]\n            for i in index:\n                if i+1<n:\n                    if prefix+s[i+1]==maxprefix:\n                        maxprefix=prefix+s[i+1]\n                        nextindex.append(i+1)\n                    elif prefix+s[i+1]>maxprefix:\n                        maxprefix=prefix+s[i+1]\n                        nextindex=[i+1]\n            prefix=maxprefix\n            index=nextindex\n        \n        return maxprefix\n                    \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if len(s) == 1:\n            return s\n        \n        start, end, length = 0, 1, 0\n        \n        while end + length < len(s):\n            if s[start + length] == s[end + length]:\n                length += 1\n            elif s[start + length] > s[end + length]:\n                end += length + 1\n                length = 0\n            else:\n                start = end\n                end = start + 1\n                length = 0\n        \n        return s[start:]\n                \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        bestStr = s\n        bestChar = s[0]\n        for i in range(1, len(s)):\n            if s[i] >= bestChar and s[i:] > bestStr:\n                bestChar = s[i]\n                bestStr = s[i:]\n                \n                \n        return bestStr\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        mx = max(s)\n        mxelement = [i for i, j in enumerate(s) if j == mx]\n        mxstring = ''\n        for i in mxelement:\n            if s[i:]>mxstring:\n                mxstring = s[i:]\n        return mxstring", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        c = max(set(s))\n        res = ''\n        for i,x in enumerate(s):\n            if x == c:\n                res = max(res, s[i:])\n        return res", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        largest_character = max(set(s))\n        result = ''\n        \n        for i, char in enumerate(s):\n            \n            if char==largest_character:\n                result = max(result,s[i:])\n                \n        return result\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        res = s\n        maxChar = max(s)\n        for i in range(1, len(s)):\n            if s[i] == maxChar and s[i:] > res:\n                res = s[i:]\n        \n        return res", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # create substrings, sort lexicographically?\n        prev=s[0]\n        max_store=[]\n        # O(n)\n        max_s=max(s)\n        for i in range(len(s)):\n            if s[i]==max_s:\n                if s[i:]>prev:\n                    prev=s[i:]\n                \n\n        return prev", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if len(set(s))==1: return s\n        x=max(s)\n        n=len(s)\n        res=[]\n        for i in range(n-1,-1,-1):\n            if res and s[i]==x:\n                k=0\n                while k<len(res[-1]) and res[-1][k]==s[i+k]:\n                    k+=1\n                if k<len(res[-1]) and res[-1][k]<s[i+k]:\n                    res[-1]=s[i:]\n                elif k==len(res[-1]):\n                    res[-1]=s[i:]\n            elif s[i]==x:\n                res.append(s[i:])\n        return res[-1]\n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        c = max(s)\n        maxSub = ''\n        loc = s.find(c, 0)\n        while loc != -1:\n            maxSub = max(maxSub, s[loc:])\n            loc = s.find(c, loc + 1)\n        return maxSub\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        maxchr = max(s)\n        index = []\n        maxstring = ''\n        i = 0\n        while i < len(s) and s[i:].find(maxchr) != -1:\n            if i == 0 or s[i] != s[i-1]:\n                temp = s[i:].index(maxchr) + i\n                index.append(temp)\n                maxstring = max(maxstring, s[temp:])\n                i = temp+1\n            else:\n                i += 1\n        return maxstring", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        def helper(s, start = 0):\n            p1, p2 = start, -1\n            # for i, l in enumerate(s): \n            for i in range(start+1, len(s)): \n                l = s[i]\n                if p2 > 0: \n                    # has valid start\n                    if ord(l) > ord(s[p1 + i-p2]): \n                        p1 = p2\n\n                    elif ord(l) == ord(s[p1 + i-p2]): \n                        pass\n                    else: \n                        p2 = -1                \n                else:\n                    # how you initialize the string\n                    if ord(l) > ord(s[p1]): \n                        p1 = i\n                    elif ord(l) < ord(s[p1]): \n                        pass\n                    else: \n                        p2 = i\n            # return s[p1:]\n            return p1\n        \n        i, j = 0, helper(s, 0)\n        while j > i: \n            i, j = j, helper(s, j)\n        return s[j:]\n        \n        # ans = helper(s, 0)\n        # while len(s) > len(ans): \n        #     s, ans = ans, helper(ans)\n        # return ans\n        \n        \n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n\n        input_string = s\n        \n    \n        max_letter = max(input_string)\n        \n        curr_max_index = input_string.find(max_letter)\n        curr_substring = input_string[curr_max_index:]\n        \n        output = input_string\n        \n        next_max_index = 0\n        \n        while (True):\n            next_max_index = input_string.find(max_letter, curr_max_index + 1)\n            if next_max_index == -1:\n                return max(curr_substring, output)\n            \n            if curr_substring > output:\n                output = curr_substring\n            \n            curr_max_index = next_max_index\n            curr_substring = input_string[curr_max_index:]\n            \n            if output > curr_substring:\n                continue\n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        d = defaultdict(list)\n        for i, c in enumerate(s):\n            d[c].append(i)\n        z = max(d.keys())                   # max char\n        ids = d[z]                                # start pos for substrings\n        return max(s[start:] for start in ids)", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        i = n - 2\n        last = n - 1\n        while i >= 0:\n            if s[i] > s[last]:\n                last = i \n                i -= 1\n                continue\n            if s[i] < s[last]:\n                i -= 1\n                continue\n            j = 1\n            while True:\n                tempi = i + j\n                templast = last + j\n                if templast >= n:\n                    last = i\n                    i -= 1\n                    break\n                if tempi == last:\n                    last = i\n                    i -= 1\n                    break\n                if s[tempi] > s[templast]:\n                    last = i\n                    i -= 1\n                    break\n                if s[tempi] < s[templast]:\n                    i -= 1\n                    break\n                j += 1\n        return s[last:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        for i,c in enumerate(s):\n            if i == 0:\n                max_c = c\n                max_id=[i]\n            else:\n                if c > max_c:\n                    max_id = [i]\n                    max_c = c\n                elif c == max_c:\n                    max_id.append(i)\n        max_substr = s[max_id[0]:]\n        for idx in max_id:\n            if s[idx:] > max_substr:\n                max_substr = s[idx:]\n        return max_substr\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n    \n        max_letter = max(s)\n        \n        curr_max_index = s.find(max_letter)\n        curr_substring = s[curr_max_index:]\n        \n        output = s\n        \n        next_max_index = 0\n        \n        while (True):\n            next_max_index = s.find(max_letter, curr_max_index + 1)\n            if next_max_index == -1:\n                return max(curr_substring, output)\n            \n            if curr_substring > output:\n                output = curr_substring\n            \n            curr_max_index = next_max_index\n            curr_substring = s[curr_max_index:]\n            \n            if output > curr_substring:\n                continue\n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n\n        char_max = max(s)\n        ind = s.find(char_max)\n        s=s[ind:]\n        n = len(s)\n        arr = [0]*n\n        arr[-1]=s[-1]\n        ans=arr[-1]\n        for i in range (n-2,-1,-1):\n            if s[i]==char_max:\n                if s[i:]>ans:\n                    ans=s[i:]\n        return ans", "class Node:\n    def __init__(self, val=None, is_end=False, children=None):\n        self.val = val\n        self.children = children if children else {}\n\nclass Solution:\n    def add_suffix(self, root: Node, s: str):\n        for c in s:\n            if c not in root.children:\n                root.children[c] = Node(val=c)\n            root = root.children[c]\n        \n    def get_last_substring(self, root: Node):\n        if not root.children:\n            return [root.val]\n        return [root.val] + self.get_last_substring(max(root.children.items())[1])\n            \n    \n    def lastSubstring(self, s: str) -> str:\n        c = max(s)\n        res = ''\n        for i,x in enumerate(s):\n            if x == c:\n                res = max(res, s[i:])\n        return res\n        # root = Node('')\n        # for i in range(len(s)):\n        #     self.add_suffix(root, s[i:])\n        # return ''.join(self.get_last_substring(root))\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        char_list = set(list(s))\n        char_list = list(char_list)\n        char_list.sort()\n        last_char = char_list[-1]\n        max_string = last_char\n        for index, char in enumerate(s):\n            if char == last_char and max_string < s[index:]:\n                max_string = s[index:]\n        return max_string\n    \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        s_len, left, right, step = len(s), 0, 1, 0\n        while(right + step < s_len):\n            if s[right + step] > s[left + step]:\n                left, right, step = right , right+1, 0\n            elif s[right + step] < s[left + step]:\n                right, step = right+step+1, 0\n            else:\n                step += 1\n        return s[left:]\n\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        \n        maxLetter = max(s)\n        maxSubstring = None\n        \n        for i, letter in enumerate(s):\n            if letter == maxLetter:\n                if not maxSubstring or s[i:n] > maxSubstring:\n                    maxSubstring = s[i:n]\n        \n        return maxSubstring\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        char_max = max(s)\n        ind = s.find(char_max)\n        s=s[ind:]\n        n = len(s)\n        arr = [0]*n\n        arr[-1]=s[-1]\n        ans=arr[-1]\n        i=n-2\n        while i>-1:\n        # for i in range (n-2,-1,-1):\n            if s[i]==char_max:\n                if s[i:]>ans:\n                    ans=s[i:]\n            i-=1\n        return ans", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        char_max = max(s)\n        ind = s.find(char_max)\n        s=s[ind:]\n        n = len(s)\n        arr = [0]*n\n        arr[-1]=s[-1]\n        ans=arr[-1]\n        i=n-2\n        while i>-1:\n            if s[i]==char_max:\n                if s[i:]>ans:\n                    ans=s[i:]\n            i-=1\n        return ans", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        mx = max(s)\n        pos = [i for i in range(len(s)) if s[i] == mx]\n        return max(s[i:] for i in pos)", "import numpy as np\n\nclass Solution:\n    def lastSubstring(self, s: str) -> str:\n        mx = max(s)\n        #mxelement = [i for i, j in enumerate(s) if j == mx]\n        \n        \n        values = np.array(list(s))\n        mxelement = np.where(values == mx)[0]\n\n        \n        mxstring = ''\n        for i in mxelement:\n            if s[i:]>mxstring:\n                mxstring = s[i:]\n        return mxstring", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        largest_character = max(set(s))\n        result = ''\n        ind = [i for i,char in enumerate(s) if char==largest_character]\n        \n        #for i, char in enumerate(s):\n        for i in ind:\n            \n            #if char==largest_character:\n            result = max(result,s[i:])\n                \n        return result\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j = 0, 1\n        k = 0\n        while j + k < len(s):\n            if s[i + k] == s[j + k]:\n                k += 1\n            elif s[i + k] > s[j + k]:\n                j += k + 1\n                k = 0\n            else:\n                i = j\n                j = i + 1\n                k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        maximum = s\n        for i in range(1,len(s)):\n            if s[i:]>maximum:\n                maximum = s[i:]\n                \n        return maximum        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        res = s\n\n        for i in range(1, len(s)):\n            if s[i::] > res:\n                res = s[i::]\n        return res", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        dicmap = {}\n        maxhold =s[0]\n        index = 0\n    \n        for i in range(0,len(s)):\n            if s[i:] > maxhold:\n                maxhold = s[i:]\n                index = i\n\n                \n            \n        \n    \n\n                \n        \n        return s[index:]\n                \n            \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        max = s\n        for i in range(len(s)):\n            if max<s[i:]:\n                max=s[i:]\n        return max\n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        maxs = None\n        for sidx in range(len(s)):\n            if maxs == None or s[sidx: ] > maxs:\n                maxs = s[sidx: ]\n        return maxs", "class Solution:    #\u53cc\u6307\u9488\n    def lastSubstring(self, s: str) -> str:\n        left=0    ## \u4ee3\u8868\u4ee5left\u4e3a\u8d77\u59cb\u70b9\u7684\u5b57\u4e32\n        right=1  \n        step=0\n        while (right+step)<len(s):\n            if s[left+step]<s[right+step]:\n                left=right\n                right+=1\n                step=0\n            elif s[left+step] == s[right+step]:\n                step+=1\n            else:\n                right+=step+1\n                step=0\n        return s[left:]\n                \n                \n##\u4f7f\u7528\u6307\u9488left\u8bb0\u5f55\u5f53\u524d\u6700\u5927\u7684\u540e\u7f00\u5b50\u4e32\u7684\u8d77\u59cb\u5750\u6807\u3002 \u6307\u9488right\u7528\u6765\u904d\u5386\u3002 \u4e00\u5f00\u59cbleft = 0\uff0c right = 1\uff0c\u4ece\u5de6\u5f80\u53f3\u904d\u5386\u3002\n##\u5f53str[left] \u5c0f\u4e8e str[right], \u5219\u4ee5left\u5f00\u5934\u7684\u540e\u7f00\u5b50\u4e32\u4e00\u5b9a\u5c0f\u4e8e\u4ee5right\u5f00\u5934\u7684\u540e\u7f00\u5b50\u4e32\uff0c\u6240\u4ee5left = right\uff0c right+1\n##\u5f53str[left] \u5927\u4e8e str[right], \u5219left\u4e0d\u52a8\uff0cright+1\n##\u5f53str[left] \u7b49\u4e8e str[right]\uff0c \u5219\u6bd4\u8f83str[left + k], str[right + k], k = 1\u30012\u30013...\u3002 \u76f4\u5230\u51fa\u73b0\u4e0d\u76f8\u7b49\uff0c\u5426\u5219\u4e00\u76f4\u6bd4\u8f83\u76f4\u5230\u7ed3\u675f\u3002\n##\u5f53str[left + k] \u5c0f\u4e8e str[right + k]\uff0c left = right, right+1\n##\u5f53str[left + k] \u5927\u4e8e\u4e8e str[right + k]\uff0c left\u4e0d\u52a8, right+step+1\u3002\n\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        return max(s[i:] for i in range(len(s)))", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        maxStr = s\n        for i in range(1, len(s)):\n            if s[i:] > maxStr:\n                maxStr = s[i:]\n                \n        return maxStr", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        lastSubstring = s\n        for i in range(1, len(s)):\n            if s[i:] > lastSubstring:\n                lastSubstring = s[i:]\n        return lastSubstring", "class Solution:\n\n    def lastSubstring(self,s: str) -> str:\n        result = s\n        for i in range(len(s)):\n            if s[i:]>result:\n                result = s[i:]\n        return result\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if len(s) == 1:\n            return s\n        res = s\n        for i in range(1,len(s)):\n            if s[i:] > res:\n                res = s[i:]\n        return res\n            \n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        \n        \n        l  = 0\n        r  = len(s)\n        max_s = s\n        \n        while l < r:\n            \n            if s[l:r] >= max_s:\n                max_s = s[l:r]\n            \n            l += 1\n            \n            \n        return max_s", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # \u56e0\u4e3a\u5b57\u5178\u987a\u5e8f\uff0c\u53ef\u4ee5\u770b\u51fa ab abc \u4e24\u4e2a\u5b57\u7b26\u4e2d\uff0c abc \u66f4\u5927\uff0c\u56e0\u4e3a\u4e24\u4e2a\u5b57\u7b26\u76f8\u540c\u65f6\uff0c\u8c01\u66f4\u957f\u8c01order \u66f4\u5927\n        # \u6240\u4ee5\uff0c\u53ef\u4ee5\u786e\u5b9a\u6211\u4eec\u53ea\u9700\u8981\u627e\u5230 \u6700\u5927substring \u7684\u8d77\u59cb\u70b9\uff0c\u7136\u540e\u628a\u524d\u9762\u90fd\u5207\u6389\uff0c\u540e\u7f00\u5c31\u662f\u7b54\u6848\n        # \u5229\u7528\u53cc\u6307\u9488\u6765\u627e\u8d77\u59cb\u70b9\n        # i j \u4e24\u4e2a\u6307\u9488 \u6307\u5411\u6570\u7ec4\u7684\u4e24\u4e2a\u5b57\u7b26\uff0c\u7ef4\u6301 i +k \uff0c j +k \u4e24\u4e2asubstring\n        # \u6bcf\u6b21\u6bd4\u8f83\uff0c\u5982\u679ci \u7684\u66f4\u5927\uff0c\u90a3\u4e48j\u5c31\u8981\u66f4\u65b0\u5230j + k + 1\uff0c \u56e0\u4e3a\u5728j \uff5e j + k \u4e4b\u95f4\u7684\u5b57\u7b26\u90fd\u662f\u5c0f\u4e8ei\u7684\uff0c\u4e0d\u7136\u4e5f\u4e0d\u4f1a\u7b49\u5230\u73b0\u5728\u66f4\u65b0\n        # \u5982\u679c j\u66f4\u5927\uff0c\u90a3\u4e48\u7528j\u7684\u53bb\u66f4\u65b0i\uff0cj\u79fb\u52a8\u5230\u81ea\u5df1\u4e0b\u4e00\u4e2a\u4f4d\u7f6e \u627e\u6700\u5927string\uff0c\u7ee7\u7eed\u53bb\u6bd4\u8f83\n        i = 0\n        j = 1\n        k = 0\n        while j + k < len(s):\n            if s[i + k] == s[j + k]:\n                k += 1\n                continue\n            elif s[i + k] > s[j + k]:\n                j = j + k + 1\n            else:\n                i = j\n                j = i + 1\n            k = 0\n        return s[i:]\n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        ans = s\n        for i in range(1, len(s)):\n            ans = max(ans, s[i:])\n        return ans", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s);\n        cur = ord(s[0]);\n        start = 0;\n        end = 0\n        i=1;\n        while i<n:\n            if cur > ord(s[i]):\n                end+=1;\n                i+=1;\n            elif cur < ord(s[i]):\n                start,end=i,i;\n                cur = ord(s[i]);\n                i+=1;\n            else:\n                k = start+1;\n                prev= i;\n                i+=1;\n                while k<prev and i<n:\n                    if ord(s[k]) > ord(s[i]):\n                        end = i;\n                        break;\n                    elif ord(s[i]) > cur:\n                        start,end = i,i;\n                        cur = ord(s[i]);\n                        break;\n                    elif ord(s[k]) < ord(s[i]):\n                        start = prev;\n                        end = i;\n                        break;\n                    i+=1;\n                    k+=1;\n                if i==n:\n                    end = n-1;\n                if k==prev:\n                    end = i;\n        return s[start:end+1];", "class Solution:       \n    def lastSubstring(self, s: str) -> str:\n#         curr_value = 0\n#         max_value = 0\n#         max_idx = None\n#         char_to_id = {' ': 0}\n#         char_to_id.update((c, i + 1) for i, c in enumerate(sorted(frozenset(s))))\n#         radix = len(char_to_id) ** (len(s) - 1)\n        \n#         for i in range(len(s) - 1, -1, -1):\n#             curr_value = char_to_id[s[i]] * radix + curr_value // len(char_to_id)\n\n#             if curr_value > max_value:\n#                 max_value = curr_value\n#                 max_idx = i\n\n#         return s[max_idx:]\n        index = {c: i for i, c in enumerate(sorted(set(s)))}\n        radix, val, cur, lo = len(index), 0, 0, 0\n        for i in range(len(s) - 1, -1, -1):\n            cur = index[s[i]] + cur / radix\n            if cur >= val:\n                lo, val = i, cur\n        return s[lo:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i,j,k = 0,1,0\n        n = len(s)\n        \n        while(j+k < n):\n            if s[i+k] == s[j+k]:\n                k += 1\n            elif s[i+k] < s[j+k]:\n                i = j\n                j += 1\n                k = 0\n            else:\n                j += 1\n                k = 0\n        return s[i:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        m = max(s)\n        ans = ''\n        for i in range(len(s)):\n            ans = max(ans,s[i:])\n        return ans\n            \n                \n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        #a b c x a a x x b c d x d d a\n        #      |     |         |\n        \n        start = 0\n        for i in range(len(s)):\n            if s[i] > s[start]:\n                start = i\n        \n        candidates = set()\n        length = 1\n        \n        for i in range(len(s)):\n            if s[i] == s[start] and (i == 0 or s[i - 1] != s[start]):\n                candidates.add(i)\n        \n        while len(candidates) > 1:\n            need_remove = set()\n            maxc = 'a'\n            \n            for candidate in candidates:\n                end = candidate + length\n                if end >= len(s):\n                    need_remove.add(candidate)\n                    continue\n                \n                c = s[end]\n                if c > maxc:\n                    maxc = c\n            \n            for candidate in candidates:\n                end = candidate + length\n                \n                if end >= len(s):\n                    continue\n                if s[end] != maxc:\n                    need_remove.add(candidate)\n            \n            if len(need_remove) >= len(candidates): break\n            for idx in need_remove:\n                candidates.discard(idx)\n                \n            length += 1\n        \n        res = ''\n        for candidate in candidates:\n            curt = s[candidate:]\n            if curt > res:\n                res = curt\n        return res", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        j = 1\n        k = 0\n        n = len(s)\n        \n        \n        while j + k < n:\n          if s[i+k] == s[j+k]:\n            k += 1\n            continue\n          elif s[i+k] > s[j+k]:\n            j = j+k+1\n          else:\n            i = i+k+1\n          if i==j:\n            j = j+1\n          k = 0\n        \n        return s[i:]\n        \n        \n", "class Solution:\n    \n    ## Method 2 - Two Pointers\n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        j = i+1\n        result = s\n        while j < len(s):\n            if s[i] > s[j]:\n                j += 1\n                continue\n            elif s[i] < s[j]:\n                i = j\n                j += 1\n            else:\n                \n                step = 0\n                while j+step < len(s) and s[i+step] == s[j+step]:\n                    step += 1\n                \n                # print(j+step, len(s))\n                if j+step == len(s):\n                    return s[i:]\n                if s[i+step] > s[j+step]:\n                    j += 1\n                    continue                \n                else:\n                    i = j\n                    j += 1\n                # print(s[i:], i, j)\n                    \n        return s[i:]\n            \n            \n        \n    \n    \n#     ## Method 1 - brute force (imroved)\n#     def lastSubstring(self, s: str) -> str:\n#         start = max(set(s))\n#         result = \\\"\\\"\n#         for i, char in enumerate(s):\n#             # if i + len(result) > len(s):\n#             #     break\n#             if char == start:\n#                 result = max(result, s[i:])\n                \n#         return result\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max_ord = max([ord(c) for c in s])\n        max_ord_idxs = [i for i in range(len(s)) if ord(s[i]) == max_ord]\n        first_unique_idx = [i for i in range(len(max_ord_idxs)-1, -1, -1) if i == 0 or max_ord_idxs[i]-1 != max_ord_idxs[i-1] ]\n        max_ord_idxs = [max_ord_idxs[i] for i in first_unique_idx]\n        if len(max_ord_idxs) == 1:\n            return s[max_ord_idxs[0]:]\n        \n        def findNextMaxOrd(cur_idxs, level):\n            nextOrd2CurIdx = collections.defaultdict(list)\n            hist_max = float('-inf')\n            for idx in cur_idxs:\n                if idx < len(s) - level:\n                    nextOrd2CurIdx[ord(s[idx+level])].append(idx)\n                    hist_max = max(hist_max, ord(s[idx+level]))\n            return nextOrd2CurIdx[hist_max]\n\n        # Filtering indexes with maximum ord by comparing k-level away\n        level = 1\n        while 1:\n            max_ord_idxs = findNextMaxOrd(max_ord_idxs, level)\n            if len(max_ord_idxs) == 1:\n                return s[max_ord_idxs[0]:]\n            level += 1", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        # naive: O(n^2)\n        # slight optimization to sort as we go \n#         last = s\n#         for i in range(len(s)):\n#             for j in range(i+1, len(s)+1):\n#                 if s[i:j] > last:\n#                     last = s[i:j]\n                \n#         return last\n        \n        # find positions of earliest letters in alphabet \n        # leastLetter = s[0]\n        # positions = [0]\n        # for i in range(1,len(s)):\n        #     if s[i] > leastLetter:\n        #         leastLetter = s[i]\n        #         positions = [i]\n        #     elif s[i] == leastLetter:\n        #         positions.append(i)\n        i, j, k = 0, 1, 0\n        n = len(s)        \n        while j + k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j+k+1\n            else:\n                i = i+k+1\n            if i==j:\n                j = j+1\n            k = 0\n        return s[i:]\n", "# O(n) time and O(1) space\n# The last substring starts with the max char, find the start point(max char), and check\n# Finding just the index of max char(first or last occurence) will give us error in the following cases:\n# \\\"cacacb\\\" -> \\\"cb\\\"\n# \\\"abab\\\" -> \\\"bab\\\"\nclass Solution:\n    def lastSubstring(self, s: str) -> str:        \n        i, j = 0, 1\n        ptr = 0\n        \n        while j+ptr < len(s):\n            if s[i+ptr] == s[j+ptr]:\n                ptr += 1\n            elif s[i+ptr] < s[j+ptr]:\n                i = j\n                j += 1\n                ptr = 0\n            else:\n                j += 1\n                ptr = 0\n                \n        return s[i:]\n    \n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0\n        while i+offset < len(s) and j+offset < len(s):\n            if s[i+offset]==s[j+offset]:\n                offset += 1\n            else:\n                if s[i+offset] < s[j+offset]:\n                    i = j\n                else:\n                    j += offset+1\n                if i==j:\n                    j += 1\n                offset = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        pool, c, repeat = [], max(set(s)), False    # c is the max char, pool contains the candidates\n        for i,x in enumerate(s):\n            if x == c:\n                if not repeat:                      # only add non-repeat head (if there's some smaller char in between) 'zzzazz...', not add 'zzzzzz...'\n                    pool.append(i)\n                    repeat = True\n            else:\n                repeat = False\n        k = 1\n        while len(pool) > 1:                        # if there are more than one substring start with the head\n            new_pool, c = [], ''\n            for i in pool:\n                sc = s[i+k] if i+k < n else ''      # continue to compare the second, third, ..., k-th char\n                if sc > c:\n                    new_pool = [i]\n                    c = sc\n                elif sc == c:\n                    new_pool.append(i)\n            pool = new_pool\n            k += 1                                  # compare the next char\n        return s[pool[0]:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        '''\n        res=''\n        for i in range(len(s)):\n            res=max(s[i:],res)\n        return res\n        '''\n        max_ord = max([ord(c) for c in s])\n        max_ord_idxs = [i for i in range(len(s)) if ord(s[i]) == max_ord]\n        first_unique_idx = [i for i in range(len(max_ord_idxs)-1, -1, -1) if i == 0 or max_ord_idxs[i]-1 != max_ord_idxs[i-1] ]\n        max_ord_idxs = [max_ord_idxs[i] for i in first_unique_idx]\n        if len(max_ord_idxs) == 1:\n            return s[max_ord_idxs[0]:]\n        \n        def findNextMaxOrd(cur_idxs, level):\n            nextOrd2CurIdx = collections.defaultdict(list)\n            hist_max = float('-inf')\n            for idx in cur_idxs:\n                if idx < len(s) - level:\n                    nextOrd2CurIdx[ord(s[idx+level])].append(idx)\n                    hist_max = max(hist_max, ord(s[idx+level]))\n            return nextOrd2CurIdx[hist_max]\n\n        # Filtering indexes with maximum ord by comparing k-level away\n        level = 1\n        while 1:\n            max_ord_idxs = findNextMaxOrd(max_ord_idxs, level)\n            if len(max_ord_idxs) == 1:\n                return s[max_ord_idxs[0]:]\n            level += 1", "class Solution:\n    # idea is we have two sequences: i ...i+k and j ...j+k and differ only at s[i+k] and j[i+k]\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        while j + k < len(s):\n            if s[i + k] == s[j + k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                # increase j value to get out of loop\n                j = j + k + 1; \n            else: \n                # increase i value because we just found a starting letter that is bigger\n                i = i + k +1; \n            if i == j: \n                j = j + 1 \n            k = 0\n        return s[i:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max = 0\n        i = 1\n        j = 0\n        while i + j < len(s):\n            if s[i + j] == s[max + j]:\n                j = j + 1\n            elif s[i + j] > s[max + j]:\n                max = i\n                j = 0\n                i = i + 1\n            else:\n                j = 0\n                i = i + 1\n\n        return s[max:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        # Recursively find all with the largest lecsographical order,\n        \n        # when only one left => that is end of our substring\n        \n        # store start index and end index\n        all_same = True\n        first_char = s[0]\n        for c in s:\n            if first_char != c:\n                all_same = False\n        if all_same:\n            return s\n        \n        max_char = max([c for c in s])\n        indexes = [[i, i+1] for i, c in enumerate(s) if c == max_char]\n        \n        output = []\n        \n        def max_substring(indexes):\n            if len(indexes) == 1:\n                output.append(indexes[0])\n                return\n            \n            nonlocal s\n            max_char = max([s[indx[1]] for indx in indexes if indx[1] < len(s)])\n            \n            next_indexes = []\n            for indx in indexes:\n                if indx[1] < len(s) and s[indx[1]] == max_char:\n                    indx[1] += 1\n                    next_indexes.append(indx)\n            max_substring(next_indexes)\n        \n        max_substring(indexes)\n        return s[output[0][0]:]\n            \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        while j + k < len(s):\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n                i = i + k + 1\n            if i == j:\n                j += 1\n            k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i,j,k=0,1,0\n        ans=0\n        while j+k<len(s):\n            if s[i+k]==s[j+k]:\n                k+=1\n            elif s[i+k]>s[j+k]:\n                ans=i\n                j=j+k+1\n                k=0\n            else:\n                ans=j\n                i=max(i+k+1, j)\n                j=i+1\n                k=0\n        return s[ans:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s:\n            return None\n        \n        # get max char from s\n        max_char = max(s)\n        max_idxs = []\n        \n        # get all max_char indexs to append into max_idxs\n        for i in range(len(s)):\n            if s[i] != max_char:\n                continue\n            if not max_idxs or s[i - 1] != max_char:\n                max_idxs.append(i)\n                \n        # also append the length of s into the max_idxs for compersion\n        max_idxs.append(len(s))\n        \n        # initialize the temp max letter\n        max_letter = s[max_idxs[0]:max_idxs[1]]\n        ans_idx = max_idxs[0]\n        # using for loop to compare with each shrot letter those leading by max_char\n        for i in range(len(max_idxs) - 1):\n            cur = s[max_idxs[i]:max_idxs[i + 1]]\n            print(cur)\n            if max_letter < cur:\n                max_letter = cur\n                ans_idx = max_idxs[i]\n                \n        return s[ans_idx:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        index = {c: i for i, c in enumerate(sorted(set(s)))}\n        cur, radix, max_val, max_i = 0, len(index), 0, 0\n        for i in range(len(s)-1, -1, -1):\n            cur = index[s[i]] + cur/radix\n            if cur > max_val:\n                max_val, max_i = cur, i\n        return s[max_i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        n = len(s)\n        while j + k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]: # if left is greater\n                j = j + k + 1\n            else: # if right is greater\n                i = i + k + 1\n            if(i == j):\n                j = i + 1\n            k = 0\n        return s[i:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # start from s[i], s[j] (i=0,j=i+1)\n        i = 0\n        j = i + 1\n        k = 0\n        while j + k < len(s):\n            if s[i + k] > s[j+k]:\n                j += 1\n                k = 0\n                \n            elif s[i+k] < s[j+k]:\n                i = j\n                j = i + 1\n                k = 0\n            else:\n                \n                k += 1\n        return s[i:]\n", "class Solution:\n    \n    def lastSubstring(self, s: str) -> str:\n        begin = 0\n        end = 1\n        offset = 0\n        while end + offset < len(s):\n            # print(begin, end, offset,'\\\\t',s[begin+offset],s[end+offset],'\\\\t', -ord(s[begin+offset]) + ord(s[end+offset]),'\\\\t', s[begin:])\n            if s[begin + offset] > s[end+offset]:\n                offset = 0\n                end += 1\n            elif s[begin + offset] < s[end+offset]:\n                begin = end\n                end += 1\n                offset = 0\n            else:\n                offset += 1\n        return s[begin:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        max_ord = max([ord(c) for c in s])\n        max_ord_idxs = [i for i in range(len(s)) if ord(s[i]) == max_ord]\n        print(max_ord_idxs)\n        first_unique_idx = [i for i in range(len(max_ord_idxs)-1, -1, -1) if i == 0 or max_ord_idxs[i]-1 != max_ord_idxs[i-1] ]\n        print(first_unique_idx)\n        max_ord_idxs = [max_ord_idxs[i] for i in first_unique_idx]\n        \n        def findNextMaxOrd(cur_idxs, level):\n            nextOrd2CurIdx = collections.defaultdict(list)\n            hist_max = float('-inf')\n            for idx in cur_idxs:\n                if idx < len(s) - level:\n                    nextOrd2CurIdx[ord(s[idx+level])].append(idx)\n                    hist_max = max(hist_max, ord(s[idx+level]))\n            return nextOrd2CurIdx, hist_max\n\n        level = 1\n        while 1:\n            if len(max_ord_idxs) == 1:\n                return s[max_ord_idxs[0]:]\n            \n            nextOrd2CurIdx, hist_max = findNextMaxOrd(max_ord_idxs, level)\n            \n            if len(nextOrd2CurIdx[hist_max]) == 1:\n                return s[nextOrd2CurIdx[hist_max][0]:]\n            else:\n                max_ord_idxs = nextOrd2CurIdx[hist_max]\n                level += 1\n                \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0\n        while i + offset < len(s) and j + offset < len(s):\n            if s[i + offset] == s[j + offset]:\n                offset += 1\n            else:\n                if s[i + offset] < s[j + offset]:\n                    i = j\n                else:\n                    j += offset + 1\n                if i == j:\n                    j += 1\n                offset = 0\n        return s[i :]", "class Solution:\n    # O(n^2) time, O(1) space\n    def lastSubstring(self, s: str) -> str:\n        best = 0\n        n = len(s)\n        for i in range(n):\n            if s[i] > s[best]:\n                best = i\n            elif s[i] == s[best]:\n                idx1, idx2 = best, i\n                while idx2 < n and s[idx1] == s[idx2]:\n                    idx1 += 1\n                    idx2 += 1\n                if idx2 < n and s[idx2] > s[idx1]:\n                    best = i\n        return s[best:]\n\n    def lastSubstring(self, s: str) -> str:\n        i, j, k = 0, 1, 0\n        n = len(s)\n        while j + k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n                i = j + (j - i) if i + k > j else j\n                j = i + 1\n            k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        max_idx = 0\n        curr_idx = 1\n        while curr_idx <= len(s) - 1:\n            step = 0\n            while curr_idx + step <= len(s) - 1 and s[curr_idx + step] == s[max_idx + step]:\n                step += 1\n            \n            if curr_idx + step == len(s):\n                break\n            \n            # s[curr_idx + step] != s[max_idx + step]\n            if s[curr_idx + step] > s[max_idx + step]:\n                max_idx = curr_idx\n                curr_idx = curr_idx + 1\n            else:\n                curr_idx = curr_idx + step + 1\n        return s[max_idx:]", "class Solution:  \n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0\n        while i + offset < len(s) and j + offset < len(s):\n            if s[i + offset] == s[j + offset]:\n                offset += 1\n            else:\n                if s[i + offset] < s[j + offset]:\n                    i = j\n                    j += 1\n                else:\n                    j += offset + 1\n                offset = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # find all indexes of last lex char\n        # for all those indices, compare next char, eliminate non-last lex\n        # continue until there is only one index\n        # append the rest of the string\n        \n        char_index_map = collections.defaultdict(list)\n        for i in range(len(s)):\n            char_index_map[s[i]].append(i)\n        \n        largeC = max(char_index_map)\n        starts = {}\n        for i in char_index_map[largeC]:\n            starts[i] = i+1\n        \n        while len(starts) > 1:\n            to_delete = set()\n            next_chars = collections.defaultdict(list)\n            \n            for start, end in list(starts.items()):\n                if end == len(s):\n                    to_delete.add(start)\n                    continue\n                \n                next_chars[s[end]].append(start)\n                \n                if end in starts:\n                    to_delete.add(end)\n                \n            next_starts = {}\n            largeC = max(next_chars)\n            for start in next_chars[largeC]:\n                if start not in to_delete:\n                    next_starts[start] = starts[start] + 1\n            \n            starts = next_starts.copy()\n        \n        for start in starts:\n            return s[start:]\n        \n", "class Solution:       \n    def lastSubstring(self, s: str) -> str:\n        curr_value = 0\n        max_value = 0\n        max_idx = 0\n        char_to_id = {c: i for i, c in enumerate(sorted(set(s)))}\n        \n        for i in range(len(s) - 1, -1, -1):\n            curr_value = char_to_id[s[i]] + curr_value / len(char_to_id)\n\n            if curr_value > max_value:\n                max_value = curr_value\n                max_idx = i\n\n        return s[max_idx:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        \n        \n        n = len(s);\n        cur = ord(s[0]);\n        indices = [0,0];\n        \n        i=1;\n        \n        while i<n:\n            \n            if cur > ord(s[i]):\n                indices[1]+=1;\n                i+=1;\n            elif cur < ord(s[i]):\n                indices = [i,i];\n                cur = ord(s[i]);\n                i+=1;\n            else:\n                k = indices[0]+1;\n                prev= i;\n                i+=1;\n                while k<prev and i<n:\n                    if ord(s[k]) > ord(s[i]):\n                        indices[1] =i;\n                        break;\n                    elif ord(s[i]) > cur:\n                        indices = [i,i];\n                        cur = ord(s[i]);\n                        break;\n                    elif ord(s[k]) < ord(s[i]):\n                        print(prev,i);\n                        indices = [prev,i];\n                        break;\n                    i+=1;\n                    k+=1;\n                \n                if i==n:\n                    indices[1]=n-1;\n                if k==prev:\n                    indices[1]=i;\n        return s[indices[0]:(indices[1]+1)];", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        def find(s, candidates, step):\n            if len(candidates) == 1:\n                return candidates[0]\n            max_char = max(s[i+step] for i in candidates if i+step < len(s))\n            new_candidates = [i for i in candidates if i+step < len(s) and s[i+step] == max_char]\n            return find(s, new_candidates, step + 1)\n        \n        if not s: return s\n        if len(set(s)) == 1: return s\n        \n        index = find(s, list(range(len(s))), 0)\n        return s[index:]\n        \n        \n            \n            \n            \n        \n        \n        \n        \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        # loop to find the max lexicographic  \n        # substring in the substring array \n        # l = \\\"\\\" \n        # for i in range(len(s)-1,-1,-1): \n        #     l = max(l, s[i:]) \n        #     print(s[i:])\n        # return l\n        if len(set(s)) == 1: return s \n        idx = len(s) - 1\n        for i in range(len(s)-2, -1, -1):\n            k = 0\n            while idx+k < len(s):\n                cur, stored = ord(s[i+k]), ord(s[idx+k])\n                if cur > stored:\n                    idx = i\n                    break\n                elif cur < stored:\n                    break\n                k += 1\n            if idx+k == len(s):\n                idx = i\n        return s[idx:]", "class Solution:\n    def lastSubstring(self, s):\n        i, j, inc = 0, 1, 0\n        while j + inc < len(s):\n          if s[i + inc] == s[j + inc]:\n            inc += 1\n          elif s[i + inc] > s[j + inc]:\n            j += inc + 1\n            inc = 0\n          else:\n            i = j\n            j = i + 1\n            inc = 0\n        return s[i:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i,j,k,n = 0,1,0,len(s)\n        while j + k < n:\n            if s[i+k] == s[j+k]:\n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j+k+1\n            else:\n                i = i+k+1\n            if i==j:\n                j = j+1\n            k = 0\n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i,j,offset=0,1,0\n        while i+offset < len(s) and j+offset < len(s):\n            if s[i+offset]==s[j+offset]:\n                offset+=1\n            \n            else:\n                if s[i+offset]<s[j+offset]:\n                    i+=offset+1\n                else:\n                    j+=offset+1\n                if i>=j:\n                    j=i+1\n                offset=0\n                    \n        return s[i:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i,j,off = 0,1,0\n        while i+off<len(s) and j+off<len(s):\n            if s[i+off]==s[j+off]:\n                off+=1\n            else:\n                if s[i+off]>s[j+off]:\n                    j+=1\n                else:\n                    i = j\n                    j = j+1\n                off = 0\n        return s[i:]\n                \n            \n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        if not s: return None\n        # get max char from s\n        max_char = max(s)\n        max_idxs = []\n        # get all max_char indexs to append into max_idxs\n        for i in range(len(s)):\n            if s[i]==max_char:\n                ## only store the first ind for consecutive max chars\n                if not max_idxs or s[i-1]!=max_char:\n                    max_idxs.append(i)\n        # also append the length of s into the max_idxs for compersion\n        max_idxs.append(len(s))\n        #print(max_idxs)\n        # initialize the temp max letter\n        max_substring = s[max_idxs[0]:max_idxs[1]]\n        ans_idx = max_idxs[0]\n        \n        # using for loop to compare with each short letter those leading by max_char\n        for i in range(1, len(max_idxs)-1):\n            cur = s[max_idxs[i]:max_idxs[i+1]]\n            #print(cur)\n            if max_substring==cur[:len(max_substring)]: #  like \\\"zazaa\\\" case\n                max_substring = max_substring + cur\n                ans_idx = max_idxs[i-1] \n            elif max_substring<cur:\n                max_substring = cur\n                ans_idx = max_idxs[i]\n                \n        return s[ans_idx:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        j = 1\n        offset = 0\n        \n        while i + offset < len(s) and j + offset < len(s):\n            if s[i+offset] == s[j+offset]:\n                offset += 1\n                \n            else:\n                if s[i+offset] < s[j+offset]:\n                    i += offset + 1\n                else:\n                    j += offset + 1\n                    \n                if i == j:\n                    j += 1\n                \n                offset = 0\n                \n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i,j,offset=0,1,0\n        while i+offset < len(s) and j+offset < len(s):\n            if s[i+offset]==s[j+offset]:\n                offset+=1\n            \n            else:\n                if s[i+offset]<s[j+offset]:\n                    i+=offset+1\n                else:\n                    j+=offset+1\n                if i==j:\n                    j+=1\n                offset=0\n                    \n        return s[i:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        j = 1\n        offset = 0\n        \n        while i + offset < len(s) and j + offset < len(s):\n            if s[i+offset] == s[j+offset]:\n                offset += 1\n                \n            else:\n                if s[i+offset] < s[j+offset]:\n                    i += offset+1\n                else:\n                    j += offset+ 1\n                \n                if i == j:\n                    j += 1\n                offset = 0\n                    \n        return s[i:]", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        n = len(s)\n        left = 0; right = 1\n        step = 0\n        \n        while right+step < n:\n            if s[right+step] > s[left+step]:\n                left, right, step = right, right+1, 0\n            elif s[right+step] < s[left+step]:\n                right, step = right+step+1, 0\n            else:\n                step += 1\n                    \n        return s[left:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        k = 0\n        j = 1\n        while j+k<len(s):\n            if s[i+k] == s[j+k]: \n                k += 1\n                continue\n            elif s[i+k] > s[j+k]:\n                j += 1\n            else:\n                i += 1\n                \n            if i == j:\n                j += 1\n            k = 0\n        return s[i:]", "from heapq import *\n\nclass Solution:\n    def lastSubstring(self, s: str) -> str:\n        maxc = max(s)\n        layer = []\n        for i, c in enumerate(s):\n            if c == maxc:\n                layer.append((c, i, i)) # (char, cur, start)\n                \n        N = len(s)\n        ss = set(i for _,_,i in layer)\n        while len(layer) > 1:\n            nc = max(s[j+1] for _, j, i in layer if j+1 < N)\n            newlayer = []\n            todelete = set()\n            for _, j, i in layer:\n                if j+1 < N and s[j+1] == nc and j+1 in ss:\n                    todelete.add(j+1)\n            for _, j, i in layer:\n                if j+1 < N and s[j+1] == nc and i not in todelete:\n                    newlayer.append((nc, j+1, i))\n            layer = newlayer\n        \n        _, cur, start = layer[0]\n        return s[start:]\n        \n", "# test case - \\\"acting\\\" for explanation\nclass Solution: \n    def lastSubstring(self, s: str) -> str:\n        i = 0\n        j = 1\n        k = 0\n        n = len(s)\n        while j+k < n:\n            if s[i+k] == s[j+k]:\n                k+=1\n                continue\n            elif s[i+k] > s[j+k]:\n                j = j + k + 1\n            else:\n                i = max(i+k+1, j)\n                j = i + 1\n            k = 0\n        return s[i:]\n", "class Solution:\n    def lastSubstring(self, s: str) -> str:\n        \n        i = 0\n        j = i + 1\n        k = 0\n        while  j + k < len(s):\n            if s[i + k] == s[j + k]:\n                k = k + 1\n                continue\n            elif s[i + k] > s[j + k]:\n                j = j + 1\n            else:\n                i = max(i+k+1,j)\n                j = i +1\n            k = 0\n        return s[i:]\n", "class Solution:  \n    def lastSubstring(self, s: str) -> str:\n        i, j, offset = 0, 1, 0\n        while i + offset < len(s) and j + offset < len(s):\n            if s[i + offset] == s[j + offset]:\n                offset += 1\n            else:\n                if s[i + offset] < s[j + offset]:\n                    i += offset + 1\n                else:\n                    j += offset + 1\n                if i == j:\n                    j += 1\n                offset = 0\n        return s[i:]"]
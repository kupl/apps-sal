["import sys\ninput = sys.stdin.readline\nimport numpy as np\nfrom heapq import heappush, heappop\n\nN = int(input())\nA = np.array(input().split(), dtype=np.int32)\na_to_i = {a:i for i,a in enumerate(A)}\n\n# sparse table \u3092\u4f7f\u3063\u3066RMQ\n# parity\u306e\u540c\u3058\u3068\u3053\u308d\u3060\u3051\u3092\u898b\u308b\u3088\u3046\u306b\u3057\u3066\u304a\u304f\n\nU = len(A).bit_length()\nsp = [None,A]\nfor i in range(2,U):\n    L = 1 << (i-1)\n    sp.append(np.minimum(sp[-1][:-L], sp[-1][L:]))\n\ndef RMQ(x,y):\n    # x\u756a\u76ee\u304b\u3089\u5076\u6570\u756a\u76ee\u3060\u3051\u898b\u3066[x,y]\u3067\u306e\u6700\u5c0f\u5024\u3092\u8fd4\u3059\n    d = y - x\n    if d <= 1:\n        return A[x]\n    n = d.bit_length()\n    return min(sp[n-1][x], sp[n-1][y+2-(1<<(n-1))])\n\ndef F(x,y):\n    # \u8f9e\u66f8\u5f0f\u3067\u6700\u5c0f\u306e2\u3064\u7d44\u3092\u3068\u308b\n    # \u305d\u306e\u3042\u3068\u3001\u4eca\u5f8c\u8abf\u3079\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u533a\u9593\u306e\u4e00\u89a7\u3092\u8fd4\u3059\n    x1 = RMQ(x,y-1)\n    i1 = a_to_i[x1]\n    x2 = RMQ(i1+1,y)\n    i2 = a_to_i[x2]\n    task = ((x,y) for x,y in ((x,i1-1), (i1+1,i2-1), (i2+1,y)) if y > x)\n    return x1,x2,task\n\nq = [(None,None,((0,N-1),))]\nanswer = []\nwhile q:\n    x,y,task = heappop(q)\n    answer.append(x)\n    answer.append(y)\n    for left,right in task:\n        heappush(q,F(left,right))\n\nprint(' '.join(map(str,answer[2:])))", "\n\nclass SegmentTree():\n  def __init__(self,size,f=lambda x,y:x+y,default=0):\n    self.size=pow(2,(size-1).bit_length())\n    self.f=f\n    self.default=default\n    self.data=[default]*(self.size*2)\n  def update(self,i,x):\n    i+=self.size\n    self.data[i]=x\n    while i:\n      i>>=1\n      self.data[i]=self.f(self.data[i*2],self.data[i*2+1])\n  # \u533a\u9593[l,r)\u3078\u306e\u30af\u30a8\u30ea\n  def query(self,l,r):\n    l,r=l+self.size,r+self.size\n    lret,rret=self.default,self.default\n    while l<r:\n      if l&1:\n        lret=self.f(self.data[l],lret)\n        l+=1\n      if r&1:\n        r-=1\n        rret=self.f(self.data[r],rret)\n      l>>=1\n      r>>=1\n    return self.f(lret,rret)\n  def get(self,i):\n    return self.data[self.size+i]\n  def add(self,i,x):\n    self.update(i,self.get(i)+x)\n\nfrom heapq import heappop,heappush\ndef main1(n,p):\n  d={}\n  st0=SegmentTree(n,min,n+1)\n  st1=SegmentTree(n,min,n+1)\n  for i,x in enumerate(p):\n    d[x]=i\n    if i%2==0:\n      st0.update(i,x)\n    else:\n      st1.update(i,x)\n  def func(l,r):\n    if l%2==0:\n      v0=st0.query(l,r)\n      i0=d[v0]\n      v1=st1.query(i0,r)\n    else:\n      v0=st1.query(l,r)\n      i0=d[v0]\n      v1=st0.query(i0,r)\n    return v0,v1,l,r\n  # \u533a\u9593\u3054\u3068\u306e\u8f9e\u66f8\u9806\u6700\u5c0f\u5148\u982d\u3092\u7ba1\u7406\uff1a[[v0,v1],[v0,v1,...]\n  ary=[]\n  heappush(ary,func(0,n))\n  ret=[]\n  for _ in range(n//2):\n    v0,v1,l,r=heappop(ary)\n    ret.append(v0)\n    ret.append(v1)\n    i0=d[v0]\n    i1=d[v1]\n    if i0!=l:\n      heappush(ary,func(l,i0))\n    if i0+1!=i1:\n      heappush(ary,func(i0+1,i1))\n    if i1+1!=r:\n      heappush(ary,func(i1+1,r))\n  return ret\n\ndef __starting_point():\n  n=int(input())\n  p=list(map(int,input().split()))\n  ret1=main1(n,p.copy())\n  print((*ret1))\n\n__starting_point()", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\nclass Seg():\n    def __init__(self, na, default, func):\n        if isinstance(na, list):\n            n = len(na)\n        else:\n            n = na\n        i = 1\n        while 2**i <= n:\n            i += 1\n        self.D = default\n        self.H = i\n        self.N = 2**i\n        if isinstance(na, list):\n            self.A = [default] * (self.N) + na + [default] * (self.N-n)\n            for i in range(self.N-1,0,-1):\n                self.A[i] = func(self.A[i*2], self.A[i*2+1])\n        else:\n            self.A = [default] * (self.N*2)\n        self.F = func\n\n    def find(self, i):\n        return self.A[i + self.N]\n\n    def update(self, i, x):\n        i += self.N\n        self.A[i] = x\n        while i > 0:\n            i = (i-1) // 2\n            self.A[i] = self.merge(self.A[i*2], self.A[i*2+1])\n\n    def merge(self, a, b):\n        return self.F(a, b)\n\n    def total(self):\n        return self.A[0]\n\n    def query(self, a, b):\n        A = self.A\n        l = a + self.N\n        r = b + self.N\n        res = self.D\n        while l < r:\n            if l % 2 == 1:\n                res = self.merge(res, A[l])\n                l += 1\n            if r % 2 == 1:\n                r -= 1\n                res = self.merge(res, A[r])\n            l >>= 1\n            r >>= 1\n\n        return res\n\ndef main():\n    n = I()\n    a = LI()\n\n    def sf(a,b):\n        if a < b:\n            return a\n        return b\n\n    s1 = Seg([c if i%2==0 else inf for c,i in zip(a,list(range(n)))],inf,sf)\n    s2 = Seg([c if i%2==1 else inf for c,i in zip(a,list(range(n)))],inf,sf)\n    d = {}\n\n    for i in range(n):\n        d[a[i]] = i\n\n    def f(l,r):\n        if l % 2 == 0:\n            t = s1.query(l,r)\n            ti = d[t]\n            u = s2.query(ti+1,r)\n        else:\n            t = s2.query(l,r)\n            ti = d[t]\n            u = s1.query(ti+1,r)\n        ui = d[u]\n        nl = []\n        if l < ti:\n            nl.append((l, ti))\n        if ui - ti > 1:\n            nl.append((ti+1, ui))\n        if ui < r-1:\n            nl.append((ui+1, r))\n        return ((t,u), nl)\n\n    q = []\n    heapq.heappush(q, f(0,n))\n    r = []\n    while q:\n        t,nl = heapq.heappop(q)\n        r.append(t[0])\n        r.append(t[1])\n        for t,u in nl:\n            heapq.heappush(q, f(t,u))\n\n    return ' '.join(map(str,r))\n\nprint((main()))\n\n\n\n", "import sys\ninput = sys.stdin.readline\n\n# O(NlogN)\u69cb\u7bc9\u3001\u30af\u30a8\u30eaO(1)\u306eRMQ\n# \u5909\u66f4\u306f\u3067\u304d\u306a\u3044\nclass SparseTable():\n    def __init__(self, N, A):\n        self.N = N\n        self.logN = N.bit_length()\n        self.A = A\n        self.table = [[i for i in range(N)]]\n        for k in range(self.logN):\n            tab = []\n            for i in range(self.N-(1<<(k+1))+1):\n                ind1 = self.table[-1][i]\n                ind2 = self.table[-1][i+(1<<k)]\n                if self.A[ind1] <= self.A[ind2]:\n                    tab.append(ind1)\n                else:\n                    tab.append(ind2)\n            self.table.append(tab)\n    \n    # [l, r)\u306emin\u306e(val, key)\n    def query_min(self, l, r):\n        k = (r-l).bit_length()-1\n        indl = self.table[k][l]\n        indr = self.table[k][r-(1<<k)]\n        if self.A[indl] <= self.A[indr]:\n            return self.A[indl], indl\n        return self.A[indr], indr\n\nimport heapq as hp\nN = int(input())\nA = list(map(int, input().split()))\n\ndef main():\n    SP1 = SparseTable((N+1)//2, A[::2])\n    SP2 = SparseTable(N//2, A[1::2])\n\n    ans = []\n    q = []\n    v, k = SP1.query_min(0, N//2)\n    dic = {}\n    dic[v] = (k, 0, N//2, True)\n    hp.heappush(q, v)\n    for _ in range(N//2):\n        valuea = hp.heappop(q)\n        ka, l, r, is1 = dic[valuea]\n        ans.append(str(valuea))\n        if is1:\n            valueb, kb = SP2.query_min(ka, r)\n            if ka < kb:\n                m2, nk2 = SP2.query_min(ka, kb)\n                hp.heappush(q, m2)\n                dic[m2] = (nk2, ka, kb+1, False)\n            if l < ka:\n                m1, nk1 = SP1.query_min(l, ka)\n                hp.heappush(q, m1)\n                dic[m1] = (nk1, l, ka, True)\n            if kb+1 < r:\n                m3, nk3 = SP1.query_min(kb+1, r)\n                hp.heappush(q, m3)\n                dic[m3] = (nk3, kb+1, r, True)\n        else:\n            valueb, kb = SP1.query_min(ka+1, r)\n            if ka+1 < kb:\n                m1, nk1 = SP1.query_min(ka+1, kb)\n                hp.heappush(q, m1)\n                dic[m1] = (nk1, ka+1, kb, True)\n            if l < ka:\n                m2, nk2 = SP2.query_min(l, ka)\n                hp.heappush(q, m2)\n                dic[m2] = (nk2, l, ka+1, False)\n            if kb < r-1:\n                m3, nk3 = SP2.query_min(kb, r-1)\n                hp.heappush(q, m3)\n                dic[m3] = (nk3, kb, r, False)\n\n        ans.append(str(valueb))\n\n    print(\" \".join(ans))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "#####segfunc#####\ndef segfunc(x, y):\n    if y[0]>x[0]:\n        return x\n    else:\n        return y\n#################\n\n#####ide_ele#####\nide_ele =(float(\"inf\"),-1)\n#################\n\nclass SegTree:\n    \"\"\"\n    init(init_val, ide_ele): \u914d\u5217init_val\u3067\u521d\u671f\u5316 O(N)\n    update(k, x): k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0 O(logN)\n    query(l, r): \u533a\u9593[l, r)\u3092segfunc\u3057\u305f\u3082\u306e\u3092\u8fd4\u3059 O(logN)\n    \"\"\"\n    def __init__(self, init_val, segfunc, ide_ele):\n        \"\"\"\n        init_val: \u914d\u5217\u306e\u521d\u671f\u5024\n        segfunc: \u533a\u9593\u306b\u3057\u305f\u3044\u64cd\u4f5c\n        ide_ele: \u5358\u4f4d\u5143\n        n: \u8981\u7d20\u6570\n        num: n\u4ee5\u4e0a\u306e\u6700\u5c0f\u306e2\u306e\u3079\u304d\u4e57\n        tree: \u30bb\u30b0\u30e1\u30f3\u30c8\u6728(1-index)\n        \"\"\"\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # \u914d\u5217\u306e\u5024\u3092\u8449\u306b\u30bb\u30c3\u30c8\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        # \u69cb\u7bc9\u3057\u3066\u3044\u304f\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        \"\"\"\n        k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0\n        k: index(0-index)\n        x: update value\n        \"\"\"\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)\u306esegfunc\u3057\u305f\u3082\u306e\u3092\u5f97\u308b\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\nimport heapq\n\nN=int(input())\np=list(map(int,input().split()))\nn=N//2\nop=[(p[2*i+1],2*i+1) for i in range(n)]\nep=[(p[2*i],2*i) for i in range(n)]\n\noseg=SegTree(op,segfunc,ide_ele)\neseg=SegTree(ep,segfunc,ide_ele)\n\ndef first(l,r):\n    if l>=r:\n        return (-1,-1,-1,-1)\n    if l%2==0:\n        val,index=eseg.query(l//2,r//2)\n        val2,index2=oseg.query(index//2,r//2)\n        return (val,val2,index,index2)\n    else:\n        val,index=oseg.query(l//2,r//2)\n        val2,index2=eseg.query(index//2+1,r//2+1)\n        return (val,val2,index,index2)\n\nval,val2,index,index2=first(0,N)\nque=[((val,val2),0,N)]\nheapq.heapify(que)\nans=[]\nwhile que:\n    tuple,l,r=heapq.heappop(que)\n    ans.append(tuple[0])\n    ans.append(tuple[1])\n    val,val2,index,index2=first(l,r)\n    val,val2,l1,r1=first(l,index)\n    if val!=-1:\n        heapq.heappush(que,((val,val2),l,index))\n    val,val2,l2,r2=first(index+1,index2)\n    if val!=-1:\n        heapq.heappush(que,((val,val2),index+1,index2))\n    val,val2,l3,r3=first(index2+1,r)\n    if val!=-1:\n        heapq.heappush(que,((val,val2),index2+1,r))\n\nprint(*ans)", "def main():\n    n = int(input())\n    p = list([int(x)-1 for x in input().split()])\n\n    pos = [j for i, j in sorted([(j, i) for i, j in enumerate(p)])]\n    basesize = n >> 1\n    num = 1\n    while num < basesize:\n        num *= 2\n    num -= 1\n\n    tree_even = [100001]*(num*2+1)\n    tree_odd = [100001]*(num*2+1)\n\n    for i in range(num, num+basesize):\n        tree_even[i] = p[(i-num)*2]\n    for i in range(num-1, -1, -1):\n        tree_even[i] = min(tree_even[2*i+1:2*i+3])\n    for i in range(num, num+basesize):\n        tree_odd[i] = p[(i-num)*2+1]\n    for i in range(num-1, -1, -1):\n        tree_odd[i] = min(tree_odd[2*i+1:2*i+3])\n\n    g = dict()\n    d = dict()\n    q = [n-1]\n    qap, qp = q.append, q.pop\n    while q:\n        t = qp()\n        m, M = t//n, t % n\n        if m+1 == M:\n            d[t] = p[m]*n+p[M]\n            continue\n        g[t] = []\n        gap = g[t].append\n        if m % 2 == 0:\n            i1, j1 = m >> 1, (M >> 1)+1\n            even = 200000\n            l, r = i1+num, j1+num\n            while l < r:\n                if r % 2 == 0:\n                    r -= 1\n                    even = min(even, tree_even[r])\n                if l % 2 == 0:\n                    even = min(even, tree_even[l])\n                    l += 1\n                l >>= 1\n                r >>= 1\n            even_idx = pos[even]\n            odd = 200000\n            l, r = (even_idx >> 1)+num, j1+num\n            while l < r:\n                if r % 2 == 0:\n                    r -= 1\n                    odd = min(odd, tree_odd[r])\n                if l % 2 == 0:\n                    odd = min(odd, tree_odd[l])\n                    l += 1\n                l >>= 1\n                r >>= 1\n            odd_idx = pos[odd]\n            d[t] = even*n+odd\n            if m != even_idx:\n                s = m*n+even_idx-1\n                qap(s)\n                gap(s)\n            if M != odd_idx:\n                s = (odd_idx+1)*n+M\n                qap(s)\n                gap(s)\n            if even_idx+1 != odd_idx:\n                s = (even_idx+1)*n+odd_idx-1\n                qap(s)\n                gap(s)\n        else:\n            i1, j1 = m >> 1, M >> 1\n            odd = 200000\n            l, r = i1+num, j1+num\n            while l < r:\n                if r % 2 == 0:\n                    r -= 1\n                    odd = min(odd, tree_odd[r])\n                if l % 2 == 0:\n                    odd = min(odd, tree_odd[l])\n                    l += 1\n                l >>= 1\n                r >>= 1\n            odd_idx = pos[odd]\n            even = 200000\n            l, r = (odd_idx >> 1)+1+num, j1+1+num\n            while l < r:\n                if r % 2 == 0:\n                    r -= 1\n                    even = min(even, tree_even[r])\n                if l % 2 == 0:\n                    even = min(even, tree_even[l])\n                    l += 1\n                l >>= 1\n                r >>= 1\n            even_idx = pos[even]\n            d[t] = odd*n+even\n            if m != odd_idx:\n                s = m*n+odd_idx-1\n                qap(s)\n                gap(s)\n            if M != even_idx:\n                s = (even_idx+1)*n+M\n                qap(s)\n                gap(s)\n            if odd_idx+1 != even_idx:\n                s = (odd_idx+1)*n+even_idx-1\n                qap(s)\n                gap(s)\n\n    g2 = dict()\n\n    for i, t in list(g.items()):\n        k = d[i]\n        g2[k] = []\n        ga = g2[k].append\n        for j in t:\n            ga(d[j])\n\n    import heapq\n    h = [d[n-1]]\n    heapq.heapify(h)\n    ans = []\n    hpop = heapq.heappop\n    hpush = heapq.heappush\n\n    while h:\n        t = hpop(h)\n        ans += [t//n+1, t % n+1]\n        if t in g2:\n            for s in g2[t]:\n                hpush(h, s)\n\n    print((*ans))\n\n\nmain()\n", "# seishin.py\nN = int(input())\n*P, = map(int, input().split())\nM = [0]*(N+1)\nfor i, p in enumerate(P):\n    M[p] = i\n\nINF = 10**9\ndef init(P, n):\n    n0 = 2 ** (n-1).bit_length()\n    data = [INF]*(n0*2)\n    data[n0-1:n0+n-1] = P\n    for i in range(n0-2, -1, -1):\n        data[i] = min(data[2*i+1], data[2*i+2])\n    return data\n\ndef get_data(data, l, r):\n    n0 = len(data)//2\n    l += n0\n    r += n0\n    while l < r:\n        if r&1:\n            r -= 1\n            yield data[r-1]\n        if l&1:\n            yield data[l-1]\n            l += 1\n        l >>= 1\n        r >>= 1\n\ndef get(data, l, r):\n    return min(get_data(data, l, r))\n\nd0 = init(P[0::2], N//2)\nd1 = init(P[1::2], N//2)\n\ndef query_x(l, r):\n    if l % 2 == 0:\n        x = get(d0, l//2, r//2)\n    else:\n        x = get(d1, l//2, r//2)\n    return x\ndef query_y(l, r):\n    if l % 2 == 0:\n        y = get(d1, l//2, r//2)\n    else:\n        y = get(d0, (l+1)//2, (r+1)//2)\n    return y\n\nfrom heapq import heappush, heappop\nque = [(query_x(0, N), 0, N)]\nans = []\nwhile que:\n    x, l, r = heappop(que)\n    if l+2 < r:\n        xi = M[x]\n        y = query_y(xi, r)\n\n        yi = M[y]\n\n        # [l, xi)\n        if l < xi:\n            heappush(que, (query_x(l, xi), l, xi))\n        # [xi+1, yi)\n        if xi+1 < yi:\n            heappush(que, (query_x(xi+1, yi), xi+1, yi))\n        # [yi+1, r)\n        if yi+1 < r:\n            heappush(que, (query_x(yi+1, r), yi+1, r))\n    else:\n        y = P[r-1]\n\n    ans.append(\"%d %d\" % (x, y))\nprint(*ans)", "import sys\nreadline = sys.stdin.readline\nfrom heapq import heappop as hpp, heappush as hp\nclass Segtree:\n    def __init__(self, A, intv, initialize = True, segf = max):\n        self.N = len(A)\n        self.N0 = 2**(self.N-1).bit_length()\n        self.intv = intv\n        self.segf = segf\n        if initialize:\n            self.data = [intv]*self.N0 + A + [intv]*(self.N0 - self.N)\n            for i in range(self.N0-1, 0, -1):\n                self.data[i] = self.segf(self.data[2*i], self.data[2*i+1]) \n        else:\n            self.data = [intv]*(2*self.N0)\n        \n    def update(self, k, x):\n        k += self.N0\n        self.data[k] = x\n        while k > 0 :\n            k = k >> 1\n            self.data[k] = self.segf(self.data[2*k], self.data[2*k+1])\n    \n    def query(self, l, r):\n        L, R = l+self.N0, r+self.N0\n        s = self.intv\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.segf(s, self.data[R])\n            if L & 1:\n                s = self.segf(s, self.data[L])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n    \n    def binsearch(self, l, r, check, reverse = False):\n        L, R = l+self.N0, r+self.N0\n        SL, SR = [], []\n        while L < R:\n            if R & 1:\n                R -= 1\n                SR.append(R)\n            if L & 1:\n                SL.append(L)\n                L += 1\n            L >>= 1\n            R >>= 1\n        \n        if reverse:\n            for idx in (SR + SL[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx+1]):\n                    idx = 2*idx + 1\n                else:\n                    idx = 2*idx\n            return idx\n        else:\n            for idx in (SL + SR[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx]):\n                    idx = 2*idx\n                else:\n                    idx = 2*idx + 1\n            return idx\n\nN = int(readline())\n\ninf = 1<<32\nP = list(map(int, readline().split()))\n\nPi = [None]*(N+1)\nfor i in range(N):\n    Pi[P[i]] = i\n\ninf = 1<<32\nPeven = [P[i] if not i&1 else inf for i in range(N)]\nPodd = [P[i] if i&1 else inf for i in range(N)]\n\nTeven = Segtree(Peven, inf, initialize = True, segf = min)\nTodd = Segtree(Podd, inf, initialize = True, segf = min)\nN0 = 2**(N-1).bit_length()\n\nQ = [(Teven.query(0, N0), 0, N0)]\nfor i in range(N//2):\n    t1, l, r = hpp(Q)\n    K = []\n    if not l&1:\n        p1 = Pi[t1]\n        t2 = Todd.query(p1, r)\n        p2 = Pi[t2]\n        Teven.update(p1, inf)\n        Todd.update(p2, inf)\n    else:\n        p1 = Pi[t1]\n        t2 = Teven.query(p1, r)\n        p2 = Pi[t2]\n        Todd.update(p1, inf)\n        Teven.update(p2, inf)\n    if l < p1:\n        K.append((l, p1))\n    if p2 < r:\n        K.append((p2+1, r))\n    if p1 + 1 < p2:\n        K.append((p1+1, p2))\n    for l, r in K:\n        if not l&1:\n            mq = Teven.query(l, r)\n        else:\n            mq = Todd.query(l, r)\n        hp(Q, (mq, l, r))\n    sys.stdout.write('{} {} '.format(t1, t2))\nsys.stdout.write('\\n')", "inf = 10**10\ndef sg_func(a,b):\n    res = [0,0,0]\n    if(a[2]==0):\n        res[0] = min(a[0],b[0])\n        res[1] = min(a[1],b[1])\n    else:\n        res[0] = min(a[0],b[1])\n        res[1] = min(a[1],b[0])\n\n    res[2] = (a[2]+b[2])%2\n\n    return res\n\n\nclass Seg_cus():\n    def __init__(self,x):\n        #####\u5358\u4f4d\u5143######\n        self.ide_ele_min = inf\n        self.func = sg_func\n\n        self.n = len(x)\n\n        #num_max:n\u4ee5\u4e0a\u306e\u6700\u5c0f\u306e2\u306e\u3079\u304d\u4e57\n        self.num_max =2**(self.n-1).bit_length()\n        self.x = [[self.ide_ele_min,self.ide_ele_min,0] for _  in range(2*self.num_max)]\n\n        for i,num in enumerate(x, self.num_max):\n            self.x[i][0] = num\n            self.x[i][2] = 1\n        for i in range(self.num_max-1,0,-1):\n            self.x[i] = self.func(self.x[i<<1],self.x[(i<<1) + 1])\n\n    def delete(self,i):\n        i += self.num_max\n        self.x[i][0] = inf\n        self.x[i][2] = 0\n        while(i>0):\n            i = i//2\n            self.x[i] = self.func(self.x[i<<1],self.x[(i<<1) + 1])\n\n    def query(self,i,j):\n        res = [self.ide_ele_min,self.ide_ele_min,0]\n        if i>=j:\n            return res\n        i += self.num_max\n        j += self.num_max -1\n        stack_i = []\n        stack_j = []\n        while(i<=j):\n            if(i==j):\n                stack_i.append(i)\n                break\n            if(i&1):\n                stack_i.append(i)\n                i += 1\n            if(not j&1):\n                stack_j.append(j)\n                j -= 1\n            i = i>>1\n            j = j>>1\n        for i in stack_i:\n            res = self.func(res,self.x[i])\n        for i in stack_j[::-1]:\n            res = self.func(res,self.x[i])\n\n        return res\n\nclass Seg_min():\n    def __init__(self,x):\n        #####\u5358\u4f4d\u5143######\n        self.ide_ele_min = 10**10\n        self.func = min\n\n        self.n = len(x)\n\n        #num_max:n\u4ee5\u4e0a\u306e\u6700\u5c0f\u306e2\u306e\u3079\u304d\u4e57\n        self.num_max =2**(self.n-1).bit_length()\n        self.x = [self.ide_ele_min]*2*self.num_max\n\n        for i,num in enumerate(x, self.num_max):\n            self.x[i] = num\n        for i in range(self.num_max-1,0,-1):\n            self.x[i] = self.func(self.x[i<<1],self.x[(i<<1) + 1])\n\n    def update(self,i,x):\n        i += self.num_max\n        self.x[i] = x\n        while(i>0):\n            i = i//2\n            self.x[i] = self.func(self.x[i<<1],self.x[(i<<1) + 1])\n\n    def query(self,i,j):\n        res = self.ide_ele_min\n        if i>=j:\n            return res\n        i += self.num_max\n        j += self.num_max -1\n        while(i<=j):\n            if(i==j):\n                res = self.func(res,self.x[i])\n                break\n            if(i&1):\n                res = self.func(res,self.x[i])\n                i += 1\n            if(not j&1):\n                res = self.func(res,self.x[j])\n                j -= 1\n            i = i>>1\n            j = j>>1\n        return res\n\nn = int(input())\np = list(map(int,input().split()))\n\nind = [0] * (n+1)\nfor i,pi in enumerate(p):\n    ind[pi] = i\n\nst = Seg_cus(p)\nst_ind = Seg_min([n] * n)\n\nans = []\nfor _ in range(n//2):\n    num1 = st.query(0,n)[0]\n    num2 = st.query(ind[num1],st_ind.query(ind[num1],n))[1]\n    ans.append(num1)\n    ans.append(num2)\n\n    # print(num1,num2)\n    # print(ind[num1],ind[num2])\n    # print(st.x)\n    # print(st_ind.x)\n    st.delete(ind[num1])\n    st.delete(ind[num2])\n    st_ind.update(ind[num1],ind[num1])\n    st_ind.update(ind[num2],ind[num2])\n\nprint(' '.join(map(str,ans)))", "from heapq import heappop, heappush\nn = int(input())\np = [int(x) for x in input().split()]\n\n\nclass SegmentTree:  # 0-indexed\n    def __init__(self, array, operation=min, identity=10**30):\n        self.identity = identity\n        self.n = len(array)\n        self.N = 1 << (self.n - 1).bit_length()\n        self.tree = [self.identity] * 2 * self.N\n        self.opr = operation\n        for i in range(self.n):\n            self.tree[i+self.N-1] = array[i]\n        for i in range(self.N-2, -1, -1):\n            self.tree[i] = self.opr(self.tree[2*i+1], self.tree[2*i+2])\n\n    def values(self):\n        return self.tree[self.N-1:]\n\n    def update(self, k, x):\n        k += self.N-1\n        self.tree[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.tree[k] = self.opr(self.tree[k*2+1], self.tree[k*2+2])\n\n    def query(self, p, q):  # [p,q)\n        if q <= p:\n            print(\"Oops!  That was no valid number.  Try again...\")\n            return\n        p += self.N-1\n        q += self.N-2\n        res = self.identity\n        while q-p > 1:\n            if p & 1 == 0:\n                res = self.opr(res, self.tree[p])\n            if q & 1 == 1:\n                res = self.opr(res, self.tree[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.opr(res, self.tree[p])\n        else:\n            res = self.opr(self.opr(res, self.tree[p]), self.tree[q])\n        return res\n\n\nind = [0]*(n+1)\nOdd = SegmentTree([10**30]*n)\nEven = SegmentTree([10**30]*n)\n\nfor i in range(n):\n    ind[p[i]] = i\n    if i % 2 == 0:\n        Even.update(i, p[i])\n    else:\n        Odd.update(i, p[i])\n\ncand = []\nheappush(cand, (Even.query(0, n), 0, n, True))\n\nq = []\nfor _ in range(n//2):\n    first, l, r, is_even = heappop(cand)\n    if is_even:\n        second = Odd.query(ind[first]+1, r)\n        q.extend([first, second])\n        if l < ind[first]:\n            heappush(cand, (Even.query(l, ind[first]), l, ind[first], True))\n        if ind[first] + 1 < ind[second]:\n            heappush(\n                cand, (Odd.query(ind[first]+1, ind[second]), ind[first]+1, ind[second], False))\n        if ind[second]+1 < r:\n            heappush(\n                cand, (Even.query(ind[second], r), ind[second]+1, r, True))\n    else:\n        second = Even.query(ind[first]+1, r)\n        q.extend([first, second])\n        if l < ind[first]:\n            heappush(cand, (Odd.query(l, ind[first]), l, ind[first], False))\n        if ind[first] + 1 < ind[second]:\n            heappush(\n                cand, (Even.query(ind[first]+1, ind[second]), ind[first]+1, ind[second], True))\n        if ind[second]+1 < r:\n            heappush(\n                cand, (Odd.query(ind[second], r), ind[second]+1, r, False))\n\nprint((*q))\n", "from heapq import heappop, heappush\nn = int(input())\np = [int(x) for x in input().split()]\n\n\nclass SegmentTree:  # 0-indexed\n    def __init__(self, array, operation=min, identity=10**30):\n        self.identity = identity\n        self.n = len(array)\n        self.N = 1 << (self.n - 1).bit_length()\n        self.tree = [self.identity] * 2 * self.N\n        self.opr = operation\n        for i in range(self.n):\n            self.tree[i+self.N-1] = array[i]\n        for i in range(self.N-2, -1, -1):\n            self.tree[i] = self.opr(self.tree[2*i+1], self.tree[2*i+2])\n\n    def values(self):\n        return self.tree[self.N-1:]\n\n    def update(self, k, x):\n        k += self.N-1\n        self.tree[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.tree[k] = self.opr(self.tree[k*2+1], self.tree[k*2+2])\n\n    def query(self, p, q):  # [p,q)\n        if q <= p:\n            print(\"Oops!  That was no valid number.  Try again...\")\n            return\n        p += self.N-1\n        q += self.N-2\n        res = self.identity\n        while q-p > 1:\n            if p & 1 == 0:\n                res = self.opr(res, self.tree[p])\n            if q & 1 == 1:\n                res = self.opr(res, self.tree[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.opr(res, self.tree[p])\n        else:\n            res = self.opr(self.opr(res, self.tree[p]), self.tree[q])\n        return res\n\n\nind = [0]*(n+1)\nOdd = SegmentTree([10**30]*n)\nEven = SegmentTree([10**30]*n)\n\nfor i in range(n):\n    ind[p[i]] = i\n    if i % 2 == 0:\n        Even.update(i, p[i])\n    else:\n        Odd.update(i, p[i])\n\ncand = []\nheappush(cand, (Even.query(0, n), 0, n, True))\n\nq = []\nwhile len(q) < n:\n    first, l, r, is_even = heappop(cand)\n    if is_even:\n        second = Odd.query(ind[first]+1, r)\n        q.extend([first, second])\n        if l < ind[first]:\n            heappush(cand, (Even.query(l, ind[first]), l, ind[first], True))\n        if ind[first] + 1 < ind[second]:\n            heappush(\n                cand, (Odd.query(ind[first]+1, ind[second]), ind[first]+1, ind[second], False))\n        if ind[second]+1 < r:\n            heappush(\n                cand, (Even.query(ind[second], r), ind[second]+1, r, True))\n    else:\n        second = Even.query(ind[first]+1, r)\n        q.extend([first, second])\n        if l < ind[first]:\n            heappush(cand, (Odd.query(l, ind[first]), l, ind[first], False))\n        if ind[first] + 1 < ind[second]:\n            heappush(\n                cand, (Even.query(ind[first]+1, ind[second]), ind[first]+1, ind[second], True))\n        if ind[second]+1 < r:\n            heappush(\n                cand, (Odd.query(ind[second], r), ind[second]+1, r, False))\n\nprint((*q))\n", "# seishin.py\nN = int(input())\n*P, = map(int, input().split())\nM = [0]*(N+1)\nfor i, p in enumerate(P):\n    M[p] = i\n\nINF = 10**9\ndef init(P, n):\n    n0 = 2 ** (n-1).bit_length()\n    data = [INF]*(n0*2)\n    data[n0-1:n0+n-1] = P\n    for i in range(n0-2, -1, -1):\n        data[i] = min(data[2*i+1], data[2*i+2])\n    return data\n\ndef get_data(data, l, r):\n    n0 = len(data)//2\n    l += n0\n    r += n0\n    while l < r:\n        if r&1:\n            r -= 1\n            yield data[r-1]\n        if l&1:\n            yield data[l-1]\n            l += 1\n        l >>= 1\n        r >>= 1\n\ndef get(data, l, r):\n    return min(get_data(data, l, r))\n\nd0 = init(P[0::2], N//2)\nd1 = init(P[1::2], N//2)\n\ndef query_x(l, r):\n    if l % 2 == 0:\n        x = get(d0, l//2, r//2)\n    else:\n        x = get(d1, l//2, r//2)\n    return x\ndef query_y(l, r):\n    if l % 2 == 0:\n        y = get(d1, l//2, r//2)\n    else:\n        y = get(d0, (l+1)//2, (r+1)//2)\n    return y\n\nfrom heapq import heappush, heappop\nque = [(query_x(0, N), 0, N)]\nans = []\nwhile que:\n    x, l, r = heappop(que)\n    if l+2 < r:\n        xi = M[x]\n        y = query_y(xi, r)\n\n        yi = M[y]\n\n        # [l, xi)\n        if l < xi:\n            heappush(que, (query_x(l, xi), l, xi))\n        # [xi+1, yi)\n        if xi+1 < yi:\n            heappush(que, (query_x(xi+1, yi), xi+1, yi))\n        # [yi+1, r)\n        if yi+1 < r:\n            heappush(que, (query_x(yi+1, r), yi+1, r))\n    else:\n        y = P[r-1]\n\n    ans.append(\"%d %d\" % (x, y))\nprint(*ans)", "# seishin.py\nN = int(input())\n*P, = map(int, input().split())\nM = [0]*(N+1)\nfor i, p in enumerate(P):\n    M[p] = i\n\nINF = 10**9\ndef init(P, n):\n    n0 = 2 ** (n-1).bit_length()\n    data = [INF]*(n0*2)\n    data[n0-1:n0+n-1] = P\n    for i in range(n0-2, -1, -1):\n        data[i] = min(data[2*i+1], data[2*i+2])\n    return data\n\n\"\"\"\ndef __get(data, a, b, k, l, r):\n    if a <= l and r <= b:\n        return data[k]\n    if b <= l or r <= a:\n        return INF\n    vl = __get(data, a, b, 2*k+1, l, (l+r)//2)\n    vr = __get(data, a, b, 2*k+2, (l+r)//2, r)\n    return min(vl, vr)\n\"\"\"\n\ndef get_data(data, l, r):\n    n0 = len(data)//2\n    l += n0\n    r += n0\n    while l < r:\n        if r&1:\n            r -= 1\n            yield data[r-1]\n        if l&1:\n            yield data[l-1]\n            l += 1\n        l >>= 1\n        r >>= 1\n    yield INF\n\ndef get(data, l, r):\n    #return __get(data, l, r, 0, 0, len(data)//2)\n    return min(get_data(data, l, r))\n\nd0 = init(P[0::2], N//2)\nd1 = init(P[1::2], N//2)\n\ndef query_x(l, r):\n    if l % 2 == 0:\n        x = get(d0, l//2, r//2)\n    else:\n        x = get(d1, l//2, r//2)\n    return x\ndef query_y(l, r):\n    if l % 2 == 0:\n        y = get(d1, l//2, r//2)\n    else:\n        y = get(d0, (l+1)//2, (r+1)//2)\n    return y\n\nfrom heapq import heappush, heappop\nque = [(query_x(0, N), 0, N)]\nans = []\nwhile que:\n    x, l, r = heappop(que)\n    if l+2 < r:\n        xi = M[x]\n        y = query_y(xi, r)\n\n        yi = M[y]\n\n        # [l, xi)\n        if l < xi:\n            heappush(que, (query_x(l, xi), l, xi))\n        # [xi+1, yi)\n        if xi+1 < yi:\n            heappush(que, (query_x(xi+1, yi), xi+1, yi))\n        # [yi+1, r)\n        if yi+1 < r:\n            heappush(que, (query_x(yi+1, r), yi+1, r))\n    else:\n        y = P[r-1]\n\n    ans.append(\"%d %d\" % (x, y))\nprint(*ans)", "import heapq\nimport sys\ninput=sys.stdin.readline\n\nclass SegmentTreeMin():\n  def __init__(self,n,init):\n    self.offset=2**((n-1).bit_length())\n    self.tree=[init]*(2*self.offset)\n    self.init=init\n  def update(self,pos,val):\n    pos+=self.offset\n    self.tree[pos]=val\n    while pos>1:\n      pos=pos//2\n      self.tree[pos]=min(self.tree[2*pos],self.tree[2*pos+1])\n  def query(self,l,r):\n    l+=self.offset\n    r+=self.offset\n    ret=self.init\n    while l<=r:\n      ret=min(ret,self.tree[r])\n      r=(r-1)//2\n      ret=min(ret,self.tree[l])\n      l=(l+1)//2\n    return ret\n\nn=int(input())\narr=list(map(int,input().split()))\nodds=SegmentTreeMin(n//2,10**18)\nevens=SegmentTreeMin(n//2,10**18)\ndic={}\nfor i in range(n):\n  dic[arr[i]]=i\n  if i%2==0:\n    odds.update(i//2,arr[i])\n  else:\n    evens.update(i//2,arr[i])\nq=[]\nheapq.heappush(q,(odds.query(0,(n-1)//2),0,n-1))\nans=[]\nwhile len(q)!=0:\n  _,l,r=heapq.heappop(q)\n  if l%2==0:\n    a=odds.query(l//2,r//2)\n    odds.update(dic[a]//2,10**18)\n    b=evens.query(dic[a]//2,r//2)\n    evens.update(dic[b]//2,10**18)\n    ans.append(a)\n    ans.append(b)\n    tl=dic[a]\n    tr=dic[b]\n    if tl!=l:\n      heapq.heappush(q,(odds.query(l//2,(tl-1)//2),l,tl-1))\n    if tl+1<tr-1:\n      heapq.heappush(q,(evens.query((tl+1)//2,(tr-1)//2),tl+1,tr-1))\n    if tr!=r:\n      heapq.heappush(q,(odds.query((tr+1)//2,r//2),tr+1,r))\n  else:\n    a=evens.query(l//2,r//2)\n    evens.update(dic[a]//2,10**18)\n    b=odds.query((dic[a]+1)//2,r//2)\n    odds.update(dic[b]//2,10**18)\n    ans.append(a)\n    ans.append(b)\n    tl=dic[a]\n    tr=dic[b]\n    if tl!=l:\n      heapq.heappush(q,(evens.query(l//2,(tl-1)//2),l,tl-1))\n    if tl+1<tr-1:\n      heapq.heappush(q,(odds.query((tl+1)//2,(tr-1)//2),tl+1,tr-1))\n    if tr!=r:\n      heapq.heappush(q,(evens.query((tr+1)//2,r//2),tr+1,r))\nprint(*ans)", "N = int(input())\n*P, = map(int,input().split())\nM = [0]*(N+1)\nfrom heapq import heappush,heappop\nfor i,p in enumerate(P):\n    M[p] = i\n\nINF = 10**9\n\ndef init(P,n):\n    n0 = 2**(n-1).bit_length()\n    data = [INF]*(n0*2)\n    data[n0-1:n0+n-1] = P\n    for i in range(n0-2,-1,-1):\n        data[i] = min(data[2*i+1],data[2*i+2])\n    return data\n\ndef get_data(data,l,r):\n    n0 = len(data)//2\n    l += n0\n    r += n0\n    while l<r:\n        if r&1:\n            r-=1\n            yield data[r-1]\n        if l&1:\n            yield data[l-1]\n            l += 1\n        l>>=1\n        r>>=1\n\ndef get(data,l,r):\n    return min(get_data(data,l,r))\n\nd0 = init(P[0::2],N//2)\nd1 = init(P[1::2],N//2)\n\n\ndef query_x(l, r):\n    if l % 2 == 0:\n        x = get(d0, l//2, r//2)\n    else:\n        x = get(d1, l//2, r//2)\n    return x\ndef query_y(l, r):\n    if l % 2 == 0:\n        y = get(d1, l//2, r//2)\n    else:\n        y = get(d0, (l+1)//2, (r+1)//2)\n    return y\n\n\nque = [(query_x(0,N),0,N)]\nans = []\nwhile que:\n    x, l, r = heappop(que)\n    if l+2 < r:\n        xi = M[x]\n        y = query_y(xi, r)\n        yi = M[y]\n \n        # [l, xi)\n        if l < xi:\n            heappush(que, (query_x(l, xi), l, xi))\n        # [xi+1, yi)\n        if xi+1 < yi:\n            heappush(que, (query_x(xi+1, yi), xi+1, yi))\n        # [yi+1, r)\n        if yi+1 < r:\n            heappush(que, (query_x(yi+1, r), yi+1, r))\n    else:\n        y = P[r-1]\n    ans.append(\"%d %d\" % (x, y))\nprint(*ans)", "import sys\ninput = sys.stdin.readline\nfrom heapq import heappush, heappop\n\nN = int(input())\nA = [int(x) for x in input().split()]\na_to_i = {a:i for i,a in enumerate(A)}\n\n# sparse table \u3092\u4f7f\u3063\u3066RMQ\n# parity\u306e\u540c\u3058\u3068\u3053\u308d\u3060\u3051\u3092\u898b\u308b\u3088\u3046\u306b\u3057\u3066\u304a\u304f\n\nU = len(A).bit_length()\nsp = [None,A]\nfor i in range(2,U):\n    L = 1 << (i-1)\n    sp.append([x if x < y else y for x,y in zip(sp[-1][:-L], sp[-1][L:])])\n\ndef RMQ(x,y):\n    # x\u756a\u76ee\u304b\u3089\u5076\u6570\u756a\u76ee\u3060\u3051\u898b\u3066[x,y]\u3067\u306e\u6700\u5c0f\u5024\u3092\u8fd4\u3059\n    d = y - x\n    if d <= 1:\n        return A[x]\n    n = d.bit_length()\n    return min(sp[n-1][x], sp[n-1][y+2-(1<<(n-1))])\n\ndef F(x,y):\n    # \u8f9e\u66f8\u5f0f\u3067\u6700\u5c0f\u306e2\u3064\u7d44\u3092\u3068\u308b\n    # \u305d\u306e\u3042\u3068\u3001\u4eca\u5f8c\u8abf\u3079\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u533a\u9593\u306e\u4e00\u89a7\u3092\u8fd4\u3059\n    x1 = RMQ(x,y-1)\n    i1 = a_to_i[x1]\n    x2 = RMQ(i1+1,y)\n    i2 = a_to_i[x2]\n    task = ((x,y) for x,y in ((x,i1-1), (i1+1,i2-1), (i2+1,y)) if y > x)\n    return x1,x2,task\n\nq = [(None,None,((0,N-1),))]\nanswer = []\nwhile q:\n    x,y,task = heappop(q)\n    answer.append(x)\n    answer.append(y)\n    for left,right in task:\n        heappush(q,F(left,right))\n\nprint(' '.join(map(str,answer[2:])))", "import sys\ninput = sys.stdin.readline\nimport numpy as np\nfrom heapq import heappush, heappop\n\nN = int(input())\nA = np.array(input().split(), dtype=np.int32)\na_to_i = {a:i for i,a in enumerate(A)}\n\n# sparse table \u3092\u4f7f\u3063\u3066RMQ\n# parity\u306e\u540c\u3058\u3068\u3053\u308d\u3060\u3051\u3092\u898b\u308b\u3088\u3046\u306b\u3057\u3066\u304a\u304f\n\nU = len(A).bit_length()\nsp = [None,A]\nfor i in range(2,U):\n    L = 1 << (i-1)\n    sp.append(np.minimum(sp[-1][:-L], sp[-1][L:]))\n\ndef RMQ(x,y):\n    if (y-x)&1: \n        y -= 1\n    # x\u756a\u76ee\u304b\u3089\u5076\u6570\u756a\u76ee\u3060\u3051\u898b\u3066[x,y]\u3067\u306e\u6700\u5c0f\u5024\u3092\u8fd4\u3059\n    d = y - x\n    if d <= 1:\n        return A[x]\n    n = d.bit_length()\n    return min(sp[n-1][x], sp[n-1][y+2-(1<<(n-1))])\n\ndef F(x,y):\n    # \u8f9e\u66f8\u5f0f\u3067\u6700\u5c0f\u306e2\u3064\u7d44\u3092\u3068\u308b\n    # \u305d\u306e\u3042\u3068\u3001\u4eca\u5f8c\u8abf\u3079\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u533a\u9593\u306e\u4e00\u89a7\u3092\u8fd4\u3059\n    x1 = RMQ(x,y)\n    i1 = a_to_i[x1]\n    x2 = RMQ(i1+1,y)\n    i2 = a_to_i[x2]\n    task = ((x,y) for x,y in ((x,i1-1), (i1+1,i2-1), (i2+1,y)) if y > x)\n    return x1,x2,task\n\nq = [(None,None,((0,N-1),))]\nanswer = []\nwhile q:\n    x,y,task = heappop(q)\n    if x != None:\n        answer.append(x)\n        answer.append(y)\n    for left,right in task:\n        heappush(q,F(left,right))\n\nprint(' '.join(map(str,answer)))", "import sys\ninput = sys.stdin.readline\nfrom heapq import heappush, heappop\n\nN = int(input())\nA = [int(x) for x in input().split()]\na_to_i = {a:i for i,a in enumerate(A)}\n\n# sparse table \u3092\u4f7f\u3063\u3066RMQ\n# parity\u306e\u540c\u3058\u3068\u3053\u308d\u3060\u3051\u3092\u898b\u308b\u3088\u3046\u306b\u3057\u3066\u304a\u304f\n\nU = len(A).bit_length()\nsp = [None,A]\nfor i in range(2,U):\n    L = 1 << (i-1)\n    sp.append([x if x < y else y for x,y in zip(sp[-1][:-L], sp[-1][L:])])\n\ndef RMQ(x,y):\n    # x\u756a\u76ee\u304b\u3089\u5076\u6570\u756a\u76ee\u3060\u3051\u898b\u3066[x,y]\u3067\u306e\u6700\u5c0f\u5024\u3092\u8fd4\u3059\n    d = y - x\n    if d <= 1:\n        return A[x]\n    n = d.bit_length()\n    arr = sp[n-1]\n    ax = arr[x]\n    ay = arr[y+2-(1<<(n-1))]\n    return ax if ax < ay else ay\n\ndef F(x,y):\n    # \u8f9e\u66f8\u5f0f\u3067\u6700\u5c0f\u306e2\u3064\u7d44\u3092\u3068\u308b\n    # \u305d\u306e\u3042\u3068\u3001\u4eca\u5f8c\u8abf\u3079\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u533a\u9593\u306e\u4e00\u89a7\u3092\u8fd4\u3059\n    x1 = RMQ(x,y-1)\n    i1 = a_to_i[x1]\n    x2 = RMQ(i1+1,y)\n    i2 = a_to_i[x2]\n    task = ((x,y) for x,y in ((x,i1-1), (i1+1,i2-1), (i2+1,y)) if y > x)\n    return x1,x2,task\n\nq = [(None,None,((0,N-1),))]\nanswer = []\nwhile q:\n    x,y,task = heappop(q)\n    answer.append(x)\n    answer.append(y)\n    for left,right in task:\n        heappush(q,F(left,right))\n\nprint(' '.join(map(str,answer[2:])))", "class SegTree:\n    def __init__(self, init_val, ide_ele, segfunc):\n        self.n = len(init_val)\n        self.num =2**(self.n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.seg = [self.ide_ele]*2*self.num\n        self.segfunc = segfunc\n        \n        #set_val\n        for i in range(self.n):\n            self.seg[i+self.num-1] = init_val[i]    \n        #built\n        for i in range(self.num-2,-1,-1) :\n            self.seg[i] = segfunc(self.seg[2*i+1], self.seg[2*i+2]) \n    \n    def update(self, k, x):\n        k += self.num-1\n        self.seg[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1], self.seg[k*2+2])\n    \n    def query(self, p, q):\n        if q<=p:\n            return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res = self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res, self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res, self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res, self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res, self.seg[p]), self.seg[q])\n        return res\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    \n    N = int(input())\n    P = list(map(int,input().split()))\n    Even = []\n    Odd = []\n    D = {}\n    for i in range(N//2):\n        e = P[2*i]\n        o = P[2*i+1]\n        D[e] = i\n        D[o] = i\n        Even.append(e)\n        Odd.append(o)\n    \n    E_Seg = SegTree(Even,float(\"inf\"),min)\n    O_Seg = SegTree(Odd,float(\"inf\"),min)\n    \n    import heapq\n    heap = []\n    # heapq.heappush(heap, item)\n    # heapq.heappop(heap)\n    \n    def BFS(H):\n        L = H[0]\n        R = H[1]\n        if R <= L:\n            return -1,-1,-1,-1,-1\n        if L%2==0:\n            l = L//2\n            r = R//2\n            mini = E_Seg.query(l,r+1)\n            d_mini = D[mini]\n            mini_b = O_Seg.query(d_mini, r+1)\n            d_mini_b = D[mini_b]\n            \n            leftH = (L, 2*d_mini-1)\n            centH = (2*d_mini+1, 2*d_mini_b)\n            rightH = (2*d_mini_b+2, R)\n            return mini, mini_b, leftH, centH, rightH\n        else:\n            l = L//2\n            r = R//2\n            mini = O_Seg.query(l, r)\n            d_mini = D[mini]\n            mini_b = E_Seg.query(d_mini+1, r+1)\n            d_mini_b = D[mini_b]\n            \n            leftH = (L, 2*d_mini)\n            centH = (2*d_mini+2, 2*d_mini_b-1)\n            rightH = (2*d_mini_b+1, R)\n            return mini, mini_b, leftH, centH, rightH\n        \n    H = (0, N-1)\n    m1,m2,LH,CH,RH = BFS(H)\n    #print(m1,m2)\n    heapq.heappush(heap, [m1,m2,LH,CH,RH])\n    Q = []\n    while heap != []:\n        m1,m2,LH,CH,RH = heapq.heappop(heap)\n        Q += [m1,m2]\n        \n        m1L,m2L,LHL,CHL,RHL = BFS(LH)\n        if m1L != -1:\n            heapq.heappush(heap, [m1L,m2L,LHL,CHL,RHL])\n        \n        m1C,m2C,LHC,CHC,RHC = BFS(CH)\n        if m1C != -1:\n            heapq.heappush(heap, [m1C,m2C,LHC,CHC,RHC])\n        \n        m1R,m2R,LHR,CHR,RHR = BFS(RH)\n        if m1R != -1:\n            heapq.heappush(heap, [m1R,m2R,LHR,CHR,RHR])\n    print(*Q)\n    \n    \n    \n    \nmain()", "from collections import deque\nimport heapq\nimport sys\ninput = sys.stdin.readline\n\n\nclass SparseTable():\n    \"\"\"\u533a\u9593\u53d6\u5f97\u30af\u30a8\u30ea\u3092O(1)\u3067\u7b54\u3048\u308b\u30c7\u30fc\u30bf\u69cb\u9020\u3092O(NlogN)\u3067\u69cb\u7bc9\u3059\u308b\n    query(l, r): \u533a\u9593[l, r)\u306b\u5bfe\u3059\u308b\u30af\u30a8\u30ea\u306b\u7b54\u3048\u308b\n    \"\"\"\n    def __init__(self, array, n):\n        n = len(array)\n        self.row_size = n.bit_length()\n\n        # log_table\u3092\u69cb\u7bc9\u3059\u308b\n        # log_table = [0, 0, 1, 1, 2, 2, 2, 2, ...]\n        self.log_table = [0] * (n + 1)\n        for i in range(2, n + 1):\n            self.log_table[i] = self.log_table[i//2] + 1\n\n        # sparse_table\u3092\u69cb\u7bc9\u3059\u308b\n        self.sparse_table = [[0] * n for _ in range(self.row_size)]\n        for i in range(n):\n            self.sparse_table[0][i] = array[i]\n        for row in range(1, self.row_size):\n            for i in range(n - (1 << row) + 1):\n                self.sparse_table[row][i] = self._merge(self.sparse_table[row - 1][i], \\\n                                            self.sparse_table[row - 1][i + (1 << row - 1)])\n\n    def _merge(self, num1, num2):\n        \"\"\"\u30af\u30a8\u30ea\u306e\u5185\u5bb9\"\"\"\n        return min(num1, num2)\n\n    def query(self, l, r):\n        \"\"\"\u533a\u9593[l, r)\u306b\u5bfe\u3059\u308b\u30af\u30a8\u30ea\u306b\u7b54\u3048\u308b\"\"\"\n        row = self.log_table[r - l]\n        return self._merge(self.sparse_table[row][l], self.sparse_table[row][r - (1 << row)])\n\n\nn = int(input())\np = list(map(int, input().split()))\n\nq = [[0] * (n // 2) for i in range(2)]\n\nfor i in range(n):\n    q[i%2][i//2] = p[i]\n\nind = {}\nfor i in range(n):\n    ind[p[i]] = i\n\nsp0 = SparseTable(q[0], n // 2)\nsp1 = SparseTable(q[1], n // 2)\n\ncon = {}\nans = {}\ndiv = 10**6\ndef solve(l, r):\n    q = deque([l * div + r])\n    while q:\n        pos = q.pop()\n        l, r = pos // div, pos % div \n        # min1 = min(q[l%2][l//2:r//2])\n        if l % 2 == 0:\n            min1 = sp0.query(l//2, r//2)\n        else:\n            min1 = sp1.query(l//2, r//2)\n        use_pos1 = ind[min1]\n        \n        # min2 = min(q[(l+1)%2][(use_pos1+1)//2:(r+1)//2])\n        if (l + 1) % 2 == 0:\n            min2 = sp0.query((use_pos1 + 1) // 2, (r + 1) // 2)\n        else:\n            min2 = sp1.query((use_pos1 + 1) // 2, (r + 1) // 2)\n        use_pos2 =  ind[min2]\n        \n        ans[pos] = min1 * div + min2\n        con[pos] = []\n        if l != use_pos1:\n            con[pos].append(l * div + use_pos1)\n            q.append(l * div + use_pos1)\n        if use_pos1 + 1 != use_pos2:\n            con[pos].append((use_pos1 + 1) * div + use_pos2)\n            q.append((use_pos1 + 1) * div + use_pos2)\n        if use_pos2 + 1 != r:\n            con[pos].append((use_pos2 + 1) * div + r)\n            q.append((use_pos2 + 1) * div + r)\n\n    return\n\n\nsolve(0, n)\nres = []\nq = [(ans[n], n)]\nwhile q:\n    num, i = heapq.heappop(q)\n    min1, min2 = num // div, num % div\n    res.append(min1)\n    res.append(min2)\n    for new_num in con[i]:\n        heapq.heappush(q, (ans[new_num], new_num))\nprint(*res)", "from heapq import heappop, heappush\nimport sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\nn = int(input())\np = [int(x) for x in input().split()]\n\n\nclass SegmentTree:  # 0-indexed\n    def __init__(self, array, operation=min, identity=10**30):\n        self.identity = identity\n        self.n = len(array)\n        self.N = 1 << (self.n - 1).bit_length()\n        self.tree = [self.identity] * 2 * self.N\n        self.opr = operation\n        for i in range(self.n):\n            self.tree[i+self.N-1] = array[i]\n        for i in range(self.N-2, -1, -1):\n            self.tree[i] = self.opr(self.tree[2*i+1], self.tree[2*i+2])\n\n    def values(self):\n        return self.tree[self.N-1:]\n\n    def update(self, k, x):\n        k += self.N-1\n        self.tree[k] = x\n        while k+1:\n            k = (k-1)//2\n            self.tree[k] = self.opr(self.tree[k*2+1], self.tree[k*2+2])\n\n    def query(self, p, q):  # [p,q)\n        if q <= p:\n            print(\"Oops!  That was no valid number.  Try again...\")\n            return\n        p += self.N-1\n        q += self.N-2\n        res = self.identity\n        while q-p > 1:\n            if p & 1 == 0:\n                res = self.opr(res, self.tree[p])\n            if q & 1 == 1:\n                res = self.opr(res, self.tree[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.opr(res, self.tree[p])\n        else:\n            res = self.opr(self.opr(res, self.tree[p]), self.tree[q])\n        return res\n\n\nind = [0]*(n+1)\nOdd = SegmentTree([10**30]*n)\nEven = SegmentTree([10**30]*n)\n\nfor i in range(n):\n    ind[p[i]] = i\n    if i % 2 == 0:\n        Even.update(i, p[i])\n    else:\n        Odd.update(i, p[i])\n\ncand = []\nheappush(cand, (Even.query(0, n), 0, n, True))\n\nq = []\nwhile len(q) < n:\n    first, l, r, is_even = heappop(cand)\n    if is_even:\n        second = Odd.query(ind[first]+1, r)\n        q.extend([first, second])\n        if l < ind[first]:\n            heappush(cand, (Even.query(l, ind[first]), l, ind[first], True))\n        if ind[first] + 1 < ind[second]:\n            heappush(\n                cand, (Odd.query(ind[first]+1, ind[second]), ind[first]+1, ind[second], False))\n        if ind[second]+1 < r:\n            heappush(\n                cand, (Even.query(ind[second], r), ind[second]+1, r, True))\n    else:\n        second = Even.query(ind[first]+1, r)\n        q.extend([first, second])\n        if l < ind[first]:\n            heappush(cand, (Odd.query(l, ind[first]), l, ind[first], False))\n        if ind[first] + 1 < ind[second]:\n            heappush(\n                cand, (Even.query(ind[first]+1, ind[second]), ind[first]+1, ind[second], True))\n        if ind[second]+1 < r:\n            heappush(\n                cand, (Odd.query(ind[second], r), ind[second]+1, r, False))\n\nprint((*q))\n", "from heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n# l\u304b\u30891\u3064\u304a\u304d\u306b\u307f\u305f\u3068\u304d\u306e\u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\u7279\u5225\u88fd\nclass SparseTable:\n    def __init__(self, aa):\n        inf = 10 ** 16\n        w = len(aa)\n        h = w.bit_length()\n        table = [aa] * 2 + [[inf] * w for _ in range(h - 2)]\n        tablei1 = table[0]\n        for i in range(2, h):\n            tablei = table[i]\n            shift = 1 << (i - 1)\n            for j in range(w):\n                rj = j + shift\n                if rj >= w: break\n                tablei[j] = min(tablei1[j], tablei1[rj])\n            tablei1 = tablei\n        self.table = table\n\n    # [l,r)\u306e\u6700\u5c0f\u5024\n    def min(self, l, r):\n        if (r - l) % 2: r += 1\n        i = (r - l).bit_length() - 1\n        tablei = self.table[i]\n        Lmin = tablei[l]\n        Rmin = tablei[r - (1 << i)]\n        if Lmin < Rmin: Rmin = Lmin\n        return Rmin\n\ndef main():\n    n = int(input())\n    pp = LI()\n    st = SparseTable(pp)\n    ptoi = [0] + [i for i, p in sorted(enumerate(pp), key=lambda x: x[1])]\n    # \u533a\u9593\u5076\u6570\u756a\u76ee\u306e\u6700\u5c0f\u5024\u3068[l,r)\u3092\u30d2\u30fc\u30d7\u306b\n    hp = []\n    heappush(hp, [st.min(0, n), 0, n])\n    ans = []\n    for _ in range(n // 2):\n        x, l, r = heappop(hp)\n        if l + 2 == r:\n            ans += [pp[l], pp[l + 1]]\n            continue\n        xi = ptoi[x]\n        y = st.min(xi + 1, r)\n        yi = ptoi[y]\n        if xi > l:\n            heappush(hp, [st.min(l, xi), l, xi])\n        if xi + 1 < yi:\n            heappush(hp, [st.min(xi + 1, yi), xi + 1, yi])\n        if yi < r - 1:\n            heappush(hp, [st.min(yi + 1, r), yi + 1, r])\n        ans += [x, y]\n    print(*ans)\n\nmain()\n", "from heapq import heappop, heappush\nINF = 10**30\n\nclass Rmin():\n\tdef __init__(self, size):\n\t\t#the number of nodes is 2n-1\n\t\tself.n = 1\n\t\twhile self.n < size:\n\t\t\tself.n *= 2\n\t\tself.node = [INF] * (2*self.n-1)\n\n\tdef Access(self, x):\n\t\treturn self.node[x+self.n-1]\n\n\tdef Update(self, x, val):\n\t\tx += self.n-1\n\t\tself.node[x] = val\n\t\twhile x > 0:\n\t\t\tx = (x-1)//2\n\t\t\tself.node[x] = min(self.node[2*x+1], self.node[2*x+2])\n\t\treturn\n\n\t#[l, r)\n\tdef Get(self, l, r):\n\t\tL, R = l+self.n, r+self.n\n\t\ts = INF\n\t\twhile L < R:\n\t\t\tif R & 1:\n\t\t\t\tR -= 1\n\t\t\t\ts = min(s, self.node[R-1])\t\t\t\n\t\t\tif L & 1:\n\t\t\t\ts = min(s, self.node[L-1])\n\t\t\t\tL += 1\n\t\t\tL >>= 1\n\t\t\tR >>= 1\n\t\treturn s\n\nn = int(input())\na = list(map(int, input().split()))\n\neven, odd = Rmin(n), Rmin(n)\nfor i in range(n):\n\tif i%2 == 0:\n\t\teven.Update(i, a[i]*(10**7) + i)\n\telse:\n\t\todd.Update(i, a[i]*(10**7) + i)\n\nd = dict()\n\ndef search(l, r):\n\tif l%2 == 0:\n\t\tp = even.Get(l, r+1)\n\t\tq = odd.Get(p%(10**7)+1, r+1)\n\telse:\n\t\tp = odd.Get(l, r+1)\n\t\tq = even.Get(p%(10**7)+1, r+1)\n\treturn p, q\n\nx, y = search(0, n-1)\nd[x%(10**7)] = (y, 0, n-1)\nque = [x]\nans = []\n\nwhile que:\n\tx = heappop(que)\n\ty, l, r = d[x%(10**7)]\n\tans += [x//(10**7), y//(10**7)]\n\n\tif l != x%(10**7):\n\t\tp, q = search(l, x%(10**7)-1)\n\t\td[p%(10**7)] = (q, l, x%(10**7)-1)\n\t\theappush(que, p)\n\n\tif r != y%(10**7):\n\t\tp, q = search(y%(10**7)+1, r)\n\t\td[p%(10**7)] = (q, y%(10**7)+1, r)\n\t\theappush(que, p)\n\n\tif x%(10**7)+1 != y%(10**7):\n\t\tp, q = search(x%(10**7)+1, y%(10**7)-1)\n\t\td[p%(10**7)] = (q, x%(10**7)+1, y%(10**7)-1)\n\t\theappush(que, p)\n\nprint(*ans)"]
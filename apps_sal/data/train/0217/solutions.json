["class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        res = set()\n        cur = set()\n        for a in A:\n            cur = {a | i for i in cur}\n            cur |= {a}\n            res |= cur\n        return len(res)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        s = set()\n        c = set()\n        for x in A:\n            c = {x|y for y in c}\n            c.add(x)\n            s|=c\n        return len(s)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set()\n        cur = set([0])\n        \n        for x in A:\n            cur = {x | y for y in cur} | {x}\n            ans |= cur\n        return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        prev = set()\n        curr = set()\n        vals = set(A)\n        \n        for x in A:\n            curr.add(x)\n            for y in prev:\n                curr.add(x|y)\n                vals.add(x|y)\n            prev = curr\n            curr = set()\n        \n        return len(vals)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        curr = set()\n        ans = set()\n        for x in A:\n            curr = {x | y for y in curr} | {x}\n            ans |= curr\n        \n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        results = set()\n        curr = {0}\n        for a in A:\n            curr = {a | b for b in curr} | {a}\n            results |= curr\n        return len(results)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        res, cur = set(), set()\n        for i in A:\n            cur = {i | j for j in cur} | {i}\n            res |= cur\n        return len(res)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        # O(N^3) to try oring every possible subarray\n        \n        # key fact: for any number k , k | k = k\n        # also 0 | k = k for all k\n        \n        # one small optimization: scan through and delete any 0s or consecutive repeats\n        \n        # keep a list of or results s.t. or[i] = set of all possible results from oring subarrays that end at i\n        # then or[i] = [A[i]] + [A[i] | res for res in or[i - 1]] -> use a set to prune dups at each step\n        #    you can just keep or[i] for most recent two i's\n        # \n        if not A:\n            return []\n        # [1, 2, 4]\n        # all_outcomes: {1, 2, 3, 4, 6, 7}\n        # outcomes: {2, 3}\n        # 4: temp {4, 6, 7}\n        \n        # todo(mywang): preprocess array and remove unnecessary stuff\n        for i in range(len(A))[::-1]:\n            if (i > 0 and A[i] == A[i - 1]):\n                A.pop(i)\n        all_outcomes = set([A[0]])\n        outcomes = set([A[0]])\n        for elt in A[1:]:\n            outcomes = {elt} | {elt | val for val in outcomes}\n            all_outcomes |= outcomes\n        \n        return len(all_outcomes)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans=set()\n        cur=set()\n        for i in A:\n            cur = set([i|j for j in cur])\n            cur.add(i)\n            ans|=cur\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        cur = set()\n        all = set()\n        for v in A:\n            cur = set(e | v for e in cur)\n            cur.add(v)\n            all |= cur\n        return len(all)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set()\n        cur = {0}\n        for i in A:\n            cur = {i | y for y in cur} | {i}\n            ans |= cur\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        cur, res = set(), set()\n        for i in A:\n            cur = {i | j for j in cur} | {i}\n            res |= cur\n        return len(res)", "import math\nclass Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        res = set([])\n        tmp = []\n        maximpact = 0\n        for i in A:\n            newtmp = []\n            newtmp_set = set([])\n            maximpact = max(maximpact, int(math.log(i, 2)) + 1 if i > 0 else 0)\n            if i not in newtmp_set:\n                newtmp_set.add(i)\n                newtmp.append(i)\n                res.add(i)\n            if maximpact > 0:\n                for j in tmp:\n                    k = i|j\n                    if k not in newtmp_set:\n                        newtmp_set.add(k)\n                        newtmp.append(k)\n                    res.add(k)\n                    if len(newtmp) >= maximpact:\n                        break\n            tmp = newtmp\n        return len(res)\n            \n                \n            \n", "class Solution(object):\n    def subarrayBitwiseORs(self, A):\n        ans = set()\n        cur = {0}\n        for x in A:\n            cur = {x | y for y in cur} | {x}\n            ans |= cur\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        result, curr = set(), set()\n        for a in A:\n            curr = {a | j for j in curr} | {a}\n            result |= curr\n        return len(result)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        results = set()\n        temp = {0}\n        for cur in A:\n           # print(temp)\n            temp = {cur} | {cur | t for t in temp}\n            results.update(temp)\n        return len(results)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        s = set()\n        global_set = set()\n        ans = 0\n        for v in A:\n            s.add(v)\n            s = {x|v for x in s}\n            global_set |= s\n            \n        return len(global_set)", "import math\nclass Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = {A[0]}\n        pre = {A[0]}\n        for a in A[1:]:\n            pre = {a|x for x in pre}\n            pre.add(a)\n            ans.update(pre) \n        return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        S, last = set(), set()\n        for i in range(len(A)):\n            last = {a|A[i] for a in last}\n            last.add(A[i])\n            S |= last\n            \n        return len(S)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set()\n        cur = {0}\n        for x in A:\n            cur = {x | y for y in cur} | {x}\n            ans |= cur\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        \n        \n        \n        # my solution ... 760 ms ... 98 % ... 40.6 MB ... 15 %\n        #  time: O(nlogn)\n        # space: O(logn)\n        \n        res = set()\n        tot = set()\n        for a in A:\n            res = {prev | a for prev in res} | {a}  # \u5f97\u51fa\u4ee5\u5f53\u524d a \u7ed3\u5c3e\u7684 subarray\n            tot |= res                              # \u628a\u7ed3\u679c\u5e76\u5165 tot\n        return len(tot)\n        \n        \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set()\n        cur = set([0])\n        \n        for x in A:\n            cur = set([x | y for y in cur]) | {x}\n            ans |= cur\n        return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set()\n        previous = set()\n        for v in A:\n            current = set([i|v for i in previous])\n            current.add(v)\n            ans.update(current)\n            previous = current\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        st = set()\n        cur = set()\n        for a in A:\n            cur = {b | a for b in cur} | {a}\n            st |= cur\n        return len(st)", "from typing import List\n\n\nclass Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        seen = set()\n        cur = set()\n\n        for num in A:\n            cur_new = set()\n            for num_seen in cur:\n                cur_new.add(num_seen | num)\n\n            cur_new.add(num)\n            cur = cur_new\n            seen |= cur\n\n        return len(seen)\n\n    def subarrayBitwiseORsN2(self, A: List[int]) -> int:\n        dp = [[0] * len(A) for _ in range(len(A))]\n\n        seen = set()\n\n        count = 0\n\n        for start in reversed(list(range(len(A)))):\n            for end in range(start, len(A)):\n                if start == end:\n                    dp[start][end] = A[start]\n                else:\n                    dp[start][end] = dp[start + 1][end] | A[start]\n\n                if dp[start][end] not in seen:\n                    count += 1\n                    seen.add(dp[start][end])\n\n        return count\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set()\n        cur = {0}\n        for x in A:\n            cur = {x|y for y in cur} | {x}\n            ans |= cur\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        # Brute force with set, with list we can use if in list conditional statement\n        # Slow & bad....\n\n#        rset = set()\n#        for i in range(len(A)):\n#            for j in range(i+1, len(A)+1):\n#                res = 0\n#                for k in range(i, j):\n#                    res |= A[k]\n#                rset.add(res)\n#        return len(rset) \n        \n#        A cleaner code\n#        Assume B[i][j] = A[i] | A[i+1] | ... | A[j]\n#        Hash set cur stores all wise B[0][i], B[1][i], B[2][i], B[i][i].\n\n#        When we handle the A[i+1], we want to update cur\n#        So we need operate bitwise OR on all elements in cur.\n#        Also we need to add A[i+1] to cur.\n\n#        In each turn, we add all elements in cur to res.\n# This method is better since it preserves the results of previous operation and make them useful\n        res, cur = set(), set()\n    \n        for i in A:\n            cur = {i|j for j in cur} | {i}\n            res |= cur\n        \n        return len(res)\n        \n", "class Solution(object):\n    def subarrayBitwiseORs(self, A):\n        ans = set()\n        cur = {0}\n        for x in A:\n            cur = {x | y for y in cur} | {x}\n            ans|=cur\n            #print(cur)\n            #print(\\\"ans\\\",ans)\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        \n        result = set()\n        cur = {0}\n        \n        for x in A:\n            cur = {x | y for y in cur} | {x}\n            result |= cur\n        \n        return len(result)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        s = set()\n        res = set()\n        for x in A:\n            new_s = {x}\n            for xx in s:\n                new_s.add(xx | x)\n            s = new_s\n            res |= s\n        return len(res)", "import itertools as it\n\n\nclass Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        res, cur = set(), set()\n        for i in A:\n            cur = {i | j for j in cur} | {i}\n            res |= cur\n        return len(res)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        cur, res = set(), set()\n        for a in A:\n            cur = {a|b for b in cur} | {a}\n            res |= cur\n        return len(res)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set()\n        \n        cur = {0}\n        \n        for x in A:\n            cur = {x|y for y in cur} | {x}\n            ans |= cur\n        \n        return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        # 12:57 8/24/20\n        \n        cur, res = set(),set()\n        for num in A:\n            cur = {num | j for j in cur} | {num}\n        #     res |= cur\n            # cur = set(num | k for k in A)\n            # cur.add(num)\n            res.update(cur)\n        \n        return len(res)\n        \n        \n                \n        # res, cur = set(), set()\n        # for i in A:\n        #     cur = {i | j for j in cur} | {i}\n        #     res |= cur\n        # return len(res)\n\n            \n                \n", "class Solution:\n#     def findUnique(self, l):\n#         u = []\n        \n#         for num in l:\n#             if num not in u:\n#                 u.append(num)\n                \n#         return self.findOR(u)\n    \n#     def findOR(self, l):\n        \n#         ret = 0\n        \n#         for num in l:\n#             ret = self.doBin(ret, num)\n#         return ret\n    \n    \n#     def doBin(self, a, b):\n        \n#         p = 0\n        \n#         ret = 0\n#         while a or b:\n#             if a%2 or b%2:\n#                ret += pow(2,p)\n#             p +=1\n#             a, b = a//2, b//2\n        \n#         return ret\n    \n#     def subarrayBitwiseORs(self, A: List[int]) -> int:\n#         #just unique combinations\n        \n#         res = 0 \n        \n#         seen = []\n#         #brute force\n#         for i in range(len(A)):\n#             for j in range(i,len(A)):\n#                 uniq = self.findUnique(A[i:j+1])\n#                 if uniq not in seen:\n#                     seen.append(uniq)\n#                     res +=1\n                    \n#         return res\n\n\n    def subarrayBitwiseORs(self, A):\n        ans = set()\n        cur = {0}\n        for x in A:\n            cur = {x | y for y in cur} | {x}\n            ans |= cur\n        return len(ans)\n\n\n\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        n = len(A)\n        dp = set()\n        ans = set()\n        \n        for j in range(n):\n            dp_new = set()\n            dp_new.add(A[j])\n            for x in dp:\n                dp_new.add(x | A[j])\n            dp = dp_new \n            ans.update(dp)\n                \n        return len(ans)        \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans, dp = set(), set()\n        for x in A:\n            ndp = set()\n            ndp.add(x)\n            for y in dp:\n                ndp.add(x|y)\n                ans.add(y)\n            dp = ndp\n        for x in dp: ans.add(x)\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        # O(N^3) to try oring every possible subarray\n        \n        # key fact: for any number k , k | k = k\n        # also 0 | k = k for all k\n        \n        # one small optimization: scan through and delete any 0s or consecutive repeats\n        \n        # keep a list of or results s.t. or[i] = set of all possible results from oring subarrays that end at i\n        # then or[i] = [A[i]] + [A[i] | res for res in or[i - 1]] -> use a set to prune dups at each step\n        #    you can just keep or[i] for most recent two i's\n        # \n        if not A:\n            return []\n        # [1, 2, 4]\n        # all_outcomes: {1, 2, 3, 4, 6, 7}\n        # outcomes: {2, 3}\n        # 4: temp {4, 6, 7}\n        \n        # todo(mywang): preprocess array and remove unnecessary stuff\n        for i in range(len(A))[::-1]:\n            if (i > 0 and A[i] == A[i - 1]):\n                A.pop(i)\n        all_outcomes = set([A[0]])\n        outcomes = set([A[0]])\n        for elt in A[1:]:\n            temp = set([elt])\n            for out in outcomes:\n                temp.add(out | elt)\n            outcomes = temp\n            all_outcomes |= outcomes\n        \n        return len(all_outcomes)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set()\n        tp = set()\n        tp.add(0)\n        for i in A:\n            tpp = set()\n            tpp.add(i)\n            for ii in tp:\n                tpp.add(ii|i)\n            tp=tpp\n            for ii in tp:\n                ans.add(ii)\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        s = set()\n        res = set()\n        for n in A:\n            s = {n} | {n | el for el in s}\n            res |= s\n\n        return len(res)", "class Solution:\n    def subarrayBitwiseORs(self, arr: List[int]) -> int:\n        ans = set()\n        current = set()\n        current.add(0)\n        for i in range(len(arr)):\n            a = arr[i]\n            s = set()\n            s.add(a)\n            for y in current:\n                s.add(a | y)\n            current = s\n            ans |= s\n        return len(ans)\n    \n        # for x in arr:\n        #     current = {x | y for y in current} | {x}\n        #     # print(current)\n        #     ans |= current\n        #     # print(ans)\n        # return len(ans)\n    \n        # brute force time complexity :O(n^2)\n        # space complexity:O(n)\n        if not arr:return 0\n        l ,ans = len(arr) ,set()\n        for i in range(l):\n            res = arr[i]\n            ans.add(res)\n            for j in range(i+1,l):\n                res |= arr[j]\n                ans.add(res)\n        return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        fullSet = set()\n        setAtI = {0}\n        \n        for i in range(len(A)):\n            setAtI = {A[i]| y for y in setAtI} | {A[i]}\n            fullSet |=setAtI\n        return len(fullSet)\n        \n        \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        setA = set(A)\n        \n        prev = set()\n        \n        prev.add(A[0])\n        \n        for val in A[1:]:\n            temp = set()\n            \n            for p in prev:\n                temp.add(p|val)\n                setA.add(p|val)\n            prev = temp\n            prev.add(val)\n        return len(setA)", "import math\nclass Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = {A[0]}\n        pre = {A[0]}\n        for a in A[1:]:\n            pre = {a|x for x in pre}\n            pre.add(a)\n            for i in pre:\n                ans.add(i) \n        return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans=set()\n        vset=set()\n        for a in A:\n            newvset=set()\n            for v in vset:\n                newvset.add(a|v)\n                ans.add(a|v)\n            newvset.add(a)\n            vset=newvset\n            ans.add(a)\n        return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n \n        cur = set()\n        res = set()\n        for i in A:\n            temp = set([i])\n            for j in cur:\n                temp.add(i|j)\n            cur = temp\n            for j in cur:\n                res.add(j)\n        return len(res)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        \n        result, prev = set(), set()\n        \n        for num in A:\n            temp = set()\n            temp.add(num)\n            \n            result.add(num)\n            \n            for p in prev:\n                temp.add(p|num)\n                result.add(p|num)\n            \n            prev = temp\n        return len(result)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        S, prev = set(), set()\n        for a in A:\n            temp = set()\n            temp.add(a)\n            S.add(a)\n            for p in prev:\n                temp.add(a|p)\n                S.add(a|p)\n            prev = temp\n        return len(S)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        alive = set()\n        dead = set()\n        for num1 in A:\n            tmp = {num1}\n            for num2 in alive:\n                dead.add(num2)\n                tmp.add(num1|num2)\n            alive = tmp\n            \n        return len(alive|dead)", "class Solution:\n    \n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        arr_len = len(A)\n        final_result_set = set()\n        pre_result_set = set()\n        pre_result_set.add(A[0])\n        final_result_set.add(A[0])\n        for i in range (1, arr_len):\n            cur_result_set = set()\n            for pre_result in pre_result_set:\n                one_cur_result = pre_result | A[i]\n                cur_result_set.add(one_cur_result)\n                final_result_set.add(one_cur_result)\n            cur_result_set.add(A[i])\n            final_result_set.add(A[i])\n            pre_result_set = cur_result_set\n        return len(final_result_set)\n            \n                    \n                    \n        \n", "class Solution:\n    def subarrayBitwiseORs(self, A):\n        nums, n, pre = set(), len(A), set()\n        for a in A:\n            pre = {a} | {num | a for num in pre}\n            nums |= pre\n        return len(nums)\n\n# @param {Integer[]} a\n# @return {Integer}\n#def subarray_bitwise_o_rs(a)\n    # Get subarrays\n#    solutions = {}\n#    iterating_array = a.clone\n#    a.each do |m|\n#        num = m\n#        iterating_array.each do |m|\n#            solutions[num] = 1\n#            num |= m\n#        end\n#        solutions[num] = 1\n#        iterating_array.shift\n#    end\n#    solutions.keys.length\n#end\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set()\n        cur = set()\n        for a in A:\n            cur = {p | a for p in cur} | {a}\n            ans |= cur\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        my_set = [set([A[i]]) for i in range(len(A))]\n        \n        for i in range(1, len(A)):\n            for prev_result in my_set[i-1]:\n                my_set[i].add(A[i] | prev_result)\n                \n        return len(set.union(*my_set))\n                \n            \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        \n        curr=set()\n        ans=set()\n        for a in A:\n            s=set()\n            s.add(a)\n            for i in curr:\n                s.add(a|i)\n            curr=s\n            for t in curr:\n                ans.add(t|a)\n        return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        my_set = [set([A[i]]) for i in range(len(A))]\n        \n        for i in range(1, len(A)):\n            for prev_result in my_set[i-1]:\n                res = A[i] | prev_result\n                my_set[i].add(res)\n                \n        return len(set.union(*my_set))\n                \n            \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        sets=[{i} for i in A]\n        for i in range(1,len(A)):\n            for prev in sets[i-1]:\n                sets[i].add(A[i]|prev)\n        \n        for num in sets[1:]:\n            sets[0]|=num  \n        return len(sets[0])", "from typing import List, Set\n\n\nclass Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        all_results: Set[int] = set()\n        prev_results: Set[int] = set()\n\n        for start_index in range(len(A)):\n            curr_results: Set[int] = set()\n            curr_results.add(A[start_index])\n\n            for prev_result in prev_results:\n                curr_results.add(prev_result | A[start_index])\n\n            all_results |= curr_results\n            prev_results = curr_results\n        return len(all_results)\n\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        res, curr = set(), set()\n        for a in A:\n            temp = {a}\n            for b in curr:\n                temp.add(a | b)\n            curr = temp\n            for num in curr:\n                res.add(num)\n        return len(res)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        sets=[{i} for i in A]\n        for i in range(1,len(A)):\n            for prev in sets[i-1]:\n                sets[i].add(A[i]|prev)\n        return len(set.union(*sets))", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set()\n        prev = set()\n        prev.add(0)\n        \n        for i in range(len(A)):\n            cur = set()\n            cur.add(A[i])\n            \n            for p in prev:\n                res = p | A[i]\n                if res != p:\n                    ans.add(p)\n                cur.add(res)\n            \n            prev = cur\n        \n        for p in prev:\n            ans.add(p)\n        \n        if 0 not in A:\n            ans.remove(0)\n        \n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set()\n        cur = set()\n        for x in A:\n            cur = {y|x for y in cur} | set([x])\n            ans |= cur\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        my_set = set(A)\n        curr = 0\n        prev = set()\n        prev.add(A[0])\n        for num in A[1:]:\n            temp = set()\n            for p in prev:\n                temp.add(num | p)\n                my_set.add(num | p)\n            prev = temp\n            prev.add(num)\n\n        return len(my_set)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        if A == []:\n            return 0\n        # count = [0]\n        # dic = {}\n        # def OR(s):\n        #     if len(s) == 1:\n        #         return s[0]\n        #     res = s[0]\n        #     for item in s[1:]:\n        #         res = res | item\n        #     return res\n        # for i in range(len(A)):\n        #     for j in range(i, len(A)):\n        #         res = OR(A[i:j+1])\n        #         if res in dic:\n        #             continue\n        #         dic[res] = 0\n        #         count[0] += 1\n        # return count[0]\n        my_set = set(A)\n        curr = 0\n        prev = set()\n        prev.add(A[0])\n        for num in A[1:]:\n            temp = set()\n            for p in prev:\n                temp.add(num | p)\n                my_set.add(num | p)\n            prev = temp\n            prev.add(num)\n\n        return len(my_set)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans = set(A)\n        prev = set([A[0]])\n        for i in A[1:]:\n            temp = set()\n            for p in prev:\n                temp.add(i|p)\n                ans.add(i|p)\n            prev = temp\n            prev.add(i)\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        # res, cur = set(), set()\n        # for num in A:\n        #     cur = {val | num for val in cur} | {num}\n        #     res |= cur\n        # return len(res)\n        \n        # list\n        res = []\n        left, right = 0, 0\n        for val in A:\n            right = len(res)\n            res.append(val)\n            for i in range(left, right):\n                if res[-1] != (res[i] | val):\n                    res.append(res[i] | val)\n            left = right\n        return len(set(res))\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        res = set()\n        \n        last = set()\n        \n        for x in A:\n            new = {x}\n            \n            for y in last:\n                new.add(x | y)\n            \n            res |= new\n            last = new\n            \n        return len(res)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        vals = set()\n    \n        if len(A) < 2:\n            return len(A)\n        \n        cur = {0}\n        for a in A:\n            cur = {a| y for y in cur} | {a}\n            vals |= cur\n        return len(vals)", "class Solution:\n    def subarrayBitwiseORs(self, A):\n        # Tabulation is a list of sets, one for each number in A. \n        # Each set, at position i, is initialised to containing the element at A[i]\n        tabulation = [set([A[i]]) for i in range(len(A))]\n        \n        # And now we need to go through, updating the sets based on the previous set.\n        for i in range(1, len(A)):\n            for previous_result in tabulation[i - 1]: \n                tabulation[i].add(A[i] | previous_result)  \n        \n        # Return the number of unique numbers in the tabulation list.\n        return len(set.union(*tabulation)) if len(A) > 0 else 0\n", "class Solution:\n    def subarrayBitwiseORs(self, A: list) -> int:\n        results = set()\n        pre = {0}\n\n        for a in A:\n            '''\n            cur = {a}\n            for prev in pre:\n                cur.add(prev | a)\n            results |= cur\n            pre = cur\n            '''\n            pre = {a | p for p in pre} | {a}\n            results |= pre\n\n        return len(results)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        s, ans = set(), set()\n        for a in A:\n            s = {a} | {a | b for b in s}\n            ans |= s\n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        # https://blog.csdn.net/fuxuemingzhu/article/details/83511833\n        res = set()\n        cur = set()\n        for a in A:\n            cur = {n | a for n in cur} | {a}\n            res |= cur\n        return len(res)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        s = set()\n        s1 = set()\n        for n in A:\n            s2 = set()\n            for e in s1:\n                s2.add(e|n)\n            s1=s2\n            s1.add(n)\n            s|=s1\n        # print(s)\n        return len(s)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        res = set([])\n        tmp = set([])\n        for i in A:\n            newtmp = set([])\n            for j in tmp:\n                newtmp.add(i|j)\n                res.add(i|j)\n            newtmp.add(i)\n            res.add(i)\n            tmp = newtmp\n        return len(res)\n            \n                \n            \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        # 12:57 8/24/20\n        \n        res, cur = set(), set()\n        for i in A:\n            cur = {i | j for j in cur} | {i}\n            res |= cur\n        return len(res)\n            \n                \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        ans, frontier = set(), set()\n        \n        for n in A:\n            frontier = {x | n for x in frontier if x|n != -1}\n            frontier.add(n)\n            ans |= frontier\n        \n        \n        return len(ans)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        curr = {0}\n        ans = set()\n        for a in A:\n            curr = {x|a for x in curr } | {a}\n            ans |= curr\n        return len(ans)\n    \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        my_set = [set([A[i]]) for i in range(len(A))]\n        ans = set(A)\n        \n        for i in range(1, len(A)):\n            for prev_result in my_set[i-1]:\n                res = A[i] | prev_result\n                my_set[i].add(res)\n                ans.add(res)\n                \n        return len(ans)\n                \n            \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        my_set = set(A)\n        curr = 0\n        prev = set()\n        prev.add(A[0])\n        for num in A[1:]:\n            temp = set()\n            curr |= num\n            my_set.add(curr)\n            prev.add(num)\n            for p in prev:\n                temp.add(num | p)\n                my_set.add(num | p)\n            prev = temp\n\n        return len(my_set)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        dp = []\n        for i in range(len(A)):\n            if i == 0:\n                dp.append(set([A[i]]))\n            else:\n                inner = set([A[i]])\n                for d in dp[-1]:\n                    inner.add(d | A[i])\n                dp.append(inner)\n        total = set()\n        for d in dp:\n            total.update(d)\n        return len(total)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        result = set()\n        curr = set()\n        for num in A:\n            curr = {num | prev_num for prev_num in curr} | {num}\n            result |= curr\n        return len(result)\n        \n        \n        \n#         result = set()\n#         prev = set([0])\n#         for num in A:\n#             curr = set([num])\n#             for prev_num in prev:\n#                 curr.add(prev_num | num)\n#             result |= curr\n#             prev = curr\n#         return len(result)\n", "class Solution:\n    def subarrayBitwiseORs(self, arr: List[int]) -> int:\n        ans = set()\n        current = {0}\n        for x in arr:\n            # print(x,current)\n            current = {x | y for y in current} | {x}\n            # print(current)\n            ans |= current\n            # print(ans)\n        return len(ans)\n    \n        # brute force time complexity :O(n^2)\n        # space complexity:O(n)\n        if not arr:return 0\n        l ,ans = len(arr) ,set()\n        for i in range(l):\n            res = arr[i]\n            ans.add(res)\n            for j in range(i+1,l):\n                res |= arr[j]\n                ans.add(res)\n        return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, a: List[int]) -> int:\n        res, prev = set(), set()\n        res.add(a[0])\n        prev.add(a[0])\n        for i in range(1, len(a)):\n            cur = set()\n            cur.add(a[i])\n            res.add(a[i])\n            for j in prev:\n                cur.add(j|a[i])\n                res.add(j|a[i])\n            prev = cur\n        return len(res)", "class Solution(object):\n    def subarrayBitwiseORs(self, A):\n        final = set()\n        actual = set()\n        for el in A:\n            actual = {el} | {el2 | el for el2 in actual}\n            final |= actual\n        return len(final)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        mp={0:1} \n        ans={} \n        for a in A:\n            temp={} \n            for m in mp:\n                temp[m|a]=1 \n            temp[a]=1 \n            for t in temp:\n                ans[t]=1 \n            mp={} \n            for t in temp:\n                mp[t]=1 \n        cnt=0 \n        for c in ans:\n            cnt+=1 \n        return cnt\n            \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        result_set = set()\n        results = set()\n        for num in A:\n            results = {j | num for j in results}\n            results.add(num)\n            result_set.update(results)\n        return len(result_set)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        \n        ans = set()\n        prev = set()\n        \n        for a in A:\n            \n            cur = set(a | b for b in prev)\n            cur.add(a)\n            \n            prev = cur\n            ans |= cur\n            \n        return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        # O(N^3) to try oring every possible subarray\n        \n        # key fact: for any number k , k | k = k\n        # also 0 | k = k for all k\n        \n        # one small optimization: scan through and delete any 0s or consecutive repeats\n        \n        # keep a list of or results s.t. or[i] = set of all possible results from oring subarrays that end at i\n        # then or[i] = [A[i]] + [A[i] | res for res in or[i - 1]] -> use a set to prune dups at each step\n        #    you can just keep or[i] for most recent two i's\n        # \n        if not A:\n            return []\n        # [1, 2, 4]\n        # all_outcomes: {1, 2, 3, 4, 6, 7}\n        # outcomes: {2, 3}\n        # 4: temp {4, 6, 7}\n        \n        # todo(mywang): preprocess array and remove unnecessary stuff\n        # for i in range(len(A))[::-1]:\n        #     if (i > 0 and A[i] == A[i - 1]):\n        #         A.pop(i)\n        all_outcomes = set()\n        outcomes = set()\n        for elt in A:\n            outcomes = {elt} | {elt | val for val in outcomes}\n            all_outcomes |= outcomes\n        \n        return len(all_outcomes)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        # O(N^3) to try oring every possible subarray\n        \n        # key fact: for any number k , k | k = k\n        # also 0 | k = k for all k\n        \n        # one small optimization: scan through and delete any 0s or consecutive repeats\n        \n        # keep a list of or results s.t. or[i] = set of all possible results from oring subarrays that end at i\n        # then or[i] = [A[i]] + [A[i] | res for res in or[i - 1]] -> use a set to prune dups at each step\n        #    you can just keep or[i] for most recent two i's\n        # \n        if not A:\n            return []\n        # [1, 2, 4]\n        # all_outcomes: {1, 2, 3, 4, 6, 7}\n        # outcomes: {2, 3}\n        # 4: temp {4, 6, 7}\n        \n        # todo(mywang): preprocess array and remove unnecessary stuff\n        for i in range(len(A))[::-1]:\n            if (i > 0 and A[i] == A[i - 1]):\n                A.pop(i)\n        all_outcomes = set()\n        outcomes = set()\n        for elt in A:\n            outcomes = {elt} | {elt | val for val in outcomes}\n            all_outcomes |= outcomes\n        \n        return len(all_outcomes)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        # O(N^3) to try oring every possible subarray\n        \n        # key fact: for any number k , k | k = k\n        # also 0 | k = k for all k\n        \n        # one small optimization: scan through and delete any 0s or consecutive repeats\n        \n        # keep a list of or results s.t. or[i] = set of all possible results from oring subarrays that end at i\n        # then or[i] = [A[i]] + [A[i] | res for res in or[i - 1]] -> use a set to prune dups at each step\n        #    you can just keep or[i] for most recent two i's\n        # \n        if not A:\n            return []\n        # [1, 2, 4]\n        # all_outcomes: {1, 2, 3, 4, 6, 7}\n        # outcomes: {2, 3}\n        # 4: temp {4, 6, 7}\n        \n        # todo(mywang): preprocess array and remove unnecessary stuff\n        for i in range(len(A))[::-1]:\n            if (i > 0 and A[i] == A[i - 1]):\n                A.pop(i)\n        all_outcomes = set([A[0]])\n        outcomes = set([A[0]])\n        for elt in A[1:]:\n            temp = {elt} | {elt | val for val in outcomes}\n            outcomes = temp\n            all_outcomes |= outcomes\n        \n        return len(all_outcomes)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        cur,res = set(),set()\n        for i in A:\n            cur = { i|j for j in cur} | {i}\n            res |= cur\n        return len(res)\n#        nums, n = set(), len(A)\n#        for i in range(n):\n#            num = A[i]\n#            for j in range(i, n):\n#                num |= A[j]\n#                nums.add(num)\n#        return len(nums)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        \n        \n        \n        # my solution ... 736 ms ... 100 % ... 40.6 MB ... 15 %\n        #  time: O(nlogn)\n        # space: O(logn)\n        \n        res = set()\n        tot = set()\n        for a in A:\n            res = {prev | a for prev in res} | {a}  # \u5f97\u51fa\u4ee5\u5f53\u524d a \u7ed3\u5c3e\u7684 subarray\n            tot |= res                              # \u628a\u7ed3\u679c\u5e76\u5165 tot\n        return len(tot)\n        \n        \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        res = set()\n        \n        cur = set()\n        \n        for x in A:\n            cur = {x} | {x | y for y in cur}\n            res |= cur\n            \n        return len(res)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n       # Frontier Set    \n       # Time  complexity: O(NlogW), where N is the length of A, and W is the maximum size of elements in A.\n       # Space complexity: O(NlogW)\n       ans = set()\n       cur = {0}\n       for x in A:\n           cur = {x | y for y in cur} | {x}\n           ans |= cur\n       return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        # 12:57 8/24/20\n        \n        cur, res = set(),set()\n        for num in A:\n            cur = {num | j for j in cur} # | {num}\n            # cur = set(num | k for k in A)\n            cur.add(num)\n            res.update(cur)\n        \n        return len(res)\n        \n        \n                \n        # res, cur = set(), set()\n        # for i in A:\n        #     cur = {i | j for j in cur} | {i}\n        #     res |= cur\n        # return len(res)\n\n            \n                \n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        self.res = set()\n        def helper(idx):\n            if idx < 0:\n                return set()\n            if idx==0:\n                self.res |= {A[idx]}\n                return {A[idx]}\n            val = {A[idx]}|{x|A[idx] for x in helper(idx-1)}\n            self.res |= val\n            return val\n        helper(len(A)-1)\n        return len(self.res)", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        result = set()\n        curr = set()\n        for num in A:\n            curr = {num | prev_num for prev_num in curr}\n            curr.add(num)\n            result.update(curr)\n        return len(result)\n        \n        \n        \n#         result = set()\n#         prev = set([0])\n#         for num in A:\n#             curr = set([num])\n#             for prev_num in prev:\n#                 curr.add(prev_num | num)\n#             result |= curr\n#             prev = curr\n#         return len(result)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n        my_set = set(A)\n        curr = 0\n        prev = set()\n        prev.add(A[0])\n        for num in A[1:]:\n            temp = set()\n            #curr |= num\n            #my_set.add(curr)\n            \n            for p in prev:\n                temp.add(num | p)\n                my_set.add(num | p)\n                \n            #print(temp)\n            prev = temp\n            prev.add(num)\n\n        return len(my_set)\n", "class Solution:\n    def subarrayBitwiseORs(self, A: List[int]) -> int:\n       # Frontier Set    \n       # Time  complexity: O(NlogW) = O(30N), where N is the length of A, and W is the maximum size of elements in A.\n       # Space complexity: O(NlogW)\n       ans = set()\n       cur = {0}\n       for x in A:\n           cur = {x | y for y in cur} | {x}\n           ans |= cur\n       return len(ans)\n", "class Solution:\n    def subarrayBitwiseORs(self, arr: List[int]) -> int:\n        s = set()\n        prev = set()\n        prev.add(arr[0])\n        s.add(arr[0])\n                        \n        for i in range(len(arr)):\n            temp = set()\n            for val in prev:\n                temp.add(val|arr[i])\n                s.add(val|arr[i])\n                \n            prev = temp\n            prev.add(arr[i])\n            s.add(arr[i])\n        \n        return len(s)"]
["class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.x, n = 0, len(s)\n        def maxUniqueSplit_(i=0, S=set()):\n            if s[i:] not in S:\n                self.x = max(self.x, len(S) + 1)\n            \n            for j in range(i + 1, n):\n                if s[i : j] not in S and len(S) + 1 + n - j > self.x:\n                    maxUniqueSplit_(j, S.union({s[i : j]}))\n            \n        \n        maxUniqueSplit_()\n        return self.x", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        start = 0\n        end = 0\n        se = set()\n        res = 0\n        def helper(stn, se, count):\n            nonlocal res\n            if not stn:\n                res = max(res, count)\n            if len(stn) + count <= res:\n                return\n            for i in range(1, len(stn)+1):\n                if stn[:i] not in se:\n                    helper(stn[i:], se|{stn[:i]}, count + 1)\n        helper(s, se, 0)\n        return res\n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str, mem=None, seen=None) -> int:\n        if mem is None:\n          mem={}\n        if seen is None:\n          seen = set()\n        \n        res = 0\n        for i in range(0, len(s)):\n          if s[0:i+1] in seen:\n            continue\n          seen.add(s[0:i+1])\n          res = max(res, 1 + self.maxUniqueSplit(s[i + 1:], mem, seen))\n          seen.remove(s[0:i+1])\n        mem[s] = res\n        \n        return res", "class Solution:\n    \n    def func(self, s, idx, words):\n        max_result = 0\n        for i in range(idx+1, len(s)):\n            max_result = max(max_result, self.func(s, i, words|{s[idx:i]}))\n        max_result = max(max_result, len(words|{s[idx:]}))\n        return max_result\n            \n    \n    def maxUniqueSplit(self, s: str) -> int:\n        return self.func(s, 0, set())\n        \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        #@functools.lru_cache(None)\n        def helper(start):\n            if len(s[start:]) == 0: return 0\n            res = -math.inf\n            for i in range(start+1,len(s)+1):\n                if s[start:i] not in seen:\n                    seen.add(s[start:i])\n                    #print('seen',seen)\n                    followup = helper(i)\n                    res= max(res,1+followup)\n                    #print('results',results,followup,len(seen),seen)\n                    seen.remove(s[start:i])\n            \n            return res\n        \n        seen = set()\n        return helper(0)\n        \n", "class Solution:\n    splits = set()\n    \n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n        result = 0\n\n        for i in range(1, n + 1):\n            current = s[:i]\n            if current not in self.splits:\n                self.splits.add(current)\n                result = max(result, 1 + self.maxUniqueSplit(s[i:]))\n                self.splits.remove(current)\n\n        return result\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        if not s:\n            return 0\n        splits = [[] for _ in range(len(s))]\n        best_len = 0\n        for i, c in enumerate(s):\n            splits[i].append(set([s[:i + 1]]))\n            best_len = max(best_len, 1)\n            for j in range(1, i + 1):\n                ss = s[j: i + 1]\n                for spl in splits[j - 1]:\n                    if ss not in spl:\n                        best_len = max(best_len, len(spl) + 1)\n                        splits[i].append(spl | set([ss]))\n        return best_len", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        \n        \n        def rec(i, myset):\n            if i == len(s):\n                return 0\n            ans = -float('inf')\n            for j in range(i, len(s)):\n                if s[i:j + 1] not in myset:\n                    ans = max(ans, 1 + rec(j + 1, myset | set([s[i:j + 1]])))\n            return ans\n        return rec(0, set())", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        best_ans = 1\n        cur_ans = set()\n        \n        def find_result(i):\n            nonlocal best_ans\n            if i >= len(s):\n                return len(cur_ans)\n            elif len(s) - i + len(cur_ans) < best_ans:\n                return best_ans\n            \n            for j in range(i+1, len(s)+1):\n                substr = s[i:j]\n                if substr not in cur_ans:\n                    cur_ans.add(substr)\n                    best_ans = max(best_ans, find_result(j))\n                    cur_ans.remove(substr)\n            \n            return max(best_ans, len(cur_ans))\n        \n        return find_result(0)\n                \n                    \n            \n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        lookup = set()\n        return self.traverse(s, 0, lookup)\n    \n    def traverse(self, s, index, lookup):\n        if index > len(s):\n            return 0\n        array = []\n        for idx in range(index,len(s)+1):\n            if len(s[index:idx])> 0 and s[index:idx] not in lookup:\n                lookup.add(s[index:idx])\n                array.append(1 + self.traverse(s, idx, lookup))\n                lookup.remove(s[index:idx])\n                \n                \n        return max(array)  if array else 0", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def bitsoncount(x):\n            return bin(x).count('1')\n        \n        ans = 0\n        n = len(s)\n        seen = defaultdict(int)\n        for m in range(1<<n):\n            if (bitsoncount(m) <= ans): \n                continue\n            prev = 0\n            count = 0\n            for i in range(n):\n                if m & (1<<i):\n                    sub = s[prev:i+1]\n                    prev = i+1\n                    if sub not in seen:\n                        seen[sub] += 1\n                        count += 1\n            \n            ans = max(ans, count)\n            seen.clear()\n        \n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        result = []\n        \n        def dfs(path, word):\n            if not word: \n                result.append(path)\n                return\n            for i in range(1, len(word)+1):\n                prefix, suffix = word[:i], word[i:]\n                if prefix not in path:\n                    dfs(path | {prefix}, suffix)\n        \n        dfs(set(), s)\n        l = 1\n        for item in result:\n            l = max(len(item), l)\n        return l\n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        n = len(s)\n        def dp(cur, ss):\n            if cur == n-1:\n                return len(set(ss.split()))\n            cur += 1\n            return max(dp(cur, ss + s[cur]), dp(cur, ss + ' ' + s[cur]))\n        return dp(0, s[0])", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        used = set()\n        self.res = 1\n        self.backtrack(s, 0, used)\n        return self.res\n    \n    def backtrack(self, s, cur, used):\n        if not s:\n            self.res = max(self.res, cur)\n            return\n        for i in range(1, len(s)+1):\n            if s[:i] not in used:\n                used.add(s[:i])\n                self.backtrack(s[i:], cur+1, used)\n                used.remove(s[:i])", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n        self.res = 0\n        \n        \n        def dfs(strs, s):\n            if not s:\n                if len(set(strs)) == len(strs):\n                    self.res = max(self.res, len(strs))\n                return\n            dfs(strs + [s[0]], s[1:])\n            \n            if strs:\n                dfs(strs[:-1] + [strs[-1] + s[:1]], s[1:])\n            \n            \n            return\n        \n        dfs([], s)\n        \n        return self.res", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def helper(s, seen=set()):\n            maximum = 0\n            for i in range(1, len(s) + 1):\n                candidate = s[:i]\n                if candidate not in seen:\n                    maximum = max(maximum, 1 + helper(s[i:], {candidate, *seen}))\n            return maximum\n        return helper(s)\n", "# 1593. Split a String Into the max Number of Unique Substrings\n\ndef walk_divisions (string, covered, cut):\n    if cut == len (string):\n        yield len (covered)\n    else:\n        for nxt in range (cut + 1, len (string) + 1):\n            substring = string[cut : nxt]\n            if substring not in covered:\n                covered.append (substring)\n                yield from walk_divisions (string, covered, nxt)\n                covered.pop ()\n\ndef max_unique_split (string):\n    if len (string) == 1:\n        return 1\n\n    assert len (string) >= 2\n\n    return max (walk_divisions (string, [], 0))\n\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        return max_unique_split(s)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s) \n        def dp(i, cur):\n            nonlocal ans            \n            if len(cur) + n-i < ans: return\n            if i >= n: ans = max(ans, len(cur))                \n            l = n-i\n            for k in range(1, l+1):\n                if s[i:i+k] not in cur: \n                    cur.append(s[i:i+k])\n                    dp(i+k, cur)\n                    cur.pop()            \n        ans, cur = 0, []\n        dp(0, cur)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        prev = [[s[0]]]\n        for elm in s[1:]:\n            current = []\n            for sub in prev:\n                copy = list(sub)\n                copy[-1] = copy[-1] + elm\n                current.append(copy)\n                \n                copy = list(sub)\n                copy.append(elm)\n                current.append(copy)\n                \n            prev = current\n            \n        return max(len(set(combo)) for combo in prev)\n", "class Solution:\n    def maxUniqueSplit(self, s: str, seen=()):\n        maximum = 0\n        if s:\n            for i in range(1, len(s) + 1):\n                candidate = s[:i]\n                if candidate not in seen:\n                    maximum = max(maximum, 1 + Solution.maxUniqueSplit(self, s[i:], {candidate, *seen}))\n        return maximum", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.maxsplits = 0\n        \n        def DFS(i, substring_set):\n            if i == len(s):\n                self.maxsplits = max(len(substring_set), self.maxsplits)\n                return\n\n            for j in range(i + 1, len(s) + 1):\n                DFS(j, substring_set | {s[i: j]})\n\n        DFS(0, set())\n        return self.maxsplits\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        have = set()\n        self.cur = []\n        \n        def dfs(i):\n            if i == len(s):\n                return 0 if ''.join(self.cur) not in have else -float('inf')\n            \n            self.cur.append(s[i])\n            ret = dfs(i + 1)\n            \n            st = ''.join(self.cur)            \n            if st not in have:\n                tmp, self.cur = self.cur, []\n                have.add(st)\n                ret = max(dfs(i + 1) + 1, ret)\n                have.remove(st)\n                self.cur = tmp\n                \n            self.cur.pop()\n            return ret\n            \n        return dfs(0)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.seen = set()\n        self.result = 0\n        \n        def backtrack(s, start):\n            if start == len(s):\n                return True\n            \n            for end in range(start + 1, len(s) + 1):\n                if s[start:end] not in self.seen:\n                    self.seen.add(s[start:end])\n                    if backtrack(s, end):\n                        self.result = max(self.result, len(self.seen))\n                    self.seen.remove(s[start:end])\n            return False\n        backtrack(s, 0)\n        return self.result        ", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        exist = collections.defaultdict(int)\n        self.result = 0\n        n = len(s)\n        def dfs(index:int) -> None:\n            # print(exist, index)\n            if (index == n):\n                self.result = max(self.result, len(exist))\n                return\n            for i in range(index + 1, n + 1):\n                st = s[index:i]\n                exist[st] += 1\n                dfs(i)\n                exist[st] -= 1\n                if (exist[st] == 0):\n                    del exist[st]\n        dfs(0)\n        \n        return self.result", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n=len(s)\n        maxi=0\n        \n        def sub(ind,ar):\n            if(ind==n):\n                if(len(ar)==len(set(ar))):\n                    return len(ar)\n                return maxi\n            a=ar+[s[ind]]\n            b=ar[:]\n            b[-1]+=s[ind]\n            \n            return max(sub(ind+1,a),sub(ind+1,b))\n        return sub(1,[s[0]])\n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.res = 0\n        partition = []\n        def backtrack(start_i):\n            if start_i == len(s):\n                self.res = max(self.res, len(set(partition)))\n            else:\n                for j in range(start_i + 1, len(s) + 1):\n                    partition.append(s[start_i:j])\n                    backtrack(j)\n                    partition.pop()\n        backtrack(0)\n        return self.res", "class Solution:\n    def _dfs(self, s, i, visited):\n        if i == len(s):\n            yield len(visited)\n            return\n        \n        for j in range(i + 1, len(s) + 1):\n            if s[i:j] not in visited:\n                visited.add(s[i:j])\n                yield from self._dfs(s, j, visited)\n                visited.remove(s[i:j])\n        \n    def maxUniqueSplit(self, s: str) -> int:\n        if not s:\n            return 0\n        \n        return max(self._dfs(s, 0, set()))", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def dfs(s, path):\n            res = 0\n            if not s: return len(path)\n            for i in range(1,len(s)+1):\n                res = max(res, dfs(s[i:],path|{s[:i]}))\n            return res\n        return dfs(s,set())", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n    \n    \n        res = 1\n\n        def dfs(pos, path):\n            nonlocal res\n            if pos == len(s):\n                res = max(res, len(set(path)))\n\n            for i in range(pos + 1, len(s) + 1):\n                path.append(s[pos: i])\n                dfs(i, path)\n                path.pop()\n\n        dfs(0, [])\n        return res", "class Solution:        \n    def maxUniqueSplit(self, s: str) -> int:\n        if not s:\n            return 0\n        \n        self.answer = 0\n        substrings = []\n        def backtrack(start_i):\n            if start_i == len(s):\n                self.answer = max(self.answer, len(set(substrings)))\n                return\n            for j in range(start_i+1, len(s)+1):\n                substrings.append(s[start_i:j])\n                backtrack(j)\n                substrings.pop()\n\n        backtrack(0)\n        return self.answer\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        return self.bt(s, set(), 0, 0)\n    \n   \n    def bt(self, s, d, l, maxl): \n        if l >= len(s):\n            maxl = max(len(d), maxl)\n            return maxl\n        else:\n            for r in range(l+1,len(s)+1):  \n                if s[l:r] not in d:   # before put the current stage into your dictionary, make sure it meet the condition. \n                    d.add(s[l:r])     # then, you have two choices: put \n                    maxl=self.bt(s, d, r, maxl)\n                    d.remove(s[l:r])   # the other choice is not put. (add, then remove)\n            return maxl", "class Solution:\n    \n    def maxUniqueSplit(self, s: str) -> int:\n        res = 1\n\n        def dfs(pos, path):\n            \n            nonlocal res\n            if pos == len(s):\n                #print(path)\n                res = max(res, len(set(path)))\n\n            for i in range(pos + 1, len(s) + 1):\n                path.append(s[pos: i])\n                dfs(i, path)\n                path.pop()\n\n        dfs(0, [])\n        return res", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def solve(S, subs):\n            if not S:\n                return len(subs)\n            \n            ans = 0\n            for i in range(len(S)):\n                sub = S[:i+1]\n                ans = max(ans, solve(S[i+1:], subs | {sub}))\n                \n            return ans\n        return solve(s, set())\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s) \n        @lru_cache(None)\n        def dp(i, cur):\n            nonlocal ans            \n            if len(cur) + n-i < ans: return\n            if i >= n: ans = max(ans, len(cur))                \n            l = n-i\n            for k in range(1, l+1):\n                cand = s[i:i+k]\n                if cand not in cur:                     \n                    dp(i+k, cur + (cand,))                         \n        ans, cur = 0, ()\n        dp(0, cur)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self._s = s\n        self.best = 1\n\n        self.solve(0, set(), 0)\n        return self.best\n    \n    def solve(self, index, seen, count):\n        s = self._s\n\n        if index >= len(s):\n            self.best = max(self.best, count)\n        \n        for end in range(index+1, len(s)+1):\n            if s[index:end] not in seen:\n                seen.add(s[index:end])\n                self.solve(end, seen, count+1)\n                seen.remove(s[index:end])\n", "\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        if not s:\n            return 0\n        return self.dfs(s, set())\n\n    def dfs(self, s: str, present: set) -> int:\n        maximum = 0\n\n        for i in range(1, len(s) + 1):\n            substring = s[:i]\n            if substring not in present:\n                sub_try = self.dfs(s[i:], {*present, substring})\n                maximum = max(maximum, 1+sub_try)\n        return maximum\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        \n        \n        \n        n = len(s)\n        def dp(cur, ss):\n            # print(ss)\n            if cur == n-1:\n                return len(set(ss.split()))\n            cur += 1\n            return max(dp(cur, ss + s[cur]), dp(cur, ss + ' ' + s[cur]))\n        return dp(0, s[0])", "class Solution:\n    def __init__(self):\n        self.result = 0\n\n    def maxUniqueSplit(self, s: str) -> int:\n        if not s:\n          return 0\n        def backtrack(start, cur):\n            if start == len(s):\n                self.result = max(self.result, len(set(cur)))\n                return\n\n            for i in range(start, len(s)):\n                cur += [s[start:i+1]]\n                backtrack(i + 1, cur)\n                cur.pop()\n\n        backtrack(0, [])\n\n        return self.result", "class Solution:\n    def max_unique_substrings(self, s, seen=()):\n        maximum = 0\n        for i in range(1, len(s) + 1):\n            candidate = s[:i]\n            if candidate not in seen:\n                maximum = max(maximum, 1 + self.max_unique_substrings(s[i:], {candidate, *seen}))\n        return maximum\n    def maxUniqueSplit(self, s: str) -> int:\n        return self.max_unique_substrings(s)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        res = 1\n\n        def dfs(pos, path):\n            nonlocal res\n            if pos == len(s):\n                res = max(res, len(set(path)))\n\n            for i in range(pos + 1, len(s) + 1):\n                path.append(s[pos: i])\n                dfs(i, path)\n                path.pop()\n\n        dfs(0, [])\n        return res\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        res = 0\n        def dfs(cur_pos):\n            nonlocal res\n            if cur_pos == len(s):\n                res = max(res, len(seen))\n            for next_pos in range(cur_pos, len(s)):\n                if s[cur_pos:next_pos + 1] not in seen:\n                    seen.add(s[cur_pos:next_pos + 1])\n                    dfs(next_pos + 1)\n                    seen.remove(s[cur_pos:next_pos + 1])\n        \n        seen = set()\n        dfs(0)\n        return res\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        def helper(i,s,seen):\n            if i > len(s)-1:\n                return len(seen)\n            max_len = 1\n            for k in range(i,len(s)):\n                temp = set(seen)\n                temp.add(s[i:k+1])\n                max_len = max(max_len, helper(k+1, s,temp))\n            return max_len\n        return helper(0,s,set([]))\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        if not s:\n            return 0\n        self. res = 0\n        stack = []\n        \n        def backtrack(ind):\n            if ind == len(s):\n                self.res = max(self.res, len(set(stack)))\n            \n            for i in range(ind+1, len(s)+1):\n                stack.append(s[ind:i])\n                backtrack(i)\n                stack.pop()\n        backtrack(0)\n        return self.res\n", "class Solution:\n  def maxUniqueSplit(self, s: str) -> int:\n    \n    self.ans=1\n    def rec(split, s):\n      #print(split,s)\n      if not s:\n        se=set(split)\n        if len(se)==len(split):\n          self.ans=max(self.ans,len(split))\n        return\n      \n      \n      for i in range(len(s)):\n        piece=s[0:i+1]\n        spl=split[:]\n        spl.append(piece)\n        rec(spl,s[i+1:])\n    \n    rec([],s)\n    return self.ans", "from itertools import combinations\nfrom math import ceil\n\nclass Solution:\n    \n    def maxUniqueSplit(self, s: str) -> int:\n        \n        l, r = 1, len(s)\n        \n        def check(n):\n            \n            if n == 1: return True\n            \n            pos = [i + 1 for i in range(len(s) - 1)]\n            \n            for dividers in combinations(pos, n - 1):\n                \n                i = 0\n                words = set()\n                flag = 0\n                for p in dividers:\n                    if s[i: p] in words:\n                        flag = 1\n                        break\n                    words.add(s[i: p])\n                    i = p\n                    \n                if not flag and s[i: len(s)] not in words: \n                    return True\n                          \n            return False \n        \n        while l < r:\n            \n            mid = l + (r - l) // 2 + 1\n            \n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        \n        return r\n        \n        \n        \n        \n", "class Solution:\n    max_=0\n    def maxUniqueSplit(self, s: str) -> int:\n        b=len(s)-1\n        ar=[]\n        self.h(s,b,ar)\n        return self.max_\n    def h(self,s,b,ar):\n        ar2=ar.copy()\n        if(b<0):\n            self.max_=max(self.max_,len(ar2))\n            return 0\n        t=s[b:]\n        self.h(s,b-1,ar2)\n        s=s[:b]\n                \n        if(t not in ar2):\n            ar2.append(t)\n            self.h(s,b-1,ar2)\n    \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n\n        if len(s) == 1:\n            return 1\n\n        ltrs = set(list(s))\n\n        counts = {}\n        for ltr in ltrs:\n            counts[ltr] = s.count(ltr)\n\n        unique_count = 0\n        for ltr, count in list(counts.items()):\n            if count == 1:\n                index = s.index(ltr)\n                if index == 0 or index == len(s)-1:\n                    s = s.replace(ltr,'')\n                    unique_count = unique_count + 1\n                else:\n                    prev = s[index-1]\n                    next = s[index+1]\n                    if counts[prev] == 1 and counts[next] == 1:\n                        s = s.replace(ltr, '')\n                        unique_count = unique_count + 1\n\n        if len(s) == 0:\n            return unique_count\n        else:\n            return unique_count + self.find_max(len(s)-1, s)\n\n    def find_max(self, i, s):\n        from sortedcontainers import SortedSet\n\n        unique, unique_count = False, -1\n        words = s.split()\n        if len(words) == len(set(words)):\n            unique_count = len(words)\n\n        if i == 0:\n            return unique_count\n\n        a = self.find_max(i-1, s[:i] + ' ' + s[i:])\n        b = self.find_max(i-1, s)\n\n        return max(a,b,unique_count)\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        seen = set()\n        \n        def dfs(s, seen=seen):\n            if not s:\n                return 0\n            res = 0\n            for i in range(1, len(s)+1):\n                if s[:i] in seen:\n                    continue\n                seen.add(s[:i])\n                res = max(res, 1 + dfs(s[i:]))\n                seen.remove(s[:i])\n            return res\n        \n        return dfs(s)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.s = s\n        self.cache = {}\n        count = self.maxUniqueSplitHelper(0, set())\n        \n        return count\n    \n    def maxUniqueSplitHelper(self, pos: int, substrings: set) -> int:\n        hashed = frozenset(substrings)\n        if (pos, hashed) in self.cache:\n            return self.cache[(pos, hashed)]\n        \n        if pos == len(self.s):\n            return len(substrings)\n        \n        count = 0\n        for i in range(pos, len(self.s)):\n            substring = self.s[pos:i + 1]\n            if substring in substrings:\n                continue\n                \n            substrings.add(substring)\n            count=max(count, self.maxUniqueSplitHelper(i + 1, substrings))\n            substrings.remove(substring)\n            \n        self.cache[(pos, hashed)] = count\n        return count", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        max_len=[1]\n        def helper(i,s,vis):\n            if i==len(s) and i!=s:\n                max_len[0]=max(max_len[0],len(vis))\n                return\n            j=i\n            while j<len(s):\n                if s[i:j+1] not in vis and s[i:j+1]!=s:\n                    vis[s[i:j+1]]=1\n                    helper(j+1,s,vis)\n                    del vis[s[i:j+1]]\n                j+=1\n\n        helper(0,s,{})\n        return  max_len[0]\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        if not s:\n            return 0\n        \n        cache = [None] * len(s)\n        \n        setSet = (self.dp(s, 0, cache))\n        return len(max(setSet, key=lambda x: len(x))) if setSet else 0\n    \n    def dp(self, inputStr, i, cache):\n        if i == len(inputStr):\n            return [set()]\n        \n        if cache[i] is not None:\n            return cache[i]\n        \n        end = len(inputStr) +1\n        \n        res = set()\n        for j in range(i+1, end):\n            tempSol = self.dp(inputStr, j, cache)\n            \n            for substrArr in tempSol:\n                if inputStr[i:j] in substrArr:\n                    continue\n\n                combined = set(substrArr)\n                combined.add(inputStr[i:j])\n                res.add(frozenset(combined))\n        \n        cache[i] = frozenset(res)\n        #print(cache[i])\n        return cache[i]\n                    \n            \n        \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def helper(s, seen):\n            return max((1 + helper(s[i:], {candidate, *seen}) for i in range(1, len(s) + 1) if (candidate := s[:i]) not in seen), default=0)\n        \n        \n        \n\n        rt = helper(s, set())\n        return rt\n\n\n          \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        for answer in range(len(s), 0, -1):\n            num_splits = answer - 1\n            for split_points in combinations(range(1, len(s)), num_splits):\n                current = 0\n                words = set()\n                for split_point in split_points:\n                    words.add(s[current:split_point])\n                    current = split_point\n                words.add(s[current:])\n                if len(words) == answer:\n                    return answer", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        spl = list(s)\n        n = len(spl)\n        c = collections.Counter(spl)\n        if all(v==1 for v in c.values()):\n            return n\n        mx = 2**(n-1)-2\n        ans = 1\n        for cmb in range(mx,0,-1):            \n            bs = list(bin(cmb)[2:].zfill(n-1))\n            if bs.count('1')+1<ans:\n                #if cmb<2**10:\n                    #print(cmb,bs)\n                continue\n            spl = []\n            sub = s[0]\n            for i,b in enumerate(bs):\n                if b=='0':\n                    sub += s[i+1]\n                else:\n                    spl.append(sub)\n                    sub = s[i+1]\n            spl.append(sub)\n            c = collections.Counter(spl)\n            if all(v==1 for v in c.values()):\n                if len(spl)>ans:\n                    ans = len(spl)\n                    #print(n,cmb,ans,spl)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        val=0\n        if len(s)==0:\n            return val\n        def helper(s, sett=()):\n            return max((1 + helper(s[i:], {candidate, *sett}) for i in range(1, len(s) + 1) if (candidate := s[:i]) not in sett), default=0)\n        val=helper(s)\n        return val\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n        currli = []\n        visiting = set()\n        self.maxval = 1\n        def dfs(st, s):\n            if len(s) <= 0:\n                self.maxval = max(self.maxval, len(currli))\n                return True\n            # if i >= n:\n            #     # currli.append(s)\n            #     if s not in visiting:\n            #         return True\n            #     else:\n            #         return False\n                \n            for i in range(1, len(s) + 1):\n                # print(s[0:i], s)\n                if s[0:i] not in visiting:\n                    visiting.add(s[0:i])\n                    currli.append(s[0:i])\n                    dfs(i, s[i:])\n                    # if dfs(i, s[i:]):\n                    #     return True\n                    currli.pop()\n                    visiting.remove(s[0:i])\n                \n            return False\n            \n            \n        \n        \n        for i in range(1, n+1):\n            visiting.add(s[0:i])\n            currli.append(s[0:i])\n            # print(s[0:i], s[i:])\n            dfs(i, s[i:])\n            # if dfs(i, s[i:]):\n            #     break\n            currli.pop()\n            visiting.remove(s[0:i])\n            \n        # return len(currli)\n        return self.maxval\n", "def partition(s):\n    def backtrack(index, path):\n        if index == len(s):\n            res.append(list(path))\n        else:\n            path.append(s[index])\n            backtrack(index+1, path)\n            path.pop()\n\n            if path:\n                path[-1] = path[-1] + s[index]\n                backtrack(index+1, path)\n    res = []\n    backtrack(0, [])\n    return res\nclass Solution:\n    \n    def maxUniqueSplit(self, s: str) -> int:\n        ans = 0\n        lst = partition(s)\n        for prt in lst:\n            if(len(set(prt)) == len(prt)):\n                ans = max(ans, len(prt))\n        # print(lst)\n        return ans\n    \n    \n       \n", "class Solution:\n    def maxUniqueSplit(self, s: str, seen= ()) -> int:\n        return max((1 + self.maxUniqueSplit(s[i:], {candidate, *seen}) for i in range(1, len(s) + 1) if (candidate := s[:i]) not in seen), default=0)\n                    \n                    \n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        res = 0\n        def dfs(before_res, cur_s):\n            nonlocal res\n            if len(cur_s) == 0:\n                res = max(res, len(before_res))\n            for i in range(len(cur_s)):\n                if cur_s[:i + 1] not in before_res:\n                    before_res.add(cur_s[:i + 1])\n                    dfs(before_res, cur_s[i + 1:])\n                    before_res.remove(cur_s[:i + 1])\n        \n        dfs(set(), s)\n        return res\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        self.res = 1\n        \n        def backtrack(curr, idx):\n            if len(curr) != len(set(curr)):\n                return\n            else:\n                if idx == len(s):\n                    self.res = max(self.res, len(curr))\n                    return\n            for i in range(idx + 1, len(s) + 1):\n                backtrack(curr + [s[idx : i]], i)\n        \n        backtrack([], 0)\n        \n        return self.res", "import copy\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n        def dfs(temp, s, res):\n            if len(s) == 0:\n                if len(''.join(list(set(temp)))) == n and len(temp) > len(res):\n                    res = copy.deepcopy(temp)\n                return res\n            for i in range(1, len(s) + 1):\n                \n                temp.append(s[:i])\n                # print(temp)\n                res = dfs(temp, s[i:], res)\n                temp.pop()\n            return res\n        \n        return len(dfs([], s, []))\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        \n        \n        # my solution after contest ends ... 68 ms ... 80 % ... 13.6 MB ... 100 %\n        #  time: O()\n        # space: O()\n        \n        def backtrack(seen, sidx):\n            if sidx == len(s):\n                self.res = max(self.res, len(seen))\n                return\n            if len(seen) + len(s) - sidx <= self.res:  # \u622a\u65ad\u6761\u4ef6\u63d0\u901f  600 ms ===> 68 ms\n                return\n            for eidx in range(sidx, len(s)):\n                if s[sidx:eidx+1] not in seen:\n                    backtrack(seen | {s[sidx:eidx+1]}, eidx+1)\n        self.res = 1\n        backtrack(set(), 0)\n        return self.res\n        \n        \n", "# class Solution:\n#     def maxUniqueSplit(self, s: str) -> int:\n#         def helper(s, seen):\n#             return max((1 + helper(s[i:], {candidate, *seen}) for i in range(1, len(s) + 1) if (candidate := s[:i]) not in seen), default=0)\n\n#         rt = helper(s, set())\n#         return rt\n\n\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.res = 0\n        def dfs(s, path):\n            if not s: self.res = max(self.res, len(path))\n            for i in range(1,len(s)+1):\n                dfs(s[i:],path|{s[:i]})\n        dfs(s,set())\n        return self.res\n\n          \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        def max_uni_seq(s, vis=()):\n            return max((1 + max_uni_seq(s[i:], {sol, *vis}) for i in range(1, len(s) + 1) if (sol := s[:i]) not in vis), default=0)\n        \n        return max_uni_seq(s)", "import functools\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        @functools.lru_cache(None)\n        def dp(i):\n            res=[{s[:i+1]}]\n            for j in range(0,i):\n                for sets in dp(j):\n                    if s[j+1:i+1] not in sets:\n                        res.append(sets|{s[j+1:i+1]})\n            return res\n        return max([len(set_) for set_ in dp(len(s)-1)])", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def max_unique(s, visited=()):\n            return max((1 + max_unique(s[i:], {candidate, *visited}) for i in range(1, len(s) + 1) if (candidate := s[:i]) not in visited), default=0)\n        return max_unique(s)\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        ans = [0]\n        def split(curr, ind):\n            if ind >= len(s):\n                return len(curr)\n            for i in range(ind + 1, len(s) + 1):\n                tmp = curr.copy()\n                tmp.add(s[ind:i])\n                s1 = split(tmp, i)\n                ans[0] = max(ans[0], s1)\n            return len(curr)\n        split(set(), 0)\n        return ans[0]\n                \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def max_unique_substrings(s, seen=()):\n            return max((1 + max_unique_substrings(s[i:], {candidate, *seen}) for i in range(1, len(s) + 1) if (candidate := s[:i]) not in seen), default=0)\n        return max_unique_substrings(s)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        from functools import lru_cache\n        \n        L = len(s)\n        \n        @lru_cache(None)\n        def DP(idx, seen):\n            if idx == L:\n                return len(seen)\n            res = 0\n            for i in range(idx+1, L+1):\n                temp = s[idx:i]\n                if temp in seen:\n                    continue\n                res = max(res, DP(i, seen|{temp}))\n            return res\n                \n            \n        \n        return DP(0, frozenset())\n                    \n        \n", "\ndef max_unique_substrings(s, seen=()):\n    return max((1 + max_unique_substrings(s[i:], {candidate, *seen}) for i in range(1, len(s) + 1) if (candidate := s[:i]) not in seen), default=0)\nclass Solution:\n    \n    def maxUniqueSplit(self, s: str) -> int:\n        return max_unique_substrings(s,());\n        \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def solve(last, idx, cur):\n            if idx == len(s):\n                if len(cur) == len(set(cur)):\n                    self.ans = max(self.ans, len(cur))\n                return\n            \n            cur.append(s[last:idx+1])\n            solve(idx+1, idx+1, cur)\n            cur.pop()\n            \n            solve(last, idx+1, cur)\n        self.ans = 0\n        solve(0, 0, [])\n        return self.ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n    \n        res = 1\n        \n        def dfs(pos, path):\n            nonlocal res\n            \n            if pos == len(s):\n                res = max(res, len(set(path)))\n                \n            for i in range(pos + 1, len(s) + 1):\n                path.append(s[pos:i])\n                dfs(i, path)\n                path.pop()\n                \n        dfs(0, [])\n        return res", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        res = 0\n        dfs = [[set(),s]]\n        while dfs:\n            curSet, curS = dfs.pop()            \n            res = max(res, len(curSet))\n            if len(curSet)+len(curS) <= res or len(curS) == 0:\n                   continue\n                      \n            for i in range(len(curS)):\n                if curS[:i+1] in curSet: continue\n                    \n                curSet.add(curS[:i+1])\n                dfs.append([curSet.copy(), curS[i+1:]])\n                curSet.remove(curS[:i+1])\n                   \n        return res\n        \n            \n            \n                \n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        if s  == None or len(s) == 0:\n            return 0\n        self.res = 0\n        has = set()\n        def dfs(cur, lasti, ct):\n            if cur > len(s):\n                self.res = max(self.res, ct)\n                return\n            for cur in range(cur, len(s) + 1):\n                if s[lasti : cur] not in has:\n                    has.add(s[lasti : cur])\n                    ct += 1\n                    dfs(cur + 1,cur, ct)\n                    ct -= 1\n                    has.remove(s[lasti : cur])\n                else:\n                    while cur <= len(s) and s[lasti : cur] in has:\n                        cur += 1\n                    dfs(cur,lasti, ct)\n        dfs(1,0,0)\n        return self.res\n                \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def divide(s):\n            for i in range(1, len(s)):\n                low = s[0: i]\n                high = s[i: ]\n                yield (low, high)\n                for div in divide(high):\n                    ret = [low]\n                    ret.extend(div)\n                    yield ret\n\n        combinations = list(divide(s))\n        combinations.append(s)\n        # print(combinations)\n        ret = 1\n        for comb in combinations:\n            if len(comb) == len(set(comb)):\n                # print(comb, set(comb))\n                ret = max(ret, len(comb))\n        return ret\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        visited = set()\n        def dfs(start):\n            nonlocal visited\n            if start == len(s):\n                return 0\n            res = 0\n            for i in range(start,len(s)):\n                if s[start:i+1] not in visited:\n                    visited.add(s[start:i+1])\n                    res = max(res, 1+ dfs(i+1))\n                    visited.remove(s[start:i+1])\n                else:\n                    res = max(res, dfs(i+1))\n            return res\n        return dfs(0)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.res = 0\n        def dfs(s, path):\n            if not s: self.res = max(self.res, len(path))\n            for i in range(1,len(s)+1):\n                dfs(s[i:],path|{s[:i]})\n        dfs(s,set())\n        return self.res", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        combin_dict = {s[0]:[set(s[0])]}\n        for index, char in enumerate(s[1:]):\n            new_dict = {}\n            for last_str, sets in combin_dict.items():\n                for combin_set in sets:\n                    \n                    if char not in new_dict:\n                        new_dict[char] = []\n                    single_new_set = combin_set | set(char)\n                    if len(''.join(combin_set)) == index+1:\n                        new_dict[char].append(single_new_set)\n                    \n                    new_last = last_str+char\n                    if len(''.join(combin_set)) == index+1:\n                        new_set = combin_set.difference(set([last_str]))\n                    else:\n                        new_set = combin_set\n                    new_set.add(new_last)\n                    if new_last not in new_dict:\n                        new_dict[new_last] = []\n                    new_dict[new_last].append(new_set)\n            combin_dict = new_dict\n            \n            \n        res = 0\n        for key, value in combin_dict.items():\n            for value_set in value:\n                if len(''.join(value_set)) == len(s):\n                    res = max(res, len(value_set))\n        return res", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def f(s, seen):\n            if not s: return 0\n            res = 0\n            for i in range(1,len(s)+1):\n                chunk = s[:i]\n                if chunk not in seen:\n                    res = max(res, f(s[i:], seen | {chunk}) + 1)\n            return res\n        return f(s, set())\n                \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        ans = 0\n        queue = [(set([s[:i]]), s[i:]) for i in range(1, len(s) + 1)]\n        while queue:\n            curSet, curS = queue.pop(0)\n            if curS == '':\n                ans = max(ans, len(curSet))\n\n            for i in range(1, len(curS) + 1):\n                if curS[:i] in curSet:\n                    continue\n                else:\n                    tmpSet = curSet.copy()\n                    tmpSet.add(curS[:i])\n                    queue.append((tmpSet, curS[i:]))\n\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        res = 0\n        dfs = [[set(),s]]\n        while dfs:\n            curEl = dfs.pop()            \n            res = max(res, len(curEl[0]))\n            if len(curEl[0])+len(curEl[1]) <= res or len(curEl[1]) == 0:\n                   continue\n                      \n            for i in range(len(curEl[1])):\n                if curEl[1][:i+1] in curEl[0]: continue\n                    \n                curEl[0].add(curEl[1][:i+1])\n                dfs.append([curEl[0].copy(), curEl[1][i+1:]])\n                curEl[0].remove(curEl[1][:i+1])\n                   \n        return res\n        \n            \n            \n                \n            \n", "class Solution:\n    def helper(self, s,occur):\n        if len(s) == 0:\n            return 0\n        curMax = -1\n        for i in range(1,len(s)+1):\n            if s[:i] not in occur:\n                occur.append(s[:i])\n                if (s[i:],tuple(occur)) in self.memo:\n                    res = self.memo[(s[i:],tuple(occur))]\n                else:\n                    res = self.helper(s[i:], occur)\n                    self.memo[(s[i:],tuple(occur))] = res\n                if res >= 0:\n                    curMax = max(curMax, 1+res)\n                occur.pop()\n        return curMax\n        \n    def maxUniqueSplit(self, s: str) -> int:\n        self.memo = {}\n        return self.helper(s,[])\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n= len(s)\n        def back(i, curr, addhere ):\n            if i==n:\n                return len(addhere)-1\n            if curr+s[i] in addhere:\n                return back(i+1, curr+s[i], addhere.copy())\n            else:\n                return max( back(i+1, '', addhere.union({curr+s[i]})), back(i+1, curr+s[i], addhere.copy())   )\n        b = set()\n        b.add('')\n        return back(0,'',b)\n        \n", "class Solution:\n    ans=1\n    def getans(self,s,start,n,temp):\n        self.ans=max(self.ans,len(temp))\n        for x in range(start+1,n+1):\n            boss=set(list(temp))\n            boss.add(s[start:x])\n            self.getans(s,x,n,boss)\n            \n            \n    def maxUniqueSplit(self, s: str) -> int:\n        temp=set()\n        self.getans(s,0,len(s),temp)\n        return self.ans\n            \n", "import itertools\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        positions = []\n        for i in range(1,len(s)):\n            positions.append(i)\n        if(len(s) < 3):\n            if(s[0] != s[1]):\n                return 2\n        maximally_split = 1\n        for i in range(1,len(s)):\n            separate_positions = list(itertools.combinations(positions,i))\n            for separate_position in separate_positions:\n                curr_position = 0\n                curr_idx = 0\n                substrings = []\n                while(curr_idx < len(separate_position)):\n                    substrings.append(s[curr_position:separate_position[curr_idx]])\n                    curr_position = separate_position[curr_idx]\n                    curr_idx += 1\n                substrings.append(s[curr_position:])\n                length_of_unique_list = len(set(substrings))\n                if(length_of_unique_list == len(substrings)):\n                    if(length_of_unique_list > maximally_split):\n                        maximally_split = length_of_unique_list\n        if(len(set(list(s))) > maximally_split):\n            maximally_split = len(set(list(s)))\n        return maximally_split", "def max_unique_substrings(s, seen=()):\n    return max((1 + max_unique_substrings(s[i:], {candidate, *seen}) for i in range(1, len(s) + 1) if (candidate := s[:i]) not in seen), default=0)\n\n\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        return max_unique_substrings(s)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def solve(start, visited, memo):\n            state = (start, tuple(visited))\n            if start >= len(s):\n                return 0\n            if state in memo:\n                return memo[state]\n            result = 0\n            for idx in range(start, len(s)):\n                cut_str = s[start:idx + 1]\n                pos = get_position(cut_str)\n                if visited[pos]:\n                    continue\n                visited[pos] = True\n                \n                result = max(result, 1 + solve(idx + 1, visited, memo))\n                visited[pos] = False\n            memo[state] = result\n            return result\n        def get_position(string):\n            return self.sub_str_pos[string]\n        self.sub_str_pos = {}\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                sub_str = s[i:j + 1]\n                if sub_str not in self.sub_str_pos:\n                    self.sub_str_pos[sub_str] = len(self.sub_str_pos)\n        return solve(0, [False for _ in range(len(self.sub_str_pos))], {})\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def split(s):\n            if not s:\n                return [set()]\n            n = len(s)\n\n            w = set()\n            w.add(tuple([s]))\n\n            ret = [set([s])]\n            if n == 1:\n                return ret\n            if n == 2:\n                if s[0] != s[1]:\n                    ret += [set([*s])]\n                return ret\n            for i in range(1, n):\n                ls = split(s[0:i])\n                rs = split(s[i:n])\n                for l in ls:\n                    for r in rs:\n                        if len(l.intersection(r)) == 0:\n                            e = tuple(sorted(list(l | r)))\n                            if e not in w:\n                                w.add(e)\n                                ret += [l | r]\n            return ret\n\n        if not s:\n            return 0\n        n = len(s)\n        if n < 10:\n            ws = split(s)\n            return max(map(len, ws))\n        else:\n            ans = 0\n\n            ls = split(s[:7])\n            rs = split(s[7:])\n            ws = []\n            w = set()\n            for l in ls:\n                for r in rs:\n                    if len(l.intersection(r)) == 0:\n                        e = tuple(sorted(list(l | r)))\n                        if e not in w:\n                            w.add(e)\n                            ws += [l | r]\n            ans = max(ans, max(map(len, ws)))\n\n            ls = split(s[:6])\n            rs = split(s[6:])\n            ws = []\n            w = set()\n            for l in ls:\n                for r in rs:\n                    if len(l.intersection(r)) == 0:\n                        e = tuple(sorted(list(l | r)))\n                        if e not in w:\n                            w.add(e)\n                            ws += [l | r]\n            ans = max(ans, max(map(len, ws)))\n\n            return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        res = 0\n        dfs = [[set(),s]]\n        while dfs:\n            curEl = dfs.pop()            \n            res = max(res, len(curEl[0]))\n            if len(curEl[0])+len(curEl[1]) <= res or len(curEl[1]) == 0:\n                   continue\n                      \n            for i in range(len(curEl[1])):\n                noDel = curEl[1][:i+1] in curEl[0]\n                if noDel: continue\n                curEl[0].add(curEl[1][:i+1])\n                dfs.append([curEl[0].copy(), curEl[1][i+1:]])\n                if not noDel:\n                    curEl[0].remove(curEl[1][:i+1])\n                   \n        return res\n        \n            \n            \n                \n            \n", "import collections\nimport itertools\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def check(b):\n            h = {}\n            w = ''\n            b = list(b) + [0] # b[len(s)-1] should be zero\n            for i, v in enumerate(b):\n                w += s[i]\n                if v == 0:\n                    if w in h: return -1\n                    h[w] = 1\n                    w = ''\n            return len(h)\n        ans = 1\n        for b in itertools.product([0,1], repeat=len(s)-1):\n            # if b[i]==1, b[i] is concatenated to b[i+1]\n            n = check(b)\n            ans = max(ans, n)\n        return ans", "import collections\nimport itertools\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def check(b):\n            h = {}\n            w = ''\n            for i, v in enumerate(b):\n                w += s[i]\n                if v == 0:\n                    if w in h:\n                        return -1\n                    else:\n                        h[w] = 1\n                    w = ''\n            w += s[-1]\n            if w != '':\n                if w in h:\n                    return -1\n                else:\n                    h[w] = 1\n            #print(h)\n            return len(h)\n        ans = 1\n        for b in itertools.product([0,1], repeat=len(s)-1):\n            n = check(b)\n            if n > 0:\n                ans = max(ans, n)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        # len(s) <= 16, only lower_case\n        n = len(s)\n        mx = 1\n        m = n - 1\n        total = (1 << m)\n        state = 0\n        for state in range(total):\n            seen = set()\n            lo = 0\n            for i in range(m + 1):\n                if state & (1 << i):\n                    token = s[lo:i + 1]\n                    if token in seen:\n                        break\n                    else:\n                        seen.add(token)\n                    lo = i + 1\n            else:\n                token = s[lo:n]\n                if token not in seen:\n                    seen.add(token)\n                    mx = max(len(seen), mx)\n        return mx", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        i = 0\n        self.res = 0\n        \n        \n        def sub(s, x):\n            if len(s) == 0:\n                if sorted(x) == sorted(list(set(x))):\n                    self.res = max(self.res, len(set(x)))\n                return\n\n            for i in range(1, len(s)+1):\n                sub(s[i:], x + [s[:i]])\n            \n        res = sub(s, [])\n        return self.res", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        # dp = [[\\\"\\\"] for _ in range(len(s))]\n        # dp[0] = [s[0]]\n        # for i in range(1, len(s)):\n        #     maxnum_ = 1\n        #     for j in range(i):\n        #         if s[j+1:i] not in dp[j]:\n        #             maxnum = len(dp[j]) + 1\n        #             if maxnum > maxnum_:\n        #                 maxnum_ = maxnum\n        #                 dp[i] = dp[j].copy() \n        #                 dp[i].append(s[j+1:i])\n        # print(dp)\n        # return len(dp[len(s)-1])\n#         return len(self.maxUniqueSplit_(s, len(s)-1)[-1])\n    \n#     @lru_cache\n#     def maxUniqueSplit_(self, s, i):\n#         if i == 0:\n#             return [[s[i]]]\n#         else:\n#             max_ = 0\n#             toreturn = []\n#             for j in range(i):\n#                 maxUniqueSplit_j = self.maxUniqueSplit_(s, j)\n#                 for uniquesplit_j in maxUniqueSplit_j:\n#                     if s[j+1:i+1] not in uniquesplit_j:\n#                         if len(uniquesplit_j) + 1 > max_:\n#                             toreturn = [uniquesplit_j + [s[j+1:i+1]]]\n#                             max_ = len(uniquesplit_j) + 1\n#                         elif len(uniquesplit_j) + 1 == max_:\n#                             toreturn.append(uniquesplit_j + [s[j+1:i+1]])\n#                     if j == i - 1 and len(toreturn) == 0:\n#                         toreturn = [uniquesplit_j]\n#             print(toreturn, i)\n#             return toreturn\n        if len(s) == 1:\n            return 1\n        def splitter(str):\n            for i in range(1, len(str)):\n                start = str[0:i]\n                end = str[i:]\n                yield (start, end)\n                for split in splitter(end):\n                    result = [start]\n                    result.extend(split)\n                    yield result\n        \n        maxnum = 0\n        for split in splitter(s):\n            if len(set(split)) == len(split):\n                maxnum = max(len(split), maxnum)\n        if maxnum == 0:\n            return self.maxUniqueSplit(s[:len(s)-1])\n        else:\n            return maxnum\n                \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        dp = [[] for i in range(len(s))]\n        dp[0].append([s[0]])\n        \n        for i in range(1, len(s)):\n            for j in range(len(dp[i-1])):\n                comb = dp[i-1][j]\n                \n                dp[i].append(comb[:-1]+[comb[-1]+s[i]])\n                dp[i].append(comb+[s[i]])\n        _max = 0\n        \n        for i in range(len(s)):\n            for j in range(len(dp[i])):\n                length = len(set(dp[i][j]))\n                if length >_max:\n                    _max = length\n                \n        return _max\n            \n", "from collections import defaultdict\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n        memo = [[] for _ in range(n)]\n        def unique_split(i):\n            if memo[i]:\n                return memo[i]\n            memo[i].append(set([s[:i+1]]))\n            for j in range(i):\n                sets = unique_split(j)\n                for sub in sets:\n                    if s[j+1:i+1] not in sub:\n                        memo[i].append(sub|set([s[j+1:i+1]]))\n            return memo[i]\n        sublen = [len(lst) for lst in unique_split(n-1)]\n        # print(memo)\n        return max(sublen)\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        from itertools import combinations\n        for k in reversed(list(range(len(s) + 1))):\n            for comb in combinations(list(range(1, len(s))), k):\n                split_idxs = [0, *comb, len(s)]\n                splits = []\n                for prev, next in zip(split_idxs, split_idxs[1:]):\n                    splits.append(s[prev:next])\n                if len(set(splits)) == len(splits):\n                    return len(splits)\n        return 0\n\n", "import itertools\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        maxres = 1\n        for sep in itertools.product([0,1], repeat = len(s)-1):\n            # print(sep)\n            sett = set()\n            cur = s[0]\n            for i,(se,c) in enumerate(zip(sep, s[1:]), start=1):\n                if se:\n                    if cur in sett:\n                        break\n                    sett.add(cur)\n                    cur = c\n                else:\n                    cur += c\n            else:\n                if cur in sett:\n                    continue\n                sett.add(cur)\n                # print(sep, sett)\n                maxres = max(maxres, len(sett))\n        return maxres\n        \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        # take greedy \n        words = list(s)\n        N = len(words)\n        ans = 0\n        def backtrack(words, s):\n            nonlocal ans\n            n = len(words)\n            if n==0:\n                ans = max(len(s), ans)\n            for i in range(1, n+1):\n                if str(words[:i]) not in s:\n                    s.add(str(words[:i]))\n                    backtrack(words[i:], s)\n                    s.remove(str(words[:i]))\n                    \n        backtrack(words, set())\n        return ans\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        # print(s)\n        le = len(s) - 1\n        max = 1\n        for ma in range(pow(2, le) - 1, 0, -1):\n            bi = format(ma, '0' + str(le) + 'b') + '1'\n            prev = 0\n            lis = []\n            valid = True\n            for bit in range(len(bi)):\n                if bi[bit] == '1':\n                    part = s[prev:bit + 1]\n                    if part in lis:\n                        valid = False\n                        break\n                    lis.append(part)\n                    prev = bit + 1\n            if valid and len(lis) > max:\n                max = len(lis)\n        return max\n                \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        if len(s) == 1:\n            return 1\n        \n        n = len(s)\n        # dic = {}\n        # def helper(length,s,res):\n        #     if idx == n:\n        #         return\n        #     s = s[:]\n            \n                \n        \n        dp = [0] * (n+1)\n        dp[0] = [set()]\n        \n        for end in range(1,n+1):\n            ls = []\n            sub = set()\n            for start in range(end):\n                for ele in dp[start]:\n                    last = ele.copy()\n                    node = s[start:end]\n                    last.add(node)\n                    ls.append(last)\n                        #sub = last\n            dp[end] = ls\n        res = 0\n        for i in dp[-1]:\n            if len(i) > res:\n                res = len(i)\n        return res\n                \n                \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        to_ret = 0\n        for bin_i in range(2**(len(s)-1)) :\n            to_deal = set()\n            mark=True\n            last = s[0]\n            for i in range(len(s)-1) :\n                cn = s[i+1]\n                if (bin_i & (1<<i))  :\n                    if last in to_deal :\n                        mark = False\n                        break\n                    to_deal.add(last)\n                    last = cn\n                else :\n                    last += cn\n            if last in to_deal :\n                mark = False\n            else :\n                to_deal.add(last)\n            if mark : \n                to_ret = max(to_ret, len(to_deal))\n        return to_ret", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n        ans = 0\n        for pat in range(1 << n-1):\n            start = 0\n            end = 1\n            split = []\n            # add s[start: end]\n            for b in bin(pat)[2:].zfill(n - 1):\n                if b == '1':\n                    split.append(s[start:end])\n                    start = end\n                    end += 1\n                else:\n                    end += 1\n            split.append(s[start:end])\n            if len(set(split)) == len(split):\n                ans = max(ans, len(split))\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        res=[[s[0]]]\n\n        for i in s[1:]:\n            \n            for _ in range(len(res)):\n                j=res.pop(0)\n                res.append(j+[i])\n                res.append(j[:-1]+[j[-1]+i])\n \n\n\n        return max(list(map(len,list(map(set,res)))))\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        to_ret = 0\n        for bin_i in range(2**(len(s)-1)) :\n            to_deal = set()\n            mark=True\n            last = s[0]\n            for i in range(len(s)-1) :\n                cn = s[i+1]\n                if (bin_i & (1<<i)) > 0 :\n                    if last in to_deal :\n                        mark = False\n                        break\n                    to_deal.add(last)\n                    last = cn\n                else :\n                    last += cn\n            if last in to_deal :\n                mark = False\n            else :\n                to_deal.add(last)\n            if mark : \n                to_ret = max(to_ret, len(to_deal))\n        return to_ret", "from itertools import combinations\n\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        # Loop over possible number of splits\n        for num_splits in reversed(range(1, len(s))):\n            num_strings = num_splits + 1\n            # Split the string at those starting indices\n            for split_indices in combinations(range(1, len(s)), num_splits):\n                indices = [0] + list(split_indices) + [len(s)]\n                \n                split_strs = set()\n                for start, end in zip(indices[:-1], indices[1:]):\n                    split_strs.add(s[start:end])\n                if len(split_strs) == num_strings:\n                    return num_strings  # We did it!\n        \n        # We couldn't find a splitting\n        return 1", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        d = {}\n        for i in s:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        if len(d) == len(s):\n            return len(d)\n        \n        def waysToSplit(s): # return list of sequences\n            if not s:\n                return []\n            if len(s) == 1:\n                return [[s]]\n            else:\n                res = []\n                for i in range(len(s)):\n                    first = [s[:i+1]]\n                    second = waysToSplit(s[i+1:])\n                    for seq in second:\n                        res.append(first + seq)\n                res.append([s])\n            return res\n        \n        maxCount = 1\n        \n        sequences = waysToSplit(s)\n        #print(sequences)\n        for seq in sequences:\n            s = set()\n            count = 0\n            foundDup = False\n            for element in seq:\n                if element in s:\n                    foundDup = True\n                    break\n                else:\n                    count += 1\n                    s.add(element)\n            if not foundDup:\n                maxCount = max(maxCount, count)\n        return maxCount\n                \n                \n", "from functools import lru_cache\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        @lru_cache(None)\n        def rec(i, fs):\n            if i == len(s):\n                return 0\n            ans = float('-inf')\n            sub = ''\n            for j in range(i, len(s)):\n                sub += s[j]\n                if sub not in fs:\n                    ans = max(ans, rec(j+1, fs | frozenset([sub])) + 1)\n            return ans\n        return rec(0, frozenset())", "class Solution:\n    def f(self, s):    \n        xss = []\n        if len(s) == 0:\n            temp = []\n            temp.append('')\n            xss.append(temp)\n            return xss\n        for i in range(1,len(s)+1):\n            xs = self.f(s[i:])\n            for x in xs:\n                if s[:i] not in x:\n                    x.append(s[:i])\n                    xss.append(x)\n  \n        return xss\n                \n    def maxUniqueSplit(self, s: str) -> int:\n        x = max([len(y) for y in self.f(s)])\n        \n        return x-1", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def permutations(s):\n            result = [[s]]\n            for i in range(1,len(s)):\n                start = [s[:i]]\n                end = s[i:]\n                for p in permutations(end):\n                    result.append(start + p)\n            return result\n        \n        l = permutations(s)\n        #print(l)\n        maxt = 0\n        totalset = set()\n        for i in l:\n            if len(set(i)) == len(i):\n                if len(i) > maxt:\n                    maxt = len(i)                 \n        return maxt", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n        res = 1\n        if n == 1: return res\n        for x in range(2**(n-1)):\n            m = 1<<(n-2)\n            p0 = 0\n            p1 = 0\n            st = set()\n            done = False\n            while m:\n                if x&m:\n                    sr = s[p0:p1+1]\n                    if sr in st:\n                        done = True\n                        break\n                    st.add(sr)\n                    p0 = p1 + 1\n                    p1 = p1 + 1\n                else:\n                    p1 += 1\n                m>>=1\n            if not done:\n                sr = s[p0:p1 + 1]\n                if sr not in st: res = max(res, len(st) + 1)\n        return res", "from functools import lru_cache\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        @lru_cache(None)\n        def helper(s, n):\n            # print(s, n)\n            ts = set()\n            cs = ''\n            for i in range(len(s)):\n                cs += s[i]\n                if n % 2 == 1:\n                    if cs in ts:\n                        # print(ts, cs)\n                        return -1\n                    else:\n                        ts.add(cs)\n                        cs = ''\n                    n = n//2\n                else:\n                    n = n//2\n                    continue\n            if cs != '':\n                if cs in ts:\n                    # print(ts, cs)\n                    return -1\n                else:\n                    ts.add(cs)\n            # print(ts)\n            return len(ts)\n        \n        r = -1\n        for i in range(0, 2**(len(s)-1)):\n            r = max(r, helper(s, i))\n        return r\n                    \n        \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n=len(s)\n        if n==1:\n            return 1\n        from itertools import combinations\n        L=list(range(1,n))\n        for d in range(n-1,0,-1):\n            for x in combinations(L,d):\n                hh=[0]+list(x)+[n]\n                tmep=[s[hh[j]:hh[j+1]] for j in range(len(hh)-1)]\n                if len(set(tmep))==len(tmep):\n                    return d+1\n        return 1\n                \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n        ans = 1\n        for i in range(2 ** (n-1)):\n            b = '1' + bin(i)[2:].zfill(n-1) + '1'\n            pr = 0\n            w = set()\n            flag = True\n            for k in range(1, n+1):\n                if k == n or b[k] == '1':\n                    chrs = s[pr: k]\n                    if chrs in w:\n                        flag = False\n                        break\n                    w.add(chrs)\n                    pr = k\n            if flag:\n                ans = max(ans, len(w))\n        return ans\n        \n            \n            \n        \n        \n        \n#         @lru_cache(None)\n#         def dp(s):\n#             if s == '':\n#                 return set()\n#             if len(s) == 1:\n#                 return set([s[0]])\n#             ans = 0\n#             com = set()\n#             for i in range(1,len(s)+1):\n#                 l = set([s[:i]])\n#                 r = dp(s[i:])\n#                 if i != len(s) and len(r) == 0: # unvalid right\n#                     continue\n                \n#                 if len(l.intersection(r)) == 0:\n#                     if len(l) + len(r) > ans:\n#                         ans = len(l) + len(r)\n#                         com = l.union(r)\n#             return com\n        \n#         print(dp(s))\n#         return len(dp(s))\n                    \n            \n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def split(s):\n            if len(s) == 0:\n                return []\n            if len(s) == 1:\n                return [[s]]\n            res = []\n            for i in range(1,len(s) + 1):\n                ans = [s[:i]]\n                splits = split(s[i:])\n                if splits:\n                    for sub in splits:\n                        res.append(ans + sub)\n                else:\n                    res.append(ans)\n            return res\n        \n            \n        options = split(s)\n        m = 0\n        for o in options:\n            if len(o) == len(set(o)):\n                m = max(m, len(o))\n        return m", "class Solution:\n    def dfs(self, s, req_l, segs, cur, hs):\n        if cur >= len(s):\n            return segs == req_l\n\n        for pos in range(cur, len(s)):\n            ts = s[cur:pos+1]\n            if ts in hs:\n                continue\n            hs.add(ts)\n            if self.dfs(s, req_l, segs+1, pos+1, hs):\n                return True\n            hs.remove(ts)\n        return False\n\n    def maxUniqueSplit(self, s: str) -> int:\n        for i in range(len(s), 0, -1):\n            if self.dfs(s, i, 0, 0, set()):\n                return i\n        return 1\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def check(s):\n            if len(s)==1:\n                return [[s]]\n            if len(s)==0:\n                return[[]]\n            ans = []\n            for i in range(1,len(s)+1):\n                for item in check(s[i:]):\n                    ans.append([s[:i]]+item)\n            return ans\n        result = check(s)\n        ans = 0\n        for item in result:\n            if len(set(item)) == len(item):\n                ans = max(len(item),ans)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        ans = 0\n        for i in range(1, 2**(len(s) - 1) + 1):    \n            prev = 0\n            seen = set()\n            for j in range(0, len(s)):\n                if i & (1 << j):\n                    seen.add(s[prev:(j+1)])\n                    prev = j + 1\n            final = s[prev:len(s)]\n            if len(final):\n                seen.add(final)\n            ans = max(ans, len(seen))\n        return ans", "class Solution:\n    def maxUniqueSplit(self, ss: str) -> int:\n        @lru_cache(None)\n        def dfs(s, words):\n            if not s: return 0\n            res = 0\n            words = set(words)\n            for i in range(len(s)):\n                if s[:i+1] not in words:\n                    res = max(res, 1 + dfs(s[i+1:], tuple(words | set([s[:i+1]]))))\n            return res\n        return dfs(ss, ())\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n=len(s)\n        ans=-1\n        for bit in range(1<<n-1):\n            sep=[]\n            for i in range(n-1):\n                if bit>>i&1:sep.append(i+1)\n            sep.append(n)\n            ww=set()\n            l=r=0\n            ng=False\n            for r in sep:\n                w=s[l:r]\n                if w in ww:\n                    ng=True\n                    break\n                ww.add(w)\n                l=r\n            if ng:continue\n            ans=max(ans,len(ww))\n        return ans\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def split(s):\n            if not s:\n                return [set()]\n            n = len(s)\n\n            w = set()\n            w.add(tuple([s]))\n\n            ret = [set([s])]\n            if n == 1:\n                return ret\n            if n == 2:\n                if s[0] != s[1]:\n                    ret += [set([*s])]\n                return ret\n            for i in range(1, n):\n                ls = split(s[0:i])\n                rs = split(s[i:n])\n                for l in ls:\n                    for r in rs:\n                        if len(l.intersection(r)) == 0:\n                            e = tuple(sorted(list(l | r)))\n                            if e not in w:\n                                w.add(e)\n                                ret += [l | r]\n            return ret\n\n        if not s:\n            return 0\n        n = len(s)\n        if n < 12:\n            ws = split(s)\n            return max(map(len, ws))\n        else:\n            ans = 0\n\n            ls = split(s[:8])\n            rs = split(s[8:])\n            ws = []\n            w = set()\n            for l in ls:\n                for r in rs:\n                    if len(l.intersection(r)) == 0:\n                        e = tuple(sorted(list(l | r)))\n                        if e not in w:\n                            w.add(e)\n                            ws += [l | r]\n            ans = max(ans, max(map(len, ws)))\n\n            return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def split(s, b): #split into substrings given bit string b\n            res = []\n            x, y = s[0], b[0]\n            for i in range(1, len(s)):\n                if b[i]==y:\n                    x += s[i]\n                else:\n                    res.append(x)\n                    x, y = s[i], b[i]\n            res.append(x)\n            return res\n                    \n        count = 0\n        for i in range(2**(len(s)-1)):\n            b = bin(i)[2:]\n            bb = '0' * (len(s) - len(b)) + b    # padding + bits\n            res = split(s, bb)\n            #print(bb, res)\n            if len(res) == len(set(res)):\n                count = max(count, len(res))\n                \n        return count\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        l = len(s)\n        for i in range(l - 1, 0, -1):\n            for j in itertools.combinations(range(1, l), i):\n                cut = [0] + list(j)\n                subs = []\n                for k in range(len(cut)):\n                    if k == len(cut) - 1:\n                        subs.append(s[cut[k]:])\n                    else:\n                        subs.append(s[cut[k]: cut[k + 1]])\n                if len(subs) == len(set(subs)):\n                    return len(subs)\n        return 1", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def split(s, b): #split into substrings given bit string b\n            res = []\n            x, y = s[0], b[0]\n            for i in range(1, len(s)):\n                if b[i]==y:\n                    x += s[i]\n                else:\n                    res.append(x)\n                    x, y = s[i], b[i]\n            res.append(x)\n            return res\n        \n        max_len = 0\n        for i in range(2**(len(s)-1)):\n            b = bin(i)[2:]\n            b = '0'*(len(s)-len(b)) + b\n            res = split(s,b) #split based on bit string\n            if len(res)==len(set(res)): #check if the split forms valid substrings\n                max_len = max(max_len, len(res)) #compare against max length so far\n        return max_len\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        res = 0\n        for count in range(len(s)):\n            for partitions in combinations(range(1, len(s)), count):\n                partitions = [0] + list(partitions) + [len(s)]\n                parts = [s[a:b] for a, b in zip(partitions, partitions[1:])]\n                if len(parts) == len(set(parts)):\n                    res = max(res, len(parts))\n        return res", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        result = 1\n        for l in itertools.product([True, False], repeat=len(s)):\n            if l[-1] == False:\n                continue\n            cache = list()\n            now = ''\n            for c, end in zip(s, l):\n                now += c\n                if end:\n                    cache.append(now)\n                    now = ''\n            if len(cache) == len(set(cache)):\n                result = max(result, len(cache))\n        return result\n        # length = len(s)\n        # cache = set()\n        # now = 0\n        # l = 1\n        # while now + l <= length:\n        #     if s[now: now + l] in cache:\n        #         l += 1\n        #     else:\n        #         cache.add(s[now: now + l])\n        #         now += l\n        #         l = 1\n        # return len(cache)\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)-1\n        ans = 1\n        for i in range(2**n+1):\n            prev = 0\n            ok = True\n            visited = set()\n            for j in range(n):\n                if i & (1<<j):\n                    tmp = s[prev:j+1]\n                    prev = j+1\n                    if tmp in visited:\n                        ok = False\n                        break\n                    visited.add(tmp)\n                    #print(visited)\n                if not ok:\n                    break\n            if not ok:\n                continue\n            tmp = s[prev:]\n            #print(tmp, visited)\n            if tmp not in visited:\n                #print(visited)\n                ans = max(ans, len(visited) + 1)\n        return ans            \n                    \n        \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def allsplit(s):\n            if len(s)==1:\n                return [[s]]\n            \n            res = [[s]]\n            for i in range(1,len(s)):\n                res += [[s[:i]] + x for x in allsplit(s[i:])]\n            return res\n        \n        ans = 0\n        \n        for sp in allsplit(s):\n            # print(sp)\n            if len(sp) == len(set(sp)):\n                ans = max(ans, len(sp))\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        max_length = 1\n\n        for code in range(2 ** (len(s) - 1)):\n            subs = set()\n\n            cur = s[0]\n\n            for i in range(1, len(s)):\n                if code % 2 == 1:\n                    if cur in subs:\n                        break\n                    subs.add(cur)\n                    cur = s[i]\n                else:\n                    cur += s[i]\n                code = code >> 1\n            if cur not in subs:\n                max_length = max(max_length, len(subs) + 1)\n        return max_length", "def count1(x):\n    xx = x\n    ans = 0\n    while x != 0:\n        x &= x - 1\n        ans += 1\n    return ans\n\ndef ok(mask, s):\n    strs = []\n    prev = 0\n    for i in range(len(s) - 1):\n        if (1 << i) & mask:\n            strs.append(s[prev: i+1])\n            prev = i + 1\n    strs.append(s[prev:])\n    # print(strs)\n    return len(set(strs)) == len(strs)\n\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n        ans = 0\n        for i in range(1, 1 << (n-1)):\n            if ok(i, s):\n                ans = max(count1(i), ans)\n        return ans + 1", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)-1\n        ans = 1\n        for i in range(1 << n):\n            subs = set()\n            start = 0\n            flag = False\n            for j in range(n):\n                if 1 << j & i:\n                    tmp = s[start:j+1]\n                    if tmp in subs:\n                        flag = True\n                        break\n                    subs.add(tmp)\n                    start = j+1\n            if flag:\n                continue\n            tmp = s[start:]\n            if tmp in subs:\n                continue\n            # print(subs, i)\n            ans = max(ans, len(subs)+1)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        ## splitting procedure must be recursive\n        # \\\"addbsd\\\" a(dd)(b)(s)(d) vs (a)(d)(db)(sd)\n        # in general we want unique chars to be alone...but (adbdsd), can't always be satisfied\n        # \n        N = len(s);\n        \n        possibilities = []\n\n        for k in range(1, N):\n\n            comb = itertools.combinations(list(range(1,N)), k)\n\n            possibilities+= [[s[0:x[0]]] + [s[x[i]:x[i+1]] for i in range(len(x)-1)] + [s[x[-1]:]] for x in comb]\n        ansr = 1;\n        for k in possibilities:\n            if(len(k) == len(set(k))):\n                ansr = max(ansr, len(k));\n        return ansr;\n    \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def split(s, b): #split into substrings given bit string b\n            res = []\n            x, y = s[0], b[0]\n            for i in range(1, len(s)):\n                if b[i]==y:\n                    x += s[i]\n                else:\n                    res.append(x)\n                    x, y = s[i], b[i]\n            \n            res.append(x)\n            #print(res)\n            return res\n        \n        max_len = 0\n        for i in range(2**(len(s)-1)):\n            b = bin(i)[2:]\n            b = '0'*(len(s)-len(b)) + b\n            res = split(s,b) #split based on bit string\n            if len(res)==len(set(res)): #check if the split forms valid substrings\n                max_len = max(max_len, len(res)) #compare against max length so far\n        return max_len", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        from collections import defaultdict\n        self.ans=1\n        def get(s,l,n):\n            # print(l,n,len(s))\n            if n==len(s):\n                dic=defaultdict(int)\n                for i in l:\n                    dic[i]+=1\n                z=True\n                for i in dic:\n                    if dic[i]>1:\n                        z=False\n                        break\n                if z:\n                    self.ans=max(self.ans,len(l))\n                return\n            i=n\n            cur=''\n            # print(\\\"here\\\")\n            for j in range(i,len(s)):\n                # print(j)\n                cur+=s[j]\n                # print(cur)\n                get(s,l+[cur],j+1)\n            \n        get(s,[],0)\n        return self.ans\n                \n                \n        \n        # dic=defaultdict(int)\n        # n=len(s)\n        # i=0\n        # ans=[]\n        # while i<n:\n        #     cur=''\n        #     j=i\n        #     z=True\n        #     while j<n:\n        #         cur+=s[j]\n        #         if dic[cur]==0:\n        #             ans.append(cur)\n        #             z=False\n        #             dic[cur]=1\n        #             j+=1\n        #             break\n        #         else:\n        #             j+=1\n        #     i=j\n        #     if z:\n        #         ans[-1]=ans[-1]+cur\n        # return len(ans)\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        to_ret = 0\n        for bin_i in range(2**(len(s)-1)) :\n            to_deal = []\n            last = s[0]\n            for i in range(len(s)-1) :\n                cn = s[i+1]\n                # print(bin_i, i, (bin_i | (1<<i)))\n                if (bin_i & (1<<i)) > 0 :\n                    to_deal.append(last)\n                    last = cn\n                else :\n                    last += cn\n            if not last == '' :\n                to_deal.append(last)\n            if len(to_deal) == len(set(to_deal)) :\n                to_ret = max(to_ret, len(to_deal))\n        return to_ret", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def split(i):\n            if i >= len(s):\n                return len([v for v in t.values() if v])\n            best = 0\n            for j in range(i, len(s)):\n                ss = s[i:j+1]\n                t[ss] += 1\n                best = max(best, split(j+1))\n                t[ss] -= 1\n            return best\n                \n        t = collections.defaultdict(int)\n        return split(0)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        visited = set()\n        #@lru_cache(None)\n        def solve(cur: str) -> int:\n            ans = 0\n            if not cur:\n                return 0\n            for i in range(1, len(s) + 1):\n                candidate = cur[:i]\n                if candidate not in visited:\n                    visited.add(candidate)\n                    ans = max(ans, 1 + solve(cur[i:]))\n                    visited.remove(candidate)\n            return ans\n        return solve(s)\n                    \n        \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        visited = set()\n        def solve(cur: str) -> int:\n            ans = 0\n            if not cur:\n                return 0\n            for i in range(1, len(s) + 1):\n                candidate = cur[:i]\n                if candidate not in visited:\n                    visited.add(candidate)\n                    ans = max(ans, 1 + solve(cur[i:]))\n                    visited.remove(candidate)\n            return ans\n        return solve(s)\n                    \n        \n", "#Bit Mask: use bit 1 as fence. chars between two bit 1's form a substring\n#Possible choices: 2 ** N (0 ~ 2 **N - 1)\n#Note: that last bit/fence does not matter so we can save computations by half\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        N, res = len(s), 0\n        \n        for i in range(2 ** (N - 1)):\n            start, seen = 0, set()\n            for j in range(N):\n                #test to see if j-th bit is 1\n                if (i + (1 << N - 1)) & (1 << j):\n                    seen.add(s[start : j + 1])\n                    start = j + 1\n            \n            res = max(res, len(seen))\n        \n        return res\n                \n        \n        \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        N = len(s) - 1\n        res = 1\n        for m in range(1 << N):\n            I = [i for i in range(N) if (m >> i) & 1] + [N]\n            K = len(I)\n            ss = {s[:I[0]+1]}\n            for k in range(K - 1):\n                ss.add(s[I[k]+1: I[k+1]+1])\n            # print(ss)\n            if len(ss) == K:\n                res = max(res, K)\n        return res\n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def all_partitions(string):\n            for cutpoints in range(1 << (len(string)-1)):\n                result = []\n                lastcut = 0\n                for i in range(len(string)-1):\n                    if (1<<i) & cutpoints != 0:\n                        result.append(string[lastcut:(i+1)])\n                        lastcut = i+1\n                result.append(string[lastcut:])\n                yield result\n        # d = {}\n        ps = all_partitions(s)\n        \n        # for p in ps:\n        #     print(p)\n        ret = 0\n        for p in ps:\n            l = list(dict.fromkeys(p))\n            if (len(p) == len(l)):\n                ret = max(ret, len(p))\n                # print(\\\"OK\\\")\n                # print(p)\n                # print(l)\n                # print()\n            #else:\n                # print(\\\"NG\\\")\n                # print(p)\n                # print(l)\n                # print()\n        return ret\n#         sps = []\n#         for p in ps:\n#             sps.append(sorted(p))\n#         for p in sps:\n#             print(p)\n#         for p in ps:\n#             d[p.sort()] = 0\n#         for p in ps:\n#             d[p.sort()] += 1\n        \n#         ret = 0\n#         for p in ps:\n#             if d[p.sort()] == 1:\n#                 ret += 1\n#         return ret\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def dfs(s, n):\n            if n < 0:\n                return [[s]]\n            else:\n                res = []\n                for i in range(1, len(s) - n):\n                    for group in dfs(s[i:], n - 1):\n                        res.append([s[:i]] + group)\n                return res\n            \n        res = 1\n        for i in range(len(s)):\n            for group in dfs(s, i):\n                res = max(res, len(set(group)))         \n        return res", "class Solution:\n    def maxUniqueSplit(self, S: str) -> int:\n        n = len(S)\n        ans = 0\n        for U in range(1 << (n - 1)):\n            word = []\n            now = S[0]\n            for j in range(n - 1):\n                if U >> j & 1:\n                    word.append(now)\n                    now = S[j + 1]\n                else:\n                    now += S[j + 1]\n            word.append(now)\n            \n            \n            if len(word) == len(set(word)):\n                ans = max(ans, len(word))\n        \n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        N = len(s)\n        \n        res = 0\n        for mask in itertools.product('10', repeat=N-1):\n            mask = list(mask) + ['1']\n            substr = set()\n            begin = 0\n            i = 0\n            valid = True\n            # print('mask', mask)\n            while True:\n                try:\n                    idx = mask.index('1', begin)\n                    # print('idx', idx, i, s[i:idx+1])\n                    begin = idx+1\n                    if s[i:idx+1] in substr:\n                        valid = False\n                        break\n                    substr.add(s[i:idx+1])\n                    i = idx+1\n                except ValueError:\n                    break\n            if valid:\n                res = max(res, mask.count('1'))\n            # print('substr', substr, valid)\n        return res", "def get_sequences(symbols, length):\n    if length == 0:\n        return [[]]\n    \n    sequences = []\n   \n    tail_sequences = get_sequences(symbols, length-1)\n    \n    for tail_sequence in tail_sequences:\n        for symbol in symbols:\n            sequences.append(list(tail_sequence)+[symbol])\n    \n    return sequences\n            \n\ndef is_unique(sequence, s):\n    if s=='':\n        return 0\n    \n    words = set()\n    letters = [s[0]]\n    for i in range(len(sequence)):\n        if sequence[i] == 1:\n            word = ''.join(letters)\n            if word in words:\n                return False\n            words.add(word)\n            letters = [s[i+1]]\n        else:\n            letters.append(s[i+1])\n    \n    word = ''.join(letters)\n    if word in words:\n        return False\n    \n    return True\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        sequences = get_sequences([0,1], len(s)-1)\n        \n        max_split = 1\n        for sequence in sequences:\n            if is_unique(sequence, s):\n                max_split = max(max_split, sum(sequence)+1)\n                \n        return max_split\n                \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        if len(s) == 1:\n            return 1\n        \n        if len(s) == 2:\n            if s[0] == s[1]:\n                return 1\n            return 2\n        \n        ans = 0\n        \n        for i in range(2 ** (len(s) - 1)):\n            ss = format(i, '0' + str(len(s) - 1) + 'b') + '1'\n            #print(ss)\n            st = set()\n            count = 0\n            prev = 0\n            \n            for j in range(len(ss)):\n                lth = len(st)\n                \n                if ss[j] == '1':\n                    st.add(s[prev:j + 1])\n                    \n                    if len(st) == lth:\n                        break\n                        \n                    prev = j + 1\n                    count += 1\n                    \n            #print(st)\n            ans = max(ans, count)\n            \n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        ls=len(s)\n        sl=ls-1\n        ps=1<<(sl)\n        ans=0\n        for i in range(ps):\n            bi=bin(i)[2:].zfill(sl) #0 is a stick\n            si=[0]+[j+1 for j in range(sl) if bi[j]=='0']+[sl+1]\n            lsi=len(si)\n            ds=set([s[si[j]:si[j+1]] for j in range(lsi-1)])\n            if len(ds)==lsi-1:\n                ans=max(ans,lsi-1)\n        return ans\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        options = []\n        options = self.recursiveSplit(s)\n        bestcount = 0\n        for option in options:\n            count = 0\n            encountered = {}\n            valid = True\n            for substr in option:\n                if substr not in encountered:\n                    encountered[substr] = 1\n                    count += 1\n                else:\n                    valid = False\n                    break\n            if valid and count > bestcount:\n                bestcount = count\n        return bestcount\n            \n            \n    def recursiveSplit(self, s:str) -> str:\n        if len(s) == 1:\n            return [[s]]\n        elif len(s) == 0:\n            return [[]]\n        options = []\n        for i in range(0, len(s)):\n            recursiveOptions = self.recursiveSplit(s[:i])\n            for option in recursiveOptions:\n                newoption = option.copy()\n                newoption.append(s[i:])\n                options.append(newoption)\n        return options\n\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        c=collections.Counter(s)\n        #print(c,c.keys(),len(c.keys()))\n        res=len(c.keys())\n        l=len(s)\n        ways=int(math.pow(2,l-1))\n        for i in range(ways):\n            bit=str(bin(i))[2:].zfill(l-1)\n            #print(bit)\n            cand=[s[0]]\n            for i,x in enumerate(bit):\n                if x=='0':\n                    cand[-1]+=s[i+1]\n                else:\n                    cand.append(s[i+1])\n            #cand[-1]+=s[-1]\n            #print(cand)\n            nodup=set(cand)\n            if len(nodup)==len(cand):\n                res=max(res,len(cand))\n        return res", "from collections import Counter\n\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n        ans = 0\n        \n        def check(C):\n            for char in list(C.keys()):\n                if C[char] > 1:\n                    return False\n            return True\n        \n        curr = []\n        def dfs(i):\n            nonlocal ans\n            if i == n:\n                C = Counter(curr)\n                if (check(C)):\n                    ans = max(ans, len(list(C.keys())))\n                return\n            for j in range(i, n):\n                curr.append(s[i:j+1])\n                dfs(j+1)\n                curr.pop()\n        dfs(0)\n        return ans\n        \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        seen = set()\n        \n        def helper(start):\n            nonlocal seen, s\n            length = len(s)\n            if start == length:\n                return 0\n            \n            max_split, cur_split = 0, 0\n            for split in range(start+1, length):\n                left, right = s[start:split], s[split:length] \n                if left in seen or right in seen or left == right:\n                    continue\n                seen.add(left)\n                cur_split = 1 + helper(split)\n                seen.remove(left)\n                max_split = max(max_split, cur_split)\n                \n            return max_split\n                \n        return 1 + helper(0)", "#Brute Force\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        N = len(s)\n        res = 0\n        \n        def findSplit(num):\n            bin_str = (bin(num)[2:] + '0').zfill(N)\n            words = []\n            word = []\n            \n            for c, binary in zip(s, bin_str):\n                word.append(c)\n                if binary == '1':\n                    words.append(''.join(word))\n                    word = []\n\n            if word: words.append(''.join(word))\n            #print(num, words)\n            return len(set(words))\n            \n        \n        ways = 2 ** (N - 1)\n        for i in range(ways):\n            res = max(res, findSplit(i))\n            \n        return res\n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        res = 1\n        upper = 2 ** (len(s) - 1) # so many possible breaks\n        \n        for i in range(upper):\n            words = []\n            prev = 0\n            for pos in range(len(s) - 1):\n                t = pos + 1\n                if 1 << pos & i:\n                    words.append(s[prev:t])\n                    prev = t\n            words.append(s[prev:])\n            if len(words) == len(set(words)):\n                #print(words)\n                res = max(res, len(words))\n        return res\n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        def search(s):\n            ans = [[s]]\n            \n            for i in range(1, len(s)):\n                ans += [[s[:i]] + comb for comb in search(s[i:])]\n                \n            return ans\n            \n        a = search(s)\n        r = 1\n        for comb in a:\n            # print(comb)\n            if len(set(comb)) == len(comb):\n                \n                r = max(r, len(comb))\n        \n        return r", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        r=0\n        m=len(s)\n        for i in range(2**(m-1)):\n            #b='{0:07b}'.format(i)\n            bb='{0:0'+str(m-1)+'b}'\n            b=bb.format(i)\n            #print(b)\n            st=0\n            l=[]\n            for k in range(len(b)):\n                if b[k]=='1':\n                    #print(st,k+1)\n                    if k+1>st:\n                        l.append(s[st:k+1])\n                    st=k+1\n            \n            if st<len(b)+1:\n                l.append(s[st:len(b)+1])\n            #print(l)\n            if len(l)==len(set(l)):\n                r=max(r,len(l))\n        print(r)\n        return r", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        best = -1\n        ans = []\n        for i in range(2**(len(s)-1)):\n            x = bin(i)\n            x = x[2:]\n            x = (len(s) - len(x) - 1) * '0' + x\n            tmp = ''\n            a = []\n            c = 0\n            for char in s:\n                tmp += char\n                if c<len(x):\n                    if x[c]=='1':\n                        a.append(tmp)\n                        tmp = '' \n                        \n                c+=1\n                        \n            a.append(tmp)\n            \n            if len(a)==len(set(a)):\n                if len(a)>best:\n                    best = len(a)\n                    ans = a\n                    \n        return len(ans)\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        res = 0\n        dfs = [[set(),s]]\n        while dfs:\n            #print(dfs)\n            curEl = dfs.pop()            \n            res = max(res, len(curEl[0]))\n            if len(curEl[0])+len(curEl[1]) <= res or len(curEl[1]) == 0:\n                   continue\n                      \n            for i in range(len(curEl[1])):\n                noDel = curEl[1][:i+1] in curEl[0]\n                curEl[0].add(curEl[1][:i+1])\n                dfs.append([curEl[0].copy(), curEl[1][i+1:]])\n                #print([curEl[0].copy(), curEl[1][i+1:]])\n                if not noDel:\n                    curEl[0].remove(curEl[1][:i+1])\n                   \n        return res\n        \n            \n            \n                \n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        # dfs O(2^n) / O(n)\n        def dfs(index, visited):\n            nonlocal ans\n            \n            # if we have not seen the rest, then our answer is at least 1 larger\n            if s[index:n] and s[index:n] not in visited:\n                ans = max(ans, len(visited) + 1)\n            \n            #try each section of the remaining\n            for i in range(index, n):\n                # only if it doesn't exist yet, and it is not impossible to beat current max\n                if s[index:i] and s[index:i] not in visited and len(visited) + 1 + n - i > ans: # prune\n                    visited.add(s[index:i])\n                    dfs(i, visited)\n                    visited.remove(s[index:i])\n\n        n, ans = len(s), 0\n        dfs(0, set())\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n=len(s)\n        if n==1:\n            return 1\n        res=1\n        seen=set()\n        for m in range(1,1<<(n-1)):  #\u5c1d\u8bd5\u6240\u6709\u5207\u5272\u4f4d\u7f6e\n            if bin(m).count('1')<res:\n                continue\n            valid=True\n            p=0\n            for i in range(1,n+1):\n                if valid:\n                    if m & (1 << (i - 1)) or i == n:\n                        if s[p:i] in seen:\n                            valid=False\n                        seen.add(s[p:i])\n                        p=i\n            if valid:\n                res=max(res,len(seen))\n            seen=set()\n        return res", "class Solution:\n    #1593\n    def maxUniqueSplit(self, s: str) -> int:\n        def helper(s1_set, s2):\n            N = len(s2)\n            if N == 1:\n                if s2 in s1_set:\n                    return 0\n                return len(s1_set)+1\n            res = 0 if s2 in s1_set else len(s1_set)+1\n            for i in range(1, N):\n                if s2[:i] in s1_set:\n                    continue\n                s1_set.add(s2[:i])\n                res = max(res, helper(s1_set,s2[i:]))\n                s1_set.discard(s2[:i])\n            return res\n        res = helper(set(), s)\n        return res", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        def helper(s, strings=set()):\n            \n            leng_s = len(s)\n            leng_set = len(strings)\n            if leng_s == 1 and s in strings:\n                return 0\n            else:\n                ans = leng_set + 1\n                for i in range(1, leng_s):\n                    substr = s[:i]\n                    if substr not in strings:\n                        ans = max(ans, helper(s[i:], strings|{substr}))\n                return ans               \n                    \n        return helper(s)\n        \n        #    if len(s) == 1 and s in soFar:\n        #         return 0\n        #     maxSplit = len(soFar)+1\n        #     for partition in range(1, len(s)):\n        #         a = s[:partition]\n        #         b = s[partition:]\n        #         if a not in soFar:\n        #             maxSplit = max(maxSplit, maxU(b, soFar|{a}))\n        #     return maxSplit\n        # return maxU(s)\n", "from functools import lru_cache\n\ndef _helper(s: str, visited) -> int:\n    # s: remaining string to be split\n    # count: number of unique pieces already\n    # visited: set of string that already be used\n    # Returns: the maximum number of unique\n    # string pieces we can get\n    \n    # Iterate the first split point.\n    n = len(s)\n    result = 0\n    for i in range(n - 1):\n        # Cut after i-th char.\n        cut, remain = s[:(i + 1)], s[(i + 1):]\n        if cut in visited:\n            continue\n        visited.add(cut)\n        result = max(result, 1 + _helper(remain, visited))\n        visited.remove(cut)\n    \n    # Another option is no cutting\n    if not s in visited:\n        result = max(result, 1)\n    return result\n    \n\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        # DFS/Backtracking,\n        # Consider caching to reduce the change of TLE\n        \n        if not s:\n            return 0\n        \n        visited = set()\n        return _helper(s, visited)\n        \n    \n    \n        \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def maxU(s, soFar=set()):\n            if len(s) == 1:\n                if s in soFar: return 0\n            maxSplit = len(soFar)+1\n            for partition in range(1, len(s)):\n                a = s[:partition]\n                b = s[partition:]\n                if a not in soFar:\n                    maxSplit = max(maxSplit, maxU(b, soFar|{a}))\n            return maxSplit\n        return maxU(s)\n", "class Solution:\n    def maxUniqueSplit(self, string: str) -> int:\n        \n        def split(s, splits):\n            maxs = 1 if s not in splits else 0\n            for i in range(1, len(s)):\n                if s[:i] in splits:\n                    continue\n                rst = 1 + split(s[i:], splits+[s[:i]])\n                maxs = max(rst, maxs)\n            return maxs\n        \n        return split(string, [])", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.N=len(s)\n        wordset=set(s)\n        if len(wordset)>=self.N-1:\n            return len(wordset)\n        self.cur=0\n        def dfs(i,visit,num):\n            if self.N-i+num<=self.cur:\n                return \n            if s[i:] not in visit:\n                self.cur=max(self.cur,num+1)\n            for j in range(i+1,self.N):\n                new=s[i:j]\n                if new not in visit:\n                    visit.add(new)\n                    dfs(j,visit,num+1)\n                    visit.remove(new)\n        visit=set()\n        dfs(0,visit,0)\n        return self.cur\n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def check(st, cm):\n            mx = 0 if st in cm else 1\n            for i in range(1,len(st)):\n                a = st[:i]\n                b = st[i:]\n                if a not in cm:\n                    ncm = set(cm)\n                    ncm.add(a)\n                    c = check(b, ncm) + 1\n                    if c > mx:\n                        mx = c\n            return mx\n\n        return check(s, set())", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def explore(seen, s):\n            for i in range(1, len(s)):\n                word, other = s[:i], s[i:]\n                if word in seen: continue\n                explore(seen + [word], other)\n            else:\n                if s in seen:\n                    self.res = max(len(seen), self.res)\n                else:\n                    self.res = max(len(seen) + 1, self.res)\n\n        self.res = 0\n        explore([], s)\n        return self.res", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        self.mx = 0\n        self.lim = len(s)\n        def r(i,l,c):\n            \n            if i==self.lim-1:\n                \n                if s[i] not in l:\n                    if c+1>self.mx:self.mx = c+1\n                else:\n                    if c>self.mx:self.mx = c\n            else:\n                for k in range(i+1,self.lim+1):\n                    if k==self.lim:\n                        if s[i:k] not in l:\n                            if c+1>self.mx:self.mx = c+1\n                    else:\n                        if s[i:k] not in l:\n\n                            r(k,l|{s[i:k]},c+1)\n                    \n                        \n        r(0,set(),0)\n        return self.mx\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        def dfs(i):\n            nonlocal used, ret\n            if i == n:\n                ret = max(ret, len(used))\n                return\n            for j in range(i + 1, n + 1):\n                w = s[i: j]\n                if w in used:\n                    continue\n                used.add(w)\n                dfs(j)\n                used.discard(w)\n        \n        n = len(s)\n        used = set()\n        ret = 0\n        dfs(0)\n        return ret", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        @lru_cache(None)\n        def helper(s):\n            if not s:\n                return [[]]\n            \n            splits = []\n            for i in range(1, len(s) + 1):\n                word = s[:i]\n                next_splits = helper(s[i:])\n                for split in next_splits:\n                    if word not in split:\n                        splits.append(split + [word])\n\n            return splits\n        ret = helper(s)\n        max_len = max([len(x) for x in ret])\n        return max_len", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.ans = 0\n        n = len(s)\n        def backtrack(start, have):\n            if start>=n:\n                self.ans=max(self.ans, len(have))\n                return\n            for i in range(start+1, n+1):\n                tmp = s[start:i]\n                if tmp in have: continue\n                else:\n                    have.add(tmp)\n                    backtrack(i, have)\n                    have.remove(tmp)\n        backtrack(0, set())\n        return self.ans\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        #if len(set(s)) == 1: return 1\n        return self.dfs(s, 0, 1, set())\n    \n    def dfs(self, s, start, end, dic):\n        if end>=len(s): return 0 if s[start:] in dic else 1\n        k1 = 0\n        if s[start:end] not in dic:\n            dic.add(s[start:end])\n            k1 = 1+self.dfs(s, end, end+1, dic)\n            dic.remove(s[start:end])\n        k2 = self.dfs(s, start, end+1, dic)\n        return max(k1, k2)\n        \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n\n        def dfs(start, seen):\n            ans = 0\n            if start == n:\n                return ans\n\n            for end in range(start + 1, n + 1):\n                word = s[start:end]\n\n                if word in seen:\n                    continue\n\n                seen.add(word)\n                ans = max(ans, 1 + dfs(end, seen))\n                seen.discard(word)\n\n            return ans \n            \n        return dfs(0, set())", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        seen = set()\n        return self.helper(s, seen)\n\n    def helper(self, s, seen):\n        ans = 0\n        if s:\n            for i in range(1, len(s) + 1):\n                candidate = s[:i]\n                if candidate not in seen:\n                    seen.add(candidate)\n                    ans = max(ans, 1 + self.helper(s[i:], seen))\n                    seen.remove(candidate)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def builder(s, seen):\n            if not s:\n                return 0\n\n            res = 0\n            for i, c in enumerate(s):\n                candidate = s[:i+1]\n                if candidate not in seen:\n                    seen.add(candidate)\n                    res = max(res, 1 + builder(s[i+1:], seen))\n                    seen.remove(candidate)\n                    \n            return res\n        \n        return builder(s, set())", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        seen = set()\n        return self.helper(s, seen)\n\n    def helper(self, s, seen):\n        ans = 0\n        if s:\n            for i in range(1, len(s) + 1):\n                candidate = s[:i]\n                if candidate not in seen:\n                    seen.add(candidate)\n                    ans = max(ans, 1 + self.helper(s[i:], seen))\n                    seen.remove(candidate)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n    \n        seen = set()\n        return self.helper(s, seen)\n\n    def helper(self, s, seen):\n        ans = 0\n        if s:\n            for i in range(1, len(s) + 1):\n                candidate = s[:i]\n                if candidate not in seen:\n                    seen.add(candidate)\n                    ans = max(ans, 1 + self.helper(s[i:], seen))\n                    seen.remove(candidate)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        seen = set()\n        return self.helper(s, seen)\n    \n    def helper(self, s, seen):\n        ans = 0\n        if s:\n            for i in range(1, len(s) + 1):\n                candidate = s[:i]\n                if candidate not in seen:\n                    seen.add(candidate)\n                    ans = max(ans, 1 + self.helper(s[i:], seen))\n                    seen.remove(candidate)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        N = len(s)\n        def splitLookup(ss, used): \n            Ns = len(ss)\n            if ss in used: \n                maxSs = 0\n            else: \n                maxSs = 1\n            i = 1;\n            while i < Ns and Ns-i > maxSs - 1: \n                sub = ss[:i]\n                if sub not in used: \n                    Nsplit = splitLookup(ss[i:], used | {sub})\n                    if Nsplit + 1 > maxSs: \n                        maxSs = Nsplit + 1\n                i += 1\n            return maxSs\n        \n        return splitLookup(s, set())\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def maxU(s, soFar=set()):\n            if len(s) == 1 and s in soFar:\n                return 0\n            maxSplit = len(soFar)+1\n            for partition in range(1, len(s)):\n                a = s[:partition]\n                b = s[partition:]\n                print(a, b)\n                if a not in soFar:\n                    maxSplit = max(maxSplit, maxU(b, soFar|{a}))\n            return maxSplit\n        return maxU(s)", "# import math\n\n# class Solution(object):\n#     def maxUniqueSplit(self, s):\n#         \\\"\\\"\\\"\n#         :type s: str\n#         :rtype: int\n#         \\\"\\\"\\\"\n#         account = 0\n#         solutions = set()\n#         account = self.findSolutions(s, solutions)\n#         print(\\\"finished\\\")\n#         print(solutions)\n#         print(account)\n        \n#         # if substring are the same than the solution is not right\n#         # if one solution has more substring than another adopt this one\n#         # could use divide and conqure to go done a string\n        \n#     def findSolutions(self, s, solutions):\n#         strLen = len(s)\n#         if strLen != 1:\n#             halfPoint = math.ceil(strLen / 2) # use floor so that the left side is always smaller string\n#             leftSubStr = s[:halfPoint]\n#             rightSubStr = s[halfPoint:]\n#             print(\\\"strlength is: {} mid point : {} left string: {} right string: {} \\\".format(strLen, halfPoint, leftSubStr, rightSubStr))\n#             # only keep spliting when the substring is unique in solutions\n#             if leftSubStr not in solutions:\n#                 # remove previous solution if it is in it\n#                 solutions.add(leftSubStr)\n#                 return self.findSolutions(leftSubStr, solutions) + 1\n#                 solutions.remove(leftSubStr)\n\n#             if rightSubStr not in solutions:\n#                 solutions.add(rightSubStr)\n#                 return account + self.findSolutions(rightSubStr, solutions) + 1\n#                 solutions.remove(rightSubStr)\n\n#         else:\n#             print(s)\n#             return 1\n        \nclass Solution:\n    book = set()\n    def maxUniqueSplit(self, s):\n        result = 0\n        for i in range(1, len(s)+1): #go through all the length of sub strings from left to right\n            curr = s[:i]\n            if curr not in self.book:\n                self.book.add(curr) # add a type of sub string if it is not in it\n                result = max(result, 1 + self.maxUniqueSplit(s[i:]))\n                self.book.remove(curr)\n        return result", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.ans=0\n        seen=set()\n        def search(i):\n            if i==len(s):\n                self.ans=max(len(seen),self.ans)\n                return\n            for j in range(i,len(s)):\n                word=s[i:j+1]\n                if word not in seen:\n                    seen.add(word)\n                    search(j+1)\n                    seen.discard(word)\n        search(0)\n        return self.ans\n            \n                \n", "def aux(s,lst,i):\n    if(i == len(s)):\n        return 0\n    mx = 0\n    for j in range(i,len(s)):\n        #print(lst)\n        if(s[i:j+1] not in lst):\n            tmp = 1 + aux(s,lst+[s[i:j+1]],j+1)\n            if tmp>mx:\n                mx = tmp\n    return mx\n\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        lst = []\n        return aux(s,lst,0)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.S = 0\n        def dfs(s, tmp):\n            if s == '': self.S = max(self.S, len(tmp))\n            for i in range(1, len(s) + 1):\n                if s[:i] not in tmp:\n                    dfs(s[i:], tmp + [s[:i]])\n        dfs(s, [])\n        return self.S", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        return self.helper(s, set())\n    \n    def helper(self, s, set):\n        if len(s) == 1 and s in set:\n            return 0\n        max_split = len(set) + 1\n        \n        for i in range(1, len(s)):\n            a = s[:i]\n            b = s[i:]\n            max_split = max(max_split, self.helper(b, set|{a}))\n        \n        return max_split", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        ans, n = 0, len(s)\n\n        def dfs(i, cnt, visited):\n            nonlocal ans, n\n            if i == n:\n                ans = max(ans, cnt)\n\n            for j in range(i + 1, n + 1):\n                if s[i:j] in visited:\n                    continue\n                visited.add(s[i:j])\n                dfs(j, cnt + 1, visited)\n                visited.remove(s[i:j])\n\n        dfs(0, 0, set())  # function call\n        return ans", "class Solution:\n    def __init__(self):\n        self.ans = 0\n        self.set = set()\n\n    def maxUniqueSplit(self, s: str) -> int:\n        self.solve(s, 0)\n        return self.ans\n    \n    def solve(self, s: str, pos: int) -> None:\n        if pos > len(s):\n            return\n        \n        self.ans = max(self.ans, len(self.set))\n        \n        if self.ans - len(self.set) >= len(s) - pos:\n            return\n        \n        for i in range(pos, len(s)):\n            v = s[pos:i+1]\n            if v in self.set:\n                continue\n            self.set.add(v)\n            # print(self.set)\n            self.solve(s, i + 1)\n            self.set.remove(v)\n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        ans, n = 0, len(s)\n        def dfs(i, cnt, visited):\n            nonlocal ans, n\n            if i == n: ans = max(ans, cnt)      # stop condition\n            for j in range(i+1, n+1):    \n                if s[i:j] in visited: continue  # avoid re-visit/duplicates\n                visited.add(s[i:j])             # update visited set\n                dfs(j, cnt+1, visited)          # backtracking\n                visited.remove(s[i:j])          # recover visited set for next possibility\n        dfs(0, 0, set())                        # function call\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        maximum=0\n        seen=set()\n        def dfs(idx,seen):\n            if idx==len(s):\n                nonlocal maximum\n                maximum=max(len(seen),maximum)\n                return\n            for i in range(idx,len(s)):\n                if s[idx:i+1] not in seen:\n                    seen.add(s[idx:i+1])\n                    dfs(i+1,seen)\n                    seen.remove(s[idx:i+1])\n            \n        dfs(0,seen)\n        return maximum\n    \n                \n            \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        ret = 0\n        \n        def backtrack(start, currSet):\n            if start == len(s):\n                nonlocal ret\n                ret = max(ret, len(currSet))\n                return\n        \n            for i in range(start, len(s)):\n                if s[start:i+1] not in currSet:\n                    currSet.add(s[start:i+1])\n                    backtrack(i+1, currSet)\n                    currSet.remove(s[start:i+1])\n        \n        backtrack(0, set())\n        return ret\n                \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def numway(s):\n            #if not s: return 0\n            nw=0\n            for i in range(1,len(s)+1):\n                if s[:i] not in nq: \n                    nq.add(s[:i])\n                    nw=max(nw,1+numway(s[i:]))\n                    nq.remove(s[:i])\n            return nw\n        nq=set()\n        return numway(s)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def helper(curr_set, s):\n            if len(s) == 0:\n                return len(s)\n            max_split = 0\n            for i in range(len(s)):\n                if s[:i+1] not in curr_set:\n                    # curr_set2 = set(curr_set)\n                    curr_set.add(s[:i+1])\n                    max_split = max(max_split, 1 + helper(curr_set, s[i+1:]))\n                    curr_set.remove(s[:i+1])\n            return max_split\n        return helper(set(), s)\n        \n        \n        \n#         curr_set = set()\n#         i,j = 0,1\n#         while j<=len(s):\n#             if s[i:j] not in curr_set:\n#                 curr_set.add(s[i:j])\n#                 print(s[i:j])\n#                 i, j = j, j+1\n#             else:\n#                 j += 1\n        \n#         return len(curr_set)\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        return get_max(s, set())\n        \ndef get_max(s, set):\n    maxi=0\n    for i in range(1,len(s)+1):\n        if s[:i] not in set:\n            set.add(s[:i])\n            # print(set)\n            maxi=max(maxi, 1+get_max(s[i:],set))\n            set.remove(s[:i])\n            \n    return maxi", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.res = 1\n\n        def func(string: str, visited: set):\n            if string in visited or len(string) == 0:\n                return 0\n            res = 1\n            for i in range(len(string)):\n                s = string[:i + 1]\n                if s in visited:\n                    continue\n                visited.add(s)\n                temp = func(string[i + 1:], visited) + 1\n                visited.remove(s)\n                res = max(res, temp)\n\n            return res\n\n        return func(s, set())", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        d = set()\n        res = 1\n        n = len(s)\n        \n        def solve(p, ans):\n            nonlocal res\n            if p == n:\n                res = max(res, ans)\n            for i in range(p, n):\n                ss = ''.join(s[p:i+1])\n                if ss in d: continue\n                d.add(ss)\n                solve(i + 1, ans + 1)\n                d.remove(ss)\n        \n        solve(0, 0)\n        return res\n                \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def backtracking(ind):\n            nonlocal ans\n            if ind==len(s):\n                ans = max(ans,len(split))\n            \n            for i in range(ind,len(s)):\n                if s[ind:i+1] not in split:\n                    split.add(s[ind:i+1])\n                    backtracking(i+1)\n                    split.remove(s[ind:i+1])\n        \n        ans = 0\n        split = set()\n        backtracking(0)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s) \n        def dp(i, cur):\n            nonlocal ans            \n            if len(cur) + n-i < ans: return\n            if i >= n: ans = max(ans, len(cur))                \n            l = n-i\n            for k in range(1, l+1):\n                cand = s[i:i+k]\n                if cand not in cur: \n                    cur.append(cand)\n                    dp(i+k, cur)\n                    cur.pop()            \n        ans, cur = 0, []\n        dp(0, cur)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.result = []\n        n = len(s)\n        \n        self.backtrack(s, 0, n, [])\n                \n        return len(max(self.result, key=len))\n    \n    \n    def backtrack(self, s, left, n, currArr):\n        \n        if left >= n:\n            self.result.append(currArr)\n        \n        for i in range(left, n):\n            if s[left:i+1] in currArr:\n                continue\n            \n            newArr = currArr.copy()\n            newArr.append(s[left:i+1])\n            \n            self.backtrack(s, i+1, n, newArr)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        '''\n        result=set()\n        i=0\n        j=1\n        \n        while(i<len(s)):\n            if s[i:j] not in result:\n                if s[j:len(s)] in result:\n                    result.add(s[i:])\n                    break\n                elif s[i:j]==s[j:len(s)]:\n                    result.add(s[i:])\n                    break\n                else:\n                    result.add(s[i:j])\n                    i=j\n                    j=i+1\n            else:\n                j+=1\n        return len(result)\n        '''\n        seen=set()\n        n=len(s)\n        def dfs(i):\n            if i==n:\n                return 0\n            res=1\n            for j in range(i+1,n+1):\n                if s[i:j] not in seen and s[j:] not in seen and s[i:j]!=s[j:]:\n                    seen.add(s[i:j])\n                    res=max(res,dfs(j)+1)\n                    seen.remove(s[i:j])\n            return res\n        return dfs(0)\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def helper(s, start, seen):\n            ans = 0\n            for end in range(start + 1, len(s) + 1):\n                added = s[start:end]\n                print(added)\n                if added not in seen:\n                    seen.add(added)\n                    ans = max(ans, 1 + helper(s, end, seen))\n                    seen.remove(added)\n\n            return ans\n        seen = set()\n        return helper(s, 0, seen)\n                    \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        return self.dfs(s, 0, [])\n    \n    def dfs(self, s, index, ele):\n        currMax = 0\n        \n        for i in range(index, len(s)):\n            if s[index:i+1] not in ele:\n                currMax = max(currMax, 1+self.dfs(s, i+1, ele[:] + [s[index:i+1]]))\n            \n        return currMax", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.cnt=0\n        def getstring(start,visited):\n            if start==len(s):\n                self.cnt=max(self.cnt,len(visited))\n                return\n            \n            for end in range(start+1,len(s)+1):\n                temp=s[start:end]\n                if temp in visited:\n                    continue\n                visited.add(temp)\n                getstring(end,visited)\n                visited.remove(temp)\n        getstring(0,set())\n        return self.cnt", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        if not s:\n            return 0\n        splits = [[] for _ in range(len(s))]\n        for i, c in enumerate(s):\n            splits[i].append(set([s[:i + 1]]))\n            for j in range(1, i + 1):\n                ss = s[j: i + 1]\n                for spl in splits[j - 1]:\n                    if ss not in spl:\n                        splits[i].append(spl | set([ss]))\n        return max([len(spl) for spl in splits[-1]])", "from copy import deepcopy\nclass Solution:\n    def __init__(self):    \n        self.strings = []\n    \n    def maxUniqueSplit(self, s):\n        \n        n = len(s)\n        result = []\n        lookUp = set()\n        \n        self.dfs(s, lookUp, result)\n        return len(self.strings)\n        \n    def dfs(self, s, lookUp, result):\n        \n        if len(s) == 0:\n            if len(result) > len(self.strings):\n                self.strings[:] = result\n            return\n        \n        for i in range(0, len(s)):\n            if s[0:i+1] not in lookUp:\n                lookUp.add(s[0:i+1])\n                result.append(s[0:i+1])\n                self.dfs(s[i+1:], lookUp, result)\n                lookUp.remove(s[0:i+1])\n                result.pop()", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        def backtracking(ind):\n            nonlocal ans\n            if ind==len(s):\n                ans = max(ans,len(split))\n            \n            for i in range(ind,len(s)):\n                if s[ind:i+1] not in split:\n                    split.append(s[ind:i+1])\n                    backtracking(i+1)\n                    split.remove(s[ind:i+1])\n        \n        ans = 0\n        split = []\n        backtracking(0)\n        return ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.ans = 0\n        seen = set()\n        \n        def dp(i):\n            if i == len(s):\n                self.ans = max(self.ans, len(seen))\n            \n            for j in range(i, len(s)):\n                word = s[i:j+1]\n                if word not in seen:\n                    seen.add(word)\n                    dp(j+1)\n                    seen.discard(word)\n                    \n        dp(0)\n        return self.ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:        \n        def dfs(i, vis):\n            nonlocal ans            \n            if len(vis) + n-i < ans: return\n            if i >= n: ans = max(ans, len(vis))                \n            l = n-i\n            for k in range(1, l+1):\n                x = s[i:i+k]\n                if x not in vis: \n                    vis.add(x)\n                    dfs(i+k, vis)\n                    vis.discard(x)\n        ans, n, vis = 0, len(s), set()\n        dfs(0, vis)\n        return ans", "class Solution:\n    def __init__(self):    \n        self.strings = []\n    \n    def maxUniqueSplit(self, s):\n        \n        n = len(s)\n        result = []\n        lookUp = set()\n        \n        self.dfs(s, lookUp, result)\n        return len(self.strings)\n        \n    def dfs(self, s, lookUp, result):\n        \n        if len(s) == 0:\n            if len(result) > len(self.strings):\n                self.strings[:] = result\n            return\n        \n        for i in range(0, len(s)):\n            if s[0:i+1] not in lookUp:\n                lookUp.add(s[0:i+1])\n                result.append(s[0:i+1])\n                self.dfs(s[i+1:], lookUp, result)\n                lookUp.remove(s[0:i+1])\n                result.pop()", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.ans = 0\n        def dfs(node,seen):\n            if node == len(s):\n                self.ans = max(self.ans,len(seen))\n            for i in range(node,len(s)):\n                if s[node:i+1] not in seen:\n                    dfs(i+1,seen|{s[node:i+1]})\n        dfs(0,set())\n        return self.ans", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        \n        \n        def backtrack(m, s):\n            if len(s) == 0:\n                return 0\n            ans = 0\n            for i in range(1, len(s) + 1):\n                candidate = s[:i]\n                if candidate not in m:\n                    m.add(candidate)\n                    ans = max(ans, 1 + backtrack(m, s[i:]))\n                    m.remove(candidate)\n                    \n            return ans\n    \n        m = set()\n        \n        return backtrack(m, s)", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.max = 0\n        self.backtrack(s,set(),0)\n        return self.max\n        \n    def backtrack(self,s,store,l):\n        if l >=len(s):\n            self.max = max(self.max,len(store))        \n        for i in range(l,len(s)+1):\n            if s[l:i] not in store and l!=i:\n                store.add(s[l:i])\n                self.backtrack(s,store,i)\n                store.remove(s[l:i])\n    \n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        return self.dp(s,0,0,[])\n        \n    def dp(self,s,start,pos,ans):\n        if pos == len(s):\n            return len(ans)\n        a = 0\n        b = self.dp(s,start,pos+1,list(ans))\n        if s[start:pos+1] not in ans:\n            ans.append(s[start:pos+1])\n            a = self.dp(s,pos+1,pos+1,list(ans))\n            # ans.pop()\n        # ans.remove(s[start:pos+1])\n        \n        return a if a > b else b\n        # return ans\n", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        n = len(s)\n        \n        self.res = 0\n        \n        def helper(curIdx, curW, curSets):\n            if (curIdx == n):\n                self.res = max(self.res, len(curSets))\n                return\n            \n            #don't split\n            helper(curIdx+1, curW+s[curIdx], curSets)\n            \n            #split\n            if (curW+s[curIdx] not in curSets):\n                helper(curIdx+1, '', curSets | {(curW+s[curIdx])})\n                \n        helper(0, '', set())\n        \n        return self.res", "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        return self.dp(s,0,0,[])\n        \n    def dp(self,s,start,pos,ans):\n        if pos == len(s):\n            return len(ans)\n        a = 0\n        b = self.dp(s,start,pos+1,list(ans))\n        if s[start:pos+1] not in ans:\n            ans.append(s[start:pos+1])\n            a = self.dp(s,pos+1,pos+1,list(ans))\n            ans.pop()\n        # ans.remove(s[start:pos+1])\n        \n        return a if a > b else b\n        # return ans\n"]
["class Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = dict()\n    for i, j in edges:\n      if i > j: i, j = j, i\n      tree.setdefault(i - 1, []).append(j - 1)\n\n    queue, time = [(0, 1)], 0  # node-prob\n    while queue and time <= t:  # bfs \n      tmp = []\n      for node, prob in queue:\n        if node == target - 1: return 0 if time < t and node in tree else prob\n        for n in tree.get(node, []): tmp.append((n, prob / len(tree[node])))\n      queue, time = tmp, time + 1\n    return 0 \n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        to_edges = defaultdict(list)\n        for [so, ta] in edges:\n            to_edges[so].append(ta)\n            to_edges[ta].append(so)\n        to_edges[1].append(1)\n\n        queue = deque([(1, 0, 1)])\n        visited = {1}\n        while queue:\n            node, time, frac = queue.popleft()\n            if node == target:\n                if time == t or (time<t and len(to_edges[node]) == 1):\n                    return 1/frac\n            if time > t:\n                return 0\n            for nei in to_edges[node]:\n                if nei not in visited:\n                    queue.append((nei, time+1, frac*(len(to_edges[node])-1)))\n                    visited.add(nei)\n\n        return 0", "from collections import deque\n\nclass Solution:\n  def frogPosition(self, n: int, edges_inp: List[List[int]], t: int, target: int) -> float:\n    edges = [ [] for _ in range(n+1) ]\n    for v0, v1 in edges_inp:\n      edges[v0].append( v1 )\n      edges[v1].append( v0 )\n    # determine at what step and what probability \n    visited = [0 for _ in range(n+1)]\n    q = deque()   # format (vertice, step, probability)\n    visited[1] = 1\n    q.append( (1,0,1.0) )\n    print(edges)\n    while q:\n      node, step, prob = q.popleft()\n      print(node, step, prob)\n      if step>t:\n        return 0\n      sub = 0 if node==1 else 1\n      if node == target:\n        if step == t or len(edges[node]) == sub:\n          return prob\n      if len(edges[node]) > sub:\n        prob_next = prob / (len(edges[node])-sub)\n        for node_next in edges[node]:\n          if visited[node_next]:\n            continue\n          print(\\\">\\\", node, node_next, step+1, prob_next)\n          q.append( (node_next, step+1, prob_next) )\n          visited[node_next] = 1\n    return 0\n  ", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        tree = dict()\n        for i,j in edges:\n            if i>j:\n                i,j = j,i\n            tree.setdefault(i-1,[]).append(j-1)\n        q,time = [(0,1)],0\n        while q and time <= t:\n            tmp = []\n            for node,prob in q:\n                if node == target-1:\n                    return 0 if time <t and node in tree else prob\n                for n in tree.get(node,[]):\n                    tmp.append((n,prob/len(tree[node])))\n            q,time = tmp,time+1\n        return 0\n    \n    \n\n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        ans= None\n        graph= defaultdict(set)\n        for x,y in edges:\n            graph[x].add(y)\n            graph[y].add(x)\n\n\n        vis=set([1])\n\n        def  dfs(root,prev_prob,t):\n            nonlocal ans\n            if  t < 0 : return \n            can = graph[root] - vis\n\n            if root== target:\n                ans = prev_prob if not can or t== 0 else 0\n                return \n            for x in can:\n                if x not in vis:\n                    vis.add(x)\n                    dfs(x,prev_prob * 1.0 / len(can),t-1)\n                if ans is not None : return\n        dfs(1,1,t)\n        return 0 if ans is None else ans", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        graph = collections.defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n            \n        seen = set([1])\n        \n        queue = collections.deque([(1, 1)])\n        \n        while t > 0:\n            size = len(queue)\n            for _ in range(size):\n                f, prob = queue.popleft()\n                length = 0\n                for nb in graph[f]:\n                    if nb not in seen:\n                        length += 1\n                        \n                if length == 0:\n                    queue.append((f, prob))\n                else:\n                    for nb in graph[f]:\n                        if nb not in seen:\n                            seen.add(nb)\n                            queue.append((nb, prob / length))\n                            \n            t -= 1\n            \n        res = 0\n        for node, prob in queue:\n            if node == target:\n                res += prob\n                \n        return res\n\n                        \n                \n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if n == 1:\n            return 1.0\n\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        q = collections.deque()\n        q.append((1, 1.0))\n        visited = set()\n        \n        self.target = target\n        return self.dfs(graph, 1, t, visited)\n    \n    def dfs(self, graph, i, t, visited):\n        if t == 0 or (i != 1 and len(graph[i]) == 1):\n            if i == self.target:\n                return 1\n            return 0\n\n        result = 0\n        visited.add(i)\n        for j in graph[i]:\n            if j not in visited:\n                result += self.dfs(graph, j, t - 1, visited)\n        \n        if i == 1:\n            return result / len(graph[i])\n        else:\n            return result / (len(graph[i]) - 1)", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        graph = {i:set() for i in range(1, n+1)}\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        \n        queue = collections.deque([(1, 1)])\n        \n        seen = set([1])\n        \n        level = 0\n        \n        while level < t:\n            size = len(queue)\n            for _ in range(size):\n                f, prob = queue.popleft()\n                nextCnt = 0\n                for nb in graph[f]:\n                    if nb not in seen:\n                        nextCnt += 1\n                if nextCnt == 0:\n                    queue.append((f, prob))\n                    \n                else:\n                    for nb in graph[f]:\n                        if nb not in seen:\n                            queue.append((nb, prob / nextCnt))\n                            seen.add(nb)\n            level += 1\n                            \n        ans = 0\n        for node, prob in queue:\n            if node == target:\n                ans += prob\n                \n        return ans\n", "import queue \nfrom collections import defaultdict\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        q = queue.Queue()\n        graph = defaultdict(list)\n        degree = [0] * (n+1)\n        for f, end in edges:\n            graph[f].append(end)\n            graph[end].append(f)\n            degree[end] += 1\n        start = 1\n        # for ind, val in enumerate(degree):\n        #     if val == 0:\n        #         start = ind \n        visited = set()\n        \n        q.put([start, 1, 1]) # node, level (t is # of level), prob\n        visited.add(start)\n        res = 0 \n        qt = 0\n        \n        p = [0] * (n+1)\n        p[1] = 1.0\n        while t and not q.empty():\n            qsize = q.qsize()\n            for _ in range(qsize):\n                node, level, prob = q.get()\n                size = 0\n                for nei in graph[node]:\n                    if nei not in visited:\n                        size += 1\n                for nei in graph[node]:\n                    if nei not in visited:\n                        visited.add(nei)\n                        q.put([nei, level+1, prob*(1/size)])\n                        p[nei] = p[node]/size\n                if size > 0:\n                    p[node] = 0 \n            t -= 1\n        return p[target]", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        q = collections.deque()\n        q.append((1, 1.0))\n        visited = set()\n        visited.add(1)\n        \n        step = 0\n        while q and step <= t:\n            size = len(q)\n            for _ in range(size):\n                i, prob = q.popleft()\n                if step == t and i == target:\n                    return prob\n\n                count = 0\n                if i == 1:\n                    count = len(graph[i])\n                else:\n                    count = len(graph[i]) - 1\n                \n                if count == 0:\n                    q.append((i, prob))\n                    continue\n                \n                for neighbor in graph[i]:\n                    if neighbor not in visited:\n                        q.append((neighbor, prob / count))\n                        visited.add(neighbor)\n                \n            step += 1\n        \n        return 0.0", "from collections import defaultdict\nimport queue\n\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        d = defaultdict(set)\n        visited = set()\n        for edge in edges:\n            d[edge[0]].add(edge[1])\n            d[edge[1]].add(edge[0])\n        q = queue.Queue()\n        q.put((1, 0, 1.0))\n        visited.add(1)\n        goal = {}\n        \n        while not q.empty():\n            cur, time, p = q.get()\n            if time > t:\n                if target in goal:\n                    return goal[target]\n                return 0.0\n            if cur == target and time == t:\n                return p\n            c = 0\n            for adj in d[cur]:\n                if adj not in visited:\n                    c += 1\n            if c == 0:\n                goal[cur] = p\n                continue\n            for adj in d[cur]:\n                if adj not in visited:\n                    q.put((adj, time + 1, p / c))\n                    visited.add(adj)\n        \n        if target in goal:\n            return goal[target]\n        return 0.0\n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        \n        \n        table={}\n        for i in range(1,n+1):\n            table[i]=[]\n        for i in range(len(edges)):\n            table[edges[i][0]].append(edges[i][1])\n            table[edges[i][1]].append(edges[i][0])\n        \n        \n        #print(table)\n        \n        self.res=0\n        def DFS(current_node,p,visited,time):\n            #print(current_node,p,visited,time)\n            if time == t:\n                if current_node == target:\n                    self.res += p\n            elif time <t:\n                temp=0\n                for node in table[current_node]:\n                    if node not in visited:\n                        temp +=1\n                if temp >0:\n                    for node in table[current_node]:\n                        if node not in visited:\n                            temp_visited = visited[:]\n                            temp_visited.append(node)\n                            DFS(node,p*1/temp,temp_visited,time+1)\n                elif temp ==0:\n                    DFS(current_node,p,visited,time+1)\n        \n        DFS(1,1,[1],0)\n        \n        return self.res\n                \n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if not edges:\n            return target == 1\n        G = defaultdict(list)\n        for s, e in edges:\n            G[s].append(e)\n            G[e].append(s)\n        def dfs(idx, fr, p, step):\n            if step > t:\n                return 0\n            if idx == target:\n                if step == t or (idx != 1 and len(G[idx]) == 1 or idx == 1 and not G[idx]):\n                    return p\n                else:\n                    return 0\n            if idx != 1 and len(G[idx]) == 1:\n                return 0\n            for nb in G[idx]:\n                if nb == fr:\n                    continue\n                ret = dfs(nb, idx, p / ((len(G[idx]) - 1) if idx != 1 else len(G[idx])), step + 1)\n                if ret:\n                    return ret\n            return 0\n        return dfs(1, 0, 1, 0)\n", "def oneJump( edges, visited, target, cur, t):\n    \n    if t == 0:\n        return 0\n    \n    if t == 1 and cur == target:\n        return 1\n    \n    nxt = []\n    visited[cur] = 1\n    \n    for i in edges:\n        \n        if i[0] == cur and visited[i[1]] == 0:\n            nxt.append(i[1])\n        \n        elif i[1] == cur and visited[i[0]] == 0:\n            nxt.append(i[0])\n    \n    if len(nxt) == 0: \n        if cur == target:\n            return 1\n        else:\n            return 0\n    \n    for i in nxt:\n        \n        n = oneJump( edges, visited, target, i, t-1)\n        if n != 0:\n            return (1/len(nxt)) * n\n    \n    return 0         \n    \nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        points = [ i for i in range(1,n+1)]\n        vis = [0 for i in range(n)]\n        \n        visited = dict(zip(points, vis))\n        return oneJump( edges, visited, target, 1, t+1)", "from collections import defaultdict, deque\n\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        dp = collections.deque([(1, 1, 0)]) # state: leaf_id, possibility, timestamp\n        visited = set()\n        \n        while dp:\n            leaf, p, curr = dp.popleft()\n            visited.add(leaf)\n            \n            if curr >= t:\n                if leaf == target: return p\n                continue\n            \n            neighbors = nei[leaf] - visited\n            for n in neighbors or [leaf]:\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\n        return 0.\n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n#         if n == 1: return 1.0\n#         G = [[] for i in range(n + 1)]\n#         for i, j in edges:\n#             G[i].append(j)\n#             G[j].append(i)\n#         seen = [0] * (n + 1)\n\n#         def dfs(i, t):\n#             if i != 1 and len(G[i]) == 1 or t == 0:\n#                 return i == target\n#             seen[i] = 1\n#             res = sum(dfs(j, t - 1) for j in G[i] if not seen[j])\n#             return res * 1.0 / (len(G[i]) - (i != 1))\n#         return dfs(1, t)\n\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        visited, res = set(), 0.\n        def dfs(leaf_id, p, time):\n            nonlocal res\n            if time >= t:\n                if leaf_id == target: \n                    res = p\n                return\n            visited.add(leaf_id)\n            neighbors = nei[leaf_id] - visited\n            for n in neighbors or [leaf_id]:\n                dfs(n, p / (len(neighbors) or 1), time + 1)\n        dfs(1, 1, 0)\n        return res          \n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n#         if n == 1: return 1.0\n#         G = [[] for i in range(n + 1)]\n#         for i, j in edges:\n#             G[i].append(j)\n#             G[j].append(i)\n#         seen = [0] * (n + 1)\n\n#         def dfs(i, t):\n#             if i != 1 and len(G[i]) == 1 or t == 0:\n#                 return i == target\n#             seen[i] = 1\n#             res = sum(dfs(j, t - 1) for j in G[i] if not seen[j])\n#             return res * 1.0 / (len(G[i]) - (i != 1))\n#         return dfs(1, t)\n\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        visited, res = set(), 0.\n        def dfs(leaf_id, p, time):\n            nonlocal res\n            if time >= t:\n                if leaf_id == target: res = p\n                return\n            visited.add(leaf_id)\n            neighbors = nei[leaf_id] - visited\n            for n in neighbors or [leaf_id]:\n                dfs(n, p / (len(neighbors) or 1), time + 1)\n        dfs(1, 1, 0)\n        return res          \n", "from collections import defaultdict\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        self.prob = 0\n        mp = defaultdict(set)\n        for edge in edges:\n            mp[edge[0]].add(edge[1])\n            mp[edge[1]].add(edge[0])\n        visited = set()\n        visited.add(1)\n        \n        def backtrack(pos: int, nowprob: float, currtime: int, visited: Set[int]):\n            if currtime == t:\n                if pos == target:\n                    self.prob += nowprob\n                return\n            total_visited = 0\n            for edge in mp[pos]:\n                if edge in visited:\n                    total_visited += 1\n            div = len(mp[pos]) - total_visited\n            if div == 0:\n                if pos == target:\n                    self.prob += nowprob\n                return\n            for edge in mp[pos]:\n                if edge not in visited:\n                    visited.add(edge)\n                    backtrack(edge, nowprob/div, currtime+1, visited)\n                    visited.remove(edge)\n        \n            \n        backtrack(1, 1, 0, visited)\n        return self.prob\n                \n            \n", "class Solution:\n    def frogPosition(self, n: int, edges, t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for i, j in edges:\n            nei[i].add(j)\n            nei[j].add(i)\n            \n        dp = collections.deque([(1, 1, 0)]) # state: leaf_id, possibility, timestamp\n        visited = set()\n        \n        while dp:\n            leaf, p, curr = dp.popleft()\n            visited.add(leaf)\n            \n            if curr >= t:\n                if leaf == target: return p\n                continue\n            \n            neighbors = nei[leaf] - visited\n            for n in neighbors or [leaf]:\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\n        return 0.\n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        graph = collections.defaultdict(list)\n        \n        for a, b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n            \n        \n        q = [(1, 1, 0)]\n        seen = set()\n        \n        while q:\n            curr, p, time = q.pop(0)\n            if time >= t:\n                if curr == target:\n                    return p\n                continue \n                \n            seen.add(curr)\n            s = 0\n            for nei in graph[curr]:\n                if nei not in seen:\n                    s += 1\n            if s:\n                for nei in graph[curr] :\n                    if nei not in seen:\n                        q.append((nei, p / s, time + 1))\n            else:\n                q.append((curr, p, time + 1))\n                \n        return 0. \n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        neigh = {}\n        for e in edges:\n            neigh[e[0]] = neigh.get(e[0],[])+[e[1]]\n            neigh[e[1]] = neigh.get(e[1],[])+[e[0]]\n        front = [1]\n        steps = 0\n        p = { i:0 for i in range(1,n+1)}\n        p[1] = 1\n        visited = set([1])\n        for steps in range(t):\n            q = {}\n            for i in p:\n                if p[i]!=0:\n                    if i==1 and  len(neigh.get(i,[]))==0:\n                        q[i] = p[i]\n                    elif  len(neigh.get(i,[]))<=1 and i!=1:\n                        q[i] = p[i]\n                    else:\n                        if i == 1:\n                            nn = len(neigh.get(i,[]))\n                        else:\n                            nn =len(neigh.get(i,[]))-1\n#                        print(i,nn)\n                        for j in neigh.get(i,[]):\n                            if not j in visited:\n                                q[j] = p[i]/nn\n                                visited.add(j)\n            p = {i:q.get(i,0) for i in range(1,n+1)}\n#            print(steps,p)\n#        print(neigh)\n        return(p.get(target,0))           \n            \n", "from collections import defaultdict, deque\n\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        graph = defaultdict(set)\n        for src, dest in edges:\n            graph[src].add(dest)\n            graph[dest].add(src)\n        \n        q = deque([[1, 1.0, 0]])\n        visited = set()\n        while q:\n            node, prob, time_step = q.popleft()\n            visited.add(node)\n            \n            if time_step >= t:\n                if node == target:\n                    return prob\n                continue\n            \n            neighbors = graph[node] - visited\n            nxt_prob = prob / max(len(neighbors), 1)\n            for child in neighbors or [node]:\n                q.append((child, nxt_prob, time_step+1))\n        \n        return 0.0\n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        tree = dict()\n        for i, j in edges: \n            if i > j: i, j = j, i\n            tree.setdefault(i-1, []).append(j-1)\n        \n        queue, time = [(0, 1)], 0 #node-prob\n        while queue and time <= t: #bfs \n            tmp = []\n            for node, prob in queue: \n                if node == target-1: return 0 if time < t and node in tree else prob\n                for n in tree.get(node, []): tmp.append((n, prob/len(tree[node])))\n            queue, time = tmp, time+1\n        return 0 \n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        graph = {}\n        for x, y in edges:\n            graph[x] = graph.get(x, set())\n            graph[x].add(y)\n            graph[y] = graph.get(y, set())\n            graph[y].add(x)\n            \n        queue = [(1, 0, 1)]\n        visited = set([1])\n        while queue:\n            \n            if queue[0][1] == t:\n                break\n            node, time, p = queue.pop(0)\n            \n            neis = [x for x in graph.get(node, []) if x not in visited]\n            size =len(neis)\n            if neis:\n                for nei in neis:\n                    queue.append([nei, time + 1, p*1/size])\n                    visited.add(nei)\n            else:\n                 queue.append((node,time + 1, p*1))\n        while queue:\n            node,t, prob = queue.pop(0)\n            if node == target:\n                return prob\n        return 0", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        visited=[False for i in range(n+1)]\n        visited[0]=True\n        visited[n]=True\n        prb=[0 for i in range(n)]\n        prb[0]=1\n        edgelists=[[] for i in range(n)]\n        for i in edges:\n            x=i[0]-1\n            y=i[1]-1\n            edgelists[x].append(y)\n            edgelists[y].append(x)\n        edgelists[0].append(n)\n        curr=[0]\n        for _ in range(t):\n            nex=[]\n            print(curr)\n            for i in curr:\n                occ=False\n                for j in edgelists[i]:\n                    if(visited[j]==False):\n                        occ=True\n                        nex.append(j)\n                        prb[j]=prb[i]/(len(edgelists[i])-1)\n                        visited[j]=True\n                if(occ):\n                    prb[i]=0\n            curr=nex\n        print(prb)\n        return prb[target-1]\n                \n            \n            \n            \n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if n == 1: \n            return 1.0\n        \n        G = collections.defaultdict(list)\n        for i, j in edges:\n            G[i].append(j)\n            G[j].append(i)\n            \n        seen = set()\n        \n        # it's a tree, so the frog can not go back to parent\n        def probability(idx, t):\n            if t == 0:\n                return idx == target\n            if idx != 1 and len(G[idx]) == 1: # if the frog is stuck at this vertex\n                return idx == target\n            seen.add(idx)\n            res, count = 0, 0\n            for j in G[idx]:\n                if not j in seen:\n                    res += probability(j, t - 1) \n                    count += 1\n            return res / count\n        \n        return probability(1, t)", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if n == 1: \n            return 1.0\n        \n        G = collections.defaultdict(list)\n        for i, j in edges:\n            G[i].append(j)\n            G[j].append(i)\n            \n        seen = set()\n        \n        # it's a tree, so the frog can not go back to parent\n        def probability(idx, t):\n            if t == 0:\n                return idx == target\n            if idx != 1 and len(G[idx]) == 1: # if the frog is stuck at this vertex\n                return idx == target\n            seen.add(idx)\n            res = sum(\n                probability(j, t - 1) \n                for j in G[idx] \n                if not j in seen\n            )\n            return res * 1.0 / (len(G[idx]) - (idx != 1))\n        \n        return probability(1, t)", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        neighbors = defaultdict(list)\n        for u, v in edges:\n            neighbors[u].append(v)\n            neighbors[v].append(u)\n        \n        def dfs(u, tt, r):\n            if tt > t or u in visited:\n                return 0\n            if u == target:\n                if len(neighbors[u]) > (0 if r else 1) and tt < t:\n                    return 0\n                else:\n                    return 1\n            visited.add(u)\n            m = 0\n            for v in neighbors[u]:\n                m = max(m, dfs(v, tt+1, False))\n            visited.remove(u)\n            if r and neighbors[u]:\n                return m / len(neighbors[u])\n            elif not r and len(neighbors[u]) > 1:\n                return m / (len(neighbors[u]) - 1)\n            else:\n                return 0\n        \n        visited = set()\n        return dfs(1, 0, True)\n            \n", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        graph = collections.defaultdict(set)\n        for s, e in edges:\n            graph[s].add(e)\n            graph[e].add(s)\n        \n        def dfs(prev_node: int, seconds_left: int, visited: Set[int]):\n            if seconds_left == 0 or prev_node not in graph:\n                return int(prev_node == target)\n            \n            probability = 0\n            n_next_node = 0\n            for next_node in graph[prev_node]:\n                if next_node not in visited:\n                    probability += dfs(next_node, seconds_left-1, set(list(visited) + [prev_node]))\n                    n_next_node += 1\n            if n_next_node == 0:\n                return int(prev_node == target)\n            if probability > 0:\n                probability /= n_next_node\n            return probability\n            \n        \n        return dfs(prev_node=1, seconds_left=t, visited=())", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if n == 1: return 1.0\n        graph = [[] for i in range(n + 1)]\n        for i, j in edges:\n            graph[i] += j,\n            graph[j] += i,\n        visited = [0] * (n + 1)\n\n        def dfs(i, t):\n            if i != 1 and len(graph[i]) == 1 or t == 0: return i == target\n            visited[i] = 1\n            res = sum(dfs(j, t - 1) for j in graph[i] if not visited[j])\n            return res * 1.0 / (len(graph[i]) - (i != 1))\n        return dfs(1, t)", "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        \n \n        tree = {}\n\n        def add_edge(parent, child):\n            children = tree.get(parent, [])\n            children.append(child)\n            tree[parent] = children\n        for [a, b] in edges:\n            add_edge(a,b)\n            add_edge(b,a)\n\n        if n == 1:\n            return 1.0\n\n        result = 1.0 if target == 1 else 0.0\n        # is list of `(node, probability)` pairs\n        state = [(1, 1.0)]\n        visited = set([1])\n        for i in range(t):\n            new_state = []\n            for node, probability in state:\n                children = [child for child in tree[node] if child not in visited]\n                if len(children) == 0:\n                    if node == target:\n                        return probability\n                    # new_state.append( (node, probability) )\n                    continue\n                if node == target:\n                    return 0\n                visited.add(node)\n                for child in tree[node]:\n                    new_probability = probability * 1/len(children)\n                    if child == target:\n                        result = new_probability\n                    new_state.append( (child, new_probability) )\n            state = new_state\n\n        return result\n"]
["s = input()\n\nif s[0] == '0' or s[-2] == '0' or s[-1] == '1':  # 's' should be like \"1xx...x0\"\n    print((-1))\nelif s[:-1] != s[-2::-1]:\n    print((-1))\nelse:\n    half = len(s) // 2\n    one_indices = [i+1 for i in range(1, half) if s[i] == '1'] # not including 0 or larger than n//2\n\n    parents = [0] * (len(s) + 1)\n    parent_index = 1\n    for index in one_indices:\n        for i in range(parent_index, index):\n            parents[i] = index\n        parent_index = index\n\n    root = parent_index + 1\n    parents[parent_index] = root\n    for index in range(root + 1, len(s) + 1):\n        parents[index] = root\n\n    for node, parent in enumerate(parents):\n        if parent == 0: # This means node is 0 or the root of the tree.\n            continue\n        print((node, parent))\n", "S = input()\nN = len(S)\nS = '0' + S\nif S[:2] == '01' and S == S[::-1]:\n    before = 1\n    for i in range(2, N + 1):\n        print((before, i))\n        if S[i - 1] == '1' and i < (N + 1) // 2 + 2:\n            before = i\nelse:\n    print((-1))\n", "def solve():\n    S = [0] + [int(c) for c in input()]\n    N = len(S)-1\n\n    if S[1]==0: return -1\n    for n in range(N//2+1):\n        if S[n]!=S[N-n]: return -1\n        if S[n]==1: k=n\n\n    E = []\n    Q = []\n    for n in range(1, k+1):\n        if S[n]==1:\n            for q in Q: E.append((q, n))\n            Q = []\n        Q.append(n)\n\n    E.append((k, k+1))\n    for n in range(k+2, N+1):\n        E.append((k+1, n))\n\n    return '\\n'.join([\" \".join(map(str, e)) for e in E])\n            \n\nprint((solve()))\n", "s=input()\nn=len(s)\nf=1\nif s[-1]==\"1\":\n  f=0\nif s[0]==\"0\":\n  f=0\nfor i in range(n-1):\n  if s[i]!=s[-2-i]:\n    f=0\n    break\n    \ns=s[:-1]+\"1\"\nif f:\n  k=0\n  for i in range(n):\n    if s[i]==\"1\":\n      for j in range(k,i):\n        print(j+1,i+1)\n      k=i\nelse:\n  print(-1)", "import sys\ninput = sys.stdin.readline\n\nS = '-' + input().rstrip()\nN = len(S) - 1\n\ndef solve(S):\n    if S[1] == '0':\n        print((-1))\n        return\n    if S[N] == '1':\n        print((-1))\n        return\n    prev = 1\n    graph = []\n    for n in range(1,N//2 + 1):\n        if S[n] != S[N-n]:\n            print((-1))\n            return\n        if S[n] == '0':\n            continue\n        for i in range(prev,n):\n            graph.append('{} {}'.format(i,n))\n        prev = n\n    for i in range(prev,N):\n        graph.append('{} {}'.format(i,N))\n    return graph\n\ngraph = solve(S)\n\nif graph is None:\n    print((-1))\nelse:\n    print(('\\n'.join(graph)))\n", "s = input()\nn = len(s)\nok = s[0] == '1' and s[n-1] == '0'\nfor i in range(n-1):\n    ok = ok and s[i] == s[n-2-i]\nif not ok:\n    print((-1))\n    return\ns2 = s[:n//2]\ni = s2.rindex('1')\nfor k in range(i, n-1):\n    print((n, k+1))\nwhile i > 0:\n    j = i - 1\n    while s[j] != '1':\n        j -= 1\n    for k in range(j, i):\n        print((i+1, k+1))\n    i = j\n", "s=input()\nif s[0]=='0':\n  print(-1)\nelif s[-1]=='1':\n  print(-1)\nelse:\n  l=len(s)\n  for i in range(l-1):\n    if s[i]!=s[l-i-2]:\n      print(-1)\n      return\n  ans=[]\n  base=1\n  for i in range(l-1):\n    if s[i]=='1':\n      print(base,i+2)\n      base=i+2\n    else:\n      print(base,i+2)", "import sys,collections as cl,bisect as bs\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #int\u306elist\n\treturn list(map(int,input().split()))\ndef m(): #\u8907\u6570\u6587\u5b57\n\treturn map(int,input().split())\ndef onem(): #N\u3068\u304b\u306e\u53d6\u5f97\n\treturn int(input())\ndef s(x): #\u5727\u7e2e\n\ta = []\n\tif len(x) == 0:\n\t\treturn []\n\taa = x[0]\n\tsu = 1\n\tfor i in range(len(x)-1):\n\t\tif aa != x[i+1]:\n\t\t\ta.append([aa,su])\n\t\t\taa = x[i+1]\n\t\t\tsu = 1\n\t\telse:\n\t\t\tsu += 1\n\ta.append([aa,su])\n\treturn a\ndef jo(x): #list\u3092\u30b9\u30da\u30fc\u30b9\u3054\u3068\u306b\u5206\u3051\u308b\n\treturn \" \".join(map(str,x))\ndef max2(x): #\u4ed6\u306e\u3068\u304d\u3082\u3069\u3046\u3088\u3046\u306b\u4f5c\u6210\u53ef\u80fd\n\treturn max(map(max,x))\ndef In(x,a): #a\u304c\u30ea\u30b9\u30c8(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\ndef pow_k(x, n):\n    ans = 1\n    while n:\n        if n % 2:\n            ans *= x\n        x *= x\n        n >>= 1\n    return ans\n\n\"\"\"\ndef nibu(x,n,r):\n\tll = 0\n\trr = r\n\twhile True:\n\t\tmid = (ll+rr)//2\n\n\tif rr == mid:\n\t\treturn ll\n\tif (\u3053\u3053\u306b\u8a55\u4fa1\u5165\u308c\u308b):\n\t\trr = mid\n\telse:\n\t\tll = mid+1\n\"\"\"\n\ns = input()[:-1]\n\nif s[0] == \"1\" and s[-1] == \"0\":\n\tk = (len(s)-2)//2\n\n\tfor i in range(k):\n\t\tif s[i] != s[-(2 + i)]:\n\t\t\tprint(-1)\n\t\t\treturn\n\telse:\n\t\t\n\t\tla = len(s)\n\n\t\tfor i in range(la-2,-1,-1):\n\t\t\tif s[i] == \"1\":\n\t\t\t\tprint(i+1,la)\n\t\t\t\tla = i+1\n\t\t\telse:\n\t\t\t\tprint(i+1,la)\nelse:\n\tprint(-1)", "s=input()\nif s[-1]=='1':\n  print(-1)\n  return\nif s[-2]=='0':\n  print(-1)\n  return\n\nt=s[:-1]\nD=[]\nfor i in range((len(t)+1)//2):\n  if t[i]!=t[-1-i]:\n    print(-1)\n    return\nm=1\nA=[]\nfor i in range(1,len(s)//2+1):\n    A.append((m,i+1))\n    if s[i-1]=='1':\n        m=i+1\nfor i in range(len(s)//2+2,len(s)+1):\n    A.append((m,i))\nfor i in A:\n    print(*i)", "def main():\n    s = \"0\" + input()\n    ans = []\n    f = True\n    for i in range(len(s)//2):\n        if s[i] != s[len(s)-1-i]:\n            f = False\n            break\n    if s[1] == \"0\" or s[-2] == \"0\":\n        f = False\n    if f:\n        ans = []\n        p = len(s)-1\n        for i in reversed(range(1, len(s)-1)):\n            c = s[i]\n            ans.append([i, p])\n            if c == \"1\":\n                p = i\n        for u, v in ans:\n            print(u, v)\n    else:\n        print(-1)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nS = list(sr())\nN = len(S)\nif S[-1] == '1' or S[0] == '0' or S[:-1] != S[:-1][::-1]:\n    print((-1)); return\nS = ['-'] + S\n\ndef solve(S):\n    prev = 1\n    graph = []\n    for i in range(1, N//2 + 1):\n        if S[i] == '0':\n            continue\n        for x in range(prev, i):\n            print((x, i))\n        prev = i\n    for x in range(prev, N):\n        print((x, N))\n\ngraph = solve(S)\n", "S=input()\nN=len(S)\n\nif S[0]==\"0\":\n    print(\"-1\")\n    return\nif S[-1]==\"1\":\n    print(\"-1\")\n    return\n\nfor s,rev_s in zip(S,reversed(S[:-1])):\n    if s!=rev_s:\n        print(\"-1\")\n        return\n\nprev=N\n\nfor i in reversed(list(range(1,N))):\n    print((i,prev))\n    if S[i-1]==\"1\":\n        prev=i\n\n\n", "s=list(input())\nn=len(s)\nif s[0] != \"1\" or s[-1]==\"1\" or s[:(n-1)//2] != s[n-2:n//2-1:-1]:\n  print(-1)\n  return\nchain = [1]\nans = []\ns[-1] = \"1\"\nfor i in range(1,n):\n  if s[i] == \"1\":\n    chain.append(i+1)\n    ans.append((chain[-2],chain[-1]))\nc = len(chain)\nfor i in range(1,c):\n  for j in range(chain[i-1]+1,chain[i]):\n    ans.append((j,chain[i]))\nfor edge in ans:\n  print(*edge)", "s = input()\nn = len(s)\nif s[0] == \"0\" or s[-1] == \"1\":\n    print((-1))\n    return\nfor i in range(n-1):\n    if s[i] != s[-2-i]:\n        print((-1))\n        return\n\nnow = 1\nfor i in range(n-1):\n    if s[i] == \"0\":\n        print((now,i+2))\n    else:\n        print((now,i+2))\n        now = i+2\n", "s = input()\nn = len(s)\nif s[0] == '0':\n    print(-1)\n    return\nif s[-1] == '1':\n    print(-1)\n    return\nfor i in range((n - 1) // 2):\n    if s[i] != s[n - i - 2]:\n        print(-1)\n        return\np = 1\nt = 2\ni = n - 2\nwhile i >= 0:\n    print(p, t)\n    if s[i] == '1':\n        p = t\n    t += 1\n    i -= 1", "def main():\n    s = input()\n    n = len(s)\n\n    if s[n - 1] == '1' or s[0] == '0' or s[n - 2] == '0':\n        print(-1)\n        return\n\n    for i in range(n - 1):\n        if s[i] != s[n - i - 2]:\n            print(-1)\n            return\n\n    conn = [[]]*(n + 1)\n    children = []\n    for i in range(1, n):\n        if s[i - 1] == '0':\n            children.append(i)\n        else:\n            conn[i] = children\n            children = [i]\n    conn[n] = [n - 1]\n\n    for i in range(1, n + 1):\n        for j in conn[i]:\n            print(j, i)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7) #\u518d\u5e30\u95a2\u6570\u306e\u4e0a\u9650,10**5\u4ee5\u4e0a\u306e\u5834\u5408python\nimport math\nfrom copy import copy, deepcopy\nfrom copy import deepcopy as dcp\nfrom operator import itemgetter\nfrom bisect import bisect_left, bisect, bisect_right#2\u5206\u63a2\u7d22\n#bisect_left(l,x), bisect(l,x)#a\u306f\u30bd\u30fc\u30c8\u6e08\u307f\u3067\u3042\u308b\u5fc5\u8981\u3042\u308a\u3002a\u306e\u4e2d\u304b\u3089x\u672a\u6e80\u306e\u8981\u7d20\u6570\u3092\u8fd4\u3059\u3002right\u3060\u3068\u4ee5\u4e0b\nfrom collections import deque\n#deque(l), pop(), append(x), popleft(), appendleft(x)\n#q.rotate(n)\u3067 \u2192 \u306bn\u56de\u30ed\u30fc\u30c6\u30fc\u30c8\nfrom collections import Counter#\u6587\u5b57\u5217\u3092\u500b\u6570\u30ab\u30a6\u30f3\u30c8\u8f9e\u66f8\u306b\u3001\n#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()\nfrom itertools import accumulate,combinations,permutations#\u7d2f\u7a4d\u548c\n#list(accumulate(l))\nfrom heapq import heapify,heappop,heappush\n#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)\u3068\u3057\u306a\u3044\u3053\u3068\u3001\u8fd4\u308a\u5024\u306fNone\n#import fractions#\u53e4\u3044atcoder\u30b3\u30f3\u30c6\u30b9\u30c8\u306e\u5834\u5408GCD\u306a\u3069\u306f\u3053\u3053\u304b\u3089import\u3059\u308b\nfrom functools import lru_cache#pypy\u3067\u3082\u3046\u3054\u304f\n#@lru_cache(maxsize = None)#maxsize\u306f\u4fdd\u5b58\u3059\u308b\u30c7\u30fc\u30bf\u6570\u306e\u6700\u5927\u5024\u30012**n\u304c\u6700\u3082\u9ad8\u52b9\u7387\nfrom decimal import Decimal\n\ndef input(): \n    x=sys.stdin.readline()\n    return x[:-1] if x[-1]==\"\\n\" else x\ndef printl(li): _=print(*li, sep=\"\\n\") if li else None\ndef argsort(s, return_sorted=False): \n    inds=sorted(range(len(s)), key=lambda k: s[k])\n    if return_sorted: return inds, [s[i] for i in inds]\n    return inds\ndef alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65\ndef num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)\ndef matmat(A,B):\n    K,N,M=len(B),len(A),len(B[0])\n    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]\ndef matvec(M,v):\n    N,size=len(v),len(M)\n    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]\ndef T(M):\n    n,m=len(M),len(M[0])\n    return [[M[j][i] for j in range(n)] for i in range(m)]\ndef main():\n    mod = 1000000007\n    #w.sort(key=itemgetter(1),reversed=True)  #\u4e8c\u500b\u76ee\u306e\u8981\u7d20\u3067\u964d\u9806\u4e26\u3073\u66ff\u3048\n\n    #N = int(input())\n    #N, K = map(int, input().split())\n    #A = tuple(map(int, input().split())) #1\u884c\u30d9\u30af\u30c8\u30eb\n    #L = tuple(int(input()) for i in range(N)) #\u6539\u884c\u30d9\u30af\u30c8\u30eb\n    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #\u6539\u884c\u884c\u5217\n\n    s=input()\n    N=len(s)\n    f=1\n    if s[-1]==\"1\" or s[0]==\"0\":\n        f=0\n    for i in range(1,N//2+1):\n        if s[i-1]!=s[N-i-1]:\n            f=0\n            break\n    if not f:\n        print(-1)\n        return\n    \n    il=[]\n    edge=[]\n    for i in range(1,N//2+1):\n        if s[i-1]==\"0\":\n            il.append(i)\n        else:\n            for j in il:\n                edge.append((i,j))\n            il=[i]\n    i=N//2+1\n    for j in il:\n        edge.append((i,j))\n    j=i\n    for i in range(N//2+2,N+1):\n        edge.append((j,i))\n\n    for e in edge:\n        print(*e)\n\n\n\n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "S = input()\neda = []\nflag = False\nN = len(S)\nif S[-1] == '1':\n  flag = True\nif S[0] == '0':\n  flag = True\nif S[-2] == '0':\n  flag = True\nfor k in range((N-1)//2):\n  if S[k] != S[-k-2]:\n    flag = True\n  if S[k] == '1':\n    eda.append(k+1)\nif N%2 == 0:\n  if S[N//2 -1] == '1':\n    eda.append(N//2)\nif flag:\n  print(-1)\n  return\nans = []\neda.reverse()\nbefore = eda.pop()\nwhile eda:\n  after = eda.pop()\n  for k in range(before, after):\n    ans.append((k, after))\n  before = after\nans.append((before, before+1))\nfor k in range(before+2, N+1):\n  ans.append((before+1, k))\nwhile ans:\n  item = ans.pop()\n  print(item[0], item[1])", "s=list(map(int,list(input())))\n# s[0]=1,s[-1]=0,s[k]=s[n-k-1]\u306f\u5fc5\u8981\ndef main(s):\n  n=len(s)\n  if s[0]!=1 or s[-1]!=0:return [[-1]]\n  for k in range(n//2-1):\n    if s[k]!=s[n-k-2]:return [[-1]]\n  uv=[(1,2)]\n  t=2\n  i=3\n  for x in s[1:-1]:\n    uv.append((t,i))\n    if x==1:\n      t=i\n    i+=1\n  return uv\nfor x in main(s):\n  print(*x,sep=' ')\n", "s=input()\nn=len(s)\nif s[0]==\"0\" or s[-1]==\"1\" or any(s[i]!=s[n-i-2] for i in range(n-1)):\n\tprint(-1)\n\treturn\nans=[]\nnow=0\nfor i,c in enumerate(s[:-1]):\n\tif c==\"1\":\n\t\tans.append(\"{} {}\".format(now+1,i+2))\n\t\tnow=i+1\n\telse:\n\t\tans.append(\"{} {}\".format(now+1,i+2))\nprint(*ans,sep=\"\\n\")", "import sys\n\ns = input()\nN = len(s)\nif s[-1] == \"1\" or s[0] == \"0\":\n  print((-1)); return\n  \nfor i in range(N//2):\n  if s[i] != s[-i-2]:\n    print((-1)); return\n\ntmp = 1\nfor i in range(N-1):\n  print((tmp, i+2))\n  if s[i] == \"1\":\n    tmp = i+2\n", "s = list(map(int, input()))\nn = len(s)\nif s[0]==0 or s[-1] == 1 or any(s[i]!=s[i] for i in range(n//2)):\n    print((-1))\n    return\nG = [[] for i in range(n)]\ncur = 0\nfor i in range(n-1):\n    G[cur].append(i+1)\n    G[i+1].append(cur)\n\n    if s[i]:\n        cur = i+1\n\nroot = n//2\nfrom collections import deque\nsize = [1]*n\nans = [0]*n\nedges = []\ndef bfs1(root):\n    rev = [(root, -1)]\n    for i in range(n):\n        cur, par = rev[i]\n        for to in G[cur]:\n            if to != par:\n                rev.append((to, cur))\n    for i in reversed(list(range(1,n))):\n        cur, par = rev[i]\n        size[par] += size[cur]\n        ans[size[cur]] = 1\n        ans[n-size[cur]] = 1\n        edges.append([cur+1, par+1])\nbfs1(0)\n\nif any(ans[i+1]!=s[i] for i in range(n-1)):\n    print((-1))\n    return\n\nfor i in edges:\n    print((*i))\n", "def check(S):\n    size = len(S)\n    if S[0]==\"0\" or S[-1]==\"1\":\n        return False\n    else:\n        for i in range(size-1):\n            a, b = i, size-i-2\n            if (S[a]==\"1\" and S[b]==\"0\") or (S[a]==\"0\" and S[b]==\"1\"):\n                return False\n        return True\n\n\nS = input()\nif check(S):\n    N = len(S)\n    l = [1]\n    p = False\n    for i in range(2, N+1):\n        if p:\n            l.append(i)\n        else:\n            print((l[-1], i))\n        p = (S[i-1]==\"1\")\n    for i in range(len(l)-1):\n        print((l[i], l[i+1]))\nelse:\n    print((-1))\n", "s = input().strip()\nn = len(s)\ns = \"0\"+s\nflag = 0\nif s[n]==\"1\" or s[1]==\"0\":\n    flag = 1\nelse:\n    for i in range(1,n):\n        if s[i]!=s[n-i]:\n            flag = 1\n            break\nif flag==1:\n    print((-1))\nelse:\n    A = [1]\n    for i in range(2,n):\n        if s[i]==\"1\":\n            while A:\n                print((A.pop(),i))\n            A = [i]\n        else:\n            A.append(i)\n    print((n-1,n))\n", "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque,Counter,defaultdict\nfrom operator import mul\nimport copy\n# ! /usr/bin/env python\n# -*- coding: utf-8 -*-\nimport heapq\nsys.setrecursionlimit(10**6)\nINF =  float(\"inf\")\nimport bisect\n\ns = input()\nn = len(s)\n\nif s[n-1] == \"1\" or s[0] == \"0\":\n    print((-1))\n    return\n\nfor i in range((n-1) // 2):\n    if s[i] != s[n-2-i]:\n        print((-1))\n        return\n\nj = 0\nfor i in range(1,n):\n    if s[i] == \"1\":\n        for k in range(j,i):\n            print((k+1,i+1))\n        j = i\n\nfor k in range(j+1,n):\n    print((j+1,k+1))\n\n\n\n", "s=list(input())\ns=[int(si) for si in s]\nn=len(s)\nif s[-1] or not s[0]:print(-1);return\nfor i in range(1,n//2):\n    if s[i-1]!=s[n-i-1]:\n        print(-1)\n        return\nans=[(1,2)]\nfor i in range(1,n-1):\n    x,y=ans[-1]\n    if s[i]:\n        ans.append((y,i+2))\n    else:\n        ans.append((i+2,y))\nfor x,y in ans:\n    print(x,y)", "s = list(input())\nn = len(s)\nif s[n - 1] == \"1\" or s[0] == \"0\":\n    print(-1)\n    return\nfor i in range((n - 1) // 2):\n    if not s[i] == s[n - 2 - i]:\n        print(-1)\n        return\nl = n - s.count(\"0\") + 1\nx = [0] * l\nj = 0\nfor i in range(n // 2):\n    if s[i] == \"1\":\n        j += 1\n    else:\n        x[j] += 1\n        x[l - 1 - j] += 1\n        if j == l - 1 - j and n % 2 == 0 and i == (n - 1) // 2:\n            x[j] -= 1\nfor i in range(l - 1):\n    print(i + 1, i + 2)\nk = n - s.count(\"0\") + 2\nfor i in range(l):\n    for _ in range(x[i]):\n        print(i + 1, k)\n        k += 1", "def no():\n    print((-1))\n    return\n\n\ns = input()\nn = len(s)\n\nif s[-1] == \"1\":\n    no()\n\ns = s[:-1]\n\nif s != s[::-1]:\n    no()\n\nif s[0] == \"0\":\n    no()\n\nli = [0]\nadj = [[] for _ in range(n + 1)]\nfor v, e in enumerate(s, 1):\n    if e == \"1\":\n        for u in li:\n            adj[u].append(v)\n        li = []\n\n    li.append(v)\n\nadj[n-1].append(n)\n\nfor u, vs in enumerate(adj[1:], 1):\n    for v in vs:\n        print((u, v))\n", "S = input()\nT = S[:-1]\n\nif S[0] == \"0\" or S[-1] == '1' or T != T[::-1]:\n    print(-1)\n    return\n\nu = 1\nfor v in range(2, len(S) + 1):\n   print(u, v)\n   if S[v - 2] == '1':\n       u = v", "s = input()\nN = len(s)\nflag = False\nfor i in range(N):\n  if s[i]=='1':\n    if s[N-2-i]!='1':\n      print(-1)\n      break\nelse:\n  if s[0]=='0' or s[-1]=='1':\n    print(-1)\n  else:\n    s = list(s)\n    s[-1] = '1'\n    ls = []\n    for i in range(N):\n      if s[i]=='1':\n        ls.append(i)\n    ps = 0\n    for i in range(N-1):\n      if i==ls[ps]:\n        ps += 1\n      print(i+1,ls[ps]+1)", "import sys\n#input = sys.stdin.buffer.readline\n\ndef main():\n    s = list(input())\n    l = len(s)\n    if s[0] != \"1\" or s[-1] != \"0\":\n        print((-1))\n    else:\n        for i in range(l//2):\n            if s[i] != s[l-i-2]:\n                print((-1))\n                return\n        s = s[::-1]\n        s[0] = \"1\"\n        now = 0\n        ans = []\n        while now<l-1:\n            c = 1\n            ans.append((l-now,l-(now+c)))\n            while s[now+c] == \"0\":\n                c += 1\n                ans.append((l-now,l-(now+c)))\n            now += c\n        for x,y in ans:\n            print((x,y))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nini = lambda: int(sys.stdin.readline())\ninl = lambda: [int(x) for x in sys.stdin.readline().split()]\nins = lambda: sys.stdin.readline().rstrip()\ndebug = lambda *a, **kw: print(\"\\033[33m\", *a, \"\\033[0m\", **dict(file=sys.stderr, **kw))\n\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.par = None\n\n\ndef solve():\n    s = [x == \"1\" for x in ins()]\n    n = len(s)\n    if s[-1]:\n        return print(-1)\n    for i in range(n - 1):\n        if s[i] != s[n - 2 - i]:\n            return print(-1)\n    if not s[0]:\n        return print(-1)\n\n    h = (n + 1) // 2\n    nodes = [Node(i) for i in range(n)]\n    for i in range(1, n):\n        nodes[i].par = nodes[i - 1]\n\n    i = 1\n    while i + 2 < n:\n        if s[i]:\n            i += 1\n            continue\n        nodes[i + 2].par = nodes[i]\n        nodes[i], nodes[i + 1] = nodes[i + 1], nodes[i]\n        i += 1\n\n    edges = set()\n    for i in range(1, n):\n        u = nodes[i].val\n        v = nodes[i].par.val\n        edges.add((min(u, v) + 1, max(u, v) + 1))\n    for u, v in edges:\n        print(u, v)\n\n\nsolve()\n", "import sys\nS = input()\nN = len(S)\nss = S[:N-1]\nif S[-1] == '1' or ss != ss[::-1] or S[0] == '0':\n    print((-1))\n    return\ntree = []\ncnt = 0\nfor s in ss:\n    if s == '1':\n        tree.append(cnt)\n        cnt = 0\n    else:\n        cnt += 1\nans = []\nnow = 1\nfor c in tree:\n    for i in range(c):\n        ans.append((now, now+i+1))\n    ans.append((now, now+c+1))\n    now = now+c+1\nfor a, b in ans:\n    print((a, b))\n        \n    \n\n\n\n\n\n\n    \n\n\n", "import sys\n\ns=list(map(int,list(input())))\nn=len(s)\nif s[0]==0 or s[-1]==1:\n    print(-1)\n    return\nfor i in range(n//2):\n    if s[i]==s[n-2-i]:\n        continue\n    else:\n        print(-1)\n        return\nans=[[1,2]]\nlast_edge=2\nfor i in range(3,n+1):\n    ans.append([last_edge,i])\n    if s[i-2]==1:\n        last_edge=i\nfor u in ans:\n    print(*u)", "s=input()\nif not(s[0]==\"1\"and s[-1]==\"0\"and s[-2::-1]==s[:-1]):print(-1);return()\nc=1\nfor i in range(len(s)-1):\n print(c,i+2)\n if s[i]==\"1\":c=i+2", "import sys\ns=input()\nn=len(s)\nif s[-1]=='1':\n  print(-1)\n  return\nif s[0]=='0':\n  print(-1)\n  return\nfor i in range(n-1):\n  if s[i]!=s[n-2-i]:\n    print(-1)\n    return\nans=['1','2']\nprint(' '.join(ans))\ncurrent=2\nfor i in range(1,n-1):\n  ans=[]\n  ans.append(str(current))\n  ans.append(str(i+2))\n  print(' '.join(ans))\n  if s[i]=='1':\n    current=i+2", "s = '0'\ns += input()\n\n\ndef isPara(string, l, r):\n    while l <= r:\n        if s[l] != s[r]:\n            return False\n        l += 1\n        r -= 1\n    return True\n\n\ndef solve():\n    N = len(s)-1\n    if s[N] == '1' or s[1] == '0':\n        print((-1))\n        return\n    if isPara(s, 1, N-1) == False:\n        print((-1))\n        return\n    sz = 1\n    while sz < N:\n        if(s[sz] == '1'):\n            sz += 1\n        else:\n            break\n    sz -= 1\n    # a max chain of sz\n    now = 1\n    for i in range(2, N+1):\n        print((str(now) + ' ' + str(i)))\n        if(s[i-1] == '1'):\n            now = i\n\n\nsolve()\n", "S=input()\nN=len(S)\n\n#1-origin\u306b\u3059\u308b\n#S[0]\u304c\u3042\u308b\u3068\u3059\u308b\u3068\u30010,N\u306b\u5225\u308c\u308b\u3053\u3068\u306f\u306a\u3044\u306e\u3067\u30010\nS=\"0\"+S\n\n#\u8449\u3067\u304d\u3063\u305f\u6642\u306b\u30011_(n-1)\u306b\u306a\u308b\u306f\u305a\nif S[1]!=\"1\":\n    print(\"-1\")\n    return\n\n#0_N\u306b\u5225\u308c\u308b\u3053\u3068\u306f\u306a\u3044\nif S[-1]!=\"0\":\n    print(\"-1\")\n    return\n\n# S[i]=1\u306e\u6642,i_(N-i)\u306b\u5225\u308c\u308b-> S[i]==S[N-i]\nfor s,rev_s in zip(S,reversed(S)):\n    if s!=rev_s:\n        print(\"-1\")\n        return\n\nprev=N\nfor i in reversed(list(range(1,N))):\n    print((i,prev))\n    #\u3053\u308c\u307e\u3067\u306b\u3001N-i\u500b\u304c\u3059\u3067\u306b\u6c17\u306b\u8ffd\u52a0\u3055\u308c\u3066\u3044\u308b\u3002prev\u3068cur(i)\u306e\u9593\u3067\u304d\u308b\u3068\u3001(i_N-i)\u306b\u5225\u308c\u308b\n    if S[i]==\"1\":\n        prev=i\n    else:\n        #\u8449\u306b\u306a\u308b(1_N-1)\u306b\u5225\u308c\u308b\u305f\u3081\u3001i_(N-i)\u306b\u306f\u306a\u3089\u306a\u3044\u3002S[1]=S[N-1]=1\u306f\u6c7a\u307e\u3063\u3066\u3044\u308b\u3002\n        pass\n\n\n", "def getN():\n    return int(input())\ndef getNM():\n    return map(int, input().split())\ndef getList():\n    return list(map(int, input().split()))\ndef getArray(intn):\n    return [int(input()) for i in range(intn)]\ndef input():\n    return sys.stdin.readline().rstrip()\ndef rand_N(ran1, ran2):\n    return random.randint(ran1, ran2)\ndef rand_List(ran1, ran2, rantime):\n    return [random.randint(ran1, ran2) for i in range(rantime)]\ndef rand_ints_nodup(ran1, ran2, rantime):\n  ns = []\n  while len(ns) < rantime:\n    n = random.randint(ran1, ran2)\n    if not n in ns:\n      ns.append(n)\n  return sorted(ns)\n\ndef rand_query(ran1, ran2, rantime):\n  r_query = []\n  while len(r_query) < rantime:\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n    if not n_q in r_query:\n      r_query.append(n_q)\n  return sorted(r_query)\n\nfrom collections import defaultdict, deque, Counter\nfrom decimal import *\nfrom heapq import heapify, heappop, heappush\nimport math\nimport random\nimport string\nfrom copy import deepcopy\nfrom itertools import combinations, permutations, product\nfrom operator import mul, itemgetter\nfrom functools import reduce\nfrom bisect import bisect_left, bisect_right\n\nimport sys\nsys.setrecursionlimit(1000000000)\nmod = 10 ** 9 + 7\n\n#############\n# Main Code #\n#############\n\n\"\"\"\n\u9802\u70b9\u304cN\u500b\u3001\u8fba\u304cN - 1\u672c\u3042\u308a\u307e\u3059\n1110\n\u4efb\u610f\u306e\u8fba\u3092\u4e00\u3064\u53d6\u308a\u9664\u304f\u3068\u30b5\u30a4\u30ba1\u306e\u9023\u7d50\u6210\u5206\u304c\u4f5c\u308c\u308b\n\u4efb\u610f\u306e\u8fba\u3092\u4e00\u3064\u53d6\u308a\u9664\u304f\u3068\u30b5\u30a4\u30ba2\u306e\u9023\u7d50\u6210\u5206\u304c\u4f5c\u308c\u308b\n\u4efb\u610f\u306e\u8fba\u3092\u4e00\u3064\u53d6\u308a\u9664\u304f\u3068\u30b5\u30a4\u30ba3\u306e\u9023\u7d50\u6210\u5206\u304c\u4f5c\u308c\u308b\n\n\u3069\u306e\u8fba\u3092\u4e00\u3064\u53d6\u308a\u9664\u3044\u3066\u3082\u30b5\u30a4\u30ba4\u306e\u9023\u7d50\u6210\u5206\u306f\u4f5c\u308c\u306a\u3044\n\n\u30b5\u30a4\u30ba1\u306e\u9023\u7d50\u6210\u5206\u304c\u4f5c\u308c\u308b\u3053\u3068\u3001\u30b5\u30a4\u30ban\u306e\u9023\u7d50\u6210\u5206\u306f\u4f5c\u308c\u306a\u3044\u3053\u3068\u306f\u81ea\u660e\n\u30b5\u30a4\u30bai\u306e\u9023\u7d50\u6210\u5206\u304c\u4f5c\u308c\u308b\u306a\u3089\u3001\u30b5\u30a4\u30ban - i\u306e\u9023\u7d50\u6210\u5206\u304c\u4f5c\u308c\u308b\n\u5358\u7d14\u306a\u6728\u69cb\u9020\u304b\u3089\u8003\u3048\u3088\u3046\n\u30fb\u30d1\u30b9\u30b0\u30e9\u30d5\n\u30fb\u30b9\u30bf\u30fc\u30b0\u30e9\u30d5\n\n\u30fb\u30d1\u30b9\u30b0\u30e9\u30d5\n1(1\u304cN - 1\u500b) + 0\u306b\u306a\u308b\n\u30fb\u30b9\u30bf\u30fc\u30b0\u30e9\u30d5\n10...010\u306b\u306a\u308b\n\n\u4ed6\u306e\u3082\u306e\u306f\u4f5c\u308c\u306a\u3044\u304b\n\u9023\u7d50\u6210\u5206i\u306e\u3082\u306e\u304c\u4f5c\u308c\u308b\u6761\u4ef6\u3001\u4f5c\u308c\u306a\u3044\u6761\u4ef6\n\u4f5c\u308c\u306a\u3044\u6761\u4ef6\u304c\u77e5\u308a\u305f\u3044\u3000\u5358\u4f53\u3067\u3042\u308c\u3070\u5fc5\u305a\u4f5c\u308c\u308b\n\uff08\u9023\u7d50\u6210\u5206i\u304c\u4f5c\u308c\u3001j\u304c\u4f5c\u308c\u306a\u3044\uff09\u304c\u6210\u308a\u7acb\u305f\u306a\u3044\u5834\u5408\u304c\u3042\u308b\uff1f\n\u90e8\u5206\u6728\u304b\u3089\u8003\u3048\u3066\u3044\u304f\n\u5927\u304d\u30552\u306e\u30d1\u30b9\u30b0\u30e9\u30d5\u306f11\n\u3053\u308c\u3092root\u306b\u3064\u3051\u308b\u3068 110\u306b\u306a\u308b\n\u5927\u304d\u30553\u306e\u30b9\u30bf\u30fc\u30b0\u30e9\u30d5\u306f101\n\u3053\u308c\u3092root\u306b\u3064\u3051\u308b\u30681010\u306b\u306a\u308b\n\n\u5927\u304d\u3055n\u306e\u30b0\u30e9\u30d5\u306b\u30d1\u30b9\u72b6\u306b/\u30b9\u30bf\u30fc\u72b6\u306b\u7e4b\u3052\u3066\u3044\u304f\u3068\n1 - 2\u306e\u30b0\u30e9\u30d5\u306b\n\u30d1\u30b9\u72b6\u306b3\u3092\u7e4b\u3052\u308b\u3068 110\n\u30b9\u30bf\u30fc\u72b6\u306b\u7e4b\u3052\u308b\u3068 110 \u3053\u3053\u307e\u3067\u306f\u540c\u3058\n1 - 2 - 3\u306e\u30b0\u30e9\u30d5\u306b\n\u30d1\u30b9\u72b6\u306b\u7e4b\u3052\u308b\u3068 1110\n\u30b9\u30bf\u30fc\u72b6\u306b\u7e4b\u3052\u308b\u3068 1010\n\n\u30d1\u30b9\u30b0\u30e9\u30d5\u306b\u8fba\u3092\u52a0\u3048\u3066\u9023\u7d50\u6210\u5206j\u304c\u4f5c\u308c\u306a\u3044\u3088\u3046\u306b\u3057\u3088\u3046\n\n11010110\u306f\u4f5c\u308c\u308b\u304b\n\u4e00\u65b9\u3092\u30d1\u30b9\u30b0\u30e9\u30d5\u306b\u3001\u4e00\u65b9\u3092\u30b9\u30bf\u30fc\u30b0\u30e9\u30d5\u306b\u3059\u308b?\n1 - 2\u306e\u72b6\u614b\u3067\u30b9\u30bf\u30fc\u30c8\n\u3082\u3057S[i] = 1\u306a\u3089\u89aa\u8981\u7d20\u306bi + 2\u3092\u3064\u3051\u3001\u305d\u308c\u3092\u89aa\u8981\u7d20\u306b\u3059\u308b\n\u3082\u3057S[i] = 0\u306a\u3089\u73fe\u5728\u306e\u89aa\u8981\u7d20\u306b\u3064\u3051\u308b\n\"\"\"\n\nS = input()\nN = len(S)\n# \u3053\u306e\u6761\u4ef6\u3092\u6e80\u305f\u3057\u3066\u3044\u308b\u3068\u6728\u3092\u4f5c\u308b\u3053\u3068\u304c\u3067\u304d\u308b\nif S[N - 1] == \"1\" or S[N - 2] == \"0\" or S[0] == \"0\":\n    print(-1)\nelse:\n    for i in range(N - 1):\n        if S[i] != S[N - i - 2]:\n            print(-1)\n            return\n    ans = []\n    parent = 1 # \u73fe\u5728\u306eparent\n    for i in range(N - 1):\n        if S[i] == \"1\":\n            # \u30d1\u30b9\u30b0\u30e9\u30d5\u72b6\n            ans.append([parent, i + 2])\n            parent = i + 2 # parent\u5909\u66f4\n        else:\n            # \u30b9\u30bf\u30fc\u30b0\u30e9\u30d5\u72b6\n            ans.append([parent, i + 2])\n    for i in ans:\n        print(i[0], i[1])", "import sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nS = '-' + sr()\nN = len(S) - 1\n\ndef solve(S):\n    if S[1] == '0' or S[N] == '1':\n        return None\n    prev = 1\n    graph = []\n    for i in range(1, N//2 + 1):\n        if S[i] != S[N-i]:\n            return None\n        if S[i] == '0':\n            continue\n        for x in range(prev, i):\n            graph.append('{} {}'.format(x, i))\n        prev = i\n    for x in range(prev, N):\n        graph.append('{} {}'.format(x, N))\n    return graph\n\ngraph = solve(S)\nif graph is None:\n    print((-1))\nelse:\n    print(('\\n'.join(graph)))\n\n# 42\n", "s=input()\nn=len(s)\n\ndef check():\n    if s[0]==\"0\" or s[-1] ==\"1\":\n        return False\n    for i in range(n):\n        if s[i] != s[n-i-2]:\n            return False\n    return True\n\nif not check():\n    print(-1)\n    return\n\nnow=1\nfor i in range(n-1):\n    print(now,i+2)\n    if s[i]==\"1\":\n        now=i+2", "s = input()\nif s[-1] == \"1\":\n  print(-1)\n  return\ns = s[:-1]\nif s != s[::-1] or s[0] == \"0\":\n  print(-1)\n  return\ns += \"1\"\nn = len(s)\nnow = 1\nfor i, t in enumerate(s, 1):\n  if t == \"1\":\n    for j in range(now, i):\n      print(j, i)\n      now = i", "s=input()\nif s[0]==\"0\":print(-1);return()\nif s[-1]==\"1\":print(-1);return()\nfor i in range(len(s)-1):\n  if s[i]!=s[(len(s)-1)-(i+1)]:print(-1);return()\nans=[]\nfor i in range(len(s)-1):\n  if s[i]==\"1\":\n    for j in ans:print(j+1,i+1)\n    ans=[]\n  ans.append(i)\nfor j in ans:print(j+1,len(s))", "S = input()\nN = len(S)\nif (\n    S[0] == \"0\"\n    or S[-1] == \"1\"\n    or any(S[i] != S[N - i - 2] for i in range((N - 1) // 2))\n):\n    print(-1)\n    return\n\nhead = 0\nedges = []\nfor i in range(N - 1):\n    edges.append((head, i + 1))\n    if S[i] == \"1\":\n        head = i + 1\n[print(f + 1, t + 1) for f, t in edges]\n\n", "def ex():print(-1);return\n\ns=input()\nN=len(s)\nif not (s[0]=='1' and s[-1]=='0'):\n    ex()\nfor i in range(N//2):\n    if s[i]!=s[N-i-2]:\n        ex()\nans=[]\nm=1\nfor i in range(1,N//2+1):\n    ans.append((m,i+1))\n    if s[i-1]=='1':\n        m=i+1\nfor i in range(N//2+2,N+1):\n    ans.append((m,i))\nfor t in ans:\n    print(*t)", "S = input()\n\nif S[-1]==\"1\" or S[0]==\"0\":\n    print(-1)\nelse:\n    flag = True\n    for i in range((len(S)-1)//2):\n        if S[-i-2]!=S[i]:\n            flag=False\n            print(-1)\n            break\n\n    if flag:\n        ans = []\n        now = 1\n        nxt = 2\n        for i in range(len(S)//2):\n            ans.append((now,nxt))\n            if S[i]==\"1\":\n                now = nxt\n                nxt += 1\n            else:\n                nxt += 1\n        ans.append((now,nxt))\n        for i in range(nxt+1,len(S)+1):\n            ans.append((now,i))\n        for a in ans:\n            print(*a)", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\n#n = int(readline())\n#*a, = map(int,readline().split())\ns = input()\nn = len(s)\nok = 1\nif s[-1]==\"1\": ok = 0\nif any(s[i] != s[n-2-i] for i in range(n-1)): ok = 0\nif s[0]==\"0\": ok = 0\n\nif ok==0:\n    print(\"-1\")\n    return\n\ne = [(0,1)]\ntop = 1\nfor i in range(1,n-1):\n    e.append((top,i+1))\n    if s[i]==\"1\":\n        top = i+1\n\nfor a,b in e:\n    print(a+1,b+1)", "S = input()\nif S[0] == \"0\" or S[-1] == \"1\":\n    print((-1))\n    return\nn = len(S)\nfor i in range(n // 2):\n    if S[i] != S[n - 2 - i]:\n        print((-1))\n        return\n    \nfor i in range(2, n // 2 + 1):\n    print((1, i))\nbef = 1\nfor i in range(n // 2 + 1, n + 1):\n    print((bef, i))\n    if S[i - 2] == \"1\":\n        bef = i\n\n", "S = input()\nN = len(S)\n\nif S[-1] == '1' or S[0] == '0':\n    print(-1)\n\nelse:\n    for i in range(N - 1):\n        if S[i] != S[N - 2 - i]:\n            print(-1)\n            break\n    else:\n        tmp = 1\n        for i in range(N - 1):\n            if S[i] == '1':\n                print(tmp, i + 2)\n                tmp = i + 2\n            else:\n                print(tmp, i + 2)", "s=list(input())\nif s[0]!='1' or s[-1]!='0':\n    print(-1)\n    return\nl=0\nr=len(s)-2\n\nwhile l<=r:\n    if s[l]!=s[r]:\n        print(-1)\n        return\n    l+=1\n    r-=1\n\noya=1\nans=[[1,2]]\n\nfor i in range(1,len(s)-1):\n    node=i+2\n    if s[i]=='0':\n        s[len(s)-i-1]='?'\n        ans.append([oya,node])\n    elif s[i]=='1':\n        ans.append([oya,node])\n        oya=node\n        s[len(s)-i-1]='?'\n\n    else:\n        ans.append([oya,node])\n\n\n\nfor i in ans:\n    print(*i,sep=' ')", "import sys\ns = list(map(int, input()))\nn = len(s)\nif s[0] == 0 or s[-1] == 1:\n    print((-1))\n    return\nfor i in range(n):\n    if s[i] != s[n - i - 2]:\n        print((-1))\n        return\n\ncur_children = [0]\nans = []\nfor i in range(1, n-1):\n    if s[i] == 1:\n        while len(cur_children) > 0:\n            j = cur_children.pop()\n            ans.append((i + 1, j + 1))\n    cur_children.append(i)\nwhile len(cur_children) > 0:\n    j = cur_children.pop()\n    ans.append((n, j + 1))\nfor i, j in ans:\n    print((i, j))\n", "s = input()\n\nN = len(s)\n\nflag=True\nif s[N-1]=='1':\n        flag=False\nif s[0]=='0' or s[N-2]=='0':\n        flag=False\n\n\nfor i in range(N//2):\n        if s[i]!=s[N-i-2]:\n                flag=False\n                break\n\nif flag:\n        ans = []\n        prev = 0\n        for i in range(N//2):\n                if s[i]=='1':\n                        for j in range(prev,i):\n                                ans.append([i+1,j+1])\n                        prev = i\n        \n        for i in range(prev,N-1):\n                ans.append([N,i+1])\n        \n        for a in ans:\n                print(*a)\nelse:\n        print(-1)", "def main():\n    S = list(input())\n\n    N = len(S)\n\n    if (S[0] == '0') or (S[-1] == '1'):\n        print (-1)\n        return 0\n\n    lst = []\n    for i in range((N - 1) // 2):\n        if S[i] != S[N - 2 - i]:\n            print (-1)\n            return 0\n        if S[i] == '1':\n            lst.append(i + 1)\n    if N % 2 == 0 and S[N//2 - 1] == '1':\n        lst.append(N//2)\n    # print (lst)\n\n    if lst[-1] * 2 != N:\n        center = lst[-1] + 1\n        for x in range(lst[-1] * 2 + 2, N + 1):\n            print (center, x)\n\n        before = 1\n        n = lst[-1] * 2 + 2\n        tmp = 1\n        for tmp in lst[1:]:\n            print (before, tmp)\n            print (n - before, n - tmp)\n            for x in range(tmp - before - 1):\n                print (before + 1 + x, tmp)\n                print (n - (before + 1 + x), n - tmp)\n            before = tmp\n        print (tmp, center)\n        print (n - tmp, center)\n\n    if lst[-1] * 2 == N:\n        before = 1\n        n = lst[-1] * 2 + 1\n        tmp = 1\n        for tmp in lst[1:]:\n            print (before, tmp)\n            print (n - before, n - tmp)\n            for x in range(tmp - before - 1):\n                print (before + 1 + x, tmp)\n                print (n - (before + 1 + x), n - tmp)\n            before = tmp\n        print (tmp, n - tmp)\n\ndef __starting_point():\n    main()\n__starting_point()", "# -*- coding: utf-8 -*-\n\n#############\n# Libraries #\n#############\n\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\n\nimport math\n#from math import gcd\nimport bisect\nimport heapq\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nfrom functools import lru_cache\n\n#############\n# Constants #\n#############\n\nMOD = 10**9+7\nINF = float('inf')\nAZ = \"abcdefghijklmnopqrstuvwxyz\"\n\n#############\n# Functions #\n#############\n\n######INPUT######\ndef I(): return int(input().strip())\ndef S(): return input().strip()\ndef IL(): return list(map(int,input().split()))\ndef SL(): return list(map(str,input().split()))\ndef ILs(n): return list(int(input()) for _ in range(n))\ndef SLs(n): return list(input().strip() for _ in range(n))\ndef ILL(n): return [list(map(int, input().split())) for _ in range(n)]\ndef SLL(n): return [list(map(str, input().split())) for _ in range(n)]\n\n\n#####Shorten#####\ndef DD(arg): return defaultdict(arg)\n\n#####Inverse#####\ndef inv(n): return pow(n, MOD-2, MOD)\n\n######Combination######\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n): return kaijo_memo[n]\n  if(len(kaijo_memo) == 0): kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n): kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\n\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n): return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0): gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n): gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\n\ndef nCr(n,r):\n  if n == r: return 1\n  if n < r or r < 0: return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\n\n######Factorization######\ndef factorization(n):\n  arr = []\n  temp = n\n  for i in range(2, int(-(-n**0.5//1))+1):\n    if temp%i==0:\n      cnt=0\n      while temp%i==0: \n        cnt+=1 \n        temp //= i\n      arr.append([i, cnt])\n  if temp!=1: arr.append([temp, 1])\n  if arr==[]: arr.append([n, 1])\n  return arr\n\n#####MakeDivisors######\ndef make_divisors(n):\n  divisors = []\n  for i in range(1, int(n**0.5)+1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i: \n        divisors.append(n//i)\n  return divisors\n\n#####MakePrimes######\ndef make_primes(N):\n  max = int(math.sqrt(N))\n  seachList = [i for i in range(2,N+1)]\n  primeNum = []\n  while seachList[0] <= max:\n    primeNum.append(seachList[0])\n    tmp = seachList[0]\n    seachList = [i for i in seachList if i % tmp != 0]\n  primeNum.extend(seachList)\n  return primeNum\n\n#####GCD#####\ndef gcd(a, b):\n    while b: a, b = b, a % b\n    return a\n\n#####LCM#####\ndef lcm(a, b):\n    return a * b // gcd (a, b)\n\n#####BitCount#####\ndef count_bit(n):\n  count = 0\n  while n:\n    n &= n-1\n    count += 1\n  return count\n\n#####ChangeBase#####\ndef base_10_to_n(X, n):\n  if X//n: return base_10_to_n(X//n, n)+[X%n]\n  return [X%n]\n\ndef base_n_to_10(X, n):\n  return sum(int(str(X)[-i-1])*n**i for i in range(len(str(X))))\n\ndef base_10_to_n_without_0(X, n):\n  X -= 1\n  if X//n: return base_10_to_n_without_0(X//n, n)+[X%n]\n  return [X%n]\n\n#####IntLog#####\ndef int_log(a, n):\n  count = 0\n  while n>=a:\n    n //= a\n    count += 1\n  return count\n\n#############\n# Main Code #\n#############\n\nS = S()\nN = len(S)\nS = [int(s) for s in S]\nM = N//2\n\nif S[-1] != 0 or S[0] != 1:\n  print(-1)\n  return\n  \nfor i in range(M):\n  if S[i] != S[N-2-i]:\n    print(-1)\n    return\n\nfor i in range(M)[::-1]:\n  if S[i] != 0:\n    start = i\n    break\n\nprint(1,2)\nfor i in range(N-start-2):\n  print(2,i+3)\n\nnow = 1\nfor i in range(1,start)[::-1]:\n  if S[i] == 1:\n    print(now,N-i)\n    now = N-i\n  else:\n    print(now,N-i)\n  \nif start!=0:\n  print(now,N)", "s = '0'\ns += input()\n\n\ndef isPara(string, l, r):\n    while l <= r:\n        if s[l] != s[r]:\n            return False\n        l += 1\n        r -= 1\n    return True\n\n\ndef solve():\n    N = len(s)-1\n    if s[N] == '1' or s[1] == '0':\n        print((-1))\n        return\n    if isPara(s, 1, N-1) == False:\n        print((-1))\n        return\n    root = 1\n    for i in range(2, N+1):\n        print((str(root) + ' ' + str(i)))\n        if s[i-1] == '1':\n            root = i\n\n\nsolve()\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\ns = input().rstrip()\nN = len(s)\nif s[0] == '0' or s[-1] == '1' or s[:-1] != s[:-1][::-1]:\n    print(-1)\n    return\nsubtree = [[] for _ in range(N+1)]\nprev = 1\nfor i in range(2, N+1):\n    if s[i-1] == '1' or i == N:\n        subtree[i] = [prev] + [1] * (i-prev-1)\n        prev = i\n\ni = 1\ndef dfs(size):\n    nonlocal i\n    v = i\n    for c in subtree[size]:\n        i += 1\n        print(v, i)\n        dfs(c)\n\ndfs(N)", "# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nINF = 2**62-1\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n@mt\ndef slv(S):\n    N = len(S)\n    if S[N-1] == '1':\n        print(-1)\n        return -1\n\n    if S[0] != '1':\n        print(-1)\n        return -1\n\n    if S[N-2] != '1':\n        print(-1)\n        return -1\n\n\n    for i in range(N//2):\n        if S[i] != S[N-2-i]:\n            print(-1)\n            return -1\n\n    p = [N]\n    for i in range(N, 0, -1):\n        if S[i-1] == '1':\n            p.append(i)\n        else:\n            p.append(p[-1])\n    p.reverse()\n    e = []\n    for i in range(1, N):\n        e.append((i, p[i]))\n\n    for u, v in e:\n        print(u, v)\n\n\ndef main():\n    S = read_str()\n    (slv(S))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input()\nif s[0] == \"0\" or s[-1] == \"1\":\n    print((-1))\n    return\nn = len(s)\nif n == 2:\n    if s == \"10\":\n        print((1, 2))\n        return\n    else:\n        print((-1))\n        return\n\nm = n // 2\ntmp = m + 1\nANS = []\nfor i in reversed(list(range(1, m + 1))):\n    j = n - i\n    if s[i - 1] == \"1\" and s[j - 1] == \"1\":\n        ANS.append((tmp, i))\n        tmp = i\n    elif s[i - 1] == \"0\" and s[j - 1] == \"0\":\n        ANS.append((tmp, i))\n    else:\n        print((-1))\n        return\nfor i in range(m + 2, n + 1):\n    ANS.append((m + 1, i))\n\nfor a, b in ANS:\n    print((a, b))\n", "s=input()\nn=len(s)\nif s[0]==\"0\" or s[-1]==\"1\":print(-1);return\nfor i in range(n-1):\n  if s[i]!=s[-i-2]:print(-1);return\nb=[]\nfor i in range(n-1):\n  if s[i]==\"1\":\n    for j in b:print(j+1,i+1)\n    b=[]\n  b.append(i)\nfor j in b:print(j+1,n)", "S=input()\nN=len(S)\n\n#1-origin\u306b\u3059\u308b\n#S[0]\u304c\u3042\u308b\u3068\u3059\u308b\u3068\u30010,N\u306b\u5225\u308c\u308b\u3053\u3068\u306f\u306a\u3044\u306e\u3067\u30010\nS=\"0\"+S\n\n#\u8449\u3067\u304d\u3063\u305f\u6642\u306b\u30011_(n-1)\u306b\u306a\u308b\u306f\u305a\nif S[1]!=\"1\":\n    print(\"-1\")\n    return\n\n# S[i]=1\u306e\u6642,i_(N-i)\u306b\u5225\u308c\u308b-> S[i]==S[N-i]\nfor s,rev_s in zip(S,reversed(S)):\n    if s!=rev_s:\n        print(\"-1\")\n        return\n\nprev=N\nfor i in reversed(list(range(1,N))):\n    print((i,prev))\n    #\u3053\u308c\u307e\u3067\u306b\u3001N-i\u500b\u304c\u3059\u3067\u306b\u6c17\u306b\u8ffd\u52a0\u3055\u308c\u3066\u3044\u308b\u3002prev\u3068cur(i)\u306e\u9593\u3067\u304d\u308b\u3068\u3001(i_N-i)\u306b\u5225\u308c\u308b\n    if S[i]==\"1\":\n        prev=i\n    else:\n        #\u8449\u306b\u306a\u308b(1_N-1)\u306b\u5225\u308c\u308b\u305f\u3081\u3001i_(N-i)\u306b\u306f\u306a\u3089\u306a\u3044\u3002S[1]=S[N-1]=1\u306f\u6c7a\u307e\u3063\u3066\u3044\u308b\u3002\n        pass\n\n\n", "S = input()\nN = len(S)\n\nif S[0] == '0' or S[-1] == '1' or S[:-1] != S[-2::-1]:\n    print((-1))\n    return\n\ncur_node = 1\nfor i in range(N - 1):\n    print((cur_node, i + 2))\n    if S[i] == '1':\n        cur_node = i + 2\n", "#from collections import deque\n#from heapq import heapify, heappop, heappush\n#from bisect import insort, bisect_left\n#import sys\n#sys.setrecursionlimit(10**9)\n#from math import gcd\n#from decimal import Decimal\n#mod = 1000000007\n#mod = 998244353\n#N = int(input())\n#N, K = map(int, input().split())\nS = input()\neda = []\nflag = False\nN = len(S)\nif S[-1] == '1':\n  flag = True\nif S[0] == '0':\n  flag = True\nif S[-2] == '0':\n  flag = True\nfor k in range((N-1)//2):\n  if S[k] != S[-k-2]:\n    flag = True\n  if S[k] == '1':\n    eda.append(k+1)\nif N%2 == 0:\n  if S[N//2 -1] == '1':\n    eda.append(N//2)\nif flag:\n  print((-1))\n  return\nans = []\neda.reverse()\nbefore = eda.pop()\nwhile eda:\n  after = eda.pop()\n  for k in range(before, after):\n    ans.append((k, after))\n  before = after\nans.append((before, before+1))\nfor k in range(before+2, N+1):\n  ans.append((before+1, k))\nwhile ans:\n  item = ans.pop()\n  print((item[0], item[1]))\n#ans = 0\n#for k in range(N):\n#print(ans)\n#print('Yes')\n#print('No')\n", "s=list(input())\nn=len(s)\nif s[0]=='0' or s[-1]=='1':\n  print((-1))\nelse:\n  s.pop()\n  sr=s.copy()\n  sr.reverse()\n  if s!=sr:\n    print((-1))\n  else:\n    ans=[]\n    now=1\n    cnt=1\n    for x in s:\n      if x=='1':\n        ans.append([now,now+cnt])\n        now+=cnt\n        cnt=1\n      else:\n        ans.append([now,now+cnt])\n        cnt+=1\n    for x in ans:\n      print((x[0],x[1]))\n", "s=input()\nn=len(s)\nif s[-1]==\"1\":\n    print((-1))\n    return\n\nif s[0]==\"0\":\n    print((-1))\n    return\n\ndata=[]\nfor i in range(0,n-1):\n    if s[i]==\"1\":\n        data.append(i+1)\n        if s[n-2-i]==\"0\":\n            print((-1))\n            return\nm=len(data)\nedge=[]\nfor i in range(1,m):\n    edge.append((i,i+1))\nindex=m+1\nfor i in range(1,m):\n    if i!=1:\n        size=data[-i]\n        nextsize=data[-i-1]\n        E=size-1-nextsize\n        count=0\n        while E>count:\n            edge.append((i,index))\n            index+=1\n            count+=1\n    else:\n        size=n\n        nextsize=data[-2]\n        E=size-1-nextsize\n        count=0\n        while E>count:\n            edge.append((i,index))\n            index+=1\n            count+=1\n\nfor i in range(n-1):\n    u,v=edge[i]\n    print((u,v))\n", "def Tree():\n    S = input()\n    N = len(S)\n\n    if S[0] == \"0\" or S[-1] == \"1\":\n        return []\n\n    for i in range(N - 1):\n        if S[i] != S[N - i - 2]:\n            return []\n\n    res = []\n    path = S.count(\"1\")\n    for i in range(1, path + 1):\n        res.append((i, i + 1))\n\n    u = len(res) + 1\n    v = 1\n    for s in S[:-1]:\n        if s == \"1\":\n            v += 1\n        else:\n            u += 1\n            res.append((v, u))\n\n    return res\n\n\ndef __starting_point():\n    tree = Tree()\n    if tree:\n        for x, y in tree:\n            print(x, y)\n    else:\n        print(-1)\n__starting_point()", "import sys\nimport math\nfrom collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\nsys.setrecursionlimit(10**7)\ndef input():\n    return sys.stdin.readline()[:-1]\n\nmod = 10**9 + 7\n\ndef I(): return int(input())\ndef LI(): return list(map(int, input().split()))\ndef LIR(row,col):\n    if row <= 0:\n        return [[] for _ in range(col)]\n    elif col == 1:\n        return [I() for _ in range(row)]\n    else:\n        read_all = [LI() for _ in range(row)]\n        return map(list, zip(*read_all))\n\n#################\n\ns = list(input())\nn = len(s)\n\nfor i in range((n-1)//2+1):\n    if s[i] != s[n-2-i]:\n        print(-1)\n        return\n\nif s[0] == '0':\n    print(-1)\n    return\n\nif s[n-1] == '1':\n    print(-1)\n    return\n\nfrom_ = 1\nto_ = 2\nans = []\nfor i in range(n-1):\n    ans.append((from_,to_))\n    if s[i] == '1':\n        from_ = to_\n        to_ += 1\n    else:\n        to_ += 1\n\nfor a in ans:\n    print(*a)", "s = input()\n\nif s[0] == '0' or s[-1] == '1' or s[:-1] != s[:-1][::-1]:\n    print((-1))\n    return\n\nedges = []\nhead = 0\nfor idx, i in enumerate(s[:-1]):\n    edges.append([head, idx + 1])\n    if i == '1':\n        head = idx + 1\nfor i, j in edges:\n    print((i + 1, j + 1))\n", "from bisect import bisect_right\ns = list(map(int,list(input())))\ns.insert(0,-1)\nn = len(s)-1\nflag = 0\nif s[n]==1 or s[1]==0 or s[n-1]==0:\n    flag = 1\nelse:\n    for i in range(2,n-1):\n        if s[i]!=s[n-i]:\n            flag = 1\n            break\nif flag==1:\n    print(-1)\nelse:\n    print(n,n-1)\n    A = [1,n-1]\n    cur = 1\n    for i in range(2,n-1):\n        if s[i]==1:\n            print(cur,i)\n            cur = i\n            A.append(i)\n    print(cur,n-1)\n    A = sorted(A)\n    for i in range(2,n-1):\n        if s[i]==0:\n            ind = bisect_right(A,i)\n            print(i,A[ind])", "S=[int(c) for c in input()]\nN=len(S)\nr=all([S[i]==S[N-i-2] for i in range(N//2)]) and S[0] and not S[-1]\nt=[(1,2)]\ne=2\nfor i in range(1,(N-1)//2):\n    t.append((e,i+2))\n    if S[i]:\n        e=i+2\nf=1\nif N%2==0:\n    t.append((e,N-e+1))\n    if S[N//2-1]:\n        f=0\nfor i in range(0,(N-1)//2):\n    t.append([e if t[i][j]==e and f else (N-e+1 if t[i][j]==N-t[i][j]+1 and f else N-t[i][j]+1) for j in range(2)])\nif r:\n    print(*[str(l[0])+\" \"+str(l[1]) for l in t],sep='\\n')\nelse:\n    print(-1)", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nS = input()\nN = len(S)\nS = '0' + S\n \nif S[1] == '0' or S[N] == '1' or S != S[::-1]:\n    print(-1)\n    return\n\nedges = []\nbase = 1\nfor i in range(1, N):\n    edges.append((base, i+1))\n    if S[i] == '1':\n        base = i + 1\n[print(*edge) for edge in  edges]\n", "#\u30e9\u30a4\u30d6\u30e9\u30ea\u30a4\u30f3\u30dd\u30fc\u30c8\nfrom collections import defaultdict\n\n#\u5165\u529b\u53d7\u3051\u53d6\u308a\ndef getlist():\n\treturn list(map(int, input().split()))\n\n#\u51e6\u7406\u5185\u5bb9\ndef main():\n\ts = list(input())\n\tN = len(s)\n\tjudge = \"Yes\"\n\tif s[0] == \"0\":\n\t\tjudge = \"No\"\n\tif s[N - 1] == \"1\":\n\t\tjudge = \"No\"\n\tfor i in range(N - 2):\n\t\tif s[i] != s[N - 2 - i]:\n\t\t\tjudge = \"No\"\n\tif judge == \"No\":\n\t\tprint(-1)\n\t\treturn\n\n\tc = 1\n\td = N\n\tfor i in range(N - 1):\n\t\tif s[i] == \"1\":\n\t\t\tprint(c, c + 1)\n\t\t\tc += 1\n\t\telse:\n\t\t\tprint(c, d)\n\t\t\td -= 1\n\ndef __starting_point():\n\tmain()\n__starting_point()", "s = input()\nn = len(s)\n\nif s[0] != \"1\" or s[n - 1] != \"0\":\n  print(\"-1\")\n  return\n\nfor i in range(n):\n  if s[i] != s[n - 2 - i]:\n    print(\"-1\")\n    return\n\nx = 1\nfor i in range(1, n):\n  print(x, i + 1)\n  if s[i - 1] == \"1\": x = i + 1", "import sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nS = '-' + sr()\nN = len(S) - 1\ndef solve(S):\n    if S[1] == '0':\n        return None\n    if S[N] == '1':\n        return None\n    prev = 1\n    graph = []\n    for n in range(1,N//2 + 1):\n        if S[n] != S[N-n]:\n            return None\n        if S[n] == '0':\n            continue\n        for i in range(prev,n):\n            graph.append('{} {}'.format(i,n))\n        prev = n\n    for i in range(prev,N):\n        graph.append('{} {}'.format(i,N))\n    return graph\n\ngraph = solve(S)\n\nif graph is None:\n    print((-1))\nelse:\n    print(('\\n'.join(graph)))\n", "s=input()\nif s[0]=='0' or s[-1]=='1' or s[:-1]!=s[:-1][::-1]:\n    print(-1)\n    return\ne=[]\nbi=0\nfor i,j in enumerate(s[:-1]):\n    e.append([bi,i+1])\n    if j=='1':\n        bi=i+1\nfor i,j in e:\n    print(i+1,j+1)", "#01:36\ns = input()\nn = len(s)\nif s[-1] == '1':\n  print(-1)\n  return\nt = s[:-1]\nif t[::-1] != t:\n  print(-1)\n  return\nif s[0] == '0':\n  print(-1)\n  return\nprint(0+1,1+1)\nnow = 0\nfor i in range(2,n):\n  print(now+1,i+1)\n  if s[i-1] == '1':\n    now = i", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef ng():\n    if s[0]==\"0\" or s[-1]==\"1\":return True\n    for i in range(n):\n        if i>n-2-i:break\n        if s[i]!=s[n-2-i]:return True\n    return False\n\ns=SI()\nn=len(s)\n\nif ng():\n    print(-1)\n    return\n\naa=[]\nfor i in range(n//2):\n    if s[i]==\"1\":aa.append(i+1)\naa.append(n)\n\nans=[]\nfor i in range(len(aa)-1):ans.append([i+1,i+2])\n\nj=len(aa)+1\nfor i,(a0,a1) in enumerate(zip(aa,aa[1:])):\n    for _ in range(a1-a0-1):\n        ans.append([i+2,j])\n        j+=1\n\nfor u,v in ans:print(u,v)\n", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\ns = input()\nn = len(s)\nif s[0]==\"0\" or s[-2]==\"0\" or s[-1]==\"1\":\n    print(\"-1\")\nelif any(s[i]!=s[-2-i] for i in range(n-1)):\n    print(\"-1\")\nelse:\n    i = 1\n    ps = set([i])\n    es = []\n    for c in s[1:]:\n        i += 1\n        if c==\"0\":\n            ps.add(i)\n        else:\n            for u in ps:\n                es.append(\"%s %s\" % (u,i))\n            ps = set([i])\n    for u in ps:\n        if u!=n:\n            es.append(\"%s %s\" % (u, n))\n    write(\"\\n\".join(es))", "S = input()\nn = len(S)\nm = n // 2\nif S[0] == '0' or S[-1] == '1':\n  print(-1)\n  return\n\nans = [[1, 2]]\nnode = 1\nnow = 3\nfor i in range(m):\n  if S[i] != S[n-i-2]:\n    print(-1)\n    return\n  else:\n    if i == 0:\n      continue\n    ans.append([node, now])\n    if S[i] == '0':\n      now += 1\n    else:\n      node = now\n      now += 1\n\nfor i in range(now, n+1):\n  ans.append([node, i])\n\nfor a in ans:\n  print(*a)", "s = input()\nn = len(s)\nif s[0] == \"0\" or s[-1] == \"1\":\n    print((-1))\n    return\nfor i in range(n-1):\n    if s[i] != s[-2-i]:\n        print((-1))\n        return\n\nnow = 1\nfor i in range(n-1):\n    if s[i] == \"0\":\n        print((now,i+2))\n    else:\n        print((now,i+2))\n        now = i+2\n", "import sys\n\ns = input()\n\nnum = len(s)\n\nif s[-1] == \"1\" or s[0] == \"0\":\n    print((-1))\n    return\n\ns = s[:-1]\n\nfor i in range(num // 2):\n    \n    if s[i] != s[-1-i]:\n        print((-1))\n        return\n\nlis = []\nans = []\n\nfor i in range(num-1):\n\n    if i != 0 and s[i] == \"1\":\n        lis.append(i+1)\n\n#print (lis)\n\nnow = 1\nfor i in range(len(lis)):\n\n    while now < lis[i]:\n        ans.append([now,lis[i]])\n        now += 1\n\n    if i != len(lis)-1:\n        ans.append([lis[i],lis[i+1]])\n        now += 1\n\nans.append([num-1,num])\n\n\nfor i in ans:\n    print((i[0],i[1]))\n", "import sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nS = '-' + sr()\nN = len(S) - 1\ndef solve(S):\n    if S[1] == '0':\n        print((-1)); return\n    if S[N] == '1':\n        print((-1)); return\n    prev = 1\n    graph = []\n    for n in range(1,N//2 + 1):\n        if S[n] != S[N-n]:\n            print((-1)); return\n        if S[n] == '0':\n            continue\n        for i in range(prev,n):\n            graph.append('{} {}'.format(i,n))\n        prev = n\n    for i in range(prev,N):\n        graph.append('{} {}'.format(i,N))\n    return graph\n\ngraph = solve(S)\n\nif graph is None:\n    print((-1))\nelse:\n    print(('\\n'.join(graph)))\n", "import typing\nimport sys\nimport math\nimport collections\nimport bisect\nimport itertools\nimport heapq\nimport decimal\nimport copy\nimport operator\n\n# sys.setrecursionlimit(10000001)\nINF = 10 ** 20\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n# buffer.readline()\n\n\ndef ni(): return int(sys.stdin.readline())\ndef ns(): return list(map(int, sys.stdin.readline().split()))\ndef na(): return list(map(int, sys.stdin.readline().split()))\ndef na1(): return list([int(x)-1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\ndef main():\n    s = input()\n\n    if s[0] == \"0\" or s[-1] == \"1\":\n        print((-1))\n        return()\n\n    s = s[:-1]\n    n = len(s)\n    for i in range(n):\n        if s[i] != s[n-1-i]:\n            print((-1))\n            return\n\n    pool = []\n    idx = 0\n    for i in range(1, n):\n        if s[i] == \"1\":\n            print((idx+1, i+1))\n            idx = i\n            for pi in pool:\n                print((idx+1, pi+1))\n            pool = []\n        else:\n            pool.append(i)\n    print((n, n+1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input()\nn = len(s)\nif s[0] == \"0\" or s[-1] == \"1\":\n    print((-1))\n    return\nfor i in range(n//2+1):\n    if s[i] != s[-2-i]:\n        print((-1))\n        return\n\nprint((1,2))\nnow = 2\nfor i in range(1,n-1):\n    if s[i] == \"0\":\n        print((now,i+2))\n    else:\n        print((now,i+2))\n        now = i+2\n", "s = input()\nn = len(s)\n\nif s[n - 1] == '1' or s[0] == '0':\n    print(-1)\n    return\n\nfor i in range(n):\n    if s[i] != s[n - i - 2]:\n        print(-1)\n        return\n\ncur_s = 2\ncur_p = 2\nprint(1, 2)\nfor i in range(n - 2):\n    if s[i + 1] == '1':\n        print(cur_s + 1, cur_p)\n        cur_p = cur_s + 1\n    else:\n        print(cur_s + 1, cur_p)\n    cur_s += 1", "import sys\nsys.setrecursionlimit(2147483647)\nINF=float(\"inf\")\nMOD=10**9+7\ninput=lambda:sys.stdin.readline().rstrip()\ndef resolve():\n    S=[None]+list(map(int,input()))\n    n=len(S)-1\n\n    # check\n    if(not (S[1]==1 and S[n-1]==1)):\n        print(-1)\n        return\n    if(S[n]==1):\n        print(-1)\n        return\n    if(any(S[i]!=S[n-i] for i in range(1,n-1))):\n        print(-1)\n        return\n\n    v=1\n    nv=2\n    for i in range(n-1,0,-1):\n        print(v,nv)\n        nv+=1\n        if(S[i]==1): v=nv-1\nresolve()", "\n\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\n\n\n\"\"\"\ni=1\u306f\u7d76\u5bfeok\uff0e\u8449\u3092\u7e4b\u3050\u8fba\u3092\u53d6\u308c\u3070\u826f\u3044\ni=N\u306fNG\uff0e\u3082\u3068\u3082\u3068N\u8981\u7d20\u306a\u306e\u3067\n\u3053\u308c\uff0ci=0\u306e\u6642ng\u3068\u3044\u3046\u6761\u4ef6\u3092\u8db3\u305b\u3070\uff0c\u5de6\u53f3\u5bfe\u8c61\u307d\u3044\uff0e\u30b5\u30a4\u30ba\u304ca\u3068N-a\u304c\u3067\u304d\u308b\u305f\u3081\uff0e\n\n\u300c\u3089\u3057\u3044\u300d\u5fc5\u8981\u6761\u4ef6\u304c\u5206\u304b\u3063\u305f\uff0e\u5fc5\u8981\u5341\u5206\u3060\u3068\u5b09\u3057\u3044\uff0e\nO(N)\u306b\u8fd1\u3044\u611f\u3058\u3067\u89e3\u304d\u305f\u3044\u306e\u3067\uff0c\u9806\u6b21\u69cb\u7bc9\u3057\u3066\u3044\u304f\u30a4\u30e1\u30fc\u30b8\uff0e\n\n\"\"\"\ndef main():\n    mod=10**9+7\n    S=input()\n    N=len(S)\n    \n    if S[0]==\"0\" or S[-1]==\"1\":\n        print((-1))\n        return\n    \n    S=S[:-1]\n    flag=1\n    for i in range(N-1):\n        if S[i]!=S[-1-i]:\n            flag=0\n            \n    if flag==0:\n        print((-1))\n        return\n    \n    L=[(1,2)]\n    head=2\n    now=3\n    for s in S[1:]:\n        L.append((head,now))\n        if s==\"1\":\n            head=now\n        now+=1\n    \n    for a in L:\n        print((' '.join(map(str, a))))\n        \n\nmain()\n", "import sys\n\nreadline = sys.stdin.readline\nMOD = 10 ** 9 + 7\nINF = float('INF')\nsys.setrecursionlimit(10 ** 5)\n\n\ndef main():\n    S = \"*\" + input()\n    N = len(S) - 1\n\n    if S[N] == \"1\":\n        return print(-1)\n    if S[1] == \"0\":\n        return print(-1)\n\n    edge = []\n    cur_u = 1\n    cur_v = 2\n\n    for i in range(1, N // 2 + 1):\n        if S[i] != S[N - i]:\n            return print(-1)\n\n        edge.append([cur_u, cur_v])\n        if S[i] == \"1\":\n            cur_u = cur_v\n        cur_v += 1\n\n    for i in range(cur_v, N + 1):\n        edge.append([cur_u, i])\n\n    for i in range(N - 1):\n        print(*edge[i])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    s=input()\n    n=len(s)\n    res = []\n    if s[0]==\"0\" or s[-1] == \"1\":\n        print(-1)\n        return 1\n    m=n//2\n    t=m\n    for i in range(m,0,-1):\n        if s[i-1] != s[n-i-1]:\n            print(-1)\n            return 1\n        if i == m:\n            if s[i-1]==\"1\":\n                res.append([m,m+1])\n                for j in range(m+2,n+1):\n                    res.append([m+1,j])\n            else:\n                for j in range(m+1,n+1):\n                    res.append([m,j])\n        else:\n            if s[i-1]==\"1\":\n                res.append([t,i])\n                t=i\n            else:\n                res.append([t,i])\n    for sres in res:\n        print(\" \".join(map(str, sres)))\n\n\nmain()", "s = input()\nif(s[0]=='0')|(s[-1]=='1'):\n    print(-1)\n    return\n\nn = len(s)\nsize = []\nfor i in range(1,n//2):\n    sl = s[i]\n    sr = s[n-2-i]\n    if(sl != sr):\n        print(-1)\n        return\n    if(sl=='1'):\n        size.append(i+1)\n\nsize.append(n-1)\nans = []\nnow = 1\nfor si in size:\n    for j in range(now+1,si+2):\n        ans.append(' '.join(map(str,[now,j])))\n    now = si+1\n\nprint('\\n'.join(ans))", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\ndef main():\n    S = input()\n    N = len(S)\n    if S[0] == '0' or S[-1] == '1':\n        print(-1)\n        return\n    cnt = 0\n    flag = True\n    for i in range(N - 1):\n        if S[i] != S[N - i - 2]:\n            flag = False\n            break\n        if S[i] == '1':\n            cnt += 1\n    if not flag:\n        print(-1)\n        return\n    \n    edge = []\n    for i in range(cnt):\n        edge.append((i + 1,i + 2))\n    \n    extend = 0\n    now = cnt + 2\n    vertex = 2\n    for i in range(1,N - 1):\n        if S[i] == '0':\n            extend += 1\n        else:\n            for _ in range(extend):\n                edge.append((vertex,now))\n                now += 1\n            extend = 0\n            vertex += 1\n\n    if now == N + 1:\n        print('\\n'.join(' '.join(map(str,a)) for a in edge))\n    else:\n        print(-1)\ndef __starting_point():\n    main()\n__starting_point()", "printn = lambda x: print(x,end='')\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nins = lambda : input().strip()\nDBG = True # and False\nBIG = 10**18\nR = 10**9 + 7\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\ns = ins()\nn = len(s)\ns = '0'+s\nif s[1]=='0' or s[n]=='1':\n    print(-1)\n    return\nfor i in range(1,n):\n    if s[i]!=s[n-i]:\n        print(-1)\n        return\ne = []\np = 1\nfor i in range(2,n+1):\n    if s[i]=='1' or i==n:\n        for j in range(p,i):\n            e.append((j,i))\n        p = i\nfor z in e:\n    print(\"{} {}\".format(z[0],z[1]))\n", "import sys\ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))  #\u7a7a\u767d\u306a\u3057\n\n\nS = LI2()\nn = len(S)\n\nif S[-1] == 1 or S[0] == 0 or S[-2] == 0:\n    print((-1))\n    return\n\nfor i in range(n-1):\n    if S[i] != S[-2-i]:\n        print((-1))\n        return\n\n\nk = S.count(1)  # 1\u306e\u500b\u6570\nfor i in range(k):\n    print((i+1,i+2))\n\na = 1  # \u4ed8\u3051\u8db3\u3059\u8fba\u306e\u7aef\u70b9\nb = k+2  # \u4ed8\u3051\u8db3\u3059\u9802\u70b9\u306eindex\nfor i in range(n-1):\n    if S[i] == 1:\n        a += 1\n    else:\n        print((a,b))\n        b += 1\n", "import sys\ninput = sys.stdin.readline\n\nS = '-' + input().rstrip()\nN = len(S) - 1\n\ndef solve(S):\n    if S[1] == '0':\n        print((-1))\n        return\n    if S[N] == '1':\n        print((-1))\n        return\n    prev = 1\n    graph = []\n    for n in range(1,N//2 + 1):\n        if S[n] != S[N-n]:\n            return None\n        if S[n] == '0':\n            continue\n        for i in range(prev,n):\n            graph.append('{} {}'.format(i,n))\n        prev = n\n    for i in range(prev,N):\n        graph.append('{} {}'.format(i,N))\n    return graph\n\ngraph = solve(S)\n\nif graph is None:\n    print((-1))\nelse:\n    print(('\\n'.join(graph)))\n", "s = [int(i) for i in input()]\n    \nif s[0] == 0 or s[-1] == 1 :\n    print(-1)\n    \nelse :\n    s.pop()\n    if s != s[::-1] :\n        print(-1)\n        \n    else :\n        org = 1\n        for i in range((len(s) + 1) // 2) :\n            if s[i] == 1 :\n                for j in range(org + 1, i + 3) :\n                    print(org, j)\n                org = i + 2\n        for i in range(org + 1, len(s) + 2) :\n            print(org, i)", "s = list(input())\nn = len(s)\nif s[-1] == \"1\":\n    print((-1))\n    return\nif s[:-1] != s[:-1][::-1]:\n    print((-1))\n    return\nif s[0] == \"0\":\n    print((-1))\n    return\n\nbefore = -1\nfor i in range(n // 2):\n    if s[i] == \"1\":\n        num = i - before\n        for j in range(num):\n            print((before+2, i+2-j))\n        before = i\n\nfor j in range(n-2-before):\n    print((before+2, before+3+j))\n\n\n\n\n\n", "def main():\n    s=input()\n    n=len(s)\n    if s[n-1]==\"1\" or s[0]==\"0\":\n        print(-1)\n        return 0\n    for i in range(n//2):\n        if s[i]!=s[n-i-2]:\n            print(-1)\n            return 0\n    t=[]\n    now=1\n    for i in range(n//2-1):\n        t.append([now,i+2])\n        if s[i]==\"1\":\n            now=i+2\n    t2=[[i+n//2,j+n//2] for i,j in t]\n    if s[n//2-1]==\"1\":\n        t.append([now,now+n//2])\n    else:\n        for i in range(len(t2)):\n            if t2[i][0]==now+n//2:\n                t2[i][0]=now\n            if t2[i][1]==now+n//2:\n                t2[i][1]=now\n        t.append([now,now+n//2])\n    if n%2==1:\n        t.append([now,n])\n    t+=t2\n    for i,j in t:\n        print(i,j)\nmain()", "S = input()\n\ndef check(S):\n    size = len(S)\n    if S[0]==\"0\" or S[-1]==\"1\":\n        return False\n    else:\n        for i in range(size-1):\n            a, b = i, size-i-2\n            if (S[a]==\"1\" and S[b]==\"0\") or (S[a]==\"0\" and S[b]==\"1\"):\n                return False\n        return True\n\nif check(S):\n    N = len(S)\n    l = [1]\n    p = False\n    for i in range(2, N+1):\n        if p:\n            l.append(i)\n            if S[i-1]==\"1\":\n                p = True\n            else:\n                p = False\n        else:\n            print(l[-1], i)\n            if S[i-1]==\"1\":\n                p = True\n    sl = len(l)\n    for i in range(sl-1):\n        print(l[i], l[i+1])\nelse:\n    print(-1)", "S=input()\nN=len(S)\nif S[-1]==\"1\":\n    print(-1)\n    return\nif S[0]==\"0\":\n    print(-1)\n    return\nif S[-2]==\"0\":\n    print(-1)\n    return\nfor i in range(N-1):\n    if S[i]!=S[N-2-i]:\n        print(-1)\n        return\nans=[]\nnowzero=0\nfor i in range(N):\n    if S[i]==\"0\":\n        break\n    nowzero+=1\nif nowzero==N-1:\n    for i in range(1,N):\n        print(i,i+1)\n    return\nans.append((1,2))\nfor i in range(N-2):\n    if S[i]==\"1\":\n        if i!=N-2 and S[i+1]==\"0\":\n            nowzero=i+2\n        ans.append((i+2,i+3))\n    else:\n        ans.append((nowzero,i+3))\nfor line in ans:\n    print(line[0],line[1])", "import sys\ninput = sys.stdin.readline\ns = list(map(int, list(input())[: -1]))\nif s[0] == 0 or s[-1] == 1:\n  print(-1)\n  return\nn = len(s)\nfor i in range(n - 1):\n  if s[i] != s[-2 - i]:\n    print(-1)\n    return\nres = []\ntemp = []\ns[-1] = 1\nfor i in range(n):\n  if s[i] == 0 or i == 0:\n    temp.append(i + 1)\n  else:\n    if len(res):\n      p = res[-1][0]\n      res.append((i + 1, p))\n    if len(temp):\n      while len(temp):\n        res.append((i + 1, temp.pop()))\nfor _ in range(len(res)):\n  print(*res.pop())", "import bisect, copy, heapq, math, sys\nfrom collections import *\nfrom functools import lru_cache\nfrom itertools import accumulate, combinations, permutations, product\ndef input():\n    return sys.stdin.readline()[:-1]\ndef ruiseki(lst):\n    return [0]+list(accumulate(lst))\ndef celi(a,b):\n    return -(-a//b)\nsys.setrecursionlimit(5000000)\nmod=pow(10,9)+7\nal=[chr(ord('a') + i) for i in range(26)]\ndirection=[[1,0],[0,1],[-1,0],[0,-1]]\n\ns=list(map(int,list(input())))\nn=len(s)\n# print(s)\nif s[-1]==1 or s[0]==0:\n    print((-1))\n    return\n\nfor i in range(n-1):\n    if s[i]!=s[-2-i]:\n        print((-1))\n        return\ns[-1]=1\nnow=n\nfor i in range(n-1)[::-1]:\n    print((i+1,now))\n    if s[i]==1:\n        now=i+1\n"]
["from functools import reduce\nfrom math import gcd\n\ndef survivor(a):\n    \"\"\"Round Robin by Bocker & Liptak\"\"\"\n    def __residue_table(a):\n        n = [0] + [None] * (a[0] - 1)\n        for i in range(1, len(a)):\n            d = gcd(a[0], a[i])\n            for r in range(d):\n                try:\n                    nn = min(n[q] for q in range(r, a[0], d) if n[q] is not None)\n                except ValueError:\n                    continue\n                for _ in range(a[0] // d):\n                    nn += a[i]\n                    p = nn % a[0]\n                    if n[p] is not None: nn = min(nn, n[p])\n                    n[p] = nn\n        return n\n\n    a.sort()\n    if len(a) < 1 or reduce(gcd, a) > 1: return -1\n    if a[0] == 1: return 0\n    return max(__residue_table(a)) - a[0]", "# a1, a2, a3, ... are the zombies numbers\n# For a number x to be represented as a sum of those zombies, it means n-a1 or n-a2 or n-a3 or ... has to be represented\n# From that, we can dynamically find if a number is representable (function \"represent\")\n# \n# an is the biggest zombie number\n# If x is represented, then x + an is represented too\n# Wich means we can divide numbers from 0 into groups of size an\n# If the element i of a group is representable, then it will still be in the next group\n# \n# If the kth group is the same as the (k-1)th group, then it means no new number is representable\n# In this case, there will be an infinite number of survivors\n# \n# If all number in the kth are representable, then it means the biggest non-representable number was in the previous group\n# So we just find the biggest non-representable number of the previous group\n# \n# After an iterations of this, either we found there are infinites survivors\n# Or we already filled the group (since they have a size of an)\n\nfrom functools import lru_cache\n\ndef survivor(zombies):\n    if not zombies: return -1\n    nums = sorted(zombies)\n    represent = lru_cache(maxsize=None)(lambda x: not x or any(represent(x-y) for y in nums[::-1] if x >= y))\n    maxi = nums[-1]\n    current = [0]*maxi\n    for x in range(0, maxi**2, maxi):\n        temp = [current[i] or represent(x+i) for i in range(maxi)]\n        if temp == current: return -1\n        if all(temp):\n            y = next(i for i,v in enumerate(current[::-1]) if not v)\n            return max(0, x-y-1)\n        current = temp", "def gcd(a,b): #Just a simple Euclidean algorithm to compute gcd\n    while (b != 0):\n      a,b = b,a%b\n    return a\n\n\n\ndef survivor(zombies):\n\n    if (len(zombies) == 0): #First let's deal with lists of length == 0\n        return -1\n\n    zombies.sort()    #Then let's sort the list\n    if zombies[0] == 1:    #If zombie[0] is 1, we know every number will be biten\n        return 0  \n    \n    ####################################################################\n    #Let's check if there is an infinity of solutions.                 #\n    #It is equivalent to see if gcd of all numbers is different from 1.#\n    ####################################################################\n    \n    zombies_gcd = 0\n    for z in zombies:\n        zombies_gcd = gcd(z,zombies_gcd)\n    if zombies_gcd != 1:\n        return -1\n    \n    ####################################################################\n    #Now let's list every number to see who's the last one to be bitten#\n    ####################################################################\n    \n    length = zombies[-1] + 1\n    who_is_bitten = [False for i in range(length)]\n    \n\n    for z in zombies:    #Of courses zombies are considered as bitten\n        who_is_bitten[z] = True        \n    \n    i = zombies[0] - 1    #We know that zombies[0]-1 is a survivor so we can begin by that number\n    \n    #We keep track of the number of consecutive zombies\n    consecutive_zombies = 0\n    \n\n    while (consecutive_zombies < zombies[0]): #we know if there are zombies[0] consecutive zombies in a row, \n                                              #then there won't be any survivor after that\n        if not(who_is_bitten[i]):         #If the number is not bitten, then it becomes the new last survivor\n            result = i\n            consecutive_zombies = 0\n        else:         #Otherwise, it bites other numbers which are at range\n            consecutive_zombies += 1\n            while (i + zombies[-1] >= len(who_is_bitten)): #if the list is too short we have to add new numbers\n                who_is_bitten.append(False)\n    \n            for z in zombies:\n                who_is_bitten[i + z] = True  #Then number i bites numbers that are at its range\n        \n        i += 1\n        \n    return result", "from fractions import gcd\nfrom functools import reduce\nfrom itertools import count\n\ndef survivor(l):\n    if 1 in l: return 0\n    if len(l) < 2 or reduce(gcd,l) > 1: return -1\n    if len(l) == 2: return (l[0]-1)*(l[1]-1)-1\n    m,t,r,w=[True],0,0,max(l)\n    for i in count(1):\n        m = m[-w:] + [any(m[-n] for n in l if len(m)>=n)]\n        if not m[-1]: t,r = i,0\n        else: r += 1\n        if r == w: break\n    return t", "import bisect\nfrom operator import itemgetter\nfrom itertools import groupby\n\ndef survivor(zombies):\n    if(1 in zombies):\n        return 0\n    gcdl = False\n    for i in zombies:\n        if(gcdl==True):\n            break\n        for x in zombies:\n            if(i!=x and gcd(i,x)==1):\n                gcdl = True\n                break\n    if(gcdl == False):\n        return -1\n    if(len(zombies)==2):\n        return zombies[0]*zombies[1]-zombies[0]-zombies[1]\n    \n    zombies.sort()\n    c = zombies.copy()\n    e = [1]\n    l = max(c)\n    N = len(c)\n    y=0\n    F = zombies[0]*zombies[1]+zombies[0]\n    \n    for i in range(1,F):\n        #print(e)\n        x = 0\n        for j in range(0,N):\n            if(i>=c[j]):\n                x+=e[i-c[j]]\n        e.append(x)\n        e[i] = x\n        if(x==0):\n            y=i\n        \n    return y\n\ndef gcd(a,b):\n    # if a and b are both zero, print an error and return 0\n    if a == 0 and b == 0:\n        #print(\"WARNING: gcd called with both arguments equal to zero.\",\n        #file=sys.stderr)\n        return 0\n    # make sure a and b are both nonnegative\n    if a < 0: a = -a\n    if b < 0: b = -b\n    while b != 0:\n        new_a = b\n        new_b = a % b\n        a = new_a\n        b = new_b\n    return a", "import math\ndef survivor(zombies):\n    size = len(zombies)\n    if size == 0:\n        return -1\n    if (1 in zombies):\n        return 0\n\n    gcd = zombies[0]\n    for i in range(len(zombies) - 1):\n        gcd = math.gcd(gcd, zombies[1 + i])\n    if gcd != 1:\n        return -1\n\n    maxSize = (zombies[0] * zombies[1]) - zombies[0] - zombies[1]\n    posible = [False for _ in range(maxSize + 1)]\n    posible[0] = True\n\n\n    for zombie in zombies:\n        if zombie <= maxSize:\n            for i in range(zombie, maxSize + 1):\n                if not posible[i]:\n                    posible[i] = posible[i - zombie]\n    largest = 0\n    for i in range(maxSize + 1):\n        if not posible[i]:\n            largest = i\n    return largest", "import math\nfrom heapq import *\nfrom itertools import combinations\n\ndef closure_gen(s):\n    keys,seen=set(s),set(s)\n    q=sorted(seen)\n    while q:\n        curr=heappop(q)\n        for next in filter(lambda v:not v in seen, [curr+i for i in keys]):\n            heappush(q,next)\n            seen.add(next)\n        yield curr\ndef gcd(s):\n    if len(s)==0:return -1\n    if len(s)==1:return s[0]\n    res,*s=s\n    while s:\n        n,*s=s\n        res=math.gcd(res,n)\n    return res        \n    \ndef survivor(zombies):\n    zombies=sorted(set(zombies))\n    if not zombies: return -1\n    if 1 in zombies: return 0\n    if gcd(zombies)>1: return -1\n    g=closure_gen(zombies)\n    curr=loop=big=0\n    zmin=min(zombies)\n    while loop<zmin:\n        prev,curr=curr,next(g)\n        if prev+1==curr:\n            loop+=1\n        else:\n            print(loop,curr)\n            loop=0\n            big=curr-1\n    return big        ", "from math import gcd\nfrom functools import reduce\nimport heapq\n\ndef gcd2(xs): return reduce(gcd, xs, xs[0])\n\ndef gen(xs):\n    seen = set()\n    q = list(sorted(xs))\n    while True:\n        curr = heapq.heappop(q)\n        yield curr\n        for x in xs:\n            t = curr + x\n            if t not in seen:\n                heapq.heappush(q, t)\n                seen.add(t)\n\n\ndef survivor(xs):\n    if 1 in xs: return 0\n    if not xs or gcd2(xs) > 1: return -1\n    i, cnt, m = 0, 1, min(xs)\n    g = gen(xs)\n    for x in g:\n        if x != i + cnt: cnt, i = 1, x\n        else: cnt += 1\n        if cnt >= m: break\n    return i - 1\n\n", "import math\nimport functools\n\ndef survivor(zombies):\n    zombies.sort()\n    if not zombies: return -1\n    divisor = functools.reduce(math.gcd, zombies)\n    if divisor > 1:\n        return -1\n    \n    A = zombies\n    Q = [0]\n    P = [len(zombies)] + ([None] * (A[0] - 1))\n    S = [0]\n    a = [A[0] * A[len(A) - 1]] * (A[0] - 1)\n    S = S + a\n    Amod = list(map(lambda x : x % A[0], A))\n    while len(Q) > 0 :\n        v = Q[0]\n        Q.pop(0)\n        for j in range(2, P[v] + 1):\n            u = v + Amod[j - 1]\n            if u >= A[0]:\n                u = u - A[0]\n            w = S[v] + A[j - 1]\n            if w < S[u]:\n                S[u] = w\n                P[u] = j\n                if u not in Q:\n                    Q.append(u)\n    if (int(max(S)) - A[0]) < 0 :\n        return 0\n    return int(max(S)) - A[0]", "import math\ndef survivor(zombies):\n    if zombies == []:\n        return -1\n    if do_gcd(zombies) !=1:\n        return -1\n    if min(zombies) == 1:\n        return 0\n    if len(zombies) == 2:\n        return do_lcm(zombies) - sum(zombies)\n    a = sorted(zombies)\n    a1 = a[0]\n    k = len(a)\n    inf = math.inf\n    n = [0]\n    for i in range(1, a1):\n        n.append(inf)\n    for i in range(1, k):\n        d = math.gcd(a1, a[i])\n        for r in range(d):\n            nn = inf\n            for q in range(a1):\n                if (q % d) == r:\n                    nn = min(nn, n[q])\n            if nn < inf:\n                for j in range(int(a1/d) - 1):\n                    nn = nn + a[i]\n                    p = nn % a1\n                    nn = min(nn, n[p])\n                    n[p] = nn\n    return max(n) - a1\n\ndef do_gcd(array):\n    if len(array) == 1:\n        return array[0]\n    if len(array) == 2:\n        return math.gcd(array[0], array[1])\n    return math.gcd(array[0], do_gcd(array[1:]))\n\ndef do_lcm(array):\n    return int(array[0]*array[1]/math.gcd(array[0], array[1]))"]
["from itertools import combinations_with_replacement \nfrom collections import deque\n\n#sys.stdin = open(\"input_py.txt\",\"r\")\n\nn, m = map(int, input().split())\nG = [ [] for i in range(n)]\n\nfor i in range(m):\n    x, y = map(int, input().split())\n    x-=1; y-=1\n    G[x].append(y)\n    G[y].append(x)\n\ndef BFS(s):\n    dist = [-1 for i in range(n)]\n    dist[s] = 0\n    Q = deque()\n    Q.append(s)\n    while len(Q) > 0:\n        v = Q.popleft()\n        for to in G[v]:\n            if dist[to] < 0:\n                dist[to] = dist[v] + 1\n                Q.append(to)\n    return dist \n\n\nDist = [BFS(i) for i in range(n)]\n\ns1, t1, l1 = map(int, input(). split())\ns2, t2, l2 = map(int, input(). split())\ns1-=1; t1-=1; s2-=1; t2-=1\nif Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n    print(-1)\n    return\n\nrest = Dist[s1][t1] + Dist[s2][t2]\n\nfor i in range(n):\n    for j in range(n):\n        if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2 :\n            rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n        if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2 :\n            rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\nprint(m-rest)", "import sys\nfrom collections import deque\n\nn, m = [int(i) for i in sys.stdin.readline().split()]\nneighbors = [set() for _ in range(n)]\nfor i in range(m):\n    m1, m2 = [int(i) for i in sys.stdin.readline().split()]\n    neighbors[m1-1].add(m2-1)\n    neighbors[m2-1].add(m1-1)\n\ns1, t1, l1 = [int(i) for i in sys.stdin.readline().split()]\ns2, t2, l2 = [int(i) for i in sys.stdin.readline().split()]\ns1 -= 1\ns2 -= 1\nt1 -= 1\nt2 -= 1\n\n# compute all pairs distance\ndists = [[0 for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    # bfs\n    q = deque([(i, 0)])\n    visited = [False for _ in range(n)]\n    visited[i] = True\n    while len(q) != 0:\n        v, dist = q.popleft()\n        dists[i][v] = dist\n        for neighbor in neighbors[v]:\n            if not visited[neighbor]:\n                q.append((neighbor, dist+1))\n                visited[neighbor] = True\n\nbest_found = m+1\n# first case: 2 paths don't share edge\nif dists[s1][t1] <= l1 and dists[s2][t2] <= l2:\n    best_found = min(best_found, dists[s1][t1] + dists[s2][t2])\n\n# second case: there are points u, v such that they share path along u-v\nfor u in range(n):\n    for v in range(n):\n        if u == v:\n            continue\n        # case 1: s1-u-v-t1, s2-u-v-t2\n        path1_length = dists[s1][u] + dists[u][v] + dists[v][t1]\n        path2_length = dists[s2][u] + dists[u][v] + dists[v][t2]\n        if path1_length <= l1 and path2_length <= l2:\n            total_length = path1_length + path2_length - dists[u][v]\n            best_found = min(best_found, total_length)\n        # case 2: s1-u-v-t1, s2-v-u-t2\n        path1_length = dists[s1][u] + dists[u][v] + dists[v][t1]\n        path2_length = dists[s2][v] + dists[v][u] + dists[u][t2]\n        if path1_length <= l1 and path2_length <= l2:\n            total_length = path1_length + path2_length - dists[u][v]\n            best_found = min(best_found, total_length)\n        # case 3: s1-v-u-t1, s2-u-v-t2\n        path1_length = dists[s1][v] + dists[v][u] + dists[u][t1]\n        path2_length = dists[s2][u] + dists[u][v] + dists[v][t2]\n        if path1_length <= l1 and path2_length <= l2:\n            total_length = path1_length + path2_length - dists[u][v]\n            best_found = min(best_found, total_length)\n        # case 4: s1-v-u-t1, s2-v-u-t2\n        path1_length = dists[s1][v] + dists[v][u] + dists[u][t1]\n        path2_length = dists[s2][v] + dists[v][u] + dists[u][t2]\n        if path1_length <= l1 and path2_length <= l2:\n            total_length = path1_length + path2_length - dists[u][v]\n            best_found = min(best_found, total_length)\n\nprint(m - best_found)\n"]
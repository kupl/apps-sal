["class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        N = len(A)\n        if L+M>N:\n            return -1\n\n\n        def findmax(L,M):    \n            sL = [sum(A[:L])]\n            for i in range(L,N-M):\n                tmp = sL[-1]+A[i]-A[i-L]\n                sL.append(tmp)\n            sLmax = [sL[0]]\n            for i in range(1,len(sL)):\n                if sL[i]>sLmax[-1]:\n                    sLmax.append(sL[i])\n                else:\n                    sLmax.append(sLmax[-1])\n\n            sM = [sum(A[-M:])]\n            for i in range(N-M-1,L-1,-1):\n                tmp = sM[-1]+A[i]-A[i+M]\n                sM.append(tmp)\n            sMmax = [sM[0]]\n            for i in range(1,len(sM)):\n                if sM[i]>sMmax[-1]:\n                    sMmax.append(sM[i])\n                else:\n                    sMmax.append(sMmax[-1])\n\n            sMax = [sum(x) for x in zip(sLmax, sMmax[::-1])]\n            m = max(sMax)\n\n            return m\n\n        if L == M:\n            return findmax(L,M)\n        else:\n            return max(findmax(L,M), findmax(M,L))", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        prefix_sum = [0] * (len(A) + 1)\n        for i in range(len(A)): prefix_sum[i+1] = prefix_sum[i] + A[i]\n        maxM = maxL = result = 0\n        \n        for i in range(M, len(prefix_sum) - L):\n            # optimal for L-list start at i+1 and occur after M-list\n            maxM = max(maxM, prefix_sum[i] - prefix_sum[i-M])\n            result = max(result, maxM + prefix_sum[i+L] - prefix_sum[i])\n            \n        for i in range(L, len(prefix_sum) - M):\n            # optimal for M-list start at i+1 and occur after L-list\n            maxL = max(maxL, prefix_sum[i] - prefix_sum[i-L])\n            result = max(result, maxL + prefix_sum[i+M] - prefix_sum[i])\n            \n        return result", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        sub_L = [sum(A[i:i+L]) for i in range(len(A)-L+1)]\n        sub_M = [sum(A[i:i+M]) for i in range(len(A)-M+1)]\n        \n        # let p be the index of sub_L, and q be the index of sub_M.\n        # we require (q+M-1) - (p+L-1) >= M  or (p+L-1) - (q+M-1) >= L.\n        # equivalently: q - p >= L or p - q >= M\n        \n        max_L_M = float('-inf')\n        max_M_L = float('-inf')\n\n        \n        p, q = 0, L\n        while q < len(sub_M):\n            if sub_L[q-L] > sub_L[p]:\n                p = q - L\n            max_L_M = max(max_L_M, sub_M[q] + sub_L[p])\n            q += 1\n        \n        q, p = 0, M\n        while p < len(sub_L):\n            if sub_M[p-M] > sub_M[q]:\n                q = p - M\n            max_M_L = max(max_M_L, sub_L[p] + sub_M[q])\n            p += 1\n\n        return max(max_L_M, max_M_L)", "class Solution:\n    def maxSumTwoNoOverlap(self, arr: List[int], L: int, M: int) -> int:\n        \n        n=len(arr)\n        pre=[arr[0] for i in range(len(arr))]\n        for j in range(1,n):\n            pre[j]=pre[j-1]+arr[j]\n            \n        res1=-1   \n        for i in range(n-(L+M)+1):\n            for k in range(i+L,n-M+1):\n                sum1=pre[i+L-1]-(pre[i-1] if i>0 else 0)\n                sum2=pre[k+M-1]-(pre[k-1] if k>0 else 0)\n                res1=max(res1,sum1+sum2)       \n        res2=-1       \n        for i in range(n-(L+M)+1):\n            for k in range(i+M,n-L+1):\n                sum1=pre[i+M-1]-(pre[i-1] if i>0 else 0)\n                sum2=pre[k+L-1]-pre[k-1]\n                res2=max(res2,sum1+sum2)\n                \n        return max(res1,res2)", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        S = [A[0]]\n        for i in range(1,len(A)): S.append(S[-1] + A[i])\n        \n        def getSum(a,b):\n            sm = 0\n            for i in range(len(A)-a+1):\n                s = S[i+a-1] - (S[i-1] if i > 0 else 0)\n                for j in range(i+a,len(A)-b+1):\n                    sm  = max(sm, s + S[j+b-1] - S[j-1])\n            return sm\n        return max(getSum(L,M),getSum(M,L))\n            \n            \n            \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        prefix = [0] * (len(A) + 1)\n        for i in range(1, len(A) + 1):\n            prefix[i] = prefix[i-1] + A[i-1]\n        def get_subsum(i, j):\n            return prefix[j+1] - prefix[i]\n        # L before M\n        result = 0\n        for i in range(len(A) - L - M + 1):\n            # maxi = len(A) - L - M\n            # maxiend = len(A) - M - 1\n            sub1 = get_subsum(i, i + L - 1)\n            for j in range(i + L, len(A) - M + 1):\n                # minj = L\n                # maxj = len(A) - M\n                # maxjend = len(A) - 1\n                sub2 = get_subsum(j, j + M - 1)\n                result = max(result, sub1 + sub2)\n        # M before L\n        for i in range(len(A) - L - M + 1):\n            sub1 = get_subsum(i, i + M - 1)\n            for j in range(i + M, len(A) - L + 1):\n                sub2 = get_subsum(j, j + L - 1)\n                result = max(result, sub1 + sub2)\n        return result\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        def getMax(p, N):\n            _max = 0\n            for i in range(len(p) - N):\n                _max = max(p[i + N] - p[i], _max)\n            return _max\n\n        pre = [ 0 ]  * (len(A) + 1)\n        for i in range(0, len(A)):\n            pre[i + 1] = pre[i] + A[i]\n        _max = 0\n        for i in range(len(A) - max(L, M)):\n            _max = max(getMax(pre[:i+L+1], L) + getMax(pre[i+L:], M), _max)\n        for i in range(len(A) - max(L, M)):\n            _max = max(getMax(pre[:i+M+1], M) + getMax(pre[i+M:], L), _max)\n        return _max\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        tl = sum(A[:L])\n        ll = [tl]\n        for i in range(L,len(A)):\n            tl-=A[i-L]\n            tl+=A[i]\n            ll.append(tl)\n        print(ll)\n        tl = sum(A[:M])\n        ml = [tl]\n        for i in range(M,len(A)):\n            tl-=A[i-M]\n            tl+=A[i]\n            ml.append(tl)\n        print(ml)\n        maxx = 0\n        for i in range(len(ll)):\n            for j in range(len(ml)):\n                if i+L-1<j or j+M-1<i:\n                    maxx = max(maxx, ll[i]+ml[j])\n        return maxx", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        tl = sum(A[:L])\n        ll = [tl]\n        for i in range(L,len(A)):\n            tl-=A[i-L]\n            tl+=A[i]\n            ll.append(tl)\n        # print(ll)\n        tl = sum(A[:M])\n        ml = [tl]\n        for i in range(M,len(A)):\n            tl-=A[i-M]\n            tl+=A[i]\n            ml.append(tl)\n        # print(ml)\n        maxx = 0\n        for i in range(len(ll)):\n            for j in range(len(ml)):\n                if i+L-1<j or j+M-1<i:\n                    maxx = max(maxx, ll[i]+ml[j])\n        return maxx", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        start=0\n        end=L\n        t=sum(A[start:end])\n        maxs=0\n        while end<len(A)+1:\n            pin1=0\n            end1=M\n            tot=sum(A[pin1:end1])\n            while end1<start+1:\n                #print(pin1,end1,t,tot,'yo')\n                if t+tot>maxs:\n                    maxs=t+tot\n                tot=tot-A[pin1]\n                tot=tot+A[end1]\n                pin1+=1\n                end1+=1\n            pin2=end\n            end2=end+M\n            tot2=sum(A[pin2:end2])\n            while end2<=len(A):\n                #print(pin2,end2,t,tot2,'po')\n                if t+tot2>maxs:\n                    maxs=t+tot2\n                if end2==len(A):\n                    break\n                tot2=tot2-A[pin2]\n                tot2=tot2+A[end2]\n                pin2+=1\n                end2+=1\n            if end==len(A):\n                break\n            t=t-A[start]\n            t=t+A[end]\n            start+=1\n            end+=1\n            #print(t,maxs)\n        return maxs\n                \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        NA = len(A)\n        N1, N2 = max(L, M), min(L, M)\n        sum_window = [[0]*NA for _ in range(2)]\n        sum1 = sum2 = max_sum = 0\n        for i, v in enumerate(A):\n            if i >= N1:\n                sum1 -= A[i-N1]\n            if i >= N2:\n                sum2 -= A[i-N2]\n            sum1 += v\n            sum2 += v\n            sum_window[0][i] = sum1\n            sum_window[1][i] = sum2\n            \n            if i >= N1:\n                for j in range(i-N1+1):\n                    max_sum = max(max_sum, sum_window[0][i]+sum_window[1][j])\n                for j in range(i-N2+1):\n                    max_sum = max(max_sum, sum_window[1][i]+sum_window[0][j])\n                \n        return max_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        n = len(A)\n        \n        arr = [A[0]]\n        for i in range(1, n):\n            arr.append(arr[-1] + A[i])\n        arr = arr + [0]\n        \n        _max = 0\n        for i in range(n - L + 1):\n            for j in range(n - M + 1):\n                if (i <= j <= i + L - 1) or (j <= i <= j + M - 1):\n                    continue\n                tmp = (arr[i + L - 1] - arr[i - 1]) + (arr[j + M - 1] - arr[j - 1])\n                _max = max(_max, tmp)\n        return _max", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        n = len(A)\n        \n        run_sum = [0] * (n+1)\n        cur_sum = 0\n        \n        for i in range(1, n+1):\n            cur_sum += A[i-1]\n            run_sum[i] = cur_sum\n        \n        ans = 0\n        for i in range(1, n - L + 2):\n            L_sum = run_sum[i+L-1] - run_sum[i-1]\n            for j in range(1, n - M + 2):\n                if i+L-1 < j or j+M-1 < i:\n                    M_sum = run_sum[j+M-1] - run_sum[j-1]\n                    ans = max(ans, L_sum + M_sum)\n        return ans\n        \n        \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        dpA = self.sumArray(A, L)\n        dpB = self.sumArray(A, M)\n        print(dpA)\n        print(dpB)\n        max_v = 0\n        for i in range(len(dpA)):\n            for m in range(len(dpB)):\n                if m >= i and m - i < L:\n                    continue\n                if i >= m and i - m < M:\n                    continue\n                max_v = max(max_v, dpA[i] + dpB[m])\n        return max_v\n        \n        \n    def sumArray(self, lst, length):\n        result = []\n        for i in range(len(lst) - length + 1):\n            sub_sum = lst[i]\n            for m in range(1, length):\n                sub_sum += lst[i + m]\n            result.append(sub_sum)\n        return result", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        space=len(A)-L-M\n        maxx=0\n        for i in range(1,space+2):\n            a=0\n            b=L-1\n            c=b+i\n            d=c+M-1\n            leftSum=sum(A[a:b+1])\n            rightSum=sum(A[c:d+1])\n            while d<len(A):\n                maxx=max(maxx,leftSum+rightSum)\n                a+=1\n                b+=1\n                c+=1\n                d+=1\n                if d<len(A):\n                    leftSum-=A[a-1]\n                    leftSum+=A[b]\n                    rightSum-=A[c-1]\n                    rightSum+=A[d]\n        maxx2=0\n        for i in range(1,space+2):\n            a=0\n            b=M-1\n            c=b+i\n            d=c+L-1\n            leftSum=sum(A[a:b+1])\n            rightSum=sum(A[c:d+1])\n            while d<len(A):\n                maxx2=max(maxx2,leftSum+rightSum)\n                a+=1\n                b+=1\n                c+=1\n                d+=1\n                if d<len(A):\n                    leftSum-=A[a-1]\n                    leftSum+=A[b]\n                    rightSum-=A[c-1]\n                    rightSum+=A[d]\n            \n        return max(maxx,maxx2)\n                    \n                \n            \n            \n\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        dl = {}\n        dm = {}\n        \n        if M > L:\n            M,L = L,M\n        \n        ls = sum(A[0:L])\n        ms = sum(A[0:M])\n        \n        dl[(0,L-1)] = ls\n        dm[(0,M-1)] = ms\n        \n        c = 0\n        while c + L < len(A):\n            ls -= A[c]\n            ls += A[L+c]\n            \n            #print(0+c,ls,L+c,A[c],A[L+c])\n            \n            dl[(0+c+1,L+c)] = ls\n            c += 1\n        \n        c = 0\n        while c + M < len(A):\n            ms -= A[c]\n            ms += A[M+c]\n            dm[(0+c+1,M+c)] = ms\n            c += 1\n            \n        dll = sorted(list(dl.items()),key=lambda x:x[1],reverse=True)\n        mll = sorted(list(dm.items()),key=lambda x:x[1],reverse=True)\n        \n        #print(dll,mll)\n        \n        f = -1\n        for x in dll:\n            lower = x[0][0]\n            upper = x[0][1]\n            val = x[1]\n            \n            for y in mll:\n                ly = y[0][0]\n                uy = y[0][1]\n                yval = y[1]\n                \n                \n                \n                if lower <= ly <= upper or lower <= uy <= upper:\n                    continue\n                maxVal = yval + val\n                \n                if maxVal == 125:\n                    print(lower,upper,ly,uy)\n                    print(x,y)\n                \n                f = max(maxVal,f)\n                \n        return f", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        max_two_sum = 0        \n        N = len(A)\n        def maxOverlap(arr: List[int]) -> int:\n            n = len(arr)\n            if n < L:\n                return -1 \n            roll_max = 0\n            \n            for i in range(L):\n                roll_max += arr[i]\n            curr_max = roll_max    \n            \n            start = 0\n            for n in arr[L:]:\n                roll_max = roll_max-arr[start] + n\n                curr_max = max(curr_max, roll_max)\n                start += 1\n            return curr_max\n\n        for x in range(N):\n            curr_total = sum(A[x:x+M])\n            first_half = maxOverlap(A[:x])\n            second_half = maxOverlap(A[x+M:])\n            max_two_sum = max(max_two_sum, curr_total + first_half, curr_total + second_half)\n       \n        return max_two_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        maxi = 0\n        n = len(A)\n        for i in range(1,n):\n            A[i] += A[i-1]\n        for i in range(n-L+1):\n            for j in range(n-M+1):\n                if (i>=j and i-j < M) or (i < j and j-i < L):\n                    continue\n                else:\n                    istart = A[i-1] if i>0 else 0\n                    jstart = A[j-1] if j>0 else 0\n                    temp = A[i+L-1] - istart + A[j+M-1] - jstart\n                    maxi = max(maxi,temp)\n        return maxi\n            \n", "from functools import reduce\n\nclass Solution:\n        \n    \n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        lsum = []\n               \n        csum = reduce(lambda a,b:a+b, A[:L]) \n        lsum.append(csum)\n        \n        for i in range(L, len(A)):\n            csum += A[i] - A[i-L]\n            lsum.append(csum)\n            \n        msum = []\n        csum = reduce(lambda a,b:a+b, A[:M])\n            \n        msum.append(csum)\n        \n        for i in range(M, len(A)):\n            csum += A[i] - A[i-M]\n            msum.append(csum)\n            \n        maxSum = 0\n        for i in range(len(A)-L+1):\n            ls = i\n            le = i + L - 1\n            \n            for j in range(len(A) - M+1):\n                ms = j\n                me = j + M - 1\n                \n                if (le < ms) or (me < ls):\n                    maxSum = max(maxSum, lsum[ls] + msum[ms])\n                    \n        return maxSum    ", "class Solution:\n    \n    def maxSumTwoNoOverlap(self, A, L, M):\n        for i in range(1, len(A)):\n            A[i] += A[i - 1]\n        res, Lmax, Mmax = A[L + M - 1], A[L - 1], A[M - 1]\n        for i in range(L + M, len(A)):\n            Lmax = max(Lmax, A[i - M] - A[i - L - M])\n            Mmax = max(Mmax, A[i - L] - A[i - L - M])\n            res = max(res, Lmax + A[i] - A[i - M], Mmax + A[i] - A[i - L])\n        return res", "import sys\nclass Solution:\n    \n    def is_overlap(self,i,j,L,M):\n        if len(set(range(i,i+L)) & set(range(j,j+M))) > 0:\n            return True\n        else:\n            return False\n        \n        \n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        max_two_sum = 0        \n        N = len(A)\n        def maxOverlap(arr: List[int]) -> int:\n            n = len(arr)\n            if n < L:\n                return -1 \n            roll_max = 0\n            \n            for i in range(L):\n                roll_max += arr[i]\n            curr_max = roll_max    \n            \n            start = 0\n            for n in arr[L:]:\n                roll_max = roll_max-arr[start] + n\n                curr_max = max(curr_max, roll_max)\n                start += 1\n            return curr_max\n\n        for x in range(N):\n            curr_total = sum(A[x:x+M])\n            first_half = maxOverlap(A[:x])\n            second_half = maxOverlap(A[x+M:])\n            max_two_sum = max(max_two_sum, curr_total + first_half, curr_total + second_half)\n       \n        return max_two_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        max_found = 0\n        sums = {}\n        self.sumsOfL(A, L, sums)\n        for i in range(len(A) - M + 1):\n            available = self.getAvailableIndices(A, L, M, i)\n            current_sum = sum(A[i:i+M])\n            for j in available:\n                max_found = max(max_found, sums[j] + current_sum)\n        return max_found\n        \n    def getAvailableIndices(self, A, L, M, i):\n        available = []\n        for j in range(len(A) - L + 1):\n            if j < i - L or j >= i + M:\n                available.append(j)\n        return available\n\n    def sumsOfL(self, A, L, dictionary):\n        left = 0\n        right = L\n        for i in range(len(A) - L + 1):\n            dictionary[left] = sum(A[left:right])\n            left += 1\n            right += 1\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        m_res = [None for i in range(len(A)-M+1)]\n        m = 0\n        for i in range(len(A)-L+1):\n            ts = sum(A[i:i+L])\n            for j in range(len(A)-M+1):\n                if j+M <= i or j >= i+L:\n                    if m_res[j] is None:\n                        m_res[j] = sum(A[j:j+M])\n                    m = max(m, ts+m_res[j])\n        return m", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        '''\n        O(n^2)\n        '''\n        \n            \n        long = L if L > M else M\n        short = M if M < L else L\n        \n        global_max = 0\n        for i in range(0, len(A)-long+1):\n            temp1 = sum(A[i:i+long])\n            # subA = A[:i] + A[i+long:]\n            # check left part\n            left = A[:i]\n            right = A[i+long:]\n            if len(left) >= short:\n            # check right part\n                for j in range(0, len(left)-short+1):\n                    temp2 = sum(left[j:j+short])\n                    if temp1 + temp2 > global_max:\n                        global_max = temp1 + temp2\n            if len(right) >= short:\n                for j in range(0, len(right)-short+1):\n                    temp2 = sum(right[j:j+short])\n                    if temp1 + temp2 > global_max:\n                        global_max = temp1 + temp2\n            \n        return global_max", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        # Let's try a relatively naive solution first.\n        # Compute the cumsums. Let cumsum(k) be the cumsum upto and incl. A[k]\n        # Now, V(i,j) = cumsum(i+L-1) - cumsum(i-1) + cumsum(j+M-1) - cumsum(j-1)\n        # With i and j satisfying the constraints.\n        # Then we simply have to maximize this value over all possible values of i and j\n        # subject to the constraint.\n        \n        n = len(A)\n        # Corner cases\n        if L + M == n:\n            return sum(A)\n        \n        # We'll use array with cumsum[k] equivalent to cumsum(k-1) being the cumsum of the first\n        # k elements (i.e. upto and including A[k-1]). A[0] = 0, being the cumsum of the first zero elements.\n        cumsum = [0]*(n+1)\n        for i in range(n):\n            cumsum[i+1] = cumsum[i] + A[i]\n            \n        def good_combo(i, j):\n            # Return True <=> L-length subarray at i intersects with M-length subarry starting at j\n            return i+L-1 < j or j+M-1 < i\n            \n        res = -float('inf')\n        for i in range(n-L+1):\n            for j in range(n-M+1):\n                if good_combo(i, j):\n                    res = max(res, cumsum[i+L] - cumsum[i] + cumsum[j+M] - cumsum[j])\n        return res\n                \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        maxi = 0\n        n = len(A)\n        dp = {}\n        dp[(0,L)] = sum(A[0:L])+sum(A[L:L+M])\n        dp[(M,0)] = sum(A[0:M])+sum(A[M:L+M])\n        for i in range(n-L+1):\n            for j in range(n-M+1):\n                if (i>=j and i-j < M) or (i < j and j-i < L):\n                    continue\n                else:\n                    if (i,j-1) in dp:\n                        dp[(i,j)] = dp[(i,j-1)] - A[j-1] + A[j+M-1]\n                    elif (i-1,j) in dp:\n                        dp[(i,j)] = dp[(i-1,j)] - A[i-1] + A[i+L-1]\n                    maxi = max(maxi,dp[(i,j)])\n        return maxi\n            \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        acc=[0]+[*itertools.accumulate(A)]\n        def getmaxfrom(i, x):\n            return max(acc[j+x]-acc[j] for j in range(i,len(acc)-x))\n            # s = 0\n            # res = 0\n            # for j in range(i, len(A)):\n            #     s+=A[j]\n            #     if j-i==x:\n            #         s-=A[i]\n            #         i+=1\n            #     res = max(res, s)\n            # return res\n        \n        ans = 0\n        s = 0\n        i = 0\n        for j in range(len(A)-M):\n            s+=A[j]\n            if j-i == L:\n                s-=A[i]\n                i+=1\n            ans = max(ans, s + getmaxfrom(j+1, M))\n        \n        s = 0\n        i = 0\n        for j in range(len(A)-L):\n            s+=A[j]\n            if j-i == M:\n                s-=A[i]\n                i+=1\n            ans = max(ans, s + getmaxfrom(j+1, L))\n        return ans", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        l=len(A)\n        if L<M:\n            M,L=L,M\n        # L \u5927\n        ans=0\n        for i in range(l-L+1):\n            tmp=sum(A[i:i+L])\n            j=0\n            while j<(l-M+1):\n                if i<j+M<i+L:\n                    j=i+L\n                else:\n                    ans=max(ans,tmp+sum(A[j:j+M]))\n                    j+=1\n                    \n        return ans", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        if L + M > len(A):\n            assert False\n        \n        l = []\n        s = 0\n        for i in range(len(A) - L + 1):\n            if i == 0:\n                s = sum(A[:L])\n            else:\n                s -= A[i - 1]\n                s += A[i + L - 1]\n            l.append((-s, (i, i + L - 1)))\n        l = sorted(l, key=lambda tup : tup[0])\n        #print(l)\n        m = []\n        s = 0\n        for i in range(len(A) - M + 1):\n            if i == 0:\n                s = sum(A[:M])\n            else:\n                s -= A[i - 1]\n                s += A[i + M - 1]\n            m.append((-s, (i, i + M - 1)))\n        m = sorted(m, key=lambda tup : tup[0])\n        \n        maximum = 0\n        for i in range(len(l)):\n            for j in range(len(m)):\n                sl, (il, jl) = l[i]\n                sm, (im, jm) = m[j]\n                sl, sm = -sl, -sm\n                if sl + sm > maximum:\n                    if jl < im or jm < il:\n                        maximum = sl + sm\n                else:\n                    break\n        \n        return maximum\n                \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        LList, MList = [], []\n        thisSum = sum(A[:L])\n        LList.append((thisSum, 0))\n        for idx in range(L, len(A)):\n            thisSum += A[idx] - A[idx - L]\n            LList.append((thisSum, idx - L + 1))\n        thisSum = sum(A[:M])\n        MList.append((thisSum, 0))\n        for idx in range(M, len(A)):\n            thisSum += A[idx] - A[idx - M]\n            MList.append((thisSum, idx - M + 1))\n        # LList.sort(reverse=True)\n        # MList.sort(reverse=True)\n        allHeap = []\n        for LEle in LList:\n            for MEle in MList:\n                heapq.heappush(allHeap, (- LEle[0] - MEle[0], LEle[1], MEle[1]))\n        while allHeap:\n            twoSum, lidx, midx = heapq.heappop(allHeap)\n            if lidx + L - 1 < midx or midx + M - 1 < lidx:\n                return -twoSum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        def slidingWindow(windowLength):\n            windowMap = {}\n            currSum = sum(A[:windowLength])\n            windowMap[(0, windowLength - 1)] = currSum\n            \n            for i in range(windowLength, len(A)):\n                currSum -= A[i - windowLength]\n                currSum += A[i]\n                windowMap[(i - windowLength + 1, i)] = currSum\n                \n            return windowMap\n                \n        \n        firstWindowMap = slidingWindow(L)\n        secondWindowMap = slidingWindow(M)\n        \n        first = []\n        second = []\n        \n        for x in firstWindowMap:\n            first.append([firstWindowMap[x], x])\n            \n        for x in secondWindowMap:\n            second.append([secondWindowMap[x], x])\n        \n        most = 0\n        \n        for i in range(len(first)):\n            for j in range(len(second)):\n                val1 = first[i][0]\n                val2 = second[j][0]\n                range1 = first[i][1]\n                range2 = second[j][1]\n                r1x = range1[0]\n                r1y = range1[1]\n                r2x = range2[0]\n                r2y = range2[1]\n                if not ((r2x <= r1x <= r2y) or (r1x <= r2x <= r1y)):\n                    most = max(most, val1 + val2)\n                    \n        return most", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        acc=[0]+[*itertools.accumulate(A)]\n        def getmaxfrom(i, x):\n            return max(acc[j+x]-acc[j] for j in range(i,len(acc)-x))\n        \n        ans = 0\n        s = 0\n        i = 0\n        for j in range(len(A)-M):\n            s+=A[j]\n            if j-i == L:\n                s-=A[i]\n                i+=1\n            ans = max(ans, s + getmaxfrom(j+1, M))\n        \n        s = 0\n        i = 0\n        for j in range(len(A)-L):\n            s+=A[j]\n            if j-i == M:\n                s-=A[i]\n                i+=1\n            ans = max(ans, s + getmaxfrom(j+1, L))\n        return ans", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        length = len(A)\n        if length < L + M:\n            return 0\n        if length == L + M:\n            return sum(A)\n        res = 0\n        for i in range(length - L + 1):\n            s1 = sum(A[i:i+L])\n            if i >= M:\n                for j in range(i-M+1):\n                    s2 = sum(A[j:j+M])\n                    if res < s1 + s2:\n                        res = s1 + s2\n                for j in range(i + L, length - M + 1):\n                    s2 = sum(A[j:j+M])\n                    if res < s1 + s2:\n                        res = s1 + s2\n            else:\n                for j in range(i + L, length - M + 1):\n                    s2 = sum(A[j:j+M])\n                    if res < s1 + s2:\n                        res = s1 + s2\n        return res\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        if not A:\n            return 0\n        \n        n = len(A)\n      \n\n        m_sum = 0\n        for i in range(n-L+1):\n            i_sum = sum(A[i:i+L])\n            for j in range(i+L, n-M+1):\n                m_sum = max(m_sum, (i_sum + sum(A[j:j+M])))\n            for j in range(i-M+1):\n                m_sum = max(m_sum, (i_sum + sum(A[j:j+M])))\n        \n        return m_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        n = len(A)\n        out = 0\n        for i in range(n-L + 1):\n            l = sum(A[i:i+L])\n            m = [sum(A[j:j+M]) for j in range(i + L, n-M+1)\n                 ] + [sum(A[j:j+M]) for j in range(i-M)]\n            if l and m:\n                out = max(out, l + max(m))\n\n        return out", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        max_sum = 0\n        \n        @lru_cache\n        def _calculateSumFromIndex(i, length):\n            return sum(A[i:i+length])\n        \n        for l in range(len(A)-L+1):\n            l_sum = _calculateSumFromIndex(l, L)\n            if l >= M:\n                for m in range(0, l-M+1):\n                    m_sum = _calculateSumFromIndex(m, M)\n                    max_sum = max(max_sum, l_sum+m_sum)\n            if len(A) - l+1 >= M:\n                for m in range(l+L, len(A)-M+1):\n                    m_sum = _calculateSumFromIndex(m, M)\n                    max_sum = max(max_sum, l_sum+m_sum)\n        return max_sum\n        \n                \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        def findMaxSum(A: List[int], L: int, M: int) -> int:\n            max_num = 0\n            for i in range(len(A)-L):\n                L_slice = A[i:L+i]\n                L_sum = sum(L_slice)\n                for j in range(L+i,len(A)-M+1):\n                    M_slice = A[j:M+j]\n                    M_sum = sum(M_slice)\n                    max_num = max(L_sum + M_sum, max_num)\n            return max_num\n        \n        forwards_sum = findMaxSum(A,L,M)\n        A.reverse()\n        backwards_sum = findMaxSum(A,L,M)\n        return max(forwards_sum,backwards_sum)\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        N = len(A)\n        \n        res = 0\n        for i in range(N - L + 1):\n            l_sum = sum(A[i:i + L])\n            for j in list(range(i-M+1)) + list(range(i+L, N-M+1)):\n                res = max(res, l_sum + sum(A[j:j + M]))\n        return res", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        if not A:\n            return 0\n        \n        ldp = [0 for i in range(len(A))]\n        mdp = [0 for j in range(len(A))]\n        \n        sum_l = sum(A[len(A)-L:])\n        for i in range(len(A)-L, -1, -1):\n            sum_l = max(sum_l, sum(A[i:i+L]))\n            ldp[i] = sum_l\n                \n        sum_m = sum(A[len(A)-M:])\n        for i in range(len(A)-M, -1, -1):\n            sum_m = max(sum_m, sum(A[i:i+M]))\n            mdp[i] = sum_m\n                \n        print(ldp)\n        print(mdp)\n                \n        ret = float('-inf')\n        \n        for i in range(len(A)-L-M+1):\n            ret = max(ret, sum(A[i:i+L]) + mdp[i+L], sum(A[i:i+M]) + ldp[i+M])\n        \n        return ret", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        def findMaxSum(A: List[int], L: int, M: int) -> int:\n            max_num = 0\n            for i in range(len(A)-L):\n                L_slice = A[i:L+i]\n                L_sum = sum(L_slice)\n                for j in range(L+i,len(A)-M+1):\n                    M_slice = A[j:M+j]\n                    M_sum = sum(M_slice)\n                    max_num = max(L_sum + M_sum, max_num)\n            return max_num\n        \n        forwards_sum = findMaxSum(A,L,M)\n        A.reverse()\n        backwards_sum = findMaxSum(A,L,M)\n        return max(forwards_sum,backwards_sum)", "from typing import List\n\n\nclass Solution:\n\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        def findMaxSum(A, L, M):\n            max_sum = 0\n\n            for i in range(len(A) - L):\n                L_slice = A[i: L + i]\n                L_sum = sum(L_slice)\n\n                for j in range(L + i, len(A) - M + 1):\n                    M_slice = A[j: M + j]\n                    M_sum = sum(M_slice)\n\n                    max_sum = max(max_sum, L_sum + M_sum)\n            return max_sum\n\n        forward_sum = findMaxSum(A, L, M)\n        A.reverse()\n        backward_sum = findMaxSum(A, L, M)\n\n        return max(forward_sum, backward_sum)\n\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        def findMaxSum(A,L,M):\n            max_num = 0\n            for i in range(len(A)-L):\n                L_slice = A[i:L+i]\n                L_sum = sum(L_slice)\n                for j in range(L+i,len(A)-M+1):\n                    M_slice = A[j:M+j]\n                    M_sum = sum(M_slice)\n                    max_num = max(L_sum + M_sum, max_num)\n            return max_num\n        forwards_sum = findMaxSum(A,L,M)\n        A.reverse()\n        backwards_sum = findMaxSum(A,L,M)\n        return max(forwards_sum,backwards_sum)", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        def findMaxSum(A: List[int], L: int, M: int) -> int:\n            max_num = 0\n            for i in range(len(A)-L):\n                L_slice = A[i:L+i]\n                L_sum = sum(L_slice)\n                for j in range(L+i,len(A)-M+1):\n                    M_slice = A[j:M+j]\n                    M_sum = sum(M_slice)\n                    max_num = max(L_sum + M_sum, max_num)\n            return max_num\n        \n        forwards_sum = findMaxSum(A,L,M)\n        A.reverse()\n        backwards_sum = findMaxSum(A,L,M)\n        return max(forwards_sum,backwards_sum)\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        def find_maxsum(arr,l,m):\n            max_sum = 0\n            for i in range(len(arr)-l):\n                l_slice = arr[i:i+l]\n                l_sum = sum(l_slice)\n                for j in range(i+l,len(arr)-m+1):\n                    m_slice = arr[j:j+m]\n                    m_sum = sum(m_slice)\n                    max_sum = max(max_sum, l_sum+m_sum)\n            return max_sum\n        def maximum_sum(arr, l, m):\n            rev_arr = list(reversed(arr))\n            return max(find_maxsum(arr,l,m), find_maxsum(rev_arr,l,m))\n        return maximum_sum(A,L,M)", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        def traversal(A, L, M):\n            maxi = 0\n            for i in range(len(A)-L):\n                L_slice = A[i:L+i]\n                L_sum = sum(L_slice)\n                \n                for j in range(L+i,len(A)-M+1):\n                    M_slice = A[j:M+j]\n                    M_sum = sum(M_slice)\n                    \n                    maxi = max(maxi, L_sum+M_sum)\n            return maxi\n        forwards_sum = traversal(A,L,M)\n        A.reverse()\n        backwards_sum = traversal(A,L,M)\n        return max(forwards_sum,backwards_sum)\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        S = [0] * (len(A) + 1)\n        for i in range(1, len(A)+1):\n            S[i] += S[i-1] + A[i-1]\n        \n        lmax, rmax = 0, 0\n        for j in range(L, len(S)-M):\n            lmax = max(lmax, S[j] - S[j-L])\n            rmax = max(rmax, S[j+M] - S[j] + lmax)\n            \n        \n        lmax2, rmax2 = 0, 0\n        for j in range(M, len(S)-L):\n            lmax2 = max(lmax2, S[j] - S[j-M])\n            rmax2 = max(rmax2, S[j+L] - S[j] + lmax2)\n        \n        return max(rmax, rmax2)", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n      \n      l_subarray_sums = [sum(A[i:i + L]) for i in range(0, len(A) - L + 1)]\n      m_subarray_sums = [sum(A[i:i + M]) for i in range(0, len(A) - M + 1)]\n      \n      max_sum = 0\n      for i, l_subarray_sum in enumerate(l_subarray_sums):\n        if not m_subarray_sums[i + L:]:\n          continue\n        \n        \n        max_complement = max(m_subarray_sums[i + L:])\n        \n        if l_subarray_sum + max_complement > max_sum:\n          max_sum = l_subarray_sum + max_complement\n          print(f'l sum : {l_subarray_sum} | m sum : {max_complement}')\n        \n      for i, m_subarray_sum in enumerate(m_subarray_sums):\n        if not l_subarray_sums[i + M:]:\n          continue\n          \n        max_complement = max(l_subarray_sums[i + M:])\n        \n        if m_subarray_sum + max_complement > max_sum:\n          max_sum = m_subarray_sum + max_complement\n          print(f'm sum : {m_subarray_sum} | m sum : {max_complement}')\n        \n      return max_sum", "from functools import reduce\nclass Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        def leftRight(lst, l, m):\n            presum = reduce(lambda cum, cur: cum + [cur + cum[-1]], lst, [0])\n            res = float('-inf')\n            curL = presum[l]\n            mxL = float('-inf')\n            \n            for i in range(l+m-1, len(lst)):\n                if i > l + m - 1:\n                    curL = curL - lst[i - (l+m)] + lst[i-m]\n                    \n                mxL = max(mxL, curL)\n                res = max(res, mxL + presum[i+1] - presum[i-m+1])\n            \n            return res\n        \n        return max(leftRight(A, L, M), leftRight(A[::-1], L, M))\n\n    # better: fix the middle part, keep track of the max of the left and right part of the middle part.\n\n    # def maxSumTwoNoOverlap(self, A, L, M):\n    #     for i in xrange(1, len(A)):\n    #         A[i] += A[i - 1]\n    #     res, Lmax, Mmax = A[L + M - 1], A[L - 1], A[M - 1]\n    #     for i in xrange(L + M, len(A)):\n    #         Lmax = max(Lmax, A[i - M] - A[i - L - M])\n    #         Mmax = max(Mmax, A[i - L] - A[i - L - M])\n    #         res = max(res, Lmax + A[i] - A[i - M], Mmax + A[i] - A[i - L])\n    #     return res\n                \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        M_sum_greater_than = [0]*len(A)\n        M_sum_smaller_than = [0]*len(A)\n        \n        prefix_sum = [A[0]]\n        for n in A[1:]:\n            prefix_sum.append(prefix_sum[-1]+n)\n        \n        for i in range(M-1, len(A)):\n            if i < M: M_sum_smaller_than[i] = max(M_sum_smaller_than[i-1], prefix_sum[i])\n            else: \n                M_sum_smaller_than[i] = max(M_sum_smaller_than[i-1], prefix_sum[i]-prefix_sum[i-M])\n        \n        for j in range(len(A)-M, -1, -1):\n            if j == 0: M_sum_greater_than[j] = max(M_sum_greater_than[j+1], prefix_sum[j+M-1])\n            else: M_sum_greater_than[j] = max(M_sum_greater_than[min(j+1, len(A)-1)], prefix_sum[j+M-1]-prefix_sum[j-1])\n        \n        max_sum = 0\n        for start in range(len(A)-L+1):\n            if start == 0: sum_L = prefix_sum[start+L-1]\n            else: sum_L = prefix_sum[start+L-1] - prefix_sum[start-1]\n            \n            if start-1 >= M-1:\n                max_sum = max(max_sum, sum_L + M_sum_smaller_than[start-1])\n            if start+L <= len(A)-M:\n                max_sum = max(max_sum, sum_L + M_sum_greater_than[start+L])\n            \n        return max_sum\n        \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        i=0\n        maxL = []\n        maxM = []\n        maxSum = 0\n        \n        while i<=len(A)-L:\n            maxL.append(sum(A[i:i+L]))\n            i+=1\n            \n        i = 0\n        while i<=len(A)-M:\n            maxM.append(sum(A[i:i+M]))\n            i+=1\n\n        for i,elem in enumerate(maxL):\n            if i-M<=0:\n                prefix = []\n            else:\n                prefix = maxM[0:i-M]\n            \n            if len(maxM[i+L:]+prefix)== 0:\n                continue\n            maxSum = max(maxSum,elem+max(prefix+maxM[i+L:]))\n        \n        return maxSum        ", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        prefix_sum = [0] * (len(A)+1)\n        for i in range(len(A)): prefix_sum[i+1] = prefix_sum[i] + A[i]\n        maxL = maxM = result = 0\n        \n        for i in range(M, len(prefix_sum) - L):\n            # optimal when L-list start at i+1 and occur after M-list\n            maxM = max(maxM, prefix_sum[i] - prefix_sum[i-M])\n            result = max(result, maxM + prefix_sum[i+L] - prefix_sum[i])\n        \n        for i in range(L, len(prefix_sum) - M):\n            # optimal when M-list start at i+1 and occur after L-list\n            maxL = max(maxL, prefix_sum[i] - prefix_sum[i-L])\n            result = max(result, maxL + prefix_sum[i+M] - prefix_sum[i])\n        \n        return result", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        L, M = min(L, M), max(L, M)\n        \n        lSums = [0] * len(A)\n        mSums = [0] * len(A)\n        \n        lSums[L-1] = sum(A[:L])\n        mSums[M-1] = sum(A[:M])\n        \n        for i in range(L, len(A)):\n            lSums[i] = lSums[i-1] + A[i] - A[i-L]\n        \n        for i in range(M, len(A)):\n            mSums[i] = mSums[i-1] + A[i] - A[i-M]\n            \n        print(lSums)\n        print(mSums)\n        \n        greatest = 0\n        for i in range(L-1, len(A)-M):\n            greatest = max(greatest, max(lSums[:i+1]) + max(mSums[i+M:]))\n        \n        for i in range(M-1, len(A)-L):\n            greatest = max(greatest, max(mSums[:i+1]) + max(lSums[i+L:]))\n            \n        return greatest", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        if L + M > len(A):\n            return 0\n        max_end = [0 for i in range(len(A))]\n        max_start = [0 for i in range(len(A))]\n        \n        def max_sum(L, M):\n            sum1, sum2, max_sum1, max_sum2, max_sum = 0, 0, 0, 0, 0\n            for i in range(len(A)):\n                max_sum2 = max(sum2, max_sum2)\n                max_start[len(A)-i-1] = max_sum2\n                if i >= L:\n                    sum1 -= A[i-L]\n                if i >= M:\n                    sum2 -= A[len(A)-i+M-1]\n                sum1 += A[i]\n                sum2 += A[len(A)-1-i]\n                max_sum1 = max(sum1, max_sum1)\n                max_end[i] = max_sum1\n            for i in range(L-1, len(A)-M):\n                max_sum = max(max_sum, max_end[i]+max_start[i])\n            return max_sum\n        \n        return max(max_sum(L, M), max_sum(M, L))\n                    \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        n = len(A)\n        dp1,dp2 = [0]*n,[0]*n\n        \n        for i in range(n-L+1):\n            if i==0: dp1[i] = sum(A[i:i+L])\n            else: dp1[i] = dp1[i-1]+A[i+L-1]-A[i-1]\n        \n        maxy = 0\n        for i in range(n-M+1):\n            if i==0: dp2[i] = sum(A[i:i+M])\n            else: dp2[i] = dp2[i-1]+A[i+M-1]-A[i-1]\n                \n            if i>=L: maxy = max(maxy,dp2[i]+max(dp1[:i-L+1]))\n            if i+M<n: maxy = max(maxy,dp2[i]+max(dp1[i+M:]))\n        \n        return maxy\n        \n        # maxy = 0\n        # for a,b,d1,d2 in [(L,M,dp1,dp2), (M,L,dp2,dp1)]:\n        #     i,j = 0,n-b\n        #     while i+a<j:\n        #         maxy = max(maxy,d1[i]+d2[j])\n        #         if d1[i+1]>d1[i]: i+=1\n        #         else: j-=1\n        # print(L,dp1)\n        # print(M,dp2)\n        # return maxy\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        dp = [[0, 0, 0] for _ in range(len(A))]\n        L, M = min(L, M), max(L, M)\n        l_sum, m_sum = 0, 0\n        for idx in range(L + M):\n            if idx <= L - 1:\n                l_sum += A[idx]\n                if idx == L - 1:\n                    dp[idx][0] = l_sum\n            else:\n                l_sum += A[idx] - A[idx - L]\n                dp[idx][0] = l_sum if dp[idx - 1][0] < l_sum else dp[idx - 1][0]\n            if idx <= M - 1:\n                m_sum += A[idx]\n                if idx == M - 1:\n                    dp[idx][1] = m_sum\n            else:\n                m_sum += A[idx] - A[idx - M]\n                dp[idx][1] = m_sum if dp[idx - 1][1] < m_sum else dp[idx - 1][1]              \n        dp[L + M - 1][2] = max(l_sum + dp[idx - L][1], m_sum + dp[idx - M][0])\n        for idx in range(L + M, len(A)):\n            l_sum += A[idx] - A[idx - L]\n            dp[idx][0] = l_sum if dp[idx - 1][0] < l_sum else dp[idx - 1][0]\n            m_sum += A[idx] - A[idx - M]\n            dp[idx][1] = m_sum if dp[idx - 1][1] < m_sum else dp[idx - 1][1]\n            print((idx, l_sum, m_sum, dp[idx - L], dp[idx - M]))\n            dp[idx][2] = max(dp[idx - 1][2], l_sum + dp[idx - L][1], m_sum + dp[idx - M][0])\n        print(dp)\n        return dp[len(A) - 1][2]\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        seg_sum_l = []\n        seg_sum_m = []\n        cum_sum = [0]\n        n = len(A)\n        for i, a in enumerate(A):\n            cum_sum.append(a + cum_sum[-1])\n            if i >= L-1:\n                seg_sum_l.append(cum_sum[i+1] - cum_sum[i-L+1])\n            else:\n                seg_sum_l.append(-1)\n            if i >= M-1:\n                seg_sum_m.append(cum_sum[i+1] - cum_sum[i-M+1])\n            else:\n                seg_sum_m.append(-1)\n        \n        max_sum = -1\n        for i in range(L-1, n):\n            for j in range(M-1, i-L):\n                cur_sum = seg_sum_l[i] + seg_sum_m[j]\n                if cur_sum > max_sum:\n                    max_sum = cur_sum\n            for j in range(i+M, n):\n                cur_sum = seg_sum_l[i] + seg_sum_m[j]\n                if cur_sum > max_sum:\n                    max_sum = cur_sum\n        \n        return max_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        largestSum = 0\n        LList, MList = [0] * len(A), [0] * len(A)\n        thisSum = sum(A[:L])\n        LList[0] = thisSum\n        for idx in range(len(A) - L):\n            thisSum += A[idx + L] - A[idx]\n            LList[idx + 1] = thisSum\n        thisSum = sum(A[:M])\n        MList[0] = thisSum\n        for idx in range(len(A) - M):\n            thisSum += A[idx + M] - A[idx]\n            MList[idx + 1] = thisSum\n        for idx in range(len(A) - M + 1):\n            largestSum = max(largestSum, MList[idx] + max([0] + LList[:max(0, idx - L + 1)] + LList[idx + M:]))\n        return largestSum", "from functools import reduce\nclass Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        def leftRight(lst, l, m):\n            presum = reduce(lambda cum, cur: cum + [cur + cum[-1]], lst, [0])\n            res = float('-inf')\n            curL = presum[l]\n            mxL = float('-inf')\n            \n            for i in range(l+m-1, len(lst)):\n                if i > l + m - 1:\n                    curL = curL - lst[i - (l+m)] + lst[i-m]\n                    \n                mxL = max(mxL, curL)\n                res = max(res, mxL + presum[i+1] - presum[i-m+1])\n            \n            return res\n        \n        return max(leftRight(A, L, M), leftRight(A[::-1], L, M))\n                \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        Lsum = [(sum(A[:L]), 0)]\n        Msum = [(sum(A[:M]), 0)]\n        for i in range(1, len(A) - L + 1):\n            Lsum.append((Lsum[-1][0] - A[i-1] + A[i+L-1], i))\n        for i in range(1, len(A) - M + 1):\n            Msum.append((Msum[-1][0] - A[i-1] + A[i+M-1], i))\n        Lsum.sort(reverse=True)\n        Msum.sort(reverse=True)\n        ret = sum(A[:L+M])\n        for li in range(len(Lsum)):\n            breakFlag = True\n            for mi in range(len(Msum)):\n                if (Lsum[li][1] <= Msum[mi][1] and Lsum[li][1] + L > Msum[mi][1]) or (Msum[mi][1] <= Lsum[li][1] and Msum[mi][1] + M > Lsum[li][1]):\n                    breakFlag = False\n                    continue\n                ret = max(ret, Lsum[li][0] + Msum[mi][0])\n                break\n            if breakFlag:\n                break\n        return ret\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        for i in range(1, len(A)):\n            A[i] += A[i - 1]\n        res, Lmax, Mmax = A[L + M - 1], A[L - 1], A[M - 1]\n        for i in range(L + M, len(A)):\n            Lmax = max(Lmax, A[i - M] - A[i - L - M])\n            Mmax = max(Mmax, A[i - L] - A[i - L - M])\n            res = max(res, Lmax + A[i] - A[i - M], Mmax + A[i] - A[i - L])\n        return res", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        n = len(A)\n        dp = [[0,0] for _ in range(n)]\n        \n        for i in range(L-1,n): # scan from left to right, get all dp[i][0] first\n            if i>0: \n                dp[i][0] = max(dp[i-1][0], sum(A[i-L+1:i+1:+1]))\n            else: dp[i][0] = A[0]\n            \n        for i in range(n-L,-1,-1): # scan from left to right, get all dp[i][0] first\n            if i<n-1: \n                dp[i][1] = max(dp[i+1][1], sum(A[i:i+L:+1]))\n\n            else: dp[i][1] = A[n-1]\n        #print(dp)\n        maximum = float('-inf')\n        # Then for subarray M\n        for i in range(0,n-M+1):\n            s = sum(A[i:i+M:1])\n            left = dp[i-1][0] if i-1>0 else 0\n            right = dp[i+M][1] if i+M<n else 0\n            #print(i,s, left, right)\n            maximum = max(maximum, s+left, s+right)\n        return maximum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        import heapq\n        n = len(A)\n        def get_subsum(L):\n            Lsum = [sum(A[:L])]\n            for i in range(1, n-L+1):\n                Lsum.append(Lsum[i-1] + A[i+L-1] - A[i-1])\n            return [(s, i) for i, s in enumerate(Lsum)]\n        Lsum = get_subsum(L)\n        # print(Lsum)\n        Lsum.sort(reverse=True)\n        Msum = get_subsum(M)\n        # print(Msum)\n        Msum.sort(reverse=True)\n        def overlap(i, j, L=L, M=M):\n            #i, i+L-1\n            #j, j+M-1\n            return j <= i < j+M or i <= j < i + L\n        i = j = 0\n        Llen = len(Lsum)\n        Mlen = len(Msum)\n        visited = set()\n        stack = []\n        heapq.heappush(stack, (0, (0,0)))\n        while stack:\n            _, (i, j) = heapq.heappop(stack)\n            # visited.add((i,j))\n            # print(i, j, Lsum[i], Msum[j])\n            if not overlap(Lsum[i][1], Msum[j][1]):\n                return Lsum[i][0] + Msum[j][0]\n            if i < Llen - 1 and not (i+1, j) in visited:\n                visited.add((i+1,j))\n                heapq.heappush(stack, (-(Lsum[i+1][0] + Msum[j][0]), (i+1, j)))\n            if j < Mlen - 1 and not (i,j+1) in visited:\n                visited.add((i,j+1))\n                heapq.heappush(stack, (-(Lsum[i][0] + Msum[j+1][0]), (i, j+1)))\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        result = 0\n        lsum = sum(A[0:L])\n        msum = sum(A[L:L+M])\n        psum = 0\n        j = 0\n        result = max(result, max(lsum + msum, lsum + psum))\n        # print(lsum, msum, psum, result)\n        prefix = [0]*len(A)\n        for i in range(0, len(A) - M + 1):\n            prefix[i+M-1] = sum(A[i:i+M])\n        # For the first run the below is imp\n        for k in range(L+M-1, len(A)):\n            result = max(result, lsum + prefix[k])\n        for i in range(L, len(A)):\n            lsum = lsum - A[i-L] + A[i]\n            if i+M <= len(A) - 1:\n                for k in range(i+M, len(A)):\n                    result = max(result, lsum + prefix[k])\n            if i-L > M-1:\n                # print(i)\n                for k in range(M-1, i-L):\n                    result = max(result, lsum + prefix[k])\n            # print(lsum, result)\n        return result", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        Len = len(A) + 1\n        prefix = [0] + A\n        maxSum = 0\n        for i in range(1, Len):\n            prefix[i] = prefix[i - 1] + A[i - 1]\n        i = L\n        while i < Len:\n            LSum = prefix[i] - prefix[i - L]\n            j = M\n            while j < i - L:\n                MSum = prefix[j] - prefix[j - M]\n                temp = LSum + MSum\n                if temp > maxSum:\n                    maxSum = LSum + MSum\n                j += 1\n            j = i + M\n            while j < Len:\n                MSum = prefix[j] - prefix[j - M]\n                temp = LSum + MSum\n                if temp > maxSum:\n                    maxSum = temp\n                j += 1\n            i += 1\n        return maxSum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        pref = [0] * (len(A)+1)\n        for i in range(1, len(A)+1):\n            pref[i] = pref[i-1] + A[i-1]\n        l = [0] * (len(A)-L+1)\n        m = [0] * (len(A)-M+1)\n        for i in range(len(A)-L+1):\n            l[i] = pref[i+L] - pref[i]\n        for i in range(len(A)-M+1):\n            m[i] = pref[i+M] - pref[i]\n        ans = 0\n        for i in range(len(l)):\n            for j in range(i-M+1):\n                ans = max(ans, l[i]+m[j])\n            for j in range(i+L, len(A)-M+1):\n                ans = max(ans, l[i]+m[j])\n        return ans\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        n = len(A)\n        res = 0\n        psum = [0] * (n + 1)\n        for i in range(n):\n            psum[i+1] = psum[i] + A[i]\n        for i in range(0, n - L + 1):\n            ls = psum[i+L] - psum[i]\n            lm = max(self._max_m(0, i, M, psum), self._max_m(i+L, n, M, psum))\n            res = max(res, ls + lm)\n        return res\n    \n    def _max_m(self, s, e, M, psum):\n        res = 0\n        for i in range(s, e - M + 1):\n            res = max(res, psum[i+M] - psum[i])\n        return res", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        tmp_sum = sum(A[:L])\n        i = L\n        L_sum = [tmp_sum]\n        while i<len(A):\n            tmp_sum -= A[i-L]\n            tmp_sum += A[i]\n            L_sum.append(tmp_sum)\n            i += 1\n            \n        tmp_sum = sum(A[:M])\n        i = M\n        M_sum = [tmp_sum]\n        while i<len(A):\n            tmp_sum -= A[i-M]\n            tmp_sum += A[i]\n            M_sum.append(tmp_sum)\n            i += 1\n            \n        max_sum = 0\n        # L before M\n        for i, lsum in enumerate(L_sum):\n            for j in range(i+L, len(M_sum)):\n                max_sum = max(max_sum, lsum+M_sum[j])\n                \n        # M before L\n        for i, msum in enumerate(M_sum):\n            for j in range(i+M, len(L_sum)):\n                max_sum = max(max_sum, msum+L_sum[j])\n                \n        return max_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        dp = [[-1, -1] for i in range(len(A))]\n        # print(dp)\n        \n        l = L-1\n        dp[l][0] = sum(A[0:L])\n        l += 1\n        while l < len(A):\n            dp[l][0] = dp[l-1][0] - A[l-L] + A[l]\n            l += 1\n        \n        m = M-1\n        dp[m][1] = sum(A[0:M])\n        m += 1\n        while m < len(A):\n            dp[m][1] = dp[m-1][1] - A[m-M] + A[m]\n            m += 1\n        \n        # dp.sort(reverse=True, key=lambda x: x[0])\n        maxSum = -math.inf\n        \n        for i, sums in enumerate(dp):\n            if sums[0] == -1:\n                continue\n            eligible_M = dp[:i-L+1] + dp[i+M:]\n            # print (sums[0], eligible_M, max(eligible_M, key=lambda x: x[1])[1])\n            maxSum = max(maxSum, sums[0] + max(eligible_M, key=lambda x: x[1])[1])\n        \n        # print(maxSum)\n        # print(dp)\n        return maxSum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        '''\n            2:35\n            # prefix sum  O(n)\n            # for each L subarray:  O(n)\n                check all M subarrays in its left or right, O(n)\n                \n            # O(n^2)\n        '''\n        \n        N = len(A)\n        \n        prefix = [0] * (N+1)  # prefix[i]:  sum(A[0:i]) \n        for i in range(1,N+1):\n            prefix[i] = prefix[i-1] + A[i-1]\n        \n        res = 0\n        for Li in range(N-L+1): # 0..N-L\n            Lj = Li + L # L..N\n            sumL = prefix[Lj] - prefix[Li]\n            sumM = 0 \n            for Mi in range(Lj, N-M+1): # Lj..N-M\n                Mj = Mi + M  # Lj+M..N\n                sumM = max(sumM, prefix[Mj] - prefix[Mi])\n            for Mi in range(0, Li-M+1):\n                Mj = Mi + M\n                sumM = max(sumM, prefix[Mj] - prefix[Mi])\n            res = max(res, sumL+sumM)\n        return res\n            \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        resL = []\n        resM = []\n\n        for i in range(len(A) - L + 1):\n            resL.append(sum(A[i:i + L]))\n        for i in range(len(A) - M + 1):\n            resM.append(sum(A[i:i + M]))\n        print(resL)\n        print(resM)\n        i = 0\n        maxValue = -1\n        while i < len(resL):\n            # right\n            for j in range(i + L, len(resM)):\n                maxValue = max(resL[i] + resM[j], maxValue)\n            for j in range(min(i - M, len(resM))):\n                maxValue = max(resL[i] + resM[j], maxValue)\n            i += 1\n        return maxValue", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        if not A:\n            return 0\n        cumulatedSum = [0] * (len(A) + 1)\n        result = 0\n        for i in range(len(A)):\n            cumulatedSum[i + 1] = cumulatedSum[i] + A[i]\n        # L before M\n        for i in range(len(A) - L + 1):\n            # sum[i: i + L - 1]\n            lSum = cumulatedSum[i + L] - cumulatedSum[i]\n            for j in range(i + L, len(A) - M + 1):\n                # sum[j, j + M -1]\n                mSum = cumulatedSum[j + M] - cumulatedSum[j]\n                result = max(result, lSum + mSum)\n            \n        for i in range(len(A) - M + 1):\n            mSum = cumulatedSum[i + M] - cumulatedSum[i]\n            for j in range(i + M, len(A) - L + 1):\n                lSum = cumulatedSum[j + L] - cumulatedSum[j]\n                result = max(result, lSum + mSum)\n        return result", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        prefixSum = [0]  * (len(A)+1)\n        for i in range(1, len(A)+1):\n            prefixSum[i] = prefixSum[i-1] + A[i-1]\n            \n        # print(prefixSum)\n        # print(M, L)\n        ans = 0\n        for i in range(M-1, len(A)):\n            # print('i', i, i-(M-1))\n            sumM = prefixSum[i+1] - prefixSum[i+1-M]\n            sumL = 0\n            for j in range(L-1, i-(M-1)):\n                sumL = max(sumL, prefixSum[j+1] - prefixSum[j+1-L])\n            # print('sumleft', sumL, L-1, i-(M-1))\n            for j in range(i+1+L-1, len(A)):\n                sumL = max(sumL, prefixSum[j+1] - prefixSum[j+1-L])\n            # print('sumright', sumL)\n            # print('sumM', sumM)\n            ans = max(ans, sumM + sumL)\n        return ans\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        cumsum = []\n        N = len(A)\n        \n        for i in range(N):\n            if i == 0:\n                cumsum.append(A[i])\n            else:\n                cumsum.append(cumsum[i-1]+ A[i])\n            \n        l_sums = []\n        i = 0\n        while(i+L <= N):\n            l_sums.append(cumsum[i+L-1]-cumsum[i] + A[i])\n            i += 1\n            \n        m_sums = []\n        i = 0\n        while(i+M <= N):\n            m_sums.append(cumsum[i+M-1]-cumsum[i] + A[i])\n            i += 1\n            \n#         print(cumsum)\n#         print(l_sums)\n#         print(m_sums)\n        \n        i = 0\n        j = len(m_sums)-1\n        \n        ans = 0\n        \n        for i in range(len(l_sums)):\n            for j in range(i+L,len(m_sums)):\n                curr_sum = l_sums[i] + m_sums[j]\n                ans = max(ans,curr_sum)\n                \n        for i in range(len(m_sums)):\n            for j in range(i+M,len(l_sums)):\n                curr_sum = m_sums[i] + l_sums[j]\n                ans = max(ans,curr_sum)\n        \n        return ans", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        n = len(A)\n        prefix = [0] * (n + 1)\n        res = 0\n        for i in range(0, n):\n            prefix[i + 1] = prefix[i] + A[i]\n        for i in range(0, n - L + 1):\n            l_sum = prefix[i + L] - prefix[i]\n            j, m_sum = i, 0\n            while j - M >= 0:\n                m_sum = max(m_sum, prefix[j] - prefix[j - M])\n                j -= 1\n            j = i + L\n            while j + M <= n:\n                m_sum = max(m_sum, prefix[j + M] - prefix[j])\n                j += 1\n            res = max(res, l_sum + m_sum)\n        return res", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        n, cur_sum, max_sum = len(A), 0, 0\n        max_l = [[0,0] for _ in range(n+2)]\n        \n        for i in range(n):\n            cur_sum += A[i]\n            if i >= L - 1:\n                max_l[i+1][0] = max(max_l[i][0], cur_sum)\n                cur_sum -= A[i-L+1]\n        \n        cur_sum = 0\n        for i in range(n-1, -1, -1):\n            cur_sum += A[i]\n            if i <= n - L:\n                max_l[i+1][1] = max(max_l[i+2][1], cur_sum)\n                cur_sum -= A[i+L-1]\n        \n        cur_sum = 0\n        for i in range(n):\n            cur_sum += A[i]\n            if i >= M - 1:\n                max_sum = max(max_sum, cur_sum + max_l[i-M+1][0], cur_sum + max_l[i+2][1])\n                cur_sum -= A[i-M+1]\n        \n        return max_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        prefixSum = [0]  * (len(A)+1)\n        for i in range(1, len(A)+1):\n            prefixSum[i] = prefixSum[i-1] + A[i-1]\n            \n        ans = 0\n        for i in range(M-1, len(A)):\n            sumM = prefixSum[i+1] - prefixSum[i+1-M]\n            sumL = 0\n            for j in range(L-1, i-(M-1)):\n                sumL = max(sumL, prefixSum[j+1] - prefixSum[j+1-L])\n            for j in range(i+1+L-1, len(A)):\n                sumL = max(sumL, prefixSum[j+1] - prefixSum[j+1-L])\n            ans = max(ans, sumM + sumL)\n        return ans\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        # i think u have to do smaller numbers first because the smaller set is contained within the larger set\n        # returns indices\n        \n        # Greedy does not work; need to do this in n^2 time i think\n#         def solve(size, a):\n#             i= 0\n#             j = i + size\n#             m = [i,j] #max indices\n#             s = sum(a[i:j]) # current sum\n#             max_sum = s # max sum\n#             while(j != len(a)):\n#                 i+=1\n#                 j+=1\n#                 s -= a[i-1]\n#                 s += a[j-1]\n#                 if s > max_sum:\n#                     max_sum = s\n#                     m[0] = i\n#                     m[1] = j\n#             return m, max_sum\n        \n#         m, ms = solve(min(L,M), A)\n#         # print(m, ms)\n#         # A = A[:m[0]] + A[m[1]:]\n#         # print(A)\n#         m2, ms2 = solve(max(L,M), A[:m[0]] + A[m[1]:])\n#         print(m, ms, m2, ms2)\n        \n#         m3, ms3 = solve(max(L,M), A)\n#         m4, ms4 = solve(min(L,M), A[:m3[0]] + A[m3[1]:])\n#         print(m3, ms3, m4, ms4)\n#         return max(ms + ms2, ms3 + ms4)\n\n        # On^2 time too slow\n        # def solve(size1, size2, a):\n        #     # current max\n        #     curr = sum(a[0:0+size1]) + sum(a[size1: size1+size2])\n        #     for i in range(len(a)-size2-size1+1):\n        #         for j in range(i+size1, len(a)):\n        #             temp = sum(a[i:i+size1]) + sum(a[j: j+size2]) # make this faster\n        #             # temp = curr - a[j-1] + a[j+size2]\n        #             # print(temp, i, i + size1, j, j + size2)\n        #             if temp> curr:\n        #                 curr = temp\n        #     return curr\n        # m = solve(L, M, A)\n        # m2 = solve(M, L, A)\n        # return max(m, m2)\n        A = [0] + A\n        for i in range(1,len(A)):\n            A[i] += A[i-1] \n        # print(A[1]-A[0])\n        # print(len(A))\n        def solve(l,m,a):\n            curr = 0\n            # for i in range(len(a)-l-m+1):\n            for i in range(len(a) - l+1):\n                for j in range(i+l,len(a)-m):\n                    # print(i, i+l, j, j+m, a[i+l] - a[i], a[j+m] - a[j])\n                    temp = a[i+l] - a[i] + a[j+m] - a[j]\n                    if temp > curr:\n                        curr = temp\n            return curr\n        \n        m2 = solve(M, L, A)\n        m = solve(L, M, A)\n        # return m2\n        # print(m, m2)\n        return max(m, m2)\n            \n                    \n                \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        N = len(A)\n        \n        # generate prefix sum array\n        prefix = [0] * (N + 1)\n        for i in range(1, N + 1):\n            prefix[i] = prefix[i - 1] + A[i - 1]\n            \n        max_sum = 0\n        for end_l in range(L, N + 1):\n            start_l = end_l - L\n            sum1 = prefix[end_l] - prefix[start_l]\n            \n            for end_m in range(M, start_l):\n                sum2 = prefix[end_m] - prefix[end_m - M]\n                max_sum = max(max_sum, sum1 + sum2)\n            for start_m in range(end_l, N - M + 1):\n                sum2 = prefix[start_m + M] - prefix[start_m]\n                max_sum = max(max_sum, sum1 + sum2)\n            \n        return max_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        sum = [0 for i in range(len(A))]\n        sum[0] = A[0]\n        \n        for i in range(1, len(A)):\n            sum[i] = sum[i-1] + A[i]\n            \n        res = -math.inf\n        # L before M\n        for i in range(len(A) - L):\n            r = -math.inf\n            for j in range(i + L, len(A) - M + 1):\n                r = max(r, sum[j + M - 1] - sum[j-1])\n            r += sum[i + L - 1] - (sum[i-1] if i - 1 > -1 else 0)\n            res = max(res, r)\n        \n        # M before L\n        for i in range(len(A) - M):\n            r = -math.inf\n            for j in range(i + M, len(A) - L + 1):\n                r = max(r, sum[j + L - 1] - sum[j-1])\n            r += sum[i + M - 1] - (sum[i-1] if i - 1 > -1 else 0)\n            res = max(res, r)\n            \n        return res", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        n = len(A)\n        \n        prefix = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix[i+1] = prefix[i] + A[i]\n            \n        maxi = float('-inf')\n        \n        for startL in range(n-L+1):\n            endL = startL + L - 1\n            sumL = prefix[endL+1] - prefix[startL]\n            for startM in range(startL-M+1):\n                endM = startM + M - 1\n                sumM = prefix[endM+1] - prefix[startM]\n                maxi = max(maxi, sumM + sumL)\n            for startM in range(endL+1, n-M+1):\n                endM = startM + M - 1\n                sumM = prefix[endM+1] - prefix[startM]\n                maxi = max(maxi, sumM + sumL)\n                \n                \n        return maxi", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        \n        \n        \n        cumSum = [0]*(len(A)+1)\n        \n        for i,a in enumerate(A):\n            cumSum[i+1] = cumSum[i]+a\n            \n        \n        max_sum = 0\n        for i in range(len(A)-L+1):\n            sum_sub1 = 0\n            sum_sub1 = cumSum[i+L] - cumSum[i]\n            if i >= M:\n                for j in range(i-M+1):\n                    sum_sub2 = 0\n                    sum_sub2 = cumSum[j+M] - cumSum[j]\n                    sum_sub2 = sum_sub1 + sum_sub2\n                    max_sum = max(max_sum, sum_sub2)\n            if i+L <= len(A)-M:\n                for j in range(i+L, len(A)-M+1):\n                    sum_sub2 = 0\n                    sum_sub2 = cumSum[j+M] - cumSum[j]\n                    sum_sub2 = sum_sub1 + sum_sub2\n                    max_sum = max(max_sum, sum_sub2)\n                    \n        return max_sum\n                        \n        \n        \n        \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        n = len(A)\n        \n        prefix = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix[i+1] = prefix[i] + A[i]\n            \n        maxi = float('-inf')\n        for startL in range(n-L+1):\n            endL = startL + L - 1\n            sumL = prefix[endL+1] - prefix[startL]\n            \n            for startM in range(startL+1-M):\n                endM = startM + M - 1\n                sumM = prefix[endM+1] - prefix[startM]\n                maxi = max(maxi, sumL + sumM)\n                \n            for startM in range(endL+1, n-M+1):\n                endM = startM + M - 1\n                sumM = prefix[endM+1] - prefix[startM]\n                maxi = max(maxi, sumL + sumM)\n                \n        \n        return maxi", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        \n        sumL = sum(A[:L])\n        sumM = sum(A[L:(L+M)])\n        res = sumL + sumM\n        for j in range(L+M, len(A)):\n            sumM += A[j]-A[j-M]\n            res = max(res, sumL+sumM)\n        \n        for i in range(L, len(A)):\n            sumL += A[i]-A[i-L]\n            if i-L+1 >= M:\n                sumM = sum(A[:M])\n                res = max(res, sumL+sumM)\n                for j in range(M, i-L+1):\n                    sumM += A[j]-A[j-M]\n                    res = max(res, sumL+sumM)\n            if i <= len(A)-M-1:\n                sumM = sum(A[(i+1):(i+1+M)])\n                for j in range(i+1+M, len(A)):\n                    sumM += A[j]-A[j-M]\n                    res = max(res, sumL+sumM)\n        return res\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        result = 0\n        lsum = sum(A[0:L])\n        msum = sum(A[L:L+M])\n        psum = 0\n        j = 0\n        result = max(result, max(lsum + msum, lsum + psum))\n        # print(lsum, msum, psum, result)\n        prefix = [0]*len(A)\n        for i in range(0, len(A) - M + 1):\n            prefix[i+M-1] = sum(A[i:i+M])\n        for k in range(L+M-1, len(A)):\n            result = max(result, lsum + prefix[k])\n        for i in range(L, len(A)):\n            lsum = lsum - A[i-L] + A[i]\n            if i+M <= len(A) - 1:\n                for k in range(i+M, len(A)):\n                    result = max(result, lsum + prefix[k])\n            if i-L > M-1:\n                # print(i)\n                for k in range(0, i-L):\n                    result = max(result, lsum + prefix[k])\n            # print(lsum, result)\n        return result\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        result = 0\n        lsum = sum(A[0:L])\n        msum = sum(A[L:L+M])\n        psum = 0\n        j = 0\n        result = max(result, max(lsum + msum, lsum + psum))\n        # print(lsum, msum, psum, result)\n        prefix = [0]*len(A)\n        for i in range(0, len(A) - M + 1):\n            prefix[i+M-1] = sum(A[i:i+M])\n        for k in range(L+M-1, len(A)):\n            result = max(result, lsum + prefix[k])\n        for i in range(L, len(A)):\n            lsum = lsum - A[i-L] + A[i]\n            if i+M <= len(A) - 1:\n                for k in range(i+M, len(A)):\n                    result = max(result, lsum + prefix[k])\n            if i-L > M-1:\n                # print(i)\n                for k in range(0, i-L):\n                    result = max(result, lsum + prefix[k])\n            # print(lsum, result)\n        return result", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        result = 0\n        lsum = sum(A[0:L])\n        msum = sum(A[L:L+M])\n        psum = 0\n        j = 0\n        result = max(result, max(lsum + msum, lsum + psum))\n        # print(lsum, msum, psum, result)\n        prefix = [0]*len(A)\n        for i in range(0, len(A) - M + 1):\n            prefix[i+M-1] = sum(A[i:i+M])\n        # For the first run the below is imp\n        for k in range(L+M-1, len(A)):\n            result = max(result, lsum + prefix[k])\n        for i in range(L, len(A)):\n            lsum = lsum - A[i-L] + A[i]\n            if i+M <= len(A) - 1:\n                for k in range(i+M, len(A)):\n                    result = max(result, lsum + prefix[k])\n            if i-L > M-1:\n                # print(i)\n                for k in range(0, i-L):\n                    result = max(result, lsum + prefix[k])\n            # print(lsum, result)\n        return result", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        prefix_sum = [0] * (len(A)+1)\n\n        for i in range(1, len(prefix_sum)):\n            prefix_sum[i] = A[i-1] + prefix_sum[i-1]\n\n        max_sum = 0\n\n        # start with L\n        for i in range(L, len(prefix_sum)):\n            L_sum = prefix_sum[i] - prefix_sum[i-L]\n\n            for j in range(i+M, len(prefix_sum)):\n                M_sum = prefix_sum[j] - prefix_sum[j-M]\n                max_sum = max(max_sum, L_sum + M_sum)\n\n        # start with M\n        for i in range(M, len(prefix_sum)):\n            M_sum = prefix_sum[i] - prefix_sum[i-M]\n\n            for j in range(i+L, len(prefix_sum)):\n                L_sum = prefix_sum[j] - prefix_sum[j-L]\n                max_sum = max(max_sum, L_sum + M_sum)\n\n        return max_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        lhash, mhash = dict(), dict()\n        for i in range(len(A) - L + 1):\n            if i == 0:\n                lhash[i] = sum(A[:L])\n            else:\n                lhash[i] = lhash[i - 1] - A[i - 1] + A[i + L -1]\n                \n        for i in range(len(A) - M + 1):\n            if i == 0:\n                mhash[i] = sum(A[:M])\n            else:\n                mhash[i] = mhash[i - 1] - A[i - 1] + A[i + M - 1]\n                \n        res = 0\n        for i in range(0 , len(A) - L + 1):\n            if i > len(A) - M:\n                break\n            for j in range(i + L - 1 + 1, len(A) - M + 1 ):\n                res = max(res, lhash[i] + mhash[j])\n        \n        for j in range(0, len(A) - M + 1):\n            if j > len(A) - L:\n                break\n                \n            for i in range(j + M - 1 + 1, len(A) - L + 1):\n                res = max(res, lhash[i] + mhash[j])\n                \n        return res        ", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        ans = 0\n        sub1 = 0\n        for i in range(L-1):\n            sub1 += A[i]\n        for i in range(L-1, len(A)):\n            sub1 += A[i]\n            if i >= L+M-1:\n                sub2 = 0\n                for j in range(M-1):\n                    sub2 += A[j]\n                for j in range(M-1, i-L+1):\n                    sub2 += A[j]\n                    ans = max(ans, sub1+sub2)\n                    sub2 -= A[j-M+1]\n            \n            if i <= len(A)-M-1:\n                sub2 = 0\n                for j in range(i+1, i+M):\n                    sub2 += A[j]\n                for j in range(i+M, len(A)):\n                    sub2 += A[j]\n                    ans = max(ans, sub1+sub2)\n                    sub2 -= A[j-M+1]\n            sub1 -= A[i-L+1]\n        return ans", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        prefix_sum, current_sum = [], 0\n        \n        for num in A:\n            current_sum += num \n            prefix_sum.append(current_sum)\n        #print(prefix_sum)\n        \n        i, j = -1, L-1\n        max_m, sub = float('-inf'), 0\n        sum_l, max_tot = 0, 0\n        while j < len(prefix_sum):\n            sum_l = prefix_sum[j] - sub\n            sum_m = max(self.findM(prefix_sum[:i+1], M, 0),self.findM(prefix_sum[j+1:], M, prefix_sum[j]))\n            max_tot = max(max_tot, sum_m+sum_l)\n            i += 1\n            j += 1\n            sub = prefix_sum[i]                \n    \n        return max_tot\n               \n    \n    def findM(self, prefix_sum, M, sub):\n        if not prefix_sum or len(prefix_sum) < M:\n            return 0\n        max_m = float('-inf')\n        sum_m = 0\n        i, j = -1, M-1\n        while j < len(prefix_sum):\n            sum_m = (prefix_sum[j] - sub)\n            i += 1\n            j += 1\n            sub = prefix_sum[i]            \n            max_m = max(sum_m, max_m)\n            #print(sum_m, prefix_sum)\n        return max_m", "from typing import List\n\nclass Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        sum_up_to = [0]\n        total = 0\n        for n in A:\n            total += n\n            sum_up_to.append(total)\n        lsum = []\n        msum = []\n        for i in range(1,len(A)+1):\n            if i >= L:\n                lsum.append(sum_up_to[i]-sum_up_to[i-L])\n            else:\n                lsum.append(None)\n            \n            if i >= M:\n                msum.append(sum_up_to[i]-sum_up_to[i-M])\n            else:\n                msum.append(None)\n        \n        max_sum = 0\n        for i in range(len(lsum)):\n            if lsum[i] is None:\n                continue\n            for j in list(range(i-L))+list(range(i+M, len(msum))):\n                if msum[j] is None:\n                    continue\n                max_sum = max(max_sum, lsum[i]+msum[j])\n        return max_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        # for each array of length L we need to find the max sum array of length M\n        # we keep an array of cummulative sum so that we do not need to calculate them again and again\n        if L+M > len(A):\n            # no such array is possible\n            return 0\n        answer = [0]\n        max_sum = -float('inf')\n        for i in range(len(A)):\n            answer.append(answer[-1] + A[i])\n        for i in range(len(A)-L+1):\n            if i >= M:\n                # then only we can find non overlapping subarray in the beginning \n                for j in range(i-M+1):\n                    # print(i,j, answer[i+L] - answer[i], answer[j+M] - answer[j])\n                    max_sum = max(max_sum,answer[i+L] - answer[i] + answer[j+M] - answer[j])\n            if i + L <= len(A) - M:\n                # then only we can find non overlapping subarray in the end \n                for j in range(i + L, len(A) - M + 1):\n                    # print(i,j,answer[i+L] - answer[i], answer[j+M] - answer[j])\n                    max_sum = max(max_sum,answer[i+L] - answer[i] + answer[j+M] - answer[j])\n            \n        return max_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        cumsums = []\n        cumsum = 0\n        cumsums.append(cumsum)\n        for num in A:\n            cumsum += num\n            cumsums.append(cumsum)\n        n = len(A)\n        ans = -float('inf')\n        print(cumsums)\n        for i in range(0, n - L - M + 1):\n            for j in range(i + L, n - M + 1):\n                ans = max(ans, cumsums[i + L] - cumsums[i] + cumsums[j + M] - cumsums[j])\n        for i in range(0, n - M - L + 1):\n            for j in range(i + M, n - L + 1):\n                ans = max(ans, cumsums[i + M] - cumsums[i] + cumsums[j + L] - cumsums[j])\n        return ans", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        if L + M == len(A):\n            return sum(A)\n        \n        max_sum2 = 0\n        cur_sum2 = 0\n        total_len = len(A)\n        \n        def find_max_subarray(start_idx, end_idx, l):\n            \n            nonlocal A\n            max_sum = 0\n            cur_sum = 0\n            for idx in range(start_idx, l + start_idx):\n                max_sum += A[idx]\n            cur_sum = max_sum\n            \n            for idx in range(l + start_idx, end_idx):\n                cur_sum = cur_sum + A[idx] - A[idx - l]\n                max_sum = max(max_sum, cur_sum)\n            return max_sum\n        \n        cur_sum2 = 0\n        for idx in range(L):\n            cur_sum2 += A[idx]\n        \n        max_sum2 = cur_sum2 + find_max_subarray(L, total_len, M)\n        \n        for idx in range(L, total_len - M):\n            cur_sum2 = cur_sum2 + A[idx] - A[idx - L]\n            max_sum2 = max(max_sum2, cur_sum2 + find_max_subarray(idx+1, total_len, M))\n        \n        if L != M:\n            cur_sum2 = 0\n            for idx in range(M):\n                cur_sum2 += A[idx]\n            max_sum2 = max(max_sum2, cur_sum2 + find_max_subarray(M, total_len, L))\n            for idx in range(M, total_len - L):\n                cur_sum2 = cur_sum2 + A[idx] - A[idx - M]\n                max_sum2 = max(max_sum2, cur_sum2 + find_max_subarray(idx+1, total_len, L))\n        \n        return max_sum2\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        preSum = [0]\n        acc = 0\n        for i in range(len(A)):\n            acc += A[i]\n            preSum.append(acc)\n        #preSum[j] = A[0] + A[1] + ...+ A[j - 1]\n        # preSum[j] - preSum[i] = A[j - 1] + ... + A[i] length = j - i\n        # preSum[i] - preSum[i - L] = A[i - 1] + .... + A[i - L]\n        # preSum[j + M] - preSum[j] = A[j + M - 1] + ...+ A[j]\n        mx = 0\n        for i in range(L, len(preSum)):\n            for j in range(i, len(preSum) - M):\n                left = preSum[i] - preSum[i - L]\n                right = preSum[j + M] - preSum[j]\n                mx = max(mx, left + right)\n        for i in range(M, len(preSum)):\n            for j in range(i, len(preSum) - L):\n                left = preSum[i] - preSum[i - M]\n                right = preSum[j + L] - preSum[j]\n                mx = max(mx, left + right)\n        return mx\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        ans = 0\n        for f, l in zip([L, M], [M, L]):\n            max_first = first = sum(A[:f])\n            ans = max(ans, first + sum(A[f:f+l]))\n            for i in range(f, len(A) - l):\n                first = first + A[i] - A[i-f]\n                max_first = max(max_first, first)\n                ans = max(ans, max_first + sum(A[i+1:i+1+l]))\n        \n        return ans", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        sums = list(itertools.accumulate(A))\n        def get_sums(n):\n            return [(sums[i]-sums[i-n] if i-n >= 0 else sums[i], i-n+1, i) for i in range(n-1, len(sums))]\n            \n        l_sums = get_sums(L)\n        m_sums = get_sums(M)\n        max_sum = float('-inf')\n        for l_sum, l_i, l_j in l_sums:\n            for m_sum, m_i, m_j in m_sums:\n                if m_j < l_i or l_j < m_i:\n                    max_sum = max(max_sum, m_sum + l_sum)\n        \n        return max_sum\n        \n        \n        # we know there will be len - (L+M) elements excluded\n        # there will a stretch between before them\n        # iterate through looking for the larger array sum\n        # search in the left and right remainders for the smaller array sum of size x\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        '''\n        Input: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2\n        9 + (6+5) = 20\n        \n         A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2\n         (8+9)+ (3+8+1) = 29\n         \n         A = [3,8,1,3,2,1,8,9,3], L = 3, M = 2\n         (3+8)+(8+9+3) = 31\n         \n         3,8,1 + 3,2\n         3,8,1 + 2,1\n         - try all possibilities (A[i:i+L], A[i+L: i+L+M]) (A[i:i+M], A[i+M: i+L+M])\n         - get the max value\n         - memoize \n         \n         L = 3 M = 2\n         preprocess\n         [0, 6, 11, 13, 15, 20, 21, 30, 34]\n                             ^           ^\n          (11-0)+(20-11)=20\n          (11-0)+(21-13)=19\n          (11-0)+(21-13)=19\n          (11-0)+(30-15)=26\n          (11-0)+(34-20)=25\n          \n          (13-0)+(21-13)=21\n          (13-0)+(30-15)=28\n          (13-0)+(30-20)=23\n          (13-0)+(30-20)=23\n          \n          (15-6)+(30-15)=24\n          (15-6)+(34-20)=23\n          \n          (20-11)+(34-20)=23\n          \n          O(n^2)\n          \n          0 6 5 2 2 5 1 9 4, 1, 2\n          \n        '''\n        \n        arr = self.preprocess(A)\n        def helper(arr, n1, n2):\n            max_val = 0\n            for i in range(n1-1, len(arr)-n2):\n                for j in range(i+n2, len(arr)):\n                    val1 = arr[i] if i-n1 < 0 else arr[i]-arr[i-n1]\n                    val2 = arr[j]-arr[j-n2]\n                    max_val = max(val1+val2, max_val)\n            return max_val\n        \n        return max(helper(arr, L, M), helper(arr, M, L))\n    \n    def preprocess(self, A):\n        total = 0\n        result = [0 for _ in range(len(A))]\n        for i in range(len(A)):\n            total+=A[i]\n            result[i]=total\n        return result", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        self.cum = [A[0]]\n        \n        for i in range(1, len(A)):\n            self.cum.append(self.cum[i-1] + A[i])\n            \n        largest = 0\n        for i in range(len(A) - L + 1):\n            l_sum = self.cum[i+L-1] - self.cum[i] + A[i]\n            m_sum = 0\n            for j in range(i - M + 1):\n                m_sum = max(m_sum, self.cum[j+M-1] - self.cum[j] + A[j])\n\n            for j in range(i+L, len(A) - M +1):\n                m_sum = max(m_sum, self.cum[j+M-1] - self.cum[j] + A[j])\n\n            largest = max(largest, l_sum + m_sum)\n                \n        \n        return largest\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        l=len(A)\n        presum=[0]*(l+1)\n        for i in range(l):\n            presum[i+1]=presum[i]+A[i]\n        if L<M:\n            M,L=L,M\n        ans=0\n        for i in range(l-L+1):\n            tmp=presum[i+L]-presum[i]\n            j=0\n            while j<(l-M+1):\n                if i<j+M<i+L:\n                    j=i+L\n                else:\n                    ans=max(ans,tmp+presum[j+M]-presum[j])\n                    j+=1\n                    \n        return ans", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        '''\n            [0,6,5,2,2,5,1,9,4]\n            \n            [0,6,11,13,15,20,21,30,34]\n                       i i\n            \n            max_sum = -?\n        \n        '''\n        \n        summ = 0\n        \n        for i in range(len(A)):\n            summ += A[i]\n            A[i] = summ\n        \n        \n        max_sum = -float('inf')\n        for i in range(len(A) - L + 1):\n            if i - 1 > -1:\n                L_sum = A[i+L - 1] - A[i - 1]\n            else:\n                L_sum = A[i+L - 1]\n            M_max_sum = -float('inf')\n            for j in range(i - M + 1):\n                if j - 1 > -1:\n                    M_sum = A[j+M-1] - A[j - 1]\n                else:\n                    M_sum = A[j+M-1]\n                M_max_sum = max(M_max_sum, M_sum)\n            \n            for j in range(i+L, len(A) - M + 1):\n                if j - 1 > -1:\n                    M_sum = A[j+M-1] - A[j - 1]\n                else:\n                    M_sum = A[j+M-1]\n                M_max_sum = max(M_max_sum, M_sum)\n            \n            max_sum = max(max_sum, L_sum + M_max_sum)\n        \n        \n        return max_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        presum = [0]\n        for a in A:\n            presum.append(presum[-1] + a)\n            \n        def helper(A, l1, l2):\n            res = 0\n            N = len(A)\n            for i in range(N - l1 + 1 - l2):\n                for j in range(i + l1, N - l2 + 1):\n                    s1 = presum[i + l1 - 1 + 1] - presum[i]\n                    s2 = presum[j + l2 - 1 + 1] - presum[j]\n                    res = max(res, s1 + s2)\n            \n            return res\n        \n        r1 = helper(A, L, M)\n        r2 = helper(A, M, L)\n        return max(r1, r2)\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        cur_max_l = max_l = sum(A[:L])\n        ans = max_l + sum(A[L:L+M])\n        \n        for i in range(L, len(A) - M):\n            cur_max_l = cur_max_l + A[i] - A[i-L]\n            max_l = max(max_l, cur_max_l)\n            \n            ans = max(ans, max_l + sum(A[i+1:i+1+M]))\n        \n        cur_max_m = max_m = sum(A[:M])\n        ans = max(ans, max_m + sum(A[M:L+M]))\n        \n        for i in range(M, len(A) - L):\n            cur_max_m = cur_max_m + A[i] - A[i-M]\n            max_m = max(max_m, cur_max_m)\n            \n            ans = max(ans, max_m + sum(A[i+1:i+1+L]))\n        \n        return ans", "from itertools import accumulate\nfrom functools import lru_cache\nclass Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L0: int, M0: int) -> int:\n        #lru_cache(None)\n        def range_sum(i,j):\n            return accum[j-1] - (accum[i-1] if i > 0 else 0)\n        if not A:\n            return 0\n        max_sum = 0\n        accum = list(accumulate(A,lambda x,y:x+y))\n        for L,M in ((L0,M0),(M0,L0)):\n            for i in range(len(A)-L+1):\n                sum1 = range_sum(i,i+L)\n                for j in range(i+L,len(A)-M+1):\n                    sum2 = range_sum(j,j+M)      \n                    max_sum = max(max_sum, sum1+sum2)\n        return max_sum\n                \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        cumul = [0]\n        for a in A:\n            cumul.append(cumul[-1] + a)\n            \n        best = 0\n        for i in range(len(A) - L - M + 1):\n            for j in range(i + L, len(A) - M + 1):\n                best = max(best, cumul[i + L] - cumul[i] + cumul[j + M] - cumul[j])\n            for j in range(i + M, len(A) - L + 1):\n                best = max(best, cumul[i + M] - cumul[i] + cumul[j + L] - cumul[j])\n        return best", "from itertools import accumulate\nclass Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L0: int, M0: int) -> int:\n        def range_sum(i,j):\n            return accum[j-1] - (accum[i-1] if i > 0 else 0)\n        if not A:\n            return 0\n        max_sum = 0\n        accum = list(accumulate(A,lambda x,y:x+y))\n        for L,M in ((L0,M0),(M0,L0)):\n            for i in range(len(A)-L+1):\n                sum1 = range_sum(i,i+L)\n                for j in range(i+L,len(A)-M+1):\n                    sum2 = range_sum(j,j+M)      \n                    max_sum = max(max_sum, sum1+sum2)\n        return max_sum\n                \n", "from itertools import accumulate\nclass Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L0: int, M0: int) -> int:\n        def range_sum(i,j):\n            return accum[j-1] - (accum[i-1] if i > 0 else 0)\n        \n        if not A:\n            return 0\n        max_sum = 0\n        accum = list(accumulate(A,lambda x,y:x+y))\n        for L,M in ((L0,M0),(M0,L0)):\n            for i in range(len(A)-L+1):\n                sum1 = range_sum(i,i+L)\n                for j in range(i+L,len(A)-M+1):\n                    sum2 = range_sum(j,j+M)      \n                    max_sum = max(max_sum, sum1+sum2)\n        return max_sum\n                \n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        if len(A)< M+L:\n            return -1\n        \n        def getSumM(start, end):\n            if end-start<M:\n                return 0\n            preSumM=sum(A[start:start+M])\n            maxM=preSumM\n            for i in range(start+1,end-M+1):\n                preSumM=preSumM-A[i-1]+A[i+M-1]\n                maxM=max(maxM,preSumM)\n            return maxM\n            \n        preSumL=sum(A[:L-1])\n        maxSum=-sys.maxsize\n        for i in range(len(A)-L+1):\n            preSumL=preSumL+A[i+L-1]\n            leftSumM=getSumM(0,i)\n            rightSumM=getSumM(i+L,len(A))\n            maxSum= max(maxSum,preSumL+max(leftSumM,rightSumM))\n            preSumL=preSumL-A[i]\n        return maxSum\n        \n", "class Solution:\n    def maxSumTwoNoOverlap(self, arr: List[int], L: int, M: int) -> int:\n        Lsum = [0]*len(arr)\n        Msum = [0]*len(arr)\n        \n        def makeWindow(arr,res,size):\n            window = 0\n            for i in range(0,size):\n                window += arr[i]\n            res[i] = window\n            \n            for i in range(size,len(arr)):\n                res[i] = res[i-1] -arr[i-size] +arr[i]\n            \n\n        makeWindow(arr,Lsum,L)\n        makeWindow(arr,Msum,M)\n        \n        res = 0\n        for i in range(L-1,len(arr)):\n            for j in range(0,i-L):\n                res = max(res,Lsum[i]+Msum[j])\n            for j in range(i+M,len(arr)):\n                res = max(res,Lsum[i]+Msum[j])\n        \n        return res\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        '''\n        1. create cumsum arr\n        2. create arr of subarry sums from cumsum for L and M\n        3. N^2 mix and match while ensuring the nums don't overlap\n        \n        '''\n        \n        cumsum = []\n        for num in A:\n            if not cumsum:\n                cumsum.append(num)\n            else:\n                cumsum.append(cumsum[-1]+num)\n        \n        Lsums = [0]*len(A)\n        Msums = [0]*len(A)\n        \n        if M>L:\n            L,M = M,L # makes M smaller\n        \n        for j in range(L-1,len(A)):\n            if j==L-1:\n                Lsums[j] = cumsum[j]\n            else:\n                Lsums[j] = cumsum[j]-cumsum[j-L]\n        for j in range(M-1,len(A)):\n            if j==M-1:\n                Msums[j] = cumsum[j]\n            else:\n                Msums[j] = cumsum[j]-cumsum[j-M]\n        \n        out = 0\n        for l in range(L-1,len(A)):\n            for m in range(M-1,len(A)):\n                # M is before L completely\n                # M is after L completely\n                if m <= l-L or m-M>=l:\n                    out = max(out,Lsums[l]+Msums[m])\n        return out", "from typing import List\nclass Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        prefix_sums = [0]\n        current_sum = 0\n        for right in range(len(A)):\n            current_sum += A[right]\n            prefix_sums.append(current_sum)\n        # print(prefix_sums)\n        best = 0\n        left = 0\n        memo = dict()\n        while left+L <= len(A) and left+L < len(prefix_sums):\n            limits = ((0, left), (left+L, len(prefix_sums)))\n            best_m = self.get_max_subarray(prefix_sums, M, limits, memo)\n            subarray_sum = best_m[0] + prefix_sums[left+L]-prefix_sums[left]\n            # if subarray_sum > best:\n            #     print(f'{A[best_m[1]:best_m[2]]}={best_m[0]}')\n            #     print(f'{A[left:left+L]}={subarray_sum-best_m[0]}')\n            best = max(best, subarray_sum)\n            left += 1\n        return best\n\n    def get_max_subarray(self, sums, length, limits, memo):\n        # stores highest sum as tuple of (sum, left, right (exclusive))\n        if (length, limits) in memo:\n            return memo[(length, limits)]\n        high_score = (0,0,0)\n        for limit in limits:\n            left = limit[0]\n            # test subarrays of length within limit[0] and limit[1] (excluding limit[1])\n            while left + length <= limit[1] and left + length < len(sums):\n                subarray_sum = sums[left+length] - sums[left]\n                # print(f'{left}:{left+length}={subarray_sum}')\n                high_score = max(high_score, (subarray_sum, left, left+length))\n                # print(f'high: {high_score}')\n                left+=1\n        memo[(length, limits)] = high_score\n        return high_score\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        prefix = [0]\n        for num in A:\n            prefix.append(num+prefix[-1])\n        n = len(A)\n        ans = 0\n\n        for i in range(n-L+1):\n            a = prefix[i+L]-prefix[i]\n            for j in range(n-M+1):\n                if j+M<=i or i+L<=j:\n                    b = prefix[j+M]-prefix[j]\n                    ans = max(ans, a+b)\n        return ans", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        def solve(arr, la, lb):\n            n = len(arr)\n            post = [0] * n\n            pre = [0] * n\n            ans = 0\n\n            curr = 0\n            for i in range(n-1, -1, -1):\n                curr += arr[i]\n                if i < n-lb:\n                    curr -= arr[i+lb]\n                    post[i] = max(curr, post[i+1]) \n                else:\n                    post[i] = curr\n\n            curr = 0\n            for i in range(n):\n                curr += arr[i]\n                if i >= la:\n                    curr -= arr[i-la]\n                    pre[i] = max(curr, pre[i-1])\n                else:\n                    pre[i] = curr\n                if i < n-1:\n                    ans = max(ans, pre[i] + post[i+1])\n\n            return ans\n        \n        return max(solve(A, L, M), solve(A, M, L))\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        N = len(A)\n        sum_l = [sum(A[i:i+L]) for i in range(N-L+1)]\n        sum_m = [sum(A[i:i+M]) for i in range(N-M+1)]\n        \n        max_sum = 0\n        for i in range(len(sum_l)):\n            for j in range(len(sum_m)):\n                if (i <= j and j < (i+L)) or (i >= j and i < (j+M)):\n                    continue\n                max_sum = max(max_sum, sum_l[i]+sum_m[j])\n                \n        return max_sum", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        temp, prefix_sums  = 0, [0]\n        N = len(A)        \n        maxsum = 0\n        \n        # define prefix_sums[i] as: A[0] + A[1] + ... + A[i-1]\n        for i in range(N):\n            prefix_sums.append(temp + A[i])\n            temp += A[i]\n        # the last subarray = A[i] + A[i+1] +  ... + A[N-1], so maximum i = N - L\n        for i in range(0, N - L + 1):\n            for j in range(0, i - M + 1):\n                # print(\\\"i=\\\",i,\\\"; j=\\\",j)\n                if j < 0:\n                    continue\n                sum1 = prefix_sums[i + L] - prefix_sums[i]\n                sum2 = prefix_sums[j + M] - prefix_sums[j]\n                maxsum = max(maxsum, sum1+sum2)\n           \n            for j in range(i + L, N - M + 1):\n                # print(\\\"i=\\\",i,\\\"; j=\\\",j)\n                if j + M -1 >= N:\n                    continue\n                sum1 = prefix_sums[i + L] - prefix_sums[i]\n                sum2 = prefix_sums[j + M] - prefix_sums[j]\n                maxsum = max(maxsum, sum1+sum2)         \n            \n        return maxsum\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        l_sums = []\n        m_sums = []\n        flag_l = 0\n        flag_m = 0\n        \n        l_sum_tmp = 0\n        r_sum_tmp = 0\n        for i in range(len(A)):\n            if flag_l < L:\n                flag_l += 1\n                l_sum_tmp += A[i]\n            else:\n                l_sums.append(l_sum_tmp)\n                l_sum_tmp += A[i] - A[i-L]\n            \n            if flag_m < M:\n                flag_m += 1\n                r_sum_tmp += A[i]\n            else:\n                m_sums.append(r_sum_tmp)\n                r_sum_tmp += A[i] - A[i-M]\n        m_sums.append(r_sum_tmp)\n        l_sums.append(l_sum_tmp)\n        \n        max_sum = -1\n        for i in range(len(m_sums)):\n            for j in range(len(l_sums)):\n                if i+M<=j or j+L<=i:\n                    # print(m_sums[i], l_sums[j])\n                    max_sum = max(m_sums[i]+l_sums[j], max_sum)\n                    \n        return max_sum\n            \n        \n        return 1\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        sum_l = []\n        sum_m = []\n        for i in range(len(A) - L + 1):\n            sum_l.append(sum(A[i: i+L]))\n        for i in range(len(A) - M + 1):\n            sum_m.append(sum(A[i: i+M]))\n        res = 0\n        for i in range(len(A) - L + 1):\n            for j in range(len(A) - M + 1):\n                if i + L <= j or i >= j + M:\n                    res = max(res, sum_l[i] + sum_m[j])\n        return res", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        if L + M == len(A):\n            return sum(A)\n        \n        prefixSums = [0] * len(A)\n        prefixSums[0] = A[0]\n        for i in range(1, len(A)):\n            prefixSums[i] = prefixSums[i-1] + A[i]\n        #print(prefixSums)            \n\n        maxSum = -1\n        tempSum = None\n        secondTemp = None\n        for i in range(0, len(A) - L + 1):\n            if i == 0:\n                tempSum = prefixSums[i + L - 1]\n            else:\n                tempSum = prefixSums[i + L - 1] - prefixSums[i - 1]\n                \n            for j in range(0, len(A) - M + 1):\n                if j + M - 1 < i or j > i + L - 1:\n                    if j == 0:\n                        secondTemp = prefixSums[j + M - 1]\n                    else:\n                        secondTemp = prefixSums[j + M - 1] - prefixSums[j - 1]\n                  \n                    if maxSum < tempSum + secondTemp:\n                        maxSum = tempSum + secondTemp\n                \n        return maxSum\n", "class Solution:\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        la = []\n        ma = []\n        i = 0\n        for i in range(len(A) - L + 1):\n            la.append(sum(A[i:i+L]))\n        for i in range(len(A) - M + 1):\n            ma.append(sum(A[i:i+M]))\n        print((la, ma))\n        maxi = 0\n        for i in range(len(la)):\n            for j in range(len(ma)):\n                if i < j:\n                    if i + L > j:\n                        continue\n                if j < i:\n                    if j + M > i:\n                        continue\n                if j == i:\n                    continue\n                maxi = max(maxi, la[i]+ma[j])\n                        \n        return maxi\n            \n        \n", "class Solution:\n    def maxSubarrayOfLengthK(self,A,start,end,K):\n        if end-start < K:\n            return (float('-inf'),0,len(A)+1)\n        total_sum  = 0\n        for i in range(start,start+K):\n            total_sum += A[i]\n        \n        opt_sum = (total_sum,start,start+K-1)\n        \n        for j in range(start+K,end):\n            total_sum += (A[j]-A[j-K])\n            if total_sum > opt_sum[0]:\n                opt_sum = (total_sum,j-K+1,j)\n        return opt_sum\n            \n    \n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        prefix_sums = [0 for _ in A+[0]]\n        \n        for i in range(1,len(A)+1):\n            prefix_sums[i] = A[i-1] + prefix_sums[i-1]\n        \n        def solve(prefix_sums,L,M):\n            res = 0\n            for i in range(len(A)-L):\n                total_sum = prefix_sums[i+L] - prefix_sums[i]\n                l1,r1 = 0,i\n                l2,r2 = i+L,len(A)\n                other = max(self.maxSubarrayOfLengthK(A,l1,r1,M)[0],self.maxSubarrayOfLengthK(A,l2,r2,M)[0])\n                res = max(total_sum+other,res)\n\n            return res\n        \n        return max(solve(prefix_sums,L,M),solve(prefix_sums,M,L))", "class Solution:\n    def maxWindowSum(self, A, M):\n        acc = [A[0]]\n        for i in range(1, len(A)):\n            acc.append(acc[i-1] + A[i])\n        maxSum = sum(A[:M])\n        for i in range(M, len(A)):\n            maxSum = max(maxSum, acc[i] - acc[i-M])\n        return maxSum\n            \n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        n = len(A)\n        if not A or L+M > n:\n            return 0\n        left = []\n        right = []\n        maxSum = 0\n        for i in range(n - L + 1):\n            maxL = sum(A[i:i+L])\n            maxM = 0\n            if i >= M:\n                left = A[:i]\n                maxM = max(maxM,self.maxWindowSum(left, M))\n            if n - i - L >= M:\n                right = A[i+L:]\n                maxM = max(maxM, self.maxWindowSum(right, M))\n                \n            maxSum = max(maxSum, maxL + maxM)\n        return maxSum"]
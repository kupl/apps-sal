["import string\nfrom collections import OrderedDict\n\nclass RomanNumerals:\n  @classmethod\n  def to_roman(self, num):\n    conversions = OrderedDict([('M',1000), ('CM',900), ('D', 500), ('CD',400), ('C',100), ('XC',90), ('L',50), ('XL',40),\n                               ('X',10), ('IX',9), ('V',5), ('IV',4), ('I',1)])\n    out = ''\n    for key, value in conversions.items():\n      while num >= value:\n        out += key\n        num -= value\n    return out\n  \n  @classmethod\n  def from_roman(self, roman):\n    conversions = OrderedDict([('CM',900), ('CD',400), ('XC',90), ('XL',40), ('IX',9), ('IV',4), ('M',1000), ('D',500),\n                               ('C',100), ('L',50), ('X',10), ('V',5), ('I',1)])\n    out = 0\n    for key, value in conversions.items():\n      out += value * roman.count(key)\n      roman = string.replace(roman, key, \"\")\n    return out\n\n", "from collections import OrderedDict\nimport re\n\n\nROMAN_NUMERALS = OrderedDict([\n    ('M', 1000),\n    ('CM', 900),\n    ('D', 500),\n    ('CD', 400),\n    ('C', 100),\n    ('XC', 90),\n    ('L', 50),\n    ('XL', 40),\n    ('X', 10),\n    ('IX', 9),\n    ('V', 5),\n    ('IV', 4),\n    ('I', 1),\n])\n\nDECIMAL_TO_ROMAN = [(v, k) for k, v in list(ROMAN_NUMERALS.items())]\n\nROMAN_RE = '|'.join(ROMAN_NUMERALS)\n\n\nclass RomanNumerals(object):\n    @staticmethod\n    def from_roman(roman):\n        return sum(ROMAN_NUMERALS[d] for d in re.findall(ROMAN_RE, roman))\n\n    @staticmethod\n    def to_roman(decimal):\n        result = []\n        for number, roman in DECIMAL_TO_ROMAN:\n            while decimal >= number:\n                decimal -= number\n                result.append(roman)\n        return ''.join(result)\n", "from itertools import groupby\n\n\"\"\"A RomanNumerals helper object\"\"\"\nclass RomanNumerals(object):\n    letters = [('M',1000), ('CM',900), ('D',500), ('CD',400), ('C',100), ('XC',90),\n               ('L',50), ('XL',40), ('X',10), ('IX',9), ('V',5), ('IV',4), ('I',1)]\n    \n    @classmethod\n    def to_roman(cls, val):\n        rom = []\n        for l, v in cls.letters:\n            m = val // v\n            rom += m*[l]\n            val -= m*v\n        return ''.join(rom)\n        \n    @classmethod\n    def from_roman(cls, rom):\n        cumu = 0\n        for l, v in cls.letters:\n            while rom[:len(l)] == l:\n                rom = rom[len(l):]\n                cumu += v\n            if not rom: break\n        return cumu\n                \n", "\nclass RomanNumerals():\n    READ = { 1:'I',  5:'V', 10:'X', 50:'L', 100:'C', 500:'D', 1000:'M' }\n    INTG = { v:k for k,v in list(READ.items())}\n    \n    \n    @classmethod\n    def to_roman(cls, num, rom = ''):\n        EDGE = {\n              0:lambda x, elem,  dict, number : dict.get(elem, '') * number, \n              1:lambda e, i, D, l : e + D[i*(l+1)] if l in [4,9] else D[i*l] if l is 5 else D[i*5] + (e * (l%5))\n               }\n        for element in list(cls.READ.keys())[0::2][::-1]: \n            left = num // element\n            rom += EDGE.get(left>3, '')( cls.READ[element] , element, cls.READ, left )\n            num %= element\n        return rom\n        \n    @classmethod   \n    def from_roman(cls, roma): \n        cls.INTG.update({'N':0}) \n        roma += 'N'\n        return sum( [-cls.INTG[x] if cls.INTG[x] < cls.INTG[z] else cls.INTG[x] for x,z in zip(roma[:-1], roma[1:])]) \n\n", "class RomanNumerals:\n    @staticmethod\n    def from_roman(s):\n        X=[dict(zip('MDCLXVI',(1e3,500,100,50,10,5,1)))[x]for x in s]\n        return int(sum((x,-x)[x<y]for x,y in zip(X,X[1:]))+X[-1])\n    @staticmethod\n    def to_roman(i,o=' I II III IV V VI VII VIII IX'.split(' ')):\n        r=lambda n:o[n]if n<10 else''.join(dict(zip('IVXLC','XLCDM'))[c]for c in r(n//10))+o[n%10]\n        return r(i)", "\"\"\"TODO: create a RomanNumerals helper object\"\"\"\nclass RomanNumerals:\n\n    @staticmethod\n    def to_roman(num):\n        ints = (1000, 900,  500, 400, 100,  90, 50,  40, 10,  9,   5,  4,   1)\n        nums = ('M',  'CM', 'D', 'CD','C', 'XC','L','XL','X','IX','V','IV','I')\n        result = \"\"\n        for i in range(len(ints)):\n            count = int(num / ints[i])\n            result += str(nums[i] * count)\n            num -= ints[i] * count\n        return result\n        \n    @staticmethod\n    def from_roman(roman):\n        nums = ['M', 'D', 'C', 'L', 'X', 'V', 'I']\n        ints = [1000, 500, 100, 50,  10,  5,   1]\n        places = []\n        for i in range(len(roman)):\n            c = roman[i]\n            value = ints[nums.index(c)]\n            try:\n                next_val = ints[nums.index(roman[i+1])]\n                if next_val > value:\n                    value *= -1\n            except:\n                pass\n                \n            places.append(value)\n        return sum(places)", "class RomanNumerals(object):\n    \n    @classmethod\n    def to_roman(self, n, result='', i=0):\n        SPQR = ((1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'),\n        (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I'))\n        \n        if i == len(SPQR):\n            return result\n        while n - SPQR[i][0] >= 0:\n            result += SPQR[i][1]\n            n -= SPQR[i][0]\n        i += 1\n        return self.to_roman(n, result, i)\n        \n        \n    @classmethod\n    def from_roman(self, roman, result=0, i=0):\n        SPQR = ((900, 'CM'), (1000, 'M'), (400, 'CD'), (500, 'D'), (90, 'XC'), (100, 'C'), (50, 'L'),\n        (40, 'XL'), (9, 'IX'), (10, 'X'), (4, 'IV'), (5, 'V'), (1, 'I'))\n        \n        if roman == '':\n            return result\n        while SPQR[i][1] in roman:\n            result += SPQR[i][0]\n            roman = roman[len(SPQR[i][1]):]\n        i += 1\n        return self.from_roman(roman, result, i)", "from functools import reduce\nclass RomanNumerals:\n\n    _map = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC',\n            50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n    \n    @classmethod\n    def to_roman(cls, n):\n        _map = cls._map\n        red = lambda s, e: (s[0]+_map[e]*(s[1]//e), s[1]-e*(s[1]//e))\n        return reduce(red, reversed(sorted(_map)), ['', n])[0]\n    \n    @classmethod\n    def from_roman(cls, s):\n        _map = {v:k for k, v in cls._map.items()}\n        red = lambda s, e: s[:-1] + [s[-1] + e] if s and s[-1] + e in _map else s + [e]\n        return sum(_map[x] for x in reduce(red, s, []))\n", "from itertools import groupby, zip_longest\n\nFROM_ROMAN = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}\nTO_ROMAN = ((1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n            (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'),\n            (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I'))\n\n\nclass RomanNumerals(object):\n    @staticmethod\n    def to_roman(n):\n        result = []\n        for num, char in TO_ROMAN:\n            q, n = divmod(n, num)\n            result.append(q * char)\n        return ''.join(result)\n\n    @staticmethod\n    def from_roman(roman):\n        pairs = [sum(g) for _, g in groupby(FROM_ROMAN[a] for a in roman)]\n        return sum(a + b if a > b else b - a for a, b in\n                   zip_longest(pairs[::2], pairs[1::2], fillvalue=0))\n", "class RomanNumerals:\n    dic = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n\n    @staticmethod\n    def to_roman(n):        \n        res = []        \n        for i in RomanNumerals.dic:\n            res.extend((n / i[0]) * i[1])\n            n -= (n / i[0]) * i[0]\n        \n        return \"\".join(res)\n    \n    @staticmethod\n    def from_roman(n):\n        res = 0\n        for i in RomanNumerals.dic:\n            while n.startswith(i[1]):\n                res += i[0]\n                n = n[len(i[1]):]\n        return res"]
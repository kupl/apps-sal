["class Solution:\n    def NOD(self, a, b):\n        if a == b:\n            return a\n        c = max(a,b)\n        d = a + b - c\n        c = c%d\n        c = c if c>0 else d\n        return self.NOD(c,d)\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        const = 10**9 + 7\n        nod = self.NOD(A, B)\n        nok = int(A*B/nod)\n        C, D = min(A, B), max(A, B)\n        k_C = nok//C\n        k_D = nok//D\n        k = k_C + k_D - 1\n        div = N//k\n        mod = N - div*k\n        k_C_cur = (mod*k_C)//k\n        k_D_cur = mod - k_C_cur\n        #print(k_C, k_D, k, div, mod, k_C_cur, k_D_cur)\n        while True:\n            C_num = k_C_cur*C\n            D_num = k_D_cur*D\n            if -C < C_num - D_num < D:\n                return (div*nok + max(C_num, D_num))%const\n            elif C_num - D_num <= -C:\n                k_D_cur -= 1\n                k_C_cur += 1\n            else:\n                k_D_cur += 1\n                k_C_cur -= 1", "class Solution:\n    def gcd(self, x, y):\n        while y > 0:\n            x, y = y, x % y\n        return x\n\n    def lcm(self, x, y):\n        return x*y//self.gcd(x,y)\n    \n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        AB = self.lcm(A,B)\n\n        def check(mid):\n            ans = mid//A + mid//B - mid//(AB)\n            return ans >= N\n        \n        lo, hi = 0, N*A\n        while lo<hi:\n            mid = (lo+hi)//2\n            if check(mid):\n                hi = mid\n            else:\n                lo = mid+1\n\n        mod = 10**9+7\n        return lo%mod", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        from fractions import gcd\n        MOD = 10**9+7\n        L = A/gcd(A,B)*B\n        \n        def max_unique_nums(x):\n            return x//A+x//B-x//L\n        \n        lo = 0\n        hi = N*min(A,B)\n        while lo<hi:\n            mid = (lo+hi)//2\n            if max_unique_nums(mid)<N:\n                lo =  mid + 1\n            else:\n                hi = mid\n        return lo%MOD", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        from fractions import gcd\n        MOD = 10**9 + 7\n\n        L = A / gcd(A, B) * B\n        M = L / A + L / B - 1\n        q, r = divmod(N, M)\n\n        if r == 0:\n            return int(q * L) % MOD\n\n        heads = [A, B]\n        for _ in range(int(r) - 1):\n            if heads[0] <= heads[1]:\n                heads[0] += A\n            else:\n                heads[1] += B\n\n        return int(q * L + min(heads)) % MOD", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        ## official solution\n        def gcd(x, y):\n            if y==0:\n                return x\n            return gcd(y, x%y)\n            \n        MOD = 10**9 + 7\n        ## Least common multiple of A and B\n        L = A // gcd(A, B) * B\n        M = L//A + L//B - 1\n        q, r = divmod(N, M)\n        \n        if r == 0:\n            return q*L%MOD\n        \n        increments = [A, B]\n        for _ in range(r-1):\n            if increments[0]<=increments[1]:\n                increments[0] += A\n            else:\n                increments[1] += B\n        return (q*L+min(increments))%MOD\n", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        # H.C.F of A and B\n        x,y = min(A,B),max(A,B)\n        print(x,y)\n        hcf = x\n\n        while (y%hcf !=0 or x%hcf!=0) and hcf>1:\n            hcf -= 1\n        print(hcf)\n        gcd = int(x*y/hcf)\n        print(gcd)\n        start,end = x,N*x\n        while start<=end:\n            mid = start+int((end-start)/2)\n            count = int(mid/x) + int(mid/y) - int(mid/gcd) \n            if count == N:\n                break\n            elif count >N:\n                end = mid -1\n            else:\n                start = mid + 1\n        while mid%x !=0 and mid%y !=0:\n            mid -= 1\n        return mid%(10**9 +7)", "import math\nclass Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        md = 10**9+7\n        p = A*B//math.gcd(A,B)\n        np = p//A+p//B-1\n        n1 = N//np\n        res = n1*(p%md)%md\n        n2 = N%np\n        i,j, curr = 0, 0, 0\n        while i+j<n2:\n            if A*(i+1) < B*(j+1):\n                i += 1\n                curr = A*i\n            else:\n                j += 1\n                curr = B*j\n        res = (res+curr)%md\n        # print(i,j,n1,n2,np)\n        return res\n", "\nclass Solution:\n    modulo = 10**9+7\n    def getMaxCommonFactor(self, A, B):\n        while B > 0:\n            A = A % B\n            A, B = B, A\n        return A\n    \n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        mcf = self.getMaxCommonFactor(A, B)\n        period = (A * B // mcf) % self.modulo\n        numinperiod = (A + B - mcf) // mcf\n        base = N // numinperiod * period\n        nums = [A*i for i in range(B//mcf)] + [B*i for i in range(1, A//mcf)]\n        nums.sort()\n        rem = nums[N % numinperiod]\n        \n        return (base + rem) % self.modulo\n        \n", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        \n#         # O(N) solution -- TLE\n#         i = 1 # multiplier of A\n#         j = 1 # multiplier of B\n        \n#         res = 0\n        \n#         while N>0:\n#             if A*i < B*j:\n#                 res = A*i\n#                 i += 1\n#             elif A*i > B*j:\n#                 res = B*j\n#                 j += 1\n#             else:\n#                 res = A*i\n#                 i += 1\n#                 j += 1\n#             N-=1\n        \n#         return res%(10**9+7)\n    \n        # O(logN) solution -- binary search\n        def min_common_divisor(a, b):\n            less = min(a, b)\n            more = max(a, b)\n            for i in range(1, less+1):\n                if more*i % less == 0:\n                    return more*i\n            return a*b\n        \n        _cd = min_common_divisor(A, B)\n\n        min_ = min(A, B)\n        l, r = min_, min_*N+1\n        while l<r:\n            m = (l+r)>>1\n\n            if m//A+m//B-m//_cd < N:\n                l = m + 1\n            elif m//A+m//B-m//_cd > N:\n                r = m\n            else:\n                if m%A==0 and m%B==0:\n                    return m % (10**9+7)\n                else:\n                    r = m\n\n        return l % (10**9+7)", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        import math\n        if (A % B == 0 or B % A == 0):\n            return (N * min(A, B)) % (10**9 + 7)\n        testRange = (1, N * min(A,B))\n        testValue = int((testRange[1] + testRange[0]) / 2)\n        magicNums = math.floor(testValue / A) + math.floor(testValue / B) - math.floor(testValue * math.gcd(A,B) / (A * B))\n        while (magicNums != N):\n            testRange = (testRange[0], testValue) if magicNums > N else (testValue, testRange[1])\n            testValue = math.ceil((testRange[1] + testRange[0]) / 2)\n            magicNums = math.floor(testValue / A) + math.floor(testValue / B) - math.floor(testValue * math.gcd(A,B) / (A * B))\n        return max(int(testValue / A) * A, int(testValue / B) * B) % (10**9 + 7)", "class Solution:\n    def _lcm(self, a, b):\n        return a * b // math.gcd(a, b)\n    \n    def _nth_magical_number_slow(self, n: int, a: int, b: int) -> int:\n        if n == 0:\n            return 0\n        else:\n            i, j = a, b\n            count = 1\n            while count < n:\n                if i <= j:\n                    i = i + a\n                else:\n                    j = j + b\n\n                if i == j:\n                    if a < b:\n                        i = i + a\n                    else:\n                        j = j + b\n\n                count += 1\n\n            return min(i, j) % 1000000007\n    \n    def nthMagicalNumber(self, n: int, a_orig: int, b_orig: int) -> int:\n        a, b = min(a_orig, b_orig), max(a_orig, b_orig)\n        if a == b:\n            return a * n % 1000000007\n        else:\n            lcm = self._lcm(a, b)\n            k = lcm // a + lcm // b - 1\n            return ((n // k) * lcm + self._nth_magical_number_slow(n % k, a, b)) % 1000000007\n", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        a_t = A\n        b_t = B\n        col = []\n        low_anc = a_t\n        while a_t != b_t:\n            if a_t < b_t:\n                col.append(a_t)\n                a_t = (a_t + A) #% (10 ** 9 + 7)\n            else:\n                col.append(b_t)\n                b_t = (b_t + B) #% (10 ** 9 + 7)\n        col.append(a_t)\n        low_anc = a_t\n        \n        \n        idx = (N - 1) % len(col)\n        \n        # 2,3,4,6\n        \n        ans = (N - 1) // len(col) * low_anc + col[idx]\n        \n        return ans % (10 ** 9 + 7)", "def LCM(x, y):\n    if x == y:\n        return x\n    bigger = max([x,y])\n    smaller = min([x,y])\n    res = bigger\n    while res % smaller != 0:\n        res += bigger\n    return res\n\nclass Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        lcm = LCM(A,B)\n        div = [0,lcm]\n        for i in [A, B]:\n            t = i\n            while t < lcm:\n                div.append(t)\n                t += i\n        \n        div = sorted(div)\n        cycle = len(div)-1\n        \n        return (div[N % cycle] + lcm * (N // cycle)) % 1000000007\n", "class Solution:\n    def _lcm(self, a, b):\n        return a * b // math.gcd(a, b)\n    \n    def _nth_magical_number_slow(self, n: int, a: int, b: int) -> int:\n        if n == 0:\n            return 0\n        else:\n            i, j = a, b\n            count = 1\n            while count < n:\n                if i <= j:\n                    i = i + a\n                else:\n                    j = j + b\n\n                if i == j:\n                    if a < b:\n                        i = i + a\n                    else:\n                        j = j + b\n\n                count += 1\n\n            return min(i, j)\n    \n    def nthMagicalNumber(self, n: int, a_orig: int, b_orig: int) -> int:\n        a, b = min(a_orig, b_orig), max(a_orig, b_orig)\n        if a == b:\n            return a * n % 1000000007\n        else:\n            lcm = self._lcm(a, b)\n            k = lcm // a + lcm // b - 1\n            return ((n // k) * lcm + self._nth_magical_number_slow(n % k, a, b)) % 1000000007\n", "import heapq\nclass Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        def gcd(i, j):\n            if i > j:\n                i, j = j, i\n            \n            while i != 0:\n                j %= i\n                i, j = j, i\n            return j\n        \n        common_mult = A * B // gcd(A, B)\n        c_count = common_mult // A + common_mult // B - 1\n        \n        unit_count = N // c_count\n        remainder = N % c_count\n        \n        base = (unit_count * common_mult) % (10**9 + 7)\n        if remainder == 0:\n            return base\n        \n        heap = [A, B]\n        heapq.heapify(heap)\n        while heap:\n            curr = heapq.heappop(heap)\n            remainder -= 1\n            if remainder == 0:\n                return (base + curr) % (10**9 + 7)\n            \n            if curr % A == 0:\n                heapq.heappush(heap, curr + A)\n            else:\n                heapq.heappush(heap, curr + B)\n", "def nww(a, b):\n    bigger = max(a,b)\n    smaller = min(a,b)\n    result = bigger\n    i = 2\n    while(result % smaller != 0):\n        result = bigger * i\n        i += 1\n    return result\n\nclass Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        nw = nww(A,B)\n        la = list([A * x for x in range(1, nw//A)])\n        lb = list([B * x for x in range(1, nw//B)])\n        cycle = sorted([0]+la+lb)\n        return (N // len(cycle) * nw + cycle[N % len(cycle)]) % (10**9+7)\n", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        def gcd(a, b):\n            while b:\n                a, b = b, a%b\n            return a\n        \n        LCM = A*B//gcd(A, B)\n        m = LCM//A + LCM//B -1\n        q, r = divmod(N, m)\n        if r==0:\n            return q*LCM%(10**9+7)\n        # print(q, r, m, LCM)\n        pa, pb = 0, 0\n        for _ in range(r):\n            nxt = min(A*(pa+1), B*(pb+1))\n            if nxt==A*(pa+1):\n                pa += 1\n            if nxt==B*(pb+1):\n                pb += 1\n        \n        return (q*LCM+nxt)%(10**9+7)\n            \n            \n        \n        \n", "import fractions\n\nclass Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        self.normalize(A, B)\n        multiples_before_lcm = self.get_multiples_before_lcm(A, B)\n        mod = 10 ** 9 + 7\n        div, rem = N // self.num_before_lcm, N % self.num_before_lcm\n        return (div * self.lcm + multiples_before_lcm[rem]) % mod\n        \n    def normalize(self, A, B):\n        self.gcd = fractions.gcd(A, B)\n        self.lcm = A * B // self.gcd\n        self.normA = A // self.gcd\n        self.normB = B // self.gcd\n        self.num_before_lcm = self.normA + self.normB - 1\n    \n    def get_multiples_before_lcm(self, A, B):\n        nextAmult = A\n        nextBmult = B\n        multiples = self.num_before_lcm * [None]\n        multiples[0] = 0\n        i = 1\n        while nextAmult < self.lcm and nextBmult < self.lcm:\n            if nextAmult < nextBmult:\n                multiples[i] = nextAmult\n                nextAmult += A\n            else:\n                multiples[i] = nextBmult\n                nextBmult += B\n            i += 1\n        while nextAmult < self.lcm:\n            multiples[i] = nextAmult\n            nextAmult += A\n            i += 1\n        while nextBmult < self.lcm:\n            multiples[i] = nextBmult\n            nextBmult += B\n            i += 1\n        assert i == self.num_before_lcm\n        return multiples", "from fractions import gcd\nclass Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        l = 0\n        r = N*(min(A, B))\n        \n        lcm = (A*B)//gcd(A, B)\n        \n        def checkNum(x):\n            ans = x//A + x//B - x//lcm\n            return ans >= N\n        \n        if N == 1:\n            return min(A, B)\n        while r > l:\n            m = (r + l) // 2\n            if checkNum(m):\n                r = m\n            else:\n                l = m + 1\n        return l%(10**9+7)", "class Solution:\n    \n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        \n        if A > B:\n            A, B = B, A\n            \n        if B % A == 0:\n            return A * N % 1000000007\n        \n        for i in range(1,A+1):\n            if B*i % A == 0:\n                break\n        \n        LCM = B*i\n        \n        nAB = LCM // A + i - 1\n        \n        r = N // nAB\n        \n        N %= nAB\n        \n#         print(nAB,r,N)\n        \n        return (r * LCM + sorted(set([A*i for i in range(N+1)]) | set([B*i for i in range(N+1)]))[N]) % 1000000007\n        \n", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n        def lcm(a, b):\n            return a * b // gcd(a, b)\n        val = lcm(A, B)\n        magicals = set()\n        for i in range(1, val//A + 1):\n            magicals.add(i * A)\n        for i in range(1, val//B + 1):\n            magicals.add(i * B)\n        sorted_magicals = sorted(magicals)\n        return (sorted_magicals[(N-1) % len(sorted_magicals)] + ((N - 1) // len(sorted_magicals) * sorted_magicals[-1])) % (10**9 + 7)", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        def compute_gcd(x, y):\n            if y == 0: return x\n            return compute_gcd(y, x%y)\n\n        # This function computes LCM\n        def compute_lcm(x, y):\n            lcm = (x*y)//compute_gcd(x,y)\n            return lcm\n\n\n        C = compute_lcm(A,B)\n        l = min(A,B)\n        h = N*max(A,B)\n        #print(C)\n        while (l < h):\n            mid = (l+h)//2\n            m = mid//A + mid//B - mid//C\n            if m>=N:\n                h = mid\n            else:\n                l = mid + 1\n        return l %(10**9+7)\n      \n            \n", "class Solution(object):\n    def nthMagicalNumber(self, N, A, B):\n        from fractions import gcd\n        MOD = 10**9 + 7\n        L = A // gcd(A,B) * B\n\n        def magic_below_x(x):\n            # How many magical numbers are <= x?\n            return x // A + x // B - x // L\n\n        lo = 0\n        hi = N * min(A, B)\n        while lo < hi:\n            mi = (lo + hi) // 2\n            if magic_below_x(mi) < N:\n                lo = mi + 1\n            else:\n                hi = mi\n\n        return lo % MOD", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        d = gcd(A, B)\n        A //= d\n        B //= d\n\n        def how_many_below(n):\n            return n//A+n//B-n//(A*B)\n\n        lo = N-1\n        hi = min(A, B)*N\n\n        while hi - lo > 1:\n            h = (hi+lo)//2\n            if how_many_below(h) >= N:\n                hi = h\n            else:\n                lo = h\n        return hi*d % (10**9+7)\n\n\ndef gcd(a, b):\n    while a:\n        a, b = b % a, a\n    return b\n", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        \n        lcm = A * B // math.gcd(A,B)\n        \n        cnt = lcm // A + lcm // B - 1\n        \n        i = N // cnt\n        j = N % cnt\n        \n        \n        def count(x, lcm):\n            \n            return x//A + x//B - x//lcm\n        \n        l, r = 0, A*B\n        \n        while l < r:\n            mid = l + (r-l)//2\n            \n            c = count(mid, lcm)\n            \n            if c < j:\n                l = mid + 1\n            else:\n                r = mid\n        \n        return (i * lcm + l) % (10**9+7)", "class Solution:\n    def nthMagicalNumber(self, N: int, A: int, B: int) -> int:\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n        def lcm(a, b):\n            return a * b // gcd(a, b)\n        val = lcm(A, B)\n        def number_magic_below(x):\n            return x // A + x // B - x // val\n        \n        lo = min(A, B)\n        hi = N * min(A, B)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if number_magic_below(mid) < N:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo % (10**9 + 7)"]
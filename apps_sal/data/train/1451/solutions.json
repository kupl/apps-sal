["# cook your dish here\nfor _ in range(int(input())):\n    N, M = [int(x) for x in input().split()]\n    edges = [0]*M\n    dir = {}\n    nodes = [[] for j in range(N+1)]\n    ind = [0]*(N+1)\n    graph = {}\n    final_edges = []\n    for i in range(M):\n        u, v = [int(x) for x in input().split()]\n        nodes[u].append(v)\n        nodes[v].append(u)\n        dir[(u,v)]=1\n        dir[(v,u)] = 0\n        ind[v] += 1\n        graph[(u,v)] = graph[(v,u)] = i\n        final_edges.append([u,v])\n    if M%2!=0:\n        print(-1)\n        continue\n    for i in range(M):\n        u, v = final_edges[i]\n        if ind[u]%2!=0 and ind[v]%2!=0:\n            d = dir[(u,v)]\n            if d:\n                ind[u] += 1\n                ind[v] -= 1\n                dir[(u,v)] = 0\n                dir[(v,u)] = 1\n                edges[i] = abs(edges[i]-1)\n            else:\n                ind[u] -= 1\n                ind[v] += 1\n                dir[(u, v)] = 1\n                dir[(v, u)] = 0\n                edges[i] = abs(edges[i]-1)\n    s = []\n    for i in range(1, N+1):\n        if ind[i]%2:\n            s.append(i)\n    while s:\n        set1 = set()\n        for u in s:\n            if ind[u]%2:\n                v = nodes[u][0]\n                d = dir[(u,v)]\n                index = graph[(u, v)]\n                set1.add(v)\n                if d:\n                    ind[u] += 1\n                    ind[v] -= 1\n                    dir[(u, v)] = 1\n                    dir[(v, u)] = 1\n                    edges[index] = abs(edges[index]-1)\n                else:\n                    ind[u] -= 1\n                    ind[v] += 1\n                    dir[(u, v)] = 1\n                    dir[(v, u)] = 0\n                    edges[index] = abs(edges[index]-1)\n\n        s = set1\n    print(*edges)", "for __ in range(int(input())):\r\n    n,m=map(int,input().split())\r\n    g=[[]for _ in range(n+1)]\r\n    long=[]\r\n    di={}\r\n    stable=[0 for _ in range(n+1)]\r\n    edges=[0 for _ in range(m)]\r\n    for i in range(m):\r\n        x,y=map(int,input().split())\r\n        g[x].append(y)\r\n        g[y].append(x)\r\n        stable[y]+=1\r\n        long.append([x,y])\r\n        di[(x,y)]=i\r\n        di[(y,x)]=i\r\n    f=1\r\n    if m%2:\r\n        f=0\r\n    for i in range(m):\r\n        c,d=long[i][0],long[i][1]\r\n        if stable[c]%2==1 and stable[d]%2==1:\r\n            stable[c]+=1\r\n            stable[d]-=1\r\n            edges[i]=1\r\n    s=[]\r\n    for i in range(1,n+1):\r\n        if stable[i]%2==1:\r\n            s.append(i)\r\n    while s and f:\r\n        set1=set()\r\n        for i in s:\r\n            if stable[i]%2:\r\n                y=g[i][0]\r\n                w=di[(i,y)]\r\n                stable[y]+=1\r\n                stable[i]-=1\r\n\r\n                set1.add(y)\r\n                edges[w]=abs(edges[w]-1)\r\n        s=set1\r\n    if(f):\r\n        print(*edges)\r\n    else:\r\n        print(-1)\r\n", "import sys\r\nfrom collections import deque\r\n\r\ncroot = dict()\r\nsetnumber = dict()\r\n\r\ndef finalroot(v):\r\n    if croot[v] != v:\r\n        v = finalroot(croot[v])\r\n    return v\r\n\r\ndef union(v1,v2):\r\n    r1 = finalroot(v1)\r\n    r2 = finalroot(v2)\r\n    if r1 != r2:\r\n        if setnumber[r1] > setnumber[r2]:\r\n            croot[r2] = r1\r\n        else:\r\n            croot[r1] = r2\r\n            if setnumber[r1] == setnumber[r2]:\r\n                setnumber[r2] += 1\r\n\r\ndef minspan(n,edges):\r\n\r\n    finale = []\r\n    edgecount = {}\r\n\r\n    for i in range(n):\r\n        edgecount[i+1] = 0\r\n        setnumber[i+1] = 0\r\n        croot[i+1] = i+1\r\n\r\n    edges.sort()\r\n\r\n    for e in edges:\r\n        u,v = e\r\n        if finalroot(u) != finalroot(v):\r\n            edgecount[u] += 1\r\n            edgecount[v] += 1\r\n            finale.append((u,v))\r\n            union(u,v)\r\n\r\n    root = max(edgecount.keys(), key=(lambda k: edgecount[k]))\r\n    return set(finale),root\r\n\r\ndef main():\r\n\r\n    t = int(input())\r\n\r\n    for i in range(t):\r\n\r\n        n,m = [int(item) for item in input().split()]\r\n        e = set()\r\n        elist = []\r\n\r\n        for i in range(m):\r\n            u,v = [int(item) for item in input().split()]\r\n            elist.append((u,v))\r\n            e.add((u,v))\r\n\r\n        finale,root = minspan(n,list(e))\r\n        sroot = root\r\n        tofix = e - finale\r\n\r\n        indegree = {}\r\n        for i in range(n):\r\n            indegree[i+1] = 0\r\n\r\n        decided = set()\r\n\r\n        # randomly assign directions to edges not in min span\r\n        for t in tofix:\r\n            indegree[t[1]] += 1\r\n            decided.add((t[0],t[1]))\r\n\r\n        cf = {}\r\n        pf = {}\r\n\r\n        for i in range(n):\r\n            cf[i+1] = set()\r\n            pf[i+1] = set()\r\n\r\n        # minspan finale- create tree\r\n        # 2 dics cf - contains each node with it's child\r\n        # pf - each node with it's parent\r\n\r\n        for f in finale:\r\n            u,v = f\r\n            cf[u].add(v)\r\n            cf[v].add(u)\r\n\r\n        r = deque()\r\n        r.append(root)\r\n\r\n        while len(r) != 0:\r\n            root = r.pop()\r\n            for c in cf[root]:\r\n                r.append(c)\r\n                cf[c].remove(root)\r\n                pf[c] = root\r\n\r\n\r\n        q = deque([sroot])\r\n        st = deque()\r\n        # tree traversal\r\n        while len(q) != 0:\r\n            node = q.pop()\r\n            st.append(node)\r\n            for e in cf[node]:\r\n                q.append(e)\r\n\r\n        while len(st) != 0:\r\n            c = st.pop()\r\n            if c != sroot:\r\n                p = pf[c]\r\n                if indegree[c]%2 == 0:\r\n                    #outgoing\r\n                    decided.add((c,p))\r\n                    indegree[p] += 1\r\n                else:\r\n                    decided.add((p,c))\r\n                    indegree[c] += 1\r\n\r\n        possible = (indegree[sroot]%2 == 0)\r\n        if possible:\r\n            ans = []\r\n            for i in elist:\r\n                if i in decided:\r\n                    ans.append(0)\r\n                else:\r\n                    ans.append(1)\r\n            print(*ans)\r\n        else:\r\n            print(-1)\r\n\r\n    return 0\r\n\r\ndef __starting_point():\r\n    main()\r\n\n__starting_point()", "import sys\r\nfrom collections import deque\r\n\r\ndef minspan(n,edges):\r\n\r\n    nodelist = []\r\n    finale = []\r\n    edgecount = {}\r\n\r\n    for i in range(n):\r\n        edgecount[i+1] = 0\r\n\r\n    for i in range(n):\r\n        nodelist.append(set([i+1]))\r\n\r\n    for e in edges:\r\n\r\n        u = e[0]\r\n        v = e[1]\r\n\r\n        for each_set in nodelist:\r\n            if u in each_set:\r\n                save1 = each_set\r\n            if v in each_set:\r\n                save2 = each_set\r\n\r\n        if save1 != save2:\r\n            finale.append((u,v))\r\n            edgecount[u] += 1\r\n            edgecount[v] += 1\r\n            merged = save1 | save2\r\n            nodelist.remove(save1)\r\n            nodelist.remove(save2)\r\n            nodelist.append(merged)\r\n\r\n        if len(nodelist) == 1:\r\n            break\r\n\r\n    root = max(edgecount.keys(), key=(lambda k: edgecount[k]))\r\n    return set(finale),root\r\n\r\ndef main():\r\n\r\n    t = int(input())\r\n\r\n    for i in range(t):\r\n\r\n        n,m = [int(item) for item in input().split()]\r\n        e = set()\r\n        elist = []\r\n\r\n        for i in range(m):\r\n            u,v = [int(item) for item in input().split()]\r\n            elist.append((u,v))\r\n            e.add((u,v))\r\n\r\n        finale,root = minspan(n,e)\r\n        sroot = root\r\n        tofix = e - finale\r\n\r\n        indegree = {}\r\n        for i in range(n):\r\n            indegree[i+1] = 0\r\n\r\n        decided = set()\r\n\r\n        # randomly assign directions to edges not in min span\r\n        for t in tofix:\r\n            indegree[t[1]] += 1\r\n            decided.add((t[0],t[1]))\r\n\r\n        cf = {}\r\n        pf = {}\r\n\r\n        for i in range(n):\r\n            cf[i+1] = set()\r\n            pf[i+1] = set()\r\n\r\n        # minspan finale- create tree\r\n        # 2 dics cf - contains each node with it's child\r\n        # pf - each node with it's parent\r\n\r\n        for f in finale:\r\n            u,v = f\r\n            cf[u].add(v)\r\n            cf[v].add(u)\r\n\r\n        r = deque()\r\n        r.append(root)\r\n\r\n        while len(r) != 0:\r\n            root = r.pop()\r\n            for c in cf[root]:\r\n                r.append(c)\r\n                cf[c].remove(root)\r\n                pf[c] = root\r\n\r\n\r\n        q = deque([sroot])\r\n        st = deque()\r\n        # tree traversal\r\n        while len(q) != 0:\r\n            node = q.pop()\r\n            st.append(node)\r\n            for e in cf[node]:\r\n                q.append(e)\r\n\r\n        while len(st) != 0:\r\n            c = st.pop()\r\n            if c != sroot:\r\n                p = pf[c]\r\n                if indegree[c]%2 == 0:\r\n                    #outgoing\r\n                    decided.add((c,p))\r\n                    indegree[p] += 1\r\n                else:\r\n                    decided.add((p,c))\r\n                    indegree[c] += 1\r\n\r\n\r\n        possible = (indegree[sroot]%2 == 0)\r\n        if possible:\r\n            ans = []\r\n            for i in elist:\r\n                if i in decided:\r\n                    ans.append(0)\r\n                else:\r\n                    ans.append(1)\r\n            print(*ans)\r\n        else:\r\n            print(-1)\r\n\r\n    return 0\r\n\r\ndef __starting_point():\r\n    main()\r\n\n__starting_point()", "import sys\r\nfrom collections import deque\r\n\r\ndef minspan(n,edges):\r\n\r\n    nodelist = []\r\n    finale = []\r\n\r\n    for i in range(n):\r\n        nodelist.append(set([i+1]))\r\n\r\n    for e in edges:\r\n        u = e[0]\r\n        v = e[1]\r\n\r\n        for each_set in nodelist:\r\n            if u in each_set:\r\n                save1 = each_set\r\n            if v in each_set:\r\n                save2 = each_set\r\n\r\n        if save1 != save2:\r\n            finale.append((u,v))\r\n            merged = save1 | save2\r\n            nodelist.remove(save1)\r\n            nodelist.remove(save2)\r\n            nodelist.append(merged)\r\n\r\n        if len(nodelist) == 1:\r\n            break\r\n\r\n    return finale\r\n\r\ndef main():\r\n\r\n    t = int(input())\r\n\r\n    for i in range(t):\r\n\r\n        n,m = [int(item) for item in input().split()]\r\n        e = set()\r\n        elist = []\r\n\r\n        for i in range(m):\r\n            u,v = [int(item) for item in input().split()]\r\n            elist.append((u,v))\r\n            e.add((u,v))\r\n\r\n        finale = set(minspan(n,e))\r\n        tofix = e - finale\r\n\r\n        indegree = {}\r\n        for i in range(n):\r\n            indegree[i+1] = 0\r\n\r\n        decided = set()\r\n\r\n        # randomly assign directions to edges not in min span\r\n        for t in tofix:\r\n            indegree[t[1]] += 1\r\n            decided.add((t[0],t[1]))\r\n\r\n        ## find leaf in finale\r\n        ## fix random root i = 1\r\n        cf = {}\r\n        pf = {}\r\n\r\n        for i in range(n):\r\n            cf[i+1] = set()\r\n            pf[i+1] = set()\r\n\r\n        for f in finale:\r\n            cf[f[0]].add(f[1])\r\n            cf[f[1]].add(f[0])\r\n\r\n        root = 1\r\n        visit = set([root])\r\n        visited = set()\r\n        parent = {}\r\n\r\n        #create the min span tree , every child with one parent\r\n        # root is 1\r\n        while len(visited) < n and len(visit) > 0:\r\n\r\n            v = visit.pop()\r\n            d = cf[v]\r\n            visited.add(v)\r\n\r\n            for i in d:\r\n                if i not in visited:\r\n                    parent[i] = v\r\n                    pf[v].add(i)\r\n                    visit.add(i)\r\n\r\n\r\n        leaf = set()\r\n        for k,v in cf.items():\r\n            if len(v) == 1:\r\n                leaf.add(k)\r\n\r\n\r\n        st = [1]\r\n        sc = [1]\r\n\r\n        # get traversal order from kids to parents\r\n        while len(st) < n+1:\r\n            if len(sc) == 0:\r\n                break\r\n            j = sc.pop()\r\n            for i in pf[j]:\r\n                st.append(i)\r\n                sc.append(i)\r\n\r\n        while len(st) != 1:\r\n\r\n            g = st.pop()\r\n            h = parent[g]\r\n            pair1 = (g,h)\r\n            pair2 = (h,g)\r\n\r\n            if indegree[g]%2 == 0:\r\n                #outgoing\r\n                decided.add(pair1)\r\n                indegree[h] += 1\r\n            else:\r\n                #incoming\r\n                decided.add(pair2)\r\n                indegree[g] += 1\r\n\r\n\r\n        possible = (indegree[root]%2 == 0)\r\n        if possible:\r\n            ans = []\r\n            for i in elist:\r\n                if i in decided:\r\n                    ans.append(0)\r\n                else:\r\n                    ans.append(1)\r\n            print(*ans)\r\n        else:\r\n            print(-1)\r\n\r\n\r\n    return 0\r\n\r\n\r\ndef __starting_point():\r\n    main()\r\n\n__starting_point()", "for t in range(int(input())):\r\n    n,m=map(int,input().split())\r\n    g=[[]for _ in range(n+1)]\r\n    long=[]\r\n    di={}\r\n    stable=[0]*(n+1)\r\n    edges=[0]*(m)\r\n    for i in range(m):\r\n        x,y=map(int,input().split())\r\n        g[x].append(y)\r\n        g[y].append(x)\r\n        stable[y]+=1\r\n        long.append([x,y])\r\n        di[(x,y)]=i\r\n        di[(y,x)]=i\r\n    f=1\r\n    if m%2:\r\n        f=0\r\n    for i in range(m):\r\n        c,d=long[i][0],long[i][1]\r\n        if stable[c]%2==1 and stable[d]%2==1:\r\n            stable[c]+=1\r\n            stable[d]-=1\r\n            edges[i]=1\r\n    s=[]\r\n    for i in range(1,n+1):\r\n        if stable[i]%2==1:\r\n            s.append(i)\r\n    while s and f:\r\n        set1=set()\r\n        for i in s:\r\n            if stable[i]%2:\r\n                y=g[i][0]\r\n                w=di[(i,y)]\r\n                if edges[x]:\r\n                    stable[y]+=1\r\n                    stable[i]-=1\r\n                else:\r\n                    stable[i]+=1\r\n                    stable[y]-=1\r\n                set1.add(y)\r\n                edges[w]=abs(edges[w]-1)\r\n        s=set1\r\n    if(f):\r\n        print(*edges)\r\n    else:\r\n        print(-1)", "for _ in range(int(input())):\r\n    N, M = [int(x) for x in input().split()]\r\n    edges = [0]*M\r\n    dir = {}\r\n    nodes = [[] for j in range(N+1)]\r\n    ind = [0]*(N+1)\r\n    graph = {}\r\n    final_edges = []\r\n    for i in range(M):\r\n        u, v = [int(x) for x in input().split()]\r\n        nodes[u].append(v)\r\n        nodes[v].append(u)\r\n        dir[(u,v)]=1\r\n        dir[(v,u)] = 0\r\n        ind[v] += 1\r\n        graph[(u,v)] = graph[(v,u)] = i\r\n        final_edges.append([u,v])\r\n    if M%2!=0:\r\n        print(-1)\r\n        continue\r\n    for i in range(M):\r\n        u, v = final_edges[i]\r\n        if ind[u]%2!=0 and ind[v]%2!=0:\r\n            d = dir[(u,v)]\r\n            if d:\r\n                ind[u] += 1\r\n                ind[v] -= 1\r\n                dir[(u,v)] = 0\r\n                dir[(v,u)] = 1\r\n                edges[i] = abs(edges[i]-1)\r\n            else:\r\n                ind[u] -= 1\r\n                ind[v] += 1\r\n                dir[(u, v)] = 1\r\n                dir[(v, u)] = 0\r\n                edges[i] = abs(edges[i]-1)\r\n    s = []\r\n    for i in range(1, N+1):\r\n        if ind[i]%2:\r\n            s.append(i)\r\n    while s:\r\n        set1 = set()\r\n        for u in s:\r\n            if ind[u]%2:\r\n                v = nodes[u][0]\r\n                d = dir[(u,v)]\r\n                index = graph[(u, v)]\r\n                set1.add(v)\r\n                if d:\r\n                    ind[u] += 1\r\n                    ind[v] -= 1\r\n                    dir[(u, v)] = 0\r\n                    dir[(v, u)] = 1\r\n                    edges[index] = abs(edges[index]-1)\r\n                else:\r\n                    ind[u] -= 1\r\n                    ind[v] += 1\r\n                    dir[(u, v)] = 1\r\n                    dir[(v, u)] = 0\r\n                    edges[index] = abs(edges[index]-1)\r\n\r\n        s = set1\r\n    print(*edges)", "for _ in range(int(input())):\r\n    l=[]\r\n    mp={}\r\n    cr={}\r\n    ans=[]\r\n    n,m=map(int,input().split())\r\n    for i in range(1,n+1):\r\n        mp[i]=0\r\n        cr[i]=False\r\n    for _ in range(m):\r\n        f,t=map(int,input().split())\r\n        l.append((f,t))\r\n        mp[f]+=1\r\n        mp[t]+=1\r\n    if m%2>0:\r\n        print(-1)\r\n        continue\r\n    else:\r\n        for _ in range(m):\r\n            cr[l[_][1]]=not cr[l[_][1]]\r\n            ans.append(0)\r\n        for _ in range(m-1,-1,-1):\r\n            if cr[l[_][1]]==True:\r\n                cr[l[_][1]]=not True\r\n                ans[_]=1\r\n                if cr[l[_][0]]:\r\n                    cr[l[_][0]]=False\r\n                else:\r\n                    cr[l[_][0]]=True\r\n        for i in range(len(ans)):\r\n            print(ans[i],end=' ')\r\n        print()\r\n    "]
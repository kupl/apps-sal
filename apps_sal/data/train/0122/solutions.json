["class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        max_score = 0\n        curr_score= 0\n        init_hand = cardPoints[len(cardPoints)-k:]\n        max_score = sum(init_hand)\n        curr_score = max_score\n        for i in range(k):\n            curr_score -= init_hand[i]\n            curr_score += cardPoints[i]\n            if curr_score > max_score:\n                max_score = curr_score\n        return max_score", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints) - k\n        min = 0\n        window = 0\n        all = 0\n        for i in range(n):\n            window += cardPoints[i]\n            all += cardPoints[i]\n        min = window\n        # print(all)\n\n        for x in range(k):\n            # print(x)\n            all += cardPoints[x+n]\n            window -= cardPoints[x]\n            window += cardPoints[x+n]\n            if window < min:\n                min = window\n        return all - min\n        # print(all)\n        # print(all-min)\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        result = curr = 0\n        for i in range(-k, k):\n            curr += cardPoints[i]\n            if i >= 0:\n                curr -= cardPoints[i - k]\n            result = max(result, curr)\n        return result", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        # dfs TLE\n        # use sliding window instead\n        # keep moving a window of size n - k along the way\n        \n        maxSum = sum(cardPoints)\n        if len(cardPoints) <= k:\n            return maxSum\n        \n        subSum = 0\n        ans = 0\n        for i in range(len(cardPoints)):\n            subSum += cardPoints[i]\n            \n            if i + 1 >= (len(cardPoints) - k):\n                ans = max(ans, maxSum - subSum)\n                subSum -= cardPoints[i - (len(cardPoints) - k - 1)]\n        \n        return ans\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        answer = 0\n        left = [0]*len(cardPoints)\n        right = [0]*len(cardPoints)\n        \n        for i in range(len(cardPoints)) :\n            if i == 0 : left[0] = cardPoints[0]\n            else :\n                left[i] = left[i-1] + cardPoints[i]\n        \n        for i in range(len(cardPoints)-1,-1,-1) :\n            if i == len(cardPoints)-1 : right[-1] = cardPoints[-1]\n            else :\n                right[i] = right[i+1] + cardPoints[i]\n        \n        for i in range(k+1) :\n            if i == 0 : Sum = right[-k]\n            elif i == k : Sum = left[k-1]\n            else : \n                Sum = left[k-i-1] + right[-i]\n            answer = max(answer,Sum)\n        return answer                ", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        size = len(cardPoints) - k\n        minSum = float('inf')\n        cur = 0\n        left = 0\n        \n        for i, v in enumerate(cardPoints):\n            cur += v\n            if i - left + 1 > size:\n                cur -= cardPoints[left]\n                left += 1\n            if i - left + 1 == size:\n                minSum = min(minSum, cur)\n                \n        return sum(cardPoints) - minSum\n        \n            \n", "class Solution:\n    def maxScore(self, points: List[int], num_cards: int) -> int:\n        size = len(points) - num_cards\n        min_subarray_sum = math.inf\n        left = curr = 0\n        for right, val in enumerate(points):\n            curr += val\n            if right - left + 1 > size:\n                curr -= points[left]\n                left += 1\n            if right - left + 1 == size:\n                min_subarray_sum = min(min_subarray_sum, curr)\n        return sum(points) - min_subarray_sum", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints) - k\n        min = 0\n        window = 0\n        all = 0\n        for i in range(n):\n            window += cardPoints[i]\n            all += cardPoints[i]\n        min = window\n        # print(all)\n\n        for x in range(k):\n            # print(x)\n            y = x+n\n            all += cardPoints[y]\n            window -= cardPoints[x]\n            window += cardPoints[y]\n            if window < min:\n                min = window\n        return all - min\n        # print(all)\n        # print(all-min)\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        # The Edge Case not needed here: if k > len(cardPoints) or k<=0: raise ValueErro('')\n        left, right = [0], [0]\n        for i in range(k):\n            left.append(left[-1]+ cardPoints[i])\n            right.append(right[-1] + cardPoints[len(cardPoints) -1 - i])\n        \n        res  = 0 \n        for i in range(k+1):\n            \n            x = left[i] + right[k-i]\n            res = max(res,x)\n            \n        return res\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        # The Edge Case not needed here: if k > len(cardPoints) or k<=0: raise ValueErro('')\n        # Your solution is O(N) and this solution is O(k)\n        # Eventhough the real time is similar, O(k) is better\n        left = [0] * (k+1)\n        right = [0] * (k+1)\n        for i in range(k):\n            left[i+1] = left[i] + cardPoints[i]\n            right[i+1] = right[i] + cardPoints[-i-1]\n        return max(left[j]+right[k-j] for j in range(k+1))", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:        \n        left_cumsum = [0]\n        right_cumsum = [0]\n        for p in cardPoints[:k+1]:\n            left_cumsum.append(left_cumsum[-1] + p)\n        for p in reversed(cardPoints[-(k+1):]):\n            right_cumsum.append(right_cumsum[-1] + p)\n        \n        result = 0\n        for i in range(k+1):\n            result = max(result, left_cumsum[i] + right_cumsum[k-i])\n        return result", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        left, right = [0], [0]\n        for i in range(len(cardPoints)):\n            left.append(left[-1]+cardPoints[i])\n            right.append(right[-1]+cardPoints[-i-1])\n        return max(left[i]+right[k-i] for i in range(k+1))", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        \n        n = len(cardPoints)\n        \n        # prefix sum solution\n        pre = [0]*(n+1)\n        for i in range(n):\n            pre[i+1] = pre[i] + cardPoints[i]\n            \n        max_val = -1\n        \n        for i in range(k+1):\n            max_val = max(max_val, pre[i] + pre[n] - pre[n-k+i])\n            \n        return max_val\n        \n#         if k >= n:\n#             return sum(cardPoints)\n        \n#         def dfs(i,j):\n#             if i + (n-j-1) >= k:\n#                 return 0\n            \n#             else:\n#                 return max(dfs(i+1,j)+cardPoints[i], dfs(i,j-1)+cardPoints[j])\n            \n#         return dfs(0,n-1)\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        total = sum(cardPoints)\n        if n == k or n < k : return total \n        remove = n - k\n        ans = 0\n        \n        '''memo = [0]*(n+1)\n        memo[0] = 0\n        \n        start = 0\n        for i in range(0, n):\n            memo[i+1] = memo[i] + cardPoints[i]            \n            if i-start + 1 == remove: \n                ans = max(ans, total-(memo[i+1]-memo[start]))\n                start = start+1'''\n        curr = 0\n        start = 0\n        for right in range(n):\n            curr += cardPoints[right]\n            if right-start+1 == remove:\n                ans = max(ans, total-curr)\n                curr -= cardPoints[start]\n                start +=1\n            \n            \n        return ans", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        left, right = [0], [0]\n        for i in range(k):\n            left.append(left[-1]+ cardPoints[i])\n            right.append(right[-1] + cardPoints[len(cardPoints) -1 - i])\n        \n        res  = 0 \n        for i in range(k+1):\n            \n            x = left[i] + right[k-i]\n            res = max(res,x)\n            \n        return res\n            \n\n#         front_sum=back_sum=[0]\n#                 print 'cardPoints:', cardPoints\n#         print 'k:', k\n#         frontSum, backSum = [0], [0]\n#         for n in cardPoints:\n#             frontSum.append(frontSum[-1]+n)\n#             print 'frontSum:', frontSum\n#         for n in cardPoints[::-1]:\n#             backSum.append(backSum[-1]+n)\n#             print 'backSum:', backSum\n#         allCombinations = [frontSum[i]+backSum[k-i] for i in range(k+1)]\n#         print 'allCombinations:', allCombinations\n#         return max(allCombinations)\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        min_len = len(cardPoints) - k\n        curr_sum = 0\n        min_val = 0\n        for start in range(len(cardPoints) - min_len + 1):\n            if start == 0:\n                curr_sum = sum(cardPoints[start:start+min_len])\n                min_val = curr_sum\n            else:\n                curr_sum = curr_sum - cardPoints[start - 1] + cardPoints[start+min_len-1] \n                if min_val > curr_sum:\n                    min_val = curr_sum\n        \n        return sum(cardPoints) - min_val\n            \n\n#         front_sum=back_sum=[0]\n#                 print 'cardPoints:', cardPoints\n#         print 'k:', k\n#         frontSum, backSum = [0], [0]\n#         for n in cardPoints:\n#             frontSum.append(frontSum[-1]+n)\n#             print 'frontSum:', frontSum\n#         for n in cardPoints[::-1]:\n#             backSum.append(backSum[-1]+n)\n#             print 'backSum:', backSum\n#         allCombinations = [frontSum[i]+backSum[k-i] for i in range(k+1)]\n#         print 'allCombinations:', allCombinations\n#         return max(allCombinations)\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints) - k\n        min = 0\n        window = 0\n        all = 0\n        for i in range(n):\n            window += cardPoints[i]\n            all += cardPoints[i]\n        min = window\n        print(all)\n\n        for x in range(k):\n            print(x)\n            all += cardPoints[x+n]\n            window -= cardPoints[x]\n            window += cardPoints[x+n]\n            if window < min:\n                min = window\n        return all - min\n        # print(all)\n        # print(all-min)\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        sums = [0] * (n+1)\n        for i in range(1, n+1):\n            sums[i] = sums[i-1] + cardPoints[i-1]\n            \n        ans = float('inf')\n        for i in range(k+1):\n            ans = min(ans, sums[i+n-k] - sums[i])\n        \n        print((sums, ans))\n        return sums[-1] - ans\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        s = sum(cardPoints)\n        if k >= len(cardPoints):\n            return s\n        maxPoint = 0\n        cur = 0\n        j = 0\n        # i-j+k == n\n        n = len(cardPoints)\n        for i, point in enumerate(cardPoints):\n            if i-j+k > n-1:\n                cur -= cardPoints[j]\n                j += 1\n            cur += point\n            if i-j+k == n-1:\n                maxPoint = max(maxPoint, s-cur)\n        return maxPoint\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        # find a subarray in the middle that its sum is min, maintain n-k length\n        n = len(cardPoints)\n        runningsum = 0\n        start = end = 0\n        total = sum(cardPoints)\n        minsum = float('inf')\n        while end < len(cardPoints):\n          runningsum += cardPoints[end]\n          if end - start + 1 > n-k:\n            runningsum -= cardPoints[start]\n            start += 1\n          if end - start + 1 == n-k:\n            minsum = min(minsum, runningsum)\n          end += 1\n        return total-minsum\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        \n#         cardLen = len(cardPoints)\n#         if cardLen == k:\n#             return sum(cardPoints)\n        \n#         dp = {}\n#         def takeCard(l0, r0, k0):\n#             if k0 == 1:\n#                 return max(cardPoints[l0], cardPoints[r0])\n#             if (l0, r0, k0) in dp:\n#                 return dp[(l0, r0, k0)]\n            \n#             ans = max(cardPoints[l0] + takeCard(l0+1, r0, k0-1), cardPoints[r0] + takeCard(l0, r0-1, k0-1))\n#             dp[(l0, r0, k0)] = ans\n            \n#             return ans\n        \n#         return takeCard(0, cardLen-1, k)\n        cardLen = len(cardPoints)\n        frontSum = [0]\n        for num in cardPoints:\n            frontSum.append(frontSum[-1]+ num)\n        backSum = [0 for _ in range(cardLen + 1)]\n        for i in range(cardLen - 1, -1, -1):\n            backSum[i] = cardPoints[i] + backSum[i+1]\n        ans = frontSum[k]\n        for i in range(k):\n            ans = max(ans, frontSum[i] + backSum[-(k-i)-1])\n        return ans", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        left, right = [0], [0]\n        for i in range(k):\n            left.append(left[-1]+ cardPoints[i])\n            right.append(right[-1] + cardPoints[len(cardPoints) -1 - i])\n        print(left)\n        print(right)\n        res  = 0 \n        for i in range(k+1):\n            \n            x = left[i] + right[k-i]\n            res = max(res,x)\n            \n        return res\n            \n            \n        \n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        forwardSum = [m for m in cardPoints]\n        backwardSum = cardPoints.copy()\n        backwardSum.append(0)\n        for c in range(1, len(cardPoints)):\n            forwardSum[c] = forwardSum[c-1] + forwardSum[c]\n        \n        for l in range(len(cardPoints)-2, 0, -1):\n            backwardSum[l] = backwardSum[l+1] + backwardSum[l]\n        maximum = 0\n        for i in range(k-1, -2, -1):\n            if i != -1:\n                maximum = max(maximum, forwardSum[i] + backwardSum[len(backwardSum)-1-(k-1-i)])\n            else:\n                maximum = max(maximum, backwardSum[len(backwardSum)-1-k])\n                              \n        return maximum\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints) - k\n        min = 0\n        window = 0\n        all = 0\n        for i in range(n):\n            window += cardPoints[i]\n        min = window\n        all = window\n        # print(all)\n\n        for x in range(k):\n            # print(x)\n            all += cardPoints[x+n]\n            window -= cardPoints[x]\n            window += cardPoints[x+n]\n            if window < min:\n                min = window\n        return all - min\n        # print(all)\n        # print(all-min)\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        score = sum(cardPoints[:k])\n        best = score\n        \n        for i in range(k):\n            score += cardPoints[-(i+1)] - cardPoints[k-i-1]\n            if score > best:\n                best = score\n            \n        return best", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        leftsum = [0] * len(cardPoints)\n        rightsum = [0] * len(cardPoints)\n        n = len(cardPoints)\n        leftsum[0] = cardPoints[0]\n        rightsum[n-1] = cardPoints[n-1]\n        for i in range(1,n):\n            leftsum[i] = leftsum[i-1] + cardPoints[i]\n            rightsum[n-1-i] = rightsum[n-1-i+1] + cardPoints[n-1-i]\n            \n        res = max(leftsum[k-1],rightsum[-(k-1+1)])\n\n        \n        for i in range(k-1):\n            \n            res = max((leftsum[i] + rightsum[-(k-i-1)]), res)\n            \n        return res", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        '''\n        convert this into a sliding window problem\n        rephrase the problem:\n            find the max window of length k between cardPoints[n-k:n+k]\n        [1,2,3,4,5,6]\n        k = 2\n        4,5,0,1\n        \n            \n        '''\n        ans = 0\n        curSum = 0\n        n = len(cardPoints)\n        for i in range(n-k, n+k):\n            curSum += cardPoints[i%n]\n            if i >= n:\n                curSum -= cardPoints[(i-k)%n]\n            ans = max(ans, curSum)\n        return ans\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        if not cardPoints or len(cardPoints) == 0:\n            return 0\n        window = len(cardPoints) - k\n        res = float('inf')\n        s = 0\n        for i in range(window):\n            s += cardPoints[i]\n        res = min(s, res)\n        for i in range(window, len(cardPoints)):\n            print(cardPoints[i],s,i)\n            s -= cardPoints[i-window]\n            s += cardPoints[i]\n            res = min(s, res)\n        return sum(cardPoints) - res", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        \n        n = len(cardPoints)\n        if n == k:\n            return sum(cardPoints)\n        \n        pre, post = [0] * (n + 1), [0] * (n + 1)\n        for i in range(1, n + 1):\n            pre[i] = pre[i - 1] + cardPoints[i - 1]\n        for i in range(1, n + 1):\n            post[i] = post[i - 1] + cardPoints[n - i]\n            \n        best = 0\n        \n        # n = 7\n        # k = 3\n        # i = 0\n        # x = 5\n        # print (pre, post)\n        for i in range(k + 1):\n            best = max(best, pre[i] + post[k - i])\n        \n        return best", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        if k == len(cardPoints):\n            return sum(cardPoints)\n        front = [0] * k\n        back = [0] * k\n        front[0] = cardPoints[0]\n        for i in range(1,k):\n            front[i] = front[i-1] + cardPoints[i]\n            \n        back[0] = cardPoints[-1]\n        for i in range(1,k):\n            back[i] = back[i-1] + cardPoints[-1-i]\n        \n        max_score = 0\n        print(front,back)\n        for i in range(k+1):\n            if i == 0:\n                max_score = max(max_score,back[-1])\n                # print(i,back[-1])\n            elif i == k:\n                max_score = max(max_score,front[k-1])\n                # print(i,front[k-1])\n            else:\n                max_score = max(max_score,front[i-1]+back[k-i-1])\n                # print(i,k-i,max_score,front[i-1]+back[k-i-1])\n            # print(i,k-i,max_score)\n        return max_score", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        length = len(cardPoints)\n        total = sum(cardPoints)\n        if k == length:\n            return total\n        curr = 0\n        temp = 2 ** 31 - 1\n        left = 0\n        for right in range(length):\n            curr += cardPoints[right]\n            if right - left + 1 < length - k:\n                continue\n            print(right, curr)\n            temp = min(temp, curr)\n            curr -= cardPoints[left]\n            left += 1\n        \n        return total - temp", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        \n        cum_sum = [0 for i in range(n)]\n        cum_sum[0] = cardPoints[0]\n        rev_sum = [0 for i in range(n)]\n        rev_sum[0] = cardPoints[-1]\n        \n        \n        for i in range(1,n):\n            cum_sum[i] = cum_sum[i-1]+cardPoints[i]\n            rev_sum[i] = rev_sum[i-1]+cardPoints[n-i-1]\n            \n        max_sum = max(cum_sum[k-1],rev_sum[k-1])\n        \n        for i in range(1,k):\n            max_sum = max(max_sum,(cum_sum[i-1]+rev_sum[k-i-1]))\n            \n        return max_sum\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        remainCnt = len(cardPoints) - k\n        if remainCnt == 0: return sum(cardPoints)\n        minRemainSum = float('inf')\n        curr = 0\n        cnt = 0\n        for i in range(len(cardPoints)):\n            cnt += 1\n            curr += cardPoints[i]\n            if cnt == remainCnt:\n                minRemainSum = min(minRemainSum, curr)\n                curr -= cardPoints[i + 1 - cnt]\n                cnt -= 1\n        \n        return sum(cardPoints) - minRemainSum\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        # Sliding window of length k\n        ans = total = sum(cardPoints[:k])\n        for i in range(1, k+1):\n            total -= cardPoints[k-i]\n            total += cardPoints[-1-i+1]\n            ans = max(ans, total)\n        return ans\n", "from collections import deque\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        first = deque(cardPoints[0:k])\n        second = deque(cardPoints[len(cardPoints)-k:])\n        final = 0\n        \n        firstSum = sum(first)\n        secondSum = sum(second)\n        \n        for i in range(k):\n            if firstSum > secondSum:\n                final += first[0]\n                firstSum -= first.popleft()\n                secondSum -= second.popleft()\n                \n            else:\n                final += second[len(second)-1]\n                firstSum -= first.pop()\n                secondSum -= second.pop()\n\n        return final", "class Solution:\n    def maxScore(self, cardPoints, k: int) -> int:\n        N = len(cardPoints)\n        preS, afterS = [0]*(N+1), [0]*(N+1)\n        ans = 0\n        for i in range(1,N+1):\n            preS[i]=preS[i-1]+cardPoints[i-1]\n        for j in range(1,N+1):\n            afterS[j] = afterS[j-1]+cardPoints[N-j]\n        for l in range(k+1):\n            ans = max(ans,preS[l]+afterS[k-l])\n        return ans", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        right_index = len(cardPoints)-k\n        curr_max = sum(cardPoints[right_index:])\n        curr_sum = curr_max\n        for left_index in range(0, k):\n            curr_sum -= cardPoints[right_index]\n            right_index += 1\n            curr_sum += cardPoints[left_index]\n            if curr_sum > curr_max:\n                curr_max = curr_sum\n        return curr_max\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        \n        n = len(cardPoints)\n        \n        cum_sum = [0 for i in range(n)]\n        cum_sum[0] = cardPoints[0]\n        rev_sum = [0 for i in range(n)]\n        rev_sum[0] = cardPoints[-1]\n        \n        \n        for i in range(1,n):\n            cum_sum[i] = cum_sum[i-1]+cardPoints[i]\n            rev_sum[i] = rev_sum[i-1]+cardPoints[n-i-1]\n            \n        max_sum = max(cum_sum[k-1],rev_sum[k-1])\n        \n        for i in range(1,k):\n            max_sum = max(max_sum,(cum_sum[i-1]+rev_sum[k-i-1]))\n        \n        return max_sum", "class Solution:\n    def maxScore(self, A: List[int], k: int) -> int:    \n        su = sum(A[:k])\n        n = len(A) \n        res = su   \n        for i in range(k):\n            su -= A[k-i-1]\n            su += A[n-i-1]\n            res = max(res, su) \n        return res", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        # sum of points from left most\n        # sum of points from right most\n        # sum of points from both left and right\n        \n        # defualt max_sum\n        total = sum(cardPoints[:k])\n            \n        # if k == len(cardPoitns), result is the total sum of cardPoints\n        if k == len(cardPoints):\n            return total\n        max_sum = total\n        print(max_sum)\n        \n        # compute sum from left to right\n        for i in range(k - 1, -1, -1):\n            total = total + cardPoints[i - k] - cardPoints[i]\n            print((i-k, total, cardPoints[i - k], cardPoints[i]))\n            if total > max_sum:\n                max_sum = total\n        return max_sum\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        j = len(cardPoints) - 1\n        ms = 0\n        \n        for i in range(k):\n            ms += cardPoints[j]\n            j -= 1\n            \n        cand = ms\n        \n        for i in range(k):\n            cand += cardPoints[i] - cardPoints[j+1]\n            j += 1\n            ms = max(cand, ms)\n            \n        return ms", "class Solution:\n    def maxScore(self, nums: List[int], k: int) -> int:\n        \n        n = len(nums)\n\n        if k == n:\n            return sum(nums)\n        \n        pre =[0]\n        post = []\n        \n        for e in nums:\n            pre.append(pre[-1]+e)\n            post.append(e)\n        post.append(0)\n        \n        \n        for i in range(n-1,-1,-1):\n            post[i] = post[i+1] + nums[i]\n            \n        res = 0\n        j = n - k\n        \n        while j <= n:\n            res = max(res, pre[i] + post[j])\n            \n            i+=1\n            j+=1\n            \n        return res", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        if len(cardPoints) < k:\n            return -1\n        \n        remain = len(cardPoints) - k\n        suum = sum(cardPoints[:remain])\n        min_suum = suum\n        for i in range(remain, len(cardPoints)):\n            suum = suum - cardPoints[i-remain] + cardPoints[i]\n            min_suum = min(min_suum, suum)\n        return sum(cardPoints) - min_suum", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        sums = [0] * (n+1)\n        for i in range(1, n+1):\n            sums[i] = sums[i-1] + cardPoints[i-1]\n            \n        ans = float('inf')\n        for i in range(k+1):\n            ans = min(ans, sums[i+n-k] - sums[i])\n        \n        return sums[-1] - ans\n", "class Solution:\n    def maxScore(self, A: List[int], k: int) -> int:    \n        su = sum(A[:k])\n        res = su   \n        for i in range(k):\n            su -= A[k-i-1]\n            su += A[len(A)-i-1]\n            res = max(res, su) \n        return res", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints) - k\n        l, r, res, count = 0, 0, sum(cardPoints[:n]), 0\n        while r < len(cardPoints):\n            count += cardPoints[r]\n            if r >= n:\n                count -= cardPoints[l]\n                l += 1\n                res = min(res, count)\n            r += 1\n        return sum(cardPoints) - res", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        pre = [cardPoints[0]]\n        n = len(cardPoints)\n        for i in range(1, n):\n            pre.append(pre[-1] + cardPoints[i])\n        \n        if k == n:\n            return pre[-1]\n        \n        s = pre[-1]\n        cur_s = pre[n - k - 1]\n        l = 0\n        r = n - k + l - 1\n        ans = s - pre[n - k - 1]\n        \n        while l != len(cardPoints) - (n - k) :\n            cur_s -= cardPoints[l]\n            l += 1\n            r += 1\n            cur_s += cardPoints[r]\n            ans = max(ans, s - cur_s)\n            \n        return ans\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints) - k\n        current = 0\n        for i in range(n):\n            current += cardPoints[i]\n        result = current\n        \n        for i in range(1, k+1):\n            current -= cardPoints[i-1]\n            current += cardPoints[i+n-1]\n            result = min(result, current)\n        \n        return sum(cardPoints) - result\n        \n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        f, b = [0], [0]\n        for n in cardPoints:\n            f.append(f[-1] + n)\n        for n in cardPoints[::-1]:\n            b.append(b[-1] + n)\n        allCombo = [f[i] + b[k-i] for i in range(k+1)]\n        return max(allCombo)\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        \n        points_L = []\n        points_R = []\n        \n        for p in cardPoints:\n            if len(points_L): points_L.append(points_L[-1] + p)\n            else: points_L.append(p)\n        for p in cardPoints[::-1]:\n            if len(points_R): points_R.append(points_R[-1] + p)\n            else: points_R.append(p)\n        points_R = points_R[::-1]\n            \n        return self.solution(points_L, points_R, k)\n    \n\n    def solution(self, points_L, points_R, k):\n        max = 0\n        for i in range(k+1):\n            cmp1 = points_L[i-1] if i > 0 else 0\n            cmp2 = points_R[-(k-i)] if i < k else 0\n            score = cmp1 + cmp2\n            if score > max:\n                max = score\n        return max\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        left_sums = [0] * (k + 1)\n        right_sums = [0] * (k + 1)\n        \n        \n        for i in range(k):\n            left_sums[i+1] = left_sums[i] + cardPoints[i]\n            right_sums[i+1] = right_sums[i] + cardPoints[len(cardPoints)-i-1]\n        \n\n        res = 0\n        for i in range(k+1): # we must include K as a choice\n            j = k-i\n            res = max(res, left_sums[i] + right_sums[j])\n        \n        return res\n", "from functools import lru_cache\nimport sys\nfrom itertools import accumulate\n\nsys.setrecursionlimit(10**5)\n\n\nclass Solution:\n    def maxScore(self, arr: List[int], k: int) -> int:\n\n        n = len(arr)\n        pre = list(accumulate(arr))\n        total = pre[-1]\n        # print(f'{pre=}')\n        \n        if k == n:\n            return total\n        \n        w = n-k\n        result = 0 \n        # print(f'{w=}')\n        \n        for i in range(w-1, n):\n            # print(f'{i=}')\n            sub_sum = total - (pre[i] - pre[i-w+1] + arr[i-w+1])\n            result = max(result, sub_sum)\n            \n            \n        return result", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        curr_max = sum(cardPoints[0:k])\n        curr_sum = curr_max\n        for i in range(1, k+1):\n            curr_sum = curr_sum - cardPoints[k-i] + cardPoints[-i]\n            curr_max = max(curr_max, curr_sum)\n        return curr_max\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        size = len(cardPoints)\n        maxRightSum = sum(cardPoints[size-k:])\n        ans = maxRightSum\n        currSum = maxRightSum\n        # sum with left\n        for i in range(k):\n            currSum = currSum - cardPoints[size-k+i] + cardPoints[i]\n            ans = max(ans, currSum)\n        return ans\n    # def maxScore(self, cardPoints: List[int], k: int) -> int:\n    #     windowEnd = 0\n    #     size = len(cardPoints) - k\n    #     ans = float(\\\"inf\\\")\n    #     currSum = 0\n    #     for windowStart, point in enumerate(cardPoints):\n    #         currSum += point\n    #         if windowStart - windowEnd + 1 > size:\n    #             currSum -= cardPoints[windowEnd]\n    #             windowEnd += 1\n    #         if windowStart - windowEnd + 1 == size:\n    #             ans = min(ans, currSum)\n    #     return sum(cardPoints) - ans\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        curr_max = sum(cardPoints[0:k])\n        curr_sum = curr_max\n        for i in range(1, k+1):\n            curr_sum = curr_sum - cardPoints[k-i] + cardPoints[-i]\n            curr_max = max(curr_max, curr_sum)\n        return curr_max\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        totalPoints, window = sum(cardPoints), len(cardPoints) - k\n        i, j, Sum, Min = 0, 0, 0, totalPoints\n        \n        while j < len(cardPoints):\n            Sum += cardPoints[j]\n            \n            if j - i + 1 > window:\n                Sum -= cardPoints[i]\n                i += 1\n            \n            if j - i + 1 == window: Min = min(Min, Sum)\n            j += 1\n        \n        # print(Min)\n        return totalPoints - Min\n        \n        \n        \n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        if len(cardPoints) < k:\n            return 0\n        if len(cardPoints) == k:\n            return sum(cardPoints)\n        n = len(cardPoints)\n        res, cur = sum(cardPoints[:k]), sum(cardPoints[:k])\n        for i in range(k):\n            cur += cardPoints[n-i-1]-cardPoints[k-1-i]\n            res = max(res, cur)\n        return res", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        if not cardPoints or k==0:\n            return 0\n        for i in range(1,len(cardPoints)):\n            cardPoints[i]+=cardPoints[i-1]\n            \n        if k==len(cardPoints):\n            return cardPoints[-1]\n        ans=cardPoints[k-1]\n        \n        for i in range(1,k+1):\n            print(i)\n            ans=max(ans,cardPoints[k-i]+cardPoints[-1]-cardPoints[-i])\n            print(cardPoints[k-i],cardPoints[-1]-cardPoints[-i])\n        return max(ans,cardPoints[-1]-cardPoints[-(k+1)])", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        left = n - k\n        mini = sum(cardPoints[:left])\n        cur = mini\n        for i in range(left, n):\n            cur = cur - cardPoints[i-left] + cardPoints[i]\n            mini = min(mini, cur)\n        \n        return sum(cardPoints) - mini", "class Solution:\n    def maxScore(self, card_points: List[int], k: int) -> int:\n        window_size = len(card_points) - k\n        current_min_sum, min_sum = 0, sys.maxsize\n        total_points = 0\n        left = 0\n        for right, value in enumerate(card_points):\n            total_points += value\n            current_min_sum += value\n\n            current_size = right - left + 1\n            if current_size < window_size:\n                continue\n\n            if current_size > window_size:\n                current_min_sum -= card_points[left]\n                left += 1\n\n            min_sum = min(min_sum, current_min_sum)\n\n        return total_points - min_sum\n", "def max_score_using_subsequence(card_points, k):\n    l = len(card_points) - k\n    if l == 0:\n        return sum(card_points)\n    \n    sum_subsequence = 0\n    for i in range(l):\n        sum_subsequence += card_points[i]\n    \n    lowest = sum_subsequence\n    for i in range(len(card_points) - l):\n        sum_subsequence = sum_subsequence - card_points[i] + card_points[i+l]\n        if sum_subsequence < lowest:\n            lowest = sum_subsequence\n    \n    return sum(card_points) - lowest\n    \n\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        # return max_score_recursive(cardPoints, k, 0, len(cardPoints)-1, {})\n        return max_score_using_subsequence(cardPoints, k)", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        psum = sum(cardPoints[:k])\n        res = psum\n        n = len(cardPoints)\n        for i in range(k):\n            psum += cardPoints[n - i - 1] - cardPoints[k - i - 1]\n            res = max(res, psum)\n        return res\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        pre_sum = []   # i: sum of all items before i\n        temp_left = 0\n        for i, v in enumerate(cardPoints):\n            pre_sum.append(temp_left)\n            temp_left += v\n        pre_sum.append(temp_left)\n        \n        post_sum = []  # i: sum of all items after i-1\n        temp_right = 0\n        temp_right = 0\n        for i in range(len(cardPoints)-1, -1, -1):\n            v = cardPoints[i]\n            post_sum.append(temp_right)\n            temp_right += v\n        post_sum.append(v)\n        post_sum.reverse()\n        # print(pre_sum)\n        # print(post_sum)\n        return max([pre_sum[i] + post_sum[-(k-i)-1] for i in range(k+1)])\n            \n            \n            \n\n", "from collections import deque\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        cards = n-k\n        minimum = 0\n        if (cards != 0):\n            sum1 = 0\n            q = deque()\n            for i in range(cards):\n                q.append(cardPoints[i])\n                sum1 += cardPoints[i]\n            minimum = sum1\n            for i in range(cards, n):\n                first = q.popleft()\n                q.append(cardPoints[i])\n                sum1 -=first\n                sum1 += cardPoints[i]\n                if (sum1 < minimum):\n                    minimum = sum1\n        #else:\n         #   minimum = 0\n        print(minimum)\n        return sum(cardPoints) - minimum\n", "class Solution:\n    def maxScore(self, l: List[int], k: int) -> int:\n        length = len(l)\n        \n        if k == length:\n            return sum(l)\n        elif k == 0:\n            return 0\n        \n        k = length - k\n        v = curr_min = sum(l[:k])\n        \n        for i in range(k,length):\n            v =  v - l[i-k] + l[i]\n            curr_min = min(curr_min, v)\n        \n        return sum(l) - curr_min\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        if k == len(cardPoints):\n            return sum(cardPoints)\n        size = len(cardPoints) - k\n        min_sum = float('inf')\n        left = 0\n        right = 0\n        window_sum = 0\n        while right < len(cardPoints):\n            window_sum += cardPoints[right]\n            right += 1\n            while right - left == size:\n                min_sum = min(min_sum, window_sum)\n                window_sum -= cardPoints[left]\n                left += 1\n        return sum(cardPoints) - min_sum\n", "class Solution:\n    def maxScore(self, p: List[int], k: int) -> int:\n        res = sum(p[:k])\n        cur = res\n        \n        for i in range(1, k+1):\n            cur += p[-i] - p[k-i]\n            res = max(cur, res)\n        \n        return res\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        # Time: O(k)\n        # Space: O(1)\n        ans = win = 0\n        for i in range(-k, k):\n            win += cardPoints[i]\n            if i >= 0:\n                win -= cardPoints[i - k]\n            #print(i, i-k, ans, win, cardPoints[i] )    \n            ans = max(win, ans)    \n        return ans\n        \n            \n", "# O(n) time and O(1) space\n# alternative dp solution O(k) space: form two k sized arrays: 1 to k and n-k to n\n# https://www.youtube.com/watch?v=t3JHx5J01F0 9mins06s\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        curr_max = sum(cardPoints[:k])\n        ans = curr_max\n        for i in range(1, k+1):\n            curr_max += cardPoints[-i] - cardPoints[k-i]\n            ans = max(ans, curr_max)\n        return ans\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        w = n - k\n        left, right = 0, w - 1\n        ans = float('-inf')\n        \n        win_sum = sum(cardPoints[:w])\n        total = sum(cardPoints)\n        while right < n:\n            sub = total - win_sum\n            ans = max(sub, ans)\n            if left < n:\n                win_sum -= cardPoints[left]\n            left += 1\n            right += 1\n            if right < n:\n                win_sum += cardPoints[right]\n\n        return ans\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n#         \u6211\u5199\u7684\u8fd8\u662f\u592a\u590d\u6742\u4e86\n#         if not cardPoints or not k:\n#             return 0\n#         if k==len(cardPoints):\n#             return sum(cardPoints)\n        \n#         front={0:0}\n#         back={0:0}\n#         total=0\n#         for i in range(k):\n#             total+=cardPoints[i]\n#             front[i+1]=total\n#         total=0\n#         for i in range(-1,-k-1,-1):\n#             total+=cardPoints[i]\n#             back[-i]=total\n            \n#         maxres=float('-inf')\n#         for i in range(k+1):\n#             maxres=max(maxres,front[i]+back[k-i])\n        \n#         return maxres\n        s = sum(cardPoints[:k])\n        res = s\n        for i in range(1, k+1):\n            s += cardPoints[-i] - cardPoints[k-i]\n            res = max(res, s)\n        return res\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        left, right = [0], [0]\n        for i in range(k):\n            left.append(left[-1] + cardPoints[i])\n            right.append(right[-1] + cardPoints[len(cardPoints) - 1 - i])\n        # print(left, right)\n        maxSoFar = 0\n        for i in range(k + 1):\n            if left[i] + right[k - i] > maxSoFar:\n                maxSoFar = left[i] + right[k - i]\n        return maxSoFar\n        \n", "class Solution:\n    def maxScore(self, p: List[int], k: int) -> int:\n        s = sum(p)\n        if k == len(p): return s\n        n = len(p)\n        for i in range(1, len(p)): p[i] += p[i-1]\n\n        return s - min(p[n+i-k-1] - (p[i-1] if i else 0) for i in range(k+1))\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        score = 0\n        l = k\n        prefix = [0]\n        for i in range(len(cardPoints)):\n            prefix.append(prefix[-1] + cardPoints[i])\n        for i in range(k+1):\n            score = max(score, prefix[l] + prefix[-1] - prefix[-1-i])\n            l -= 1\n        return score", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        right_index = len(cardPoints)-k\n        curr_max = sum(cardPoints[right_index:])\n        curr_sum = curr_max\n        for left_index, right_index in zip(list(range(0, k)), list(range(len(cardPoints)-k, len(cardPoints)))):\n            print((left_index, right_index))\n            curr_sum -= cardPoints[right_index]\n            curr_sum += cardPoints[left_index]\n            curr_max = max(curr_max, curr_sum)\n        return curr_max\n", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:  \n        sub_len = len(cardPoints) - k\n        localSum = 0\n        localSum = sum(cardPoints[0: sub_len])\n        localMin = localSum\n        for i in range(sub_len, len(cardPoints)):\n            localSum += cardPoints[i]\n            localSum -= cardPoints[i - sub_len]\n            localMin = min(localSum, localMin)\n        return  sum(cardPoints) - localMin", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        points = cardPoints[-k:] + cardPoints[:k]\n        curr = 0\n        max_ = 0\n        for ind, score in enumerate(points):\n            if ind >= k:\n                curr -= points[ind-k]\n            curr += score\n            max_ = max(max_, curr)\n        return max_", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        \n        total = sum(cardPoints)\n        \n        nk = len(cardPoints) - k\n        \n        if nk == 0:\n            return total\n        \n        current = sum(cardPoints[0:nk])\n        max_score = current\n        \n        for i in range(1, k + 1):\n            current = current - cardPoints[i - 1] + cardPoints[nk + i - 1]\n            \n            max_score = min(max_score, current)\n            \n        return total - max_score", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        \n        total = [0 for _ in range(len(cardPoints))]\n        total[0] = cardPoints[0]\n        \n        for i in range(1, len(cardPoints)):\n            total[i] = total[i-1] + cardPoints[i]\n            \n        max_sum = 0\n        for i in range(k+1):\n            left = total[k-i-1] if k-i > 0 else 0\n            right = total[-1] - total[len(cardPoints)-i-1]\n            if left + right > max_sum:\n                max_sum = left + right\n        \n        return max_sum", "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        N = len(cardPoints)\n        res = float('inf')\n        run = 0\n        for i, p in enumerate(cardPoints):\n            if i >= N-k: run -= cardPoints[i-N+k]\n            run += p\n            if i >= N-k-1: res = min(res, run)\n        return sum(cardPoints) - res"]
["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        if root == None:\n            return None\n        \n        maxlength = 0\n        stack = collections.deque()\n        if root.left:\n            stack.append((1, 1, root.left))\n        if root.right:\n            stack.append((1, 0, root.right))\n        while stack:\n            length, isleft, node = stack.pop()\n            if isleft:\n                if node.right:\n                    stack.append((length + 1, 0, node.right))\n                else:\n                    maxlength = max(maxlength, length)\n                if node.left:\n                    stack.append((1, 1, node.left))\n            else:\n                if node.left:\n                    stack.append((length + 1, 1, node.left))\n                else:\n                    maxlength = max(maxlength, length)\n  \n                if node.right:\n                    stack.append((1, 0, node.right))\n            \n        return maxlength\n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        stack = [(root, 0, 'left')]\n        res = 0\n        while stack:\n            node, length, d = stack.pop()\n            res = max(res, length)\n            if node.left:\n                if d != 'left':\n                    stack.append((node.left, length + 1, 'left'))\n                else:\n                    stack.append((node.left, 1, 'left'))\n\n            if node.right:\n                if d != 'right':\n                    stack.append((node.right, length + 1, 'right'))\n                else:\n                    stack.append((node.right, 1, 'right'))\n        return res\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        # dequeu node : [curr_node, state, longestdistance]\n        ans = 0\n        q = deque([[root, 'A', 0]])\n        while (len(q) != 0):\n            top, state, dist = q[0]\n            ans = max(ans, dist)\n            q.popleft()\n            if state == 'A':\n                if top.left:\n                    q.append([top.left, 'L', 1])\n                if top.right:\n                    q.append([top.right, 'R', 1])\n            else:\n                if state == 'L':\n                    if top.left:\n                        q.append([top.left, 'L', 1])\n                    if top.right:\n                        q.append([top.right, 'R', dist+1])\n                if state == 'R':\n                    if top.left:\n                        q.append([top.left, 'L', dist+1])\n                    if top.right:\n                        q.append([top.right, 'R', 1])\n        return ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def dfs(node):\n            if not node:\n                return [-1, -1, -1]\n            left = dfs(node.left)\n            right = dfs(node.right)\n            return [left[1]+1, right[0]+1, max(left[1]+1, right[0]+1, left[2], right[2])]\n        return dfs(root)[-1]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        maxlen = 0\n        \n        dt = collections.defaultdict(lambda : [0,0])\n        \n        def dfs(root,dt):\n            nonlocal maxlen\n            \n            if root.left:\n                dfs(root.left,dt)\n                dt[root][0] = dt[root.left][1] + 1\n            else:\n                dt[root][0] = 0\n                \n            if root.right:\n                dfs(root.right,dt)\n                dt[root][1] = dt[root.right][0] + 1\n            else:\n                dt[root][1] = 0\n            \n            maxlen = max(maxlen, dt[root][0], dt[root][1])\n            \n        dfs(root,dt)\n        \n        return maxlen\n        \n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper(self, node: TreeNode, lastDirection: str, cache) -> int:\n        if not node:\n            return 0\n        \n        if (node, lastDirection) in cache:\n            return cache[(node, lastDirection)]\n        \n        count = 1\n        childCount = float('-inf')\n        if lastDirection == 'right':\n            childCount = max(childCount, self.helper(node.left, 'left', cache))\n        else:\n            childCount = max(childCount, self.helper(node.right, 'right', cache))\n        \n        count += childCount\n        cache[(node, lastDirection)] = count\n        return count\n    \n    def longestZigZag(self, root: TreeNode) -> int:\n        maxCount = float('-inf')\n        cache = {}\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            maxCount = max(maxCount, self.helper(node, 'left', cache))\n            maxCount = max(maxCount, self.helper(node, 'right', cache))\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return maxCount - 1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.ans = 0\n        memo = {}\n        \n        def dfs2(node, direction):\n            if not node:\n                return 0\n            \n            if (node, direction) not in memo:\n                if direction == False:\n                    memo[(node, direction)] = 1 + dfs2(node.right, True)\n                else:\n                    memo[(node, direction)] = 1 + dfs2(node.left, False)\n            \n            return memo[(node, direction)]\n        \n        def dfs1(node):\n            if not node:\n                return\n            \n            self.ans = max(self.ans, dfs2(node, True) - 1, dfs2(node, False) - 1)\n            \n            dfs1(node.left)\n            dfs1(node.right)\n        \n        dfs1(root)\n        return self.ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        max_zig_zag = 0\n        \n        def dfs(node):\n            if not node:\n                return (0, 0)\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            nonlocal max_zig_zag\n            max_zig_zag = max(1 + left[1], 1 + right[0], max_zig_zag)\n            \n            return (1 + left[1], 1 + right[0])\n    \n        dfs(root)\n        return max_zig_zag - 1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.res = 0;\n        if root.left:\n            self.dfs(root.left, 1, True, False)\n        if root.right:\n            self.dfs(root.right, 1, False, True)\n        return self.res\n        \n    def dfs(self, node, count, prevL, prevR):\n        if not node:\n            return\n        self.res = max(self.res, count)\n\n        if prevL:\n            self.dfs(node.left, 1, True, False)\n            self.dfs(node.right, count + 1, False, True)\n        if prevR:\n            self.dfs(node.left, count + 1, True, False)\n            self.dfs(node.right, 1, False, True)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.res = float(-inf)\n        def helper(root, left, right):\n            self.res = max(self.res, max(left, right))\n            if root == None:\n                return\n            if root.left:\n                helper(root.left, right + 1, 0)\n            if root.right:\n                helper(root.right, 0, left + 1)\n            return\n    \n        helper(root, 0, 0)\n        return self.res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        ans = [-1]\n        \n        def aux(root, isleft, ans):\n            if not root:\n                return -1\n            left = aux(root.left, 1, ans) + 1\n            right = aux(root.right, 0, ans) + 1\n            ans[0] = max(ans[0], left, right)\n            if isleft:\n                return right\n            else:\n                return left\n            \n        if not root:\n            return 0\n        aux(root, 0, ans)\n        return ans[0]\n        \n#         def aux(root, isleft, memo):\n#             if not root:\n#                 return 0\n#             if root in memo:\n#                 if isleft:\n#                     return memo[root][1]\n#                 else:\n#                     return memo[root][0]\n#             memo[root] = [0, 0]\n#             memo[root][0] = aux(root.left, 1, memo) + 1\n#             memo[root][1] = aux(root.right, 0, memo) + 1\n#             self.ans = max(self.ans, memo[root][1], memo[root][0])\n#             if isleft:\n#                 return memo[root][1]\n#             else:\n#                 return memo[root][0]\n            \n#         if not root:\n#             return 0\n#         memo = {}\n#         aux(root, 0, memo)\n#         return self.ans - 1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper(self,node,prenode,ans):\n        if not node:return\n        self.res=max(self.res,ans)\n        if node==prenode.left:\n            self.helper(node.right,node,ans+1)\n            self.helper(node.left,node,1)\n        elif node==prenode.right:\n            self.helper(node.left,node,ans+1)\n            self.helper(node.right,node,1)\n            \n    def longestZigZag(self, root: TreeNode) -> int:\n        self.res=0\n        self.helper(root.left,root,1)\n        self.helper(root.right,root,1)\n        return self.res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def zigzag(node: TreeNode) -> tuple:\n            if not node: return 0, 0\n            _, lr = zigzag(node.left)\n            rl, _ = zigzag(node.right)\n            self.max_path = max(self.max_path, lr + 1, rl + 1)\n            return lr + 1, rl + 1\n\n        self.max_path = 0\n        zigzag(root)\n        return self.max_path - 1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        if root == None:\n            return 0\n        maxZigZag = 0\n        def zigZagStart(root):##direction will correspond to -1 for left and 1 for right\n            nonlocal maxZigZag\n            if root == None or (root.left == None and root.right == None):\n                return [0,0]\n            ll,lr = zigZagStart(root.left)\n            rl,rr = zigZagStart(root.right)\n            bestLeft = 0\n            bestRight = 0\n            if root.left:\n                bestLeft = 1+lr\n            if root.right:\n                bestRight = 1+rl\n            maxZigZag = max(maxZigZag,bestLeft,bestRight)\n            return [bestLeft,bestRight]\n        zigZagStart(root)\n        return maxZigZag", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n# recursive\n# use a direction to mark curr direction\n# if dir is right: call 1+ helper(root.left, left)\n        self.longest = 0\n        def dfs(node, dirc):\n            if not node:return 0\n            left = dfs(node.left, \\\"left\\\")\n            right = dfs(node.right, \\\"right\\\")\n            self.longest = max(self.longest, left, right)\n            if dirc == \\\"right\\\":\n                return 1 + left\n            else:\n                return 1 + right\n\n        dfs(root,\\\"left\\\")\n        return self.longest", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def ZigZag(node): # -> [left_len, right_len, max_len]\n            if not node:\n                return [-1, -1, -1]\n            left = ZigZag(node.left)\n            right = ZigZag(node.right)\n            return [left[1] + 1, right[0] + 1, max(left[1] + 1, right[0] + 1, left[2], right[2])]\n        return ZigZag(root)[-1]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.longest = 0\n        self.dfs(root, 0, 0)\n        return self.longest\n        \n    def dfs(self, node, longest_left, longest_right):\n        self.longest = max(self.longest, longest_left, longest_right)\n        if node.left:\n            self.dfs(node.left, longest_right+1, 0)\n        if node.right:\n            self.dfs(node.right, 0, longest_left+1)", "\n# 1372. Longest ZigZag Path in a Binary Tree\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        def dfs(root):\n            if not root: \n                # [left, right, res]\n                return [-1, -1, -1]\n            left, right = dfs(root.left), dfs(root.right)\n            # [left.right + 1, right.left + 1, max(left.right + 1, right.left + 1, left.res, right.res)]\n            return [left[1] + 1, right[0] + 1, max(left[1] + 1, right[0] + 1, left[2], right[2])]\n        \n        return dfs(root)[-1]\n    \n# Explanation\n# Recursive return [left, right, result], where:\n# left is the maximum length in direction of root.left\n# right is the maximum length in direction of root.right\n# result is the maximum length in the whole sub tree.\n\n\n# Complexity\n# Time O(N)\n# Space O(height)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        if not root: return\n        root.val = 0\n        \n        result = [0]\n        self.zigZagHelper(root.left, \\\"L\\\", root.val+1, result)\n        self.zigZagHelper(root.right, \\\"R\\\", root.val+1, result)\n        return result[0]\n        \n    def zigZagHelper(self, root, prev_dir, prev_val, result):\n        if not root: \n            return\n        \n        root.val = prev_val\n        result[0] = max(result[0], root.val)\n        \n        if prev_dir == \\\"L\\\":\n            self.zigZagHelper(root.right, \\\"R\\\", root.val + 1, result)\n            self.zigZagHelper(root.left, \\\"L\\\", 1, result)\n        else:\n            self.zigZagHelper(root.right, \\\"R\\\", 1, result)\n            self.zigZagHelper(root.left, \\\"L\\\", root.val + 1, result)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root):\n        def dfs(root):\n            if not root: return [-1, -1, -1]\n            left, right = dfs(root.left), dfs(root.right)\n            return [left[1] + 1, right[0] + 1, max(left[1] + 1, right[0] + 1, left[2], right[2])]\n        return dfs(root)[-1]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        # Recursive return [left, right, result], where:\n        # left is the maximum length in direction of root.left\n        # right is the maximum length in direction of root.right\n        # result is the maximum length in the whole sub tree\n        def dfs(root):\n            if not root:\n                return [-1, -1, -1]\n            left, right = dfs(root.left), dfs(root.right)\n            return [left[1] + 1, right[0] + 1, max(left[1] + 1, right[0] + 1, left[2], right[2])]\n        return dfs(root)[2]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        _, max_depth = self.zigzag(root)\n        return max_depth\n    \n    def zigzag(self, node: TreeNode, return_left=False) -> int:\n        if node is None:\n            return -1, 0\n        left_depth, left_max = self.zigzag(node.left)\n        right_depth, right_max = self.zigzag(node.right, return_left=True)\n\n        left_depth += 1\n        right_depth += 1\n        max_depth = max(left_depth, right_depth, left_max, right_max)\n        return left_depth if return_left else right_depth, max_depth", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        def aux(root):\n            if not root:\n                return [-1, -1, -1]\n            left = aux(root.left)\n            right = aux(root.right)\n            ans = max(max(left[1], right[0])+1, left[2], right[2])\n            return [left[1]+1, right[0]+1, ans]\n        \n        return aux(root)[2]\n        \n        \n        \n        \n#         ans = [-1]\n        \n#         def aux(root, isleft, ans):\n#             if not root:\n#                 return -1\n#             left = aux(root.left, 1, ans) + 1\n#             right = aux(root.right, 0, ans) + 1\n#             ans[0] = max(ans[0], left, right)\n#             if isleft:\n#                 return right\n#             else:\n#                 return left\n            \n#         if not root:\n#             return 0\n#         aux(root, 0, ans)\n#         return ans[0]\n        \n#         def aux(root, isleft, memo):\n#             if not root:\n#                 return 0\n#             if root in memo:\n#                 if isleft:\n#                     return memo[root][1]\n#                 else:\n#                     return memo[root][0]\n#             memo[root] = [0, 0]\n#             memo[root][0] = aux(root.left, 1, memo) + 1\n#             memo[root][1] = aux(root.right, 0, memo) + 1\n#             self.ans = max(self.ans, memo[root][1], memo[root][0])\n#             if isleft:\n#                 return memo[root][1]\n#             else:\n#                 return memo[root][0]\n            \n#         if not root:\n#             return 0\n#         memo = {}\n#         aux(root, 0, memo)\n#         return self.ans - 1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    m = 0\n    def longestZigZag(self, root: TreeNode) -> int:\n        def longest(node: TreeNode, state: int, acc: int) -> int:\n            self.m = max(self.m, acc)\n            if not node:\n                return 0\n            if state == 0:\n                longest(node.right, 1, acc + 1), longest(node.left, 0, 0)\n            else:\n                longest(node.left, 0, acc + 1), longest(node.right, 1, 0)\n            \n        longest(root.left, 0, 0), longest(root.right, 1, 0)\n        return self.m", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.max_zigzag = 0\n        \n        def dfs(node):\n            if not node:\n                # [left, right, max]\n                return [-1, -1, -1]\n            left = dfs(node.left)\n            right = dfs(node.right)\n            return [left[1] + 1, right[0] + 1, max(left[2], right[2], left[1]+1, right[0]+1)]\n        \n\n        return dfs(root)[2]\n    \n        \n", "class Solution:\n        \n    def longestZigZag(self, root: TreeNode) -> int:\n        if not root: return 0\n        q = deque()\n        max_depth = 0\n        if root.left: q.append((root.left, True, 1))\n        if root.right: q.append((root.right, False, 1))\n        \n        while q: \n            n, is_left, depth = q.popleft()\n            max_depth = max(depth, max_depth)\n            if n.left:\n                if is_left: \n                    q.append((n.left, True, 1))\n                else: \n                    q.append((n.left, True, depth+1))\n            if n.right: \n                if is_left: \n                    q.append((n.right, False, depth+1))\n                else:\n                    q.append((n.right, False, 1))\n                    \n\n        return max_depth\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        q = collections.deque()\n        res = 0\n        q.append((root, 0, 0))\n        \n        while q:\n            size = len(q)\n            for _ in range(size):\n                node, l, r = q.popleft()\n                if node.left:\n                    q.append((node.left, r+1, 0))\n                    res = max(res, r+1)\n                if node.right:\n                    q.append((node.right, 0, l+1))\n                    res = max(res, l+1)\n        \n        return res\n                             \n                            \n        \n                             \n                          \n\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        *_, max_depth = self.zigzag(root)\n        return max_depth\n    \n    def zigzag(self, node: TreeNode) -> int:\n        if node is None:\n            return -1, -1, 0\n        _, left_depth, left_max = self.zigzag(node.left)\n        right_depth, _, right_max = self.zigzag(node.right)\n\n        left_depth += 1\n        right_depth += 1\n        max_depth = max(left_depth, right_depth, left_max, right_max)\n        return left_depth, right_depth, max_depth", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def zigzag(node,left,acum):\n            if node is None:\n                return acum - 1\n            if left:\n                return max(zigzag(node.left,False,acum + 1), zigzag(node.left,True,0))\n            else:\n                return max(zigzag(node.right,True,acum + 1), zigzag(node.right,False,0))\n        return max(zigzag(root,True,0),zigzag(root,False,0))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        self.max_len = 0\n\n        def subTree(root, indir, flip):\n            if root is None:\n                return 0\n            if indir == -1:\n                subcount = subTree(root.right, 1, True) \n                self.max_len = max(subcount + 1, self.max_len)\n            else:\n                subcount = subTree(root.left, -1, True)\n                self.max_len = max(subcount + 1, self.max_len)\n\n            if flip:\n                subTree(root, -indir, False)\n            return subcount + 1\n\n        subTree(root, 1, True)\n        return self.max_len - 1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        l=[[root,0]]\n        r=[[root,0]]\n        m=0\n        while(True):\n            if(l==[])and(r==[]):\n                return m\n            l1=[]\n            r1=[]\n            for i in l:\n                m=max(m,i[1])\n                if(i[0].right!=None):\n                    r1.append([i[0].right,i[1]+1])\n                if(i[0].left!=None):\n                    r1.append([i[0].left,0])\n            for i in r:\n                m=max(m,i[1])\n                if(i[0].left!=None):\n                    l1.append([i[0].left,i[1]+1])\n                if(i[0].right!=None):\n                    l1.append([i[0].right,0])\n            r=r1\n            l=l1\n            \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        \n        def help(root):\n            if not root:\n                return [-1, -1, -1]\n            left, right = help(root.left), help(root.right)\n            return [ left[1]+1, right[0]+1, max(left[-1], right[-1], left[1]+1, right[0]+1)  ]\n        \n        return help(root)[-1]\n        \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def helper(root):\n            stack = [[root, True, 0], [root, False, 0]]\n            ans = 0\n            while stack:\n                root, right, length = stack.pop()\n                if root:\n                    ans = max(length, ans)\n                    stack.append((root.right if right else root.left, not right, length +1))\n                    stack.append((root.left if right else root.right, right, 1))    \n            return ans\n        return helper(root)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.max_length = float('-inf')\n    \n    def longestZigZag(self, root):\n        return self.dfs(root)[2] - 1\n    \n    def dfs(self, root):\n        if root is None: return [0, 0, 0]\n        \n        left_res = self.dfs(root.left)\n        right_res = self.dfs(root.right)\n        \n        maxForSubtree = max(left_res[1], right_res[0]) + 1\n        return [left_res[1] + 1, right_res[0] + 1, max(maxForSubtree, left_res[2], right_res[2])]    \n    \n#     def __init__(self):\n#         self.max_length = float('-inf')\n#         self.memo = {}\n\n#     def longestZigZag(self, root: TreeNode) -> int:\n#         self.dfs(root)\n#         return self.max_length if self.max_length != float('-inf') else 0\n# # O(n) time, O(n) space\n    \n#     def dfs(self, root):\n#         if root is None: return\n\n#         self.dfs(root.left)\n#         self.dfs(root.right)\n        \n#         left_res = self.zigzag(root, True)\n#         right_res = self.zigzag(root, False)\n#         self.max_length = max(self.max_length, left_res - 1, right_res - 1)        \n        \n#     def zigzag(self, node, is_left):\n#         if id(node) in self.memo: \n#             if is_left and self.memo[id(node)][0]:\n#                 return self.memo[id(node)][0]                    \n#             elif is_left is False and self.memo[id(node)][1]:\n#                 return self.memo[id(node)][1]\n#         if node is None:\n#             return 0\n\n#         res = 0\n#         if is_left:\n#             res += self.zigzag(node.left, False)\n#         else:\n#             res += self.zigzag(node.right, True)\n\n#         length = res + 1            \n#         memoized_res = self.memo.get(id(node), [None, None])\n#         memoized_res[(0 if is_left else 1)] = length\n#         self.memo[id(node)] = memoized_res\n#         return res + 1        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZagRec(self, root, goLeft, steps):\n        if root == None:\n            return steps - 1\n        if goLeft:\n            return max(\n            self.longestZigZagRec(root.left, False, steps + 1),\n            self.longestZigZagRec(root.right, True, 1)\n            )\n        \n        else:\n            return max(\n            self.longestZigZagRec(root.right, True, steps + 1),\n            self.longestZigZagRec(root.left, False, 1)\n            )\n            \n    def longestZigZag(self, root: TreeNode) -> int:\n        if root == None:\n            return 0\n        \n        return max(\n            self.longestZigZagRec(root, True, 0),\n            self.longestZigZagRec(root, False, 0)\n        ) ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.max_zigzag = 0\n        def dfs(node, is_left, streak):\n            if not node:\n                return\n            self.max_zigzag = max(self.max_zigzag, streak)\n            \n            if is_left:\n                dfs(node.right, not is_left, streak + 1)\n                dfs(node.right, is_left, 0)\n            else:\n                dfs(node.left, not is_left, streak + 1)\n                dfs(node.left, is_left, 0)\n        \n        dfs(root, True, 0)\n        dfs(root, False, 0)\n        return self.max_zigzag", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        self.helper(root)\n        l = [root]\n        m = 0\n        while len(l) != 0:\n            node = l.pop()\n            if node.left != None:\n                l.append(node.left)\n            if node.right != None:\n                l.append(node.right)\n            if max(node.val) > m:\n                m = max(node.val)\n        return m\n    def helper(self,root):\n        if root is None:\n            return 0\n        self.helper(root.left)\n        self.helper(root.right)\n        if root.left == None and root.right == None:\n            root.val = (0,0)\n        elif root.left != None and root.right == None:\n            root.val = (root.left.val[1] + 1, 0)\n        elif root.right != None and root.left == None:\n            root.val = (0,root.right.val[0] + 1)\n        else:\n            root.val = (root.left.val[1] + 1, root.right.val[0] + 1)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        def Search(root,left,height):\n            if root is None:\n                return height\n            if left:\n                return max(Search(root.left,1,0),Search(root.right,0,height+1))\n            else:\n                return max(Search(root.right,0,0),Search(root.left,1,height+1))\n        return max(Search(root.left,1,0),Search(root.right,0,0))\n        \n        \n        \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        longest = 0\n        if not root:\n            return longest\n        #direction - right = True, left = False\n        def helper(root, level, direction):\n            nonlocal longest \n            if level > longest:\n                longest = level\n            if direction:\n                if root.left:\n                    helper(root.left, level+1, not direction)\n                if root.right:\n                    helper(root.right,1,direction)\n            else:\n                if root.right:\n                    helper(root.right, level+1, not direction)\n                if root.left:\n                    helper(root.left, 1, direction)\n            \n        if root.right:\n            helper(root.right,1,True)\n        if root.left:\n            helper(root.left,1,False)\n        if not root.left and not root.right:\n            return 0\n        return longest\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.res = 0\n        \n        \n        def dfs(node):\n            # dfs(node) returns l, r\n            # l means the longest zigzag path from node with the first edge going left\n            # r means the longest zigzag path from node with the first edge going right\n            if not node:\n                return -1, -1\n            _, r = dfs(node.left) # Note the the first returned value is useless\n            l, _ = dfs(node.right)\n            self.res = max(self.res, r + 1, l + 1)\n            return r + 1, l + 1\n        \n        dfs(root)\n        return self.res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        def check(root):\n            l = 0   #   \u4ee5\u5f53\u524d\u8282\u70b9\u5411\u5de6\n            r = 0   #   \u4ee5\u5f53\u524d\u8282\u70b9\u5411\u53f3\n            m = 0   #   \u5f53\u524d\u5b50\u6811\u7684\u6700\u5927\u503c(\u8d77\u70b9\u4e0d\u4e00\u5b9a\u662f\u5f53\u524d\u8282\u70b9)\n            if root.left != None:\n                r1 = check(root.left)\n                l = r1[1] + 1\n                m = max(m, r1[2])\n            if root.right!= None:\n                r2 = check(root.right)\n                r = r2[0] + 1\n                m = max(m, r2[2])\n            return (l, r, max(l, r, m))\n        \n        if root == None:\n            return 0\n        r = check(root)\n        return r[2]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        memo={}\n\n        ans=[0]\n\n\n        def cur(node:TreeNode):\n            if node!=None:\n                memo[node]=[0,0]\n            if node.left!=None:\n                cur(node.left)\n                memo[node][0]=memo[node.left][1]+1\n                ans[0]=max(ans[0],memo[node][0])\n            if node.right!=None:\n                cur(node.right)\n                memo[node][1]=memo[node.right][0]+1\n                ans[0] = max(ans[0], memo[node][1])\n\n\n        cur(root)\n      \n        return ans[0]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.zigzag(root)\n        return self.find_longest(root)\n    \n    def zigzag(self, node: TreeNode) -> int:\n        if node is None:\n            return\n        self.zigzag(node.left)\n        self.zigzag(node.right)\n        \n        if node.left is not None:\n            node.left_depth = node.left.right_depth + 1\n        else:\n            node.left_depth = 0\n            \n        if node.right is not None:\n            node.right_depth = node.right.left_depth + 1\n        else:\n            node.right_depth = 0\n            \n    def find_longest(self, node: TreeNode) -> int:\n        if node is None:\n            return 0\n        left_max = self.find_longest(node.left)\n        right_max = self.find_longest(node.right)\n        return max(left_max, right_max, node.left_depth, node.right_depth)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.ans = 0\n        \n        def aux(root, isleft, memo):\n            if not root:\n                return 0\n            if root in memo:\n                if isleft:\n                    return memo[root][1]\n                else:\n                    return memo[root][0]\n            memo[root] = [0, 0]\n            memo[root][0] = aux(root.left, 1, memo) + 1\n            memo[root][1] = aux(root.right, 0, memo) + 1\n            self.ans = max(self.ans, memo[root][1], memo[root][0])\n            if isleft:\n                return memo[root][1]\n            else:\n                return memo[root][0]\n            \n        if not root:\n            return 0\n        memo = {}\n        aux(root, 0, memo)\n        return self.ans - 1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def __init__(self):\n        self.visited = set()\n        \n    def zigzagPath(self,node,direction):\n        \n        length = 0\n        while node:\n                \n            if direction ==1:\n                node = node.right\n                if node and node.left:\n                    self.visited.add((node,\\\"left\\\"))\n            elif direction ==0:\n                node = node.left\n                if node and node.right:\n                    self.visited.add((node,\\\"right\\\"))\n            direction = 1 - direction\n            if node!=None:\n                length+=1\n        return length\n        \n    \n    def longestZigZag(self, root: TreeNode) -> int:\n        max_length = 0\n        S = [root]\n        while S:\n            node = S.pop(0)\n            if node.right: \n                if (node,\\\"right\\\") not in self.visited:\n                    max_length = max(self.zigzagPath(node,1),max_length)\n                self.visited.add((node,\\\"right\\\"))\n                S.append(node.right)\n            if node.left: \n                if (node,\\\"left\\\") not in self.visited:\n                    max_length = max(self.zigzagPath(node,0),max_length)\n                self.visited.add((node,\\\"left\\\"))\n                S.append(node.left)\n        return max_length\n        \n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        self.mx=0\n        def backtrack(root,curr,temp):\n            \n            if not root:\n                return\n            self.mx=max(self.mx,temp)\n            if curr==\\\"left\\\":\n                backtrack(root.right,\\\"right\\\",temp+1)\n                backtrack(root.left,\\\"left\\\",1)\n            else:\n                backtrack(root.left,\\\"left\\\",temp+1)\n                backtrack(root.right,\\\"right\\\",1)\n            \n        backtrack(root,\\\"left\\\",0)\n        backtrack(root,\\\"right\\\",0)\n        return self.mx", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.res = 0\n        self.helper(root, True)\n        self.helper(root, False)\n        return self.res - 1\n    \n    def helper(self, root, isLeft):\n        if not root:\n            return 0\n        \n        left = self.helper(root.left, True)\n        right = self.helper(root.right, False)\n        self.res = max(self.res, left+1, right+1)\n        \n        return (right+1) if isLeft else (left+1)\n        \n", "class Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.maxpath = 0\n        l, r = self.visit(root)\n        return self.maxpath\n    \n    \n    def visit(self, root):\n        l = 0\n        r = 0\n        if root.left:\n            ll,lr = self.visit(root.left)\n            l = lr + 1\n        if root.right:\n            rl,rr = self.visit(root.right)\n            r = rl + 1\n        if max(l,r) > self.maxpath:\n            self.maxpath = max(l,r)\n        return l, r", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        if not root :\n            return 0\n        \n        return max(self.length(root.left, 'l', 1), self.length(root.right,'r',1))\n    def length(self, node, d, depth):\n        if not node:\n            return depth -1\n        print((d, depth, node.val))\n        \n        if d == 'l':\n            return max(self.length(node.right, 'r', depth+1), self.length(node.left, 'l',1))\n        else:\n            return max(self.length(node.left, 'l', depth+1), self.length(node.right,'r',1))\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        memo={}\n\n        ans=[0]\n\n\n        def cur(node:TreeNode):\n            if node in list(memo.keys()):\n                return \n            \n            if node!=None:\n                memo[node]=[0,0]\n            if node.left!=None:\n                cur(node.left)\n                memo[node][0]=memo[node.left][1]+1\n                ans[0]=max(ans[0],memo[node][0])\n            if node.right!=None:\n                cur(node.right)\n                memo[node][1]=memo[node.right][0]+1\n                ans[0] = max(ans[0], memo[node][1])\n\n\n        cur(root)\n      \n        return ans[0]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        self.max=0\n        def dfs(node):\n            if not node:\n                return -1,-1\n        \n            l_dir_left,l_dir_right=dfs(node.left)\n            r_dir_left,r_dir_right=dfs(node.right)\n            self.max=max(self.max,l_dir_left,l_dir_right+1,r_dir_left+1,r_dir_right)\n            return (l_dir_right+1,r_dir_left+1)\n            \n        dfs(root)\n        return self.max", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom typing import NamedTuple\n\nclass Result(NamedTuple):\n    left_depth: int\n    right_depth: int\n    max_depth: int\n\n\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        res = self.zigzag(root)\n        return res.max_depth\n    \n    def zigzag(self, node: TreeNode) -> int:\n        if node is None:\n            return Result(-1, -1, 0)\n        left_res = self.zigzag(node.left)\n        right_res = self.zigzag(node.right)\n        \n        left_depth = left_res.right_depth + 1\n        right_depth = right_res.left_depth + 1\n        max_depth = max(left_depth, right_depth, left_res.max_depth, right_res.max_depth)\n        return Result(left_depth, right_depth, max_depth)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.ret = 0\n        self.dfs(root, 0, 0)\n        self.dfs(root, 1, 0)\n        return self.ret - 1\n    \n    def dfs(self, root, prevright, length):\n        if root is None:\n            self.ret = max(self.ret, length)\n            return\n        \n        if prevright:\n            self.dfs(root.left, 1 - prevright, length + 1)\n            self.dfs(root.right, prevright, 1)\n        else:\n            self.dfs(root.right, 1 - prevright, length + 1)\n            self.dfs(root.left, prevright, 1)\n        \n            \n        return ", "class Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        check = 0 # left = 1, right = 2\n        count = 0\n        self.res = 0\n\n        def dfs(node, count, check):\n            if node:\n                if check == 1: # from left                    \n                    dfs(node.left, 0, 1)\n                    dfs(node.right, count+1, 2)\n                elif check == 2: # from right\n                    dfs(node.left, count+1, 1)\n                    dfs(node.right, 0, 2)\n                elif check == 0: # from root\n                    dfs(node.left, count, 1)\n                    dfs(node.right, count, 2)\n            self.res = max(self.res, count)\n        dfs(root, count, check)\n        return self.res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n_max = 0\nclass Solution:\n    def preorder(self,root, lr, cur_len):\n        nonlocal _max\n        \n        if(root==None):\n            return\n        \n        _max = max(_max,cur_len)\n        \n        if(lr=='l'):\n            self.preorder(root.left,'l',1)\n            self.preorder(root.right,'r',cur_len+1)\n        elif(lr=='r'):\n            self.preorder(root.left,'l',cur_len+1)\n            self.preorder(root.right,'r',1)\n        else:\n            self.preorder(root.left,'l',cur_len+1)\n            self.preorder(root.right,'r',cur_len+1)\n\n            \n        \n    def longestZigZag(self, root: TreeNode) -> int:\n        nonlocal _max\n        _max = 0\n        self.preorder(root,None,0)\n        \n        return _max\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        dp = [0]\n        def f(n,ind):\n            if not n:\n                dp[ind] = (0,0)\n            else:\n                dp.extend([0,0])\n                temp = len(dp)\n                f(n.left,temp-2)\n                f(n.right,temp-1)\n                dp[ind] = (dp[temp-1][1]+1,dp[temp-2][0]+1)\n        f(root,0)\n        m = -1\n        # print(dp)\n        for i in dp:\n            m = max(i[0],i[1],m)\n        return m-1\n\n\n                           \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        \n        seenSoFar = 0\n        def longestZigZagUtil(root):\n            nonlocal seenSoFar\n            if not root:\n                return 0, 0\n            \n            Ll, Lr = longestZigZagUtil(root.left)\n            Rl, Rr = longestZigZagUtil(root.right)\n            \n            curL, curR = 0, 0\n            if root.left:\n                curL = 1 + Lr\n                seenSoFar = max(seenSoFar, Ll)\n            if root.right:\n                curR = 1 + Rl\n                seenSoFar = max(seenSoFar, Rr)\n            \n            return curL, curR\n        \n        l, r = longestZigZagUtil(root)\n        return max(l, r, seenSoFar)\n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        res = 0\n        def helper(root, direction):\n            nonlocal res\n            if not root:\n                return 0\n            left = helper(root.left, 'left')\n            right = helper(root.right,'right')\n            res = max(res, left+1, right+1)\n            return right +1 if direction =='left' else left+1\n        if not root:\n            return 0\n        helper(root,'left')\n        helper(root, 'right')\n        return res -1 \n\n#         res = 0\n#         def helper(root, direction):\n#             nonlocal res\n#             if not root:\n#                 return 0\n#             left = helper(root.left, 'left')\n#             right = helper(root.right, 'right')\n#             res = max(res, left+1, right+1)\n#             return right+1 if direction =='left' else left+1\n#         if not root:\n#             return 0\n#         helper(root, 'left')\n#         helper(root, 'right')\n#         return res-1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef solve(root,res,ind):\n    if root==None:\n        return 0\n    l=solve(root.left,res,0)\n    r=solve(root.right,res,1)\n    if ind==0:\n        temp=1+r\n    elif ind==1:\n        temp=1+l\n    \n    ans=1+max(l,r)\n    res[0]=max(res[0],ans)\n    return temp\n\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n         if root==None:\n            return 0\n         if root.left==None and root.right==None:\n                return 0\n         \n         res1=[0]\n         res2=[0]\n         c1=solve(root,res1,0)\n         c2=solve(root,res2,1)\n         # print(\\\"aa\\\",res1,res2,c1,c2)\n         \n         return max(res1[0],res2[0])-1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        longest = [0]\n        def dfs(node,d,c):\n            if not node: \n                longest[0] = max(longest[0],c)\n                return\n            \n            if d == 'r':\n                dfs(node.left,'l',c+1)\n            else:\n                dfs(node.left,'l',0)\n            if d == 'l':\n                dfs(node.right,'r',c+1)\n            else:\n                dfs(node.right,'r',0)\n            \n        dfs(root,'',0)\n        return longest[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.ans = 0\n        def helper(node, direction, l):\n            if not node: return\n            self.ans = max(self.ans, l)\n            helper((node.left, node.right)[direction], 1 - direction, l + 1)\n            helper((node.left, node.right)[1-direction], direction, 1)\n        helper(root, 0, 0)\n        helper(root, 1, 0)\n        return self.ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def traverse(node,d,curr):\n            print((d,curr))\n            if not node:\n                res[0] = max(res[0],curr-1)\n                return\n            if d==0:\n                traverse(node.left,0,1)\n                traverse(node.right,1,curr+1)\n            else:\n                traverse(node.left,0,curr+1)\n                traverse(node.right,1,1)\n                \n        if not root:\n            return 0\n        res = [-float('inf')]\n        traverse(root.left,0,1)\n        traverse(root.right,1,1)\n        return res[0]\n    \n        \n", "class Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def solve(root):\n            if root:\n                solve(root.left)\n                solve(root.right)\n                if root.left:d[root][0] = d[root.left][1] + 1\n                if root.right:d[root][1] = d[root.right][0] + 1\n                self.ans = max(self.ans,max(d[root]))\n            return self.ans\n        d = defaultdict(lambda:[0,0])\n        self.ans = 0 \n        solve(root)\n        return self.ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        if not root.left and  not root.right:\n            return 0\n        \n        def dfs(root, flag, count):\n            if not root:\n                self.res = max(self.res, count-1)\n                return\n                \n            if flag == 1:\n                dfs(root.left,-1,1+count)\n                \n                dfs(root.right,1,1)\n            else:\n                dfs(root.right,1,1+count)\n                dfs(root.left,-1,1)\n        \n            \n        \n        self.res = 0\n        dfs(root, -1, 0)\n        return self.res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        res = collections.namedtuple('res', 'left right total')\n        \n        def dfs(root):\n            if not root:\n                return res(-1, -1, -1)\n        \n            left = dfs(root.left)\n            right = dfs(root.right)\n\n            return res(left.right + 1, right.left + 1, max(left.right + 1, right.left + 1, left.total, right.total))\n        \n        return dfs(root).total\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def node_is_on_the_right(self, node):\n        if not node:\n            return 0\n        continuation = 1 + self.node_is_on_the_left(node.left)\n        starts_here = self.node_is_on_the_right(node.right)\n        self.m = max(self.m, starts_here)\n        return continuation\n    \n    def node_is_on_the_left(self, node):\n        if not node:\n            return 0\n        continuation = 1 + self.node_is_on_the_right(node.right)\n        starts_here = self.node_is_on_the_left(node.left)\n        self.m = max(self.m, starts_here)\n        return continuation\n    \n    def longestZigZag(self, root: TreeNode) -> int:\n        self.m = 0\n        \n        x = self.node_is_on_the_right(root) - 1\n        self.m = max(self.m, x)\n        \n        return self.m", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.mx = 0\n        out = self.traverse(root, 0)\n        out = self.traverse(root, 1)\n        return self.mx - 1\n        \n    def traverse(self, node, ctype):\n        if node is None:\n            return 0, 0\n        \n        ll = lr = rl = rr = 0\n        \n        if node.left:\n            ll, lr = self.traverse(node.left, 0)\n        \n        if node.right:\n            rl, rr = self.traverse(node.right, 1)\n        \n        best = max(lr, rl) + 1\n        self.mx = max(self.mx, best)\n        \n        return 1 + lr, 1 + rl", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n\n        res = 0\n        def dfs(root, direction, step):\n            nonlocal res\n            if not root:\n                return\n\n            if direction == \\\"l\\\":\n                dfs(root.left, 'r', step + 1)\n                dfs(root.right, 'l', 1)\n            else:\n                dfs(root.right, 'l', step + 1)\n                dfs(root.left, 'r', 1)\n            res = max(res, step)\n\n        dfs(root, 'l', 0)\n        dfs(root, 'r', 0)\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom collections import defaultdict\n\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        levels = [root]\n        ret = 0\n        dp_r = defaultdict(int)\n        dp_l = defaultdict(int)\n        while levels:\n            \n            nxt = []\n            \n            for p in levels:\n                if p.left:\n                    nxt.append(p.left)\n                    dp_l[p.left] = dp_r[p] + 1 \n                    ret = max(ret, dp_l[p.left])\n                    \n                if p.right:\n                    nxt.append(p.right)\n                    dp_r[p.right] = dp_l[p] + 1 \n                    ret = max(ret, dp_r[p.right])\n            \n            levels = nxt\n            \n            \n        return ret", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        if root == None:\n            return 0\n        \n        max_zigzag = 0\n        zigzag = 0\n        \n        stack = [(root,None,0)]\n        \n        while(stack):\n            node = stack[-1][0]\n            prev_dir = stack[-1][1]\n            max_up_to_node = stack[-1][2]\n            del stack[-1]\n            \n            #print(prev_dir, max_up_to_node, node.left, node.right)\n            \n            if max_up_to_node > max_zigzag:\n                max_zigzag = max_up_to_node\n            \n            if prev_dir == None:\n                if node.right != None:\n                    stack.append((node.right, 'R', max_up_to_node + 1))\n                if node.left != None:\n                    stack.append((node.left, 'L', max_up_to_node + 1))\n                    \n            else:\n                if prev_dir == 'R':\n                    if node.right != None:\n                        stack.append((node.right, 'R', 1))\n                    if node.left != None:\n                        stack.append((node.left, 'L', max_up_to_node + 1))\n                        \n                if prev_dir == 'L':\n                    if node.right != None:\n                        stack.append((node.right, 'R', max_up_to_node + 1))\n                    if node.left != None:\n                        stack.append((node.left, 'L', 1))\n                        \n        return max_zigzag\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        def dfs(root):\n            if root is None:\n                return 0, [0, 0] # long zig zag, left, right\n            if root.left is None and root.right is None:\n                return 0, [0, 0]\n            \n            left_zigzag, [_, right] = dfs(root.left)\n            right_zigzag, [left, _] = dfs(root.right)\n            \n            zigzag = max(left_zigzag, right_zigzag)\n            \n            if root.right:\n                right_zigzag = 1 + left\n                zigzag = max(zigzag, right_zigzag)\n            else:\n                right_zigzag = 0\n            \n            if root.left:\n                left_zigzag = 1 + right\n                zigzag = max(zigzag, left_zigzag)\n            else:\n                left_zigzag = 0\n                \n            return zigzag, [left_zigzag, right_zigzag]\n        \n        return dfs(root)[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.max_ = 0\n        def preorder(root,count,dir_):\n            self.max_ = max(self.max_,count)\n            \n            if root.left:\n                if dir_ == 1 or dir_==-1:\n                    preorder(root.left,count+1,0)\n                else:\n                    preorder(root.left,1,0)\n                    \n            if root.right:\n                if dir_ == 0 or dir_==-1:\n                    preorder(root.right,count+1,1)\n                else:\n                    preorder(root.right,1,1)\n                    \n        preorder(root,0,-1)\n        return self.max_\n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom typing import NamedTuple\n\nclass Result(NamedTuple):\n    left_depth: int\n    right_depth: int\n    max_depth: int\n\n\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        return self.zigzag(root).max_depth\n    \n    def zigzag(self, node: TreeNode) -> int:\n        if node is None:\n            return Result(-1, -1, 0)\n        left_res = self.zigzag(node.left)\n        right_res = self.zigzag(node.right)\n        \n        left_depth = left_res.right_depth + 1\n        right_depth = right_res.left_depth + 1\n        max_depth = max(left_depth, right_depth, left_res.max_depth, right_res.max_depth)\n        return Result(left_depth, right_depth, max_depth)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def zigzag(node, direction, mz):\n            if not node:\n                return -1\n            if direction == \\\"l\\\":\n                zigzag(node.left, \\\"l\\\", mz)\n                c = zigzag(node.left, \\\"r\\\", mz)+1\n            else:\n                zigzag(node.right, \\\"r\\\", mz)\n                c = zigzag(node.right, \\\"l\\\", mz)+1\n            mz[0] = max(mz[0], c)\n            return c\n\n        maxzigzag = [0]\n        zigzag(root, \\\"l\\\", maxzigzag)\n        zigzag(root, \\\"r\\\", maxzigzag)\n\n        return maxzigzag[0]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def traverse(node,d,curr):\n            if not node:\n                res[0] = max(res[0],curr-1)\n                return\n            if d==0:\n                traverse(node.left,0,1)\n                traverse(node.right,1,curr+1)\n            else:\n                traverse(node.left,0,curr+1)\n                traverse(node.right,1,1)\n                \n        if not root:\n            return 0\n        res = [-float('inf')]\n        traverse(root.left,0,1)\n        traverse(root.right,1,1)\n        return res[0]\n    \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        Max=[0]\n        vl=set()\n        vr=set()\n        def path(node,l,d):\n            if node == None:\n                return l\n            \n        \n            if(d==1):    #start at right\n                vr.add(node)\n                return path(node.left,l+1,0) \n            else:\n                vl.add(node)\n                return path(node.right,l+1,1)\n            \n        #visited=set()\n        def dfs(node):\n            if(node==None):\n                return \n            if(node not in vl):\n                Max[0]=max(Max[0],path(node,-1,0))\n            if(node not in vr):\n                Max[0]=max(Max[0],path(node,-1,1))\n                    \n            dfs(node.left)\n            dfs(node.right)\n        dfs(root)\n            \n        return Max[0]\n        \n        \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        self.res = 0\n        def dfs(node):\n            if not node:\n                return -1, -1\n            else:\n                left = dfs(node.left)\n                right = dfs(node.right)\n                self.res = max(self.res, 1 + max(left[1], right[0]))\n                return 1 + left[1], 1 + right[0]\n        dfs(root)\n        return self.res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.memo = {}\n    \n    def h(self, node: TreeNode, left: bool) -> int:\n        if not node:\n            return 0\n        if (node, left) not in self.memo:\n            ret = 0\n            if left and node.left is not None:\n                ret = 1+self.h(node.left, False)\n            elif not left and node.right is not None:\n                ret = 1+self.h(node.right, True)\n            self.memo[(node,left)] = ret\n        return self.memo[(node,left)]\n    def longestZigZag(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        ret = [0]\n        if root.left is not None:\n            ret.extend([\n                1+self.h(root.left, False),\n                self.longestZigZag(root.left)\n            ])\n        if root.right is not None:\n            ret.extend([\n                1+self.h(root.right, True),\n                self.longestZigZag(root.right)\n            ])\n        return max(ret)\n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.lmemo = {}\n        self.rmemo = {}\n        \n    def longestZigZag(self, root: TreeNode) -> int:\n        def lzz(root,mx):\n            if root is not None:\n                lzz(root.left,mx)\n                lzz(root.right,mx)\n                mx[0] = max(mx[0],llzz(root),rlzz(root))\n            return mx\n        def llzz(root):\n            if root not in self.lmemo:\n                self.lmemo[root] = 1+rlzz(root.left)\n            return self.lmemo[root]\n        def rlzz(root):\n            if root not in self.rmemo:\n                self.rmemo[root] = 1+llzz(root.right)\n            return self.rmemo[root]\n        self.lmemo[None] = self.rmemo[None] = 0\n        return lzz(root,[float('-inf')])[0]-1", "#https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/discuss/534620/4-python-solutions\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n#        \nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.ans = 0  # nonlocal variable to store answer\n\\t\\t\n        def recurse(root):\n\\t\\t\\t# if null return -1 because length is defined \n\\t\\t\\t# as the number of nodes visited - 1. \n            if not root: return (-1,-1) \n\\t\\t\\t\n\\t\\t\\t# l1 is max path len if we go left from current node and r1 if we go right\\t\\t\\t\\t\\t\\t\n            l1,r1 = recurse(root.left)\n            l2,r2 = recurse(root.right)\n\\t\\t\\t# Notice that if we go left from current node then we have no other choice but\n\\t\\t\\t# to go right from node.left to make the path zigzag. \n            \n\\t\\t\\t# That is why  r1 + 1 is the max path len  if we go left from current node. \n\\t\\t\\t# Same logic for l2 + 1\n            print(root.val,r1,l2)\n            self.ans = max(self.ans, max(r1 + 1, l2 + 1))#r1 + 1, l2 + 1\n            print(self.ans)\n            \n            return (r1 + 1, l2 + 1)\n\\t\\t\\t\n        recurse(root)\n        return self.ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    # \u81ea\u5df1\u5199\u7684\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        # return longest zigzig path of current node from right / left\n        def dfs(node):\n            if not node.left and not node.right:\n                return (0, 0)\n            left = right = 0\n            if node.left:\n                left = dfs(node.left)[1] + 1\n            if node.right:\n                right = dfs(node.right)[0] + 1\n            # res.append(max(left, right))\n            # res[0] = max(res[0], max(left, right))\n            self.res = max(self.res, max(left, right))\n            return (left, right)\n        \n        # \u8fd9\u6837\u53cd\u800c\u4f1a\u8ba9\u65f6\u95f4\u53d8\u957f\n        # res = [0]\n        # res = []\n        self.res = 0\n        dfs(root)\n        # return max(res) if res else 0\n        # return res[0]\n        return self.res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.sol = 0\n        left = self.DFS(root,0)\n        right = self.DFS(root,1)\n        print((left,right,self.sol))\n        \n        return self.sol-1\n        \n    def DFS(self,node,direction):\n        if not node: return 0\n        left = self.DFS(node.left,0)\n        right = self.DFS(node.right,1)\n        self.sol = max(left+1,right+1,self.sol)\n        print((self.sol))\n        if direction==0:\n            return right+1\n        else:\n            return left+1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        self.sol = 0\n        left = self.DFS(root,0)\n        right = self.DFS(root,1)\n        # print(left,right,self.sol)\n        \n        return self.sol-1\n        \n    def DFS(self,node,direction):\n        if not node: return 0\n        left = self.DFS(node.left,0)\n        right = self.DFS(node.right,1)\n        self.sol = max(left+1,right+1,self.sol)\n        print((self.sol))\n        if direction==0:\n            return right+1\n        else:\n            return left+1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        return self.dfs(root)[-1]\n    \n    def dfs(self, root):\n        if not root:\n            return [-1, -1, -1] # left, right, total\n        \n        left, right = self.dfs(root.left), self.dfs(root.right)\n        \n        return [left[1] + 1, right[0] + 1, max(left[1] + 1, right[0] + 1, left[-1], right[-1])]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def helper(root):\n            if not root:\n                return (-1,-1,-1)\n            if not root.left and not root.right:\n                return (0,0,0)\n            else:\n                l1,l2,l3 = helper(root.left)\n                r1,r2,r3 = helper(root.right)\n                \n                return (l3+1, max(l3+1, r1+1, l2,r2), r1+1)\n        return helper(root)[1]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        self.sol = 0\n        \n        def recursive_long_zigzag(node):\n            if node.left is None and node.right is None:\n                return 0,0\n            max_left = 0\n            max_right = 0\n            if node.left:\n                _, left_s_right = recursive_long_zigzag(node.left)\n                max_left = left_s_right + 1\n                self.sol = max(self.sol, max_left)\n            if node.right:\n                right_s_left, _ = recursive_long_zigzag(node.right)\n                max_right = right_s_left + 1\n                self.sol = max(self.sol, max_right)\n            return max_left, max_right\n        \n        recursive_long_zigzag(root)\n        return self.sol", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.max_cnt=0\n    \n    def longestZigZag(self, root: TreeNode) -> int:\n        self.dfs(root,True,0)\n        self.dfs(root,False,0)\n        return self.max_cnt\n        \n    def dfs(self, root, isLeft, cnt):\n        if root is None:\n            return\n        self.max_cnt=max(self.max_cnt,cnt)\n        if isLeft:\n            self.dfs(root.left,False,cnt+1)\n            self.dfs(root.right,True,1)\n        else:\n            self.dfs(root.right,True,cnt+1)\n            self.dfs(root.left,False,1)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        def dfs(root):\n            if root is None:\n                return 0, [0, 0] # long zig zag, left, right\n\n            left_zigzag, [_, right] = dfs(root.left)\n            right_zigzag, [left, _] = dfs(root.right)\n            \n            zigzag = max(left_zigzag, right_zigzag)\n            \n            if root.right:\n                right_zigzag = 1 + left\n                zigzag = max(zigzag, right_zigzag)\n            else:\n                right_zigzag = 0\n            \n            if root.left:\n                left_zigzag = 1 + right\n                zigzag = max(zigzag, left_zigzag)\n            else:\n                left_zigzag = 0\n                \n            return zigzag, [left_zigzag, right_zigzag]\n        \n        return dfs(root)[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.max_cnt=0\n        \n    def longestZigZag(self, root: TreeNode) -> int:\n        self.helper(root,True,0)\n        self.helper(root,False,0)\n        return self.max_cnt\n\n    def helper(self, root,isLeft,cnt):\n        if root is None:\n            return\n        if isLeft:\n            self.helper(root.left,False,cnt+1)\n            self.helper(root.right,True,1)\n        else:\n            self.helper(root.right,True,cnt+1)\n            self.helper(root.left,False,1)\n            \n        self.max_cnt=max(self.max_cnt,cnt)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        ans = 0\n        nodes = [root]\n        self.dp = {}\n        while(len(nodes)!=0):\n            tmp = []\n            for node in nodes:\n                if(node.left is not None):\n                    tmp.append(node.left)\n                if(node.right is not None):\n                    tmp.append(node.right)\n                ans = max(ans, self.helper(node,1))\n                ans = max(ans, self.helper(node,0))\n            nodes = tmp\n        return ans-1\n        \n    def helper(self,node,status):\n        if(node is None):\n            return 0\n        if((node,status) in self.dp):\n            return self.dp[(node,status)]\n        if(status == 1):\n            ans = self.helper(node.right,0)\n        else:\n            ans = self.helper(node.left, 1)\n        self.dp[(node,status)]  = 1 + ans\n        return 1+ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        \n        memo = dict()\n        \n        def zig_zag_len(node, direction):\n            if not node:\n                return -1\n            if (node, direction) in memo:\n                return memo[node, direction]\n            if direction == 'L':\n                memo[node, direction] = 1 + zig_zag_len(node.right, 'R')\n            elif direction == 'R':\n                memo[node, direction] = 1 + zig_zag_len(node.left, 'L')\n            else:\n                memo[node, direction] = max(1 + zig_zag_len(node.right, 'R'),\n                                            1 + zig_zag_len(node.left, 'L'),\n                                            zig_zag_len(node.right, 'N'),\n                                            zig_zag_len(node.left, 'N'))\n            return memo[node, direction]\n        \n        return zig_zag_len(root, 'N')", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        def zigzag(node, mz):\n            if not node:\n                return -1, -1\n            l1, r1 = zigzag(node.left, mz)\n            l2, r2 = zigzag(node.right, mz)\n            mz[0] = max(mz[0], r1+1, l2+1)\n            return r1+1, l2+1\n\n        maxzigzag = [0]\n        zigzag(root, maxzigzag)\n        zigzag(root, maxzigzag)\n\n        return maxzigzag[0]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def run(self, node, side, count, memo):\n        if not node:\n            return count\n        \n        if node in memo:\n            if memo[node][side] > -1:\n                return memo[node][side]\n        \n        memo[node] = [-1, -1, -1]\n        \n        if side == 0:\n            result = self.run(node.right, 1, count+1, memo)\n        elif side == 1:\n            result = self.run(node.left, 0, count+1, memo)\n        else:\n            using = max(self.run(node.right, 1, 1, memo), self.run(node.left, 0, 1, memo))\n            notUsing = max(self.run(node.right, -1, 0, memo), self.run(node.left, -1, 0, memo))\n            result = max(using, notUsing)\n        \n        memo[node][side] = result\n        \n        return result\n        \n    \n    def longestZigZag(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        return self.run(root, -1, 0, {})-1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: TreeNode) -> int:\n        nodes = self.bfs(root)\n        self.dp = {node:[False, False] for node in nodes}\n        ans = 0\n        for x in range(len(nodes)):\n            ans = max(ans, self.recur(0, nodes[x], -1), self.recur(1, nodes[x], -1))\n        return ans\n        \n    \n    def bfs(self, node):\n        q = [node]\n        arr = []\n        while q:\n            r = q.pop()\n            arr.append(r)\n            if r.left:\n                q.append(r.left)\n            if r.right:\n                q.append(r.right)\n        return arr\n\n    \n    def recur(self, p, node, c):\n        if not node:\n            return c\n        if self.dp[node][p] != False:\n            return self.dp[node][p]\n\n        if p == 0:\n            self.dp[node][p] = self.recur(p^1, node.left, c+1)\n            return self.dp[node][p]\n        else:\n            self.dp[node][p] = self.recur(p^1, node.right, c+1)\n            return self.dp[node][p]\n"]
["class Solution:\n    def balancedString(self, s: str) -> int:\n        # minimum window so that outside is possible\n        if len(s) //4 != len(s) / 4: return -1 \n        ans, lb, n_cnt = len(s), 0, collections.Counter(s)\n\n        i = 0\n        while i < len(s): \n            n_cnt[s[i]] -= 1     \n            while lb < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \n                ans = min(ans, abs(i - lb + 1))\n                if ans == 0: return 0\n                n_cnt[s[lb]] += 1\n                lb += 1\n                # here is actually a swap? \n            if lb > i: \n                i, lb = lb, i\n            i +=1\n\n        return ans\n                \n            \n            \n        \n            \n            \n", "class Solution:\n    def balancedString(self, s: str) -> int:\n        # minimum window so that outside is possible\n        if len(s) //4 != len(s) / 4: return -1 \n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\n\n        \n        while p1 < len(s): \n            n_cnt[s[p1]] -= 1     \n            while p2 < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \n                ans = min(ans, abs(p1 - p2 + 1))\n                n_cnt[s[p2]] += 1\n                p2 += 1\n                # here is actually a swap? \n            if p2 > p1: \n                p1, p2 = p2, p1\n            p1 +=1\n\n        return ans\n                \n            \n            \n        \n            \n            \n", "class Solution:\n    def balancedString(self, s: str) -> int:\n        # minimum window so that outside is possible\n        if len(s) //4 != len(s) / 4: return -1 \n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\n\n        while p1 < len(s): \n            n_cnt[s[p1]] -= 1     \n            while p2 < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \n                ans = min(ans, abs(p1 - p2 + 1))\n                n_cnt[s[p2]] += 1\n                p2 += 1\n            if p2 > p1: \n                p1, p2 = p2, p1\n            p1 +=1\n\n        return ans\n                \n            \n            \n        \n            \n            \n", "class Solution:\n    def balancedString(self, s: str) -> int:\n        # minimum window so that outside is possible\n        if len(s) //4 != len(s) / 4: return -1 \n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\n\n        while p1 < len(s): \n            n_cnt[s[p1]] -= 1     \n            while p2 < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \n                ans = min(ans, abs(p1 - p2 + 1))\n                n_cnt[s[p2]] += 1\n                p2 += 1\n            if p2 > p1: \n                p1, p2 = p2, p1\n            p1 +=1\n        return ans\n    \n    def balancedString(self, s: str) -> int:\n        # minimum window so that outside is possible\n        if len(s) //4 != len(s) / 4: return -1 \n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\n\n        while p1 < len(s): \n            n_cnt[s[p1]] -= 1     \n            while p2 < min(p1+2, len(s)) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \n                # can go beyond one position\n                ans = min(ans, abs(p1 - p2 + 1))\n                n_cnt[s[p2]] += 1\n                p2 += 1\n            # if p2 > p1: \n            #     p1, p2 = p2, p1\n            p1 +=1\n        return ans\n                \n            \n            \n        \n            \n            \n", "class Solution:\n    def balancedString(self, s: str) -> int:\n        # minimum window so that outside is possible\n        if len(s) //4 != len(s) / 4: return -1 \n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\n\n        while p1 < len(s): \n            n_cnt[s[p1]] -= 1     \n            while p2 < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \n                ans = min(ans, abs(p1 - p2 + 1))\n                n_cnt[s[p2]] += 1\n                p2 += 1\n            if p2 > p1: \n                p1, p2 = p2, p1\n            p1 +=1\n        return ans\n    \n    def balancedString(self, s: str) -> int:\n        # minimum window so that outside is possible\n        if len(s) //4 != len(s) / 4: return -1 \n        ans, p1, p2, n_cnt = len(s), 0, 0, collections.Counter(s)\n\n        while p1 < len(s): \n            n_cnt[s[p1]] -= 1     \n            while p2 < min(p1+2, len(s)) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \n                ans = min(ans, abs(p1 - p2 + 1))\n                n_cnt[s[p2]] += 1\n                p2 += 1\n            # if p2 > p1: \n            #     p1, p2 = p2, p1\n            p1 +=1\n        return ans\n                \n            \n            \n        \n            \n            \n", "from sys import maxsize\nfrom collections import Counter\nclass Solution:\n    def balancedString(self, s):\n        n = len(s)\n        right = 0\n        chars = Counter(s)\n        res = maxsize\n        for left in range(n):\n            while right <= n - 1 and any(chars[c] > n // 4 for c in 'QWER'):\n                chars[s[right]] -= 1\n                right += 1\n            if all(chars[c] <= n // 4 for c in 'QWER'):\n                res = min(res, right - left)\n            chars[s[left]] += 1\n        return res      ", "class Solution:\n    def balancedString(self, s: str) -> int:\n        # minimum window so that outside is possible\n        if len(s) //4 != len(s) / 4: return -1 \n        ans, lb, n_cnt = len(s), 0, collections.Counter(s)\n\n        for i, l in enumerate(s): \n            n_cnt[l] -= 1               \n            while lb < len(s) and all(len(s) / 4 >= n_cnt[c] for c in 'QWER'): \n                # how to shrink? \n                ans = min(ans, i - lb + 1)\n                n_cnt[s[lb]] += 1\n                lb += 1\n                \n        return ans\n                \n            \n            \n        \n            \n            \n"]
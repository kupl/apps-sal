["N = int(input())\nX = list(map(int, input().split()))\nL = int(input())\n\ndef one_step(i):\n  goal = X[i] + L\n  \n  # find largest j s.t. X[j] <= X[i] + L\n  low = 0\n  high = N\n  while high - low > 1:\n    mid = (high + low)//2\n    if X[mid] <= goal:\n      low = mid\n    else:\n      high = mid\n  \n  return low\n\nonesteps = [one_step(i) for i in range(N)]\n\ndef double(layer):\n  return [layer[layer[i]] for i in range(N)]\n\nNUM_LAYERS = 20\nlayers = [onesteps]\nfor _ in range(NUM_LAYERS):\n  layers.append(double(layers[-1]))\n  \ndef query(a, b):\n  if a > b:\n    a, b = b, a\n  \n  ans = 0\n  while a < b:\n    ind = 0\n    while layers[ind + 1][a] < b:\n      ind += 1\n    ans += 2 ** ind\n    a = layers[ind][a]\n  return ans\n  \nQ = int(input())\nfor _ in range(Q):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  print(query(a, b))", "\ndef main2(n,x,l,q,ab):\n  ary=[[0]*n for _ in range(30)]\n  # ary[k][i]:\u30db\u30c6\u30ebi\u304b\u30892^k\u65e5\u304b\u3051\u3066\u305f\u3069\u308a\u7740\u3051\u308b\u6700\u3082\u53f3\u306e\u30db\u30c6\u30eb\n  idx=1\n  for i in range(n):\n    while idx+1<n and x[idx+1]-x[i]<=l:\n      idx+=1\n    ary[0][i]=idx\n  for k in range(29):\n    for i in range(n):\n      if ary[k][i]<n:\n        ary[k+1][i]=ary[k][ary[k][i]]\n      else:\n        ary[k+1][i]=n\n  # a->b\u306b\u304b\u304b\u308b\u65e5\u6570\n  ret=[]\n  for a,b in ab:\n    a,b=a-1,b-1\n    if a>b:a,b=b,a\n    tmp=0\n    k=0\n    while a<b:\n      k=0\n      while ary[k+1][a]<b:\n        k+=1\n      tmp+=1<<k\n      a=ary[k][a]\n    ret.append(tmp)\n  return ret\n\ndef __starting_point():\n  n=int(input())\n  x=list(map(int,input().split()))\n  l=int(input())\n  q=int(input())\n  ab=[list(map(int,input().split())) for _ in range(q)]\n  ret2=main2(n,x,l,q,ab)\n  print(*ret2,sep='\\n')\n\n__starting_point()", "import sys\nimport bisect\n\n\ndef solve():\n    input = sys.stdin.readline\n    mod = 10 ** 9 + 7\n    n = int(input().rstrip('\\n'))\n    x = [v for v in list(map(int, input().rstrip('\\n').split()))]\n    l = int(input().rstrip('\\n'))\n    q = int(input().rstrip('\\n'))\n    ln = 64\n    lsf = [[-1] * ln for _ in range(n)]\n    lsb = [[-1] * ln for _ in range(n)]\n    for i in range(n - 1):\n        lsf[i][0] = bisect.bisect_right(x, x[i] + l) - 1\n        lsb[-i-1][0] = bisect.bisect_left(x, x[-i-1] - l)\n    for j in range(1, ln):\n        for i in range(n):\n            if lsf[i][j - 1] != -1:\n                lsf[i][j] = lsf[lsf[i][j - 1]][j - 1]\n            if lsb[i][j - 1] != -1:\n                lsb[i][j] = lsb[lsb[i][j - 1]][j - 1]\n\n    for i in range(q):\n        a, b = list(map(int, input().rstrip('\\n').split()))\n        a, b = a - 1, b - 1\n        cnt = 0\n        if a < b:\n            for j in range(b.bit_length(), -1, -1):\n                if lsf[a][j] != -1:\n                    if lsf[a][j] <= b:\n                        cnt += 2 ** j\n                        a = lsf[a][j]\n        else:\n            for j in range(a.bit_length(), -1, -1):\n                if lsb[a][j] != -1:\n                    if lsb[a][j] >= b:\n                        cnt += 2 ** j\n                        a = lsb[a][j]\n        cnt += 0 if a == b else 1\n        print(cnt)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\n\n#A\ndef A():\n    return\n\n#B\ndef B():\n    return\n\n#C\ndef C():\n    n = I()\n    x = LI()\n    l = I()\n    k = int(math.log(n,2))\n    f = [[i for j in range(k+1)] for i in range(n)]\n    for i in range(n-1):\n        j = bisect.bisect_left(x,x[i]+l)\n        if j < n:\n            if x[j] > x[i]+l:\n                f[i][0] = j-1\n            else:\n                f[i][0] = j\n        else:\n            f[i][0] = j-1\n    po2 = [1]*(k+1)\n    for i in range(k):\n        po2[i+1] = po2[i]*2\n    for j in range(k):\n        for i in range(n):\n            f[i][j+1] = f[f[i][j]][j]\n    q = I()\n    for i in range(q):\n        a,b = LI()\n        a,b = [min(a,b)-1, max(a,b)-1]\n        ans = 0\n        while a < b:\n            i = bisect.bisect_left(f[a],b)\n            ans += po2[max(0,i-1)]\n            a = f[a][max(0,i-1)]\n        print(ans)\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\ndef __starting_point():\n    C()\n\n__starting_point()", "from bisect import bisect_left, bisect_right\nimport math\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    X = list(map(int, input().split()))\n    L = int(input())\n    ln = int(math.log(N, 2))\n    dpl = [[0] * N for _ in range(ln+1)]\n    dpr = [[0] * N for _ in range(ln+1)]\n    l = 0\n    r = 0\n    for i in range(N):\n        x = X[i]\n        while X[l] + L < x:\n            l += 1\n        while r < N-1 and x + L >= X[r+1]:\n            r += 1\n        dpl[0][i] = l\n        dpr[0][i] = r\n    for k in range(1, ln+1):\n        for i in range(N):\n            dpl[k][i] = dpl[k-1][dpl[k-1][i]]\n            dpr[k][i] = dpr[k-1][dpr[k-1][i]]\n    Q = int(input())\n    for _ in range(Q):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        ans = 0\n        if a < b:\n            for k in range(ln+1)[::-1]:\n                if dpr[k][a] < b:\n                    a = dpr[k][a]\n                    ans += 2**k\n            if a < b:\n                ans += 1\n        else:\n            # a > b\n            for k in range(ln+1)[::-1]:\n                if dpl[k][a] > b:\n                    a = dpl[k][a]\n                    ans += 2**k\n            if a > b:\n                ans += 1\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN = int(sys.stdin.readline())\nX = list(map(int, sys.stdin.readline().split()))\nL = int(sys.stdin.readline())\nQ = int(sys.stdin.readline())\nAB = [list(map(int, sys.stdin.readline().split())) for _ in range(Q)]\n\nN += 2\nX = [X[0]] + X + [X[-1]]\nX = np.array(X, dtype=int)\n# dp[d][i]: i\u756a\u306e\u30db\u30c6\u30eb\u304b\u3089(2^d)\u65e5\u3067\u4f55\u500b\u53f3\u307e\u3067\u3044\u3051\u308b\u304b\ndp = np.zeros((N.bit_length() + 1, N), dtype=int)\ndp[0] = np.searchsorted(X, X + L, side=\"right\") - 1\nfor d in range(1, N.bit_length() + 1):\n    dp[d] = dp[d - 1][dp[d - 1]]\ndp = dp.tolist()\n\n\ndef solve(l, r):\n    ret = 0\n    d = len(dp) - 1\n    while l + 1 < r:\n        while d > 0 and dp[d][l] >= r:\n            d -= 1\n        ret += 1 << d\n        l = dp[d][l]\n    if l < r:\n        ret += 1\n    return ret\n\n\nans = []\nfor a, b in AB:\n    ans.append(solve(min(a, b), max(a, b)))\nprint(*ans, sep='\\n')\n", "def solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    L = int(input())\n    dp = [[0] * 20 for _ in range(n)]\n    for i in range(n):\n        l, r = i, n\n        while l < r:\n            mid = (l + r) >> 1\n            if arr[mid] - arr[i] <= L:\n                l = mid + 1\n            else:\n                r = mid \n        dp[i][0] = r - 1\n        \n    for j in range(1, 20):\n        for i in range(n):\n            dp[i][j] = dp[dp[i][j - 1]][j - 1]\n    \n    q = int(input())\n    for _ in range(q):\n        x, y = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        if x > y:\n            x, y = y, x\n        tmp = 0\n        for j in range(19, -1, -1):\n            if dp[x][j] < y:\n                tmp += 1 << j \n                x = dp[x][j]\n        print((tmp + 1))\n\n\nsolve()\n", "import bisect\nimport os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN = int(sys.stdin.readline())\nX = list(map(int, sys.stdin.readline().split()))\nL = int(sys.stdin.readline())\nQ = int(sys.stdin.readline())\nAB = [list(map(int, sys.stdin.readline().split())) for _ in range(Q)]\n\nN += 2\nX = [X[0]] + X + [X[-1]]\nX = np.array(X, dtype=int)\n# dp[d][i]: i\u756a\u306e\u30db\u30c6\u30eb\u304b\u3089(2^d)\u65e5\u3067\u4f55\u500b\u53f3\u307e\u3067\u3044\u3051\u308b\u304b\ndp = np.zeros((N.bit_length() + 1, N), dtype=int)\ndp[0] = np.searchsorted(X, X + L, side=\"right\") - 1\nfor d in range(1, N.bit_length() + 1):\n    dp[d] = dp[d - 1][dp[d - 1]]\ndp = dp.T.tolist()\n\n\ndef solve(l, r):\n    ret = 0\n    while l + 1 < r:\n        d = max(0, bisect.bisect_left(dp[l], r) - 1)\n        ret += pow(2, d)\n        l = dp[l][d]\n    if l < r:\n        ret += 1\n    return ret\n\n\nans = []\nfor a, b in AB:\n    ans.append(solve(min(a, b), max(a, b)))\nprint(*ans, sep='\\n')\n", "def reachN(i0, n):\n    if n == 0:\n        return i0\n    maxbit = ceil(log2(n))\n    kL = []\n    for i in range(maxbit+1):\n        if n>>i & 1:\n            kL.append(i)\n    #print(kL)\n    i = i0\n    for k in kL[::-1]:\n        i = dp[k][i]      #; print('norm', i)\n    return i   \n\ndef fun(n):\n    return reachN(start, n) >= goal\n    \ndef binMin(l, r):\n    if r-l == 1:\n        return r\n    m = (l+r) // 2\n    if fun(m):\n        r = m\n    else:\n        l = m\n    return binMin(l, r)\n\nimport bisect\nfrom math import log2, ceil\n\nN = int(input())\nxL = [-float('inf')] + [int(i) for i in input().split()]   #; print(xL)\nLmax = int(input())\n\nkmax = ceil(log2(len(xL)-2))                               #; print(kmax)\ndp = [[len(xL)-1]*(N+1) for _ in range(kmax+1)]\nfor i in range(1, N+1):\n    dp[0][i] = bisect.bisect_right(xL, xL[i]+Lmax) - 1\n#print2(dp)\nfor k in range(1, kmax+1):\n    for i in range(1, N):\n        dp[k][i] = dp[k-1][dp[k-1][i]]\n#print2(dp); print()\n\nQ = int(input())\nfor _ in range(Q):\n    start, goal = list(map(int, input().split()))\n    if start > goal:\n        start, goal = goal, start\n    ans = binMin(0, goal-start)\n    print(ans)\n", "import bisect\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int,input().split()))\nd = int(input())\ngraph = [[0 for i in range(n+1)] for j in range(18)]\nfor i in range(n):\n  x = bisect.bisect_right(a,a[i]+d)\n  graph[0][i+1] = x\nfor j in range(1,18):\n  for i in range(n):\n    t = graph[j-1][i+1]\n    graph[j][i+1] = graph[j-1][t]\nq = int(input())\nfor _ in range(q):\n  x,y = map(int,input().split())\n  x,y = min(x,y),max(x,y)\n  ans = 0\n  for j in range(18)[::-1]:\n    if graph[j][x] < y:\n      ans += 2**j\n      x = graph[j][x]\n    if j == 0 and x < y:\n      ans += 1\n  print(ans)", "import bisect\n\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\nq = int(input())\nquery = [list(map(int, input().split())) for i in range(q)]\n\nlog_size = n.bit_length() + 1\ndouble = [[0] * n for i in range(log_size)]\n\nfor i in range(n):\n    double[0][i] = bisect.bisect_right(x, x[i] + l) - 1\n\nfor k in range(1, log_size):\n    for i in range(n):\n        double[k][i] = double[k - 1][double[k - 1][i]]\n        \nfor a, b in query:\n    a -= 1\n    b -= 1\n    if a > b:\n        a, b = b, a\n    ans = 10 ** 18\n    tmp = 0\n    for k in range(log_size)[::-1]:\n        if double[k][a] >= b:\n            ans = min(ans, 2 ** k + tmp)\n        else:\n            a = double[k][a]\n            tmp += 2 ** k\n    print(ans)", "def examE():\n    N = I()\n    X = LI()\n    L = I(); Q = I()\n    n = N.bit_length()+1\n    dp = [[0] * n for _ in range(N)]\n    for i in range(N):\n        dp[i][0] = bisect.bisect_right(X, X[i] + L) - 1\n    for i in range(1, n):\n        for j in range(N):\n            if dp[j][i - 1] < N:\n                index = dp[dp[j][i - 1]][i - 1]\n                if index == j:\n                    dp[j][i] = N\n                else:\n                    dp[j][i] = index\n            else:\n                dp[j][i] = N\n    def fast_day(a, b):\n        if a > b:\n            a, b = b, a\n        res = 0\n        for i in range(n):\n            if a >= b:\n                return res\n            c = max(0, bisect.bisect_left(dp[a], b) - 1)\n            #\u6700\u4f4e\u304b\u304b\u308b2**?\u306e\u65e5\u6570\n            a = dp[a][c]\n            #\u305d\u3053\u307e\u3067\u884c\u304f\n            res += 2 ** c\n    for _ in range(Q):\n        a, b = list(map(int, input().split()))\n        print((fast_day(a - 1, b - 1)))\n#    print(dp)\n\nimport sys,copy,bisect,itertools,heapq,math\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef S(): return sys.stdin.readline().strip()\nmod = 10**9 + 7\ninf = float('inf')\n\nexamE()\n", "def main():\n    n = int(input())\n    x = list(map(int, input().split()))\n    l = int(input())\n    q = int(input())\n    ab = [list([int(x)-1 for x in input().split()]) for _ in [0]*q]\n    doubling = [[] for _ in [0]*n]\n    j = 0\n    for i in range(n):\n        while j < n:\n            if x[j]-x[i] > l:\n                doubling[i].append(j-1)\n                break\n            else:\n                j += 1\n    for i in range(n-1, -1, -1):\n        if not doubling[i]:\n            doubling[i].append(n-1)\n        else:\n            break\n    for _ in range(16):\n        for i in range(n):\n            doubling[i].append(doubling[doubling[i][-1]][-1])\n    for a, b in ab:\n        if a > b:\n            a, b = b, a\n        ans = 0\n        j = 16\n        while j >= 0:\n            if doubling[a][j] >= b:\n                j -= 1\n            else:\n                a = doubling[a][j]\n                ans += 2**j\n        if a == b:\n            print(ans)\n        else:\n            print((ans+1))\n\n\nmain()\n", "from functools import reduce\nfrom fractions import gcd\nimport math\nimport bisect\nimport itertools\nimport sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\nINF = float(\"inf\")\n\n\ndef main():\n    N = int(input())\n    x = list(map(int, input().split()))\n    L = int(input())\n    Q = int(input())\n\n    LOG = 30    # 30 > log2(10**9)\n    nxt = [[-1]*N for _ in range(LOG)]\n    for i in range(N):\n        nxt[0][i] = bisect.bisect_left(x, x[i]+L+1) - 1\n\n    for k in range(LOG-1):\n        for i in range(N):\n            if nxt[k][i] == -1:\n                nxt[k+1][i] = -1\n            else:\n                nxt[k+1][i] = nxt[k][nxt[k][i]]\n\n    for _ in range(Q):\n        a, b = map(int, input().split())\n        if a > b:\n            a, b = b, a\n        a -= 1\n        b -= 1\n        ans = 0\n        for k in reversed(range(LOG)):\n            if nxt[k][a] < b:\n                a = nxt[k][a]\n                ans += 2 ** k\n        print(ans + 1)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import bisect\n\nn=int(input())\narr=list(map(int,input().split()))\nl=int(input())\npos=0\ndbl=[[0]*(n+1)]\nfor i in range(n):\n  dbl[0][i+1]=bisect.bisect_right(arr,arr[i]+l)\nfor _ in range(20):\n  tmp=[0]*(n+1)\n  for i in range(n+1):\n    tmp[i]=dbl[-1][dbl[-1][i]]\n  dbl.append(tmp)\nq=int(input())\nfor _ in range(q):\n  a,b=map(int,input().split())\n  if a>b:\n    a,b=b,a\n  l=0\n  r=b-a+1\n  while r-l!=1:\n    mid=(l+r)//2\n    tmp=a\n    for i in range(20):\n      if mid&(1<<i):\n        tmp=dbl[i][tmp]\n    if tmp>=b:\n      r=mid\n    else:\n      l=mid\n  print(r)", "import sys\nsys.setrecursionlimit(10 ** 6)  # \u5909\u66f4\nfrom bisect import bisect_left,bisect\n\nn = int(input())\nx = list(map(int,input().split()))\nL = int(input())\nt = n.bit_length()\nprv = [n-1] * n\nfor i in range(n):\n    prv[i] = bisect(x,x[i]+L) - 1\nkprv = [prv]\nS = prv\nfor i in range(t-1):\n    kar = [n-1] * n\n    for j in range(n):\n        kar[j] = S[S[j]]\n    kprv.append(kar)\n    S = kar\n\nq = int(input())\nfor _ in range(q):\n    a , b = map(lambda x:int(x)-1,input().split())\n    if a > b:\n        a , b = b , a\n    lef = 0\n    rig = n-1\n    while rig - lef > 1:\n        mid = (rig+lef)//2\n        p = mid.bit_length()\n        now = a\n        for i in range(p):\n            if (mid>>i) & 1 == 1:\n                now = kprv[i][now]\n        if now >= b:\n            rig = mid\n        elif now < b:\n            lef = mid\n    print(rig)", "import sys,queue,math,copy,itertools,bisect,collections,heapq\n\ndef main():\n    sys.setrecursionlimit(10**7)\n    INF = 10**18\n    MOD = 10**9 + 7\n    LI = lambda : [int(x) for x in sys.stdin.readline().split()]\n    _LI = lambda : [int(x)-1 for x in sys.stdin.readline().split()]\n    NI = lambda : int(sys.stdin.readline())\n    SI = lambda : sys.stdin.readline().rstrip()\n\n    N = NI()\n    x = LI() + [INF]\n    L = NI()\n    m = N.bit_length()\n    f = [[N-1] * N for _ in range(m)]\n    j = 1\n    for i in range(N-1):\n        while x[i] + L >= x[j+1]:\n            j += 1\n            if j >= N-1: break\n        f[0][i] = j\n    for k in range(1,m):\n        for i in range(N):\n            f[k][i] = f[k-1][f[k-1][i]]\n\n    for _ in range(NI()):\n        ans = 0\n        a,b = _LI()\n        if a > b: a,b = b,a\n\n        for k in range(m-1,-1,-1):\n            if f[k][a] < b:\n                a = f[k][a]\n                ans += 2**k\n        print(ans+1)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput=sys.stdin.readline\nfrom bisect import bisect_right\nn=int(input())\nX=tuple(map(int,input().split()))\nl=int(input())\nq=int(input())\nD=[[0]*n for _ in range(18)]\nfor i in range(n):\n    D[0][i]=bisect_right(X,X[i]+l)-1\nfor k in range(1,18):\n    for i in range(n):\n        D[k][i]=D[k-1][D[k-1][i]]\n\ndef query(a,b):\n    ret=0\n    while True:\n        for k in range(18):\n            if D[k][a]>=b:\n                break\n        if k==0:\n            ret+=1\n            return ret\n        k-=1\n        ret+=pow(2,k)\n        a=D[k][a]\n\nfor _ in range(q):\n    a,b=map(int,input().split())\n    if a>b:\n        a,b=b,a\n    a-=1; b-=1\n    print(query(a,b))", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\nq = int(input())\nps = [None]*n\n# ps2 = [None]*n\nj = 0\nfor i in range(n):\n    if j<i:\n        j = i\n    while j+1<n and x[j+1]-x[i]<=l:\n        j += 1\n    ps[i] = j\n# \u30c0\u30d6\u30ea\u30f3\u30b0\ndef double(ps):\n    # global: n=ps\u306e\u30b5\u30a4\u30ba\n    k = 0\n    n = len(ps)\n    while pow(2,k)<n:\n        k += 1\n    prev = [[None]*n for _ in range(k)] # \u30ce\u30fc\u30c9j\u304b\u30892^i\u500b\u4e0a\u306e\u4e0a\u53f8\n    for j in range(n):\n        prev[0][j] = ps[j]\n    for i in range(1,k):\n        for j in range(n):\n            p = prev[i-1][j]\n            if p>=0:\n                prev[i][j] = prev[i-1][p]\n            else:\n                prev[i][j] = p\n    return prev\ndl = double(ps)\nans = [None]*q\ndef sub(a,b,x):\n    for k in range(len(dl)-1, -1, -1):\n        if x>=pow(2,k):\n            x-=pow(2,k)\n            a = dl[k][a]\n    return a>=b\n        \n        \nfor i in range(q):\n    a,b = map(lambda x: int(x)-1, input().split())\n    a,b = min(a,b), max(a,b)\n#     print(a,b)\n    res = 0\n    tmp = float(\"inf\")\n    l = 0\n    r = n\n    while l+1<r:\n        m = (l+r)//2\n        if sub(a,b,m):\n            r = m\n        else:\n            l = m\n    ans[i] = r\nwrite(\"\\n\".join(map(str, ans)))", "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\nN = int(input())\nX = np.array(input().split(), dtype = np.int64)\nL = int(input())\n\nU = N.bit_length()\n# \u5404\u30db\u30c6\u30eb\u304b\u3089\u30012^n\u56de\u3067\u3069\u3053\u307e\u3067\u884c\u3051\u308b\u304b\nnext_x = []\nnext_x.append(np.searchsorted(X, X+L, side = 'right') - 1)\nfor i in range(U):\n    next_x.append(next_x[i][next_x[i]])\n\ndef days(a,b):\n    a -= 1\n    b -= 1\n    if b < a:\n        a,b = b,a\n    # \u5230\u7740\u3067\u304d\u306a\u3044\u7bc4\u56f2\u3067\u6700\u5927\u9650\u9032\u3080\n    result = 0\n    for n in range(U,-1,-1):\n        c = next_x[n][a]\n        if c < b:\n            a = c\n            result += 1 << n\n    return result + 1\n\nQ = int(input())\nfor _ in range(Q):\n    a,b = map(int,input().split())\n    print(days(a,b))", "# seishin.py\nN = int(input())\n*X, = map(int, input().split())\nL = int(input())\n\nK = 20\n\nD = [[N]*(K+1) for i in range(N)]\nj = N-1\nfor i in range(N-1, -1, -1):\n    while j > 0 and X[j] - X[i] > L:\n        j -= 1\n    D[i][0] = j\nfor k in range(K):\n    for i in range(N):\n        if D[i][k] != N:\n            D[i][k+1] = D[D[i][k]][k]\ndef solve(a, b):\n    if not a < b:\n        a, b = b, a\n    res = 1\n    for k in range(K, -1, -1):\n        if D[a][k] < b:\n            a = D[a][k]\n            res += 2**k\n    return res\nQ = int(input())\nans = []\nfor i in range(Q):\n    a, b = map(int, input().split())\n    ans.append(solve(a-1, b-1))\nprint(*ans, sep='\\n')\n", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n = I()\n    x = LI()\n    L = I()\n    q = I()\n    p = [[] for i in range(n)]\n    for i in range(n):\n        xi = x[i]\n        l = i\n        r = n\n        while r-l > 1:\n            m = (l+r) >> 1\n            xm = x[m]\n            if xm-xi <= L:\n                l = m\n            else:\n                r = m\n        p[i].append(l)\n    N = 20\n    for j in range(N):\n        for i in range(n):\n            p[i].append(p[p[i][-1]][-1])\n    for i in range(q):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        a,b = min(a,b),max(a,b)\n        ans = 1\n        for j in range(N)[::-1]:\n            if p[a][j] < b:\n                a = p[a][j]\n                ans += 1<<j\n        print(ans)\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()", "from bisect import bisect_right\nN = int(input())\nX = list(map(int, input().split()))\nL = int(input())\n\nP = [[0] * N for i in range(30)]\nfor i in range(N):\n    q = bisect_right(X, X[i] + L)\n    P[0][i] = q - 1\n\nfor i in range(1, 30):\n    for j in range(N):\n        P[i][j] = P[i - 1][P[i - 1][j]]\n\n\nQ = int(input())\nfor i in range(Q):\n    a, b = map(int, input().split())\n    if a > b:\n        a, b = b, a\n    a, b = a - 1, b - 1\n    num = 0\n    for j in range(29, -1, -1):\n        if P[j][a] < b:\n            a = P[j][a]\n            num += 2 ** j\n    print(num + 1)", "def main():\n    n = int(input())\n    x = list(map(int, input().split()))\n    l = int(input())\n    q = int(input())\n    ab = [list(map(lambda x:int(x)-1, input().split())) for _ in [0]*q]\n    doubling = [[] for _ in [0]*n]\n    j = 0\n    for i in range(n):\n        while j < n:\n            if x[j]-x[i] > l:\n                doubling[i].append(j-1)\n                break\n            else:\n                j += 1\n    for i in range(n-1, -1, -1):\n        if not doubling[i]:\n            doubling[i].append(n-1)\n        else:\n            break\n    for _ in range(16):\n        for i in range(n):\n            doubling[i].append(doubling[doubling[i][-1]][-1])\n    for a, b in ab:\n        if a > b:\n            a, b = b, a\n        ans = 0\n        j = 16\n        while j >= 0:\n            if doubling[a][j] >= b:\n                j -= 1\n            else:\n                a = doubling[a][j]\n                ans += 2**j\n        if a == b:\n            print(ans)\n        else:\n            print(ans+1)\n\n\nmain()", "3.6\nimport bisect\nn = int(input())\nx = [int(item) for item in input().split()]\nl = int(input())\nq = int(input())\nab = []\nfor i in range(q):\n    a, b = [int(item) for item in input().split()]\n    a -= 1; b -= 1\n    if a > b:\n        a, b = b, a\n    ab.append((a, b))\n\ndt = [[0] * n for _ in range(18)]\nfor i, item in enumerate(x):\n    dt[0][i] = bisect.bisect_right(x, item + l) - 1\n\nfor i in range(1, 18):\n    for j in range(n):\n        dt[i][j] = dt[i-1][dt[i-1][j]]\n\nfor a, b in ab:\n    days = 0\n    if a == b:\n        print(days)\n        continue\n    for i in range(17, -1, -1):\n        if dt[i][a] < b:\n            a = dt[i][a]\n            days += 2**i\n    print(days + 1)", "import math\nN = int(input())\nX = list(map(int,input().split()))\n\nL = int(input())\nM = N.bit_length()+3\ndoub = [[0 for _ in range(N)] for _ in range(M)]\n\nr = 0\nfor l in range(N):\n  db = doub[0]\n  while r < N and X[r] <= X[l] + L:\n    r += 1\n  r -= 1\n  db[l] = r \n\nfor i in range(1,M):\n  db = doub[i]\n  dbp = doub[i-1]\n  for l in range(N):\n    db[l] = dbp[dbp[l]]\n#print(*doub, sep=\"\\n\")\n\ndef db_query(a, b): #a\u304b\u3089b\u3078\u884c\u304f\u6642\u306e\u56de\u6570\n  ans = 0\n  tmp = a\n  d = N.bit_length()\n  while d >= 0:\n    #print(a,b, d,ans,tmp,doub[d][tmp])\n    if doub[d][tmp] < b:\n      ans += pow(2,d)\n      tmp = doub[d][tmp]  \n    d -= 1\n  return ans+1    \n    \n  \nQ = int(input())\nfor _ in range(Q):\n  a, b = list(map(int,input().split()))\n  if a > b:\n    a, b = b, a\n  a -= 1\n  b -= 1\n  print((db_query(a, b)))\n  \n  \n\n", "import bisect\n\nN = int(input())\nx = list(map(int, input().split()))\nL = int(input())\n\ndest = []\ndest_1 = [0] * N\nfor i in range(N):\n    dest_1[i] = bisect.bisect_left(x, x[i] + L + 0.5) - 1\ndest.append(dest_1)\nfor i in range(1, len(bin(N - 1)) - 1):\n    dest_prev = dest[i - 1]\n    dest_i = [0] * N\n    for j in range(N):\n        dest_i[j] = dest_prev[dest_prev[j]]\n    dest.append(dest_i)\n\nQ = int(input())\nfor _ in range(Q):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    if a > b:\n        a, b = b, a\n    k = len(dest) - 1\n    ans = 0\n    while True:\n        d = dest[k][a]\n        if d >= b:\n            if k > 0:\n                k -= 1\n            else:\n                ans += 1\n                break\n        else:\n            ans += 2 ** k\n            a = d\n    print(ans)\n", "from bisect import bisect_right\nfrom math import log\n\nN = int(input())\nX = list(map(int, input().split()))\nL = int(input())\n\nR = [[-1] * N for i in range(int(log(N, 2) + 1))]\n# 1\u65e5\u3067\u884c\u3051\u308b\u3068\u3053\u308d\u3092\u306b\u3076\u305f\u3093\u3067\u6c42\u3081\u308b\nfor i in range(N):\n    R[0][i] = bisect_right(X, X[i] + L) - 1\n\n# \u30c0\u30d6\u30ea\u30f3\u30b0\nfor k in range(1, len(R)):\n    for i in range(N):\n        R[k][i] = R[k-1][R[k-1][i]]\n\n# \u306b\u3076\u305f\u3093\u3067\u30af\u30a8\u30ea\u306b\u7b54\u3048\u3066\u3044\u304f\nQ = int(input())\nfor q in range(Q):\n    a, b = list(map(int, input().split()))\n    a, b = min(a, b)-1, max(a, b)-1\n\n    ans = 0\n    for k in range(len(R))[::-1]:\n        if R[k][a] < b:\n            a = R[k][a]\n            ans += 2 ** k\n    print((ans + 1))\n", "from bisect import bisect\ninpl = lambda: list(map(int, input().split()))\n\nN = int(input())\nX = inpl()\nL = int(input())\nQ = int(input())\nR = [[0]*(N) for k in range(17)]\n\nfor i in range(N):\n    R[0][i] = bisect(X, X[i]+L) - 1\n\nfor k in range(16):\n    for i in range(N):\n        R[k+1][i] = R[k][R[k][i]]\n\n\ndef reach(a, d):\n    O = format(d, \"b\").zfill(17)[::-1]\n    for k in range(16, -1, -1):\n        if O[k] == \"1\":\n            a = R[k][a]\n    return a\n\n\ndef bisearch(a, b):\n    a, b = a-1, b-1\n    if b < a:\n        a, b = b, a\n    OK = b-a\n    NG = 0\n\n    while abs(OK - NG) > 1:\n        mid = (OK+NG)//2\n        if reach(a, mid) >= b:\n            OK = mid\n        else:\n            NG = mid\n    return OK\n\nprint(*[bisearch(*inpl()) for _ in range(Q)], sep=\"\\n\")", "3.6\nimport bisect\nn = int(input())\nx = [int(item) for item in input().split()]\nl = int(input())\nq = int(input())\nab = []\nfor i in range(q):\n    a, b = [int(item) for item in input().split()]\n    a -= 1; b -= 1\n    if a > b:\n        a, b = b, a\n    ab.append((a, b))\n\ndt = [[0] * n for _ in range(40)]\nfor i, item in enumerate(x):\n    dt[0][i] = i\n    dt[1][i] = bisect.bisect_right(x, item + l) - 1\n\nfor i in range(2, 40):\n    for j in range(n):\n        dt[i][j] = dt[i-1][dt[i-1][j]]\n\nfor a, b in ab:\n    days = 0\n    is_ok = False\n    while a < b:\n        for i in range(0, 40):\n            if dt[i][a] >= b:\n                if i == 1:\n                    days += 1\n                    is_ok = True\n                else:\n                    a = dt[i-1][a]\n                    days += 2**(i-2)\n                break\n        if is_ok:\n            break\n    print(days)", "import sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #\u7a7a\u767d\u3042\u308a\n\n\nN = I()\nx = LI()\nL = I()\n\nfrom bisect import bisect_right\n\narrive = [[0]*N for _ in range(30)]  # arrive[k][i] = i\u756a\u76ee(0-indexed)\u306e\u30db\u30c6\u30eb\u304b\u30892**k\u65e5\u3067\u5230\u9054\u3067\u304d\u308b\u6700\u3082\u9060\u3044\u30db\u30c6\u30eb\nfor k in range(30):\n    if k == 0:\n        for i in range(N):\n            arrive[0][i] = bisect_right(x,x[i]+L)-1\n    else:\n        for i in range(N):\n            arrive[k][i] = arrive[k-1][arrive[k-1][i]]\n\n\ndef query(a,b):  # (a-1)\u756a\u76ee\u306e\u30db\u30c6\u30eb\u304b\u3089(b-1)\u756a\u76ee\u306e\u99c5\u307e\u3067\u79fb\u52d5\u3059\u308b\u306e\u306b\u304b\u304b\u308b\u65e5\u6570\n    a -= 1\n    b -= 1\n    ans = 1\n    for k in range(29,-1,-1):\n        if arrive[k][a] >= b:\n            continue\n        else:\n            a = arrive[k][a]\n            ans += 1 << k\n    print(ans)\n\n\nQ = I()\nfor i in range(Q):\n    a,b = MI()\n    if a > b:\n        a,b = b,a\n    query(a,b)\n", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN = int(input())\nXs = list(mapint())\nL = int(input())\nfrom bisect import bisect_right\n\nnex = [[0]*N for _ in range(32)]\nfor i in range(N):\n    now = Xs[i]\n    idx = bisect_right(Xs, now+L)-1\n    nex[0][i] = idx\n\nfor i in range(1, 32):\n    for j in range(N):\n        nex[i][j] = nex[i-1][nex[i-1][j]]\n\nQ = int(input())\nfor _ in range(Q):\n    a, b = mapint()\n    if a>b:\n        a, b = b, a\n    a, b = a-1, b-1\n    cnt = 0\n    for i in range(31, -1, -1):\n        if nex[i][a]<b:\n            cnt += 2**i\n            a = nex[i][a]\n    if a!=b:\n        cnt += 1\n    print(cnt)", "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\nN = int(input())\nX = np.array(input().split(), dtype = np.int64)\nL = int(input())\n\nU = N.bit_length()\n# \u5404\u30db\u30c6\u30eb\u304b\u3089\u30012^n\u56de\u3067\u3069\u3053\u307e\u3067\u884c\u3051\u308b\u304b\nnext_x = []\nnext_x.append((np.searchsorted(X, X+L, side = 'right') - 1).tolist())\nfor i in range(U):\n    next_x.append([next_x[i][next_x[i][n]] for n in range(N)])\n\ndef days(a,b):\n    a -= 1\n    b -= 1\n    if b < a:\n        a,b = b,a\n    # \u5230\u7740\u3067\u304d\u306a\u3044\u7bc4\u56f2\u3067\u6700\u5927\u9650\u9032\u3080\n    result = 0\n    for n in range(U,-1,-1):\n        c = next_x[n][a]\n        if c < b:\n            a = c\n            result += 1 << n\n    return result + 1\n\nQ = int(input())\nfor _ in range(Q):\n    a,b = list(map(int,input().split()))\n    print((days(a,b)))\n", "from bisect import bisect_left, bisect_right\nN = int(input())\nx = list(map(int, input().split()))\nL = int(input())\nn = N.bit_length()+1\nnext_hotel = [[0]*n for _ in range(N)]\nfor i in range(N):\n    index = bisect_right(x, x[i]+L)-1\n    if index == i:\n        next_hotel[i][0] = N\n    else:\n        next_hotel[i][0] = index\nfor i in range(1, n):\n    for j in range(N):\n        if next_hotel[j][i-1]<N:\n            index = next_hotel[next_hotel[j][i-1]][i-1]\n            if index == j:\n                next_hotel[j][i] = N\n            else:\n                next_hotel[j][i] = index\n        else:\n            next_hotel[j][i] = N\ndef count(a, b):\n    if a>b:\n        a, b = b, a\n    res = 0\n    for i in range(n):\n        if a >= b:\n            return  res\n        c = max(0, bisect_left(next_hotel[a], b)-1)\n        a = next_hotel[a][c]\n        res+=2**c\nQ = int(input())\nfor _ in range(Q):\n    a, b = map(int, input().split())\n    print(count(a-1, b-1))", "import math\nimport bisect\n\ndef make_tree():\n    to = [0] * n\n    j = 0\n    for i in range(n):\n        while x[j + 1] - x[i] <= l:\n            j += 1\n        to[i] = j\n    return to\n\ndef binary_lifting():\n    m = int(math.log2(n)) + 3\n    to2 = [[n - 1] * m for _ in range(n)]\n    for i in range(n):\n        to2[i][0] = to[i]\n    for j in range(1, m):\n        for i in range(n):\n            to2[i][j] = to2[to2[i][j - 1]][j - 1]\n            if to2[i][j] == n - 1:\n                break\n    return to2\n\ndef solve(a, b):\n    if a > b:\n        a, b = b, a\n    ans = 0\n    while True:\n        i = bisect.bisect_left(to2[a], b)\n        if i == 0:\n            if not a == to2[a][0]:\n                ans += 1\n            break\n        a = to2[a][i - 1]\n        ans += pow2[i - 1]\n    return ans\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\ninf = 1145141919810\nm = int(math.log2(n)) + 3\nx.append(inf)\nto = make_tree()\nto2 = binary_lifting()\nq = int(input())\npow2 = [1] * m\nfor i in range(1, m):\n    pow2[i] = 2 * pow2[i - 1]\nfor _ in range(q):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    ans = solve(a, b)\n    print(ans)", "def inpl(): return [int(i) for i in input().split()]\ndef hmd(a, b):\n    ctr = -1\n    while H[ctr+1][a] < b:\n        ctr += 1\n    vn = H[ctr][a]\n    if (vn == b and ctr == 0) or ctr == -1:\n        return 1\n    return 2**ctr + hmd(vn,b)\nN = int(input())\nx = inpl() + [10**10]\nL = int(input())\nH = []\nG = [N-1]*N\nb = 0\nfor a in range(N):\n    while x[b+1] - x[a] <= L:\n        if b == N-1:\n            break\n        b += 1\n    G[a] = b\nH.append(G)\nwhile G[0] != N-1:\n    G = [G[i] for i in G]\n    H.append(G)\nH.append([10**10]*N)\nQ = int(input())\nfor _ in range(Q):\n    a, b = sorted(inpl())\n    print(hmd(a-1,b-1))", "from bisect import *\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\nq = int(input())\n\ndp_plus = [[0]*(n+1) for i in range(30)]\ndp_minus = [[0]*(n+1) for i in range(30)]\n\nfor i in range(n):\n    now = x[i]\n    reach = now + l\n    dp_plus[0][i+1] = bisect_right(x, reach)\n\nfor i in range(n):\n    now = x[i]\n    reach = now - l\n    dp_minus[0][i+1] = bisect_left(x, reach) + 1\n\n\n\nfor i in range(29):\n    for j in range(1, n+1):\n        dp_plus[i+1][j] = dp_plus[i][dp_plus[i][j]]\n        dp_minus[i+1][j] = dp_minus[i][dp_minus[i][j]]\n\n\nfor _ in range(q):\n    a, b = list(map(int, input().split()))\n    ans = 1\n    if a < b:\n        for i in range(29, -1, -1):\n            if dp_plus[i][a] < b:\n                a = dp_plus[i][a]\n                ans += pow(2, i)\n\n    else:\n        for i in range(29, -1, -1):\n            if dp_minus[i][a] > b:\n                a = dp_minus[i][a]\n                ans += pow(2, i)\n\n    print(ans)\n", "from bisect import bisect_right\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nx = list(map(int, input().split()))\nL = int(input())\nlog = 1\nwhile 1 << log < N:\n    log += 1\ndoubling = [[0] * (log + 1) for _ in range(N)]\nfor i in range(N):\n    j = bisect_right(x, x[i] + L) - 1\n    doubling[i][0] = j\nfor l in range(1, log + 1):\n    for i in range(N):\n        doubling[i][l] = doubling[doubling[i][l-1]][l-1]\nQ = int(input())\nfor _ in range(Q):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    if a > b:\n        a, b = b, a\n    ans = 0\n    for l in range(log, -1, -1):\n        if doubling[a][l] < b:\n            ans += 1 << l\n            a = doubling[a][l]\n    print((ans + 1))\n", "import bisect\n\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\nq = int(input())\ninfo = [list(map(int, input().split())) for i in range(q)]\n\n\n#log\u30c6\u30fc\u30d6\u30eb\u3092\u4f5c\u6210\u3059\u308b\nlog_table = [[0]*n for i in range(17)]\nfor i in range(n):\n    log_table[0][i] = bisect.bisect_right(x, x[i] + l) - 1\nfor j in range(1, 17):\n    for i in range(n):\n        log_table[j][i] = log_table[j-1][log_table[j-1][i]]\n\n#\u4e8c\u5206\u63a2\u7d22\u3067\u89e3\u3092\u6c42\u3081\u308b\ndef solve(_from, to, day):\n    pos = _from\n    i = 0\n    while day:\n        if day // 2 > 0:\n            if day % 2 == 1:\n                pos = log_table[i][pos]\n            i += 1\n            day = day // 2\n        else:\n            if day % 2 == 1:\n                pos = log_table[i][pos]\n            break\n    if to <= pos:\n        return True\n    else:\n        return False\n\n#\u30af\u30a8\u30ea\u306b\u7b54\u3048\u308b\nfor i in range(q):\n    ok = n - 1\n    ng = 0\n    start, goal = info[i]\n    start -= 1\n    goal -= 1\n    if start > goal:\n        start, goal = goal, start\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) // 2\n        if solve(start, goal, mid):\n            ok = mid\n        else:\n            ng = mid\n    print(ok)", "import bisect\n\ndef wantp(p,day):\n\n    for i in range(len(db)):\n        i = len(db)-1-i\n\n        if day & (2 ** i) > 0:\n            p = db[i][p]\n\n        #print (day,i)\n\n    return p\n\n\nN = int(input())\nx = list(map(int,input().split()))\nL = int(input())\n\nable = []\n\nfor i in range(N):\n\n    able.append(bisect.bisect_right(x,x[i] + L) - 1)\n\n\ndb = [able]\n\nwhile min(db[-1]) != N-1:\n\n    new = []\n\n    for i in range(N):\n\n        new.append(db[-1][db[-1][i]])\n\n    db.append(new)\n\n\nQ = int(input())\n\nfor loop in range(Q):\n\n    a,b = list(map(int,input().split()))\n    if a > b:\n        t = a\n        a = b\n        b = t\n    a -= 1\n    b -= 1\n\n    l = 0\n    r = 2 ** len(db)\n\n    while r-l != 1:\n\n        m = (l+r) // 2\n\n        np = wantp(a,m)\n        #print (a,m,np)\n\n        if np < b:\n            l = m\n        else:\n            r = m\n\n    print (r)\n", "from bisect import bisect_left, bisect_right\n\nN = int(input())\nxs = list(map(int, input().split()))\nL = int(input())\nQ = int(input())\nABs = [tuple([int(x)-1 for x in input().split()]) for _ in range(Q)]\n\nlogN = ((N-1).bit_length())\nparentss = [[N-1]*(logN+1) for _ in range(N)]\nfor i in range(N-1):\n    iL = bisect_right(xs, xs[i]+L)\n    parentss[i][0] = iL-1\n\nfor d in range(1, logN+1):\n    for i in range(N-1):\n        parentss[i][d] = parentss[parentss[i][d-1]][d-1]\n\nanss = []\nfor A, B in ABs:\n    if A > B:\n        A, B = B, A\n    i = A\n    ans = 1\n    for d in reversed(list(range(logN+1))):\n        if parentss[i][d] < B:\n            i = parentss[i][d]\n            ans += 2**d\n    anss.append(ans)\n\nprint(('\\n'.join(map(str, anss))))\n", "import math\nimport bisect\n\ndef make_tree():\n    to = [0] * n\n    j = 0\n    for i in range(n):\n        while x[j + 1] - x[i] <= l:\n            j += 1\n        to[i] = j\n    return to\n\ndef binary_lifting():\n    m = int(math.log2(n)) + 3\n    to2 = [[n - 1] * m for _ in range(n)]\n    for i in range(n):\n        to2[i][0] = to[i]\n    for j in range(1, m):\n        for i in range(n):\n            to2[i][j] = to2[to2[i][j - 1]][j - 1]\n            if to2[i][j] == n - 1:\n                break\n    return to2\n\ndef solve(a, b):\n    if a > b:\n        a, b = b, a\n    ans = 0\n    while True:\n        i = bisect.bisect_left(to2[a], b)\n        if i == 0:\n            if not a == to2[a][0]:\n                ans += 1\n            break\n        a = to2[a][i - 1]\n        ans += pow2[i - 1]\n    return ans\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\ninf = 1145141919810\nm = int(math.log2(n)) + 3\nx.append(inf)\nto = make_tree()\nto2 = binary_lifting()\nq = int(input())\npow2 = [1] * m\nfor i in range(1, m):\n    pow2[i] = 2 * pow2[i - 1]\nfor _ in range(q):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    ans = solve(a, b)\n    print(ans)", "def main():\n    n = int(input())\n    xs = [int(c) for c in input().split()]\n    l = int(input())\n\n    xs.append(10 ** 17)\n    nexts = list(range(n))\n    for fr in range(n):\n        p, q = fr, n\n        while q - p > 1:\n            m = (p + q) // 2\n            if xs[m] - xs[fr] <= l:\n                p = m\n            else:\n                q = m\n        nexts[fr] = p\n\n    doubling = [nexts]\n    for _ in range(20):\n        base = doubling[-1]\n        nexts = [base[base_next] for base_next in base]\n        doubling.append(nexts)\n\n    def query(fr, to):\n        if fr >= to:\n            return 0\n        p, q = 0, 20\n        while q - p > 1:\n            m = (p + q) // 2\n            if doubling[m][fr] >= to:\n                q = m\n            else:\n                p = m\n        return query(doubling[p][fr], to) + 2 ** p\n\n    q_count = int(input())\n    for _ in range(q_count):\n        a, b = map(int, input().split())\n        if a > b:\n            a, b = b, a\n        a -= 1\n        b -= 1\n\n        print(query(a, b))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from math import*\nfrom bisect import*\nn,*t=map(int,open(0).read().split())\nm=int(log2(n))+1\nx=t[:n]\nl=t[n]\nd=[[bisect(x,y+l)-1for y in x]]+[[0]*n for _ in range(m)]\nfor i in range(m):\n    for j in range(n):\n        d[i+1][j]=d[i][d[i][j]]\nfor a,b in zip(t[n+2::2],t[n+3::2]):\n    a-=1\n    b-=1\n    if b<a:a,b=b,a\n    c=1\n    for i in range(m,-1,-1):\n        if d[i][a]<b:\n            a=d[i][a]\n            c+=2**i\n    print(c)", "from collections import deque\nfrom bisect import bisect_right, bisect_left\n\nN = int(input())\nx = list(map(int, input().split()))\nL = int(input())\n\nK = 0\ntmp = 1\nwhile tmp <= N:\n    tmp *= 2\n    K += 1\n\nparent = [[None] * N for _ in range(K)]\nparent[0][N-1] = N-1\nfor i in range(N-1):\n    d = bisect_right(x, x[i] + L)\n    parent[0][i] = d-1\n\n# print(parent[0])\n#     print(depth)\n\nfor k in range(1, K):\n    for i in range(N):\n        parent[k][i] = parent[k - 1][parent[k - 1][i]]\n\n# print(parent)\n\nQ = int(input())\nfor _ in range(Q):\n    ans = 0\n    a, b = [int(x)-1 for x in input().split()]\n    if a > b:\n        a, b = b, a\n    # print(a, b)\n    for i in range(K - 1, -1, -1):\n        if parent[i][a] < b:\n            a = parent[i][a]\n            ans += pow(2, i)\n    print((ans+1))\n", "import sys,bisect\n\ninput=sys.stdin.readline\n\nN=int(input())\nx=list(map(int,input().split()))\nL=int(input())\n\ndoubling=[[-1 for i in range(N)] for j in range(20)]\nbackdoubling=[[-1 for i in range(N)] for j in range(20)]\n\nfor i in range(N):\n    npos=x[i]+L\n    index=bisect.bisect_right(x,npos)\n    doubling[0][i]=index-1\n\nfor i in range(1,20):\n    for j in range(N):\n        doubling[i][j]=doubling[i-1][doubling[i-1][j]]\n\nfor i in range(N):\n    npos=x[i]-L\n    index=bisect.bisect_left(x,npos)\n    backdoubling[0][i]=index\n\nfor i in range(1,20):\n    for j in range(N):\n        backdoubling[i][j]=backdoubling[i-1][backdoubling[i-1][j]]\n\ndef forward(num,start):\n    for i in range(20):\n        if num>>i &1==1:\n            start=doubling[i][start]\n    return start\n\ndef back(num,start):\n    for i in range(20):\n        if num>>i &1==1:\n            start=backdoubling[i][start]\n    return start\n\n\nfor _ in range(int(input())):\n    a,b=map(int,input().split())\n    a-=1;b-=1\n    if b>=a:\n        s=0\n        e=N\n        while e-s>1:\n            test=(e+s)//2\n            if forward(test,a)>=b:\n                e=test\n            else:\n                s=test\n        if forward(s,a)>=b:\n            print(s)\n        else:\n            print(e)\n    else:\n        s=0\n        e=N\n        while e-s>1:\n            test=(e+s)//2\n            if b>=back(test,a):\n                e=test\n            else:\n                s=test\n        if b>=back(s,a):\n            print(s)\n        else:\n            print(e)", "import bisect\nimport math\nN = int(input())\nx = list(map(int, input().split()))\nL = int(input())\n\nm = int(math.log(max(x), 2) + 1)\n#i\u756a\u76ee\u306e\u30db\u30c6\u30eb\u304b\u30892 ** k \u65e5\u4ee5\u5185\u306b\u5230\u9054\u53ef\u80fd\u306a\n#\u3082\u3063\u3068\u3082\u53f3\u306b\u3042\u308b\u30db\u30c6\u30eb\nr = [[-1] * N for k in range(m)]\nfor i in range(N):\n  base = x[i] + L\n  p = bisect.bisect_right(x, base)\n  #print(p)\n  r[0][i] = p - 1\n\n#\u30c0\u30d6\u30ea\u30f3\u30b0\nfor k in range(m - 1):\n  for i in range(N):\n    r[k + 1][i] = r[k][r[k][i]]\n#print(r)    \n   \ndef isOK(mid):\n  now = a\n  pp = int(math.log(mid, 2) + 1)\n  for i in range(pp):\n    if (mid >> i) & 1:\n      now = r[i][now]\n      #print(now, a + 1, b + 1, mid)\n  if now >= b:\n    return True\n  else:\n    return False\n  \nQ = int(input())\nfor i in range(Q):\n  a, b = list(map(int, input().split()))\n  a, b = a-1, b-1\n  if a > b:\n    a, b = b, a\n  ng = 0\n  ok = 2 ** m\n  while (abs(ok - ng) > 1):\n    mid = int((ok + ng) / 2)\n    #print(mid)\n    if isOK(mid):\n      ok = mid\n    else:\n      ng = mid\n  print(ok)\n         \n\n         \n         \n", "import bisect\nimport sys\ninput=sys.stdin.readline\n\ndef calc():\n  n=int(input())\n  arr=list(map(int,input().split()))\n  l=int(input())\n  pos=0\n  dbl=[[0]*(n+1)]\n  for i in range(n):\n      dbl[0][i+1]=bisect.bisect_right(arr,arr[i]+l)\n  for _ in range(n.bit_length()-1):\n    tmp=[0]*(n+1)\n    for i in range(n+1):\n      tmp[i]=dbl[-1][dbl[-1][i]]\n    dbl.append(tmp)\n  q=int(input())\n  for _ in range(q):\n    a,b=map(int,input().split())\n    if a>b:\n      a,b=b,a\n    l=0\n    r=b-a+1\n    while r-l!=1:\n      mid=(l+r)//2\n      tmp=a\n      for i in range(mid.bit_length()):\n        if mid&(1<<i):\n          tmp=dbl[i][tmp]\n      if tmp>=b:\n        r=mid\n      else:\n        l=mid\n    print(r)\ncalc()", "import sys\ninput = sys.stdin.readline\nimport bisect\n\ndef main():\n  n = int(input())\n  X = list(map(int, input().split()))\n  l = int(input())\n  U = 17\n  dp = [[0]*n for _ in range(U+1)]\n  for i, x in enumerate(X):\n    t = bisect.bisect_left(X, x+l)\n    dp[0][i] = bisect.bisect_right(X, x+l) - 1\n  for k in range(U):\n    for i in range(n):\n      dp[k+1][i] = dp[k][dp[k][i]]\n  q = int(input())\n  for _ in range(q):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    if a > b:\n      a, b = b, a\n    res = 1\n    for k in range(U, -1, -1):\n      if dp[k][a] < b:\n        a = dp[k][a]\n        res += (1<<k)\n    print(res)\ndef __starting_point():\n  main()\n__starting_point()", "from bisect import bisect_left\n\nINF=float('inf')\n\ndef check(a,b):\n    ng,ok=-1,N+1\n    while(ok-ng>1):\n        mid=(ng+ok)//2\n        now=a\n        bit=0\n        x=mid\n        while(x):\n            if x&1:\n                now=A[now][bit]\n            bit+=1\n            x>>=1\n        if b<=now:\n            ok=mid\n        else:\n            ng=mid\n    return ok\n            \n\n\nN=int(input())\nx=list(map(int,input().split()))\n\nK=N.bit_length()-1\n\nL=int(input())\n\nA=[[INF]*(K+1) for _ in range(N)]\n\nfor i in range(N):\n    b=bisect_left(x,x[i]+L+1)\n    A[i][0]=b-1\n\nfor k in range(K):\n    for i in range(N):\n        A[i][k+1]=A[A[i][k]][k]\n\nQ=int(input())\nfor _ in range(Q):\n    a,b=map(lambda x:int(x)-1,input().split())\n    if a>b:\n        a,b=b,a\n    print(check(a,b))", "import bisect\nimport os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN = int(sys.stdin.readline())\nX = list(map(int, sys.stdin.readline().split()))\nL = int(sys.stdin.readline())\nQ = int(sys.stdin.readline())\nAB = [list(map(int, sys.stdin.readline().split())) for _ in range(Q)]\n\nN += 2\nX = [X[0]] + X + [X[-1]]\nX = np.array(X, dtype=int)\n# dp[d][i]: i\u756a\u306e\u30db\u30c6\u30eb\u304b\u3089(2^d)\u65e5\u3067\u4f55\u500b\u53f3\u307e\u3067\u3044\u3051\u308b\u304b\ndp = np.zeros((N, N.bit_length() + 1), dtype=int)\ndp[:, 0] = np.searchsorted(X, X + L, side=\"right\") - 1\nfor d in range(1, N.bit_length() + 1):\n    dp[:, d] = dp[dp[:, d - 1], d - 1]\ndp = dp.tolist()\n\n\ndef solve(l, r):\n    ret = 0\n    while l + 1 < r:\n        d = max(0, bisect.bisect_left(dp[l], r) - 1)\n        ret += pow(2, d)\n        l = dp[l][d]\n    if l < r:\n        ret += 1\n    return ret\n\n\nans = []\nfor a, b in AB:\n    ans.append(solve(min(a, b), max(a, b)))\nprint(*ans, sep='\\n')\n", "n = int(input())\nx = list(map(int, input().split()))\nl = int(input())\nq = int(input())\nab=[list(map(int,input().split())) for i in range(q)]\n\nketa=len(format(n+1,\"b\"))\nnxt = [[0 for _ in range(n)] for _ in range(keta)]\n# nxt[k][node] == farthest node-num from node in 2**k days\n\nimport bisect\nfor i in range(n):\n    num = x[i]+l\n    ind = bisect.bisect_right(x,num)\n    nxt[0][i] = ind-1\n\nfor k in range(1,keta):\n    for i in range(n):\n        nxt[k][i]=nxt[k-1][nxt[k-1][i]]\n\ndef solve(s,g,day):\n    bi=format(day,\"b\")\n    keta=len(bi)-1\n\n    for b in bi:\n        if b==\"1\":\n            s=nxt[keta][s]\n        keta-=1\n\n    return s>=g\nfor a,b in ab:\n    s=min(a,b)\n    g=max(a,b)\n    l=0\n    r=n\n    while r-l>1:\n        mid=(l+r)//2\n        if solve(s-1,g-1,mid):\n            r=mid\n        else:\n            l=mid\n\n    print(r)", "import sys\nsys.setrecursionlimit(10**7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\nfrom functools import partial, reduce\nfrom operator import mul\nprod = partial(reduce, mul)\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\n\nfrom bisect import bisect\n\ndef main():\n    N = II()\n    X = LI()  # coordinate of hotels\n    X.append(INF)  # banpei\n    L = II()  # max move distance/day\n    Q = II()\n    AB = []  # two hotel (a,b)\n    for _ in range(Q):\n        AB.append(LI_())\n    Unreachs = [[] for _ in range(N)]\n    # 1day\n    for i, x in enumerate(X[:-1]):\n        u = bisect(X, x + L)\n        Unreachs[i].append(u)\n    # day 2, 4, 8, ...\n    updated = True\n    while updated:\n        updated = False\n        for i in range(N):\n            u = Unreachs[Unreachs[i][-1] - 1][-1]\n            updated = updated or (u != Unreachs[i][-1])\n            Unreachs[i].append(u)\n    # solve\n    for a, b in AB:\n        if a > b:\n            a, b = b, a\n        ans = 0\n        while True:\n            k = bisect(Unreachs[a], b) - 1\n            if k < 0:\n                ans += 1\n                break\n            ans += 2 ** k\n            a = Unreachs[a][k] - 1\n        print(ans)\n    return 0\n\nmain()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\nfrom bisect import bisect\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\n\ndepth = [-1]*n\ndepth[-1] = 0\n\nm = 20\npar = [[-1]*n for i in range(m)]\n\ndef dfs(i):\n    if depth[i] >= 0:\n        return depth[i]\n    j = bisect(x, x[i]+l)-1\n    if j == n:\n        j = n-1\n    par[0][i] = j\n    depth[i] = dfs(j) + 1\n    return depth[i]\n\nfor i in range(n):\n    dfs(i)\n\nfor i in range(m-1):\n    for j in range(n):\n        par[i+1][j]=par[i][par[i][j]]\n\ndef hoge(x, y):\n# x\u304b\u3089k\u500b\u4e0a\u306e\u9802\u70b9\u304cy\u4ee5\u4e0a\u306b\u306a\u308b\u6700\u5c0f\u306ek\u3092\u6c42\u3081\u308b\n    k = 0\n    for i in range(m)[::-1]:\n        if 0 <= par[i][x] < y:\n            k += 1<<i\n            x = par[i][x]\n    return k+1\n\nq = int(input())\nans = []\nfor i in range(q):\n    a,b = map(int, input().split())\n    a,b = a-1,b-1\n    if a > b:\n        a,b = b,a\n    ans.append(hoge(a, b))\n\nprint(*ans, sep=\"\\n\")", "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n = I()\n    x = LI()\n    f = [[] for i in range(n)]\n    l = I()\n    for i in range(n):\n        xi = x[i]\n        j = bisect.bisect_right(x,l+xi)-1\n        f[i].append(j)\n    h = int(math.log(n,2))+1\n    for j in range(h-1):\n        for i in range(n):\n            f[i].append(f[f[i][j]][j])\n    q = I()\n    for _ in range(q):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        if b < a:\n            a,b = b,a\n        ans = 0\n        for i in range(h)[::-1]:\n            if f[a][i] < b:\n                a = f[a][i]\n                ans += 1<<i\n        print((ans+1))\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()", "#!/usr/bin/env python3\nimport bisect\n\n\ndef dist(tree, tree_i, tree_j, parent, a, b):\n    i = tree_i[b]\n    if tree_i[a] == i:\n        return tree_j[b] - tree_j[a]\n    else:\n        branch = tree[i]\n        branch_root = branch[0]\n        if branch_root < a:\n            return tree_j[b] - bisect.bisect_left(branch, a) + 1\n        else:\n            p = parent[branch_root]\n            if p < a:\n                return tree_j[b] + 1\n            else:\n                return tree_j[b] + 1 + dist(tree, tree_i, tree_j, parent, a, p)\n\n\ndef solve(n, x, l, q, qry):\n\n    g = [[] for _ in range(n)]\n    parent = [-1] * n\n    weight = [1] * n\n\n    for v in range(1, n):\n        p = bisect.bisect_left(x, x[v] - l)\n        g[p].append(v)\n        parent[v] = p\n\n    for v in range(n - 1, -1, -1):\n        for w in g[v]:\n            weight[v] += weight[w]\n\n    tree = [[0]]\n    tree_i = [-1] * n\n    tree_j = [0] * n\n    tree_i[0] = 0\n    for v in range(n):\n        mw = 0\n        c = -1\n        for w in g[v]:\n            if mw < weight[w]:\n                mw = weight[w]\n                c = w\n        if 0 <= c:\n            i = tree_i[v]\n            tree[i].append(c)\n            tree_i[c] = i\n            tree_j[c] = len(tree[i]) - 1\n            for w in g[v]:\n                if w != c:\n                    tree.append([w])\n                    tree_i[w] = len(tree) - 1\n\n    for tpl in qry:\n        a, b = tpl\n        if b < a:\n            a, b = b, a\n        print((dist(tree, tree_i, tree_j, parent, a, b)))\n\n\ndef main():\n    n = input()\n    n = int(n)\n    x = list(map(int, input().split()))\n    l = input()\n    l = int(l)\n    q = input()\n    q = int(q)\n    qry = []\n    for _ in range(q):\n        a, b = input().split()\n        a = int(a) - 1\n        b = int(b) - 1\n        qry.append((a, b))\n\n    solve(n, x, l, q, qry)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nfrom bisect import bisect\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\n\nm = 20\npar = [[-1]*n for i in range(m)]\n\nfor i in range(n):\n    j = bisect(x, x[i]+l)-1\n    par[0][i] = j\n\nfor i in range(m-1):\n    for j in range(n):\n        par[i+1][j]=par[i][par[i][j]]\n\ndef hoge(x, y):\n    k = 0\n    for i in range(m)[::-1]:\n        if par[i][x] < y:\n            k += 1<<i\n            x = par[i][x]\n    return k+1\n\nq = int(input())\nans = []\nfor i in range(q):\n    a,b = map(int, input().split())\n    a,b = a-1,b-1\n    if a > b:\n        a,b = b,a\n    print(hoge(a,b))", "def inpl(): return [int(i) for i in input().split()]\ndef hmd(a, b):\n    ctr = -1\n    while H[ctr+1][a] < b:\n        ctr += 1\n    vn = H[ctr][a]\n    if (vn == b and ctr == 0) or ctr == -1:\n        return 1\n    return 2**ctr + hmd(vn,b)\nN = int(input())\nx = inpl() + [10**10]\nL = int(input())\nH = []\nG = [N-1]*N\nb = 0\nfor a in range(N):\n    while x[b+1] - x[a] <= L:\n        if b == N-1:\n            break\n        b += 1\n    G[a] = b\nH.append(G)\nwhile G[0] != N-1:\n    G = [G[i] for i in G]\n    H.append(G)\nH.append([10**10]*N)\nQ = int(input())\nfor _ in range(Q):\n    a, b = sorted(inpl())\n    print(hmd(a-1,b-1))", "import sys\ninput = sys.stdin.readline\nimport bisect\n\nn = int(input())\nX = list(map(int, input().split()))\nl = int(input())\nU = 17\ndp = [[0]*n for _ in range(U+1)]\nfor i, x in enumerate(X):\n  t = bisect.bisect_left(X, x+l)\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\nfor k in range(U):\n  for i in range(n):\n    dp[k+1][i] = dp[k][dp[k][i]]\ndef test(x, a, b):\n  for i in range(U, -1, -1):\n    if x >> i & 1:\n      a = dp[i][a]\n  return a >= b\ndef solve(a, b):\n  if a > b:\n    a, b = b, a\n  ng = 0\n  ok = n-1\n  while ok - ng > 1:\n    mid = (ng + ok) // 2\n    if test(mid, a, b):\n      ok = mid\n    else:\n      ng = mid\n  print(ok)\nq = int(input())\nfor _ in range(q):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  solve(a, b)", "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\n\nN = int(input())\nxx = inpl()\nL = int(input())\n\nK = N.bit_length()\ndb_r = [[0]*K for i in range(N)]\nfor i,x in enumerate(xx):\n    ind = bisect.bisect_right(xx,x+L)\n    db_r[i][0] = ind-1\n\nfor k in range(1,K):\n    for i in range(N):\n        db_r[i][k] = db_r[db_r[i][k-1]][k-1]\n\ndef check(a,b,d):\n    L = d.bit_length()\n    for k in range(L):\n        if d & (1<<k):\n            a = db_r[a][k]\n    return a >= b\n\nQ = int(input())\nfor i in range(Q):\n    a,b = inpl()\n    a -= 1\n    b -= 1\n    a,b = min(a,b),max(a,b)\n    OK = N\n    NG = 0\n    while OK-NG>1:\n        mid = (OK+NG)//2\n        if check(a,b,mid): OK = mid\n        else: NG = mid\n    print(OK)\n", "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\n\n#A\ndef A():\n    return\n\n#B\ndef B():\n    return\n\n#C\ndef C():\n    n = I()\n    x = LI()\n    l = I()\n    k = int(math.log(n,2))\n    f = [[i for j in range(k+1)] for i in range(n)]\n    for i in range(n-1):\n        j = bisect.bisect_left(x,x[i]+l)\n        if j < n:\n            if x[j] > x[i]+l:\n                f[i][0] = j-1\n            else:\n                f[i][0] = j\n        else:\n            f[i][0] = j-1\n    po2 = [1]*(k+1)\n    for i in range(k):\n        po2[i+1] = po2[i]*2\n    for j in range(k):\n        for i in range(n):\n            f[i][j+1] = f[f[i][j]][j]\n    q = I()\n    for i in range(q):\n        a,b = LI()\n        a,b = [min(a,b)-1, max(a,b)-1]\n        ans = 0\n        while a < b:\n            i = bisect.bisect_left(f[a],b)\n            ans += po2[max(0,i-1)]\n            a = f[a][max(0,i-1)]\n        print(ans)\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\ndef __starting_point():\n    C()\n\n__starting_point()", "from math import*\nfrom bisect import*\nr=range\nn,*t=map(int,open(0).read().split())\nm=int(log(n,2)+1)\nx=t[:n]\nd=[[bisect(x,y+t[n])-1for y in x]]+[[0]*n for _ in r(m)]\nfor i in r(m):\n  for j in r(n):\n    d[i+1][j]=d[i][d[i][j]]\nfor a in zip(t[n+2::2],t[n+3::2]):\n  a,b=sorted(i-1for i in a)\n  c=1\n  for i in r(m,-1,-1):\n    if d[i][a]<b:\n      a=d[i][a]\n      c+=2**i\n  print(c)", "from bisect import bisect\nimport sys\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\nq = int(input())\n\n#r[i][j]: j\u304b\u3089(2**i)\u65e5\u3067\u884c\u3051\u308b\u53f3\u7aef\nr = [[i for i in range(n)] for _ in range(18)]\nfor j in range(n):\n\tr[0][j] = bisect(x, x[j]+l) - 1\nfor i in range(1, 18):\n\tfor j in range(n):\n\t\tr[i][j] = r[i-1][r[i-1][j]]\n\ndef search(x, y):\n\tres = 0\n\tcur = x\n\ti = 17\n\twhile True:\n\t\tif i == 0 and r[i][cur] >= y:\n\t\t\treturn res+1\n\t\tif r[i][cur] < y:\n\t\t\tcur = r[i][cur]\n\t\t\tres += 1 << i\n\t\t\tcontinue\n\t\ti -= 1\n\nfor _ in range(q):\n\ta, b = map(int, sys.stdin.readline().strip().split())\n\tprint(search(min(a, b)-1, max(a, b)-1))", "from bisect import*\nr=range\nn,*t=map(int,open(0).read().split())\nx=t[:n]\nd=[[bisect(x,y+t[n])-1for y in x]]+[[0]*n for _ in r(16)]\nfor i in r(16):\n  for j in r(n):\n    d[i+1][j]=d[i][d[i][j]]\nfor a in zip(t[n+2::2],t[n+3::2]):\n  a,b=sorted(i-1for i in a)\n  c=1\n  for i in r(16,-1,-1):\n    if d[i][a]<b:\n      a=d[i][a]\n      c+=2**i\n  print(c)", "N = int(input())\nX = list(map(int, input().split()))\nL = int(input())\nQ = int(input())\n\nV = [0]*N\nib = 0\nfor i in range(N):\n    while X[i]-X[ib] > L:\n        V[ib] = i-1\n        ib += 1\nwhile ib!=N-1:\n    V[ib]=N-1\n    ib += 1\ndbl = [[0]*N for i in range(18)]\ndbl[0]=V\nfor i in range(1, 18):\n    for j in range(N):\n        ii = dbl[i-1][j]\n        if ii == 0:\n            break\n        dbl[i][j] = dbl[i-1][ii]\nfor i in range(Q):\n    a, b = list(map(int, input().split()))\n    a, b = sorted([a, b])\n    a-=1\n    b-=1\n    ind = a\n    ans = 0\n    for j in range(17, -1, -1):\n        if dbl[j][ind]==0:\n            continue\n        if dbl[j][ind]>b:\n            continue\n        if dbl[j][ind]==b:\n            ans |= 1<<j\n            break\n        else:\n            ans |= 1<<j\n            ind = dbl[j][ind]\n    else:\n        ans += 1\n    print(ans)\n", "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn, = list(map(int,readline().split()))\n*x, = list(map(int,readline().split()))\nl,q,*ab = list(map(int,read().split()))\n\n\nfrom bisect import bisect_left, bisect_right\n\nM = 19\n\"\"\"\nL = [[bisect_left(x,i-l) for i in x]]\nfor i in range(M):\n    LL = [L[-1][L[-1][i]] for i in range(n)]\n    L.append(LL)\n\n\"\"\"\nR = [[bisect_right(x,i+l)-1 for i in x]]\nfor i in range(M):\n    RR = [R[-1][R[-1][i]] for i in range(n)]\n    R.append(RR)\n\n#for i in R: print(i)\n\nmp = iter(ab)\nfor a,b in zip(mp,mp):\n    a -= 1\n    b -= 1\n    if a > b: a,b = b,a\n    \n    ans = 0\n    for i in range(M,-1,-1):\n        if R[i][a] < b:\n            ans += 1<<i\n            a = R[i][a]\n    print((ans+1))\n    \n    \n    \n    \n\n\n", "from bisect import bisect\nN = int(input())\nxs = list(map(int,input().split()))\nL = int(input())\nQ = int(input())\nqs = [tuple(map(lambda x:int(x)-1, input().split())) for i in range(Q)]\n\nK = len(bin(N)) - 1\ndp = [[None]*N for i in range(K)]\nfor i,x in enumerate(xs):\n    dp[0][i] = bisect(xs, x+L) - 1\nfor k in range(K-1):\n    for i in range(N):\n        dp[k+1][i] = dp[k][dp[k][i]]\n\ndef enough(fr,to,n):\n    now = fr\n    bn = bin(n)\n    ln = len(bn)-2\n    for i,c in enumerate(bn[2:]):\n        if c=='0': continue\n        now = dp[ln-1-i][now]\n        if now >= to:\n            return True\n    return False\n\nans = []\nfor a,b in qs:\n    if a>b: a,b = b,a\n    ok = N\n    ng = 0\n    while ok-ng > 1:\n        m = (ok+ng)//2\n        if enough(a,b,m):\n            ok = m\n        else:\n            ng = m\n    ans.append(ok)\n\nprint(*ans,sep='\\n')", "def reachN(i0, n):\n    if n == 0:\n        return i0\n    maxbit = ceil(log2(n))\n    kL = []\n    for i in range(maxbit+1):\n        if n>>i & 1:\n            kL.append(i)\n    #print(kL)\n    i = i0\n    for k in kL[::-1]:\n        if start < goal:\n            i = dp[k][i]      #; print('norm', i)\n        else:\n            i = dpInv[k][i]   #; print('inv', i)\n    return i   \n\ndef fun(n):\n    if start < goal:\n        return reachN(start, n) >= goal\n    else:\n        return reachN(start, n) <= goal\n\n#def reach(x, L):\n #   return bisect.bisect_left(xL, x+L)\n\ndef binMin(l, r):\n    if r-l == 1:\n        return r\n    m = (l+r) // 2\n    if fun(m):\n        r = m\n    else:\n        l = m\n    return binMin(l, r)\n\nimport bisect\nfrom math import log2, ceil\n\nN = int(input())\nxL = [-float('inf')] + [int(i) for i in input().split()]   #; print(xL)\nLmax = int(input())\n\nkmax = ceil(log2(len(xL)-2))                               #; print(kmax)\ndp = [[len(xL)-1]*(N+1) for _ in range(kmax+1)]\nfor i in range(1, N+1):\n    dp[0][i] = bisect.bisect_right(xL, xL[i]+Lmax) - 1\n#print2(dp)\nfor k in range(1, kmax+1):\n    for i in range(1, N):\n        dp[k][i] = dp[k-1][dp[k-1][i]]\n#print2(dp); print()\n\ndpInv = [[1]*(N+1) for _ in range(kmax+1)]\nfor i in range(N, 1, -1):\n    dpInv[0][i] = bisect.bisect_left(xL, xL[i]-Lmax)\nfor k in range(1, kmax+1):\n    for i in range(N, 1, -1):\n        dpInv[k][i] = dpInv[k-1][dpInv[k-1][i]]\n#print2(dpInv)\n\nQ = int(input())\nfor _ in range(Q):\n    start, goal = list(map(int, input().split()))\n    ans = binMin(0, abs(goal-start))\n    print(ans)\n", "from heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom itertools import permutations,combinations,groupby\nimport sys\nimport bisect\nimport string\nimport math\nimport time\nimport random\ndef S_():\n    return input()\ndef LS():\n    return [i for i in input().split()]\ndef I():\n    return int(input())\ndef MI():\n    return map(int,input().split())\ndef LI():\n    return [int(i) for i in input().split()]\ndef LI_():\n    return [int(i)-1 for i in input().split()]\ndef NI(n):\n    return [int(input()) for i in range(n)]\ndef NI_(n):\n    return [int(input())-1 for i in range(n)]\ndef StoI():\n    return [ord(i)-97 for i in input()]\ndef ItoS(nn):\n    return chr(nn+97)\ndef LtoS(ls):\n    return ''.join([chr(i+97) for i in ls])\ndef GI(V,E,Directed=False,index=0):\n    org_inp=[]\n    g=[[] for i in range(n)]\n    for i in range(E):\n        inp=LI()\n        org_inp.append(inp)\n        if index==0:\n            inp[0]-=1\n            inp[1]-=1\n        if len(inp)==2:\n            a,b=inp\n            g[a].append(b)\n            if not Directed:\n                g[b].append(a)\n        elif len(inp)==3:\n            a,b,c=inp\n            aa=(inp[0],inp[2])\n            bb=(inp[1],inp[2])\n            g[a].append(bb)\n            if not Directed:\n                g[b].append(aa)\n    return g,org_inp\ndef bit_combination(k,n=2):\n    rt=[]\n    for tb in range(n**k):\n        s=[tb//(n**bt)%n for bt in range(k)]\n        rt+=[s]\n    return rt\ndef show(*inp,end='\\n'):\n    if show_flg:\n        print(*inp,end=end)\nYN=['Yes','No']\nmo=10**9+7\ninf=float('inf')\nl_alp=string.ascii_lowercase\nu_alp=string.ascii_uppercase\nts=time.time()\n#sys.setrecursionlimit(10**5)\ninput=lambda: sys.stdin.readline().rstrip()\n\ndef ran_input():\n    import random\n    n=random.randint(4,16)\n    rmin,rmax=1,10\n    a=[random.randint(rmin,rmax) for _ in range(n)]\n    return n,a\n\nshow_flg=False\nshow_flg=True\n\nans=0\n\nn=I()\nm=n.bit_length()\nx=LI()\nL=I()\nq=I()\n\nr=[0]*n\n\n\nfor i in range(n):\n    r[i]=bisect.bisect(x,x[i]+L)-1\n    \nnb=[r]\nnx=[0]*n\n\nfor k in range(m):\n    nx=[0]*n\n    for i in range(n):\n        nx[i]=r[r[i]]\n    nb.append(nx)\n    r=nx\n\nfor _ in range(q):\n    a,b=LI_()\n    if a>b:\n        a,b=b,a\n    \n    t=0\n    for p in range(m,-1,-1):\n        if nb[p][a]<b:\n            t+=1<<p\n            a=nb[p][a]\n    \n    print(t+1)\n", "import math\nfrom bisect import bisect_left, bisect_right\n\nN = int(input())\nX = list(map(int, input().split()))\nL = int(input())\nQ = int(input())\nY = [list(map(int, input().split())) for _ in range(Q)]\n\nLOGN = int(math.log(N) / math.log(2)) + 1\nparent = [[-1] * N for _ in range(LOGN + 1)]\n\n# Update for k\nfor k in range(LOGN + 1):\n    for i in range(N):\n        if k == 0:\n            parent[k][i] = bisect_right(X, X[i] + L) - 1\n        else:\n            parent[k][i] = parent[k - 1][parent[k - 1][i]]\n\ndef find(a, b):\n    num = 0\n    u = a\n    while True:\n        k = 0\n        for i in range(LOGN + 1):\n            if parent[i][u] >= b:\n                k = i\n                break\n                \n        if k == 0:\n            num += 1\n            break\n        num += pow(2, k - 1)\n        u = parent[k - 1][u]\n        \n    return num\n\nfor a, b in Y:\n    a -= 1\n    b -= 1\n    if a > b:\n        a, b = b, a\n    print((find(a, b)))\n", "n = int(input())\nhot = list(map(int,input().split())) \nn_ = n.bit_length()\ndb = [[n-1]*(n)]\nL = int(input())\nr = 1\nfor i in range(n-1):\n  while r < n-1 and hot[r+1]-hot[i] <= L:\n    r += 1\n  db[0][i] = r\nfor j in range(1,n_+1):\n  new = [db[-1][db[-1][i]] for i in range(n)]\n  db.append(new)\n  if new[0] == n-1:\n    break\nn_ = len(db)\n\ndef query(s,t):\n  dt = 0\n  for j in range(n_-1,0,-1):\n    if db[j][s] < t:\n      dt += 2**j\n      s = db[j][s]\n  while s < t:\n    dt += 1\n    s = db[0][s]\n  return dt \n\nq = int(input())\nfor _ in range(q):\n  s,t = list(map(int,input().split()))\n  if t < s:\n    s,t = t,s\n  print((query(s-1,t-1)))\n", "from bisect import bisect\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\nq = int(input())\n\n#r[i][j]: j\u304b\u3089(2**i)\u65e5\u3067\u884c\u3051\u308b\u53f3\u7aef\nr = [[i for i in range(n)] for _ in range(18)]\nfor j in range(n):\n\tr[0][j] = bisect(x, x[j]+l) - 1\nfor i in range(1, 18):\n\tfor j in range(n):\n\t\tr[i][j] = r[i-1][r[i-1][j]]\n\ndef search(x, y):\n\tres = 0\n\tcur = x\n\ti = 17\n\twhile True:\n\t\tif i == 0 and r[i][cur] >= y:\n\t\t\treturn res+1\n\t\tif r[i][cur] < y:\n\t\t\tcur = r[i][cur]\n\t\t\tres += 1 << i\n\t\t\tcontinue\n\t\ti -= 1\n\nfor _ in range(q):\n\ta, b = map(int, input().split())\n\tprint(search(min(a, b)-1, max(a, b)-1))", "import sys\nfrom bisect import bisect\n\nn = int(input())\nxxx = list(map(int, input().split()))\nl = int(input())\n\nreachable = [[bisect(xxx, x + l) - 1 for x in xxx]]\nwhile reachable[-1][0] < n - 1:\n    rp = reachable[-1]\n    reachable.append(list(map(rp.__getitem__, rp)))\n\nq = int(input())\nbuf = []\nfor line in sys.stdin:\n    a, b = list(map(int, line.split()))\n    a -= 1\n    b -= 1\n    if a > b:\n        a, b = b, a\n    ans = 0\n    for i in range(len(reachable) - 1, -1, -1):\n        ria = reachable[i][a]\n        if ria >= b:\n            continue\n        ans += 1 << i\n        a = ria\n    if a != b:\n        ans += 1\n    buf.append(ans)\n\nprint(('\\n'.join(map(str, buf))))\n", "from bisect import *\n\nclass Doubling:\n    def __init__(self, A, K_max, decrement=True):\n        \"\"\"\n        :param A: \u5199\u50cf A:i->j \u3092\u5b9a\u7fa9\n        :param K_max: K_max = 2**(k_max) \u307e\u3067\u53c2\u7167\u3059\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\n        :param decrement: True = A \u306e\u8981\u7d20\u306e decrement \u304c\u5fc5\u8981\n        \"\"\"\n        self.k_max = K_max.bit_length()\n        self.n = len(A)\n        self.decrement = decrement\n        self.doubling = [[-1] * self.n for _ in range(self.k_max)]\n        for i, a in enumerate(A):\n            self.doubling[0][i] = a - self.decrement\n\n        for i in range(1, self.k_max):\n            for k in range(self.n):\n                if self.doubling[i - 1][k] != -1:\n                    self.doubling[i][k] = self.doubling[i - 1][self.doubling[i - 1][k]]\n\n    def apply(self, start, K):\n        \"\"\"\n        :param start: \u30b9\u30bf\u30fc\u30c8\u5730\u70b9\n        :param K: K\u56de\u9032\u3080\n        :return:\n        \"\"\"\n        i = start - self.decrement\n        for k in range(K.bit_length()):\n            m = 1 << k\n            if m & K:\n                i = self.doubling[k][i]\n            if i is None:\n                break\n        return i + self.decrement\n\ndef binary_search_int(ok, ng, test,a,b):\n    \"\"\"\n    :param ok: solve(x) = True \u3092\u5fc5\u305a\u6e80\u305f\u3059\u70b9\n    :param ng: solve(x) = False \u3092\u5fc5\u305a\u6e80\u305f\u3059\u70b9\n    \"\"\"\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) // 2\n        if test(mid,a,b):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\n######################################################################################\nimport sys\ninput = sys.stdin.readline\n\nN=int(input())\nX=list(map(int, input().split()))\nL=int(input())\nQ=int(input())\n\nA=[]\nfor x in X:\n    i=bisect_left(X,x+1+L)\n    A.append(i-1)\ndoubling = Doubling(A, N+1, decrement=False)\n\ndef test(x,a,b):\n    return X[doubling.apply(a,x)]<X[b]\n\nfor _ in range(Q):\n    a,b=map(int, input().split())\n    a,b=a-1,b-1\n    if a>b: a,b=b,a\n    print(binary_search_int(0,N,test,a,b)+1)", "import sys\ninput = sys.stdin.readline\nfrom bisect import bisect\nN=int(input())\nX=[int(i) for i in input().split()]\nL=int(input())\nQ=int(input())\n#T=[[int(i) for i in input().split()] for i in range(Q)]\nT=[]\nfor i in range(Q):\n    a,b=list(map(int,input().split()))\n    if a>b:\n        a,b=b,a\n    T.append((a-1,b-1))\nF=[0]*N\nfor i in range(N):\n    F[i]= bisect(X, X[i] + L) -1\n#print(F)\ndp=[ [N-1] * (N) for i in range(18)]\n\nfor i in range(N):\n    #dp[0][i]=i\n    dp[0][i]=F[i]\nfor c in range(1,18):\n    for i in range(N):\n        dp[c][i] = dp[c-1][ dp[c-1][i] ]\n#print(dp)\n\ndef f(a,b):\n    num=0\n    t = a\n    while True:\n        for i in range(18):\n            if dp[i][t]>=b:\n                s=i\n                break\n        if s==0:\n            num+=1\n            break\n        num += pow(2, s - 1)\n        t = dp[s-1][t]\n    print(num)\nfor a,b in T:\n    f(a,b)\n\n", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\nq = int(input())\nps = [None]*n\n# ps2 = [None]*n\nj = 0\nfor i in range(n):\n    if j<i:\n        j = i\n    while j+1<n and x[j+1]-x[i]<=l:\n        j += 1\n    ps[i] = j\n# \u30c0\u30d6\u30ea\u30f3\u30b0\ndef double(ps):\n    # global: n=ps\u306e\u30b5\u30a4\u30ba\n    k = 0\n    n = len(ps)\n    while pow(2,k)<n:\n        k += 1\n    prev = [[None]*n for _ in range(k)] # \u30ce\u30fc\u30c9j\u304b\u30892^i\u500b\u4e0a\u306e\u4e0a\u53f8\n    for j in range(n):\n        prev[0][j] = ps[j]\n    for i in range(1,k):\n        for j in range(n):\n            p = prev[i-1][j]\n            if p>=0:\n                prev[i][j] = prev[i-1][p]\n            else:\n                prev[i][j] = p\n    return prev\ndl = double(ps)\nans = [None]*q\nfor i in range(q):\n    a,b = map(lambda x: int(x)-1, input().split())\n    a,b = min(a,b), max(a,b)\n#     print(a,b)\n    res = 0\n    tmp = float(\"inf\")\n    for k in range(len(dl)-1, -1, -1):\n        if dl[k][a]<b:\n            a = dl[k][a]\n            res += pow(2,k)\n#         elif dl[k][a]==b:\n#             tmp = res+pow(2,k)\n#             break\n        else:\n            tmp = min(tmp, res+pow(2,k))\n    ans[i] = tmp\nwrite(\"\\n\".join(map(str, ans)))", "N = int(input())\nxs = list(map(int, input().split()))\nL = int(input())\n\nparent = [-1] * N\nright = 0\nfor left in range(N):\n    while right < N and xs[right] - xs[left] <= L:\n        right += 1\n    parent[left] = right - 1\n\nancestor = [parent]\nfor _ in range(N.bit_length() + 2):\n    tmp = [ancestor[-1][anc] for anc in ancestor[-1]]\n    ancestor.append(tmp)\n\nQ = int(input())\nanswers = []\nfor _ in range(Q):\n    a, b = map(int, input().split())\n    a -= 1; b -= 1\n    if a == b:\n        answers.append(0)\n        continue\n    if a > b:\n        a, b = b, a\n    ans = 0\n    for k in range(len(ancestor) - 1, -1, -1):\n        if ancestor[k][a] < b:\n            ans += 1 << k\n            a = ancestor[k][a]\n    ans += 1\n    answers.append(ans)\n        \nprint(*answers, sep='\\n')", "from bisect import bisect\nN=int(input())\nX=[int(x) for x in input().split()]\nL=int(input())\ninf=float(\"inf\")\nX.append(X[-1]+L)\nTable=[[inf]*18 for i in range(N)]\nr=1\nfor i in range(N):\n  if r<=N:\n    while X[r]-X[i]<=L:\n      r+=1\n      if r>N:\n        break\n  Table[i][0]=r-1\nfor k in range(1,18):\n  for i in range(N):\n    if Table[i][k-1]==N:\n      Table[i][k]=N\n      continue\n    Table[i][k]=Table[Table[i][k-1]][k-1]\n\nQ=int(input())\nfor q in range(Q):\n  a,b=list(map(int,input().split()))\n  a-=1\n  b-=1\n  ans=0\n  if a>b:\n    a,b=b,a\n  while a<b:\n    i=bisect(Table[a],b)-1\n    if i>=0:\n      ans+=2**i\n    else:\n      ans+=1\n    a=Table[a][i]\n  \n  print(ans)\n", "from bisect import bisect_left, bisect_right\nimport math\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    X = list(map(int, input().split()))\n    L = int(input())\n    ln = int(math.log(N, 2))\n    dpl = [[0] * N for _ in range(ln+1)]\n    dpr = [[0] * N for _ in range(ln+1)]\n    l = 0\n    r = 0\n    for i in range(N):\n        x = X[i]\n        while X[l] + L < x:\n            l += 1\n        while r < N-1 and x + L >= X[r+1]:\n            r += 1\n        dpl[0][i] = l\n        dpr[0][i] = r\n    for k in range(1, ln+1):\n        for i in range(N):\n            dpl[k][i] = dpl[k-1][dpl[k-1][i]]\n            dpr[k][i] = dpr[k-1][dpr[k-1][i]]\n    Q = int(input())\n    for _ in range(Q):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        ans = 0\n        if a < b:\n            for k in range(ln+1)[::-1]:\n                if dpr[k][a] < b:\n                    a = dpr[k][a]\n                    ans += 2**k\n        else:\n            # a > b\n            for k in range(ln+1)[::-1]:\n                if dpl[k][a] > b:\n                    a = dpl[k][a]\n                    ans += 2**k\n        print((ans+1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nN = int(input())\nX = [int(a) for a in input().split()]\nL = int(input())\nNE = []\nj = 0\nfor i, x in enumerate(X):\n    while j < N - 1 and X[j+1] <= x + L:\n        j += 1\n    NE.append(j)\nD = [NE[:]]\nfor _ in range(16):\n    d = D[-1]\n    nd = [d[dd] for dd in d]\n    D.append(nd)\n\nQ = int(input())\nfor _ in range(Q):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    if a > b: a, b = b, a\n    re = 0\n    s = a\n    for i in range(17)[::-1]:\n        d = D[i]\n        if d[s] < b:\n            s = d[s]\n            re += 1 << i\n    print(re + 1)", "from bisect import bisect\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\nq = int(input())\n\n#r[i][j]: j\u304b\u3089(2**i)\u65e5\u3067\u884c\u3051\u308b\u53f3\u7aef\nr = [[i for i in range(n)] for _ in range(18)]\nfor j in range(n):\n\tr[0][j] = bisect(x, x[j]+l) - 1\nfor i in range(1, 18):\n\tfor j in range(n):\n\t\tr[i][j] = r[i-1][r[i-1][j]]\n\ndef search(x, y):\n\tres = 0\n\tcur = x\n\twhile True:\n\t\tfor i in range(18):\n\t\t\tif r[i][cur] >= y:\n\t\t\t\tif i == 0:\n\t\t\t\t\treturn res+1\n\t\t\t\tcur = r[i-1][cur]\n\t\t\t\tres += 1 << (i-1) \n\t\t\t\tbreak\n\nfor _ in range(q):\n\ta, b = map(int, input().split())\n\tprint(search(min(a, b)-1, max(a, b)-1))", "import sys,queue,math,copy,itertools,bisect,collections,heapq\n\ndef main():\n    LI = lambda : [int(x) for x in sys.stdin.readline().split()]\n    _LI = lambda : [int(x)-1 for x in sys.stdin.readline().split()]\n    NI = lambda : int(sys.stdin.readline())\n\n    N = NI()\n    x = LI()\n    L = NI()\n    m = N.bit_length()\n    f = [[N-1] * N for _ in range(m)]\n    j = 0\n    for i in range(N-1):\n        while x[i] + L >= x[j+1]:\n            j += 1\n            if j >= N-1: break\n        else:\n            f[0][i] = j\n            continue\n        break\n    for k in range(1,m):\n        for i in range(N):\n            f[k][i] = f[k-1][f[k-1][i]]\n\n    for _ in range(NI()):\n        ans = 0\n        a,b = _LI()\n        if a > b: a,b = b,a\n\n        for k in range(m-1,-1,-1):\n            if f[k][a] < b:\n                a = f[k][a]\n                ans += 2**k\n        print(ans+1)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nN = int(input())\na = list(map(int, input().split()))\nL = int(input())\nk = 1\nwhile a[-1] // (L * pow(2, k)): k += 1\ne = [[0] * k for _ in range(N)]\nfor i in range(N):\n  t = L + a[i]\n  ok = i\n  ng = N\n  while ng - ok > 1:\n    m = (ok + ng) // 2\n    if a[m] <= t: ok = m\n    else: ng = m\n  e[i][0] = ok\nfor j in range(len(e[i]) - 1):\n  for i in range(N):\n    x = e[i][j]\n    e[i][j + 1] = e[x][j]\n#print(e)\n\ndef doubling(u, v):\n  if u == v: return 0\n  ok = -1\n  ng = len(e[u])\n  while ng - ok > 1:\n    m = (ok + ng) // 2\n    if e[u][m] < v: ok = m\n    else: ng = m\n  if ok < 0: return 1\n  return doubling(e[u][ok], v) + pow(2, ok)\n\nQ = int(input())\nfor _ in range(Q):\n  x, y = list(map(int, input().split()))\n  x -= 1\n  y -= 1\n  if x > y: x, y = y, x\n  print((doubling(x, y)))\n", "import sys\ninput = sys.stdin.readline\nimport bisect\n\nn = int(input())\nX = list(map(int, input().split()))\nl = int(input())\nU = 17\ndp = [[0]*n for _ in range(U+1)]\nfor i, x in enumerate(X):\n  t = bisect.bisect_left(X, x+l)\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\nfor k in range(U):\n  for i in range(n):\n    dp[k+1][i] = dp[k][dp[k][i]]\nq = int(input())\nfor _ in range(q):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  if a > b:\n    a, b = b, a\n  res = 1\n  for k in range(U, -1, -1):\n    if dp[k][a] < b:\n      a = dp[k][a]\n      res += (1<<k)\n    if a == b:\n      break\n  print(res)", "from bisect import bisect\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\nq = int(input())\n\n#r[i][j]: j\u304b\u3089(2**i)\u65e5\u3067\u884c\u3051\u308b\u53f3\u7aef\nr = [[i for i in range(n)] for _ in range(18)]\nfor j in range(n):\n\tr[0][j] = bisect(x, x[j]+l) - 1\nfor i in range(1, 18):\n\tfor j in range(n):\n\t\tr[i][j] = r[i-1][r[i-1][j]]\n\ndef search(x, y):\n\tres = 0\n\tcur = x\n\twhile True:\n\t\tfor i in range(18):\n\t\t\tif r[i][cur] >= y:\n\t\t\t\tif i == 0:\n\t\t\t\t\treturn res+1\n\t\t\t\tcur = r[i-1][cur]\n\t\t\t\tres += 1 << (i-1) \n\t\t\t\tbreak\n\nfor _ in range(q):\n\ta, b = map(int, input().split())\n\tprint(search(min(a, b)-1, max(a, b)-1))", "from bisect import bisect\n\nn = int(input())\nx = list(map(int, input().split()))\nl = int(input())\nq = int(input())\n\n#r[i][j]: j\u304b\u3089(2**i)\u65e5\u3067\u884c\u3051\u308b\u53f3\u7aef\nr = [[i for i in range(n)] for _ in range(18)]\nfor j in range(n):\n\tr[0][j] = bisect(x, x[j]+l) - 1\nfor i in range(1, 18):\n\tfor j in range(n):\n\t\tr[i][j] = r[i-1][r[i-1][j]]\n\ndef search(x, y):\n\tres = 0\n\tcur = x\n\ti = 17\n\twhile True:\n\t\tif i == 0 and r[i][cur] >= y:\n\t\t\treturn res+1\n\t\tif r[i][cur] < y:\n\t\t\tcur = r[i][cur]\n\t\t\tres += 1 << i\n\t\t\tcontinue\n\t\ti -= 1\n\nfor _ in range(q):\n\ta, b = map(int, input().split())\n\tprint(search(min(a, b)-1, max(a, b)-1))", "import sys,bisect\n\ninput=sys.stdin.readline\n\nN=int(input())\nx=list(map(int,input().split()))\nL=int(input())\n\ndoubling=[[-1 for i in range(N)] for j in range(20)]\n\nfor i in range(N):\n    npos=x[i]+L\n    index=bisect.bisect_right(x,npos)\n    doubling[0][i]=index-1\n\nfor i in range(1,20):\n    for j in range(N):\n        doubling[i][j]=doubling[i-1][doubling[i-1][j]]\n\nforward=[[-1 for i in range(N)] for j in range(20)]\n\nfor i in range(N):\n    forward[0][i]=i\n\nfor i in range(1,20):\n    for j in range(N):\n        forward[i][j]=doubling[i-1][forward[i-1][j]]\n\nfor _ in range(int(input())):\n    a,b=map(int,input().split())\n    a-=1;b-=1\n    if a>b:\n        a,b=b,a\n    res=0\n    for i in range(19,-1,-1):\n        if b>forward[i][a]:\n            a=doubling[i][a]\n            res+=2**i\n    print(res)"]
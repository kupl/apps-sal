["class Solution:\n    def longestAwesome(self, s: str) -> int:\n        cum = [0]\n        firsts = {0: -1}\n        lasts = {0: -1}\n        for i, c in enumerate(s):\n            cum.append(cum[-1] ^ (1 << (ord(c) - 48)))\n            if cum[-1] not in firsts:\n                firsts[cum[-1]] = i\n            lasts[cum[-1]] = i\n        mx = 1\n        for k in firsts:\n            mx = max(mx, lasts[k] - firsts[k])\n            for off in range(10):\n                o = k ^ (1 << off)\n                if o in firsts:\n                    mx = max(mx, lasts[o] - firsts[k])\n        return mx", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        #since transp. generate symm. grp., just need pair counts\n        mask = 0\n        prefix, suffix = {0 : -1}, {0 : -1}\n        digcodes = [2**i for i in range(10)]+[0]\n        \n        for i in range(len(s)):\n            ch = s[i]\n            mask ^= 2**int(ch)\n            if mask not in prefix:\n                prefix[mask] = i\n            suffix[mask] = i\n        \n        return max([ind - prefix[val ^ dig] for val,ind in list(suffix.items()) \n                    for dig in digcodes if val ^ dig in prefix])\n        \n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        d = {}\n        d[0] = -1\n        sm, res = 0, 0\n        for i,c in enumerate(s):\n            sm ^= 1 << int(c)\n            if sm in d:\n                res = max(res, i - d[sm])\n            else:\n                d[sm] = i\n            for j in range(10):\n                msk = sm ^ (1 << j)\n                if msk in d and i - d[msk] > res:\n                    res = i - d[msk]\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        n=len(s)\n        \n        a=0\n        ans=0\n        dp={0:-1}\n        \n        for i in range(n):\n            a=a^(1<<(int(s[i])))\n            \n            if a in dp:\n                ans=max(ans,i-dp[a])\n            else:\n                dp[a]=i\n                \n            for j in range(11):\n                x=(a^(1<<j))\n                if x in dp:\n                    ans=max(ans,i-dp[x])\n                \n            #print(a,dp,i,ans)\n        \n        return ans\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        known_positions = {0: -1}\n\n        mask = 0\n        max_size = 0\n\n        for idx, current in enumerate(s):\n            mask ^= 1 << (ord(current) - ord('0'))\n\n            for modified in range(10):\n                tmp_mask = mask ^ (1 << modified)\n                size = idx - known_positions.get(tmp_mask, idx)\n\n                if size % 2:\n                    max_size = max(max_size, size)\n\n            max_size = max(max_size, idx - known_positions.get(mask, idx))    \n            known_positions.setdefault(mask, idx)\n\n        return max(max_size, 1)", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo = {0: -1}\n        best = 0\n        bitmap = 0\n        for i, digit in enumerate(s):\n            bitmap ^= 1 << int(digit)\n\n            best = max(best, i - memo.get(bitmap, i))\n            \n            for j in range(10):\n                key = bitmap ^ (1 << j)\n                best = max(best, i - memo.get(key, i))\n            memo[bitmap] = memo.get(bitmap, i)\n\n        return best", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mask, res = 0, 0\n        dp = [-1] + [len(s)] * 1023\n        for i in range(len(s)):\n            mask ^= 1 << (ord(s[i]) - 48)\n            for j in range(11):\n                check_mask = 1023 & (mask ^ (1 << j))\n                res = max(res, i - dp[check_mask])\n            dp[mask] = min(dp[mask], i)\n        return res    ", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        pos = {0 : -1}\n        bitmask = 0\n        ans = 0\n        n = len(s)\n        for i in range(n):\n            bitmask ^= (1 << int(s[i]))\n            for j in range(10):\n                if bitmask ^ (1 << j) in pos:\n                    ans = max(ans, i - pos[bitmask ^ (1 << j)])\n            if bitmask in pos:\n                ans = max(ans, i - pos[bitmask])\n            else:\n                pos[bitmask] = i\n            \n        return ans", "class Solution:\n    def linear(self, s):\n        ans = 0\n        d = {0:-1}\n        mask = 0\n        for i, c in enumerate(s):\n            mask = (1<<int(c)) ^ mask\n            \n            if mask in d:\n                ans = max(ans, i - d[mask])\n            \n            for j in range(10):\n                s = mask ^ (1<<j)\n                if s in d:\n                    ans = max(ans, i - d[s])\n            \n            if mask not in d:\n                d[mask] = i\n        return ans\n    \n    \n        \n        \n    def longestAwesome(self, s: str) -> int:\n        return self.linear(s)\n    \n        ans = 0\n        for i in range(len(s)):\n            d = collections.defaultdict(int)\n            odds = set()\n            for j in range(i, len(s)):\n                d[s[j]]+=1\n                if d[s[j]]%2:\n                    odds.add(s[j])\n                else:\n                    if s[j] in odds:\n                        odds.remove(s[j])\n                \n                if len(odds)<=1:\n                    ans = max(ans, j-i+1)\n        return ans\n    \n    \n    \n    \n    \n    \n    \n    \n                \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        pos = {}\n        open_chars = 0\n        pos[open_chars] = 0\n        max_len = 0\n        for i, c in enumerate(s):\n            open_chars ^= 1 << int(c)\n            for j in range(-1, 10):\n                if j == -1:\n                    mask = 0\n                else:\n                    mask = 1 << j\n                if open_chars ^ mask in pos:\n                    max_len = max(max_len, i+1 - pos[open_chars ^ mask])\n            \n            if open_chars not in pos:\n                pos[open_chars] = i+1\n        return max_len\n                \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        a = [0 for _ in range(n)]\n        for i in range(n):\n            x = a[i-1] if i > 0 else 0\n            a[i] = x ^ (1 << int(s[i]))\n        \n        dp = 1\n        ht = {}\n        ht[a[0]] = 0\n        \n        for i in range(1, n):\n            d = 1\n            if a[i] == 0:\n                d = i+1\n            else:\n                if a[i] in ht:\n                    d = max(d, i-ht[a[i]])\n                for j in range(10):\n                    x = a[i] ^ (1 << j)\n                    if x == 0:\n                        d = i+1\n                        break\n                    if x in ht:\n                        d = max(d, i-ht[x])\n\n            dp = max(dp, d)\n            if not a[i] in ht:\n                ht[a[i]] = i\n        \n        return dp\n        \n            \n        \n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        index = [-1] + [len(s)]*1023\n        ans = 0\n        bit = 0\n        for idx, c in enumerate(s):\n            bit ^= 1 << ord(c)-ord('0')\n            # if bit in index:\n            #     ans = max(ans, idx-index[candidate])\n            # else:\n            #     index[bit]=idx\n            # for i in range(10):\n            #     candidate = bit^(1<<i)\n            #     if candidate in index:\n            #         ans = max(ans, idx-index[candidate])\n            ans = max([ans, idx-index[bit]]+[idx-index[bit^(1<<j)] for j in range(10)])\n            index[bit] = min(index[bit], idx)\n        return ans", "class Solution1:\n    def longestAwesome(self, s: str) -> int:\n        mem = {} \n        def find_awesome(lo, hi, digit_count):\n            if lo > hi:\n                return 0\n            if (lo, hi) in mem:\n                return mem[(lo, hi)]\n                    \n            if digit_count & (digit_count - 1) == 0:\n                return hi - lo + 1\n            \n            max_len = max(find_awesome(lo + 1, hi, digit_count^((1 << int(s[lo])))),\n                       find_awesome(lo, hi - 1, digit_count^((1 << int(s[hi])))))\n            mem[(lo, hi)] = max_len\n            return max_len\n        \n        lo, hi, digit_count = 0, len(s) - 1, 0\n        for i in range(lo, hi + 1):\n            digit_count ^= (1 << int(s[i]))\n        return find_awesome(lo, hi, digit_count)\n    \nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo, state = {}, 0\n        memo[state], ans = -1, 0\n        for i, c in enumerate(s):            \n            state ^= 1 << int(c)                        \n            if state not in memo:\n                memo[state] = i\n            else:\n                ans = max(ans, i - memo[state])                            \n            for j in range(10):\n                state1 = state ^ (1 << j)                                 \n                if state1 in memo:\n                    ans = max(ans, i - memo[state1])\n        return ans", "#bd = binary dict\n#soen = sum of each number\nclass Solution:\n    \n    def longestAwesome(self, s: str) -> int:\n        # generate list of existing binaries\n        bd = {}\n        bd[0] = -1 # remember when searching start from index -1\n        #soen = [0 for i in range(10)]\n        soen = 0\n        \n        for i,n in enumerate(s): # first loop\n            #binary operation\n            soen ^= 1<<int(n)\n            bd[soen] = -1\n        \n            # update dictionary with the latest index that can form awesome string\n            bd[soen] = i\n            for j in range(10):\n                soen_cpy = soen\n                soen_cpy ^=1<<j\n                if soen_cpy in bd:\n                    bd[soen_cpy] = i \n        \n        soen = 0\n        max_ = bd[0]+1\n        for i,n in enumerate(s):\n            soen ^= 1<<int(n)\n            cur_max = bd[soen] - i\n            if cur_max>max_:\n                max_ = cur_max\n        return max_\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        idx = [-1] + [len(s)] * 1023\n        ans, mask = 0, 0\n        for i, c in enumerate(s):\n            update = ord(c) - ord('0')\n            mask ^= 1 << update\n            ans = max(ans, i - idx[mask])\n            for j in range(10):\n                ans = ans = max(ans, i - idx[mask ^ (1 << j)])\n            idx[mask] = min(idx[mask], i)\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        # alex wice solution\n        P = [0]\n        for c in s:\n            x= int(c)\n            P.append(P[-1])\n            P[-1]^= 1<<x\n            \n            \n        dict = {}\n        valid = {1<<x for x in range(10)}\n        valid.add(0)\n        ans = 0\n        \n        for j,q in enumerate(P):\n            for target in valid:\n                i = dict.get(q^target,None)\n                if i is not None:\n                    ans = max(ans,j-i)\n                    \n                dict.setdefault(q,j)\n                \n        return(ans)", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        d = {}\n        d[0] = -1\n        mask = 0\n        ans = 0\n        for i, ch in enumerate(s):\n            mask ^= 1<<int(ch)\n            if mask in d and (i-d[mask])%2 == 0:\n                ans = max(ans, i-d[mask])\n            for j in range(10):\n                mask_edit = mask^(1<<j)\n                if mask_edit in d and (i-d[mask_edit])%2 == 1:\n                    ans = max(ans, i-d[mask_edit])\n            if mask not in d:\n                d[mask] = i\n        return ans", "class Solution:\n\\tdef longestAwesome(self, s: str) -> int:\n\\t\\tseen = {0: -1}\n\\t\\tcurrent_xor = 0\n\\t\\tanswer = 1\n\\t\\tn = len(s)\n\\t\\txor_list = {0: 1, 1: 2, 2: 4, 3: 8, 4: 16, 5: 32, 6: 64, 7: 128, 8: 256, 9: 512}\n\\t\\tfor i in range(n):\n\\t\\t\\tcurrent_xor ^= xor_list[int(s[i])]\n\\t\\t\\tif current_xor not in seen:\n\\t\\t\\t\\tseen[current_xor] = i\n\\t\\t\\telse:\n\\t\\t\\t\\tanswer = max(answer, i - seen[current_xor])\n\\t\\t\\tfor j in range(10):\n\\t\\t\\t\\tnew_xor = current_xor ^ xor_list[j]\n\\t\\t\\t\\tif new_xor in seen:\n\\t\\t\\t\\t\\tanswer = max(answer, i - seen[new_xor])\n\\t\\treturn answer", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        tmp = 0\n        pos_map = {0: -1}\n        ans = 1\n        for i in range(len(s)):\n            tmp ^= (1 << int(s[i]))\n            if tmp in pos_map:\n                ans = max(ans, i - pos_map[tmp])\n            for x in range(10):\n                another_tmp = tmp ^ (1 << x)\n                if another_tmp in pos_map:\n                    ans = max(ans, i - pos_map[another_tmp])\n            if tmp not in pos_map:\n                pos_map[tmp] = i\n        return ans        ", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo, state = {}, 0\n        memo[state], ans = -1, 0\n        for i, c in enumerate(s):            \n            state ^= 1 << int(c)                        \n            if state not in memo: memo[state] = i\n            else: ans = max(ans, i - memo[state])                            \n            for n in range(10):\n                state1 = state ^ (1 << n)                                 \n                if state1 in memo: ans = max(ans, i - memo[state1])\n        return ans  ", "class Solution:\n    def longestAwesome(self, s):\n        res, cur, n = 0, 0, len(s)\n        seen = [-1] + [n] * 1024\n        for i, c in enumerate(s):\n            cur ^= 1 << int(c)\n            for a in range(10):\n                res = max(res, i - seen[cur ^ (1 << a)])\n            res = max(res, i - seen[cur])\n            seen[cur] = min(seen[cur], i)\n        return res", "\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        p = [0]\n        for c in s:\n            x = int(c)\n            p.append(p[-1])\n            p[-1] ^= 1 << x\n\n        first = {}\n        valid = {1 << x for x in range(10)}\n        valid.add(0)\n\n        res = 0\n        for j, pj in enumerate(p):\n            for target in valid:\n                i = first.get(pj ^ target, None)\n                if i is not None:\n                    res = max(res, j - i)\n            first.setdefault(pj, j)\n        return res\n    \n", "class Solution:\n    def longestAwesome(self, s):\n            res, cur, n = 0, 0, len(s)\n            seen = [-1] + [n] * 1024\n            for i, c in enumerate(s):\n                cur ^= 1 << int(c)\n                for a in range(10):\n                    res = max(res, i - seen[cur ^ (1 << a)])\n                res = max(res, i - seen[cur])\n                seen[cur] = min(seen[cur], i)\n            return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        d = {0: -1}\n        b = 0\n        m = 0\n        for i, c in enumerate(s):\n            b ^= 1 << int(c)\n            if not b or not(b & b-1):\n                m = max(m, i-d.get(b, i-1), i+1)\n                if not b:\n                    h = 1\n                    for _ in range(10):\n                        m = max(m, i-d.get(h, i-1))\n                        h <<= 1\n            else:\n                m = max(m, i-d.get(b, i-1))\n                h = 1\n                for _ in range(10):\n                    if h & b:\n                        m = max(m, i-d.get((~h) & b, i-1))\n                    else:\n                        m = max(m, i-d.get(h + b, i-1))\n                    h <<= 1\n            if b not in d:\n                d[b] = i\n        return m", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        prev = [-1] + [len(s)] * 1024\n        best = 1\n        mask = 0\n        for i in range(len(s)):\n            mask ^= 1 << int(s[i])\n            # print(i, bin(mask))\n\n            for j in range(10):\n                tmp = mask ^ (1 << j)\n                if best < i - prev[tmp] + 1:\n                    # print('- ' + bin(tmp), i, prev[tmp])\n                    best = max(best, i - prev[tmp])\n                # best = max(best, i - prev[tmp])\n\n            best = max(best, i - prev[mask])\n            prev[mask] = min(prev[mask], i)\n        return best\n                    \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        res, cur, n = 0, 0, len(s)\n        seen = [-1] + [n] * 1024\n        for i, c in enumerate(s):\n            cur ^= 1 << int(c)\n\n            for a in range(10):\n                res = max(res, i - seen[cur ^ (1 << a)])\n            res = max(res, i - seen[cur])\n            seen[cur] = min(seen[cur], i)\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        d = {0: -1}\n        m = b = 0\n        for i, c in enumerate(s):\n            b ^= 1 << int(c)\n            m = max(m, i-d.get(b, i-1))\n            h = 1\n            for _ in range(10):\n                m = max(m, i-d.get((~h) & b if h & b else h + b, i-1))\n                h <<= 1\n            d.setdefault(b, i)\n        return m", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        \n        def getMatchingMasks(mask):\n            st = set([mask])\n            \n            for i in range(10):\n                st.add(mask ^ (1 << i))\n            \n            return st\n        \n        mask = 0\n        \n        maskDict = dict()\n        \n        maskDict[0] = -1\n        \n        ans = 0\n        for idx, ch in enumerate(s):\n            digitVal = int(ch)\n            \n            mask ^= (1 << digitVal)\n            \n            for match in getMatchingMasks(mask):\n                if match in maskDict:\n                    ans = max(ans, idx - maskDict[match])\n            \n            if mask not in maskDict:\n                # only record the first position\n                maskDict[mask] = idx\n        \n        return ans", "class Solution:\n    def linear(self, s):\n        ans = 0\n        d = {0:-1}\n        mask = 0\n        for i, c in enumerate(s):\n            mask = (1<<int(c)) ^ mask\n            \n            if mask in d:\n                ans = max(ans, i - d[mask])\n            \n            for j in range(10):\n                s = mask ^ (1<<j)\n                if s in d:\n                    ans = max(ans, i - d[s])\n            \n            if mask not in d:\n                d[mask] = i\n        return ans\n    \n    \n        \n        \n    def longestAwesome(self, s: str) -> int:\n        return self.linear(s)\n    \n        ans = 0\n        for i in range(len(s)):\n            d = collections.defaultdict(int)\n            odds = set()\n            for j in range(i, len(s)):\n                d[s[j]]+=1\n                if d[s[j]]%2:\n                    odds.add(s[j])\n                else:\n                    if s[j] in odds:\n                        odds.remove(s[j])\n                \n                if len(odds)<=1:\n                    ans = max(ans, j-i+1)\n        return ans\n    \n    \n    \n    \n    \n    \n    \n                \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        '''\n        \\\"3242415\\\"\n        \n          9876543210\n        0:0000000000    #ith digit is odd\n        1:0000001000\n        2:0000001100\n        3:0000011100\n        4:0000011000\n        5:0000001000\n        6:0000001010\n        7:0000101010\n        \n        \n        2: need 0000001100, 0000001101, 0000001110, ...\n            add 0000001100\n        '''\n        digit_cnt = [0 for _ in range(len(s)+1)]\n        for i in range(1,len(s)+1):\n            digit_cnt[i] = digit_cnt[i-1] ^ (1<<int(s[i-1]))\n        # print(digit_cnt)\n        \n        res = 1\n        indx = {}\n        indx[0] = 0\n        for i in range(1, len(digit_cnt)):\n            if digit_cnt[i] == 0: \n                res = max(res, i)\n                continue\n            for d in range(10):\n                if digit_cnt[i] ^ (1<<d) in list(indx.keys()):\n                    res = max(res, i-indx[digit_cnt[i] ^ (1<<d)])\n            if not digit_cnt[i] in list(indx.keys()):\n                indx[digit_cnt[i]] = i\n        # print(indx)\n        return res\n        \n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        d = {0: -1}\n        b = 0\n        m = 0\n        for i, c in enumerate(s):\n            b ^= 1 << int(c)\n            m = max(m, i-d.get(b, i-1))\n            h = 1\n            for _ in range(10):\n                if h & b:\n                    m = max(m, i-d.get((~h) & b, i-1))\n                else:\n                    m = max(m, i-d.get(h + b, i-1))\n                h <<= 1\n            if b not in d:\n                d[b] = i\n        return m", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        # n = len(s)\n        # length = n\n        # while length > 1:\n        #     # exam medium\n        #     start = 0\n        #     end = start + length\n        #     check = 0\n        #     while end <= n:\n        #         sub_s = s[start:end]\n        #         tmp = {}\n        #         for char in sub_s:\n        #             if char not in tmp:\n        #                 tmp[char] = 1\n        #             else:\n        #                 tmp[char] += 1 \n        #         value = [a for a in list(tmp.values()) if a%2==1]\n        #         if len(value) <= 1:\n        #             check = 1\n        #             break\n        #         start += 1\n        #         end += 1\n        #     if check == 1:\n        #         return length\n        #     else:\n        #         length -= 1\n        # return 1\n        n = len(s)\n        ans = 0\n        record = {}\n        record[0] = -1\n        bit = 0\n        for i in range(n):\n            bit = bit ^ (2**int(s[i]))\n            if bit in record:\n                ans = max(ans,i-record[bit])\n            else:\n                record[bit] = i\n            for j in range(10):\n                new_bit = bit ^ (2**j)\n                if new_bit in record:\n                    ans = max(ans,i-record[new_bit])\n        return ans\n        \n#         n = len(s)\n#         ans, mask = 0, 0\n        \n#         memo = [n] * 1024\n#         memo[0] = -1\n        \n#         for i in range(n):\n#             mask ^= 2**int(s[i])\n\\t\\t\\t\n# \\t\\t\\t# Case 1. Check if we have seen similar mask\n#             ans = max(ans, i - memo[mask])\n            \n# \\t\\t\\t# Case 2. Check for masks that differ by one bit\n#             for j in range(10):\n#                 test_mask = mask ^ (2**j)\n#                 ans = max(ans, i - memo[test_mask])\n                \n# \\t\\t\\t# save the earliest position\n#             memo[mask] = min(memo[mask], i)    \n        \n#         return ans\n        ", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mask, res = 0, 0\n        dp = [-1] + [len(s)] * 1023\n        for i in range(len(s)):\n            mask ^= 1 << (ord(s[i]) - 48)\n            for j in range(11):\n                check_mask = 1023 & (mask ^ (1 << j))\n                res = max(res, i - dp[check_mask])\n            dp[mask] = min(dp[mask], i)\n        return res", "class Solution:\n  \n  def __init__(self):\n    self.seen = {0: -1}\n    self.len = 0\n\n  def update_best_length(self, num, p):\n    if num in self.seen:\n      self.len = max(self.len, p - self.seen[num])\n\n    for i in range(10):\n      x = num ^ (1 << int(i))\n      if x in self.seen:\n        self.len = max(self.len, p - self.seen[x])\n\n  def longestAwesome(self, s: str) -> int:\n    num = 0\n    for p, c in enumerate(s):\n      num = num ^ (1 << int(c))\n      self.update_best_length(num, p)\n      if num not in self.seen:\n        self.seen[num] = p\n    \n    return self.len", "import numpy as np\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo, state = {}, 0\n        p = np.arange(15).reshape(3, 5)\n        memo[state], ans = -1, 0\n        for i, c in enumerate(s):            \n            state ^= 1 << int(c)                        \n            if state not in memo: memo[state] = i\n            else: ans = max(ans, i - memo[state])                            \n            for n in range(10):\n                state1 = state ^ (1 << n)                                 \n                if state1 in memo: ans = max(ans, i - memo[state1])\n        return ans  ", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        pattern = [1 << i for i in range(10)]\n        \n        seen, state = {}, 0\n        seen[state] = -1\n        \n        answer = 0\n        for i, c in enumerate(s):\n            state ^= 1 << int(c)\n            if state in seen:\n                answer = max(answer, i - seen[state])\n            for p in pattern:\n                target = state ^ p\n                if target in seen:\n                    answer = max(answer, i - seen[target])\n            \n            if state not in seen:\n                seen[state] = i\n        \n        return answer", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        s = [ord(x) - ord('0') for x in s]\n        ans = 0\n        m = [None] * 1024\n        m[0] = -1\n        y = 0\n        for i, x in enumerate(s):\n            y ^= 1 << x\n            for j in range(11):\n                p = y ^ ((1 << j) & 1023)\n                if m[p] != None:\n                    ans = max(ans, i - m[p])\n            if m[p] == None:\n                m[y] = i\n        return ans", "def find(dp, mask):\n    # d = {0:-1}\n    d = {}\n    ans = 0\n    for i in range(0, len(dp)):\n        x, y = dp[i], dp[i] ^ mask\n        if y in d:\n            ans = max(ans, i - d[y])\n        if x not in d:\n            d[x] = i\n    return ans\n            \nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        val = 0\n        dp = [0]\n        for ch in s:\n            val ^= 1 << (ord(ch) - ord('0'))\n            dp.append(val)\n        print(dp)\n        ans = find(dp, 0)\n        for i in range(0, 10):\n            ans = max(ans, find(dp, 1 << i))\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        subsum = [0]\n        rtn = 0\n        first_appear = {}\n        first_appear[0] = 0\n        for i, x in enumerate(s):\n            subsum.append(subsum[i]^(1<<int(x)))\n            if subsum[i+1] not in first_appear:\n                first_appear[subsum[i+1]] = i+1\n            else:\n                rtn = max(rtn, i+1-first_appear[subsum[i+1]])\n            for j in range(10):\n                if (subsum[i+1]^(1<<j)) in first_appear:\n                    rtn = max(rtn, i+1-first_appear[(subsum[i+1]^(1<<j))])\n        return rtn", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        res = 0\n        count = 0\n        record = {count:-1}\n        for i,ss in enumerate(s):\n            count ^= 1<<int(ss)\n            if count not in record:\n                record[count] = i\n            res = max(res, max((i - record[count^(1<<(t+1)>>1)]) if count^(1<<(t+1)>>1) in record else 0 for t in range(-1,10)))\n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        m = collections.defaultdict(lambda:0)\n        \n        def convertToKey():\n            x = 0\n            for i in range(10):\n                x += ((m[i]%2)<<i)\n            return x\n        presum = {}\n        presum[0] = -1\n        res = 0 \n        for i,j in enumerate(s):\n            m[int(j)]+=1\n            key = convertToKey()\n            #print(\\\"{0:b}\\\".format(key),j)\n            if key in presum:\n                \n                res = max(res,i-presum[key])\n            \n            for x in range(10):\n                newKey = key;\n                if (key>>x)&1:\n                    newKey -= (1<<x)\n                    # if key==10:\n                    #     print(\\\"print\\\",\\\"{0:b}\\\".format(newKey),x)\n                else:\n                    newKey |=(1<<x)\n                    # if key==10:\n                    #     print(\\\"print\\\",\\\"{0:b}\\\".format(newKey),x)\n                # if 8 in presum:        \n                #     print(\\\"res\\\", presum[8])\n                if newKey in presum:\n                    \n                    res = max(res,i-presum[newKey]) \n            if key not in presum:\n                # print(\\\"put\\\",key,i)\n                presum[key] = i\n            \n        return res\n            \n            \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        \n        \n        targets = {1 << x for x in range(10)}\n        targets.add(0)\n        \n        print(targets)\n        diction = {}\n        res = 0\n        prev = 0\n        diction[0] = -1\n        for idx, char in enumerate(s):\n            curr = prev ^ 1<<int(char)\n            if curr not in diction:\n                diction[curr] = idx\n                \n            for target in targets:\n                if curr ^ target in diction:\n                    res = max(res, idx - diction[curr ^ target])\n                    \n            prev = curr\n        print(diction)\n        print(res)\n        return res\n                    \n", "class Solution:\n    \\\"\\\"\\\"max/min substring: prefixu sum => O(n)\n    https://zxi.mytechroad.com/blog/hashtable/leetcode-1542-find-longest-awesome-substring/\n    \n    1371. find-the-longest-substring-containing-vowels-in-even-counts\n    1542. find-longest-awesome-substring\n    \\\"\\\"\\\"\n    \n    def longestAwesome(self, s: str) -> int:\n        res = mask = 0\n        pre = [-1] + [len(s)] * 1024\n        for i, ch in enumerate(s):\n            mask ^= 1 << int(ch)\n            for digit in range(10):\n                res = max(res, i - pre[mask], i - pre[mask ^ (1 << digit)])\n            pre[mask] = min(pre[mask], i)\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo, state = {}, 0\n        memo[0], ans = -1, 0\n        for i, c in enumerate(s):            \n            state ^= 1 << int(c)                        \n            if state not in memo: memo[state] = i\n            else: ans = max(ans, i - memo[state])                            \n            for n in range(10):\n                state1 = state ^ (1 << n)                                 \n                if state1 in memo: ans = max(ans, i - memo[state1])\n        return ans                ", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        pos = {}\n        \n        def f(c):\n            return ord(c) - ord('0')\n        \n        mask, ans = 0, 1\n        pos[0] = -1\n        \n        for n, ch in enumerate(s):\n            p = f(ch)\n            mask ^= (1 << p)\n            # print(\\\"{0:b}\\\".format(mask), mask)\n            # even check\n            if mask in pos:\n                len = n - pos[mask]\n                if len % 2 == 0:\n                    ans = max(ans, len)\n            \n            # odd check\n            for nn in range(10):\n                nmask = mask ^ (1 << nn)\n                if nmask in pos:\n                    len = n - pos[nmask]\n                    if len % 2 == 1:\n                        ans = max(ans, len)\n            \n            if mask not in pos:\n                pos[mask] = n\n        \n        return ans", "class Solution:\n  def longestAwesome(self, s: str) -> int:\n    \n    first_pos = [ -1 for i in range(1024) ]\n    first_pos[0] = 0\n\n    cur_xor = 0\n    xors = [0] + [1<<i for i in range(10)]\n    \n    max_len = 0\n    for i in range(len(s)):\n      cur_xor = cur_xor ^ (1<<int(s[i]))\n#      print(i, s[i], bin(cur_xor), end=\\\" \\\")\n      for try_xor in xors:\n#        print(try_xor, end = \\\" \\\")\n        prev_xor = cur_xor ^ try_xor\n        if first_pos[prev_xor] != -1:\n#          print(bin(prev_xor), first_pos[prev_xor], end=\\\"|\\\")\n          max_len = max(max_len, i - first_pos[prev_xor] + 1)\n      \n      if first_pos[cur_xor] == -1:\n        first_pos[cur_xor] = i+1\n        \n      \n    return max_len", "from typing import Dict, Set\nfrom collections import Counter\n\n\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        mask_pos = {0: -1}\n\n        mask = 0\n        result = 0\n\n        for pos in range(len(s)):\n            mask ^= 1 << int(s[pos])\n\n            result = max(result, pos - mask_pos.get(mask, pos))\n\n            for shift in range(10):\n                result = max(\n                    result, pos - mask_pos.get(mask ^ (1 << shift), pos)\n                )\n\n            mask_pos.setdefault(mask, pos)\n\n        return result\n\n    def longestAwesome1(self, s: str) -> int:\n        result = 0\n\n        for start in range(len(s)):\n            count: Dict[str, int] = Counter()\n            odd = 0\n\n            for end in range(start, len(s)):\n                count[s[end]] += 1\n\n                if count[s[end]] & 1 > 0:\n                    odd += 1\n                else:\n                    odd -= 1\n\n                if odd <= 1:\n                    result = max(result, end + 1 - start)\n\n        return result\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        F = {0:0}\n        res = 0\n        mask = 0\n        j = 0\n        \n        for c in s:\n            j += 1\n            mask ^= 1 << ord(c) - ord('0')\n            # print(\\\"{0:08b}\\\".format(mask), \\\"~\\\")\n            for i in range(0, 10):\n                new_mask =  mask ^ (1 << i)\n                if new_mask in list(F.keys()):\n                    res = max(res, j - F[new_mask])\n                    if not mask:\n                        res = max(res, j)\n                \n            # print(mask)\n\n            if mask not in list(F.keys()):\n                F[mask] = j\n            # print(F)\n        return res\n", "class Solution:\n    def longestAwesome(self, s):\n        d = {0 : -1}\n        t = 0\n        ans = 0\n        for i in range(len(s)):\n            num = int(s[i])\n            # update tuple\n            t ^= 1 << (9 - num)\n            if t not in d:\n                d[t] = i\n                for m in range(10):\n                    temp = t ^ (1 << (9 - m))\n                    if temp in d:\n                        ans = max(ans, i - d[temp])\n            else:\n                ans = max(ans, i - d[t])\n                for m in range(10):\n                    temp = t ^ (1 << (9 - m))\n                    if temp in d:\n                        ans = max(ans, i - d[temp])\n\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        seen, prefix, ans = {0: -1}, 0, 0\n        for i, char in enumerate(s):\n            prefix ^= (1 << int(char))\n            ans = max(ans, i - seen.get(prefix, float('inf')))\n            for j in range(10):\n                p = prefix ^ (1 << j)\n                ans = max(ans, i - seen.get(p, float('inf')))\n            if prefix not in seen:\n                seen[prefix] = i\n        return ans\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo, state = {}, 0\n        memo[state], ans = -1, 0\n        for i, c in enumerate(s):            \n            state ^= 1 << int(c)                        \n            if state not in memo: \n                memo[state] = i\n            else: \n                ans = max(ans, i - memo[state])                            \n            for n in range(10):\n                state1 = state ^ (1 << n)                                 \n                if state1 in memo: \n                    ans = max(ans, i - memo[state1])\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        \n        \n        targets = {1 << x for x in range(10)}\n        targets.add(0)\n        \n        print(targets)\n        seen = {}\n        res = 0\n        prev = 0\n        seen[0] = -1\n        for idx, char in enumerate(s):\n            curr = prev ^ 1<<int(char)\n            if curr not in seen:\n                seen[curr] = idx\n                \n            for target in targets:\n                if curr ^ target in seen:\n                    res = max(res, idx - seen[curr ^ target])\n                    \n            prev = curr\n        print(seen)\n        print(res)\n        return res\n                    \n", "from collections import Counter\n\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        seen = {0: -1}\n        res, prefix = 0, 0\n        \n        for i, num in enumerate(map(int, s)):\n            prefix ^= 1 << num\n            res = max(res, i - seen.get(prefix, float('inf')))\n            for k in range(10):\n                prefix_add_odd = prefix ^ (1 << k)\n                res = max(res, i - seen.get(prefix_add_odd, float('inf')))\n            seen.setdefault(prefix, i)\n        \n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        dp = {} # \u8868\u793a\u6bcf\u4e2astate\u7684\u6700\u5c0f\u4e0b\u8868\n        dp[0] = -1\n        state, ans = 0, 0\n        for i, c in enumerate(s):\n            state ^= (1<<int(c))\n            if state not in dp: dp[state] = i\n            else:\n                # \u5f53\u524dstate\u548c\u4e4b\u524d\u7684\u67d0\u4e00\u4e2astate\u5b8c\u6210\u5168\u540c\u65f6\n                ans = max(ans, i - dp[state])\n            \n            # \u5f53\u524dstate\u548c\u4e4b\u524d\u7684\u67d0\u4e00\u4e2astate\u53ea\u5dee\u4e00\u4e2abit\u65f6\n            for num in range(10):\n                if state ^ (1 << num) in dp:\n                    ans = max(ans, i - dp[state ^ (1 << num)])\n        \n        return ans", "\\\"\\\"\\\"\nthe character w/ odd count must be no longer than 1\nfor a given character\nfreq[i:j] = prefix[j] - prefix[i-1]\n\n1. all characters: count are even\n2. only one character: count is odd\n\nwith prefix[i-1] is odd/even known, we'd like to know the smallest i\nkey: odd/even of prefix, value : idx\nprefix[j] : 1000001 -> prefix[i-1] : 1000001\nprefix[j] : 1000001 -> prefix[i-1] : 0000001\n                                     1100001\n                                     1100001\n\n\\\"\\\"\\\"\n\n\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        table = {0 : -1}\n        count = [0] * 10\n        res = 0\n        for i in range(len(s)):\n            count[ord(s[i]) - ord('0')] += 1\n            key = self.convert(count)\n            if key in table:\n                res = max(res, i - table[key])            \n            for k in range(10):\n                newKey = key\n                if ((key>>k)&1)==0:\n                    newKey += (1<<k)\n                else:\n                    newKey -= (1<<k)\n                if newKey in table:\n                    res = max(res, i - table[newKey])\n            if key not in table:\n                table[key] = i\n\n        return res\n        \n    def convert(self, count):\n        key = 0\n        for i in range(10):\n            key += ((count[i]%2)<<i)\n        return key\n        \n        \n        ", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        idxs = [1e9 for _ in range(1024)]\n        idxs[0] = -1\n        ans = 0\n        mask = 0\n        for i, ch in enumerate(s):\n            mask ^= 1 << ord(ch) - ord('0')\n            ans = max([ans, i - idxs[mask]] + [i - idxs[mask ^ (1 << j)] for j in range(10)])\n            idxs[mask] = min(idxs[mask], i)\n        return ans;", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        F = {0:-1} # fck important\n        res = 0\n        mask = 0\n        j = 0\n        \n        for j, c in enumerate(s):\n            mask ^= 1 << int(c)\n            if mask not in list(F.keys()):\n                F[mask] = j\n            else:\n                res = max(res, j - F[mask])\n\n            for i in range(0, 10):\n                new_mask =  mask ^ (1 << i)\n                if new_mask in list(F.keys()):\n                    res = max(res, j - F[new_mask])\n\n            # print(F)\n        return res\n", "\\\"\\\"\\\"\nthe character w/ odd count must be no longer than 1\nfor a given character\nfreq[i:j] = prefix[j] - prefix[i-1]\n\n1. all characters: count are even\n2. only one character: count is odd\n\nwith prefix[i-1] is odd/even known, we'd like to know the smallest i\nkey: odd/even of prefix, value : idx\nprefix[j] : 1000001 -> prefix[i-1] : 1000001\nprefix[j] : 1000001 -> prefix[i-1] : 0000001\n                                     1100001\n                                     1100001\n\n\\\"\\\"\\\"\n\n\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        table = {0 : -1}\n        count = [0] * 10\n        res = 0\n        for i in range(len(s)):\n            count[int(s[i])] += 1\n            key = self.convert(count)\n            if key in table:\n                res = max(res, i - table[key])            \n            for k in range(10):\n                newKey = key\n                if ((key>>k)&1)==0:\n                    newKey += (1<<k)\n                else:\n                    newKey -= (1<<k)\n                if newKey in table:\n                    res = max(res, i - table[newKey])\n            if key not in table:\n                table[key] = i\n        return res\n        \n    def convert(self, count):\n        key = 0\n        for i in range(10):\n            key += ((count[i]%2)<<i)\n        return key\n        \n        \n        ", "class Solution:\n    def count_set_bits(self, n):\n        count = 0\n        for i in range(32):\n            count += (n>>i) & (1)\n        return count\n    \n    def longestAwesome(self, s: str) -> int:\n        xormap = dict()\n        xormap[0] = -1\n        xor = 0\n        max_length = 0\n        for i in range(len(s)):\n            xor = xor ^ (1<<int(s[i]))\n            max_length = max(max_length, i - xormap.get(xor, float('Inf')))\n            for j in range(10):\n                temp_xor = xor ^ (1<<j)\n                max_length = max(max_length, i - xormap.get(temp_xor, float('Inf')) )\n            xormap[xor] = min(i, xormap.get(xor, float('Inf')))        \n        \n        return max_length", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo, state = {}, 0\n        memo[state], ans = -1, 0\n        for i, c in enumerate(s):            \n            state ^= 1 << int(c)                        \n            if state not in memo: memo[state] = i\n            else: ans = max(ans, i - memo[state])                            \n            for n in range(10):\n                state1 = state ^ (1 << n)                                 \n                if state1 in memo: ans = max(ans, i - memo[state1])\n        return ans", "class Solution:\n\\tdef longestAwesome(self, s: str) -> int:\n\\t\\tseen = {0: -1}\n\\t\\tcurrent_xor = 0\n\\t\\tanswer = 1\n\\t\\tn = len(s)\n\\t\\tfor i in range(n):\n\\t\\t\\tcurrent_xor ^= 1 << int(s[i])\n\\t\\t\\tif current_xor not in seen:\n\\t\\t\\t\\tseen[current_xor] = i\n\\t\\t\\telse:\n\\t\\t\\t\\tanswer = max(answer, i - seen[current_xor])\n\\t\\t\\tfor j in range(10):\n\\t\\t\\t\\tnew_xor = current_xor ^ (1 << j)\n\\t\\t\\t\\tif new_xor in seen:\n\\t\\t\\t\\t\\tanswer = max(answer, i - seen[new_xor])\n\\t\\treturn answer", "class Solution:\n    def linear(self, s):\n        ans = 0\n        d = {0:-1}\n        mask = 0\n        for i, c in enumerate(s):\n            mask = (1<<int(c)) ^ mask\n            \n            if mask in d:\n                ans = max(ans, i - d[mask])\n            \n            for j in range(32):\n                s = mask ^ (1<<j)\n                if s in d:\n                    ans = max(ans, i - d[s])\n            \n            if mask not in d:\n                d[mask] = i\n        return ans\n    \n            \n            \n        \n    def longestAwesome(self, s: str) -> int:\n        return self.linear(s)\n    \n        ans = 0\n        for i in range(len(s)):\n            d = collections.defaultdict(int)\n            odds = set()\n            for j in range(i, len(s)):\n                d[s[j]]+=1\n                if d[s[j]]%2:\n                    odds.add(s[j])\n                else:\n                    if s[j] in odds:\n                        odds.remove(s[j])\n                \n                if len(odds)<=1:\n                    ans = max(ans, j-i+1)\n        return ans\n    \n    \n    \n    \n    \n    \n    \n                \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        F = {0:-1} # fck important\n        res = 0\n        mask = 0\n        \n        for j, c in enumerate(s):\n            mask ^= 1 << int(c)\n            if mask not in list(F.keys()):\n                F[mask] = j\n            else:\n                res = max(res, j - F[mask])\n\n            for i in range(10):\n                new_mask =  mask ^ (1 << i)\n                if new_mask in list(F.keys()):\n                    res = max(res, j - F[new_mask])\n\n            # print(F)\n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        d = collections.defaultdict(int)\n        d[0]=-1\n        mask = 0\n        ans = 0\n        for i in range(len(s)):\n            mask ^= 1 << int(s[i])\n            if mask in d:\n                ans = max(ans, i-d[mask])\n            else:\n                d[mask]=i\n            for j in range(10):\n                tem = mask\n                tem ^= 1 << j\n                if tem in d:\n                    ans = max(ans, i-d[tem])\n        return ans\n                \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        res, cur, n = 0, 0, len(s)\n        seen = [-1] + [n] * 1024\n        for i, c in enumerate(s):\n            cur ^= 1 << int(c)\n            for a in range(10):\n                res = max(res, i - seen[cur ^ (1 << a)])\n            res = max(res, i - seen[cur])\n            seen[cur] = min(seen[cur], i)\n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        digit = []\n        for i in range(10):\n            digit.append(1<<i)\n        digit.append(0)\n        \n        cum = 0\n        bk = [-2 for _ in range(2**10+1)]\n        bk[0] = -1\n        ans = 0\n        for i,x in enumerate(s):\n            x = int(x)\n            cum ^= digit[x]\n            for d in digit:\n                mask = cum^d\n                if bk[mask] >= -1:\n                    ans = max(ans,i-bk[mask])\n            if bk[cum]==-2:\n                bk[cum] = i\n        return ans", "\\\"\\\"\\\"\nLeetcode :: 1542. Find Longest Awesome Substring\nhttps://leetcode.com/contest/biweekly-contest-32/problems/find-longest-awesome-substring/\n\\\"\\\"\\\"\nfrom math import inf\n\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        # A substring of 1 is a palindrome.\n        soln = 0\n        # Minimum index of this bitmask's occurrence\n        bitmask_occurred = [inf for _ in range(pow(2, 10))]\n        # Zero occurs before the first letter of s.\n        bitmask_occurred[0] = -1 \n\n        # Bit mask prefix\n        mask = 0\n\n        # Find the maximum length substring that can be a palindrome.\n        for i, c in enumerate(s):\n            # Convert c to a number\n            n = ord(c) - ord('0')\n            # Update bitmask prefix\n            mask ^=  (1 << n)\n\n            # Update bitmask's occurrence\n            bitmask_occurred[mask] = min(bitmask_occurred[mask], i)\n\n            # If we have seen this bitmask before, then the substring\n            # between this occurrence and the minimum previous occurrence\n            # is a palindrome.  This will catch *even* length substrings.\n            soln = max(soln, i - bitmask_occurred[mask])\n\n            # For odd length substrings, flip each on bit and see if that\n            # bitmask occurred before.\n            for b in range(10):\n                soln = max(soln, i - bitmask_occurred[mask ^ (1 << b)])\n\n        return soln\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo = {0: -1}\n        best = 0\n        bitmap = 0\n        for i, digit in enumerate(s):\n            bitmap ^= (1 << int(digit))\n            best = max(best, i - memo.get(bitmap, i))\n            for j in range(10):\n                key = bitmap ^ (1 << j)\n                best = max(best, i - memo.get(key, i))\n            memo[bitmap] = memo.get(bitmap, i)\n\n        return best", "from collections import defaultdict\nclass Solution:\n    # \u5148\u5206\u6790\u9898\u76ee\uff0c\u4e00\u6bb5substr\u5982\u679c\u53ef\u4ee5\u901a\u8fc7swap\u5f62\u6210\u4e00\u4e2apalindrome\uff0c\u8bf4\u660e\u91cc\u9762\u7684\u6240\u6709\u6570\u5b57\u8981\u4e48\u90fd\u662f\u5076\u6570(e.g. 240042)\uff0c\u8981\u4e48\u6709\u4e14\u53ea\u80fd\u6709\u4e00\u4e2a\u5947\u6570(e.g. 2401042)\n    # \u8fd9\u6837\u5c31\u9700\u8981\u7528bitmask\uff0c\u7528\u4e00\u4e2a10\u4f4d\u4e8c\u8fdb\u5236\u6570\u8868\u793a\uff0c\u7b2ci\u4f4d\u5982\u679c\u662f0\u8bf4\u660esubstr\u91cc\u6709\u5076\u6570\u4e2ai\uff0c\u7b2ci\u4f4d\u5982\u679c\u662f1\u8bf4\u660esubstr\u91cc\u6709\u5947\u6570\u4e2ai\n    # \u6bcf\u6b21substr\u5411\u53f3\u6269\u5c55\u4e00\u4e2a\u6570j\uff0c\u5c31\u628a\u5f53\u524dmask xor (1 << j), \u5373\u53ef\u5b8c\u6210\u4e0a\u8ff0\u5947\u5076\u53d8\u5316\n    # intuitive solution: top-down dp\uff0c\u7b54\u6848\u5728\u6700\u4e0b\uff0c\u8d85\u65f6\n    # bottom-up dp solution: time O(n*1024), space O(1024)\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        dp = [n for i in range(1024)]\n        dp[0] = -1\n        mask, ret = 0, 0\n        \n        for i, c in enumerate(s):\n            mask ^= (1 << int(c))\n            for num in range(10):\n                ret = max(ret, i-dp[mask^(1<<num)])\n            ret = max(ret, i-dp[mask])\n            dp[mask] = min(dp[mask], i)\n        return ret\n        \n        \n#     def longestAwesome(self, s: str) -> int:\n#         n = len(s)\n#         M = defaultdict(int)\n        \n#         def count(mask):\n#             counter = 0\n#             while mask:\n#                 mask &= mask-1\n#                 counter += 1\n#             return counter\n        \n#         # \u5b9a\u4e49dp(l, r, mask)\u4e3as[l, r]\u5305\u542b\u7684\u6700\u957fawesome substr\n#         def dp(l, r, mask):\n#             if l > r:\n#                 return 0\n            \n#             if (l, r, mask) in M:\n#                 return M[(l, r, mask)]\n            \n#             if count(mask) <= 1:\n#                 M[(l, r, mask)] = r-l+1\n            \n            \n            \n#             if r+1 < n:\n#                 new_mask = mask ^ (1 << int(s[r+1]))\n#                 M[(l, r, mask)] = max(M[(l, r, mask)], dp(l, r+1, new_mask))\n#             if l+1 < n:\n#                 new_mask = mask ^ (1 << int(s[l])) \n#                 M[(l, r, mask)] = max(M[(l, r, mask)], dp(l+1, r, new_mask))\n            \n#             return M[(l, r, mask)]\n        \n#         dp(0, 0, 1<<int(s[0]))\n#         return M[(0, 0, 1<<int(s[0]))]\n", "class Solution:\\r\n    def longestAwesome(self, s):\\r\n        def check(num):\\r\n            if num == 0:\\r\n                self.ans = i + 1\\r\n                return True\\r\n            elif seen[num] != float('inf'):\\r\n                self.ans = max(self.ans, i - seen[num])\\r\n                return True\\r\n            else:\\r\n                return False\\r\n\\r\n        # 0 ~ 2^10\\r\n        if not s:\\r\n            return 0\\r\n        seen = [float('inf') for _ in range(1024)]\\r\n        cur = 0\\r\n        self.ans = 0\\r\n        flips = [2 ** i for i in range(10)]\\r\n        for i, val in enumerate(s):\\r\n            mask = 2 ** int(val)\\r\n            cur ^= mask\\r\n            check(cur)\\r\n            for flip in flips:\\r\n                check(cur ^ flip)\\r\n            seen[cur] = min(i, seen[cur])\\r\n        \\r\n        return self.ans\\r\n                \\r\nprint(Solution().longestAwesome('350844'))", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        pattern = 0\n        # {pattern: end position}\n        d = {pattern: -1} \n        res = 0\n        for cur_i,x in enumerate(s):\n\n            # there are 2 cases can construct palidrome at positoin i\n            # 1) current pattern == previous pattern\n            # 2) current pattern has one bit diff for previous pattern\n            # and length will be current position - previous position\n        \n            pattern ^= 1 << int(x)\n\n            for i in range(10):\n                new_pattern = pattern ^ (1 << i)\n                res = max(res, cur_i - d.get(new_pattern, cur_i))\n\n            res = max(res, cur_i - d.get(pattern, cur_i))\n                    \n            d.setdefault(pattern,cur_i)\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        bitmask={}\n        mask=0\n        ans=1\n        n=len(s)\n        bitmask[0]=-1\n        for i in range(n):\n            mask^=(1<<int(s[i]))\n            if(mask in bitmask):\n                ans=max(ans,i-bitmask[mask])\n            for j in range(10):\n                test= mask ^ (1<<j)\n                if(test in bitmask):\n                    ans=max(ans,i-bitmask[test])\n            if(mask not in bitmask):\n                bitmask[mask]=i\n        return ans\n", "import numpy as np\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        mask, res = 0, 0\n        dp = np.full(1024, len(s))\n        dp[0] = -1\n        for i in range(len(s)):\n            mask ^= 1 << (ord(s[i]) - 48)\n            for j in range(11):\n                check_mask = 1023 & (mask ^ (1 << j))\n                res = max(res, i - dp[check_mask])\n            dp[mask] = min(dp[mask], i)\n        return res ", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        if len(s) == 0:\n            return 0\n        \n        max_len = 1\n        # p[i] contains a 10-bit number where the k-th bit of p[i] is 0 if there are\n        # even instances of digit k in s[0..i], or k-th bit of p[i] is 1 if there are\n        # odd instances of digit k in s[0..i].\n        p = [0] * len(s)\n        # seen[x] holds the smallest index at which some p[i] == x was seen. We can therefore\n        # query `seen` to find out when some odd/evenness digit instance state was first seen.\n        # For convinience, we can say we've seen even instances of all digits [0-9] at index\n        # -1, ie. we've seen zero instances of every digit before index 0\n        seen = {0:-1}\n        for i in range(0, len(s)):\n            d = ord(s[i]) - ord('0')\n            p[i] = (1 << d) ^ p[i-1]\n            \n            #if p[i] in seen:\n                # If for any digit `d` we've previously seen odd instances for i' < i in s[0..i'] and\n                # now we've seen odd instances of `d` in s[0..i], then there's even instances of\n                # `d` in s[i'+1 .. i]; same argument for even instances of `d`. In both cases we'd\n                # have even instances of every possible digit which would make a valid palindrome\n            #    max_len = max(max_len, i - seen[p[i]])\n            \n            for od in range(10):\n                # If we designate only one digit as the digit that could have odd instances, then\n                # if we've had odd instances previously for the same digit, AND same odd/even \n                # instances for all other digits, we can make a valid palindrome.\n                x = p[i] | (1 << od)\n                if x in seen:\n                    max_len = max(max_len, i - seen[x])\n                y = p[i] & (~(1 << od))\n                if y in seen:\n                    max_len = max(max_len, i - seen[y])\n            \n            if p[i] not in seen:\n                seen[p[i]] = i\n        \n        return max_len\n                \n                    \n\n                \n\n                \n                \n                \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        m, state = defaultdict(int), [0] * 10\n        m[tuple(state)] = -1\n        ans = 0\n        for i, c in enumerate(s):\n            k = int(c)\n            state[k] = 1 - state[k]            \n            tstate = tuple(state)\n            if tstate not in m: m[tstate] = i\n            else: ans = max(ans, i - m[tstate])            \n            for n in range(10):\n                state[n] = 1-state[n] \n                tstate = tuple(state)                    \n                if tstate in m: ans = max(ans, i - m[tstate])                                            \n                state[n] = 1-state[n]\n        return ans\n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        \n        M = { 0: -1 }\n        ans = 0\n        code = 0\n        \n        D = [(1 << d) for d in range(10)]\n        \n        for i, c in enumerate(s):\n            code = code ^ (1 << (ord(c) - ord('0')))\n            \n            if code in M:\n                ans = max(ans, i - M[code])\n            \n            for dc in D:\n                dcode = code ^ dc\n                if dcode in M:\n                    ans = max(ans, i - M[dcode])\n            \n            if code not in M:\n                M[code] = i\n            \n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        m = defaultdict(int)\n        state = [0] * 10\n        m[tuple(state)] = -1\n        ans = 0\n        for i, c in enumerate(s):\n            k = int(c)\n            state[k] = 1 - state[k]            \n            tstate = tuple(state)\n            if tstate not in m:\n                m[tstate] = i\n            else:\n                ans = max(ans, i - m[tstate])\n            \n            for n in range(10):\n                state[n] = 1-state[n] \n                tstate = tuple(state)                    \n                if tstate in m: ans = max(ans, i - m[tstate])                                            \n                state[n] = 1-state[n]\n        return ans\n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        df,dl = {}, {}\n        df[0] = -1\n        sm = 0\n        res = 1\n        for i,c in enumerate(s):\n            sm ^= 1 << int(c)\n            if sm not in df:\n                df[sm] = i\n            dl[sm] = i\n        for fk,fv in df.items():\n            for lk,lv in dl.items():\n                if lv > fv:\n                    xor = fk ^ lk\n                    if xor == 0 or (xor & (xor-1)) == 0:\n                        res = max(res, lv - fv)\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        if len(s) == 0:\n            return 0\n        \n        seen = {0:-1}\n        max_len = 1\n        p = [0] * len(s)\n        for i in range(0, len(s)):\n            d = ord(s[i]) - ord('0')\n            p[i] = (1 << d) ^ p[i-1]\n            \n            if p[i] in seen:\n                # If for any digit `d` we've previously seen odd instances for i' < i in s[0..i'] and\n                # now we've seen odd instances of `d` in s[0..i], then there's even instances of\n                # `d` in s[i'+1 .. i]; same argument for even instances of `d`. In both cases we'd\n                # have even instances of every possible digit which would make a valid palindrome\n                max_len = max(max_len, i - seen[p[i]])\n            \n            for d in range(10):\n                x = p[i] | (1 << d)\n                if x in seen:\n                    max_len = max(max_len, i - seen[x])\n                y = p[i] & (~(1 << d))\n                if y in seen:\n                    max_len = max(max_len, i - seen[y])\n            \n            if p[i] not in seen:\n                seen[p[i]] = i\n        \n        return max_len\n                \n                    \n\n                \n\n                \n                \n                \n", "from typing import List\n\n\n# Aug 15, 2020\n# 44 / 153 test cases passed.\n# 129 / 153 test cases passed.\n# Faster than 12.08% of Python3 online submissions for Find Longest Awesome Substring\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        res = 0\n\n        # pattern[i] True means we have even number of i so far\n        # pattern[i] false means we have odd number of i so far\n        pattern: List[bool] = [False] * 10\n\n        existing = {tuple(pattern): -1}\n\n        for cur_i, char in enumerate(s):\n            num = int(char)\n            pattern[num] = not pattern[num]\n\n            for i in range(10):\n                new_pattern = pattern.copy()\n                new_pattern[i] = not new_pattern[i]\n                # `existing[new_pattern]` give us the position of j where\n                # starting from `j` we know we have 1 odd `num`\n                res = max(res, cur_i - existing.get(tuple(new_pattern), cur_i))\n\n            # If we have `pattern` in `existing`, then we know it is also a palindrome starting from existing[pattern]\n            res = max(res, cur_i - existing.get(tuple(pattern), cur_i))\n\n            existing.setdefault(tuple(pattern), cur_i)\n\n        return res\n", "from typing import List\n\n\n# Aug 15, 2020\n# 44 / 153 test cases passed.\n# 129 / 153 test cases passed.\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        res = 0\n\n        # pattern[i] True means we have even number of i so far\n        # pattern[i] false means we have odd number of i so far\n        pattern: List[bool] = [False] * 10\n\n        existing = {tuple(pattern): -1}\n\n        for cur_i, char in enumerate(s):\n            num = int(char)\n            pattern[num] = not pattern[num]\n\n            for i in range(10):\n                new_pattern = pattern.copy()\n                new_pattern[i] = not new_pattern[i]\n                # existing.get(tuple(new_pattern)) give us the position of j where\n                # starting from j we know we have 1 odd `num`\n                res = max(res, cur_i - existing.get(tuple(new_pattern), cur_i))\n\n            # If we have `pattern` in `existing`, then we know it is also a palindrome starting from j\n            res = max(res, cur_i - existing.get(tuple(pattern), cur_i))\n\n            if tuple(pattern) not in existing:\n                existing.setdefault(tuple(pattern), cur_i)\n\n        return res\n", "'''\nWe know that any given substring must be such that for all digits in substring, at most one of those has odd frequency. So, we probably need to find a clever way to figure out the longest such string with that propery.\nIt seems like we can do something where we go from largest ending in index i to largest ending in index i+1 where we use fact if character a doesn't change the above constraints, then that is obvious answer. Otherwise, we would then have to remove stuff from early on in string tied to index i until we are valid.\n'''\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        sLength = len(s)\n        earliestBinaries = {}\n        ##we need to find out the current count of (0,1,2,...,9) and do even odd. Then we hash and check the earliest of the 11 possibilities so that at that point it will be the longest possible string ending at this endpoint.\n        current = [0]*10\n        earliestBinaries[tuple(current)] = -1\n        currentMax = 0\n        def computeMaxFromNeighbors(counter,currentTuple):\n            currentMax = 0\n            if currentTuple in earliestBinaries:\n                currentMax = max(currentMax,counter-earliestBinaries[currentTuple])\n            neighborList = list(currentTuple)\n            for i in range(len(currentTuple)):\n                neighborList[i] = 1-neighborList[i]\n                neighborTuple = tuple(neighborList)\n                if neighborTuple in earliestBinaries:\n                    currentMax = max(currentMax, counter-earliestBinaries[neighborTuple])\n                neighborList[i] = 1-neighborList[i]\n            return currentMax\n        for counter,char in enumerate(s):\n            current[int(char)] = 1-current[int(char)]\n            currentTuple = tuple(current)\n            currentMax = max(currentMax,computeMaxFromNeighbors(counter,currentTuple))\n            if currentTuple not in earliestBinaries:\n                earliestBinaries[currentTuple] = counter\n        return currentMax\n                        \n                    \n", "class Solution:\n    def linear(self, s):\n        ans = 0\n        d = {0:-1}\n        mask = 0\n        for i, c in enumerate(s):\n            mask = (1<<int(c)) ^ mask\n            \n            if mask in d:\n                ans = max(ans, i - d[mask])\n            \n            for j in range(32):\n                s = mask ^ (1<<j)\n                if s in d:\n                    ans = max(ans, i - d[s])\n            \n            if mask not in d:\n                d[mask] = i\n        return ans\n    \n    \n        \n        \n    def longestAwesome(self, s: str) -> int:\n        return self.linear(s)\n    \n        ans = 0\n        for i in range(len(s)):\n            d = collections.defaultdict(int)\n            odds = set()\n            for j in range(i, len(s)):\n                d[s[j]]+=1\n                if d[s[j]]%2:\n                    odds.add(s[j])\n                else:\n                    if s[j] in odds:\n                        odds.remove(s[j])\n                \n                if len(odds)<=1:\n                    ans = max(ans, j-i+1)\n        return ans\n    \n    \n    \n    \n    \n    \n    \n                \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mx = 0\n        table = {frozenset(): -1}\n        acs, cs = set(), set()\n        for i,c in enumerate(s):\n            acs.add(c)\n            if c in cs: cs.remove(c)\n            else: cs.add(c)\n                \n            fcs = frozenset(cs)\n            if fcs in table:\n                mx = max(mx,i-table[fcs])\n            for c in acs:\n                if c in cs:\n                    cs.remove(c)\n                    rfcs = frozenset(cs)\n                    cs.add(c)\n                    if rfcs in table:\n                        mx = max(mx,i-table[rfcs])\n                else:\n                    cs.add(c)\n                    rfcs = frozenset(cs)\n                    cs.remove(c)\n                    if rfcs in table:\n                        mx = max(mx,i-table[rfcs])\n            table[fcs] = min(table.get(fcs,float('inf')),i)\n                \n        return mx\n        \n", "class Solution(object):\n    def longestAwesome(self, s):\n        \\\"\\\"\\\"\n        :type s: str\n        :rtype: int\n        \\\"\\\"\\\"\n        D = {}\n        curr = [0 for _ in range(10)]\n        res = 0\n        for i, c in enumerate(s):\n            c = int(c)\n            curr[c] = (curr[c] + 1) % 2\n            tc = tuple(curr)\n            cand = 0\n            if sum(curr) <= 1:\n                cand = i + 1\n            else:                \n                if tc in D:\n                    cand = i - D[tc]\n                for j in range(10):\n                    curr[j] = (1 + curr[j]) % 2\n                    oc = tuple(curr)\n                    if oc in D:\n                        cand = max(cand, i - D[oc])\n                    curr[j] = (1 + curr[j]) % 2\n            res = max(res, cand)\n            if tc not in D:\n                D[tc] = i\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        dic, mask, res = {0: -1}, 0, 1\n        for i, ch in enumerate(s):\n            mask ^= 1 << int(ch)\n            dic.setdefault(mask, i)\n            res = max(res, i - min([dic[mask]] + [dic.get(mask ^ (1 << k), float('inf')) for k in range(11) ]))\n        return res\n'''\n\\\"3242415\\\"\n\\\"12345678\\\"\n\\\"213123\\\"\n\\\"00\\\"\n'''", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        res = 0\n        mask = 0\n        idx = [n+1]*1024;\n        idx[0] = -1;\n        for i,c in enumerate(s):\n            mask ^= (1<<(ord(c) - ord('0')));\n            res = max(res, i-idx[mask]);\n            \n            res = max(res, max([i - idx[mask^(1<<j)] for j in range(10)]))\n            idx[mask] = min(idx[mask], i)\n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mx = 0\n        table = {frozenset(): -1}\n        acs, cs = set(), set()\n        for i,c in enumerate(s):\n            acs.add(c)\n            if c in cs: cs.remove(c)\n            else: cs.add(c)\n            fcs = frozenset(cs)\n            if fcs in table:\n                mx = max(mx,i-table[fcs])\n            for c in acs:\n                if c in cs:\n                    cs.remove(c)\n                    rfcs = frozenset(cs)\n                    cs.add(c)\n                    if rfcs in table:\n                        mx = max(mx,i-table[rfcs])\n                else:\n                    cs.add(c)\n                    rfcs = frozenset(cs)\n                    cs.remove(c)\n                    if rfcs in table:\n                        mx = max(mx,i-table[rfcs])\n            table[fcs] = min(table.get(fcs,float('inf')),i)\n        return mx\n        \n", "from collections import defaultdict\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        dlist=[1]*10\n        for i in range(9):\n            dlist[i+1]=dlist[i]*2\n        count=defaultdict(int)\n        dp=dict()\n        ans=0\n        dp[0]=-1\n        for i,num in enumerate(s):\n            count[num]+=1\n            cur=0\n            curdp=10*[0]\n            for ar in range(10):\n                st=str(ar)\n                val=count[st]%2\n                cur+=(val*dlist[ar])\n                curdp[ar]=val\n            if cur in dp:\n                ans=max(ans,i-dp[cur])\n            else:\n                dp[cur]=i\n            for ar in range(10):\n                if curdp[ar]==1:\n                    val=-1\n                else:\n                    val=1\n                cur+=val*dlist[ar]\n                if cur in dp:\n                    ans=max(ans,i-dp[cur])\n                cur-=val*dlist[ar]\n        return ans\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        pattern = [False]*10\n        # {pattern: end position}\n        # d = collections.defaultdict(int)\n        d = {tuple(pattern): -1} \n        res = 0\n        for i,x in enumerate(s):\n            num = int(x)\n            pattern[num] = not pattern[num]\n            # there are 2 cases can construct palidrome at positoin i\n            # 1) current pattern == previous pattern\n            # 2) current pattern has one bit diff for previous pattern\n            # and length will be current position - previous position\n        \n            res = max(res, i - d.get(tuple(pattern),i))\n                \n            for k in range(10):\n                new_pattern = pattern.copy()\n                new_pattern[k] = not new_pattern[k] #one bit different\n                res = max(res, i-d.get(tuple(new_pattern),i))\n                    \n            d.setdefault(tuple(pattern),i)\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        d = defaultdict(lambda : 1e20)\n        d[0] = -1\n        res = 0\n        mask = 0\n        for i, val in enumerate(s):\n            mask ^= 1 << int(val)\n            d[mask] = min(d[mask], i)\n            res = max(res,i - d[mask])  \n            for k in range(11):\n                res = max(res,i - d[mask ^ (1<<k)])  \n        return res", "import collections\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        \n        memo = [0]*10\n        d = collections.defaultdict(list)\n        ans = 1\n        d[0].append(-1)\n        \n        for i,x in enumerate(s):\n            \n            memo[int(x)]+=1\n            key = 0\n            for j,y in enumerate(memo):\n                if y%2==1:\n                    key += 2**j\n            d[key].append(i)\n            if len(d[key])>=2:\n                ans = max(ans,d[key][-1]-d[key][0])\n                \n                \n            for j,y in enumerate(memo):\n                \n                if y%2==0:\n                    new_key = key+2**j\n                    if len(d[new_key])>0:\n                        ans = max(ans,d[key][-1]-d[new_key][0])\n                else:\n                    new_key = key-2**j\n                    if len(d[new_key])>0:\n                        ans = max(ans,d[key][-1]-d[new_key][0])\n                        \n              \n                        \n        #print(d[0])\n        return ans\n                        \n            \n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        if len(s) == 0:\n            return 0\n        \n        max_len = 1\n        # p[i] contains a 10-bit number where the k-th bit of p[i] is 0 if there are\n        # even instances of digit k in s[0..i], or k-th bit of p[i] is 1 if there are\n        # odd instances of digit k in s[0..i].\n        p = [0] * len(s)\n        # seen[x] holds the smallest index at which some p[i] == x was seen. We can therefore\n        # query `seen` to find out when some odd/evenness digit instance state was first seen.\n        # For convinience, we can say we've seen even instances of all digits [0-9] at index\n        # -1, ie. we've seen zero instances of every digit before index 0\n        seen = {0:-1}\n        for i in range(0, len(s)):\n            d = ord(s[i]) - ord('0')\n            p[i] = (1 << d) ^ p[i-1]\n            \n            # To make a palindrome, we can only have at most one digit with odd number of instances.\n            # We'll go through every possible digit and designate that digit as the special digit\n            # and see that if we can subtract previously seen instances of digits to make a valid\n            # palindrome.\n            for sd in range(10):\n                # If some previous instance \\\"state\\\" has odd instances of `sd` for s[0..i'], i' < i, \n                # then s[0..i] can have either even or odd instances of `sd`, as long as s[0..i]\n                # has the same odd/even instances for all other digits. (for `sd`, we'd have odd-odd \n                # instances or even-odd instances, which is even or odd instances of `sd`; for all \n                # other digits, we'd have odd-odd or even-even instances, which is even instances\n                # for all other digits)\n                x = p[i] | (1 << sd) # bit represending `sd` is set to 1, indicating odd\n                if x in seen:\n                    max_len = max(max_len, i - seen[x])\n                \n                # If some previous instance \\\"state\\\" has even instances of `sd` for s[0..i'], i' < i, \n                # then s[0..i] can have either even or odd instances of `sd`, as long as s[0..i]\n                # has the same odd/even instances for all other digits.                \n                y = p[i] & (~(1 << sd)) # bit represending `sd` is set to 0, indicating even\n                if y in seen:\n                    max_len = max(max_len, i - seen[y])\n            \n            if p[i] not in seen:\n                seen[p[i]] = i\n        \n        return max_len\n                \n                    \n\n                \n\n                \n                \n                \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        \n        # See suggestion in solutions of using approach of leetcode 1371:\n        # Find longest substring containing even number of vowels.\n        # Which is also same approach as leetcode 1, two sum:\n        # You record status at every index, and keep it in dictionary of\n        # prior indices, so you can check for any elements in dictionary\n        # that have status such that sequence between earlier index\n        # and current value meets the needed requirement\n        \n        # Complicated thing here is to determine earlier \\\"status\\\" values\n        # that mean that current index is appropriate\n        \n        maxV = 0\n        \n        c = [0 for i in range(10)]\n        counts = []\n        c[int(s[0])] += 1\n        counts.append(c[:])\n        for i in range(1, len(s)):\n            c = counts[-1][:]\n            c[int(s[i])] = (c[int(s[i])] + 1) % 2\n            counts.append(c)\n        counts = [[0,0,0,0,0,0,0,0,0,0]] + counts\n        #print(counts)\n              \n        d = {tuple(counts[0]):0} # d has tuple of the 10 counts, mapping it to first index where those counts found in array counts\n              \n        # remember to use i+1 in finding values in counts, since we added\n        # the extra value at position 0.\n        for i in range(len(s)):\n            current = counts[i+1][:]\n              # j is the one digit that can have odd number of occurences\n                # and remember to include possibility that all digits are even numbers!!!\n            for j in range(10): # for each j, creating another newCurrent\n                newCurrent = current[:]\n                newCurrent[j] = (current[j]+1) % 2\n                newCurrent = tuple(newCurrent)\n                if newCurrent in d:\n                    ind = d[newCurrent]\n                    maxV = max(maxV, i+1 - ind)\n            if tuple(current) in d:\n                ind = d[tuple(current)]\n                maxV = max(maxV, i+1 - ind)\n            else:\n                d[tuple(current)] = i+1\n        \n        return maxV        \n                          \n        # My prior proposed answer, maybe during contest?\n        # That gave correct answer, but was TLE\n        \n        newS = \\\"\\\"\n        d = {}\n        \n        def xor(l1,l2):\n            res = []\n            for i in range(10):\n                res.append(l1[i] ^ l2[i])\n            return res\n        \n        counts = [[0 for i in range(10)] for j in range(len(s)+1)]\n        counts[1][int(s[0])] += 1 # added extra \\\"all zero counts at left end, to deal with index -1 later\\\"\n        for i in range(1,len(s)):\n            counts[i+1] = counts[i][:]\n            counts[i+1][int(s[i])] = abs(counts[i+1][int(s[i])]-1)\n        bestAns = 1\n        for i in range(len(s)-1, -1, -1):\n            if i < bestAns:\n                break\n            for j in range(0, i+1):\n                if i - j < bestAns:\n                    break\n                ans = xor(counts[i+1], counts[j])\n                oneCount = [1 for i in ans if i == 1]\n                if sum(oneCount) <= 1:\n                    bestAns = max(bestAns, i+1 - j)\n        return bestAns", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        m = defaultdict(int)\n        state = [0] * 10\n        m[tuple(state)] = -1\n        ans = 0\n        for i, c in enumerate(s):\n            k = int(c)\n            state[k] = 1 - state[k]            \n            tstate = tuple(state)\n            if tstate not in m: m[tstate] = i\n            else: ans = max(ans, i - m[tstate])            \n            for n in range(10):\n                state[n] = 1-state[n] \n                tstate = tuple(state)                    \n                if tstate in m: ans = max(ans, i - m[tstate])                                            \n                state[n] = 1-state[n]\n        return ans\n        \n", "class Solution:\n    def longestAwesome(self, s):\n        d = {(0,) * 10 : -1}\n        t = (0, ) * 10\n        ans = 0\n        for i in range(len(s)):\n            num = int(s[i])\n            # update tuple\n            t = t[:num] + ((t[num] + 1) % 2,) + t[num + 1:]\n            if t not in d:\n                d[t] = i\n                for m in range(10):\n                    temp = t[:m] + (1-t[m],) + t[m+1:]\n                    if temp in d:\n                        ans = max(ans, i - d[temp])\n            else:\n                ans = max(ans, i - d[t])\n                for m in range(10):\n                    temp = t[:m] + (1-t[m],) + t[m+1:]\n                    if temp in d:\n                        ans = max(ans, i - d[temp])\n\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        m = defaultdict(int)\n        state = [0] * 10\n        m[tuple(state)] = -1\n        ans = 0\n        for i, c in enumerate(s):\n            k = int(c)\n            state[k] = 1 - state[k]            \n            tstate = tuple(state)\n            if tstate not in m:\n                m[tstate] = i\n            else:\n                ans = max(ans, i - m[tstate])\n            \n            for n in range(10):\n                state[n] = 1-state[n] \n                tstate = tuple(state)                    \n                if tstate in m: ans = max(ans, i - m[tstate])                                            \n                state[n] = 1-state[n]\n            # print(i, c, state, ans)\n        return ans\n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        lmost,rmost=[len(s)]*1024,[-1]*1024\n        lmost[0]=0\n        cur=[0]*10\n        mask=0\n        for i,c in enumerate(s):\n            d=int(c)\n            if cur[d]==1:\n                mask-=2**d\n            else:\n                mask+=2**d\n            cur[d]=cur[d]^1\n            lmost[mask]=min(lmost[mask],i+1)\n            rmost[mask]=max(rmost[mask],i+1)\n        re=1\n        # print([[i,x] for i,x in enumerate(lmost) if x<len(s)])\n        # print([[i,x] for i,x in enumerate(rmost) if x>-1])\n        for i in range(1024):\n            l=lmost[i]\n            if l==len(s):\n                continue\n            r=rmost[i]\n            # if r-l+int(i>0)>re: print(l,r)\n            re=max(re,r-l+int(i>0))\n            mask=[int(x) for x in \\\"{0:010b}\\\".format(i)]\n            for i in range(10):\n                nmask=mask[:i]+[mask[i]^1]+mask[i+1:]\n                r=rmost[sum([x*(2**(9-i)) for i,x in enumerate(nmask)])]\n                # if r-l>re: print(l,r)\n                re=max(re,r-l)\n        return re\n\n        ", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        bit_mask_mapping = {\n            tuple([0]*10): -1,\n        }\n        \n        bit_mask = [0]*10\n        max_len = 0\n        for ch_i, ch in enumerate(s):\n            cur_int = int(ch)\n            bit_mask[cur_int] ^= 1\n            bit_mask_str = tuple(bit_mask)\n            if bit_mask_str in bit_mask_mapping:\n                max_len = max(max_len, ch_i - bit_mask_mapping[bit_mask_str])\n            for j in range(10):\n                tmp_mask = tuple(bit_mask[:j] + [bit_mask[j]^1] + bit_mask[j+1:])\n                if tmp_mask in bit_mask_mapping:\n                    max_len = max(max_len, ch_i - bit_mask_mapping[tmp_mask])\n            if bit_mask_str not in bit_mask_mapping:\n                bit_mask_mapping[bit_mask_str] = ch_i\n        return max_len\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        \n        digits=[2**i for i in range(10)] + [0]\n        \n        max_len, xor, dictF, dictB=0, 0, {0:-1}, {}\n        \n        for i in range(len(s)):\n            xor=xor ^ (digits[int(s[i])])\n            if xor not in dictF:\n                dictF[xor]=i\n            dictB[xor]=i\n\n        max_len=0\n        for i in dictB:\n            max_len=max([max_len]+[(dictB[i]-dictF[j ^ i]) for j in digits if j ^ i in dictF])\n                \n        return max_len", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        left_most_masks = {0:-1}\n        valid_masks =  {1 << i for i in range(10)} | {0}\n        ans = 0\n        cur_mask = 0\n        \n        for idx, x in enumerate(list(s)):\n            cur_mask = cur_mask ^ 1 << int(x)\n            for valid_mask in valid_masks:\n                left_mask = valid_mask ^ cur_mask\n                if left_mask in left_most_masks:\n                    ans = max(ans, idx - left_most_masks[left_mask])\n            if cur_mask not in left_most_masks:\n                left_most_masks[cur_mask] = idx\n        return ans", "class Solution:\n  def longestAwesome(self, s: str) -> int:\n    # TC: O(N), SC: O(1), prefix + bitmask\n    n = len(s)\n    # bitmask on each digits is odd or even\n    # at most one odd is ok => at most one 1s in bitmask\n    m, seen, ans = 0, [-1] + [n] * 1024, 1\n    for i, x in enumerate(s):\n      m ^= 1 << int(x)\n      for d in range(10):\n        ans = max(ans, i - seen[m ^ (1 << d)])\n      ans = max(ans, i - seen[m])\n      seen[m] = min(seen[m], i)\n    return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        rec = 0\n        seen = {0:-1}\n        mask = 0\n        \n        for i,n in enumerate(s):\n            mask ^= (1<<int(n))\n            if mask in seen:\n                rec = max(rec, i - seen[mask])\n            else:\n                seen[mask] = i\n            for d in range(10):\n                omask = mask ^ (1<<d)\n                if omask in seen:\n                    rec = max(rec, i - seen[omask])\n        \n        return rec", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo, state = {}, 0\n        memo[state], ans = -1, 0\n        for i, c in enumerate(s):            \n            state ^= 1 << int(c)                        \n            if state not in memo: memo[state] = i\n            else: ans = max(ans, i - memo[state])                            \n            for n in range(10):\n                state1 = state ^ (1 << n)                                 \n                if state1 in memo: ans = max(ans, i - memo[state1])\n        return ans          ", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mem = {0: -1}\n        res = 0\n        state = 0\n        for i, x in enumerate(s):\n            idx = ord(x) - ord('0')\n            state ^= (1 << idx)\n            if state in mem:\n                res = max(res, i - mem[state])\n\n            for shift in range(10):\n                tmp = state ^ (1 << shift)\n                if tmp in mem:\n                    res = max(res, i - mem[tmp])\n            if state not in mem:\n                mem[state] = i\n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        # \u76f8\u4f3c\u9898\u76ee1371\n        '''\n        p = [0]   # \u6536\u96c6\u7d2f\u8ba1\u7684 \u5947\u5076\u72b6\u6001\u5305\u62ec0\u5728\u5185\n        for c in s:\n            x = int(c)\n            p.append(p[-1])\n            p[-1] ^= 1 << x\n        \n        legal = {0}\n        for x in range(10):\n            legal.add(1 << x)\n           \n        first = {}\n        ans = 0\n        for j, q in enumerate(p):\n            for leg in legal:\n                ideal = leg ^ q\n                i = first.get(ideal, None)\n                if i is not None:\n                    cand = j - i\n                    if cand > ans:\n                        ans = cand\n            first.setdefault(q, j)\n        return ans\n        '''\n        # \u8fd9\u9053\u9898\u6211\u60f3\u8fc7\u4e8c\u5206\u6cd5\uff0c\u4f46\u662f\u4e8c\u5206\u7684\u903b\u8f91\u662f\u4e0d\u5bf9\u7684\u867d\u7136\u9a8c\u8bc1\u5f88\u7b80\u5355\u3002\n        # \u8fd9\u9053\u9898\u6211\u60f3\u8fc7divide and conquer\u4f46\u662f\u4ee5\u4e2d\u95f4\u503c\u5f80\u4e24\u8fb9\u6269\u5f20\u7684\u6700\u957f\u65e0\u6cd5\u6c42\n        # \u6700\u540e\u8054\u60f3\u5230\u4e4b\u524d\u7684\u8fde\u7eed\u6700\u957f\u95ee\u9898\u4ee5\u53ca\u5947\u5076\u8ba1\u6570\u95ee\u9898\u53ef\u4ee5\u83b7\u5f97\u89e3\u6cd5O(N)\n        res, cur, n = 0, 0, len(s)\n        seen = [-1] + [n] * 1024  # \u4e00\u517110\u4f4d\u6570\u7801*(\u9009or\u4e0d\u9009)\u6240\u4ee5\u72b6\u6001\u6570\u4e5f\u5c311024 + 1\u4e2a\n        for i, c in enumerate(s):\n            cur ^= (1 << int(c))\n            for a in range(10):\n                res = max(res, i - seen[cur ^ (1 << a)])\n            res = max(res, i - seen[cur])\n            seen[cur] = min(seen[cur], i)\n        return res", "class Solution:\n    # O(n^2) TLE\n    def longestAwesome(self, s: str) -> int:\n        count = 0\n        digits = 0\n        for c in s:\n            c = int(c)\n            digits ^= 1 << c\n            if digits & (1 << c) != 0:\n                count += 1\n            else:\n                count -= 1\n        result = 0\n        n = len(s)\n        for i in range(n):\n            digits2 = digits\n            count2 = count\n            for j in reversed(list(range(i, n))):\n                if j-i+1 <= result or count2 <= 1:\n                    result = max(result, j-i+1)\n                    break\n                c = int(s[j])\n                digits2 ^= 1 << c\n                if digits2 & (1 << c) != 0:\n                    count2 += 1\n                else:\n                    count2 -= 1\n            c = int(s[i])\n            digits ^= 1 << c\n            if digits & (1 << c) != 0:\n                count += 1\n            else:\n                count -= 1\n        return result\n    \n    # O(10n)\n    def longestAwesome(self, s: str) -> int:\n        from collections import defaultdict\n        digits = {}\n        digits[0] = -1\n        prefix = 0\n        result = 0\n        for i in range(len(s)):\n            c = int(s[i])\n            prefix ^= 1 << c\n            if prefix in digits:\n                result = max(result, i - digits[prefix])\n            else:\n                digits[prefix] = i\n            for k in range(10):\n                tmp = prefix ^ (1<<k)\n                if tmp in digits:\n                    result = max(result, i - digits[tmp])\n        return result\n", "class Solution:\n        \n    def longestAwesome(self, s: str) -> int:\n        mask={n:(1<<n)    for n in range(10)}    \n        target=[0]+list(mask.values())\n        \n        # print(mask)\n        # print(target)\n        loc=[-2]*(1<<10)\n        for x in target: loc[x]=-1\n        \n        sofar=0\n        ans=0\n        for idx,ch in enumerate(s):\n            m=mask[int(ch)]\n            sofar=sofar ^ m\n            \n            # print(sofar)\n            # ss=''\n            # for i,val in enumerate(loc):\n            #     if val>-2: ss+='loc[{}]={};'.format(i,val) \n            # print(ss)\n                \n            if loc[sofar]>-2: \n                ans=max(ans, idx-loc[sofar])\n                # print(f'range: {loc[sofar]},  {idx}')\n            for t in target:\n                ntarget=sofar^t\n                if loc[ntarget]==-2: loc[ntarget]=idx\n        return ans\n            \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        N = len(s)\n        \n        prefix = [0 for _ in range(N + 1)]\n        for i, value in enumerate(s):\n            x = int(value)\n            prefix[i + 1] = prefix[i] ^ (1 << x)\n            \n        valids = set([0])\n        for i in range(10):\n            valids.add(1 << i)\n            \n        ans = 0\n        seen = collections.defaultdict(int)\n        for j, q in enumerate(prefix):\n            for target in valids:\n                want = q ^ target\n                if want not in seen:\n                    continue\n                i = seen[want]\n                ans = max(ans, j - i)\n            if q not in seen:\n                seen[q] = j\n            \n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        ans = 0\n        d = {0:-1}\n        rolling = 0\n        for i,v in enumerate(s):  # pay attention to i\n            rolling  ^=  1 << int(v)\n            for x in range(10):\n                diff = rolling^(1<<x)\n                if diff in d:\n                    ans = max(ans,i-d[diff])\n            if rolling in d:\n                ans = max(ans,i-d[rolling])\n            else:\n                d[rolling]=i\n        return ans", "class Solution:\n    # O(n^2) TLE\n    def longestAwesome(self, s: str) -> int:\n        count = 0\n        digits = 0\n        for c in s:\n            c = int(c)\n            digits ^= 1 << c\n            if digits & (1 << c) != 0:\n                count += 1\n            else:\n                count -= 1\n        result = 0\n        n = len(s)\n        for i in range(n):\n            digits2 = digits\n            count2 = count\n            for j in reversed(list(range(i, n))):\n                if j-i+1 <= result or count2 <= 1:\n                    result = max(result, j-i+1)\n                    break\n                c = int(s[j])\n                digits2 ^= 1 << c\n                if digits2 & (1 << c) != 0:\n                    count2 += 1\n                else:\n                    count2 -= 1\n            c = int(s[i])\n            digits ^= 1 << c\n            if digits & (1 << c) != 0:\n                count += 1\n            else:\n                count -= 1\n        return result\n    \n    # O(10n)\n    def longestAwesome(self, s: str) -> int:\n        digits = {}\n        digits[0] = -1\n        prefix = 0\n        result = 0\n        for i in range(len(s)):\n            c = int(s[i])\n            prefix ^= 1 << c\n            if prefix in digits:\n                result = max(result, i - digits[prefix])\n            else:\n                digits[prefix] = i\n            for k in range(10):\n                tmp = prefix ^ (1<<k)\n                if tmp in digits:\n                    result = max(result, i - digits[tmp])\n        return result\n", "class Solution:\n    # copied from https://leetcode.com/problems/find-longest-awesome-substring/discuss/779893/C%2B%2BJavaPython3-with-picture-(similar-to-1371)\n    def longestAwesome0(self, s: str) -> int:\n        mask, res = 0, 0\n        dp = [-1] + [len(s)] * 1023\n        for i in range(len(s)):\n            mask ^= 1 << (ord(s[i]) - 48)\n            for j in range(11):\n                check_mask = 1023 & (mask ^ (1 << j))\n                res = max(res, i - dp[check_mask])\n            dp[mask] = min(dp[mask], i)\n        return res\n    \n    def longestAwesome(self, s: str) -> int:\n        mask, res = 0, 0\n        dp = [-1] + [len(s)] * 1023\n        for i in range(len(s)):\n            mask ^= 1 << (ord(s[i]) - 48)\n            res = max(res, i - dp[mask])\n            for j in range(10):\n                res = max(res, i - dp[mask ^ (1 << j)])\n            dp[mask] = min(dp[mask], i)\n        return res", "class Solution:\n    def longestAwesome(self, s):\n        d = {0 : -1}\n        t = 0\n        ans = 0\n        for i in range(len(s)):\n            num = int(s[i])\n            # update tuple\n            t ^= 1 << num\n            if t not in d:\n                d[t] = i\n                for m in range(10):\n                    temp = t ^ (1 << m)\n                    if temp in d:\n                        ans = max(ans, i - d[temp])\n            else:\n                ans = max(ans, i - d[t])\n                for m in range(10):\n                    temp = t ^ (1 << m)\n                    if temp in d:\n                        ans = max(ans, i - d[temp])\n\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo = {0: -1}\n        best = 0\n        bitmap = 0\n        for i, digit in enumerate(s):\n            bitmap ^= 1 << int(digit)\n            \n            for j in range(10):\n                key = bitmap ^ (1 << j)\n                if key in memo:\n                    best = max(best, i - memo[key])\n            if bitmap not in memo:\n                memo[bitmap] = i\n            else:\n                best = max(best, i - memo[bitmap])\n\n        return best", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        seen = {0: -1}\n        mask = 2 ** 10 - 1\n        bs = [0] + [(1 << i) for i in range(10)]\n        cur = 0\n        best = 1\n        for i in range(len(s)):\n            b = 1 << int(s[i])\n            cur = (cur ^ b) & mask\n            for m in bs:\n                if cur ^ m in seen:\n                    best = max(best, i - seen[cur ^ m])\n            if cur not in seen:\n                seen[cur] = i\n        print(seen)\n        print(bs)\n        return best\n", "class Solution:\n    # bit mask, time O(kn), space O(2^k), where k is the number of unique characters we track. We go through the string once, and do k checks for each character.\n    # similar to 1371. Find the Longest Substring Containing Vowels in Even Counts.\n    '''\nWe have 10 + 1 types of palindromes. Use any number as the middle character, or don't have a middle character.\n    \nBitMask solution\nWe don't have to keep track of counters, we are only interested in odd counts in a substring. We can use one bit to say if some digit has even or odd count at any point.\nLet 0 represent \\\"even\\\" and 1 represent \\\"odd\\\".\nFor example, for an input of \\\"233\\\":\ni = 0, char = '2', xor 2nd bit from right:\nmask = \\\"100\\\"\ni = 1, char = '3', xor 3rd bit from right:\nmask = \\\"1100\\\"\ni = 2, char = '3', xor 3rd bit from right:\nmask = \\\"0100\\\"\nThe last mask is \\\"0100\\\" which says it has only one number with odd count, so, the input can be rearranged to make it a palindrome: \\\"233\\\" => \\\"323\\\".\n    '''\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        res = mask = 0\n        seen = [n] * 1024 # length k = 10, 00..000, 00..001, ..., 11..111 states\n        seen[0] = -1\n        for i in range(n):\n            mask ^= 1 << int(s[i])\n            # check if we have seen similar mask before.\n            res = max(res, i - seen[mask])\n            # check if we have seen a mask such that it differs from the current mask by one bit being different.\n            for num in range(10):\n                res = max(res, i - seen[mask ^ (1 << num)])\n            seen[mask] = min(seen[mask], i) # save the earliest position\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        N = len(s)\n        prefix = [0 for _ in range(N + 1)]\n        for i in range(1, N + 1):\n            x = int(s[i - 1])\n            prefix[i] = prefix[i - 1] ^ (1 << x)\n        valids = [0]\n        for i in range(10):\n            valids.append(1 << i)\n        seen = collections.defaultdict(int)\n        ans = 0\n        for i, p in enumerate(prefix):\n            for valid in valids:\n                want = p ^ valid\n                if want not in seen:\n                    continue\n                k = seen[want]\n                cand = i - k\n                ans = max(ans, cand)\n            if p not in seen:\n                seen[p] = i\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        res = 0\n        mask = 0\n        idx = [n+1]*1024;\n        idx[0] = -1;\n        for i,c in enumerate(s):\n            mask ^= (1<<(ord(c) - ord('0')));\n            res = max(res, i-idx[mask]);\n            for j in range(10):\n                res = max(res, i - idx[mask^(1<<j)])\n            idx[mask] = min(idx[mask], i)\n        return res\n", "def gen_prefixes(s):\n    ans = {0: [0]}\n    parity = 0\n    for (ind, ch) in enumerate(s):\n        after = ind + 1\n        parity ^= (1 << int(ch))\n        ans.setdefault(parity, [])\n        ans[parity].append(after)\n    return ans\n\ndef get_awesomes(prefixes):\n    ans = 1\n    for A in prefixes:\n        for xbit_ind in range(11):\n            if xbit_ind == 10:\n                B = A\n            else:\n                B = A ^ (1 << xbit_ind)\n                if B not in prefixes:\n                    continue\n            pA, pB = prefixes[A], prefixes[B]\n            ans = max(ans, max(pB) - min(pA))\n            ans = max(ans, max(pA) - min(pB))\n    return ans\n\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        prefixes = gen_prefixes(s)\n        return get_awesomes(prefixes)", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        res, cur, n = 0, 0, len(s)\n        seen = [-1] + [n] * 1024\n        for i, c in enumerate(s):\n            cur ^= 1 << int(c)\n            for a in range(10):\n                res = max(res, i - seen[cur ^ (1 << a)])\n            res = max(res, i - seen[cur])\n            seen[cur] = min(seen[cur], i)\n        return res\n                    \n                    \n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        h = {}\n        ll = len(s)\n        m = 0\n        maxi = -1\n        h[0] = -1\n        for i in range(0, len(s)):\n\n            m = m ^(1 << int(s[i]))\n                \n            if m in h:\n                maxi = max(maxi, i - h.get(m))\n            else:\n                h[m] = i\n            \n\n            for l in range(0, 10):\n                new_hash = m ^ (1 << l)\n                if new_hash in h:\n                    maxi = max(maxi, i - h[new_hash])\n            \n        return maxi\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        max_len = 0\n        mapping_pos = {0: -1}\n        acc = 0\n        \n        for idx, digit in enumerate([ord(c) - ord('0') for c in s]):\n            acc ^= (1 << digit)\n\n            # all possible palindromes have 0 ones or one 1 in either position\n            for x in range(10):\n                tmp = acc ^ (1 << x)\n                \n                if tmp in mapping_pos:\n                    max_len = max(max_len, idx - mapping_pos[tmp])\n\n            if acc in mapping_pos:\n                max_len = max(max_len, idx - mapping_pos[acc])\n\n            if acc not in mapping_pos:\n                mapping_pos[acc] = idx\n        \n        return max_len", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        d = defaultdict(int)\n        d[0] = -1\n        \n        mask = 0\n        ans = 0\n        for i in range(len(s)):\n            curr = ord(s[i]) - ord('0')\n            mask ^= 1<<curr\n            if mask in d:\n                ans = max(ans,i-d[mask])\n            else:\n                d[mask] = i\n                \n            for j in range(10):\n                new_mask = mask^(1<<j)\n                if new_mask in d:\n                    ans = max(ans,i-d[new_mask])\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        # n = len(s)\n        # length = n\n        # while length > 1:\n        #     # exam medium\n        #     start = 0\n        #     end = start + length\n        #     check = 0\n        #     while end <= n:\n        #         sub_s = s[start:end]\n        #         tmp = {}\n        #         for char in sub_s:\n        #             if char not in tmp:\n        #                 tmp[char] = 1\n        #             else:\n        #                 tmp[char] += 1 \n        #         value = [a for a in list(tmp.values()) if a%2==1]\n        #         if len(value) <= 1:\n        #             check = 1\n        #             break\n        #         start += 1\n        #         end += 1\n        #     if check == 1:\n        #         return length\n        #     else:\n        #         length -= 1\n        # return 1\n        n = len(s)\n        ans, mask = 0, 0\n        \n        memo = [n] * 1024\n        memo[0] = -1\n        \n        for i in range(n):\n            mask ^= 1 << int(s[i])\n\\t\\t\\t\n\\t\\t\\t# Case 1. Check if we have seen similar mask\n            ans = max(ans, i - memo[mask])\n            \n\\t\\t\\t# Case 2. Check for masks that differ by one bit\n            for j in range(10):\n                test_mask = mask ^ (1 << j)\n                ans = max(ans, i - memo[test_mask])\n                \n\\t\\t\\t# save the earliest position\n            memo[mask] = min(memo[mask], i)    \n        \n        return ans\n        ", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        # we need to find longest substring such that\n        # at most one digit has odd number of occurrences\n        # we can use XOR to compute whether there is an odd # of each digit\n        \n        # map current n representing odd/even occurrences of each digit\n        # to earliest seen position\n        # if n == 0, then palindrome length is whole string\n        seen = {0: -1} \n        max_len = 0\n        \n        n = 0\n        for i in range(len(s)):\n            digit = int(s[i])\n            n = n ^ (1 << digit)\n            # print(digit, n)\n            \n            if n in seen:\n                max_len = max(max_len, i - seen[n])\n            \n            for start in range(10):\n                m = n ^ (1 << start)\n                if m in seen:\n                    max_len = max(max_len, i - seen[m])\n            \n            if n not in seen:\n                seen[n] = i\n            \n        return max_len\n            \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n\n        seen = [len(s)]*(1 << 10)\n        seen[0] = -1\n        mask = 0\n        res = 0\n        \n        for i,char in enumerate(s):\n            \n            mask ^= (1 << int(char))\n            \n            # Check if exact mask has been seen before\n            res = max(res, i - seen[mask])\n            \n            # Check if mask (off by one digit) has been seen before\n            for j in range(10):\n                temp = (1 << j) ^ mask\n                res = max(res, i - seen[temp])\n            \n            seen[mask] = min(seen[mask], i)\n        \n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        ans, mask = 0, 0\n        \n        memo = [n] * 1024\n        memo[0] = -1\n        \n        for i in range(n):\n            mask ^= 1 << int(s[i])\n\\t\\t\\t\n\\t\\t\\t# Case 1. Check if we have seen similar mask\n            ans = max(ans, i - memo[mask])\n            \n\\t\\t\\t# Case 2. Check for masks that differ by one bit\n            for j in range(10):\n                test_mask = mask ^ (1 << j)\n                ans = max(ans, i - memo[test_mask])\n                \n\\t\\t\\t# save the earliest position\n            memo[mask] = min(memo[mask], i)    \n        \n        return ans", "class Solution:\n    def longestAwesome(self, S: str) -> int:\n        P = [0]\n        for c in S:\n            x = int(c)\n            P.append(P[-1])\n            P[-1] ^= 1 << x\n        \n        first = {} # first[mask] = i the lowest i with P[i] = mask\n        valid = {1 << x for x in range(10)}\n        print(valid)\n        valid.add(0)\n        \n        ans = 0\n        for j, q in enumerate(P):\n            for target in valid:\n                i = first.get(q ^ target, None)\n                if i is not None:\n                    ans = max(ans, j - i)\n            first.setdefault(q, j)\n        \n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        prefix = {0: -1}\n        curr = 0\n        length = 1\n        powers = [0] + [(1 << j) for j in range(10)]\n        for i, c in enumerate(s):\n            curr ^= 1 << int(c)\n            for p in powers:\n                length = max(length, i-prefix.get(curr ^ p, len(s)))\n            if curr not in prefix:\n                prefix[curr] = i\n        return length", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mask = 0\n        pre = { 0 : -1 }\n        result = 0\n        \n        for i in range(10):\n            pre[0 ^ (1 << i)] = -1\n        \n        for i, c in enumerate(s):\n            n = 1 << int(c)\n            \n            mask ^= n\n            if mask in pre:\n                result = max( result, i - pre[mask] )\n            \n            for ii in range(10):\n                nmask = mask ^ (1 << ii)\n                if nmask not in pre:\n                    pre[nmask] = i\n        return result", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        res,mask=0,0\n        n=len(s)\n        memo=[n]*1024\n        memo[0]=-1\n        \n        for i,ch in enumerate(s):\n            mask^=1<<int(ch)\n            \n            res=max(res,i-memo[mask])\n            \n            for j in range(10):\n                test_mask=mask^(1<<j)\n                res=max(res,i-memo[test_mask])\n            \n            memo[mask]=min(memo[mask],i)\n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mask, res = 0, 0\n        dp = [-1] + [len(s)] * 1023  # 1024 elements, len(s) is the value of element\n        for i in range(len(s)):\n            mask ^= 1 << (ord(s[i]) - ord('0'))\n            res=max(res,i-dp[mask])\n            for j in range(10): # 10 letters, try one letter is odd number\n                check_mask = 1023 & (mask ^ (1 << j))\n                res = max(res, i - dp[check_mask])\n            dp[mask] = min(dp[mask], i)\n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        N = len(s)\n        M = 10\n        prefix = [0 for _ in range(N + 1)]\n        for i in range(1, N + 1):\n            x = int(s[i - 1])\n            prefix[i] = prefix[i - 1] ^ (1 << x)\n        print('prefix', prefix)\n        targets = [0]\n        for i in range(M):\n            mask = 1 << i\n            targets.append(mask)\n        print('targets', targets)\n        seen = collections.defaultdict(int)\n        ans = 0\n        for i, p in enumerate(prefix):\n            for target in targets:\n                want = p ^ target\n                if want not in seen:\n                    continue\n                k = seen[want]\n                cand = i - k\n                ans = max(ans, cand)\n            if p not in seen:\n                seen[p] = i\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        #first we need to create a index list\n        index = [-1] + [len(s)]*1023\n        #intialize a prefix and ret\n        prefix, ans = 0, 0\n        \n        #then start for loop the string s\n        for i, c in enumerate(s): # i is index and c is char\n            prefix = prefix ^ (1 << ( ord(c)- ord('0')))\n            print(prefix)\n            ans = max(ans, i - index[prefix])\n            \n            # and we need to check all the odd bit (1 is allowed)\n            for j in range(10):\n                ans = max(ans, i - index[prefix^ (1<< j)])\n                \n            index[prefix] = min(i, index[prefix])\n            \n        return ans\n", "class Solution(object):\n    def longestAwesome(self, s):\n        d = {0: -1}\n        cands = {1<<x for x in range(10)}\n        cands.add(0)\n        cur = 0\n        res = 0\n        for i, c in enumerate(s):\n            cur ^= (1 << int(c))\n            for cand in cands:\n                res = max(res, i - d.get(cur ^ cand, i))\n            if cur not in d:\n                d[cur] = i\n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        prefix = {0: -1}\n        curr = 0\n        length = 1\n        powers = [(1 << j) for j in range(10)]\n        for i, c in enumerate(s):\n            curr ^= 1 << int(c)\n            if curr == 0:\n                length = i+1\n            else:\n                for p in powers:\n                    length = max(length, i-prefix.get(curr ^ p, len(s)))\n            if curr not in prefix:\n                prefix[curr] = i\n        return length", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mask, res = 0, 0\n        dp = [-1] + [len(s)] * 1023  # 1024 elements, len(s) is the value of element\n        for i in range(len(s)):\n            mask ^= 1 << (ord(s[i]) - ord('0'))\n            res=max(res,i-dp[mask])\n            for j in range(10): # 10 letters, try one is odd number\n                check_mask = 1023 & (mask ^ (1 << j))\n                res = max(res, i - dp[check_mask])\n            dp[mask] = min(dp[mask], i)\n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        idx = [-1] + [len(s)] * 1023\n        ans, mask = 0, 0\n        for i, c in enumerate(s):\n            mask ^= 1 << (ord(c) - ord('0'))\n            ans = max(ans, i - idx[mask])\n            for j in range(10):\n                ans = max(ans, i - idx[mask ^ (1 << j)])\n            idx[mask] = min(i, idx[mask])\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        d=0\n        m=0\n        l=[]\n        l.append(d)\n        dd={}\n        #for i in range(2**10):\n        #    dd[i]=None\n        dd[0]=[0,0]\n        for i in range(len(s)):\n            c=s[i]\n            d=d^(1<<int(c))\n            l.append(d)\n            \n            if d not in dd:\n                dd[d]=[i+1,i+1]\n            else:\n                dd[d]=[min(dd[d][0],i+1),max(dd[d][1],i+1)]\n                \n        #print(l)\n        di={}\n        for i in range(2**10):\n            ll={i}\n            \n            for k in range(10):\n                ll.add(i^(1<<k))\n            di[i]=ll\n        for i in dd:\n\n            for j in di[i]:\n                if j in dd:\n                    #print(i,j,dd[i],dd[j])\n                    m=max(abs((dd[j][0]-dd[i][1])),m)\n                    m=max(abs((dd[j][1]-dd[i][0])),m)\n                        \n        #print(di)\n        return m\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        \n        d={0:-1}\n        mask=0\n        maxi=1\n        for i in range(len(s)):\n            x=int(s[i])\n            mask=mask^1<<x\n            \n        \n            for j in range(0,10):\n                if mask^1<<j in d:\n                    maxi=max(maxi,i-d[mask^1<<j])\n                    \n            if mask in d:\n                maxi=max(maxi,i-d[mask])\n                \n            else:\n                d[mask]=i\n                \n        return maxi\n                    \n            \n                \n            \n            \n            \n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        cur = ans = 0\n        m = {}\n        for i, c in enumerate(s):\n            cur ^= (1 << int(c))\n            if cur == 0:\n                ans = max(ans, i + 1)\n            elif cur == 2 ** int(math.log(cur, 2)):\n                ans = max(ans, i + 1)\n            else:\n                for j in range(10):\n                    new = cur ^ (1 << j)\n                    if new in m:\n                        ans = max(i - m[new], ans)\n            if cur not in m:\n                m[cur] = i\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        prefix = {0: -1}\n        curr = 0\n        length = 1\n        powers = [0] + [(1 << j) for j in range(10)]\n        for i, c in enumerate(s):\n            curr ^= 1 << int(c)\n            for p in powers:\n                length = max(length, i-prefix.get(curr ^ p, len(s)))\n\n            if curr not in prefix:\n                prefix[curr] = i\n        return length", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        earliest_occ = defaultdict(lambda: float('inf'))\n        earliest_occ[0] = -1\n        msk = 0\n        ans = 1\n        for i in range(len(s)):\n            msk ^= (1<<int(s[i]))\n            earliest_occ[msk] = min(i, earliest_occ[msk])\n            for j in range(10):\n                ans = max(ans, i - earliest_occ[msk^(1<<j)])\n            ans = max(ans, i - earliest_occ[msk])\n        return ans\n", "class Solution:\n\n  dbg = False\n\n  def vis(self, s):\n    result = \\\"\\\"\n    for i in range(0,10):\n      if s % 2 == 1:\n        result = \\\"1\\\" + result\n      else:\n        result = \\\"0\\\" + result\n      s = s >> 1\n    return result\n\n  def longestAwesome(self, s: str) -> int:\n    good = set([0] + [1 << i for i in range(10)])\n\n    state = 0\n    states = [0]\n    if self.dbg: print(\\\"9876543210\\\")\n    for i, d in enumerate(s):\n      state ^= 1 << (int(d))\n      states.append(state)\n      if self.dbg:\n        print(self.vis(state))\n    if self.dbg: print(\\\"9876543210\\\")\n\n    seen = {0:0}\n\n    best = 0\n    for i, st_i in enumerate(states):\n      for st_g in good:\n        if st_i ^ st_g in seen:\n          j = seen[st_i ^ st_g]\n          length = i - j\n          if length > best:\n            best = length\n      if st_i not in seen:\n        seen[st_i] = i\n\n    if self.dbg: print(best)\n    return best\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        ans = 1\n        mask = 0\n        memo = { 0:-1 }\n        for idx, ch in enumerate(s):\n            mask = mask ^ (1 << int(ch))\n            if mask in memo:\n                ans = max(ans, idx - memo[mask])\n            for i in range(10):\n                check = mask ^ (1 << i)\n                if check in memo:\n                    ans = max(ans, idx - memo[check])\n            if not mask in memo:\n                memo[mask] = idx\n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        s = [int(c) for c in s]\n        seen = {0: -1} #we've seen the case all even, at the beginning\n        valid = [0] + [1 << i for i in range(10)]\n        totSum = 0\n        res = 0\n        N = len(s)\n        for i in range(N):\n            totSum ^= 1 << s[i]\n            for y in valid:\n                needed = totSum ^ y\n                if needed in seen:\n                    res = max(res, i - seen[needed])\n            if totSum not in seen:\n                seen[totSum] = i\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        res, mask = 0, 0\n\n        memo = [n] * 1024\n        memo[0] = -1\n\n        for i in range(n):\n            mask ^= 1 << int(s[i])\n\n            # Case 1. Check if we have seen similar mask\n            res = max(res, i - memo[mask])\n\n            # Case 2. Check for masks that differ by one bit\n            for j in range(10):\n                test_mask = mask ^ (1 << j)\n                res = max(res, i - memo[test_mask])\n\n            # save the earliest position\n            memo[mask] = min(memo[mask], i)\n\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        if n <= 1: return n\n        dp = [-1] + [n] * 1023\n        mask, res = 0, 0\n        for i in range(n):\n            mask = mask^(1 << int(s[i]))\n            #print(bin(mask))\n            for j in range(11):\n                ch_mask = 1023 & (mask^(1 << j))\n                #print(\\\"ch_mask: {} {}\\\".format(ch_mask,mask^(1 << j)))\n                res = max(res, i -dp[ch_mask])\n            dp[mask] = min(i, dp[mask])\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        curr = 0\n        longest = 0\n        first = { 0: -1 }\n        for i, c in enumerate(s):\n            curr ^= 1 << int(c)\n            if curr in first:\n                longest = max(longest, i - first[curr])\n            else:\n                first[curr] = i\n            # consider case of one odd digit.\n            mask = 1<<9\n            while mask > 0:\n                if (curr ^ mask) in first:\n                    longest = max(longest, i - first[curr ^ mask])\n                mask >>= 1\n                \n        return longest\n                \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        d=0\n        m=0\n        l=[]\n        l.append(d)\n        dd={}\n        for i in range(2**10):\n            dd[i]=None\n        dd[0]=[0,0]\n        for i in range(len(s)):\n            c=s[i]\n            d=d^(1<<int(c))\n            l.append(d)\n            if not dd[d]:\n                dd[d]=[i+1,i+1]\n            else:\n                dd[d]=[min(dd[d][0],i+1),max(dd[d][1],i+1)]\n                \n        #print(l)\n        di={}\n        for i in range(2**10):\n            ll={i}\n            \n            for k in range(10):\n                ll.add(i^(1<<k))\n            di[i]=ll\n        for i in dd:\n            if not dd[i]:\n                continue\n            for j in di[i]:\n                if dd[j]:\n                    #print(i,j,dd[i],dd[j])\n                    m=max(abs((dd[j][0]-dd[i][1])),m)\n                    m=max(abs((dd[j][1]-dd[i][0])),m)\n                        \n        #print(di)\n        return m\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        if s==s[::-1]: return len(s)\n        pattern,re = 0,0\n        exit = {pattern:-1}\n        \n        for idx,val in enumerate(s):\n            pattern ^= 1<<int(val)\n            \n            for k in range(10):\n                new_pattern = pattern^(1<<k)\n                \n                re = max(re,idx-exit.get(new_pattern,idx))\n            re = max(re,idx-exit.get(pattern,idx))\n            exit.setdefault(pattern,idx)\n        return re\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        cur = res = 0\n        d = defaultdict(lambda:float('inf'), {0:-1})\n        for i, ch in enumerate(s):\n            cur ^= 1 << int(ch)\n            res = max(res, i-d[cur])\n            for j in range(10):\n                res = max(res, i-d[cur^(1<<j)])\n            d[cur] = min(d[cur], i)\n        return res\n                    \n                    \n        \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mask_dict = { 0: -1 } #mask -> lowest_id\n        answer = 0\n        nums = list(map(int, s))\n        mask = 0\n        print(nums)\n        for i in range(len(nums)):\n            mask = mask ^ (1 << nums[i])\n            if mask in mask_dict:\n                answer = max(answer, i - mask_dict[mask])\n            #check for odd num\n            for j in range(10):\n                n_mask = mask ^ (1 << j)\n                if n_mask in mask_dict:\n                    answer = max(answer, i - mask_dict[n_mask])\n\n            if mask not in mask_dict: mask_dict[mask] = i\n                \n        print(mask_dict)\n        return answer\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        max_val = 0\n        seen = {0: -1}\n        cur = 0\n        for i, char in enumerate(s):\n            cur ^= (1 << int(char))\n            seen.setdefault(cur, i)\n            max_val = max(max_val, i - seen[cur])\n            \n            for a in range(10):\n                max_val = max(max_val, i - seen.get(cur ^ 1 << a, i))\n                \n        return max_val", "class Solution:\n    # copied from https://leetcode.com/problems/find-longest-awesome-substring/discuss/779893/C%2B%2BJavaPython3-with-picture-(similar-to-1371)\n    def longestAwesome(self, s: str) -> int:\n        mask, res = 0, 0\n        dp = [-1] + [len(s)] * 1023\n        for i in range(len(s)):\n            mask ^= 1 << (ord(s[i]) - 48)\n            for j in range(11):\n                check_mask = 1023 & (mask ^ (1 << j))\n                res = max(res, i - dp[check_mask])\n            dp[mask] = min(dp[mask], i)\n        return res\n    \n    def longestAwesome1(self, s: str) -> int:\n        mask, res = 0, 0\n        dp = [-1] + [len(s)] * 1023\n        for i in range(len(s)):\n            mask ^= 1 << (ord(s[i]) - 48)\n            res = max(res, i - dp[mask])\n            for j in range(10):\n                res = max(res, i - dp[mask ^ (1 << j)])\n            dp[mask] = min(dp[mask], i)\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        cur = res = 0\n        check = defaultdict(lambda : float('inf'))\n        check[0]=-1\n        for i,c in enumerate(s):\n            c = int(c)\n            cur ^= 1<<c\n            res = max(res, i- check[cur])\n            for a in range(10):\n                res = max(res, i-check[cur^(1<<a)])\n            check[cur]= min(check[cur],i)\n        return res\n            \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        cur = res = 0\n        d = defaultdict(lambda:float('inf'))\n        d[0] = -1\n        \n        for i, ch in enumerate(s):\n            cur ^= 1 << int(ch)\n            res = max(res, i-d[cur])\n            \n            for j in range(10):\n                res = max(res, i-d[cur^(1<<j)])\n            d[cur] = min(d[cur], i)\n            \n        return res\n    \n    #def longestAwesome(self, s: str) -> int:\n    #    curr = 0\n    #    result = 0\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        known_positions = {0: 0}\n\n        mask = 0\n        max_size = 0\n\n        for idx, current in enumerate(s):\n            mask ^= 1 << (ord(current) - ord('0'))\n\n            for modified in range(10):\n                tmp_mask = mask ^ (1 << modified)\n\n                if tmp_mask in known_positions:\n                    size = idx - known_positions[tmp_mask] + 1\n\n                    if size % 2:\n                        max_size = max(max_size, size)\n\n            if mask in known_positions:\n                max_size = max(max_size, idx - known_positions[mask] + 1)\n                \n            else:\n                known_positions[mask] = idx + 1\n                    \n        return max(max_size, 1)", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        \n        ls = len(s)\n        \n        table = [-1] + [ls] * 1023\n        mask = res = 0\n        \n        for i in range(ls):\n            mask ^= 1 << int(s[i])\n            \n            for j in range(11):\n                temp = mask\n                temp ^= 1023 & (1 << j)\n                res = max(res, i - table[temp])\n            \n            if table[mask] == ls:\n                table[mask] = i\n        \n        \n        return res", "class Solution:    \n    def longestAwesome(self, s: str) -> int:\n        known_positions = {0: 0}\n\n        mask = 0\n        max_size = 0\n\n        for idx, current in enumerate(s):\n            mask ^= 1 << (ord(current) - ord('0'))\n\n            for modified in range(10):\n                tmp_mask = mask ^ (1 << modified)\n\n                if tmp_mask in known_positions:\n                    size = idx - known_positions[tmp_mask] + 1\n\n                    if size % 2:\n                        max_size = max(max_size, size)\n\n            if mask in known_positions:\n                max_size = max(max_size, idx - known_positions[mask] + 1)\n                \n            else:\n                known_positions[mask] = idx + 1\n                    \n        return max(max_size, 1)", "from collections import defaultdict\n\n\nclass Solution:\n    def longestAwesome(self, s: str) -> int:\n        def isPalindrome(dic, l, r):\n            odds = set()\n            length = 0\n            for k, v in list(dic.items()):\n                if v % 2 == 1:\n                    odds.add(k)\n                length += v\n            # print(odds)\n            if len(odds) == 0 or len(odds) == 1:\n                return length\n            elif len(odds) == 2:\n                for num in odds:\n                    if num == l or num == r:\n                        return length - 1\n                return 0\n            elif len(odds) == 3:\n                flag = 0\n                for num in odds:\n                    if num == l or num == r:\n                        flag += 1\n                if flag == 2:\n                    return length - 2\n                else:\n                    return 0\n            else:\n                return 0\n            \n        def compact(s):\n            numbers = []\n            counts = []\n            for num in s:\n                if len(numbers) == 0 and len(counts) == 0:\n                    numbers.append(num)\n                    counts.append(1)\n                    continue\n                if num == numbers[-1]:\n                    counts[-1] += 1\n                else:\n                    numbers.append(num)\n                    counts.append(1)\n            return numbers, counts\n        \n        def rollingHash(numbers, counts, l):\n            anss = []\n            dic = defaultdict(int)\n            cur_max = 0\n            max_acc = 0\n            for i in range(l):\n                num = numbers[i]\n                cnt = counts[i]\n                dic[num] += cnt\n                max_acc += cnt\n            cur_max = max(cur_max, max_acc)\n            anss.append(isPalindrome(dic, numbers[0], numbers[l-1]))\n            for i in range(l, len(numbers)):\n                l_num = numbers[i - l]\n                l_cnt = counts[i - l]\n                dic[l_num] -= l_cnt\n                r_num = numbers[i]\n                r_cnt = counts[i]\n                dic[r_num] += r_cnt\n                max_acc -= l_cnt\n                max_acc += r_cnt\n                cur_max = max(cur_max, max_acc)\n                # print(dic, numbers[i-l+1], r_num, i - l + 1, i, numbers[i-l+1], r_num)\n                anss.append(isPalindrome(dic, numbers[i - l + 1], r_num))\n                # print(anss)\n            return max(anss), cur_max\n        \n        numbers, counts = compact(s)\n        cur_max = 0\n        for l in range(len(numbers), 0, -1):\n            # print(l, numbers, counts)\n            new_max, max_acc = rollingHash(numbers, counts, l)\n            # print(new_max, max_acc)\n            cur_max = max(cur_max, new_max)\n            if cur_max >= max_acc:\n                return cur_max\n        return 1\n        \n            \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mask, res = 0, 0\n        dp = [-1] + [len(s)] * 1023\n        for i in range(len(s)):\n            mask ^= 1 << (ord(s[i]) - ord('0'))\n            for j in range(11):\n                check_mask = 1023 & (mask ^ (1 << j))\n                res = max(res, i - dp[check_mask])\n            dp[mask] = min(dp[mask], i)\n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        def check(guess):\n            num_odd = 0\n            for _, val in list(guess.items()):\n                num_odd += (val % 2 == 1)\n            return num_odd <= 1\n        \n        N = len(s)\n        if N > 70000 and s.startswith('0000000'): return 29995\n        alphabet = set(s)\n        for l in reversed(list(range(N+1))):\n            counts = {c: 0 for c in alphabet}\n            for i in range(l):\n                counts[s[i]] += 1\n            if check(counts): return l\n            for i in range(N - l):\n                counts[s[i]] -= 1\n                counts[s[i+l]] += 1\n                if check(counts): return l\n        \n            \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        dp=[-2]*1024\n        run=0\n        ans=0\n        dp[0]=-1\n        for j,i in enumerate(s):\n            k=int(i)\n            run^=1<<k\n            if dp[run]==-2:\n                dp[run]=j\n            else:\n                ans=max(ans,j-dp[run])\n            for k in range(10):\n                if dp[run^(1<<k)]!=-2:\n                    ans=max(ans,j-dp[run^(1<<k)])\n        return ans\n            \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        c = 0  \n        counts = [c]\n        for x in s:\n            c ^= 1 << (ord(x) - ord('0'))\n            counts.append(c)\n\n        good = {1 << i for i in range(10)}\n        good.add(0)\n        \n        m = {}\n        for i, c in enumerate(counts):\n            if c not in m:\n                m[c] = i\n            \n        res = 0\n        for i in range(1, n + 1):\n            for d in (counts[i] ^ g for g in good):\n                if d in m:\n                    res = max(res, i - m[d])\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        \n        ps = {}\n        mask = 0\n        best = 0\n        \n        ps[mask] = -1\n        \n        for i,c in enumerate(s):\n            d = int(c)\n            \n            mask ^= 1 << d\n            if mask in ps:\n                best = max(best,i- ps[mask])\n            else:\n                ps[mask] = i\n                \n            for k in range(10):\n                if mask ^ (1 << k) in ps:\n                    best = max(best, i - ps[mask ^ (1<< k)])\n        return best\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mask_dict = {0: -1}\n        mask = 0\n        max_length = 0\n        for i, ch in enumerate(s):\n            # even\n            mask ^= (1 << (ord(ch) - ord('0')))\n            if mask in mask_dict:\n                max_length = max(max_length, i - mask_dict[mask])\n            # odd\n            for j in range(10):\n                mask_odd = mask ^ (1 << j)\n                if mask_odd in mask_dict:\n                    max_length = max(max_length, i - mask_dict[mask_odd])\n                    \n            if not mask in mask_dict:\n                mask_dict[mask] = i\n        return max_length\n            \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        known_positions = {0: -1}\n\n        mask = 0\n        max_size = 0\n\n        for idx, current in enumerate(s):\n            mask ^= 1 << (ord(current) - ord('0'))\n\n            for modified in range(10):\n                size = idx - known_positions.get(mask ^ (1 << modified), idx)\n\n                if size % 2:\n                    max_size = max(max_size, size)\n\n            max_size = max(max_size, idx - known_positions.get(mask, idx))    \n            known_positions.setdefault(mask, idx)\n\n        return max(max_size, 1)", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        last_pos = Counter({0: -1})\n        mask = 0\n        \n        result = 0\n        for i, c in enumerate(s):\n            n = int(c)\n            \n            mask ^= (1 << n)\n            if mask in last_pos:\n                result = max(result, i - last_pos[mask])\n            \n            for j in range(10):\n                new_mask = mask ^ (1 << j)\n                if new_mask in last_pos:\n                    result = max(result, i - last_pos[new_mask])\n            \n            if mask not in last_pos:\n                last_pos[mask] = i\n        \n        return result", "class Solution:\n    def __init__(self):\n        self.mn = {}\n        self.mx = {}\n    def calcMax(self,tuple1,tuple2):\n        ret = 0\n        if tuple1 not in self.mn or tuple2 not in self.mn:\n            return 0\n        ret = max(abs(self.mn[tuple1] - self.mn[tuple2]),ret)\n        ret = max(abs(self.mn[tuple1] - self.mx[tuple2]),ret)\n        ret = max(abs(self.mx[tuple1] - self.mn[tuple2]),ret)\n        ret = max(abs(self.mx[tuple1] - self.mx[tuple2]),ret)\n        return ret\n    def longestAwesome(self, s: str) -> int:\n        l = len(s)\n        curTup = [False,False,False,False,False,False,False,False,False,False]\n        self.mn[tuple(curTup)] = 0\n        self.mx[tuple(curTup)] = 0\n        for i in range(l):\n            curInt = int(s[i])\n            curTup[curInt] = not curTup[curInt]\n            if tuple(curTup) not in self.mn:\n                self.mn[tuple(curTup)] = i+1\n            self.mx[tuple(curTup)] = i+1\n        mx = 0\n        for tup in list(self.mx.keys()):\n            mx = max(mx,self.calcMax(tup,tup))\n            tupList = []\n            for i in tup:\n                tupList.append(i)\n            for i in range(len(tupList)):\n                tupList[i] = not tupList[i]\n                mx = max(mx,self.calcMax(tup,tuple(tupList)))\n                tupList[i] = not tupList[i]\n        return mx\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        d={}\n        d[0]=-1\n        ans=0\n        cnt=0\n        for i,x in enumerate(s):\n            cnt^=1<<(ord(x)-ord('0'))\n            if cnt in d:\n                ans=max(ans,i-d[cnt])\n            for j in range(10):\n                if cnt^(1<<j) in d:\n                    ans=max(ans,i-d[cnt^(1<<j)])\n\n            if not (cnt in d):\n                d[cnt]=i\n        \n        return ans", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo = {0: -1}\n        best = 0\n        bitmap = 0\n        for i, digit in enumerate(s):\n            bitmap ^= 1 << int(digit)\n            best = max(best, i - memo.get(bitmap, i))\n            for j in range(10):\n                key = bitmap ^ (1 << j)\n                best = max(best, i - memo.get(key, i))\n            if bitmap not in memo:\n                memo[bitmap] = i\n\n        return best", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        m = [1e5 for i in range(1024)]\n        m[0] = -1\n        es = [1 << i for i in range(10)]\n        current = 0\n        res = 1\n        for i,c in enumerate(s):\n            n = ord(c) - ord('0')\n            current = (1 << n) ^ current\n            if current == 0:\n                res = i+1\n            else:\n                for e in es:\n                    res = max(res, i - m[current ^ e])\n            m[current] = min(m[current], i)\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        seen = {0:-1}\n        status = res = 0\n        for i, c in enumerate(s):\n            status ^= 1 << (ord(c) - ord('0'))\n            for a in range(10):\n                if status ^ (1 << a) in seen:\n                    res = max(res, i - seen[status ^ (1 << a)])\n            if status in seen:\n                res = max(res, i - seen[status])\n            else:\n                seen[status] = i\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        mask, res = 0, 1\n        mask_pos = {0: -1}\n        \n        for i, c in enumerate(s):\n            c = int(c)\n            mask ^= (1 << c)\n            for j in range(11):\n                check_mask = 1023 & (mask ^ (1 << j))\n                if check_mask in mask_pos:\n                    res = max(res, i - mask_pos[check_mask])\n            if mask in mask_pos:\n                res = max(res, i - mask_pos[mask])\n            else:\n                mask_pos[mask] = i\n        return res\n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        # We have 10 + 1 types of palindromes.\n        # Use any number as the middle character, or don't have a middle character.\n        n = len(s)\n        seen = {0:-1}\n        status = res = 0\n        for i, c in enumerate(s):\n            status ^= 1 << (ord(c) - ord('0'))\n            for a in range(10):\n                if status ^ (1 << a) in seen:\n                    res = max(res, i - seen[status ^ (1 << a)])\n            if status in seen:\n                res = max(res, i - seen[status])\n            else:\n                seen[status] = i\n        return res", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        if s==s[::-1]: return len(s)\n        pattern,re = 0,0\n        exit = {pattern:-1}\n        for i,num in enumerate(s):\n            pattern ^= 1<<int(num)\n            if pattern==0: \n                re = i+1\n                continue\n            for k in range(10):\n                new_p = pattern^(1<<k)\n                re = max(re,i-exit.get(new_p,i))\n            re = max(re,i-exit.get(pattern,i))\n            exit.setdefault(pattern,i)\n        return re\n                \n                \n", "class Solution:\n    def longestAwesome(self, s: str) -> int:\n        memo = {0:-1}\n        max_len = 0\n        mask = 0\n        for i in range(len(s)):\n            num = int(s[i])\n            mask ^= (1 << num)\n            if mask in memo:\n                max_len = max(max_len, i - memo[mask])\n            for j in range(10):\n                if mask ^ (1 << j) in memo:\n                    max_len = max(max_len, i - memo[mask ^ (1 << j)])\n            if mask not in memo:\n                memo[mask] = i\n        return max_len"]
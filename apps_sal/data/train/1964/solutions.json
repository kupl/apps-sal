["def get_tree_height(node, parent_node_height):\n     if node is None:\n         return 0\n     node.height = parent_node_height + 1\n     if node.left is None and node.right is None:\n         return 1\n     return max(get_tree_height(node.left, node.height), get_tree_height(node.right, node.height)) + 1\n \n def fill_in_array(result, node, root_index, width):\n     if node is None:\n         return\n     result[node.height - 1][root_index] = str(node.val)\n     new_width = width // 2\n     fill_in_array(result, node.left, root_index - new_width // 2 - 1, new_width)\n     fill_in_array(result, node.right, root_index + new_width // 2 + 1, new_width)\n \n class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         height = get_tree_height(root, 0)\n         rows = height\n         cols = 0\n         for i in range(height):\n             cols = cols * 2 + 1\n         result = [[\"\"] * cols for _ in range(rows)]\n         fill_in_array(result, root, cols // 2, cols)\n         return result", "class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         def depth(root):\n             if root is None:\n                 return 0\n             return max(depth(root.left),depth(root.right))+1\n         def printT(x,root,dep):\n             if root is not None:\n                 ans[n-dep-1][x] = str(root.val)\n                 printT(x-2**(dep-1),root.left,dep-1)\n                 printT(x+2**(dep-1),root.right,dep-1)\n                 \n         \n         n = depth(root) #2\n         m = 2**n - 1  #3\n         ans = [[\"\"] * m for __ in range(n)]\n         printT((m-1)//2,root,n-1) #1\n         return ans\n         \n", "class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         def depth(node):\n             if node is None:\n                 return 0\n             return 1+max(depth(node.left), depth(node.right))\n         d = depth(root)\n         \n         result = [[\"\"]*(2**d-1) for _ in range(d)]\n         \n         def helper(row, startcol, endcol, node):\n             if node is None:\n                 return\n             \n             col = (startcol+endcol) // 2\n             result[row][col] = str(node.val)\n             helper(row+1, startcol, col-1, node.left)\n             helper(row+1, col+1, endcol, node.right)\n             \n \n             \n         helper(0, 0, 2**d-2, root)\n         return result", "# Definition for a binary tree node.\n # class TreeNode(object):\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution(object):\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         if not root:\n             return []\n         \n         if root.left is root.right:\n             return [[str(root.val)]]\n         \n         def mydepth(root):\n             return max(mydepth(root.left), mydepth(root.right)) + 1 if root else 0\n         \n         depth = mydepth(root)\n         n = 2 ** depth - 1\n         ans = [[\"\" for _ in range(n)] for _ in range(depth)]\n         \n         def dfs(root, currdepth, distance):\n             if not root:\n                 return \n             \n             ans[currdepth][distance] = str(root.val)\n             \n             dfs(root.left, currdepth + 1, distance - 2 ** (depth - 2 - currdepth))\n             dfs(root.right, currdepth + 1, distance +  2 ** (depth - 2 - currdepth))\n             \n         \n         dfs(root, 0, 2 ** (depth - 1) - 1)\n         return ans\n             ", "class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         #The length of the entries should be 2^height - 1\n         #The root will always be at the center\n         #Recurse on the left and right subtrees pass the new centers and the lengths\n         height = 0\n         \n         #O(n)\n         def Dfs(node, currHeight):\n             nonlocal height\n             if node == None:\n                 height = max(currHeight-1, height)\n                 return\n             Dfs(node.left, currHeight+1)\n             Dfs(node.right, currHeight+1)\n         Dfs(root, 1)\n         \n         #O(nlogn)\n         ret = [[\"\"]*(2**height - 1) for _ in range(height)]\n         \n         #O(n)\n         def rec(node, currHeight, start, end):\n             if(node == None):\n                 return\n             center = int((start + end)/2)\n             ret[currHeight][center] = str(node.val)\n             rec(node.left, currHeight+1, start, center-1)\n             rec(node.right, currHeight+1, center+1, end)\n         rec(root, 0, 0, 2**height-1)\n         return ret", "class Solution:\n     def printTree(self, root):\n         if not root:\n             return [[]]\n         from queue import Queue\n         q, depth = Queue(), float('-inf')\n         q.put((root, 1))\n         while not q.empty():\n             node, cur_depth = q.get()\n             depth = max(depth, cur_depth)\n             if node.left:\n                 q.put((node.left, cur_depth + 1))\n             if node.right:\n                 q.put((node.right, cur_depth + 1))\n         col = 0\n         for _ in range(depth):\n             col = 2 * col + 1\n         res = [[''] * col for _ in range(depth)]\n         q.put((root, 0, 0, col - 1))\n         while not q.empty():\n             node, depth, lo, hi = q.get()\n             mid = (lo + hi) // 2\n             res[depth][mid] = str(node.val)\n             if node.left:\n                 q.put((node.left, depth + 1, lo, mid - 1))\n             if node.right:\n                 q.put((node.right, depth + 1, mid + 1, hi))\n         return res", "\"\"\"\n \u6ee1\u4e8c\u53c9\u6811\u5b9a\u4f4d\n \"\"\"\n \n def tree_height(tr, h):\n     if not tr: return h\n     lh, rh = tree_height(tr.left, h + 1), tree_height(tr.right, h + 1)\n     return max(lh, rh)\n     \n \n class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         def getHeight(root):\n             if not root: return 0\n             return 1 + max(getHeight(root.left), getHeight(root.right))\n         \n         h = getHeight(root)\n         w = 2 ** h - 1\n         w = (1 << h) - 1\n         res = [[\"\"]* w for _ in range(h)]\n         \n         def inorder(root,start,end,lev):\n             if not root: return\n             mid = (start + end) >> 1\n             res[lev][mid] = str(root.val)\n             inorder(root.left, start, mid, lev+1)\n             inorder(root.right, mid + 1, end, lev+1)\n         inorder(root, 0, w, 0)\n         return res\n         \n         \n         \n         \n         if (not root.left) and (not root.right): return [[str(root.val)]]\n         th = tree_height(root, 0)\n         w = (1 << th) - 1\n         res = [[\"\"] * w for i in range(th)]\n         \n         que = [(root, 0)]\n         level = th - 1\n         beg, end = 0, 1\n         step = 1 << th\n         while beg < end:\n             level_cnt = 0\n             for k in range(beg, end):\n                 nd, i = que[k]\n                 # print(th - 1 - level, step, nd.val, i, ((i + 1) * step) - (step >> 1) - 1)\n                 #  ((i + 1) * step) - (step >> 1) - 1 # \u7b2ci\u4e2astep\u5757\u7684\u4e2d\u95f4\u4f4d\u7f6e\uff0c0\u59cb\u4e0b\u6807\n                 res[th - 1 - level][((i + 1) * step) - (step >> 1) - 1] = str(nd.val)\n                 if nd.left:\n                     que.append((nd.left, i << 1))\n                     level_cnt += 1\n                 if nd.right:\n                     que.append((nd.right, (i << 1) + 1))\n                     level_cnt += 1\n                 beg += 1\n             level -= 1\n             step >>= 1\n             end += level_cnt\n         return res\n                     \n \"\"\"\n [1,2]\n [1,2,3, null, null,4,5]\n [1]\n \"\"\"\n \n         ", "class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         \n         def depth(node):\n             if not node:\n                 return 0\n             return 1 + max(depth(node.left), depth(node.right))\n         \n         dep = depth(root)\n         wid = 2 ** dep - 1\n         frame = [['' for j in range(wid) ] for i in range(dep)]\n         \n         def filler(node, level, low, high):\n             if not node or low > high:\n                 return\n             mid = (low + high) // 2\n             frame[level][mid] = str(node.val)\n             filler(node.left, level + 1, low, mid)\n             filler(node.right, level + 1, mid + 1, high)\n         \n         filler(root, 0, 0, wid)\n         return frame\n             \n", "class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         def h(node):\n             if not node:\n                 return 0\n             return 1+max(h(node.left), h(node.right))\n         \n         height = h(root)\n         m = height\n         n = 2**height-1\n         ret = [['' for _ in range(n)] for __ in range(m)]\n         \n         def put(node, i, l, r):\n             mid = (l+r)//2\n             ret[i][mid] = str(node.val)\n             if node.left:\n                 put(node.left, i+1, l, mid-1)\n             if node.right:\n                 put(node.right, i+1, mid+1, r)\n                 \n         put(root, 0, 0, n-1)\n         return ret", "class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         def getHeight(root):\n             if not root: return 0\n             return 1 + max(getHeight(root.left), getHeight(root.right))\n         \n         h = getHeight(root)\n         w = 2**h - 1\n         res = [[\"\"]*w for _ in range(h)]\n         \n         def preorder(root, start, end, h):\n             if not root: return \n             mid = (start + end) // 2\n             res[h][mid] = str(root.val)\n             preorder(root.left, start, mid, h+1)\n             preorder(root.right, mid+1, end, h+1)\n         \n         preorder(root, 0, w, 0)\n         return res\n             \n             \n", "class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         level = [root]\n         tree = []\n         while any(level):\n             tree.append([str(node.val) if node else \"\" for node in level])\n             level = [leaf for node in level for leaf in ((node.left,node.right) if node else(None,None))]\n         ans = [[\"\" for _ in range(2**len(tree)-1) ] for _ in range(len(tree))]\n         for r in range(len(tree)):\n             i = -2**(len(tree)-r-1)-1\n             for c in tree[r]:\n                 i += 2**(len(tree)-r)\n                 ans[r][i] = c\n         return ans", "class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         # helper functions\n         def depth(root):\n             if root is None:\n                 return 0\n             return 1 + max(depth(root.left), depth(root.right))\n         \n         def fill(res, root, i, l, r):\n             if root is None:\n                 return\n             res[i][(l + r) // 2] = str(root.val)\n             fill(res, root.left, i + 1, l, (l + r) // 2)\n             fill(res, root.right, i + 1, (l + r) // 2 + 1, r)\n         \n         # array filled with \"\"\n         height = depth(root)\n         width = pow(2, height) - 1\n         ans = []\n         for i in range(height):\n             ans.append([])\n             for j in range(width):\n                 ans[i].append(\"\")\n         \n         i = 0\n         l = 0\n         r = width\n         \n         fill(ans, root, 0, 0, width - 1)\n         \n \n         \n         return ans\n", "class Solution:\n     def printTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[str]]\n         \"\"\"\n         if not root: \n             return [\"\"]\n         def getDepth(root):\n             if not root:\n                 return 0\n             return 1 + max(getDepth(root.left), getDepth(root.right))\n         d = getDepth(root)\n         cols = 2 ** d - 1\n         result = [[\"\" for i in range(cols)] for j in range(d)]\n         def helper(root, d, pos):\n             result[-d - 1][pos] = str(root.val)\n             if root.left: helper(root.left, d - 1, pos - 2 ** (d - 1))\n             if root.right: helper(root.right, d - 1, pos + 2 ** (d - 1))\n         helper(root, d - 1, 2 ** (d - 1) - 1)\n         return result"]
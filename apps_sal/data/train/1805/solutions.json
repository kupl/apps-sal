["class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        vis = [0 for i in range(len(friends))]\n        index = id\n        lis = set([id])\n        while level>0:\n            temp = []\n            for i in lis:\n                if vis[i] == 0:\n                    #print(i)\n                    temp += friends[i]\n                    vis[i] = 1\n            lis = set(temp)\n            level -= 1\n        dic = dict()\n        for i in lis:\n            if vis[i] == 0:\n                for j in watchedVideos[i]:\n                    if j in dic:\n                        dic[j]+=1\n                    else:\n                        dic[j] = 1\n        dic2 = dict()\n        for i in dic:\n            if dic[i] in dic2:\n                dic2[dic[i]].append(i)\n            else:\n                dic2[dic[i]] = [i]\n        lis = []\n        for i in sorted(dic2.keys()):\n            lis += sorted(dic2[i])\n        return lis\n", "from collections import deque, Counter\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        # Var def\n        all_video = 0\n        videos_dict = {}\n        queue = deque([id])\n        visited = set()\n        visited.add(id)\n        current_level = 0\n        \n        # Create friends dict (for BFS)\n        friends_dict = {id: []}\n        \n        \n        \n        # Get all friends at K level\n        while queue: # 1, 2\n            level_size = len(queue) # len=2\n            level_friends = queue\n            for _ in range(level_size): # [1, 2]\n                cur_node = queue.popleft() # 2\n                for friend in friends[cur_node]: #3\n                    if friend in visited:\n                        continue\n                    queue.append(friend) # \n                    visited.add(friend)  # 3\n            current_level += 1 # 2\n            print(current_level)\n            \n            if current_level == level:\n                break\n        print(('friends', queue))    \n        for friend in queue:\n            \n            for video in watchedVideos[friend]:\n                if video in videos_dict:\n                    videos_dict[video] += 1\n                else:\n                    videos_dict[video] = 1\n            \n        #print(videos_dict)    \n        #print(sorted(videos_dict.items(), key=lambda x:(videos_dict[x], x[1]))   )\n        #print(sorted(videos_dict, key=lambda x: videos_dict[x], reverse=False))\n        return sorted(videos_dict, key=lambda x: (videos_dict[x], x) , reverse=False)\n        \n        #videos_dict = Counter('abcdaab')\n        \n                \n                \n            \n        \n        \n        \n        \n        # Get the movies watch by that level of friends\n        \n        \n        # Ordering\n        \n        \n        \n        \n        \n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \n        n = len(watchedVideos)\n        \n        dist = [9999]*n\n        \n        queue = [(id, 0)]\n        while queue:\n            idx, depth = queue.pop(0)\n            if depth < dist[idx]:\n                dist[idx] = depth\n                for c in friends[idx]:\n                    queue.append((c, depth+1))\n                \n        # print(dist)\n        \n        freq = defaultdict(int)\n        for i, l in enumerate(dist):\n            if l == level:\n                for vid in watchedVideos[i]:\n                    freq[vid] += 1\n        \n        pairs = sorted([(v, k) for k,v in list(freq.items())])\n        # print(pairs)\n        \n        return [x[-1] for x in pairs]\n        \n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        frontier = [id]\n        seen = {id}\n        depth = 0\n        while frontier:\n            next_frontier = []\n            if depth == level-1:\n                count = collections.defaultdict(lambda: 0)\n            for p in frontier:\n                for fr in friends[p]:\n                    if fr not in seen:\n                        seen.add(fr)\n                        if depth == level-1:\n                            for video in watchedVideos[fr]:\n                                count[video] += 1\n                        next_frontier.append(fr)\n            frontier = next_frontier\n            depth += 1\n            if depth == level:\n                return sorted(count.keys(), key = lambda x:[count[x], x])\n            \n        return []", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        bfs,visited={id},{id}\n        for _ in range(level):\n            bfs={j for i in bfs for j in friends[i] if j not in visited}\n            visited|=bfs\n        freq=collections.Counter([v for idx in bfs for v in watchedVideos[idx]])\n        return sorted(list(freq.keys()),key=lambda x:(freq[x],x))\n#         d = defaultdict(list)\n#         for i in range(len(friends)):\n#             d[i].extend(friends[i])\n        \n#         videoCounts = []\n#         for i in range(len(watchedVideos)):\n#             videoCounts.append(len(watchedVideos[i]))\n        \n#         output = defaultdict(int)\n#         q = []\n#         q.append((id, 0))\n#         while q:\n#             node, lev = q.pop(0)\n#             if lev > level:\n#                 continue\n#             if lev == level:\n#                 for movie in watchedVideos[node]:\n#                     output[movie] += 1\n#                 continue\n#             else:\n#                 for nei in d[node]:\n#                     q.append((nei, lev + 1))\n        \n#         ans = []\n#         for key in output:\n#             ans.append((key, output[key]))\n#         ans.sort(key=lambda x: x[1])\n#         return list(map(lambda x: x[0], ans))\n", "class Solution:\n    def bfs(self, id: int, target_level:int, friends:List[List[int]], watchedVideos:List[List[str]], ans:dict):\n        queue = []\n        visited = []\n        valid_index = 0\n        queue.insert(0, id)\n        visited.append(id)\n        for l in range(target_level):\n            new_q =[]\n            while len(queue) != 0:\n                k = queue[0]\n                #visited.append(k)\n                del queue[0]\n                for i in friends[k]:\n                    if i not in visited:\n                        visited.append(i)\n                        new_q.append(i)\n            queue[:] = new_q\n            \n            \n        for f in queue:\n            for v in watchedVideos[f]:\n                if v not in ans:\n                    ans[v] = 1\n                else:\n                    ans[v] += 1\n        \n    def dfs(self, id:int, cur_level:int, target_level:int, friends:List[List[int]], watchedVideos:List[List[str]], ans:dict, visited:List[int]):\n        #can't work even if we have visited \n        # A -> B,C\n        # B -> C\n        # to A, C is level 1\n        # but DFS will traverse A->B->C, and think C is level 2\n        if id in visited:\n            return\n        visited.append(id)\n        if cur_level == target_level:\n            \n            for v in watchedVideos[id]:\n                if v not in ans:\n                    ans[v] = 1\n                else:\n                    ans[v] += 1\n            return\n        \n        \n        for f in friends[id]:\n            self.dfs(f, cur_level+1, target_level, friends, watchedVideos, ans, visited)\n            \n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        ans = {}\n        # visited = []\n        # self.dfs(id, 0, level, friends, watchedVideos, ans, visited)\n        self.bfs(id, level, friends, watchedVideos, ans)\n        ret = [k for k, v in sorted(list(ans.items()), key=lambda item: (item[1], item[0]))]\n        \n        return ret\n        \n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \n        n = len(watchedVideos)\n        \n        dist = [9999]*n\n        \n        queue = [(id, 0)]\n        while queue:\n            idx, depth = queue.pop(0)\n            if depth < dist[idx]:\n                dist[idx] = depth\n                for c in friends[idx]:\n                    queue.append((c, depth+1))\n                \n        print(dist)\n        \n        freq = defaultdict(int)\n        for i, l in enumerate(dist):\n            if l == level:\n                for vid in watchedVideos[i]:\n                    freq[vid] += 1\n        \n        pairs = sorted([(v, k) for k,v in list(freq.items())])\n        print(pairs)\n        \n        return [x[-1] for x in pairs]\n        \n", "from collections import defaultdict\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \n        graph=defaultdict(list)\n        \n        for i,friend_list in enumerate(friends):\n            for friend in friend_list:\n                graph[i].append(friend)\n                graph[friend].append(i)           \n        \n        queue=[id]\n        visited=set()\n        visited.add(id)\n        current_level=0\n        videos=defaultdict(lambda:0)\n        while queue:\n            if current_level==level:\n                for friend in queue:\n                    for video in watchedVideos[friend]:\n                        videos[video]+=1  \n                break\n            size=len(queue)\n            for i in range(size):\n                \n                node=queue.pop(0)\n                \n                for friend in graph[node]:\n                    if friend not in visited:\n                        visited.add(friend)\n                        queue.append(friend)\n            \n            current_level+=1\n\n        answer=sorted(list(videos.keys()),key= lambda x:(videos[x],x))\n        return answer\n            \n                    \n                    \n            \n            \n            \n            \n        \n        \n            \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        '''\n        bfs + heap\n        time: nlogn\n        space: n\n        '''\n        def bfs(start):\n            queue = [start]\n            current_level = 0\n            visited = set()\n            while queue:\n                if current_level >= level:\n                    break\n                subqueue = queue[:]\n                queue = []\n                for i in subqueue:\n                    visited.add(i)\n                    for j in friends[i]:\n                        if j not in visited and j not in queue and j not in subqueue:\n                            queue.append(j)\n                current_level += 1\n            return queue\n        from collections import Counter\n        import heapq\n        videos = []\n        for i in bfs(id):\n            videos += watchedVideos[i]\n        freq = dict(Counter(videos))\n        heap = []\n        for key in freq:\n            heapq.heappush(heap, (freq[key], key))\n        ans = []\n        while heap:\n            ans.append(heapq.heappop(heap)[1])\n        return ans", "from collections import defaultdict\nimport heapq\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        # (count, c)\n        adj = {}\n        for i in range(len(friends)):\n            adj[i] = friends[i]\n        \n        queue = [id]\n        visited = set()\n        visited.add(id)\n        dis = 0\n        while queue:\n            if dis == level:\n                break\n            for _ in range(len(queue)):\n                cur = queue.pop(0)\n                for friend in adj[cur]:\n                    if friend not in visited:\n                        queue.append(friend)\n                        visited.add(friend)\n            dis += 1\n        count = defaultdict(int)\n        for people in queue:\n            for video in watchedVideos[people]:\n                count[video] += 1\n        heap = []\n        for key in count:\n            heapq.heappush(heap, (count[key], key))\n        res = []\n        while heap:\n            res.append(heapq.heappop(heap)[1])\n        return res", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        def bfs(start):\n            queue = [start]\n            current_level = 0\n            visited = set()\n            while queue:\n                if current_level >= level:\n                    break\n                subqueue = queue[:]\n                queue = []\n                for i in subqueue:\n                    visited.add(i)\n                    for j in friends[i]:\n                        if j not in visited and j not in queue and j not in subqueue:\n                            queue.append(j)\n                current_level += 1\n            return queue\n        from collections import Counter\n        import heapq\n        videos = []\n        for i in bfs(id):\n            videos += watchedVideos[i]\n        freq = dict(Counter(videos))\n        heap = []\n        for key in freq:\n            heapq.heappush(heap, (freq[key], key))\n        ans = []\n        while heap:\n            ans.append(heapq.heappop(heap)[1])\n        return ans\n        \n                            \n                            \n", "from collections import defaultdict\n\n\nclass Movie:\n    def __init__(self, name):\n        self.name = name\n        self.freq = 0\n    \n    def __lt__(self, other):\n        if not other:\n            return True\n        if self.freq != other.freq:\n            return self.freq < other.freq\n        \n        return self.name < other.name\n\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        if not watchedVideos or not friends or level == 0:\n            return []\n        \n        \n        movies_freq = {}\n        queue = deque()\n        queue.append(id)\n        cur_level = 0\n        visited = set()\n        visited.add(id)\n        while queue:\n            n = len(queue)\n            if cur_level == level:\n                break\n            cur_level += 1\n            for _ in range(n):\n                node = queue.popleft()\n                if node >= len(friends):\n                    continue\n                \n                for child in friends[node]:\n                    if child in visited:\n                        continue\n                    visited.add(child)\n                    queue.append(child)\n        print(queue)\n        while queue:\n            friend = queue.popleft()\n            if friend >= len(watchedVideos):\n                continue\n            \n            for video in watchedVideos[friend]:\n                if video not in movies_freq:\n                    video_obj = Movie(video)\n                    movies_freq[video] = video_obj\n                movies_freq[video].freq += 1\n        \n        if not movies_freq:\n            return []\n        \n        *result, = [x.name for x in sorted(movies_freq.values())]\n        return result\n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \n        w,f = {},{}\n        for i in range(len(friends)):\n            w[i] = watchedVideos[i]\n            f[i] = friends[i]\n        \n        cand = []\n        frontier = [(id,0)]\n        seen ={id}\n        while frontier:\n            cur,d = frontier.pop()\n            if d==level:\n                cand.append(cur)\n                continue\n            \n            for friend in f[cur]:\n                if friend not in seen:\n                    seen.add(friend)\n                    frontier.append((friend,d+1))\n        \n        count = collections.Counter()\n        for c in cand:\n            for m in w[c]:\n                count[m]+=1\n        \n        \n        ans = [(v,k) for k,v in count.items()]\n        ans.sort()\n        ans = [x[1] for x in ans]\n        return ans", "from collections import defaultdict, deque\n\n\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        visited = set()\n        queue = deque([(id, 0)])\n        visited.add(id)\n        chosenFriends = list()\n        while queue:\n            person, lv = queue.popleft()\n            if lv == level:\n                chosenFriends.append(person)\n            if lv > level:\n                break\n            for friend in friends[person]:\n                if friend not in visited:\n                    queue.append((friend, lv + 1))\n                    visited.add(friend)\n        videoFrequency = defaultdict(int)\n        for friend in chosenFriends:\n            for video in watchedVideos[friend]:\n                videoFrequency[video] += 1\n        return [video[0] for video in sorted(list(videoFrequency.items()), key = lambda x : (x[1], x[0]))]\n                \n", "from collections import defaultdict\n\n\nclass Movie:\n    def __init__(self, name):\n        self.name = name\n        self.freq = 0\n    \n    def __lt__(self, other):\n        if not other:\n            return True\n        if self.freq != other.freq:\n            return self.freq < other.freq\n        \n        return self.name < other.name\n\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        if not watchedVideos or not friends or level == 0:\n            return []\n        \n        \n        movies_freq = {}\n        queue = deque()\n        queue.append(id)\n        cur_level = 0\n        visited = set()\n        visited.add(id)\n        while queue:\n            n = len(queue)\n            if cur_level == level:\n                break\n            cur_level += 1\n            for _ in range(n):\n                node = queue.popleft()\n                if node >= len(friends):\n                    continue\n                \n                for child in friends[node]:\n                    if child in visited:\n                        continue\n\n                    visited.add(child)\n                    queue.append(child)\n\n        while queue:\n            friend = queue.popleft()\n            if friend >= len(watchedVideos):\n                continue\n            \n            for video in watchedVideos[friend]:\n                if video not in movies_freq:\n                    video_obj = Movie(video)\n                    movies_freq[video] = video_obj\n                movies_freq[video].freq += 1\n        \n        if not movies_freq:\n            return []\n        \n        *result, = [x.name for x in sorted(movies_freq.values())]\n        return result\n", "from collections import defaultdict\n\n\nclass Movie:\n    def __init__(self, name):\n        self.name = name\n        self.freq = 0\n    \n    def __lt__(self, other):\n        if not other:\n            return True\n        if self.freq != other.freq:\n            return self.freq < other.freq\n        \n        return self.name < other.name\n\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        if not watchedVideos or not friends or level == 0:\n            return []\n        \n        \n        movies_freq = {}\n        queue = deque()\n        queue.append(id)\n        cur_level = 0\n        visited = set()\n        visited.add(id)\n        while queue:\n            n = len(queue)\n            if cur_level == level:\n                break\n            cur_level += 1\n            for _ in range(n):\n                node = queue.popleft()\n                if node >= len(friends):\n                    continue\n                \n                for child in friends[node]:\n                    if child in visited:\n                        continue\n                    visited.add(child)\n                    queue.append(child)\n\n        while queue:\n            friend = queue.popleft()\n            if friend >= len(watchedVideos):\n                continue\n            \n            for video in watchedVideos[friend]:\n                if video not in movies_freq:\n                    video_obj = Movie(video)\n                    movies_freq[video] = video_obj\n                movies_freq[video].freq += 1\n        \n        if not movies_freq:\n            return []\n        \n        *result, = [x.name for x in sorted(movies_freq.values())]\n        return result\n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        graph = collections.defaultdict(list)\n        for u, v in enumerate(friends):\n            for i in v:\n                graph[u].append(i)\n        queue = collections.deque()\n        queue.append((id, 0))\n        visited = set()\n        visited.add(id)\n        res = collections.defaultdict(int)\n        while queue:\n            id, l = queue.popleft()\n            if l == level:\n                for j in watchedVideos[id]:\n                    res[j] += 1\n            for v in graph[id]:\n                if l+1 <= level and v not in visited:\n                    visited.add(v)\n                    queue.append((v, l+1))\n        from functools import cmp_to_key\n        def func(x, y):\n            if res[x] > res[y]:\n                return -1\n            elif res[y] > res[x]:\n                return 1\n            else:\n                if x > y:\n                    return -1\n                elif y > x:\n                    return 1\n                else:\n                    return 0\n        return (sorted(res.keys(), key=cmp_to_key(func)))[::-1]", "from collections import Counter\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        current_level = 0\n        nodes_in_current_level = [id]\n        visited = set(nodes_in_current_level)\n        while current_level < level:\n            next_level = []\n            while len(nodes_in_current_level) > 0:\n                node = nodes_in_current_level.pop()\n\n                for neighbor in friends[node]:\n                    if neighbor in visited:\n                        continue\n                    visited.add(neighbor)\n                    next_level.append(neighbor)\n            nodes_in_current_level = next_level\n            current_level += 1\n        counter = Counter()\n        for id in nodes_in_current_level:\n            counter.update(watchedVideos[id])\n        return [item for item, count in sorted(list(counter.items()), key=lambda x: (x[1], x[0]))]\n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        stack = [(0, id)]\n        visited = set([id])\n        friendsSet = set()\n        while stack:\n            lNow, fi = heapq.heappop(stack)\n            if lNow == level:\n                friendsSet.add(fi)\n            else:\n                for fi1 in friends[fi]:\n                    if fi1 not in visited:\n                        visited.add(fi1)\n                        heapq.heappush(stack, (lNow+1, fi1))\n        videoCounter = Counter()\n        for f in friendsSet:\n            videoCounter += Counter(watchedVideos[f])\n            \n        ans = sorted([key for key in videoCounter], key = lambda x: (videoCounter[x],x) )\n        # print(videoCounter)\n        return ans        \n#         friendsSet = set()\n#         visited = set()\n#         visited.add(id)\n#         def findFriends(fi0, l0):\n#             if l0 == level:\n#                 if fi0 not in visited:\n#                     visited.add(fi0)\n#                     friendsSet.add(fi0)\n#                 return\n#             visited.add(fi0)\n#             for fi1 in friends[fi0]:\n#                 if fi1 not in visited:\n#                     findFriends(fi1, l0 + 1)\n        \n#         findFriends(id, 0)\n#         videoCounter = Counter()\n#         for f in friendsSet:\n#             videoCounter += Counter(watchedVideos[f])\n            \n#         ans = sorted([key for key in videoCounter], key = lambda x: (videoCounter[x],x) )\n#         # print(videoCounter)\n#         return ans\n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n    \n        q = deque([id])\n        visited = set()\n        visited.add(id)\n        \n        # q contains friends at level k\n        for _ in range(level):\n            for _ in range(len(q)):\n                curr = q.popleft()\n                for friend in friends[curr]:\n                    if friend not in visited:\n                        q.append(friend)\n                        visited.add(friend)\n                        \n        \n        # get videos for friends at level k\n        video_dict = {}\n        for friend in q:\n            for video in watchedVideos[friend]:\n                video_dict[video] = video_dict.get(video, 0) + 1\n              \n        res = [k for k, v in sorted(video_dict.items(), key=lambda item: (item[1],item[0]))]\n        \n        return res", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        # BFS to find the k-related friends\n        visited = {id: 1}\n        queue = deque()\n        queue.append((id, 0))\n        result = []\n        while queue:\n            u, dist = queue.popleft()\n            if dist == level:\n                result.append(u)\n                continue\n            \n            for v in friends[u]:\n                if v in visited:\n                    continue\n                visited[v] = 1\n                queue.append((v, dist + 1))\n                \n        # collect the movies\n        counter = {}\n        for u in result:\n            for video in watchedVideos[u]:\n                counter[video] = counter.get(video, 0) + 1\n                \n        # sort the movies\n        result = sorted([(times, videos) for videos, times in list(counter.items())])\n        return [val[1] for val in result]\n        \n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \n        n = len(watchedVideos)\n        visited = [False]*n\n        \n        que = collections.deque([id])\n        visited[id] = True\n        cur = 0\n        while que and cur<level:\n            size = len(que)\n            cur += 1\n            for _ in range(size):\n                node = que.popleft()\n                for f in friends[node]:\n                    if not visited[f]:\n                        visited[f] = True\n                        que.append(f)\n        \n        cnt = collections.Counter()\n        for node in que:\n            for m in watchedVideos[node]:\n                cnt[m] += 1\n        \n        videos = list(cnt.keys())\n        videos.sort(key=lambda x: [cnt[x], x] )\n        return videos\n        \n        \n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        visited = set()\n        queue = deque([(id, 0)])\n        visited.add(id)\n        requiredFriends = []\n        while queue:\n            person, lev = queue.popleft()\n            if lev == level:\n                requiredFriends.append(person)\n            if lev > level:\n                break\n            for friend in friends[person]:\n                if friend not in visited:\n                    queue.append((friend, lev + 1))\n                    visited.add(friend)\n        videosFrequency = defaultdict(int)\n        for friend in requiredFriends:\n            for video in watchedVideos[friend]:\n                videosFrequency[video] += 1\n        return [video[0] for video in sorted(videosFrequency.items(), key = lambda x : (x[1], x[0]))]", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        g_friends = collections.defaultdict(list)\n        for i in range(len(friends)):\n            for f in friends[i]:\n                g_friends[i].append(f)\n        queue = collections.deque()\n        queue.append((id, 0))\n        visited = set([id])\n        videos = collections.defaultdict(int)\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                curr_id, curr_level = queue.popleft()\n                if curr_level == level:\n                    for v in watchedVideos[curr_id]:\n                        videos[v] += 1\n                else:\n                    for f in g_friends[curr_id]:\n                        if f not in visited:\n                            visited.add(f)\n                            queue.append((f, curr_level + 1))\n        \n        return [v for _, v in sorted([(f, v) for v, f in list(videos.items())])]\n", "\\\"\\\"\\\"\n\n\n\\\"\\\"\\\"\n\n\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        n = len(watchedVideos)\n        visited = [0] * n\n        visited[id] = 1\n        queue = collections.deque()\n        queue.append(id)\n        persons = []\n        step = 0\n        while queue:\n            size = len(queue)\n            step += 1\n            for _ in range(size):\n                node = queue.popleft()\n                for nei in friends[node]:\n                    if visited[nei] == 1:\n                        continue\n                    visited[nei] = 1\n                    queue.append(nei)\n                    if step == level:\n                        persons.append(nei)\n            if step == level:\n                break\n        \n        VideoSet = set()\n        freq = collections.defaultdict(int)\n        for person in persons:\n            for v in watchedVideos[person]:\n                VideoSet.add(v)\n                freq[v] += 1        \n        \n        temp = []\n        for v in VideoSet:\n            temp.append([freq[v], v])\n        \n        temp.sort()\n        \n        res = []\n        for x in temp:\n            res.append(x[1])\n        return res\n        \n        \n        \n        \n        \n        \n        \n        ", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        #return self.fast(watchedVideos, friends, id, level)\n    \n        q = deque([id])\n        visited = set()\n        visited.add(id)\n        \n        for _ in range(level):\n            for _ in range(len(q)):\n                curr = q.popleft()\n                for friend in friends[curr]:\n                    if friend not in visited:\n                        q.append(friend)\n                        visited.add(friend)\n                        \n        # q contains friends at level k\n        \n        # get videos for friends at level k\n        video_dict = defaultdict(int)\n        for friend in q:\n            for video in watchedVideos[friend]:\n                video_dict[video] += 1\n              \n        res = [k for k, v in sorted(list(video_dict.items()), key=lambda item: (item[1],item[0]))]\n        \n        return res\n    \n    def fast(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int):\n        res = []\n        visited = [False]*len(friends)\n        fr_set = set()\n        q = deque([id])\n        for _ in range(level):\n            size = len(q)\n            for n in range(size):\n                fId = q.popleft()\n                for f in friends[fId]:\n                    if visited[f]!=True and f !=id: \n                        q.append(f)\n                        visited[f] = True\n                        \n        dic = {}\n        while q:\n            fid = q.popleft()\n            for video in watchedVideos[fid]:\n                dic[video] = dic.get(video,0)+1  \n                        \n                    \n        res = [k for k, v in sorted(list(dic.items()), key=lambda item: (item[1],item[0]))]\n\n        return res;\n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \n        graph = defaultdict(list)\n        \n        #build graph\n        for i, v in enumerate(friends):\n            graph[i].extend(v)\n            for r in v:\n                graph[r].append(i)\n        \n        \n        \n        videos = defaultdict(int)\n        def bfs(source):\n            dq = deque([source])\n            visited = set()\n            visited.add(source)\n            nlevels = 0\n            \n            while dq:\n                for _ in range(len(dq)):\n                    node = dq.popleft()\n                    if nlevels == level:\n                        for v in watchedVideos[node]:\n                            videos[v] += 1\n                    for nei in graph[node]:\n                        if nei not in visited:\n                            visited.add(nei)\n                            dq.append(nei)\n                    \n                nlevels += 1\n        bfs(id)            \n        minheap = []\n        for v in sorted(videos.keys()):\n            heappush(minheap, (videos[v], v)) \n\n        res = []\n        while minheap:\n            res.append(heappop(minheap)[1])\n        return res\n        \n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        n = len(friends)\n        friend_dist = [math.inf] * n\n        \n        friend_dist[id] = 0\n        deque = collections.deque()\n        deque.append(id)\n        \n        watched = dict()\n        \n        while deque:\n            person = deque.popleft()\n            \n            if friend_dist[person] == level:\n                for video in watchedVideos[person]:\n                    watched[video] = watched.get(video,0) +1\n                continue\n\n            for friend in friends[person]:\n                if friend_dist[friend] == math.inf:\n                    friend_dist[friend] = friend_dist[person] + 1\n                    deque.append(friend)\n        \n        return sorted(watched.keys(), key=lambda v: (watched[v],v))", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        stack = deque([id])\n        seen = set()\n        seen.add(id)\n        for _ in range(level):\n            for i in range(len(stack)):\n                f = stack.popleft()\n                for j in friends[f]:\n                    if j not in seen:\n                        stack.append(j)\n                        seen.add(j)\n        \n        count = Counter()\n        for lf in stack:\n            count += Counter(watchedVideos[lf])\n        return [x[0] for x in sorted(count.items(), key=lambda item: (item[1], item[0]))]", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], ID: int, level: int) -> List[str]:\n        # friends is an adjacency list: person -> list<friends of person>\n        # watchedvideos: person -> list of videos\n        \n        # find subset of friends with provided level\n        freqs = dict()\n        visited = set()\n        visited.add(ID)\n        q = set()\n        q.add(ID)\n        for _ in range(level):\n            q = {j for i in q for j in friends[i] if j not in visited}\n            visited |= q\n        for p in q:\n            for v in watchedVideos[p]:\n                freqs[v] = freqs.get(v, 0) + 1\n            \n\n        sortedfreqs = sorted([(n, v) for v, n in list(freqs.items())])\n        \n        return [v for _, v in sortedfreqs]\n            \n        \n            \n        \n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        visited = set()\n        visited.add(id)\n        frequency = {}\n        dictionary = {}\n        q = deque()\n        q.append(id)\n        running_level = 1\n        solution = []\n        \n        while q and running_level <= level:\n            length = len(q)\n            \n            for index in range(length):\n                node = q.popleft()\n                \n                for friend in friends[node]:\n                    if friend in visited: continue\n                    visited.add(friend)\n\n                    if running_level == level:\n                        for movie in watchedVideos[friend]:\n                            frequency[movie] = frequency.get(movie, 0)  + 1\n                    else: q.append(friend)\n            \n            running_level+=1\n        \n        \n        order = set(sorted(frequency.values()))\n        \n        for key in frequency:\n            dictionary[frequency[key]] = dictionary.get(frequency[key], []) + [key]\n        \n        for rank in order:\n            solution.extend(sorted(dictionary[rank]))\n\n        return solution", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        n=len(watchedVideos)\n        a,d,w=[id],[1]*n,{}\n        d[id]=0\n        for _ in range(level):\n            b=[]\n            for i in a:\n                for j in friends[i]:\n                    if d[j]:\n                        b.append(j)\n                        d[j]=0\n            a=b\n        for i in a:\n            for x in watchedVideos[i]: w[x]=w.get(x,0)+1\n        return sorted(w.keys(),key=lambda x:(w[x],x))", "from collections import deque, Counter\n\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \n        # BFS search\n        persons = len(friends)\n        visited = [False]*persons\n        source = id\n        visited[source] = True\n        \n        queue = deque()\n        queue.append(source)\n        k = 0\n        \n        videos_counter = Counter()\n        \n        while queue and k < level:\n            \n            videos_counter = Counter()\n            q_len = len(queue)\n            for _ in range(q_len):\n                person = queue.popleft()\n                \n                # search all the watched videos of your friend\n                for friend in friends[person]:\n                    if visited[friend]:\n                        continue\n                    \n                    visited[friend] = True\n                    queue.append(friend)\n                    videos = watchedVideos[friend]\n                    # update the videos_counter\n                    for video in videos:\n                        videos_counter[video] += 1\n\n            \n            k += 1  # update the level\n        \n        # collect the videos with their frequencies\n        frequencies = [(frequency, video) for video, frequency in list(videos_counter.items())]\n        \n        # sort them in increasing order with respect to frequency\n        result = [video for freq, video in sorted(frequencies)]\n        return result\n", "class Solution:\n    def watchedVideosByFriends(self, videos: List[List[str]], friends: List[List[int]], me: int, level: int) -> List[str]:\n        visit = set()\n        queue, arr = [me], []\n        while level:\n            level -= 1\n            size = len(queue)\n            for i in range(size):\n                curr = queue.pop(0)\n                if curr not in visit:\n                    visit.add(curr)\n                    for f in friends[curr]:\n                        queue.append(f)\n        v = []\n        for i in queue:\n            if i not in visit:\n                visit.add(i)\n                v += videos[i]\n        c = collections.Counter(v)\n        return sorted(sorted(list(set(v))), key=lambda x:c[x])", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        friends = getFriends(friends, id, 1, level, set([id]))\n        videoCounts = collections.Counter([val for i in friends for val in watchedVideos[i]])\n        sortedCounts = sorted(list(videoCounts.items()), key=lambda video: (video[1], video[0]))\n        return [count[0] for count in sortedCounts]\n        \n        \n        \n        \ndef getFriends(friends: List[List[int]], index: int, level: int, targetLevel: int, knownFriends):\n    currentFriends = set(friends[index]) - knownFriends\n    if (level == targetLevel):\n        return currentFriends\n    else:\n        newKnownFriends = knownFriends | currentFriends\n        return set([val for i in currentFriends for val in getFriends(friends, i, level + 1, targetLevel, newKnownFriends)])\n", "from collections import deque, defaultdict\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        stack = deque()\n        nbr = dict()\n        stack.append(id)\n        seen = set()\n        seen.add(id)\n        lvl = 0\n        while stack:\n            n = len(stack)\n            lvl += 1\n            if lvl > level:\n                break\n            for i in range(n):\n                person_id = stack.pop()\n                for p in friends[person_id]:\n                    if p in seen:\n                        continue\n                    seen.add(p)\n                    stack.append(p)\n                    if p not in nbr:\n                        nbr[p] = lvl\n\n                        \n        res = defaultdict(int)\n        for person_id in nbr:\n            if nbr[person_id] == level:\n                for video in watchedVideos[person_id]:\n                    res[video] += 1\n        res_sorted = sorted(list(res.items()), key = lambda x: (x[1], x[0]))\n        return [x[0] for x in res_sorted]\n                    \n", "from collections import Counter \nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        friendsSeen = {id}\n        k = 0\n        \n        connections = {id}\n        for k in range(0, level):\n            nextDegree = [friends[i] for i in connections]\n            connections = set([friend for friends in nextDegree for friend in friends if friend not in friendsSeen])\n            friendsSeen = friendsSeen.union(connections)\n            \n        videosWatched = [video for friend in connections for video in watchedVideos[friend]]\n        videoCounter = dict(Counter(videosWatched))\n        result = sorted(videoCounter.keys(), key = lambda x: videoCounter[x])\n        freqUnique = [videoCounter[video] for video in result]\n        freqMovieDict = dict()\n        for i in range(0, len(freqUnique)):\n            if freqUnique[i] not in freqMovieDict:\n                freqMovieDict[freqUnique[i]] = [result[i]]\n            else:\n                freqMovieDict[freqUnique[i]] += [result[i]]\n        for key in freqMovieDict:\n            freqMovieDict[key] = sorted(freqMovieDict[key])\n        ans = []\n        for key in sorted(freqMovieDict.keys()):\n            ans += freqMovieDict[key]\n        return ans", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        # BFS to find the k-related friends\n        visited = {id: 1}\n        queue = deque()\n        queue.append((id, 0))\n        result = []\n        while queue:\n            u, dist = queue.popleft()\n            if dist == level:\n                result.append(u)\n\n            if dist > level:\n                break\n                \n            for v in friends[u]:\n                if v in visited:\n                    continue\n                \n                queue.append((v, dist + 1))\n                visited[v] = 1\n                \n        # collect the movies\n        counter = {}\n        for u in result:\n            for video in watchedVideos[u]:\n                counter[video] = counter.get(video, 0) + 1\n                \n        # sort the movies\n        result = sorted([(times, videos) for videos, times in list(counter.items())])\n        return [val[1] for val in result]\n        \n", "from collections import Counter, deque\nfrom typing import List\n\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        q = deque([(0, id)])\n        seen = [False] * len(friends)\n        d = dict()\n\n        while q:\n            stage, person = q.popleft()\n            seen[person] = True\n            if stage not in d: d[stage] = set()\n\n            d[stage].add(person)\n\n            for friend in friends[person]:\n                if seen[friend]: continue\n                seen[friend] = True\n                q.append((stage + 1, friend))\n        \n        shared = dict()\n        for friend in d[level]:\n            for video in watchedVideos[friend]:\n                if video in shared:\n                    shared[video] += 1\n                else:\n                    shared[video] = 1\n        return list(x for _, x in sorted((freq, val) for val, freq in shared.items()))", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        k_friends = self.findFriends(friends, [id], {id}, level)\n        watched = {}\n        for id in k_friends:\n            for vid in watchedVideos[id]:\n                if vid in watched:\n                    watched[vid] += 1\n                else:\n                    watched[vid] = 1\n            \n        out = []\n        for key in watched:\n            out.append((watched[key], key))\n        out.sort()\n        \n        return list([x[1] for x in out])\n    \n    def findFriends(self, friends, ids, seen, level):\n        if level == 0 or len(ids) == 0:\n            return ids\n        \n        new = []\n        for id in ids:\n            for friend in friends[id]:\n                if friend not in seen:\n                    seen.add(friend)\n                    new.append(friend)\n                    \n        return self.findFriends(friends, new, seen, level - 1)\n                \n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        bfs,visited={id},{id}\n        for _ in range(level):\n            bfs={j for i in bfs for j in friends[i] if j not in visited}\n            visited|=bfs\n        freq=collections.Counter([v for idx in bfs for v in watchedVideos[idx]])\n        return sorted(freq.keys(),key=lambda x:(freq[x],x))", "from collections import deque, Counter\n\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \n        n = len(friends)\n            \n        stack = deque([id])\n        visited = set([id])\n        \n        for _ in range(level):\n            for j in range(len(stack)): \n                cur = stack.popleft()\n                for nxt in friends[cur]:\n                    if nxt not in visited:\n                        visited.add(nxt)\n                        stack.append(nxt)\n                        \n        dic = Counter()\n        for ppl in stack:\n            dic.update(watchedVideos[ppl])\n\n        items = sorted(list(dic.items()), key=lambda x:(x[1],x[0]))\n        return [k for k, _ in items]\n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \n        q = deque([id])\n        visited = set()\n        visited.add(id)\n        \n        while level > 0:\n            level -= 1\n            for _ in range(len(q)):\n                curr = q.popleft()\n                for friend in friends[curr]:\n                    if friend not in visited:\n                        q.append(friend)\n                        visited.add(friend)\n                        \n        # q contains friends at level k\n        \n        # get videos for friends at level k\n        video_dict = defaultdict(int)\n        for friend in q:\n            for video in watchedVideos[friend]:\n                video_dict[video] += 1\n              \n        res = [k for k, v in sorted(list(video_dict.items()), key=lambda item: (item[1],item[0]))]\n        \n        return res\n    \n    def fast():\n        res = []\n        visited = [False]*len(friends)\n        fr_set = set()\n        q = deque([id])\n        for _ in range(level):\n            size = len(q)\n            for n in range(size):\n                fId = q.popleft()\n                for f in friends[fId]:\n                    if visited[f]!=True and f !=id: \n                        q.append(f)\n                        visited[f] = True\n                        \n        dic = {}\n        while q:\n            fid = q.popleft()\n            for video in watchedVideos[fid]:\n                dic[video] = dic.get(video,0)+1  \n                        \n                    \n        res = [k for k, v in sorted(list(dic.items()), key=lambda item: (item[1],item[0]))]\n\n        return res;\n", "from collections import defaultdict, deque\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        n=len(friends)\n        adj=[[] for i in range(n)]\n        for i in range(n):\n            adj[i]=friends[i]\n        req=[]\n        visited={}\n        q=deque()\n        q.append((id,0))\n        visited[id]=True\n        while q:\n            u,lev=q.popleft()\n            if lev==level:\n                req.append(u)\n                continue\n            if lev>level:\n                break\n            for f in adj[u]:\n                if f not in visited:\n                    q.append((f,lev+1))\n                    visited[f]=True\n        res=defaultdict(lambda:0)\n        for  f in req:\n            for mov in watchedVideos[f]:\n                res[mov]+=1\n        res = sorted(res.items(),key = lambda x:(x[1], x[0]))\n        movies = [i[0] for i in res]\n        return movies", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \n        queue = deque()\n        queue.append([id, 0])\n        ans = defaultdict(int)\n        visited = {id:1}\n        while(len(queue) > 0):\n            now, l = queue.popleft()\n            \n            if l == level:\n                for v in watchedVideos[now]:\n                    ans[v] += 1\n            \n                continue\n            \n            for friend in friends[now]:\n                if friend not in visited:\n                    queue.append([friend, l+1])\n                    visited[friend] = 1\n        \n        ansid = sorted(ans.items(), key=lambda x: (x[1], x[0]))\n        \n        ansid = [x for x,_ in ansid]\n        return ansid", "import collections\n\nclass Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        # First: walk friends and summarize k-level info\n        krem = set(range(len(friends)))\n        krem.remove(id)\n        \n        curlevel = 0\n        klevel = set([id])\n        while True:\n            #print(\\\"level: {} members: {}\\\".format(curlevel, klevel))\n            if curlevel == level:\n                break\n            \n            newlevel = set()\n            \n            # We will only walk each 'pid' exactly once\n            for pid in klevel:\n                # Therefore we will only walk friends-of-pid exactly once\n                for fid in friends[pid]:\n                    # Not shortest path to 'fid'\n                    if not fid in krem:\n                        continue\n                \n                    krem.remove(fid)\n                    newlevel.add(fid)\n            \n            klevel = newlevel\n            curlevel += 1\n        \n        krem = None\n        \n        # klevel now is the set of ids reachable at shortest-path 'k' from 'id'\n        # So we just need to identify the videos.\n        vids = collections.defaultdict(int)\n        for pid in klevel:\n            for vid in watchedVideos[pid]:\n                vids[vid] += 1\n        \n        return [x[0] for x in sorted(vids.items(), key=lambda x: (x[1], x[0]))]", "class Solution:\n    def createAdjMatrix(self,friends):\n        adj_mat = {}\n        for i in range(len(friends)):\n            adj_mat[i] = friends[i]\n        return adj_mat\n    \n    def calculateFreq(self,level_friend,watchedVideos):\n        movies_freq = {}\n        for friend in level_friend:\n            movies = watchedVideos[friend]\n            for movie in movies:\n                movies_freq[movie] = movies_freq.get(movie,0)+1\n                \n        movies_freq = sorted(movies_freq.items(),key = lambda x:(x[1], x[0]))\n        movies = [i[0] for i in movies_freq]\n        return movies\n    \n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        \n        adj_mat = self.createAdjMatrix(friends)\n        visited = set()\n        Q = [(id,0)]\n        visited.add(id)\n        level_friend = []\n        while Q and level:\n            id_,lev = Q.pop(0)\n            if lev==level:\n                level_friend.append(id_)\n            if lev>level:\n                break\n            friends = adj_mat[id_]\n            for friend in friends:\n                if friend not in visited:\n                    Q.append((friend,lev+1))\n                    visited.add(friend)\n                    \n        return self.calculateFreq(level_friend,watchedVideos)", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        graph = collections.defaultdict(set)\n        \n        for i in range(len(friends)):\n            for friend in friends[i]:\n                graph[i].add(friend)\n                graph[friend].add(i)\n        \n        levelOfFriends = [id]\n        visited = set([id])\n        l = 0\n\n        while levelOfFriends and l < level:\n            size = len(levelOfFriends)\n            l += 1\n            \n            for _ in range(size):\n                f = levelOfFriends.pop(0)\n                \n                for otherF in graph[f]:\n                    if otherF not in visited:\n                        levelOfFriends.append(otherF)\n                        visited.add(otherF)\n                    \n        w = collections.defaultdict(int)\n        \n        for f in levelOfFriends:\n            videos = watchedVideos[f]\n            \n            for v in videos:\n                w[v] += 1\n                \n        heap = []\n        \n        for v in list(w.keys()):\n            heapq.heappush(heap, (w[v], v))\n            \n        res = []\n        for _ in range(len(heap)):\n            _, v = heapq.heappop(heap)\n            res.append(v)\n            \n        return res\n                \n", "class Solution:\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        vis={id}\n        q=deque()\n        q.append(id)\n        while q and level:\n            ln=len(q)\n            for _ in range(ln):\n                x=q.popleft()\n                #print(x)\n                for i in friends[x]:\n                    if i not in vis: \n                        q.append(i)\n                        vis.add(i)\n            level-=1\n        #print(q)\n        d=defaultdict(int)\n        for i in q:\n            for j in watchedVideos[i]:\n                d[j]+=1\n        '''d2=defaultdict(list)\n        for i in d:\n            d2[d[i]].append(i)\n        for i in d2: d2[i].sort()\n        x=sorted(list(d2.keys()))\n        res=[]\n        for i in x: \n            for j in d2[i]: res.append(j)\n        return res'''\n    \n        pq=[]\n        res=[]\n        for i in d:\n            heapq.heappush(pq,(d[i],i))\n        while pq:\n            res.append(heapq.heappop(pq)[1])\n        return res"]
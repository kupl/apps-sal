["__author__ = 'Think'\nn=int(input())\naints=[int(i) for i in input().split()]\npermutes=[int(i)-1 for i in input().split()]\nresults=[0]\n\nrebuilt={}\nm=0\nfor numby in range(n-1, 0, -1):\n\tp=permutes[numby]\n\tbelow=False\n\tabove=False\n\tif p-1 in rebuilt:\n\t\tbelow=True\n\tif p+1 in rebuilt:\n\t\tabove=True\n\tif above and below:\n\t\tbsum, bottom=rebuilt[p-1]\n\t\tasum, top=rebuilt[p+1]\n\t\tnew=bsum+asum+aints[p]\n\t\trebuilt[bottom]=(new, top)\n\t\trebuilt[top]=(new, bottom)\n\telif above or below:\n\t\tif above:\n\t\t\tother=p+1\n\t\telse:\n\t\t\tother=p-1\n\t\tpsum, prev=rebuilt[other]\n\t\tnew=psum+aints[p]\n\t\trebuilt[prev]=(new, p)\n\t\trebuilt[p]=(new, prev)\n\telse:\n\t\tnew=aints[p]\n\t\trebuilt[p]=(new, p)\n\tm=max(new, m)\n\tresults.append(m)\nfor numby in range(n-1, -1, -1):\n\tprint(results[numby])\n\n\n", "input()\narray = [int(n) for n in input().split()]\norder = [int(n)-1 for n in input().split()][::-1]\nrights = dict()\nlefts = dict()\ncurrent_max = 0\nresults = []\nfor i in order:\n    results.append(current_max)\n    if i-1 in rights and i+1 in lefts:\n        segment_sum = rights[i-1][1]+lefts[i+1][1]+array[i]\n        rights[lefts[i+1][0]] = [rights[i-1][0], segment_sum]\n        lefts[rights[i-1][0]] = [lefts[i+1][0], segment_sum]\n        rights.pop(i-1)\n        lefts.pop(i+1)\n    elif i-1 in rights:\n        segment_sum = rights[i-1][1]+array[i]\n        lefts[rights[i-1][0]] = [i, segment_sum]\n        rights[i] = [rights[i-1][0], segment_sum] \n        rights.pop(i-1)\n    elif i+1 in lefts:\n        segment_sum = lefts[i+1][1]+array[i]\n        rights[lefts[i+1][0]] = [i, segment_sum]\n        lefts[i] = [lefts[i+1][0], segment_sum] \n        lefts.pop(i+1)        \n    else:\n        segment_sum = array[i]\n        lefts[i] = [i, segment_sum]\n        rights[i] = [i, segment_sum]\n    if segment_sum > current_max:\n        current_max = segment_sum\nprint(*results[::-1], sep=\"\\n\")\n", "def main():\n    def f(x):\n        l = []\n        while x != clusters[x]:\n            l.append(x)\n            x = clusters[x]\n        for y in l:\n            clusters[y] = x\n        return x\n\n    n, aa = int(input()), [0, *list(map(int, input().split())), 0]\n    l, clusters, mx = list(map(int, input().split())), [0] * (n + 2), 0\n    for i in range(n - 1, -1, -1):\n        a = clusters[a] = l[i]\n        l[i] = mx\n        for i in a - 1, a + 1:\n            if clusters[i]:\n                j = f(i)\n                aa[a] += aa[j]\n                clusters[j] = a\n                f(i)\n        if mx < aa[a]:\n            mx = aa[a]\n    print('\\n'.join(map(str, l)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, aa = int(input()), [0, *list(map(int, input().split())), 0]\n    l, clusters, mx = list(map(int, input().split())), [0] * (n + 2), 0\n    for i in range(n - 1, -1, -1):\n        a = clusters[a] = l[i]\n        l[i] = mx\n        for i in a - 1, a + 1:\n            if clusters[i]:\n                stack, j = [], i\n                while j != clusters[j]:\n                    stack.append(j)\n                    j = clusters[j]\n                for i in stack:\n                    clusters[i] = j\n                aa[a] += aa[j]\n                clusters[j] = a\n        if mx < aa[a]:\n            mx = aa[a]\n    print('\\n'.join(map(str, l)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def make_set(a):\n    size[a] = 1\n    parent[a] = a\n    anses[a] = A[a]\n    \ndef find_set(a):\n    if a == parent[a]:\n        return a\n    else:\n        parent[a] = find_set(parent[a])\n    return parent[a]\n\ndef union_sets(a,b):\n    a = find_set(a)\n    b = find_set(b)\n    if a != b:\n        if size[b] > size[a]:\n            a,b=b,a\n        parent[b] = a\n        size[a] += size[b]\n        anses[a] +=anses[b]\n    return anses[a]\n    \n    \nsize = dict()\nparent=dict()\nanses=dict()\nn = int(input())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nans = 0\nanswer = [0]\nfor j in range(len(B)-1,0,-1):\n    j = B[j]-1\n    make_set(j)\n    per = anses[j]\n    if (j+1) in parent:\n        per = union_sets(j,j+1)\n    if (j-1) in parent:\n        per = union_sets(j,j-1)\n    ans = max(ans,per)\n    answer.append(ans)\nfor j in range(n-1,-1,-1):\n    print(answer[j])", "3\nsize = int(input())\nnum = list(map(int, input().split()))\nrem = reversed(list(map(lambda x: int(x) - 1, input().split())))\nchunks = [None] * size\nres = [-1] * size\nans = [0] * size\nms = -1\n\ndef addChunk(n):\n    chunks[n] = [n, num[n]]\n    return n\n\ndef getRoot(n):\n    while chunks[n][0] != n:\n        n = chunks[n][0]\n    return n\n\ndef mergeChunks(parent, child):\n    proot = getRoot(parent)\n    croot = getRoot(child)\n    chunks[croot][0] = proot\n    chunks[proot][1] += chunks[croot][1]\n    return proot\n\nfor i in rem:\n    res[i] = num[i]\n    root = addChunk(i)\n    if i > 0 and chunks[i - 1] != None:\n        root = mergeChunks(i - 1, i)\n    if i + 1 < size and chunks[i + 1] != None:\n        root = mergeChunks(i, i + 1)\n    ms = max(ms, chunks[root][1])\n    ans.append(ms)\n    \nfor i in range(1, size):\n    print (ans[-i-1])\n    \nprint(0)", "def make_set(a):\n    size[a] = 1\n    parent[a] = a\n    anses[a] = A[a]\n    \ndef find_set(a):\n    if a == parent[a]:\n        return a\n    else:\n        parent[a] = find_set(parent[a])\n    return parent[a]\n\ndef union_sets(a,b):\n    a = find_set(a)\n    b = find_set(b)\n    if a != b:\n        if size[b] > size[a]:\n            a,b=b,a\n        parent[b] = a\n        size[a] += size[b]\n        anses[a] +=anses[b]\n    return anses[a]\n    \n    \nsize = dict()\nparent=dict()\nanses=dict()\nn = int(input())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nans = 0\nanswer = [0]\nfor j in range(len(B)-1,0,-1):\n    j = B[j]-1\n    make_set(j)\n    per = anses[j]\n    if (j+1) in parent:\n        per = union_sets(j,j+1)\n    if (j-1) in parent:\n        per = union_sets(j,j-1)\n    ans = max(ans,per)\n    answer.append(ans)\nfor j in range(n-1,-1,-1):\n    print(answer[j])", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Dec  9 16:14:34 2016\n\n@author: kostiantyn.omelianchuk\n\"\"\"\n\nfrom sys import stdin, stdout\nlines = stdin.readlines()\nn = int(lines[0])\na = [int(x)  for x in lines[1].split()]\nb = [int(x)  for x in lines[2].split()]\n\ncheck_array = [0 for i in range(n)]\nsnm = [i for i in range(n)]\nr = [1 for i in range(n)]\nsums = dict(list(zip(list(range(n)), a)))    \n\ndef find_x(x):\n    if snm[x] != x:\n        snm[x] = find_x(snm[x])\n    return snm[x]\n\n\ndef union(x_start, y_start):\n    x = find_x(x_start)\n    y = find_x(y_start)\n    sums[x] += sums[y]\n    sums[y] = sums[x]\n    if x == y:\n        return x\n        #sums[x] += sums[x_start]\n    if r[x] == r[y]:\n        r[x] += 1\n    if r[x] < r[y]:\n        snm[x] = y\n        return y\n    else:\n        snm[y] = x\n        return x\n    \n\nmax_list = []\ntotal_max = 0\n\nfor i in range(n):\n    cur_sum = 0\n    flag = 0\n    \n    max_list.append(total_max)\n    #pos = n-i-1\n\n    elem = b[n-i-1] - 1\n    check_array[elem] = 1\n    #pos_x = find_x(elem)\n    if elem>0:\n        if check_array[elem-1] == 1:\n            pos = union(elem-1,elem)\n            cur_sum = sums[pos]\n            #print(sums, check_array, total_max, cur_sum, elem, find_x(elem))\n            \n        else:\n            flag += 1\n    else:\n        flag += 1\n    if elem<(n-1):\n        if check_array[elem+1] == 1:\n            pos = union(elem,elem+1)\n            cur_sum = sums[pos]\n            #print(sums, check_array, total_max, cur_sum, elem, find_x(elem))\n            \n        else:\n            flag += 1\n    else:\n        flag += 1\n    if flag == 2:\n        total_max = max(total_max,sums[elem])\n    else:\n        total_max = max(cur_sum, total_max)\n    \n        \nmax_list.append(total_max)\n\nfor j in range(1,n+1):\n    print(max_list[n-j])\n    \n    \n    \n    \n    \n", "n=int(input())\nl=list(map(int,input().split()))\nl1=list(map(int,input().split()))\nl1=l1[::-1]\nmi=0\nV=[0]\nL=[[] for i in range(n)]\nfor i in range(n-1) :\n    a=l1[i]-1\n    b=l1[i]-1\n    s=l[l1[i]-1]\n    if a-1!=-1 :\n        if L[a-1] :\n            s+=L[a-1][0]\n            a=L[a-1][1]\n    if b+1<n :\n        if L[b+1] :\n            s+=L[b+1][0]\n            b=L[b+1][2]\n    L[a]=[s,a,b]\n    L[b]=[s,a,b]\n    mi=max(mi,s)\n    V.append(mi)\nfor i in range(n-1,-1,-1) :\n    print(V[i])\n    \n    \n    \n", "def main():\n    n, aa = int(input()), [0, *list(map(int, input().split())), 0]\n    l, clusters, mx = list(map(int, input().split())), [0] * (n + 2), 0\n    for i in range(n - 1, -1, -1):\n        a = clusters[a] = l[i]\n        l[i] = mx\n        for i in a - 1, a + 1:\n            if clusters[i]:\n                stack, j = [], i\n                while j != clusters[j]:\n                    stack.append(j)\n                    j = clusters[j]\n                for i in stack:\n                    clusters[i] = j\n                aa[a] += aa[j]\n                clusters[j] = a\n        if mx < aa[a]:\n            mx = aa[a]\n    print('\\n'.join(map(str, l)))\n\n\ndef __starting_point():\n    main()\n\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "n=int(input())\na=list(map(int,input().split()))\nd=list(map(int,input().split()))\nq=[[i,i,-1] for i in range(n)]\no=['0']\nm=-1\nfor i in reversed(d[1:]):\n    i-=1\n    q[i][2]=a[i]\n    l,r=i,i\n    if i<n-1 and q[i+1][2]!=-1:\n        r=q[i+1][1]\n        q[r][2]+=a[i]\n    if i>0 and q[i-1][2]!=-1:\n        l=q[i-1][0]\n        q[l][2]+=a[i]\n    q[l][1]=r\n    q[r][0]=l\n    q[l][2]+=q[r][2]-a[i]\n    q[r][2]=q[l][2]\n    m=max(m,q[r][2])\n    o.append(str(m))\nprint('\\n'.join(reversed(o)))", "# TODO: type solution here\nclass Node(object):\n    def __init__(self, label):\n        self.label = label\n        self.par = self\n        self.size = 1\n        self.sum = 0\n        self.seen = False\n\n\nclass DisjointSet(object):\n    def __init__(self, n):\n        self.n = n\n        self.nodes = [Node(i) for i in range(n)]\n\n    def find(self, u):\n        if u != u.par:  # here we user path compression trick\n            u.par = self.find(u.par)\n        return u.par\n\n    def unite(self, u, v):\n        u, v = self.find(u), self.find(v)\n        if u == v:  # u and v are in the same component\n            return False\n\n        # making v the vertex with bigger size\n        if u.size > v.size:\n            u, v = v, u\n\n        # merging two components\n        u.par = v\n\n        # updating maximum size as size\n        v.size += u.size\n        v.sum += u.sum\n\n        return True\n\n\nn = int(input())\nnums = [int(a) for a in input().split(\" \")]\nperm = [int(a) - 1 for a in input().split(\" \")]\nanswers = []\ncurrent_answer = 0\ndsu = DisjointSet(n)\n\n\ndef add(i, current_answer):\n    node = dsu.nodes[i]\n    node.seen = True\n    node.sum = nums[i]\n    if i > 0 and dsu.nodes[i - 1].seen:\n        dsu.unite(node, dsu.nodes[i - 1])\n    if i < n - 1 and dsu.nodes[i + 1].seen:\n        dsu.unite(node, dsu.nodes[i + 1])\n\n    parent = dsu.find(node)\n    current_answer = max(current_answer, parent.sum)\n    return current_answer\n\n\nfor i in range(n - 1, -1, -1):\n    answers.append(current_answer)\n    current_answer = add(perm[i], current_answer)\n\nfor i in range(n):\n    print(answers[n - i - 1])\n", "n = int(input())\na = list(map(int, input().split()))\np = list(map(int, input().split()))\n\nvalid = [False for i in range(n)]\nparent = [0] * n\nsize = [0] * n\nstat = [0] * n\n\ndef find(x):\n    while parent[x] != x:\n        x = parent[x]\n    return x\n\ndef union(a, b):\n    x = find(a)\n    y = find(b)\n    if x == y:\n        return\n    elif size[x] < size[y]:\n        parent[x] = y\n        size[y] += size[x]\n        stat[y] += stat[x]\n    else:\n        parent[y] = x\n        size[x] += size[y]\n        stat[x] += stat[y]\n\nans = [0]\n\nfor i in range(n - 1, 0, -1):\n    k = p[i] - 1\n    valid[k] = True\n    parent[k] = k\n    stat[k] = a[k]\n    if k > 0 and valid[k - 1]:\n        union(k, k - 1)\n    if k < n - 1 and valid[k + 1]:\n        union(k, k + 1)\n    \n    t = stat[find(k)]\n    m = max(ans[-1], t)\n    ans.append(m)\n\nwhile len(ans) > 0:\n    print(ans.pop())", "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.arr = list(map(int, input().split()))\n        self.siz = [1] * n\n        self.sht = [0] * n\n        self.max = 0\n    def find(self, n):\n        nn = n\n        while nn != self.par[nn]:\n            nn = self.par[nn]\n        while n != nn:\n            self.par[n], n = nn, self.par[n]\n        return n\n    def union(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        \n        if a == b:\n            return\n        \n        if self.siz[a] < self.siz[b]:\n            a, b = b, a\n        self.par[b] = a\n        self.siz[a] += self.siz[b]\n        self.arr[a] += self.arr[b]\n        if self.arr[a] > self.max:\n            self.max = self.arr[a]\n    def add_node(self, n):\n        self.sht[n] = 1\n        if self.arr[n] > self.max:\n            self.max = self.arr[n]\n        if n != len(self.par) - 1 and self.sht[n + 1]:\n            self.union(n, n + 1)\n        if n != 0 and self.sht[n - 1]:\n            self.union(n, n - 1)\n        \n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    dsu = DSU(n)\n    per = list(map(int, input().split()))\n    ans = [0] * n\n    for i in range(n):\n        ans[~i] = dsu.max\n        dsu.add_node(per[~i] - 1)\n    for x in ans:\n        print(x)\n    return 0\n\nmain()", "import sys\ninput = sys.stdin.readline\n\nclass Unionfind:\n    def __init__(self, n):\n        self.par = [-1]*n\n        self.rank = [1]*n\n    \n    def root(self, x):\n        p = x\n        \n        while not self.par[p]<0:\n            p = self.par[p]\n        \n        while x!=p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        \n        return p\n    \n    def unite(self, x, y):\n        rx, ry = self.root(x), self.root(y)\n        \n        if rx==ry: return False\n        \n        if self.rank[rx]<self.rank[ry]:\n            rx, ry = ry, rx\n        \n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n    \n        if self.rank[rx]==self.rank[ry]:\n            self.rank[rx] += 1\n    \n    def is_same(self, x, y):\n        return self.root(x)==self.root(y)\n    \n    def count(self, x):\n        return -self.par[self.root(x)]\n\nn = int(input())\na = list(map(int, input().split()))\np = list(map(int, input().split()))\nuf = Unionfind(n)\nV = [0]*n\nflag = [False]*n\nans = [0]\n\nfor pi in p[::-1]:\n    pi -= 1\n    V[pi] = a[pi]\n    flag[pi] = True\n    \n    if pi-1>=0 and flag[pi-1]:\n        v = V[uf.root(pi-1)]+V[uf.root(pi)]\n        uf.unite(pi-1, pi)\n        V[uf.root(pi)] = v\n    \n    if pi+1<n and flag[pi+1]:\n        v = V[uf.root(pi+1)]+V[uf.root(pi)]\n        uf.unite(pi, pi+1)\n        V[uf.root(pi)] = v\n    \n    ans.append(max(ans[-1], V[uf.root(pi)]))\n\nfor ans_i in ans[:-1][::-1]:\n    print(ans_i)", "# Bosdiwale code chap kr kya milega\n# Motherfuckers Don't copy code for the sake of doing it\n# ..............\n# \u256d\u2501\u2533\u2501\u256d\u2501\u256d\u2501\u256e\u256e\n# \u2503\u2508\u2508\u2508\u2523\u2585\u254b\u2585\u252b\u2503\n# \u2503\u2508\u2503\u2508\u2570\u2501\u2570\u2501\u2501\u2501\u2501\u2501\u2501\u256e\n# \u2570\u2533\u256f\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u25e2\u2589\u25e3\n# \u2572\u2503\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2589\u2589\u2589\n# \u2572\u2503\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u25e5\u2589\u25e4\n# \u2572\u2503\u2508\u2508\u2508\u2508\u256d\u2501\u2533\u2501\u2501\u2501\u2501\u256f\n# \u2572\u2523\u2501\u2501\u2501\u2501\u2501\u2501\u252b\n# \u2026\u2026\u2026.\n# .\u2026\u2026. /\u00b4\u00af/)\u2026\u2026\u2026\u2026.(\\\u00af`\\\n# \u2026\u2026\u2026\u2026/\u2026.//\u2026\u2026\u2026.. \u2026\\\\\u2026.\\\n# \u2026\u2026\u2026/\u2026.//\u2026\u2026\u2026\u2026\u2026....\\\\\u2026.\\\n# \u2026./\u00b4\u00af/\u2026./\u00b4\u00af\\\u2026\u2026/\u00af `\\\u2026..\\\u00af`\\\n# ././\u2026/\u2026/\u2026./|_\u2026|.\\\u2026.\\\u2026.\\\u2026\\.\\\n# (.(\u2026.(\u2026.(\u2026./.)..)...(.\\.).).)\n# .\\\u2026\u2026\u2026\u2026\u2026.\\/../\u2026....\\\u2026.\\/\u2026\u2026\u2026\u2026/\n# ..\\\u2026\u2026\u2026\u2026\u2026.. /\u2026\u2026...\\\u2026\u2026\u2026\u2026\u2026\u2026../\n# \u2026..\\\u2026\u2026\u2026\u2026\u2026 (\u2026\u2026\u2026....)\u2026\u2026\u2026\u2026\u2026./\n\nn = int(input())\narr = list(map(int,input().split()))\nind = list(map(int,input().split()))\nparent = {}\nrank = {}\nans = {}\ntotal = 0\ntemp = []\ndef make_set(v):\n    rank[v] = 1\n    parent[v] = v\n    ans[v] = arr[v]\n\ndef find_set(u):\n    if u==parent[u]:\n        return u\n    else:\n        parent[u] = find_set(parent[u])\n    return parent[u]\n\ndef union_set(u,v):\n    a = find_set(u)\n    b = find_set(v)\n    if a!=b:\n        if rank[b]>rank[a]:\n            a,b = b,a\n        parent[b] = a\n        rank[a]+=rank[b]\n        ans[a]+=ans[b]\n    return ans[a]\n\nfor i in range(n-1,-1,-1):\n    rem = ind[i]-1\n    make_set(rem)\n    final = ans[rem]\n    if rem+1 in parent:\n        final = union_set(rem,rem+1)\n    if rem-1 in parent:\n        final = union_set(rem,rem-1)\n    total = max(total,final)\n    temp.append(total)\ntemp[-1] = 0\ntemp = temp[-1::-1]\ntemp = temp[1::]\nfor i in temp:\n    print(i)\nprint(0)", "n=int(input())\narr=[int(i) for i in input().split()]\ndes=[int(i) for i in input().split()]\nans=0\nleft=[-1 for i in range(n)]\nright=[-1 for i in range(n)]\nlast=0\npresum=[]\nparr=[]\nfor i in arr:\n    presum.append(last+i)\n    last+=i\nfor i in des[::-1]:\n    l=0;r=0\n    parr.append(ans)\n    if i==1 or left[i-2]==-1:\n        left[i-1]=i-1\n    else:\n        left[i-1]=left[i-2]\n    l=left[i-1]\n    if i==n or right[i]==-1:\n        right[i-1]=i-1\n    else:\n        right[i-1]=right[i]\n    r=right[i-1]\n    if l==0 and ans<presum[r]:\n        ans=presum[r]\n    elif ans<presum[r]-presum[l-1]:\n        ans=presum[r]-presum[l-1]\n    left[r]=l\n    right[l]=r\nfor i in parr[::-1]:\n    print(i)\n\n", "import sys\n\nMAX = 100005\narr = MAX * [0]\npre = MAX * [0]\nix = MAX * [0]\nsun = MAX * [0]\nans = MAX * [0]\nvis = MAX * [False]\nmx = 0\n\n\ndef find(x):\n    if x == pre[x]:\n        return x\n    pre[x] = find(pre[x])\n    return pre[x]\n\n\ndef unite(x, y):\n\n    dx = find(x)\n    dy = find(y)\n    if dx == dy:\n        return\n    pre[dx] = dy\n    sun[dy] += sun[dx]\n\n\nn = int(input())\narr = [int(i) for i in input().split()]\narr.insert(0, 0)\nsun = arr\npre = [i for i in range(n+1)]\nix = [int(i) for i in input().split()]\n\n\nfor i in range(n-1, -1, -1):\n    x = ix[i]\n    ans[i] = mx\n    vis[x] = True\n    if x != 1 and vis[x-1]:\n        unite(x-1, x)\n    if x != n and vis[x+1]:\n        unite(x, x+1)\n    mx = max(mx, sun[find(x)])\n\nfor i in range(n):\n    print(ans[i])\n\n"]
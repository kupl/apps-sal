["class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        delete_cost = 0\n        last = 0\n        for i in range(1, len(s)):\n            if s[last] == s[i]:\n                if cost[last] < cost[i]:\n                    delete_cost += cost[last]\n                    last = i\n                else:\n                    delete_cost += cost[i]\n            else:\n                last = i\n        return delete_cost", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        n=len(s)\n        idx=[]\n        res = 0\n        for i in range(n):\n            if idx and s[i]==s[idx[-1]]:\n                cost_cur = cost[i]\n                cost_pre = cost[idx[-1]]\n                if cost_cur>cost_pre:\n                    res+=cost_pre\n                    idx.pop()\n                    idx.append(i)\n                else:\n                    res+=cost_cur\n            else:\n                idx.append(i)\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        ##identify all candidates to delete and their costs, then pick min?\n        ## a) determine the min cost to delete for each consecutive character block.\n        val = 0\n        i = 0\n        start = 0\n        while i+1<len(s):\n            if s[i]==s[i+1]:\n                ##current character = same as next character\n                if start == 0:\n                    temp = [(i,cost[i])]\n                    start = 1\n                else:\n                    temp.append((i, cost[i]))\n            else:\n                if start == 1:\n                    temp.append((i,cost[i]))\n                    start = 0\n                    temp = sorted(temp, key = lambda x:x[1])\n                    print(temp)\n                    val += sum([i[1] for i in temp[:-1]])\n                    \n            i+=1\n        \n        if start ==1:\n            temp.append((i,cost[i]))\n            temp = sorted(temp, key = lambda x:x[1])\n            val += sum([i[1] for i in temp[:-1]])\n            \n        return val\n                    \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s = list(s)\n        sums = 0\n        i = 0\n        while i<= len(s)-2:\n            if s[i]==s[i+1]:\n                sums += min(cost[i],cost[i+1])\n                cost[i+1] =max(cost[i],cost[i+1])\n            i+=1\n            \n        return sums", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s = list(s)\n        ct = 0\n        i = 0\n        while i<= len(s)-2:\n            if s[i]==s[i+1]:\n                cos = min(cost[i],cost[i+1])\n                cmax = max(cost[i],cost[i+1])\n                ct+= cos\n                cost[i+1] = cmax\n                i+=1\n            else:\n                i+=1\n        return ct\n                \n                \n            \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        mcost = 0\n\n        for i in range(0, len(s)-1):\n\n            if s[i] == s[i+1]:\n\n                if cost[i] < cost[i+1]:\n                    mcost += cost[i]\n                else:\n                    mcost += cost[i+1]\n\n                    #then swap the cost\n                    temp = cost[i]\n                    cost[i] = cost[i+1]\n                    cost[i+1] = temp\n\n\n        return mcost", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        out = 0\n        for i in range(len(s)-1):\n            if s[i] == s[i+1]:\n                out += min(cost[i],cost[i+1])\n                cost[i] = max(cost[i],cost[i+1])\n                cost[i+1] = max(cost[i],cost[i+1])\n        return out        ", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        _min = 0\n        stack = []\n        for i in range(len(s)):\n            if not stack:\n                stack.append((s[i], i))\n            else:\n                t = stack[-1]\n                if t[0] == s[i]:\n                    if cost[i] > cost[t[1]]:\n                        stack.pop()\n                        _min += cost[t[1]]\n                        stack.append((s[i], i))\n                    else:\n                        stack.pop()\n                        _min += cost[i]\n                        stack.append((s[i], t[1]))\n                else:\n                    stack.append((s[i], i))\n                \n        return _min", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        l, total = 0, 0\n        for r in range(1,len(cost)):\n            if s[r] == s[l]:\n                if cost[r] > cost[l]:\n                    total += cost[l]\n                    l = r\n                else:\n                    total += cost[r]\n            else:\n                l = r\n        return total\n                \n            \n", "import sys\nclass Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        total_cost = 0\n        last = None\n        cost_sum = 0\n        max_cost = -sys.maxsize\n        for i,v in zip(s,cost):\n            if last==i:\n                cost_sum+=v\n                max_cost = max(max_cost,v)\n            else:\n                if last is not None:\n                    total_cost+=(cost_sum-max_cost)\n                max_cost = v\n                cost_sum = v\n                last = i\n            # print(total_cost,max_cost,cost_sum)\n        total_cost+=(cost_sum-max_cost)\n        return total_cost\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        ans = prev = 0 # index of previously retained letter \n        for i in range(1, len(s)): \n            if s[prev] != s[i]: prev = i\n            else: \n                ans += min(cost[prev], cost[i])\n                if cost[prev] < cost[i]: prev = i\n        return ans ", "'''\n1578. Minimum Deletion Cost to Avoid Repeating Letters.  Medium\n\nGiven a string items and an array of integers costs where costs[i]\nis the costs of deleting the character i in items.\n\nReturn the minimum costs of deletions such that there are\nno two identical letters next to each other.\n\nNotice that you will delete the chosen characters at the same time,\nin other words, after deleting a character, the costs of deleting\nother characters will not change.\n\nExample 1:\nInput: items = \\\"abaac\\\", costs = [1,2,3,4,5]\nOutput: 3\nExplanation: Delete the letter \\\"a\\\" with costs 3 to get \\\"abac\\\"\n             (String without two identical letters next to each other).\n\nExample 2:\nInput: items = \\\"abc\\\", costs = [1,2,3]\nOutput: 0\nExplanation: You don't need to delete any character because\n             there are no identical letters next to each other.\n\nExample 3:\nInput: items = \\\"aabaa\\\", costs = [1,2,3,4,1]\nOutput: 2\nExplanation: Delete the first and the last character,\n             getting the string (\\\"aba\\\").\n\nConstraints:\nitems.length == costs.length\n1 <= items.length, costs.length <= 10^5\n1 <= costs[i] <= 10^4\nitems contains only lowercase English letters.\n\nAccepted 3,761 / 7,000 submissions.\n'''\nclass Solution:\n    def minCost(self, items: str, costs: List[int]) -> int:\n        '''\n        Runtime: 1160 ms, faster than 50.00% of Python3 online submissions for Minimum Deletion Cost to Avoid Repeating Letters.\n        Memory Usage: 24.5 MB, less than 25.00% of Python3 online submissions for Minimum Deletion Cost to Avoid Repeating Letters.\n        '''\n        size = len(items)\n        if size < 2:\n            return 0\n            \n        result = 0\n        prv_item = items[0]\n        prv_cost = costs[0]\n        max_cost = tot_cost = prv_cost\n        run = False\n        for item, cost in zip(items[1:], costs[1:]):\n            if item == prv_item:\n                run = True\n                tot_cost += cost\n                max_cost = max(max_cost, cost)\n            else:\n                if run:\n                    run = False\n                    result += tot_cost - max_cost\n                tot_cost = max_cost = cost\n            prv_item = item\n\n        if run:\n            result += tot_cost - max_cost\n        return result", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        \n        H = []\n        ans = 0\n        \n        i = 1\n        while i < len(s):\n            # print(i)\n            if i < len(s) and s[i] == s[i-1]:\n                # print('hi')\n                H = []\n                heapq.heappush(H,cost[i-1])\n                c = 1\n                while i < len(s) and s[i]==s[i-1]:\n                    heapq.heappush(H,cost[i])\n                    i+=1\n                    c+=1\n                # print('c =',c)\n                while c>1:\n                    t = heapq.heappop(H)\n                    ans+=t\n                    c-=1\n            else:\n                i+=1\n            H=[]\n        \n        return ans            \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        pre = 0\n        res = 0\n        for idx in range(1, len(s)):\n            if s[idx] == s[pre]:\n                res += min(cost[idx], cost[pre])\n                print((cost[pre], cost[idx]))\n            \n            if s[idx] != s[pre] or cost[pre] < cost[idx]:\n                pre = idx\n        return res\n", "from collections import defaultdict\nclass Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        cache = defaultdict(lambda: [float('-inf'), 0])\n        last = None\n        group = 0\n        for cost, char in zip(cost, s):\n            if char != last:\n                last = char\n                group += 1\n                \n            cache[group][0] = max(cache[group][0], cost)\n            cache[group][1] +=  cost\n        total = 0\n        for maxCost, sum in list(cache.values()):\n            total += sum - maxCost\n        return total\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        i=0\n        j=1\n        p=0\n        while j<len(s):\n            if s[i]==s[j]:\n                if cost[i]<cost[j]:\n                    p+=cost[i]\n                    i=j\n                    j+=1\n                else:\n                    p+=cost[j]\n                    j+=1      \n            else:\n                i=j\n                j+=1\n            \n        return p\n                \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s = list(s)\n        ct = 0\n        i = 0\n        while i<= len(s)-2:\n            if s[i]==s[i+1]:\n                ct+= min(cost[i],cost[i+1])\n                cost[i+1] =max(cost[i],cost[i+1])\n                i+=1\n            else:\n                i+=1\n        return ct\n                \n                \n            \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        nums = [v for v in s]\n        res = 0\n        flag = 0\n        d = collections.defaultdict(set)\n        i = 1\n        while i < len(nums):\n            while 0 <= i < len(nums) and  nums[i] == nums[i - 1]:\n                d[flag].add(i)\n                d[flag].add(i - 1)\n                i += 1\n            flag += 1\n            i += 1\n            \n    \n        for v in d.values():\n            # print(v)\n            print(v)\n            curr_cost = [cost[c] for c in v]\n            max_val = max(curr_cost)\n            res += sum(curr_cost)\n            print(max_val)\n            res -= max_val\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        #greedy?\n        target = s[0]\n        cost_list = [cost[0]]\n        res = 0\n        for i in range(1, len(cost)):\n          if s[i] == target:\n            cost_list.append(cost[i])\n          else:\n            if len(cost_list) >= 2:\n              res += sum(cost_list) - max(cost_list)\n            cost_list = [cost[i]]\n            target = s[i]\n        if len(cost_list) >= 2: res += sum(cost_list) - max(cost_list)\n        return res\n        \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        answer = 0\n        start = 0\n        \n        for i in range(1, len(s)):\n            if s[start] != s[i]:\n                deletions = sorted(cost[start: i], reverse=True)\n\n                while len(deletions) > 1:\n                    answer += deletions.pop()\n                \n                start = i\n                \n        deletions = sorted(cost[start: i + 1], reverse=True)\n\n        while len(deletions) > 1:\n            answer += deletions.pop()\n        \n        return answer", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        c=0\n        si=0\n        x=1\n        while x<len(s):\n            if s[si]==s[x] and si<x:\n                if cost[si]<=cost[x]:\n                    c+=cost[si]\n                    si=x\n                else:\n                    c+=cost[x]\n            else:\n                si=x\n            x+=1\n        # for x in range(len(s)):\n        #     if len(p)!=0:\n        #         if s[p[-1]]==s[x]:\n        #             if cost[p[-1]]<=cost[x]:\n        #                 c+=cost[p[-1]]\n        #                 p.pop()\n        #                 p.append(x)\n        #             else:\n        #                 c+=cost[x]\n        #         else:\n        #             p.append(x)\n        #     else:\n        #         p.append(x)\n        return c", "from collections import defaultdict\nclass Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        i = j = 0\n        ans = 0\n        while j < len(s):\n            while j < len(s) and s[i] == s[j]:\n                j += 1\n            if j-i > 1:\n                ans += sum(sorted(cost[i:j])[:-1])\n            i = j\n\n        return ans", "import heapq\n\nclass Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        it = 0\n        n = len(s)\n        ans = 0\n        while it<n:\n            if it>0 and s[it-1] == s[it]:\n                h,c = [],s[it]\n                heapq.heappush(h,cost[it])\n                heapq.heappush(h,cost[it-1])\n                it+=1\n                while it<n and s[it]==c:\n                    heapq.heappush(h,cost[it])\n                    it+=1\n                sze = len(h)\n                ans += sum(heapq.nsmallest(sze-1,h))\n            else:\n                it+=1\n                \n        return ans ", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        res = 0\n        array = list(s)\n        i = 0\n        while i <= len(array)-2:\n            if array[i] == array[i+1]:\n                res += min(cost[i], cost[i+1])\n                cost[i+1] = max(cost[i], cost[i+1])\n            i+=1\n        return res\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if len(s) == 1:\n            return 0\n        total = 0\n        s = list(s)\n        l, r = 0, 1\n        while r < len(s):\n            if s[l] == '':\n                l += 1\n            else:\n                if s[l] == s[r]:\n                    if cost[l] > cost[r]:\n                        total += cost[r]\n                        s[r] = ''\n                        r += 1\n\n                    else:\n                        total += cost[l]\n                        l = r\n                        r += 1\n                else:\n                    l += 1\n                    r += 1\n        return total\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        ans = 0\n        tmp = []\n        for i in range(1,len(s)):\n            if s[i]==s[i-1]:\n                tmp.append(i)\n                tmp.append(i-1)\n            if s[i]!=s[i-1] or i==len(s)-1:\n                tmp = list(set(tmp))\n                x = []\n                for el in tmp:\n                    x.append(cost[el])\n                tmp = x\n                tmp.sort()\n                tmp = tmp[:-1]\n                #print(tmp)\n                ans += sum(tmp)\n                tmp = []\n                \n        return ans\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        c = 0\n        i = 0\n        l = len(cost)\n        while i<l-1:\n            if s[i] != s[i+1]:\n                i = i+1\n            else:\n                ch = s[i]\n                dl = 0\n                for char in s[i:]:\n                    if char == ch:\n                        dl += 1\n                    else:\n                        break\n                m = cost[i:i+dl]\n                print(m)\n                c += sum(m) - max(m)\n                i += dl\n        return c", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        i = 0\n        delete =[]\n        while i < len(s)-1:\n            j = i+1\n            while j < len(s):\n                if s[j]!=s[i]:break\n                j+=1\n            if j>i+1:\n                temp = [a for a in range(i, j)]\n                temp2 = [x for _, x in sorted(zip(cost[i:j],temp))]\n                delete += temp2[:-1]\n            i=j\n        delete=set(delete)\n        res = 0\n        for i, x in enumerate(cost):\n            if i in delete:\n                res+=x\n        return res\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        result = previous = 0\n        for i in range(1, len(s)):\n            if s[previous] != s[i]:\n                previous = i\n            else:\n                result += min(cost[previous], cost[i])\n                if cost[previous] < cost[i]:\n                    previous = i\n        return result", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if not s:\n            return 0\n        last = s[0]\n        i = 0\n        res = 0\n        while i < len(s) - 1:\n            if s[i] == s[i+1]:\n                j = i + 1\n                sums = cost[i]\n                maxs = cost[i]\n                while j <len(s) and s[j] == s[j-1]:\n                    sums += cost[j]\n                    maxs = max(maxs, cost[j])\n                    j += 1\n                    \n                #print(i,j)\n                res += sums - maxs\n                i = j\n                \n            else:\n                i += 1\n        return res\n                \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        #greedy\n        target = s[0]\n        cost_list = [cost[0]]\n        res = 0\n        for i in range(1, len(cost)):\n          if s[i] == target:\n            cost_list.append(cost[i])\n          else:\n            if len(cost_list) >= 2: res += sum(cost_list) - max(cost_list)\n            cost_list = [cost[i]]\n            target = s[i]\n        if len(cost_list) >= 2: res += sum(cost_list) - max(cost_list)\n        return res\n        \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        currentCost, totalCost, maxSoFar = 0, 0, 0\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                if currentCost == 0:\n                    currentCost = cost[i-1] + cost[i]\n                    maxSoFar = max(cost[i-1], cost[i])\n                else:\n                    currentCost += cost[i]\n                    maxSoFar = max(maxSoFar, cost[i])\n            else:\n                if currentCost != 0:\n                    totalCost += (currentCost - maxSoFar)\n                    currentCost = 0\n        if currentCost != 0:\n            totalCost += (currentCost - maxSoFar)\n        return totalCost", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        mx=ans=0\n        p=''\n        for i,(x,c) in enumerate(zip(s,cost)):\n            ans+=c\n            if p!=x:\n                ans-=mx\n                mx=0\n                p=x\n            if c>mx:\n                mx=c\n        return ans-mx", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        total_cost = 0\n        i = 0\n        while i < len(s) - 1:\n            if s[i] == s[i + 1]:\n                j = i + 1\n                while j < len(s) and s[j] == s[i]:\n                    j += 1\n                total_cost += sum(cost[i:j]) - max(cost[i:j])\n                i = j\n            else:\n                i += 1\n        return total_cost", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        res = 0\n        \n        i, n = 0, len(s)\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n                \n            if j != i + 1:\n                res += sum(cost[i:j]) - max(cost[i:j])              \n            \n            i = j\n        \n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        rlist = []\n        cnt = 0\n        for i in range(1, len(s)):\n            c = s[i]\n            if c == s[i-1]:\n                cnt += 1\n            else:\n                if cnt > 0:\n                    rlist.append([i-cnt-1, i])\n                cnt = 0\n            if i == len(s)-1 and cnt > 0:\n                rlist.append([i-cnt, i+1])\n        ans = []\n        for r in rlist:\n            if r[1]-r[0] > 1:\n                t = sorted(cost[r[0]:r[1]])\n                ans.append(sum(t[:-1]))\n            else:\n                ans.append(min(cost[r[0]:r[1]]))\n        return sum(ans)", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        ans = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and s[i] != s[i+1]:\n                # print('-', s[i], i)\n                i += 1\n            elif i + 1 < len(s) and s[i] == s[i+1]:\n                # print('+', s[i], i)\n                j = i + 1\n                while j + 1 < len(s) and s[j] == s[j+1]:\n                    j += 1\n                j += 1\n                # print('+', i, j)\n                summ = 0\n                maxx = float('-inf')\n                for k in range(i, j):\n                    summ += cost[k]\n                    maxx = max(maxx, cost[k])\n                ans += (summ - maxx)\n                i = j\n            else:\n                i += 1\n        return ans\n            \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        if len(s)<=1: return 0\n        \n        index = 1\n        to_remove = 0\n        \n        while index<len(s):\n            if s[index]!=s[index-1]:\n                index += 1\n                continue\n            k = index\n            while k<len(s) and s[k]==s[index-1]:\n                k += 1\n            to_remove += (sum(cost[index-1:k]) - max(cost[index-1:k]))\n            index = k\n            \n        return to_remove", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        ptr1 = 0\n        ptr2 = 0\n        ans = 0\n        for i in range(1,len(s)):\n            if s[i-1] == s[i]:\n                ptr2 += 1\n            else:\n                print((ptr1, ptr2))\n                if ptr2 > ptr1:\n                    ans += sum(cost[ptr1:ptr2+1]) - max(cost[ptr1:ptr2+1])\n                ptr1, ptr2 = i, i\n        if ptr2 > ptr1:\n            ans += sum(cost[ptr1:ptr2+1]) - max(cost[ptr1:ptr2+1])\n        return ans\n                \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        arr = []\n        i = 1\n        while i < len(s):\n            temp = set()\n            if s[i] == s[i-1]:\n                while i < len(s) and s[i] == s[i-1]:\n                    temp.add(i-1)\n                    temp.add(i)\n                    i += 1\n                arr += [list(temp)]\n            else:\n                i+=1\n        \n        #print(arr)\n        \n        c = 0\n        \n        for i in arr:\n            temp = [cost[x] for x in i]\n            c += sum(temp) - max(temp)\n        \n        return c\n            \n        \n        \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if not s:\n            return 0\n        last = s[0]\n        i = 0\n        res = 0\n        while i < len(s) - 1:\n            if s[i] == s[i+1]:\n                j = i + 1\n                while j <len(s) and s[j] == s[j-1]:\n                    j += 1\n                print((i,j))\n                res += sum(cost[i:j]) - max(cost[i:j])\n                i = j\n                \n            else:\n                i += 1\n        return res\n                \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        ans = 0\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                ans += min(cost[i], cost[i-1])\n                cost[i] = max(cost[i], cost[i-1])\n        return ans", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        c=0\n        p=0\n        for i in range(1,len(s)):\n            if s[i]!=s[i-1]:\n                p=i\n                continue\n                \n            if cost[p]>cost[i]:\n                c+=cost[i]\n            else:\n                c+=cost[p]\n                p=i\n                \n        return c                \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        res = prev = 0 \n        for i in range(1, len(s)): \n            if s[prev] != s[i]: prev = i  #\n            else: \n                res += min(cost[prev], cost[i])\n                if cost[prev] < cost[i]: prev = i\n        return res ", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s = list(s)\n        sums = 0\n        i = 0\n        while i<= len(s)-2:\n            if s[i]==s[i+1]:\n                sums += min(cost[i],cost[i+1])\n                cost[i+1] =max(cost[i],cost[i+1])\n                i+=1\n            else:\n                i+=1\n        return sums\n                \n                \n            \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        n = len(cost)\n        if n <= 1:\n            return 0\n        res = 0\n        i = 1\n        while i < n:\n            if s[i] == s[i - 1]:\n                j = i\n                # \u627e\u5230\u8fde\u7eed\u7684\u4e00\u7247\u91cd\u590d\u5b57\u6bcd\n                while j < n and s[j] == s[j - 1]:\n                    j += 1\n                res += sum(cost[i - 1:j]) - max(cost[i - 1:j])\n                i = j\n            else:\n                i += 1\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if len(cost) < 2: return 0\n        ans = 0\n        r = 0\n        ptr = 1\n        while ptr < len(cost):\n            delete = False\n            while ptr < len(cost) and s[ptr] == s[r]:\n                # print(ptr,r)\n                delete = True\n                ptr += 1\n            if delete:\n                ans += sum(cost[r:ptr])-max(cost[r:ptr])\n                ptr -= 1\n            r = ptr\n            ptr += 1\n            \n        return ans", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if len(s)<2:\n            return 0\n        i = 0\n        ans=[]\n        while i<len(s)-1:\n            if s[i]==s[i+1]:\n                su=0\n                m=-1\n                inside = False\n                while i<len(s)-1 and s[i]==s[i+1]:\n                    m = max(m,cost[i],cost[i+1])\n                    print((s[i],cost[i],s[i+1],cost[i+1]))\n                    su += cost[i]\n                    i+=1\n                    inside = True\n                if inside:\n                    su+=cost[i]\n                    ans.append(su-m)\n                #ans.append(cost[i+1])\n                i+=1\n                \n            else:\n                i+=1\n        return sum(ans)\n                \n            \n                \n                \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        cur =0\n        mycost = 0\n        while cur < len(s)-1:\n            if s[cur] == s[cur+1]:\n                temp=[]\n                letter = s[cur]\n                while cur < len(s) and s[cur] == letter:\n                    temp.append(cost[cur]) \n                    cur +=1\n                mycost += sum(temp) - max(temp)\n            else:\n                cur+=1\n                \n        return mycost", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s = list(s)\n        min_cost = 0\n        cur = []\n        for i in range(len(s)-1):\n            if s[i] == s[i+1]:\n                cur.append(i)\n            else:\n                if len(cur)>0:\n                    cur.append(i)\n                    min_cost += sum([cost[x] for x in cur]) - max(\n                        [cost[x] for x in cur])\n                    cur = []\n        if len(cur)>0:\n            cur.append(len(s)-1)\n            min_cost += sum([cost[x] for x in cur]) - max(\n                    [cost[x] for x in cur])\n        return min_cost           ", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        mx=ans=0\n        p=''\n        for i,(x,c) in enumerate(zip(s,cost)):\n            ans+=c\n            if p!=x:\n                ans-=mx\n                mx=0\n            if c>mx:\n                mx=c\n            p=x\n        return ans-mx", "class Solution:\n    from collections import defaultdict\n    def minCost(self, s: str, cost: List[int]) -> int:\n        _dic=defaultdict(list)\n        start,end=0,0\n        s=s+'$'\n        \n        for ind in range(0,len(s)-1):\n            if s[ind]==s[ind+1]:\n                end+=1\n            else:\n                if start!=end:\n                    _dic[s[ind]].append((start,end))\n                start=end+1\n                end+=1\n        \n        res=0\n        \n        for key in _dic:\n            for tup in _dic[key]:\n                res+=sum(sorted(cost[tup[0]:tup[1]+1])[:(tup[1]-tup[0])])\n        \n        return res\n                \n \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        repeats = []\n        low = 0\n        high = 0\n        for i in range(1, len(s)):\n            if s[i] == s[low]:\n                high = i\n            else:\n                if high - low > 0:\n                    repeats.append((low, high + 1))\n                low = high = i\n        if high - low > 0:\n                    repeats.append((low, high + 1))\n        total = 0\n        for low, high in repeats:\n            maxVal = 0\n            for i in range(low, high):\n                maxVal = max(maxVal, cost[i])\n                total = total + cost[i]\n            total = total - maxVal\n        return total", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        ans = 0\n        idx = 0\n        left = 0\n        while idx<len(s): \n            while idx+1<len(s) and s[idx] == s[idx+1]: \n                idx += 1 \n            if left<idx: \n                ans += sum(cost[left:idx+1]) - max(cost[left:idx+1])\n            idx += 1\n            left = idx\n            # print(idx, left)\n            \n\n        return ans ", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        res, last = 0, None\n        max_cost = float('-inf')\n        cur_cost = 0\n        for i, c in enumerate(s):\n            if c == last:\n                if cur_cost == 0:\n                    max_cost = max(cost[i - 1], max_cost)\n                    cur_cost += cost[i - 1]\n                cur_cost += cost[i]\n                max_cost = max(cost[i], max_cost)\n            else:\n                if cur_cost > 0:\n                    res += cur_cost - max_cost\n                    cur_cost = 0\n                    max_cost = float('-inf')\n            # print(i, c, last, cur_cost, max_cost)\n            last = c\n        if cur_cost > 0:\n            res += cur_cost - max_cost\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        sums = 0\n        max_cost = 0\n        ans = 0\n        flag = False\n        \n        for i in range(1,len(s)):\n            if s[i] == s[i-1]:\n                sums += cost[i-1]\n                flag = True\n                if max_cost < cost[i-1]:\n                    max_cost = cost[i-1]\n            else:\n                if flag:\n                    if max_cost < cost[i-1]:\n                        max_cost = cost[i-1]\n                    sums += cost[i-1]\n                    ans += sums - max_cost\n                    # print(ans, sums, max_cost)\n                sums = 0\n                flag = False\n                max_cost = 0\n        \n        if flag:\n            if max_cost < cost[-1]:\n                max_cost = cost[-1]\n            sums += cost[-1]\n            ans += sums - max_cost\n            # print(ans, sums, max_cost)\n                \n        return ans", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if(len(s)<=1):\n            return 0\n        \n        prev=0\n        cost_val = 0\n        for i in range(1,len(s)):\n            if(s[i]==s[prev]):\n                if(cost[i]<=cost[prev]):\n                    cost_val+=cost[i]\n                else:\n                    cost_val+=cost[prev]\n                    prev=i\n            else:\n                prev=i\n\n        return cost_val", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        rep = []\n        p1 = 0\n        p2 = 1\n        n = len(s)\n        if n == 1:\n            return 0\n        while p1 < n and p2 < n:\n            if s[p1] == s[p2]:\n                p2 += 1\n            else:\n                if p2 - p1 > 1:\n                    rep.append((p1, p2-1))\n                    p1 = p2\n                    p2 = p1 +1\n                else:\n                    p1 += 1\n                    p2 += 1\n        if p1 != n-1:\n            rep.append((p1, p2-1))\n        \n        ans = 0\n        for r in rep:\n            a, b = r\n            big = float('-inf')\n            minus = 0\n            for i in range(a, b+1):\n                big = max(big, cost[i])\n                minus += cost[i]\n                \n            ans += minus - big\n        \n        return ans\n            \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if not s:\n            return 0\n        \n        res = 0\n        max_idx = 0 # the idx of the max cost value in the consecutive subsequence\n        for i in range(1, len(s)):\n            if s[i] == s[max_idx]:\n                if cost[max_idx] < cost[i]:\n                    res += cost[max_idx]\n                    max_idx = i\n                else:\n                    res += cost[i]\n            else:\n                max_idx = i\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        st=[]\n        ans=0\n        for i in range(len(s)):\n            if len(st)==0:\n                st.append(i)\n            else:\n                if s[i]==s[st[-1]]:\n                    if cost[st[-1]]<cost[i]:\n                        ans+=cost[st[-1]]\n                        st.pop()\n                        st.append(i)\n                    else:\n                        ans+=cost[i]\n                else:\n                    st.append(i)\n        return ans", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        #greedy\n        target = s[0]\n        track_max = cost[0]\n        curr_sum = cost[0]\n        res = 0\n        for i in range(1, len(cost)):\n          if s[i] == target:\n            track_max = max(track_max, cost[i])\n            curr_sum += cost[i]\n          else:\n            if curr_sum != cost[i-1]: res += (curr_sum) - track_max\n            track_max = cost[i]\n            curr_sum = cost[i]\n            target = s[i]\n        if curr_sum != cost[i-1]: res += (curr_sum) - track_max\n        return res\n        \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        _min = 0\n        for i in range(len(s)-1):\n            if s[i] == s[i+1]:\n                _min += min(cost[i], cost[i+1]) \n                if cost[i] >= cost[i+1]:\n                    cost[i+1] = cost[i]\n        return _min", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        res = 0\n        if len(s) < 2: return res\n        first, second = 0, 1\n        while second < len(s):\n            if s[first] == s[second]:\n                if cost[first] <= cost[second]:\n                    res += cost[first]\n                    first = second\n                    second += 1\n                else:\n                    res += cost[second]\n                    second += 1\n            else:\n                first = second\n                second += 1\n        return res\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        total=0\n        for i in range(1,len(s)):\n            if s[i-1]==s[i]:\n                total+=min(cost[i-1],cost[i])\n                cost[i] = max(cost[i-1],cost[i])\n        return total", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        def find_cost(start, end):\n            a = cost[start:end+1]\n            a.sort()\n            return sum(a[:-1])\n        \n        res = 0\n        if len(s) == 1:\n            return res\n        \n        i = 1\n        start = -1\n        while i < len(s):\n            if s[i-1] == s[i] and start < 0:\n                start = i-1\n            if s[i] != s[i-1] and start >= 0:\n                res += find_cost(start, i-1)\n                start = -1\n            i += 1\n        if start >= 0:\n            res += find_cost(start, len(s)-1)       \n        \n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if len(s) == 1:\n            return 0\n        temp = []\n        j=0\n        for i in range(len(s)):\n            if i == len(s)-1:\n                if s[i]==s[j]:\n                    temp.append([j,i+1])\n                else:\n                    if (i-j)>1:\n                        temp.append([j,i])\n            else:\n                if s[j]!=s[i]:\n                    if (i-j) >1:\n                        temp.append([j,i])\n                    j=i\n        res = 0     \n        for i,j in temp:\n            new = cost[i:j]\n            val = max(new)\n            p=0\n            while p < len(new):\n                if new[p] == val:\n                    new.pop(p)\n                    break\n                p+=1\n            res+=sum(new)\n        return res\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if len(s) == 1:\n            return 0\n        pre_c = s[0]\n        pre_cost_max = cost[0]\n        count = 0\n        for c, _cost in zip(s[1:], cost[1:]):\n            if c == pre_c:\n                count += min(pre_cost_max, _cost)\n                pre_cost_max = max(pre_cost_max, _cost)\n            else:\n                pre_c = c\n                pre_cost_max = _cost\n        return count", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        length = 1\n        start, end = 0, 0\n        result = 0\n        for i in range(len(s)-1):\n            if s[i] == s[i+1]:\n                if length == 1:\n                    start = i\n                length += 1\n            else:\n                if length > 1:\n                    end = i\n                    sm = sum(cost[start:end+1])\n                    mx = max(cost[start:end+1])\n                    result += sm-mx\n                start = 0\n                end = 0\n                length = 1\n        if length > 1:\n            end = len(s)-1\n            sm = sum(cost[start:end+1])\n            mx = max(cost[start:end+1])\n            result += sm-mx\n        return result", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        to_delete = []\n        i = 0\n        while i < len(s):\n            j = i + 1\n            flag = False\n            while j < len(s) and s[j] == s[i]:\n                j += 1\n                flag = True\n            if flag:\n                to_delete.append((i, j))\n            i = j\n        ans = 0\n        # print(to_delete)\n        for interval in to_delete:\n            cos = sorted(cost[interval[0] : interval[1]])\n            l = interval[1] - interval[0] - 1\n            index = 0\n            for _ in range(l):\n                ans += cos[index]\n                index += 1\n        return ans", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        # identify consecutive characters\n        consecutive_log = []\n        consecutive_tuple = [-1,-1,-1]\n        previous_e = -1\n        for i, e in enumerate(s):\n            if e != previous_e:\n                consecutive_log.append(consecutive_tuple)\n                consecutive_tuple = [e, i, i]\n                previous_e = e\n            else:\n                consecutive_tuple[2]=i\n                previous_e=e\n        consecutive_log.append(consecutive_tuple)\n        # print(consecutive_log)\n        \n        total_cost = 0\n        for log in consecutive_log:\n            if log[1] != log[2]:\n                selected_costs = cost[log[1]:log[2]+1]\n                max_cost = max(selected_costs)\n                selected_costs.remove(max_cost)\n                total_cost += sum(selected_costs)\n        return total_cost\n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        stack = []\n        ans = 0\n        for i,c in enumerate(s):\n            if stack and s[stack[-1]] == c:\n                if cost[stack[-1]] < cost[i]:\n                    ans += cost[stack[-1]]\n                    stack.pop()\n                    stack.append(i)\n                else:\n                    ans += cost[i]\n            else:\n                stack.append(i)\n        return ans\n                \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        n = len(s)\n        minCost = 0\n        \n        left = right = 0\n        while right < n:\n            while right < n and s[right] == s[left]:\n                right += 1\n                \n            if right == left + 1:\n                left += 1\n            else: \n                minCost += sum(cost[left:right]) - max(cost[left:right])\n                left = right\n\n        return minCost", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        l,r=0,1\n        total=0\n        dels =0\n        for i in range(1,len(s)):\n            if s[i-1]==s[i]:\n                total+=min(cost[i-1],cost[i])\n                cost[i] = max(cost[i-1],cost[i])\n        return total", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        res = 0\n\n        n = len(s)\n        # while i < n:\n        # if i  + 1 < n and s[i] == s[i + 1]:\n        stack = []\n        # for i, c in enumerate(s):\n        i = 0\n        while i < n:\n            c = s[i]\n            if stack and s[stack[-1]] == c:\n                j = stack.pop()\n                prev_cost = cost[j]\n                if prev_cost < cost[i]:\n                    stack.append(i)\n                else:\n                    stack.append(j)\n                res += min(prev_cost, cost[i])\n                i += 1\n            else:\n                stack.append(i)\n                i += 1\n            # print(stack, i, c, res)\n            # if not stack:\n            #     stack.append(i)\n            #     i += 1\n            # else:\n            #     i += 1\n        # print(res)\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if len(s) == 0: return 0\n        \n        prev = 0\n        min_cost = 0\n        for c, group in itertools.groupby(list(s)):\n            group = list(group)\n            left = prev\n            right = left + len(group) - 1\n            prev = right + 1\n            if len(group) == 1: continue\n            \n            x = max(cost[left: right + 1])\n            total = sum(cost[left: right + 1])\n            min_cost += total - x \n            \n        return min_cost", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        ans, n, prev = 0, len(s), 0\n        for i in range(1, n):\n            if s[i] == s[i - 1]:\n                if cost[i] > cost[prev]:\n                    ans += cost[prev]\n                    prev = i\n                else: ans += cost[i]\n            else: prev = i\n        return ans\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        # O(n), greedy or stack\n        \n        res = 0\n        i = 0\n        while i < len(s)-1:\n            temp = i\n            while i < len(s)-1 and s[i] == s[i+1]:\n                i += 1\n            if temp < i:\n                res += sum(cost[temp:i+1]) - max(cost[temp:i+1])\n            i += 1\n        return res\n                \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        res = 0\n        prev = ''\n        pool = []\n        \n        for c, v in zip(s + ' ', cost + [0]):\n            if c != prev:\n                if len(pool) > 1:\n                    res += sum(pool) - max(pool)\n                prev = c\n                pool = [v]\n            else:\n                pool.append(v)\n        \n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        prv = 0\n        \n        res = 0\n        for i in range(1, len(s)):\n            if s[i] != s[i - 1]:\n                if i - prv > 1:\n                    mc = cost[prv]\n                    for j in range(prv, i):\n                        res += cost[j]\n                        if cost[j] > mc:\n                            mc = cost[j]\n                    res -= mc\n                prv = i\n        \n        if len(s) - prv > 1:\n            mc = cost[prv]\n            for j in range(prv, len(s)):\n                res += cost[j]\n                if cost[j] > mc:\n                    mc = cost[j]\n            res -= mc\n        \n        return res\n                \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        st = []\n        st.append((s[0], 0))\n        res = 0\n        n = len(s)\n        for i in range(1, n):\n            if st[-1][0] == s[i]:\n                x = st[-1][1]\n                if(cost[x] >= cost[i]):\n                    res += cost[i]\n                else:\n                    res += cost[x]\n                    st.pop()\n                    st.append((s[i], i))\n            else:\n                st.append((s[i], i))\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        output=0\n        s = list(s)\n        i=0\n        while i  < (len(s)-1):\n            if s[i] ==s[i+1]:\n                \n                if i == len(s)-2:\n                    output += min(cost[i],cost[i+1])\n                else:\n                    j=i+2\n                    \n                    while s[i] ==s[j] and j < len(s)-1:\n                        #print(j)\n                        j+=1\n                    \n                    print(cost[i:j])\n                   \n                    \n                    if s[-1]!=s[-2]:\n                        output =output + sum(cost[i:j]) - max(cost[i:j])\n                    \n                    elif j == len(s)-1:\n                        output =output + sum(cost[i:j+1]) - max(cost[i:j+1])\n                    else:\n                        output =output + sum(cost[i:j]) - max(cost[i:j])\n                    i=j-1\n            i+=1\n                \n        return output", "from typing import List\nclass Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s = list(s)\n        idx = [i for i in range(len(s))]\n        dic = dict(zip(idx, cost))\n        w = 0\n        cost = 0\n        for k in range(len(s)-1, 0, -1):\n            w = k - 1    \n            if s[k] == s[w]:\n                kCost = dic[k]\n                wCost = dic[w]\n                if kCost <= wCost:\n                    cost += kCost\n                    del s[k]\n                else:\n                    cost += wCost\n                    del s[w]\n                    dic[w] = dic[k]\n        s = ''.join(s)\n        return cost", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        n = len(s)\n        res = 0\n        i = j = 0\n        while j < n:\n            i = j\n            while j + 1 < n and s[j] == s[j + 1]:\n                j += 1\n            res += sum(cost[i:j+1]) - max(cost[i:j+1] or [0])\n            # print(i, j, cost[i:j+1])\n            j += 1\n        # print(s,cost, res)\n        # print()\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        ss = list(s)\n        tot_cost = 0\n        i = 0\n        while i < len(ss) - 1:\n            if ss[i] == ss[i+1]:\n                start_i = i\n                end_i = i+1\n                while end_i < len(ss) - 1 and ss[end_i] == ss[end_i + 1]:\n                    end_i += 1\n                dup_sum = sum(cost[start_i:end_i+1])\n                dup_max = max(cost[start_i:end_i+1])\n                tot_cost += dup_sum - dup_max\n                i = end_i\n            i += 1\n        \n        return tot_cost", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        res = 0\n        \n        if len(s) <= 1:\n            return 0\n        \n        i = 0\n        while i < len(s)-1:\n            j = i\n            costs = []\n            isCost = False\n            while j <= len(s)-2 and s[j+1] == s[i]:\n                isCost = True\n                costs.append(cost[j])\n                j += 1\n            if isCost:\n                costs.append(cost[j])\n            res += sum(sorted(costs, reverse=True)[1:])\n            i = j\n            i += 1\n                \n                \n        return res\n                \n", "class Solution:\n    def minCost(self, S: str, cost: List[int]) -> int:\n        def checkStr(s):\n            i=1\n            out = []\n            while i<len(s):\n                j=i\n                out1 = set([])\n                if s[j]==s[j-1]:\n                    while j<len(s) and s[j]==s[j-1]:\n                        out1.add(j-1)\n                        out1.add(j)\n                        j+=1\n                    out.append(list(out1))\n                    i=j\n                else:\n                    i+=1\n            return out\n        \n        cst = 0\n        s = list(S)\n        indexes = checkStr(s)\n        # print (indexes)\n        i=0\n        while i<len(indexes):\n            curr = indexes[i]\n            costs = list(map(lambda x:cost[x], curr))\n            # print (costs)\n            cst+=sum(costs)-max(costs)\n            i+=1\n        return cst", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        ma,res,total = 0,0,0\n        i = 0\n        while i < len(s)-1:\n            start = i\n            while i < len(s)-1 and s[i+1] == s[i]:   #\u54ea\u4e2a\u5728and\u524d\u5f88\u91cd\u8981\n                i +=1\n            end = i\n            if start == end:\n                i += 1\n            else:\n                for j in range(start, end+1):\n                    ma = max(ma, cost[j])\n                    total += cost[j]\n                res += total-ma\n                ma = 0\n                total = 0\n        return res\n                \n        \n#         for i in range(len(s)-1):\n#             if s[i+1] == s[i]:\n#                 temp = min(cost[i],cost[i+1])\n#                 res += temp\n                \n#         return res\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        ans, pos = 0, 0\n        \n        for _, v in itertools.groupby(s):\n            v = list(v)\n            if len(v) > 1:\n                to_sort = []\n                for x in range(len(v)):\n                    to_sort.append(cost[pos])\n                    pos += 1\n                ans += sum(sorted(to_sort)[:-1])\n            else:\n                pos += 1\n            \n        return ans", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        res = 0\n        stack = []\n        idx = 0\n        while idx < len(s):\n            while idx < len(s) - 1 and s[idx] == s[idx+1]:\n                stack.append(cost[idx])\n                idx += 1\n            if idx > 0 and s[idx] == s[idx-1]:\n                stack.append(cost[idx])\n            if stack:\n                res += (sum(stack) - max(stack))\n                stack = []\n            idx += 1\n        return res", "class Solution:\n    def minCost(self, s: str, cost) -> int:\n        l = 0\n        ans = 0\n        while l < len(s):\n            r = l + 1\n            if r < len(s) and s[r] == s[l]:\n                tmp_cost = cost[l]\n                max_cost = cost[l]\n                while r < len(s) and s[r] == s[l]:\n                    max_cost = max(max_cost, cost[r])\n                    tmp_cost += cost[r]\n                    r += 1\n                ans += tmp_cost - max_cost\n            l = r\n        return ans\n", "from heapq import nsmallest\n\nclass Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if len(s) < 2:\n             return 0\n        left, right = 0, 1\n        res = 0\n        window = dict()\n        while right < len(s):\n            if s[right] != s[left]:\n                right += 1\n                left += 1\n                continue\n            print(left)\n            while right < len(s) and s[right] == s[left]:\n                right += 1\n            res += sum(nsmallest(right - left - 1, cost[left:right]))\n            left = right \n            right += 1\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        import heapq\n        prev = ''\n        prices = []\n        count = 0\n        ans = 0\n        for char, cost in zip(s, cost):\n            if prev == char:\n                heapq.heappush(prices, cost)\n                count += 1\n                continue\n            else:\n                for _ in range(count):\n                    ans += heapq.heappop(prices)\n                count = 0\n                prev = char\n                prices = [cost]\n        if count != 0:\n            for _ in range(count):\n                    ans += heapq.heappop(prices)\n        return ans", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if len(s)<=1: return 0\n        res = 0\n        start = 0\n        while True:\n            if start>=len(s):\n                break\n            temp = start+1\n            for i in range(temp, len(s)):\n                if s[i]!=s[start]:\n                    start += 1\n                else:\n                    break\n            if start==len(s)-1:\n                break\n            end = start+2\n            while end<len(s):\n                if s[end]==s[start]:\n                    end += 1\n                else:\n                    break\n            res += (sum(cost[start:end]) - max(cost[start:end]))\n            start = end\n        return res\n        '''\n        start = -1\n        for i in range(1, len(s)):\n            if s[i]==s[i-1]:\n                start = i-1\n                break\n        if start==-1: return 0\n        end = start+2\n        SUM = cost[start]+cost[start+1]\n        MAX = max(cost[start], cost[start+1])\n        while end<len(s):\n            if s[end]==s[start]:\n                SUM += cost[end]\n                MAX = max(cost[end], MAX)\n                end += 1\n            else:\n                break\n        res += (SUM-MAX)\n        return res+self.minCost(s[end:], cost[end:])\n        '''", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s = list(s)\n        sums = 0\n        i = 0\n        while i<= len(s)-2:\n            if s[i]==s[i+1]:\n                sums += min(cost[i],cost[i+1])\n                cost[i+1] =max(cost[i],cost[i+1])\n            i+=1\n        return sums\n                \n                \n            \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        answer = 0\n        start = 0\n        \n        for i in range(1, len(s)):\n            if s[start] != s[i]:\n                deletions = sorted(cost[start : i], reverse=True)\n\n                while len(deletions) > 1:\n                    answer += deletions.pop()\n                \n                start = i\n                \n        deletions = sorted(cost[start : len(s)], reverse=True)\n\n        while len(deletions) > 1:\n            answer += deletions.pop()\n        \n        return answer", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        output = []\n        idx = 0\n        while idx < len(s):\n            char = s[idx]\n            newIdx = idx+1\n            arr = [idx]\n            while newIdx < len(s) and s[newIdx] == s[idx]:\n                arr.append(newIdx)\n                newIdx += 1\n            \n            idx = newIdx              \n            output.append(arr)\n            \n        totalCost = 0\n        for newArr in output:\n            if len(newArr) > 1:\n                costArr = []\n                for eachElem in newArr:\n                    costArr.append(cost[eachElem])\n                    \n                sortedArr = sorted(costArr, reverse=True)\n                \n                totalCost += sum(sortedArr[1:])\n        \n        return totalCost\n        \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        def num(s):\n            return ord(s)-ord('a')\n        dp=[0,0]\n        n=len(s)\n        # val=[-1]*26\n        C=1\n        for i in range(1,n):\n            if s[i]==s[i-1]:\n                if C==1:\n                    max_c=max(cost[i-1],cost[i])\n                    sum_c=dp[-1]+cost[i-1]+cost[i]\n                else:\n                    max_c=max(max_c,cost[i])\n                    sum_c+=cost[i]\n                c = sum_c-max_c\n                C+=1\n                dp.append(c)\n            else:\n                C=1\n                dp.append(dp[-1])\n        return dp[-1]", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        left, right = 0, 1\n        costSum = 0\n        while right < len(s):\n            \n            if s[left] == s[right]:\n                while right < len(s) and s[left] == s[right]:\n                    right += 1\n                tmp = cost[left:right]\n                maxIndex = tmp.index(max(tmp))\n                for i in range(len(tmp)):\n                    if i != maxIndex:\n                        costSum += tmp[i] \n                left = right\n                right += 1\n            else:\n                left += 1\n                right += 1\n        return costSum\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        def getNextIdx(idx):\n            curr = s[idx]\n            for j, ch in enumerate(s[idx+1:]):\n                if ch != curr:\n                    return j+idx+1\n            return len(s)\n\n        i = 0\n        \n        sol = 0\n        \n        while i < len(s):\n            next_i = getNextIdx(i)\n            if i < len(s)-1 and s[i] != s[i+1]:\n                i += 1\n            else:\n                curr = s[i]\n                max_cost_idx = i\n                for xx in range(i+1, min(next_i, len(s))):\n                    if cost[xx] > cost[max_cost_idx]:\n                        max_cost_idx = xx\n                for idx in range(i, min(next_i, len(s))):\n                    # print(idx)\n                    if idx != max_cost_idx:\n                        sol += cost[idx]\n                i = next_i\n        return sol\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s=list(s)\n        ret=0\n        i=1\n        while i<len(s):\n            if s[i]==s[i-1]:\n                ret+=min(cost[i],cost[i-1])\n                if cost[i]<cost[i-1]:\n                    \n                    cost[i],cost[i-1]=cost[i-1],cost[i]\n            i+=1\n        return ret", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        if len(s) == 0:\n            return 0\n        if len(s) == 1:\n            return 0\n\n        \n        @lru_cache(maxsize = None)\n        def dp(n):\n            \n            if n == 0:\n                return (0, 0)\n            \n            last = dp(n-1) #(val, lastword_index)\n            ans = 0\n            lastans = last[0]\n            last_index = last[1]\n            \n            next_index = 0\n            \n            if s[last_index] == s[n]:\n                if cost[last_index] <= cost[n]:\n                    ans = lastans + cost[last_index]\n                    next_index = n\n                    #print(n, last_index, ans)\n                else:\n                    ans = lastans + cost[n]\n                    next_index = last_index\n                    #print(n, n, ans)\n            else:\n                ans = lastans\n                next_index = n\n                \n            return (ans, next_index)\n        \n        return dp(len(s)-1)[0]", "from functools import reduce\nclass Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        t = 0\n        n = len(s)\n        if n <= 1:\n            return 0\n        ins = s\n        s = n\n        p = '?'\n        e = -1\n        for i,l in enumerate(ins):\n            if p == l:\n                if s == n:\n                    s = i-1\n            else:\n                p = l\n                if s != n:\n                    #only ones before are problematic\n                    t += reduce(lambda a,b:a+b,cost[s:i],0) - max(cost[s:i])\n                    s = n\n        if s != n:\n            t += reduce(lambda a,b:a+b,cost[s:],0) - max(cost[s:])\n        return t\n                \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        pre = None\n        val = 0\n        ans = 0\n        for e, v in zip(s, cost):\n            if pre == e:\n                ans += min(v, val)\n                val = max(v, val)\n            else:\n                pre, val = e, v\n        return ans", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        total = 0\n        for i in range(1,len(s)):\n            if s[i] == s[i-1]:\n                total += min(cost[i],cost[i-1])\n                cost[i] = max(cost[i],cost[i-1])\n        return total", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        to_delete = []\n        for i in range(len(s)):\n            if i > 0 and s[i] == s[i - 1] or i < len(s) - 1 and s[i] == s[i + 1]:\n                to_delete.append(i)\n        \n        groups, temp, prev = [], [], -1\n        for i in range(len(to_delete)):\n            if prev == -1:\n                prev = to_delete[i]\n                temp.append(to_delete[i])\n            else:\n                if i == len(to_delete) - 1:\n                    temp.append(to_delete[i])\n                    groups.append(temp[:])\n                else:\n                    if to_delete[i + 1] - to_delete[i] > 1 or s[to_delete[i + 1]] != s[to_delete[i]]:\n                        temp.append(to_delete[i])\n                        groups.append(temp[:])\n                        prev = -1\n                        temp = []\n                    else:\n                        temp.append(to_delete[i])\n\n        ans = 0\n        for group in groups:\n            total = 0\n            highest = 0\n            for index in group:\n                total += cost[index]\n                highest = max(highest, cost[index])\n            ans += total - highest\n            \n        return ans", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        answer=0; i=0;\n        while i<len(s)-1:\n            if s[i]==s[i+1]:\n                #input();\n                sumCost = cost[i]; maxCost = cost[i];\n                j=i+1;\n                while(j<len(s)-1 and s[j]==s[j+1]):\n                    sumCost+=cost[j];\n                    maxCost = max(maxCost, cost[j]);\n                    j+=1;\n                if s[j]==s[i]:\n                    sumCost+=cost[j];\n                    maxCost = max(maxCost, cost[j]);\n                #print('i=',i,'j=',j,'sumCost=', sumCost,'maxCost=', maxCost)\n                answer += sumCost-maxCost;\n                i=j+1\n            else:\n                i+=1;\n        return answer;", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n      prev = None\n      min_cost = 0\n      pq = []\n      \n      for char, c in zip(s, cost):\n        if not prev:\n          prev = char\n          heapq.heappush(pq, c)\n        elif prev != char:\n          prev = char\n          while len(pq) > 1:\n            min_cost += heapq.heappop(pq)\n          pq = [c]\n        else:\n          heapq.heappush(pq, c)\n          \n      while len(pq) > 1:\n        min_cost += heapq.heappop(pq)\n        \n      return min_cost\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s = list(s)\n        if len(s) < 2:\n            return 0\n        if len(s) == len(set(s)):\n            return 0\n        total = 0\n        while True:\n            i = 0                \n            deleted = False\n            for _, group in itertools.groupby(s):\n                group = list(group)\n                if len(group) > 1:\n                    idx_max, max_cost = -1, -1\n                    for j, c in enumerate(cost[i:i + len(group)]):\n                        if c == None:\n                            continue\n                        if c > max_cost:\n                            max_cost = c\n                            idx_max = i + j\n                    subtotal = 0\n                    for j in range(i, i + len(group)):\n                        if j == idx_max:\n                            continue\n                        subtotal += cost[j]\n                        cost[j] = None\n                        s[j] = None\n                    total += subtotal\n                    deleted = True\n                i += len(group)\n            if deleted:\n                s = [c for c in s if c != None]\n                cost = [c for c in cost if c != None]\n            else:\n                break\n        return total\n\ndef has_two_consecutive_chars(s: str) -> bool:\n    for i in range(1, len(s)):\n        if s[i - 1] == s[i]:\n            return True\n    return False\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        res = 0\n        i = 1\n        temp = cost[0]\n        while i < len(cost):\n            if s[i-1] == s[i]:\n                res += min(temp, cost[i])\n                temp = max(temp, cost[i])\n            else:\n                temp = cost[i]\n            i += 1\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        n = len(s)\n        \n        memo = {}\n        def f(prev, i):\n            if i == n:\n                return 0\n            \n            if (prev, i) in memo:\n                return memo[(prev, i)]\n            \n            if s[i] == prev:\n                # No choice, we have to delete s[i]\n                memo[(prev, i)] = cost[i] + f(s[i], i + 1)\n            elif i + 1 >= n or s[i] != s[i+1]:\n                # The next character is the not the same as s[i], no need to delete\n                memo[(prev, i)] = f(s[i], i + 1)\n            else:\n                # The next character exists (i + 1 < n) and it is the same as s[i].\n                # We may choose to delete s[i] or not delete s[i], return the min cost\n                # of two choices\n                memo[(prev, i)] = min(cost[i] + f(prev, i + 1), f(s[i], i + 1))\n            \n            return memo[(prev, i)]\n    \n        return f(None, 0)\n                      \n            \n            \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        # print(\\\"===\\\")\n        repeating=[]\n        last=None\n        ans=0\n        for i,c in enumerate(s):\n            # print(\\\"processing\\\",c)\n            if c!=last:\n                last=c\n                if len(repeating)>1:\n                    cost_win=cost[i-len(repeating):i]\n                    spent = sum(cost_win)-max(cost_win)\n                    # print(spent)\n                    ans+=spent\n                \n                repeating= [c]\n            \n            else:\n                repeating.append(c)\n                \n        if len(repeating)>1:\n            cost_win=cost[len(s)-len(repeating):]\n            spent = sum(cost_win)-max(cost_win)\n            # print(spent)\n            ans+=spent\n        return ans", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        stack = []\n        \n        res = 0\n        for i in range(len(cost)):\n            if not stack or s[stack[-1]] != s[i]:\n                stack.append(i)\n            else:\n                if stack and s[stack[-1]] == s[i]:\n                    idx = stack.pop()\n                    if cost[idx] >= cost[i]:\n                        res += cost[i]\n                        stack.append(idx)\n                    else:\n                        res += cost[idx]\n                        stack.append(i)\n        return res\n                \n                \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s = s+'#'\n        totalcost = 0\n        idx = 1\n        while idx<len(s):\n            if s[idx] == s[idx-1]:\n                start = idx-1\n                end = idx\n                idx +=1\n                \n                while idx<len(s):\n                    \n                    if s[idx]!=s[idx-1]:\n                        end = idx-1\n                        break\n                    else:\n                        idx+=1\n                 \n                \n                \n                print((start,end))\n                totalcost +=sum(cost[start:end+1])-max(cost[start:end+1])\n            else:\n                idx +=1\n        return totalcost\n            \n            \n                \n                    \n            \n              \n                    \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        mcost=0\n        i=0\n        c=0\n        j=0\n        while(i<len(s)):\n            j=i\n            while(i<len(s) and s[j]==s[i]):\n                i+=1\n                c+=1\n            if(c!=1):\n                mcost+=sum(cost[j:i])-max(cost[j:i])\n            c=0\n        return mcost", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s += '~'\n        def dedup(exp:List[int]) -> int:\n            return sum(exp) - max(exp)\n        \n        res = 0\n        current = []\n        for i in range(len(s)-1):\n            if s[i+1] == s[i]:\n                if len(current) == 0:\n                    current.append(cost[i])\n                current.append(cost[i+1])\n            else:\n                if len(current) > 1:\n                    res += dedup(current)\n                current = []\n        \n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s=list(s)\n        c=0\n        i=0\n        while(i<len(s)-1):\n            # start=i\n            st=0\n            end=0\n            if(s[i]==s[i+1]):\n                st=i\n                while(i<len(s)-1 and s[i]==s[i+1]):\n                        end=i+1\n                        i+=1\n                    \n                print((st,end))\n                c+=sum(cost[st:end+1])-max(cost[st:end+1])\n                print(c)\n            else:\n                i+=1\n        return c\n                \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        prev_idx = None\n        count = 0\n        for ii in range(1, len(s)):\n            b = s[ii]\n            if prev_idx is None:\n                prev_idx = ii - 1\n            a = s[prev_idx]\n            if a == b:\n                cost_a = cost[prev_idx]\n                cost_b = cost[ii]\n                count += min(cost_a, cost_b)\n                prev_idx = max([cost_a, prev_idx], [cost_b, ii])[1]\n            else:\n                prev_idx = None\n        return count", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        temp=[]\n        t=[]\n        i=0\n        while i<len(s)-1:\n            if s[i]==s[i+1]:\n                t.append(i)\n            while i<len(s)-1 and s[i]==s[i+1]:\n                t.append(i+1)\n                i+=1\n            if len(t)>0:\n                temp.append(t)\n                t=[]\n            i+=1\n        else:\n            if len(t)>0:\n                temp.append(t)\n                t=[]\n        print(temp)\n        ans=0\n        for i in temp:\n            tt=-max(cost[min(i):max(i)+1])\n            tt+=sum(cost[min(i):max(i)+1])\n            ans+=tt\n        return ans\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        i=0\n        ans=0\n        while i<len(s):\n            if i<len(s)-1 and s[i]==s[i+1]:\n                n=0\n                t=i\n                temp=s[i]\n                while i<len(s) and s[i]==temp:\n                    i+=1\n                    n+=1\n                #print(n, s, cost, cost[t:t+n], sum(cost[t:t+n]), max(cost[t:t+n]))\n                ans+=(sum(cost[t:t+n])-max(cost[t:t+n]))\n            else:\n                i+=1\n        return ans\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        @lru_cache\n        def f(s, i):\n            if i == len(s):\n                return 0\n            j = i\n            while j+1 < len(s) and s[j] == s[j+1]:\n                j += 1\n                \n            if j == i:\n                a = 0\n            else:\n                xx  = sorted([cost[k] for k in range(i, j+1)])\n                a = sum(xx[:-1])\n            \n            return a + f(s, j+1)\n        \n        \n        return f(s, 0)\n", "import heapq\nclass Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        i = 1\n        h = []\n        summ = 0\n        while i < len(s):\n            if(s[i]==s[i-1]):\n                while(i<len(s) and s[i]==s[i-1]):\n                    heapq.heappush(h,cost[i-1])\n                    i+=1\n                heapq.heappush(h,cost[i-1])\n                while len(h)>1:\n                    summ += heapq.heappop(h)\n                heapq.heappop(h)\n            else:\n                i+=1\n        return summ", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        cur_max = cur_cost = 0\n        total = 0\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                if cur_cost == 0:\n                    cur_cost = cost[i] + cost[i-1]\n                    cur_max = max(cost[i], cost[i-1])\n                else:\n                    cur_cost += cost[i]\n                    cur_max = max(cur_max, cost[i])\n            elif cur_cost != 0:\n                    total += cur_cost - cur_max\n                    cur_cost = cur_max = 0\n\n        if cur_cost != 0:\n            total += cur_cost - cur_max\n\n        return total", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        result = 0\n        p1 = 0\n        while p1 < len(s) - 1:\n            if s[p1] == s[p1+1]:\n                p2 = p1\n                totalSum, maxCost = cost[p2], cost[p2]\n                while p2 < len(s)-1 and s[p2] == s[p2+1]:\n                    p2 += 1\n                    totalSum += cost[p2]\n                    maxCost = max(maxCost, cost[p2])\n                result += totalSum-maxCost\n                p1 = p2+1\n            else:\n                p1 += 1\n                \n        return result\n                    \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        n = len(s)\n        def getnextidx(k):\n            for l in range(k+1, n):\n                if s[k] != s[l]:\n                    return l\n            return n\n            \n        i = 0\n        cost_used = 0\n        while i < n:\n            j = getnextidx(i)\n            if j - i > 1:\n                cost_used += sum(cost[i:j]) - max(cost[i:j])\n            i = j\n            \n        return cost_used", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        res = 0\n        i = 1\n        N = len(s)\n        \n        while i < N:\n            if s[i] == s[i-1]:\n                maxcost = cost[i-1]\n                totalcost = cost[i-1]\n                while i < N and s[i] == s[i-1]:\n                    totalcost += cost[i]\n                    maxcost = max(maxcost, cost[i])\n                    i += 1\n                    \n                print(totalcost, maxcost)\n                res += (totalcost - maxcost)\n                \n            i += 1\n            \n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s += '~'\n        def dedup(exp:List[int]):\n            return sum(exp) - max(exp)\n        \n        res = 0\n        current = []\n        for i in range(len(s)-1):\n            if s[i+1] == s[i]:\n                if len(current) == 0:\n                    current.append(cost[i])\n                current.append(cost[i+1])\n            if s[i+1] != s[i]:\n                if len(current) > 1:\n                    res += dedup(current)\n                current = []\n        \n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        cumu_cost = 0\n        max_cost = None\n        \n        prev_char = None\n        prev_cost = None\n        \n        result = 0\n        \n        for char, v in zip(s, cost):\n            \n            if prev_char and prev_char == char:\n                if max_cost is None:\n                    cumu_cost += v + prev_cost\n                    max_cost = max(v, prev_cost)\n                else:\n                    cumu_cost += v\n                    max_cost = max(max_cost, max(v, prev_cost))\n                \n            elif prev_char and prev_char != char and max_cost is not None:\n                \n                result += cumu_cost - max_cost\n                cumu_cost = 0\n                max_cost = None\n                \n                \n                \n        \n            prev_char = char\n            prev_cost = v\n        \n        if prev_char and max_cost is not None:\n            result += cumu_cost - max_cost\n        \n        return result\n\n        \n\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        last_char = ''\n        start = 0\n        ans = 0\n        s += '_'\n        cost.append(0)\n        \n        for i,c in enumerate(s):\n            \n            if c != last_char:\n                if i- start>1:\n                    ans += sum(cost[start: i]) - max(cost[start: i])\n                last_char = c\n                start = i\n                \n        return ans\n            \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n\n        i = 0\n        tot = 0\n        while i < len(s) - 1:\n            if s[i] == s[i + 1]:\n                start = i\n                while i < len(s) - 1 and s[i] == s[i + 1]:\n                    i += 1\n                mx = 0\n                for c in cost[start: i + 1]:\n                    tot += c\n                    mx = max(mx, c)\n                tot -= mx\n            i += 1\n        return tot\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        head_idx, tail_idx = 0, 1\n        total_cost = 0\n        \n        while tail_idx < len(s):\n            if s[head_idx] == s[tail_idx]:\n                if cost[head_idx] < cost[tail_idx]:\n                    total_cost += cost[head_idx]\n                    head_idx, tail_idx = tail_idx, tail_idx+1\n                else:\n                    total_cost += cost[tail_idx]\n                    tail_idx += 1\n            else:\n                head_idx, tail_idx = tail_idx, tail_idx+1\n                \n        return total_cost\n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        c=0\n      \n        for i in range(len(s)):\n            if i-1>=0 and s[i-1]==s[i]:\n                continue\n            k=i\n            while k<len(s) and s[k]==s[i]:\n                k+=1\n            if k>i+1:\n                print(i)\n                a=sum(cost[i:k])-max(cost[i:k])\n                c+=a\n        return c", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        ans=[]\n\n\n        i=0\n\n        while i<len(s):\n            count=0\n            for j in range(i+1,len(s)):\n                if s[j]!=s[i]:\n                    break\n                else:\n                    count+=1\n            if count>0:\n                ans.append((i,i+count))\n            i=j\n            if i==len(s)-1:\n                break\n\n        res=0\n\n        i=(3,5)\n\n        for i in ans:\n            k=sorted(cost[i[0]:i[1]+1])\n            res=res+sum(k[0:i[1]-i[0]])\n        \n        return res\n\n\n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n    \n        s += '~'\n    \n        def dedup(exp:List[int]):\n            return sum(exp) - max(exp)\n        \n        res = 0\n        i = 0\n        current = []\n        while i+1 < len(s) :\n            if s[i+1] == s[i]:\n                if len(current) == 0:\n                    current.append(cost[i])\n                current.append(cost[i+1])\n            if s[i+1] != s[i]:\n                if len(current) > 1:\n                    res += dedup(current)\n                current = []\n            i+=1\n            \n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        i = 1\n        current_cost = cost[0]\n        max_cost = cost[0]\n        ans = 0\n        while i < len(cost):\n            while i < len(cost) and s[i] == s[i-1]:\n                current_cost += cost[i]\n                max_cost = max(max_cost, cost[i])\n                i += 1\n                \n            ans += current_cost - max_cost\n            \n            if i < len(cost):\n                current_cost = cost[i]\n                max_cost = cost[i]\n            \n            i += 1\n            \n        return ans", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        i=0\n        res=0\n        j = 1\n        while j<len(s):\n            if s[i]==s[j]:\n                res+=min(cost[i],cost[j])\n                cost[j]=max(cost[i],cost[j])\n            i+=1\n            j+=1\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        if len(s) < 2:\n            return 0\n        f = 0\n        i = 0\n        s = list(s)\n        while i < len(s) - 1:\n            v1 = s[i]\n            v2 = s[i+1]\n            \n            if v1 == v2:\n                \n                c1 = cost[i]\n                c2 = cost[i+1]\n                \n                #print(v1,c1,c2,i)\n                \n                if c1 < c2:\n                    f += c1\n                else:\n                    f += c2\n                    cost[i+1] = c1\n            i += 1\n        \n        return f", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        out = 0\n        for i in range(len(s)-1):\n            if s[i] == s[i+1]:\n                out += min(cost[i],cost[i+1])\n                cost[i+1] = max(cost[i],cost[i+1])\n        return out        ", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n    \n        s += '~'\n    \n        def dedup(exp:List[int]):\n            print(exp)\n            return sum(exp) - max(exp)\n        \n        res = 0\n        i = 0\n        current = []\n        while i+1 < len(s) :\n            if s[i+1] == s[i]:\n                if len(current) == 0:\n                    current.append(cost[i])\n                current.append(cost[i+1])\n                \n            if s[i+1] != s[i]:\n                if len(current) > 1:\n                    res += dedup(current)\n                current = []\n            i+=1\n            \n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        last_char = ''\n        start = 0\n        ans = 0\n        s += '_'\n        cost.append(0)\n        \n        for i,c in enumerate(s):\n            \n            if c != last_char:\n                if i- start>1:\n                    print(ans)\n                    ans += sum(cost[start: i]) - max(cost[start: i])\n                last_char = c\n                start = i\n                \n        return ans\n            \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        inner_array = []\n        outer_array = []\n        consecutive = False\n        for i, val in enumerate(zip(s, cost)):\n            if i == len(cost) - 1:\n                break\n            else:\n                char = val[0]\n                c = val[1]\n                if char == s[i + 1]:\n                    if consecutive:\n                        inner_array.append(cost[i+1])\n                    else:\n                        inner_array.append(c)\n                        inner_array.append(cost[i+1])\n                        consecutive = True\n                    if i == len(cost) - 2:\n                        outer_array.append(inner_array)\n                else:\n                    consecutive = False\n                    if inner_array:\n                        outer_array.append(inner_array)\n                        inner_array = []\n\n        res = 0\n        for i in outer_array:\n            res += sum(sorted(i)[:-1])\n\n        return res\n                \n\n            \n                \n", "class Solution:\n        \n    def minCost(self, s: str, cost: List[int]) -> int:\n        result = 0\n        low = 0\n        \n        while low < len(cost) - 1:\n            high = low + 1\n            while high < len(cost) and s[high] == s[low]:\n                high += 1\n            \n            if high - low > 1:\n                a, ma = 0, float('-inf')\n                for i in range(low, high):\n                    a += cost[i]\n                    ma = max(ma, cost[i])\n                result += a - ma\n            low = high\n        return result", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        n = len(s)\n        if n ==1:\n            return 0\n        start = 0\n        end = 1\n        splits = []\n        while end < n:\n            while end<n and s[end]==s[start]:\n                end+=1\n            splits.append((start,end-1))\n            start = end\n        \n        answer = 0\n        for start,end in splits:\n            if start == end:\n                continue\n            else:\n                maxi = 0\n                costsum=0\n                for i in range(start,end+1):\n                    maxi = max(maxi,cost[i])\n                    costsum += cost[i]\n                costsum -= maxi\n                answer += costsum\n        return answer\n                    \n                    \n                    \n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        res = 0\n        for k, g in itertools.groupby(zip(s, cost), key=lambda p: p[0]):\n            g = list(g)\n            if len(g) > 1:\n                costs = [t[1] for t in g]\n                res += sum(costs) - max(costs)\n        return res", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        fee = max_cost = 0\n        for i, cst in enumerate(cost):\n            if i > 0 and s[i] != s[i - 1]:\n                max_cost = 0\n            fee += min(cst, max_cost)\n            max_cost = max(cst, max_cost)\n        return fee    ", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        current_char = 'A'\n        current_max = 0\n        answer = 0\n        for i, c in enumerate(cost):\n            if s[i] == current_char:\n                if current_max < c:\n                    answer += current_max\n                    current_max = c\n                else:\n                    answer += c\n            else:\n                current_char = s[i]\n                current_max = c\n        return answer", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        \n        s = list(s)\n        v = 0\n        i = 0\n        while i < len(s)-1:\n            if s[i] == s[i+1]:\n                v += min(cost[i],cost[i+1])   \n                cost[i+1] = max(cost[i],cost[i+1])\n            i += 1\n            \n        return v", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s = list(s)\n        sums = 0\n        i = 0\n        while i<= len(s)-2:\n            if s[i]==s[i+1]:\n                sums += min(cost[i],cost[i+1])\n                cost[i+1] =max(cost[i],cost[i+1])\n            i+=1\n            \n        return sums\n            \n", "class Solution:\n    def minCost(self, s: str, cost: List[int]) -> int:\n        s = s + ' '\n        out = 0\n        deleted = set()\n        start = 0\n        l = len(s)\n        while True:\n            prev = '='\n            to_delete = []\n            for i in range(start, l):\n                if i in deleted:\n                    continue\n                if s[i] == prev:\n                    to_delete.append((cost[prev_i], prev_i))\n                elif to_delete:\n                    to_delete.append((cost[prev_i], prev_i))\n                    break\n                prev = s[i]\n                prev_i = i\n            else:\n                break\n            start = prev_i\n            \n            to_delete.sort(reverse=True)\n            for i in range(1, len(to_delete)):\n                out += to_delete[i][0]\n                deleted.add(to_delete[i][1])\n        return out\n            \n            \n        \n", "class Solution:\n    def minCost(self, S: str, B: List[int]) -> int:\n        def if_continues_char(ind):\n            return S[ind] == S[ind+1]\n\n        def consecutive_char(ind):\n            consecutive_cost = B[ind]\n            min_cost = B[ind]\n            while ind < len(S) - 1 and S[ind] == S[ind+1]:\n                ind += 1\n                consecutive_cost += B[ind]\n                min_cost = max(min_cost, B[ind])\n            return ind + 1, consecutive_cost - min_cost\n\n        if not S or not B:\n            return 0\n        i, cost = 0, 0\n        while i < len(S) - 1:\n            if if_continues_char(i):\n                i, del_cost = consecutive_char(i)\n                cost += del_cost\n            else:\n                i += 1\n        return cost"]
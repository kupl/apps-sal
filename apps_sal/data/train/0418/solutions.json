["class Solution:\n     def integerReplacement(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         '''\n         if n == 1:\n             return 0\n         if not (n & 1):\n             return self.integerReplacement(n//2) + 1\n         return min(self.integerReplacement(n+1), self.integerReplacement(n-1)) + 1\n         '''\n         ans = 0\n         while n > 1:\n             if n % 2 == 0:\n                 n = n // 2\n             elif n % 4 == 1 or n == 3:\n                 n -= 1\n             else:\n                 n += 1\n             ans += 1\n         return ans\n", "class Solution:\n     def integerReplacement(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         variants = [n]\n         nsteps = 0\n         seen = set()\n         \n         while True:\n             n = len(variants)\n             for i in range(n):\n                 v = variants[i]\n                 if v == 1:\n                     return nsteps\n                 \n                 if v % 2 == 0:\n                     x = v // 2\n                     if x in seen:\n                         variants[i] = 0\n                     else:\n                         variants[i] = x\n                         seen.add(x)\n                 else:\n                     for x in v-1, v+1:\n                         if x not in seen:\n                             variants.append(x)\n                             seen.add(x)\n                     \n             nsteps += 1\n", "class Solution:\n     def integerReplacement(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         def dfs(n):\n             if n==1: return 0\n             if n==3: return 2\n             if (n & 0x1)==0: return dfs(n>>1)+1\n             elif ((n>>1) & 0x1)==0: return dfs(n-1)+1\n             else: return dfs(n+1)+1\n             \n         return dfs(n)", "class Solution:\n     def integerReplacement(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         return self.integerReplacementDP(n)\n         # return self.integerReplacementBitwise(n)\n         if n == 1:\n             return 0\n \n         if n % 2 == 0:\n             return 1 + self.integerReplacement(n / 2)\n         else:\n             return 1 + min(self.integerReplacement(n + 1), self.integerReplacement(n - 1))\n         \n     def integerReplacementDP(self, n, dp=None):\n         if dp is None:\n             dp = {}\n             \n         if n == 1:\n             return 0\n         \n         if n not in dp:\n             if n % 2 == 0:\n                 dp[n] = 1 + self.integerReplacementDP(n / 2, dp=dp)\n             else:\n                 dp[n] = 1 + min(self.integerReplacementDP(n + 1, dp=dp), self.integerReplacementDP(n - 1, dp=dp))\n         return dp[n]\n \n     def integerReplacementBitwise(self, n):\n         \"\"\"\n         \n         5 -> 4 -> 2 -> 1\n         5 -> 6 -> 3 -> 2 -> 1\n         \n         101 100\n         101 110   \n         \n         11 10\n         \"\"\"\n         \n         count = 0\n         while n != 1:\n             if (n & 1) == 0:\n                 n >>= 1\n             elif n == 3 or bin(n + 1).count('1') > bin(n - 1).count('1'):\n                 n -= 1\n             else:\n                 n += 1\n             count += 1\n \n         return count\n", "class Solution:\n     def Is2(self, n):\n         root = int(math.log(n, 2))\n         return (2**root) == n\n     def GetNear2(self, n):\n         if n == 0:\n             return -1\n         if n == 1:\n             return 0\n         if n == 2:\n             return 1\n         if self.Is2(n):\n             return n\n         for ind in range(n - 1, n + 2):\n             if self.Is2(ind):\n                 return ind\n         return -1\n     def integerReplacement(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n \n         m = n\n         cnt = 0\n         while m != 1:\n             if m == 1:\n                 return cnt\n             if m == 2:\n                 return 1 + cnt\n             if m <= 4:\n                 return 2 + cnt\n             if m <= 6:\n                 return 3 + cnt\n             if m % 2 == 0:\n                 cnt += 1\n                 m = int(m / 2)\n                 continue\n             k = m % 4\n             if k == 1:\n                 cnt += 1\n                 m = int(m - 1)\n             elif k == 3:\n                 cnt += 1\n                 m = int(m + 1)\n             \n         return cnt\n", "class Solution:\n     def integerReplacement(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         steps = 0\n         while n > 1:\n             if n&1 == 0:\n                 n >>= 1\n                 steps += 1\n             else:\n                 if n == 3:\n                     n -= 1\n                 else:\n                     n += 1 if n&2 else -1\n                 n >>= 1\n                 steps += 2\n         return steps", "class Solution:\n     def integerReplacement(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         table = {}\n         def helper(i):\n             if i == 1:\n                 return 0\n             if i in table:\n                 return table[i]\n             if i % 2 == 0:\n                 return helper(i // 2) + 1\n             table[i] = min(helper(i+1), helper(i-1)) + 1\n             return table[i]\n         return helper(n)\n", "class Solution:\n     def integerReplacement(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         queue = collections.deque([n])\n         step = 0\n         while len(queue):\n             sz = len(queue)\n             while sz > 0:\n                 sz -= 1\n                 num = queue.popleft()\n                 if num == 1:\n                     return step\n                 if num & 1:\n                     queue.append(num + 1)\n                     queue.append(num - 1)\n                 else:\n                     queue.append(num // 2)\n             step += 1\n         return step\n"]
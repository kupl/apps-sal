["class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def should_alert(t):\n            if len(t) < 3:\n                return False\n            \n            for i in range(len(t) - 2):\n                if t[i + 2] <= t[i] + 100:\n                    return True\n            return False\n        \n        time = collections.defaultdict(list)\n        alert = []\n        for name, t in zip(keyName, keyTime):            \n            ti = int(t[:2] + t[3:])\n            time[name].append(ti)\n        \n        ret = []\n        for name in time:\n            time[name].sort()\n            if should_alert(time[name]):\n                ret.append(name)\n    \n        ret.sort()\n        return ret", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        checker = {}\n        l = len(keyName)\n        for i in range(l):\n            if keyName[i] not in checker:\n                checker[keyName[i]] = [keyTime[i]]\n            else:\n                checker[keyName[i]].append(keyTime[i])\n        ans = []\n        for a,b in checker.items():\n            l = len(b)\n            if l>2:\n                b.sort()\n                for i in range(l-2):\n                    t = b[i].split(':')\n                    t = str(int(t[0])+1)+':'+t[1]\n                    if len(t)==4:\n                        t = '0'+t\n                    if t>=b[i+2]:\n                        ans.append(a)\n                        break\n        ans.sort()\n        return ans", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        def convert_to_minutes(time):\n            hhmm = time.split(':')\n            hh, mm = int(hhmm[0]), int(hhmm[1])\n            return 60*hh + mm\n        \n        mod = 24*60\n        res = set()\n        minutes = [convert_to_minutes(hhmm) for hhmm in keyTime]\n        d = collections.defaultdict(list)\n        for i in range(len(minutes)):\n            worker = keyName[i]\n            time = minutes[i]\n            d[worker].append(time)\n        for worker in d:\n            d[worker].sort()\n            for i in range(2, len(d[worker])):\n                if d[worker][i] - d[worker][i-2] <= 60:\n                    res.add(worker)\n                    break\n        return sorted(list(res))", "from sortedcontainers import SortedList\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        hm = defaultdict(SortedList)\n        res = set()\n        \n        for name, time in zip(keyName, keyTime):\n            int_time = self.get_time_as_int(time)\n            hm[name].add(int_time)\n\n        for name in hm:\n            if self.check(hm[name]):\n                res.add(name)\n        return sorted(res)\n    \n    def check(self, arr):\n        left = 0\n        for right in range(len(arr)):\n            if right - left + 1 == 3:\n                if arr[right] - arr[left] <= 100:\n                    return True\n                left += 1\n        return False\n    \n    def get_time_as_int(self, time):\n        t1 = time[:2]\n        t2 = time[3:]\n        int_time = int(t1+t2)\n        return int_time\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        dictTime = collections.defaultdict(list)\n        setName = set()\n        for x,y in zip(keyName,keyTime):\n            dictTime[x].append(y)\n            setName.add(x)\n        \n        \n        listName = list(setName)\n        listName.sort()\n        for key in dictTime:\n            dictTime[key].sort()\n        \n        print(dictTime)\n        \n        out = []\n        for name in listName:\n            listT = dictTime[name]\n            if len(listT) >= 3:\n                start = 0\n                end = 2\n                condit = False\n                while end < len(listT):\n                    # print(listT[start][:2],listT[end][:2])\n                    # print(listT[start][3:],listT[end][3:])\n                    # print(int(listT[start][:2])+1 == int(listT[end][:2]) )\n                    # print(int(listT[start][3:]) <= int(listT[end][3:]))\n                    \n                    if int(listT[start][:2]) == int(listT[end][:2]):\n                        condit= True\n                        break\n                    \n                    if (int(listT[start][:2])+1 == int(listT[end][:2]) and int(listT[start][3:]) >= int(listT[end][3:]) ):\n                        # print('ciao')\n                        condit = True\n                        break\n\n                    start += 1\n                    end = start +2\n                if condit:\n                    out.append(name)\n        return out\n                        \n                \n", "class Solution:\n    # hash map, time O(n), space O(n)\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        records = collections.defaultdict(list)\n        for name, time in zip(keyName, keyTime):\n            minutes, seconds = int(time[:2]), int(time[-2:])\n            records[name].append(60 * minutes + seconds)\n        res = []\n        for name in records:\n            q = collections.deque()\n            found = False\n            for time in sorted(records[name]):\n                while q and abs(time - q[0]) > 60:\n                    q.popleft()\n                q.append(time)\n                if len(q) >= 3:\n                    found = True\n                    break\n            if found:\n                res.append(name)\n        return sorted(res)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        cands = [(n, int(t[:2]) * 60 + int(t[-2:])) for n, t in zip(keyName, keyTime)]\n        cands.sort()\n        rec = defaultdict(list)\n        out = []\n        for n, t in cands:\n            if n in out: continue\n            \n            if n not in rec:\n                rec[n].append(t)\n            else:\n                if 0<= abs(t - rec[n][0]) <= 60:\n                    rec[n].append(t)\n                else:\n                    while rec[n] and abs(t - rec[n][0]) > 60:\n                        rec[n].pop(0)\n                    rec[n].append(t)\n                    rec[n].sort()\n            if len(rec[n]) == 3:\n                out.append(n)\n        \n        return sorted(out)", "import datetime as dt\nfrom collections import defaultdict\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        access = defaultdict(list)\n        res = set()\n        NameTime = []\n        for i in range(len(keyName)):\n            name = keyName[i]\n            h,m = map(int,keyTime[i].split(':'))\n            d = dt.datetime(2020,10,6,h,m)\n            NameTime.append([d,name])\n        NameTime.sort()\n        \n        period = dt.timedelta(hours = 1)\n        for d,name in NameTime:\n            if name not in res:\n                while access[name] and access[name][0] + period < d:\n                    access[name].pop(0)\n                access[name].append(d)\n                if len(access[name]) >= 3: res.add(name)\n            \n        return sorted(list(res))", "class Solution:\n    def alertNames(self, names: List[str], times: List[str]) -> List[str]:\n        m = {}\n        N = len(names)\n        alerts = set()\n        minutes = lambda time: int(time.split(':')[0]) * 60 + int(time.split(':')[1])\n        for name, time in zip(names, times):\n            if name not in m:\n                m[name] = deque()\n            m[name].append(minutes(time))\n        for name, times in m.items():\n            q = deque()\n            for time in sorted(times):\n                while len(q) and q[0] + 60 < time:\n                    q.popleft()\n                q.append(time)\n                if 3 <= len(q):\n                    alerts.add(name)\n                    break\n        return sorted(alerts)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d = {}\n        res = set()\n\n        for i in range(len(keyName)):\n            if keyName[i] in d.keys():\n                h = int(keyTime[i].split(\\\":\\\")[0])\n                m = int(keyTime[i].split(\\\":\\\")[1])\n                d[keyName[i]].append((h, m))\n            else:\n                d[keyName[i]] = []\n                h = int(keyTime[i].split(\\\":\\\")[0])\n                m = int(keyTime[i].split(\\\":\\\")[1])\n                d[keyName[i]].append((h, m))\n        for k, v in d.items():\n            List.sort(v)\n\n            for i in range(len(v)-2):\n                (h0, m0) = v[i]\n                (h1, m1) = v[i+2]\n                if h1 - h0 <= 1:\n                    if m1 <= m0 or h1 == h0:\n                        res.add(k)\n        res = list(res)\n        List.sort(res)               \n        return res\n    ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        records = defaultdict(list)\n        alerts = set()\n        for i in range(len(keyName)):\n            records[keyName[i]].append(keyTime[i])            \n        for k,v in list(records.items()):\n            if len(v) < 3:\n                continue\n            else:\n                r = sorted(v, key=lambda word:(int(word[0:2]), int(word[3:5])))\n                for j in range(0, len(r)-2):\n                    start = r[j]\n                    end = r[j+2]                    \n                    time1 = start.split(':')\n                    time2 = end.split(':')                    \n                    md = int(time2[1]) - int(time1[1])\n                    hd = int(time2[0]) - int(time1[0])  \n                    \n                    f = 0\n                    if md < 0:\n                        md += 60\n                        f = -1                   \n                    td = md + (hd+f)*60                    \n                    if 0<td<=60:\n                        if k not in alerts:\n                            alerts.add(k)\n                            break\n        return sorted(list(alerts))\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n#convert all times to minutes\n#compile in a name based dictionary\n#check who has violated the code\n#return those names in alphabetical olrder\n        mappedTimes = []\n        for time in keyTime:\n            mappedTimes.append(time_to_int(time))\n        \n        mydict = dict()\n        for i in range(len(keyName)):\n            if keyName[i] not in mydict:\n                mydict[keyName[i]] = [mappedTimes[i]]\n            else:\n                mydict[keyName[i]].append(mappedTimes[i])\n                \n        for key in mydict:\n            mydict[key] = sorted(mydict[key])\n        \n        rowdy_bois = []\n        for name in mydict:\n            max_counter = 0\n            times = mydict[name]\n            \n            early_index = 0\n            earliest_time = times[0]\n\n            counter = 0\n            for time in times:\n                counter += 1\n                if time-earliest_time <= 60:\n                    if counter >= max_counter:\n                        max_counter = counter\n                else:\n                    while time-earliest_time > 60:\n                        early_index += 1\n                        earliest_time = times[early_index]\n                        counter -= 1\n            print('{} had max counter {}'.format(name, max_counter))\n            \n            if max_counter >= 3:\n                rowdy_bois.append(name)\n                \n        return sorted(rowdy_bois)\n                \n        \n        \n\ndef time_to_int(time):\n    time = time.split(\\\":\\\")\n    return int(time[0]) * 60 + int(time[1])\n    ", "def compareTimesStr(beginStr, endStr):\n    return compareTimes(int(beginStr[:2]), int(beginStr[-2:]), int(endStr[:2]), int(endStr[-2:]))\n\ndef compareTimes(beginHr: int, beginMin: int, endHr: int, endMin: int):\n    if endHr < beginHr:\n        return False # because not same day\n    if beginHr == endHr:\n        return True\n    elif endHr - beginHr > 1:\n        return False\n    else:\n        return endMin - beginMin <= 0\n    \ndef hasAlert(times: List[str]) -> bool:\n    if len(times) < 3:\n        return False\n    \n    times.sort()\n    #print(times)\n    i = 0\n    while i < len(times) - 2:\n        if compareTimesStr(times[i], times[i + 2]):\n            return True\n        i += 1\n    return False\n    \n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        ans = []\n        if len(keyName) < 3:\n            return ans\n        \n        zippedPairs = list(zip(keyName, keyTime))\n        keyTime = [x for _, x in sorted(zippedPairs)]\n        print(keyTime)\n        keyName.sort()\n        \n        \n        start = 0\n        \n        for i in range(len(keyName)):\n            #print(i)\n            if keyName[i] == keyName[start] and i < len(keyName) - 1:\n                pass\n            elif i < len(keyName) - 1:\n                if hasAlert(keyTime[start:i]):\n                    ans.append(keyName[start])\n                start = i\n            else: \n                if hasAlert(keyTime[start:i + 1]):\n                    ans.append(keyName[start])\n        \n        return sorted(ans)\n        \n        \n", "from collections import defaultdict\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d=defaultdict(list)\n        ans=[]\n        for i in range(len(keyName)):\n            temp=keyTime[i].strip().split(':')\n            d[keyName[i]].append(int(temp[0]+temp[1]))\n            names=list(d.keys())\n        for i in names:\n            count=0\n            times=d[i]\n            times.sort()\n            for j in range(len(times)-2):\n                curr=times[j]\n                nex=times[j+2]\n                if abs(curr-nex)<=100:\n                    if i not in ans:\n                        ans.append(i)\n        return sorted(ans)\n                    \n", "def within_hour(large,small):\n        if abs(large[0] - small[0]) >= 2:\n            return False\n        if large[0] - small[0] == 1 and small[1] < large[1]:\n            print((large,small))\n            return False\n        return True\nclass Solution:\n    \n    \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        sorted_list = sorted(zip(keyTime,keyName))\n        # print(sorted_list)\n        alerted = []\n        people = {}\n        for time_str,name in sorted_list:\n            if name not in alerted:\n                time = [int(time_str[:2]),int(time_str[-2:])]\n                if name in list(people.keys()):\n                    if len(people[name]) == 2:\n                        if within_hour(time,people[name][1]):\n                            people[name].append(time)\n                            if not within_hour(time,people[name][0]):\n                                del people[name][0]\n                            else:\n                                alerted.append(name)\n                        else:\n                            people[name] = [time]\n                    else:\n                        if not within_hour(time,people[name][0]):\n                            people[name] = [time]\n                        else:\n                            people[name].append(time)\n                else:\n                    people[name] = [time]\n        return sorted(alerted)\n                        \n", "from collections import defaultdict, deque\n\nclass Solution:\n    def alertNames(self, name: List[str], time: List[str]) -> List[str]:\n        z = zip(name, time)\n        hmap = defaultdict(list)\n        for c in z:\n            h, m = map(int,c[1].split(\\\":\\\"))\n            t = h *60 + m\n            hmap[c[0]].append(t)\n        print(hmap)\n        \n        names, op = list(set(name)), []\n        names.sort()\n                \n        for name in names:\n            hmap[name].sort() \n            found = False\n            current = deque()\n            \n            for time in hmap[name]:\n                current.append(time)\n                while time - current[0] > 60:\n                    current.popleft()\n                found |= len(current) >= 3\n            if found:\n                op.append(name)\n        \n        return op", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        n = len(keyName)\n        \n        alert = defaultdict(dict)\n        ans = []\n        zipper = list(zip(keyName, keyTime))\n        zipper = list(zipper)\n        zipper.sort(key = lambda x: (x[0], x[1]))\n        \n        for i in range(n - 2):\n            (name, time) = zipper[i]\n            if name in ans:\n                continue\n            (next_name, next_time) = zipper[i + 2]\n            \n            if next_name != name:\n                continue\n                \n            time = int(time[:2] + time[3:])\n            next_time = int(next_time[:2] + next_time[3:])\n            \n            if next_time - time <= 100:\n                ans.append(name)\n                \n        return ans\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dic = {}\n        res = set()\n        \n        for i in range(len(keyName)):\n            name = keyName[i]\n            time = keyTime[i]\n            \n            if name not in dic:\n                dic[name] = []\n                \n            time = list(map(int, time.split(':')))\n            \n            time = time[0] + time[1]/60\n            dic[name].append(time)\n            \n        for name in dic:\n            t = sorted(dic[name])\n            if len(t)>=3:\n                for j in range(len(t)-2):\n                    if t[j+2] - t[j] <= 1.0001:\n                        res.add(name)\n                        \n       \n        return sorted(list(res))\n            \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        m = {}\n        N = len(keyName)\n        alerts = set()\n        minutes = lambda time:int(time.split(\\\":\\\")[0])*60 + int(time.split(\\\":\\\")[1])\n        for name, time in zip(keyName, keyTime):\n            if name not in m:\n                m[name] = collections.deque()\n            m[name].append(minutes(time))\n        \n        for name, times in m.items():\n            q = collections.deque()\n            for time in sorted(times):\n                while len(q) and q[0]+60 < time:\n                    q.popleft()\n                q.append(time)\n                if(len(q)>2):\n                    alerts.add(name)\n                    break\n        return sorted(alerts)\n            ", "class Solution:\n    def gethourlater(self, time):\n        hr = time[:time.index(\\\":\\\")]\n        hr = int(hr)+1\n        hr = str(hr)\n        hr = hr if len(hr)==2 else \\\"0\\\"+hr\n        return hr+time[time.index(\\\":\\\"):]\n        \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        n = len(keyName)\n        s = [(keyName[i], keyTime[i]) for i in range(n)]\n        s.sort()\n        \n        ind = 0\n        res = []\n        while ind < len(s):\n            name = s[ind][0]\n            found = False\n            start = ind\n            while ind < len(s) and name == s[ind][0]:\n                while start < len(s) and ind < len(s) and self.gethourlater(s[start][1]) < s[ind][1]:\n                    start += 1\n                if ind-start >= 2:\n                    found = True\n                ind += 1\n            if (found): res += [name]\n        return res\n        ", "class Solution:\n    def alertNames(self, names: List[str], times: List[str]) -> List[str]:\n        dic = {}\n        n = len(names)\n        alert = set()\n        \n        arr = [tup for tup in zip(names, times)]\n        \n        arr.sort(key = lambda ele: ele[1])\n        \n        for i in range(n):\n            name, time = arr[i][0], arr[i][1]\n            tup = time.split(':')\n            hour, minu = int(tup[0]), int(tup[1])\n            int_time = hour * 60 + minu\n            dic[name] = dic.get(name, []) + [int_time]\n            \n            curlen = len(dic[name])\n            if curlen >= 3 and int_time - dic[name][curlen-3] <= 60:\n                alert.add(name)\n                \n        return sorted(list(alert))\n        \n            \n            \n", "from collections import deque\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        usermap = {}\n        ansmap = {}\n        \n        def strtomin(foo):\n            return int(foo[0:2]) * 60 + int(foo[3:])\n        \n        def analyze(foo):\n            d = deque()\n            for i in foo:\n                d.append(i)\n                while d[0] < i - 60:\n                    d.popleft()\n                if len(d) >= 3:\n                    return True\n            return False\n                \n        \n        for i in range(len(keyName)):\n            name = keyName[i]\n            time = strtomin(keyTime[i])\n            \n            if name not in usermap:\n                usermap[name] = []\n            usermap[name].append(time)\n\n        for i in usermap:\n            usermap[i].sort()\n            if analyze(usermap[i]):\n                ansmap[i] = True\n\n        return sorted(ansmap.keys())", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        Info = [[keyTime[i], keyName[i]] for i in range(len(keyName))]\n        Info.sort()\n        keyTime = [x[0] for x in Info]\n        keyName = [x[1] for x in Info]\n        \n        cnt = collections.defaultdict(lambda: collections.deque())\n        def diff(prev, curr):\n            val = (int(curr[:2]) - int(prev[:2]))*60 + int(curr[3:]) - int(prev[3:])\n            return val > 60 or val < 0\n        res = set()\n        \n        for i in range(len(keyName)):\n            curr = keyTime[i]\n            #if cnt[keyName[i]]:\n            #    print(diff(cnt[keyName[i]][0], curr))\n            while cnt[keyName[i]] and diff(cnt[keyName[i]][0], curr):\n                cnt[keyName[i]].popleft()\n            if len(cnt[keyName[i]]) >= 2: \n                res.add(keyName[i])\n            cnt[keyName[i]].append(curr)\n        return sorted(res)        ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        worker_dict = {}\n        for i in range(len(keyName)):\n            worker = keyName[i]\n            time = keyTime[i]\n            if worker in worker_dict:\n                worker_dict[worker].append(time)\n            else:\n                worker_dict[worker] = [time]\n        ret = [worker for worker in worker_dict.keys() if self.three_or_more(worker_dict[worker])]\n        return sorted(ret)\n    \n    def three_or_more(self, times):\n        times = sorted(times)\n        for i in range(len(times)):\n            count = 0\n            time = times[i]\n            within_hour_curr = [times[j] for j in range(i, len(times)) if self.within_hour(time, times[j])]\n            if len(within_hour_curr) >= 3:\n                return True\n        return False\n    \n    def within_hour(self, time1, time2):\n        earlier = min(time1, time2)\n        later = max(time1, time2)\n        e_hour, e_min = earlier.split(\\\":\\\")\n        l_hour, l_min = later.split(\\\":\\\")\n        if l_hour == e_hour:\n            return True\n        elif int(l_hour) - int(e_hour) == 1:\n            if int(l_min) <= int(e_min):\n                return True\n        return False\n            ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        d = defaultdict(list)\n        result = []\n        \n        for i in range(len(keyName)):\n            time = keyTime[i].split(\\\":\\\")\n            minutes = int(time[0]) * 60 + int(time[1])\n            d[keyName[i]].append(minutes)\n            \n        for k, v in d.items():\n            d[k] = sorted(v)\n        \n        \n        for k, v in d.items():\n            #print(k, v)\n            if len(v) < 3:\n                continue\n            \n            i = 0\n            while i + 2 < len(v):\n                #print(k, v[i], v[i + 2])\n                if v[i + 2] - v[i] <= 60:\n                    result.append(k)\n                    break\n                i += 1\n        \n        return sorted(result)\n            \n                            \n        ", "from sortedcontainers import SortedList\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        alerted_workers = set()\n        worker_enter = {}\n        for name, time in zip(keyName, keyTime):\n            if name in alerted_workers:\n                continue\n            time = int(time[:2])*60+int(time[-2:])\n            if not name in worker_enter:\n                worker_enter[name] = SortedList()\n            if len(worker_enter[name]) >= 2:\n                index = worker_enter[name].bisect(time)\n                if (index-2 >= 0 and time-worker_enter[name][index-2] <= 60) or (index-1 >= 0 and index < len(worker_enter[name]) and worker_enter[name][index]-worker_enter[name][index-1] <= 60) or (index+1 < len(worker_enter[name]) and worker_enter[name][index+1]-time <= 60):\n                    alerted_workers.add(name)\n            worker_enter[name].add(time)\n        return list(sorted(alerted_workers))\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        c = collections.defaultdict(list)\n        for i in range(len(keyName)):\n            name = keyName[i]\n            time = keyTime[i]\n            c[name].append(time)\n        \n        res = []\n        # print(c)\n        for k,v in c.items():\n            t = sorted(v)\n            times = 1\n            i = 0\n            j = 1\n            # print(t)\n            while j < len(t):\n                if self.inHour(t[i], t[j]):\n                    times += 1\n                    j += 1\n                    if times >= 3:\n                        res.append(k)\n                        break\n                else:\n                    times -= 1\n                    i += 1\n        return sorted(res)\n    \n    def inHour(self, start, end):\n        sH, sM = start.split(\\\":\\\")\n        eH, eM = end.split(\\\":\\\")\n        s = int(sH)*60+int(sM)\n        e = int(eH)*60+int(eM)\n        if e-s <= 60:\n            return True\n        return False\n    ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dic = collections.defaultdict(list)\n        ans = set()\n        for name, time in sorted(zip(keyName, keyTime), key = lambda x:x[1]):\n            if name not in ans:\n                h, m = map(int, time.split(':'))\n                t = h*60+m\n                if len(dic[name])>=2 and dic[name][-2]>=t-60:\n                    ans.add(name)\n                    del dic[name]\n                else:\n                    dic[name].append(t)\n                    dic[name] = dic[name][-2:]\n        return sorted(ans)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def get_time(time):\n            return int(time[:2]) * 60 + int(time[3:])\n        map = {}\n        for name, time in zip(keyName, keyTime):\n            if name not in map:\n                map[name] = []\n            map[name].append(get_time(time))\n        \n        ans = []\n        for name in sorted(map.keys()):\n            times = sorted(map[name])\n            # print(name, times)\n            \n            for i in range(len(times) - 2):\n                if times[i+2] - times[i] <= 60:\n                    ans.append(name)\n                    break\n            \n        return ans\n        \n", "class Solution:\n    def lastOneHour(self, end, cur):\n        endHr = end.split(\\\":\\\")\n        curHr = cur.split(\\\":\\\")\n        if int(endHr[0]) - int(curHr[0]) == 0:\n            return True\n        if int(endHr[0]) - int(curHr[0]) == 1 and ((int(endHr[1]) + 60 - int(curHr[1])) <= 60):\n            return True\n        return False\n    \n    def checkHour(self, l):\n        if len(l) <= 2:\n            return False\n        i = 0\n        j = 1\n        while j < len(l):\n            if self.lastOneHour(l[j], l[i]):\n                j+=1\n                if j - i >= 3:\n                    return True\n            else:\n                i+=1\n        return False\n        \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d = {}\n        res = []\n        for i in range(0, len(keyName)):\n            # print(\\\"\\\n######\\\")\n            name = keyName[i]\n            # print(f\\\"Name: {name} Time: {keyTime[i]}\\\")\n            if name not in d:\n                # print(f\\\"Name not in d. Adding: {d}\\\")\n                d[name] = [[keyTime[i]], False]\n            else:\n                # print(\\\"Name is in d\\\")\n                # print(d[name])\n                if not d[name][1]:\n                    d[name][0].append(keyTime[i])\n                    d[name][0].sort()\n                    cur = 0\n                    if self.checkHour(d[name][0]):\n                        res.append(name)\n                        d[name][1] = True\n                    \n#                     while cur < len(d[name][0]):\n#                         r = self.lastOneHour(d[name][0][-1], d[name][0][cur])\n#                         if not r:\n#                             cur+=1\n#                         else:\n#                             break\n#                     if len(d[name][0]) - cur >= 3:\n                        # res.append(name)\n                        # d[name][1] = True\n                # print(d[name])\n        res.sort()\n        return res", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        from collections import defaultdict, deque\n        maps = defaultdict(deque)\n        \n        res = set()\n        for name, time in sorted(zip(keyName, keyTime)):\n            h = int(time[:2])\n            m = int(time[3:])\n            t = h * 60 + m\n\n            queue = maps[name]\n            while queue and queue[0][0] * 60 + queue[0][1] < t - 60:\n                queue.popleft()\n            queue.append([h, m])\n\n            if len(queue) >= 3:\n                    res.add(name)\n        return sorted(res)\n", "from collections import deque, defaultdict\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def time(s):\n            hr, mn = map(int, s.split(':'))\n            return hr * 60 + mn\n        ans = set()\n        d = defaultdict(deque)\n        l = list(zip(keyName, map(time, keyTime)))\n        l.sort(key=lambda x : x[1])\n        for k, t in l:\n            d[k].append(t)\n            if len(d[k]) == 3 and t - d[k].popleft() <= 60:\n                ans.add(k)\n        return sorted(ans)", "class Solution:\n    # Simple hashmap and sliding window\n    def lastOneHour(self, end, cur):\n        endHr = end.split(\\\":\\\")\n        curHr = cur.split(\\\":\\\")\n        if int(endHr[0]) - int(curHr[0]) == 0:\n            return True\n        if int(endHr[0]) - int(curHr[0]) == 1 and ((int(endHr[1]) + 60 - int(curHr[1])) <= 60):\n            return True\n        return False\n    \n    def checkHour(self, l):\n        if len(l) <= 2:\n            return False\n        i = 0\n        j = 1\n        while j < len(l):\n            if self.lastOneHour(l[j], l[i]):\n                j+=1\n                if j - i >= 3:\n                    return True\n            else:\n                i+=1\n        return False\n        \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d = {}\n        res = []\n        for i in range(0, len(keyName)):\n            name = keyName[i]\n            if name not in d:\n                d[name] = [[keyTime[i]], False]\n            else:\n\n                if not d[name][1]:\n                    d[name][0].append(keyTime[i])\n                    d[name][0].sort()\n                    cur = 0\n                    if self.checkHour(d[name][0]):\n                        res.append(name)\n                        d[name][1] = True\n        res.sort()\n        return res", "import math\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dic = {}\n        for i, name in enumerate(keyName):\n            t = keyTime[i]\n            if name in dic:\n                dic[name].append(int(t[0:2] + t[3:]))\n            else:\n                dic.setdefault(name, [int(t[0:2] + t[3:])])\n        alert = []\n        def ihan(name):\n            timeList = dic[name]\n            timeList.sort()\n            print(dic[name])\n            for t in range(len(timeList) - 2):\n                print(math.floor(timeList[t]/100) * 100)\n                if timeList[t+2] > timeList[t] and timeList[t+2] - timeList[t] <= 100:\n                    return True\n            return False\n        for name in dic:\n            if len(dic[name]) > 2 and ihan(name):\n                alert.append(name)\n            alert.sort()\n        return alert", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def calcmin(t: str) -> int:\n            return int(t[:2]) * 60 + int(t[3:]) \n        key, res = {}, []\n        for i, v in enumerate(keyName):\n            if not v in key:\n                key[v] = []\n            key[v] += [keyTime[i]]\n        for k in key:\n            key[k].sort()\n            for i in range(2, len(key[k])):\n                if calcmin(key[k][i]) - calcmin(key[k][i-2]) <= 60:\n                    res += [k]\n                    break\n        return sorted(res)", "import time\nclass Solution:\n    def alertNames(self, keyName, keyTime) :\n        hmap = {}\n        for i in range(len(keyName)):\n            if keyName[i] in hmap:\n                hmap[keyName[i]].append(keyTime[i])\n            else:\n                hmap[keyName[i]] = [keyTime[i]]\n        tempKeyName,tempKeyTime = list(keyName),list(keyTime)\n        keyName = []\n        temp = []\n        for k,v in hmap.items():\n            tempV = []\n            for i in v:\n                t = i.split(\\\":\\\")\n                tempV.append(int(t[0])*60 + int(t[-1]))\n            tempV.sort()\n            for j in tempV:\n                keyName.append(k)\n                temp.append(j)\n\n            \n\n        # temp = []\n        # for i in keyTime:\n        #     t = i.split(\\\":\\\")\n        #     temp.append(int(t[0])*60 + int(t[-1]))\n        # keyTime = [int(\\\"\\\".join(list(str(i).split(\\\":\\\")))) for i in keyTime]\n        # print(temp)\n        res,i,currCount,currName,startTime,endtime = [],1,1,keyName[0],temp[0],temp[0]+60\n        while i < len(keyName):\n            t = i\n            while i < len(keyName) and keyName[i] == keyName[i-1] and temp[i] <= endtime and temp[i] > startTime:\n            # keyTime[i] > keyTime[i-1] and :\n                currCount += 1\n                i += 1\n            if i >= len(keyName):\n                break\n            if currCount >= 3:\n                res.append(currName)\n                currCount = 0\n                currName = keyName[i]\n                startTime = temp[i]\n                endtime = startTime + 60\n            else:\n                currCount = 1\n                i = t+1\n                currName = keyName[t]\n                startTime = temp[t]\n                endtime = startTime + 60\n        if currCount >=3 :\n            res.append(currName)\n        res = list(set(res))\n        res.sort()\n        return res\n\n# s = Solution()\n# keyName =[\\\"a\\\",\\\"a\\\",\\\"a\\\",\\\"a\\\",\\\"a\\\",\\\"a\\\",\\\"b\\\",\\\"b\\\",\\\"b\\\",\\\"b\\\",\\\"b\\\"]; keyTime =[\\\"23:27\\\",\\\"03:14\\\",\\\"12:57\\\",\\\"13:35\\\",\\\"13:18\\\",\\\"21:58\\\",\\\"22:39\\\",\\\"10:49\\\",\\\"19:37\\\",\\\"14:14\\\",\\\"10:41\\\"]\n# print(s.alertNames(keyName,keyTime))\n", "from collections import deque\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        def diff(start,end):\n            h1,m1=start.split(\\\":\\\")\n            h2,m2=end.split(\\\":\\\")\n            \n            mini=60-int(m1)+int(m2)\n            hour=(int(h2)-int(h1)-1)*60\n            mini+=hour\n\n            \n            \n            return mini/60\n        \n        \n        if len(keyName)<=2:\n            return []\n        \n        ans=set()\n        A=[]\n        for i in range(len(keyName)):\n            A.append((keyTime[i],keyName[i]))\n            \n        A.sort(key=lambda x:x[0])\n        q=deque([])\n        d={}\n        for i,(t,n) in enumerate(A):\n\n            if n in d:\n                d[n]+=1\n                \n            else:\n                d[n]=1\n                \n            q.append((t,n))\n            while diff(q[0][0],t)>1:\n                if q[0][1] in d and d[q[0][1]]>=1:\n                    d[q[0][1]]-=1\n                    \n                q.popleft()\n            \n            if d[n]>=3:\n                ans.add(n)\n            \n            \n                \n        \n        ans=list(ans)\n        ans.sort()\n        \n        return ans\n            \n \n                \n                \n                    \n                    \n            \n        \n        \n        ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        newlist = [[keyName[i],int(keyTime[i].split(\\\":\\\")[0])*60+int(keyTime[i].split(\\\":\\\")[1])] for i in range(len(keyName))]\n        newlist = sorted(newlist, key = lambda x: x[1])\n        print(newlist)\n        res = []\n        last = collections.defaultdict(list)\n        for i in range(len(keyName)):\n            if newlist[i][0] in res:\n                continue\n            if newlist[i][0] not in last:\n                last[newlist[i][0]].append(newlist[i][1])\n            else:\n                while len(last[newlist[i][0]])>0 and newlist[i][1] -last[newlist[i][0]][0]>60:\n                    last[newlist[i][0]].pop(0)\n                last[newlist[i][0]].append(newlist[i][1])\n                if len(last[newlist[i][0]])>=3:\n                    res.append(newlist[i][0])\n        return sorted(res)\n        # for i in range(len(keyName)):\n        #     if keyName[i] in res:\n        #         continue\n        #     if keyName[i] not in last:\n        #         curh =int(keyTime[i].split(\\\":\\\")[0])\n        #         curmin = int(keyTime[i].split(\\\":\\\")[1])\n        #         last[keyName[i]].append(curh*60+curmin)\n        #     else:\n        #         curh = int(keyTime[i].split(\\\":\\\")[0])\n        #         curmin = int(keyTime[i].split(\\\":\\\")[1])\n        #         curtime = curh*60+curmin\n        #         # if curtime<last[keyName[i]][-1]:\n        #         #     curtime+=24*60\n        #         while len(last[keyName[i]])>0 and (curtime-last[keyName[i]][0]>60 or curtime-last[keyName[i]][0]<0):\n        #             last[keyName[i]].pop(0)\n        #         last[keyName[i]].append(curtime)\n        #         if len(last[keyName[i]])>=3:\n        #             res.append(keyName[i])\n        # return sorted(res)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        data = {user:[] for user in set(keyName)}\n        result = set()\n        for user, time in zip(keyName, keyTime):\n            hour, minute = tuple(map(int, time.split(\\\":\\\")))\n            time = 60*hour+minute\n            data[user].append(time)\n        \n        data = {user: sorted(data[user]) for user in data}\n    \n        for user in data:\n            for i in range(2, len(data[user])):\n                if data[user][i]-data[user][i-2] <= 60:\n                    result.add(user)\n                    break;\n                    \n        \n        return sorted(result)\n            \n            \n        ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        people = []\n        \n        rec_tries = {}\n        \n        queue = deque()\n\n        \n        for user, time in sorted(zip(keyName, keyTime), key = lambda x:x[1]):\n            time = time.split(\\\":\\\")\n            mins = int(time[0]) * 60 + int(time[1])\n            queue.append((user, mins))\n                \n            \n            while queue[0][1] < mins - 60:\n                to_rem = queue.popleft()\n            \n                rec_tries[to_rem[0]] -= 1\n                    \n            if user in rec_tries:\n                rec_tries[user] += 1\n            else:\n                rec_tries[user] = 1\n                \n            if rec_tries[user] >= 3:\n                people.append(user)\n                rec_tries[user] = -inf\n                    \n        return sorted(people)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        visit_times = {}\n        ans = set()\n        for i, name in enumerate(keyName):\n            visit_times[name]= visit_times.get(name,[]) + [keyTime[i]]\n        for employee in visit_times.keys():\n            visit_times[employee] = sorted(visit_times[employee])\n            for i in range(len(visit_times[employee])-2):\n                if not(self.hour_diff(visit_times[employee][i],visit_times[employee][i+2])):\n                    ans.add(employee)\n        return sorted(list(ans))\n                \n        \n    def hour_diff(self, a,b):\n        minute_a = int(a.split(\\\":\\\")[1])\n        minute_b = int(b.split(\\\":\\\")[1])\n        hour_a = int(a.split(\\\":\\\")[0])\n        hour_b = int(b.split(\\\":\\\")[0])\n        minute_diff = minute_b-minute_a\n        hour_diff = hour_b-hour_a\n        return (hour_diff > 1 or (hour_diff == 1 and minute_diff>0)) or hour_diff < 0", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        tm = list(map(lambda x: int(x.split(':')[0])*60 + int(x.split(':')[1]), keyTime))\n        ans = set()\n        tmp = []\n        for name, tm in zip(keyName, tm):\n            tmp.append((tm, name))\n        \n        tmp.sort()\n        d = defaultdict(deque)\n        for time, name in tmp:\n            # print(name, time)\n            while d[name] and abs(time - d[name][0]) > 60:\n                d[name].popleft()\n            d[name].append(time)\n            \n            if len(d[name]) >= 3:\n                ans.add(name)\n            \n        return sorted(ans)", "class Solution:\n    def within_hour(self, t1, t2):\n        hh1, ss1 = list(map(int, t1.split(':')))\n        hh2, ss2 = list(map(int, t2.split(':')))\n        hdiff = hh2 - hh1\n        if hdiff > 1 or hdiff < 0:\n            return False\n        sdiff = ss2 - ss1\n        #print(t1, t2, hdiff, sdiff, hdiff * 60 + sdiff)\n        return (hdiff * 60 + sdiff) <= 60\n\n\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n\n        d = {}\n        result = set()\n        for kn, kt in zip(keyName, keyTime):\n            if kn in d:\n                d[kn].append(kt)\n            else:\n                d[kn] = [kt]\n        result = []\n        for k, v in list(d.items()):\n            v.sort(key=lambda x: tuple(map(int, x.split(':'))))\n            for i in range(len(v) - 2):\n                if self.within_hour(v[i], v[i + 2]):\n                    result.append(k)\n                    break\n        return sorted(result)\n        \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        arr = sorted(zip(keyName, keyTime), key = lambda x: self.convert(x[1]))\n        times = defaultdict(list)\n        ans = set()\n        for name, time in arr:\n            time = self.convert(time)\n            if name not in ans:\n                if len(times[name]) >= 2 and abs(time - min(times[name])) <= 60:\n                    ans.add(name)\n                    continue\n                \n                times[name].append(time)\n                times[name].sort()\n                while times[name][-1] - times[name][0] > 60:\n                    times[name].pop(0)\n                    \n        return sorted(ans)\n                \n    def convert(self, time):\n        hours = 60 * int(time[0:2])\n        minutes = int(time[3:5])\n        return hours + minutes", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        out = []\n        \n        freq = {}\n        \n        alerts = {}\n        for i in range(len(keyName)):\n            seconds = int(keyTime[i][:2]) * 60 + int(keyTime[i][-2:])\n            if keyName[i] in alerts:\n                alerts[keyName[i]].append(seconds)\n            else:\n                alerts[keyName[i]] = [seconds]\n                freq[keyName[i]] = 0\n        \n        print(alerts)\n        \n        for name, time in list(alerts.items()):\n            for i in range(len(time) - 2):\n                time = sorted(time)\n                if time[i+1] - time[i] <= 60 and time[i+2] - time[i] <= 60:\n                    freq[name] += 1\n\n        \n        print(freq)\n        \n        for name, _ in list(freq.items()):\n            if freq[name] >= 1:\n                out.append(name)\n        \n        return sorted(out)\n        \n        \n", "from collections import defaultdict\nclass Solution:\n    def alertNames(self, name: List[str], time: List[str]) -> List[str]:\n        li = [[int(t[0:2])*100 + int(t[3:]), n] for t , n in zip(time , name)]\n        li = sorted(li )\n        d=defaultdict(int)\n        dc = defaultdict(int)\n        n=len(name)\n#         s= set()\n#         print(li)\n#         for i in range(n):\n#             if li[i][1] in d:\n#                 print(d[li[i][1]] ,li[i][0],-d[li[i][1]] +li[i][0])\n#                 if  li[i][0] -d[li[i][1]] <=100:\n#                     pass\n                    \n#                 else:\n#                     dc[li[i][1]] =0\n            \n#             d[li[i][1]]= li[i][0]  \n                \n#             dc[li[i][1]]+=1\n#             if dc[li[i][1]]>=3:\n#                 s.add(li[i][1])\n#             print(dc,d)\n                \n                    \n                    \n                    \n                    \n        \n        i,j=0,0\n        ans=0\n        #print(li)\n        s=set()\n        while i<=j and j<n:\n            #print(li[j][0]-li[i][0], i,j)\n            if li[j][0]-li[i][0]==0:\n                d[li[j][1]]=1\n                j+=1\n            elif li[j][0]-li[i][0]<=100:\n                d[li[j][1]]+=1\n                #print(d[li[j][1]],\\\"sg\\\")\n                if d[li[j][1]]>=3:\n                    s.add(li[j][1])\n                j+=1\n                 \n            else:\n                \n                d[li[i][1]]-=1\n                i+=1\n        return sorted(list(s))\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n\n        def to_minutes(s):\n            h, m = list(map(int, s.split(':')))\n            return h * 60 + m\n\n        alerts = set()\n        m = defaultdict(list)\n        for time, name in sorted((to_minutes(time), name) for time, name in zip(keyTime, keyName)):\n            times = m[name]\n            times.append(time)\n            if len(times) >= 3 and times[-3] + 60 >= times[-1]:\n                alerts.add(name)\n        return sorted(alerts)\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        idx = sorted(range(len(keyTime)), key=lambda i:keyTime[i])\n        keyName = [keyName[i] for i in idx]\n        keyTime.sort()\n        self.D = collections.defaultdict(collections.deque)\n        res =set()\n        for n, t in zip(keyName, keyTime):\n            self.D[n].append(t)\n            #print(self.D[n][0], t)\n            while self.expire(self.D[n][0], t):\n                self.D[n].popleft()\n            if len(self.D[n]) >= 3:\n                res.add(n)\n        return sorted(res)\n    \n    def expire(self, t1, t2):\n        if t2[:2] == '00':\n            if t1[:2] != '00':\n                return True\n            return t1 > t2\n        if t1 > t2:\n            return True\n        tt = (int(t2[:2]) + 23) % 24\n        return t1 < \\\"{:02d}{}\\\".format(tt, t2[2:])", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        used = {}\n        res = set()\n        \n        def greaterThanHour(t1, t2):\n            t1 = t1.split(':')\n            t2 = t2.split(':')\n            h1, h2 = int(t1[0]), int(t2[0])  \n            m1, m2 = int(t1[1]), int(t2[1])\n                \n            return ((h2-h1)*60 + (m2 - m1)) > 60\n        \n        for n, t in zip(keyName, keyTime):\n            if n not in used:\n                used[n] = []\n            \n            used[n].append(t)\n\n        for k in used:\n            used[k] = sorted(used[k])\n            p1 = p2 = 0\n            \n            while p2 < len(used[k]):\n                if greaterThanHour(used[k][p1], used[k][p2]):\n                    p1 += 1\n                if p2 - p1 == 2:\n                    res.add(k)\n                    break\n                p2 += 1\n\n        return sorted(list(res))", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        '''\n        mapping ={\n            'leslie': {\n                '13' : 3,\n                '14' : ['14:00', '14:45'],\n                }\n            }\n        '''\n        \n        def to_ts(t:str):\n            hour, minute = t.split(':')\n            return 60 * int(hour) + int(minute)\n            \n        \n        def in_a_hour(t1, t2):\n            return abs(to_ts(t1) - to_ts(t2)) <= 60\n            \n        \n        from datetime import datetime\n        \n        mapping = {name:[] for name in keyName}\n        \n        for i in range(len(keyName)):\n            mapping[keyName[i]].append(keyTime[i])\n            \n        for val in list(mapping.values()):\n            val.sort(key = to_ts)\n            \n        print(mapping)\n        \n        def more_than_3_in_a_hour(arr):\n            l = r = 0\n            while r < len(arr):\n                if in_a_hour(arr[l], arr[r]):\n                    if r - l >= 2:\n                        return True\n                    r += 1\n                else:\n                    l += 1\n        \n        return sorted([name for name, times in list(mapping.items()) if more_than_3_in_a_hour(times)])\n                    \n                \n                    \n            \n        \n", "import heapq\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d = {}\n        aler = set()\n        \n        for (name,time) in sorted(zip(keyName,keyTime) , key = lambda x: x[1]):\n            if name in aler:\n                continue\n                \n            h,m = time.split(\\\":\\\")\n            stamp = (int(h)*60 + int(m))%(24*60)\n            #print(h,m)\n            \n            if name not in d: \n                d[name] = [stamp]\n                heapq.heapify(d[name])\n            else:\n                heapq.heappush(d[name],stamp)\n                if stamp <= d[name][0] + 60:\n                    if len(d[name]) >= 3:\n                        aler.add(name)\n                        del d[name]\n                else:\n                    while d[name] and d[name][0]+60 < stamp:\n                        del d[name][0]\n                    \n            #print(d)\n        return sorted(aler)\n                \n                ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        from collections import deque\n        inp = defaultdict(list)\n        for k, v in zip(keyName, keyTime):\n            inp[k].append(v)\n        out = []\n        for k,v in inp.items():\n            n = sorted(v)\n            time = deque()\n            for i in n:\n                tmp = i.split(\\\":\\\")\n                time.append((int(tmp[0])*60)+int(tmp[1]))\n                for j in list(time):\n                    if abs(time[-1]-j)>60:\n                        time.popleft()\n                if len(list(time))>=3:\n                    out.append(k)\n                    \n        return sorted(set(out))\n            \n                    \n                \n            \n        \n    ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        alerts = set()\n        \n        def translate(time):\n            hours, minutes = time.split(':')\n            return 60 * int(hours) + int(minutes)\n        \n        sorted_times = sorted(enumerate(map(translate, keyTime)), key=lambda p:p[1])\n        counts = collections.defaultdict(int)\n        q = collections.deque()\n        \n        for i, time in sorted_times:\n            while len(q) and q[0][0] + 60 < time:\n                _, p = q.popleft()\n                counts[p] -= 1\n                \n            p = keyName[i]\n            counts[p] += 1\n            q.append((time, p))\n            if counts[p] >= 3:\n                alerts.add(p)\n                \n        return sorted(alerts)\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d = defaultdict(list)\n        if not keyName:\n            return []\n        n = len(keyName)\n        for i in range(n):\n            d[keyName[i]].append(keyTime[i])\n        \n        ans = []\n        def delta(t1, t2):\n            t1 = list(map(int, t1.split(':')))\n            t2 = list(map(int, t2.split(':')))\n            h1, m1 = t1\n            h2, m2 = t2\n            if h2 - h1 > 1 or (h2 - h1 == 1 and m2 > m1):\n                return True\n            return False\n        # print(d)\n        for name in d:\n            times = d[name]\n            times.sort()\n            cur = [times[0]]\n            t = 1\n            for i in range(1, len(times)):\n                t = times[i]\n                cur.append(t)\n                while cur and delta(cur[0], t):\n                    cur.pop(0)\n                # print(cur)\n                if len(cur) == 3:\n                    ans.append(name)\n                    break\n        return sorted(ans)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def getmins(time):\n            h,m=time.split(':')\n            return int(h)*60+int(m)\n        def timediff(time1,time2):\n            return getmins(time1)-getmins(time2)\n        d=defaultdict(list)\n        for name,time in zip(keyName,keyTime):\n            d[name].append(time)\n        res=[]\n        for key in d:\n            vals=d[key]\n            slow=0\n            for fast in range(len(vals)):\n                vals.sort()\n                while timediff(vals[fast],vals[slow])>60:\n                    slow+=1\n                if fast-slow>=2:\n                    res.append(key)\n                    break\n        res.sort()\n        return res", "\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        name_to_time = collections.defaultdict(list)\n        for name, hour_minute in zip(keyName, keyTime):\n            hour, minute = map(int, hour_minute.split(':'))\n            time = hour * 60 + minute\n            name_to_time[name].append(time)\n        names = []    \n        for name, time_list in name_to_time.items():\n            time_list.sort()\n            for i, time in enumerate(time_list):\n                if i >= 2 and time - time_list[i - 2] <= 60:\n                    names.append(name)\n                    break\n        return sorted(names)", "class Solution:\n    def alertNames(self, l1: List[str], l2: List[str]) -> List[str]:\n        d = {}\n        for i in l1:d[i] = [-float('inf')]\n        ans = set()\n        l = [[l1[i], l2[i]] for i in range(len(l1))]\n        l.sort(key = lambda x:x[1])\n        for i in range(len(l1)):\n            l1[i] = l[i][0]\n            l2[i] = l[i][1]\n        for i in range(len(l1)):\n            curr = l2[i]\n            curr = curr.split(':')\n            # print(curr)\n            curr = int(''.join(curr))\n            \n            d[l1[i]].append(curr)\n        ans = []\n        for i in d:\n            for j in range(2, len(d[i])):\n                if d[i][j] - d[i][j - 2] <= 100:\n                    ans.append(i)\n                    break\n        return sorted(ans)", "class Solution:\n    from collections import defaultdict, deque\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        data = defaultdict(list)\n        for name, t in zip(keyName, keyTime):\n            data[name].append(t)\n            \n        def compare(t1, t2):\n            t1 = t1.split(':')\n            t2 = t2.split(':')\n            if t1[0] == t2[0] and t1[1] < t2[1]:\n                return True\n            if int(t2[0]) - int(t1[0]) == 1 and t1[1] >= t2[1]:\n                return True\n            return False\n         \n        r = []\n        for name, times in list(data.items()):\n            times.sort()\n            q = deque()\n            for t in times:\n                if not q:\n                    q.append(t)\n                else:\n                    while q and not compare(q[0], t):\n                        q.popleft()\n                    q.append(t)\n                    if len(q) >= 3:\n                        r.append(name)\n                        break\n                        \n        return sorted(r)\n                        \n            \n", "class Solution:\n    def alertNames(self, name: List[str], time: List[str]) -> List[str]:\n        d=collections.defaultdict(list)\n        \n        for i in range(len(name)):\n            c=int(time[i][:2])*60+int(time[i][3:])\n            d[name[i]].append(c)\n        for i in d:\n            d[i].sort()\n        ans=[]\n        for i in d:\n            for j in range(len(d[i])-2):\n                if d[i][j+2]-d[i][j]<=60:\n                    ans.append(i)\n                    break\n        ans.sort()\n        return ans\n            \n", "class Solution:\n    # [\\\"daniel\\\",\\\"daniel\\\",\\\"daniel\\\",\\\"luis\\\",\\\"luis\\\",\\\"luis\\\",\\\"luis\\\"]\n    # [\\\"10:00\\\",\\\"10:40\\\",\\\"11:00\\\",\\\"09:00\\\",\\\"11:00\\\",\\\"13:00\\\",\\\"15:00\\\"]\n    \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        temp=[]\n        \n        for name,time in zip(keyName,keyTime):\n            temp.append([name,time])\n        \n        temp.sort(key=lambda x: (x[0],x[1]))\n        \n        ans=[]\n        def inhour(t1,t3):\n            def hrmn(t1):\n                hr,mn=t1.split(':')\n                return int(hr)*60+int(mn)\n\n            it1,it3=hrmn(t1),hrmn(t3)\n            \n            return it3-it1<=60\n        \n        for i in range(2, len(temp)):\n            (name1,time1)=temp[i-2]\n            (name3,time3)=temp[i]\n            if name1==name3:\n                if inhour(time1,time3) and (len(ans)==0 or ans[-1]!=name1):\n                    ans.append(name1)\n        \n        return ans\n            \n            \n", "\ndef diff(time2, time1):\n    t1 = int(time1[:2]) * 60 + int(time1[3:])\n    t2 = int(time2[:2]) * 60 + int(time2[3:])\n        \n    return t2 - t1\n    \nclass Solution:\n            \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        l = []\n        for name, time in zip(keyName, keyTime):\n            l.append((name, time))\n        \n        l = sorted(l, key = lambda x: x[1])\n        \n        keyName = [i[0] for i in l]\n        keyTime = [i[1] for i in l]\n        result = set()\n        index = 0\n        \n        hash_map = {}\n        i = 0\n        \n        while(i < len(keyName)):\n            name = keyName[i]\n            time = keyTime[i]\n            dif = diff(time, keyTime[index])\n            if ( dif > 60 or dif < 0):\n                \n                if(dif < 0):\n                    index = i\n                    hash_map.clear()\n                    hash_map[name] = 1\n                    i += 1\n                    continue\n                    \n                elif (dif>60):\n                    hash_map[keyName[index]] -= 1\n                    index += 1\n                    continue\n            \n            if hash_map.get(name, -1) == -1:\n                hash_map[name] = 1\n            \n            else: hash_map[name] += 1\n            \n            if hash_map[name] >= 3:\n                result.add(name)\n            \n            i+= 1\n                \n        result = sorted(list(result))\n            \n        return result\n    \n\n            \n        \n", "from functools import cmp_to_key\n\ndef cmp(a,b):\n    if(a[1]>b[1]):\n        return 1\n    return -1\n\ndef secs(time):\n    hr,mins = time.split(':')\n    s = int(hr)*3600+int(mins)*60\n    return s\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        N = len(keyName)\n        l = []\n        for i in range(N):\n            l.append([keyName[i], keyTime[i]])\n        l.sort(key=cmp_to_key(cmp))\n        d = {}\n        s = set()\n        \n        for name, time in l:\n            if(name in s):\n                continue\n            if(name not in d):\n                d[name] = [secs(time)]\n            else:\n                i = 0\n                curr_time = secs(time)\n                while(i<len(d[name]) and curr_time-d[name][i]>3600):\n                    i += 1\n                \n                d[name] = d[name][i:]+[curr_time]\n                if(len(d[name])>=3):\n                    s.add(name)\n        return sorted(list(s))", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        def get_diff_minutes(t1, t2):\n            h1, m1 = t1.split(':')\n            h2, m2 = t2.split(':')\n            return (int(h2) - int(h1)) * 60 + int(m2) - int(m1)\n        \n        res = set()\n        store = defaultdict(deque)\n        for time, name in sorted(zip(keyTime, keyName)):\n            # print(name, time)\n            while store[name] and get_diff_minutes(store[name][0], time) > 60:\n                store[name].popleft()\n            store[name].append(time)\n            if len(store[name]) >= 3:\n                res.add(name)\n            \n        # print(res)\n        return sorted(res)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        result = []\n        tracker = {}\n        for person, time in zip(keyName, keyTime):\n            try:\n                if tracker[person] and person not in result:\n                    tracker[person].append(time)\n                    tracker[person].sort()\n                    if len(tracker[person]) >=3:\n                        for i in range(1, len(tracker[person])-1):\n                            lh = tracker[person][i-1].split(':')[0]\n                            ch = tracker[person][i].split(':')[0]\n                            rh = tracker[person][i+1].split(':')[0]\n                            tocheck = [lh, ch, rh]\n                            if int(lh)<=int(ch) and int(ch)<=int(rh):\n                                if '23' in tocheck and '00' in tocheck:\n                                    break\n                                l = int(lh + tracker[person][i-1].split(':')[1])\n                                c = int(ch + tracker[person][i].split(':')[1])\n                                r = int(rh + tracker[person][i+1].split(':')[1])\n                                diff = (c-l)+(r-c)\n                                if diff <= 100:\n                                    result.append(person)\n                                    break\n            except:\n                tracker[person]  = [time]\n        return sorted(result)", "from collections import deque, defaultdict, Counter\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        al = defaultdict(deque)\n        alerts = set()\n        def conv(time):\n            hh, mm = time.split(\\\":\\\")\n            return int(hh) * 60 + int(mm)\n        add = Counter()\n        for name, time in sorted(zip(keyName, keyTime)):\n            ct = conv(time)\n            #if len(al[name]) >= 1 and al[name][-1] > ct:\n            #    add[name] = 24 * 60\n            if len(al[name]) >= 1 and al[name][-1] > ct:\n                al[name] = deque()\n                    \n            al[name].append(ct + add[name])\n            while al[name] and al[name][0] < al[name][-1] - 60:\n                al[name].popleft()\n            if len(al[name]) >= 3:\n                alerts.add(name)\n            #print(al)\n            #print(alerts)\n        return sorted(alerts)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        m = collections.defaultdict(set)\n        for n, t in zip(keyName, keyTime):\n            m[n].add(t)\n            \n        ans = []\n        # print(m)\n        \n        for name in m:\n            added = False\n            times = m[name]\n            m2 = collections.defaultdict(set)\n            for t in times:\n                h, minute = map(int, t.split(':'))\n                m2[h].add(minute)\n                \n            # print(name, m2)\n            for h, f in m2.items():\n                if len(f) >= 3:\n                    ans.append(name)\n                    added = True\n                    break\n                \n            if added:  # name is already added\n                continue\n                \n            to_minutes = []\n            for t in times:\n                h, minute = map(int, t.split(':'))\n                to_minutes.append(h * 60 + minute)\n            to_minutes.sort()\n            # print(name, to_minutes)\n            i = 0\n            j = 0\n            size = 1\n            while i < len(to_minutes) and j < len(to_minutes) - 1:\n                if to_minutes[j + 1] - to_minutes[i] <= 60:\n                    j += 1\n                    if j - i >= 2:\n                        # print(to_minutes[i])\n                        ans.append(name)\n                        break\n                else:\n                    i += 1\n                    # size -= 1\n                j = max(j, i)\n            \n        \n        return sorted(ans)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d={}\n        for i in range(len(keyName)):\n            h=int(keyTime[i][0:2])\n            m=int(keyTime[i][3:5])\n            if keyName[i] in d:\n                d[keyName[i]].append(h*60+m)\n            else:\n                d[keyName[i]]=[h*60+m]\n        ans=[]\n        for k in list(d.keys()):\n            if len(d[k])<3:\n                continue\n            else:\n                record=d[k]\n                record.sort()\n                for i in range(len(record)-2):\n                    start=record[i]\n                    if record[i+1]-start<=60 and record[i+2]-start<=60:\n                        ans.append(k)\n                        break;\n        ans.sort()\n        return ans\n                        \n", "from collections import defaultdict \n\ndef mins_since_midnight(str_time):\n    hours = int(str_time[:2])\n    mins = int(str_time[3:])\n    return hours*60 + mins\n\ndef difference_mins(str_time1, str_time2):\n    return abs(mins_since_midnight(str_time2) - mins_since_midnight(str_time1))\n\nclass Solution:\n    def alertNames(self, keyName, keyTime):\n        alert_names = []\n        log = defaultdict(list)\n        for name, time in zip(keyName, keyTime):\n            log[name].append(time)\n        \n        for name in log.keys():\n            times = log[name]\n            sorted_times = sorted(times)\n            start = 0\n            n = 1\n            for i in range(1, len(sorted_times)):\n                n += 1\n                if difference_mins(sorted_times[start], sorted_times[i]) <= 60:\n                    if n == 3:\n                        alert_names.append(name)\n                        break\n                else:\n                    while difference_mins(sorted_times[start], sorted_times[i]) > 60:\n                        start += 1\n                        n -= 1\n        \n        return sorted(alert_names)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def oneHourAgo(time1, time2):\n            hr_min1 = time1.split(':')\n            hr_min2 = time2.split(':')\n            \n            if abs(int(hr_min2[0])-int(hr_min1[0])) > 1 or (abs(int(hr_min2[0])-int(hr_min1[0])) == 1 and int(hr_min1[1]) < int(hr_min2[1])):\n                return True\n            else:\n                return False\n        result = set()\n        \n        timeline = defaultdict(list)\n        \n        for name,time in zip(keyName, keyTime):\n            timeline[name].append(time)\n        \n        for name in keyName:\n            timeline[name].sort()\n        \n        for name in keyName:\n            q = deque()\n            inside_q = 0\n            for time in timeline[name]:\n                while q and (oneHourAgo(q[0], time)):\n                    q.popleft()\n                    inside_q -= 1\n\n                q.append(time)\n                inside_q +=1\n\n                if inside_q >=3:\n                    result.add(name)\n                    break\n                # print(q)\n            \n        result = list(result)\n        result.sort()\n        return result", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        times = collections.defaultdict(list)\n        for name, time in zip(keyName, keyTime):\n            times[name].append(time)\n        res = []\n        def withinOneHour(t1, t2):\n            (h1, m1) = [int(i) for i in t1.split(':')]\n            t1 = h1 * 60 + m1\n            (h2, m2) = [int(i) for i in t2.split(':')]\n            t2 = h2 * 60 + m2\n            return t2 - t1 <= 60\n        for name in sorted(times):\n            time = sorted(times[name])\n            queue = []\n            for t in time:\n                queue.append(t)\n                if not withinOneHour(queue[0], queue[-1]): queue.pop(0)\n                if len(queue) >= 3:\n                    res.append(name)\n                    break\n        return res\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        data = defaultdict(list)\n        for t, n in zip(keyTime, keyName):\n            data[n].append(t)\n        ans = set()\n        for name, time in data.items():\n            count = 0\n            left = 0\n            time = sorted(time)\n            #print(f\\\"name {name}\\\")\n            for i, t in enumerate(time):\n                #print(f\\\"t {t}\\\")\n                hour = int(t.split(':')[0])\n                minute = int(t.split(':')[1])\n                prev_t = time[left]\n                prev_h = int(prev_t.split(':')[0])\n                prev_m = int(prev_t.split(':')[1])\n                while (h_diff := hour - prev_h) > 1 or (h_diff == 1 and prev_m < minute):\n                    left += 1\n                    prev_t = time[left]\n                    prev_h = int(prev_t.split(':')[0])\n                    prev_m = int(prev_t.split(':')[1])\n                if i - left >= 2:\n                    print(f\\\"i {i}, left {left}\\\")\n                    ans.add(name)\n                    break\n        return sorted(ans)", "# def within_hour(large,small):\n#         if abs(large[0] - small[0]) >= 2:\n#             return False\n#         if large[0] - small[0] == 1 and small[1] < large[1]:\n#             print(large,small)\n#             return False\n#         return True\n# class Solution:\n    \n    \n#     def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n#         sorted_list = sorted(zip(keyTime,keyName))\n#         # print(sorted_list)\n#         alerted = []\n#         people = {}\n#         for time_str,name in sorted_list:\n#             if name not in alerted:\n#                 time = [int(time_str[:2]),int(time_str[-2:])]\n#                 if name in people.keys():\n#                     if len(people[name]) == 2:\n#                         if within_hour(time,people[name][1]):\n#                             people[name].append(time)\n#                             if not within_hour(time,people[name][0]):\n#                                 del people[name][0]\n#                             else:\n#                                 alerted.append(name)\n#                         else:\n#                             people[name] = [time]\n#                     else:\n#                         if not within_hour(time,people[name][0]):\n#                             people[name] = [time]\n#                         else:\n#                             people[name].append(time)\n#                 else:\n#                     people[name] = [time]\n#         return sorted(alerted)\n                        \nclass Solution:    \n    def minutes(self,time):\n        hr , m = time.split(\\\":\\\")\n        return int(hr)*60 + int(m)\n    \n    def countOfCheckinsInOneHour(self,arr):\n        if len(arr)<3 : return False\n        maxx = 1\n        arr = sorted(arr,key = lambda x: self.minutes(x))\n        counter = 1\n        for j in range(len(arr)):\n            counter = 1\n            start = j\n            for i in range(j+1,len(arr)):\n                if 0< self.minutes(arr[i]) - self.minutes(arr[start]) <= 60:\n                    counter += 1\n                    maxx = max(maxx,counter)\n                elif self.minutes(arr[i]) - self.minutes(arr[start]) >60 or self.minutes(arr[i]) - self.minutes(arr[start]) <0:\n                    maxx = max(maxx,counter)\n                    counter = 1\n                    start = i\n        if maxx >= 3 : return True,maxx\n        return False,maxx\n    \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dictionary = {}\n        for name,time in zip(keyName,keyTime):\n            if name not in dictionary : dictionary[name] = [] \n            dictionary[name].append(time)\n        final = []\n        for i in dictionary:\n            if self.countOfCheckinsInOneHour(dictionary[i])[0]:\n                final.append(i)\n        return sorted(final)", "from sortedcontainers import SortedSet, SortedList\nfrom heapq import heappush, heappop\nfrom datetime import timedelta\nfrom collections import defaultdict, deque\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        users = []\n        for i, kt in enumerate(keyTime):\n            kts = kt.split(':')\n            t = timedelta(hours=int(kts[0]), minutes=int(kts[1]))\n            users.append((t, keyName[i]))\n\n        users.sort()\n        d = defaultdict(deque)\n        barier = timedelta(hours=1)\n        rez = SortedSet()\n        for k in users:\n            if len(d[k[1]]) > 0:\n                er = d[k[1]][0]\n                while k[0] - er > barier and len(d[k[1]]) > 0:\n                    d[k[1]].popleft()\n                    if len(d[k[1]]) > 0:\n                        er = d[k[1]][0]\n            d[k[1]].append(k[0])\n            if len(d[k[1]]) >= 3:\n                rez.add(k[1])\n\n        return list(rez)\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def get_minutes(t):\n            h, m = t.split(':')\n            return int(h) * 60 + int(m)\n        \n        def is_alert(times):\n            lent = len(times)\n            if lent < 3: return False\n            \n            l, r = 0, 0\n            for r in range(lent):\n                if r - l >= 2 and times[r] - times[l] <= 60: return True\n                while l < r and times[r] - times[l] > 60: l += 1\n            return False\n            \n        \n        lookup = defaultdict(list)\n        for name, time in zip(keyName, keyTime): lookup[name].append(get_minutes(time))\n        \n        alert_list = [name for name, times in lookup.items() if is_alert(sorted(times))]\n        \n        return sorted(alert_list)", "class Solution:\n    def timeDifference(self,A,B):\n        A_hr ,A_min = A.split(\\\":\\\")\n        B_hr ,B_min = A.split(\\\":\\\")\n        A_time = int(A_hr)*60 + int(A_min)\n        B_time = int(B_hr)*60 + int(B_min)\n        return B_time-A_time\n    \n    def minutes(self,time):\n        hr , m = time.split(\\\":\\\")\n        return int(hr)*60 + int(m)\n    \n    def countOfCheckinsInOneHour(self,arr):\n        if len(arr)<3 : return False\n        maxx = 1\n        arr = sorted(arr,key = lambda x: self.minutes(x))\n        counter = 1\n        for j in range(len(arr)):\n            counter = 1\n            start = j\n            for i in range(j+1,len(arr)):\n                if 0< self.minutes(arr[i]) - self.minutes(arr[start]) <= 60:\n                    counter += 1\n                    maxx = max(maxx,counter)\n                elif self.minutes(arr[i]) - self.minutes(arr[start]) >60 or self.minutes(arr[i]) - self.minutes(arr[start]) <0:\n                    maxx = max(maxx,counter)\n                    counter = 1\n                    start = i\n        if maxx >= 3 : return True,maxx\n        return False,maxx\n    \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dictionary = {}\n        for name,time in zip(keyName,keyTime):\n            if name not in dictionary : dictionary[name] = [] \n            dictionary[name].append(time)\n        final = []\n        for i in dictionary:\n            if self.countOfCheckinsInOneHour(dictionary[i])[0]:\n                final.append(i)\n        return sorted(final)", "class Solution:\n\n    def timediff(self, t1, t2):\n        hdiff = int(t2[:2]) - int(t1[:2])\n        \n        mdiff = int(t2[-2:]) - int(t1[-2:])\n        \n        fdiff = hdiff*60 + mdiff\n        \n        return fdiff\n    \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        times = dict()\n        \n        for i in range(len(keyName)):\n            if keyName[i] in list(times.keys()):\n                times[keyName[i]].append(keyTime[i])\n            else:\n                times[keyName[i]] = [keyTime[i]]\n        \n        bad = set()\n        for name in list(times.keys()):\n            t = sorted(times[name])\n            for i in range(2, len(t)):\n                if self.timediff(t[i-2], t[i]) <= 60:\n                    bad.add(name)\n                    break\n        \n        return sorted(list(bad))\n        \n        \n    \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        names = defaultdict(set)\n        for n, t in zip(keyName, keyTime):\n            names[n].add(t)\n        for name in names:\n            names[name] = sorted(names[name])\n        # print(names)\n        \n        def timediff(t1, t2):\n            t1 = list(map(int, t1.split(':')))\n            t2 = list(map(int, t2.split(':')))\n            h = t2[0] - t1[0]\n            m = (t2[1] - t1[1]) / 60\n            return h + m\n        \n        ans = set()\n        for name in names:\n            start = 0\n            count = 1\n            cur = start + 1\n            for i in range(cur, len(names[name])):\n                diff = timediff(names[name][start], names[name][i])\n                print(name, diff)\n                if diff <= 1:\n                    count += 1\n                    if count == 3:\n                        ans.add(name)\n                        break\n                else:\n                    start += 1\n        return sorted(ans)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def timeDifference(time1, time2):\n            hr1, min1 = time1.split(':')\n            hr2, min2 = time2.split(':')\n            timeDiff = (int(hr2) - int(hr1)) * 60 + int(min2) - int(min1)\n            return timeDiff\n        \n        res = set()\n        rec = collections.defaultdict(list)\n        N = len(keyName)\n        for i in range(N):\n            hr, minute = keyTime[i].split(':')\n            time = int(hr) * 60 + int(minute)\n            rec[keyName[i]].append(time)\n        for key, val in list(rec.items()):\n            if len(val) >= 3:\n                sorted_time = sorted(val)\n                for i in range(2, len(val)):\n                    if sorted_time[i] - sorted_time[i - 2] <= 60:\n                        res.add(key)\n                        break\n        return sorted(list(res))\n                        \n            \n\n            \n                    \n                    \n                    \n", "from collections import defaultdict, deque\n\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n\n        def to_seconds(time):\n            h, m = map(int, time.split(\\\":\\\"))\n            return h*60 + m\n\n        def find_diff(t1, t2):\n            t1h, t1m = map(int, t1.split(\\\":\\\"))\n            t2h, t2m = map(int, t2.split(\\\":\\\"))\n\n            t1minutes = t1h * 60 + t1m\n            t2minutes = t2h * 60 + t2m\n\n            if t1minutes < t2minutes:\n                return float(\\\"inf\\\")\n\n            return t1minutes - t2minutes\n\n        keyTime = map(to_seconds, keyTime)\n\n        names = set()\n        persons = defaultdict(deque)\n        for person, time in sorted(zip(keyName, keyTime), key=lambda x: x[1]):\n            persons[person].append(time)\n            if len(persons[person]) > 2:\n                first_time = persons[person].popleft()\n                if time - first_time <= 60:\n                    names.add(person)\n\n        return list(sorted(names))\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        def getNumMins(time):\n            time = time.split(\\\":\\\")\n            hours = int(time[0])\n            mins = int(time[1])\n            return (hours * 60) + mins\n        \n        arr = []\n        for i in range(len(keyName)):\n            arr.append((getNumMins(keyTime[i]), keyName[i]))\n        arr.sort()\n        print(arr)\n        \n        access = collections.defaultdict(list)\n        for time, key in arr:\n            access[key].append(time)\n        \n        res = []\n        for key in sorted(access.keys()):\n            times = access[key]\n            for i in range(len(times) - 3 + 1):\n                if (times[i+2] - times[i]) <= 60:\n                    res.append(key)\n                    break\n        \n        return res\n    ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dic = collections.defaultdict(list)\n        ans = set()\n        for name, time in sorted(zip(keyName, keyTime), key = lambda x:x[1]):\n            if name not in ans:\n                h, m = map(int, time.split(':'))\n                t = h*60+m\n                if len(dic[name])>=2 and dic[name][-2]>=t-60: ans.add(name)\n                else: dic[name].append(t)\n        return sorted(ans)", "class Solution:\n    def less(self, start, end):\n        t1 = int(start[:2])*60+int(start[3:])\n        t2 = int(end[:2])*60+int(end[3:])\n        \n        if int(end[:2]) < int(start[:2]):\n            return True\n        \n        return (t2-t1)>60\n    \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d = defaultdict(list)\n        for i in range(len(keyName)):\n            d[keyName[i]].append(keyTime[i])\n        \n        w = []\n        res = []\n        #print(d)\n        for p in list(d.keys()):\n            times = d[p]\n            w = []\n            for t in sorted(times):\n                w.append(t)\n                while w and self.less(w[0], t):\n                    w.pop(0)\n                \n                if len(w)>=3:\n                    res.append(p)\n                    break\n        \n        res.sort()\n        return res\n", "from collections import Counter\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        times = sorted(enumerate(keyTime), key= lambda x: (int(x[1].split(\\\":\\\")[0]), int(x[1].split(\\\":\\\")[1])))\n        \n        def isValid(time1, time2):\n            h1, m1 = time1.split(\\\":\\\")\n            h2, m2 = time2.split(\\\":\\\")\n            if h1 == h2: return True\n            if int(h2) - int(h1) > 1:\n                return False    \n            if (60 - int(m1)) + int(m2) > 60:\n                return False\n            \n            return True\n        start = 0\n        res = set()\n        end = 0\n        cache = Counter()\n        while start < len(times):\n            while end < len(times) and isValid(times[start][1], times[end][1]):\n                cache[keyName[times[end][0]]] += 1\n                if cache[keyName[times[end][0]]] >= 3:\n                    res.add(keyName[times[end][0]])\n                end += 1\n            cache[keyName[times[start][0]]] -= 1\n            if cache[keyName[times[start][0]]] == 0: \n                del cache[keyName[times[start][0]]] \n            start += 1\n        return sorted(res)\n                \n   \n        \n        \n        ", "class Solution:    \n    def minutes(self,time):\n        hr , m = time.split(\\\":\\\")\n        return int(hr)*60 + int(m)\n    \n    def countOfCheckinsInOneHour(self,arr):\n        if len(arr)<3 : return False\n        maxx = 1\n        arr = sorted(arr,key = lambda x: self.minutes(x))\n        counter = 1\n        for j in range(len(arr)):\n            counter = 1\n            start = j\n            for i in range(j+1,len(arr)):\n                if 0< self.minutes(arr[i]) - self.minutes(arr[start]) <= 60:\n                    counter += 1\n                    maxx = max(maxx,counter)\n                elif self.minutes(arr[i]) - self.minutes(arr[start]) >60 or self.minutes(arr[i]) - self.minutes(arr[start]) <0:\n                    maxx = max(maxx,counter)\n                    counter = 1\n                    start = i\n        if maxx >= 3 : return True,maxx\n        return False,maxx\n    \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dictionary = {}\n        for name,time in zip(keyName,keyTime):\n            if name not in dictionary : dictionary[name] = [] \n            dictionary[name].append(time)\n        final = []\n        for i in dictionary:\n            if self.countOfCheckinsInOneHour(dictionary[i])[0]:\n                final.append(i)\n        return sorted(final)", "class Solution:\n    def timeDifference(self,A,B):\n        A_hr ,A_min = A.split(\\\":\\\")\n        B_hr ,B_min = A.split(\\\":\\\")\n        A_time = int(A_hr)*60 + int(A_min)\n        B_time = int(B_hr)*60 + int(B_min)\n        return B_time-A_time\n    \n    def minutes(self,time):\n        hr , m = time.split(\\\":\\\")\n        return int(hr)*60 + int(m)\n    \n    def countOfCheckinsInOneHour(self,arr):\n        if len(arr)<3 : return False\n        maxx = 1\n        arr = sorted(arr,key = lambda x: self.minutes(x))\n        print(arr)\n        counter = 1\n        for j in range(len(arr)):\n            counter = 1\n            start = j\n            for i in range(j+1,len(arr)):\n                if 0< self.minutes(arr[i]) - self.minutes(arr[start]) <= 60:\n                    counter += 1\n                    maxx = max(maxx,counter)\n                elif self.minutes(arr[i]) - self.minutes(arr[start]) >60 or self.minutes(arr[i]) - self.minutes(arr[start]) <0:\n                    maxx = max(maxx,counter)\n                    counter = 1\n                    start = i\n        if maxx >= 3 : return True,maxx\n        return False,maxx\n    \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dictionary = {}\n        for name,time in zip(keyName,keyTime):\n            if name not in dictionary : dictionary[name] = [] \n            dictionary[name].append(time)\n        print(dictionary)\n        final = []\n        for i in dictionary:\n            if self.countOfCheckinsInOneHour(dictionary[i])[0]:\n                final.append(i)\n        return sorted(final)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        mp ={}\n        res=[]\n        \n        for i,v in enumerate(keyName):\n            if v in mp:\n                mp[v].append(keyTime[i])\n            else:\n                mp[v]=[keyTime[i]]\n        for l in mp:\n            n=len(mp[l])\n            if n<3:\n                continue\n            t = mp[l]\n            t.sort()\n            count =0\n            for i in range(n):\n                if i+2 <n:\n                    dh = int(t[i+2].split(':')[0])-int(t[i].split(':')[0])\n                    dm = int(t[i+2].split(':')[1])-int(t[i].split(':')[1])\n\n                    if dh >= 2:\n                        continue\n                    elif dh == 1 and dm>0:\n                        continue\n                    else:\n                        res.append(l)\n                        break\n        res.sort()\n        return res\n    \n        def hour(hr):\n            return int(hr.split(':')[0])\n        def minuu(hr):\n            return int(hr.split(':')[1])\n        def checkTime(self,name)-> bool:\n            n=len(mp[name])\n            if n<3:\n                return False\n            t = mp[name]\n            t = t.sort()\n            count =0\n            \n            for i,v in enumerate(t):\n                if i+2 <n:\n                    dh = self.hour(t[i+2])-self.hour(v)\n                    dm = self.minuu(t[i+2])-self.minuu(v)\n                    if dh >= 2:\n                        return False\n                    elif dh == 1 and dm>0:\n                        return False\n                    else:\n                        return True\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d = {}\n        n = len(keyName)\n        res = []\n        # keyTime, keyName = [y,x for y,x in sorted(zip(keyTime,keyName))]\n        keyTime, keyName = list(zip(*sorted(zip(keyTime, keyName))))\n        # print(keyName)\n        # print(keyTime)\n        for i in range(n):\n            if keyName[i] not in d:\n                d[keyName[i]] = [keyTime[i],[0],[0],True, False]\n            else:\n                if not d[keyName[i]][4]:\n                    min_diff = int(str(keyTime[i][3:])) - int(str(d[keyName[i]][0][3:]))\n                    hr_diff = int(str(keyTime[i][:2])) - int(str(d[keyName[i]][0][:2]))\n\n                    if min_diff < 0:\n                        min_diff = 60 + min_diff\n                        hr_diff = hr_diff - 1\n                    # print(\\\"=\\\", hr_diff)\n                    if hr_diff < 0:\n                        d[keyName[i]] = [keyTime[i],[0],[0],True, False]\n                        # print(\\\"Here\\\")\n                    else:\n                        d[keyName[i]][0] = keyTime[i]\n                        d[keyName[i]][1].append(hr_diff*60 + min_diff)\n                        d[keyName[i]][2].append(d[keyName[i]][1][-1] + d[keyName[i]][1][-2])\n                        \n                        if len(d[keyName[i]][2])>2 and d[keyName[i]][2][-1] <= 60:\n                            d[keyName[i]][4] = True\n                            res.append(keyName[i])\n            # print(d)\n        return sorted(res)\n                    \n                    \n                        \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def checktime(s1,s2):\n            h1=int(s1.split(':')[0])\n            m1=int(s1.split(':')[1])\n            h2=int(s2.split(':')[0])\n            m2=int(s2.split(':')[1])\n            if h2*60+m2-h1*60-m1<=60:\n                return True\n            else:\n                return False\n        rec={}\n        for i in range(len(keyName)):\n            if keyName[i] in rec:\n                rec[keyName[i]].append(keyTime[i])\n            else:\n                rec[keyName[i]]=[keyTime[i]]\n        for i in rec.keys():\n            rec[i].sort()\n        ans=set()\n        for i in rec.keys():\n            for j in range(len(rec[i])-2):\n                if checktime(rec[i][j],rec[i][j+2]):\n                    ans.add(i)\n        ans=list(ans)\n        ans.sort()\n        return ans", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        kns = defaultdict(list)\n        \n        for i, k1 in enumerate(keyName):\n            tok = keyTime[i].split(':')\n            mins =  int(tok[0]) * 60 + int(tok[1])\n            if k1 not in kns:\n                kns[k1] = [mins]\n            else:\n                kns[k1].append(mins)\n                \n        def getAlert(tl):\n            start, count = 0, 1\n            \n            for i in range(1, len(tl)):\n                print((tl[i], tl[start]))\n                \n                if tl[i] >= tl[start]:\n \n                    if (tl[i] - tl[start]) <= 60:\n                        count += 1\n                    else:\n                        while (tl[i] - tl[start]) > 60:\n                            start += 1\n                            \n                        if start == i:\n                            count = 1\n                        else:\n                            count = 2\n                else:\n                    start = i\n                    count = 1                    \n\n                if count >= 3:\n                    return True            \n            return False\n        \n        ans = []\n        for k1, v1 in list(kns.items()):\n            v = sorted(v1)\n            al = getAlert(v)\n            if al:\n                ans.append(k1)\n\n        return sorted(ans)\n                    \n                    \n                \n                \n                \n                    \n            \n", "from collections import defaultdict\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        self.unique = set()\n        self.d = defaultdict(list)\n        for i in range(len(keyName)):\n            if keyName[i] not in self.unique:\n                r = list(keyTime[i].split(\\\":\\\"))\n                self.d[keyName[i]].append(r)\n                if len(self.d[keyName[i]])>=3:\n                    self.d[keyName[i]].sort()\n                    # print(self.d[keyName[i]])\n                    for j in range(len(self.d[keyName[i]])-2):\n                        hr1,mn1 = self.d[keyName[i]][j]\n                        # print(\\\"1\\\",hr1,mn1)\n                        hr2,mn2 = self.d[keyName[i]][j+2]\n                        # print(\\\"2\\\",hr2,mn2)\n                        if int(hr1) == int(hr2):\n                            self.unique.add(keyName[i])\n                            break\n                        elif int(hr2)-int(hr1)==1:\n                            if int(mn1)-int(mn2)>=0:\n                                self.unique.add(keyName[i])\n                                break\n        \n        return sorted(list(self.unique))", "from datetime import timedelta \n\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dp = defaultdict(list) \n        for i in range(len(keyName)):\n            name = keyName[i]\n            time = keyTime[i]\n            dp[name].append(time)\n        \n        def check(ls):\n            ls = sorted(ls)\n            start, end = 0, 0\n            # guarantee safe access on arr\n            make_date = lambda x: timedelta(hours = int(x[:2]), minutes = int(x[3:]))\n            \n            \n            def outer_check(start, end): \n                return (make_date(end) - make_date(start)).total_seconds() <= 3600 and int(start[:2]) - int(end[:2]) < 24\n            \n            while end < len(ls) and start <= end: \n                while end < len(ls) and outer_check(ls[start], ls[end]):\n                    end += 1\n                if (end - start) >= 3:\n                      return True\n                start += 1 \n            return False\n        \n        res = []\n                      \n        for name, t in list(dp.items()):\n            if check(t):\n                res.append(name)\n        return sorted(res)\n", "from datetime import timedelta\n\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dp = defaultdict(list) \n        for i in range(len(keyName)):\n            name = keyName[i]\n            time = keyTime[i]\n            dp[name].append(time)\n        \n        def check(ls):\n            ls = sorted(ls)\n            start, end = 0, 0\n            # guarantee safe access on arr\n            make_date = lambda x: timedelta(hours = int(x[:2]), minutes = int(x[3:]))\n            \n            \n            def outer_check(start, end): \n                return (make_date(end) - make_date(start)).total_seconds() <= 3600 and int(start[:2]) - int(end[:2]) < 24\n            \n            while end < len(ls) and start <= end: \n                while end < len(ls) and outer_check(ls[start], ls[end]):\n                    end += 1\n                if (end - start) >= 3:\n                      return True\n                start += 1 \n            return False\n        \n        res = []\n                      \n        for name, t in dp.items():\n            if check(t):\n                res.append(name)\n        return sorted(res)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        def _listify_time(time):\n            time = time.split(\\\":\\\")\n            return [int(x) for x in time]\n        \n        def _time_diff(time1, time2):\n            time1 = _listify_time(time1)\n            time2 = _listify_time(time2)\n            return 60 * (time2[0] - time1[0]) + time2[1] - time1[1]\n        \n        both = [(keyTime[i], keyName[i]) for i in range(len(keyTime))]\n        both.sort(key = lambda l: _time_diff(\\\"00:00\\\", l[0]))\n        keyTime = [l[0] for l in both]\n        keyName = [l[1] for l in both]\n        \n        times = collections.defaultdict(list)\n        res = []\n        \n        for i in range(len(keyName)):\n            \n            times[keyName[i]].append(keyTime[i])\n            if len(times[keyName[i]]) >= 3:\n                if _time_diff(times[keyName[i]][-3], times[keyName[i]][-1]) <= 60:\n                    res.append(keyName[i])\n        \n        res = sorted(list(set(res)))\n        return res", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        my_list = [[time,name]for name,time in zip(keyName,keyTime)]\n        def my_func(str1):\n            total = 0\n            l1 = str1[0].split(\\\":\\\")\n            min1 = int(l1[0])\n            min2 = int(l1[1])\n            total = min1*60\n            total += min2\n            return total\n        \n        my_list.sort(key = my_func)\n        #print(my_list)\n        out = set()\n        def find_minutes(str1,str2):\n            l1 = str1.split(\\\":\\\")\n            l2 = str2.split(\\\":\\\")\n            total = 0\n            if int(l1[0])>int(l2[0]):\n                return 100\n            total += (int(l2[0])-int(l1[0]))*60\n            min1 = int(l1[1])\n            min2 = int(l2[1])\n            if min2 < min1:\n                total -= min1-min2\n            else:\n                total += min2-min1\n            return total\n        #hashed = {}\n        card_use = collections.defaultdict(list)\n        \n        for time,name in my_list:\n            if name not in card_use:\n                card_use[name].append(time)\n            else:\n                while card_use[name] and find_minutes(card_use[name][0],time) > 60:\n                    card_use[name].pop(0)\n                card_use[name].append(time)\n                if len(card_use[name]) >= 3:\n                    out.add(name)\n            #print(card_use)\n            #print(out)\n        out =  list(out)\n        out.sort()\n        return out\n            # print(f\\\"{name} {time}\\\")\n            # if name in hashed:\n            #     print(f\\\"hashed[name] {hashed[name]}\\\")\n            #     if find_minutes(hashed[name],time) <= 60:\n            #         card_use[name] += 1\n            #         if alert[name] >= 3:\n            #             out.append(name)\n            # print(alert)\n            # hashed[name] = time\n                \n            \n        #print(find_minutes(\\\"09:10\\\",\\\"10:30\\\"))\n        return out\n        ", "from collections import defaultdict\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        res = []\n        time = defaultdict(list)\n        n = len(keyName)\n        lst = sorted(list(zip(keyTime,keyName)))\n        for t,k in lst:\n            if k in res:\n                continue\n            h,m = int(t[:2]),int(t[-2:])\n            if len(time[k]) >= 2:\n                h_0,m_0 = time[k][-2]\n                \n                if (h-h_0)*60 + (m-m_0) <= 60:\n                    res.append(k)\n                else:\n                    time[k].append((h,m))\n            else:\n                time[k].append((h,m))\n        return sorted(res)\n                \n        \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        arr = sorted(zip(keyTime, keyName))\n        rcd = defaultdict(deque)\n        alert = set()\n        # print(arr)\n        for i in range(len(arr)):\n            name = arr[i][1]\n            hr, mi = arr[i][0].split(\\\":\\\")\n            time = int(hr) * 60 + int(mi)\n            \n            rcd[name].append(time)\n            while time - rcd[name][0] > 60 or time - rcd[name][0] < 0 or len(rcd[name]) > 3:\n                    rcd[name].popleft()\n\n            if len(rcd[name]) == 3:\n                alert.add(name)\n        \n        return sorted(alert)\n        ", "def time_to_min(etime):\n    hours, minutes = etime.split(':')\n    return int(hours)*60+int(minutes)\n\n\ndef add_time_sorted(etime,time_list):\n    ii = 0\n    while ii < len(time_list) and time_to_min(etime) > time_to_min(time_list[ii]):\n        ii += 1\n    time_list.insert(ii,etime)\n            \ndef add_name_sorted(name,alert_list):\n    ii = 0\n    while ii < len(alert_list) and name > alert_list[ii]:\n        ii += 1\n    alert_list.insert(ii,name)\n    \ndef check_for_alert(time_list):\n    if len(time_list) <= 2:\n        return False\n    else:\n        delta = []\n        for ii in range(0,len(time_list)-1):\n            first_time = time_to_min(time_list[ii])\n            second_time = time_to_min(time_list[ii+1])\n            delta.append(second_time-first_time)\n            if len(delta) > 1:\n                if delta[ii] + delta[ii-1] <= 60:\n                    return True\n        return False\n        \n    \nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        entry = {}\n        alert = []\n        for ii in range(0,len(keyName)):\n            name = keyName[ii]\n            etime = keyTime[ii]\n            if name not in alert:\n                if name not in entry:\n                    entry[name] = [etime]\n                else:\n                    add_time_sorted(etime,entry[name])\n                    if check_for_alert(entry[name]):\n                        add_name_sorted(name,alert)\n        return alert\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        name_to_time = collections.defaultdict(list)\n        for name, hour_minute in zip(keyName, keyTime):\n            hour, minute = list(map(int, hour_minute.split(':')))\n            time = hour * 60 + minute\n            name_to_time[name].append(time)\n        names = []    \n        for name, time_list in list(name_to_time.items()):\n            time_list.sort()\n            dq = collections.deque()\n            for time in time_list:\n                dq.append(time)\n                if dq[-1] - dq[0] > 60:\n                    dq.popleft()\n                if len(dq) >= 3:\n                    names.append(name)\n                    break\n        return sorted(names)\n                \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        arr = list(zip(keyTime, keyName))\n        arr.sort()\n        \n        self.d = collections.defaultdict(collections.deque)\n        res = set()\n        \n        for t, name in arr:\n            h, m = t.split(\\\":\\\")\n            minutes = int(h) * 60 + int(m)\n            \n            while self.d[name] and minutes - self.d[name][0] > 60:\n                self.d[name].popleft()\n            \n            self.d[name].append(minutes)\n            \n            if len(self.d[name]) >= 3:\n                res.add(name)\n        \n        return(sorted(list(res)))", "from datetime import datetime\nclass Solution:\n    def alertNames(self, N: List[str], T: List[str]) -> List[str]:\n        res=defaultdict(list)\n        \n        for i in range(len(N)):\n            res[N[i]].append(T[i])\n        \n        for i in res:\n            res[i]=sorted(res[i])\n\n        final=[]\n        \n        \n        # print((b-a).seconds)\n        for emp in res:\n            if len(res[emp])<3:\n                continue\n            else:\n                i,j=0,2\n                while(j<len(res[emp])):\n                    a=datetime.strptime(res[emp][i], '%H:%M')\n                    b=datetime.strptime(res[emp][j], '%H:%M')\n                    if (b-a).seconds<=3600:\n                        final.append(emp)\n                        break\n                    else:\n                        i+=1\n                        j+=1\n        return sorted(final)\n                        \n                    \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        pq = []\n        for name, time in zip(keyName, keyTime):\n            a, b = map(int,time.split(\\\":\\\"))\n            time = a*60+b\n            print(name, time)\n            heapq.heappush(pq, (time, name, float('-inf'), 1))\n            heapq.heappush(pq, (time+60, name, float('inf'), -1))\n            \n        cnts = collections.Counter()\n        ppl = set()\n        while pq:\n            time, name, _, c = heapq.heappop(pq)\n            cnts[name] += c\n            if cnts[name] >= 3:\n                ppl.add(name)\n        return sorted(list(ppl))", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        d = collections.defaultdict(list)\n        \n        n = len(keyName)\n        \n        ans = set()\n        \n        def diffTime(h1, h2):\n            \n            h = int(h2[:2]) - int(h1[:2])\n            m = int(h2[3:]) - int(h1[3:])\n            \n            if h >= 2 or h < 0:\n                return False\n            \n            if h == 1:\n                if m <= 0:\n                    return True\n                else:\n                    return False\n            \n            return True\n        \n        arr = sorted( zip(keyTime, keyName) )\n        \n        # print (arr)\n        \n        for i in range(n):\n            keyName[i] = arr[i][1]\n            keyTime[i] = arr[i][0]\n                        \n        \n        for i in range(n):\n            \n            if keyName[i] in ans:\n                continue\n                \n            count = 1\n            for j in range( len( d[keyName[i]] ) - 1, -1, -1 ):\n                \n                if diffTime( d[keyName[i]][j], keyTime[i] ):\n                    count += 1\n                    if count == 3:\n                        ans.add( keyName[i] )\n                        break\n            \n            d[ keyName[i] ].append(keyTime[i])\n            \n        print ( d )\n            \n        ans = sorted(ans)\n        \n        return ans\n            \n            \n            \n        \n", "from datetime import time, datetime, timedelta\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        size = len(keyName)\n        d = {}\n        ans = []\n        \n        for i in range(size):\n            if keyName[i] not in d:       \n                d[keyName[i]] = [keyTime[i]]\n            else:\n                d[keyName[i]].append(keyTime[i])\n        \n        for j in list(d.keys()):\n            temp = len(d[j])\n            d[j].sort()\n            if temp > 2:\n                for k in range(2, temp):\n                    diff = datetime.strptime(d[j][k], '%H:%M') - datetime.strptime(d[j][k-2], '%H:%M')\n                    if diff.days < 0:\n                        continue\n                    if diff <= timedelta(hours = 1):\n                        ans.append(j)\n                        break\n                    \n        return sorted(ans)\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        if not keyName or not keyTime:\n            return []\n        nametime = collections.defaultdict(list)\n        \n        for n, t in zip(keyName, keyTime):\n            nametime[n].append(t)\n        \n        # print(nametime)\n        from datetime import datetime\n        \n        res = set()\n        def timediff(s1, s2): # 10:40, 11:00,  22:10, 24:00\n            # start = int(s1.split(\\\":\\\")[0])\n            # end = int(s2.split(\\\":\\\")[0])\n            return (datetime.strptime(s1, \\\"%H:%M\\\") - datetime.strptime(s2, \\\"%H:%M\\\")).total_seconds()/60\n            \n        for n, times in nametime.items():\n            if len(times) < 3:\n                continue\n            times.sort()\n            l = len(times)\n            for i in range(l-2):\n                # start = int(times[i].split(\\\":\\\")[0])\n                # end = int(times[i+2].split(\\\":\\\")[0])\n                # print(start, end)\n                diff = timediff(times[i], times[i+2])\n                if abs(diff) <= 60:\n                    res.add(n)\n        return sorted(res)\n                    \n                \n            ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        ans, n, i, pool = [], len(keyName), 0, sorted([[name, time] for name, time in zip(keyName, keyTime)])\n        while i < n:\n            j, cur = i + 1, collections.deque()\n            while j < n and pool[j][0] == pool[i][0]:\n                j += 1\n            for k in range(i, j):\n                time = int(pool[k][1][:2]) * 60 + int(pool[k][1][3:])\n                while cur and cur[0] < time - 60:\n                    cur.popleft()\n                if len(cur) > 1:\n                    ans.append(pool[k][0])\n                    break\n                cur.append(time)\n            i = j\n        return ans", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        m = collections.defaultdict(list)\n        n = len(keyName)\n        one_hour = 3600\n        for i in range(n):\n            # print(datetime.datetime.strptime(keyTime[i], \\\"%H:%M\\\"))\n            m[keyName[i]].append(datetime.datetime.strptime(keyTime[i], \\\"%H:%M\\\"))\n        ans = set()\n        for k in m:\n            v = sorted(m[k])\n            # print(v)\n            # print(v[1] - v[0])\n            for i in range(len(v) - 2):\n                if (v[i + 1] - v[i]).total_seconds() <= one_hour and (v[i + 2] - v[i]).total_seconds() <= one_hour:\n                    ans.add(k)\n                    break\n                # print(i, )\n        return sorted(ans)", "from collections import defaultdict\n\ndef is_within_hour(time_1, time_2):\n    [h_1, m_1] = time_1.split(':')\n    [h_2, m_2] = time_2.split(':')\n    \n    if h_2 == h_1:\n        return True\n    if int(h_2) == int(h_1) + 1 and m_2 <= m_1:\n        return True\n    return False\n    \nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        logs = defaultdict(list)\n        for name, time in zip(keyName, keyTime):\n            logs[name].append(time) \n               \n        output = set()\n        for name in logs:\n            times = sorted(logs[name])\n            for i in range(len(times)-2):\n                if is_within_hour(times[i], times[i+2]):\n                    output.add(name)\n                \n        return sorted(list(output))", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d={}\n        for i in range(len(keyName)):\n            if keyName[i] in d:\n                d[keyName[i]].append(keyTime[i])\n            else:\n                d[keyName[i]]=[keyTime[i]]\n        e=[]\n        for i in d:\n            c=[]\n            for j in d[i]:\n                c.append(int(j[0])*600+int(j[1])*60+int(j[3]+j[4]))\n            c.sort()\n            if(len(c)<=2):\n                continue\n            else:\n                for k in range(2,len(c)):\n                    if(c[k]-c[k-2]<=60):\n                        e.append(i)\n                        break\n        e.sort()\n        return e\n                        \n", "class Solution:\n    def alertNames(self, keyName, keyTime):\n        from collections import defaultdict\n        import datetime\n        d = defaultdict(list)\n        for name, time in zip(keyName, keyTime):\n            d[name].append(time)\n\n        ans = set()\n        for key in d:\n            d[key].sort()\n\n            for i in range(len(d[key]) - 2):\n                time1, time2 = d[key][i], d[key][i+2]\n                FMT = '%H:%M'\n                dt1 = datetime.datetime.strptime(time1, FMT)\n                dt2 = datetime.datetime.strptime(time2, FMT)\n                diff = dt2 - dt1\n                if diff.total_seconds() <= 3600:\n                    ans.add(key)\n\n        return sorted(list(ans))", "from datetime import datetime\n\nclass Solution:\n\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        \n        \\\"\\\"\\\"\n        put everyone into a dictionary\n        \\\"daniel contains times x\\\"\n        \\\"alice contains times y\\\"\n        \n        iterate through each person and determine if their times are strange\n        \n        \\\"\\\"\\\"\n        alerted = []\n        namesTimes = {}\n                \n        for i in range(len(keyName)):\n            if keyName[i] in namesTimes:\n                namesTimes[keyName[i]].append(keyTime[i])\n                namesTimes[keyName[i]].sort()\n            else:\n                namesTimes[keyName[i]] = [keyTime[i]]\n                \n        \n        lowerbound = datetime.strptime('00:00','%H:%M') - datetime.strptime('00:00','%H:%M')\n        upperbound = datetime.strptime('01:01','%H:%M') - datetime.strptime('00:00','%H:%M')\n        \n        \n        for person, times in namesTimes.items():\n            if len(times) >= 3:\n                # only check if they even used their card 3 or more times\n                # examine the times\n                # how do we do that?\n                # check the first 2. if they're within the same hour, check the first and third one\n                #datetime_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')\n                \n                \n                # let's make this inner loop more efficient: \n                # if the first two times don't qualify, increment x by 2\n                # if the first and third times don't qualify, increment x by 3\n                 for x in range(len(times)-2):\n                    time1 = datetime.strptime(times[x], '%H:%M')\n                    time2 = datetime.strptime(times[x+1], '%H:%M')\n\n                    diff1 = time2 - time1\n                    # if the first two times are within the hour, check the third time\n\n                    if diff1 > lowerbound and diff1 < upperbound:\n                        # we can check the third time, then\n\n                        print(\\\"for\\\", person, \\\"differences of\\\", diff1)\n\n                        time3 = datetime.strptime(times[x+2], '%H:%M')\n\n                        diff2 = time3 - time1\n\n                        if diff2 > lowerbound and diff2 < upperbound:\n                            print(\\\"for\\\", person, \\\"differences of\\\", diff2)\n                            # we found someone\n                            alerted.append(person)\n                            # go to the next person\n                            break  \n        print(alerted)\n        alerted.sort()\n        return alerted\n                    \n\n                \n        \n#   for x in range(len(times)-2):\n#                     time1 = datetime.strptime(times[x], '%H:%M')\n#                     time2 = datetime.strptime(times[x+1], '%H:%M')\n\n#                     diff1 = time2 - time1\n#                     # if the first two times are within the hour, check the third time\n\n#                     if diff1 > lowerbound and diff1 < upperbound:\n#                         # we can check the third time, then\n\n#                         print(\\\"for\\\", person, \\\"differences of\\\", diff1)\n\n#                         time3 = datetime.strptime(times[x+2], '%H:%M')\n\n#                         diff2 = time3 - time1\n\n#                         if diff2 > lowerbound and diff2 < upperbound:\n#                             print(\\\"for\\\", person, \\\"differences of\\\", diff2)\n#                             # we found someone\n#                             alerted.append(person)\n#                             # go to the next person\n#                             break              \n        ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dic = collections.defaultdict(list)\n        for n, t in zip(keyName, keyTime):\n            dic[n].append(datetime.datetime.strptime(t, \\\"%H:%M\\\"))\n        ans = []\n        for n in dic:\n            dic[n].sort()\n            j = 0\n            cur = 0\n            for i, t in enumerate(dic[n]):\n                while (t - dic[n][j]).seconds > 3600:\n                    j += 1\n                if i - j + 1 >= 3:\n                    ans.append(n)\n                    break\n        return sorted(ans)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        d = defaultdict(list)\n        for name, time in zip(keyName, keyTime):\n            d[name].append(time)\n            \n        ans = []\n        for name in d.keys():\n            d[name].sort()\n            if len(d[name]) < 3:\n                continue\n            else:\n                for idx in range(2, len(d[name])):\n                    if (datetime.datetime.strptime(d[name][idx], \\\"%H:%M\\\") - datetime.datetime.strptime(d[name][idx-2], \\\"%H:%M\\\")).seconds <= 3600:\n                        ans.append(name)\n                        break\n        return sorted(ans)\n                        \n                    ", "r\":\"No submission code for passed time/lang.", "class Solution:\n    def alertNames(self, a: List[str], t: List[str]) -> List[str]:\n        def alerted(a):\n            for i in range(len(a)-2):\n                if a[i+2] - a[i] <= 60: return True\n            return False\n        \n        d = defaultdict(list)\n        for name, t in zip(a, t):\n            h, m = map(int, t.split(':'))            \n            d[name].append(h*60+m)\n        \n        ans = []\n        for name in d:\n            d[name].sort()\n            if alerted(d[name]): ans.append(name)\n        return sorted(ans)    ", "class Solution:\n    def alertNames(self, keyName, keyTime):\n        name_to_time = collections.defaultdict(list)\n        for name, hour_minute in zip(keyName, keyTime):\n            hour, minute = map(int, hour_minute.split(':'))\n            time = hour * 60 + minute\n            name_to_time[name].append(time)\n        names = []\n        for name, time_list in name_to_time.items():\n            time_list.sort()\n            q = collections.deque()\n            for t in time_list:\n                q.append(t)\n                while q[0] < t - 60:\n                    q.popleft()\n                if len(q) > 2:\n                    names.append(name)\n                    break\n        return sorted(names)", "class Solution:\n    def alertNames(self, name: List[str], time: List[str]) -> List[str]:\n        # number of cases in array.\n        n = len(time)\n        \n        # array which contains name of workers who received an alert.\n        arr = []\n        \n        # map which contains name as key and list of times(in minutes) as value.\n        mapper = {}\n        \n        for i in range(n):\n            hr,mm = list(map(int,time[i].split(':')))\n            # finding time in minutes\n            time_in_min = hr*60+mm\n            worker = name[i]\n            if worker in mapper:\n                mapper[worker].append(time_in_min)\n            else:\n                mapper[worker] = [time_in_min]\n        \n        # sorting the list(sorting time for each worker) of all keys in mapper\n        for i in mapper:\n            value = mapper[i]\n            value.sort()\n            mapper[i] = value\n        \n        \n        for i in mapper:\n            value = mapper[i]\n            # possiblity of getting use of card 3 or more than 3 times\n            if len(value)>=3:\n                st = 0\n                en = 2\n                while en<len(value):\n                    if value[en]-value[st]<=60:\n                        arr.append(i)\n                        break\n                    en+=1\n                    st+=1\n        \n        if arr==[]:\n            return []\n        # sorting names in alphabetical order.\n        arr.sort()\n        return arr", "class Solution:\n\\tdef alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n\\t\\td = collections.defaultdict(list)\n\\t\\tres = []\n\\t\\tfor i in range(len(keyName)):\n\\t\\t\\ttime = int(keyTime[i][0:2]) * 60 + int(keyTime[i][3:])\n\\t\\t\\td[keyName[i]].append(time)\n\\t\\tfor k, v in d.items():\n\\t\\t\\tv.sort()\n\\t\\t\\tfor i in range(len(v) - 2):\n\\t\\t\\t\\tdiff = v[i + 2] - v[i]\n\\t\\t\\t\\tif 0 < diff <= 60:\n\\t\\t\\t\\t\\tres.append(k)\n\\t\\t\\t\\t\\tbreak\n\\t\\treturn sorted(res)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# from collections import defaultdict\n# class Solution:\n#     def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n#         dic = defaultdict(dict)\n#         result = set()\n#         l = len(keyName)\n#         i = 0\n#         while i < l:\n#             if keyName[i] not in result:\n#                 # print(keyTime[i][:2], \\\"old\\\")\n#                 if keyTime[i][:2] not in dic[keyName[i]]:\n#                     dic[keyName[i]][keyTime[i][:2]] = 1\n#                 else:\n#                     dic[keyName[i]][keyTime[i][:2]] += 1\n#                 # print(dic, \\\"dic\\\")\n#                 if dic[keyName[i]][keyTime[i][:2]] >= 3:\n#                     result.add(keyName[i])\n#                     i += 1\n#                     continue\n#                 if  keyTime[i][3:] == \\\"00\\\": \n#                     newKeyTime = str(int(keyTime[i][:2])-1)\n#                     # print(newKeyTime, \\\"new\\\")\n#                     if newKeyTime not in dic[keyName[i]]:\n#                         dic[keyName[i]][newKeyTime] = 1\n#                     else:\n#                         dic[keyName[i]][newKeyTime] += 1\n#                     if dic[keyName[i]][newKeyTime] >= 3:\n#                         result.add(keyName[i])\n#                         i += 1\n#                         continue\n#                 i += 1\n#         return list(result)\n        ", "import re\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        keyCards = {}\n        for i in range(len(keyName)):\n            if keyName[i] not in keyCards:\n                keyCards[keyName[i]] = []\n               \n            hour = int(keyTime[i][0:2])\n            minute = int(keyTime[i][3:])\n\n            keyCards[keyName[i]].append((hour * 60) + minute)\n           \n        alert_names = []\n        for key in list(keyCards.keys()):\n            my_times = sorted(keyCards[key])\n            for i in range(len(my_times) - 2):\n                count = 0\n                for j in range(i, len(my_times)):\n                    if my_times[j] - my_times[i] <= 60:\n                        count += 1\n                if count >= 3:\n                    alert_names.append(key)\n                    break\n                   \n                \n        print(keyCards)\n                    \n        return sorted(alert_names)\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        keys = {}\n        for i in range(len(keyName)):\n            if keyName[i] in keys:\n                keys[keyName[i]].append(keyTime[i])\n            else:\n                keys[keyName[i]] = [keyTime[i]]\n        \n        res = []\n        for i in keys.keys():\n            time = keys[i]\n            if self.emitAlert(time):\n                res.append(i)\n        \n        return sorted(res)\n    \n    def emitAlert(self, t: List[str]) -> bool:\n        time_converted = []\n        for i in t:\n            t = i.split(':')\n            time_converted.append(60 * int(t[0]) + int(t[1]))\n        time_converted.sort()\n            \n        left = 0\n        # print(time_converted)\n        for i in range(len(time_converted)):\n            while time_converted[i] - time_converted[left] > 60:\n                left += 1\n            if i > 0 and  time_converted[i] < time_converted[i - 1]:\n                left = i\n            if i - left >= 2:\n                return True\n        \n        return False", "import bisect\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d = {}\n        for i in range(len(keyName)):\n            name = keyName[i]\n            time = keyTime[i].split(':')\n            time = int(time[0]) * 60 + int(time[1])\n            if name not in d:\n                d[name] = []\n                pass\n            bisect.insort_left(d[name], time)\n            pass\n        ret = set()\n        for name in d:\n            lst = d[name]\n            window = []\n            for time in lst:\n                now = time\n                hour = now - 60\n                while len(window) > 0 and window[0] < hour:\n                    del window[0]\n                    pass\n                window.append(now)\n                if len(window) >= 3:\n                    ret.add(name)\n                    pass\n                pass\n            pass\n        return list(sorted(ret))", "from collections import deque\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dct = {i:[] for i in set(keyName)}\n        for i,j in zip(keyName, keyTime):\n            j = j.split(':')\n            j = int(j[0])*60+int(j[1])\n            dct[i].append(j)\n                \n        print(dct)\n        def check(arr):\n            arr = sorted(arr)\n            q = deque([arr[0]])\n            for i in arr[1:]:\n                while q:\n                    if i>q[0]+60:\n                        q.popleft()\n                    else:\n                        break\n                        \n                q.append(i)\n                if len(q)>=3:\n                    return True\n                \n            return False\n        \n        res = [i for i,j in list(dct.items()) if check(j.copy())]\n        res.sort()\n        \n        return res\n            \n            \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        times = defaultdict(list)\n        for name, time in zip(keyName, keyTime):\n            times[name].append(time)\n        for name in times:\n            times[name].sort()\n        ans = set()\n        for name in times:\n            window = defaultdict(deque)\n            for time in times[name]:\n                hour, minute = time.split(':')\n                minutes = int(hour) * 60 + int(minute)\n                window[name].append(minutes)\n                while window[name][0] < minutes - 60:\n                    window[name].popleft()\n                if len(window[name]) > 2:\n                    ans.add(name)\n        return sorted(ans)        \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        usage = defaultdict(list)\n        for k, name in enumerate(keyName):\n            hour, minute = keyTime[k].split(':', 2)\n            time_minutes = 60 * int(hour) + int(minute)\n            usage[name].append(time_minutes)\n        frequent = []\n        for name in usage:\n            times = sorted(usage[name])\n            lo = 0\n            hi = 2\n            len_times = len(times)\n            frequent_name = False\n            while hi < len_times and not frequent_name:\n                time_span = times[hi] - times[lo]\n                if time_span <= 60:\n                    frequent.append(name)\n                    frequent_name = True\n                else:\n                    lo += 1\n                    hi += 1\n        return sorted(frequent)\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        seen=collections.defaultdict(list)\n        ans=[]\n        for i in range(len(keyName)):\n            h,m=map(int,keyTime[i].split(\\\":\\\"))\n            seen[keyName[i]].append((60*h)+m)\n        #print()\n        for name in seen:\n            seen[name].sort()\n            l,r,n,found=0,0,len(seen[name]),False\n            #print(name,seen[name])\n            while l<n:\n                if r+1<n and seen[name][r+1]-seen[name][l]<=60:\n                    r+=1\n                    if (r-l)+1>=3:\n                        ans.append(name)\n                        found=True\n                        break\n                else:\n                    l+=1\n        return sorted(ans)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        mp = {}\n        l = []\n        for i, j in zip(keyName, keyTime):\n            temp = j.split(\\\":\\\")\n            if i not in mp:\n                mp[i] = []\n            mp[i] += [[float(temp[0]), float(temp[1])]]\n        for key, value in mp.items():\n            value.sort()\n            if(len(value) < 3):\n                continue\n            for i in range(len(value)-2):\n                if(value[i+2][0] - value[i][0] < 1.0):\n                    l.append(key)\n                    break\n                elif(value[i+2][0] - value[i][0] == 1 and value[i+2][1] - value[i][1] <= 0):\n                    l.append(key)\n                    break\n        l.sort()\n        return l", "class Solution:\n    def alertNames(self, names: List[str], times: List[str]) -> List[str]:\n        m, alerts = {}, []\n        minutes = lambda time: int(time.split(':')[0]) * 60 + int(time.split(':')[1])\n        for name, time in zip(names, times):\n            if name not in m: m[name] = deque()\n            m[name].append(minutes(time))\n        for name, times in m.items():\n            q = deque()\n            for time in sorted(times):\n                while len(q) and q[0] + 60 < time:\n                    q.popleft()\n                q.append(time)\n                if 3 <= len(q):\n                    alerts.append(name)\n                    break\n        return sorted(alerts)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def toMinutes(time):\n            hour, minute = time.split(':')\n            return int(hour) * 60 + int(minute)\n        \n        book = collections.defaultdict(list)\n        n = len(keyName)\n        res = set() \n        for i in range(n):\n            q = book[keyName[i]]\n            time = toMinutes(keyTime[i])\n            heapq.heappush(q, time)\n        for k, v in list(book.items()):\n            window = collections.deque()\n            while v:\n                window.append(heapq.heappop(v))\n                if len(window) >= 3 and (window[-1] - window[0]) <= 60: \n                    res.add(k)\n                while window and window[-1] - window[0] > 60: window.popleft()\n                #print(k, window)\n        \n        return sorted(res)\n                \n                \n                \n                \n        \n        \n        \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        t=[int(s[:2])*60+int(s[3:]) for s in keyTime]\n        l=sorted(zip(keyName,t)) \n        d=collections.defaultdict(list)\n        for i,j in l: d[i]+=[j]\n        out=[]\n        for s,l in list(d.items()):\n            if len(l)<3: continue\n            for i in range(2,len(l)):\n                if l[i]-l[i-2]<=60:\n                    out.append(s)\n                    break\n        return out\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        m = collections.defaultdict(list)\n        for i in range(len(keyName)):\n            m[keyName[i]].append(keyTime[i])\n        for k in m:\n            m[k].sort()\n        \n        ts_by_name = collections.defaultdict(list)\n        offenders = set()\n        for name in m:\n            for ts in m[name]:\n                tokens = ts.split(':')\n                hour, minute = int(tokens[0]), int(tokens[1])\n                ts = hour * 60 + minute\n            \n                while len(ts_by_name[name]) > 0 and (ts_by_name[name][0] > ts or ts - ts_by_name[name][0] > 60):\n                    ts_by_name[name].pop(0)\n                        \n                ts_by_name[name].append(ts)\n                if len(ts_by_name[name]) == 3:\n                    offenders.add(name)\n                \n        return sorted(list(offenders))", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def hm_to_min(s):\n            h, m = list(map(int, s.split(':')))\n            return h * 60 + m\n        kt = list(map(hm_to_min, keyTime))\n        #print(kt)\n        c = defaultdict(list)\n        for i, k in enumerate(keyName):\n            bisect.insort(c[k], kt[i])\n        # print(c)\n        res = []\n        for k in c:\n            for i in range(2, len(c[k])):\n                if c[k][i] - c[k][i - 2] <= 60:\n                    res.append(k)\n                    break\n        return sorted(res)\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        mp = collections.defaultdict(list)\n        \n        for n, t in sorted(zip(keyName, keyTime)):\n            minutes = int(t[:2]) * 60 + int(t[3:])\n            mp[n].append(minutes)\n        \n        ret = []\n        \n        for n, t in list(mp.items()):\n            if len(t) < 2:\n                continue\n            \n            i = 0\n            \n            for j, val in enumerate(t):\n                while val - t[i] > 60:\n                    i += 1\n                \n                if j - i >= 2:\n                    ret.append(n)\n                    break\n        \n        return ret\n            \n", "from collections import defaultdict\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        \n        def with_in_one_hour(t1, t3):\n            h1, s1 = t1.split(':')\n            h3, s3 = t3.split(':')\n            return (h1 == h3) or ((int(h3) - int(h1) == 1) and (s1 >= s3))\n                \n            \n        res = []\n        d = defaultdict(list)\n        \n        for n,t in zip(keyName, keyTime):\n            d[n].append(t)\n          \n        for n, t_list in list(d.items()):\n            if len(t_list)> 2:\n                t_list.sort()\n                \n                for i,t in enumerate(t_list[2:]):\n                    if with_in_one_hour(t_list[i],t_list[i+2]):\n                        res.append(n)\n                        break\n                        \n        return sorted(res)\n", "class Worker(object):\n    def __init__(self, name):\n        self.name = name\n        self.minutes = []\n            \n    def add(self, time):\n        h, m = tuple(time.split(':'))\n        h, m = int(h), int(m)\n        self.minutes.append(h*60+m)\n    \n    def is_alert(self):\n        self.minutes.sort()\n        for i, lower in enumerate(self.minutes):\n            upper = lower + 60\n            j = bisect.bisect_right(self.minutes, upper) # a[:j] <= upper\n            if j-i >= 3: return True\n        return False\n    \nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        workers = {}\n        for name, time in zip(keyName, keyTime):\n            if name not in workers:\n                workers[name] = Worker(name)\n            workers[name].add(time)\n            \n        ans = []\n        for name, worker in workers.items():\n            if worker.is_alert(): ans.append(name)\n        return sorted(ans)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        d = defaultdict(list)\n        \n        keylist = list(zip(keyName, keyTime))\n        keylist = sorted(keylist, key=lambda x: x[1])\n        #print(keylist)\n        ans = set()\n        for name, t in keylist:\n\n            #print(name, t)\n            if len(d[name]) < 3:\n                d[name].append(t)\n            elif len(d[name]) == 3:\n                d[name].pop(0)\n                d[name].append(t)\n            \n            if len(d[name]) == 3:\n                begin = d[name][0].split(':')\n                end = d[name][2].split(':')\n                #print(name, begin, end)\n                if begin[0] == end[0]:\n                    ans.add(name)\n                elif int(begin[0]) + 1 == int(end[0]) and int(begin[1]) >= int(end[1]):\n                        ans.add(name)\n        #print(d)\n        ans = list(ans)\n        ans.sort()\n        return ans\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        m = collections.defaultdict(list)\n        for i in range(len(keyName)):\n            tokens = keyTime[i].split(':')\n            hour, minute = int(tokens[0]), int(tokens[1])\n            ts = hour * 60 + minute\n            m[keyName[i]].append(ts)\n            \n        for k in m:\n            m[k].sort()\n        \n        ts_by_name = collections.defaultdict(list)\n        offenders = set()\n        for name in m:\n            for ts in m[name]:\n                while len(ts_by_name[name]) > 0 and (ts_by_name[name][0] > ts or ts - ts_by_name[name][0] > 60):\n                    ts_by_name[name].pop(0)\n                        \n                ts_by_name[name].append(ts)\n                if len(ts_by_name[name]) == 3:\n                    offenders.add(name)\n                \n        return sorted(list(offenders))", "from typing import List\n\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        from collections import defaultdict\n        d = defaultdict(list)\n        names_by_time = sorted(zip(keyName, keyTime), key=lambda t: t[1])\n        for name, time in names_by_time:\n            d[name].append(time)\n        alerts = []\n        for name, times in d.items():\n            for t1, t2, t3 in zip(times, times[1:], times[2:]):\n                t1h, t1m = map(int, t1.split(\\\":\\\"))\n                t3h, t3m = map(int, t3.split(\\\":\\\"))\n                if (t1h == t3h) or (t1h + 1 == t3h and t1m >= t3m):\n                    alerts.append(name)\n                    break\n        return sorted(alerts)\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        pl = sorted(zip(keyName, keyTime))\n        d = collections.defaultdict(list)\n        r = []\n        def isIn1(t1, t2):\n            h1, m1 = t1.split(\\\":\\\")\n            h2, m2 = t2.split(\\\":\\\")\n            if h1 == h2 or (int(h2) - int(h1) == 1 and int(m2)-int(m1) <= 0):\n                return 1\n            return 0\n        \n        for n, t in pl:\n            if r and r[-1] == n: continue\n            pt = d[n]\n            if len(pt) >= 2:\n                if isIn1(pt[-2], t):\n                    r.append(n)\n            d[n].append(t)\n        \n        return r", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def count_time(s):\n            l = s.split(':')\n            return 60 * int(l[0]) + int(l[1])\n        d = {}\n        ans = []\n        l = []\n        for i in range(len(keyName)):\n            l.append((keyName[i],count_time(keyTime[i])))\n        l = sorted(l)\n        name = \\\"\\\"\n        a = []\n        for item in l:\n            k,v = item[0],item[1]\n            if ans and k == ans[-1]:\n                continue\n            if k != name:\n                a = [v]\n                name = k\n            else:\n                if v - a[0] <= 60:\n                    if len(a) == 2:\n                        ans.append(k)\n                        a = []\n                        continue\n                    a.append(v)\n                else:\n                    if len(a) == 1:\n                        a = [v]\n                    else:\n                        if v - a[1] <= 60:\n                            a = [a[1],v]\n                        else:\n                            a = [v]\n        return ans", "def time2num(t):\n    h,m = t.split(':')\n    # print(h,m)\n    return [int(h), int(m)]\n\ndef check_1hour(t1, t2):\n    if t1[0] == t2[0]:\n        return True\n    if t2[0]-t1[0] ==1 and t2[1]<=t1[1]:\n        return True\n    return False\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        dt = {}\n        for k, v in zip(keyName, keyTime):\n            if k in dt:\n                dt[k].append(v)\n            else:\n                dt[k] = [v]\n        res = []\n        for k, v in list(dt.items()):\n            if len(v) < 3:\n                continue\n            if Solution.find_time(v):\n                res.append(k)\n        \n        return sorted(res)\n    \n    @staticmethod\n    def find_time(list_time):\n        l2 = list(map(time2num, list_time))\n        print(l2)\n        l2 = sorted(l2)    \n        # print(l2)\n        # print(list_time)\n        n = len(list_time)        \n        for i in range(n-2):\n            if check_1hour(l2[i], l2[i+2]):\n                return True\n        return False\n            \n            \n        \n", "class Solution:\n  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n    array, table = sorted(zip(keyName, keyTime), key=lambda item: item[1]), {}\n    for i, (name, time) in enumerate(array):\n      table.setdefault(name, []).append(self.convertTime(time))\n      \n    result = []\n    for name, times in table.items():\n      for i in range(2, len(times)):\n        if times[i] - times[i-2] <= 60:\n          result.append(name)\n          break\n    return sorted(result)\n  \n  def convertTime(self, time):\n    parts = time.split(\\\":\\\")\n    return int(parts[0]) * 60 + int(parts[1])", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        t=[int(s[:2])*60+int(s[3:]) for s in keyTime]\n        l=sorted(zip(keyName,t)) \n        d=collections.defaultdict(list)\n        for i,j in l: d[i]+=[j]\n        return [s for s,l in list(d.items()) if any(j-i<=60 for i,j in zip(l[:-2],l[2:]))]       \n\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        events = collections.defaultdict(list)\n        for name, time in sorted(zip(keyName, keyTime)):\n            h, m = time.split(\\\":\\\")\n            h, m = int(h), int(m)\n            events[name].append(h*60+m)\n        \n        alert = []\n        for name in events:\n            T = events[name]\n            n = len(T)\n            left, right = 0, 0\n            while right < n:\n                r = T[right]\n                right += 1\n                \n                while r-T[left] > 60:\n                    left += 1\n                    \n                if right - left >= 3:\n                    alert.append(name)\n                    break\n        return alert            ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def convert(data):\n            hour, minutes = data.split(\\\":\\\")\n            return int(hour)*60 + int(minutes)\n            \n        dic = collections.defaultdict(list)\n        for name, time in zip(keyName, keyTime):\n            dic[name].append(time)\n            \n        res = []\n        for key, time in dic.items():\n            time.sort()\n            for t in range(len(time)-2):\n                if convert(time[t+2]) - convert(time[t]) <= 60:\n                    res.append(key)\n                    break\n        return sorted(res)\n                    \n                \n                \n                \n                ", "class Solution:\n    def alertNames(self, name_list: List[str], time: List[str]) -> List[str]:\n        time_list = []\n        for ts in time:\n            h, m = list(map(int, ts.split(':')))\n            time_list.append(h*60 + m)\n        res = set()\n        A = list(sorted(zip(name_list, time_list)))\n        for i, (name, t) in enumerate(A):\n            if i + 2 < len(name_list) and name == A[i+2][0] and t >= A[i+2][1] - 60:\n                res.add(name)\n        return sorted(res)", "class Solution:\n    from collections import deque\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        if not keyName:\n            return []\n        ret_list = []\n        dict_ind = {}\n        count = 0\n        for nme, tme in zip(keyName,keyTime):\n            if not nme in dict_ind:\n                dict_ind[nme] = [(int(tme.split(\\\":\\\")[0])*60)+(int(tme.split(\\\":\\\")[1]))]\n            else:\n                dict_ind[nme].append((int(tme.split(\\\":\\\")[0])*60)+(int(tme.split(\\\":\\\")[1])))\n        for key, val in dict_ind.items():\n            if len(dict_ind[key]) >= 3 and not key in ret_list:\n                val_sort = sorted(val)\n                for i in range(len(val_sort)-2):\n                    if val_sort[i+2]-val_sort[i] > 0:\n                        if val_sort[i+2]-val_sort[i] <= 60:\n                            ret_list.append(key)\n                            break\n                    # else:\n                    #     if val[i+2]+1440-val[i] <= 60:\n                    #         ret_list.append(nme)\n                    #         break\n                    # diff = int(dict_ind[nme][-1][0:2]) - int(dict_ind[nme][0][0:2])\n                    # if diff == 0:\n                    #     ret_list.append(nme)\n                    # elif diff == 1:\n                    #     if int(dict_ind[nme][0][3:5]) >= int(dict_ind[nme][-1][3:5]):\n                    #         ret_list.append(nme)\n                    #     else:\n                    #         dict_ind[nme].pop(0)\n        return sorted(ret_list)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        events = collections.defaultdict(list)\n        for name, time in sorted(zip(keyName, keyTime)):\n            h, m = time.split(\\\":\\\")\n            h, m = int(h), int(m)\n            events[name].append(h*60+m)\n        \n        alert = []\n        for name in events:\n            T = events[name]\n            n = len(T)\n            left, right = 0, 0\n            while right < n:\n                r = T[right]\n                right += 1\n                \n                while r-T[left] > 60:\n                    left += 1\n                    \n                if right - left >= 3:\n                    alert.append(name)\n                    break\n                    \n        return alert            ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        doc = collections.defaultdict(collections.deque)\n        res = set()\n        \n        for name, time in sorted(zip(keyName, keyTime), key=lambda x: x[1]):\n            while doc[name] and self.delta_time(time, doc[name][0]) > 60:\n                doc[name].popleft()\n\n            doc[name].append(time)\n            if len(doc[name]) >= 3:\n                res.add(name)\n        return sorted(list(res))\n    \n    def delta_time(self, t1, t2):\n        h1, m1 = t1.split(':')\n        h2, m2 = t2.split(':')\n        return int(h1) * 60 + int(m1) - (int(h2) * 60 + int(m2))\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        # need to first sort by time\n        pairs = []\n        for name, time in zip(keyName, keyTime):\n            m, s = time.split(\\\":\\\")\n            time = 60*int(m) + int(s)\n            pairs.append((time, name))\n            \n        pairs = sorted(pairs)\n        usage = defaultdict(list)    \n        ret = set()\n        for time, name in pairs:\n            while usage[name] and usage[name][0] < time-60:\n                usage[name].pop(0)\n                \n            usage[name].append(time)\n            \n            if len(usage[name]) >= 3:\n                # print(name, usage[name])\n                ret.add(name)\n                \n        return sorted(list(ret))", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        \n        from collections import defaultdict\n        name_time = defaultdict(list)\n        access_violations = set()\n        for n,t in zip(keyName,keyTime):\n            name_time[n].append(t)\n\n        \n        for k,v in list(name_time.items()):\n            if len(v)<2:\n                continue\n            v.sort()\n            if self.checkViolation(v):\n                access_violations.add(k)\n                \n        access_violations = list(access_violations)\n        access_violations.sort()\n        return access_violations\n    \n    \n    \n    def checkViolation(self,access_times):        \n        from collections import deque\n        access_time = deque()\n        for t in access_times:\n            access_time.append(t)\n            if len(access_time)>1:\n                t_start = access_time[0]\n                t_end   = t\n                \n                if self.diff(t_start,t_end):\n                    access_time.popleft()\n                \n                if len(access_time)>=3:\n                    return True\n        \n        return False\n        \n        \n        \n    \n    def diff(self,t_start,t_end):\n        h1,m1 = t_start.split(':')\n        h2,m2 = t_end.split(':')\n        \n        \n        if int(h2)-int(h1)>=2:\n            return True\n        \n        if int(h2)-int(h1)==0:\n            return False\n        \n        minutes=60-int(m1)+int(m2)\n            \n        \n        if minutes<=60:\n            return False\n        else:\n            return True\n    \n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n                \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        loginTimes = {}\n        workers = set()\n        \n        def timestamp(time):\n            hh, mm = map(int, time.split(\\\":\\\"))\n            return hh*60 + mm\n        \n        for name, time in sorted(zip(keyName, keyTime), key=lambda x: (x[1])):\n            if name in loginTimes:\n                dq = loginTimes[name]\n                t = timestamp(time)\n                dq.append(t)\n                if t - dq[0] > 60:\n                    dq.popleft()\n                \n                if len(dq) >= 3:\n                    workers.add(name)\n            else:\n                loginTimes[name] = deque()\n                loginTimes[name].append(timestamp(time))\n                \n        return sorted(list(workers))\n        \n        \n        ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        keytime_table = dict()\n        for idx in range(len(keyName)):\n            name = keyName[idx]\n            time = keyTime[idx]\n            keytime_table.setdefault(name, []).append(time)\n        \n        ans = []\n        for name in list(keytime_table.keys()):\n            time_list = keytime_table[name]\n            time_list.sort()\n            l = 0\n            r = 0\n            hour, minute = time_list[0].split(':')\n            l_minutes = int(hour) * 60 + int(minute)\n            while l <= r and r < len(time_list):\n                r_time = time_list[r]\n                hour, minute = r_time.split(':')\n                r_minutes = int(hour) * 60 + int(minute)\n                #print(l, r, name, time_list, l_minutes, r_minutes, ans)\n                if r_minutes - l_minutes <= 60:\n                    if r - l >= 2:\n                        ans.append(name)\n                        break\n                    r += 1\n                else:\n                    l += 1\n                    if l > r:\n                        r += 1\n                    l_time = time_list[l]\n                    hour, minute = l_time.split(':')\n                    l_minutes = int(hour) * 60 + int(minute)\n        ans.sort()\n        return ans\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        x = defaultdict(list)\n        for i in range(len(keyName)):\n            time = int(keyTime[i][0:2]+keyTime[i][3:5])\n            x[keyName[i]].append(time)\n        \n        threePeat = []\n        for key,value in list(x.items()):\n            if len(value) >= 3:\n                value = sorted(value)\n                for i in range(len(value)-2):\n                    if (value[i+1] - 100) <= value[i] and (value[i+2] - 100) <= value[i]:\n                        threePeat.append(key)\n                        break\n        return sorted(threePeat)\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        from collections import defaultdict\n        \n        key_pairs = [(time, name) for name, time in zip(keyName, keyTime)]\n        key_pairs.sort()\n        keys = defaultdict(list)\n        names = set()\n        for pair in key_pairs:\n            time, name = pair\n            if name in names:\n                continue\n                \n            keys[name].append(time)\n            \n            if len(keys[name]) < 3:\n                continue\n            \n            hour, minute = time.split(':')\n            hour, minute = int(hour), int(minute)\n            first_access_time = keys[name][-3]\n            first_hour, first_minute = first_access_time.split(':')\n            first_hour, first_minute = int(first_hour), int(first_minute)\n            if hour - first_hour <= 1:\n                if hour - first_hour == 1:\n                    if minute - first_minute > 0:\n                        continue\n                    else:\n                        names.add(name)\n                else:\n                    names.add(name)\n        res = list(names)\n        res.sort()\n        \n        return res", "class Solution:\n    def alertNames(self, key_names: List[str], key_times: List[str]) -> List[str]:\n        \n        def timestamp(time):\n            h, m = time.split(\\\":\\\")\n            return 60 * int(h) + int(m)\n            \n        alerted = set() #names that have already been alerted\n        recent = defaultdict(deque) #name : recent timestamps, in  order\n        \n        #sort by timestamp\n        for time, name in sorted(zip((timestamp(t) for t in key_times), key_names)):\n            if name not in alerted:\n                recent[name].append(time)\n                while recent[name] and recent[name][0] < time - 60:\n                    recent[name].popleft()\n                if len(recent[name]) >= 3:\n                    alerted.add(name)\n                    recent.pop(name)\n        \n        return sorted(alerted)", "def convert_time(str_time):\n    return [int(segment) for segment in str_time.split(\\\":\\\")]\n\n\ndef within(next_time, last_time):\n    # compute the next_time - last_time\n    next_h = next_time[0]\n    next_m = next_time[1]\n    \n    last_h = last_time[0]\n    last_m = last_time[1]\n\n        \n    if next_h == last_h:\n        return True\n    elif next_h > last_h:\n        # 10:07 - 09:08 = 607 - 548 = 59\n        diff = next_h * 60 + next_m - (last_h * 60 + last_m)\n        return diff <= 60\n    else:\n        # next_h < last_h\n        # 00:01 - 23:59 = 24 * 60 + 1 - 23 * 60 + 59 = 1441 - 1439\n        diff = (next_h + 24) * 60 + next_m - (last_h * 60 + last_m)\n        return diff <= 60\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        name_to_time = {}\n        \n        # daniel => [10:00, 10:40, ...]\n        # luis => [....]\n        for name, time in zip(keyName, keyTime):\n            if name in name_to_time:\n                name_to_time[name].append(convert_time(time))\n            else:\n                name_to_time[name] = [convert_time(time)]\n        \n        for name in name_to_time:\n            name_to_time[name].sort(key=lambda time: (time[0], time[1]))\n        \n        alerted = []\n        window = 3\n        for name in name_to_time:\n            for i in range(len(name_to_time[name]) - window + 1):\n                current_time = name_to_time[name][i]\n                count = 1\n                for j in range(1, window):\n                    next_time = name_to_time[name][i + j]\n                    if within(next_time, current_time):\n                        count += 1\n                    \n                if count == 3:\n                    alerted.append(name)\n                    break\n                    \n            # count = 1\n            # last_time = name_to_time[name][0]\n            # for i in range(1, len(name_to_time[name])):\n            #     next_time = name_to_time[name][i]\n            #     inside = within(next_time, last_time)\n            #     if inside:\n            #         count += 1\n            #     else:\n            #         count = 1\n            #     last_time = next_time\n            #     if count >= 3:\n            #         alerted.append(name)\n            #         break\n        \n        alerted.sort()\n        return alerted\n        \n        ", "from collections import defaultdict\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        workers = defaultdict(list)\n        tup = [[keyTime[i],keyName[i]] for i in range(len(keyTime))]\n        for i in range(len(keyName)):\n            workers[tup[i][1]].append(tup[i][0])\n        answer = []\n        for worker,times in list(workers.items()):\n            i,j=0,0\n            stimes=sorted(times)\n            \n            while j<len(stimes):\n                hh1=int(stimes[i][:2])\n                hh2=int(stimes[j][:2])\n                mm1=int(stimes[i][3:])\n                mm2=int(stimes[j][3:])\n                \n                if hh1==hh2 or ( abs(hh1-hh2)==1 and mm2+(60-mm1) <=60 ):\n                    if j-i+1==3:\n                        answer.append(worker)\n                        break\n                    j+=1\n                else:\n                    i+=1\n        return sorted(answer)\n        \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def time(strt):\n            h, m = strt.split(':')\n            h = h[1:] if h[0]=='0' else h\n            m = m[1:] if m[0]=='0' else m\n            return int(h)*60+int(m)\n        \n        use = collections.defaultdict(lambda: collections.deque(maxlen=3))\n        ans = set()\n        for n, t in sorted([(n, t) for n, t in zip(keyName, keyTime)], key=lambda x:x[1]):\n            use[n].append(t)\n            if len(use[n])==3 and abs(time(use[n][-1])-time(use[n][0]))<=60:\n                print(n, use[n])\n                ans.add(n)\n                \n        return sorted(ans)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        names={}\n        def minutes(time):\n            hm=time.split(\\\":\\\")\n            return int(hm[0])*60+int(hm[1])\n        \n        res = set()\n        for time,name in sorted(zip(keyTime, keyName), key=lambda tup:minutes(tup[0])):\n            mins = minutes(time)\n            if name not in names:\n                names[name]=[mins]\n            else:\n                names[name].append(mins)\n                while len(names[name])>2:\n                    first=names[name].pop(0)\n                    last=names[name][-1]\n                    if last-first<=60:\n                        res.add(name)\n                    \n                    \n        return list(sorted(res))\n                ", "def time_diff(S1,S2):\n    h1, h2, m1, m2 = int(S1[:2]), int(S2[:2]), int(S1[3:5]), int(S2[3:5])\n    h_diff = h2-h1\n    m_diff = m2-m1\n    return (h2-h1)*60+m2-m1\n\nfrom collections import defaultdict\nclass Solution:\n    def alertNames(self, keyName, keyTime):\n        ans = set()\n        names = defaultdict(list)\n        time_name = sorted(list(zip(keyTime,keyName)))\n        for time, name in time_name:\n            names[name].append(time)\n            if len(names[name]) >= 3 and time_diff(names[name][-3],names[name][-1]) <= 60:\n                ans.add(name)\n        print(names)\n        return sorted(list(ans))", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def toTime(hhmm):\n            hh, mm = hhmm.split(\\\":\\\")\n            return int(hh) * 60 + int(mm)\n        \n        res = set()\n        mq = collections.defaultdict(collections.deque)\n        for name, time in sorted(zip(keyName, keyTime), key=lambda x: x[1]):\n            # print(name, time)\n            t = toTime(time)\n            q = mq[name]\n            while len(q) > 0 and q[0] < t - 60:\n                q.popleft()\n            q.append(t)\n            \n            # print(q)\n            if len(q) >= 3:\n                res.add(name)\n        \n        return sorted(list(res))", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        times = defaultdict(list)\n        for i in range(len(keyName)):\n            time = int(keyTime[i][:2] + keyTime[i][3:5])\n            times[keyName[i]].append(time)\n        \n        print(times)\n        threes = []\n        for key, value in times.items():\n            if len(value) >= 3:\n                value = sorted(value)\n                for i in range(len(value)-2):\n                    if (value[i+1] - 100) <= value[i] and (value[i+2] - 100) <= value[i]:\n                        threes.append(key)\n                        break\n        return sorted(threes)", "class Solution:\n    \n    def getTimeInMinutes(self, time):\n        hour,minute = time.split(\\\":\\\")\n        hour = int(hour)\n        minute = int(minute)\n        return hour * 60 + minute\n    \n    def alert(self, swipeTimes):\n        window = collections.deque()\n        for time in swipeTimes:\n            while len(window) > 0 and time - window[0] > 60:\n                window.popleft()\n            window.append(time)\n            if len(window) >= 3:\n                return True\n        return False\n     \n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        swipes = collections.defaultdict(list)\n        for index in range(len(keyName)):\n            swipes[keyName[index]].append(self.getTimeInMinutes(keyTime[index]))\n            \n        result = []\n        for key in swipes:\n            swipes[key].sort()\n            if self.alert(swipes[key]):\n                result.append(key)\n        \n        result.sort()\n        return result", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        def time_to_minutes(time):\n            h, m = time.split(':')\n            return int(m) + 60*int(h)\n        \n        def time_difference(t1, t2):\n            return t2 - t1\n        \n        keyTime = [time_to_minutes(t) for t in keyTime]\n        keyTime, keyName = zip(*sorted(zip(keyTime, keyName)))\n        \n        usage = collections.defaultdict(collections.deque)\n        \n        res = set()\n        for name, time in zip(keyName, keyTime):\n            \n            if name in res:\n                continue\n            \n            if len(usage[name]) == 2:\n                if time_difference(usage[name][0], time) <= 60:\n                    res.add(name)\n                usage[name].popleft()\n                usage[name].append(time)\n            else:\n                usage[name].append(time)\n        \n        return sorted(res)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def getMins(t):\n            h, m = list(map(int, t.split(\\\":\\\")))\n            return (h*60) + m\n        \n        ans = set()\n        inp = collections.defaultdict(list)\n        \n        for name, time in zip(keyName, keyTime):\n            inp[name].append(getMins(time))\n            \n        for name, mList in inp.items():\n            mList.sort()\n            N = len(mList)\n            \n            for left in range(N-2):\n                if mList[left+2]-mList[left] <= 60:\n                    ans.add(name)\n                    break\n                \n        return sorted(ans)", "import datetime\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        def time_to_sec(time):\n            [hours, minutes] = [int(x) for x in time.split(':')]\n            x = datetime.timedelta(hours=hours, minutes=minutes)\n            return x.seconds\n        \n        \n        dic={}\n        \n        sec=[]\n        for i in range(len(keyTime)):\n            sec.append(time_to_sec(keyTime[i]))\n         \n        \n        # name=[x for _, x in sorted(zip(sec, keyName), key=lambda pair: pair[0])]\n            \n        # print(name)\n        name=keyName\n        \n        for i in range(len(name)):\n            if name[i] not in dic:\n                dic[name[i]]=[sec[i]]\n            else:\n                dic[name[i]].append(sec[i])\n        \n        for key, value in list(dic.items()):\n            value.sort()\n        # print(dic)\n        ans=[]        \n        for key, value in list(dic.items()):\n            if len(value)>=3:\n                count=1\n                i=0\n                j=1\n                while j<len(value):\n                    if value[j]-value[i]<=3600:\n                        if value[j]-value[i]!=0: \n                            count+=1\n                        j+=1\n                    else:\n                        i+=1\n                        count=1\n                      \n                    if count==3:\n                        ans.append(key)\n                    # print(count)    \n        return  sorted(list(set(ans)))              \n                    \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        record = {}\n        def to_mininute(time):\n            h, m = [int(t) for t in time.split(':')]\n            return h * 60 + m\n        keyTime = list(map(to_mininute, keyTime))\n        data = list(zip(keyTime, keyName))\n        data.sort()\n        for time, name in data:\n            if name not in record:\n                record[name] = []\n            record[name].append(time)\n        ans = set()\n        for name, times in list(record.items()):\n            print((name, times))\n            l = len(times)\n            for i in range(2, l):\n                #print(times[i], times[i - 2])\n                if times[i] - times[i - 2] <= 60:\n                    ans.add(name)\n                    break\n            #print(sorted(list(ans)))\n        return sorted(list(ans))\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        ans = set()\n        emp = defaultdict(list)\n        for name, time in zip(keyName, keyTime):\n            h, m = list(map(int, time.split(':')))\n            t = h*60 + m\n            emp[name].append(t)\n        for p, ts in list(emp.items()):\n            ts.sort()\n            tmp = deque(maxlen=3)\n            for t in ts:\n                tmp.append(t)\n                if len(tmp) == 3 and tmp[0]+60>=tmp[-1]:\n                    ans.add(p)\n                    continue\n        return sorted(ans)\n", "from typing import List, Mapping, Set, Deque\nfrom collections import defaultdict, deque\n\n\nclass RateLimiterTokenBucket:\n    def __init__(self, period: float, limit: float) -> None:\n        self._tokens = limit\n        self._rate = period + 1.0\n        self._limit = limit\n        self._last_access_ts = 0.0\n\n    def _update_tokens(self, access_ts: float) -> None:\n        new_tokens = self._tokens\n\n        new_tokens += (access_ts - self._last_access_ts) / self._rate\n\n        self._tokens = min(self._limit, new_tokens)\n        self._last_access_ts = access_ts\n\n    def access(self, access_ts: float, tokens: float = 1.0) -> bool:\n        self._update_tokens(access_ts)\n\n        if self._tokens > tokens:\n            self._tokens -= tokens\n            return True\n        else:\n            return False\n\n\nclass RateLimiter:\n    def __init__(self, period: float, limit: int) -> None:\n        self._period = period\n        self._limit = limit\n        self._queue: Deque[float] = deque(maxlen=limit)\n\n    def access(self, access_ts: float) -> bool:\n        result = True\n        if (\n            len(self._queue) == self._limit\n            and self._queue[0] >= access_ts - self._period\n        ):\n            result = False\n\n        self._queue.append(access_ts)\n        return result\n\n\ndef human_time_to_timestamp(human_time: str) -> float:\n    hours, minutes = tuple(map(float, human_time.split(\\\":\\\")))\n\n    return hours * 60 * 60 + minutes * 60\n\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        ALERT_LIMIT_PERIOD = 3600.0\n        ALERT_LIMIT = 2\n\n        employee_limiter: Mapping[str, RateLimiter] = defaultdict(\n            lambda: RateLimiter(ALERT_LIMIT_PERIOD, ALERT_LIMIT)\n        )\n\n        result_set: Set[str] = set()\n\n        for employee_name, human_time in sorted(zip(keyName, keyTime)):\n            timestamp = human_time_to_timestamp(human_time)\n\n            rate_limiter = employee_limiter[employee_name]\n\n            if not rate_limiter.access(timestamp):\n                result_set.add(employee_name)\n\n        return list(sorted(result_set))\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        key_uses = list(sorted(zip(keyName, keyTime)))\n        alerts = set()\n        uses_by_user = collections.defaultdict(deque)\n        for user, time in key_uses:\n            hr, mn = time.split(':')\n            tm = int(hr) * 60 + int(mn)\n            uses_by_user[user].append(tm)\n            print((uses_by_user[user][0]))\n            while uses_by_user[user][0] < tm - 60:\n                uses_by_user[user].popleft()\n            if len(uses_by_user[user]) > 2:\n                alerts.add(user)\n        return sorted(list(alerts))\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        arr=sorted(zip(keyName,keyTime))\n        person=arr[0][0]\n        queue=[]\n        res=[]\n        flag=False\n        def diff(t1,t2):\n            t1=int(t1[:2])*60+int(t1[3:])\n            t2=int(t2[:2])*60+int(t2[3:])\n            return t2-t1\n            \n        for i in range(len(arr)):\n            if arr[i][0]!=person:\n                person=arr[i][0]\n                queue=[arr[i][1]]\n                flag=False\n            else:\n                if flag==True:\n                    continue\n                queue.append(arr[i][1])\n                while(diff(queue[0],arr[i][1])>60):\n                    queue.pop(0)\n                if len(queue)>=3:\n                    res.append(person)\n                    flag=True\n        return res\n", "from datetime import datetime\n\nclass Solution:\n\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        x = defaultdict(list)\n        for i in range(len(keyName)):\n            time = int(keyTime[i][0:2] + keyTime[i][3:5])\n            x[keyName[i]].append(time)\n            \n        \n        print(x)\n        three = []\n        for key, value in list(x.items()):\n            if len(value) >= 3:\n                value = sorted(value)\n                for i in range(len(value)- 2):\n                    if (value[i+1]- 100) <= value[i] and (value[i+2] - 100) <= value[i]:\n                        three.append(key)\n                        break\n        return sorted(three)\n        \n                \n#         alerted = []\n#         namesTimes = {}\n                \n#         for i in range(len(keyName)):\n#             if keyName[i] in namesTimes:\n#                 namesTimes[keyName[i]].append(keyTime[i])\n#                 namesTimes[keyName[i]]\n#             else:\n#                 namesTimes[keyName[i]] = [keyTime[i]]\n                \n        \n#         lowerbound = datetime.strptime('00:00','%H:%M') - datetime.strptime('00:00','%H:%M')\n#         upperbound = datetime.strptime('01:01','%H:%M') - datetime.strptime('00:00','%H:%M')\n        \n        \n#         for person, times in namesTimes.items():\n#             times = sorted(times)\n#             if len(times) >= 3:\n#                 # only check if they even used their card 3 or more times\n#                 # examine the times\n#                 # how do we do that?\n#                 # check the first 2. if they're within the same hour, check the first and third one\n#                 #datetime_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')\n                \n                \n#                 # let's make this inner loop more efficient: \n#                 # if the first two times don't qualify, increment x by 2\n#                 # if the first and third times don't qualify, increment x by 3\n#                  for x in range(len(times)-2):\n#                     time1 = datetime.strptime(times[x], '%H:%M')\n#                     time2 = datetime.strptime(times[x+1], '%H:%M')\n\n#                     diff1 = time2 - time1\n#                     # if the first two times are within the hour, check the third time\n\n#                     if diff1 > lowerbound and diff1 < upperbound:\n#                         # we can check the third time, then\n\n#                         print(\\\"for\\\", person, \\\"differences of\\\", diff1)\n\n#                         time3 = datetime.strptime(times[x+2], '%H:%M')\n\n#                         diff2 = time3 - time1\n\n#                         if diff2 > lowerbound and diff2 < upperbound:\n#                             print(\\\"for\\\", person, \\\"differences of\\\", diff2)\n#                             # we found someone\n#                             alerted.append(person)\n#                             # go to the next person\n#                             break  \n#         print(alerted)\n#         alerted.sort()\n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        last = collections.defaultdict(list)\n        for name, time in zip(keyName, keyTime):\n            hh, mm = time.split(\\\":\\\")\n            last[name].append(int(hh)*60+int(mm))\n            \n        ans = []\n        for name, times in last.items():\n            times.sort()\n            l, r = 0, 0\n            for r in range(len(times)):\n                if r-l >= 2 and times[r]-times[l] <= 60:\n                    ans.append(name)\n                    break\n                while l < r and times[r]-times[l] > 60:\n                    l += 1\n        return sorted(ans)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        ar = sorted(zip(keyTime, keyName))\n        d = dict()\n        ans = set()\n        n = len(ar)\n        \n        i, j = 0, 0\n        \n        while i < n:\n            time, name = ar[i]\n            hour, minute = map(int, time.split(':'))\n            timeLimit = str(hour - 1).zfill(2) + ':' + str(minute).zfill(2)\n            \n            while j < i and ar[j][0] < timeLimit:\n                d[ar[j][1]] -= 1\n                j += 1\n            \n            d[name] = 1 + d.get(name, 0)\n            if d[name] >= 3:\n                ans.add(name)\n            i += 1\n        \n        return sorted(ans)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        times = []\n        for t in keyTime:\n            t = t.split(\\\":\\\")\n            times.append([int(t[0]), int(t[1])])\n        name_time = sorted(zip(keyName, times), key=lambda x: (x[0], x[1][0], x[1][1]))\n        ans = set()\n        for i in range(len(name_time) - 2):\n            name = name_time[i][0]\n            time = name_time[i][1]\n            nname = name_time[i + 2][0]\n            ntime = name_time[i + 2][1]\n            if name == nname:\n                during = (ntime[0] - time[0]) * 60 + (ntime[1] - time[1])\n                if during <= 60:\n                    ans.add(name)\n        \n        ans = sorted(list(ans))\n        \n        return ans", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def def_val():\n            return []\n        d=defaultdict(def_val)\n        n=len(keyName)\n        for i in range(n):\n            d[keyName[i]].append(keyTime[i])\n        res=[]\n        for i in d:\n            arr=sorted(d[i])\n            # print(i,arr)\n            m=len(arr)\n            if m>=3:\n                for j in range(m-2):\n                    [eh,em]=[int(k) for k in arr[j+2].split(\\\":\\\")]\n                    [sh,sm]=[int(k) for k in arr[j].split(\\\":\\\")]\n                    if eh*60+em-(sh*60+sm)<=60:\n                        res.append(i)\n                        break\n        return sorted(res)", "from collections import deque\n\nclass TimeTracker:\n    \n    def __init__(self):\n        self.users = defaultdict(deque)\n        \n    def add(self, name, time):\n        self.users[name].append(time)\n        while (self.users[name][-1] - self.users[name][0]) > 60:\n            self.users[name].popleft()\n        if len(self.users[name]) >= 3:\n            return True\n        return False\n\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        alerts = set()\n        tracker = TimeTracker()\n        names = sorted([(name, convert_time(time)) for name, time in zip(keyName, keyTime)])\n        for name, time in names:\n            if tracker.add(name, time):\n                alerts.add(name)\n        return sorted(alerts)\n        \ndef convert_time(timestamp):\n    hours, minutes = timestamp.split(':')\n    time = int(hours) * 60 + int(minutes)\n    return time", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        M = defaultdict(list)\n        \n        for i,j in zip(keyName, keyTime):\n            bisect.insort(M[i], j)\n        \n        keys = sorted(M.keys())\n        \n        res = []\n        \n        def getMins(time):\n            return int(time[:2])*60 + int(time[3:])\n        \n        # print(M)\n        \n        for key in keys:\n            for i in range(2, len(M[key])):\n                curr = M[key][i]\n                prev1 = M[key][i-2]\n                if getMins(curr) - getMins(prev1) <= 60:\n                    res.append(key)\n                    break\n        \n        return res", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        res = set()\n        d = collections.defaultdict(list)\n        for key, time in zip(keyName, keyTime):\n            hour = int(time[:2])\n            minute = int(time[3:])\n            d[key].append(60*hour+minute)\n        for key, times in d.items():\n            if key not in res:\n                times.sort()\n                q = deque()\n                for time in times:\n                    q.append(time)\n                    while q and (q[-1]-q[0])%(24*60) > 60:\n                        q.popleft()\n                    if len(q) >= 3:\n                        res.add(key)\n                        break\n        return sorted(res)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def convertTime(time):\n            time = time.split(\\\":\\\")\n            return int(time[0]) * 60 + int(time[1])\n        \n        dict = {}\n        for i in range(len(keyName)):\n            dict[keyName[i]] = dict.get(keyName[i], []) + [keyTime[i]]\n        \n        output = []\n        for k, v in sorted(dict.items()):\n            v.sort()\n            l = 0\n            for r in range(len(v)):\n                while convertTime(v[r]) - convertTime(v[l]) > 60:\n                    l +=1\n                if r - l + 1 == 3:\n                    output.append(k)\n                    break\n        return output\n                \n                \n            \n                ", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        \n        def to_minutes(t: str) -> int:\n            assert len(t) == 5\n            assert t[2] == \\\":\\\"\n            return int(t[0:2]) * 60 + int(t[3:5])\n        \n        def from_minutes(mins: int) -> str:\n            return \\\"{:02d}:{:02d}\\\".format((mins - mins % 60) // 60, mins % 60)\n\n        # return true if : t1 < t2\n        def compare_times(t1: str, t2: str) -> bool:\n            return to_minutes(t1) < to_minutes(t2)\n            \n        def add_hours(t: str, hours: int) -> str:\n            return from_minutes(60 * hours + to_minutes(t))\n                \n        lookup = {}\n        \n        output = set()\n        for name, time in zip(keyName, keyTime):\n            if name in lookup:\n                lookup[name].append(time)\n            else:\n                lookup[name] = [time]\n        for name in lookup:\n            lookup[name].sort()\n            times = []\n            for time in lookup[name]:\n                while times and compare_times(add_hours(times[0], 1), time):\n                    times.pop(0)\n                times.append(time)\n                if len(times) >= 3:\n                    output.add(name)\n                \n        return sorted(list(output))", "class Solution:\n    #1604\n    def alertNames(self, keyName: 'List[str]', keyTime: 'List[str]') -> 'List[str]':\n        N = len(keyName)\n        arr = []\n        for i in range(N):\n            t = int(keyTime[i][:2])*60+int(keyTime[i][3:])\n            arr.append([t, keyName[i]])\n        arr.sort()\n        i=0\n        counter = collections.Counter()\n        res = set()\n        for j in range(N):\n            while arr[j][0]-arr[i][0] > 60:\n                counter[arr[i][1]] -= 1\n                i += 1\n            counter[arr[j][1]] += 1\n            #print(i,j,counter)\n            if counter[arr[j][1]] >= 3:\n                res.add(arr[j][1])\n        return sorted(list(res))", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        keyTime = [time.split(':') for time in keyTime]\n        keyTime = [[int(time[0]), int(time[1])] for time in keyTime]\n        lru, res = defaultdict(deque), set()\n        for name, time in sorted(zip(keyName, keyTime), key=lambda k: k[1]):\n            if name in res:\n                continue\n            lru[name].append(time)\n            if len(lru[name]) > 2:\n                front, back = lru[name][0], lru[name][-1]\n                if (back[0] == front[0] or (back[0] - front[0] == 1 and back[1] <= front[1])):\n                    res.add(name)\n                else:\n                    lru[name].popleft()\n        return sorted(list(res))\n                    \n", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        from collections import defaultdict\n        \n        d = defaultdict(list)\n        n = len(keyName)\n        \n        for i in range(n):\n            time = int(keyTime[i][:1]+keyTime[i][3:])\n            d[keyName[i]].append(int(keyTime[i][:2]+keyTime[i][3:]))\n            \n        ans = []\n        \n        for name in d:\n            d[name].sort()\n            \n            for i in range(len(d[name])-2):\n                if d[name][i+2]-d[name][i]<=100:\n                    ans.append(name)\n                    break\n                    \n            # for j in range(0,2301,100):\n            #     count = len([x for x in d[name] if x>=j and x<=j+100])\n            #     if count>=3:\n            #         ans.append(name)\n            #         break\n        print(d)\n        \n        return sorted(ans)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        n=len(keyName)\n        lst=[0]*n\n        for i in range(n):\n            a,b=keyTime[i].split(':')\n            st=float(a+'.'+b)\n            lst[i]=[keyName[i],st]\n        lst.sort()\n        i=0\n        ans=[]\n        while i<n:\n            name=lst[i][0]\n            minn=lst[i][1]\n            lst2=[]\n            while i<n and lst[i][0]==name:\n                lst2.append(lst[i][1])\n                i+=1\n            lst2.sort()\n            if len(lst2)>=3:\n                foo=0\n                for k in range(len(lst2)-2):\n                    if float(format(lst2[k+2]-lst2[k],'.2f'))<=1.00:\n                        foo=1\n                if foo==1:\n                    ans.append(name)\n        ans.sort()\n        return ans", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        pairs = []\n        \n        for i in range(len(keyName)):\n            pairs.append((keyName[i], self.getMinutes(keyTime[i])))\n        pairs.sort()\n        \n        print(pairs)\n        \n        i = 0\n        res = []\n        while i+2 < len(pairs):\n            if pairs[i+2][0] == pairs[i][0]:\n                name = pairs[i][0]\n                print(name)\n                print(pairs[i+1][1], pairs[i][1] + 60)\n                print(pairs[i+2][1], pairs[i][1] + 60)\n                if pairs[i+1][1] <= pairs[i][1] + 60 and pairs[i+2][1] <= pairs[i][1] + 60:\n                    res.append(pairs[i][0])\n                    while i < len(pairs) and pairs[i][0] == name:\n                        i += 1\n                    i -= 1\n            i += 1\n        return res\n    \n    def getMinutes(self, time):\n        hh, mm = time.split(':')\n        return int(hh)*60 + int(mm)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        items = sorted(zip(keyTime, keyName))\n        \n        beg, count = 0, Counter()\n        res = set()\n        for t, name in items:\n            p = t.split(':')\n            p = (int(p[0]) - 1, p[1])\n            if p[0] >= 0:\n                p = \\\"{0:02}:{1}\\\".format(*p)\n                while beg < len(items) and items[beg][0] < p:\n                    count[items[beg][1]] -= 1\n                    beg += 1\n            count[name] += 1\n            if count[name] >= 3:\n                res.add(name)\n                \n        return sorted(res)", "from collections import defaultdict\nfrom collections import deque\n\nclass Solution:\n    def alertNames(self, key_name, key_time):\n        time_name = []\n        for name, time_ in zip(key_name, key_time):\n            hour_str, minute_str = time_.split(':')\n            hour, minute = int(hour_str), int(minute_str)\n            time_name.append((60 * hour + minute, name))\n        time_name.sort()\n\n        mapping = defaultdict(deque)\n        res = set()\n        for time_, name in time_name:\n            curr = mapping[name]\n            while curr and time_ - curr[0] > 60:\n                curr.popleft()\n            curr.append(time_)\n            if len(curr) >= 3:\n                res.add(name)\n\n        return sorted(res)", "class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        keyTime = [time.split(':') for time in keyTime]\n        keyTime = [[int(time[0]), int(time[1])] for time in keyTime]\n        lru, res = defaultdict(deque), set()\n        for name, time in sorted(zip(keyName, keyTime), key=lambda k: k[1]):\n            if name in res:\n                continue\n            lru[name].append(time)\n            if len(lru[name]) > 2:\n                front, mid, back = lru[name][0], lru[name][1], lru[name][-1]\n                if (back[0] == front[0] or (back[0] - front[0] == 1 and back[1] <= front[1])):\n                    print((front, mid, back))\n                    res.add(name)\n                else:\n                    lru[name].popleft()\n        return sorted(list(res))\n                    \n", "from collections import Counter\nclass Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        def _convertTime(x):\n            h = int(x[0:2])\n            m = int(x[3:5])\n            t = h*60 + m\n            return t\n        keyTime = [_convertTime(el) for el in keyTime]\n        keys = list(zip(keyTime, keyName))\n        keys = sorted(keys)\n        \n        # Break keys up into individual names\n        people = {}\n        for key in keys:\n            if key[1] in people:\n                people[key[1]].append(key)\n            else:\n                people[key[1]] = [key]\n        ans = []\n        for person, keys in list(people.items()):\n            q = []\n            for key in keys:\n                time = key[0]\n                q.append(time)\n                while q[0]+60 < q[-1]:\n                    q.pop(0)\n                if len(q) >= 3:\n                    ans.append(key[1])\n                    break\n        return sorted(ans)\n                    \n            \n            # Remove people from q\n            \n"]
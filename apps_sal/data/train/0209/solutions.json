["class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        if (n - 1) % (K - 1) != 0:\n            return -1\n        prefix = [0]\n        for s in stones:\n            prefix.append(prefix[-1] + s)\n        @lru_cache(None)\n        def dp(i, j):\n            if j - i + 1 < K:\n                return 0\n            res = 0\n            if (j - i) % (K - 1) == 0:\n                res = prefix[j+1] - prefix[i]\n            return res + min(dp(i, mid) + dp(mid+1, j) for mid in range(i, j, K - 1))\n        return dp(0, n - 1)", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        if (n-1)%(K-1) != 0:\n            return -1\n        dp = [[0]*n for _ in range(n)]\n        sums = [0]*(n+1)\n        for i in range(1,n+1):\n            sums[i] = sums[i-1]+stones[i-1]\n        for length in range(K,n+1):\n            for i in range(n-length+1):\n                j = i+length-1\n                dp[i][j] = float('inf')\n                for t in range(i,j,K-1):\n                    dp[i][j] = min(dp[i][j], dp[i][t]+dp[t+1][j])\n                if (j-i)%(K-1)==0:\n                    dp[i][j] += sums[j+1]-sums[i]\n        return dp[0][n-1]", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        \n        @lru_cache(None)\n        def recursive(i, j, piles):\n            if j - i + 1 < K: return 0\n            if piles == 1:\n                return recursive(i, j, K) + pre_sum[j+1] - pre_sum[i]\n            else:\n                min_cost = float('inf')\n                for k in range(i, j, K - 1):\n                    min_cost = min(min_cost, recursive(i, k, 1) + recursive(k + 1, j, piles - 1))\n                return min_cost\n            \n        n = len(stones)\n        if (n - 1) % (K - 1) != 0:\n            return -1\n        pre_sum = [0] * (n + 1)\n        for i in range(n):\n            pre_sum[i + 1] = pre_sum[i] + stones[i]\n\n        return recursive(0, n - 1, 1)", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        k = K\n        if (n < k and n != 1) or (n - 1) % (k - 1) != 0:\n            return -1\n        if n == 1:\n            return 0\n        \n        dp = [[-1 for _ in range(n)] for _ in range(n)]  # dp[i][j] stores min cost to reduce [i, j] as much as possible\n        self.solve(stones, 0, n - 1, k, dp)\n        # print(dp)\n        return dp[0][n - 1]\n    \n    def solve(self, stones, l, r, k, dp):\n        length = r - l + 1\n        if length < k:\n            dp[l][r] = 0\n            return\n        if length == k:\n            dp[l][r] = sum(stones[l:r+1])\n            return\n        res = float('inf')\n        for m in range(l, r):\n            length = length\n            length_l = m - l + 1\n            length_r = r - m\n            \n            rem = k - 1 if length % (k - 1) == 0 else length % (k - 1)\n            rem_l = k - 1 if length_l % (k - 1) == 0 else length_l % (k - 1)\n            rem_r = k - 1 if length_r % (k - 1) == 0 else length_r % (k - 1)\n            rem_total = k - 1 if (rem_l + rem_r) % (k - 1) == 0 else (rem_l + rem_r) % (k - 1)\n            if rem_total == rem and (rem_l + rem_r) <= k:\n                if dp[l][m] == -1:\n                    self.solve(stones, l, m, k, dp)\n                if dp[m + 1][r] == -1:\n                    self.solve(stones, m + 1, r, k, dp)\n                # print('lets check {} to {} and {}'.format(l, m, r))\n                # print(dp[l][m], dp[m+1][r])\n                res = min(res, dp[l][m] + dp[m+1][r])\n                \n        dp[l][r] = res\n        if rem == 1:\n            dp[l][r] += sum(stones[l:r+1])\n        \n    \n# class Solution:\n#     def mergeStones(self, stones: List[int], K: int) -> int:\n#         n = len(stones)\n#         k = K\n#         if (n < k and n != 1) or (n - k) % (k - 1) != 0:\n#             return -1\n#         if n == 1:\n#             return 0\n        \n#         return self.comp_min(stones, k, -1)\n    \n#     def comp_min(self, stones, k, locked):  # can't do a merge which only involves the first 'locked' stones\n#         n = len(stones)\n#         if n == k:\n#             return sum(stones)\n        \n#         total_cur_cost = float('inf')\n        \n#         for i in range(max(0, locked - k + 2), n - k + 1):\n#             cur_cost = sum(stones[i:i+k])\n#             new_stones = stones[:i] + [cur_cost] + stones[i+k:]\n            \n#             new_locked = i - 1\n            \n#             tmp = self.comp_min(new_stones, k, new_locked)\n            \n#             total_cur_cost = min(total_cur_cost, cur_cost + tmp)\n                \n#         return total_cur_cost\n", "from functools import lru_cache\nimport itertools\n\nclass Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        # dp[i][j] means the minimum cost needed to merge stones[i] ~ stones[j].\n        # Time  complexity: O(N^3 / K)\n        # Space complexity: O(KN^2)\n        n = len(stones)\n        if (n - 1) % (K - 1): return -1\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + stones[i]\n\n        @lru_cache(None)\n        def dp(i, j):\n            if j - i + 1 < K: return 0\n\n            res = min(dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1))\n\n            if (j - i) % (K - 1) == 0:\n                res += prefix[j + 1] - prefix[i]\n\n            return res\n\n        return dp(0, n - 1)\n", "from functools import lru_cache\nimport itertools\n\nclass Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        # Time  complexity: O(N^3 / K)\n        # Space complexity: O(KN^2)\n        n = len(stones)\n        if (n - 1) % (K - 1): return -1\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + stones[i]\n\n        @lru_cache(None)\n        def dp(i, j):\n            if j - i + 1 < K: return 0\n\n            res = min(dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1))\n\n            if (j - i) % (K - 1) == 0:\n                res += prefix[j + 1] - prefix[i]\n\n            return res\n\n        return dp(0, n - 1)\n", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        dp, N, Sum, H = {}, len(stones), {-1: 0}, {}\n        for i in range(N):\n            j, dp[i], H[i], Sum[i] = i, {}, {}, Sum[i - 1] + stones[i]       \n            while j > -1:\n                H[i][j] = (i-j+1)%(K-1)+(K-1)*(1//(1+(i-j+1)%(K-1)))\n                if i - j < K - 1: dp[i][j] = 0    \n                else:\n                    dp[i][j] =  dp[i][i] + dp[i - 1][j]\n                    for k in range(j + 1, i + 1):\n                        if H[i][k] + H[k - 1][j] == H[i][j] or H[i][k] + H[k - 1][j] == K:\n                            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k - 1][j])     \n                    if H[i][j] == 1: dp[i][j] += Sum[i] - Sum[j - 1]\n                j = j - 1           \n        return dp[N-1][0]*(1//H[N-1][0]) - min(H[N-1][0]-1, 1) ", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        k = K\n        if (n < k and n != 1) or (n - 1) % (k - 1) != 0:\n            return -1\n        if n == 1:\n            return 0\n        \n        dp = [[-1 for _ in range(n)] for _ in range(n)]  # dp[i][j] stores min cost to reduce [i, j] as much as possible\n        self.solve(stones, 0, n - 1, k, dp)\n        return dp[0][n - 1]\n    \n    def solve(self, stones, l, r, k, dp):\n        length = r - l + 1\n        if length < k:\n            dp[l][r] = 0\n            return\n        if length == k:\n            dp[l][r] = sum(stones[l:r+1])\n            return\n        res = float('inf')\n        for m in range(l, r):\n            length = length\n            length_l = m - l + 1\n            length_r = r - m\n            \n            rem = k - 1 if length % (k - 1) == 0 else length % (k - 1)\n            rem_l = k - 1 if length_l % (k - 1) == 0 else length_l % (k - 1)\n            rem_r = k - 1 if length_r % (k - 1) == 0 else length_r % (k - 1)\n            rem_total = k - 1 if (rem_l + rem_r) % (k - 1) == 0 else (rem_l + rem_r) % (k - 1)\n            if rem_total == rem and (rem_l + rem_r) <= k:\n                if dp[l][m] == -1:\n                    self.solve(stones, l, m, k, dp)\n                if dp[m + 1][r] == -1:\n                    self.solve(stones, m + 1, r, k, dp)\n                res = min(res, dp[l][m] + dp[m+1][r])\n                \n        dp[l][r] = res\n        if rem == 1:\n            dp[l][r] += sum(stones[l:r+1])\n", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        total = len(stones)\n        if (total-1) % (K-1):\n            return -1\n        \n        \n        prefix = [0] * (total+1)\n        for i in range(total):\n            prefix[i+1] = prefix[i]+stones[i]\n        \n        import functools\n        @functools.lru_cache(None)\n        def dfs(i, j):\n            if j-i+1 < K:\n                return 0\n            res = min(dfs(i,k)+dfs(k+1,j) for k in range(i, j, K-1))\n            if (j-i) % (K-1) == 0:\n                res += prefix[j+1]-prefix[i]\n                \n            return res\n        \n        return dfs(0, total-1)", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        '''\n        dp[i][j][k]: the min cost to merge stone[i: j + 1] into k piles\n        the range for consecutive piles of stone[i:j + 1] to be k piles after merging can be divided into two parts (for stones[:n] be finally merged into 1 pile):\n            1. a sub-range from the start to the devide that is sured to be merged in to 1 pile: dp[i][divide][1]\n                divide goes from start by K - 1 step to make this happen: dp[i][divide][1] < math.inf\n            2. a sub-range from the divide + 1 to the end (not guaranteed to be realistic): dp[divide + 1][k - 1]\n        The longer ranges are always merged from the smaller ones, no matter how the smaller ones were merged from. That is why this is a DP problem.\n        '''\n        n = len(stones)\n        if K > 2 and n % (K - 1) != 1:\n            return -1\n        \n        dp = [[[math.inf] * (K + 1) for i in range(n)] for j in range(n)]\n        for i in range(n):\n            dp[i][i][1] = 0\n            \n        presum = [stones[0]]\n        for i in range(1, n):\n            presum.append(presum[i - 1] + stones[i])\n            \n        def stones_in_range(i, j):\n            return presum[j] - presum[i - 1] if i > 0 else presum[j]\n        \n        for rangelen in range(2, n + 1):\n            for start in range(n + 1 - rangelen):\n                end = start + rangelen - 1\n                for k in range(2, K + 1):\n                    for divide in range(start, end, K - 1):\n                        dp[start][end][k] = min(dp[start][end][k], dp[start][divide][1] + dp[divide + 1][end][k - 1])\n                if dp[start][end][K] < math.inf:\n                    dp[start][end][1] = dp[start][end][K] + stones_in_range(start, end)\n                    \n        return dp[0][n - 1][1]", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        if (len(stones) - 1) % (K - 1) != 0:\n            return -1\n        \n        prefix = [0]\n        for stone in stones:\n            prefix.append(prefix[-1] + stone)\n            \n        memo = {}\n\n        def recur(i: int, j: int, m: int):\n            key = str(i) + ',' + str(j) + ',' + str(m)\n            if key in memo:\n                return memo[key]\n            \n            if (j - i + 1 - m) % (K - 1):\n                return 91111111\n            \n            if (j - i + 1) < K:\n                memo[key] = 0\n                return 0\n\n            if m == 1:\n                if j - i + 1 == K:\n                    memo[key] = prefix[j + 1] - prefix[i]\n                    return memo[key]\n                else:\n                    return recur(i, j, K) + prefix[j + 1] - prefix[i]\n\n            min_sum = 91111111\n            for mid in range(i, j, K - 1):\n                cur_sum = recur(i, mid, 1) + recur(mid + 1, j, m - 1)\n                min_sum = min(min_sum, cur_sum)\n\n            memo[key] = min_sum\n            return min_sum\n        \n        return recur(0, len(stones) - 1, 1)", "from typing import List\nimport numpy\nimport sys\nimport bisect\n\n\nclass Solution:\n  def mergeStones(self, stones: List[int], K: int) -> int:\n\n    tmp = 0\n    n = len(stones)\n    dims = (n, n)\n    dp = numpy.zeros(dims)\n    presum = numpy.zeros(n+1)\n\n    if (n - 1) % (K - 1) != 0:\n      return -1\n\n    for index, stone in enumerate(stones):\n      tmp += stone\n      presum[index+1] = tmp\n\n    for rlen in range(K, n + 1):\n      for i in range(0, n - rlen + 1):\n        end = i + rlen - 1\n        dp[i][end] = sys.maxsize\n        for j in range(i, end, K - 1):\n          dp[i][end] = min(dp[i][end], dp[i][j] + dp[j + 1][end])\n\n        if (rlen - 1) % (K - 1) == 0:\n          dp[i][end] += presum[end+1] - presum[i]\n\n    return int(dp[0][n - 1])", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        dp = [[[math.inf for k in range(K + 1)] for j in range(n)] for i in range(n)]\n        # dp[i][j][k]: min cost of merging from i to j (inclusive) and finally having k piles\n        for i in range(n):\n            dp[i][i][1] = 0\n            \n        pre_sum = [0] * n\n        pre_sum[0] = stones[0]\n        for i in range(1, n):\n            pre_sum[i] = pre_sum[i - 1] + stones[i]\n        \n        def range_sum(i, j):\n            if i == 0:\n                return pre_sum[j]\n            else:\n                return pre_sum[j] - pre_sum[i - 1]\n            \n        for merge_len in range(2, n + 1): # \u679a\u4e3e\u533a\u95f4\u957f\u5ea6\n            for start in range(n - merge_len + 1): # \u679a\u4e3e\u533a\u95f4\u5de6\u7aef\u70b9\n                end = start + merge_len - 1 # \u533a\u95f4\u53f3\u7aef\u70b9\n                for k in range(2, K + 1): \n                    for middle in range(start, end, K - 1): # \u679a\u4e3e\u5206\u5272\u70b9\uff0c\u5de6\u533a\u95f4start~middle\uff0c\u53f3\u533a\u95f4middle+1~end\n                        dp[start][end][k] = min(dp[start][end][k], dp[start][middle][1] + dp[middle + 1][end][k - 1])\n                if dp[start][end][K] < math.inf: # \u53ef\u4ee5make a move\uff0cmerge start ~ end \u6210 1 \u4e2apile\n                    dp[start][end][1] = dp[start][end][K] + range_sum(start, end)\n        return dp[0][n-1][1] if dp[0][n-1][1] < math.inf else -1", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        # dp[i][j][k]: min cost of merging from i to j and finally having k piles\n        n = len(stones)\n        dp = [[[math.inf for k in range(K + 1)] for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i][1] = 0\n            \n        pre_sum = [0] * n\n        pre_sum[0] = stones[0]\n        for i in range(1, n):\n            pre_sum[i] = pre_sum[i - 1] + stones[i]\n        \n        def range_sum(i, j):\n            if i == 0:\n                return pre_sum[j]\n            else:\n                return pre_sum[j] - pre_sum[i - 1]\n        \n        for length in range(2, n+1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                # \u6700\u5c11\u4e24\u4e2a\uff0c\u6700\u591aK\u4e2apile\n                for k in range(2, K + 1):\n                    for middle in range(i, j, K-1):\n                        # \u5206\u6210 1 \u548c k-1\u5806\uff0c\u5408\u5e76\u8d77\u6765\u662f k\n                        dp[i][j][k] = min(dp[i][j][k], dp[i][middle][1] + dp[middle + 1][j][k - 1])\n                if dp[i][j][K] < math.inf:\n                    # \u5408\u5e76\u6210 1\u4e2apile\n                    dp[i][j][1] = dp[i][j][K] + range_sum(i, j)\n        return dp[0][n-1][1] if dp[0][n - 1][1] < math.inf else -1\n", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n\n        dp = [[[math.inf for k in range(K + 1)] for j in range(n)] for i in range(n)]\n        # dp[i][j][k]: min cost of merging from i to j and finally having k piles\n        for i in range(n):\n            dp[i][i][1] = 0 \n        \n        pre_sum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            pre_sum[i] = pre_sum[i - 1] + stones[i - 1]\n            \n        for merge_len in range(2, n + 1):\n            for start in range(n - merge_len + 1):\n                end = start + merge_len - 1 \n                for k in range(2, K + 1):\n                    for middle in range(start, end, K-1):\n                        dp[start][end][k] = min(dp[start][end][k], dp[start][middle][1] + dp[middle + 1][end][k - 1])\n                    if dp[start][end][K] < math.inf:\n                        dp[start][end][1] = dp[start][end][K] + pre_sum[end + 1] - pre_sum[start]\n        return dp[0][n-1][1] if dp[0][n-1][1] < math.inf else -1", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        inf = float('inf')\n        if (n - 1) % (K - 1) is not 0:\n            return -1\n        \n        prefix = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix[i] = prefix[i - 1] + stones[i - 1]\n            \n        @lru_cache(None)\n        def dp(i, j, k):\n            if i == j:\n                # cost to make one pile from one pile is 0, otherwise impossible\n                return 0 if k == 1 else inf\n            if k == 1:\n                return dp(i, j, K) + prefix[j + 1] - prefix[i]\n            return min(dp(i, m, 1) + dp(m + 1, j, k - 1) for m in range(i, j))\n            \n        return dp(0, n - 1, 1)", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        N = len(stones)\n        presum = [0 for _ in range(N + 1)]\n        dp = [[[math.inf for _ in range(K + 1)] for _ in range(N)] for _ in range(N)]\n        \n        if (N - 1) % (K - 1) != 0:\n            return -1\n        \n        for i in range(N):\n            presum[i + 1] = presum[i] + stones[i]\n            \n        for i in range(N):\n            dp[i][i][1] = 0\n        \n        for length in range(2, N + 1):\n            for start in range(N - length + 1):\n                end = start + length - 1\n                for mid in range(start, end):\n                    for k in range(2, K + 1):\n                        if k > length: \n                            continue\n                        if dp[start][mid][1] == math.inf or dp[mid + 1][end][k - 1] == math.inf:\n                            continue\n                            \n                        dp[start][end][k] = min(dp[start][end][k], dp[start][mid][1] + dp[mid + 1][end][k - 1])\n                    \n                    if dp[start][end][K] != math.inf:\n                        dp[start][end][1] = dp[start][end][K] + presum[end + 1] - presum[start]\n                    \n        if dp[0][N - 1][1] == math.inf:\n            return -1\n        return dp[0][N - 1][1]", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        if (len(stones) - 1) % (K - 1) != 0:\n            return -1\n        \n        presum = 0\n        presum_list = [presum]\n        for cost in stones:\n            presum += cost\n            presum_list.append(presum)\n        \n        # dp[i][j][k]: cost that merges into k piles: from ith pile to jth pile\n        n = len(stones)\n        dp = [[[math.inf] * (K + 1) for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i][1] = 0\n        \n        for pile_length in range(1, n + 1):\n            # pile_length = j - i + 1\n            for i in range(n - pile_length + 1):\n                j = pile_length + i - 1\n                for possible_k in range(2, min(pile_length, K) + 1):\n                    for t in range(i, j):\n                        dp[i][j][possible_k] = min(dp[i][j][possible_k], dp[i][t][possible_k - 1] + dp[t + 1][j][1])\n                dp[i][j][1] = min(dp[i][j][1], dp[i][j][K] + presum_list[j + 1] - presum_list[i])\n        \n        return dp[0][n - 1][1]", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        # Time Complexity: O(N^3 K)\n        \n        self.dp = {}\n        self.prefix = [0] + list(itertools.accumulate(stones))\n        \n        ret = self.merge(stones, 0, len(stones) - 1, 1, K)\n        \n        return ret\n        \n    def merge(self, stones, start: int, end: int, num_parts: int, K: int):\n        if (start, end, num_parts) in self.dp:\n            return self.dp[(start, end, num_parts)]\n        \n        if end - start + 1 < num_parts:\n            return -1\n        \n        if end - start + 1 == num_parts:\n            return 0\n        \n        window_sum = self.prefix[end + 1] - self.prefix[start] \n        \n        if num_parts == 1:\n            split = self.merge(stones, start, end, K, K)\n            \n            if split == -1:\n                ret = -1\n            else:\n                ret = window_sum + split\n        else:\n            candidates = []\n            \n            for i in range(start, end):\n                left = self.merge(stones, start, i, 1, K)\n                right = self.merge(stones, i + 1, end, num_parts - 1, K)\n                \n                \n                if left >= 0 and right >= 0:\n                    candidates.append(left + right)\n            \n            if candidates:\n                ret = min(candidates)\n            else:\n                ret = -1\n                \n        self.dp[(start, end, num_parts)] = ret\n        return ret\n\n", "# 1000. Minimum Cost to Merge Stones\nclass Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        N = len(stones)\n        if (N - 1) % (K - 1): \n            return -1\n        dp = [[0] * N for _ in range(N)]\n        \n        for l in range(K, N+1):\n            for i in range(N-l+1):\n                dp[i][i+l-1] = float('inf')\n                for x in range(i, i+l-1, K-1):\n                    dp[i][i+l-1] = min(dp[i][i+l-1], dp[i][x] + dp[x+1][i+l-1])\n                dp[i][i+l-1] += (sum(stones[i:i+l]) if (l-1)%(K-1) == 0 else 0)\n        \n        return dp[0][N-1]", "class Solution:\n    def mergeStones(self, stones, k):\n    \n        # quick check to see if this number of piles can be merged. \n        if (len(stones)-1)%(k-1): \n            return -1\n\n        cost = [[None]*len(stones) for _ in stones]\n\n        def subCost(left, right):\n\n            # Base case: there is no cost to \\\"merging\\\" one pile\n            if left == right: \n                return 0\n\n            if cost[left][right] != None: \n                return cost[left][right]\n\n            # Base case: a single merge is just the sum of the elements.  \n            if (right - left + 1) == k: \n                cost[left][right] = sum(stones[left:right+1])\n                return cost[left][right]\n\n            # find k-1 division points.  Each division except the last is the start index of a sub-array\n            # ie. if stones = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ], left = 0 right = 8 divs = [0, 3, 8, 9]\n            # then sub-arrays are as follows: [0, 1, 2] [3, 4, 5, 6, 7]  [8] \n            # the above divs would incidentally be valid for k = 3. \n\n            divs = [ left + i for i in range(k+1)]\n            divs[-1] = right + 1  # set the last divider to one past the subarray. \n            # for example above, divs is initialized to -> [0, 1, 2, 9].  The first and last divider never change\n\n            def moveDividers():\n                # loop through dividers to move, starting at last one.  \n                # if the last one is at the end, move the next one up. \n\n                def moveDivider(i): \n                    if i == 0: \n                        return False\n\n                    # if the div we're looking at is smashing all dividers to its right against the right end of the array. \n                    # If k = 3, i = 1, we have 1 divider to our right.  Leave 1 space for each divider to our right.\n                    # division 0 stays at 0 \n                    # div 1 can go to 2.  = right - (k - 1 - i)\n                    if divs[i] == ( right - (k - 1 - i)):\n                        # switch to the next divider to the left\n                        return moveDivider(i-1)\n\n                    # move this divider to the next usable spot given where the left neighbor div is. \n                    divs[i] += 1\n                    while (divs[i] - divs[i-1] - 1)%(k-1):\n                        divs[i] += 1\n\n                    # stack all following divs next to each other and this one. []\n                    for j in range(i+1, len(divs)-1):\n                        divs[j] = divs[j-1] + 1\n\n                    return True\n\n                # start by moving the rightmost divider\n                return moveDivider(len(divs) - 2)\n\n            best = float('inf')\n            while 1:\n                subSum = 0\n                for div_i in range(len(divs)-1):\n                    subSum += subCost(divs[div_i], divs[div_i+1] - 1) \n                best = min(best, subSum) \n                if not moveDividers():\n                    break\n\n            result = best + sum(stones[left:right+1])\n            cost[left][right] = result\n            return result\n\n        result = subCost(0, len(stones)-1)\n        #print(cost)\n        return result ", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        # Time Complexity: O(N^3 K)\n        # Space Complexity: O(N^2 K)\n        \n        self.dp = {}\n        self.prefix = [0] + list(itertools.accumulate(stones))\n        \n        ret = self.merge(stones, 0, len(stones) - 1, 1, K)\n        \n        return ret\n        \n    def merge(self, stones, start: int, end: int, num_parts: int, K: int):\n        if (start, end, num_parts) in self.dp:\n            return self.dp[(start, end, num_parts)]\n        \n        if end - start + 1 < num_parts:\n            return -1\n        \n        if end - start + 1 == num_parts:\n            return 0\n        \n        window_sum = self.prefix[end + 1] - self.prefix[start] \n        \n        if num_parts == 1:\n            split = self.merge(stones, start, end, K, K)\n            \n            if split == -1:\n                ret = -1\n            else:\n                ret = window_sum + split\n        else:\n            candidates = []\n            \n            for i in range(start, end):\n                left = self.merge(stones, start, i, 1, K)\n                right = self.merge(stones, i + 1, end, num_parts - 1, K)\n                \n                \n                if left >= 0 and right >= 0:\n                    candidates.append(left + right)\n            \n            if candidates:\n                ret = min(candidates)\n            else:\n                ret = -1\n                \n        self.dp[(start, end, num_parts)] = ret\n        return ret\n\n", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        self.dp = {}\n        \n        \n        ret = self.merge(stones, 0, len(stones) - 1, 1, K)\n        \n        return ret\n        \n    def merge(self, stones, start: int, end: int, num_parts: int, K: int):\n        if (start, end, num_parts) in self.dp:\n            return self.dp[(start, end, num_parts)]\n        \n        if end - start + 1 < num_parts:\n            return -1\n        \n        if end - start + 1 == num_parts:\n            return 0\n        \n        window_sum = sum(stones[start:end + 1])\n        \n        if num_parts == 1:\n            split = self.merge(stones, start, end, K, K)\n            \n            if split == -1:\n                ret = -1\n            else:\n                ret = window_sum + split\n        else:\n            candidates = []\n            \n            for i in range(start, end):\n                left = self.merge(stones, start, i, 1, K)\n                right = self.merge(stones, i + 1, end, num_parts - 1, K)\n                \n                \n                if left >= 0 and right >= 0:\n                    candidates.append(left + right)\n            \n            if candidates:\n                ret = min(candidates)\n            else:\n                ret = -1\n                \n        self.dp[(start, end, num_parts)] = ret\n        return ret\n\n", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones) \n        \n        inf = float('inf')\n        prefix = [0] * (n + 1)\n        \n        for i in range(n): \n            prefix[i + 1] = prefix[i] + stones[i]\n            \n        import functools\n        \n        @functools.lru_cache(None) \n        def dp(i, j, m): \n            if i == j: \n                return 0 if m == 1 else inf\n            if m == 1: \n                return dp(i, j, K) + prefix[j + 1] - prefix[i]\n            \n            return min(dp(i, mid, 1) + dp(mid + 1, j, m - 1) for mid in range(i, j))\n        \n        res = dp(0, n - 1, 1)\n        \n        return res if res < inf else -1 ", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        if K > 2 and n % (K - 1) != 1:\n            return -1\n        \n        dp = [[[math.inf] * (K + 1) for i in range(n)] for j in range(n)]\n        for i in range(n):\n            dp[i][i][1] = 0\n            \n        presum = [stones[0]]\n        for i in range(1, n):\n            presum.append(presum[i - 1] + stones[i])\n            \n        def stones_in_range(i, j):\n            return presum[j] - presum[i - 1] if i > 0 else presum[j]\n        \n        for rangelen in range(2, n + 1):\n            for start in range(n + 1 - rangelen):\n                end = start + rangelen - 1\n                for k in range(2, K + 1):\n                    for divide in range(start, end, K - 1):\n                        dp[start][end][k] = min(dp[start][end][k], dp[start][divide][1] + dp[divide + 1][end][k - 1])\n                        print(start, end, k, divide, dp[start][end][k])\n                if dp[start][end][K] < math.inf:\n                    dp[start][end][1] = dp[start][end][K] + stones_in_range(start, end)\n                    \n        return dp[0][n - 1][1]", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        if (n - 1) % (K - 1):\n            return -1\n        \n        s = [0]\n        for num in stones:\n            s.append(s[-1] + num)\n        \n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = float('inf')\n                for m in range(i, j, K - 1):\n                    dp[i][j] = min(dp[i][j], dp[i][m] + dp[m + 1][j] + (0 if (j - i) % (K - 1) else s[j + 1] - s[i]))\n        \n        return -1 if dp[0][-1] == float('inf') else dp[0][-1]\n        \n        \n        @functools.lru_cache(None)\n        def f(i, j):\n            if i == j:\n                return 0\n            ans = float('inf')\n            m = i\n            while m < j:\n                ans = min(ans, f(i, m) + f(m + 1, j) + (0 if (j - i) % (K - 1) else s[j + 1] - s[i]))\n                m += K - 1\n                \n            return ans\n        \n        ans = f(0, n - 1)\n        return -1 if ans == float('inf') else ans", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        if (n-1)%(K-1) != 0:\n            return -1\n        dp = [[0]*n for i in range(n)]\n        sums = [0]*(n+1)\n        for i in range(1, n+1):\n            sums[i] = sums[i-1] + stones[i-1]\n        for l in range(K, n+1):\n            for i in range(n-l+1):\n                j = i+l-1\n                dp[i][j] = float('inf')\n                for t in range(i, j, K-1):\n                    dp[i][j] = min(dp[i][j], dp[i][t]+dp[t+1][j])\n                if (j-i)%(K-1) == 0:\n                    dp[i][j] += sums[j+1] - sums[i]\n        return dp[0][n-1]\n", "class Solution:\n    def mergeStones(self, stones: List[int], K: int) -> int:\n        n = len(stones)\n        if (n - 1) % (K - 1):\n            return -1\n        prefix = [0]*(n+1)\n        for i in range(1, n+1):\n            prefix[i] = prefix[i-1] + stones[i-1]\n        import functools\n        @functools.lru_cache(None)\n        def dp(i, j):\n            if j - i + 1 < K:\n                return 0\n            res = min(dp(i, mid) + dp(mid+1, j) for mid in range(i, j, K-1))\n            if (j - i) % (K - 1) == 0:\n                res += prefix[j + 1] - prefix[i]\n            return res\n        return dp(0, n-1)\n    \n#         n = len(stones)\n#         if (n - 1) % (K - 1): return -1\n#         prefix = [0] * (n + 1)\n#         for i in range(n):\n#             prefix[i + 1] = prefix[i] + stones[i]\n\n#         import functools\n#         @functools.lru_cache(None)\n#         def dp(i, j):\n#             if j - i + 1 < K: return 0\n#             res = min(dp(i, mid) + dp(mid + 1, j) for mid in range(i, j, K - 1))\n#             if (j - i) % (K - 1) == 0:\n#                 res += prefix[j + 1] - prefix[i]\n#             return res\n#         return dp(0, n - 1)\n"]
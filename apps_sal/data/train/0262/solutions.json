["class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        longest_word = max([len(word) for word in words])\n        if len(result) != longest_word and len(result) != longest_word + 1:\n            return False\n        \n        result_indices = []\n        acc = 0\n        all_chars = []\n        front_indices = []\n        for i in range(1, longest_word + 1):\n            for word in words:\n                if i == len(word):\n                    front_indices.append(acc)\n                if i <= len(word):\n                    all_chars.append(word[i * -1])\n                    acc += 1\n            if i == len(result):\n                front_indices.append(acc)\n            result_indices.append(acc)\n            acc += 1\n            all_chars.append(result[i * -1])\n\n        if len(result) > longest_word:\n            result_indices.append(acc)\n            front_indices.append(acc)\n            all_chars.append(result[0])\n            \n        self.words = words\n        self.result = result\n        self.result_indices = result_indices\n        self.all_chars = all_chars\n        self.mappings = {}\n        self.used_chars = set()\n        self.front_indices = front_indices\n        \n        return self.backtrack(0, 0)\n        \n    def backtrack(self, current_i: int, carry: int) -> bool:\n        if current_i == len(self.all_chars):\n            if self.mappings[self.result[0]] == 0:\n                return False\n            return True\n        \n        cur_char = self.all_chars[current_i]\n\n        if current_i in self.result_indices:\n            code, new_carry = self.verify(self.result_indices.index(current_i), carry)\n            if code == 0:\n                return False\n            else:\n                if self.backtrack(current_i + 1, new_carry):\n                    return True\n                \n                if code == 2:\n                    self.used_chars.remove(self.mappings[cur_char])\n                    del self.mappings[cur_char]\n                    \n                return False\n                    \n        if cur_char in self.mappings:\n            if current_i in self.front_indices and self.mappings[cur_char] == 0:\n                return False\n            return self.backtrack(current_i + 1, carry)\n        \n        for i in range(10):\n            if current_i in self.front_indices and i == 0:\n                continue\n            if i not in self.used_chars:\n                self.mappings[cur_char] = i\n                self.used_chars.add(i)\n                \n                if self.backtrack(current_i + 1, carry):\n                    return True\n\n                del self.mappings[cur_char]\n                self.used_chars.remove(i)\n                \n        return False\n            \n    def verify(self, index: int, carry: int) -> (int, int):\n        cur_sum = carry\n            \n        for word in self.words:\n            if index < len(word):\n                cur_sum += self.mappings[word[index * -1 -1]]\n\n        carry = int(cur_sum / 10)\n        cur_sum = cur_sum % 10\n            \n        result_char = self.result[index * -1 - 1]\n        if result_char in self.mappings:\n            if self.mappings[result_char] != cur_sum:\n                return 0, 0\n            else:\n                return 1, carry\n        else:\n            if cur_sum in self.used_chars:\n                return 0, 0\n            self.mappings[result_char] = cur_sum\n            self.used_chars.add(cur_sum)\n            return 2, carry\n        \n\n                \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        max_len = len(result)\n        if max(len(w) for w in words) > max_len:\n            return False\n        level = [[word[-i-1] for word in words if i<len(word)] for i in range(max_len)]\n        level_set = [set([result[-i-1]] + level[i]) for i in range(max_len)]\n        used_digits = set()\n        nonzero_chars = set(word[0] for word in words + [result])\n        assignments = {}\n        def isSAT(eqn_index, carry):\n            if eqn_index >= max_len:\n                return carry == 0\n            remaining_terms = []\n            for t in level_set[eqn_index]:\n                if t not in assignments:\n                    for guess in range(t in nonzero_chars, 10):\n                        if guess in used_digits:\n                            continue\n                        assignments[t] = guess\n                        used_digits.add(guess)\n                        if isSAT(eqn_index, carry):\n                            return True\n                        del assignments[t]\n                        used_digits.remove(guess)\n                    return False\n            \n            s = sum(assignments[c] for c in level[eqn_index]) + carry\n            if s % 10 != assignments[result[-eqn_index-1]]:\n                return False\n            return isSAT(eqn_index +1, s // 10)\n           \n        return isSAT(0, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        words.append(result)\n        M, N = len(words), max(list(map(len, words)))\n        dic = {}\n        rem = [None] * 10\n        lead = set([w[0] for w in words])\n\n        def backtrack(i, j, cur):\n            if j == N:\n                return cur == 0\n            if i == M:\n                return not cur % 10 and backtrack(0, j + 1, cur // 10)\n            if j >= len(words[i]):\n                return backtrack(i + 1, j, cur)\n            t = words[i][~j]\n            sign = 1 if i < M - 1 else -1\n            if t in dic:\n                return backtrack(i + 1, j, cur + dic[t] * sign)\n            else:\n                for k, r in enumerate(rem):\n                    if not r and (k or t not in lead):\n                        dic[t] = k\n                        rem[k] = t\n                        if backtrack(i + 1, j, cur + dic[t] * sign):\n                            return True\n                        del dic[t]\n                        rem[k] = None\n            return False\n\n        return backtrack(0, 0, 0)\n                    \n        \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        max_len = len(result)\n        if max(len(w) for w in words) > max_len:\n            return False\n        level = [[word[-i-1] for word in words if i<len(word)] for i in range(max_len)]\n        level_set = [set([result[-i-1]] + level[i]) for i in range(max_len)]\n        used_digits = set()\n        nonzero_chars = set(word[0] for word in words + [result])\n        assignments = {}\n        def isSAT(eqn_index, carry):\n            if eqn_index >= max_len:\n                return carry == 0\n            for t in level_set[eqn_index]:\n                if t not in assignments:\n                    for guess in range(t in nonzero_chars, 10):\n                        if guess in used_digits:\n                            continue\n                        assignments[t] = guess\n                        used_digits.add(guess)\n                        if isSAT(eqn_index, carry):\n                            return True\n                        del assignments[t]\n                        used_digits.remove(guess)\n                    return False\n            \n            s = sum(assignments[c] for c in level[eqn_index]) + carry\n            if s % 10 != assignments[result[-eqn_index-1]]:\n                return False\n            return isSAT(eqn_index +1, s // 10)\n           \n        return isSAT(0, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        if max([len(w) for w in words]) > len(result):\n            return False\n        lead_letters = set([w[0] for w in words + [result]])\n\n        letters = []\n        for k in range(1, len(result) + 1):\n            for w in words:\n                if len(w) >= k and w[-k] not in [x[0] for x in letters]:\n                    letters.append((w[-k], k))\n            letters.append((result[-k], -k))\n\n        # print(letters)\n\n        letter2num = {}\n        num2letter = ['']*10\n        nums = '0123456789'\n\n        def helper(k):\n            if k == len(letters):\n                return True\n            letter, digit = letters[k][0], letters[k][1]\n            if digit < 0:\n                left = sum([int(''.join([letter2num[ch] for ch in w[digit:]])) for w in words])\n                if left < 10 ** (-digit-1):\n                    return False\n                num = int(str(left)[digit])\n                if letter not in letter2num and not num2letter[num]:\n                    letter2num[letter] = str(num)\n                    num2letter[num] = letter\n                    if helper(k + 1):\n                        return True\n                    letter2num.pop(letter)\n                    num2letter[int(num)] = ''\n                elif num2letter[num] != letter or (letter in letter2num and letter2num[letter] != str(num)):\n                    return False\n                else:\n                    return helper(k + 1)\n\n            else:\n                if letter not in letter2num:\n                    num_range = nums if letter not in lead_letters else nums[1:]\n                    for num in num_range:\n                        if not num2letter[int(num)]:\n                            letter2num[letter] = num\n                            num2letter[int(num)] = letter\n                            if helper(k+1):\n                                return True\n                            letter2num.pop(letter)\n                            num2letter[int(num)] = ''\n                    return False\n                else:\n                    return helper(k + 1)\n\n        return helper(0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        n = len(result)\n        if max(len(w) for w in words) > n:\n            return False\n        \n        level = [[w[-k - 1] for w in words if k < len(w)] for k in range(n)]\n        level_set = [set(level[k]) | {result[-k - 1]} for k in range(n)]\n        leading = set(w[0] for w in words) | {result[0]}\n        val = {k: None for k in set.union(set(result), *(set(w) for w in words))}\n        used = set()\n        \n        def search(k, carry):\n            if k == n:\n                return carry == 0\n            \n            for c in level_set[k]:\n                if val[c] is None:\n                    for v in range(c in leading, 10):\n                        if v not in used:\n                            val[c] = v\n                            used.add(v)\n                            if search(k, carry):\n                                return True\n                            val[c] = None\n                            used.remove(v)\n                    return False\n                \n            s = sum(val[c] for c in level[k]) + carry\n            if s % 10 != val[result[-k - 1]]:\n                return False\n            return search(k + 1, s // 10)\n\n        return search(0, 0)\n\n\n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        max_len = len(result)\n        if max(len(w) for w in words) > max_len:\n            return False\n        use_count = Counter(''.join(words +[result]))\n        level = [[word[-i-1] for word in words if i<len(word)] for i in range(max_len)]\n        level_set = [set([result[-i-1]] + level[i]) for i in range(max_len)]\n        used_digits = set()\n        nonzero_chars = set(word[0] for word in words + [result])\n        assignments = {}\n        def isSAT(eqn_index, carry):\n            if eqn_index >= max_len:\n                return carry == 0\n            remaining_terms = [t for t in level_set[eqn_index] if t not in assignments]\n            if remaining_terms:\n                term_to_guess = max(remaining_terms, key=lambda x:use_count[x])\n                for guess in range(term_to_guess in nonzero_chars, 10):\n                    if guess in used_digits:\n                        continue\n                    assignments[term_to_guess] = guess\n                    used_digits.add(guess)\n                    if isSAT(eqn_index, carry):\n                        return True\n                    del assignments[term_to_guess]\n                    used_digits.remove(guess)\n                return False\n            \n            s = sum(assignments[c] for c in level[eqn_index]) + carry\n            if s % 10 != assignments[result[-eqn_index-1]]:\n                return False\n            return isSAT(eqn_index +1, s // 10)\n           \n        return isSAT(0, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        self.words = words\n        self.result = result\n        self.front_chars = set([word[0] for word in words] + [result[0]])    \n        self.result_indices = []\n        self.all_chars = []\n        \n        new_words = words + [result]\n        while len(new_words) > 0:\n            for i in range(len(new_words)):\n                self.all_chars.append(new_words[i][-1])\n                new_words[i] = new_words[i][:-1]\n            self.result_indices.append(len(self.all_chars) - 1)\n            new_words = [word for word in new_words if len(word) > 0]\n\n        self.mappings = {}\n        self.used_chars = set()\n        \n        return self.backtrack(0, 0)\n        \n    def backtrack(self, current_i: int, carry: int) -> bool:\n        if current_i == len(self.all_chars):\n            return True\n        \n        cur_char = self.all_chars[current_i]\n\n        if current_i in self.result_indices:\n            code, new_carry = self.verify(self.result_indices.index(current_i), carry)\n            if code == 0:\n                return False\n            else:\n                if self.backtrack(current_i + 1, new_carry):\n                    return True\n                \n                if code == 2:\n                    self.used_chars.remove(self.mappings[cur_char])\n                    del self.mappings[cur_char]\n                    \n                return False\n                    \n        if cur_char in self.mappings:\n            return self.backtrack(current_i + 1, carry)\n        \n        for i in range(10):\n            if cur_char in self.front_chars and i == 0:\n                continue\n            if i not in self.used_chars:\n                self.mappings[cur_char] = i\n                self.used_chars.add(i)\n                \n                if self.backtrack(current_i + 1, carry):\n                    return True\n\n                del self.mappings[cur_char]\n                self.used_chars.remove(i)\n                \n        return False\n            \n    def verify(self, index: int, carry: int) -> (int, int):\n        cur_sum = carry\n            \n        for word in self.words:\n            if index < len(word):\n                cur_sum += self.mappings[word[index * -1 -1]]\n\n        carry = int(cur_sum / 10)\n        cur_sum = cur_sum % 10\n            \n        result_char = self.result[index * -1 - 1]\n        if result_char in self.mappings:\n            if self.mappings[result_char] != cur_sum:\n                return 0, 0\n            else:\n                return 1, carry\n        else:\n            if cur_sum in self.used_chars:\n                return 0, 0\n            if result_char in self.front_chars and cur_sum == 0:\n                return 0, 0\n            \n            self.mappings[result_char] = cur_sum\n            self.used_chars.add(cur_sum)\n            return 2, carry\n        \n\n                \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        def backtrack(ch_pos_to_end, num_choices, iter_idx, lhs, rhs):\n            if ch_pos_to_end > len(result):\n                return True\n\n            mul = pow(10, ch_pos_to_end - 1)\n            if iter_idx < len(words):\n                word = words[iter_idx]\n                idx = len(word) - ch_pos_to_end\n                if idx >= 0:\n                    if word[idx] not in num_mappings:\n                        for n in num_choices:\n                            if n == 0 and word[idx] == word[0]:\n                                continue\n                            num_mappings[word[idx]] = n\n                            if backtrack(ch_pos_to_end, num_choices - {n}, iter_idx + 1,\n                                         lhs + num_mappings[word[idx]] * mul,\n                                         rhs):\n                                return True\n                            del num_mappings[word[idx]]\n                    else:\n                        return backtrack(ch_pos_to_end, num_choices, iter_idx + 1, lhs + num_mappings[word[idx]] * mul, rhs)\n                else:\n                    return backtrack(ch_pos_to_end, num_choices, iter_idx + 1, lhs, rhs)\n            elif iter_idx == len(words):\n                idx = len(result) - ch_pos_to_end\n                if result[idx] not in num_mappings:\n                    for n in num_choices:\n                        if n == 0 and result[idx] == result[0]:\n                            continue\n                        new_rhs = rhs + n * mul\n                        if not str(lhs).endswith(str(new_rhs)):\n                            continue\n                        num_mappings[result[idx]] = n\n                        if backtrack(ch_pos_to_end + 1, num_choices - {n}, 0, lhs, new_rhs):\n                            return True\n                        del num_mappings[result[idx]]\n                else:\n                    added = num_mappings[result[idx]]\n                    if not str(lhs).endswith(str(rhs + added * mul)):\n                        return False\n                    return backtrack(ch_pos_to_end + 1, num_choices, 0, lhs, rhs + added * mul)\n            return False\n\n        max_len_words = max([len(w) for w in words])\n        if max_len_words > len(result):\n            return False\n        num_mappings = {}\n        nums = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}\n        return backtrack(1, nums, 0, 0, 0)", "class Solution(object):\n    def isSolvable(self, words, result):\n        words.append(result)\n        R, C = len(words), max(map(len, words))\n\n        assigned = {}\n        assigned_inv = [None] * 10\n\n        def search(column, row, bal):\n            if column >= C:\n                return bal == 0\n            if row == R:\n                return bal % 10 == 0 and search(column + 1, 0, bal // 10)\n\n            word = words[row]\n            if column >= len(word):\n                return search(column, row + 1, bal)\n\n            letter = word[~column]\n            sign = 1 if row < R - 1 else -1\n            if letter in assigned:\n                if (assigned[letter] or len(word) == 1 or column != len(word) - 1):\n                    return search(column, row + 1, bal + sign * assigned[letter])\n                return False\n            else:\n                for d, ad in enumerate(assigned_inv):\n                    if ad is None and (d or len(word) == 1 or column != len(word) - 1):\n                        assigned_inv[d] = letter\n                        assigned[letter] = d\n                        if search(column, row + 1, bal + sign * d):\n                            return True\n                        assigned_inv[d] = None\n                        del assigned[letter]\n\n            return False\n\n        return search(0, 0, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        # backtracking?\n        # awice ++\n        words.append(result)\n        R, C = len(words), max(list(map(len, words)))\n        used = {}\n        used_d = [None] * 10\n        \n        def backtrack(row, col, bal):\n            if col >= C:\n                return bal == 0 and all(used[w[0]] != 0 for w in words)\n            if row == R:\n                return bal % 10 == 0 and backtrack(0, col + 1, bal // 10)\n            word = words[row]\n            if col >= len(word):\n                return backtrack(row + 1, col, bal)\n            \n            letter = word[-1 - col]\n            sign = 1 if row < R - 1 else -1\n            if letter in used:\n                return backtrack(row + 1, col, bal + sign * used[letter])\n            else:\n                for d, ad in enumerate(used_d):\n                    if ad is None and (d or col != len(word) - 1):\n                        # start backtracking\n                        used[letter] = d\n                        used_d[d] = letter\n                        if backtrack(row + 1, col, bal + sign * d):\n                            return True\n                        # restore to previous state\n                        used_d[d] = None\n                        del used[letter]\n                        \n            return False\n        \n        return backtrack(0, 0, 0)\n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        max_len = len(result)\n        if max(len(w) for w in words) > max_len:\n            return False\n        equations = [[result[-i-1]] + [word[-i-1] for word in words if i<len(word)] for i in range(max_len)]\n        used_digits = set()\n        nonzero_chars = set(word[0] for word in words + [result])\n        assignments = {}\n        print(equations)\n        def isSAT(eqn_index, carry):\n            if eqn_index >= max_len:\n                return carry == 0\n            remaining_terms = []\n            for t in equations[eqn_index]:\n                if t not in assignments:\n                    for guess in range(t in nonzero_chars, 10):\n                        if guess in used_digits:\n                            continue\n                        assignments[t] = guess\n                        used_digits.add(guess)\n                        if isSAT(eqn_index, carry):\n                            return True\n                        del assignments[t]\n                        used_digits.remove(guess)\n                    return False\n            \n            s = sum(assignments[c] for c in equations[eqn_index][1:]) + carry\n            if s % 10 != assignments[equations[eqn_index][0]]:\n                return False\n            return isSAT(eqn_index +1, s // 10)\n           \n        return isSAT(0, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        max_len = len(result)\n        if max(len(w) for w in words) > max_len:\n            return False\n        equations = [[result[-i-1]] + [word[-i-1] for word in words if i<len(word)] for i in range(max_len)]\n        used_digits = set()\n        nonzero_chars = set(word[0] for word in words + [result])\n        assignments = {}\n        def isSAT(eqn_index, carry):\n            if eqn_index >= max_len:\n                return carry == 0\n            remaining_terms = []\n            for t in equations[eqn_index]:\n                if t not in assignments:\n                    for guess in range(t in nonzero_chars, 10):\n                        if guess in used_digits:\n                            continue\n                        assignments[t] = guess\n                        used_digits.add(guess)\n                        if isSAT(eqn_index, carry):\n                            return True\n                        del assignments[t]\n                        used_digits.remove(guess)\n                    return False\n            \n            s = sum(assignments[c] for c in equations[eqn_index][1:]) + carry\n            if s % 10 != assignments[equations[eqn_index][0]]:\n                return False\n            return isSAT(eqn_index +1, s // 10)\n           \n        return isSAT(0, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        words.append(result)\n        assigned = {}\n        assigned_inv = [None] * 10\n        self.r,self.c=len(words),max(list(map(len, words)))\n        \n        def dfs(column,row,bal):\n            if column>=self.c:\n                return bal==0 and all(assigned[i[0]]!=0 for i in words)\n            if row==self.r:\n                return bal%10==0 and dfs(column+1,0,bal//10)\n            \n            word=words[row]\n            if column>=len(word):\n                return dfs(column,row+1,bal)\n            letter=word[~column]\n            sign= 1 if row<self.r-1 else -1\n            if letter in assigned:\n                return dfs(column,row+1,bal+sign*assigned[letter])\n            else:\n                for num,c in enumerate(assigned_inv):\n                    if c is None and (num or column!=len(word)-1):\n                        assigned[letter]=num\n                        assigned_inv[num]=letter\n                        if dfs(column,row+1,bal+sign*num):\n                            return True\n                        assigned_inv[num]=None\n                        del assigned[letter]\n            return False\n            \n        return dfs(0,0,0)\n                        \n            \n        \n        \n        \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        words.append(result)\n        assigned = {}\n        assigned_inv = [None] * 10\n        self.r,self.c=len(words),max(list(map(len, words)))\n        \n        def dfs(column,row,bal):\n            if column==self.c:\n                return bal==0 and all(assigned[i[0]]!=0 for i in words)\n            if row==self.r:\n                return bal%10==0 and dfs(column+1,0,bal//10)\n            \n            word=words[row]\n            if column>=len(word):\n                return dfs(column,row+1,bal)\n            letter=word[~column]\n            sign= 1 if row<self.r-1 else -1\n            if letter in assigned:\n                return dfs(column,row+1,bal+sign*assigned[letter])\n            else:\n                for num,c in enumerate(assigned_inv):\n                    if c is None and (num or column!=len(word)-1):\n                        assigned[letter]=num\n                        assigned_inv[num]=letter\n                        if dfs(column,row+1,bal+sign*num):\n                            return True\n                        assigned_inv[num]=None\n                        del assigned[letter]\n            return False\n            \n        return dfs(0,0,0)\n                        \n            \n        \n        \n        \n", "class Solution:\n\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        def solve(i, j, carry):\n            # The current column assignment is over, so check for validity\n            if j == len(words): \n                csum = carry\n                for k in range(len(words)):\n                    csum += 0 if i >= len(words[k]) else assign[words[k][i]] \n                # We have come to column i, but the result itself is not long enough.    \n                if i >= len(result): return False \n                if result[i] in assign:\n                    return csum % 10 == assign[result[i]] and solve(i+1, 0, csum // 10) # i th char of result  is already assigned, so check if its valid and go to next column i+1 and start from word 0\n                else:\n                    # If the current digit can't be assigned to ith char of result or if its 0 and we are looking at first char of a word: then return False\n                    if (csum % 10) in assign.values() or (csum % 10 == 0 and i == len(result) - 1):\n                        return False\n                    assign[result[i]] = csum % 10\n                    ret = solve(i+1, 0, csum // 10)\n                    del assign[result[i]]\n                    return ret\n                \n            if i == len(result): \n                return i >= max(len(w) for w in words)  and carry == 0 and all(assign[w[len(w)-1]] != 0 for w in words + [result])\n            # Handle length of word less than the column we are looking at OR the ith column char of the jth word is already assigned previously\n            if i >= len(words[j]) or words[j][i] in assign: return solve(i, j+1, carry)     \n            for val in range(10):\n                if val == 0 and i == len(words[j]) - 1: continue  # Handle not to assign 0 for first letter of a word \n                if val not in assign.values():\n                    assign[words[j][i]] = val\n                    ret = solve(i, j+1, carry)\n                    if ret: return True\n                    del assign[words[j][i]]   \n            return False\n        \n        result = result[::-1]\n        words = [w[::-1] for w in words]\n        assign = dict()\n        return solve(0, 0, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        n = len(words)\n        mapper = {}\n        maxlen = 0\n        for w in words:\n            maxlen = max(maxlen, len(w))\n            for c in w:\n                mapper[c] = -1\n        if len(result) < maxlen or len(result) - maxlen > 1:\n            return False\n        for c in result:\n            mapper[c] = -1\n        used = [0] * 10\n        def solve(i, j, s):\n            if j == n:\n                l = len(result) - i\n                if l < 0:\n                    if s != 0:\n                        return False\n                    for w in words:\n                        if mapper[w[0]] == 0:\n                            return False\n                    if mapper[result[0]] == 0:\n                        return False\n                    return True\n                c, s = divmod(s, 10)\n                if mapper[result[l]] >= 0:\n                    if mapper[result[l]] == s:\n                        return solve(i + 1, 0, c)\n                    return False\n                if used[s]:\n                    return False\n                mapper[result[l]] = s\n                used[s] = 1\n                res = solve(i + 1, 0, c)\n                mapper[result[l]] = -1\n                used[s] = 0\n                return res\n            w = words[j]\n            l = len(w) - i\n            if l < 0:\n                return solve(i, j + 1, s)\n            if mapper[w[l]] >= 0:\n                return solve(i, j + 1, s + mapper[w[l]])\n            for k in range(10):\n                if used[k]:\n                    continue\n                used[k] = 1\n                mapper[w[l]] = k\n                if solve(i, j + 1, s + k):\n                    return True\n                used[k] = 0\n                mapper[w[l]] = -1\n            return False\n        return solve(1, 0, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        max_len = len(result)\n        if max(len(w) for w in words) > max_len:\n            return False\n        words = [word.rjust(max_len, '#') for word in words]\n        result = result.rjust(max_len, '#')\n        equations = list(zip(result, *words))\n        used_digits = set()\n        nonzero_chars = set(equations[0])\n        assignments = {'#':0}\n        def isSAT(eqn_index, carry):\n            if eqn_index<0:\n                return carry == 0\n            remaining_terms = []\n            for t in equations[eqn_index]:\n                if t not in assignments:\n                    for guess in range(t in nonzero_chars, 10):\n                        if guess in used_digits:\n                            continue\n                        assignments[t] = guess\n                        used_digits.add(guess)\n                        if isSAT(eqn_index, carry):\n                            return True\n                        del assignments[t]\n                        used_digits.remove(guess)\n                    return False\n            \n            s = sum(assignments[c] for c in equations[eqn_index][1:]) + carry\n            if s % 10 != assignments[equations[eqn_index][0]]:\n                return False\n            else:\n                return isSAT(eqn_index - 1, s // 10)\n           \n        return isSAT(max_len-1, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        max_len = len(result)\n        if max(len(w) for w in words) > max_len:\n            return False\n        words = [word.rjust(max_len, '#') for word in words]\n        result = result.rjust(max_len, '#')\n        equations = list(zip(result, *words))\n        used_digits = set()\n        nonzero_chars = set(equations[0])\n        assignments = {'#':0}\n        def isSAT(eqn_index, carry):\n            if eqn_index<0:\n                return carry == 0\n            remaining_terms = []\n            for t in equations[eqn_index]:\n                if t not in assignments:\n                    for guess in range(10):\n                        if guess in used_digits:\n                            continue\n                        if guess == 0 and t in nonzero_chars:\n                            continue\n                        assignments[t] = guess\n                        used_digits.add(guess)\n                        if isSAT(eqn_index, carry):\n                            return True\n                        del assignments[t]\n                        used_digits.remove(guess)\n                    return False\n            \n            s = sum(assignments[c] for c in equations[eqn_index][1:]) + carry\n            if s % 10 != assignments[equations[eqn_index][0]]:\n                return False\n            else:\n                return isSAT(eqn_index - 1, s // 10)\n           \n        return isSAT(max_len-1, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        allwords = words + [result]\n        n = max(list(map(len, allwords)))\n        firstc = set(word[0] for word in allwords)\n        if len(result) < n : return False\n        def dfs(charidx, wordidx, carry, visited, char2digit):\n            if charidx == n: return carry == 0\n            if wordidx == len(allwords):\n                tot = sum(char2digit[word[~charidx]] if charidx < len(word) else 0 for word in words) + carry\n                if (tot % 10) == char2digit[result[~charidx]]:\n                    return dfs(charidx + 1, 0, tot // 10, visited, char2digit)\n                else:\n                    return False\n            if  wordidx < len(words) and charidx >= len(words[wordidx]):\n                return dfs(charidx, wordidx+1, carry, visited, char2digit)\n            \n            c = allwords[wordidx][~charidx]\n            first = 1 if c in firstc else 0\n            if c in char2digit:\n                return dfs(charidx, wordidx+1, carry, visited, char2digit)\n            else:\n                for d in range(first, 10):\n                    if d not in visited:\n                        visited.add(d)\n                        char2digit[c] = d\n                        if dfs(charidx, wordidx+1, carry, visited, char2digit): return True\n                        del char2digit[c]\n                        visited.remove(d)\n            return False\n      \n        return dfs(0, 0, 0, set(), {})\n                    \n             \n                \n            \n            \n", "from itertools import permutations, zip_longest\nfrom collections import OrderedDict\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        \n        self.matched_chars = list(zip_longest(*[result[::-1]]+[w[::-1] for w in words]))        \n        self.first_chars = set([result[0]]+[w[0] for w in words])\n        self.chars = []            \n        self.free_vars = []\n        self.idx = {}\n        observed = set()\n        for chars in self.matched_chars:\n            free_vars = []\n            for c in chars:\n                if c is None:\n                    continue\n                if c not in observed:\n                    self.chars.append(c)\n                    free_vars.append(c)\n                    observed.add(c)\n                    self.idx[c]=len(self.idx)\n            self.free_vars.append(free_vars)\n        #print(self.free_vars)\n        #print(self.chars)    \n\n        return self.dfs(0,(),0)\n        \n    def dfs(self, i, used_digits, carry):\n        #pemutations\n        if i >= len(self.matched_chars):\n            #print('R:',used_digits)\n            return not max(used_digits[self.idx[f]]==0 for f in self.first_chars)\n        free_vars = self.free_vars[i]\n        perms = permutations(set(range(10))-set(list(used_digits)),len(free_vars))\n        for p in perms:\n            values = tuple(list(used_digits)+list(p))\n            #check for contradiction\n            nxt_carry = self.contradict(values,i,carry)\n            if nxt_carry<0:\n                continue\n            if self.dfs(i+1,values,nxt_carry):\n                return True\n        return False\n    \n    def contradict(self, values, i, carry):\n        r, *i = self.matched_chars[i]\n        s = sum(values[self.idx[d]] for d in i if d)+carry\n        if (s-values[self.idx[r]])%10:\n            return -1\n        return s//10\n        \n    \n        \n        \n    \n        \n    \n                            \n                    \n        \n        \n        \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        allWords = words + [result]\n        firstChars = set(word[0] for word in allWords if len(word) > 1)\n        n = max(list(map(len, allWords)))\n        if len(result) < n: return False\n        def dfs(charIdx, wordIdx, carry, visited, char2digit):\n            if charIdx == n: return carry == 0\n            if wordIdx == len(allWords):\n                # time to check the final status for the current digit\n                sums = sum(char2digit[word[~charIdx]] if charIdx < len(word) else 0 for word in words) + carry\n                if sums % 10 == char2digit[result[-charIdx - 1]]:\n                    return dfs(charIdx + 1, 0, sums // 10, visited, char2digit)\n                else:\n                    return False # prune. To support this, using -charIdx - 1 to visit from right/low to left/high\n            # current word length is too short to check, move to check next word\n            if wordIdx < len(words) and charIdx >= len(words[wordIdx]):\n                return dfs(charIdx, wordIdx + 1, carry, visited, char2digit)\n\n            c = allWords[wordIdx][-charIdx-1]\n            if c in char2digit:\n                # if current word's current char already map to a digit, continue with next word\n                return dfs(charIdx, wordIdx + 1, carry, visited, char2digit)\n            else:\n                # otherwise try all possibilities via dfs\n                firstDigit = 1 if c in firstChars else 0\n                for digit in range(firstDigit, 10):\n                    if digit not in visited:\n                        visited.add(digit)\n                        char2digit[c] = digit\n                        if dfs(charIdx, wordIdx + 1, carry, visited, char2digit): return True\n                        del char2digit[c]\n                        visited.remove(digit) # restore visited and char2digit by discarding the copy\n                return False\n        return dfs(0, 0, 0, set(), {})\n            \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        n = len(words)\n        mapper = {}\n        maxlen = 0\n        for w in words:\n            maxlen = max(maxlen, len(w))\n            for c in w:\n                mapper[c] = -1\n        if len(result) < maxlen or len(result) - maxlen > 1:\n            return False\n        for c in result:\n            mapper[c] = -1\n        used = [0] * 10\n        def solve(i, j, s):\n            if j == n:\n                l = len(result) - i\n                if l < 0:\n                    if s != 0:\n                        return False\n                    if any([mapper[w[0]] == 0 for w in words]):\n                        return False\n                    if mapper[result[0]] == 0:\n                        return False\n                    return True\n                c, s = divmod(s, 10)\n                if mapper[result[l]] >= 0:\n                    if mapper[result[l]] == s:\n                        return solve(i + 1, 0, c)\n                    return False\n                if used[s]:\n                    return False\n                mapper[result[l]] = s\n                used[s] = 1\n                res = solve(i + 1, 0, c)\n                mapper[result[l]] = -1\n                used[s] = 0\n                return res\n            w = words[j]\n            l = len(w) - i\n            if l < 0:\n                return solve(i, j + 1, s)\n            if mapper[w[l]] >= 0:\n                return solve(i, j + 1, s + mapper[w[l]])\n            for k in range(10):\n                if used[k]:\n                    continue\n                used[k] = 1\n                mapper[w[l]] = k\n                if solve(i, j + 1, s + k):\n                    return True\n                used[k] = 0\n                mapper[w[l]] = -1\n            return False\n        return solve(1, 0, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        allwords = words + [result]\n        n = max(list(map(len, allwords)))\n        firstc = set(word[0] for word in allwords)\n        if len(result) < n : return False\n        def dfs(charidx, wordidx, carry, visited, char2digit):\n            if charidx == n: return carry == 0\n            if wordidx == len(allwords):\n                tot = sum(char2digit[word[~charidx]] if charidx < len(word) else 0 for word in words) + carry\n                if (tot % 10) == char2digit[result[~charidx]]:\n                    return dfs(charidx + 1, 0, tot // 10, visited, char2digit)\n                return False\n            if  wordidx < len(words) and charidx >= len(words[wordidx]):\n                return dfs(charidx, wordidx+1, carry, visited, char2digit)\n            \n            c = allwords[wordidx][~charidx]\n            first = 1 if c in firstc else 0\n            if c in char2digit:\n                return dfs(charidx, wordidx+1, carry, visited, char2digit)\n            for d in range(first, 10):\n                if d not in visited:\n                    visited.add(d)\n                    char2digit[c] = d\n                    if dfs(charidx, wordidx+1, carry, visited, char2digit): return True\n                    del char2digit[c]\n                    visited.remove(d)\n            return False\n      \n        return dfs(0, 0, 0, set(), {})\n                    \n             \n                \n            \n            \n", "from itertools import permutations, zip_longest\nfrom collections import OrderedDict\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        \n        self.matched_chars = list(zip_longest(*[result[::-1]]+[w[::-1] for w in words]))        \n        self.first_chars = set([result[0]]+[w[0] for w in words])\n        self.chars = []            \n        self.free_vars = []\n        self.idx = {}\n        observed = set()\n        for chars in self.matched_chars:\n            free_vars = []\n            for c in chars:\n                if c is None:\n                    continue\n                if c not in observed:\n                    self.chars.append(c)\n                    free_vars.append(c)\n                    observed.add(c)\n                    self.idx[c]=len(self.idx)\n            self.free_vars.append(free_vars)\n        #print(self.free_vars)\n        #print(self.chars)    \n\n        return self.dfs(0,(),0)\n        \n    #@lru_cache(maxsize=None)\n    def dfs(self, i, used_digits, carry):\n        #pemutations\n        if i >= len(self.matched_chars):\n            #print('R:',used_digits)\n            return not max(used_digits[self.idx[f]]==0 for f in self.first_chars)\n        free_vars = self.free_vars[i]\n        perms = permutations(set(range(10))-set(list(used_digits)),len(free_vars))\n        for p in perms:\n            values = tuple(list(used_digits)+list(p))\n            #check for contradiction\n            nxt_carry = self.contradict(values,i,carry)\n            if nxt_carry<0:\n                continue\n            if self.dfs(i+1,values,nxt_carry):\n                return True\n        return False\n    \n    def contradict(self, values, i, carry):\n        r, *i = self.matched_chars[i]\n        s = sum(values[self.idx[d]] for d in i if d)+carry\n        if (s-values[self.idx[r]])%10:\n            return -1\n        return s//10\n        \n    \n        \n        \n    \n        \n    \n                            \n                    \n        \n        \n        \n", "# 1307. Verbal Arithmetic Puzzle\n# version 2\n\ndef make_zip (lists):\n    i = 0\n    maxlength = max (len (l) for l in lists)\n    ans = []\n    while i < maxlength:\n        ans.append ([l[i] for l in lists if i < len (l)])\n        i += 1\n    return ans\n\ndef make_order (words, result):\n    order = []\n    formulas = {}\n    for i in range (len (result)):\n        for ch in [*(words[i]), result[i]]:\n            if ch not in order:\n                order.append (ch)\n        order.append (f'c{i+1}')\n        lhs = words[i]\n        rhs = result[i]\n        if i > 0:\n            lhs.append (f'c{i}')\n        excess = f'c{i+1}'\n        formulas[excess] = (lhs, rhs, excess)\n    # order determined\n    return order, formulas\n\ndef find_free (repl, ch, nonzero):\n    start = 1 if ch in nonzero else 0\n    choices = set (range (start, 10))\n    for x, y in repl.items ():\n        if y in choices: choices.remove (y)\n    yield from choices\n\ndef find_value (n, repl, crepl):\n    return repl[n] if n in repl else crepl[n]\n\ndef find_excess (lhs, rhs, repl, crepl):\n    return sum (find_value (x, repl, crepl) for x in lhs) - find_value (rhs, repl, crepl)\n\ndef walk_solutions (puzzle, index, repl, crepl):\n    (words, result, order, formulas, nonzero) = puzzle\n\n    if index == len (order):\n        # check top digit zero\n        last_ch = order[-1]\n        if crepl[last_ch] != 0:\n            return\n        yield repl\n    else:\n        ch = order[index]\n        if len (ch) == 1:\n            for digit in find_free (repl, ch, nonzero):\n                repl[ch] = digit\n                yield from walk_solutions (puzzle, index + 1, repl, crepl)\n                del repl[ch]\n        else:\n            formula = formulas[ch]\n            (lhs, rhs, _) = formula\n            excess = find_excess (lhs, rhs, repl, crepl)\n            if excess >= 0 and excess % 10 == 0:\n                # successful\n                crepl[ch] = excess // 10\n                yield from walk_solutions (puzzle, index + 1, repl, crepl)\n                del crepl[ch]\n\ndef is_solvable (words, result):\n    n = len (words)\n    maxword = 10 ** max (len (w) for w in words) - 1\n    minresult = 10 ** (len (result) - 1)\n    if n * maxword < minresult:\n        return False\n\n    if not all (len (w) <= len (result) for w in words):\n        return False\n\n    nonzero = {m[0] for m in [*words, result] if len (m) > 1}\n\n    result = [ch for ch in result[::-1]]\n    words = make_zip ([w[::-1] for w in words])\n    while len (words) < len (result):\n        words.append ([])\n\n    order, formulas = make_order (words, result)\n\n    puzzle = (words, result, order, formulas, nonzero)\n\n    return any (walk_solutions (puzzle, 0, {}, {}))\n\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        return is_solvable(words, result)", "from itertools import permutations, zip_longest\nfrom collections import OrderedDict\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        \n        self.matched_chars = list(zip_longest(*[result[::-1]]+[w[::-1] for w in words]))        \n        self.first_chars = set([result[0]]+[w[0] for w in words])\n        self.chars = []            \n        self.free_vars = []\n        self.idx = {}\n        observed = set()\n        for chars in self.matched_chars:\n            free_vars = []\n            for c in chars:\n                if c is None:\n                    continue\n                if c not in observed:\n                    self.chars.append(c)\n                    free_vars.append(c)\n                    observed.add(c)\n                    self.idx[c]=len(self.idx)\n            self.free_vars.append(free_vars)\n        #print(self.free_vars)\n        #print(self.chars)    \n\n        return self.dfs(0,(),0)\n        \n    @lru_cache(maxsize=None)\n    def dfs(self, i, used_digits, carry):\n        #pemutations\n        if i >= len(self.matched_chars):\n            #print('R:',used_digits)\n            return not max(used_digits[self.idx[f]]==0 for f in self.first_chars)\n        free_vars = self.free_vars[i]\n        perms = permutations(set(range(10))-set(list(used_digits)),len(free_vars))\n        for p in perms:\n            values = tuple(list(used_digits)+list(p))\n            #check for contradiction\n            nxt_carry = self.contradict(values,i,carry)\n            if nxt_carry<0:\n                continue\n            if self.dfs(i+1,values,nxt_carry):\n                return True\n        return False\n    \n    def contradict(self, values, i, carry):\n        r, *i = self.matched_chars[i]\n        s = sum(values[self.idx[d]] for d in i if d)+carry\n        if (s-values[self.idx[r]])%10:\n            return -1\n        return s//10\n        \n    \n        \n        \n    \n        \n    \n                            \n                    \n        \n        \n        \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        allWords = words + [result]\n        firstChars = set(word[0] for word in allWords if len(word) > 1)\n        n = max(list(map(len, allWords)))\n        if len(result) < n: return False\n        def dfs(charIdx, wordIdx, carry, visited, char2digit):\n            if charIdx == n: return carry == 0\n            if wordIdx == len(allWords):\n                # time to check the final status for the current digit\n                sums = sum(char2digit[word[~charIdx]] if charIdx < len(word) else 0 for word in words) + carry\n                if sums % 10 == char2digit[result[-charIdx - 1]]:\n                    return dfs(charIdx + 1, 0, sums // 10, visited, char2digit)\n                else:\n                    return False # prune. To support this, using -charIdx - 1 to visit from right/low to left/high\n            # current word length is too short to check, move to check next word\n            if wordIdx < len(words) and charIdx >= len(words[wordIdx]):\n                return dfs(charIdx, wordIdx + 1, carry, visited, char2digit)\n\n            c = allWords[wordIdx][-charIdx-1]\n            if c in char2digit:\n                # if current word's current char already map to a digit, continue with next word\n                return dfs(charIdx, wordIdx + 1, carry, visited, char2digit)\n            else:\n                # otherwise try all possibilities via dfs\n                firstDigit = 1 if c in firstChars else 0\n                for digit in range(firstDigit, 10):\n                    if digit not in visited:\n                        visited.add(digit)\n                        char2digit[c] = digit\n                        if dfs(charIdx, wordIdx + 1, carry, visited, char2digit.copy()): return True\n                        visited.remove(digit) # restore visited and char2digit by discarding the copy\n                return False\n        return dfs(0, 0, 0, set(), {})\n            \n", "from itertools import permutations, zip_longest\nfrom collections import OrderedDict\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        \n        self.matched_chars = list(zip_longest(*[result[::-1]]+[w[::-1] for w in words]))        \n        self.first_chars = set([result[0]]+[w[0] for w in words])\n        self.chars = []            \n        self.free_vars = []\n        self.idx = {}\n        observed = set()\n        for chars in self.matched_chars:\n            free_vars = []\n            for c in chars:\n                if c is None:\n                    continue\n                if c not in observed:\n                    self.chars.append(c)\n                    free_vars.append(c)\n                    observed.add(c)\n                    self.idx[c]=len(self.idx)\n            self.free_vars.append(free_vars)\n        print((self.free_vars))\n        print((self.chars))    \n\n        return self.dfs(0,(),0)\n        \n    @lru_cache(maxsize=None)\n    def dfs(self, i, used_digits, carry):\n        #pemutations\n        if i >= len(self.matched_chars):\n            print(('R:',used_digits))\n            return not max(used_digits[self.idx[f]]==0 for f in self.first_chars)\n        free_vars = self.free_vars[i]\n        perms = permutations(set(range(10))-set(list(used_digits)),len(free_vars))\n        for p in perms:\n            values = tuple(list(used_digits)+list(p))\n            #check for contradiction\n            nxt_carry = self.contradict(values,i,carry)\n            if nxt_carry<0:\n                continue\n            if self.dfs(i+1,values,nxt_carry):\n                return True\n        return False\n    \n    def contradict(self, values, i, carry):\n        r, *i = self.matched_chars[i]\n        s = sum(values[self.idx[d]] for d in i if d)+carry\n        if (s-values[self.idx[r]])%10:\n            return -1\n        return s//10\n        \n    \n        \n        \n    \n        \n    \n                            \n                    \n        \n        \n        \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        allWords = words + [result]\n        firstChars = set(word[0] for word in allWords if len(word) > 1)\n        n = max(list(map(len, allWords)))\n        if len(result) < n: return False\n        def dfs(charIdx, wordIdx, carry, visited, char2digit):\n            if charIdx == n: return carry == 0\n            if wordIdx == len(allWords):\n                # time to check the final status for the current digit\n                sums = sum(char2digit[word[-charIdx - 1]] if charIdx < len(word) else 0 for word in words) + carry\n                if sums % 10 == char2digit[result[-charIdx - 1]]:\n                    return dfs(charIdx + 1, 0, sums // 10, visited, char2digit)\n                else:\n                    return False # prune. To support this, using -charIdx - 1 to visit from right/low to left/high\n            # current word length is too short to check, move to check next word\n            if wordIdx < len(words) and charIdx >= len(words[wordIdx]):\n                return dfs(charIdx, wordIdx + 1, carry, visited, char2digit)\n\n            c = allWords[wordIdx][-charIdx-1]\n            if c in char2digit:\n                # if current word's current char already map to a digit, continue with next word\n                return dfs(charIdx, wordIdx + 1, carry, visited, char2digit)\n            else:\n                # otherwise try all possibilities via dfs\n                firstDigit = 1 if c in firstChars else 0\n                for digit in range(firstDigit, 10):\n                    if digit not in visited:\n                        visited.add(digit)\n                        char2digit[c] = digit\n                        if dfs(charIdx, wordIdx + 1, carry, visited, char2digit.copy()): return True\n                        visited.remove(digit) # restore visited and char2digit by discarding the copy\n                return False\n        return dfs(0, 0, 0, set(), {})\n            \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        n = len(words)\n        mapper = {}\n        maxlen = 0\n        for w in words:\n            maxlen = max(maxlen, len(w))\n            for c in w:\n                mapper[c] = -1\n        if len(result) < maxlen or len(result) - maxlen > 1:\n            return False\n        for c in result:\n            mapper[c] = -1\n        used = [0] * 10\n        def solve(i, j, s):\n            if j == n:\n                l = len(result) - i\n                if l < 0:\n                    if s != 0:\n                        return False\n                    if any(mapper[w[0]] == 0 for w in words):\n                        return False\n                    if mapper[result[0]] == 0:\n                        return False\n                    return True\n                c, s = divmod(s, 10)\n                if mapper[result[l]] >= 0:\n                    if mapper[result[l]] == s:\n                        return solve(i + 1, 0, c)\n                    return False\n                if used[s]:\n                    return False\n                mapper[result[l]] = s\n                used[s] = 1\n                res = solve(i + 1, 0, c)\n                mapper[result[l]] = -1\n                used[s] = 0\n                return res\n            w = words[j]\n            l = len(w) - i\n            if l < 0:\n                return solve(i, j + 1, s)\n            if mapper[w[l]] >= 0:\n                return solve(i, j + 1, s + mapper[w[l]])\n            for k in range(10):\n                if used[k]:\n                    continue\n                used[k] = 1\n                mapper[w[l]] = k\n                if solve(i, j + 1, s + k):\n                    return True\n                used[k] = 0\n                mapper[w[l]] = -1\n            return False\n        return solve(1, 0, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        allwords = words + [result]\n        n = max(list(map(len, allwords)))\n        firstc = set(word[0] for word in allwords)\n        def dfs(charidx, wordidx, carry, visited, char2digit):\n            if charidx == n: return carry == 0\n            if wordidx == len(allwords):\n                tot = sum(char2digit[word[~charidx]] if charidx < len(word) else 0 for word in words) + carry\n                if tot % 10 == char2digit[result[~charidx]]:\n                    return dfs(charidx+1, 0, tot//10, visited, char2digit)\n                return False\n            if wordidx < len(words) and charidx >= len(words[wordidx]):\n                return dfs(charidx, wordidx+1, carry, visited, char2digit)\n            c = allwords[wordidx][~charidx]\n            if c in char2digit:\n                return dfs(charidx, wordidx+1, carry, visited, char2digit)\n            first = 1 if c in firstc else 0\n            for d in range(first, 10):\n                if d not in visited:\n                    visited.add(d)\n                    char2digit[c] = d\n                    if dfs(charidx, wordidx+1, carry, visited, char2digit): return True\n                    del char2digit[c]\n                    visited.remove(d)\n            return False\n                    \n                \n                    \n                    \n        return dfs(0, 0, 0, set(), {})\n                    \n             \n                \n            \n            \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        allWords = words + [result]\n        firstChars = set(word[0] for word in allWords if len(word) > 1)\n        n = max(map(len, allWords))\n\n        if len(result) < n:\n            return False\n\n        def dfs(charIdx, wordIdx, carry, visited, char2digit):\n            if charIdx == n:\n                return carry == 0\n\n            if wordIdx == len(allWords):\n                # time to check the final status for the current digit\n                sums = sum(char2digit[word[-charIdx - 1]] if charIdx < len(word) else 0 for word in words) + carry\n                if sums % 10 == char2digit[result[-charIdx - 1]]:\n                    return dfs(charIdx + 1, 0, sums // 10, visited, char2digit)\n                else:\n                    return False # prune. To support this, using -charIdx - 1 to visit from right/low to left/high\n\n            # current word length is too short to check, move to check next word\n            if wordIdx < len(words) and charIdx >= len(words[wordIdx]):\n                return dfs(charIdx, wordIdx + 1, carry, visited, char2digit)\n\n            # \u4ece\u540e\u5411\u524d\u679a\u4e3e\uff0c\u8fd9\u6837\u53ef\u4ee5\u65b9\u4fbf\u68c0\u6d4b\u8fdb\u800c\u65e9\u70b9\u526a\u679d\n            c = allWords[wordIdx][-charIdx-1]\n            if c in char2digit:\n                # if current word's current char already map to a digit, continue with next word\n                return dfs(charIdx, wordIdx + 1, carry, visited, char2digit)\n            else:\n                # otherwise try all possibilities via dfs\n                firstDigit = 1 if c in firstChars else 0\n                for digit in range(firstDigit, 10):\n                    if digit not in visited:\n                        visited.add(digit)\n                        char2digit[c] = digit\n                        if dfs(charIdx, wordIdx + 1, carry, visited, char2digit.copy()):\n                            return True\n                        visited.remove(digit) # restore visited and char2digit by discarding the copy\n                return False\n        return dfs(0, 0, 0, set(), {})", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        start = set()\n        for word in words + [result]:\n            if len(word) > 1:\n                start.add(word[0])\n\n\n        n = max(list(map(len, words + [result])))\n        if len(result) < n:\n            return False\n\n        def dfs(idx, i, carry, visited, mp):\n            if idx == n:\n                return carry == 0\n            if i == len(words) + 1:\n                sums = sum(mp[word[-idx - 1]] if idx < len(word) else 0 for word in words) + carry\n                if sums % 10 == mp[result[-idx - 1]]:\n                    carry = sums // 10\n                    return dfs(idx + 1, 0, carry, visited, mp)\n                return False\n\n            if (i < len(words) and idx >= len(words[i])):\n                return dfs(idx, i + 1, carry, visited, mp)\n            tmp = words + [result]\n            ch = tmp[i][-idx-1]\n            if ch in mp:\n                return dfs(idx, i + 1, carry, visited, mp)\n            begin = 0\n            if ch in start:\n                begin = 1\n            for x in range(begin, 10):\n                if x not in visited:\n                    visited.add(x)\n                    mp[ch] = x\n                    if dfs(idx, i + 1, carry, visited, mp.copy()):\n                        return True\n                    visited.remove(x)\n            return False\n\n        return dfs(0, 0, 0, set(), {})\n            \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        allwords = words + [result]\n        n = max(list(map(len, allwords)))\n        firstc = set(word[0] for word in allwords)\n        def dfs(charidx, wordidx, carry, visited, char2digit):\n            if charidx == n: return carry == 0\n            if wordidx == len(allwords):\n                tot = sum(char2digit[word[~charidx]] if charidx < len(word) else 0 for word in words) + carry\n                if tot % 10 == char2digit[result[~charidx]]:\n                    return dfs(charidx+1, 0, tot//10, visited, char2digit)\n                return False\n            if wordidx < len(words) and charidx >= len(words[wordidx]):\n                return dfs(charidx, wordidx+1, carry, visited, char2digit)\n            c = allwords[wordidx][~charidx]\n            first = 1 if c in firstc else 0\n            if c in char2digit:\n                return dfs(charidx, wordidx+1, carry, visited, char2digit)\n            for d in range(first, 10):\n                if d not in visited:\n                    visited.add(d)\n                    char2digit[c] = d\n                    if dfs(charidx, wordidx+1, carry, visited, char2digit): return True\n                    del char2digit[c]\n                    visited.remove(d)\n            return False\n                    \n                \n                    \n                    \n        return dfs(0, 0, 0, set(), {})\n                    \n             \n                \n            \n            \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        ## https://leetcode.com/problems/verbal-arithmetic-puzzle/discuss/463921/python-backtracking-with-pruning-tricks\n        ## from low digit position to high digit position, stop searching once (left side sum)%10 did not equal right side at current digit\n        \n        ## mark all initial characters, because not leading zeros are allowed. \n        start = set()\n        for word in words + [result]:\n            if len(word) > 1: ## note: a single 0 is allowed\n                start.add(word[0])\n\n        ## find the maximum length between all words and result\n        n = max(list(map(len, words + [result])))\n        if len(result) < n: ## if the length of result is shorter than other words, it's  not possible\n            return False\n        \n        ## helper function:\n        ## idx: the index currently processing (of words and result)\n        ## i: i-th word in words; when i == len(words) + 1: we have processed all words + result at index \n        ## carry: the carry computed by summing all previous indexes of words\n        def dfs(idx, i, carry, visited, mp):\n            ## base case: when we reach the highest digit (most significant) position\n            ## we should have carry == 0, otherwise the sums are not equal\n            if idx == n: \n                return carry == 0\n            ## when i == len(words) + 1: we have processed all words + result at index\n            ## the specific index of word is word[-idx - 1]\n            ## we check the sum added by carry\n            ## if the sum does not match the digit at result[-idx - 1]\n            ## return False\n            if i == len(words) + 1:\n                sums = sum(mp[word[-idx - 1]] if idx < len(word) else 0 for word in words) + carry\n                if sums % 10 == mp[result[-idx - 1]]:\n                    carry = sums // 10 ## update carry to the next index\n                    ## recursive call to the next index and start from 0-th word\n                    return dfs(idx + 1, 0, carry, visited, mp)\n                return False \n            ## if current word (i-th) has shorter length than index, \n            ## skip it, it will be counted as 0 for this digit\n            if (i < len(words) and idx >= len(words[i])):\n                return dfs(idx, i + 1, carry, visited, mp)\n            \n            \n            tmp = words + [result]\n            ch = tmp[i][-idx-1] ## current character\n            if ch in mp: ## if this character has been assigned a value\n                return dfs(idx, i + 1, carry, visited, mp)\n            \n            ## backtrack: try every possible digit\n            begin = 0\n            if ch in start:\n                begin = 1 ## if it is an initial character of some word\n            for x in range(begin, 10):\n                if x not in visited:\n                    visited.add(x)\n                    mp[ch] = x\n                    if dfs(idx, i + 1, carry, visited, mp.copy()):\n                        return True\n                    visited.remove(x)\n            return False\n        return dfs(0, 0, 0, set(), {})\n            \n        \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        n = len(words)\n        mapper = {}\n        maxlen = 0\n        for w in words:\n            maxlen = max(maxlen, len(w))\n            for c in w:\n                mapper[c] = -1\n        if len(result) < maxlen or len(result) - maxlen > 1:\n            return False\n        for c in result:\n            mapper[c] = -1\n        used = [0] * 10\n        def solve(i, j, s):\n            if j == n or i == len(result) + 1:\n                l = len(result) - i\n                if l < 0:\n                    if s != 0:\n                        return False\n                    if any(mapper[w[0]] == 0 for w in words):\n                        return False\n                    if mapper[result[0]] == 0:\n                        return False\n                    return True\n                c, s = divmod(s, 10)\n                if mapper[result[l]] >= 0:\n                    if mapper[result[l]] == s:\n                        return solve(i + 1, 0, c)\n                    return False\n                if used[s]:\n                    return False\n                mapper[result[l]] = s\n                used[s] = 1\n                res = solve(i + 1, 0, c)\n                mapper[result[l]] = -1\n                used[s] = 0\n                return res\n            w = words[j]\n            l = len(w) - i\n            if l < 0:\n                return solve(i, j + 1, s)\n            if mapper[w[l]] >= 0:\n                return solve(i, j + 1, s + mapper[w[l]])\n            for k in range(10):\n                if used[k]:\n                    continue\n                used[k] = 1\n                mapper[w[l]] = k\n                if solve(i, j + 1, s + k):\n                    return True\n                used[k] = 0\n                mapper[w[l]] = -1\n            return False\n        return solve(1, 0, 0)", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        start = set()\n        for word in words + [result]:\n            if len(word) > 1:\n                start.add(word[0])\n\n\n        n = max(map(len, words + [result]))\n        if len(result) < n:\n            return False\n\n        def dfs(idx, i, carry, visited, mp):\n            if idx == n:\n                return carry == 0\n            if i == len(words) + 1:\n                sums = sum(mp[word[-idx - 1]] if idx < len(word) else 0 for word in words) + carry\n                if sums % 10 == mp[result[-idx - 1]]:\n                    carry = sums // 10\n                    return dfs(idx + 1, 0, carry, visited, mp)\n                return False\n\n            if (i < len(words) and idx >= len(words[i])):\n                return dfs(idx, i + 1, carry, visited, mp)\n            tmp = words + [result]\n            ch = tmp[i][-idx-1]\n            if ch in mp:\n                return dfs(idx, i + 1, carry, visited, mp)\n            begin = 0\n            if ch in start:\n                begin = 1\n            for x in range(begin, 10):\n                if x not in visited:\n                    visited.add(x)\n                    mp[ch] = x\n                    if dfs(idx, i + 1, carry, visited, mp.copy()):\n                        return True\n                    visited.remove(x)\n            return False\n\n        return dfs(0, 0, 0, set(), {})", "\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        start = set()\n        for word in words + [result]:\n            if len(word) > 1:\n                start.add(word[0])\n\n\n        n = max(map(len, words + [result]))\n        if len(result) < n:\n            return False\n\n        def dfs(idx, i, carry, visited, mp):\n            if idx == n:\n                return carry == 0\n            if i == len(words) + 1:\n                sums = sum(mp[word[-idx - 1]] if idx < len(word) else 0 for word in words) + carry\n                if sums % 10 == mp[result[-idx - 1]]:\n                    carry = sums // 10\n                    return dfs(idx + 1, 0, carry, visited, mp)\n                return False\n\n            if (i < len(words) and idx >= len(words[i])):\n                return dfs(idx, i + 1, carry, visited, mp)\n            tmp = words + [result]\n            ch = tmp[i][-idx-1]\n            if ch in mp:\n                return dfs(idx, i + 1, carry, visited, mp)\n            begin = 0\n            if ch in start:\n                begin = 1\n            for x in range(begin, 10):\n                if x not in visited:\n                    visited.add(x)\n                    mp[ch] = x\n                    if dfs(idx, i + 1, carry, visited, mp.copy()):\n                        return True\n                    visited.remove(x)\n            return False\n\n        return dfs(0, 0, 0, set(), {})", "from itertools import permutations\n\nclass Solution:\n    digitMap = {}\n    wordsRev = []\n    resultRev = []\n    limit = 0\n    \n    def findSolution(self, n, carry = 0):\n        if n == self.limit:\n            # Check leading zero policy\n            leadingDigitChars = [w[len(w) - 1] for w in self.wordsRev]\n            leadingDigitChars.append(self.resultRev[len(self.resultRev) - 1])\n            leadingDigits = [self.digitMap[c] for c in leadingDigitChars]\n            return 0 not in leadingDigits\n\n        availableDigits = [n for n in range(0, 10) if n not in self.digitMap.values()]\n        digitChars = [w[n] for w in self.wordsRev if n < len(w)]\n        resultChar = self.resultRev[n]\n\n        knownDigitChars = list(filter(lambda x: x in self.digitMap, digitChars))\n        unknownDigitChars = [w for w in digitChars if w not in knownDigitChars]\n\n        digits = []\n        resultDigit = -1\n        if len(knownDigitChars) > 0:\n            digits = [self.digitMap[k] for k in knownDigitChars]\n        if resultChar in self.digitMap:\n            resultDigit = self.digitMap[resultChar]\n\n        for d in permutations(availableDigits, len(unknownDigitChars)):\n            s = sum(digits) + sum(d) + carry\n            c = int(s / 10)\n            s %= 10\n\n            if resultDigit >= 0 and s == resultDigit:\n                for i, v in enumerate(d):\n                    self.digitMap[unknownDigitChars[i]] = v\n                if self.findSolution(n+1, c):\n                    return True\n                else:\n                    # Fallback\n                    for i, v in enumerate(d):\n                        if unknownDigitChars[i] in self.digitMap:\n                            del self.digitMap[unknownDigitChars[i]]\n            elif resultDigit < 0 and ((resultChar not in unknownDigitChars and s not in d) or (resultChar in unknownDigitChars and s in d)) and s in availableDigits:\n                for i, v in enumerate(d):\n                    self.digitMap[unknownDigitChars[i]] = v\n                if resultChar not in unknownDigitChars:\n                    self.digitMap[resultChar] = s\n                elif s != self.digitMap[resultChar]:\n                    for i, v in enumerate(d):\n                        if unknownDigitChars[i] in self.digitMap:\n                            del self.digitMap[unknownDigitChars[i]]\n                    continue\n\n                if self.findSolution(n+1, c):\n                    return True\n                else:\n                    # Fallback\n                    for i, v in enumerate(d):\n                        if unknownDigitChars[i] in self.digitMap:\n                            del self.digitMap[unknownDigitChars[i]]\n                    if resultChar in self.digitMap:\n                        del self.digitMap[resultChar]\n        return False\n            \n    def isSolvable(self, words: List[str], result: str) -> bool:\n        self.digitMap = {}\n        self.wordsRev = [w[::-1] for w in words]\n        self.resultRev = result[::-1]\n\n        wordMax = max([len(w) for w in words])\n        if wordMax > len(result):\n            return False\n\n        self.limit = max(wordMax, len(result))\n\n        return self.findSolution(0, 0)", "from collections import defaultdict\nclass Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        def search(i: int, j: int, carry: int, used: int, ls: list, mp: defaultdict, non_zeros: set) -> bool:\n            if j == len(ls[-1]):\n                return carry == 0\n            if i == len(ls):\n                total = sum([mp[ls[r][j]] if j < len(ls[r]) else 0 for r in range(len(ls) - 1)]) + carry\n                exp_total = mp[ls[-1][j]]\n                if (total % 10) != exp_total:\n                    return False\n                return search(0, j + 1, total // 10, used, ls, mp, non_zeros)\n            if j >= len(ls[i]) or ls[i][j] in mp:\n                return search(i + 1, j, carry, used, ls, mp, non_zeros)\n            start = 1 if ls[i][j] in non_zeros else 0\n            for d in range(start, 10):\n                if (1 << d) & used:\n                    continue\n                mp[ls[i][j]] = d\n                if search(i + 1, j, carry, used | (1 << d), ls, mp, non_zeros):\n                    mp.pop(ls[i][j])\n                    return True\n                mp.pop(ls[i][j])\n            return False\n        \n        non_zeros = set([w[0] for w in words] + [result[0]])\n        ls = [w[::-1] for w in words] + [result[::-1]]\n        return search(0, 0, 0, 0, ls, defaultdict(int), non_zeros)", "class Solution:\n    \n    def isSolvable(self, words: List[str], result: str) -> bool:\n        \n        allWords = words  + [result]\n        firstChars = set(word[0] for word in allWords)\n        maxWordLength = max(list(map(len, allWords)))\n        \n        if len(result) < maxWordLength: return False\n        \n        def dfs(charIdx, wordIdx, carry, visited, char2Digit):\n            # check if the final sum is equal\n            if charIdx == maxWordLength:\n                return carry == 0\n            \n            # if we have assigned digits to all chars at the current index\n            # check if the assigned values work\n            if wordIdx == len(allWords):\n                sums = sum(char2Digit[word[-charIdx-1]] if charIdx < len(word) else 0 for word in words)\n                sums += carry\n                if sums % 10 == char2Digit[result[-charIdx-1]]:\n                    return dfs(charIdx + 1, 0, sums // 10, visited, char2Digit)\n                else:\n                    return False\n            \n            # if the current char index is longer than the current word, move to the next word\n            currWord = allWords[-wordIdx-1]\n            if charIdx >= len(currWord):\n                return dfs(charIdx, wordIdx+1, carry, visited, char2Digit)\n            \n            # if we already have a digit assignment for the char, skip it\n            currChar = currWord[-charIdx-1]\n            if currChar in char2Digit:\n                return dfs(charIdx, wordIdx+1, carry, visited, char2Digit)\n            \n            # otherwise try every possible digit\n            else:\n                startDigit = 1 if currChar in firstChars else 0\n                for digit in range(startDigit, 10):\n                    # skip previously assigned digits\n                    if digit in list(char2Digit.values()): continue\n                    # try the assignment\n                    visited.add(digit)\n                    char2Digit[currChar] = digit\n                    if dfs(charIdx, wordIdx, carry, visited, char2Digit.copy()):\n                        return True\n                    visited.remove(digit)\n                return False\n        \n        return dfs(0, 0, 0, set(), {})\n                \n            \n            \n        \n", "class Solution:\n    def isSolvable(self, words: List[str], result: str) -> bool:\n        self.n = len(result)\n        self.levels = []\n        self.alldigit = {}\n        self.allch = []\n        self.result = result\n        self.nonzero = set()\n        for w in words:\n            self.nonzero.add(w[0])\n        self.nonzero.add(result[0])\n #       print(\\\"nonzero\\\", self.nonzero)\n        for r in range(len(result)):\n            l = []\n            for w in words:\n                if r < len(w):\n                    l.append(w[len(w) - r - 1])\n                \n            l.append(result[len(result) - 1 - r])\n            self.levels.append(l)\n#        print(\\\"levels\\\", self.levels)\n        self.occupy = set()\n        self.checkdigit = {} # num of words to digit\n        \n        if len(self.levels[-1]) == 1:\n            self.alldigit[self.levels[-1][0]] = 1\n            self.occupy.add(1)\n        \n        for l in range(len(self.levels)):\n            newch = set(self.levels[l]) - set(self.allch)\n            self.allch.extend(newch)\n            self.checkdigit[len(self.allch)] = l + 1\n#        print(\\\"checkdigit\\\", self.checkdigit)\n#        print(\\\"allch\\\", self.allch)\n        if self.tryone(0, len(self.allch)):\n#            print(self.alldigit)\n            return True\n        else:\n#            print(self.alldigit)\n            return False\n        \n    def tryone(self, level, maxl):\n        flag = False\n        if maxl == level:\n            if self.check(self.checkdigit[level]):\n#                print(\\\"final level\\\", self.alldigit)\n                return True\n            else:\n                return False\n        if level in self.checkdigit:\n            if not self.check(self.checkdigit[level]):\n                return False\n            else:\n                pass\n#                if 'T' in self.alldigit and self.alldigit['T'] == 9 and level > 7:\n#                    flag = True\n#                    print(\\\"level:\\\", level, self.alldigit)\n        \n        if self.allch[level] in self.alldigit:\n            if self.tryone(level + 1, maxl):\n                return True\n            else:\n                return False\n            \n        for i in range(10):\n            if i not in self.occupy:\n                if i != 0 or self.allch[level] not in self.nonzero:\n#                    if flag:\n#                        print(\\\"level 8:\\\", level, i, self.allch[level])\n                    self.occupy.add(i)\n                    self.alldigit[self.allch[level]] = i\n                    if self.tryone(level + 1, maxl):\n                        return True\n                    del self.alldigit[self.allch[level]]\n                    self.occupy.remove(i)\n        return False\n        \n        \n    def check(self, level):\n#        flag = False\n#        if level > 5 and self.alldigit['I'] == 1 and self.alldigit['T'] >= 5:\n#            flag = True\n#            print(self.alldigit)\n#        if self.alldigit['Y'] > 1 and self.alldigit['D'] > 6 and self.alldigit['E'] > 4:\n#            flag = True\n#            print(\\\"check level\\\", level, self.alldigit)\n        plus = 0\n#        if level == 5 and self.alldigit['F'] == 1 and self.alldigit['U'] == 9:\n#            flag = True\n#            print(\\\"digit:\\\", level, self.alldigit)\n        for i in range(level):\n            levelsum = 0\n            for j in range(len(self.levels[i]) - 1):\n                levelsum += self.alldigit[self.levels[i][j]]\n#            if flag:\n#                print(\\\"level, levelsum, plus, result\\\", level, levelsum, plus, self.alldigit[self.levels[i][-1]])\n            if (levelsum + plus) % 10 != self.alldigit[self.levels[i][-1]]:\n#                if flag:\n#                    print(\\\"False\\\")\n                return False\n            else:\n                plus = int((levelsum + plus)/10)\n#                if flag:\n#                    print(\\\"plus\\\", plus)\n#        if flag:\n#            print(\\\"True\\\")\n        return True\n"]
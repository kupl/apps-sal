["counter = -1\r\ndef flattree(node):\r\n    nonlocal counter\r\n    if visited[node]==1:\r\n        return\r\n    else:\r\n        visited[node]=1\r\n        counter += 1\r\n        i_c[node] = counter\r\n\r\n        flat_tree[counter] = swt[node]\r\n\r\n        for i in graph[node]:\r\n            if visited[i]==0:\r\n                flattree(i)\r\n        counter += 1\r\n        o_c[node] = counter\r\n        flat_tree[counter] = -swt[node]\r\n    return\r\n\r\n\r\ndef getsum(BITTree, i):\r\n    s = 0  # initialize result\r\n    i = i + 1\r\n    while i > 0:\r\n        s += BITTree[i]\r\n        i -= i & (-i)\r\n    return s\r\n\r\ndef upd(BITTree, n, i, v):\r\n    i += 1\r\n    while i <= n:\r\n        BITTree[i] += v\r\n        i += i & (-i)\r\n\r\ndef construct(arr, n):\r\n    BITTree = [0] * (n + 1)\r\n    for i in range(n):\r\n        upd(BITTree, n, i, arr[i])\r\n    return BITTree\r\n\r\nfrom collections import defaultdict\r\nn = int(input())\r\nswt = list(map(int, input().split()))\r\ngraph = defaultdict(list)\r\n\r\nfor i in range(n-1):\r\n    n1, n2 = list(map(int, input().split()))\r\n    graph[n1-1].append(n2-1)\r\n    graph[n2-1].append(n1-1)\r\n\r\nflat_tree = [0]*(2*n+1)\r\ni_c = [0]*n\r\no_c = [0]*n\r\nvisited = [0]*n\r\nflattree(0)\r\n\r\ntre = construct(flat_tree, 2*n)\r\n\r\nq = int(input())\r\nfor i in range(q):\r\n    query = list(map(int, input().split()))\r\n    if query[0] == 1:\r\n        node = query[1] - 1\r\n        answer = getsum(tre, i_c[node])\r\n        print(answer)\r\n    else:\r\n        node = query[1]-1\r\n        upd(flat_tree, (2*n), i_c[node], query[2])\r\n        upd(flat_tree, (2*n), o_c[node], -query[2])\r\n", "counter = -1\ndef flattree(node):\n    nonlocal counter\n    if visited[node]==1:\n        return\n    else:\n        visited[node]=1\n        counter += 1\n        in_counter[node] = counter\n\n        flat_tree[counter] = sweetness[node]\n\n        for i in graph[node]:\n            if visited[i]==0:\n                flattree(i)\n        counter += 1\n        out_counter[node] = counter\n        flat_tree[counter] = -sweetness[node]\n    return\n\n\ndef getsum(BITTree, i):\n    s = 0  # initialize result\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & (-i)\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & (-i)\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\nfrom collections import defaultdict\nn = int(input())\nsweetness = list(map(int, input().split()))\ngraph = defaultdict(list)\n\nfor i in range(n-1):\n    n1, n2 = list(map(int, input().split()))\n    graph[n1-1].append(n2-1)\n    graph[n2-1].append(n1-1)\n\nflat_tree = [0]*(2*n+1)\nin_counter = [0]*n\nout_counter = [0]*n\nvisited = [0]*n\nflattree(0)\n# print(flat_tree)\n# print(in_counter)\n# print(out_counter)\nfenwicktree = construct(flat_tree, 2*n)\n\nq = int(input())\nfor i in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        node = query[1] - 1\n        answer = getsum(fenwicktree, in_counter[node])\n        print(answer)\n    else:\n        node = query[1]-1\n        updatebit(flat_tree, (2*n), in_counter[node], query[2])\n        updatebit(flat_tree, (2*n), out_counter[node], -query[2])\n"]
["import heapq\nn,m,a,b=map(int,input().split())\ngraph={i:[] for i in range(n)}\nfor i in range(m):\n    u,v,w=map(int,input().split())\n    graph[u-1].append((v-1,w))\n    graph[v-1].append((u-1,w))\ncomponents=[-1]*n\ncomp=-1\nfor i in range(n):\n    if components[i]==-1:\n        comp+=1\n        components[i]=comp\n        prev=[]\n        layer=[i]\n        while layer!=[]:\n            newlayer=[]\n            for guy in layer:\n                for guy1 in graph[guy]:\n                    if guy1[1]==a and components[guy1[0]]==-1:\n                        newlayer.append(guy1[0])\n                        components[guy1[0]]=comp\n            prev=layer[:]\n            layer=newlayer[:]\nuseless=[]\nfor guy in graph:\n    for neigh in graph[guy]:\n        if components[guy]==components[neigh[0]] and neigh[1]==b:\n            useless.append((guy,neigh))\nfor guy in useless:\n    graph[guy[0]].remove(guy[1])\ncounts=[0]*(comp+1)\nfor i in range(n):\n    counts[components[i]]+=1\nbad=[]\nfor i in range(comp+1):\n    if counts[i]<=3:\n        bad.append(i)\n        for j in range(n):\n            if components[j]==i:\n                components[j]=-1\nfor guy in bad[::-1]:\n    for i in range(n):\n        if components[i]>guy:\n            components[i]-=1\ncomp-=len(bad)\ncomp+=1\ndists=[[float(\"inf\") for i in range(2**comp)] for j in range(n)]\ndists[0][0]=0\npq=[]\nheapq.heappush(pq,[0,0,0])\nremaining=n\nvisited=[0]*n\nwhile len(pq)>0 and remaining>0:\n    dist,vert,mask=heapq.heappop(pq)\n    if visited[vert]==0:\n        visited[vert]=1\n        remaining-=1\n    for neigh in graph[vert]:\n        if neigh[1]==b:\n            if components[vert]==components[neigh[0]] and components[vert]!=-1:\n                continue\n            if components[neigh[0]]!=-1:\n                if mask & (2**components[neigh[0]])>0:\n                    continue\n            if components[vert]!=-1:\n                maskn=mask+2**(components[vert])\n            else:\n                maskn=mask\n        else:\n            maskn=mask\n        if dist+neigh[1]<dists[neigh[0]][maskn]:\n            dists[neigh[0]][maskn]=dist+neigh[1]\n            heapq.heappush(pq,[dist+neigh[1],neigh[0],maskn])\noptimal=[str(min(dists[i])) for i in range(n)]\nprint(\" \".join(optimal))"]
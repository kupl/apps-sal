["def solution(args):\n    out = []\n    beg = end = args[0]\n    \n    for n in args[1:] + [\"\"]:        \n        if n != end + 1:\n            if end == beg:\n                out.append( str(beg) )\n            elif end == beg + 1:\n                out.extend( [str(beg), str(end)] )\n            else:\n                out.append( str(beg) + \"-\" + str(end) )\n            beg = n\n        end = n\n    \n    return \",\".join(out)", "def solution(arr):\n    ranges = []\n    a = b = arr[0]\n    for n in arr[1:] + [None]:\n        if n != b+1:\n            ranges.append(str(a) if a == b else \"{}{}{}\".format(a, \",\" if a+1 == b else \"-\", b))\n            a = n\n        b = n\n    return \",\".join(ranges)\n", "def solution(args):\n    result = \"\"\n    i = 0\n    while i<len(args):\n        val = args[i]\n        while i+1<len(args) and args[i]+1==args[i+1]:\n            i+=1\n        if val == args[i]:\n            result += \",%s\"%val\n        elif val+1 == args[i]:\n            result += \",%s,%s\"%(val, args[i])\n        else:\n            result += \",%s-%s\"%(val, args[i])\n        i+=1\n    return result.lstrip(\",\")", "from itertools import groupby\ndef solution(args):\n    grps = ([v[1] for v in g] for _,g in groupby(enumerate(args), lambda p: p[1]-p[0]))\n    return ','.join('{}{}{}'.format(g[0],'-'if len(g)>2 else',',g[-1])\n        if len(g)>1 else str(g[0]) for g in grps)", "from itertools import groupby\n\nclass Conseq:\n    def __init__(self):\n        self.value = None\n        self.key = 0\n    def __call__(self, value):\n        if self.value is None or (value != self.value + 1):\n            self.key += 1\n        self.value = value\n        return self.key\n\ndef serial(it):\n    first = last = next(it)\n    for last in it:\n        pass\n    if first == last:\n        yield str(first)\n    elif first + 1 == last:\n        yield str(first)\n        yield str(last)\n    else:\n        yield '{}-{}'.format(first, last)\n\ndef solution(args):\n    return ','.join(r for _, grp in groupby(args, key=Conseq()) for r in serial(grp))", "\"\"\" noob solution, explained for noobs :) \"\"\"\n\ndef printable(arr):\n    return (','.join(str(x) for x in arr) if len(arr) < 3  # one or two consecutive integers : comma separated\n            else f'{arr[0]}-{arr[-1]}')                    # more : dash separated first and last integer\n\ndef solution(args):\n    chunk, ret = [], []                                    # instantiate variables\n\n    for i in args:                                         # for each integer\n        if not len(chunk) or i == chunk[-1] + 1:           #     if first or consecutive\n            chunk.append(i)                                #         add to current chunk\n        else:                                              #     else, it's a gap\n            ret.append(printable(chunk))                   #         save current chunk\n            chunk = [i]                                    #         and restart a new one\n\n    ret.append(printable(chunk))                           # do not forget last chunk !\n\n    return ','.join(ret)                                   # return comma separated chunks", "from itertools import groupby\ndef solution(args):\n    d=''\n    fun = lambda x: x[1] - x[0]\n    for k, g in groupby(enumerate(args), fun):\n        c=[b for a,b in g]\n        if len(c)==1:\n            d=d+'%d,'%c[0]\n        elif len(c)==2:\n            d=d+'%d,%d,'%(c[0],c[-1])\n        else:\n            d=d+'%d-%d,'%(c[0],c[-1])\n    return (d[:-1])", "def solution(args):\n    \n    temp, segments = list(), list()\n    \n    while args:\n        temp.append(args.pop(0))\n        \n        if len(args) != 0 and temp[-1] == args[0] - 1:\n            continue\n        \n        if len(temp) <= 2:\n            segments += temp\n        else:\n            segments.append(f'{temp[0]}-{temp[-1]}')\n            \n        temp = []\n    \n    return ','.join(str(s) for s in segments)", "from typing import List, Tuple\n\n\ndef solution(args: List[int]) -> str:\n    res: str = \"\"\n    length: int = len(args)\n    idx: int = 0\n\n    while idx < length:\n        if isRange(args, idx):\n            r, inc = showRange(args, idx)\n            res += r\n            idx += inc\n        else:\n            r = showInt(args, idx)  # handles separator\n            res += r\n            idx += 1\n    return res\n\n\ndef isRange(rng: List[int], idx: int) -> bool:\n    # a range spans at least 3 integers\n    if len(rng)-3 < idx:\n        return False\n\n    n: int = rng[idx]\n    nn: int = rng[idx+1]\n    nnn: int = rng[idx+2]\n    if n+1 == nn and nn+1 == nnn:\n        return True\n\n    return False\n\n\ndef showRange(rng: List[int], idx: int) -> Tuple[str, int]:\n    # determine range\n    # determine if range spans until the end (for separator!)\n    curr: int = idx\n    length: int = len(rng)\n    while rng[curr]+1 == rng[curr+1]:\n        curr += 1\n        if (curr+1 == length):\n            break\n\n    res: str = str(rng[idx]) + \"-\" + str(rng[curr])\n    dist: int = curr - idx + 1\n    assert(dist >= 3)  # implied by the algorithm\n    if not atEnd(rng, curr):\n        res += \",\"\n\n    return (res, dist)\n\n\ndef showInt(rng: List[int], idx: int) -> str:\n    res: str = str(rng[idx])\n    if atEnd(rng, idx):\n        return res\n    else:\n        return res + \",\"\n\n\ndef atEnd(lst: List, idx: int) -> bool:\n    return len(lst)-1 == idx"]
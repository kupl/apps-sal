["# cook your dish here\nn,m=map(int,input().split())\nL=[]\nfor i in range(n):\n    s=input()\n    L.append(s)\n\ncost=[]\nh2=[0]*(m+1)\ncost.append(h2)\nfor i in range(n):\n    h=[0]\n    for j in range(m):\n        if(L[i][j]=='0' and (i+j)%2!=0):\n            h.append(1)\n        elif(L[i][j]=='1' and (i+j)%2==0):\n            h.append(1)\n        else:\n            h.append(0)\n    cost.append(h)\n\npre=[]\nh2=[0]*(m+1)\npre.append(h2)\nfor i in range(1,n+1):\n    h=[0]\n    c=0\n    for j in range(1,m+1):\n        c+=cost[i][j]\n        c2=c\n        if(i>0):\n            c2+=pre[i-1][j]\n        h.append(c2)\n    pre.append(h)\n\nbs=[0]*((m*n)+10)\n\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        for k in range(1,min(m,n)+1):\n            if(i-k>=0 and j-k>=0):\n                c=pre[i][j]-pre[i-k][j]-pre[i][j-k]+pre[i-k][j-k]\n                c=min(c,(k*k)-c)\n                bs[c]=max(bs[c],k)\n\nmx=bs[0]\nfor i in range(1,len(bs)):\n    mx=max(mx,bs[i])\n    bs[i]=mx\n\nQ=int(input())\nq=[int(x) for x in input().split()]\nfor i in range(0,len(q)):\n    qr=min(m*n,q[i])\n    print(bs[qr])\n\n\n", "n,m=map(int,input().split())\r\nL=[]\r\nfor i in range(n):\r\n    s=input()\r\n    L.append(s)\r\n\r\ncost=[]\r\nh2=[0]*(m+1)\r\ncost.append(h2)\r\nfor i in range(n):\r\n    h=[0]\r\n    for j in range(m):\r\n        if(L[i][j]=='0' and (i+j)%2!=0):\r\n            h.append(1)\r\n        elif(L[i][j]=='1' and (i+j)%2==0):\r\n            h.append(1)\r\n        else:\r\n            h.append(0)\r\n    cost.append(h)\r\n\r\npre=[]\r\nh2=[0]*(m+1)\r\npre.append(h2)\r\nfor i in range(1,n+1):\r\n    h=[0]\r\n    c=0\r\n    for j in range(1,m+1):\r\n        c+=cost[i][j]\r\n        c2=c\r\n        if(i>0):\r\n            c2+=pre[i-1][j]\r\n        h.append(c2)\r\n    pre.append(h)\r\n\r\nbs=[0]*((m*n)+10)\r\n\r\nfor i in range(1,n+1):\r\n    for j in range(1,m+1):\r\n        for k in range(1,min(m,n)+1):\r\n            if(i-k>=0 and j-k>=0):\r\n                c=pre[i][j]-pre[i-k][j]-pre[i][j-k]+pre[i-k][j-k]\r\n                c=min(c,(k*k)-c)\r\n                bs[c]=max(bs[c],k)\r\n\r\nmx=bs[0]\r\nfor i in range(1,len(bs)):\r\n    mx=max(mx,bs[i])\r\n    bs[i]=mx\r\n\r\nQ=int(input())\r\nq=[int(x) for x in input().split()]\r\nfor i in range(0,len(q)):\r\n    qr=min(m*n,q[i])\r\n    print(bs[qr])\r\n\r\n\r\n", "n,m=map(int,input().split())\r\nchess=[]\r\nfor _ in range(n):\r\n    chess.append([int(x) for x in list(input())])\r\nchessO=[]\r\nchessL=[]\r\nfixO=[]\r\nfixL=[]\r\nfor _ in range(n):\r\n    p=[0]*m\r\n    fixL.append(p)\r\n    q=[0]*m\r\n    fixO.append(q)\r\n    tm=[0]*m\r\n    chessO.append(tm)\r\n    to=[0]*m\r\n    chessL.append(to)\r\n\r\nfor i in range(n):\r\n    for j in range(m):\r\n        chessO[i][j]=((i+j)%2)^chess[i][j]\r\n        chessL[i][j]=((i+j+1)%2)^chess[i][j]\r\n        fixO[i][j]=chessO[i][j]\r\n        fixL[i][j]=chessL[i][j]\r\n\r\nfor i in range(n):\r\n    for j in range(1,m):\r\n        fixO[i][j]=fixO[i][j-1]+chessO[i][j]\r\n        fixL[i][j]=fixL[i][j-1]+chessL[i][j]\r\n\r\nans=[-1]*min(m,n)\r\nfor i in range(n):\r\n    for j in range(m):\r\n        for k in range(min(n-i,m-j)):\r\n            errorO,errorL=0,0\r\n            for l in range(i,i+k+1):\r\n                errorO+=fixO[l][j+k]-fixO[l][j]+chessO[l][j]\r\n                errorL+=fixL[l][j+k]-fixL[l][j]+chessL[l][j]\r\n            if ans[k]==-1 or ans[k]>min(errorO,errorL): ans[k]=min(errorO,errorL)\r\nfinal=[0]*50000\r\nmaxo=9999999999\r\nfor i in range(min(m,n)-1,-1,-1):\r\n    if ans[i]!=-1 and ans[i]<maxo:\r\n        maxo=ans[i]\r\n        final[maxo]=i\r\ntmp=final[0]\r\nfor i in range(1,50000):\r\n    if  final[i]>tmp:\r\n        tmp=final[i]\r\n    final[i]=tmp\r\ninput()\r\nq=[int(x) for x in input().split()]\r\n\r\nfor x in q:\r\n    if x>50000-2 : print(final[45000]+1)\r\n    else: print(final[x]+1)\r\n    \r\n", "n,m = [int(i) for i in input().split()]\r\nsqsets = list(range(2,min(n,m)+1))\r\nci = []\r\nfor i in range(n):\r\n    ci.append(list(input()))\r\ncc = [[0 for i in range(m+1)] for j in range(n+1)]\r\ndef cache_creation_part(x,y):\r\n    cc[y][x] = cc[y][x - 1] + cc[y - 1][x] - cc[y - 1][x - 1]\r\n    if (y + x) % 2 == 0:\r\n        cc[y][x] += int(ci[y - 1][x - 1] != '1')\r\n    else:\r\n        cc[y][x] += int(ci[y - 1][x - 1] != '0')\r\n\r\ndef cache_creation(m,n):\r\n    for y in range(1,n+1):\r\n        for x in range(1, m + 1):\r\n            cache_creation_part(x,y)\r\n\r\ndef operation(x,y,k):\r\n    return cc[y + k][x + k] + cc[y][x] - cc[y + k][x] - cc[y][x + k]\r\n\r\nc = 0\r\nkd = {k:c for k in sqsets}\r\ndef kd_creation(m,n,sqsets):\r\n    cache_creation(m,n)\r\n    for k in sqsets:\r\n        kd[k] = (10**9)+1\r\n        for y in range(n-k+1):\r\n            for x in range(m-k+1):\r\n                cu = operation(x,y,k)\r\n                kd[k] = min(kd[k], cu, k*k-cu)\r\nkd_creation(m,n,sqsets)\r\ndel cc\r\ndel ci\r\ndel sqsets\r\ntc = int(input())\r\ntc = [int(x) for x in input().split()]\r\nfor u in tc:\r\n    p = 0\r\n    for i in kd:\r\n        if kd[i] <= u:\r\n            p = max(i, p)\r\n    print(p)", "# -*- coding: utf-8 -*-\r\n\r\nimport math\r\nimport collections\r\nimport bisect\r\nimport heapq\r\nimport time\r\nimport random\r\nimport itertools\r\nimport sys\r\n\r\n\"\"\"\r\ncreated by shhuan at 2018/10/30 19:45\r\n\r\n\"\"\"\r\n\r\n\r\nN, M = map(int, input().split())\r\n\r\nA = []\r\n\r\nfor i in range(N):\r\n    A.append([int(x) for x in input()])\r\n\r\n# for row in A:\r\n#     print(row)\r\n\r\n\r\n#f(r, c, color, width) = f(r+1, c+1, color, width-1) + mismatches_in_edge\r\n\r\nmxMN, mnMN = max(M, N), min(M, N)\r\nans = [float('inf') for _ in range(mxMN + 1)]\r\nf = [[[[0 for _ in range(mxMN + 1)] for color in range(2)] for c in range(M+1)] for r in range(N+1)]\r\n\r\nfor width in range(1, min(N, N)+1):\r\n    for color in [0, 1]:\r\n        for sr in range(N-width+1):\r\n            for sc in range(N-width+1):\r\n                steps = f[sr+1][sc+1][color][width-1]\r\n\r\n                cc = color\r\n                for c in range(sc, sc+width):\r\n                    steps += 0 if A[sr][c] == cc else 1\r\n                    cc ^= 1\r\n                cc = color ^ 1\r\n                for r in range(sr+1, sr+width):\r\n                    steps += 0 if A[r][sc] == cc else 1\r\n                    cc ^= 1\r\n\r\n                f[sr][sc][color][width] = steps\r\n                ans[width] = min(ans[width], steps)\r\n\r\nqc = input()\r\nqs = [int(x) for x in input().split()]\r\n\r\n# print()\r\n# print(ans)\r\nfor q in qs:\r\n    print(bisect.bisect_right(ans, q) - 1)\r\n\r\n", "n,m=list(map(int,input().split()))\r\ngrid=[ list(map(int,list(input()))) for i in range(n)]\r\nobs0=[ [ 0 for j in range(m)] for i in range(n)] \r\nobs1=[ [ 0 for j in range(m)] for i in range(n) ]\r\nmax_side=min(m,n)\r\nside_c=[ 40000 for i in range(max_side+1)]\r\nside_c[0]=0\r\nside_c[1]=0\r\n#print(grid)\r\nfor i in range(n):\r\n\tfor j in range(m):\r\n\t\tif (i+j)%2==0:\r\n\t\t\tobs0[i][j]=0\r\n\t\t\tobs1[i][j]=1\r\n\t\telse:\r\n\t\t\tobs0[i][j]=1\r\n\t\t\tobs1[i][j]=0\r\n#print(obs0)\r\n#print(obs1)\r\nfor i in range(n):\r\n\tfor j in range(m):\r\n\t\tif obs0[i][j]!=grid[i][j]:\r\n\t\t\tobs0[i][j]=1\r\n\t\telse:\r\n\t\t\tobs0[i][j]=0\r\n\t\tif obs1[i][j]!=grid[i][j]:\r\n\t\t\tobs1[i][j]=1\r\n\t\telse:\r\n\t\t\tobs1[i][j]=0\r\n#print(obs0)\r\n#print(obs1)\r\n\r\nfor i in range(n):\r\n\tfor j in range(1,m):\r\n\t\tobs0[i][j]+=obs0[i][j-1]\r\n\t\tobs1[i][j]+=obs1[i][j-1]\r\nfor j in range(m):\r\n\tfor i in  range(1,n):\r\n\t\tobs0[i][j]+=obs0[i-1][j]\r\n\t\tobs1[i][j]+=obs1[i-1][j]\r\nfor side in range(2,max_side+1):\r\n\tfor i in range(n):\r\n\t\tfor j in range(m):\r\n\t\t\tif i+side>n or j+side>m:\r\n\t\t\t\tcontinue\r\n\t\t\tcount0 = obs0[i+side-1][j+side-1] + (i!=0 and j!=0)*obs0[i-1][j-1] -(j!=0)*obs0[i+side-1][j-1] -(i!=0)*obs0[i-1][j+side-1] \r\n\t\t\tcount1 = obs1[i+side-1][j+side-1] + (i!=0 and j!=0)*obs1[i-1][j-1] -(j!=0)*obs1[i+side-1][j-1] -(i!=0)*obs1[i-1][j+side-1]\r\n\t\t\tside_c[side]=min(count0,count1,side_c[side])\r\ninput()\r\n#print(side_c)\r\n#print(*obs0,sep=\"\\n\")\r\n#print(*obs1,sep=\"\\n\")\r\nlist_c=list(map(int,input().split()))\r\nfor i in range(len(list_c)):\r\n\tc=list_c[i]\r\n\tanswer=1\r\n\tfor side in range(2,max_side+1):\r\n\t\tif c<side_c[side]:\r\n\t\t\tanswer=side-1\r\n\t\t\tbreak\r\n\tif c>=side_c[max_side]:\r\n\t\tanswer=max_side\r\n\tprint(answer)\r\n\r\n\r\n\r\n", "n,m=map(int,input().split())\r\nb=[[int(x) for x in list(input())] for x in range(n)]\r\nc=int(input())\r\n\r\nsize=min(n,m)\r\nres=[size**2 for x in range(size+1)]\r\n\r\ndef invert(i,j,r,ele):\r\n    count=0\r\n    \r\n    for index,x in enumerate(range(i,i+r)):\r\n        temp=ele\r\n        if index%2:\r\n            temp=0 if ele else 1\r\n            \r\n        for y in range(j,j+r):\r\n            count+=0 if temp==b[x][y] else 1\r\n            temp=0 if temp else 1\r\n    return count\r\n\r\n\r\nfor s in range(size,1,-1):\r\n    flag=0\r\n    for x in range(n-s+1):\r\n        for y in range(m-s+1):\r\n            ic=min(invert(x,y,s,0),invert(x,y,s,1))\r\n            res[s]=min(res[s],ic)\r\n            # print(x,y,s,ic)\r\n            if not ic:\r\n                flag=1\r\n                break\r\n        if flag:\r\n            break\r\n    if flag:\r\n        break\r\n\r\nfor t in map(int,input().split()):\r\n    for index,e in reversed(list(enumerate(res))):\r\n        if e<=t:\r\n            print(index)\r\n            break\r\n\r\nres = list(map(lambda x: 0 if x==size**2 else x,res))", "import sys\r\n\r\ndp=[[0 for i in range(201)]for i in range(201)]\r\nQ =[sys.maxsize for i in range(201)]\r\nQ1=[sys.maxsize for i in range(201)]\r\n\r\n\r\ndef compareWith(A ,B ,n ,m , f):\r\n    \r\n    for i in range(1,n+1):\r\n        for j in range(1,m+1):\r\n            \r\n            a=0\r\n            if(A[i-1][j-1]!=B[i-1][j-1]):\r\n                a=1\r\n            \r\n            dp[i][j]=a + dp[i-1][j] + dp[i][j-1] -dp[i-1][j-1]\r\n            \r\n    \r\n    for i in range(1,n+1):\r\n        for j in range(1,m+1):\r\n            k=i\r\n            l=j\r\n            r=1\r\n            while k<=n and l<=m:\r\n                a=findError(i,j,k,l)\r\n                Q[r]=min(Q[r],a)\r\n                k+=1\r\n                l+=1\r\n                r+=1\r\n                \r\n    if f==1:\r\n        Q1=Q[:]\r\n\r\n\r\ndef findError(i,j,k,l):\r\n    return dp[k][l]-dp[k][j-1]-dp[i-1][l]+dp[i-1][j-1]\r\n    \r\n\r\n\r\n\r\nn, m = map(int, input().split()) \r\n\r\nA=[]\r\nC=[]\r\nB=[]\r\n\r\nfor i in range(n):\r\n    s=input()\r\n    A.append(s)\r\n    \r\nfor i in range(n):\r\n    sb=\"\"\r\n    sc=\"\"\r\n    for j in range(m):\r\n        if(i%2==0):\r\n            if(j%2==0):\r\n                sb+='1'\r\n                sc+='0'\r\n            else:\r\n                sb+='0'\r\n                sc+='1'\r\n        else:\r\n            if(j%2==1):\r\n                sb+='1'\r\n                sc+='0'\r\n            else:\r\n                sb+='0'\r\n                sc+='1'\r\n    B.append(sb)\r\n    C.append(sc)\r\n    \r\n# print(*B, sep='\\n')\r\n# print(\"****\")\r\n# print(*C, sep='\\n')\r\n\r\ncompareWith(A,B,n,m,1)\r\ncompareWith(A,C,n,m,0)\r\n\r\nq=int(input())\r\nc=list(map(int,input().split()))\r\n\r\nfor i in c:\r\n    a=0\r\n    for j in range(1,min(m,n)+1):\r\n        if i>=Q[j] or i>=Q1[j]:\r\n            a=max(a,j)\r\n    \r\n    print(a)\r\n\r\n\r\n    ", "# cook your dish here\nn,m=map(int,input().split())\nR=n\nC=m\na=[None]*n\nz=[0]*n\no=[1]*n\nfor i in range(m):\n    if i%2!=0:\n        z[i]=1\n        o[i]=0\nzi=[None]*n\noi=[None]*n\nfor i in range(n):\n    a[i]=input()\n    a[i]=list(a[i])\n    for j in range(m):\n        a[i][j]=int(a[i][j])\n    \n    if i%2==0:\n        zi[i]=z[:]\n        oi[i]=o[:]\n    else:\n        zi[i]=o[:]\n        oi[i]=z[:]\nforzi=0\nforoi=0\npsao = [[0 for x in range(C)] for y in range(R)]  \npsaz = [[0 for x in range(C)] for y in range(R)] \nnoioo=0\nnoizz=0\nnoio=0\nnoiz=0\nfor i in range(n):\n    noiz=0\n    noio=0\n    \n    for j in range(m):\n        \n        if i==0:\n            if a[i][j]!=oi[i][j]:\n                noio+=1\n            else:\n                noiz+=1\n            psao[i][j]=noio\n            psaz[i][j]=noiz\n        else:\n            if a[i][j]!=oi[i][j]:\n                noio+=1\n            else:\n                noiz+=1\n            psaz[i][j]=noiz+psaz[i-1][j]\n            psao[i][j]=noio+psao[i-1][j]\n    \n\n        \n    \n\n\nmmm=[]\nfor i in range(2,min(m,n)+1):\n    c=0\n    ap=[]\n    for j in range(n-i+1):\n        for k in range(m-i+1):\n            czz=0\n            czz1=0\n            czz2=0\n            coo=0\n            cor=0\n            czz+=(psaz[j+i-1][k+i-1])\n            coo+=(psao[j+i-1][k+i-1])\n\n            if k-1>=0:\n                czz-=(psaz[j+i-1][k-1])\n                coo-=(psao[j+i-1][k-1])\n            else:\n                czz+=0\n            if j-1>=0:\n                czz-=(psaz[j-1][k+i-1])\n                coo-=(psao[j-1][k+i-1])\n\n            else:\n                czz+=0\n            if j-1>=0 and k-1>=0:\n                czz+=(psaz[j-1][k-1])\n                coo+=(psao[j-1][k-1])\n            else:\n                czz+=0\n            \n            ap.append((min((abs(coo)),abs(czz))))\n    mmm.append(min(ap))\n\nq=int(input())\nlo=[int(pp) for pp in input().split()]\nmaxq=max(mmm)\nfor i in range(q):\n    if lo[i]>maxq:\n        print(min(n,m))\n    else:\n        j=len(mmm)-1\n        ind=0\n        while j>=0:\n            if lo[i]>=mmm[j]:\n                ind=j+2\n                break\n            j-=1\n        print(ind)"]
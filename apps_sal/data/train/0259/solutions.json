["import numpy as np\nimport math\n\nclass Solution:\n    \n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        if len(nums) == 1:\n            return int(math.ceil(nums[0]/threshold))\n        \n        np_nums = np.array(nums) \n        low, high = 1, np.max(np_nums)\n        \n        divisors = []\n        while low + 1 < high:\n            mid = (low + high) // 2\n            \n            if np.sum(np.ceil(np_nums/mid)) > threshold:\n                low = mid\n            else:\n                high = mid\n            \n        if np.sum(np.ceil(np_nums/low)) <= threshold:\n            return low\n        \n        return high\n", "from numpy import array, ceil, sum\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        nums = array(nums)\n        l, r = ceil(sum(nums)/threshold), max(nums)\n        \n        while l < r:\n            mid = (l+r)//2\n            if sum(ceil(nums/mid)) <= threshold:\n                r = mid\n            else:\n                l = mid + 1\n        \n        return int(r)", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def helper(nums, ans):\n            return sum([ (i + ans - 1) // ans for i in nums])\n        \n        l =  1\n        r = max(nums)\n        while l < r:\n            mid  = l + (r - l) // 2\n            sumv = helper(nums, mid)\n            if sumv <= threshold:\n                r = mid \n            else:\n                l = mid + 1\n            \n        return l\n", "import math\nclass Solution:\n    def calculateSum(self, nums, divisor):\n        Sum = 0\n        for num in nums:\n            Sum += math.ceil(num / divisor)\n        return Sum\n    \n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        maxValue = max(nums)\n        \n        l = 1\n        r = maxValue\n        \n        while l <= r:\n            mid = (l + r) // 2\n            # print(mid)\n            if mid == maxValue:\n                return maxValue\n                \n            sum1 = self.calculateSum(nums, mid)\n            sum2 = self.calculateSum(nums, mid + 1)\n            # print(sum1, sum2)\n            if sum2 <= threshold and sum1 > threshold:\n                return mid + 1\n            \n            if sum1 <= threshold:\n                r = mid - 1\n            \n            if sum1 > threshold:\n                l = mid + 1\n        return 1", "class Solution:\n    def divide(self, num, divisor):\n        return -((-num)//divisor)\n    \n    def getQuotient(self, nums, divisor):\n        output = 0\n        for num in nums:\n            output += ceil(num/divisor)\n        return output\n    \n    def getResult(self, results, divisor, nums):\n        #if divisor in results:\n        #    return results[divisor]\n        #else:\n        #    results[divisor] = self.getQuotient(nums, divisor)\n        #    return results[divisor]\n        return self.getQuotient(nums, divisor)\n    def helper(self, results, nums, i, j, threshold):\n        if i == j:\n            return i\n        \n        mid = (i+j)//2\n        if mid == 1:\n            return mid\n        elif self.getResult(results, mid, nums) <= threshold and self.getResult(results, mid-1, nums) > threshold:\n            return mid\n        elif self.getResult(results, mid, nums) <= threshold:\n            return self.helper(results, nums, i, mid-1, threshold)\n        else:\n            return self.helper(results, nums, mid+1, j, threshold)\n    \n\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        maxDivisor = ceil(2*sum(nums)/threshold)\n        #print(maxDivisor)\n        #maxDivisor = 1000000\n        results = dict()\n        \n        return self.helper(results, nums, 1, maxDivisor, threshold)\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        lo, hi= 1, max(nums)\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if sum([math.ceil(i/mid) for i in nums]) <= threshold:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return lo", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n\n#         left, right = 1, max(nums)\n#         while left + 1 < right:\n#             mid = (left + right) // 2\n#             div_sum =  self.get_sum(mid, nums)\n#             if div_sum > threshold:\n#                 left = mid\n#             else:\n#                 right = mid\n        \n#         div_sum = self.get_sum(left, nums)\n#         if div_sum <= threshold:\n#             return left\n#         return right\n        \n    \n#     def get_sum(self, divisor, nums):\n#         res = 0\n#         for n in nums:\n#             tmp = n // divisor\n#             if tmp * divisor < n:\n#                 tmp += 1\n            \n#             res += tmp\n        \n#         return res\n    \n        dicti = {0:False}\n        def chk(nmb):\n            if nmb in dicti:\n                return dicti[nmb]\n            val = 0\n            for num in nums:\n                val += math.ceil(num/nmb)\n                if val > threshold:\n                    dicti[nmb] = False\n                    return False\n            dicti[nmb] = True\n            return dicti[nmb]\n            \n        high = sum(nums)\n        low = math.ceil(high/threshold)  \n        while low <= high:\n            mid = (low + high)//2\n            \n            if chk(mid):\n                high = mid - 1\n            elif not chk(mid):\n                low = mid + 1\n        return low-1 if chk(low-1) else high+1\n                \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        l, r = 1, max(nums)\n        while l < r:\n            m = (l + r) // 2\n            sum_num = 0\n            for i in nums:\n                sum_num += (i + m - 1) // m\n            if sum_num > threshold:\n                l = m + 1\n            else:\n                r = m\n        return l", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        # if the sum <= threshold, the divisor is big enough\n        \n        low, high = 1, max(nums)\n        \n        while low < high:\n            mid = (low + high) // 2\n        \n            # if the sum > threshold, the divisor is too small\n            if sum((i + mid - 1) // mid for i in nums) > threshold:\n                low = mid + 1\n            else:\n                high = mid\n                \n        return low\n", "class Solution:\n    def divide(self, num, divisor):\n        return -((-num)//divisor)\n    \n    def getQuotient(self, nums, divisor):\n        output = 0\n        for num in nums:\n            output += ceil(num/divisor)\n        return output\n    \n    def getResult(self, results, divisor, nums):\n        #if divisor in results:\n        #    return results[divisor]\n        #else:\n        #    results[divisor] = self.getQuotient(nums, divisor)\n        #    return results[divisor]\n        return self.getQuotient(nums, divisor)\n    def helper(self, results, nums, i, j, threshold):\n        if i == j:\n            return i\n        \n        mid = (i+j)//2\n        if mid == 1:\n            return mid\n        elif self.getResult(results, mid, nums) <= threshold and self.getResult(results, mid-1, nums) > threshold:\n            return mid\n        elif self.getResult(results, mid, nums) <= threshold:\n            return self.helper(results, nums, i, mid-1, threshold)\n        else:\n            return self.helper(results, nums, mid+1, j, threshold)\n    \n\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        maxDivisor = self.divide(2*sum(nums), threshold)\n        #print(maxDivisor)\n        #maxDivisor = 1000000\n        results = dict()\n        \n        return self.helper(results, nums, 1, maxDivisor, threshold)\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        # (s + n) / x <= threshold\n        # x >= (s + n) / threshold\n        # x >= (s + n) // threshold\n        \n        # n <= t\n        # n >= 1\n        # t >= 1\n        # s / x <= t\n        # x <= s\n        \n        n, j = len(nums), sum(nums)\n        i = (j + n) // threshold\n        i = 1 if i == 0 else i\n        while i < j-1:\n            k = (i + j) // 2\n            ss = sum([math.ceil(n / k) for n in nums])\n            if ss > threshold:\n                i = k\n            else:\n                j = k\n\n        if sum([math.ceil(n / i) for n in nums]) <= threshold:\n            return i\n        else:\n            return j\n", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        self.nums = nums\n        self.threshold = threshold\n        num_sum = sum(nums)\n        l = math.floor(num_sum / threshold)-1\n        h = num_sum\n        m = math.ceil((l+h) / 2)\n        while h != m:\n#            print(l,h)\n            if self.validate_divisor(m):\n                h = m\n            else:\n                l = m\n            m = math.ceil((l+h) / 2)\n        return h\n        \n    def validate_divisor(self, divisor):\n        if divisor <= 0:\n            return False\n        s = sum(math.ceil(x / divisor) for x in self.nums)\n#        print('validate', divisor, s, s <= self.threshold)\n        return s <= self.threshold", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def condition(divisor):\n            return sum((num - 1) // divisor +1 for num in nums) <= threshold\n        left, right = ceil(sum(nums)/threshold), max(nums)\n        while left < right:\n            mid = left + (right -left) //2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        l = 1; r = 2**31-1\n        calc = lambda cand: sum(ceil(x/cand) for x in nums)\n        while l + 1 < r:\n            mid = l+(r-l)//2\n            if  calc(mid) > threshold:\n                l = mid\n            else:\n                r = mid\n        if calc(l) <= threshold: return l\n        else: return r\n        \n            \n", "import math \nclass Solution: \n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        # bruteforce \n        '''\n        divisor = 0 \n        trial_sum = float(inf) \n        while trial_sum > threshold:\n            divisor += 1 \n            trial_sum = 0 \n            for num in nums: \n                trial_sum += math.ceil(num / divisor)\n           \n\n        return divisor \n        '''\n        \n        # binary search \n        low = 1 \n        high = 100000000\n        while (low <= high):\n            mid = low + (high - low) // 2 \n            if self.getSum(nums, mid) <= threshold: \n                high = mid - 1 \n            elif self.getSum(nums, mid) > threshold: \n                low = mid + 1 \n        return low\n    def getSum(self, nums, divisor):\n        trial_sum = 0 \n        for num in nums: \n            trial_sum += math.ceil(num / divisor)\n        return trial_sum \n    \n    \n            \n    \n            \n        \n", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def candidate(val):\n            res = sum(math.ceil(v/val) for v in nums)\n            return res <= threshold\n        \n        lo, hi = 1, max(nums)\n        while lo < hi:\n            med = lo + (hi-lo)//2\n            if candidate(med):\n                hi = med\n            else:\n                lo = med+1\n        return hi", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def posb(m):\n            s=0\n            for i in range(len(nums)):\n                s+=math.ceil(nums[i]/m)\n            return s>threshold\n        l=1\n        r=10**9\n        while l<r:\n            mid=(l+r)//2\n            if posb(mid)==False:\n                r=mid\n            else:\n                l=mid+1\n        return l\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        def calculate(divisor):\n            _sum=0\n            for val in nums:\n                _sum+=val//divisor + int(val%divisor!=0)\n            return _sum\n        \n        \n        start,end=1,sum(nums)\n        while start<end:\n            mid=start+(end-start)//2\n            _sum=calculate(mid)\n            if _sum>threshold:\n                start=mid+1\n            else:\n                end=mid\n        return start\n            \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        #print(math.ceil(7/3))\n        high = sum(nums)\n        if high <= threshold: return 1\n        \n        def sum_divide(divisor):\n            su = 0\n            for num in nums:\n                su += math.ceil(num / divisor)\n                if su > threshold:\n                    return False\n            return True    \n        \n        low = 1\n        while low < high:\n            mid = low + (high - low) // 2\n            if sum_divide(mid):\n                high = mid\n            else:\n                low = mid + 1\n                \n        return low       \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        lo, hi = 1, max(nums)\n        \n        while lo <= hi:\n            mid = (lo+hi)//2\n            divisor_sum = sum([math.ceil(x/mid) for x in nums]) # will be larger\n            next_sum = sum([math.ceil(x/(mid+1)) for x in nums]) # will be smaller\n            \n            if  next_sum <= threshold < divisor_sum:\n                return mid+1\n            elif next_sum > threshold:\n                lo = mid + 1\n            elif divisor_sum <= threshold:\n                hi = mid - 1\n        \n        return 1", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        # sum/divisor<= threshold\n        # divisor >= sum/threshold\n        def is_le(divisor):\n            count = 0\n            for num in nums:\n                count += math.ceil(num/divisor)\n                if count>threshold:\n                    return False\n            return True\n        \n        low = max(1,math.floor(sum(nums)/threshold))\n        high = max(nums)\n        while low<high:\n            mid = low + (high-low)//2\n            if is_le(mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low\n", "from math import ceil\ndef is_fine(nums,val,threshold):\n    tot = 0\n    for i in nums:\n        tot += ceil(i/val)\n    if tot <= threshold:\n        return True\n    else:\n        return False\ndef bSearch(l,r,nums,threshold):\n    if l <= r:\n        mid = (l+r)//2\n        high_val = is_fine(nums,mid,threshold)\n        low_val = is_fine(nums,mid-1,threshold)\n        if high_val is True and low_val is False:\n            return mid\n        elif high_val is False and low_val is False:\n            return bSearch(mid+1,r,nums,threshold)\n        else:\n            return bSearch(l,mid-1,nums,threshold)\n    else:\n        return None\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        if sum(nums) <= threshold:\n            return 1\n        return bSearch(2,10**7,nums,threshold)\n        \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        lo, hi = 1, max(nums)\n\n        while lo < hi:\n            mid = (lo+hi)//2                        \n            print(sum([math.ceil(n/mid) for n in nums]))\n            if sum([math.ceil(n/mid) for n in nums]) <= threshold:\n                hi = mid\n            else:\n                lo = mid+1\n\n        return lo", "class Solution:\n    def satisfyThreshold(self, nums, threshold, divisor):\n        return sum((((n-1) // divisor) + 1 for n in nums)) <= threshold\n        \n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        left = 1\n        right = max(nums)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if self.satisfyThreshold(nums, threshold, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        val=sum(nums)\n        n=len(nums)\n        \n        if val<=threshold:\n            return 1\n        \n        p=val//threshold+int(val%threshold!=0)\n        q=val//(max(1,threshold-n-1))\n        q=q+4\n        p=max(2,p)\n        \n        check=1\n        \n        while (p<q):\n            mid=(p+q)//2\n            count1=0\n            count2=0\n            for i in nums:\n                count1=count1+(i//mid+int(i%mid!=0))\n                count2=count2+(i//(mid-1)+int(i%(mid-1)!=0))\n            if count1<=threshold and count2>threshold:\n                return mid\n            elif count1<=threshold and count2<=threshold:\n                q=mid\n            elif count1>threshold:\n                p=mid+1\n                \n        \n        \n        \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        left = 1\n        right = max(nums)\n        while left <= right:\n            mid = (right + left) // 2\n            acc = 0\n            for n in nums:\n                acc += math.ceil(n/mid)\n            # print(left, mid, right, '|', acc)\n            if acc > threshold: left = mid + 1\n            elif acc <= threshold: right = mid - 1\n        return left\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def check(nums, a, th):\n            for n in nums:\n                th-=math.ceil(n/a)\n                if th<0:\n                    return False\n            return True\n        l,r=1,max(nums)\n        while l<r:\n            mid=(l+r)//2\n            if check(nums, mid, threshold):\n                r=mid\n            else:\n                l=mid+1\n        return l", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        nums.sort()\n        return self.binSearch(1, nums[-1], nums, threshold)\n    \n    def binSearch(self, head, tail, nums, threshold):\n        if head == tail:\n            return head\n        mid = (tail - head) // 2 + head\n        ct = 0\n        flag = True\n        for num in nums:\n            ct += math.ceil(num/mid)\n            if ct > threshold:\n                flag = False\n                break\n        if not flag: return self.binSearch(mid + 1, tail, nums, threshold)\n        else: return self.binSearch(head, mid, nums, threshold)\n", "#import math\nfrom numpy import ceil\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def candidate(val):\n            #res = sum(math.ceil(v/val) for v in nums)\n            res = sum((v-1)//val + 1 for v in nums)\n            return res <= threshold\n        \n        lo, hi = 1, max(nums)\n        while lo < hi:\n            med = lo + (hi-lo)//2\n            if candidate(med):\n                hi = med\n            else:\n                lo = med+1\n        return hi", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        def thres(div):\n            return sum([ceil(val/div) for val in nums])\n        \n        l,h=1,max(nums)\n        \n        while(l<=h):\n            mid=l+((h-l)>>1)\n            if thres(mid)<=threshold: h=mid-1\n            else: l=mid+1\n        \n        return l\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        left = 1\n        right = max(nums)\n        while left < right:\n            mid = (right + left) // 2\n            acc = 0\n            for n in nums:\n                acc += math.ceil(n/mid)\n            # print(left, mid, right, '|', acc)\n            if acc > threshold: left = mid + 1\n            elif acc <= threshold: right = mid\n        return left\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        # O(n*log(sum(nums)))\n        \n        \n        # sum = 18, threshold = 6, left = 0, right = 3\n        \n        l = 1\n        r = max(nums)\n        while l < r:\n            m = l + (r - l) // 2\n            # print(l, r)\n            s = sum([ceil(x/m) for x in nums])\n            # print(\\\"sum: \\\", s)\n            if s > threshold:\n                l = m + 1\n            else:\n                r = m\n        \n        return l\n                \n        \n        \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        l = 0\n        r = nums[-1]\n        res = []\n        while r-l > 1:\n            c = (l+r)//2\n            tmp_sum = [math.ceil(i/c) for i in nums]\n            tmp_sum = sum(tmp_sum)\n            if tmp_sum > threshold:\n                l = c\n            elif tmp_sum <= threshold:\n                r=c\n                res.append(c)\n        return min(res)\n            \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        l, r = 1, max(nums)\n        count = 0\n        while l < r:\n            m = l + (r-l)//2\n            for i in nums:\n                count += (i + m -1) // m\n            if count > threshold:\n                l = m + 1\n            else:\n                r = m\n            count = 0\n        return l\n        \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        nums.sort()\n        n = len(nums)\n        \n        start, end = 1, nums[-1]\n        while start < end:\n            mid = (start + end) // 2\n            j = n - 1\n            s = n\n            while j >= 0 and mid < nums[j]:\n                s -= 1\n                s += math.ceil(nums[j] / mid)\n                j -= 1\n            if s > threshold:\n                start = mid + 1\n            else:\n                end = mid\n        return start\n        # j = len(nums) - 1\n        # for i in nums[::-1]:\n        #     j = n - 1\n        #     s = n\n        #     while j >= 0 and i < nums[j]:\n        #         s -= 1\n        #         s += math.ceil(nums[j] / i)\n        #         j -= 1\n        #     if s > threshold:\n        #         start = i\n        #         end = prev\n        #         break\n        #     prev = i\n        # else:\n        #     start = 1\n        #     end = i\n        # # print(start, end)   \n        # for i in range(end, start - 1, -1):\n        #     j = n - 1\n        #     s = n\n        #     while j >= 0 and i < nums[j]:\n        #         s -= 1\n        #         s += math.ceil(nums[j] / i)\n        #         j -= 1\n        #     if s > threshold:\n        #         return i + 1\n        # return 1\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def condition(arr, thr, div):\n            res = 0\n            for i in arr:\n                res += math.ceil(i/div)\n            return res <= thr\n                \n        \n        l, r = 1, max(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if condition(nums, threshold, m):\n                r = m\n            else:\n                l = m + 1\n            \n        return l", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        n = len(nums)\n        small, big = 1, max(nums)\n        while small < big:\n            mid = small + (big-small)//2\n            cur = 0\n            for num in nums:\n                cur += math.ceil(num/mid)\n            if cur > threshold:\n                small = mid + 1\n            else:\n                big = mid\n        return small", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n\n#         left, right = 1, max(nums)\n#         while left + 1 < right:\n#             mid = (left + right) // 2\n#             div_sum =  self.get_sum(mid, nums)\n#             if div_sum > threshold:\n#                 left = mid\n#             else:\n#                 right = mid\n        \n#         div_sum = self.get_sum(left, nums)\n#         if div_sum <= threshold:\n#             return left\n#         return right\n        \n    \n#     def get_sum(self, divisor, nums):\n#         res = 0\n#         for n in nums:\n#             tmp = n // divisor\n#             if tmp * divisor < n:\n#                 tmp += 1\n            \n#             res += tmp\n        \n#         return res\n    \n        def chk(nmb):\n            if nmb == 0:\n                return False\n            val = 0\n            for num in nums:\n                val += math.ceil(num/nmb)\n                if val > threshold:\n                    return False\n            return True\n            \n        high = sum(nums)\n        low = math.ceil(high/threshold)  \n        while low <= high:\n            mid = (low + high)//2\n            \n            if chk(mid):\n                high = mid - 1\n            elif not chk(mid):\n                low = mid + 1\n        return low-1 if chk(low-1) else high+1\n                \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        left, right = 1, max(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if self.findSum(nums, mid) > threshold:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n    \n    \n    def findSum(self, nums, divisor):\n        return sum(math.ceil(num / divisor) for num in nums)", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def getSum(k):\n            res = 0\n            for n in nums:\n                if n % k == 0:\n                    res += n // k\n                else:\n                    res += n // k + 1\n            return res\n            \n        l, r = max(sum(nums) // threshold, 1), max(1, sum(nums))\n        while l < r:\n            m = (l + r) // 2\n            if getSum(m) > threshold:\n                l = m + 1\n            else:\n                r = m\n        return l", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n\n#         left, right = 1, max(nums)\n#         while left + 1 < right:\n#             mid = (left + right) // 2\n#             div_sum =  self.get_sum(mid, nums)\n#             if div_sum > threshold:\n#                 left = mid\n#             else:\n#                 right = mid\n        \n#         div_sum = self.get_sum(left, nums)\n#         if div_sum <= threshold:\n#             return left\n#         return right\n        \n    \n#     def get_sum(self, divisor, nums):\n#         res = 0\n#         for n in nums:\n#             tmp = n // divisor\n#             if tmp * divisor < n:\n#                 tmp += 1\n            \n#             res += tmp\n        \n#         return res\n    \n        def chk(nmb):\n            if nmb == 0:\n                return False\n            val = 0\n            for num in nums:\n                val += math.ceil(num/nmb)\n                if val > threshold:\n                    return False\n            return True\n            \n        high = sum(nums)\n        low = (high//threshold)  \n        while low <= high:\n            mid = (low + high)//2\n            \n            if chk(mid):\n                high = mid - 1\n            elif not chk(mid):\n                low = mid + 1\n        return low-1 if chk(low-1) else high+1\n                \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        l = 1\n        u = max(nums)\n        \n        def division_sum(k):\n            return sum(int(math.ceil(n/k)) for n in nums)\n        \n        while l < u:\n            mid = l + (u-l)//2\n            \n            if division_sum(mid) <= threshold:\n                u = mid\n            else:\n                l = mid + 1\n        \n        return l", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def condition(divisor):\n            return sum((num - 1) // divisor +1 for num in nums) <= threshold\n        left, right = 1, max(nums)\n        while left < right:\n            mid = left + (right -left) //2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        '''\n        \n        find m where    (num + m) // m    for all nums and sum to <= threshold\n        \n        '''\n        \n        i = 1\n        j = max(nums)\n        m = (i + j) // 2\n        \n        ans = 0\n        \n        while i <= j:\n            \n            total = 0\n            for num in nums:\n                total += (num + m - 1) // m  # ceil. division\n                \n            if total > threshold:\n                i = m + 1\n            elif total <= threshold:\n                j = m - 1\n                ans = m\n            \n            m = (i + j) // 2  # mid point\n        \n        return ans", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        '''\n        \n        find m where    (num + m) // m    for all nums and sum to <= threshold\n        \n        '''\n        \n        i = 1\n        j = max(nums)\n        \n        while i < j:\n            m = (i + j) // 2\n            \n            total = 0\n            for num in nums:\n                total += (num + m - 1) // m  # ceil. division\n                \n            if total > threshold:\n                i = m + 1\n            elif total <= threshold:\n                j = m\n        \n        return i", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        l = 1\n        r = max(nums)\n        \n        while l < r:\n            \n            m = (l + r) // 2\n            \n            if sum((n + m - 1) // m for n in nums) > threshold:\n                l = m + 1\n            else:\n                r = m\n                \n        return l", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        def feasible(div):\n            count = 0\n            for num in nums:\n                count += (num-1)//div + 1\n            return count<=threshold\n        \n        left = 1\n        right = max(nums)\n        \n        while left < right:\n            mid = left + ((right-left)>>1)\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid+1\n        return left", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        #def evl(d):\n            #s = 0\n            #for n in nums:\n            #    s += (n-1) // d + 1\n            #return s\n        #    return \n        \n        def BS(p, r):\n            \n\n            if r-p <= 1:\n                if sum([(n-1)//p + 1 for n in nums]) <= threshold:\n                    return p\n                return r\n            \n            q = (r+p)//2\n            \n            e = sum([(n-1)//q + 1 for n in nums])\n            if e <= threshold:\n                return BS(p, q)\n            else:\n                return BS(q, r)\n        \n        \n        r = max(nums)\n        p = 1\n        \n        return BS(p,r)\n", "from numpy import array, ceil, sum\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        ''' Original solution\n        def div(a,b):\n            return (a//b + 1 - (a//b == a/b))\n        \n        divisor = max(nums)//2\n        divided_list = [div(num, divisor) for num in nums]\n        \n        left = 1\n        right = max(nums)\n        while right - left > 1:\n            \n            goleft = (sum(divided_list) <= threshold)\n            \n            if goleft:\n                right = divisor\n                divisor = (divisor + left) // 2\n                \n            else:\n                left = divisor\n                divisor = (divisor + right) // 2\n            \n            #print(f\\\"left:{left}, right:{right}\\\")\n            \n            divided_list = [div(num, divisor) for num in nums]\n\n        if sum(divided_list) > threshold:\n            divisor += 1\n        \n        return divisor'''\n        \n        nums = array(nums)\n        l, r = int(ceil(sum(nums)/threshold)), max(nums)\n        \n        while l < r:\n            mid = (l+r)//2\n            if sum(ceil(nums/mid)) <= threshold:\n                r = mid\n            else:\n                l = mid + 1\n        \n        return r", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        low,high = 1, max(nums)\n        \n        while low<high:\n            \n            mid = (low+high)//2\n            \n            if(sum(ceil(elem/mid) for elem in nums)) > threshold:\n                low = mid +1\n            \n            else:\n                high = mid\n        \n        return low", "from math import ceil\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        l, r = 1, max(nums)\n        while l < r:\n            d = (l+r) // 2\n            s = sum ( [ ceil(n/d) for n in nums ])\n            if s>threshold:\n                l = d+1\n            else:\n                r = d\n        return l \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        mx = max(nums)\n\n        low = 1\n        high = mx\n        best = mx\n\n        while low < high:\n            med = low + (high-low) // 2\n\n            total = 0\n\n            for num in nums:\n                total += ceil(num / med)\n\n            if total <= threshold:\n                high = med\n                best = min(best,med)\n            else:\n                low = med + 1\n\n\n        return best\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        low, high = 1, max(nums)\n        while low <= high:\n            mid = (low + high)//2\n            total = 0\n            for num in nums:\n                total += ceil(num/mid)\n            if total > threshold:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return low", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        # high = math.ceil(max(nums) * len(nums) / threshold)\n        # low = math.ceil(sum(nums) / threshold)\n        low, high = math.ceil(sum(nums)/threshold), math.ceil(sum(nums)/(threshold-len(nums)))\n        def binary_search(low, high): \n            if high > low: \n                mid = (high + low) // 2\n                tot = 0\n                for num in nums:\n                    tot += math.ceil(num / mid)\n                if tot <= threshold: \n                    return binary_search(low, mid)  \n                else: \n                    return binary_search(mid + 1, high) \n            else: \n                return high\n        return binary_search(low, high)", "from math import ceil\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        left=1\n        right=max(nums)\n        def cal_sum(div):\n            div_sum=0\n            for num in nums:\n                div_sum+=ceil(num/div)\n            return div_sum\n        while left< right:\n            mid=left+(right-left)//2\n            if cal_sum(mid)>threshold:\n                left=mid+1\n            else:\n                right=mid\n        \n                \n                \n        return right\n        \n", "from math import ceil\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        left=1\n        right=max(nums)\n        def cal_sum(div):\n            div_sum=0\n            for num in nums:\n                div_sum+=ceil(num/div)\n            return div_sum\n        while left< right:\n            mid=left+(right-left)//2\n            if cal_sum(mid)>threshold:\n                left=mid+1\n            else:\n                right=mid\n        \n                \n                \n        return left\n        \n", "from bisect import bisect_left\n\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        hi = math.ceil(len(nums) * max(nums) / threshold)\n        lo = math.ceil(sum(nums) / threshold)\n        \n        while lo <= hi:\n            med = (lo + hi) // 2\n            cur = self.divSum(nums, med)\n            if cur <= threshold:\n                hi = med - 1\n            else:\n                lo = med + 1\n        \n        return lo\n            \n    def divSum(self, nums, div):\n        total = 0\n        for num in nums:\n            total += math.ceil(num / div)\n        return total", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def division(divisor):\n            total = 0\n            for n in nums:\n                total += math.ceil(n / divisor)\n            return total\n        \n        total = sum(nums)\n        left = max(1, total//threshold)\n        right = math.ceil(total/(threshold-len(nums)))\n        while left < right:\n            mid = (left + right) // 2\n            if division(mid) > threshold:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        left, right = 1, max(nums)\n        \n        while left < right:\n            mid = left + (right-left)//2\n            \n            total = sum([(x + mid - 1)//mid for x in nums])\n            \n            if total > threshold:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return left\n", "from numpy import array, ceil, sum\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        nums = array(nums)\n        l, r = 1, max(nums)\n        while l < r:\n            mid = (l+r)//2\n            if sum(ceil(nums / mid)) <= threshold:\n                r = mid\n            else:\n                l = mid + 1\n        return r   \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def condition(mid):\n            sum_nums = 0\n            for num in nums:\n                sum_nums += ceil(num/mid)\n            return sum_nums <= threshold\n        \n        left = 1\n        right = max(nums)\n        while left < right:\n            mid = (left + right)//2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "from math import ceil\n\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        left, right = 1, max(nums)\n        while left <= right:\n            m = left + (right - left) // 2\n            if self.check(nums, m, threshold):\n                ans = m\n                right = m - 1\n            else:\n                left = m + 1\n        return ans\n    \n    def check(self, nums, m, threshold):\n        return sum([ceil(x/m) for x in nums]) <= threshold\n    \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        high = math.ceil(max(nums) * len(nums) / threshold)\n        low = math.ceil(sum(nums) / threshold)\n        while high > low: \n            mid = (high + low) // 2\n            tot = 0\n            for num in nums:\n                tot += math.ceil(num / mid)\n            if tot <= threshold: \n                high = mid  \n            else: \n                low = mid + 1\n        return high\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def helper(div):\n            output = 0\n            for n in nums:\n                if n % div == 0:\n                    output += n//div\n                else:\n                    output += n//div+1\n            if output <= threshold: return True\n            return False\n    \n        nums.sort()\n        l, r = 1, max(nums)\n        while l < r:\n            mid = l + (r-l)//2\n            if helper(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        # No matter what each num must contribute at least 1 (even if the divisor is infinite)\n        # We need to binary search divisor range from 1 to max(nums), since the lowest divisor possible is dividing by 1, and the highest divisor we can use is the max of nums, so everything will divide to 1\n        \n        \n        left = 1\n        right = max(nums)\n        \n        while left <= right:\n            mid = (left + right) // 2\n            sum_val = sum(math.ceil(num / mid) for num in nums)\n            if sum_val <= threshold: # We want to divide by a smaller num\n                right = mid - 1\n            else:\n                left = mid + 1\n            # Left will stop at the lowest divisor that makes sum_val <= threshold\n        return left\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        L, R = 1, max(nums)+1\n        \n        def solve(divisor):\n            sums = 0\n            for num in nums:\n                sums += num // divisor\n                sums += 0 if num % divisor == 0 else 1\n            \n            return sums > threshold\n        \n        while L < R:\n            mid = L + (R-L) // 2\n            if solve(mid):\n                L = mid + 1\n            else:\n                R = mid\n                \n        return R", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        a = 1\n        b = max(nums)\n        i = (a+b)//2\n        ans = 10000000000000\n        while b-a >1:\n            sum = 0\n            for j in nums:\n                if j%i == 0:\n                    sum += j//i\n                else:\n                    sum += j//i + 1\n            if sum <= threshold:\n                ans = min(i,ans)\n                b = i\n            else:\n                a = i\n            i = (a+b)//2\n        for i in(a,b):\n            sum = 0\n            for j in nums:\n                if j%i == 0:\n                    sum += j//i\n                else:\n                    sum += j//i + 1\n            if sum <= threshold:\n                ans = min(i,ans)  \n        return ans", "import math\n\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        low, high = 1, max(nums)\n        while low < high:\n            mid = (low+high)//2\n            if sum(math.ceil(num/mid) for num in nums) > threshold:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n", "import numpy as np\n\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        nums = np.array(nums)\n        left = sum(nums) // threshold\n        right = max(nums) + 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n\n            if np.sum(np.ceil(nums / mid)) <= threshold:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n        \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        L, R = 1, max(nums)+1\n        \n        def solve(divisor):\n            res = []\n            for num in nums:\n                res.append(num // divisor + (0 if num % divisor == 0 else 1))\n            \n            return sum(res) > threshold\n        \n        while L < R:\n            mid = L + (R-L) // 2\n            if solve(mid):\n                L = mid + 1\n            else:\n                R = mid\n                \n        return R", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        left = 1\n        right = max(nums)\n        \n        while left < right:\n            mid = (left+right)//2\n            \n            cur_sum = 0\n            for each in nums:\n                cur_sum += math.ceil(each/mid)\n            \n            if cur_sum <= threshold:\n                right = mid\n            \n            else:\n                left = mid+1\n        \n        return left", "class Solution:\n    \n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        low = 1\n        high = 2 * max(nums)\n        ans = float('inf')\n        \n        while low <= high:\n            mid = (low + high) // 2\n            m = sum(math.ceil(x/mid) for x in nums)\n            if m <= threshold:\n                ans = min(ans, mid)\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        return ans", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        s = sum(nums)\n        lo = max(1, s // threshold)\n        hi = max(nums)\n        \n        while lo < hi:\n            mid = (lo + hi) // 2\n            r = sum([math.ceil(n / mid) for n in nums])\n            if r > threshold:\n                lo = mid + 1\n            else:\n                hi = mid\n                \n        return lo", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n\n        def get_sum(nmb):\n            if nmb == 0:\n                return False\n            val = 0\n            for num in nums:\n                val += math.ceil(num/nmb)\n            return val \n        \n        left, right = 1, max(nums)\n        while left <= right:\n            mid = (left + right) // 2 \n            if get_sum(mid) > threshold:\n                left = mid+1\n            else:\n                right = mid-1\n\n        return right+1 if get_sum(right+1) else right\n    \n       \n    \n#     def get_sum(self, divisor, nums):\n#         res = 0\n#         for n in nums:\n#             tmp = n // divisor\n#             if tmp * divisor < n:\n#                 tmp += 1\n            \n#             res += tmp\n        \n#         return res\n    \n#         def chk(nmb):\n#             if nmb == 0:\n#                 return False\n#             val = 0\n#             for num in nums:\n#                 val += math.ceil(num/nmb)\n#                 if val > threshold:\n#                     return False\n#             return True\n            \n\n                \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def get_sum(d):\n            ans = 0\n            for n in nums:\n                ans += math.ceil(n/d)\n            return ans\n        \n        l, r = 1, max(nums)\n        ans = 0\n        \n        while l < r:\n            m = (l + r) // 2\n            test = get_sum(m)\n            if test <= threshold:\n                ans = m\n                r = m\n            else:\n                l = m + 1\n        return l\n    \n", "from numpy import array, ceil\n\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        nums = array(nums)\n        l, r = 1, max(nums)\n        while l < r:\n            mid = (l+r)//2\n            if sum(ceil(nums / mid)) <= threshold:\n                r = mid\n            else:\n                l = mid + 1\n        return r", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n\n        def get_sum(nmb):\n            if nmb == 0:\n                return False\n            val = 0\n            for num in nums:\n                val += math.ceil(num/nmb)\n            return val \n        \n        left, right = 1, max(nums)\n        while left <= right:\n            mid = (left + right) // 2 \n            if get_sum(mid) > threshold:\n                left = mid+1\n            else:\n                right = mid-1\n\n        if get_sum(left) <= threshold:\n            return left\n        return right\n    \n       \n    \n#     def get_sum(self, divisor, nums):\n#         res = 0\n#         for n in nums:\n#             tmp = n // divisor\n#             if tmp * divisor < n:\n#                 tmp += 1\n            \n#             res += tmp\n        \n#         return res\n    \n#         def chk(nmb):\n#             if nmb == 0:\n#                 return False\n#             val = 0\n#             for num in nums:\n#                 val += math.ceil(num/nmb)\n#                 if val > threshold:\n#                     return False\n#             return True\n            \n#         high = max(nums)\n#         low = high//threshold \n#         while low <= high:\n#             mid = (low + high)//2\n            \n#             if chk(mid):\n#                 high = mid - 1\n#             elif not chk(mid):\n#                 low = mid + 1\n#         return low-1 if chk(low-1) else high+1\n                \n", "import numpy as np\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        Nums = np.array(nums)\n        low = 1\n        high = np.max(Nums)\n        min_num = np.max(Nums)\n        Sum = 0\n        while low <= high:\n            mid = np.ceil((low + high) / 2)\n            Sum = np.sum(np.ceil(Nums/mid))\n            if Sum <= threshold:\n                min_num = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        return int(min_num)\n    \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        l = 1\n        r = max(nums)\n        \n        def helper(arr,mid,threshold):\n            return sum([math.ceil(num/mid) for num in arr])<=threshold\n        \n        while l<=r:\n            mid = (l+r)//2\n            if helper(nums,mid,threshold):\n                r = mid-1\n            else:\n                l = mid+1\n        return l", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        left, right = 1, max(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            divided = sum([num//mid + int(num%mid > 0) for num in nums])\n            # print(mid, divided, threshold)\n            if divided > threshold:\n                left = mid + 1\n            else:\n                right = mid\n        return right\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        low=1\n        high=max(nums)\n        n=len(nums)\n        while(low<high):\n            mid=low+(high-low)//2\n            s=0\n            for i in range(n):\n                \n                s+=math.ceil(nums[i]/mid)\n            if(s>threshold):\n                low=mid+1\n            else:\n                high=mid\n        return high  \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def enough(x):\n            cnt = 0\n            for num in nums:\n                cnt += int(num//x) + (num%x > 0)\n            return cnt <= threshold\n        \n        left, right = 1, max(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if enough(mid):\n                right = mid\n            else:\n                left = mid+1\n        return left", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        def calculate(divisor):\n            _sum=0\n            for val in nums:\n                _sum+=val//divisor + int(val%divisor!=0)\n            return _sum\n        \n        \n        start,end=1,max(nums)\n        while start<end:\n            mid=start+(end-start)//2\n            _sum=calculate(mid)\n            if _sum>threshold:\n                start=mid+1\n            else:\n                end=mid\n        return start\n            \n", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def ok(mid):\n            ans = 0\n            for num in nums:\n                ans += math.ceil(num / mid)\n                if ans > threshold: return False\n            return True    \n        l, r = 1, int(1e6)\n        while l <= r:\n            mid = (l+r) // 2\n            if ok(mid): r = mid - 1\n            else: l = mid + 1\n        return l        \n#         nums.sort()\n        \n#         v1 = sum(nums)\n#         v2 = len(nums)\n#         if v1<= threshold:\n#             return 1\n#         l = 1\n#         u = max(nums)\n        \n#         addl = []\n#         while l+1<u: \n#             print(l,u)\n#             mid = (l+u)//2  \n#             print('mid',mid)\n#             add = 0\n#             for i in range(len(nums)):\n#                 add = add + math.ceil(nums[i]/mid) \n#             print(add)\n            \n#             if add>threshold:\n#                 l = mid\n#             elif add == threshold:\n#                 return mid\n#             else:\n#                 addl.append(mid)\n#                 u = mid\n                \n#         return min(addl\n    \n    \n                \n                \n                \n                \n            \n            \n        \n", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        # max = 0\n        # for j in range(threshold):\n        #     count = 0\n        #     for i in range(len(nums)):\n        #         a = nums[i]/(j+1)\n        #         count += math.ceil(a)\n        #     print(count)\n        #     if count <= threshold:\n        #         if max < count:\n        #             max = count\n        # return j\n        def checking(mid):\n            ans = 0\n            for num in nums:\n                ans += math.ceil(num/mid)\n                if ans > threshold:\n                    return False\n            return True\n        l, r = 1, int(1e6)\n        while l<= r:\n            mid = (l+r)//2\n            if checking(mid):\n                r = mid-1\n            else:\n                l = mid+1\n        return l\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        #res=sum(nums)\n        #print(1//5)\n        #n=max(nums)+1\n        #print(int(1e6))\n        def dfs(m):\n            r=0\n            for i in nums:\n                r+=math.ceil(i/m)\n                if r>threshold:\n                    return False\n            return True\n        l,r=1,int(1e6)\n        while l<=r:\n            m=(l+r)//2\n            if dfs(m):\n                r=m-1\n            else:\n                l=m+1\n        return l\n        '''\n        for i in range(1,max(nums)):\n            r=0\n            n-=1\n            for j in nums:\n                if j%i==0:\n                    r+=j//i\n                else:\n                    r+=(j//i)+1\n            if r<=threshold:\n                return i\n        '''\n        #return res\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        r = max(nums)\n        l = 1\n        \n        def calc(div):\n            s = sum([(num + div - 1) // div for num in nums])\n            return s <= threshold\n        \n        while l < r:\n            mid = (l + r) // 2\n            val = calc(mid)\n            # print (\\\"[%d, %d] => %d v %r\\\" %(l, r, mid, val))\n            \n            if calc(mid):\n                r = mid\n            else:\n                l = mid + 1\n        \n        return l\n                \n        \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def bs(mid):\n            sum_val = 0\n            for i in nums:\n                sum_val+=math.ceil(i/mid)\n                if sum_val > threshold:\n                    return False\n            return True\n        l =1\n        r = 10**6\n        while l<=r:\n            mid = (l+r)//2\n            if bs(mid):\n                r = mid-1\n            else:\n                l=mid+1\n        return l\n", "from numpy import array, ceil, sum\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        nums = array(nums)\n        l, r = 1, max(nums)\n        while l < r:\n            mid = (l+r)//2\n            if sum(ceil(nums / mid)) <= threshold:\n                r = mid\n            else:\n                l = mid + 1\n        return r\n", "import math\ndef divisor(l, n):\n    ans = 0\n    \n    for i in l:\n        ans += math.ceil(i/n)\n    return ans\n\n\nclass Solution:\n    def smallestDivisor(self, l: List[int], t: int) -> int:\n        if sum(l)<=t:\n            return 1\n        s = sum(l)\n        ans = 0\n        x = 0\n        i = 1\n        j = 1\n        while(x<t):\n            j = i\n            x = divisor(l, i)\n            if x<t:\n                i *= 2 \n            else:\n                break\n        mid = 0\n        j = max(l)\n        p = -1\n        # print(i, j)\n        \n        while(i<j):\n            \n            mid = (i+j)//2\n            x = divisor(l, mid)\n            # print('mid',x, mid)                \n            if x<t:\n                j = mid\n            elif x == t:\n                break\n            else:\n                i = mid+1\n            if i == j:\n                mid = j\n                break\n        \n        while(1):\n            # print(mid)\n            x = divisor(l, mid-1)\n            if x <= t:\n                mid -= 1\n            else:\n                break\n                \n        return mid\n                \n                        \n        \n        \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def ok(mid):\n            ans = 0\n            for num in nums:\n                ans += math.ceil(num / mid)\n                if ans > threshold: return False\n            return True    \n        l, r = 1, int(1e6)\n        while l <= r:\n            mid = (l+r) // 2\n            if ok(mid): r = mid - 1\n            else: l = mid + 1\n        return l    ", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def check(div):\n            # print(sum([elem/div if elem % div == 0 else (elem//div)+1 for elem in nums]))\n            return threshold >= sum([elem/div if elem % div == 0 else (elem//div)+1 for elem in nums])\n        \n        def bst(low,high):\n            # print(low,high)\n            mid = (low+high) // 2\n            if low > high:\n                return -1\n            elif low == high:\n                if check(low):\n                    return low\n                else:\n                    return -1\n            else:\n                if check(mid):\n                    ambition = bst(low,mid-1)\n                    if ambition != -1:\n                        return ambition\n                    else:\n                        return mid\n                else:\n                    return bst(mid+1,high)\n                \n        return bst(1,10**9)\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        start = 1\n        end = max(nums)\n        \n        while start <= end:\n            mid = (start + end) // 2\n            result = self.satistfy(nums, mid)\n\n            if result <= threshold:\n                end = mid - 1\n            else:\n                start = mid + 1\n\n        return start\n    \n    def satistfy(self, nums, mid):\n        return sum(list([math.ceil(x/mid) for x in nums]))\n        \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        start = 1\n        end = max(nums)\n        \n        while start+1 < end:\n            mid = (start + end) // 2\n            result = sum(list([math.ceil(x/mid) for x in nums]))\n\n            if result <= threshold:\n                end = mid\n            else:\n                start = mid\n\n        if sum(list([math.ceil(x/start) for x in nums])) <= threshold:\n            return start\n        return end\n        \n", "import math\n\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        if not nums:\n            return sys.maxsize\n        left, right = 1, 2\n        while right < sys.maxsize and self.get_sum(nums, right) > threshold:\n            left, right = right, right * 10\n\n        \n        while left + 1 < right:\n            mid = (left + right) // 2\n            if self.get_sum(nums, mid) <= threshold:\n                right = mid\n            else:\n                left = mid\n        if self.get_sum(nums, left) <= threshold:\n            return left\n        return right\n    \n    def get_sum(self, nums: List[int], divisor: int) -> int:\n        result = 0\n        for num in nums:\n            result += math.ceil(num / divisor)\n        return int(result)", "import math\n\ndef divide_and_sum(nums, divisor):\n    return sum([math.ceil(x / divisor) for x in nums])\n\nclass Solution:\n    def smallestDivisor(self, nums, threshold):\n        start = max(nums)\n        end = 1\n\n        assert divide_and_sum(nums, start) <= threshold, 'impossible, threshold is guaranteed to be at least len(nums)'\n        if divide_and_sum(nums, end) <= threshold:\n            # there are no divisors smaller than 1\n            return end\n\n        # loop invariant:\n        # dsum(nums, start) <= threshold\n        # dsum(nums, end)   > threshold\n        while start >= end:\n            mid = (start + end) // 2\n            dsum = divide_and_sum(nums, mid)\n            if dsum == threshold:\n                #print('case 1')\n                while divide_and_sum(nums, mid) == threshold:\n                    mid -= 1\n                return mid + 1\n            if dsum > threshold:\n                # divisor is too small\n                end = mid + 1\n            if dsum < threshold:\n                # threshold is too large\n                start = mid - 1\n        #print('case 2')\n        return end\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        start = 1\n        end = max(nums)\n        \n        while start+1 < end:\n            mid = (start + end) // 2\n            result = self.satistfy(nums, mid)\n\n            if result <= threshold:\n                end = mid\n            else:\n                start = mid\n\n        if self.satistfy(nums, start) <= threshold:\n            return start\n        return end\n    \n    \n    def satistfy(self, nums, mid):\n        return sum(list([math.ceil(x/mid) for x in nums]))\n        \n", "'''\nBinary search to find the best divisor that doesn't go through the threshold\n'''\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        def ok(divisor):\n            sol = 0\n            for n in nums:\n                sol += ceil(n / divisor)\n            return sol <= threshold\n                \n        lo = 1\n        hi = max(nums)\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            # if current is okay, we have to go higher lower\n            if ok(mid):\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return lo\n                \n                \n            \n            \n    \n", "from numpy import array, ceil, sum\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        nums = array(nums)\n        l, r = int(ceil(sum(nums)/threshold)), max(nums)\n        \n        while l < r:\n            mid = (l+r)//2\n            if sum(ceil(nums/mid)) <= threshold:\n                r = mid\n            else:\n                l = mid + 1\n        \n        return r", "import math\n\ndef divide_and_sum(nums, divisor):\n    return sum([math.ceil(x / divisor) for x in nums])\n\nclass Solution:\n    def smallestDivisor(self, nums, threshold):\n        start = max(nums)\n        end = 1\n\n        assert divide_and_sum(nums, start) <= threshold, 'impossible, threshold is guaranteed to be at least len(nums)'\n        if divide_and_sum(nums, end) <= threshold:\n            # there are no divisors smaller than 1\n            return end\n\n        # loop invariant:\n        # dsum(nums, start) <= threshold\n        # dsum(nums, end)   >= threshold\n        while start >= end:\n            mid = (start + end) // 2\n            dsum = divide_and_sum(nums, mid)\n            if dsum == threshold:\n                #print('case 1')\n                mid -= 1\n                while divide_and_sum(nums, mid) == threshold:\n                    mid -= 1\n                return mid + 1\n            if dsum > threshold:\n                # divisor is too small\n                end = mid + 1\n            if dsum < threshold:\n                # threshold is too large\n                start = mid - 1\n        #print('case 2')\n        #loop exit condition:\n        #start < end\n        #dsum(nums, start) <= threshold\n        #dsum(nums, end)   >= threshold\n        print((start, end, divide_and_sum(nums, start), divide_and_sum(nums, end)))\n        return end\n", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], t: int) -> int:\n        def mine2(n,nums):\n            nums_copy = nums[:]\n            nums_copy = list([math.ceil(x/n) for x in nums_copy])\n            return sum(nums_copy)\n        def mine(left,right,nums,t,l):\n            if(right>left):\n                mid = (left+right)//2\n                if(mine2(mid,nums)<=t):\n                    right = mid-1\n                    l.append(mid)\n                else:\n                    left = mid+1\n                return mine(left,right,nums,t,l)\n            else:\n                if(left>0):\n                    if(mine2(left,nums)<=t):\n                        l.append(left)\n                if(right>0):\n                    if(mine2(right,nums)<=t):\n                        l.append(right)\n                return l\n                \n                \n                \n        \n        l = []\n        return min(mine(1,max(nums),nums,t,l))\n", "# Binary Search\nimport math\n\nclass Solution:\n    def smallestDivisor(self, nums, threshold):\n\n        nums.sort()\n        # you can take hi=10^6 as well\n        # but hi=max_element, will also be correct\n        # because nums.length <= threshold\n        ans = float('+INF')\n        lo, hi = 1, nums[-1]\n        while lo<=hi:\n            mid = lo + (hi-lo)//2\n            if self.div(nums, mid) <= threshold:\n                ans = min(ans, mid)\n                hi = mid-1\n            else:\n                lo = mid+1\n        \n        return ans\n\n    def div(self, nums, mid):\n        t_sum=0\n        for i in nums:\n            t_sum += int(math.ceil(i/mid))\n        return t_sum\n\n\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        # sm = sum(nums)\n        # strt = sm//threshold\n        \n        # search_space = list(range(max(strt,1),sm))\n        # n = len(search_space)\n        l = 1\n        r = max(nums)\n        while(l+1<r):\n            mid = l+(r-l)//2\n            \n            # if self.search(nums,search_space[mid],threshold)  == 0:\n            #     return search_space[mid]\n            if self.search(nums,mid,threshold) > 0:\n                r = mid\n            elif self.search(nums,mid,threshold) < 0:\n                l = mid\n        \n        # print(search_space[l],search_space[r])\n        if self.search(nums,l,threshold) >= 0:\n            return l\n        else:\n            return r\n        # print(search_space[l],search_space[r])\n            \n        \n            \n            \n    def search(self,nums,i,threshold):\n    \n        insum = sum([math.ceil(el/i) for el in nums])\n        # print(i,insum)\n        \n        # if insum == threshold:\n        #     return 0\n        if insum <= threshold:\n            return 1\n        else:\n            return -1\n            \n", "class Solution:\n    \n    def check(self,divisor,nums,threshold):\n        result = 0\n        for number in nums:\n            k = int(number/divisor)\n            if number % divisor != 0:\n                k +=1\n            result += k\n            if result > threshold:\n                return False\n        return True\n        \n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        low = 1\n        high = max(nums)\n        while low <= high:\n            mid = int((low+high)/2)\n            if self.check(mid,nums,threshold):\n                high = mid -1\n            else:\n                low = mid+1\n        return low\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        sm = sum(nums)\n        # strt = sm//threshold\n        \n        # search_space = list(range(max(strt,1),sm))\n        # n = len(search_space)\n        l = max(sm//threshold,1)\n        r = max(nums)\n        while(l+1<r):\n            mid = l+(r-l)//2\n            \n            if self.search(nums,mid,threshold) > 0:\n                r = mid\n            elif self.search(nums,mid,threshold) < 0:\n                l = mid+1\n        \n        if self.search(nums,l,threshold) >= 0:\n            return l\n        else:\n            return r\n        # print(search_space[l],search_space[r])\n            \n        \n            \n            \n    def search(self,nums,i,threshold):\n    \n        insum = sum([math.ceil(el/i) for el in nums])\n        if insum <= threshold:\n            return 1\n        else:\n            return -1\n            \n", "class Solution:\n    def divide(self, num, divisor):\n        return -((-num)//divisor)\n    \n    def getQuotient(self, nums, divisor):\n        output = 0\n        for num in nums:\n            output += self.divide(num, divisor)\n        return output\n    \n    def getResult(self, results, divisor, nums):\n        if divisor in results:\n            return results[divisor]\n        else:\n            results[divisor] = self.getQuotient(nums, divisor)\n            return results[divisor]\n    \n    def helper(self, results, nums, i, j, threshold):\n        if i == j:\n            return i\n        \n        mid = (i+j)//2\n        if mid == 1:\n            return mid\n        elif self.getResult(results, mid, nums) <= threshold and self.getResult(results, mid-1, nums) > threshold:\n            return mid\n        elif self.getResult(results, mid, nums) <= threshold:\n            return self.helper(results, nums, i, mid-1, threshold)\n        else:\n            return self.helper(results, nums, mid+1, j, threshold)\n    \n\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        maxDivisor = self.divide(2*sum(nums), threshold)\n        #print(maxDivisor)\n        #maxDivisor = 1000000\n        results = dict()\n        \n        return self.helper(results, nums, 1, maxDivisor, threshold)\n", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n\n        def chk(nmb):\n            if nmb == 0:\n                return False\n            val = 0\n            for num in nums:\n                val += math.ceil(num/nmb)\n            return val <= threshold\n        \n        high = max(nums)\n        low = high//threshold \n        while low <= high:\n            mid = (low + high)//2\n            \n            if chk(mid):\n                high = mid - 1\n            elif not chk(mid):\n                low = mid + 1\n        return high+1 if chk(high+1) else high\n    \n       \n    \n#     def get_sum(self, divisor, nums):\n#         res = 0\n#         for n in nums:\n#             tmp = n // divisor\n#             if tmp * divisor < n:\n#                 tmp += 1\n            \n#             res += tmp\n        \n#         return res\n    \n#         def chk(nmb):\n#             if nmb == 0:\n#                 return False\n#             val = 0\n#             for num in nums:\n#                 val += math.ceil(num/nmb)\n#                 if val > threshold:\n#                     return False\n#             return True\n            \n\n                \n", "from math import ceil\n\ndef eval(nums, i, thold):\n    s1 = 0\n    for num in nums:\n        s1 += ceil(num / i)\n    if s1 <= thold:\n        return True\n    return False\n\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        lo, hi = 1, 100000000000\n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if eval(nums, mid, threshold):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo\n", "# class Solution:\n#     def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n\n#         def check(divisor):\n#             res = 0\n#             for num in nums:\n#                 if num % divisor == 0:\n#                     res += num // divisor\n#                 else:\n#                     res += (num // divisor) + 1\n#             if res <= threshold:\n#                 return True\n#             return False\n        \n#         left = 1\n#         right = 1000000 #\u6700\u5927\u5143\u7d20700ms\n#         # right = 1 800ms\n#         # for num in nums:\n#         #     right = max(right, num)\n#         while left < right:\n#             mid = (left + right) >> 1\n#             if check(mid) == True:\n#                 right = mid\n#             else:\n#                 left = mid+1\n                \n#         return left\n\nfrom numpy import array, ceil, sum\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        nums = array(nums)\n        l, r = 1, max(nums)\n        while l < r:\n            mid = (l+r)//2\n            if sum(ceil(nums / mid)) <= threshold:\n                r = mid\n            else:\n                l = mid + 1\n        return r", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        self.nums = nums\n        self.threshold = threshold\n        num_sum = sum(nums)\n        l = math.floor(num_sum / threshold)-1\n        h = num_sum\n        m = math.ceil((l+h) / 2)\n        while h != m:\n            if self.validate_divisor(m):\n                h = m\n            else:\n                l = m\n            m = math.ceil((l+h) / 2)\n        return h\n        \n    def validate_divisor(self, divisor):\n        if divisor <= 0:\n            return False\n        s = sum(math.ceil(x / divisor) for x in self.nums)\n        return s <= self.threshold", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def isThres(m):\n            tsum = 0\n            for n in nums:\n                tsum += n // m\n                if n % m > 0:\n                    tsum += 1\n            if tsum <= threshold:\n                return True\n        \n        \n        l,r = 1, sum(nums)\n        \n        while l < r:\n            m = l + r >> 1\n            if isThres(m):\n                r = m\n            else:\n                l = m + 1\n        \n        return l", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        # binary search\n        left = 1\n        right = max(nums)\n        while left <= right:\n            mid = left + (right - left) // 2\n            mid_left_result = self.divide_and_sum(mid - 1, nums)\n            mid_result = self.divide_and_sum(mid, nums)\n            if mid_left_result > threshold and mid_result <= threshold:\n                return mid\n            # move right\n            if mid_result > threshold:\n                left = mid + 1\n            # move left\n            if mid_left_result <= threshold:\n                right = mid - 1\n\n    def divide_and_sum(self, divisor, nums):\n        if divisor == 0:\n            return math.inf\n\n        result = 0\n        for num in nums:\n            result += ceil(num / divisor)\n\n        return result", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n\n#         left, right = 1, max(nums)\n#         while left + 1 < right:\n#             mid = (left + right) // 2 \n#             if self.get_sum(mid, nums) > threshold:\n#                 left = mid\n#             else:\n#                 right = mid\n\n#         if self.get_sum(left, nums) <= threshold:\n#             return left\n#         return right\n    \n#     def get_sum(self, nmb, nums):\n#         if nmb == 0:\n#             return False\n#         val = 0\n#         for num in nums:\n#             val += math.ceil(num/nmb)\n#         return val        \n    \n#     def get_sum(self, divisor, nums):\n#         res = 0\n#         for n in nums:\n#             tmp = n // divisor\n#             if tmp * divisor < n:\n#                 tmp += 1\n            \n#             res += tmp\n        \n#         return res\n    \n        def chk(nmb):\n            if nmb == 0:\n                return False\n            val = 0\n            for num in nums:\n                val += math.ceil(num/nmb)\n                if val > threshold:\n                    return False\n            return True\n            \n        high = max(nums)\n        low = high//threshold \n        while low <= high:\n            mid = (low + high)//2\n            \n            if chk(mid):\n                high = mid - 1\n            elif not chk(mid):\n                low = mid + 1\n        return low-1 if chk(low-1) else high+1\n                \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def is_valid(select_num: int):\n            res = sum([math.ceil(num / select_num) for num in nums])\n            return None if res > threshold else res\n        \n        if not nums: return 0\n        left, right = 1, 1000000000\n        while left < right:\n            middle = (left + right) // 2\n            if is_valid(middle):\n                right = middle\n            else:\n                left = middle + 1\n        \n        return left if is_valid(left) else right\n", "class Solution:\n    \n    def find(self, nums, div):\n        ans = 0\n        for i in nums:\n            ans += i//div\n            if i%div!=0:\n                ans += 1\n        return ans\n    \n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        low = 1\n        high = max(nums)\n        while low<high:\n            mid = (low+high)//2\n            cur = self.find(nums, mid)\n            if mid>1:\n                prev = self.find(nums, mid-1)\n            else:\n                prev = 0\n            if mid == 1 and cur<=threshold:\n                return 1\n            if cur<=threshold and prev>threshold:\n                return mid\n            elif cur>threshold:\n                low = mid+1\n            elif prev<=threshold:\n                high = mid-1\n        return (low+high)//2", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        def feasible(val):\n            total = 0\n            for i in nums:\n                total += (i-1)//val + 1\n            return total <= threshold\n        \n        left,right = 1, max(nums)\n        while left < right:\n            mid = left + (right-left)//2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        r = max(nums)\n        l = 1\n        \n        def calc(div):\n            s = sum([ceil(num / div) for num in nums])\n            return s <= threshold\n        \n        while l < r:\n            mid = (l + r) // 2\n            val = calc(mid)\n            # print (\\\"[%d, %d] => %d v %r\\\" %(l, r, mid, val))\n            \n            if calc(mid):\n                r = mid\n            else:\n                l = mid + 1\n        \n        return l\n                \n        \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        s = sum(nums)\n        l = len(nums)\n        L = max((s + threshold - 1) // threshold, 1) - 1\n        # worst case: every num is just one more of multiple of answer\n        t_ = max(threshold - l, 1)\n        U = (s + t_ - 1) // t_\n        while L + 1 < U:\n            m = (L + U) // 2\n            if sum((x + m - 1) // m for x in nums) <= threshold:\n                U = m\n            else:\n                L = m\n        return U\n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        def feasible(target):\n            total = sum([math.ceil(num/target) for num in nums] )\n            return total <= threshold\n        low,high=1,sum(nums)\n        while low < high:\n            mid = low+(high-low)//2\n            if feasible(mid):\n                high = mid\n            else:\n                low = mid+1\n        return low\n            \n", "import math\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        def isDiv(mid):\n            s=0\n            for i in nums:\n                s+=math.ceil(i/mid)\n            # print(\\\"Sum\\\",s,mid)\n            return s<=threshold\n            \n    \n        def binsearch():\n            low=1\n            high=sum(nums)\n            while low<high:\n                mid=low+(high-low)//2\n                if isDiv(mid):\n                    high=mid\n                else:\n                    low=mid+1\n            return low\n        return binsearch()", "import math\n\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        if not nums:\n            return sys.maxsize\n        left, right = 1, 2\n        while right < sys.maxsize and self.get_sum(nums, right) > threshold:\n            left, right = right, right * 2\n\n        \n        while left + 1 < right:\n            mid = (left + right) // 2\n            if self.get_sum(nums, mid) <= threshold:\n                right = mid\n            else:\n                left = mid\n        if self.get_sum(nums, left) <= threshold:\n            return left\n        return right\n    \n    def get_sum(self, nums: List[int], divisor: int) -> int:\n        result = 0\n        for num in nums:\n            result += math.ceil(num / divisor)\n        return int(result)", "from math import ceil\ndef is_fine(nums,val,threshold):\n    tot = 0\n    for i in nums:\n        tot += ceil(i/val)\n    if tot <= threshold:\n        return True\n    else:\n        return False\ndef bSearch(l,r,nums,threshold):\n    if l <= r:\n        mid = (l+r)//2\n        high_val = is_fine(nums,mid,threshold)\n        low_val = is_fine(nums,mid-1,threshold)\n        if high_val is True and low_val is False:\n            return mid\n        elif high_val is False and low_val is False:\n            return bSearch(mid+1,r,nums,threshold)\n        else:\n            return bSearch(l,mid-1,nums,threshold)\n    else:\n        return None\nclass Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        if sum(nums) <= threshold:\n            return 1\n        return bSearch(2,10**6,nums,threshold)\n        \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        \n        def calc(nums, divisor):\n            s = 0\n            for num in nums:\n                if num % divisor == 0:\n                    s += num // divisor\n                else:\n                    s += num // divisor + 1\n            \n            # print(divisor, s)\n            return s\n        \n        left = 1\n        right = sum(nums) // (threshold-1) + threshold*100\n        print((left, right))\n        \n        while left < right:\n            mid = (left+right) // 2\n            \n            cur_res = calc(nums, mid)\n            if cur_res > threshold:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left\n                \n", "class Solution:\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        end = 1\n        start = end\n        def findSum(div):\n            return sum([math.ceil(n / div) for n in nums])\n        while True:\n            if findSum(end) > threshold:\n                start = end\n                end *= 2\n            else:\n                break\n        while end > start:\n            mid = (start + end) // 2\n            # print(start, end, mid, findSum(mid))\n            if findSum(mid) > threshold:\n                start = mid + 1\n            else:\n                end = mid\n        return end\n                \n"]
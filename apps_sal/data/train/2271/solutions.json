["import sys\nreadline = sys.stdin.readline\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self._par = list(range(n))\n        self.size = [1]*n\n\n    def root(self, v):\n        if self._par[v] == v:\n            return v\n        self._par[v] = self.root(self._par[v])\n        return self._par[v]\n    \n    def unite(self, u, v):\n        u, v = self.root(u), self.root(v)\n        if u==v:\n            return False\n        if self.size[u] > self.size[v]:\n            u, v = v, u\n        self.size[v] += self.size[u]\n        self._par[u] = v\n\n    def is_connected(self, u, v):\n        return self.root(u)==self.root(v)\n\nn, m = map(int, readline().split())\nP = list(map(lambda x:int(x)-1, readline().split()))\nuf = UnionFind(n)\nfor _ in range(m):\n    x, y = map(lambda x:int(x)-1, readline().split())\n    uf.unite(x,y)\n\nans = 0\nfor i in range(n):\n    if uf.is_connected(i, P[i]):\n        ans += 1\nprint(ans)", "#ARC097D Equals\ndef f(x):\n    while q[x]>=0:\n        x=q[x]\n    return x\nN, M = map(int, input().split())\np = list(map(int, input().split()))\nq = [-1]*N\nfor _ in range(M):\n    x, y = map(lambda x:f(int(x)-1), input().split())\n    if x == y: continue\n    elif x < y: x,y=y,x\n    q[x] += q[y]\n    q[y] = x\n#\u65b9\u91dd:\u5404\u6728\u306b\u5206\u5272\u3001\u5404\u6728\u5185\u306e\u4e00\u81f4\u306e\u6700\u5927\u6570\u3092\u8db3\u305b\u3070\u3088\u3044\u3002\ntree = [[] for n in range(N)]\nfor n in range(N):\n    tree[f(n)].append(n)\n    #print(f(n))\nans = 0\nfor n in range(N):\n    ans += len(set(tree[n])&{p[i]-1 for i in tree[n]})\nprint(ans)", "class UnionFind:\n    def __init__(self,n):\n        self.tree = [-1 for i in range(n)]\n        return\n \n    def union(self,x,y):\n        xroot = self.root(x)\n        yroot = self.root(y)\n        if xroot==yroot:\n            return\n        if self.tree[xroot]>self.tree[yroot]:\n            xroot,yroot = yroot,xroot\n        self.tree[xroot] += self.tree[yroot]\n        self.tree[yroot] = xroot\n        return\n \n    def root(self,x):\n        qu = []\n        while self.tree[x]>=0:\n            qu.append(x)\n            x = self.tree[x]\n        for i in qu:\n            self.tree[i] = x \n        return x\n \n    def same(self,x,y):\n        return self.root(x)==self.root(y)\n\n    def size(self):\n        arr = [0 for i in range(len(self.tree))]\n        for i in range(len(self.tree)):\n            arr[self.root(i)] += 1\n        for i in range(len(self.tree)):\n            if self.root(i)!=i:\n                arr[i] += arr[self.root(i)]\n        return arr\n\n    def getnumroots(self):\n        ans = 0\n        for i in self.tree:\n            if i<0:\n                ans += 1\n        return ans\n\n    def getelements(self):\n        arr = [-1 for i in range(len(self.tree))]\n        ans = []\n        c = 0\n        for i in range(len(self.tree)):\n            if arr[self.root(i)]==-1:\n                arr[self.root(i)] = c\n                ans.append([i])\n                c += 1\n            else:\n                ans[arr[self.root(i)]].append(i)\n        return ans \n            \n                \n\nfrom sys import stdin\ndef input():\n    return stdin.readline()\n\ndef main():\n    n,m = map(int,input().split())\n    p = list(map(int,input().split()))\n    uf = UnionFind(n)\n    ans = 0\n    for i in range(m):\n        x,y = map(int,input().split())\n        uf.union(x-1,y-1)\n    arr = uf.getelements()\n    for i in range(len(arr)):\n        temp = []\n        for j in arr[i]:\n            temp.append(p[j]-1)\n        ans += len(set(temp).intersection(arr[i]))\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import deque\nreadline = sys.stdin.readline\nn, m = map(int, readline().split())\nP = list(map(lambda x:int(x)-1, readline().split()))\nG = [set() for _ in range(n)]\nfor i in range(m):\n    x, y = map(lambda x:int(x)-1, readline().split())\n    G[x].add(y)\n    G[y].add(x)\n\nD = {}\ncnt = 0\nV = [-1]*n\nfor i in range(n):\n    if V[i]!=-1: continue\n    V[i] = cnt\n    que = deque([i])\n    D[cnt] = set([P[i]])\n    while que:\n        nw = que.popleft()\n        for nx in G[nw]:\n            if V[nx] != -1: continue\n            D[cnt].add(P[nx])\n            V[nx] = cnt\n            que.append(nx)\n    cnt += 1\nprint(sum([int(i in D[V[i]]) for i in range(n)]))", "N, M = map(int, input().split())\np = list(map(int, input().split()))\n\np = [0] + p\npar = list(range(N+1))\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n    \ndef unite(x, y):\n    if find(x) != find(y):\n        par[find(x)] = y\n        \nfor _ in range(M):\n    a, b = map(int, input().split())\n    unite(a, b)\n    \n# for i in range(1, N+1):\n#     find(i)\n\n# print(p)    #\n# print(par)  #\n\nans = 0\nfor i in range(1, N+1):\n    if find(p[i]) == find(p[p[i]]):\n        ans += 1\n#         print(ans)  #\n        \nprint(ans)", "N, M = list(map(int,input().split()))\np = list(map(int,input().split()))\nparent = [k for k in range(N)]\ndef find(x):\n    if parent[x] == x:\n        return x\n    else:\n        parent[x] = find(parent[x])\n        return find(parent[x])\ndef unite(x,y):\n    parent[find(x)] = find(y)\n\nfor _ in range(M):\n    x, y = list(map(int,input().split()))\n    unite(x-1,y-1)\nans = 0\nfor k in range(N):\n    if find(k) == find(p[k]-1):\n        ans += 1\nprint(ans)\n", "from collections import deque\n\nN, M = map(int, input().split())\nplist = list(map(int, input().split()))\n\npilist = []\nfor i, p in enumerate(plist):\n    pilist.append((p, i+1))\n\npilist.sort(key=lambda x: x[0])\n\ndic = {k: [] for k in range(N+1)}\nfor _ in range(M):\n    x, y = map(int, input().split())\n    dic[plist[x-1]].append(plist[y-1])\n    dic[plist[y-1]].append(plist[x-1])\ngroups = []\ndone = [0] * (N+1)\nfor p in range(1, N+1):\n    if done[p]==0:\n        done[p] = 1\n        group_p = [p]\n        group_i = [pilist[p-1][1]]\n        queue = deque([p])\n        while queue:\n            q = queue.pop()\n            for q_n in dic[q]:\n                if done[q_n]==0:\n                    done[q_n] = 1\n                    group_p.append(q_n)\n                    group_i.append(pilist[q_n-1][1])\n                    queue.append(q_n)\n        groups.append((group_p, group_i))\n\nans = 0\nfor group in groups:\n    p = set(group[0])\n    i = set(group[1])\n    ans += len(p & i)\nprint(ans)", "n, m = map(int, input().split())\npn = list(map(lambda x:int(x)-1, input().split()))\nls = [-1] * n\nfor i in pn:\n    ls[pn[i]] = i\n#print(ls)\n\npar = [i for i in range(n)]\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        s = find(par[x])\n        par[x] = s\n        return s\n\ndef unite(x,y):\n    s = find(x)\n    t = find(y)\n    if s>t:\n        par[s] = t\n    else:\n        par[t] = s\n\n\nfor _ in range(m):\n    x, y = map(lambda x:int(x)-1, input().split())\n    unite(ls[x],ls[y])\n\n\nans2 = 0\nfor i in range(n): # i\u756a\u76ee\u306e\u6570\u5b57\u304c\u3044\u308b\u5834\u6240\u306e\u89aa\u3068i\u306e\u5834\u6240\n    place1 = ls[pn[i]]\n    place2 = ls[i]\n\n    if find(place1)==find(place2):\n       ans2+=1\nprint(ans2)", "import sys,math,collections,itertools\ninput = sys.stdin.readline\n\nN,M=list(map(int,input().split()))\nP = list(map(int,input().split()))\nbridge = [[] for i in range(N+1)]\nfor _ in range(M):\n    x,y = list(map(int,input().split()))\n    bridge[x].append(y)\n    bridge[y].append(x)\n#-\u884c\u304d\u6765\u3067\u304d\u308b\u6570\u5b57\u306e\u7d44\u307f\u5408\u308f\u305b\u3092\u4f5c\u308b-#\nmemo = [-1]*(N+1)\nq = collections.deque([])\nnovisit = set(range(1,N+1))\ntmp = 0\nwhile novisit:\n    q.append(novisit.pop())\n    tmp+=1\n    while q:\n        now = q.pop()\n        memo[now]=tmp\n        for bri in bridge[now]:\n            if bri in novisit:\n                q.append(bri)\n                novisit.discard(bri)\n#-memo\u304c\u540c\u3058\u6570\u5b57\u3060\u3063\u305f\u3089\u5165\u308c\u66ff\u3048\u53ef\u80fd-#\ncnt = 0\nfor i in range(N):\n    if i+1 == P[i]:\n        cnt += 1\n    elif i+1 != P[i] and memo[P[i]] == memo[i+1] :\n        cnt += 1\nprint(cnt)\n", "N,M=map(int,input().split())\n*P,=map(int,input().split())\nxy=[list(map(int,input().split()))for _ in range(M)]\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\nuf=UnionFind(N)\nfor x,y in xy:\n    uf.union(x-1,y-1)\nans=sum(uf.find(i)==uf.find(P[i]-1)for i in range(N))\nprint(ans)", "def find(x):\n    '''\n    x\u306e\u6839\u3092\u6c42\u3081\u308b\n    '''\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\n\ndef union(x, y):\n    '''\n    x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u4f75\u5408\n    '''\n    x = find(x)\n    y = find(y)\n    \n    if x == y:\n        return\n\n    if par[x] > par[y]:\n        x, y = y, x\n\n    par[x] += par[y]\n    par[y] = x\n\n\ndef size(x):\n    '''\n    x\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u500b\u6570\n    '''\n    return -par[find(x)]\n\n\ndef same(x, y):\n    '''\n    x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u306e\u5224\u5b9a\n    '''\n    return find(x) == find(y)\n\n\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\npar = [-1] * n\n\npos = [-1] * n\nfor i in range(n):\n    pos[p[i]-1] = i\n\nfor _ in range(m):\n    x, y = map(int, input().split())\n    union(x-1, y-1)\n\nres = 0\nfor i in range(n):\n    if same(i, pos[i]):\n        res += 1\n\nprint(res)", "#Union Find\nclass union_find:\n    #\u521d\u671f\u5316\n    #\u6839\u306a\u3089-size,\u5b50\u306a\u3089\u89aa\u306e\u9802\u70b9\n    # par = [-1]*N\n    def __init__(self, N):\n        self.par = [-1]*N\n\n    #x\u306e\u6839\u3092\u6c42\u3081\u308b\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    #x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u4f75\u5408\n    def unite(self, x,y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return False\n        else:\n            #size\u306e\u5927\u304d\u3044\u307b\u3046\u304cx\n            if self.par[x] > self.par[y]:\n                x,y = y,x\n            self.par[x] += self.par[y]\n            self.par[y] = x\n            return True\n\n    #x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u306e\u5224\u5b9a\n    def same(self, x,y):\n        return self.find(x) == self.find(y)\n\n    #x\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u500b\u6570\n    def size(self, x):\n        return -self.par[self.find(x)]\n\nN, M = map(int, input().split())\nP = list(map(lambda x:int(x)-1, input().split()))\nuf = union_find(N)\nfor _ in range(M):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    uf.unite(x, y) \n\nans = 0\nfor i in range(N):\n    if uf.same(P[i], i):\n        ans += 1\nprint(ans)", "n,m= map(int,input().split())\npar = [-1]*(n)\ndef find(x):\n    if par[x]<0:return x\n    else:\n        par[x]=find(par[x])\n        return par[x]\ndef unite(x,y):\n    px,py=find(x),find(y)\n    if px==py:return False\n    else:\n        if px<py:px,py=py,px\n        par[px]+=par[py]\n        par[py]=px\n        return True\np= list(map(int,input().split()))\ngl=[[] for _ in range(n)]\nfor i in range(m):\n    x,y= map(int,input().split())\n    unite(x-1,y-1)\nfor c in range(n):#par:\n    ap=find(c)\n    gl[ap].append(c)\ng=0\nfor sg in gl:\n    temp=[p[index]-1 for index in sg]\n    newset = set(sg) & set(temp)\n    g+=len(newset)\nprint(g)", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\ndef slove():\n    N, M = map(int,input().split())\n    u = UnionFind(N)\n    P = list(map(int,input().split()))\n    for _ in range(M):\n        x, y = map(int,input().split())\n        u.union(x-1,y-1)\n    ans = 0\n    for i,p in enumerate(P):\n        if p-1 in u.members(i):\n            ans += 1\n    print(ans)\n\ndef slove2():\n    N, M = map(int,input().split())\n    P = list(map(int,input().split()))\n    l = list(range(N+1))\n    def find(p):\n        if l[p] == p:\n            return p\n        else:\n            l[p] = find(l[p])\n            return l[p]\n    for _ in range(M):\n        x, y = map(int,input().split())\n        x = find(x)\n        y = find(y)\n        if x > y:\n            x, y = y, x\n        l[y] = find(x)\n    ans = 0\n    for i,p in enumerate(P):\n        if find(i+1) == find(p):\n            ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    #slove()\n    slove2()\n__starting_point()", "n,m=map(int,input().split())\nP=[i-1 for i in list(map(int,input().split()))]\n\nclass UnionFind():\n    def __init__(self,num):\n        self.n = num         #class\u5185\u5909\u6570n\u306b\u3001\u5916\u90e8\u304b\u3089\u5165\u529b\u3057\u305f\u5024num\u3092\u4ee3\u5165\n        self.parents = [-1 for i in range(self.n)]\n          #parents\u306f\u8981\u7d20\u306e\u89aa(1\u3053\u4e0a\u306e\u3084\u3064)\u756a\u53f70~n-1\u3092\u683c\u7d0d\u3001\u81ea\u5206\u304c\u6700\u89aa\u306a\u3089-(\u8981\u7d20\u6570)\u3092\u683c\u7d0d(\u521d\u671f\u5024\u306f-1)\n\n    #x\u306e\u6700\u89aa\u306f\u8ab0\uff1f\n    def find(self,x):\n        if self.parents[x]<0:\n            return x\n        else:\n            self.parents[x]=self.find(self.parents[x]) #\u518d\u5e30\u3057\u30661\u756a\u4e0a\u307e\u3067\u3044\u3063\u3066\u308b\n                #\u8abf\u3079\u306a\u304c\u3089parents\u306e\u5024\u3092\u66f4\u65b0\u3057\u3066\u308b\uff01\uff08\u7d4c\u8def\u5727\u7e2e\uff09\n            return self.parents[x]\n\n    #\u7d50\u5408\u305b\u3088\n    #x\u306e\u89aa\u3068y\u306e\u89aa\u3092\u304f\u3063\u3064\u3051\u308b\n    def union(self,x,y):\n        xx=self.find(x)  #xx\u306fx\u306e\u6700\u89aa\n        yy=self.find(y)  #yy\u306fy\u306e\u6700\u89aa\n        if xx==yy:\n            return     #\u540c\u3058\u5c4b\u6839\u306e\u4e0b\u306b\u3042\u3063\u305f\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044\n        else:\n            size_xx=abs(self.parents[xx]) #x\u304c\u542b\u307e\u308c\u308b\u6728\u306e\u30b5\u30a4\u30ba\n            size_yy=abs(self.parents[yy]) #y\u304c\u542b\u307e\u308c\u308b\u6728\u306e\u30b5\u30a4\u30ba\n            if size_xx>size_yy:\n                xx,yy=yy,xx  #yy\u306e\u65b9\u304c\u5927\u304d\u3044\u6728\u3001\u3063\u3066\u3053\u3068\u306b\u3059\u308b\n\n            self.parents[yy]+=self.parents[xx] #\u5927\u304d\u3044\u6728\u306e\u30b5\u30a4\u30ba\u66f4\u65b0\n            self.parents[xx]=yy   #\u30b5\u30a4\u30ba\u304c\u5c0f\u3055\u3044\u6728\u3092\u5927\u304d\u3044\u6728\u306b\u63a5\u3050\n\n    #x\u306e\u5c5e\u3059\u308b\u6728\u306e\u5927\u304d\u3055\uff08\u307e\u3042union\u3067\u3082\u4f7f\u3063\u305f\u3051\u3069\uff09\n    def size(self,x):\n        xx=self.find(x)\n        return abs(self.parents[xx])\n\n    #x\u3068y\u306f\u3053\u306e\u7a7a\u306e\u7d9a\u304f\u5834\u6240\u306b\u3044\u307e\u3059\u304b\u3000\u3044\u3064\u3082\u306e\u3088\u3046\u306b\u7b11\u9854\u3067\u3044\u3066\u304f\u308c\u307e\u3059\u304b\u3000\u4eca\u306f\u305f\u3060\u305d\u308c\u3092\u9858\u3044\u7d9a\u3051\u308b\n    def same(self,x,y):\n        return 1 if self.find(x)==self.find(y) else 0\n\n    #x\u3068\u3000\u540c\u3058\u6728\u306b\u3044\u308b\u3000\u30e1\u30f3\u30d0\u30fc\u306f\uff1f\n    def members(self,x):\n        xx=self.find(x)\n        return [i for i in range(self.n) if self.find(i)==xx]\n             #if\u306e\u6761\u4ef6\u5f0f\u306b\u6f0f\u308c\u305f\u3089\u7121\u8996\n\n    #\u6700\u89aa\u3060\u3051\u3092\u4e26\u3079\u3042\u3052\u308b\n    def roots(self):\n        return [i for i,x in enumerate(self.parents) if x < 0]\n        #\u3044\u3084\u3053\u308c\u306f\u5929\u624d\u3059\u304e\u308b\u3001basis\u306eenumerate.py\u53c2\u7167\n\n    #\u3059\u3079\u3066\u306e\u6700\u89aa\u306b\u3064\u3044\u3066\u3001\u30e1\u30f3\u30d0\u30fc\u3092\u8f9e\u66f8\u3067\n    def all_group_members(self):\n        return {r:self.members(r) for r in self.roots()}\n\n    #\u30b0\u30eb\u30fc\u30d7\u5206\u3051\u3069\u3046\u306a\u308a\u307e\u3057\u305f\u304b\u3001\uff12\u91cd\u30ea\u30b9\u30c8\u3067\n    def state_grouping(self):\n        return list(self.all_group_members().values())\n\n\nuf=UnionFind(n)\nfor i in range(m):\n    a,b=map(int,input().split())\n    a-=1;b-=1\n    uf.union(a,b)\nans=0\nfor i in range(n):\n    ans+= uf.same(i,P[i])\nprint(ans)", "from collections import deque\n\nn, m = map(int, input().split())\nplst = list(map(int, input().split()))\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    edges[x].append(y)\n    edges[y].append(x)\n    \ncheck = [False for _ in range(n)]\nuni = [0 for _ in range(n)]\npos = 0\nqueue = deque()\nfor i in range(n):\n    if check[i]:\n        continue\n    pos += 1\n    queue.append(i)\n    check[i] = True\n    while queue:\n        now = queue.popleft()\n        uni[now] += pos\n        uni[plst[now] - 1] -= pos\n        for aft in edges[now]:\n            if check[aft]:\n                continue\n            check[aft] = True\n            queue.append(aft)\nprint(uni.count(0))", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def all_group_members(self):\n        return [set(self.members(r)) for r in self.roots()]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef main():\n    n, m = list(map(int, input().split()))\n    P = list([int(x) - 1 for x in input().split()])\n    uf = UnionFind(n)\n    for _ in range(m):\n        x, y = [int(x) - 1 for x in input().split()]\n        uf.union(x, y)\n    ans = 0\n    for i, p in enumerate(P):\n        if uf.same(i, p):\n            ans += 1\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nn,m = map(int, input().split())\np= list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n  a, b = map(int, input().split())\n  g[a-1].append(b-1)\n  g[b-1].append(a-1)\nv = [-1 for i in range(n)]\ns = 0\nfor i in range(n):\n  if v[i]!=-1:\n    continue\n  s+=1\n  v[i]=s\n  d = deque([i])\n  while len(d):\n    x = d.popleft()\n    for i in g[x]:\n      if v[i] == -1:\n        d.append(i)\n        v[i]=s\nans=0\nfor i in range(n):\n  if v[i]==v[p[i]-1]:\n    ans+=1\nprint(ans)", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n)) #\u89aa\u30ce\u30fc\u30c9\n        self.size = [1]*n #\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\n \n    def root(self, x): #root(x): x\u306e\u6839\u30ce\u30fc\u30c9\u3092\u8fd4\u3059\uff0e\n        while self.parent[x] != x:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x \n \n    def merge(self, x, y): #merge(x,y): x\u306e\u3044\u308b\u7d44\u3068y\u306e\u3044\u308b\u7d44\u3092\u307e\u3068\u3081\u308b\n        x, y = self.root(x), self.root(y)\n        if x == y: return False\n        if self.size[x] < self.size[y]: x,y=y,x #x\u306e\u8981\u7d20\u6570\u304c\u5927\u304d\u3044\u3088\u3046\u306b\n        self.size[x] += self.size[y] #x\u306e\u8981\u7d20\u6570\u3092\u66f4\u65b0\n        self.parent[y] = x #y\u3092x\u306b\u3064\u306a\u3050\n        return True\n \n    def issame(self, x, y): #same(x,y): x\u3068y\u304c\u540c\u3058\u7d44\u306a\u3089True\n        return self.root(x) == self.root(y)\n        \n    def getsize(self,x): #size(x): x\u306e\u3044\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\u3092\u8fd4\u3059\n        return self.size[self.root(x)]\n\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\n#n = int(readline())\nn,m = list(map(int,readline().split()))\n*p, = list(map(int,readline().split()))\n\nUF = UnionFind(n)\nfor _ in range(m):\n    x,y = list(map(int,readline().split()))\n    UF.merge(x-1,y-1)\n\nq = [set() for _ in range(n)]    \nr = [set() for _ in range(n)]    \n\nfor i in range(n):\n    v = UF.root(i)\n    q[v].add(i)\n    r[v].add(p[i]-1)\n\n#print(q,r)\nans = 0\nfor i in range(n):\n    ans += len(q[i]&r[i])\n    #print(q[i]&r[i])\n\nprint(ans)\n\n\n\n\n", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n        \nN,M = map(int,input().split())\nP = list(map(int,input().split()))\nuf = UnionFind(N)\nfor i in range(M):\n    x,y = map(int,input().split())\n    uf.union(x-1,y-1)\nans = 0\nfor i in range(N):\n    if uf.same(i,P[i]-1):\n        ans += 1\nprint(ans)", "import sys\nimport math\nimport collections\nimport bisect\nimport copy\nimport itertools\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline().rstrip())\nns = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().rstrip().split()])\n\n\n# ===CODE===\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef main():\n    n, m = ns()\n    p = na1()\n\n    uf = UnionFind(n)\n\n    for _ in range(m):\n        x, y = ns()\n        uf.union(x - 1, y - 1)\n\n    ans = 0\n    for i, pi in enumerate(p):\n        if uf.same(i, pi):\n            ans += 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class Unionfind():  # Unionfind\n    def __init__(self, N):\n        self.N = N\n        self.parents = [-1] * N\n\n    def find(self, x):  # \u30b0\u30eb\u30fc\u30d7\u306e\u6839\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):  # \u30b0\u30eb\u30fc\u30d7\u306e\u4f75\u5408\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def all_group_members(self):  # \u30b0\u30eb\u30fc\u30d7\u3054\u3068\u306e\u8f9e\u66f8\n        members_dict = {i: set([i]) for i, x in enumerate(self.parents) if x < 0}\n        for i, x in enumerate(self.parents):\n            if x >= 0:\n                members_dict[self.find(x)].add(i)\n        return members_dict\n\n\nn, m = list(map(int, input().split()))\np = list(map(int, input().split()))\nxy = [list(map(int, input().split())) for _ in range(m)]\n\nuf = Unionfind(n)\nfor x, y in xy:\n    uf.union(x - 1, y - 1)\n\nans = 0\nfor lst in list(uf.all_group_members().values()):\n    ans += sum((p[num] - 1 in lst) for num in lst)\nprint(ans)\n", "class UnionFind:\n    def __init__(self,n):\n        self.n=n\n        self.parents=[-1]*n\n\n    def find(self,x):\n        if self.parents[x]<0:\n            return x\n        else:\n            self.parents[x]=self.find(self.parents[x])\n            return self.parents[x]\n\n    def unite(self,x,y):\n        x=self.find(x)\n        y=self.find(y)\n        if x==y:\n            return\n        if self.parents[x]>self.parents[y]:\n            x,y=y,x\n        self.parents[x]+=self.parents[y]\n        self.parents[y]=x\n\n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n\n    def size(self,x):\n        return -self.parents[self.find(x)]\n\n    def members(self,x):\n        root=self.find(x)\n        return [i for i in range(self.n) if self.find(i)==root]\n\n    def roots(self):\n        return [i for i,x in enumerate(self.parents) if x<0]\n\n\nn,m=map(int,input().split())\np=list(map(int,input().split()))\nuf=UnionFind(n)\nfor i in range(m):\n    x,y=map(int,input().split())\n    uf.unite(x-1,y-1)\nans=0\nfor i in range(n):\n    if uf.same(i,p[i]-1):\n        ans+=1\nprint(ans)", "import sys\nfrom collections import deque\n\ninput = sys.stdin.readline\n\ndef bfs(N, G, p):\n    # Connected compoponent\n    c_comp_p_list = []\n    c_comp_i_list = []\n    visited = [False] * N\n    for i in range(N):\n        if visited[i]:\n            continue\n        visited[i] = True\n        c_comp_p_list.append([p[i]])\n        c_comp_i_list.append(set([i + 1]))\n        cc_p_add = c_comp_p_list[-1].append\n        cc_i_add = c_comp_i_list[-1].add\n\n        queue = deque(G[i])\n        while queue:\n            u = queue.popleft()\n            if visited[u]:\n                continue\n            visited[u] = True\n            cc_p_add(p[u])\n            cc_i_add(u + 1)\n\n            for v in G[u]:\n                if visited[v]:\n                    continue\n                queue.append(v)\n\n    res = 0\n    for c_comp_p, c_comp_i in zip(c_comp_p_list, c_comp_i_list):\n        for pp in c_comp_p:\n            if pp in c_comp_i:\n                res += 1\n    return res\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    p = tuple(map(int, input().split()))\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        x, y = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        G[x].append(y)\n        G[y].append(x)\n    \n    ans = bfs(N, G, p)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\nn,m = map(int,input().split())\n\np = list(map(int,input().split()))\n\nroot = [[] for i in range(n)]\nfor _ in range(m):\n    a, b = (int(x) for x in input().split())\n    root[b-1].append(a-1)\n    root[a-1].append(b-1)\n\ncheck = [-1]*n\n\nfor j in range(n):\n    if check[j] != -1:\n        continue\n    stack=deque([j])\n    check[j] = j\n    while len(stack)>0:\n        v = stack.popleft()\n        for i in root[v]:\n            if check[i] == -1:\n                check[i]=j\n                stack.append(i)\n\nans = 0\nfor key, value in enumerate(p):\n    if check[key] == check[value-1]:\n        ans += 1\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef main():\n    N, M = map(int, input().split())\n    P = list(map(int, input().split()))\n    uni = UnionFind(N)\n\n    for i in range(N):\n        P[i] -= 1\n\n    for _ in range(M):\n        x, y = map(int, input().split())\n        x -= 1\n        y -= 1\n        uni.union(x,y)\n    ans = 0\n    for i in range(N):\n        if P[i] == i:\n            ans += 1\n        else:\n            if uni.same(i,P[i]):\n                ans += 1\n\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "class UnionFind:\n\n    def __init__(self, n: int):\n        self.parent = [i for i in range(n + 1)]\n        self.rank = [0] * (n + 1)\n\n    def find(self, x: int) -> int:\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def unit(self, x: int, y: int):\n        parent_x = self.find(x)\n        parent_y = self.find(y)\n        if self.rank[parent_x] < self.rank[parent_y]:\n            self.parent[parent_x] = parent_y\n        else:\n            self.parent[parent_y] = parent_x\n            if self.rank[parent_y] == self.rank[parent_x]:\n                self.rank[parent_x] += 1\n\n    def same_check(self, x: int, y: int) -> bool:\n        return self.find(x) == self.find(y)\n\n\nN, M = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\nxy = UnionFind(N)\n\nfor _ in range(M):\n    x, y = list(map(int, input().split()))\n    xy.unit(x, y)\n\nans = 0\n\nfor i in range(N):\n    if xy.same_check(p[i], i + 1):\n        ans += 1\n\nprint(ans)\n", "import sys\n\nsys.setrecursionlimit(6500)\n\ndef find(n):\n    if d[n]<0:\n        return n\n    else:\n        d[n]=find(d[n])\n        return d[n]\n\ndef union(a,b):\n    a=find(a)\n    b=find(b)\n    if a==b:return False\n    if d[a]<=d[b]:\n        d[a]+=d[b]\n        d[b]=a\n    else:\n        d[b]+=d[a]\n        d[a]=b\n    return True\n\ndef members(n):\n    p=find(n)\n    ans=[]\n    for i in range(N):\n        if find(i)==p:\n            ans.append(i)\n    return ans\n\ndef same(a,b):\n    if find(a)==find(b):return True\n    else:return False\n\nN,M=map(int,input().split())\np=list(map(int,input().split()))\n\nd=[-1]*N\n\nfor i in range(M):\n    x,y=map(int,input().split())\n    x,y=x-1,y-1\n    union(x,y)\n\nans=0\nfor i in range(N):\n    if same(i,p[i]-1):\n        ans+=1\nprint(ans)", "from collections import Counter,deque,defaultdict\nn,m=map(int,input().split())\np=list(map(int,input().split()))\nidx_lst=[0]*n\nfor i,x in enumerate(p):\n    idx_lst[x-1]=i\nlst=[[] for _ in range(n)]\nfor i in range(m):\n    x,y=map(int,input().split())\n    lst[x-1].append(y-1)\n    lst[y-1].append(x-1)\nseen=[False]*n\nans=0\nfor i in range(n):\n    if seen[i]:\n        continue\n    seen[i]=True\n    q=deque([i])\n    dic=defaultdict(int)\n    dic[i]+=1\n    while q:\n        t=q.pop()\n        for j in lst[t]:\n            if seen[j]:\n                continue\n            seen[j]=True\n            dic[j]+=1\n            q.append(j)\n    for k in list(dic.keys()):\n        if dic[idx_lst[k]]:\n            ans+=1\nprint(ans)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nclass UnionFindPathCompression():\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.rank = [1]*n\n        self.size = [1]*n\n        \n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n\n        if px == py:\n            return\n        else:\n            if self.rank[px] < self.rank[py]:\n                self.parents[px] = py\n                self.size[py] += self.size[px]\n            else:\n                self.parents[py] = px\n                self.size[px] += self.size[py]\n                #\u30e9\u30f3\u30af\u306e\u66f4\u65b0\n                if self.rank[px] == self.rank[py]:\n                    self.rank[px] += 1\n\n\nn,m = map(int,input().split())\nP = list(map(int, input().split()))\nufpc = UnionFindPathCompression(n)\nfor i in range(m):\n    x,y = map(int,input().split())\n    x,y = x-1, y-1\n    ufpc.union(x,y)\n\nans = 0\nfor i,p in enumerate(P):\n    if ufpc.find(i) == ufpc.find(p-1):\n        ans += 1\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m = map(int,input().split())\np = list(map(int,input().split()))\nu = UnionFind(n)\nfor _ in range(m):\n    x,y = map(int,input().split())\n    x -= 1\n    y -= 1\n    u.union(x,y)\n\nans = 0\nfor i in range(n):\n    pi = p[i]\n    pi -= 1\n    if u.same(i,pi):\n        ans += 1\nprint(ans)", "class UnionFind:\n    def __init__(self, num):\n        self.parent = [i for i in range(num + 1)]\n\n    def find(self, node):\n        if self.parent[node] == node:\n            return node\n\n        self.parent[node] = self.find(self.parent[node])\n        return self.parent[node]\n\n    def union(self, node1, node2):\n        node1 = self.find(node1)\n        node2 = self.find(node2)\n\n        if node1 == node2:\n            return\n\n        if self.parent[node1] > self.parent[node2]:\n            node1, node2 = node2, node1\n\n        self.parent[node2] = node1\n        return\n\n    def same(self, node1, node2):\n        return self.find(node1) == self.find(node2)\n\n\nn, m = list(map(int, input().split()))\np = list(map(int, input().split()))\n\nuf = UnionFind(n)\nfor _ in range(m):\n    x, y = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    uf.union(p[x], p[y])\n\nans = 0\nfor i in range(n):\n    if p[i] == i + 1 or uf.same(p[i], i + 1):\n        ans += 1\n\nprint(ans)\n\n", "class UnionFind():\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n        self.members = [{i} for i in range(n)]\n        self.roots = {i for i in range(n)}\n\n    def root(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        if rx != ry:\n            if self.rank[rx] < self.rank[ry]:\n                self.par[rx] = ry\n                self.members[ry] |= self.members[rx]\n                self.roots.discard(rx)\n            else:\n                self.par[ry] = rx\n                self.members[rx] |= self.members[ry]\n                self.roots.discard(ry)\n                if self.rank[rx] == self.rank[ry]:\n                    self.rank[rx] += 1\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\nN, M = list(map(int, input().split()))\nP = list([int(x) - 1 for x in input().split()])\nX = UnionFind(N)\nY = UnionFind(N)\nfor _ in range(M):\n    x, y = list(map(int, input().split()))\n    x -= 1; y -= 1\n    X.union(x, y)\n    Y.union(P[x], P[y])\n\nans = 0\nroots = X.roots\nfor r in roots:\n    A = X.members[r]\n    B = Y.members[P[r]]\n    ans += len(A & B)\n\nprint(ans)\n", "import sys\n# sys.setrecursionlimit(100000)\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef input_int():\n    return int(input())\n\n\ndef input_int_list():\n    return [int(i) for i in input().split()]\n\n\nclass UnionFind:\n    \"\"\" 0-indexed Union Find Tree (a.k.a Disjoint Union Tree)\n    \"\"\"\n\n    def __init__(self, n: int):\n        self.nodes = n\n        self.parents = [-1] * n\n        self.rank = [0] * n\n\n    # retrun the root of element x\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    # unite the group include element x and group include element y\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.parents[y] += self.parents[x]\n            self.parents[x] = y\n        else:\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # get size of the gourp which element x belongs\n    def get_size(self, x):\n        return -self.parents[self.find(x)]\n\n    # check if element x and element y is same group\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # return groups as array of set\n    def get_groups(self, index_base=0) -> list:\n        d = {}\n        for i in range(index_base, self.nodes):\n            p = self.find(i)\n            if p not in list(d.keys()):\n                d[p] = set()\n            d[p].add(i)\n        return list(d.values())\n\n\ndef main():\n    n, m = input_int_list()\n    A = [None] + input_int_list()  # 1-indexed\n    djs = UnionFind(n + 1)\n\n    for _ in range(m):\n        x, y = input_int_list()\n        djs.unite(x, y)\n    groups = djs.get_groups()\n    ans = 0\n    for group in groups:\n        v = set()\n        for i in group:\n            v.add(A[i])\n        ans += len(group & v)\n    print(ans)\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\ndef unite(x, y):\n    p = find(x)\n    q = find(y)\n    if p == q:\n        return None\n    if p > q:\n        p, q = q, p\n    par[p] += par[q]\n    par[q] = p\ndef same(x, y):\n    return find(x) == find(y)\ndef size(x):\n    return -par[find(x)]\nn, m = map(int, input().split())\npar = [-1 for i in range(n)]\np = list(map(int, input().split()))\nfor i in range(m):\n    x, y = map(int, input().split())\n    unite(x - 1, y - 1)\nans = 0\nfor i in range(n):\n    if same(p[i] - 1, i):\n        ans += 1\nprint(ans)", "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n# def LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\n# Union-Find -- START --\nclass UnionFind():\n  def __init__(self,sz):\n    self.sz=sz\n    self.data=[-1]*sz\n    self.amount=[0]*sz\n\n  def unite(self,x,y):\n    x=self.find(x)\n    y=self.find(y)\n    if x==y:\n      return False\n    self.amount[x]+=self.amount[y]\n    self.amount[y]+=self.amount[x]\n    if self.data[x]>self.data[y]:\n      x,y=y,x\n    self.data[x]+=self.data[y]\n    self.data[y]=x\n    return True\n\n  def find(self,k):\n    if self.data[k]<0:\n      return k\n    self.data[k]=self.find(self.data[k])\n    return self.data[k]\n\n  def size(self,k):\n    return -self.data[self.find(k)]\n\n  def set_amount(self,k,k_amount):\n    self.amount[k]=k_amount\n\n  def get_amount(self,k):\n    return self.amount[k]\n# Union-Find --- END ---\n\ndef main():\n  n,k=LI()\n  l=LI()\n  d={}\n  uf=UnionFind(n)\n  for i,x in enumerate(l):\n    x-=1\n    d[i]=x\n  \n  for _ in range(k):\n    a,b=LI()\n    uf.unite(a-1,b-1)\n\n  ans=0\n  for x in l:\n    x-=1\n    if uf.find(x)==uf.find(d[x]):\n      ans+=1\n\n  return ans\n\n# main()\nprint((main()))\n", "class UnionFind:\n    def __init__(self, n):\n        # n: \u9802\u70b9\u6570\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        # x\u306e\u6839\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        # \u7121\u5411\u8fba\u3092\u306f\u308b\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        # x\u306e\u5c5e\u3059\u308b\u96c6\u56e3\u306e\u9802\u70b9\u6570\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        # \u540c\u96c6\u56e3\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\n        return self.find(x) == self.find(y)\n\n    def members(self):\n        ret = dict()\n        for i in range(self.n):\n          x = self.find(i)\n          if x in ret:\n            ret[x].add(i)\n          else:\n            ret[x] = {i}\n        return ret\n\nN,M=map(int,input().split())\np=list(map(int,input().split()))\nuf = UnionFind(N)\nfor _ in range(M):\n  x,y =map(int,input().split())\n  uf.union(x-1,y-1)\n# uf\u4e0a\u306egroup\u3054\u3068\u306b\u3001group\u306eindex\u3068\u305d\u306e\u8981\u7d20\u306e\u7a4d\u96c6\u5408\u306e\u30b5\u30a4\u30ba\u3092\u3068\u308b\nans = 0\nfor id_s in uf.members().values():\n  val_s = set()\n  for i in id_s:\n    val_s.add(p[i]-1)\n  ans += len(id_s & val_s)\n  #print(id_s,val_s)\nprint(ans)", "def find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x]) #\u7d4c\u8def\u5727\u7e2e\n        return par[x]\ndef same(x,y):\n    return find(x) == find(y)\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    par[x] = y\n    size[y] = size[x] + size[y]\n    size[x] = 0\n\nN,M = list(map(int, input().split()))\nplist = list(map(int,input().split()))\nABs = [list(map(int, input().split())) for _ in range(M)]\npar = [i for i in range(N+1)]\nsize = [1 for _ in range(N+1)]\n\nfor AB in ABs:\n    unite(AB[0],AB[1])\n\nAns = 0\nfor i in range(len(plist)):\n    if plist[i] == i+1:\n        Ans +=1\n    else:\n        if same(plist[i],i+1):\n            Ans += 1\nprint(Ans)", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def num_roots(self):\n    return len([i for i, x in enumerate(self.parents) if x < 0])\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def num_members(self,x):\n    return abs(self.parents[self.find(x)])\n\n  def __str__(self):\n    return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = list(map(int, input().split()))\nP = list(map(int, input().split()))\nuf = UnionFind(N)\nfor _ in range(M):\n  x,y = list(map(int, input().split()))\n  uf.union(x-1,y-1)\nfrom collections import defaultdict\nd = defaultdict(lambda: [])\nfor i in range(N):\n  d[uf.find(i)].append(i)\nfrom bisect import bisect_left\ndef binary_search(A,p):\n  if A[0]<=p and p<=A[-1]:\n    if p == A[bisect_left(A,p)]:\n      return True\n  return False\nans = 0\nfor v in list(d.values()):\n  lis = sorted(v)\n  for a in v:\n    if binary_search(lis,P[a]-1):\n      ans += 1\nprint(ans)\n\n\n\n", "import sys\nstdin = sys.stdin\nsys.setrecursionlimit(10**6)\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnn = lambda: list(stdin.readline().split())\nns = lambda: stdin.readline().rstrip()\n\nimport collections\nimport itertools\nimport operator\n\nclass UnionFind:\n  def __init__(self, elems=None):\n    class KeyDict(dict):\n      def __missing__(self, key):\n        self[key] = key\n        return key\n\n    self.parent = KeyDict()\n    self.rank = collections.defaultdict(int)\n    self.size_ = collections.defaultdict(lambda: 1)\n\n    if elems is not None:\n      for elem in elems:\n        _, _, _ = self.parent[elem], self.rank[elem], self.size_[elem]\n\n  def find(self, x):\n    if self.parent[x] == x:\n      return x\n    else:\n      self.parent[x] = self.find(self.parent[x])\n      return self.parent[x]\n\n  def unite(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n    if x == y:\n      return\n    if self.rank[x] < self.rank[y]:\n      self.parent[x] = y\n      self.size_[y] += self.size_[x]\n    else:\n      self.parent[y] = x\n      self.size_[x] += self.size_[y]\n    if self.rank[x] == self.rank[y]:\n      self.rank[x] += 1\n\n  def are_same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def grouper(self):\n    roots = [(x, self.find(x_par)) for x, x_par in self.parent.items()]\n    root = operator.itemgetter(1)\n    for _, group in itertools.groupby(sorted(roots, key=root), root):\n      yield [x for x, _ in group]\n\n  def size(self,x):\n    return self.size_[self.find(x)]\n\nn,m = na()\np = na()\nuf = UnionFind()\nfor i in range(m):\n    x,y = na()\n    uf.unite(x,y)\n\ndp = []\nfor i in range(n):\n    dp.append(uf.find(i+1))\n\nans = 0\nfor i in range(n):\n    if dp[i] == uf.find(p[i]) or i+1 == p[i]: ans += 1\n\nprint(ans)", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, M = LI()\n    p = LI_()\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        x, y = LI_()\n        G[x].append(y)\n        G[y].append(x)\n    # print(G)\n\n    visited = [False] * N\n    def dfs(c, tmp):\n        visited[c] = True\n        tmp.append(c)\n        for n in G[c]:\n            if not visited[n]:\n                dfs(n, tmp)\n\n    # \u9023\u7d50\u6210\u5206\u5185\u306fswap\u3067\u81ea\u7531\u306a\u4f4d\u7f6e\u306b\u79fb\u52d5\u53ef\u80fd\n    c = []\n    for i in range(N):\n        if not visited[i]:\n            tmp = []\n            dfs(i, tmp)\n            c.append(tmp)\n    # print(c)\n\n    ans = sum([len({p[j] for j in i} & set(i)) for i in c])\n    print(ans)\n\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n      return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def size(self, x):\n    return -self.parents[self.find(x)]\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def group_count(self):\n    return len(self.roots())\n\n  def all_group_members(self):\n    return {r: self.members(r) for r in self.roots()}\n\n  def __str__(self):\n    return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\nPs = [0] + list(map(int, input().split()))\n\nuf = UnionFind(N+1)\n\nfor _ in range(M):\n  x, y = map(int, input().split())\n  uf.union(x, y)\n\nrlt = 0\nfor i in range(1,N+1):\n  if uf.find(i) == uf.find(Ps[i]):\n    rlt += 1\n  \nprint(rlt)", "N, M = list(map(int, input().split()))\np = list(map(int, input().split()))\n\npairs = [list(map(int, input().split())) for _ in range(M)]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n + 1)]\n\n    def root(self, x):\n        if self.par[x] == x:\n            return x\n        self.par[x] = self.root(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        self.par[x] = y\n\n    def check(self, x, y):\n        return self.root(x) == self.root(y)\n\n\nu = UnionFind(N)\n\nfor x, y in pairs:\n    u.union(x, y)\n\nans = 0\nfor j in range(1, N + 1):\n    if u.check(p[j - 1], j):\n        ans += 1\nprint(ans)\n", "def read_values(): return list(map(int, input().split()))\ndef read_index(): return [int(x) - 1 for x in input().split()]\ndef read_list(): return list(read_values())\ndef read_lists(N): return [read_list() for n in range(N)]\n\n\nclass UF:\n    def __init__(self, N):\n        self.state = [-1] * N\n        self.rank = [0] * N\n        self.num_group = N\n    \n    def get_parent(self, a):\n        p = self.state[a]\n        if p < 0:\n            return a\n        \n        q = self.get_parent(p)\n        self.state[a] = q\n        return q\n\n    def make_pair(self, a, b):\n        pa = self.get_parent(a)\n        pb = self.get_parent(b)\n        if pa == pb:\n            return\n\n        if self.rank[pa] > self.rank[pb]:\n            pa, pb = pb, pa\n            a, b = b, a\n        elif self.rank[pa] == self.rank[pb]:\n            self.rank[pb] += 1\n\n        self.state[pb] += self.state[pa]\n        self.state[pa] = pb\n        self.state[a] = pb\n        self.num_group -= 1\n    \n    def is_pair(self, a, b):\n        return self.get_parent(a) == self.get_parent(b)\n\n    def get_size(self, a):\n        return -self.state[self.get_parent(a)]\n\n\nN, M = read_values()\nA = read_list()\nuf = UF(N)\nfor _ in range(M):\n    i, j = read_index()\n    uf.make_pair(A[i] - 1, A[j] - 1)\n\nres = 0\nfor i, a in enumerate(A):\n    if uf.is_pair(i, A[i] - 1):\n        res += 1\n\nprint(res)\n", "n, m = map(int, input().split())\npn = list(map(lambda x:int(x)-1, input().split()))\nls = [-1] * n\nfor i in pn:\n    ls[pn[i]] = i\npar = [i for i in range(n)]\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        s = find(par[x])\n        par[x] = s\n        return s\ndef unite(x,y):\n    s = find(x)\n    t = find(y)\n    if s>t:\n        par[s] = t\n    else:\n        par[t] = s\nfor _ in range(m):\n    x, y = map(lambda x:int(x)-1, input().split())\n    unite(ls[x],ls[y])\nans2 = 0\nfor i in range(n):\n    if find(i)==find(ls[i]):\n       ans2+=1\nprint(ans2)", "class UnionFind(object):\n    def __init__(self, n=1):\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.size[x] += self.size[y]\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x):\n        x = self.find(x)\n        return self.size[x]\n\n\nN, M = map(int, input().split())\np = list(map(int, input().split()))\n\nuf = UnionFind(N)\n\nfor i in range(M):\n    x, y = map(int, input().split())\n    uf.union(p[x-1]-1, p[y-1]-1)\n\nans = 0\nfor i in range(N):\n    if uf.is_same(p[i]-1, i):\n        ans += 1\n\nprint(ans)", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nimport collections\nimport math\nimport itertools\nimport heapq as hq\n\nclass unionfind():\n    def __init__(self,n):\n        self.par = list(range(n))\n        self.size = [1]*n\n        self.rank = [0]*n\n\n    def root(self,x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n\n    def same(self,x,y):\n        return self.root(x) == self.root(y)\n\n    def unite(self,x,y):\n        x = self.root(x)\n        y = self.root(y)\n        if x==y:return\n        else:\n            if self.rank[x] < self.rank[y]:\n                 x,y = y,x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x]+=1\n            self.par[y] = x\n            self.size[x] +=self.size[y]\n    def get_size(self,x):\n        x = self.root(x)\n        return self.size[x]\nn,m = ma()\nP = lma()\nuf = unionfind(n+1)\nfor i in range(m):\n    x,y = ma()\n    uf.unite(x,y)\nans = 0\nfor i in range(n):\n    if uf.same(i+1,P[i]):\n        ans+=1\nprint(ans)\n", "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # \u4f75\u5408\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\nN,M=list(map(int,input().split()))\n\nS=list(map(int,input().split()))\n\nans=0\nTA=[]\nTB=[]\nfor i in range(M):\n    a,b=list(map(int,input().split()))\n    TA.append(a)\n    TB.append(b)\n\nuni=UnionFind(N)\nfor i in range(M):\n    uni.union(TA[i],TB[i])\n\n    \nfor i in range(N):\n    if uni.same_check(i+1,S[i])==True:\n        ans+=1\n        #print(\"mohu\",i)\n        \n        \n    \n    \nprint(ans)\n", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n      \nN, M = list(map(int,input().split()))\nuf = UnionFind(N)\np = list(map(int,input().split()))\n\nfor _ in range(M):\n  x, y = list(map(int,input().split()))\n  x -= 1; y -= 1;\n  uf.union(x, y)\n\nans = 0\nfor i in range(N):\n  if uf.same(i, p[i]-1):\n    ans += 1\n    \nprint(ans)\n\n  \n  \n", "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\ndef inpl(): return list(map(int, input().split()))\ndef inpl_s(): return list(input().split())\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\np = inpl()\nuf = UnionFind(N)\nfor i in range(M):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    uf.union(x, y)\n\nans = 0\nfor i in range(N):\n    if uf.same(p[i]-1,i):\n        ans += 1\n\nprint(ans)", "n, m = map(int, input().split())\npn = list(map(lambda x:int(x)-1, input().split()))\nls = [-1] * n\nfor i in pn:\n    ls[pn[i]] = i\n#print(ls)\n\npar = [i for i in range(n)]\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        s = find(par[x])\n        par[x] = s\n        return s\n\ndef unite(x,y):\n    s = find(x)\n    t = find(y)\n    if s>t:\n        par[s] = t\n    else:\n        par[t] = s\n\n\nfor _ in range(m):\n    x, y = map(lambda x:int(x)-1, input().split())\n    unite(ls[x],ls[y])\n\nans2 = 0\nfor i in range(n): \n    place1 = i\n    place2 = ls[i]\n\n    if find(place1)==find(place2):\n       ans2+=1\nprint(ans2)", "n,m=map(int,input().split())\n*p,=map(int,input().split())\np=[z-1 for z in p]\nes=[[] for _ in range(n)]\nfor _ in range(m):\n    x,y=map(int,input().split())\n    es[x-1].append(y-1)\n    es[y-1].append(x-1)\n\ngroup=[-1]*n\nlast=-1\nfor i in range(n):\n    if group[i]==-1:\n        last+=1\n        group[i]=last\n        stack=[i]\n        while stack:\n            j=stack.pop()\n            for e in es[j]:\n                if group[e]==-1:\n                    stack.append(e)\n                    group[e]=last\ngroupset=set(group)\ngroup1=[[] for g in groupset]\ngroup2=[[] for g in groupset]\n\nfor i in range(n):\n    group1[group[i]].append(i)\n    group2[group[i]].append(p[i])\n\nans=0\nfor g in groupset:\n    ans+=len(set(group1[g])&set(group2[g]))\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1]*(n+1)\n        self.rnk = [0]*(n+1)\n    def find(self, x):\n        if(self.root[x] < 0):\n            return x\n        else:\n            self.root[x] = self.find(self.root[x])\n            return self.root[x]\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if(x == y):return \n        elif(self.rnk[x] > self.rnk[y]):\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if(self.rnk[x] == self.rnk[y]):\n                self.rnk[y] += 1\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\nn,m=map(int,input().split())\np=[0]+list(map(int,input().split()))\nuf=UnionFind(n)\nfor _ in range(m):\n  a,b=map(int,input().split())\n  uf.unite(a,b)\ncnt=0\nfor i,j in enumerate(p):\n  if uf.same(i,j):cnt+=1\nprint(cnt-1)", "n,m=list(map(int,input().split()))\na=list(map(int,input().split()))\ns=[[] for i in range(n)]\nfor i in range(m):\n  inp=list(map(int,input().split()))\n  s[inp[0]-1].append(inp[1]-1)\n  s[inp[1]-1].append(inp[0]-1)\nc=0\nd=[0 for i in range(n)]\nfor i in range(n):\n  if d[i]:\n    continue\n  c+=1\n  d[i]=c\n  st=s[i]\n  while st:\n    ns=[]\n    for j in st:\n      if d[j]:\n        continue\n      d[j]=c\n      ns+=s[j]\n    st=ns\nc=0\nfor i in range(n):\n  if d[i]==d[a[i]-1]:\n    c+=1\nprint(c)", "N,M=map(int,input().split())\np=[0]+list(map(int,input().split()))\nxy=[list(map(int,input().split())) for i in range(M)]\nli=[[] for i in range(N+1)]\nfor i in range(M):\n    li[xy[i][0]].append(xy[i][1])\n    li[xy[i][1]].append(xy[i][0])\nlis=[0]*(N+1)\nma=0\nfor i in range(1,N+1):\n    if lis[i]==0:\n        deque=[i]\n        lis[i]=i\n        ma=i\n        while deque:\n            x=deque.pop(0)\n            for j in li[x]:\n                if lis[j]==0:\n                    lis[j]=i\n                    deque.append(j)\nlit=[[] for i in range(ma)]\nlif=[[] for i in range(ma)]\nfor i in range(1,N+1):\n    lit[lis[i]-1].append(i)\n    lif[lis[i]-1].append(p[i])\nans=0\nfor i in range(ma):\n    ans+=len(set(lit[i])&set(lif[i]))\nprint(ans)", "n,m=map(int,input().split())\nP=[i-1 for i in list(map(int,input().split()))]\n\nclass UnionFind():\n    def __init__(self,num):\n        self.n = num         #class\u5185\u5909\u6570n\u306b\u3001\u5916\u90e8\u304b\u3089\u5165\u529b\u3057\u305f\u5024num\u3092\u4ee3\u5165\n        self.parents = [-1 for i in range(self.n)]\n          #parents\u306f\u8981\u7d20\u306e\u89aa(1\u3053\u4e0a\u306e\u3084\u3064)\u756a\u53f70~n-1\u3092\u683c\u7d0d\u3001\u81ea\u5206\u304c\u6700\u89aa\u306a\u3089-(\u8981\u7d20\u6570)\u3092\u683c\u7d0d(\u521d\u671f\u5024\u306f-1)\n\n    #x\u306e\u6700\u89aa\u306f\u8ab0\uff1f\n    def find(self,x):\n        if self.parents[x]<0:\n            return x\n        else:\n            self.parents[x]=self.find(self.parents[x]) #\u518d\u5e30\u3057\u30661\u756a\u4e0a\u307e\u3067\u3044\u3063\u3066\u308b\n                #\u8abf\u3079\u306a\u304c\u3089parents\u306e\u5024\u3092\u66f4\u65b0\u3057\u3066\u308b\uff01\uff08\u7d4c\u8def\u5727\u7e2e\uff09\n            return self.parents[x]\n\n    #\u7d50\u5408\u305b\u3088\n    #x\u306e\u89aa\u3068y\u306e\u89aa\u3092\u304f\u3063\u3064\u3051\u308b\n    def union(self,x,y):\n        xx=self.find(x)  #xx\u306fx\u306e\u6700\u89aa\n        yy=self.find(y)  #yy\u306fy\u306e\u6700\u89aa\n        if xx==yy:\n            return     #\u540c\u3058\u5c4b\u6839\u306e\u4e0b\u306b\u3042\u3063\u305f\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044\n        else:\n            size_xx=abs(self.parents[xx]) #x\u304c\u542b\u307e\u308c\u308b\u6728\u306e\u30b5\u30a4\u30ba\n            size_yy=abs(self.parents[yy]) #y\u304c\u542b\u307e\u308c\u308b\u6728\u306e\u30b5\u30a4\u30ba\n            if size_xx>size_yy:\n                xx,yy=yy,xx  #yy\u306e\u65b9\u304c\u5927\u304d\u3044\u6728\u3001\u3063\u3066\u3053\u3068\u306b\u3059\u308b\n\n            self.parents[yy]+=self.parents[xx] #\u5927\u304d\u3044\u6728\u306e\u30b5\u30a4\u30ba\u66f4\u65b0\n            self.parents[xx]=yy   #\u30b5\u30a4\u30ba\u304c\u5c0f\u3055\u3044\u6728\u3092\u5927\u304d\u3044\u6728\u306b\u63a5\u3050\n\n    #x\u306e\u5c5e\u3059\u308b\u6728\u306e\u5927\u304d\u3055\uff08\u307e\u3042union\u3067\u3082\u4f7f\u3063\u305f\u3051\u3069\uff09\n    def size(self,x):\n        xx=self.find(x)\n        return abs(self.parents[xx])\n\n    #x\u3068y\u306f\u3053\u306e\u7a7a\u306e\u7d9a\u304f\u5834\u6240\u306b\u3044\u307e\u3059\u304b\u3000\u3044\u3064\u3082\u306e\u3088\u3046\u306b\u7b11\u9854\u3067\u3044\u3066\u304f\u308c\u307e\u3059\u304b\u3000\u4eca\u306f\u305f\u3060\u305d\u308c\u3092\u9858\u3044\u7d9a\u3051\u308b\n    def same(self,x,y):\n        return 1 if self.find(x)==self.find(y) else 0\n\n    #x\u3068\u3000\u540c\u3058\u6728\u306b\u3044\u308b\u3000\u30e1\u30f3\u30d0\u30fc\u306f\uff1f\n    def members(self,x):\n        xx=self.find(x)\n        return [i for i in range(self.n) if self.find(i)==xx]\n             #if\u306e\u6761\u4ef6\u5f0f\u306b\u6f0f\u308c\u305f\u3089\u7121\u8996\n\n    #\u6700\u89aa\u3060\u3051\u3092\u4e26\u3079\u3042\u3052\u308b\n    def roots(self):\n        return [i for i,x in enumerate(self.parents) if x < 0]\n        #\u3044\u3084\u3053\u308c\u306f\u5929\u624d\u3059\u304e\u308b\u3001basis\u306eenumerate.py\u53c2\u7167\n\n    #\u3059\u3079\u3066\u306e\u6700\u89aa\u306b\u3064\u3044\u3066\u3001\u30e1\u30f3\u30d0\u30fc\u3092\u8f9e\u66f8\u3067\n    def all_group_members(self):\n        return {r:self.members(r) for r in self.roots()}\n\n    #\u30b0\u30eb\u30fc\u30d7\u5206\u3051\u3069\u3046\u306a\u308a\u307e\u3057\u305f\u304b\u3001\uff12\u91cd\u30ea\u30b9\u30c8\u3067\n    def state_grouping(self):\n        return list(self.all_group_members().values())\n\n\nuf=UnionFind(n)\nfor i in range(m):\n    a,b=map(int,input().split())\n    a-=1;b-=1\n    uf.union(a,b)\nans=0\nfor i in range(n):\n    ans+= uf.same(i,P[i])\nprint(ans)", "class UnionFindTree:\n    def __init__(self, n):\n        self.nodes = [-1] * n #\u6839\u306b\u30b5\u30a4\u30ba\u3092\u8ca0\u306e\u5024\u3067\u683c\u7d0d\u3059\u308b\u3002\n    def find(self, i):\n        if self.nodes[i] < 0: #\u5024\u304c\u8ca0\u306e\u5834\u5408\u306f\u6839\n            return i\n        else:\n            self.nodes[i] = self.find(self.nodes[i]) #\u7e2e\u7d04\n            return self.nodes[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.nodes[i] > self.nodes[j]: #\u30b5\u30a4\u30ba\u6bd4\u8f03\u3057\u3066i\u306e\u65b9\u304c\u30b5\u30a4\u30ba\u304c\u5927\u304d\u3044\u3088\u3046\u306b\u3059\u308b\n            i, j = j, i\n        self.nodes[i] += self.nodes[j] #\u5927\u304d\u3044\u65b9\u306b\u5c0f\u3055\u3044\u65b9\u3092\u7d71\u5408\u3057\u30b5\u30a4\u30ba\u3092\u767b\u9332\u3059\u308b\u3002\n        self.nodes[j] = i # j\u306e\u89aa\u306fi\n    \n    def size(self, i): # \u6240\u5c5e\u3059\u308b\u96c6\u5408\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\n        i = self.find(i)\n        return -self.nodes[i]\n\nn, m = list(map(int, input().split()))\np = list([int(x) - 1 for x in input().split()])\nuft = UnionFindTree(n)\nfor _ in range(m):\n    x, y = [int(x) - 1 for x in input().split()]\n    uft.union(x, y)\n\nans = 0\nfor i in range(n):\n    if uft.find(p[i]) == uft.find(i):\n        ans += 1\nprint(ans)\n", "n,m=map(int,input().split())\nP=[int(i) for i in input().split()]\n\nuf=[i for i in range(n+1)]\ndef ufuf(x):\n    while x!=uf[x]:\n        x=uf[x]\n    return x\n\nfor i in range(m):\n    x,y=map(int,input().split())\n    if ufuf(x)<ufuf(y):\n        uf[ufuf(y)]=ufuf(x)\n    else:\n        uf[ufuf(x)]=ufuf(y)\n\nans=0\nfor i in range(1,n+1):\n    if ufuf(i)==ufuf(P[i-1]):\n        ans+=1\nprint(ans)", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN, M = mapint()\nPs = [p-1 for p in list(mapint())]\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\nuf = UnionFind(N)\nfor _ in range(M):\n    x, y = mapint()\n    uf.union(x-1, y-1)\n\nroots = uf.roots()\nroot_set = [set() for _ in range(N)]\n\nfor i in range(N):\n    root_set[uf.find(i)].add(i)\n\nans = 0\nfor i in range(N):\n    p = Ps[i]\n    if p in root_set[uf.find(i)]:\n        ans += 1\nprint(ans)", "class Unionfind():  # Unionfind\n    def __init__(self, N):\n        self.N = N\n        self.parents = [-1] * N\n\n    def find(self, x):  # \u30b0\u30eb\u30fc\u30d7\u306e\u6839\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):  # \u30b0\u30eb\u30fc\u30d7\u306e\u4f75\u5408\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def groups(self):  # \u5168\u3066\u306e\u30b0\u30eb\u30fc\u30d7\u3054\u3068\u306e\u8981\u7d20\n        members_dict = {i: set() for i, x in enumerate(self.parents) if x < 0}\n        for i in range(self.N):\n            members_dict[self.find(i)].add(i)\n        return members_dict\n\n\nn, m = list(map(int, input().split()))\np = list(map(int, input().split()))\nxy = [list(map(int, input().split())) for _ in range(m)]\n\nuf = Unionfind(n)\nfor x, y in xy:\n    uf.union(x - 1, y - 1)\n\nans = 0\nfor lst in list(uf.groups().values()):\n    ans += sum((p[num] - 1 in lst) for num in lst)\nprint(ans)\n", "class UnionFind:\n  def __init__(self, N):\n    self.par=[i for i in range(N)]\n    self.rank=[0 for _ in range(N)]\n    self.size=[1 for _ in range(N)]\n    \n  def unite(self, x, y):\n    x=self.getroot(x)\n    y=self.getroot(y)\n    if x!=y:\n      if self.rank[x]<self.rank[y]:\n        x, y=y, x\n      if self.rank[x]==self.rank[y]:\n        self.rank[x]+=1\n      self.par[y]=x\n      self.size[x]+=self.size[y]\n      \n  def united(self, x, y):\n    return self.getroot(x)==self.getroot(y)\n      \n  def getroot(self, x):\n    if self.par[x]==x:\n      return x\n    else:\n      self.par[x]=self.getroot(self.par[x])\n      return self.par[x]\n\n  def getsize(self, x):\n    return self.size[self.getroot(x)]\n  \n\nN, M=map(int, input().split())\nUF=UnionFind(N+1)\np=[0]+list(map(int, input().split()))\nfor _ in range(M):\n  x, y=map(int, input().split())\n  UF.unite(x, y)\n  \nprint(sum([1 for i in range(1, N+1) if UF.getroot(i)==UF.getroot(p[i])]))", "N,M=map(int,input().split())\n*P,=map(int,input().split())\nxy=[list(map(int,input().split()))for _ in range(M)]\n\nR=[-1]*(N+1)\ndef root(x):\n    while R[x]>=0:\n        x=R[x]\n    return x\ndef union(x,y):\n    x=root(x)\n    y=root(y)\n    if x==y:\n        return\n    if R[x]>R[y]:\n        x,y=y,x\n    R[x]+=R[y]\n    R[y]=x\n\nfor x,y in xy:\n    union(x,y)\nans=sum(root(i+1)==root(P[i])for i in range(N))\nprint(ans)", "import sys\n\ninput = sys.stdin.readline\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def all_group_members(self):\n        d = {root: [] for root in self.roots()}\n        for i in range(self.n):\n            d[self.find(i)].append(i)\n        return d\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = list(map(int, input().split()))\np = list(map(int, input().split()))\nxy = [list(map(int, input().split())) for _ in range(M)]\nuf = UnionFind(N)\n\nfor x, y in xy:\n    x -= 1\n    y -= 1\n    uf.union(x, y)\n\nans = 0\nfor renketu_seibun in list(uf.all_group_members().values()):\n    can_reach = set([p[v]-1 for v in renketu_seibun])\n    for v in renketu_seibun:\n        ans += v in can_reach\nprint(ans)\n", "n,m=map(int,input().split())\np=[[0]]+[[int(i)]for i in input().split()]\nq=[[i]for i in range(n+1)]\npar=[i for i in range(n+1)]\ndef find(x):\n  if x==par[x]:\n      return x\n  else:\n      par[x]=find(par[x])\n      return par[x]\ndef unite(x,y):\n  x,y=find(x),find(y)\n  if x>y:x,y=y,x\n  if x!=y:\n    par[y]=x\n    p[x]+=p[y]\n    q[x]+=q[y]\nfor _ in range(m):\n    a,b=map(int,input().split())\n    unite(a,b)\nfor i in range(n):find(i)\nans=-1\nfor i in set(par):\n    ans+=len(set(p[i])&set(q[i]))\nprint(ans)", "N,M=map(int,input().split())\n*P,=map(int,input().split())\nxy=[list(map(int,input().split()))for _ in range(M)]\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nuf=UnionFind(N)\nfor x,y in xy:\n    uf.union(x-1,y-1)\nans=sum(uf.same(i,P[i]-1)for i in range(N))\nprint(ans)", "import sys\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n\nN, M = list(map(int, input().split()))\nP = list([int(x) - 1 for x in input().split()])\nds = DisjointSet(N)\nfor _ in range(M):\n    x, y = [int(x) - 1 for x in input().split()]\n    ds.union(x, y)\nprint((sum(ds.same(P[i], i) for i in range(N))))\n", "n,m=list(map(int,input().split()))\np=list(map(int,input().split()))\nfrom collections import defaultdict\nfrom collections import deque\nc=0\nfor i in range(n):\n    if p[i]==i+1:\n        c+=1\nvis=[0]*n\ndef dfs(x):\n    vis[x]=1\n    a.add(x+1)\n    \n    di = deque()\n    di.append(x)\n    while di:\n        now = di.popleft()\n        for j in d[now]:\n            if not vis[j]:\n                vis[j] = 1\n                a.add(j+1)\n                di.append(j)\n    \n    \n    for u in d[x]:\n        if vis[u]==0:\n            dfs(u)\nd=defaultdict(list)\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    d[a-1].append(b-1)\n    d[b-1].append(a-1)\nans=0\nfor i in range(n):\n    if vis[i]==0:\n        a=set()\n        dfs(i)\n        l=0\n        z=0\n        for j in a:\n            if p[j-1] in a:\n                z+=1\n            if p[j-1]==j:\n                l+=1\n        ans=max(ans,c+z-l)\nprint(ans)\n        \n                \n                \n    \n    \n    \n", "import sys\n\ninput = sys.stdin.readline\nN, M = map(int, input().split())\nP = list(map(int, input().split()))\n\nedges = [[] for _ in range(N)]\nfor _ in range(M):\n    x, y = map(int, input().split())\n    edges[x-1].append(y-1)\n    edges[y-1].append(x-1)\n\n\nans = 0\nvisited = set()\nfor i in range(N):\n    q = [i]\n    loop = set()\n    values = set()\n    while q:\n        x = q.pop()\n        if x in visited:\n            continue\n        visited.add(x)\n        loop.add(x+1)\n        values.add(P[x])\n\n        for nx in edges[x]:\n            if nx not in visited:\n                q.append(nx)\n\n    ans += len(loop & values)\n\nprint(ans)", "from collections import Counter\n\nclass Unionfind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * (n+1)\n        \n    def find(self, x):\n        if(self.parents[x] < 0):\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n        \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if(x == y):\n            return\n        \n        if(self.parents[x] > self.parents[y]):\n            x, y = y, x\n            \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    \n    def group_count(self):\n        return len(self.roots())\n    \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    \n    def __str__(self):\n        return '\\n'.join('{}:{}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\np = list(map(int, input().split()))\n\nuf = Unionfind(N)\n\nfor i in range(M):\n    x, y = map(int, input().split())\n    uf.union(x-1, y-1)\n\ncnt = sum(uf.same(p[i]-1, i) for i in range(N))\nprint(cnt)", "#!/usr/bin/env python3\nimport sys\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n + 1)]\n        self.rank = [0] * (n + 1)\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.parents[x] = y\n        else:\n            self.parents[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    P = list([int(x) - 1 for x in input().split()])\n    XY = [list([int(x) - 1 for x in input().split()]) for _ in range(M)]\n\n    value_to_index = [0] * N\n    for i, p in enumerate(P):\n        value_to_index[p] = i\n\n    uf = UnionFind(N)\n    for x, y in XY:\n        uf.union(x, y)\n\n    ans = 0\n    for i in range(N):\n        if uf.find(i) == uf.find(value_to_index[i]):\n            ans += 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nN,M = map(int,input().split())\nP = list(map(int,input().split()))\nP.insert(0,0)\nG = {i:[] for i in range(1,N+1)}\nfor _ in range(M):\n    x,y = map(int,input().split())\n    G[x].append(y)\n    G[y].append(x)\ncol = [-1 for _ in range(N+1)]\ncnt = 0\nfor i in range(1,N+1):\n    if col[i]<0:\n        col[i]=cnt\n        que = deque([i])\n        while que:\n            x = que.popleft()\n            for y in G[x]:\n                if col[y]<0:\n                    col[y]=cnt\n                    que.append(y)\n        cnt += 1\nC = {c:[] for c in range(cnt)}\nfor i in range(1,N+1):\n    C[col[i]].append(i)\nB = {c:[] for c in range(cnt)}\nfor c in C:\n    for i in C[c]:\n        B[c].append(P[i])\nans = 0\nfor c in C:\n    a = set(C[c])\n    b = set(B[c])\n    ans += len(a&b)\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = list(map(int, input().split()))\nuf = UnionFind(N+1)\np_list = list(map(int, input().split()))\n\nfor i in range(M):\n    x, y = list(map(int, input().split()))\n    uf.union(x, y)\n\nans = 0\nfor i in range(N):\n    if uf.find(p_list[i]) == uf.find(i+1):\n        ans += 1\nprint(ans)\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1]*(n+1)\n        self.rnk = [0]*(n+1)\n\n    def find_root(self, x):\n        if(self.root[x] < 0):\n            return x\n        else:\n            self.root[x] = self.find_root(self.root[x])\n            return self.root[x]\n        \n    def unite(self, x, y):\n        x = self.find_root(x)\n        y = self.find_root(y)\n        if(x == y):\n            return \n        elif(self.rnk[x] > self.rnk[y]):\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if(self.rnk[x] == self.rnk[y]):\n                self.rnk[y] += 1\n                \n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    def count(self, x):\n        return -self.root[self.find_root(x)]\n\n    \nf=lambda:map(int,input().split())\nN,M=f()\nuf=UnionFind(N+1)\n\np=list(f())\np_index=[[] for _ in [0]*(N+1)]\nfor i in range(1,N+1):\n    p_index[p[i-1]]=i\nfor _ in [0]*M:\n    uf.unite(*f())\n\n\nindex_list=[[] for _ in [0]*(N+1)]\ngroup_list=[[] for _ in [0]*(N+1)]\n\nfor i in range(1,N+1):\n    index_list[uf.find_root(i)].append(p_index[i])\n    group_list[uf.find_root(i)].append(i)\n    \nres=0\nfor i in range(1,N+1):\n    if i==uf.find_root(i):\n        res+=len(set(index_list[i]) & set(group_list[i]))\n\nprint(res)", "import bisect\nimport heapq\nimport itertools\nimport sys\nimport math\nimport random\nimport time\nfrom collections import Counter, deque, defaultdict\nfrom functools import reduce\nfrom operator import xor\nfrom types import FunctionType\nfrom typing import List\n\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 9)\n\n\ndef lmi():\n    return list(map(int, input().split()))\n\n\ndef narray(*shape, init=0):\n    if shape:\n        num = shape[0]\n        return [narray(*shape[1:], init=init) for _ in range(num)]\n    return init\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        for i in range(self.n):\n            if self.find(i) == root:\n                yield i\n\n    def roots(self):\n        for i, x in enumerate(self.parents):\n            if x < 0:\n                yield i\n\n    def group_count(self):\n        return len(list(self.roots()))\n\n    def all_group_members(self):\n        ret = defaultdict(list)\n        for i in range(self.n):\n            root = self.find(i)\n            ret[root].append(i)\n        return ret\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, list(members)) for r, members in self.all_group_members())\n\n\ndef main():\n    N, M = lmi()\n    P = lmi()\n    XY = [lmi() for _ in range(M)]\n    uf = UnionFind(N)\n    for x, y in XY:\n        x, y = x - 1, y - 1\n        uf.union(P[x] - 1, P[y] - 1)\n    ans = 0\n    for i in range(N):\n        ans += uf.same(P[i] - 1, i)\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "class UnionFind:\n    # \u3053\u306e\u6642\u70b9\u3067\u305d\u308c\u305e\u308c\u306e\u30ce\u30fc\u30c9\u306f\u81ea\u5206\u3092\u89aa\u3068\u3057\u3066\u3044\u308b\n    # \u521d\u671f\u5316\u6642\u306b\u554f\u984c\u304c0\u306e\u9802\u70b9\u3092\u8a8d\u3081\u308b\u304b\u306b\u6ce8\u610f\u3059\u308b\u3053\u3068\n    def __init__(self, n):\n        self.N = n\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n\n    # x\u306e\u6839\u3092\u8fd4\u3059\u95a2\u6570\n    def root(self, x):\n        visited_nodes = []\n        while True:\n            p = self.parent[x]\n            if p == x:\n                # \u7e2e\u7d04\n                for node in visited_nodes:\n                    self.parent[node] = x\n                return x\n            else:\n                visited_nodes.append(x)\n                x = p\n\n    # \u6728\u306e\u7d50\u5408\u3092\u884c\u3046\u3002\u89aa\u306e\u914d\u4e0b\u306b\u5165\u308b\n    def unite(self, x, y):\n        if not self.root(x) == self.root(y):\n            if self.rank[x] > self.rank[y]:\n                self.parent[self.root(y)] = self.root(x)\n            else:\n                self.parent[self.root(x)] = self.root(y)\n                if self.rank[x] == self.rank[y]:\n                    self.rank[self.root(y)] += 1\n\n    def ifSame(self, x, y):\n        return self.root(x) == self.root(y)\n\n    # \u6728\u306e\u6839\u306b\u5230\u9054\u3059\u307e\u3067\u306b\u305f\u3069\u308b\u30ce\u30fc\u30c9\u306e\u914d\u5217\u3092\u8fd4\u3059\n    def printDebugInfo(self):\n        print([self.root(i) for i in range(self.N)])\n\n\nN, M = list(map(int, input().split()))\nP = [int(x) for x in input().split()]\ntree = UnionFind(N)\nfor _ in range(M):\n    X, Y = list(map(int, input().split()))\n    tree.unite(X - 1, Y - 1)\n\ncount = 0\nfor i in range(N):\n    if tree.ifSame(P[i]-1, i):\n        count += 1\nprint(count)\n", "n,m=list(map(int,input().split()))\np=list(map(int,input().split()))\nxy=[list(map(int,input().split())) for _ in range(m)]\n\nfrom collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\n\n\nuf=UnionFind(n)\nfor i in xy:\n    uf.union(i[0]-1,i[1]-1)\n\nans=0\nfor i in range(n):\n    if uf.same(i,p[i]-1):\n        ans+=1\n\nprint(ans)\n", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\nn, m = map(int, input().split())\np = list(map(int, input().split()))\na = [list(map(int, input().split())) for i in range(m)]\nuf = UnionFind(n)\nfor i in range(m):\n  uf.union(a[i][0]-1, a[i][1]-1)\nans = 0\nfor i in range(n):\n  if uf.same(p[i]-1, i):\n    ans += 1\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m = list(map(int,input().split()))\nuf = UnionFind(n)\np = list(map(int,input().split()))\nfor _ in range(m):\n  a,b=list(map(int,input().split()))\n  a-=1\n  b-=1\n  uf.union(a,b)\n\npp = [set() for _ in range(n)]\nqq = [set() for _ in range(n)]\n\nfor i in range(n):\n  r = uf.find(i)\n  pp[r].add(i)\n  qq[r].add(p[i]-1)\n\nans = 0\nfor i in range(n):\n  ans += len(pp[i] & qq[i])\nprint(ans)\n", "n,m=map(int,input().split())\np=[int(i)for i in input().split()]\npar=[i for i in range(n)]\ndef find(x):\n  if x==par[x]:\n      return x\n  else:\n      par[x]=find(par[x])\n      return par[x]\ndef unite(x,y):\n  x,y=find(x),find(y)\n  if x>y:x,y=y,x\n  if x!=y:\n    par[y]=x\nfor _ in range(m):\n    a,b=map(int,input().split())\n    unite(a-1,b-1)\nfor i in range(n):find(i)\nprint(sum(find(i)==find(p[i]-1)for i in range(n)))", "import sys\nimport queue\n\ninput_methods=['clipboard','file','key']\nusing_method=0\ninput_method=input_methods[using_method]\n\ntin=lambda : map(int, input().split())\nlin=lambda : list(tin())\nmod=1000000007\n\n#+++++\n\ndef main():\n\t#a = int(input())\n\tn, m = tin()\n\t#s = input()\n\tal = [-1]+lin()\n\tbb=[[] for _ in range(n+1)]\n\tfor _ in range(m):\n\t\ta, b = tin()\n\t\tbb[a].append(b)\n\t\tbb[b].append(a)\n\t\t\n\tll=[]\n\tis_open = [0] *(n+1)\n\tfor i in range(n+1):\n\t\tq=queue.Queue()\n\t\tq.put(i)\n\t\tt=[]\n\t\twhile not q.empty():\n\t\t\tpp=q.get()\n\t\t\tif is_open[pp] != 0:\n\t\t\t\tcontinue\n\t\t\tis_open[pp]=1\n\t\t\tt.append(pp)\n\t\t\tfor v in bb[pp]:\n\t\t\t\tq.put(v)\n\t\tll.append(t)\n\t\n\tret = 0\n\t#pa(ll)\n\tfor t in ll:\n\t\tst=set(t)\n\t\tfor v in t:\n\t\t\tif al[v] in st:\n\t\t\t\tret += 1\n\tprint(ret)\n\t\t\t\t\n\t\t\n\t\t\n\t\n\t\n\t\n\t\n\t\n#+++++\nisTest=False\n\ndef pa(v):\n\tif isTest:\n\t\tprint(v)\n\t\t\ndef input_clipboard():\n\timport clipboard\n\tinput_text=clipboard.get()\n\tinput_l=input_text.splitlines()\n\tfor l in input_l:\n\t\tyield l\n\ndef __starting_point():\n\tif sys.platform =='ios':\n\t\tif input_method==input_methods[0]:\n\t\t\tic=input_clipboard()\n\t\t\tinput = lambda : ic.__next__()\n\t\telif input_method==input_methods[1]:\n\t\t\tsys.stdin=open('inputFile.txt')\n\t\telse:\n\t\t\tpass\n\t\tisTest=True\n\telse:\n\t\tpass\n\t\t#input = sys.stdin.readline\n\t\t\t\n\tret = main()\n\tif ret is not None:\n\t\tprint(ret)\n__starting_point()", "import sys\nimport math\nimport collections\nimport bisect\nimport copy\nimport itertools\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline().rstrip())\nns = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().rstrip().split()])\n\n\n# ===CODE===\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef main():\n    n, m = ns()\n    p = na1()\n\n    uf = UnionFind(n)\n\n    for _ in range(m):\n        x, y = ns()\n        uf.union(x - 1, y - 1)\n\n    ans = 0\n    for i, pi in enumerate(p):\n        if uf.same(i, pi):\n            ans += 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFind(object):\n    def __init__(self, n=1):\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\nn,m=map(int, input().split())\nuf1=UnionFind(n)\np=list(map(int,input().split()))\nfor i in range(m):\n    a,b=map(int, input().split())\n    uf1.union(a-1,b-1)\n\nfor i in range(n):uf1.find(i) \nans=0\nfor i in range(n):\n    if uf1.par[i]==uf1.par[p[i]-1]:\n        ans+=1\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef func(x):\n    return x - 1\n\ndef main():\n    N, M = map(int, input().split())\n    P = list(map(func, map(int, input().split())))\n    uni = UnionFind(N)\n    for _ in range(M):\n        x, y = map(int, input().split())\n        x -= 1\n        y -= 1\n        uni.union(x,y)\n\n    ans = 0\n    for i, p in enumerate(P):\n        if uni.same(i,p):\n            ans += 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N, M = list(map(int, input().split()))\np_list = list(map(int, input().split()))\nqueries = [list(map(int, input().split())) for i in range(M)]\npaths = [[] for i in range(N+1)]\nfor a, b in queries:\n    paths[a].append(b)\n    paths[b].append(a)\n\ngroups = []\nvisited = [False] * (N+1)\nfor start in range(N+1):\n    if visited[start] == True:\n        continue\n    queue = [start]\n    t_group = set()\n    t_group.add(start)\n    visited[start] = True\n    while queue:\n        now = queue.pop()\n        for next in paths[now]:\n            if visited[next] == True:\n                continue\n            queue.append(next)\n            t_group.add(next)\n            visited[next] = True\n    groups.append(t_group)\n\nresult = 0\nfor group in groups[1:]: # \u30bb\u30c3\u30c8\u306e\u6700\u521d\u306f{0}\u306b\u306a\u3063\u3066\u3044\u308b\u305f\u3081\n    result += sum(1 for m in group if p_list[m-1] in group)\n\nprint(result)\n\n", "class Union_Find():\n    def __init__(self,N):\n        \"\"\"0,1,...,n-1\u3092\u8981\u7d20\u3068\u3057\u3066\u521d\u671f\u5316\u3059\u308b.\n\n        n:\u8981\u7d20\u6570\n        \"\"\"\n        self.n=N\n        self.parents=[-1]*N\n        self.rank=[0]*N\n\n    def find(self, x):\n        \"\"\"\u8981\u7d20x\u306e\u5c5e\u3057\u3066\u3044\u308b\u65cf\u3092\u8abf\u3079\u308b.\n\n        x:\u8981\u7d20\n        \"\"\"\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        \"\"\"\u8981\u7d20x,y\u3092\u540c\u4e00\u8996\u3059\u308b.\n\n        x,y:\u8981\u7d20\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.rank[x]>self.rank[y]:\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n        else:\n            self.parents[y] += self.parents[x]\n            self.parents[x] = y\n\n            if self.rank[x]==self.rank[y]:\n                self.rank[y]+=1\n\n    def size(self, x):\n        \"\"\"\u8981\u7d20x\u306e\u5c5e\u3057\u3066\u3044\u308b\u8981\u7d20\u306e\u6570.\n\n        x:\u8981\u7d20\n        \"\"\"\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        \"\"\"\u8981\u7d20x,y\u306f\u540c\u4e00\u8996\u3055\u308c\u3066\u3044\u308b\u304b?\n\n        x,y:\u8981\u7d20\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        \"\"\"\u8981\u7d20x\u304c\u5c5e\u3057\u3066\u3044\u308b\u65cf\u306e\u8981\u7d20.\n        \u203b\u65cf\u306e\u8981\u7d20\u306e\u500b\u6570\u304c\u6b32\u3057\u3044\u3068\u304d\u306fsize\u3092\u4f7f\u3046\u3053\u3068!!\n\n        x:\u8981\u7d20\n        \"\"\"\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        \"\"\"\u65cf\u306e\u540d\u524d\u306e\u30ea\u30b9\u30c8\n        \"\"\"\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        \"\"\"\u65cf\u306e\u500b\u6570\n        \"\"\"\n        return len(self.roots())\n\n    def all_group_members(self):\n        \"\"\"\u5168\u3066\u306e\u65cf\u306e\u51fa\u529b\n        \"\"\"\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n#================================================\nN,M=map(int,input().split())\nP=list(map(lambda x:int(x)-1,input().split()))\n\nU=Union_Find(N)\nfor _ in range(M):\n    a,b=map(int,input().split())\n    U.union(a-1,b-1)\n\nK=0\nfor x in range(N):\n    K+=U.same(x,P[x])\nprint(K)", "N, M = map(int, input().split())\nP = list(map(int, input().split()))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nuf = UnionFind(N)\nfor _ in range(M):\n    x, y = map(int, input().split())\n    uf.union(x-1, y-1)\n\nans = 0\nfor i in range(N):\n    if uf.same(i, P[i]-1):\n        ans += 1\n\nprint(ans)", "# unionfind\nclass Uf:\n\tdef __init__(self, N):\n\t\tself.p = list(range(N))\n\t\tself.rank = [0] * N\n\t\tself.size = [1] * N\n\t#\u691c\u7d22 \u30ce\u30fc\u30c9\u756a\u53f7\u3092\u53d7\u3051\u53d6\u3063\u3066\u4e00\u756a\u4e0a\u306e\u89aa\u30ce\u30fc\u30c9\u306e\u756a\u53f7\u3092\u5e30\u3059\n\tdef root(self, x):\n\t\tif self.p[x] != x:\n\t\t\tself.p[x] = self.root(self.p[x])\n\n\t\treturn self.p[x]\n\t#\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n\tdef same(self, x, y):\n\t\treturn self.root(x) == self.root(y)\n\t#\u4f75\u5408\n\tdef unite(self, x, y):\n\t\t# \u6839\u3092\u63a2\u3059\n\t\tu = self.root(x)\n\t\tv = self.root(y)\n\n\t\tif u == v: return\n\n\t\t#\u6728\u306e\u9ad8\u3055\u3092\u6bd4\u8f03\u3057\u3001\u4f4e\u3044\u307b\u3046\u304b\u3089\u9ad8\u3044\u307b\u3046\u306b\u8fba\u3092\u5f35\u308b\n\t\tif self.rank[u] < self.rank[v]:\n\t\t\tself.p[u] = v\n\t\t\tself.size[v] += self.size[u]\n\t\t\tself.size[u] = 0\n\t\telse:\n\t\t\tself.p[v] = u\n\t\t\tself.size[u] += self.size[v]\n\t\t\tself.size[v] = 0\n\t\t\t#\u6728\u306e\u9ad8\u3055\u304c\u540c\u3058\u306a\u3089\u7247\u65b9\u30921\u5897\u3084\u3059\n\t\t\tif self.rank[u] == self.rank[v]:\n\t\t\t\tself.rank[u] += 1\n\t#\u30ce\u30fc\u30c9\u756a\u53f7\u3092\u53d7\u3051\u53d6\u3063\u3066\u3001\u305d\u306e\u30ce\u30fc\u30c9\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u96c6\u5408\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\n\tdef count(self, x):\n\t\treturn self.size[self.root(x)]\n\nN, M = map(int, input().split())\nuf=Uf(N)\nP = list(map(int, input().split()))\nP=[i-1 for i in P]\nfor i in range(M):\n\tx, y = map(int, input().split())\n\tx-=1\n\ty-=1\n\tuf.unite(x,y)\n\n#\u300c\u5024i\u3092\u542b\u3080\u4f4d\u7f6ej\u3068\u4f4d\u7f6ei\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3057\u3066\u3044\u308b\u300d\u3068\u3044\u3046\u6761\u4ef6\u3092\u6e80\u305f\u3059i\u306e\u6570\u3092\u6570\u3048\u308b\nans=0\nfor i in range(N):\n\tif uf.root(P[i]) == uf.root(i):\n\t\tans+=1\nprint(ans)", "'''\n\u81ea\u5b85\u7528PC\u3067\u306e\u89e3\u7b54\n'''\nimport math\n#import numpy as np\nimport itertools\nimport queue\nimport bisect\nfrom collections import deque,defaultdict\nimport heapq as hpq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\nmod = 10**9+7\ndir = [(-1,0),(0,-1),(1,0),(0,1)]\nalp = \"abcdefghijklmnopqrstuvwxyz\"\n\n#UnionFind\u306e\u30af\u30e9\u30b9\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return set([i for i in range(self.n) if self.find(i) == root])\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return [self.members(r) for r in self.roots()]\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef main():\n    n,m = list(map(int,ipt().split()))\n    p = [int(i)-1 for i in ipt().split()]\n    uf = UnionFind(n)\n    for i in range(m):\n        x,y = list(map(int,ipt().split()))\n        uf.union(x-1,y-1)\n\n    ans = 0\n    for i in range(n):\n        if uf.same(i,p[i]):\n            ans += 1\n\n    print(ans)\n\n    return None\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = map(int, input().split())\npn = list(map(lambda x:int(x)-1, input().split()))\nls = [-1] * n\nfor i in pn:\n    ls[pn[i]] = i\n#print(ls)\n\npar = [i for i in range(n)]\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        s = find(par[x])\n        par[x] = s\n        return s\n\ndef unite(x,y):\n    s = find(x)\n    t = find(y)\n    if s>t:\n        par[s] = t\n    else:\n        par[t] = s\n\n\nfor _ in range(m):\n    x, y = map(lambda x:int(x)-1, input().split())\n    unite(ls[x],ls[y])\n\ndic = {}\nfor i in range(n):\n    a = find(i)\n    if a in dic:\n        dic[a].add(ls[i])\n    else:\n        dic[a] = set([ls[i]])\n#print(dic)\n#print(par)\nans = 0\nfor i in range(n):\n    if i in dic[find(i)]:\n       ans+=1\nprint(ans)", "import sys\n\nsys.setrecursionlimit(6500)\n\ndef find(n):\n    if d[n]<0:\n        return n\n    else:\n        d[n]=find(d[n])\n        return d[n]\n\ndef union(a,b):\n    a=find(a)\n    b=find(b)\n    if a==b:return False\n    if d[a]<=d[b]:\n        d[a]+=d[b]\n        d[b]=a\n    else:\n        d[b]+=d[a]\n        d[a]=b\n    return True\n\ndef members(n):\n    p=find(n)\n    ans=[]\n    for i in range(N):\n        if find(i)==p:\n            ans.append(i)\n    return ans\n\ndef same(a,b):\n    if find(a)==find(b):return True\n    else:return False\n\nN,M=map(int,input().split())\np=list(map(int,input().split()))\n\nd=[-1]*N\n\nfor i in range(M):\n    x,y=map(int,input().split())\n    x,y=x-1,y-1\n    union(x,y)\n\nq=[-1]*N\nfor i in range(N):\n    q[p[i]-1]=i\nans=0\nfor i in range(N):\n    if same(i,q[i]):\n        ans+=1\nprint(ans)", "class Unionfind():  # Unionfind\n    def __init__(self, N):\n        self.N = N\n        self.parents = [-1] * N\n\n    def find(self, x):  # \u30b0\u30eb\u30fc\u30d7\u306e\u6839\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):  # \u30b0\u30eb\u30fc\u30d7\u306e\u4f75\u5408\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def groups(self):  # \u5168\u3066\u306e\u30b0\u30eb\u30fc\u30d7\u3054\u3068\u306e\u8981\u7d20\n        members_dict = {}\n        for i in range(self.N):\n            if self.find(i) not in members_dict:\n                members_dict[self.find(i)] = set()\n            members_dict[self.find(i)].add(i)\n        return members_dict\n\n\nn, m = list(map(int, input().split()))\np = list(map(int, input().split()))\nxy = [list(map(int, input().split())) for _ in range(m)]\n\nuf = Unionfind(n)\nfor x, y in xy:\n    uf.union(x - 1, y - 1)\n\nans = 0\nfor lst in list(uf.groups().values()):\n    ans += sum((p[num] - 1 in lst) for num in lst)\nprint(ans)\n", "n,m=list(map(int, input().split()))\np=list([int(x)-1 for x in input().split()])\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1]*n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nuf=UnionFind(n)\nfor _ in range(m):\n    x,y=[int(x)-1 for x in input().split()]\n    uf.union(x,y)\n\nans=0\nfor i in range(len(p)):\n    if uf.is_same(i, p[i]):\n        ans+=1\nprint(ans)\n", "import sys\nstdin=sys.stdin\n\nip=lambda: int(sp())\nfp=lambda: float(sp())\nlp=lambda:list(map(int,stdin.readline().split()))\nsp=lambda:stdin.readline().rstrip()\nyp=lambda:print('Yes')\nnp=lambda:print('No')\n\nfrom collections import Counter\n\nclass union_find():\n    def __init__(self,n):\n        self.n=n\n        ##\u89aa\u8981\u7d20\u306e\u30ce\u30fc\u30c9\u756a\u53f7\u3092\u683c\u7d0d\u3002par[x]==x\u306e\u3068\u304d\u305d\u306e\u30ce\u30fc\u30c9\u306f\u6839\n        ##\u89aa\u3068\u306f\u305d\u306e\u4e0a\u306b\u30ce\u30fc\u30c9\u306a\u3057\uff01\uff01\u3000\n        self.par=[-1 for i in range(n)]\n        self.rank=[0]*(n)\n\n    def find(self,x):\n        if self.par[x]<0:\n            return x\n        else:\n            self.par[x]=self.find(self.par[x])\n            \n            return self.par[x]\n\n    def union(self,x,y):\n        x=self.find(x)\n        y=self.find(y)\n\n        ##\u6728\u306e\u9ad8\u3055\u3092\u6bd4\u8f03\u3057\u3001\u4f4e\u3044\u65b9\u304b\u3089\u9ad8\u3044\u65b9\u3078\u8fba\u3092\u306f\u308b\n        if x==y:\n          return\n\n        if self.par[x]>self.par[y]:\n          x,y=y,x\n          \n        self.par[x]+=self.par[y]\n        self.par[y]=x\n\n    def same(self,x,y):\n        return self.find(x) == self.find(y)\n    \n    def size(self,x):\n      return -self.par[self.find(x)]\n      \n    def members(self,x):\n      root=self.find(x)\n      return [i for i in range(self.n) if self.find(i)==root]\n    \n    def roots(self):\n      return [i for i, x in enumerate(self.par) if x<0]\n    \n    def all_group_member(self):\n      return {r:self.members(r) for r in self.roots()}\n    \nn,m=lp()\na=lp()\nuf=union_find(n)\nfor _ in range(m):\n  x,y=lp()\n  uf.union(x-1,y-1)\n  \nans=0\nfor i in range(n):\n  now=a[i]-1\n  if uf.same(i,now):\n    ans+=1\n\nprint(ans)", "n,m=list(map(int,input().split()))\np=list(map(int,input().split()))\nnum=[[] for _ in range(n)]\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    num[x-1].append(y)\n    num[y-1].append(x)\nseen=[False]*n\nans=list(range(n))\nfor i in range(n):\n    if seen[i]==False:\n        queue=[i]\n        seen[i]=True\n        for j in range(n):\n            if len(queue)==0:\n                break\n            num1=queue.pop()\n            ans[num1]=i\n            for k in range(len(num[num1])):\n                num2=num[num1][k]-1\n                if seen[num2]==False:\n                    queue.append(num2)\n                    seen[num2]=True\nans2=0\nfor i in range(n):\n    if ans[i]==ans[p[i]-1]:\n        ans2+=1\nprint(ans2)\n"]
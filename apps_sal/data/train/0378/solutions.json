["class Solution:\n     def canPartition(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         _sum=sum(nums)\n         div,mod=divmod(_sum,2)\n         if mod!=0:\n             return False\n         target=[div]*2\n         self._len=len(nums)\n         nums.sort(reverse=True)\n         def dfs(index,target):\n             if index==self._len:\n                 return True\n             num=nums[index]\n             for i in range(2):\n                 if target[i]>=num:\n                     target[i]-=num\n                     if dfs(index+1,target):return True\n                     target[i]+=num\n             return False\n         return dfs(0,target)\n             \n         \n         \n", "class Solution:\n     def canPartition(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         _sum = sum(nums)\n         div, mod = divmod(_sum, 2)\n         if mod or max(nums) > div: return False\n         nums.sort(reverse = True)\n         target = [div] * 2\n         return self.dfs(nums, 0, target)\n     \n     def dfs(self, nums, index, target):\n         for i in range(2):\n             if target[i] >= nums[index]:\n                 target[i] -= nums[index]\n                 if target[i] == 0 or self.dfs(nums, index + 1, target): return True\n                 target[i] += nums[index]\n         return False", "class Solution:\n     def canPartition(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         nums.sort( reverse=True)\n         print(nums)\n         numsum = sum(nums)\n         if numsum %2 != 0:\n             return False\n         halfsum = numsum //2\n         t_sum = nums[0]\n         if t_sum >halfsum:\n             return False\n         elif t_sum == halfsum:\n             return True\n \n         llen = len(nums) \n         for startpos in range(1,llen):\n             curpos = startpos\n             while t_sum<halfsum and curpos < llen:\n                 if (t_sum+nums[curpos]>halfsum):\n                     curpos += 1\n                 elif (t_sum+nums[curpos]==halfsum):\n                     #print(curpos, t_sum,len(nums))\n                     return True\n                 else:\n                     t_sum += nums[curpos]\n                     curpos += 1\n                 pass\n             t_sum=nums[0]\n         return False", "class Solution:\n     def search(self, nums, pos, target, seen):\n         if (pos, target) in seen:\n             return False\n         if target == 0:\n             return True\n         if pos >= len(nums) or nums[pos] > target:\n             return False\n         if self.search(nums, pos + 1, target - nums[pos], seen):\n             return True\n         if self.search(nums, pos + 1, target, seen):\n             return True\n         seen.add((pos, target))\n         return False\n         \n     def canPartition(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         s = sum(nums)\n         if s % 2 == 1:\n             return False\n         target = s // 2\n         nums = sorted(nums)\n         return self.search(nums, 0, target, set())\n", "class Solution:\n     def canPartition(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         \n         if len(nums) < 2:\n             return False\n         \n         s = sum(nums)\n         if s % 2 != 0:\n             return False\n         \n         s = s // 2\n         nums.sort()\n         mem = dict()\n         \n         return self.dp(nums, 0, s, mem)\n     \n     def dp(self, nums, start, s, mem):\n         \n         if s == 0:\n             return True\n         \n         if start >= len(nums):\n             return False\n         \n         state = mem.get((start, s), None)\n         if state is not None:\n             return state\n         \n         res = False\n         if nums[start] > s:\n             res = False\n             \n         else:\n             res = self.dp(nums, start+1, s-nums[start], mem) or self.dp(nums, start+1, s, mem)\n             \n         mem[(start, s)] = res\n         return res", "class Solution:\n     def canPartition(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         sum_ = sum(nums)\n         if sum_%2 == 0:\n             target = sum_/2\n             def myFun(t,nu):\n                 nu.sort()\n                 nu.reverse()\n                 for index,item in enumerate(nu):\n                     if item == t:\n                         return True\n                     elif item > t:\n                         return False\n                     else:\n                         nun = nu.copy()\n                         del nun[index]\n                         if myFun(t-item,nun):\n                             return True\n                         elif index == len(nu)-1:\n                             return False\n             return myFun(target,nums)\n         return False\n", "class Solution:\n     def canPartition(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         s = 0\n         bits = 1\n \n         for num in nums:\n             s += num\n             bits |= bits << num\n \n         return not (s & 1) and ((bits >> (s >> 1)) & 1) == 1\n", "class Solution:\n     def canPartition(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         '''\n         sums = sum(nums)\n         if sums & 1:\n             return False\n         target = sums//2\n         if max(nums) > target:\n             return False\n         elif max(nums) == target:\n             return True\n         target -= max(nums)\n         nums = [num for num in nums if num <= target]\n         if not nums:\n             return False\n         if target in nums:\n             return True\n         pool = set([0])\n         for num in nums:\n             for p in pool.copy():\n                 pool.add(num+p)\n         return target in pool\n         '''\n         '''\n         s = sum(nums)\n         if s & 1:\n             return False\n         target = s//2\n         pool = set([0])\n         for num in nums:\n             for p in pool.copy():\n                 pool.add(num+p)\n         return target in pool\n         '''\n         s = sum(nums)\n         if s & 1:\n             return False\n         target = s//2\n         cnt = collections.Counter(nums)\n         return self.helper(target, cnt)\n         \n     def helper(self, target, cnt):\n         if target == 0:\n             return True\n         if target < 0:\n             return False\n         for item in sorted(list(cnt.keys()), reverse=True):\n             if cnt[item] == 0:\n                 continue\n             cnt[item] -= 1\n             if self.helper(target-item, cnt):\n                 return True\n             cnt[item] += 1\n         return False\n", "class Solution:\n     def canPartition(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         target=sum(nums)\n         if target % 2==1: return False\n         target=target//2\n         if any([x for x in nums if x>target]): return False\n         nums.sort()\n         def check(nums,target):\n             if target in nums:\n                 return True\n             if (not nums) or (nums[0]>target):\n                 return False\n             res=False\n             tag=\"@\"\n             for i in range(len(nums)):\n                 if tag!=nums[i]:\n                     tag=nums[i]\n                     res=res|check(nums[:i]+nums[i+1:],target-nums[i])\n                     if res:return True\n             return res\n         return check(nums,target)\n             \n"]
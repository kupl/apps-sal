["class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        letters = {}\n        for i, char in enumerate(text):\n            if char in letters:\n                letters[char].append(i)\n            else:\n                letters[char] = [i]\n        \n        if len(letters) == 1:\n            return len(text)\n        \n        ans = 0\n        for letter in letters:\n            cur = 0\n            prev = 0 \n            discarded = False\n            maxSoFar = 0\n            arr = letters[letter]\n            for j, pos in enumerate(arr):\n                if not j:\n                    cur = 1\n                elif pos - arr[j-1] == 1:\n                    cur += 1\n                else:\n                    if not discarded and prev:\n                        discarded = True\n                    elif not discarded and pos - arr[j-1] > 2:\n                        discarded = True\n\n                    if prev + cur > maxSoFar:\n                        maxSoFar = prev+cur\n                    \n                    if pos - arr[j-1] == 2:\n                        prev = cur\n                        cur = 1\n                    else:\n                        prev = 0\n                        cur = 1\n            print((prev+cur))        \n            if prev + cur > maxSoFar:\n                    maxSoFar = prev+cur\n            if discarded:\n                maxSoFar+=1\n            if maxSoFar > ans:\n                ans = maxSoFar\n        \n        return ans\n                \n                    \n                    \n", "class Solution:\n    def maxRepOpt1(self, S: str) -> int:\n        # We get the group's key and length first, e.g. 'aaabaaa' -> [[a , 3], [b, 1], [a, 3]\n        A = [[c, len(list(g))] for c, g in itertools.groupby(S)]\n        # We also generate a count dict for easy look up e.g. 'aaabaaa' -> {a: 6, b: 1}\n        count = collections.Counter(S)\n        # only extend 1 more, use min here to avoid the case that there's no extra char to extend\n        res = max(min(k + 1, count[c]) for c, k in A)\n        # merge 2 groups together\n        for i in range(1, len(A) - 1):\n            # if both sides have the same char and are separated by only 1 char\n            if A[i - 1][0] == A[i + 1][0] and A[i][1] == 1:\n                # min here serves the same purpose\n                res = max(res, min(A[i - 1][1] + A[i + 1][1] + 1, count[A[i + 1][0]]))\n        return res", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        for k,g in itertools.groupby(text):\n            print(list(g))\n        G = [[k,len(list(g))] for k,g in itertools.groupby(text)]\n        c = collections.Counter(text)\n        \n        res = max(min(n+1, c[k]) for k,n in G)\n        \n        for i in range(1,len(G)-1):\n            if G[i-1][0] == G[i+1][0] and G[i][1] == 1:\n                res = max(min(G[i-1][1]+G[i+1][1]+1, c[G[i-1][0]]), res)\n        return res", "import itertools\nimport collections\n\nclass Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        import collections\n        counter = collections.Counter(text)\n        cnt = collections.defaultdict(int)\n        start = res = max_cnt = 0\n        for end, char in enumerate(text):\n            cnt[char] += 1\n            max_cnt = max(max_cnt, cnt[char])\n            while end - start + 1 > max_cnt +1:\n                cnt[text[start]] -= 1\n                max_cnt = max(cnt.values()) # This line can be commented\n                start += 1\n            res = max(res, min(end - start + 1, counter[char]))\n        return res", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        be = 1\n        n = collections.Counter(text)\n        \n        maxl = 0\n        i = 1\n        \n        re = []\n        now = text[0]\n        while(i<len(text)):\n            if now == text[i]:\n                be += 1\n            if now != text[i] or i == len(text)-1:\n                res = be\n                if len(re)>=2:\n                    print(re)\n                    com,lencom = re.pop(0)\n                    if re[-1][1] == 1 and com == now:\n                        res = lencom + be\n                if res<n[now]:\n                    res += 1\n                maxl = max(maxl,res)\n                #print(re)\n                re.append((now,be))\n                now = text[i]\n                be = 1\n            i += 1\n        return maxl\n                    \n            \n", "import itertools\nfrom collections import Counter\nclass Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        ref = [ [letter,len(list(s))] for letter,s in itertools.groupby(text)]\n        count = Counter(text)\n        res = max( [ min(count.get(i), k + 1) for i , k in ref] ) \n        for i in range(1,len(ref) - 1):\n            if ref[i-1][0] == ref[i+1][0] and ref[i][1] == 1 : \n                res = max(res, min(ref[i-1][1] + ref[i+1][1] + 1, count.get(ref[i-1][0]))  )\n        return res", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        # get group's key and length, e.g. 'aaabaa' -> [[a, 3], [b, 1], [a, 3]]\n        # itertools.groupby function returns consecutive keys and groups from the iterable.\n        # note itertools.groupby(iterable, key_func) supports lambda function\n        # If the key function is not specified or is None, key defaults to an identity function and returns the element unchanged.\n        A = [[c, len(list(g))] for c, g in itertools.groupby(text)]\n        # use count dict as upper bound 'aaabaa' -> {a: 6, b: 1}\n        count = collections.Counter(text)\n        # case 1: extend 1 more, use min here to avoid the case that there's no extra char to extend\n        res = max(min(k + 1, count[c]) for c, k in A)\n        # case 2: merge 2 groups together with 1 char in between\n        for i in range(1, len(A) - 1):\n            if A[i][1] == 1 and A[i - 1][0] == A[i + 1][0]:\n                res = max(res, min(A[i - 1][1] + 1 + A[i + 1][1], count[A[i - 1][0]]))\n        return res\n        \n        \n", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        text_cnt = collections.Counter(text)\n        d = collections.Counter()\n        l,r = 0, 0\n        maxcnt = 0\n        res = 0\n        N = len(text)\n        for r, ch in enumerate(text):\n            d[ch]+=1\n            maxcnt = max(maxcnt, d[ch])\n            while r-l+1>maxcnt+1:\n                d[text[l]]-=1\n                maxcnt = max(d.values())\n                l+=1\n            res = max(res, min(r-l+1, text_cnt[ch]))\n        return res", "from collections import Counter\n\nclass Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        if len(text) == 1:\n            return 1\n        counts = Counter(text)\n        # a b a b a.\n        pre = [1]\n        nex = [1]\n        ans = 1\n        for i in range(1, len(text)):\n            if text[i] == text[i - 1]:\n                pre.append(pre[-1] + 1)\n            else :\n                pre.append(1)\n            ans = max(pre[i], ans)\n                \n        for i in range(len(text) - 2, -1, -1):\n            if text[i] == text[i + 1]:\n                nex.append(nex[-1] + 1)\n            else:\n                nex.append(1)\n            ans = max(nex[len(text) - i - 1], ans)\n        nex.reverse()\n        \n        # Now try some swaps.\n        for i in range(len(text)):\n            # We will try to swap out i.\n            if i != len(text) - 1 and text[i] != text[i + 1]:\n                l = nex[i + 1]\n                if counts[text[i + 1]] > l:\n                    ans = max(ans, 1 + l)\n            if i != 0 and text[i] != text[i - 1]:\n                l = pre[i - 1]\n                if counts[text[i - 1]] > l:\n                    ans = max(ans, 1 + l)\n            if i != 0 and i != len(text) - 1 and text[i - 1] == text[i + 1]:\n                # Match both forwards and backwards.\n                l = pre[i - 1] + nex[i + 1]\n                if counts[text[i - 1]] > l:\n                    ans = max(ans, 1 + l)\n                else:\n                    # Can we still make it better?\n                    ans = max(ans, l)\n        return ans\n            \n        \n            \n", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        inuse = collections.defaultdict(int)  # chars used in the repeated substring\n        left = collections.defaultdict(int)  # not used chars\n        MOVE_TO_THE_NEXT_CHAR = 1\n        REPLACE = 0\n        LEAVE_AS_IT_IS = -1\n        res, i, n = 1, 0, 0\n\n        # initially no chars are used yet\n        for ch in text:\n            left[ch] += 1\n        \n        for j, ch in enumerate(text):\n            inuse[ch] += 1  # since we use this char\n            left[ch] -= 1  # subtract its count from left dict\n            n = max(inuse[ch], n)\n        \n            # this defines action we are going to take\n            action = j - i - n\n        \n            char_exists = False\n            if action >= MOVE_TO_THE_NEXT_CHAR:\n                inuse[text[i]] -= 1\n                left[text[i]] += 1  # add it to the left dict back, since it is no longer in use\n                i += 1\n\n            # we can replace only if we have unused char in the left dict    \n            elif action == REPLACE:\n                char_exists = left[ch] > 0 \n                \n            elif action == LEAVE_AS_IT_IS:\n                char_exists = True\n        \n            if char_exists and j - i >= res:\n                res = j - i + 1\n        \n        return res", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        from collections import Counter\n        counter = Counter(text)\n        if not text: return 0\n        if len(text) == 1: return 1\n        def helper(text):\n            start_idx, end_idx = 0, 0\n            first_found = None\n            ret = 0\n            while end_idx < len(text):\n                if text[end_idx] == text[start_idx]:\n                    end_idx += 1\n                    if counter[text[start_idx]] >= end_idx-start_idx:\n                        ret = max(ret, end_idx-start_idx)\n                    else:\n                        ret = max(ret, end_idx-start_idx-1)\n                else:\n                    if not first_found:\n                        first_found = end_idx\n                        end_idx += 1 \n                        if counter[text[start_idx]] >= end_idx-start_idx:\n                            ret = max(ret, end_idx-start_idx)\n                        else:\n                            ret = max(ret, end_idx-start_idx-1)\n                    else:\n                        start_idx = end_idx = first_found\n                        first_found = None\n            return ret\n        return max(helper(text), helper(text[::-1]))", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        c = Counter(text)\n        window = Counter()\n        i = 0\n        ans = 1\n        for j in range(len(text)):\n            c[text[j]] -= 1\n            window[text[j]] += 1\n            if (len(window) == 1 or\n                (len(window) == 2 and\n                 min(window.values()) == 1 and\n                 c[sorted(window, key=window.get)[1]] > 0)):\n                ans = max(ans, j - i + 1)\n            else:    \n                c[text[i]] += 1\n                window[text[i]] -= 1\n                if window[text[i]] == 0:\n                    del window[text[i]]\n                i += 1\n        return ans       ", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        n = len(text)\n        win = collections.Counter()\n        \n        def valid_win(win):\n            if len(win) > 2:\n                return False\n            \n            if len(win) == 1:\n                return True\n            \n            return not all(n >= 2 for n in win.values())\n        \n        max_c_idx = {}\n        min_c_idx = {}\n        for i, c in enumerate(text):\n            if c not in max_c_idx:\n                max_c_idx[c] = i\n            elif i > max_c_idx[c]:\n                max_c_idx[c] = i\n            if c not in min_c_idx:\n                min_c_idx[c] = i\n            \n        left, right = 0, 0\n        ans = 0\n        \n        while right < n:\n            c = text[right]\n            right += 1\n            win[c] += 1\n            \n            while not valid_win(win) and left < right:\n                d = text[left]\n                left += 1\n                win[d] -= 1\n                if win[d] == 0:\n                    win.pop(d)\n            \n            if len(win) == 1:\n                ans = max(ans, right - left)\n            else:\n                k1, k2 = win.keys()\n                if win[k1] == 1 and (max_c_idx[k2] >= right or min_c_idx[k2] < left):\n                    ans = max(ans, right - left)\n                elif win[k2] == 1 and (max_c_idx[k1] >= right or min_c_idx[k1] < left):\n                    ans = max(ans, right - left)\n                else:\n                    ans = max(ans, right - left - 1)\n                    \n        return ans", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        max_char=''\n        clist=[1]*len(text)\n        one_max=1\n        compress_list=[]\n        for i in range(1,len(text)):\n            if text[i]==text[i-1]:\n                clist[i]=clist[i-1]+1\n            else:\n                clist[i]=1\n                compress_list.append([text[i-1],clist[i-1]])\n            if clist[i]>one_max:\n                one_max=clist[i]\n                max_char=text[i]\n        compress_list.append([text[-1],clist[-1]])\n        print(compress_list)\n        two_count=[]\n        two_max=0\n        for i in range(2,len(compress_list)):\n            if compress_list[i-1][1]>1:\n                continue\n            if compress_list[i][0]!=compress_list[i-2][0]:\n                continue\n            if compress_list[i][1]+compress_list[i-2][1]+1<two_max:\n                continue\n            c=compress_list[i][0]\n            swaped=False\n            for j in range(len(compress_list)):\n                if j>=i-2 and j<=i:\n                    continue\n                if compress_list[j][0]==c:\n                    len2=compress_list[i][1]+compress_list[i-2][1]+1\n                    two_count.append(len2)\n                    if len2>two_max:\n                        two_max=len2\n                    swaped=True\n            if swaped:\n                continue\n            len2 = compress_list[i][1] + compress_list[i - 2][1]\n            two_count.append(len2)\n            if len2 > two_max:\n                two_max = len2\n        if one_max>=two_max:\n            char_count=0\n            for i in range(len(compress_list)):\n                if compress_list[i][0]==max_char:\n                    char_count+=1\n            if char_count>1:\n                one_max+=1\n        return max(one_max,two_max)", "from collections import Counter\n\nclass Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        if len(text) == 0:\n            return 0\n        \n        seen = set()\n        max_count = 0\n        i = j = 0\n        window = Counter()\n        maxes = Counter()\n        \n        while j < len(text):\n            if len(window) > 2 or (len(window) == 2 and min(window.values()) != 1):\n                maxes[text[i]] = max(maxes[text[i]], window[text[i]])\n                window[text[i]] -= 1\n                if window[text[i]] == 0:\n                    del window[text[i]]\n                i += 1\n            else:\n                inc = 0\n                cur_char = text[j]\n                window[cur_char] += 1\n                \n                if cur_char in maxes:\n                    max_count = max(max_count, maxes[cur_char] + 1)\n                    inc = 1\n                    \n                max_count = max(max_count, window[cur_char] + inc)\n                \n                j += 1\n\n        return max_count\n                \n                \n        \n", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        n = len(text)\n        ans = 1\n        mp = {}\n        for i in text:\n            if i in mp:\n                mp[i]+=1\n            else:\n                mp[i]=1\n        for i in mp:\n            first = 0\n            second = 0\n            if i in mp:\n                for j in range(0,n):\n                    if text[j]==i:\n                        first+=1\n                        if first+second<mp[i]:\n                            ans = max(ans,first+second+1)\n                        else:\n                            ans = max(ans,first+second)\n                    else:\n                        if j!=0 and j!=n-1 and text[j-1]==i and text[j+1]==i:\n                            second = first\n                        else:\n                            second = 0\n                        first = 0\n                        \n        return ans\n", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        \n        if not text:\n            return 0\n\n        compact = [ [text[0], 1] ]\n        max_ = 1\n        \n        for i in range(1, len(text)):\n            if text[i] == compact[-1][0]:\n                compact[-1][1] += 1\n            else:\n                compact.append([text[i], 1])\n            max_ = max(max_, compact[-1][1])\n        \n        last_idx = defaultdict(int)\n        \n        for i in range(len(compact)):\n            last_idx[compact[i][0]] += compact[i][1]\n        \n        #print(compact)\n        \n        for i in range( len(compact) - 2 ):\n            \n            if compact[i][0] == compact[i+2][0] and compact[i+1][1] == 1 and compact[i][1] + compact[i+2][1] < last_idx[compact[i][0]]:\n                max_ = max(max_, compact[i][1] + compact[i+2][1] + 1)\n            \n            if compact[i][0] == compact[i+2][0] and compact[i+1][1] == 1:\n                max_ = max(max_, compact[i][1] + compact[i+2][1])\n        \n        for i in range( len(compact)):\n            if last_idx[compact[i][0]] > compact[i][1]:\n                max_ = max(max_, compact[i][1] + 1)\n        \n        return max_\n            \n            \n        \n        \n                \n            \n", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        # Group letters by occurence\n        # Ex: \\\"aaabaaa\\\" -> [['a', 3], ['b', 1], ['a', 3]]\n        groups = []\n        for key, group in itertools.groupby(text):\n            groups.append([key,len(list(group))])\n            \n        # We need a counter to check if we can extend by one letter\n        # Ex: \\\"aaa\\\" in \\\"aaabba\\\" can be extended to \\\"aaaa\\\" because we have another \\\"a\\\" at the end.\n        count = collections.Counter(text)\n        \n        for index in range(len(groups)):\n            # Check if we can merge two groups.\n            # Ex \\\"aaa\\\" and \\\"aa\\\" in aaabaa\\\" can be merged to \\\"aaaaa\\\"\n            if index <= len(groups) - 3: # Make sure to dont go out of bounds\n                # The next groups's length must be 1 to be able to merge\n                if groups[index+1][1] == 1 and groups[index+2][0] == groups[index][0]:\n                    groups[index][1] += groups[index+2][1]\n                    \n            # Length will be extend by 1 if there are more letters in available, as explained above.\n            if count[groups[index][0]] > groups[index][1]:\n                groups[index][1] += 1\n                \n        # Return the maximum length that exists\n        maxlength = 0\n        for group in groups:\n            if group[1] > maxlength:\n                maxlength = group[1]\n        return maxlength", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        def get_possible(idx, cur, step, swap):\n            if idx >= len(positions):\n                return step + swap\n            if positions[idx] - 1 == cur:\n                return get_possible(idx+1, positions[idx], step + 1, swap)\n            elif not swap:\n                return step\n            else:\n                return max(\n                    step+1,\n                    get_possible(idx, cur + 1, step + 1, False),\n                    get_possible(idx, positions[idx] - 1, 1, False),\n                    get_possible(idx + 1, positions[idx], 1, True),\n                )\n        letters, ans = defaultdict(list), 0\n        for i, c in enumerate(text):\n            letters[c].append(i)\n\n        for _, positions in letters.items():\n            if len(positions) < 3:\n                ans = max(ans, len(positions))\n                continue\n            x = min(get_possible(1, positions[0], 1, True), len(positions))\n            ans = max(x, ans)\n        return ans", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        ln=len(text)\n        if ln==1:\n            return 1\n        mx=-1\n        start=0\n        \n        while start<ln:\n            print(start,',',end='')\n            i=start+1\n            inx=-1\n            while i<ln and (text[start]==text[i] or inx==-1):\n                if text[start]!=text[i]:\n                    inx=i\n                i+=1\n            print(i,',',end='')\n            if inx!=-1 and (text[start] in text[i:] or text[start] in text[:start]):\n                mx=max(mx,i-start)\n            elif inx==-1 and (text[start] in text[i:] or text[start] in text[:start]):\n                mx=max(mx,i-start+1)\n            elif inx==-1:\n                mx=max(mx,i-start)\n            else:\n                mx=max(mx,i-start-1)\n            if inx==-1:\n                start=i\n            else:\n                start=inx\n            print(mx)\n        \n        return mx\n                ", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        # out\n        tcounter = Counter(text)\n        res = 0\n        counter = Counter()\n        i = 0\n        for j in range(len(text)):\n            counter[text[j]] += 1\n            \n            while j-i+1-max(counter.values())>1:\n                counter[text[i]] -= 1\n                i += 1\n            \n            curr_max = max(counter.values())\n            c = [k for k in counter if counter[k]==curr_max][0]\n            res = max(res, min(j-i+1, tcounter[c]))\n            \n        return res", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        d={}\n        f={}\n        for i in text:\n            d[i]=[]\n            f[i]=f.get(i,0)+1\n        for i in list(d.keys()):\n            s=0\n            same=0\n            diff=0\n            for j in text:\n                if j==i:\n                    s=1\n                if j==i and s==1:\n                    if diff:\n                        d[i].append(-diff)\n                    same+=1\n                    diff=0\n                else:\n                    if same:\n                        d[i].append(same)\n                    diff+=1\n                    same=0\n            if same:\n                d[i].append(same)\n            if diff:\n                d[i].append(-diff)\n        l=0\n        print(d)\n        for i in list(d.keys()):\n            for j,v in enumerate(d[i]):\n                if v>0:\n                    l=max(l,v)\n                    if j+2<len(d[i]) and d[i][j+1]==-1  :\n                        if d[i][j+2]+d[i][j]<f[i]:\n                            l=max(l,d[i][j+2]+d[i][j]+1)\n                        else:\n                            l=max(l,d[i][j+2]+d[i][j])\n                            \n                    else:\n                        if d[i][j]<f[i]:\n                            l=max(l,d[i][j]+1)\n        return l\n                        \n                    \n                    \n                 \n            \n", "from collections import Counter\nclass Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        if not text:\n            return 0\n        cnt = Counter(list(text))\n        print(cnt)\n        output = 0\n        for c, n in list(cnt.items()):\n            val = 0\n            holder = 0\n            for i, t in enumerate(text):\n                if t == c:\n                    val += 1     \n                else:\n                    holder = val\n                    val = 0\n                if val + holder < n:\n                    op = val + holder + 1\n                else:\n                    op = val + holder \n                output = max(output, op)\n        return output\n\n            \n", "from collections import Counter\n\nclass Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        if not text:\n            return 0\n        \n        cnt = Counter(list(text))\n        output = 0\n        \n        for c, n in cnt.items():\n            val = 0\n            holder = 0\n            \n            for i, t in enumerate(text):\n                if t == c:\n                    val += 1\n                else:\n                    holder = val\n                    val = 0\n                \n                if val + holder < n:\n                    op = val + holder + 1\n                else:\n                    op = val + holder\n                    \n                output = max(output, op)\n        \n        return output", "from collections import Counter\n\nclass Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        \n        if not text:\n            return 0\n        \n        cnt = Counter(list(text))\n        \n        output = 0\n        \n        for c, n in cnt.items():\n            \n            val = 0\n            \n            holder = 0\n            \n            for i, t in enumerate(text):\n                if t == c:\n                    val += 1\n                    \n                else:\n                    holder = val\n                    val = 0\n                \n                if val + holder < n:\n                    op = val + holder + 1\n                else:\n                    op = val + holder\n               \n                output = max(output, op)\n        \n        return output", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        count = Counter(text)\n        i = 0\n        diff = 1\n        sol = 0\n        while i < len(text):\n            c = text[i]\n            j = i+1\n            found = False\n            while j < len(text):\n                if text[j] == c:\n                    j+= 1\n                else:\n                    if found:\n                        if count[c] >= j-i:\n                            sol = max(sol, j-i)\n                        else:\n                            sol = max(sol, j-i-1)\n                        break\n                    found = True\n                    diff = j\n                    j += 1\n            if j == len(text):\n                if count[c] > j-i and not found:\n                    sol = max(sol, j-i+1)\n                if count[c] >= j-i:\n                    sol = max(sol, j-i)\n                else:\n                    sol = max(sol, j-i-1)\n                break\n            i = diff\n        return sol    \n", "class Unionfind:\n    def __init__(self, n):\n        self.par = [-1]*n\n        self.rank = [1]*n\n    \n    def root(self, x):\n        r = x\n        \n        while not self.par[r]<0:\n            r = self.par[r]\n        \n        t = x\n        \n        while t!=r:\n            tmp = t\n            t = self.par[t]\n            self.par[tmp] = r\n        \n        return r\n    \n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        \n        if rx==ry:\n            return\n        \n        if self.rank[rx]<=self.rank[ry]:\n            self.par[ry] += self.par[rx]\n            self.par[rx] = ry\n            \n            if self.rank[rx]==self.rank[ry]:\n                self.rank[ry] += 1\n        else:\n            self.par[rx] += self.par[ry]\n            self.par[ry] = rx\n    \n    def is_same(self, x, y):\n        return self.root(x)==self.root(y)\n    \n    def count(self, x):\n        return -self.par[self.root(x)]\n\nclass Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        n = len(text)\n        cnt = Counter(list(text))\n        uf = Unionfind(n)\n        \n        for i in range(n-1):\n            if text[i]==text[i+1]:\n                uf.unite(i, i+1)\n        \n        ans = 0\n        \n        for i in range(n):\n            ans = max(ans, uf.count(i)+(1 if uf.count(i)<cnt[text[i]] else 0))\n        \n        for i in range(n-2):\n            if text[i]==text[i+2] and text[i]!=text[i+1]:\n                total = uf.count(i)+uf.count(i+2)\n                ans = max(ans, total+(1 if total<cnt[text[i]] else 0))\n\n        return ans", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        c = Counter(text)\n        window = Counter()\n        i = 0\n        ans = 1\n        for j in range(len(text)):\n            c[text[j]] -= 1\n            window[text[j]] += 1\n            while not (len(window) == 1 or (len(window) == 2 and min(window.values()) == 1)):\n                c[text[i]] += 1\n                window[text[i]] -= 1\n                if window[text[i]] == 0:\n                    del window[text[i]]\n                i += 1\n            if len(window) == 1 or c[sorted(window, key=window.get)[1]] > 0:\n                ans = max(ans, j - i + 1)\n        return ans       ", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        n = len(text)\n        ans = 1\n        mp = {}\n        for i in text:\n            if i in mp:\n                mp[i]+=1\n            else:\n                mp[i]=1\n        for i in range(26):\n            first = 0\n            second = 0\n            if chr(i+97) in mp:\n                for j in range(0,n):\n                    if text[j]==chr(97+i):\n                        first+=1\n                        if first+second<mp[chr(i+97)]:\n                            ans = max(ans,first+second+1)\n                        else:\n                            ans = max(ans,first+second)\n                    else:\n                        if j!=0 and j!=n-1 and text[j-1]==chr(i+97) and text[j+1]==chr(i+97):\n                            second = first\n                        else:\n                            second = 0\n                        first = 0\n                        \n        return ans\n", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        lst, lookup = list(), dict()\n        ptr = 0\n        while ptr < len(text):\n            curr, count = text[ptr], 0\n            while ptr < len(text) and curr == text[ptr]:\n                count += 1\n                ptr += 1\n            lookup[curr] = lookup.get(curr, 0) + count\n            lst.append((curr, count))\n        res = 0\n        for i in range(len(lst)):\n            if 0 < i < len(lst)-1:\n                if lst[i-1][0] == lst[i+1][0] and lst[i][1] == 1:\n                    curlen = lst[i-1][1]+lst[i+1][1]\n                    if lookup[lst[i-1][0]] > curlen:\n                        curlen += 1\n                    res = max(res, curlen)\n                    continue\n            curlen = lst[i][1]\n            if lookup[lst[i][0]] > curlen:\n                curlen += 1\n            res = max(res, curlen)\n        return res", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        hashmap = {}\n        wordlist = [] \n        l, r, ans = 0, 0, 0\n        while r < len(text):\n            while r < len(text) and text[l] == text[r]:\n                r += 1\n            wordlist.append([text[l], r-l])\n            if text[l] not in hashmap:\n                hashmap[text[l]] = r-l\n            else:\n                hashmap[text[l]] += r-l\n            l = r\n        for ch, count in wordlist:\n            ans = max(ans, min(count+1, hashmap[ch]))\n        for i in range(1, len(wordlist)-1):\n            if wordlist[i-1][0] == wordlist[i+1][0] and wordlist[i][1] == 1:\n                ans = max(ans, min(wordlist[i-1][1] + wordlist[i+1][1]+1, hashmap[wordlist[i+1][0]]))\n        \n        return ans\n            \n", "class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        for k,g in itertools.groupby(text):\n            print(g)\n        G = [[k,len(list(g))] for k,g in itertools.groupby(text)]\n        c = collections.Counter(text)\n        \n        res = max(min(n+1, c[k]) for k,n in G)\n        \n        for i in range(1,len(G)-1):\n            if G[i-1][0] == G[i+1][0] and G[i][1] == 1:\n                res = max(min(G[i-1][1]+G[i+1][1]+1, c[G[i-1][0]]), res)\n        return res"]
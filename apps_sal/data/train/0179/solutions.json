["class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n = len(s)\n\n        def compLen(c):\n            return 1 + len(str(c)) if c > 1 else 1\n\n        @lru_cache(None)\n        def dp(i, k): # return {head: (len, -head_count)}\n            if (n - i) <= k:\n                return {} # remove all\n            x, res = s[i], {}\n            # remove\n            if k:\n                res = dp(i + 1, k - 1)\n            # keep\n            keep = dp(i + 1, k)\n            t = [(1 + min((leng for leng, _ in list(keep.values())), default=0), -1)]\n            if x in keep:\n                leng, negc = keep[x]\n                leng, negc = (leng - compLen(-negc) + compLen(-negc + 1),\n                              negc - 1)\n                t.append((leng, negc))\n            if x in res:\n                t.append(res[x])\n            res[x] = min(t)\n            return res\n\n        m = dp(0, k)\n        return min((leng for leng, _ in list(m.values())), default = 0)\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        def _len(cnt): return 1 if cnt == 1 else 2 if cnt <= 9 else 3 if cnt <= 99 else 4\n\n        @lru_cache(None)\n        def solve(left, k):\n            if k < 0:\n                return float('inf')\n            # remove s[0:left+1]\n            if left + 1 == k:\n                return 0\n            # 1. keep s[left]\n            # 2. remove s[left]\n            res = min(solve(left - 1, k) + 1, solve(left - 1, k - 1))\n            cnt = 1\n            for j in range(left - 1, -1, -1):\n                if s[j] != s[left]:\n                    k -= 1\n                    if k < 0:\n                        break\n                else:\n                    cnt += 1\n                    if j < k:\n                        break\n                    res = min(res, solve(j - 1, k) + _len(cnt)) \n            return res\n        return solve(len(s) - 1, k)\n", "from typing import *\nfrom functools import lru_cache\n\n\n\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n\n        def get_compressed_len(n):\n            if n == 0:\n                return 0\n            if n == 1:\n                return 1\n            return len(str(n)) + 1\n\n        @lru_cache(None)\n        def dp_memo(x, y, left_count, remain_k):\n            if x > y:\n                return 0\n\n            # 1. don't concat s[x] with any further character\n            ans = get_compressed_len(left_count + 1) + dp_memo(x + 1, y, 0, remain_k)\n\n            # 2. remove s[x]\n            if remain_k > 0:\n                ans = min(ans, get_compressed_len(left_count) + dp_memo(x + 1, y, 0, remain_k - 1))\n\n            # 3. try to concat s[x] with further character s[xx]\n            for i in range(remain_k + 1):\n                xx = x + i + 1\n                if xx > y:  # out of bounds\n                    break\n                if s[x] == s[xx]:  # same s[x] and s[xx], concat them\n                    ans = min(ans, dp_memo(xx, y, left_count + 1, remain_k - i))\n\n            # print(x, y, left_count, remain_k, '->', ans)\n            return ans\n        return dp_memo(0, len(s) - 1, 0, k)", "class Solution:    \n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [[n if i > 0 else 0] * (k + 1) for i in range(n + 1)]\n        \n        def cost(v):\n            return (1 + len(str(v))) if v > 1 else v\n        \n        for i in range(n):\n            for j in range(k + 1):\n                if j:\n                    dp[i + 1][j - 1] = min(dp[i + 1][j - 1], dp[i][j])\n                take = 0\n                for x in range(i + 1)[::-1]:\n                    if s[x] != s[i]:\n                        take += 1\n                    if take > j:\n                        break\n                    dp[i + 1][j - take] = min(dp[i + 1][j - take], dp[x][j] + cost(i - x - take + 1))        \n        return min(dp[n])", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        states = { # (deletions, last character, multiple) -> minimum length\n            (0, None, 0): 0\n        } \n        \n        def count_len(d):\n            if d == 0 or d == 1:\n                return 0\n            else:\n                return len(str(d))\n        \n        for c in s:\n            new_states = collections.defaultdict(lambda: float('inf'))\n            for (deletions, last_char, count), length in states.items():\n                # with deletion\n                if deletions < k:\n                    new_state = (deletions + 1, last_char, count)\n                    new_length = length\n                    new_states[new_state] = min(new_states[new_state], new_length)\n                # without deletion\n                if c == last_char:\n                    new_state = (deletions, c, count + 1)\n                    new_length = length - count_len(count) + count_len(count + 1)\n                else:\n                    new_state = (deletions, c, 1)\n                    new_length = length + 1\n                new_states[new_state] = min(new_states[new_state], new_length)\n            states = new_states\n            \n        min_length = float('inf')\n        for (deletions, last_char, count), length in states.items():\n            if deletions == k:\n                min_length = min(min_length, length)\n        return min_length", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, K: int) -> int:\n        def getCost(k):\n            if k <= 1:\n                return k\n            else:\n                return 1 + len(str(k))\n        \n        n = len(s)\n        dp = [[n] * (K + 1) for i in range(n+1)]\n        dp[0] = [0] * (K + 1)\n        for i in range(n):\n            for j in range(K+1):\n                if j > 0:\n                    dp[i+1][j-1] = min(dp[i+1][j-1], dp[i][j]) # delete at position i\n                take = 0\n                for k in range(i+1)[::-1]: # keep at position i, iterate length of suffix you keep\n                    if s[k] != s[i]:\n                        take += 1\n                    if take > j:\n                        break\n                    dp[i+1][j-take] = min(dp[i+1][j-take], dp[k][j] + getCost(i - k - take + 1))\n                    \n        return min(dp[n])", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        '''\n        DP\n\n        dp(i, k) := minimal length for encoded string starting from 'i' with 'k' characters removed\n        dp(i, k) = min(dp(i, k-1), dp(j, k))\n        '''\n\n        def segment2Len(segment):\n            if segment[1] <= 1: return segment[1]\n            return len(str(segment[1])) + 1\n\n        segments = []\n        start = 0\n        for i in range(1, len(s)):\n            if s[i] != s[i-1]:\n                segments.append([s[i-1], i-start, start])\n                start = i\n        segments.append([s[-1], len(s)-start, start])\n        \n        def minLength(pChar, pLen, i, k, mem):\n            key = (pChar, pLen, i, k)\n            if key in mem: return mem[key]\n\n            if k == 0:\n                mem[key] = sum(map(segment2Len, segments[i:])) + segment2Len([pChar, pLen])\n                return mem[key]\n\n            if i == len(segments):\n                mem[key] = segment2Len([pChar, max(0, pLen-k)])\n                return mem[key]\n            \n            lengths = []\n            curLen = pLen + 2\n            for j in range(min(pLen, k) + 1):\n                newLen = segment2Len([pChar, pLen - j])\n                if newLen < curLen:\n                    lengths.append(newLen + minLength(segments[i][0], segments[i][1], i+1, k-j, mem))\n                    curLen = newLen\n\n            for j in range(i, len(segments)):\n                subStrLen = segments[j][2] - segments[i][2]\n                if subStrLen <= k:\n                    if segments[j][0] == pChar:\n                        lengths.append(minLength(pChar, pLen+segments[j][1], j+1, k-subStrLen, mem))\n                else:\n                    break\n\n            mem[key] = min(lengths)\n            return mem[key]\n\n        mem = {}\n        ans = minLength('', 0, 0, k, mem)\n        return ans\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        \n        def get_code_len(x):\n            if x == 1: return 1\n            return len(str(x)) + 1 if x >= 2 else 0\n        \n        n = len(s)\n        dp = [ [n] * (k + 1) for _ in range(len(s) + 1)]\n        dp[0] = [ 0 ] * (k + 1)\n        for i in range(n):\n            for j in range( k + 1):\n                if j > 0:\n                    dp[i + 1][j - 1] = min(dp[i][j], dp[i + 1][j - 1])\n                \n                deleted = 0\n                for p in reversed(list(range(i + 1))):\n                    # delete different \n                    if s[i] != s[p]:\n                        deleted += 1\n                    if deleted > j:\n                        break\n                    dp[i + 1][j - deleted] = min(\n                        dp[i + 1][j - deleted], \n                        dp[p][j] + get_code_len( i + 1 - p - deleted))\n        return min(dp[n])\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def get(index, left, c, streak):\n            if left < 0: return 1e6\n            if index == len(s):\n                return ((1 + len(str(streak))) - (streak == 1)) * (streak > 0)\n            return min(\n                ((1 + len(str(streak))) - (streak == 1)) * (streak > 0) * (c != s[index]) + get(index+1, left, s[index], 1 + streak * (c == s[index])),\n                get(index+1, left-1, c, streak))\n        \n        return get(0, k, None, 0)\n        \n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        memo={}\n        def counter(start, last, last_count, left):\n            if (start, last, last_count, left) in memo:\n                return memo[(start, last, last_count, left)]\n            if left<0:\n                return sys.maxsize\n            if start>=len(s):\n                return 0\n            \n            if s[start]==last:\n                incre=1 if last_count==1 or last_count==9 or last_count==99 else 0\n                memo[start, last, last_count, left]=incre+counter(start+1, last, last_count+1, left)\n            else:\n                keep=1+counter(start+1, s[start], 1, left)\n                delete=counter(start+1, last, last_count, left-1)\n                memo[start, last, last_count, left]=min(keep, delete)\n            return memo[start, last, last_count, left]\n        return counter(0, '', 0, k)", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def get(index, left, c, streak):\n            val = ((1 + len(str(streak))) - (streak == 1)) * (streak > 0)\n            if left < 0 or index == len(s): return 1e6 if left < 0 else val\n            return min(val*(c!=s[index])+get(index+1,left,s[index],1+streak*(c==s[index])),get(index+1,left-1,c,streak))\n        return get(0, k, None, 0)", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def get(index, left, c, streak):\n            val = ((1 + len(str(streak))) - (streak == 1)) * (streak > 0)\n            if left < 0 or index == len(s): return 1e6 if left < 0 else val\n            return min(val*(c != s[index]) + get(index+1, left, s[index], 1 + streak * (c == s[index])),get(index+1, left-1, c, streak))\n        return get(0, k, None, 0)\n        \n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:    \n        \n        def get_code_len(x):\n            return 1 + len(str(x)) if x > 1 else x\n        \n        n = len(s)\n        dp = [[ n ] * (k + 1) for i in range(n + 1)]\n        dp[0] = [0] * (k + 1)\n        for i in range(n):\n            for j in range(k + 1):\n                if j > 0:\n                    dp[i + 1][j - 1] = min(dp[i+1][j-1], dp[i][j])\n                    \n                deletions = 0\n                for p in reversed(range(i+1)): \n                    if s[p] != s[i]:\n                        deletions += 1\n                    if deletions > j:\n                        break\n                    dp[i+1][j - deletions] = min(dp[i + 1][j - deletions],\n                                          dp[p][j] + get_code_len(i - p - deletions + 1))\n                    \n        return min(dp[n])", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        dp = {}\n        def dfs(i, t, prev, last):\n            if t == -1:\n                return float('inf')\n            if i == len(s):\n                return 0\n            if (i, t, prev, last) in dp:\n                return dp[(i, t, prev, last)]\n            if s[i] == last:\n                increase = 0\n                if prev == 1 or prev == 9 or prev == 99:\n                    increase = 1\n                dp[(i, t, prev, last)] = increase + dfs(i + 1, t, prev + 1, last)\n            else:\n                take = dfs(i + 1, t, 1, s[i]) + 1\n                remove = dfs(i + 1, t - 1, prev, last)\n                dp[(i, t, prev, last)] = min(take, remove)\n            return dp[(i, t, prev, last)]\n        return dfs(0, k, 0, '')\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        memo = {}\n        def f(i, run_ch, run_length, remain_dels):\n            if i == len(s):\n                return 0\n            key = (i, run_ch, run_length, remain_dels)\n            if key in memo:\n                return memo[key]\n            \n            del_costs = float('inf')\n            if remain_dels > 0:\n                del_costs = f(i+1, run_ch, run_length, remain_dels-1)\n            keep_costs = 0\n            if s[i] == run_ch:\n                extra_cost = 0\n                if run_length == 1 or len(str(run_length+1)) > len(str(run_length)):\n                    extra_cost = 1\n                keep_costs = extra_cost + f(i+1, run_ch, run_length+1, remain_dels)\n            else:\n                keep_costs = 1 + f(i+1, s[i], 1, remain_dels)\n            memo[key] = min(keep_costs, del_costs)\n            return memo[key]\n        return f(0, '', 0, k)", "from functools import lru_cache\n\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        c = []\n        idx = 0\n        tmp = 0\n        while idx < len(s):\n            if idx >= 1 and s[idx] != s[idx - 1]:\n                c.append((s[idx - 1], tmp))\n                tmp = 1\n            else:\n                tmp += 1\n            if idx == len(s) - 1 and (len(c) == 0 or c[-1][0] != s[idx]):\n                c.append((s[idx], tmp))\n            idx += 1\n        def rl(x):\n            if x[1] == 1:\n                return 1\n            if 2 <= x[1] < 10:\n                return 2\n            if x[1] == 100:\n                return 4\n            return 3\n        if len(s) >= 100 and len(c) == 1:\n            return rl((c[0]))\n        @lru_cache(None)\n        def dfs(i, r, prev=None, d=False):\n            if i == len(c):\n                return 0\n            out = dfs(i + 1, r, c[i]) + rl(c[i])\n            if r >= c[i][1] and not d:\n                if i + 1 < len(c) and prev and prev[0] == c[i + 1][0]:\n                    c[i + 1] = (c[i + 1][0], c[i + 1][1] + prev[1])\n                    out = min(out, dfs(i + 1, r - c[i][1], prev, True) - rl(prev))\n                    c[i + 1] = (c[i + 1][0], c[i + 1][1] - prev[1])\n                else:\n                    out = min(out, dfs(i + 1, r - c[i][1], prev))\n            if c[i][1] >= 10 and r - c[i][1] + 9 >= 0:\n                out = min(out, dfs(i + 1, r - c[i][1] + 9, (c[i][0], 9)) + 2)\n            if c[i][1] >= 2 and r - c[i][1] + 1 >= 0:\n                out = min(out, dfs(i + 1, r - c[i][1] + 1, (c[i][0], 1)) + 1)\n            return out\n        \n        return dfs(0, k)\n\n            \n", "class Solution:\n    def getLengthOfOptimalCompression(self, s, k):\n        n = len(s)\n        dp = [[9999] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n\n        for i in range(1, n + 1):\n            for j in range(k + 1):\n                cnt = 0\n                del_ = 0\n                for l in range(i, 0, -1): # Keep s[i - 1], remove s[l - 1] if it's different char\n                    if s[l - 1] == s[i - 1]:\n                        cnt += 1\n                    else:\n                        del_ += 1\n                    if j - del_ >= 0:\n                        dp[i][j] = min(dp[i][j], dp[l - 1][j - del_] + 1 + (3 if cnt > 99 else 2 if cnt > 9 else 1 if cnt > 1 else 0))\n                if j > 0: # remove s[i - 1]\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1])\n\n        return dp[n][k]", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        memo = {}\n        def f(i, run_ch, run_len, remain_dels):\n            if i == len(s):\n                return 0\n            key = (i, run_ch, run_len, remain_dels)\n            if key in memo:\n                return memo[key]\n            del_costs = float('inf')\n            if remain_dels > 0:\n                del_costs = f(i+1, run_ch, run_len, remain_dels-1)\n            \n            keep_costs = 0\n            if s[i] == run_ch:\n                extra_cost = 0\n                if run_len == 1 or len(str(run_len+1)) > len(str(run_len)):\n                    extra_cost = 1\n                keep_costs = extra_cost + f(i+1, run_ch, run_len+1, remain_dels)\n            else:\n                keep_costs = 1 + f(i+1, s[i], 1, remain_dels)\n            \n            memo[key] = min(del_costs, keep_costs)\n            return memo[key]\n        return f(0, '', 0, k)\n", "def stringcomp(a, i, last,k,count, memo):\n    if (i, last,k,count) in memo:\n        return memo[((i, last,k,count))]\n    if k<0:\n        return float('inf')\n    if i>=len(a):\n        return 0\n    if a[i] == last:\n        keepi = stringcomp(a, i+1, last, k, count+1, memo) + (1 if count in (1, 9,99,999) else 0)\n        deletei = stringcomp(a, i+1, last, k-1, count, memo)\n    else:\n        keepi = 1+stringcomp(a, i+1, a[i], k, 1, memo)\n        deletei = stringcomp(a, i+1, last, k-1, count, memo)\n    memo[((i, last,k,count))] = min(keepi, deletei)\n    return min(keepi, deletei)\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        return stringcomp(s,0,'', k, 0,{})", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        m = {}\n        def f(i, cur, length, dels):\n            if i == len(s):\n                return 0\n            key = (i, cur, length, dels)\n            if key in m: return m[key]\n            del_cost = float('inf')\n            if dels>0:\n                del_cost = f(i+1, cur, length, dels-1)\n            keep = 0\n            if s[i]==cur:\n                extra = 0\n                if length==1 or len(str(length+1))>len(str(length)):\n                    extra=1\n                keep = extra + f(i+1, cur, length+1, dels)\n            else:\n                keep =1+f(i+1, s[i], 1, dels)\n            m[key]=min(keep, del_cost)\n            return m[key]\n        return f(0, '', 0, k)", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def get_length(beg: int, last_char: str, n_repeat: str, quota: int) -> int:\n            if quota < 0:\n                return float('inf')\n            if beg == len(s):\n                return 0\n            if s[beg] == last_char:\n                incr = 1 if n_repeat in [1, 9, 99] else 0\n                return incr + get_length(beg+1, last_char, n_repeat+1, quota)\n            else:\n                return min(\n                    get_length(beg+1, last_char, n_repeat, quota - 1), # delete this char\n                    1 + get_length(beg+1, s[beg], 1, quota)\n                )\n        return get_length(0, '', 0, k)", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        count = 1\n        prev = s[0]\n        counts = []\n        for l in s[1:]:\n            if l == prev:\n                count += 1\n            else:\n                counts.append([prev, count])\n                count = 1\n                prev = l\n        counts.append([prev, count])\n        \n        @lru_cache(None)\n        def opt(i, k):\n            if i >= len(counts):\n                return 0\n            l, c = counts[i]\n            best = 1 + (len(str(c)) if c > 1 else 0) + opt(i + 1, k)\n            if k >= c:\n                best = min(best, opt(i + 1, k - c))\n            if c > 1 and c - 1 <= k:\n                best = min(best, 1 + opt(i + 1, k - (c - 1)))\n            if c > 9 and c - 9 <= k:\n                best = min(best, 2 + opt(i + 1, k - (c - 9)))\n            if c > 99 and c - 99 <= k:\n                best = min(best, 3 + opt(i + 1, k - (c - 99)))\n            j = i + 1\n            while j < len(counts) and k >= 0:\n                if counts[j][0] == l:\n                    c += counts[j][1]\n                    best = min(best, 1 + (len(str(c)) if c > 1 else 0) + opt(j + 1, k))\n                    if k >= c:\n                        best = min(best, opt(j + 1, k - c))\n                    if c > 1 and c - 1 <= k:\n                        best = min(best, 1 + opt(j + 1, k - (c - 1)))\n                    if c > 9 and c - 9 <= k:\n                        best = min(best, 2 + opt(j + 1, k - (c - 9)))\n                    if c > 99 and c - 99 <= k:\n                        best = min(best, 3 + opt(j + 1, k - (c - 99)))\n                else:\n                    k -= counts[j][1]\n                j += 1\n            return best\n        return opt(0, k)\n                \n            \n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        cache = {}\n        \n        def process(i, x, c, k):\n            if not (i, x, c, k) in cache:\n                ans = 101\n                if i == -1:\n                    return 0\n                else:\n                    # delete s[i]\n                    if k > 0:\n                        ans = min(ans, process(i-1, x, c, k-1))\n                    # keep s[i]\n                    if s[i] != x:\n                        ans = min(ans, 1+process(i-1, s[i], 1, k))\n                    elif c == 1 or c == 9 or c == 99:\n                        ans = min(ans, 1+process(i-1, x, c+1, k))\n                    else:\n                        ans = min(ans, process(i-1, x, c+1, k))            \n                \n                cache[(i, x, c, k)] = ans\n            return cache[(i, x, c, k)]\n        \n        n = len(s)\n        return process(n-1, '*', 0, k)", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def fuck(start,last,c,left):\n            if start >= len(s):\n                return 0\n            if left == 0:\n                return (1 if c==99 or c == 9 or c ==1 else 0) +  fuck(start+1, last, c +1, left) if s[start]==last else 1 + fuck(start+1, s[start], 1, left)\n\n            \n            return (1 if c==99 or c == 9 or c ==1 else 0) +  fuck(start+1, last, c +1, left) if s[start]==last else min(fuck(start+1, last, c, left-1),1 + fuck(start+1, s[start], 1, left))\n        return fuck(0,'sb',0, k)", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        mem={}\n        last=[]\n        for c in s:\n            if not last or c!=last[-1][0]:\n                last.append([c,0])\n            last[-1][1]+=1\n        if len(last)==1:\n            if k==len(s):\n                return 0\n            return len(''.join([x+(str(y-k) if y-k>=2 else '') for x,y in last]))\n        ns=''.join([x+(str(y) if y>=2 else '') for x,y in last])\n        print(ns)\n        def inner(i,lb,ll,ck):\n            if ck<0:\n                return len(ns)\n            if i==len(s):\n                return 0\n            if (i,lb,ll,ck) not in mem:\n                mem[(i,lb,ll,ck)]=inner(i+1,lb,ll,ck-1)\n                if s[i]==lb:\n                    nll=ll+1\n                    if nll==2 or nll==10:\n                        mem[(i,lb,ll,ck)]=min(mem[(i,lb,ll,ck)], inner(i+1,lb,nll,ck)+1)\n                    else:\n                        mem[(i,lb,ll,ck)]=min(mem[(i,lb,ll,ck)], inner(i+1,lb,nll,ck))\n                else:\n                    mem[(i,lb,ll,ck)]=min(mem[(i,lb,ll,ck)],1+inner(i+1,s[i],1,ck))\n            return mem[(i,lb,ll,ck)]\n        print(mem)\n        return inner(0,None,0,k)", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        self.memo = {}\n        return self.helper(0, 0, '', s, k)\n    \n    def helper(self, i, last_count, last_ch, s, k):\n        if i == len(s):\n            length_count = len(str(last_count)) if last_count > 1 else 0\n            length_ch = len(last_ch)\n            return length_count + length_ch\n        \n        if (i, last_count, last_ch, k) in self.memo:\n            return self.memo[(i, last_count, last_ch, k)]\n        \n        delete = float('inf')\n        if k>0:\n            delete = self.helper(i+1, last_count, last_ch, s, k-1)\n        \n        if s[i] == last_ch:\n            no_delete = self.helper(i+1, last_count+1, last_ch, s, k)\n        else:\n            length_count = len(str(last_count)) if last_count > 1 else 0\n            length_ch = len(last_ch)\n            no_delete = length_count + length_ch + self.helper(i+1, 1, s[i], s, k)\n        \n        res = min(delete, no_delete)\n        self.memo[(i, last_count, last_ch, k)] = res\n        return res\n    \n    \n\n        \n        \n    \n    \n", "class Solution:\n    def getLengthOfOptimalCompression(self, s, k):\n        memo = {}\n        \n        def counter(start, last_char, last_char_len, rem_chars):\n            nonlocal memo, s\n            if rem_chars < 0:\n                return float('inf')\n            if start == len(s):\n                return 0\n            if (start, last_char, last_char_len, rem_chars) not in memo:\n                if s[start] == last_char:\n                    inc = 1 if last_char_len in (1, 9, 99) else 0\n                    memo[(start, last_char, last_char_len, rem_chars)] = inc + counter(start + 1, last_char, last_char_len + 1, rem_chars)\n                else:\n                    # keep\n                    keep_len = 1 + counter(start + 1, s[start], 1, rem_chars)\n                    # Remove\n                    rem_len = counter(start + 1, last_char, last_char_len, rem_chars - 1)\n                    memo[(start, last_char, last_char_len, rem_chars)] = min(keep_len, rem_len) \n            return memo[(start, last_char, last_char_len, rem_chars)]\n\n        return counter(0, '', 0, k)", "from functools import lru_cache\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n \n        @lru_cache(None)\n        def singlelen(n: int) :\n            if not isinstance(n, int):\n                print(n)\n            if n <= 1:\n                return n\n            elif n < 10:\n                return 2\n            elif n < 100:\n                return 3\n            else:\n                return 4\n            \n        def encode(s):\n            last, len = '' , 0\n            res = []\n            for c in s:\n                if c == last:\n                    len += 1\n                else :\n                    if last != '':\n                        res.append((last, len))\n                    last, len = c, 1\n            if len != 0:\n                res.append((last, len))\n            return res\n        def add(curchar, curlen: int , code):\n            #print(32, type(curlen), end= ' ')\n            if len(code) == 0:\n                return 0, curchar, curlen \n            \n            prevsum  = 0\n            for n, l in code:\n                if n == curchar:\n                    curlen += l\n                else:\n                    prevsum += singlelen(curlen)\n                    curchar, curlen = n, l  \n                    #print(43, type(curlen), end= ' ')\n            return (prevsum, curchar, curlen) \n        \n        @lru_cache(None)\n        def dp(code, remain, todel, curchar, curlen: int):\n            #print(sum(tuple(zip(*code))[1]), remain, todel, curchar, curlen)\n            if remain == todel:\n                #print(49, type(curlen), end= ' ')\n                return singlelen(curlen)\n            if todel == 0:\n                (prelen, curchar, curlen) = add(curchar, curlen, code)\n                #print(53, type(curlen), end= ' ')\n                return prelen + singlelen(curlen)\n            \n            if len(code) < 1 or len(code[0]) < 1: \n                print((57, code, remain, todel, curchar, curlen))\n            if code[0][0] == curchar:\n                curlen += code[0][1]\n                remain -= code[0][1]\n                if remain < todel:\n                    curlen += todel - remain\n                    remain = todel\n                    return singlelen(curlen)\n                else:\n                    code = code[1:]\n                if len(code) == 0:\n                    return singlelen(curlen)\n                \n            cases = []\n            \n            if todel >= code[0][1]:\n                #print(63, type(curlen), end= ' ')\n                cases.append(dp(code[1:], remain - code[0][1], todel - code[0][1], curchar, curlen))\n        \n            (prelen, newchar, newlen) = add(curchar, curlen, code[:1]) \n            #print(67, type(newlen), end= ' ') \n            for trydel in range(max(0, todel - remain + code[0][1] ),  min(code[0][1], todel + 1)) :\n                cases.append(prelen  + dp(code[1:], remain - code[0][1], todel - trydel, newchar, newlen - trydel))\n\n            # remove all current stride, remove partial of current stride, keep current stride \n        \n            if len(cases) == 0:\n                #81       4                          1       1      b        3       -  0       b        5\n                #  (('b', 2), ('a', 1), ('c', 1)) ((0, 2), (2, 2))\n                #81       2                          1       1      c        4       -  0       c        6 \n                # | (('c', 2),)  ((0, 2), (2, 2))\n                print((81, sum(tuple(zip(*code))[1]), remain, todel, curchar, curlen,'-',prelen, newchar, newlen, '|', code, ((0, todel - remain + code[0][1] ),  (code[0][1], todel + 1))))\n            return min(cases)\n        \n    \n        code = tuple( encode(s))\n        print((code, len(s))) \n        print((sum(tuple(zip(*code))[1])))\n        \n        return dp( code, len(s), k, '', 0)\n    \n    def getLengthOfOptimalCompression2(self, s: str, k: int) -> int:\n        N = len(s)\n        if N == k:\n            return 0\n        @lru_cache(None)\n        def singlelen(n) :\n            if n <= 1:\n                return n\n            elif n < 10:\n                return 2\n            elif n < 100:\n                return 3\n            else:\n                return 4\n                \n        def finallen(prev):\n            return prev[0] + singlelen(prev[1]) \n        \n        def add(prev, s):\n            if len(s) == 0:\n                return prev \n            \n            prevsum, curlen, cur = prev\n            for n in s:\n                if n == cur:\n                    curlen += 1\n                else:\n                    prevsum += singlelen(curlen)\n                    curlen, cur= 1, n  \n                \n            return (prevsum, curlen, s[-1:]) \n        \n        @lru_cache(None)\n        def dp(s, k, prev):\n            if k == 0:\n                return finallen(add(prev, s))\n            if len(s) == k:\n                return finallen(prev)\n\n            cur, s = s[:1], s[1:]\n            while cur == prev[2] and len(s) > k:\n                prev = add(prev,cur) \n                cur, s = s[:1], s[1:] \n\n            return min (dp(s, k - 1, prev), dp(s, k, add(prev,cur))) \n        \n        return dp(s, k, (0, 0, ''))\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        # dp[i][k]: the min length for s[:i+1] with at most k deletion\n        # each s[i]: keep or discard\n        # if delete: dp[i][j] = dp[i-1][j-1]\n        # if keep: delete at most j chars in s[:i+1] that are different from s[i]\n        n = len(s)\n        dp =[[float('inf') for _ in range(n+1)] for _ in range(n+1)]\n        \n        dp[0][0] = 0\n        for i in range(1, n+1):\n            for j in range(k+1):\n                cnt = 0\n                d = 0\n                for l in range(i, 0, -1):\n                    if s[l-1] == s[i-1]:\n                        cnt += 1\n                    else:\n                        d += 1\n                    if j - d >= 0:\n                        diff = 0\n                        if cnt >= 100:\n                            diff = 3\n                        elif cnt >=10:\n                            diff = 2\n                        elif cnt >= 2:\n                            diff = 1\n                            \n                        dp[i][j] = min(dp[i][j], dp[l-1][j-d] +1 +diff)\n                if j > 0:\n                    # delete s[i]\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1])\n        return dp[n][k]", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n = len(s)\n\n        @lru_cache(None)\n        def dp(i, k, last, last_count):\n            if (n - i) <= k:\n                return 0 # remove all\n            \n            if s[i] == last:\n                inc = 1 if last_count in [1,9,99] else 0\n                return inc + dp(i + 1, k, last, last_count + 1)\n            else:\n                res = 1 + dp(i + 1, k, s[i], 1)\n                if k:\n                    res = min(res, dp(i + 1, k - 1, last, last_count))\n                return res\n\n        return dp(0, k, '', 0)\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def count(start, pre, pre_count, k):\n            if k<0: return float('inf')\n            if len(s)-start<=k: return 0\n            \n            if s[start]==pre:\n                incr = 1 if pre_count==1 or pre_count==9 or pre_count==99 else 0\n                return incr + count(start+1, pre, pre_count+1, k)\n            else:\n                delete = count(start+1, pre, pre_count, k-1)\n                keep = 1 + count(start+1, s[start], 1, k)\n                return min(delete, keep)\n            \n        return count(0, '', 0, k)\n", "from collections import defaultdict\nfrom functools import lru_cache\n\n\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        # char2ids = defaultdict(list)\n        # for i, c in enumerate(s):\n        #     if len(char2ids[c]) == 0 or i > char2ids[c][-1] + 1:\n        #         char2ids[c].append(i)\n\n        def compressed_length(cnt):\n            return 4 if cnt == 100 else (3 if cnt >= 10 else (2 if cnt > 1 else 1))\n\n        @lru_cache(None)\n        def DP(i, k):\n            if k < 0: return float('inf')\n            if i + 1 <= k: return 0\n\n            ret = min(DP(i - 1, k) + 1, DP(i - 1, k - 1))\n            cnt = 1\n            for j in range(i - 1, -1, -1):\n                if s[j] != s[i]:\n                    k -= 1\n                    if k < 0: break\n                else:\n                    cnt += 1\n                    ret = min(DP(j - 1, k) + compressed_length(cnt), ret)\n\n            return ret\n\n        return DP(len(s) - 1, k)", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        #dp[i][k] min len of s[i:] encoded by deleting at most k chars\n        # delete d[i+1][k-1]\n        # encode_len(s[i->j] == s[i]) + d(j+1, k - sum(s[i->j])) for j in range(i, n)\n        n = len(s)\n     \n        @lru_cache(None)\n        def dp(i, k):\n            if k < 0: return n\n            if i+k >= n:\n                return 0\n            res = dp(i+1, k-1)\n            l = 0\n            same = 0\n            for j in range(i, n):\n                if s[j] == s[i]:\n                    same += 1\n                    if same <= 2 or same == 10 or same == 100:\n                        l += 1\n                diff = j - i + 1 - same\n                #if diff < 0: break\n                res = min(res, l + dp(j+1, k - diff))\n            return res\n        \n        return dp(0, k)\n            \n", "\nclass Solution:\n  def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n    n = len(s)\n    dp_cache = dict()\n    def dp(i, k):\n      if k < 0:\n        return n\n      if i + k >= n:\n        return 0\n\n      if (i, k) in dp_cache:\n        return dp_cache[(i, k)]\n      ans = dp(i + 1, k - 1)\n      l = 0\n      same = 0\n      for j in range(i, n):\n        if s[j] == s[i]:\n          same += 1\n          if same <= 2 or same == 10 or same == 100:\n            l += 1\n        diff = j - i + 1 - same\n        if diff < 0: break\n        ans = min(ans, l + dp(j + 1, k - diff))\n      dp_cache[(i, k)] = ans\n      return ans\n    return dp(0, k)", "from functools import lru_cache\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        def _len(cnt): return 1 if cnt == 1 else 2 if cnt <= 9 else 3 if cnt <= 99 else 4\n\n        @lru_cache(None)\n        def solve(left, k):\n            if k < 0:\n                return float('inf')\n            # remove s[0:left+1]\n            if left + 1 == k:\n                return 0\n            # 1. keep s[left]\n            # 2. remove s[left]\n            res = min(solve(left - 1, k) + 1, solve(left - 1, k - 1))\n            cnt = 1\n            for j in range(left - 1, -1, -1):\n                if s[j] != s[left]:\n                    k -= 1\n                    if k < 0:\n                        break\n                else:\n                    cnt += 1\n                    if j < k:\n                        break\n                    res = min(res, solve(j - 1, k) + _len(cnt)) \n            return res\n        return solve(len(s) - 1, k)\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def cmp(n):\n            if n<=0:\n                return 0\n            if n==1:\n                return 1\n            if n<10:\n                return 2\n            if n>=100:\n                return 4\n            return 3\n        \n        @lru_cache(None)\n        def solve(l,k):\n            if k<0:\n                return 10000\n            if l>=len(s):\n                return 0\n            ans=solve(l+1,k-1)\n            ad,de=0,0\n            for i in range(l,len(s)):\n                if s[i]==s[l]:\n                    ad+=1\n                else:\n                    de+=1\n                ans=min(ans,cmp(ad)+solve(i+1,k-de))\n            # print(s[l:],k,ans)\n            return ans\n        \n        return solve(0,k)", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        \n        def backtrack(s, start, last, last_cnt, left, memo):\n            if left < 0:\n                return float('inf')\n            \n            if len(s) - start <= left:\n                return 0\n            \n            if (start, last, last_cnt, left) in memo:\n                return memo[(start, last, last_cnt, left)]\n            \n            ans = float('inf')\n            if s[start] == last:\n                if last_cnt == 1:\n                    inc = 1\n                else:\n                    inc = len(str(last_cnt + 1)) - len(str(last_cnt))\n                    \n                ans = min(ans, inc + backtrack(s, start+1, last, last_cnt+1, left, memo))\n            else:\n                # delete\n                delete_res = backtrack(s, start+1, last, last_cnt, left-1, memo)\n                # keep\n                keep_res = 1 + backtrack(s, start+1, s[start], 1, left, memo)\n                \n                ans = min(delete_res, keep_res)\n                \n            memo[(start, last, last_cnt, left)] = ans\n            return memo[(start, last, last_cnt, left)]\n        \n        \n        return backtrack(s, 0, '', 0, k, dict())\n                \n", "from functools import lru_cache\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        if len(s) - k <= 1:\n            return len(s) - k\n        \n        if len(s) == 100 and all([c==s[0] for c in s[1:]]):\n            if k == 0: return 4\n            if k <= 90: return 3\n            if k <= 98: return 2\n            return 1\n        \n        @lru_cache(None)\n        def run(i, k, j, l):\n            if k < 0:\n                return 10000\n            \n            if i == len(s):\n                return 0\n            \n            c = s[i]\n            if c == j:\n                return run(i+1, k, j, min(10, l+1)) + (l in [1,9]) \n            \n            return min(\n                run(i+1, k-1, j, l), \n                run(i+1, k, c, 1) + 1\n            )\n        return run(0, k, None, 0)\n", "from functools import lru_cache\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n = len(s)\n        \n        @lru_cache(None)\n        def dp(i, k, last, cnt):\n            if k < 0:\n                return float('inf')\n            if i + k >= n:\n                return 0\n            res = n\n            if last == s[i]:\n                carry = int(cnt == 1 or cnt == 9 or cnt == 99)\n                res = min(res, dp(i+1, k, last, cnt+1) + carry)\n            else:\n                res = min(res,\n                         dp(i+1, k, s[i], 1) + 1,\n                         dp(i+1, k-1, last, cnt))\n            return res\n        \n        return dp(0, k, '', 0)\n", "from functools import lru_cache\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def dp(i, k, p, l):\n            if k < 0: return sys.maxsize // 2\n            if i >= len(s): return 0\n            \n            if s[i] == p:\n                carry = l in [1, 9, 99]\n                return carry + dp(i+1, k, p, l+1)\n            else: # min(delete s[i], keep s[i])\n                return min(dp(i+1, k-1, p, l),\n                          1 + dp(i+1, k, s[i], 1))\n        return dp(0, k, '', 0)\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        #if s[i] != s[i-1]: dp[i][t] = min(dp[i-1][t-1], dp[i-1][t] + 1)\n        #else: dp[i][t] = min(dp[i-1][t-1], dp[i-1][t] + carry) carry = (cnt in [9, 99, 999]) cnt += 1\n        n = len(s)\n        cp = s[:]\n        @lru_cache(None)\n        def dp(i, last, curlen, k):\n            if k < 0: return n+1\n            if i >= n:\n                return 0\n            res = n+1\n            if s[i] == last:\n                carry = (curlen in [1, 9, 99])\n                res = carry + dp(i+1, last, curlen+1, k)\n            else:\n                res = min(1+ dp(i+1, s[i], 1, k),\n                         dp(i+1, last, curlen, k-1))\n            return res\n        \n        return dp(0, '.', 0, k)\n            \n", "from functools import lru_cache\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def dp(i, k, p, l): # p: last char from prev step, l: len(last char) of prev step\n            # delete\n            if k < 0: return sys.maxsize // 2\n            if i >= len(s): return 0            \n            if s[i] == p: # same as prev, no need to delete\n                carry = l in [1, 9, 99]\n                return carry + dp(i+1, k, p, l+1)\n            else:\n                return min(1 + dp(i+1, k, s[i], 1), # keep s[i]\n                        dp(i+1, k-1, p, l)\n                         )\n        return dp(0, k, '', 0)\n", "def dlen(n):\n    ans = 0\n    while n > 0:\n        ans += 1\n        n //= 10\n    return ans\n\n\ndef backtrack(i, s, k, memo):\n    n = len(s)\n    if k < 0:\n        return float('inf')\n    elif i == n or k >= n - i: # empty\n        return 0\n    elif (i, k) in memo:\n        return memo[(i, k)]\n    else:\n        ans = float('inf')\n        count = defaultdict(int)\n        most_freq = 0\n\n        for j in range(i, n):\n            char = s[j]\n            count[char] += 1\n            most_freq = max(most_freq, count[char])\n            digit_len = 0 if most_freq == 1 else len(str(most_freq))\n            range_length = j - i + 1\n            ans = min(ans, 1 + digit_len + backtrack(j + 1, s, k - (range_length - most_freq), memo))\n        memo[(i, k)] = ans\n        return ans\n        \n        \nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        # dp[i][j]\n        # denotes minimum length of encoded string from 0 to i with at most j deletion\n        # Transition:\n        # if we keep s[i]: \n        # dp[i][j] = dp[i - 1][j - 1]\n        # if we remove s[i]:\n        # dp[i][j] = min(dp[i][j], dp[p - 1][j - removed] + 1 + digit_len for p from i..0)\n        \n        n = len(s)\n        memo = {}\n        return backtrack(0, s, k, memo)\n#         dp = [[float('inf') for _ in range(k + 1)] for _ in range(n + 1)]\n        \n#         for j in range(k + 1):\n#             dp[0][j] = 0\n        \n#         # we have two choices, to remove s[i] or to keep s[i]\n#         for i in range(1, n + 1):\n#             for j in range(k + 1):\n#                 if j > 0:\n#                     # remove current character\n#                     dp[i][j] = dp[i - 1][j - 1]\n                \n#                 # also consider remove the least frequent characters before s[i]\n#                 removed = 0\n#                 count = 0\n#                 for p in range(i, 0, -1):\n#                     if s[i - 1] == s[p - 1]:\n#                         count += 1\n#                     else:\n#                         removed += 1\n                    \n#                     # remove at most j, cannot exceed j\n#                     if removed > j:\n#                         break\n                    \n#                     digit_len = 0 if count == 1 else dlen(count)\n#                     dp[i][j] = min(dp[i][j], dp[p - 1][j - removed] + 1 + digit_len)\n                \n#         return dp[n][k]\n        \n        \n", "from functools import lru_cache\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        if len(s) - k <= 1:\n            return len(s)-k\n        \n        @lru_cache(None)\n        def run(i, j, k, l):\n            if k < 0:\n                return 10000\n            \n            if i == len(s):\n                return 0\n            \n            c = s[i]\n            if c == j:\n                return run(i+1, c, k, l+1) + (1 if l in [1, 9, 99] else 0)\n            \n            return min(\n                run(i+1, j, k-1, l),\n                run(i+1, c, k, 1) + 1,\n            )\n        \n        return run(0, None, k, 0)\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def counter(start,last,last_cnt,left):\n            if left < 0:\n                return float('inf')\n            if start >= len(s):\n                return 0\n            if s[start] == last:\n                inc = 1 if last_cnt == 1 or last_cnt == 9 or last_cnt == 99 else 0\n                return inc + counter(start+1,last,last_cnt+1,left)\n            else:\n                keep_c = 1 + counter(start+1,s[start],1,left)\n                del_c = counter(start+1,last,last_cnt,left-1)\n                return min(keep_c,del_c)\n        return counter(0,'',0,k)", "def dlen(n):\n    ans = 0\n    while n > 0:\n        ans += 1\n        n //= 10\n    return ans\n\n\ndef backtrack(i, s, k, memo):\n    n = len(s)\n    \n    if k < 0:\n        return float('inf')\n    elif i == n or k >= n - i: # empty\n        return 0\n    elif (i, k) in memo:\n        return memo[(i, k)]\n    else:\n        ans = float('inf')\n        count = defaultdict(int)\n        most_freq = 0\n\n        for start in range(i, n):\n            char = s[start]\n            count[char] += 1\n            most_freq = max(most_freq, count[char])\n            digit_len = 0 if most_freq == 1 else len(str(most_freq))\n\n            ans = min(ans, 1 + digit_len + backtrack(start + 1, s, k - (start - i + 1 - most_freq), memo))\n        \n        memo[(i, k)] = ans\n        return ans\n        \n        \nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        # dp[i][j]\n        # denotes minimum length of encoded string from 0 to i with at most j deletion\n        # Transition:\n        # if we keep s[i]: \n        # dp[i][j] = dp[i - 1][j - 1]\n        # if we remove s[i]:\n        # dp[i][j] = min(dp[i][j], dp[p - 1][j - removed] + 1 + digit_len for p from i..0)\n        \n        n = len(s)\n        memo = {}\n        return backtrack(0, s, k, memo)\n#         dp = [[float('inf') for _ in range(k + 1)] for _ in range(n + 1)]\n        \n#         for j in range(k + 1):\n#             dp[0][j] = 0\n        \n#         # we have two choices, to remove s[i] or to keep s[i]\n#         for i in range(1, n + 1):\n#             for j in range(k + 1):\n#                 if j > 0:\n#                     # remove current character\n#                     dp[i][j] = dp[i - 1][j - 1]\n                \n#                 # also consider remove the least frequent characters before s[i]\n#                 removed = 0\n#                 count = 0\n#                 for p in range(i, 0, -1):\n#                     if s[i - 1] == s[p - 1]:\n#                         count += 1\n#                     else:\n#                         removed += 1\n                    \n#                     # remove at most j, cannot exceed j\n#                     if removed > j:\n#                         break\n                    \n#                     digit_len = 0 if count == 1 else dlen(count)\n#                     dp[i][j] = min(dp[i][j], dp[p - 1][j - removed] + 1 + digit_len)\n                \n#         return dp[n][k]\n        \n        \n", "from functools import lru_cache\n\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def compress(now, prev_ch, prev_count, left):\n            if left < 0: return len(s) + 1\n            if now >= len(s): return 0\n            if s[now] == prev_ch:\n                incr = 1 if prev_count == 1 or prev_count == 9 or prev_count == 99 else 0\n                return incr + compress(now + 1, prev_ch, prev_count + 1, left)\n            keep = 1 + compress(now + 1, s[now], 1, left)\n            delete = compress(now + 1, prev_ch, prev_count, left - 1)\n            return min(keep, delete)\n        \n        return compress(0, '', 0, k)", "from functools import lru_cache\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        def _len(cnt): return 1 if cnt == 1 else 2 if cnt <= 9 else 3 if cnt <= 99 else 4\n\n        @lru_cache(None)\n        def solve(left, k):\n            if k < 0:\n                return float('inf')\n            # remove s[0:left+1]\n            if left + 1 == k:\n#                 print(93, left -1, k )\n                return 0\n            # 1. keep s[left], regard no repeating\n            # 2. remove s[left]\n            res = min(solve(left - 1, k) + 1, solve(left - 1, k - 1))\n#             print(98, left -1, k )\n            # 3. fix repeating characters\n            cnt = 1\n            for j in range(left - 1, -1, -1):\n                if j < k:\n                    break\n                elif s[j] != s[left]:\n                    k -= 1\n                else:\n                    cnt += 1\n                    res = min(res, solve(j - 1, k) + _len(cnt)) \n#                 print(110, j -1, k )\n            return res\n        return solve(len(s) - 1, k)\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def dp(start, last, lastCount, k):\n            if k < 0:\n                return float('inf')\n            if start == len(s):\n                return 0\n            if s[start] == last:\n                inc = 1 if lastCount == 1 or lastCount == 9 or lastCount == 99 else 0\n                return inc + dp(start+1, last, lastCount + 1, k)\n            else:\n                return min(dp(start+1, last, lastCount, k-1), 1 + dp(start+1, s[start], 1, k))\n        return dp(0, '', 0, k)", "from functools import lru_cache\n\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n            \n        @lru_cache(None)\n        def dfs(start, last_ch, count, k):\n            if k < 0:\n                return float('inf')\n            if start >= len(s):\n                return 0\n            if s[start] == last_ch:\n                return dfs(start+1, last_ch, count+1, k) + ( 1 if count in {1, 9, 99, 99} else 0 )\n            else:\n                keep = 1 + dfs(start+1, s[start], 1, k)\n                discard = dfs(start+1, last_ch, count, k - 1)\n                return min(keep, discard)\n        \n        return dfs(0, '', 0, k)\n", "from functools import lru_cache\n\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def compress(now, prev_ch, prev_count, left):\n            if left < 0: return len(s) + 1\n            if now >= len(s): return 0\n            if s[now] == prev_ch:\n                incr = 1 if prev_count == 1 or prev_count == 9 or prev_count == 99 else 0\n                return incr + compress(now + 1, s[now], prev_count + 1, left)\n            keep = 1 + compress(now + 1, s[now], 1, left)\n            delete = compress(now + 1, prev_ch, prev_count, left - 1)\n            return min(keep, delete)\n        \n        return compress(0, '', 0, k)", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        def _len(cnt): return 1 if cnt == 1 else 1 + len(str(cnt))\n        dp = [[0]*(k+1) for _ in range(len(s)+1)]\n\n        for ki in range(k+1):\n            for left in range(ki, len(s)):\n                drop = dp[left-1][ki-1] if ki > 0 else float('inf')\n                keep = 1 + dp[left-1][ki]\n                cnt = 1\n                kj = ki\n                for j in range(left-1, -1, -1):\n                    if s[j] != s[left]:\n                        if kj == 0:\n                            break\n                        kj -= 1\n                    else:\n                        cnt += 1\n                        keep = min(keep, _len(cnt) + dp[j-1][kj])\n\n                dp[left][ki] = min(keep, drop)\n\n        return dp[len(s)-1][k]\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        \n        def calculatelen(cnt):         #length calculator\n            if cnt==0: return 0\n            elif cnt==1: return 1\n            elif cnt < 10: return 2\n            elif cnt < 100: return 3\n            else: return 4\n        \n        \n        n = len(s)\n        x = 999999\n        dp = [[x]*(k+1) for i in range(n+1)]\n        for i in range(k+1):\n            dp[0][i] = 0\n\n        for i in range(1,n+1):\n            for j in range(k+1):\n                \n                cnt,remove = 0,0\n                \n                if j > 0: dp[i][j] = dp[i-1][j-1]\n                    \n                for p in range(i,0,-1):\n                    if(s[p-1] == s[i-1]): cnt+=1\n                    else: \n                        remove += 1\n                        if remove > j: break\n                    dp[i][j] = min(dp[i][j],(dp[p-1][j-remove] + calculatelen(cnt)))\n                    \n        return dp[n][k]", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        N = len(s)\n        \n        @lru_cache(None)\n        def rec(cur, rem, ln, ch):\n            if rem < 0:\n                return math.inf\n            if cur == N:\n                return 0\n            \n            ans = math.inf\n            if s[cur] == ch:\n                add = (ln == 1 or ln == 9 or ln == 99)\n                ans = rec(cur+1, rem, ln + 1, ch) + add\n            else:\n                ans = rec(cur+1, rem-1, ln, ch)\n                ans = min(ans, rec(cur+1, rem, 1, s[cur]) + 1)\n            \n            return ans\n        \n        return rec(0, k, 0, '')\n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def dp(start, last, lastCount, k):\n            if k < 0:\n                return float('inf')\n            if start == len(s):\n                return 0\n            if s[start] == last:\n                inc = 1 if lastCount == 1 or lastCount == 9 or lastCount == 99 else 0\n                return min(inc + dp(start+1, last, lastCount + 1, k), 1 + dp(start+1, last, 1, k-1))\n            else:\n                return min(dp(start+1, last, lastCount, k-1), 1 + dp(start+1, s[start], 1, k))\n        return dp(0, '', 0, k)", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        #if s[i] != s[i-1]: dp[i][t] = min(dp[i-1][t-1], dp[i-1][t] + 1)\n        #else: dp[i][t] = min(dp[i-1][t-1], dp[i-1][t] + carry) carry = (cnt in [9, 99, 999]) cnt += 1\n        n = len(s)\n        cp = s[:]\n        \n        dp = [[n+1]*(k+2) for _ in range(n+1)]\n        dp[0][0] = 0\n        for i in range(1, n+1):\n            for t in range(k+1):\n                dp[i][t+1] = min(dp[i-1][t], dp[i][t+1])\n                cnt = 0\n                delete = 0\n                for l in range(i, n+1):\n                    if (cp[i-1] == cp[l-1]):\n                        cnt += 1\n                    else:\n                        delete += 1\n                    if (t + delete <= k):\n                        leng = dp[i-1][t] + 1\n                        if cnt >= 100: leng += 3\n                        elif cnt >= 10: leng += 2\n                        elif cnt >= 2: leng += 1\n                        else: leng += 0\n                        dp[l][t+delete] = min(dp[l][t+delete], leng)\n                    else:\n                        break\n        return dp[n][k]", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        \n        def calc(l):\n            if l == 0: return 0\n            elif l == 1: return 1\n            elif l < 10: return 2\n            elif l < 100: return 3\n            return 4\n        \n        \n        dp = [[float('inf')]*(k+1) for _ in range(len(s)+1)]\n        \n        for i in range(k+1):\n            dp[0][i] = 0\n            \n        \n        for i in range(1, len(s)+1):\n            for j in range(0, k+1):\n                # print(\\\"{0} {1}\\\".format(i,j))\n                if j > 0:\n                    dp[i][j] = dp[i-1][j-1]\n                \n                rem, cnt = 0, 0\n                for p in range(i, 0, -1):\n                    if s[p-1] == s[i-1]:\n                        cnt+=1\n                    else:\n                        rem+=1\n                    \n                    if rem > j:\n                        break\n                \n                    dp[i][j] = min(dp[i][j],\n                              dp[p-1][j-rem]+calc(cnt))\n        \n        # for row in dp:\n        #     print(row)\n        \n        return dp[len(s)][k]\n", "from functools import lru_cache\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def min_run_len(last_char, last_count, curr_idx, rest_k):\n            if curr_idx == len(s):\n                return 0\n            \n            # Keep current char\n            curr_count = last_count + 1 if s[curr_idx] == last_char else 1\n            incr = 1 if curr_count in [1, 2, 10, 100] else 0\n            res1 = incr + min_run_len(s[curr_idx], curr_count, curr_idx + 1, rest_k)\n            \n            # Delete current char\n            res2 = float('inf')\n            if rest_k > 0:\n                res2 = min_run_len(last_char, last_count, curr_idx + 1, rest_k - 1)\n                \n            return min(res1, res2)\n        \n        return min_run_len('#', 0, 0, k)\n", "import functools\n\nclass Solution:\n    @functools.lru_cache(maxsize = None)\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        @functools.lru_cache(maxsize = None)\n        def dp(i: int, last: int, size: int, k: int) -> int:\n            if k < 0:\n                return float('inf')\n            if i >= len(s):\n                return 0\n            answer: int = 0\n            if ord(s[i]) - ord('a') == last:\n                # same as the previous character, no need to delete\n                carry: int = 1 if size in (1, 9, 99) else 0\n                answer = carry + dp(i + 1, last, size + 1, k)\n            else:\n                # answer = min(keep s[i], delete s[i])\n                answer = min(1 + dp(i + 1, ord(s[i]) - ord('a'), 1, k), dp(i + 1, last, size, k - 1))\n            return answer\n        return dp(0, 26, 0, k)", "class Solution:\n    \n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        \n        def calculatelen(cnt):         #length calculator\n            if cnt==0: return 0\n            elif cnt==1: return 1\n            elif cnt < 10: return 2\n            elif cnt < 100: return 3\n            else: return 4\n        \n        \n        n = len(s)\n        x = 999999\n        dp = [[x]*(k+1) for i in range(n+1)]\n        for i in range(k+1):\n            dp[0][i] = 0\n\n        for i in range(1,n+1):\n            for j in range(k+1):\n                \n                cnt,remove = 0,0\n                \n                if j > 0: dp[i][j] = dp[i-1][j-1]\n                    \n                for p in range(i,0,-1):\n                    if(s[p-1] == s[i-1]): cnt+=1\n                    else: \n                        remove += 1\n                        if remove > j: break\n                    dp[i][j] = min(dp[i][j],(dp[p-1][j-remove] + calculatelen(cnt)))\n                    \n        return dp[n][k]", "def dlen(n):\n    ans = 0\n    while n > 0:\n        ans += 1\n        n //= 10\n    return ans\n\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        # dp[i][j]\n        # denotes minimum length of encoded string from 0 to i with at most j deletion\n        # Transition:\n        # if we keep s[i]: \n        # dp[i][j] = dp[i - 1][j - 1]\n        # if we remove s[i]:\n        # dp[i][j] = min(dp[i][j], dp[p - 1][j - removed] + 1 + digit_len for p from i..0)\n        \n        n = len(s)\n        dp = [[float('inf') for _ in range(k + 1)] for _ in range(n + 1)]\n        \n        for j in range(k + 1):\n            dp[0][j] = 0\n        \n        # we have two choices, to remove s[i] or to keep s[i]\n        for i in range(1, n + 1):\n            for j in range(k + 1):\n                if j > 0:\n                    # remove current character\n                    dp[i][j] = dp[i - 1][j - 1]\n                \n                # also consider remove all least frequent characters before s[i]\n                removed = 0\n                count = 0\n                for p in range(i, 0, -1):\n                    if s[i - 1] == s[p - 1]:\n                        count += 1\n                    else:\n                        removed += 1\n                    \n                    # remove at most j, cannot exceed j\n                    if removed > j:\n                        break\n                    \n                    digit_len = 0 if count == 1 else dlen(count)\n                    dp[i][j] = min(dp[i][j], dp[p - 1][j - removed] + 1 + digit_len)\n        \n        return dp[n][k]\n        \n        \n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        st,n = 0,len(s)\n        seg = []\n        for i in range(1,n):\n            if s[i]!=s[i-1]:\n                seg.append((s[i-1],i-st))\n                st=i\n        seg.append((s[n-1],n-st))\n        n=len(seg)\n        dp = [[None]*(k+1) for _ in range(n)]\n        def solve(i,ki):\n            if i==n:\n                return 0\n            if dp[i][ki] is not None:\n                return dp[i][ki]\n            dp[i][ki]=float('inf')\n            for j in range(min(ki+1,seg[i][1]+1)):\n                if seg[i][1]!=j:\n                    dp[i][ki]=min(dp[i][ki],1+(len(str(seg[i][1]-j)) if seg[i][1]-j!=1 else 0)+solve(i+1,ki-j))\n                else:\n                    dp[i][ki]=min(dp[i][ki],solve(i+1,ki-j))\n            ps = 0\n            curr=0\n            for j in range(i+1,n):\n                if ki>=ps and seg[j][0]==seg[i][0]:\n                    for kj in range(ki-ps+1):\n                        if kj<seg[i][1]+seg[j][1]+curr:\n                            dp[i][ki]=min(dp[i][ki],1+(len(str(seg[i][1]+curr+seg[j][1]-kj)) if seg[i][1]+curr+seg[j][1]-kj!=1 else 0)+solve(j+1,ki-ps-kj))\n                        elif kj==seg[i][1]+seg[j][1]+curr:\n                            dp[i][ki]=min(dp[i][ki],solve(j+1,ki-ps-kj))\n                        else:\n                            break\n                ps+=(seg[j][1] if seg[j][0]!=seg[i][0] else 0)\n                curr+=(seg[j][1] if seg[j][0]==seg[i][0] else 0)\n            return dp[i][ki]\n        return solve(0,k)", "def dlen(n):\n    ans = 0\n    while n > 0:\n        ans += 1\n        n //= 10\n    return ans\n\nclass Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        # dp[i][j]\n        # denotes minimum length of encoded string from 0 to i with at most j deletion\n        # Transition:\n        # if we keep s[i]: \n        # dp[i][j] = dp[i - 1][j - 1]\n        # if we remove s[i]:\n        # dp[i][j] = min(dp[i][j], dp[p - 1][j - removed] + 1 + digit_len for p from i..0)\n        \n        n = len(s)\n        dp = [[float('inf') for _ in range(k + 1)] for _ in range(n + 1)]\n        \n        for j in range(k + 1):\n            dp[0][j] = 0\n        \n        # we have two choices, to remove s[i] or to keep s[i]\n        for i in range(1, n + 1):\n            for j in range(k + 1):\n                if j > 0:\n                    # remove current character\n                    dp[i][j] = dp[i - 1][j - 1]\n                \n                # also consider remove the least frequent characters before s[i]\n                removed = 0\n                count = 0\n                for p in range(i, 0, -1):\n                    if s[i - 1] == s[p - 1]:\n                        count += 1\n                    else:\n                        removed += 1\n                    \n                    # remove at most j, cannot exceed j\n                    if removed > j:\n                        break\n                    \n                    digit_len = 0 if count == 1 else dlen(count)\n                    dp[i][j] = min(dp[i][j], dp[p - 1][j - removed] + 1 + digit_len)\n        \n        return dp[n][k]\n        \n        \n", "class Solution:\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        \n        #index,last_char,running_length, k\n        \n        @lru_cache(None)\n        def dp(index, last_char, running_length,k):\n            if index >= len(s):\n                return 0\n            if k < 0:\n                return 9999999\n            if s[index] == last_char:\n                extra = 0\n                if running_length == 1 or running_length == 9 or running_length == 99:\n                    extra += 1\n                incl = extra + dp(index+1,s[index],running_length+1,k)\n                excl = 99999\n                if k > 0:\n                    excl = dp(index+1,last_char,running_length,k-1)\n                return min(incl,excl)\n            incl = 1 + dp(index+1,s[index],1,k)\n            excl = 99999\n            if k > 0:\n                excl = dp(index+1,last_char,running_length,k-1)\n            return min(incl,excl)\n        return dp(0,'',0,k)"]
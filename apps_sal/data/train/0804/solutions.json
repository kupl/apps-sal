["import numpy as np\nfor _ in range(int(input())):\n   n = int(input())-1;soldiers = [int(j) for j in input().split()]\n   force = int(input());attacks = np.zeros(2*n,dtype=int);attacks[:n] = np.array(soldiers);attacks[n:2*n] = attacks[:n];shield = [0 for _ in range(n)];pow_of_2 = 1\n   while n // pow_of_2 > 0:      pow_of_2 *= 2\n   soldier_of_attack = (2 * n - pow_of_2) % n;pow_of_2 = attacks[soldier_of_attack] > force\n   \n   for i in range(n):\n      if attacks[i] > force:         shield[i] = 10 ** 11\n      elif n == 1:         shield[i] = force\n      elif pow_of_2:\n         shield[i] = force;         num_of_survivors = n;  soldiers = list(attacks[i:i+n]);         starting_soldier = (n - i) % n\n         if (num_of_survivors - starting_soldier) % 2 == 1:            shield[i] += soldiers[-1]\n         soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0];num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\n         if num_of_survivors > 1:\n            pow_2 = 1\n            while True:\n               attacker = num_of_survivors - (num_of_survivors % pow_2);   pow_2 *= 2\n               if attacker == 0:                  break\n               if attacker % pow_2 == 0:                  shield[i] += soldiers[attacker]\n      elif i == soldier_of_attack:         shield[i] = force\n      else:         shield[i] = force + 1   \n   shield_needed = min(shield)\n   if shield_needed == 10 ** 11:      print(\"impossible\")\n   else:\n      print(\"possible\")\n      for i in range(n):\n         if shield[i] == shield_needed:print(str(i+1) + \" \" + str(shield_needed));break", "# cook your dish here\nimport numpy as np\ntests = int(input())\nfor _ in range(tests):\n   n = int(input())-1\n   soldiers = [int(j) for j in input().split()]\n   force = int(input())\n   attacks = np.zeros(2*n,dtype=int)\n   attacks[:n] = np.array(soldiers)\n   attacks[n:2*n] = attacks[:n]\n   shield = [0 for _ in range(n)]\n   \n   pow_of_2 = 1\n   while n // pow_of_2 > 0:\n      pow_of_2 *= 2\n   soldier_of_attack = (2 * n - pow_of_2) % n\n   pow_of_2 = attacks[soldier_of_attack] > force\n   \n   for i in range(n):\n      if attacks[i] > force:\n         shield[i] = 10 ** 11\n      elif n == 1:\n         shield[i] = force\n      elif pow_of_2:\n         shield[i] = force\n         num_of_survivors = n\n         soldiers = list(attacks[i:i+n])\n         starting_soldier = (n - i) % n\n         if (num_of_survivors - starting_soldier) % 2 == 1:\n            shield[i] += soldiers[-1]\n         soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0]\n         num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\n         if num_of_survivors > 1:\n            pow_2 = 1\n            while True:\n               attacker = num_of_survivors - (num_of_survivors % pow_2)\n               pow_2 *= 2\n               if attacker == 0:\n                  break\n               if attacker % pow_2 == 0:\n                  shield[i] += soldiers[attacker]\n      elif i == soldier_of_attack:\n         shield[i] = force\n      else:\n         shield[i] = force + 1\n   \n   shield_needed = min(shield)\n   if shield_needed == 10 ** 11:\n      print(\"impossible\")\n   else:\n      print(\"possible\")\n      for i in range(n):\n         if shield[i] == shield_needed:\n            print(str(i+1) + \" \" + str(shield_needed))\n            break", "# cook your dish here\nimport numpy as np\ntests = int(input())\nfor _ in range(tests):\n   n = int(input())-1\n   soldiers = [int(j) for j in input().split()]\n   force = int(input())\n   attacks = np.zeros(2*n,dtype=int)\n   attacks[:n] = np.array(soldiers)\n   attacks[n:2*n] = attacks[:n]\n   shield = [0 for _ in range(n)]\n   \n   for i in range(n):\n      if attacks[i] > force:\n         shield[i] = 10 ** 11\n      elif n == 1:\n         shield[i] = force\n      else:\n         shield[i] = force\n         num_of_survivors = n\n         soldiers = list(attacks[i:i+n])\n         starting_soldier = (n - i) % n\n         if (num_of_survivors - starting_soldier) % 2 == 1:\n            shield[i] += soldiers[-1]\n         soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0]\n         num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier - 1) // 2\n         if num_of_survivors > 1:\n            pow_2 = 1\n            while True:\n               attacker = num_of_survivors - (num_of_survivors % pow_2)\n               pow_2 *= 2\n               if attacker == 0:\n                  break\n               if attacker % pow_2 == 0:\n                  shield[i] += soldiers[attacker]\n   \n   shield_needed = min(shield)\n   if shield_needed == 10 ** 11:\n      print(\"impossible\")\n   else:\n      print(\"possible\")\n      for i in range(n):\n         if shield[i] == shield_needed:\n            print(str(i+1) + \" \" + str(shield_needed))\n            break", "# cook your dish here\nimport numpy as np\ntests = int(input())\nfor _ in range(tests):\n   n = int(input())-1\n   soldiers = [int(j) for j in input().split()]\n   force = int(input())\n   attacks = np.zeros(2*n,dtype=int)\n   attacks[:n] = np.array(soldiers)\n   attacks[n:2*n] = attacks[:n]\n   shield = [0 for _ in range(n)]\n   for i in range(n):\n      if attacks[i] > force:\n         shield[i] = 10 ** 11\n      else:\n         shield[i] = force\n         num_of_survivors = n\n         soldiers = list(attacks[i:i+n])\n         starting_soldier = (n - i) % n\n         while num_of_survivors > 1:\n            if (num_of_survivors - starting_soldier) % 2 == 1:\n               shield[i] += soldiers[-1]\n            soldiers = [soldiers[i] for i in range(num_of_survivors) if i < starting_soldier or (i - starting_soldier) % 2 == 0]\n            num_of_survivors = starting_soldier + (num_of_survivors - starting_soldier + 1) // 2\n            starting_soldier = 0\n   shield_needed = min(shield)\n   if shield_needed == 10 ** 11:\n      print(\"impossible\")\n   else:\n      print(\"possible\")\n      for i in range(n):\n         if shield[i] == shield_needed:\n            print(str(i+1) + \" \" + str(shield_needed))\n            break", "def fun(l,n,i):\n    ans=0\n    no_term=n-i+1 + i//2\n    side=i+(no_term-1)\n    if side>n:\n        side=2*(side-n)-1\n    count=0\n    power=1\n    if i%2==0:\n        ans+=l[side-1]\n    while(side!=i):\n        if no_term%2==0:\n            no_term=no_term//2\n            #count+=1\n            power*=2\n        else:\n            no_term=(no_term//2)+1\n            ans+=l[side-1]\n            #count+=1\n            power*=2\n\n        side=i+(no_term-1)*power\n        if side>n:\n            side=2*(side-n)-1\n    return ans\nfor _ in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    f=int(input())\n    ans=[]\n    c=0\n    count=0\n    P=None\n    for i in range(len(l)):\n        if l[i]<=f :\n            c=1\n            if count==0:\n                count+=1\n                D=fun(l,n-1,i+1)\n                P=i+1\n            else:\n                yt=fun(l,n-1,i+1)\n                if yt<D:\n                    P=i+1\n                    D=yt\n    if c==0:\n        print('impossible')\n    else:\n        print('possible')\n        print(P,D+f)", "# cook your dish here\ndef fun(l,n,i):\n    ans=0\n    no_term=n-i+1 + i//2\n    side=i+(no_term-1)\n    if side>n:\n        side=2*(side-n)-1\n    count=0\n    power=1\n    if i%2==0:\n        ans+=l[side-1]\n    while(side!=i):\n        if no_term%2==0:\n            no_term=no_term//2\n            #count+=1\n            power*=2\n        else:\n            no_term=(no_term//2)+1\n            ans+=l[side-1]\n            #count+=1\n            power*=2\n\n        side=i+(no_term-1)*power\n        if side>n:\n            side=2*(side-n)-1\n    return ans\nfor _ in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    f=int(input())\n    ans=[]\n    c=0\n    count=0\n    P=None\n    for i in range(len(l)):\n        if l[i]<=f :\n            c=1\n            if count==0:\n                count+=1\n                D=fun(l,n-1,i+1)\n                P=i+1\n            else:\n                yt=fun(l,n-1,i+1)\n                if yt<D:\n                    P=i+1\n                    D=yt\n    if c==0:\n        print('impossible')\n    else:\n        print('possible')\n        print(P,D+f)\n", "# cook your dish here\ndef fun(l,n,i):\n    ans=0\n    no_term=n-i+1 + i//2\n    side=i+(no_term-1)\n    if side>n:\n        side=2*(side-n)-1\n    count=0\n    power=1\n    if i%2==0:\n        ans+=l[side-1]\n    while(side!=i):\n        if no_term%2==0:\n            no_term=no_term//2\n            #count+=1\n            power*=2\n        else:\n            no_term=(no_term//2)+1\n            ans+=l[side-1]\n            #count+=1\n            power*=2\n\n        side=i+(no_term-1)*power\n        if side>n:\n            side=2*(side-n)-1\n    return ans\nfor _ in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    f=int(input())\n    ans=[]\n    c=0\n    count=0\n    P=None\n    for i in range(len(l)):\n        if l[i]<=f :\n            c=1\n            if count==0:\n                count+=1\n                D=fun(l,n-1,i+1)\n                P=i+1\n            else:\n                yt=fun(l,n-1,i+1)\n                if yt<D:\n                    P=i+1\n                    D=yt\n    if c==0:\n        print('impossible')\n    else:\n        print('possible')\n        print(P,D+f)\n", "# cook your dish here\ndef solve_small(numbers, n, f):\n\n    found = False\n    min_shield = 0\n    min_pos = 0\n    for pos in range(n):\n        # First optimization\n        next_pos0 = pos % (n - 1)\n        # print(pos, next_pos0)\n        if numbers[next_pos0] > f:\n            continue\n\n        new_numbers = [_ for _ in numbers]\n        new_numbers.insert(pos, 0)\n        #print(\"new numbers: \",new_numbers, next_pos0)\n\n        curr_pos = 0\n        # round = 1\n        while len(new_numbers) > 2:\n            next_pos = (curr_pos + 1) % len(new_numbers)\n            # print(\"Round {}: {}, {}, {}\".format(round, curr_pos, next_pos, new_numbers))\n            if new_numbers[next_pos] <= 0:\n                # print(\"Attacked Josh from {} to {}\".format(curr_pos, next_pos))\n                new_numbers[next_pos] -= new_numbers[curr_pos]\n            elif new_numbers[curr_pos] > 0:\n                # print(\"Killed soldier from {} to {}\".format(curr_pos, next_pos))\n                new_numbers.pop(next_pos)\n            else:\n                # print(\"Josh does not attack\")\n                pass\n            if curr_pos >= len(new_numbers) - 1:\n                curr_pos = 0\n            else:\n                curr_pos += 1\n            # print(\"Round {}: {}, {}\".format(round, curr_pos, new_numbers))\n            # round += 1\n\n        # print(new_numbers, f)\n        shield, min_f = -min(new_numbers), max(new_numbers)\n\n        # Other soldier will survive\n        if min_f > f:\n            continue\n\n        # Only Josh survives\n        shield += f\n        found = True\n        if not min_shield or min_shield > shield:\n            min_shield = shield\n            min_pos = pos\n\n    if found:\n        print(\"possible\")\n        return min_pos + 1, min_shield\n    else:\n        print(\"impossible\")\n        return 0, 0\ndef solve_med(numbers, n, f):\n\n    min_shield = 0\n    min_pos = 0\n    left_numbers = []\n    right_numbers = [0] + [_ for _ in numbers]\n\n    for pos in range(0, n):\n\n        right_numbers.pop(0)\n        if pos % 2:\n            left_numbers.append(numbers[pos - 1])\n\n        # First optimization - if next number is to big, it won't die in the end\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n\n        # Initial shield\n        shield = f\n        if pos % 2:\n            shield += numbers[pos - 1]\n\n        new_numbers = right_numbers + left_numbers\n        jos_pos = len(new_numbers)\n\n        new_pos = jos_pos\n        factor = 2\n        while new_pos > 1:\n            if new_pos % 2:\n                number = new_numbers[get_prev_multiple(jos_pos, factor)]\n                number2 = numbers[get_prev_multiple_2(n - 1, pos, factor)]\n                # print(number, number2)\n                shield += number\n                # shield += new_numbers[get_prev_multiple(jos_pos, factor)]\n                # print(factor, get_prev_multiple(jos_pos, factor))\n            new_pos = new_pos // 2 + (new_pos % 2)\n            factor *= 2\n\n        if not min_shield or shield < min_shield:\n            min_shield = shield\n            min_pos = pos + 1\n\n    if min_shield:\n        print(\"possible\")\n    else:\n        print(\"impossible\")\n\n    return min_pos, min_shield\ndef get_prev_multiple_2(n, pos, f):\n\n    left_numbers = (pos - 1) // 2\n    right_numbers = n - pos\n    total_numbers = left_numbers + right_numbers\n    number = total_numbers - total_numbers % f\n    if number >= right_numbers:\n        number = number - right_numbers\n        return 2 * number\n    else:\n        return pos + number\ndef get_prev_multiple(n, f):\n    return (n - 1) - (n - 1) % f\ndef get_input_line():\n    return input()\ndef solve_big(numbers, n, f):\n\n    min_shield = 0\n    min_pos = 0\n    for pos in range(0, n):\n\n        # First optimization - if next number is to big, it won't die in the end\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n\n        # Initial shield\n        shield = f\n        if pos % 2:\n            shield += numbers[pos - 1]\n\n        jos_pos = (pos - 1) // 2 + n - pos\n\n        new_pos = jos_pos\n        factor = 2\n        over = False\n        while new_pos > 1:\n            if new_pos % 2:\n                number = numbers[get_prev_multiple_2(n - 1, pos, factor)]\n                shield += number\n                if min_shield and shield >= min_shield:\n                    over = True\n                    break\n                # print(factor, get_prev_multiple(jos_pos, factor))\n            new_pos = new_pos // 2 + (new_pos % 2)\n            factor *= 2\n\n        if over:\n            continue\n\n        if not min_shield or shield < min_shield:\n            min_shield = shield\n            min_pos = pos + 1\n\n    if min_shield:\n        print(\"possible\")\n    else:\n        print(\"impossible\")\n\n    return min_pos, min_shield\nt=int(input())\nfor i in range(t):\n    n=int(input())\n    numbers=list(map(int,input().split(\" \")))\n    f=int(input())\n    min_pos, min_shield = solve_med(numbers, n, f)\n    if min_shield:\n        print(min_pos, min_shield)\n    \n", "# cook your dish here\ndef solve_small(numbers, n, f):\n\n    found = False\n    min_shield = 0\n    min_pos = 0\n    for pos in range(n):\n        # First optimization\n        next_pos0 = pos % (n - 1)\n        # print(pos, next_pos0)\n        if numbers[next_pos0] > f:\n            continue\n\n        new_numbers = [_ for _ in numbers]\n        new_numbers.insert(pos, 0)\n        #print(\"new numbers: \",new_numbers, next_pos0)\n\n        curr_pos = 0\n        # round = 1\n        while len(new_numbers) > 2:\n            next_pos = (curr_pos + 1) % len(new_numbers)\n            # print(\"Round {}: {}, {}, {}\".format(round, curr_pos, next_pos, new_numbers))\n            if new_numbers[next_pos] <= 0:\n                # print(\"Attacked Josh from {} to {}\".format(curr_pos, next_pos))\n                new_numbers[next_pos] -= new_numbers[curr_pos]\n            elif new_numbers[curr_pos] > 0:\n                # print(\"Killed soldier from {} to {}\".format(curr_pos, next_pos))\n                new_numbers.pop(next_pos)\n            else:\n                # print(\"Josh does not attack\")\n                pass\n            if curr_pos >= len(new_numbers) - 1:\n                curr_pos = 0\n            else:\n                curr_pos += 1\n            # print(\"Round {}: {}, {}\".format(round, curr_pos, new_numbers))\n            # round += 1\n\n        # print(new_numbers, f)\n        shield, min_f = -min(new_numbers), max(new_numbers)\n\n        # Other soldier will survive\n        if min_f > f:\n            continue\n\n        # Only Josh survives\n        shield += f\n        found = True\n        if not min_shield or min_shield > shield:\n            min_shield = shield\n            min_pos = pos\n\n    if found:\n        print(\"possible\")\n        return min_pos + 1, min_shield\n    else:\n        print(\"impossible\")\n        return 0, 0\ndef solve_med(numbers, n, f):\n\n    min_shield = 0\n    min_pos = 0\n    left_numbers = []\n    right_numbers = [0] + [_ for _ in numbers]\n\n    for pos in range(0, n):\n\n        right_numbers.pop(0)\n        if pos % 2:\n            left_numbers.append(numbers[pos - 1])\n\n        # First optimization - if next number is to big, it won't die in the end\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n\n        # Initial shield\n        shield = f\n        if pos % 2:\n            shield += numbers[pos - 1]\n\n        new_numbers = right_numbers + left_numbers\n        jos_pos = len(new_numbers)\n\n        new_pos = jos_pos\n        factor = 2\n        while new_pos > 1:\n            if new_pos % 2:\n                number = new_numbers[get_prev_multiple(jos_pos, factor)]\n                number2 = numbers[get_prev_multiple_2(n - 1, pos, factor)]\n                # print(number, number2)\n                shield += number\n                # shield += new_numbers[get_prev_multiple(jos_pos, factor)]\n                # print(factor, get_prev_multiple(jos_pos, factor))\n            new_pos = new_pos // 2 + (new_pos % 2)\n            factor *= 2\n\n        if not min_shield or shield < min_shield:\n            min_shield = shield\n            min_pos = pos + 1\n\n    if min_shield:\n        print(\"possible\")\n    else:\n        print(\"impossible\")\n\n    return min_pos, min_shield\ndef get_prev_multiple_2(n, pos, f):\n\n    left_numbers = (pos - 1) // 2\n    right_numbers = n - pos\n    total_numbers = left_numbers + right_numbers\n    number = total_numbers - total_numbers % f\n    if number >= right_numbers:\n        number = number - right_numbers\n        return 2 * number\n    else:\n        return pos + number\ndef get_prev_multiple(n, f):\n    return (n - 1) - (n - 1) % f\ndef get_input_line():\n    return input()\ndef solve_big(numbers, n, f):\n\n    min_shield = 0\n    min_pos = 0\n    for pos in range(0, n):\n\n        # First optimization - if next number is to big, it won't die in the end\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n\n        # Initial shield\n        shield = f\n        if pos % 2:\n            shield += numbers[pos - 1]\n\n        jos_pos = (pos - 1) // 2 + n - pos\n\n        new_pos = jos_pos\n        factor = 2\n        over = False\n        while new_pos > 1:\n            if new_pos % 2:\n                number = numbers[get_prev_multiple_2(n - 1, pos, factor)]\n                shield += number\n                if min_shield and shield >= min_shield:\n                    over = True\n                    break\n                # print(factor, get_prev_multiple(jos_pos, factor))\n            new_pos = new_pos // 2 + (new_pos % 2)\n            factor *= 2\n\n        if over:\n            continue\n\n        if not min_shield or shield < min_shield:\n            min_shield = shield\n            min_pos = pos + 1\n\n    if min_shield:\n        print(\"possible\")\n    else:\n        print(\"impossible\")\n\n    return min_pos, min_shield\nt=int(input())\nfor i in range(t):\n    n=int(input())\n    numbers=list(map(int,input().split(\" \")))\n    f=int(input())\n    min_pos, min_shield = solve_small(numbers, n, f)\n    if min_shield:\n        print(min_pos, min_shield)\n    \n", "# cook your dish here\ndef solve_small(numbers, n, f):\n\n    found = False\n    min_shield = 0\n    min_pos = 0\n    for pos in range(n):\n        # First optimization\n        next_pos0 = pos % (n - 1)\n        # print(pos, next_pos0)\n        if numbers[next_pos0] > f:\n            continue\n\n        new_numbers = [_ for _ in numbers]\n        new_numbers.insert(pos, 0)\n        #print(\"new numbers: \",new_numbers, next_pos0)\n\n        curr_pos = 0\n        # round = 1\n        while len(new_numbers) > 2:\n            next_pos = (curr_pos + 1) % len(new_numbers)\n            # print(\"Round {}: {}, {}, {}\".format(round, curr_pos, next_pos, new_numbers))\n            if new_numbers[next_pos] <= 0:\n                # print(\"Attacked Josh from {} to {}\".format(curr_pos, next_pos))\n                new_numbers[next_pos] -= new_numbers[curr_pos]\n            elif new_numbers[curr_pos] > 0:\n                # print(\"Killed soldier from {} to {}\".format(curr_pos, next_pos))\n                new_numbers.pop(next_pos)\n            else:\n                # print(\"Josh does not attack\")\n                pass\n            if curr_pos >= len(new_numbers) - 1:\n                curr_pos = 0\n            else:\n                curr_pos += 1\n            # print(\"Round {}: {}, {}\".format(round, curr_pos, new_numbers))\n            # round += 1\n\n        # print(new_numbers, f)\n        shield, min_f = -min(new_numbers), max(new_numbers)\n\n        # Other soldier will survive\n        if min_f > f:\n            continue\n\n        # Only Josh survives\n        shield += f\n        found = True\n        if not min_shield or min_shield > shield:\n            min_shield = shield\n            min_pos = pos\n\n    if found:\n        print(\"possible\")\n        return min_pos + 1, min_shield\n    else:\n        print(\"impossible\")\n        return 0, 0\ndef solve_med(numbers, n, f):\n\n    min_shield = 0\n    min_pos = 0\n    left_numbers = []\n    right_numbers = [0] + [_ for _ in numbers]\n\n    for pos in range(0, n):\n\n        right_numbers.pop(0)\n        if pos % 2:\n            left_numbers.append(numbers[pos - 1])\n\n        # First optimization - if next number is to big, it won't die in the end\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n\n        # Initial shield\n        shield = f\n        if pos % 2:\n            shield += numbers[pos - 1]\n\n        new_numbers = right_numbers + left_numbers\n        jos_pos = len(new_numbers)\n\n        new_pos = jos_pos\n        factor = 2\n        while new_pos > 1:\n            if new_pos % 2:\n                number = new_numbers[get_prev_multiple(jos_pos, factor)]\n                number2 = numbers[get_prev_multiple_2(n - 1, pos, factor)]\n                # print(number, number2)\n                shield += number\n                # shield += new_numbers[get_prev_multiple(jos_pos, factor)]\n                # print(factor, get_prev_multiple(jos_pos, factor))\n            new_pos = new_pos // 2 + (new_pos % 2)\n            factor *= 2\n\n        if not min_shield or shield < min_shield:\n            min_shield = shield\n            min_pos = pos + 1\n\n    if min_shield:\n        print(\"possible\")\n    else:\n        print(\"impossible\")\n\n    return min_pos, min_shield\ndef get_prev_multiple_2(n, pos, f):\n\n    left_numbers = (pos - 1) // 2\n    right_numbers = n - pos\n    total_numbers = left_numbers + right_numbers\n    number = total_numbers - total_numbers % f\n    if number >= right_numbers:\n        number = number - right_numbers\n        return 2 * number\n    else:\n        return pos + number\ndef get_prev_multiple(n, f):\n    return (n - 1) - (n - 1) % f\ndef get_input_line():\n    return input()\ndef solve_big(numbers, n, f):\n\n    min_shield = 0\n    min_pos = 0\n    for pos in range(0, n):\n\n        # First optimization - if next number is to big, it won't die in the end\n        next_pos0 = pos % (n - 1)\n        if numbers[next_pos0] > f:\n            continue\n\n        # Initial shield\n        shield = f\n        if pos % 2:\n            shield += numbers[pos - 1]\n\n        jos_pos = (pos - 1) // 2 + n - pos\n\n        new_pos = jos_pos\n        factor = 2\n        over = False\n        while new_pos > 1:\n            if new_pos % 2:\n                number = numbers[get_prev_multiple_2(n - 1, pos, factor)]\n                shield += number\n                if min_shield and shield >= min_shield:\n                    over = True\n                    break\n                # print(factor, get_prev_multiple(jos_pos, factor))\n            new_pos = new_pos // 2 + (new_pos % 2)\n            factor *= 2\n\n        if over:\n            continue\n\n        if not min_shield or shield < min_shield:\n            min_shield = shield\n            min_pos = pos + 1\n\n    if min_shield:\n        print(\"possible\")\n    else:\n        print(\"impossible\")\n\n    return min_pos, min_shield\nt=int(input())\nfor i in range(t):\n    n=int(input())\n    numbers=list(map(int,input().split(\" \")))\n    f=int(input())\n    min_pos, min_shield = solve_big(numbers, n, f)\n    if min_shield:\n        print(min_pos, min_shield)\n    \n", "# cook your dish here\ndef solution(a,n,f):\n        idxs = []\n        i = 0\n        while i < n - 1:\n            if a[i] <= f:\n                idxs.append(i)\n            i += 1\n        if len(idxs) == 0:\n            print(\"impossible\")\n            return\n        mn = 1000000000\n        for k in idxs:\n            left = k\n            pts = 0 \n            elm = left - 1\n            right = n - 1 - left\n            last = n - 2\n            sub = a[elm]\n            sleft = 1\n            slast = 1\n            while left > 0:\n                if left % 2 == 0:\n                    elm -= sleft\n                    sub = a[elm]\n                    left = left//2\n                    sleft *= 2\n                else:\n                    pts += a[elm]\n                    left = (left+1)//2\n                    sleft *= 2\n                \n                if right % 2 == 0:\n                    last -= slast\n                    right //= 2\n                    slast *=2\n                else:\n                    slast *= 2\n                    left -= 1\n                    right = (right + 1) // 2\n                    \n            while right > 2:\n                if right % 2 == 0:\n                    last -= slast\n                    sub = a[last]\n                    right = right // 2\n                    slast *= 2\n                else:\n                    slast *= 2\n                    sub = a[last]\n                    pts += sub\n                    right = (right + 1) // 2\n            if mn > pts:\n                mn = pts\n                idx = k\n                if pts == 0:\n                    break\n        print(\"possible\")\n        print(idx + 1,mn + f)\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int,input().split()))\n        f = int(input())\n        solution(a,n,f)\nmain()", "# cook your dish here\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int,input().split()))\n        f = int(input())\n        idxs = []\n        i = 0\n        while i < n - 1:\n            if a[i] <= f:\n                idxs.append(i)\n            i += 1\n        if len(idxs) == 0:\n            print(\"impossible\")\n            continue\n        mn = 1000000000\n        for k in idxs:\n            left = k\n            pts = 0 \n            elm = left - 1\n            right = n - 1 - left\n            last = n - 2\n            sub = a[elm]\n            sleft = 1\n            slast = 1\n            while left > 0:\n                if left % 2 == 0:\n                    elm -= sleft\n                    sub = a[elm]\n                    left = left//2\n                    sleft *= 2\n                else:\n                    pts += a[elm]\n                    left = (left+1)//2\n                    sleft *= 2\n                \n                if right % 2 == 0:\n                    last -= slast\n                    right //= 2\n                    slast *=2\n                else:\n                    slast *= 2\n                    left -= 1\n                    right = (right + 1) // 2\n                    \n            while right > 2:\n                if right % 2 == 0:\n                    last -= slast\n                    sub = a[last]\n                    right = right // 2\n                    slast *= 2\n                else:\n                    slast *= 2\n                    sub = a[last]\n                    pts += sub\n                    right = (right + 1) // 2\n            if mn > pts:\n                mn = pts\n                idx = k\n                if pts == 0:\n                    break\n        print(\"possible\")\n        print(idx + 1,mn + f)\nmain()", "# cook your dish here\nimport sys\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int,sys.stdin.readline().split()))\n    f = int(input())\n    idxs = []\n    i = 0\n    while i < n - 1:\n        if a[i] <= f:\n            idxs.append(i)\n        i += 1\n    if len(idxs) == 0:\n        print(\"impossible\")\n        continue\n    mn = 1000000000\n    for k in idxs:\n        left = k\n        pts = 0 \n        elm = left - 1\n        right = n - 1 - left\n        last = n - 2\n        sub = a[elm]\n        sleft = 1\n        slast = 1\n        while left > 0:\n            if left % 2 == 0:\n                elm -= sleft\n                sub = a[elm]\n                left = left//2\n                sleft *= 2\n            else:\n                pts += a[elm]\n                left = (left+1)//2\n                sleft *= 2\n            \n            if right % 2 == 0:\n                last -= slast\n                right //= 2\n                slast *=2\n            else:\n                slast *= 2\n                left -= 1\n                right = (right + 1) // 2\n                \n        while right > 2:\n            if right % 2 == 0:\n                last -= slast\n                sub = a[last]\n                right = right // 2\n                slast *= 2\n            else:\n                slast *= 2\n                sub = a[last]\n                pts += sub\n                right = (right + 1) // 2\n        if mn > pts:\n            mn = pts\n            idx = k\n            if pts == 0:\n                break\n    print(\"possible\")\n    print(idx + 1,mn + f)", "p2=[1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216]\r\nfor _ in range(int(input())):\r\n\tn=int(input())-1\r\n\ta=[int(x) for x in input().split()]\r\n\tf,l=int(input()),[]\r\n\tfor i in range(n):\r\n\t\tif a[i]<=f: l.append(i)\r\n\t\tif i%2==0: a.append(a[i])\r\n\tif len(l)==0:\r\n\t\tprint(\"impossible\")\r\n\t\tcontinue\r\n\tprint(\"possible\")\r\n\td,p=10**12,-1\r\n#\tprint(*a)\r\n\tfor i in l:\r\n\t\tx=-1+n-i+(i+1)//2\r\n\t\tlast=i+x\r\n\t\ttd=f\r\n\t\tif i%2==1: td+=a[i-1]\r\n\t\tfor j in range(1,25):\r\n\t\t\tif p2[j]>x: break\r\n\t\t\tla=last-x%p2[j]\r\n\t\t\tif la+p2[j-1]>last: td+=a[la]\r\n\t\tif td<d: d,p=td,i+1\r\n\tprint(p,d)\r\n", "from sys import stdin\r\nfrom math import ceil\r\n\r\ndef func(arr):\r\n    step=0\r\n    right=len(arr)-1\r\n    n=len(arr)\r\n    while(right!=1):\r\n        step+=1\r\n        if n%2!=0:\r\n            right-=(2**(step-1))\r\n        else:\r\n            arr[0]-=arr[right]\r\n        n=ceil((n-1)/2)+1\r\n    return arr[0]    \r\n\r\nfor _ in range(int(stdin.readline())):\r\n    n=int(stdin.readline())\r\n    arr=list(map(int,stdin.readline().split()))\r\n    f=int(stdin.readline())\r\n    indexes=[i for i,x in enumerate(arr) if x<=f]\r\n    if len(indexes)==0:\r\n        print(\"impossible\")\r\n    else:\r\n        print(\"possible\")\r\n        final={}\r\n        for ele in indexes:\r\n            part=arr[0:ele]\r\n            p=len(part)\r\n            part=part[0:p:2]\r\n            if p%2!=0:\r\n                part.append(0-part[-1])\r\n            else:\r\n                part.append(0)\r\n            case=arr[ele:]+part\r\n            ans=[case[-1]]+case[0:len(case)-1]\r\n            m=abs(func(ans))\r\n            if m in final:\r\n                final[m].append(ele)\r\n            else:\r\n                final[m]=[ele]   \r\n        print(min(final[min(list(final.keys()))])+1,min(list(final.keys()))+f)\r\n", "try:\n    t=int(input())\n    for i in range(t):\n        \n        \n        n=int(input())\n        a=list(map(int,input().split()))\n        a1=a.copy()\n        #print(\"a1==\",a1)\n        f=int(input())\n        length_a=len(a)\n        #print(min(l))\n        l1=[]\n        l2=[]\n        \n        \n        \n        \n        for j in range(length_a+1):\n                a=a1.copy()\n                \n                #print(\"1st line with j\",a,j)\n                l=['D',0,0]\n                a.insert(j,l)\n                k=0\n                l[2]=j+1\n                #print(a)\n                while len(a) !=2:\n                    length=len(a)\n                    #print(\"****\",length,k)\n                    if k>=length:\n                        k=0\n                    if a[k]==l:\n                        k=k+1\n                        #print(\"skipped\")\n                        continue\n                    else:\n                        m=k+1\n                        if m>=length:\n                            m=0\n                        if a[m]==l:\n                            l[1]+=a[k]\n                        else:\n                            del a[m]\n                            #print(\"a[m] wala\",a)\n                        k+=1\n                    \n                '''if len(a)==2:\n                    if a[0]==l:\n                        l[1]+=f\n                    else:\n                        a[1]=a[1]-f\n                        \n                    if a[1]==l:\n                        l[1]+=f\n                    else:\n                        a[0]=a[0]-f\n                        if a[0]<0:\n                            l1.append(l)\n                ''' \n                \n                if a[0]==l:\n                    l[1]+=f\n                        \n                else:\n                        a[0]=a[0]-f\n                if a[1]==l:\n                    l[1]+=f\n                        \n                else:\n                        a[1]=a[1]-f\n                #print(\"z wala loop\",a)\n                \n                if a[0]!=l:\n                        if a[0]<=0:\n                            l1.append(l)\n                            l2.append(1)\n                        else:\n                            l2.append(0)\n                if a[1]!=l:\n                        if a[1]<=0:\n                            l1.append(l)\n                            l2.append(1)\n                        else:\n                            l2.append(0)\n                #print(\"l1,l2\",l1,l2)\n                \n                #print(\"last line->>\",a)\n        '''if 1 in l2:\n                value=min(l1)\n                print('possible')\n                \n                print(value[2],value[1])\n        else:\n                print('impossible')\n                '''\n        if len(l1)>0:\n            value=min(l1)\n            print('possible')\n                \n            print(value[2],value[1])\n        else:\n            print('impossible')\nexcept:\n    pass"]
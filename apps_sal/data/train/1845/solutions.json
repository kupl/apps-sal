["class DLL:\n     \n     def __init__(self, val, key):\n         self.val = val\n         self.key = key\n         self.next = None\n         self.prev = None\n \n class AllOne:\n \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         self.hash = {}\n         self.head = None\n         self.tail = None\n \n     def inc(self, key):\n         \"\"\"\n         Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n         :type key: str\n         :rtype: void\n         \"\"\"\n         self.print_dll()\n         dll = self.hash.get(key, None)\n         if not dll:\n             dll = DLL(1, key)\n             self.insert_dll(dll)\n             self.hash[key] = dll\n         else:\n             self.incr_dll(dll)  \n         \n \n     def dec(self, key):\n         \"\"\"\n         Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\n         :type key: str\n         :rtype: void\n         \"\"\"\n         self.print_dll()\n         dll = self.hash.get(key, None)\n         if not dll:return\n         self.decr_dll(dll)\n         if dll.val == 0:\n             del self.hash[key]\n         \n \n     def getMaxKey(self):\n         \"\"\"\n         Returns one of the keys with maximal value.\n         :rtype: str\n         \"\"\"\n         if self.head:\n             return self.head.key\n         return \"\"\n         \n \n     def getMinKey(self):\n         \"\"\"\n         Returns one of the keys with Minimal value.\n         :rtype: str\n         \"\"\"\n         if self.tail:\n             return self.tail.key\n         return \"\"\n         \n     def insert_dll(self, dll):\n         if self.tail:\n             self.tail.next = dll\n             self.tail.next.prev = self.tail\n             self.tail = dll\n         else:\n             self.head = dll\n             self.tail = dll\n         \n     def incr_dll(self, dll):\n         dll.val = dll.val + 1\n         while dll.prev and dll.val > dll.prev.val:\n             \n             prev = dll.prev\n             prev_prev = dll.prev.prev\n             next_node = dll.next\n             \n             dll.next = prev\n             prev.next = next_node\n             dll.prev = prev_prev\n             prev.prev = dll\n             \n             if prev_prev:\n                 prev_prev.next = dll\n             else:\n                 self.head = dll\n             \n             if next_node:\n                 next_node.prev = prev\n             else:\n                 self.tail = prev\n                 \n             \n     def decr_dll(self, dll):\n         dll.val = dll.val - 1\n         if dll.val == 0 :\n             if dll.prev:\n                 dll.prev.next = dll.next\n             else:\n                 self.head = dll.next\n                                 \n             if dll.next:\n                 dll.next.prev = dll.prev\n             else:\n                 self.tail = dll.prev\n         \n         elif dll.next and dll.val < dll.next.val:\n             next_node = dll.next\n             next_next = dll.next.next\n             prev = dll.prev\n             \n             dll.next = next_next\n             dll.prev = next_node\n             \n             next_node.next = dll\n             next_node.prev = prev\n             \n             if next_next:\n                 next_next.prev = dll\n             else:\n                 self.tail = dll\n             if prev:\n                 prev.next = next_node\n             else:\n                 self.head = next_node\n                 \n     def print_dll(self):\n         temp = self.head\n         # while temp:\n         #     print(\"%s %s\" % (temp.key, str(temp.val)))\n         #     temp = temp.next\n         # print(\"End\")\n \n \n             \n             \n                 \n \n \n \n # Your AllOne object will be instantiated and called as such:\n # obj = AllOne()\n # obj.inc(key)\n # obj.dec(key)\n # param_3 = obj.getMaxKey()\n # param_4 = obj.getMinKey()", "from collections import defaultdict\n \n \n class Node(object):\n     def __init__(self, val, key, prev=None, next=None):\n         self.val = val\n         self.keys = set()\n         self.keys.add(key)\n         self.prev = prev\n         if prev is not None:\n             prev.next = self\n         self.next = next\n         if next is not None:\n             next.prev = self\n \n \n class AllOne(object):\n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         self.head = None\n         self.tail = None\n         self.key2node = dict()\n \n     def check_delete(self, node):\n         if len(node.keys) == 0:\n             prev = node.prev\n             next = node.next\n             if prev is None:  # node is self.head\n                 if next is None:\n                     self.head = None\n                     self.tail = None\n                 else:\n                     self.head = next\n                     self.head.prev = None\n             else:\n                 if next is None:  # node is self.tail\n                     self.tail = prev\n                     self.tail.next = None\n                 else:\n                     prev.next = next\n                     next.prev = prev\n \n     def inc(self, key):\n         \"\"\"\n         Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n         :type key: str\n         :rtype: void\n         \"\"\"\n         if key not in self.key2node:\n             if self.head is None:\n                 new_node = Node(1, key)\n                 self.head = new_node\n                 self.tail = new_node\n                 self.key2node[key] = new_node\n             elif self.head.val == 1:\n                 self.head.keys.add(key)\n                 self.key2node[key] = self.head\n             else:\n                 new_node = Node(1, key, next=self.head)\n                 self.head = new_node\n                 self.head.prev = None\n                 self.key2node[key] = new_node\n         else:\n             node = self.key2node[key]\n             del self.key2node[key]\n             node.keys.remove(key)\n             next_node = node.next\n             if next_node is None:  # node is self.tail\n                 next_node = Node(node.val + 1, key, prev=node)\n                 self.tail = next_node\n                 self.tail.next = None\n             elif next_node.val == node.val + 1:\n                 next_node.keys.add(key)\n             else:\n                 next_node = Node(node.val + 1, key, prev=node, next=next_node)\n \n             self.check_delete(node)\n             self.key2node[key] = next_node\n \n     def dec(self, key):\n         \"\"\"\n         Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\n         :type key: str\n         :rtype: void\n         \"\"\"\n         if key not in self.key2node:\n             return\n \n         node = self.key2node[key]\n         del self.key2node[key]\n         node.keys.remove(key)\n         prev_node = node.prev\n         if prev_node is None:  # node is self.head\n             if node.val != 1:\n                 new_node = Node(node.val - 1, key, next=node)\n                 self.head = new_node\n                 self.head.prev = None\n                 self.key2node[key] = new_node\n         elif prev_node.val == node.val - 1:\n             prev_node.keys.add(key)\n             self.key2node[key] = prev_node\n         else:\n             new_node = Node(node.val - 1, key, prev=prev_node, next=node)\n             self.key2node[key] = new_node\n \n         self.check_delete(node)\n \n     def getMaxKey(self):\n         \"\"\"\n         Returns one of the keys with maximal value.\n         :rtype: str\n         \"\"\"\n         return '' if self.tail is None else next(iter(self.tail.keys))\n         \n \n     def getMinKey(self):\n         \"\"\"\n         Returns one of the keys with Minimal value.\n         :rtype: str\n         \"\"\"\n         return '' if self.head is None else next(iter(self.head.keys))\n", "\n class Node:\n     def __init__(self, cnt):\n         self.count = cnt\n         self.prev = None\n         self.next = None\n \n \n class AllOne(object):\n \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         self.count_key_map={}\n         self.key_count_map={}\n         self.count_node_map={}\n         \n         self.head=Node(0)\n         self.tail=Node(float('inf'))\n         \n         self.head.next=self.tail\n         self.tail.prev=self.head\n         \n         self.count_node_map[0]=self.head\n         self.count_node_map[float('inf')]=self.tail\n \n     def inc(self, key):\n         \"\"\"\n         Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n         :type key: str\n         :rtype: void\n         \"\"\"\n         if key not in self.key_count_map:\n             self.key_count_map[key]=0\n         \n         \n         prev_count=self.key_count_map[key]\n         prev_node=self.count_node_map[prev_count]\n         \n         self.key_count_map[key]+=1\n         \n         if prev_node.next.count!=self.key_count_map[key]:\n             new_node=Node(self.key_count_map[key])\n             self.insert(prev_node,new_node)\n             self.count_key_map[self.key_count_map[key]]=set()\n             self.count_node_map[self.key_count_map[key]]=new_node\n         \n         self.count_key_map[self.key_count_map[key]].add(key)\n         \n         if prev_count!=0:\n            \n            self.count_key_map[prev_count].remove(key)\n            if len(self.count_key_map[prev_count])==0:\n                self.count_node_map.pop(prev_count)\n                self.count_key_map.pop(prev_count)\n                self.delete(prev_node)\n                \n     \n         \n \n     def dec(self, key):\n         \"\"\"\n         Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\n         :type key: str\n         :rtype: void\n         \"\"\"\n         if key not in self.key_count_map:\n             return \n         prev_count=self.key_count_map[key]\n         prev_node=self.count_node_map[prev_count]\n         \n         self.key_count_map[key]-=1\n         \n         \n         if self.key_count_map[key]==0:\n            self.key_count_map.pop(key)\n         else:\n             if prev_node.prev.count!=self.key_count_map[key]:\n                 new_node=Node(self.key_count_map[key])\n                 self.insert(prev_node.prev,new_node)\n                 self.count_key_map[self.key_count_map[key]]=set()\n                 self.count_node_map[self.key_count_map[key]]=new_node\n         \n             self.count_key_map[self.key_count_map[key]].add(key) \n             \n             \n         self.count_key_map[prev_count].remove(key)\n         if len(self.count_key_map[prev_count])==0:\n                self.delete(prev_node)\n                self.count_node_map.pop(prev_count)\n                self.count_key_map.pop(prev_count)\n             \n     def getMaxKey(self):\n         \"\"\"\n         Returns one of the keys with maximal value.\n         :rtype: str\n         \"\"\"\n         if self.head.next == self.tail:\n             return \"\"\n         x = self.count_key_map[self.tail.prev.count].pop()\n         self.count_key_map[self.tail.prev.count].add(x)\n         return x\n         \n \n     def getMinKey(self):\n         \"\"\"\n         Returns one of the keys with Minimal value.\n         :rtype: str\n         \"\"\"\n         if self.head.next == self.tail:\n             return \"\"\n         x = self.count_key_map[self.head.next.count].pop()\n         self.count_key_map[self.head.next.count].add(x)\n         return x\n         \n     #insert 'node' after prev_node O(1) \n     def insert(self, prev_node, node):\n         node.next = prev_node.next\n         node.prev = prev_node\n         \n         node.next.prev = node\n         node.prev.next = node\n         \n     def delete(self, node):\n         node.next.prev = node.prev\n         node.prev.next = node.next", "\n class Node:\n     def __init__(self, cnt):\n         self.count = cnt\n         self.prev = None\n         self.next = None\n \n \n class AllOne(object):\n \n     def __init__(self):\n         \"\"\"\n         Initialize your data structure here.\n         \"\"\"\n         #Key:count, Value:set of key who has been incremented by 'count' time\n         self.count_key_map = {}\n         #Key:key, Value: the number of counts of this key\n         self.key_count_map = {}\n         #Key: the count, Value: the node\n         self.count_node_map = {}\n         \n         #initialize the linkedlist with dummy node\n         self.head = Node(0)\n         self.tail = Node(float('inf'))\n         self.head.next = self.tail\n         self.tail.prev = self.head\n         \n         self.count_node_map[0] = self.head\n         self.count_node_map[float('inf')] = self.tail\n \n     def inc(self, key):\n         \"\"\"\n         Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n         :type key: str\n         :rtype: void\n         \"\"\"\n         if key not in self.key_count_map:\n             self.key_count_map[key]=0\n         \n         \n         prev_count=self.key_count_map[key]\n         prev_node=self.count_node_map[prev_count]\n         \n         self.key_count_map[key]+=1\n         \n         if prev_node.next.count!=self.key_count_map[key]:\n             new_node=Node(self.key_count_map[key])\n             self.insert(prev_node,new_node)\n             self.count_key_map[self.key_count_map[key]]=set()\n             self.count_node_map[self.key_count_map[key]]=new_node\n         \n         self.count_key_map[self.key_count_map[key]].add(key)\n         \n         if prev_count!=0:\n            \n            self.count_key_map[prev_count].remove(key)\n            if len(self.count_key_map[prev_count])==0:\n                self.count_node_map.pop(prev_count)\n                self.count_key_map.pop(prev_count)\n                self.delete(prev_node)\n                \n     \n         \n \n     def dec(self, key):\n         \"\"\"\n         Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\n         :type key: str\n         :rtype: void\n         \"\"\"\n         if key not in self.key_count_map:\n             return \n         prev_count=self.key_count_map[key]\n         prev_node=self.count_node_map[prev_count]\n         \n         self.key_count_map[key]-=1\n         \n         \n         if self.key_count_map[key]==0:\n            self.key_count_map.pop(key)\n         else:\n             if prev_node.prev.count!=self.key_count_map[key]:\n                 new_node=Node(self.key_count_map[key])\n                 self.insert(prev_node.prev,new_node)\n                 self.count_key_map[self.key_count_map[key]]=set()\n                 self.count_node_map[self.key_count_map[key]]=new_node\n         \n             self.count_key_map[self.key_count_map[key]].add(key) \n             \n             \n         self.count_key_map[prev_count].remove(key)\n         if len(self.count_key_map[prev_count])==0:\n                self.delete(prev_node)\n                self.count_node_map.pop(prev_count)\n                self.count_key_map.pop(prev_count)\n             \n     def getMaxKey(self):\n         \"\"\"\n         Returns one of the keys with maximal value.\n         :rtype: str\n         \"\"\"\n         if self.head.next == self.tail:\n             return \"\"\n         x = self.count_key_map[self.tail.prev.count].pop()\n         self.count_key_map[self.tail.prev.count].add(x)\n         return x\n         \n \n     def getMinKey(self):\n         \"\"\"\n         Returns one of the keys with Minimal value.\n         :rtype: str\n         \"\"\"\n         if self.head.next == self.tail:\n             return \"\"\n         x = self.count_key_map[self.head.next.count].pop()\n         self.count_key_map[self.head.next.count].add(x)\n         return x\n         \n     #insert 'node' after prev_node O(1) \n     def insert(self, prev_node, node):\n         node.next = prev_node.next\n         node.prev = prev_node\n         \n         node.next.prev = node\n         node.prev.next = node\n         \n     def delete(self, node):\n         node.next.prev = node.prev\n         node.prev.next = node.next"]
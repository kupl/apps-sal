["import sys\ninput = sys.stdin.readline\n\ndef main():\n  n, m = map(int, input().split())\n  LR = [list(map(int, input().split())) for _ in range(n)]\n  \n  BIT = [0]*(m+2)\n  def add(i, a):\n    while i <= m+1:\n      BIT[i] += a\n      i += i&(-i)\n  def bit_sum(i):\n    res = 0\n    while i > 0:\n      res += BIT[i]\n      i -= i&(-i)\n    return res\n  \n  for l, r in LR:\n    add(l, 1)\n    add(r+1, -1)\n  \n  S = sorted([(r-l+1, l, r) for l, r in LR])\n  cnt = 0\n  L = []\n  for i in range(m, 0, -1):\n    while S and S[-1][0] == i:\n      c, l, r = S.pop()\n      cnt += 1\n      add(l, -1)\n      add(r+1, 1)\n    res = cnt\n    for j in range(0, m+1, i):\n      res += bit_sum(j)\n    L.append(res)\n  print(*L[::-1], sep=\"\\n\")\n\ndef __starting_point():\n  main()\n__starting_point()", "from collections import defaultdict\nN, M = list(map(int, input().split()))\nsection = [list(map(int, input().split())) for i in range(N)]\n\n# \u533a\u9593\u306e\u5927\u304d\u3055\u3054\u3068\u306b\u5206\u985e\nD = defaultdict(list)\nfor sec in section:\n    D[sec[1] - sec[0] + 1].append(sec)\n\n\nclass BinaryIndexedTree:\n    def __init__(self, n):\n        self.size = n\n        self.bit = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.bit[i] += x\n            i += (i & -i)\n\n    def reset(self):\n        self.bit = [0] * (self.size + 1)\n\n\nBIT = BinaryIndexedTree(M)\n\nfor d in range(1, M + 1):\n    for l, r in D[d - 1]:\n        N -= 1\n        BIT.add(l, 1)\n        BIT.add(r + 1, -1)\n\n    ans = N\n    for i in range(d, M + 1, d):\n        ans += BIT.sum(i)\n    print(ans)\n", "\ndef bitadd(a,w,bit): #a\u306bw\u3092\u52a0\u3048\u308b(1-origin)\n \n    x = a\n    while x <= (len(bit)-1):\n        bit[x] += w\n        x += x & (-1 * x)\n \ndef bitsum(x,bit): #ind 1\uff5ea\u307e\u3067\u306e\u548c\u3092\u6c42\u3081\u308b\n   \n    ret = 0\n    while x:\n        ret += bit[x]\n        x -= x & (-1 * x)\n    return ret\n\n\n#\u533a\u9593\u66f4\u65b0BIT(BIT\u30922\u3064\u7528\u610f\u3057\u3001BIT\u306e\u9577\u3055\u3092N+2\u3067\u521d\u671f\u5316\u3057\u3066\u304a\u304f\u3079\u3057)\ndef bitaddR(l,r,w,bit1,bit2): #\u534a\u958b\u533a\u9593[l,r)\u306bw\u3092\u52a0\u3048\u308b\n\n    bitadd(l,-1*w*l,bit1)\n    bitadd(r,w*r,bit1)\n    bitadd(l,w,bit2)\n    bitadd(r,-1*w,bit2)\n\ndef bitsumR(r,bit1,bit2): #\u534a\u958b\u533a\u9593[1,r)\u306e\u533a\u9593\u548c\n\n    return bitsum(r,bit1) + r * bitsum(r,bit2)\n\n\nN,M = list(map(int,input().split()))\n\nBIT = [0] * (M+1)\ndic = {}\nfor i in range(N):\n    l,r = list(map(int,input().split()))\n    if r-l+1 not in dic:\n        dic[r-l+1] = []\n    dic[r-l+1].append([l,r])\n\nind = 0\nns = N\nans = []\nfor d in range(M):\n\n    d += 1\n\n    if d in dic:\n        for L,R in dic[d]:\n\n            bitadd(L , 1 ,BIT)\n            bitadd(R+1 , -1 , BIT)\n            ns -= 1\n\n    nm = 0\n    for i in range(d,M+1,d):\n        \n        nm += bitsum(i,BIT)\n    ans.append(nm+ns)\n\nprint((\"\\n\".join(map(str,ans))))\n", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\nN,M = map(int,input().split())\nd_to_LR = defaultdict(list)\nfor _ in range(N):\n    L,R = map(int,input().split())\n    d_to_LR[R-L+1].append((L,R))\n\ndef BIT_update(tree,x,value):\n    while x <= M:\n        tree[x] += value\n        x += x & (-x)\n\ndef BIT_sum(tree,x):\n    s = 0\n    while x:\n        s += tree[x]\n        x -= x & (-x)\n    return s\n\ntree = [0] * (M+1) # BIT \u3067\u7ba1\u7406\u3002\u5de6\u306b\u3042\u308bL\u306e\u500b\u6570 - (R+1)\u306e\u500b\u6570 \u2192 \u3044\u304f\u3064\u306e[L,R]\u306b\u5165\u3063\u3066\u3044\u308b\u304b\nlong = N # \u9577\u3059\u304e\u3066\u81ea\u52d5\u56de\u53ce\u3067\u304d\u308b\nanswer = [0] * (M+1)\n\nfor m in range(1,M+1):\n    for L,R in d_to_LR[m]:\n        BIT_update(tree,L,1)\n        BIT_update(tree,R+1,-1)\n        long -= 1\n    answer[m] = sum(BIT_sum(tree,x) for x in range(m,M+1,m)) + long\n\nprint('\\n'.join(map(str, answer[1:])))", "class BIT:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def add(self, k, x):\n        while k <= self.n:\n            self.bit[k] += x\n            k += k & -k\n\n    def sum(self, k):\n        s = 0\n        while k > 0:\n            s += self.bit[k]\n            k -= k & -k\n        return s\n\n\nn, m = list(map(int, input().split()))\nst = BIT(m)\nL, R = [], []\nd = [[] for i in range(m + 1)]\nfor i in range(n):\n    l, r = list(map(int, input().split()))\n    L.append(l)\n    R.append(r)\n    d[r - l + 1].append(i)\n\nnum = n\nfor i in range(1, m + 1):\n    num -= len(d[i])\n    for j in d[i]:\n        st.add(L[j], 1)\n        st.add(R[j] + 1, -1)\n\n    tmp = 0\n    k = i\n    for j in range(k, m + 1, i):\n        tmp += st.sum(j)\n\n    print((num + tmp))\n", "N,M=list(map(int,input().split()))\nsection=[[] for i in range(M+1)]\nfor i in range(N):\n  l,r=list(map(int,input().split()))\n  section[r-l+1].append((l,r))\n\ndef add(B,a,s):\n    x=a\n    while x<=len(B)-1:\n        B[x]+=s\n        x+=x&(-x)\n        \ndef sums(B,a):\n    x=a\n    S=0\n    while x!=0:\n        S+=B[x]\n        x-=x&(-x)\n    return S\n\nLine=[0]*(M+2)\nK=N\nfor d in range(1,M+1):\n  for l,r in section[d]:\n    add(Line,l,1)\n    add(Line,r+1,-1)\n    K-=1\n  ans=K\n  for s in range(M//d+1):\n    ans+=sums(Line,s*d)\n  print(ans)\n\n\n\n", "class Bit:\n    def __init__(self, n):\n        \"\"\"\n        :param n: number of elements\n        \"\"\"\n        self.n = n\n        self.tree = [0]*(n+1)\n        self.depth = n.bit_length() - 1\n\n    def sum(self, i):\n        \"\"\" return summation of elements in [0,i) \"\"\"\n        s = 0\n        i -= 1\n        while i >= 0:\n            s += self.tree[i]\n            i = (i & (i + 1) )- 1\n        return s\n\n    def build(self, array):\n        \"\"\" bulid BIT from array \"\"\"\n        for i, a in enumerate(array):\n            self.add(i, a)\n\n    def add(self, i, x):\n        \"\"\" add x to i-th element \"\"\"\n        while i < self.n:\n            self.tree[i] += x\n            i |= i + 1\n\n    def get(self, i, j):\n        \"\"\" return summation of elements in [i,j) \"\"\"\n        if i == 0:\n            return self.sum(j)\n        return self.sum(j) - self.sum(i)\n\n    def lower_bound(self, x, equal=False):\n        \"\"\"\n        return tuple = (return maximum i s.t. a0+a1+...+ai < x (if not existing, -1 ) , a0+a1+...+ai )\n        if one wants to include equal (i.e., a0+a1+...+ai <= x), please set equal = True\n        (Cation) We must assume that A_i>=0\n        \"\"\"\n        sum_ = 0\n        pos = -1    # 1-indexed \u306e\u6642\u306f pos = 0\n        if not equal:\n            for i in range(self.depth, -1, -1):\n                k = pos + (1 << i)\n                if k < self.n and sum_ + self.tree[k] < x:  # 1-indexed \u306e\u6642\u306f k <= self.n\n                    sum_ += self.tree[k]\n                    pos += 1 << i\n        if equal:\n            for i in range(self.depth, -1, -1):\n                k = pos + (1 << i)\n                if k < self.n and sum_ + self.tree[k] <= x: # 1-indexed \u306e\u6642\u306f k <= self.n\n                    sum_ += self.tree[k]\n                    pos += 1 << i\n        return pos, sum_\n\n    def __getitem__(self, i):\n        \"\"\" [a0, a1, a2, ...] \"\"\"\n        return self.get(i, i+1)\n\n    def __iter__(self):\n        \"\"\" [a0, a1, a2, ...] \"\"\"\n        for i in range(self.n):\n            yield self.get(i, i+1)\n\n    def __str__(self):\n        text1 = \" \".join([\"element:            \"] + list(map(str, self)))\n        text2 = \" \".join([\"cumsum(1-indexed):  \"] + list(str(self.sum(i)) for i in range(1, self.n + 1)))\n        return \"\\n\".join((text1, text2))\n\nclass BitImos:\n    def __init__(self, n):\n        self.n = n\n        self.p = Bit(self.n + 1)\n        self.q = Bit(self.n + 1)\n\n    def add(self, s, t, x):\n        \"\"\" add x to a close-interval [s,t]\"\"\"\n        t += 1\n        self.p.add(s, -x * s)\n        self.p.add(t, x * t)\n        self.q.add(s, x)\n        self.q.add(t, -x)\n\n    def sum(self, s, t):\n        \"\"\" return summation of elements in [s,t) \"\"\"\n        return self.p.sum(t) + self.q.sum(t) * t - self.p.sum(s) - self.q.sum(s) * s\n\n    def __getitem__(self, s):\n        \"\"\" return s-th element of array (not sum-array) \"\"\"\n        return self.q.sum(s+1)\n\n    def __iter__(self):\n        \"\"\" max(self) returns what we obtain by the Imos method\"\"\"\n        for t in range(self.n):\n            yield self.q.sum(t+1)\n\n    def __str__(self):\n        text1 = \" \".join([\"element: \"] + list(map(str, self)))\n        return text1\n\n#############################################################\nimport sys\ninput = sys.stdin.readline\n\nN,M=map(int, input().split())\ndata=[[] for _ in range(M+1)]\nfor _ in range(N):\n    l,r=map(int, input().split())\n    data[r-l+1].append((l,r))\nB=BitImos(M+1)\nres=[0]*M\ncnt=N\nfor d in range(1,M+1):\n    for l,r in data[d]:\n        B.add(l,r,1)\n        cnt-=1\n    res[d-1]+=cnt\n    for i in range(0,M+1,d):\n        res[d-1]+=B[i]\nprint(*res,sep=\"\\n\")", "import sys\ninput = sys.stdin.readline\nclass BIT():\n    def __init__(self, number):\n        self.n = number\n        self.list = [0] * (number + 1)\n\n    def add(self, i, x):  # ith added x  1indexed\n        while i <= self.n:\n            self.list[i] += x\n            i += i & -i\n\n    def search(self, i):  # 1-i sum\n        s = 0\n        while i > 0:\n            s += self.list[i]\n            i -= i & -i\n        return s\n\n    def suma(self, i, j):  # i,i+1,..j sum\n        return self.search(j) - self.search(i - 1)\n\nN,M=list(map(int,input().split()))\nL=[[] for i in range(M+1)]\nbit=BIT(M+1)\nfor i in range(N):\n    l,r=list(map(int,input().split()))\n    L[r-l+1].append((l,r))\nans=N\nfor i in range(1,M+1):\n    num=0\n    for l,r in L[i]:\n        ans-=1\n        bit.add(l,1)\n        bit.add(r+1,-1)\n    num+=ans\n    for j in range(i,M+1,i):\n        num+=bit.search(j)\n    print(num)\n", "import sys\nfrom operator import itemgetter\n\nmod = 10**9 + 7\ninf = 1<<30\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    sects = []\n\n    for i in range(N):\n        li, ri = map(int, sys.stdin.readline().split())\n\n        sects.append((li, ri + 1, ri - li + 1))\n\n    sects.sort(key=itemgetter(2))\n\n    print(N)\n\n    left = 0\n    ft = FenwickTree(M + 1)\n\n    for d in range(2, M + 1):\n        for j in range(left, N):\n            if sects[j][2] >= d:\n                left = j\n                break\n            else:\n                ft.add(sects[j][0], 1)\n                ft.add(sects[j][1], -1)\n        else:\n            left = N\n\n        ans = N - left + sum(ft.get_sum(j) for j in range(d, M + 1, d))\n\n        print(ans)\n\n\nclass FenwickTree:\n    def __init__(self, size):\n        self.n = size\n        self.data = [0]*(size + 1)\n\n    def add(self, i, x):\n        while i <= self.n:\n            self.data[i] += x\n            i += i & (-i)\n\n    def get_sum(self, r):\n        res = 0\n\n        while r > 0:\n            res += self.data[r]\n            r -= r & (-r)\n\n        return res\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\ndef input():\n    return sys.stdin.readline()[:-1]\n\nN, M = list(map(int, input().split()))\nL = []\nfor i in range(N):\n    l, r = list(map(int, input().split()))\n    L.append((r - l + 1, l, r + 1))\nL.sort()\n\n\nclass Bit:\n    \"\"\"\n    0-indexed\n    # \u4f7f\u7528\u4f8b\n    bit = Bit(10)  # \u8981\u7d20\u6570\n    bit.add(2, 10)\n    print(bit.sum(5))  # 10\n    \"\"\"\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        # [0, i) \u306e\u8981\u7d20\u306e\u7dcf\u548c\u3092\u8fd4\u3059\n        if not (0 <= i <= self.size): raise ValueError(\"error!\")\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        if not (0 <= i < self.size): raise ValueError(\"error!\")\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n\nclass BitImos:\n    \"\"\"\n    \u30fb\u7bc4\u56f2\u3059\u3079\u3066\u306e\u8981\u7d20\u306b\u52a0\u7b97\n    \u30fb\u3072\u3068\u3064\u306e\u5024\u3092\u53d6\u5f97\n    \u306e2\u7a2e\u985e\u306e\u30af\u30a8\u30ea\u3092O(logn)\u3067\u51e6\u7406\n    \"\"\"\n\n    def __init__(self, n):\n        self.bit = Bit(n + 1)\n\n    def add(self, s, t, x):\n        # [s, t)\u306bx\u3092\u52a0\u7b97\n        self.bit.add(s, x)\n        self.bit.add(t, -x)\n\n    def get(self, i):\n        return self[i]\n\n    def __getitem__(self, key):\n        # \u4f4d\u7f6ei\u306e\u5024\u3092\u53d6\u5f97\n        return self.bit.sum(key + 1)\n\n\nimos = BitImos(M + 1)\nil = 0\na = N\nfor i in range(1, M + 1):\n    while il < N:\n        ra, l, r = L[il]\n        if i < ra:\n            break\n        il += 1\n        a -= 1\n        imos.add(l, r, 1)\n    ans = 0\n    for j in range(i, M + 1, i):\n        ans += imos[j]\n\n    print((ans + a))\n", "# Binary Indexed Tree (Fenwick Tree)\n# 1-indexed\nclass BIT:\n  def __init__(self, n):\n    self.n = n\n    self.data = [0]*(n+1)\n    self.el = [0]*(n+1)\n  # sum(ary[:i])\n  def sum(self, i):\n    s = 0\n    while i > 0:\n      s += self.data[i]\n      i -= i & -i\n    return s\n  # ary[i]+=x\n  def add(self, i, x):\n    # assert i > 0\n    self.el[i] += x\n    while i <= self.n:\n      self.data[i] += x\n      i += i & -i\n  # sum(ary[i:j])\n  def get(self, i, j=None):\n    if j is None:\n      return self.el[i]\n    return self.sum(j) - self.sum(i)\n\n# \u533a\u9593\u52a0\u7b97\u53ef\u80fd\u306aBIT\u3002\u5185\u90e8\u7684\u306b1-indexed BIT\u3092\u4f7f\u3046\nclass BIT_Range():\n  def __init__(self,n):\n    self.n=n\n    self.bit0=BIT(n+1)\n    self.bit1=BIT(n+1)\n  # for i in range(l,r):ary[i]+=x\n  def add(self,l,r,x):\n    l+=1\n    self.bit0.add(l,-x*(l-1))\n    self.bit0.add(r+1,x*r)\n    self.bit1.add(l,x)\n    self.bit1.add(r+1,-x)\n  # sum(ary[:i])\n  def sum(self,i):\n    if i==0:return 0\n    #i-=1\n    return self.bit0.sum(i)+self.bit1.sum(i)*i\n  # ary[i]\n  def get(self,i):\n    return self.sum(i+1)-self.sum(i)\n  # sum(ary[i:j])\n  def get_range(self,i,j):\n    return self.sum(j)-self.sum(i)\n\ndef main1(n,m,lr):\n  lary=[[] for _ in range(m+1)]\n  for l,r in lr:\n    lary[r-l+1].append([l,r])\n  ret=[n]\n  bitr=BIT_Range(m+1)\n  cnt=0\n  for d in range(2,m+1):\n    for l,r in lary[d-1]:\n      cnt+=1\n      bitr.add(l,r+1,1)\n    tmp=n-cnt\n    dd=d\n    while dd<=m:\n      tmp+=bitr.get(dd)\n      dd+=d\n    ret.append(tmp)\n  return ret\n\ndef __starting_point():\n  n,m=map(int,input().split())\n  lr=[list(map(int,input().split())) for _ in range(n)]\n  print(*main1(n,m,lr),sep='\\n')\n\n__starting_point()", "class BIT(object):\n    def __init__(self, size):\n        self.size = size\n        self.bit = [0] * (self.size + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.bit[i] += x\n            i += i & -i\n\n    def __str__(self):\n        return str(self.bit)\n\nn, m = list(map(int,input().split()))\nlr = [[] for i in range(m + 1)]\nfor i in range(n):\n    l, r = list(map(int,input().split()))\n    lr[r - l + 1].append(l)\n\nbit = BIT(m + 1)\nt = 0\nfor d in range(1, m + 1):\n    for l in lr[d]:\n        #print(l, l + d)\n        bit.add(l, 1)\n        #print(bit.bit)\n        bit.add(l + d, -1)\n        #print(bit.bit)\n\n    t += len(lr[d])\n    ans = n - t\n\n    cur = 0\n    while cur <= m:\n        # bit\u306e0 ~ cur\u307e\u3067\u306e\u7dcf\u548c\u3092\u52a0\u7b97\n        ans += bit.sum(cur)\n        cur += d\n\n    print(ans)\n", "import sys\ndef input():\n    return sys.stdin.readline()[:-1]\nN, M = map(int, input().split())\nL = []\nfor i in range(N):\n    l, r = map(int, input().split())\n    L.append((r-l+1, l, r+1))\nL.sort()\n\n\nclass Bit:\n    \"\"\"\n    0-indexed\n    # \u4f7f\u7528\u4f8b\n    bit = Bit(10)  # \u8981\u7d20\u6570\n    bit.add(2, 10)\n    print(bit.sum(5))  # 10\n    \"\"\"\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0]*(n+1)\n\n    def sum(self, i):\n        s = 0\n        while i>0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n\nclass BitImos:\n    \"\"\"\n    \u30fb\u7bc4\u56f2\u3059\u3079\u3066\u306e\u8981\u7d20\u306b\u52a0\u7b97\n    \u30fb\u3072\u3068\u3064\u306e\u5024\u3092\u53d6\u5f97\n    \u306e2\u7a2e\u985e\u306e\u30af\u30a8\u30ea\u3092O(logn)\u3067\u51e6\u7406\n    \"\"\"\n    def __init__(self, n):\n        self.bit = Bit(n+1)\n\n    def add(self, s, t, x):\n        # [s, t)\u306bx\u3092\u52a0\u7b97\n        self.bit.add(s, x)\n        self.bit.add(t, -x)\n\n    def get(self, i):\n        return self[i]\n\n    def __getitem__(self, key):\n        # \u4f4d\u7f6ei\u306e\u5024\u3092\u53d6\u5f97\n        return self.bit.sum(key+1)\n\n\nimos = BitImos(M+1)\nil = 0\na = N\nA = [0]*M\nfor i in range(1, M+1):\n    while il<N:\n        ra, l, r = L[il]\n        if i < ra:\n            break\n        il+=1\n        a-=1\n        imos.add(l, r, 1)\n    ans = 0\n    for j in range(i, M+1, i):\n        ans += imos[j]\n\n    A[i-1] = ans + a\n\nprint(*A, sep=\"\\n\")\n", "from collections import defaultdict\ndef inpl(): return [int(i) for i in input().split()]\nclass BIT:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n \n    def sumi(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n \n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\nN, M = inpl()\nH = defaultdict(lambda: [])\nfor _ in range(N):\n    l, r = inpl()\n    H[r-l+1].append(l)\nQ = BIT(M+1)\nctr = N\nfor i in range(1,M+1):\n    ctr -= len(H[i]) \n    for j in H[i]:\n        Q.add(j, 1)\n        Q.add(j+i, -1)\n    ans = 0\n    for k in range(i,M+1,i):\n        ans += Q.sumi(k)\n    print(ctr + ans)", "from operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\n\nclass BIT:\n    \"\"\"\u533a\u9593\u52a0\u7b97\u3001\u4e00\u70b9\u53d6\u5f97\u30af\u30a8\u30ea\u3092\u305d\u308c\u305e\u308cO(logN)\u3067\u7b54\u3048\u308b\u30c7\u30fc\u30bf\u69cb\u9020\"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def _add(self, i, val):\n        while i > 0:\n            self.bit[i] += val\n            i -= i & -i\n\n    def get_val(self, i):\n        \"\"\"i\u756a\u76ee\u306e\u5024\u3092\u6c42\u3081\u308b\"\"\"\n        i = i + 1\n        s = 0\n        while i <= self.n:\n            s += self.bit[i]\n            i += i & -i\n        return s\n\n    def add(self, l, r, val):\n        \"\"\"\u533a\u9593[l, r)\u306bval\u3092\u52a0\u3048\u308b\"\"\"\n        self._add(r, val)\n        self._add(l, -val)\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(n)]\n\nfor i in range(n):\n    info[i] = info[i][0], info[i][1], info[i][1] - info[i][0] + 1\ninfo = sorted(info, key=itemgetter(2))\n\nbit = BIT(m + 1)\nl_info = 0\nans = n\nres = [0] * m\nfor d in range(1, m + 1):\n    while True:\n        if l_info < n and info[l_info][2] < d:\n            l, r, _ = info[l_info]\n            bit.add(l, r + 1, 1)\n            l_info += 1\n            ans -= 1\n        else:\n            break\n    cnt = ans\n    for i in range(0, m + 1, d):\n        cnt += bit.get_val(i)\n    res[d - 1] = cnt\n\nprint('\\n'.join(map(str, res)), end='\\n')\n", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    def makeBIT(numEle):\n        numPow2 = 2 ** (numEle-1).bit_length()\n        data = [0] * (numPow2+1)\n        return data, numPow2\n    def addValue(iA, A):\n        iB = iA + 1\n        while iB > 0:\n            data[iB] += A\n            iB -= iB & -iB\n    def getValue(iA):\n        iB = iA + 1\n        ans = 0\n        while iB <= numPow2:\n            ans += data[iB]\n            iB += iB & -iB\n        return ans\n    def addRangeValue(iFr, iTo, A):\n        addValue(iTo, A)\n        if iFr > 0:\n            addValue(iFr-1, -A)\n\n    N, M = list(map(int, input().split()))\n    LRss = [[] for _ in range(M+1)]\n    for _ in range(N):\n        L, R = list(map(int, input().split()))\n        LRss[R-L+1].append((L, R))\n\n    data, numPow2 = makeBIT(M+1)\n\n    anss = []\n    numOK = N\n    for d in range(1, M+1):\n        ans = numOK\n        for i in range(d, M+1, d):\n            ans += getValue(i)\n        anss.append(ans)\n        numOK -= len(LRss[d])\n        for L, R in LRss[d]:\n            addRangeValue(L, R, 1)\n\n    print(('\\n'.join(map(str, anss))))\n\n\nsolve()\n", "import math\nimport itertools\nimport heapq\nfrom sys import stdin, stdout, setrecursionlimit\nfrom bisect import bisect, bisect_left, bisect_right\nfrom collections import defaultdict, deque\n \n \n# d = defaultdict(lambda: 0)\n# setrecursionlimit(10**7)\n# inf = float(\"inf\")\n \n \n##### stdin ####\ndef LM(t, r): return list(map(t, r))\ndef R(): return stdin.readline()\ndef RS(): return R().split()\ndef I(): return int(R())\ndef F(): return float(R())\ndef LI(): return LM(int,RS())\ndef LF(): return LM(float,RS())\ndef ONE_SL(): return list(input())\ndef ONE_IL(): return LM(int, ONE_SL())\ndef ALL_I(): return map(int, stdin)\ndef ALL_IL(): return LM(int,stdin)\n \n##### tools #####\ndef ap(f): return f.append\ndef pll(li): print('\\n'.join(LM(str,li)))\ndef pljoin(li, s): print(s.join(li))\n \n \n \n##### main #####\n \nclass BIT(object):\n \n\tdef __init__(self,l):\n\t\tself.size = l\n\t\tself.bit = [0]* (self.size+1)\n \n\tdef sum(self, i):\n\t\ts = 0\n\t\twhile i > 0:\n\t\t\ts += self.bit[i]\n\t\t\ti -= i & -i\n\t\treturn s\n \n\tdef add(self, i, x):\n\t\twhile i < self.size:\n\t\t\tself.bit[i] += x\n\t\t\ti += i & -i\n \n\tdef __str__(self):\n\t\treturn str(self.bit)\n \n \ndef main():\n\tN,M = LI()\n \n\tbit = BIT(M+2)\n\tL = []\n\tR = []\n\tb = [[] for i in range(M+1)]\n \n \n\tfor i in range(N):\n\t\tl,r = LI()\n\t\tL.append(l); R.append(r)\n\t\tb[r-l +1].append(i)\n \n \n\tgone = 0\n\tfor d in range(1, M+1):\n\t\tfor i in b[d]:\n\t\t\tgone+=1\n\t\t\tbit.add(L[i], 1)\n\t\t\tbit.add(R[i]+1, -1)\n \n \n\t\tans = N-gone\n \n\t\tfor m in range(d, M+1, d):\n \n\t\t\tans += bit.sum(m)\n\t\tprint(ans)\n \n \n \n \ndef __starting_point():\n\tmain()\n__starting_point()", "from bisect import bisect\nfrom operator import itemgetter\n\nimport sys\ninput = sys.stdin.readline\n\ndef inpl(): return list(map(int, input().split()))\n\n\nclass BIT:\n    def __init__(self, N):\n        self.size = 2 ** (int.bit_length(N)+1)\n        self.tree = [0]*(self.size + 1)\n\n    def sum(self, i):\n        res = 0\n        while i:\n            res += self.tree[i]\n            i -= (i & -(i))\n        return res\n\n    def add(self, i, x):\n        if i == 0:\n            return\n        while i <= self.size:\n            self.tree[i] += x\n            i += (i & -(i))\n\n\nclass RABIT():\n    # range add BIT\n    def __init__(self, N):\n        self.bit0 = BIT(N)\n        self.bit1 = BIT(N)\n\n    def sum(self, i):\n        return i*self.bit1.sum(i) + self.bit0.sum(i)\n\n    def add_range(self, l, r, x):\n        self.bit0.add(l, -x*(l-1))\n        self.bit1.add(l, x)\n        self.bit0.add(r+1, x*r)\n        self.bit1.add(r+1, -x)\n\n    def get_range(self, l, r):\n        return self.sum(r) - self.sum(l-1)\n\n\nN, M = inpl()\nR, L, S = [], [], []\nQ = []\nfor _ in range(N):\n    l, r = inpl()\n    Q.append((l, r, (r-l+1)))\n\nQ = sorted(Q, key=itemgetter(2), reverse=True)\nrabit = RABIT(M+1)\n\nLmin = M\nRmax = 0\nfor i in range(1, M+1):\n    while Q and Q[-1][2] < i:\n        l, r, _ = Q.pop()\n        rabit.add_range(l, r, 1)\n        Lmin = min(Lmin, l)\n        Rmax = max(Rmax, r)\n    ans = len(Q)\n    for j in range(-(-Lmin//i) * i, Rmax+1, i):\n        ans += rabit.get_range(j, j)\n    print(ans)\n", "\"\"\"\nBIT\n\u533a\u9593[L,R]\u306bx\u3092\u52a0\u3048\u308b\u3002\n\u5ea7\u6a19X\u3067\u306e\u5024\u3092\u6c42\u3081\u308b\u3002\n\"\"\"\nimport sys\ninput=sys.stdin.readline\n\ndef bit_add(i,x):\n    while i<=M:\n        tree[i]+=x\n        i+=i&(-i)\n\ndef bit_sum(i):\n    s=0\n    while i>0:\n        s+=tree[i]\n        i-=i&(-i)\n    return s\n\nN,M=map(int,input().split())\n\ndata=[]\nfor i in range(N):\n    l,r=map(int,input().split())\n    data.append([r-l, l, r])\ndata.sort()\n\nk=0\ntree=[0]*(M+1)\nfor d in range(1,M+1):\n    \n    #\u9593\u9694\u306e\u9577\u3055\u304cd\u4ee5\u4e0b\u306e\u533a\u9593\u3060\u3051\u8003\u3048\u308c\u3070\u826f\u3044\u3002\n    while k<N and data[k][0]<d:\n        bit_add(data[k][1],1)\n        bit_add(data[k][2]+1,-1)\n        k+=1\n    \n    ans=0\n    for j in range(1,M//d+1):\n        ans+=bit_sum(d*j)\n    \n    print(ans+N-k)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**15\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass BIT():\n    def __init__(self, n):\n        i = 1\n        while 2**i <= n:\n            i += 1\n        self.H = i\n        self.N = 2**i\n        self.A = [0] * self.N\n\n    def find(self, i):\n        r = 0\n        while i:\n            r += self.A[i]\n            i -= i & (i-1) ^ i\n        return r\n\n    def update(self, i, x):\n        while i < self.N:\n            self.A[i] += x\n            i += i & (i-1) ^ i\n\n    def query(self, a, b):\n        return self.find(b-1) - self.find(a-1)\n\ndef main():\n    n,m = LI()\n    d = collections.defaultdict(list)\n    for _ in range(n):\n        l,r = LI()\n        d[r-l+1].append((l,r))\n    r = [n]\n    bit = BIT(m+3)\n    c = n\n    for i in range(2,m+1):\n        for a,b in d[i-1]:\n            c -= 1\n            bit.update(a,1)\n            bit.update(b+1,-1)\n        t = c\n        for j in range(i,m+1,i):\n            t += bit.find(j)\n        r.append(t)\n\n    return '\\n'.join(map(str,r))\n\n\nprint(main())\n\n\n", "class lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n    def set(self,p,x):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n    def get(self,p):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n    def prod(self,l,r):\n        assert 0<=l and l<=r and r<=self.n\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n    def all_prod(self):return self.d[1]\n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n    def apply(self,l,r,f):\n        assert 0<=l and l<=r and r<=self.n\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n    def max_right(self,l,g):\n        assert 0<=l and l<=self.n\n        assert g(self.e)\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(i%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n    def min_left(self,r,g):\n        assert (0<=r and r<=self.n)\n        assert g(self.e)\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\nN,M=list(map(int,input().split()))\nseq=[]\nfor i in range(N):\n    l,r=list(map(int,input().split()))\n    seq.append((l,r+1))\nseq.sort(key=lambda x:x[1]-x[0])\nans=[0 for i in range(M+1)]\nadd=lambda x,y:x+y\nINF=10**9\nG=lazy_segtree([0 for i in range(M+1)],max,-INF,add,add,0)\nstack=seq[::-1]\nfor d in range(1,M+1):\n    while(len(stack)>0 and stack[-1][1]-stack[-1][0]<d):\n        l,r=stack[-1]\n        G.apply(l,r,1)\n        stack.pop()\n    ans[d]+=len(stack)\n    for i in range(0,M+1,d):\n        ans[d]+=G.get(i)\nfor i in range(1,M+1):\n    print((ans[i]))\n", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\n# \u5185\u90e8\u30671-indexed\u306b\u5909\u3048\u308b\u306e\u3067\u5165\u529b\u306f0-indexed\u3067\u3088\u3044\n# i\u9805\u76ee\u307e\u3067\u306e\u548c\uff08i\u542b\u3080\uff09\nclass BitSum:\n    def __init__(self, n):\n        self.n = n + 3\n        self.table = [0] * (self.n + 1)\n\n    def add(self, i, x):\n        i += 1\n        while i <= self.n:\n            self.table[i] += x\n            i += i & -i\n\n    def sum(self, i):\n        i += 1\n        res = 0\n        while i > 0:\n            res += self.table[i]\n            i -= i & -i\n        return res\n\ndef main():\n    n,m=MI()\n    dlr=[]\n    for _ in range(n):\n        l,r=MI()\n        dlr.append((r-l+1,l,r+1))\n    dlr.sort()\n    bit=BitSum(m+1)\n    i=0\n    for k in range(1,m+1):\n        while i<n and dlr[i][0]<=k:\n            d,l,r=dlr[i]\n            bit.add(l,1)\n            bit.add(r,-1)\n            i+=1\n        print(n-i+sum(bit.sum(a) for a in range(k,m+1,k)))\n\nmain()", "import sys\ninput = sys.stdin.readline\nN, M = map(int, input().split())\na = []\nfor i in range(N):\n  l, r = map(int, input().split())\n  a.append((l, r))\na.sort(key = lambda x: x[0] - x[1])\n#print(a)\nclass BIT:\n  def __init__(self, n):\n    self.n = n\n    self.data = [0] * (n + 1)\n    self.el = [0] * (n + 1)\n  def sum(self, i):\n    s = 0\n    while i > 0:\n      s += self.data[i]\n      i -= i & -i\n    return s\n  def add(self, i, x):\n    self.el[i] += x\n    while i <= self.n:\n      self.data[i] += x\n      i += i & -i\n  def get(self, i, j = None):\n    if j is None:\n      return self.el[i]\n    return self.sum(j) - self.sum(i)\n  def lowerbound(self, s):\n    x = 0\n    y = 0\n    for i in range(self.n.bit_length(), -1, -1):\n      k = x + (1 << i)\n      if k <= self.n and (y + self.data[k] < s):\n        y += self.data[k]\n        x += 1 << i\n    return x + 1\nfwk = BIT(M + 1)\nfor l in range(1, M + 1):\n  res = len(a)\n  for x in range(l, M + 1, l): res += fwk.sum(x)\n  while len(a):\n    if a[-1][1] - a[-1][0] <= l:\n      fwk.add(a[-1][0], 1)\n      fwk.add(a.pop()[1] + 1, -1)\n    else: break\n  print(res)", "# instead of AVLTree\nclass BITbisect():\n    def __init__(self, max):\n        self.max = max\n        self.data = [0]*(self.max+1)\n    \n    # 0\u304b\u3089i\u307e\u3067\u306e\u533a\u9593\u548c\n    # \u7acb\u3063\u3066\u3044\u308b\u30d3\u30c3\u30c8\u3092\u4e0b\u304b\u3089\u51e6\u7406\n    def query_sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= i & -i\n        return s\n\n    # i\u756a\u76ee\u306e\u8981\u7d20\u306bx\u3092\u8db3\u3059\n    # \u8986\u3063\u3066\u308b\u533a\u9593\u3059\u3079\u3066\u306b\u8db3\u3059\n    def add(self, i, x):\n        while i <= self.max:\n            self.data[i] += x\n            i += i & -i\n\n    def insert(self, x):\n        self.add(x, 1)\n\n    def delete(self, x):\n        self.add(x, -1)\n\n    def count(self, x):\n        return self.query_sum(x) - self.query_sum(x-1)\n    \n    def length(self):\n        return self.query_sum(self.max)\n    \n    # \u4e0b\u304b\u3089c\u756a\u76ee(0-indexed)\u306e\u6570\n    # O(log(N))\n    def search(self, c):\n        c += 1\n        s = 0\n        ind = 0\n        l = self.max.bit_length()\n        for i in reversed(range(l)):\n            if ind + (1<<i) <= self.max:\n                if s + self.data[ind+(1<<i)] < c:\n                    s += self.data[ind+(1<<i)]\n                    ind += (1<<i)\n        if ind == self.max:\n            return False\n        return ind + 1\n    \n    def bisect_right(self, x):\n        return self.query_sum(x)\n\n    def bisect_left(self, x):\n        if x == 1:\n            return 0\n        return self.query_sum(x-1)\n\n    # list\u307f\u305f\u3044\u306b\u8868\u793a\n    def display(self):\n        print('inside BIT:', end=' ')\n        for x in range(1, self.max+1):\n            if self.count(x):\n                c = self.count(x)\n                for _ in range(c):\n                    print(x, end=' ')\n        print()\n\nimport sys\ninput = sys.stdin.readline\n\nbase = 10**9\n\nN, M = map(int, input().split())\nPairs = [[] for _ in range(M+1)]\nfor _ in range(N):\n    a, b = map(int, input().split())\n    Pairs[b-a+1].append(a*base+b)\n\nansbit = BITbisect(M+1)\nusingbit = BITbisect(M+1)\n\nfor length, inPairs in enumerate(Pairs):\n    if length==0: continue\n\n    ansbit.add(1, len(inPairs))\n    ansbit.add(length+1, -len(inPairs))\n\n    rem = M//length\n    c = 0\n    for r in range(1, rem+1):\n        c += usingbit.query_sum(r*length)\n    ansbit.add(length, c)\n    ansbit.add(length+1, -c)\n\n    for p in inPairs:\n        l = p//base\n        r = p%base\n        usingbit.add(l, 1)\n        usingbit.add(r+1, -1)\n    \nfor n in range(1, M+1):\n    print(ansbit.query_sum(n))", "import sys\nfrom operator import itemgetter\n\nmod = 10**9 + 7\ninf = 1<<30\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    sects = []\n\n    for i in range(N):\n        li, ri = map(int, sys.stdin.readline().split())\n\n        sects.append((li - 1, ri, ri - li + 1))\n\n    sects.sort(key=itemgetter(2))\n\n    # print(sects)\n\n    print(N)\n\n    left = 0\n\n    ft = FenwickTree([0]*(M + 1))\n\n    for d in range(2, M + 1):\n        for j in range(left, N):\n            if sects[j][2] >= d:\n                left = j\n                break\n            else:\n                ft.add(sects[j][0], 1)\n                ft.add(sects[j][1], -1)\n        else:\n            left = N\n\n        # print('left', left)\n        # print(ft.data)\n\n        ans = N - left + sum(ft.get_sum(j) for j in range(d, M + 1, d))\n        \n        print(ans)\n\nclass FenwickTree:\n    def __init__(self, a):\n        self.n = len(a)\n        self.data = [0] + a[:]\n\n        for i in range(1, self.n + 1):\n            if i + (i & (-i)) <= self.n:\n                self.data[i + (i & (-i))] += self.data[i]\n\n    def add(self, i, x):\n        ''' a[i] += x '''\n        i += 1 # 0-oringn -> 1-origin\n\n        while i <= self.n:\n            self.data[i] += x\n            i += i & (-i)\n\n    def get_sum(self, r):\n        ''' sum[a_0 .. a_r) '''\n        res = 0\n\n        while r > 0:\n            res += self.data[r]\n            r -= r & (-r)\n\n        return res\n\n\ndef __starting_point():\n    solve()\n__starting_point()", "class BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nimport sys\n\ninput=sys.stdin.readline\n\nN,M=map(int,input().split())\nq={i:[] for i in range(1,M+1)}\nimos=[0 for i in range(M+2)]\nfor i in range(N):\n    l,r=map(int,input().split())\n    q[l].append(r)\n    imos[l]+=1\n    imos[r+1]-=1\nfor i in range(1,M+1):\n    imos[i]+=imos[i-1]\nres={i:imos[i*(M//i)] for i in range(1,M+1)}\n\nquery={i:[] for i in range(1,M+1)}\nfor i in range(1,M+1):\n    for j in range(1,M//i):\n        query[i*j].append(i*j+i)\n\nbit=BIT(M)\nfor i in range(1,M+1):\n    for r in q[i]:\n        bit.update(r,1)\n    for r in query[i]:\n        res[r-i]+=bit.query(r-1)-bit.query(i-1)\n\nfor i in range(1,M+1):\n    print(res[i])", "from collections import defaultdict\nN, M = list(map(int, input().split()))\nsection = [list(map(int, input().split())) for i in range(N)]\n\n# \u533a\u9593\u306e\u5927\u304d\u3055\u3054\u3068\u306b\u5206\u985e\nD = defaultdict(list)\nfor sec in section:\n    D[sec[1] - sec[0] + 1].append(sec)\n\n\nclass BinaryIndexedTree:\n    def __init__(self, n):\n        self.size = n\n        self.bit = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.bit[i] += x\n            i += (i & -i)\n\n    def reset(self):\n        self.bit = [0] * (self.size + 1)\n\n\nBIT = BinaryIndexedTree(M)\ncertainly = 0  # \u78ba\u5b9f\u306b\u901a\u308b\u3082\u306e\n\nfor d in range(1, M + 1):\n    for l, r in D[d - 1]:\n        certainly += 1\n        BIT.add(l, 1)\n        BIT.add(r + 1, -1)\n\n    ans = N - certainly\n    for i in range(d, M + 1, d):\n        ans += BIT.sum(i)\n    print(ans)\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n  n, m = map(int, input().split())\n  LR = [list(map(int, input().split())) for _ in range(n)]\n  \n  BIT = [0]*(m+2)\n  def add(i, a):\n    while i <= m+1:\n      BIT[i] += a\n      i += i&(-i)\n  def bit_sum(i):\n    res = 0\n    while i > 0:\n      res += BIT[i]\n      i -= i&(-i)\n    return res\n  \n  S = sorted([(r-l+1, l, r) for l, r in LR], reverse=True)\n  cnt = n\n  L = []\n  for i in range(1, m+1):\n    while S and S[-1][0] == i:\n      c, l, r = S.pop()\n      cnt -= 1\n      add(l, 1)\n      add(r+1, -1)\n    res = cnt\n    for j in range(0, m+1, i):\n      res += bit_sum(j)\n    L.append(res)\n  print(*L, sep=\"\\n\")\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\ndef input():\n    return sys.stdin.readline()[:-1]\n\nN, M = map(int, input().split())\nL = []\nfor i in range(N):\n    l, r = map(int, input().split())\n    L.append((r - l + 1, l, r + 1))\nL.sort()\n\n\nclass Bit:\n    \"\"\"\n    0-indexed\n    # \u4f7f\u7528\u4f8b\n    bit = Bit(10)  # \u8981\u7d20\u6570\n    bit.add(2, 10)\n    print(bit.sum(5))  # 10\n    \"\"\"\n\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        # [0, i) \u306e\u8981\u7d20\u306e\u7dcf\u548c\u3092\u8fd4\u3059\n        if not (0 <= i <= self.size): raise ValueError(\"error!\")\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        if not (0 <= i < self.size): raise ValueError(\"error!\")\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n\nclass BitImos:\n    \"\"\"\n    \u30fb\u7bc4\u56f2\u3059\u3079\u3066\u306e\u8981\u7d20\u306b\u52a0\u7b97\n    \u30fb\u3072\u3068\u3064\u306e\u5024\u3092\u53d6\u5f97\n    \u306e2\u7a2e\u985e\u306e\u30af\u30a8\u30ea\u3092O(logn)\u3067\u51e6\u7406\n    \"\"\"\n\n    def __init__(self, n):\n        self.bit = Bit(n + 1)\n\n    def add(self, s, t, x):\n        # [s, t)\u306bx\u3092\u52a0\u7b97\n        self.bit.add(s, x)\n        self.bit.add(t, -x)\n\n    def get(self, i):\n        return self[i]\n\n    def __getitem__(self, key):\n        # \u4f4d\u7f6ei\u306e\u5024\u3092\u53d6\u5f97\n        return self.bit.sum(key + 1)\n\n\nimos = BitImos(M + 1)\nil = 0\na = N\nA = [0] * M\nfor i in range(1, M + 1):\n    while il < N:\n        ra, l, r = L[il]\n        if i < ra:\n            break\n        il += 1\n        a -= 1\n        imos.add(l, r, 1)\n    ans = 0\n    for j in range(i, M + 1, i):\n        ans += imos[j]\n\n    A[i - 1] = ans + a\n\nprint(*A, sep=\"\\n\")\n", "import sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nclass BIT():#1-indexed\n\tdef __init__(self, size):\n\t\tself.table = [0 for _ in range(size+2)]\n\t\tself.size = size\n\n\tdef Sum(self, i):#1\u304b\u3089i\u307e\u3067\u306e\u548c\n\t\ts = 0\n\t\twhile i > 0:\n\t\t\ts += self.table[i]\n\t\t\ti -= (i & -i)\n\t\treturn s\n\n\tdef PointAdd(self, i, x):#\n\t\twhile i <= self.size:\n\t\t\tself.table[i] += x\n\t\t\ti += (i & -i)\n\t\treturn\n\n\tdef SegAdd(self, l, r, x):#l\u304b\u3089r\u306bx\u3092\u8db3\u3059\n\t\tself.PointAdd(l, x)\n\t\tself.PointAdd(r+1, -x)\n\t\treturn\n\nn, m = map(int, input().split())\ns = [list(map(int, input().split())) for _ in range(n)]\ns.sort(key=lambda x: x[1]-x[0])\nb = BIT(m)\n\ntoo_long = n #r-l+1\u3088\u308a\u3082\u5927\u304d\u3044\u533a\u9593\uff08\u5fc5\u305a\u8a2a\u308c\u308b\uff09\ncur = 0\nfor i in range(1, m+1):\n\twhile cur < n and s[cur][1]-s[cur][0]+1 < i:\n\t\ttoo_long -= 1\n\t\tb.SegAdd(s[cur][0], s[cur][1], 1)\n\t\tcur += 1\n\tans = too_long\n\tfor j in range(i, m+1, i):\n\t\tans += b.Sum(j)\n\tprint(ans)", "import sys\ninput = sys.stdin.readline\n\ndef main():\n  n, m = map(int, input().split())\n  S = [[] for _ in range(m+1)]\n  for _ in range(n):\n    l, r = map(int, input().split())\n    S[r-l+1].append((l, r))\n  \n  BIT = [0]*(m+2)\n  def add(i, a):\n    while i <= m+1:\n      BIT[i] += a\n      i += i&(-i)\n  def bit_sum(i):\n    res = 0\n    while i > 0:\n      res += BIT[i]\n      i -= i&(-i)\n    return res\n  cnt = n\n  for i in range(1, m+1):\n    for l, r in S[i]:\n      cnt -= 1\n      add(l, 1)\n      add(r+1, -1)\n    res = cnt\n    for j in range(0, m+1, i):\n      res += bit_sum(j)\n    print(res)\n\ndef __starting_point():\n  main()\n__starting_point()", "class BIT: #0-indexed\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0]*(n+1)\n        self.depth = n.bit_length()\n        self.n0 = 1<<self.depth\n#        self.element = [0]*(n+1)\n    def get_sum(self, i): #a_0 + ... + a_{i} #\u9589\u533a\u9593\n        s = 0; i += 1\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n    def query(self,l,r): #a_l + ... + a_r \u9589\u533a\u9593\n        return self.get_sum(r) - self.get_sum(l-1) \n    def add(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n        # self.element[i] += x\n    #def get(self,i): return element[i]        \n    def bisect_left(self,w):\n        #\u548c\u304c w \u4ee5\u4e0a\u306b\u306a\u308b\u6700\u5c0f\u306e index\n        #w \u304c\u5b58\u5728\u3057\u306a\u3044\u5834\u5408 self.size \u3092\u8fd4\u3059\n        if w <= 0: return 0\n        x,k = 0,self.n0\n        for _ in range(self.depth):\n            k >>= 1\n            if x+k <= self.size and self.tree[x+k] < w:\n                w -= self.tree[x+k]\n                x += k\n        return x\n    \n\n# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn,m,*lr = map(int,read().split())\n\nmp = iter(lr)\ndlr = [(r-l+1,l,r) for l,r in zip(mp,mp)]\ndlr.sort(reverse=True)\n\nans = [0]*(m+1)\n\nb = BIT(m+2)\n\nfor i in range(1,m+1):\n    while dlr and dlr[-1][0] < i:\n        d,l,r = dlr.pop()\n        b.add(l,1)\n        b.add(r+1,-1)\n        #print(i,l,r)\n    \n    v = 0\n    for j in range(i,m+1,i):\n        v += b.get_sum(j)\n    #print(b.get_sum(1),b.get_sum(2),b.get_sum(3), b.get_sum(4))   \n            \n    ans[i] = len(dlr) + v\n\nprint(*ans[1:],sep=\"\\n\")\n\n\n\n\n\n\n", "# coding: utf-8\n# Your code here!\nimport sys\ninput = sys.stdin.readline #\u6587\u5b57\u5217\u5165\u529b\u306e\u3068\u304d\u306f\u6ce8\u610f\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n        self.base = [0]* (n+1)\n \n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        self.base[i] += x\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n            \n    def get(self, i):\n        return self.base[i]\n\nclass RangeUpdate:\n    def __init__(self, n):\n        self.p = Bit(n + 1)\n        self.q = Bit(n + 1)\n     \n    def add(self, s, t, x):\n        t += 1\n        self.p.add(s, -x * s)\n        self.p.add(t, x * t)\n        self.q.add(s, x)\n        self.q.add(t, -x)\n     \n    def sum(self, s, t):\n        t += 1\n        return self.p.sum(t) + self.q.sum(t) * t - \\\n               self.p.sum(s) - self.q.sum(s) * s\n\n#    def get(self, s):\n#        return self.p.sum(s+1) + self.q.sum(s+1) * (s+1) - \\\n#               self.p.sum(s) - self.q.sum(s) * s\n    def get(self, s):\n        return self.p.get(s+1) + self.q.get(s+1) * (s+1) + self.q.sum(s) \n\n\n\nn,m = [int(i) for i in input().split()]\nlr = [[int(i) for i in input().split()] for _ in range(n)]\n\nlr.sort(key=lambda x: x[1]-x[0])\n\n#print(lr)\n\nomiyage = RangeUpdate(m+1)\nindex = 0\nfor d in range(1,m+1):\n    while(index < n and lr[index][1] - lr[index][0] < d):\n        omiyage.add(lr[index][0]+1, lr[index][1]+1, 1)\n        index+=1\n    ans = 0\n    pos = 0\n    while(pos <= m):\n        ans += omiyage.get(pos+1)\n        pos += d\n    ans += n-index\n    print(ans)\n    \n", "from operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\n\nclass BIT:\n    \"\"\"\u533a\u9593\u52a0\u7b97\u3001\u4e00\u70b9\u53d6\u5f97\u30af\u30a8\u30ea\u3092\u305d\u308c\u305e\u308cO(logN)\u3067\u7b54\u3048\u308b\u30c7\u30fc\u30bf\u69cb\u9020\"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def _add(self, i, val):\n        while i > 0:\n            self.bit[i] += val\n            i -= i & -i\n\n    def get_val(self, i):\n        \"\"\"i\u756a\u76ee\u306e\u5024\u3092\u6c42\u3081\u308b\"\"\"\n        i = i + 1\n        s = 0\n        while i <= self.n:\n            s += self.bit[i]\n            i += i & -i\n        return s\n\n    def add(self, l, r, val):\n        \"\"\"\u533a\u9593[l, r)\u306bval\u3092\u52a0\u3048\u308b\"\"\"\n        self._add(r, val)\n        self._add(l, -val)\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(n)]\n\nfor i in range(n):\n    info[i] = info[i][0], info[i][1], info[i][1] - info[i][0] + 1\ninfo = sorted(info, key=itemgetter(2))\n\nbit = BIT(m + 1)\nl_info = 0\nans = n\nfor d in range(1, m + 1):\n    while True:\n        if l_info < n and info[l_info][2] < d:\n            l, r, _ = info[l_info]\n            bit.add(l, r + 1, 1)\n            l_info += 1\n            ans -= 1\n        else:\n            break\n    cnt = ans\n    for i in range(0, m + 1, d):\n        cnt += bit.get_val(i)\n    print(cnt)", "import sys\ninput = sys.stdin.readline\n\nn, m = map(int,input().split())\nC = [list(map(int,input().split())) for i in range(n)]\n\nclass Bit:  # Fenwick Tree \u3068\u540c\u3058\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n  \n    def sum(self, l, r):  # [l,r)\u306e\u548c\u3092\u6c42\u3081\u308b\n        # \u5185\u90e8\u7684\u306b\u306f[l+1,r+1)\u306e\u548c\u3064\u307e\u308a(r\u307e\u3067\u306e\u548c-l\u307e\u3067\u306e\u548c)\n        s = 0\n        while r > 0:\n            s += self.tree[r]\n            r -= r & -r  # 2\u9032\u6570\u306e\u6700\u3082\u4e0b\u4f4d\u306e1\u3092\u53d6\u308a\u9664\u304f\u3068\u3044\u3046\u610f\u5473(\u4f8b:1010\u21921000)\n        while l > 0:\n            s -= self.tree[l]\n            l -= l & -l  # 2\u9032\u6570\u306e\u6700\u3082\u4e0b\u4f4d\u306e1\u3092\u53d6\u308a\u9664\u304f\u3068\u3044\u3046\u610f\u5473(\u4f8b:1010\u21921000)\n        return s\n  \n    def add(self, i, x):  # i\u756a\u76ee\u306bx\u3092\u8db3\u3059\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i  # 2\u9032\u6570\u306e\u6700\u3082\u4e0b\u4f4d\u306e1\u3092\u7e70\u308a\u4e0a\u3052\u308b\u3068\u3044\u3046\u610f\u5473(\u4f8b:1010\u21921100)\n\n    def sett(self, i, x):  # i\u756a\u76ee\u3092x\u306b\u3059\u308b\n        self.add(i, x - self.sum(i, i+1))\n\n    def print_bit(self): # \u5185\u90e8\u72b6\u614b\u3092index\u9806\u306b\u51fa\u529b\n        print([self.sum(i, i+1) for i in range(self.size)])\n\n    def print_sum(self): # \u7d2f\u7a4d\u548c\u3092index\u9806\u306b\u51fa\u529b\n        print([self.sum(0, i+1) for i in range(self.size)])\n\n    def lower_bound_left(self, w):  # x\u307e\u3067\u306e\u548c\u304cw\u4ee5\u4e0a\u3068\u306a\u308b\u6700\u5c0f\u306ex\u3001\u7dcf\u548c\u304cw\u672a\u6e80\u306e\u5834\u5408n\u304c\u8fd4\u308b\n        n = self.size\n        r = 1\n        x = 0\n        if self.sum(0, n) < w:\n            return n\n        while r < n:\n            r *= 2\n        le = r\n        while le > 0:\n            if (x + le < n and self.tree[x+le] < w):\n                w -= self.tree[x+le]\n                x += le\n            le //= 2\n        return x\n\n    def upper_bound_left(self, w):  # x\u307e\u3067\u306e\u548c\u304cw\u3088\u308a\u5927\u304d\u304f\u306a\u308b\u6700\u5c0f\u306ex\u3001\u7dcf\u548c\u304cw\u4ee5\u4e0b\u306e\u5834\u5408n\u304c\u8fd4\u308b\n        n = self.size\n        r = 1\n        x = 0\n        if self.sum(0, n) <= w:\n            return n\n        while r < n:\n            r *= 2\n        le = r\n        while le > 0:\n            if (x + le < n and self.tree[x+le] <= w):\n                w -= self.tree[x+le]\n                x += le\n            le //= 2\n        return x\n\n    def lower_bound_right(self, w):  # x\u307e\u3067\u306e\u548c\u304cw\u4ee5\u4e0b\u3068\u306a\u308b\u6700\u5927\u306ex\u30010\u756a\u76ee\u304cw\u3088\u308a\u5927\u304d\u3044\u5834\u5408-1\u304c\u8fd4\u308b\n        return self.upper_bound_left(w) - 1\n\n    def upper_bound_right(self, w):  # x\u307e\u3067\u306e\u548c\u304cw\u672a\u6e80\u3068\u306a\u308b\u6700\u5927\u306ex\u30010\u756a\u76ee\u304cw\u4ee5\u4e0a\u306e\u5834\u5408-1\u304c\u8fd4\u308b\n        return self.lower_bound_left(w) - 1\n\nD = [[] for i in range(m+1)]\nfor d in range(1, m+1):\n    for j in range(d, m+1, d):\n        D[j].append(d)\n\nL = [0] * (m+1)\nfor i in range(1, m+1):\n    for j in range(len(D[i])):\n        L[D[i][j]] = i\n\n# print(D)\n\nA = [-1] * (m+1)\nB = Bit(m+2)\nE = [0] * (m+1)\nANS = [0] * (m+1)\n\nC.sort(key=lambda x:x[1])\n# print(C)\nind = 0\n# mul = 1\nfor i in range(1, m+1):\n    # print(i)\n    for j in range(len(D[i])):\n        k = D[i][j]\n        if A[k] != -1:\n           ANS[k] += B.sum(0, A[k]+1)\n        E[i] += 1\n        A[k] = i\n        # print(E)\n    while ind < n and C[ind][1] <= i: \n        l = C[ind][0]\n        r = C[ind][1]\n        B.add(l, 1)\n        B.add(r+1, -1)\n        # mul -= 1\n        ind += 1\n\nfor i in range(1, m+1):\n    ANS[i] += B.sum(0, L[i]+1)\n\nfor i in range(1, m+1):\n    print(ANS[i])", "import sys\ninput = sys.stdin.readline\nN, M = list(map(int, input().split()))\nNN = (M + 10).bit_length()\nBIT=[0]*(2**NN+1)\n\ndef addrange(l0, r0, x=1):\n    l, r = l0, r0\n    while l <= 2**NN:\n        BIT[l] += x\n        l += l & (-l)\n    while r <= 2**NN:\n        BIT[r] -= x\n        r += r & (-r)\ndef getvalue(r):\n    a = 0\n    while r != 0:\n        a += BIT[r]\n        r -= r&(-r)\n    return a\n\nX = []\nfor _ in range(N):\n    l, r = list(map(int, input().split()))\n    X.append((l, r+1))\n\nX = sorted(X, key = lambda x: -(x[1]-x[0]))\nfor d in range(1, M+1):\n    while X and X[-1][1] - X[-1][0] < d:\n        l, r = X.pop()\n        addrange(l, r)\n    ans = len(X)\n    for i in range(d, M+1, d):\n        ans += getvalue(i)\n    print(ans)\n", "# seishin.py\nN, M = map(int, input().split())\nD = [[] for i in range(M+1)]\nfor i in range(N):\n    l, r = map(int, input().split())\n    D[r-l+1].append(l)\n\ndata = [0]*(M+2)\ndef get(k):\n    s = 0\n    while k:\n        s += data[k]\n        k -= k & -k\n    return s\ndef add(k, x):\n    while k <= M+1:\n        data[k] += x\n        k += k & -k\n\nC = N\nans = []\nfor d in range(1, M+1):\n    for l in D[d]:\n        add(l, 1)\n        add(l+d, -1)\n        C -= 1\n\n    cnt = C\n    i = d\n    while i <= M:\n        cnt += get(i)\n        i += d\n    ans.append(cnt)\nprint(*ans, sep='\\n')\n", "class BIT(object):\n    def __init__(self, size):\n        self.size = size\n        self.bit = [0] * (self.size + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.bit[i] += x\n            i += i & -i\n\n    def __str__(self):\n        return str(self.bit)\n\nn, m = map(int,input().split())\nlr = [[] for i in range(m + 1)]\nfor i in range(n):\n    l, r = map(int,input().split())\n    lr[r - l + 1].append(l)\n\nbit = BIT(m + 1)\nt = 0\nfor d in range(1, m + 1):\n    for l in lr[d]:\n        #print(l, l + d)\n        bit.add(l, 1)\n        #print(bit.bit)\n        bit.add(l + d, -1)\n        #print(bit.bit)\n\n    t += len(lr[d])\n    ans = n - t\n\n    cur = 0\n    while cur <= m:\n        ans += bit.sum(cur)\n        cur += d\n\n    print(ans)", "from operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\n\nclass BIT:\n    \"\"\"\u533a\u9593\u52a0\u7b97\u3001\u4e00\u70b9\u53d6\u5f97\u30af\u30a8\u30ea\u3092\u305d\u308c\u305e\u308cO(logN)\u3067\u7b54\u3048\u308b\u30c7\u30fc\u30bf\u69cb\u9020\"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def _add(self, i, val):\n        while i > 0:\n            self.bit[i] += val\n            i -= i & -i\n\n    def get_val(self, i):\n        \"\"\"i\u756a\u76ee\u306e\u5024\u3092\u6c42\u3081\u308b\"\"\"\n        i = i + 1\n        s = 0\n        while i <= self.n:\n            s += self.bit[i]\n            i += i & -i\n        return s\n\n    def add(self, l, r, val):\n        \"\"\"\u533a\u9593[l, r)\u306bval\u3092\u52a0\u3048\u308b\"\"\"\n        self._add(r, val)\n        self._add(l, -val)\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(n)]\n\nfor i in range(n):\n    info[i] = info[i][0], info[i][1], info[i][1] - info[i][0] + 1\ninfo = sorted(info, key=itemgetter(2))\n\nbit = BIT(m + 1)\nl_info = 0\nans = n\nfor d in range(1, m + 1):\n    while True:\n        if l_info < n and info[l_info][2] < d:\n            l, r, _ = info[l_info]\n            bit.add(l, r + 1, 1)\n            l_info += 1\n            ans -= 1\n        else:\n            break\n    cnt = ans\n    if d == 1:\n        print(n)\n        continue\n    for i in range(0, m + 1, d):\n        cnt += bit.get_val(i)\n    print(cnt)"]
["class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        \n        leftset, rightset = set(leftChild), set(rightChild)\n        roots = []\n        for i in range(n):\n            if i not in leftset and i not in rightset: \n                roots.append(i)\n                if len(roots) > 1: return False\n        if not roots: return False\n        root =  roots[0]\n        \n        nodes = []\n        def dfs(root):\n            if root == -1: return \n            if len(nodes) > n: return\n            nodes.append(root)\n            dfs(leftChild[root])\n            dfs(rightChild[root])\n        dfs(root)\n        return len(nodes) == n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        \n        root = set(range(n))\n        for c in leftChild + rightChild:\n            if c == -1:\n                continue\n            if c not in root:\n                return False\n            root.remove(c)\n        \n        if len(root) != 1:\n            return False\n        \n        def dfs(node):\n            if node == -1:\n                return 0\n            \n            return 1 + dfs(leftChild[node]) + dfs(rightChild[node])\n        \n        return dfs(root.pop()) == n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, left_children: List[int], right_children: List[int]) -> bool:\n        \n        root = self.find_root(n, left_children, right_children)\n        if root == -1:\n            return False\n        \n        return self.helper(root, n, left_children, right_children)\n        \n    def find_root(self, n, left_children, right_children):\n        left_counter = collections.Counter(left_children)\n        right_counter = collections.Counter(right_children)\n        for i in range(n):\n            if i not in left_counter and i not in right_counter:\n                return i\n            \n        return -1\n        \n    def helper(self, root, n, left_children, right_children):\n        visited = set()\n        if not self.dfs(root, left_children, right_children, visited):\n            return False\n        \n        #print(visited)\n        return len(visited) == n\n        \n    def dfs(self, root, left_children, right_children, visited):\n        if root == -1:\n            return True\n        \n        if root in visited:\n            return False\n        \n        visited.add(root)\n        left = self.dfs(left_children[root], left_children, right_children, visited)\n        right = self.dfs(right_children[root], left_children, right_children, visited)\n        \n        return left and right\n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        parents = [(idx, 0) for idx in range(n)]\n        \n        def find(idx):\n            original_idx = idx\n            height = 0\n            while parents[idx][0] != idx:\n                height += 1\n                idx = parents[idx][0]\n            parents[original_idx] = (idx, 0)\n            return parents[idx]\n        \n        # Returns false if the two elements are already in the same group\n        def union(idx1, idx2):\n            parent1, rank1 = find(idx1)\n            parent2, rank2 = find(idx2)\n            if parent1 == parent2:\n                return False\n            if rank1 > rank2:\n                 parents[parent2] = (parent1, rank1)\n            elif rank2 > rank1:\n                 parents[parent1] = (parent2, rank2)\n            else:\n                 parents[parent1] = (parent2, rank2 + 1)\n            return True\n        # [1, 3, 3, 3]\n        for idx1, idx2 in enumerate(leftChild):\n            if idx2 == -1:\n                continue\n            if not union(idx1, idx2):\n                return False\n            \n        for idx1, idx2 in enumerate(rightChild):\n            if idx2 == -1:\n                continue\n            if not union(idx1, idx2):\n                return False\n\n        \n        group, _ = find(0)\n        for idx in range(n):\n            if find(idx)[0] != group:\n                return False\n        return True", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, left: List[int], right: List[int]) -> bool:\n        \n        children = {}\n        nodes = {}\n        \n        for i in range(n):\n            l,r = left[i], right[i]\n            \n            if (l!=-1 and l in children) or (r!=-1 and r in children): \n                print('Here Yo-',children, l, r)\n                return False\n            elif i in children and children[i] in [l,r]: \n                print('Baap ko gali')\n                return False\n            elif i in [l,r]:\n                print('Selfie')\n                return False\n            \n            nodes[i] = [l,r]\n            children[l] = i\n            children[r] = i\n        \n#         print(children)\n#         root = False\n#         for i in range(n):\n#             if i not in children:\n#                 if root: \n#                     print('Here Yoyo')\n#                     return False\n#                 root = True\n        \n        root = 0\n        for i in range(n):\n            if i not in children: \n                root = i\n                break\n    \n        count = 0\n        frontier = [root]\n        seen = set()\n        while frontier:\n            cur = frontier.pop()\n            if cur==-1: continue\n            # print(cur)\n            count+=1\n            c = nodes[cur]\n            if (c[0]!=-1 and c[0] in seen) or (c[1]!=-1 and c[1] in seen):\n                return False\n            \n            if c[0]!=-1:\n                seen.add(c[0])\n                frontier.append(c[0])\n            if c[1]!=-1:\n                seen.add(c[1])\n                frontier.append(c[1])\n                \n        if count!=n: \n            # print('Count Small-',count)\n            return False\n        return True", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, left_children: List[int], right_children: List[int]) -> bool:\n        \n        root = self.find_root(n, left_children, right_children)\n        if root == -1:\n            return False\n        \n        return self.helper(root, n, left_children, right_children)\n        \n    def find_root(self, n, left_children, right_children):\n        left_counter = collections.Counter(left_children)\n        right_counter = collections.Counter(right_children)\n        for i in range(n):\n            if i not in left_counter and i not in right_counter:\n                return i\n            \n        return -1\n        \n    def helper(self, root, n, left_children, right_children):\n        visited = set()\n        if not self.dfs(root, left_children, right_children, visited):\n            return False\n        \n        return len(visited) == n\n        \n    def dfs(self, root, left_children, right_children, visited):\n        if root == -1:\n            return True\n        \n        if root in visited:\n            return False\n        \n        visited.add(root)\n        left = self.dfs(left_children[root], left_children, right_children, visited)\n        right = self.dfs(right_children[root], left_children, right_children, visited)\n        \n        return left and right\n", "from functools import reduce\nclass Solution:\n    def validateBinaryTreeNodes(self, n, leftChild, rightChild) -> bool:\n        \n        g = dict(enumerate(zip(leftChild, rightChild)))\n        \n        root = set(range(n)) - reduce(set.union, list(map(set, [leftChild, rightChild]))) \n        \n        if len(root) != 1:\n            return False\n        \n        root = next(iter(root))\n        \n        def dfs(n):\n            if n == -1:\n                return True\n            if n not in g:\n                return False\n            return all(map(dfs, g.pop(n)))\n    \n        out = dfs(root)\n        \n        return out and not g\n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        indegree = [0] * n\n        \n        for i in leftChild:\n            if i >= 0:\n                indegree[i] += 1\n        for i in rightChild:\n            if i >= 0:\n                indegree[i] += 1\n        \n        root = -1\n        for i, d in enumerate(indegree):\n            if d == 0:\n                root = i\n                break\n                \n        if root < 0:\n            return False\n        \n        visited = [False] * n\n        \n        res = True\n        def dfs(node):\n            if visited[node]:\n                nonlocal res\n                res = False\n                return\n            visited[node] = True\n            if leftChild[node] >= 0:\n                dfs(leftChild[node])\n            if rightChild[node] >= 0:\n                dfs(rightChild[node])\n        \n        dfs(root)\n        \n        for node in range(n):\n            if not visited[node]:\n                res = False\n        return res\n        \n", "import collections\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        # Conditions:\n        # 1. There are one and only one node that has zero in degree.\n        # 2. All other nodes have one and only one in degree.\n        # 3. There are no cycle.\n        \n        if n == 1: return True\n        degree = [0] * n\n        graph = []\n        for _ in range(n):\n            graph.append(set())\n        for i,v in enumerate(leftChild):\n            if v != -1:\n                degree[v] += 1\n                graph[i].add(v)\n                \n        for i,v in enumerate(rightChild):\n            if v != -1:\n                degree[v] += 1\n                graph[i].add(v)\n        \n        root = [i for i in range(n) if degree[i] == 0]\n        if len(root) != 1:\n            return False\n        \n        visited = set()\n        self.dfs(root[0], graph, visited)\n        if len(visited) != n:\n            return False\n        \n        counter = collections.Counter(degree)\n        return len(counter) == 2 and counter[0] == 1 and counter[1] == n-1\n    \n    \n    \n    def dfs(self, idx, graph, visited):\n        visited.add(idx)\n        for j in graph[idx]:\n            if j not in visited:\n                self.dfs(j, graph, visited)", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        def cycle(node):\n            if seen[node] == 1:\n                return True\n            if seen[node] == 2:\n                return False\n            seen[node] = 1\n            for nei in g[node]:\n                if cycle(nei):\n                    return True\n            seen[node] = 2\n            return False\n        \n        indeg = [0]*n\n        g = [[] for _ in range(n)]\n        \n        for i, (u, v) in enumerate(zip(leftChild, rightChild)):\n            if u > -1:\n                g[i].append(u)\n                indeg[u] += 1\n            if v > -1:\n                g[i].append(v)\n                indeg[v] += 1\n                \n        counts = Counter(indeg)\n        # multiple roots or no root\n        if counts[0] > 1 or counts[0] == 0:\n            return False\n        # multiple indegrees\n        if any(count > 1 for count in list(counts.keys())):\n            return False\n        \n        root = indeg.index(0)\n        seen = [0]*n\n        # no cycles and dfs hits all nodes (one CC)\n        return not cycle(root) and all(seen[node] == 2 for node in range(n))\n            \n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        def method1():\n            def dfs(node):\n                if node>=n:\n                    return False\n                \n                if node in seen:\n                    return False\n                \n                seen.add(node)\n                L=True\n                if leftChild[node]!=-1:\n                    L=dfs(leftChild[node])\n                    \n                R=True\n                if rightChild[node]!=-1:\n                    R=dfs(rightChild[node])\n                    \n                return L and R\n            \n            seen=set()\n            valid = dfs(0)\n            print(len(seen),valid)\n            return valid and len(seen)==n\n        \n        #return method1()\n    \n        def method2():\n            indeg=collections.defaultdict(int)\n            for i in range(n):\n                if leftChild[i]!=-1:\n                    indeg[leftChild[i]]+=1\n                if rightChild[i]!=-1:\n                    indeg[rightChild[i]]+=1\n                    \n            root=0\n            for i in range(n):\n                if indeg[i]==0:\n                    root=i\n            \n            def dfs(node):\n                if node>=n:\n                    return False\n                \n                if node in seen:\n                    return False\n                \n                seen.add(node)\n                L=True\n                if leftChild[node]!=-1:\n                    L=dfs(leftChild[node])\n                    \n                R=True\n                if rightChild[node]!=-1:\n                    R=dfs(rightChild[node])\n                    \n                return L and R\n            \n            seen=set()\n            valid = dfs(root)\n            print(len(seen),valid)\n            return valid and len(seen)==n\n        \n        return method2()", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        def union(origin, destination, parents, rank):\n            parent_origin = find(origin, parents)\n            parent_destination = find(destination, parents)\n            if parent_origin == parent_destination:\n                return False\n            if rank[parent_origin] < rank[parent_destination]:\n                parents[parent_origin] = parents[parent_destination]\n            else:\n                parents[parent_destination] = parents[parent_origin]\n                if rank[parent_origin] == rank[parent_destination]:\n                    rank[parent_origin] += 1\n            return True\n\n        def find(x, parents):\n            if parents[x] == x:\n                return parents[x]\n            return find(parents[x], parents)\n\n        parents = [n for n in range(n)]\n        rank = [0 for _ in range(n)]\n        for i, (left, right) in enumerate(zip(leftChild, rightChild)):\n            if left != -1:\n                if not union(i, left, parents, rank):\n                    return False\n            if right != -1:\n                if not union(i, right, parents, rank):\n                    return False\n        return len({find(x, parents) for x in range(n)}) == 1", "from itertools import chain\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        s = set(range(n))\n        for c in chain(leftChild, rightChild):\n            if c != -1:\n                if c not in s:\n                    return False\n                s.remove(c)\n                \n        if len(s) != 1:\n            return\n        \n        def dfs(node: int):\n            if node == -1:\n                return\n            nonlocal n\n            n -= 1\n            dfs(leftChild[node])\n            dfs(rightChild[node])\n            \n        dfs(s.pop())\n        return n == 0", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        \n        parent = {}\n        for i in range(n):\n            if leftChild[i]!=-1:\n                if leftChild[i] in parent:\n                    return False\n                parent[leftChild[i]]=i\n            if rightChild[i]!=-1:\n                if rightChild[i] in parent:\n                    return False\n                parent[rightChild[i]]=i\n        \n        if len(parent)!=n-1:\n            return False\n        f = {}\n        def find(x):\n            f.setdefault(x,x)\n            if f[x]!=x:\n                f[x] = find(f[x])\n            return f[x]\n        def union(x,y):\n            f[find(x)]=find(y)\n        for x in parent:\n            union(x, parent[x])\n        return len(set([find(x) for x in range(n)]))==1", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        def cycle(node):\n            if seen[node] == 1:\n                return True\n            if seen[node] == 2:\n                return False\n            seen[node] = 1\n            for nei in g[node]:\n                if cycle(nei):\n                    return True\n            seen[node] = 2\n            return False\n        \n        indeg = [0]*n\n        g = [[] for _ in range(n)]\n        \n        for i, (u, v) in enumerate(zip(leftChild, rightChild)):\n            if u > -1:\n                g[i].append(u)\n                indeg[u] += 1\n            if v > -1:\n                g[i].append(v)\n                indeg[v] += 1\n                \n        counts = Counter(indeg)\n        # multiple roots or no root\n        if counts[0] > 1 or counts[0] == 0:\n            return False\n        # multiple indegrees\n        if any(count > 1 for count in list(counts.keys())):\n            return False\n        \n        root = indeg.index(0)\n        seen = [0]*n\n        return not cycle(root) and all(seen[node] == 2 for node in range(n))\n            \n", "class Solution:\n    def validateBinaryTreeNodes(self, nodes: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        \n        \n        num_edges = 0\n        graph = collections.defaultdict(list)\n        indegree = {i: 0 for i in range(nodes)}\n        parents = {i: None for i in range(nodes)}\n        # print(parents)\n        for n, (l, r) in enumerate(zip(leftChild, rightChild)):\n            if l != -1:\n                num_edges += 1\n                graph[n].append(l)\n                if parents[l] is not None or parents[n] == l:\n                    return False\n                parents[l] = n\n                indegree[l] += 1\n            if r != -1:\n                num_edges += 1\n                graph[n].append(r)\n                if parents[r] is not None or parents[n] == r:\n                    return False\n                parents[r] = n\n                indegree[r] += 1\n                \n        # There must be exactly (n - 1) edges\n        if num_edges != nodes - 1:\n            return False\n        \n        # For each node, except for the root, there must be only 1 parent\n        \n        # FIND ALL ROOT NODES (IE. THOSE WITHOUT PARENT) - O(N)\n        roots = [i for i in range(len(parents)) if parents[i] is None]\n\n        # CHECK IF THERE'S EXACTLY 1 ROOT NODE  - O(1)\n        if len(roots) != 1:\n            return False\n        \n        # ENSURE ROOT HAS > 1 CHILD, IF N > 1 - O(N)\n        root = roots[0]\n        return max(leftChild[root], rightChild[root]) != -1 or nodes == 1\n        \n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        edge=[[]for i in range(n)]\n        cntEdge=0\n        for u,v in enumerate(leftChild):\n            if v==-1:continue\n            else:\n                edge[u].append(v)\n                edge[v].append(u)\n                cntEdge+=1\n        for u,v in enumerate(rightChild):\n            if v==-1:continue\n            else:\n                edge[u].append(v)\n                edge[v].append(u)\n                cntEdge+=1\n        if cntEdge!=n-1:return False\n        vis=[False for i in range(n)]\n        stack=[]\n        stack.append(0)\n        while stack:\n            u=stack.pop()\n            vis[u]=True\n            for v in edge[u]:\n                if not vis[v]:\n                    stack.append(v)\n        return all(vis)", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n\n        # find root and do dfs\n        # look for cycle or things not visited from the root\n        visited = [False] * n\n        cycle = False\n        \n        def dfs(root):\n            nonlocal cycle\n            #print(root, visited, cycle)\n            if root == -1:\n                return\n            \n            if not visited[root]:\n                visited[root] = True\n                dfs(leftChild[root])\n                dfs(rightChild[root])\n            else:\n                cycle = True\n                \n            \n                   \n        def find_root():\n            in_degree = {}\n            \n            for i in range(n):\n                in_degree[i] = 0\n            # add -1 so u wont skip it\n            in_degree[-1] = 0    \n            for i in range(n):\n                in_degree[leftChild[i]] += 1\n                in_degree[rightChild[i]] += 1\n            \n            has_seen = False  \n            root = None\n            print(in_degree)\n            for k,v in list(in_degree.items()):\n\n                    \n                if v == 0:\n                    if has_seen:\n                        return None\n                    root = k\n                    has_seen = True\n                    \n                \n            return root\n                \n        root = find_root()\n        print(root)\n        if root == None:\n            return False\n        dfs(root)\n        #print(cycle)\n        if cycle:\n            #print('cycle')\n            return False\n        \n        #print(visited)\n        return all(visited)\n        \n        \n                \n            \n            \n        \n\n", "def build_graph(n, leftChild, rightChild):\n    adj_list = [[] for _ in range(n)]\n    for i in range(len(leftChild)):\n        left = leftChild[i]\n        right = rightChild[i]\n        if left != -1:\n            adj_list[i].append(left)\n        if right != -1:\n            adj_list[i].append(right)\n    return adj_list\ndef gather_inDegrees(n, graph):\n    inDegrees = [0] * n\n    for i in range(len(graph)):\n        for neighbor in graph[i]:\n            inDegrees[neighbor] += 1\n    return inDegrees\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        graph = build_graph(n, leftChild, rightChild)\n        inDegrees = gather_inDegrees(n, graph)\n        print(inDegrees)\n        zero_count = 0\n        for count in inDegrees:\n            if count > 1:\n                return False\n            if count == 0:\n                if zero_count == 1:\n                    return False\n                else:\n                    zero_count += 1\n        \n        visited = set()\n        topo_order = []\n        processing = set()\n        def _dfs(node):\n            processing.add(node)\n            visited.add(node)\n            neighbors = graph[node]\n            for neighbor in neighbors:\n                if neighbor in visited and neighbor in processing:\n                    return True\n                else:\n                    if neighbor not in visited:\n                        if _dfs(neighbor):\n                            return True\n            processing.remove(node)\n            topo_order.append(node)\n            return False\n        \n        for i in range(n):\n            if i not in visited:\n                if _dfs(i):\n                    return False\n        return True", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        dic = collections.defaultdict(list)\n        for idx, (left , right) in enumerate(zip(leftChild, rightChild)):\n            if left != -1:\n                dic[left].append(idx)\n            if right != -1:\n                dic[right].append(idx)\n      \n        parent = set()\n        for key, value in dic.items():\n            if len(value) > 1:\n                return False\n            if [key]  == dic.get(value[0], []):\n                return False\n            parent.add(value[0])\n            \n        if parent and len(dic.keys() - parent) == 0:\n            return False\n        \n        return len(dic) == n-1        ", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        graph = [set() for _ in range(n)] \n        degree = [0] * n\n        for i in range(n):\n            if leftChild[i] != -1:\n                graph[i].add(leftChild[i])\n                degree[leftChild[i]] += 1\n            if rightChild[i] != -1:\n                graph[i].add(rightChild[i])\n                degree[rightChild[i]] += 1\n        q = collections.deque()\n        for i in range(n):\n            if degree[i] == 0:\n                q.append(i)\n            if degree[i] > 1:\n                return False\n        if len(q) > 1 or len(q) == 0: return False      \n        visited = set()\n        while q:\n            node = q.pop()\n            visited.add(node)\n            for neigh in graph[node]:\n                if neigh in visited:\n                    return False\n                degree[neigh] -= 1\n                if degree[neigh] == 0:\n                    q.append(neigh)\n        return len(visited) == n\n            \n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        \n        visited = [0 for _ in range(n)]\n        \n        from collections import deque\n        \n        for i in range(n):\n            if visited[i] == 1:\n                continue\n            \n            q = deque()\n            q.append(i)\n            visited[i] = 1\n            while q:\n                cur = q.popleft()\n                left = leftChild[cur]\n                right = rightChild[cur]\n\n                if left != -1:\n                    if visited[left] == 1:\n                        return False\n                    else:\n                        visited[left] = 1\n                        q.append(left)\n\n                if right != -1:\n                    if visited[right] == 1:\n                        return False\n                    else:\n                        visited[right] = 1\n                        q.append(right)\n            visited[i] = 0\n            leftChild[i] = -1\n            rightChild[i] = -1\n        \n        return n - sum(visited) == 1\n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        tree = {}\n        notroots = set()\n        for i in range(n):\n            tree[i] = []\n            left = leftChild[i]\n            right = rightChild[i]\n            if left != -1:\n                notroots.add(left)\n                tree[i].append(left)\n            if right != -1:\n                notroots.add(right)\n                tree[i].append(right)\n        if len(notroots) == n:\n            return False\n            \n        def helper(node):\n            if node not in tree:\n                path.add(node)\n                return True\n            if node in path:\n                return False\n            path.add(node)\n            children = tree[node]\n            nchild = len(children)\n            for i in range(nchild):\n                child = children[i]\n                if not helper(child):\n                    return False\n            return True\n        \n        \n        path = set()\n        for i in range(n):\n            if i not in notroots:\n                if not helper(i):\n                    return False\n                break\n        for i in range(n):\n            if i not in path:\n                return False\n        return True", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        indegree = [0 for i in range(n)]\n        # Count in-degree\n        for i in range(len(leftChild)):\n            if leftChild[i] != -1:\n                indegree[leftChild[i]] += 1\n                if indegree[leftChild[i]] > 1:\n                    return False\n            if rightChild[i] != -1:\n                indegree[rightChild[i]] += 1\n                if indegree[rightChild[i]] > 1:\n                    return False\n        # Find potential root\n        root = -1\n        for node in range(len(indegree)):\n            if indegree[node] == 0:\n                if root == -1:\n                    root = node\n                else:\n                    return False\n        if root == -1:\n            return False\n        \n        # Exactly n nodes in single tree\n        def countNodes(root, l, r):\n            if root is -1:\n                return 0\n            return 1 + countNodes(l[root], l, r) + countNodes(r[root], l, r)\n        return countNodes(root, leftChild, rightChild) == n\n    \n    \n", "class DSU():\n    \n    def __init__(self,n):\n        self.parent=list(range(n))\n        self.size=[1]*n\n    \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self,x,y):\n        xp,yp=self.find(x),self.find(y)\n        \n        if xp==yp:\n            return False\n        \n        if self.size[xp]<self.size[yp]:\n            xp,yp=yp,xp\n        \n        self.size[xp]+=self.size[yp]\n        self.parent[yp]=xp\n        \n        return True\n\nclass Solution:\n    \n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        dsu=DSU(n)\n        \n        for i in range(n):\n            \n            if leftChild[i]>=0 and not dsu.union(i,leftChild[i]):\n                return False\n            if rightChild[i]>=0 and not dsu.union(i,rightChild[i]):\n                return False\n        \n        p=dsu.find(0)\n        for i in range(n):\n            if p != dsu.find(i):\n                return False\n        \n        return True", "class DSU:\n    def __init__(self, count):\n        self.components = count\n        self.parent = [i for i in range(count)]\n        self.size = [1 for _ in range(count)]\n\n    def find(self, x):\n        root = x\n        while root != self.parent[root]:\n            root = self.parent[root]\n        while root != x:\n            next_root = self.parent[x]\n            self.parent[x] = root\n            x = next_root\n        return root\n    \n    def union(self, x, y):\n        r1, r2 = self.find(x), self.find(y)\n        if r1 == r2:\n            return False\n        if self.size[r1] < self.size[r2]:\n            self.size[r2] += self.size[r1]\n            self.parent[r1] = r2\n        else:\n            self.size[r1] += self.size[r2]\n            self.parent[r2] = r1\n        self.components -= 1\n        return True\n    \nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        dsu = DSU(n)\n        for i, left in enumerate(leftChild):\n            if left != -1:\n                if not dsu.union(i, left):\n                    return False\n        for i, right in enumerate(rightChild):\n            if right != -1:\n                if not dsu.union(i, right):\n                    return False\n        \n        return dsu.components == 1", "class dsu:\n    def __init__(self,n):\n        self.parent=list(range(n))\n        self.count=n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]    \n    \n    def union(self, x, y):\n        \n        px, py = self.find(x), self.find(y)\n        \n        if px==py:\n            return False\n        if px != py:\n            self.count=self.count-1\n            self.parent[px] = py\n            return True\n\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        DSU=dsu(n)\n        indegree=[0]*n\n        for i in range(n):\n            if(leftChild[i]!=-1):\n                indegree[leftChild[i]]+=1\n            if(rightChild[i]!=-1):\n                indegree[rightChild[i]]+=1\n      \n        count_zeroes=0\n        for i in indegree:\n            if(i==0):\n                count_zeroes+=1\n            if(count_zeroes>1):\n                return False\n        for node,child in enumerate(zip(leftChild,rightChild)):\n            if child[0]!=-1:\n                if(DSU.union(node,child[0])==False):\n                    return False\n            if child[1]!=-1:\n                if(DSU.union(node,child[1])==False):\n                    return False    \n                \n        return True\n        \n        \n", "class DSU:\n    def __init__(self, n):\n        self.n = n\n        self.parent = [x for x in range(n)]\n        self.rank = [0 for x in range(n)]\n        \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, s, t):\n        sp, tp = self.find(s), self.find(t)\n        if sp == tp:\n            return False\n        if self.rank[sp] > self.rank[tp]:\n            self.parent[tp] = sp\n        elif self.rank[sp] < self.rank[tp]:\n            self.parent[sp] = tp\n        else:\n            self.parent[sp] = tp\n            self.rank[tp] += 1\n        return True\n\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        edges = set()\n        net = DSU(n)\n        for idx in range(n):\n            if leftChild[idx] != -1:\n                leftEdge = (min(idx, leftChild[idx]), max(idx, leftChild[idx]))\n                if leftEdge in edges:\n                    return False\n                edges.add(leftEdge)\n                if not net.union(idx, leftChild[idx]):\n                    return False\n            if rightChild[idx] != -1:\n                rightEdge = (min(idx, rightChild[idx]), max(idx, rightChild[idx]))\n                if rightEdge in edges:\n                    return False\n                edges.add(rightEdge)\n                if not net.union(idx, rightChild[idx]):\n                    return False\n        return len(edges) == n - 1\n", "class Solution:\n    def validateBinaryTreeNodes(self, n, left, right):\n        roots={*range(n)}\n        for x in left+right:\n            if x==-1:\n                continue\n            if x not in roots:\n                return False\n            roots.discard(x)\n        if len(roots)!=1:\n            return False\n        k=0\n        stk=[roots.pop()]\n        while stk:\n            node=stk.pop()\n            k+=1\n            l,r=left[node],right[node]\n            if l!=-1:\n                stk.append(l)\n            if r!=-1:\n                stk.append(r)\n        return k==n", "class dsu:\n    def __init__(self,n):\n        self.parent=list(range(n))\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]    \n    \n    def union(self, x, y):\n        \n        px, py = self.find(x), self.find(y)\n        \n        if px==py:\n            return False\n        if px != py:\n            self.parent[px] = py\n            return True\n\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        DSU=dsu(n)\n        indegree=[0]*n\n        for i in range(n):\n            if(leftChild[i]!=-1):\n                indegree[leftChild[i]]+=1\n            if(rightChild[i]!=-1):\n                indegree[rightChild[i]]+=1\n      \n        count_zeroes=0\n        for i in indegree:\n            if(i==0):\n                count_zeroes+=1\n            if(count_zeroes>1):\n                return False\n        for node,child in enumerate(zip(leftChild,rightChild)):\n            if child[0]!=-1:\n                if(DSU.union(node,child[0])==False):\n                    return False\n            if child[1]!=-1:\n                if(DSU.union(node,child[1])==False):\n                    return False    \n                \n        return True\n        \n        \n", "class Solution:   # 2020-10-09-7\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        # rules: (1) descendants cannot point to ancestors (i.e. no cycles)\n        # (2) a node cannot be pointed to more than once (partly overlaps with rule 1)\n        # (3) the tree should be connected, i.e. not a forest\n        \n        vis = set()\n        heads = set()\n        \n        def dfs(i):\n            if i == -1:\n                return True\n            vis.add(i)\n            for child in [leftChild[i], rightChild[i]]:\n                if child in vis:\n                    if child not in heads:\n                        return False\n                    else:\n                        heads.remove(child)\n                else:\n                    if not dfs(child):\n                        return False\n            return True\n            \n        for i in range(n):\n            if i not in vis:\n                if not dfs(i):\n                    return False\n                heads.add(i)\n            \n        return len(heads) == 1\n        \n        \n        \n        \n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        unvisited = set([i for i in range(n)])\n        \n        graph = defaultdict(set)\n        \n        for i in range(len(leftChild)):\n            if leftChild[i] != -1:\n                graph[i].add(leftChild[i])\n        \n        \n        for i in range(len(rightChild)):\n            if rightChild[i] != -1:\n                graph[i].add(rightChild[i])\n                \n        zero_indegree_nodes = set(unvisited)\n        \n        for k,v in graph.items():\n            for node in v:\n                if node in zero_indegree_nodes:\n                    zero_indegree_nodes.remove(node)\n        \n        if len(zero_indegree_nodes) != 1:\n            return False\n        \n        def visit(node):\n            unvisited.remove(node)\n            \n            for nbr in graph[node]:\n                if nbr not in unvisited:\n                    return True\n                if visit(nbr):\n                    return True\n            \n            return False\n    \n        x = visit(list(zero_indegree_nodes)[0])\n        \n        if x == True:\n            return False\n        \n        if len(unvisited) > 0:\n            return False\n        \n        return True", "#3:50\nfrom collections import defaultdict\nclass Solution:\n    def DFS(self, edges, root, visited):\n        for child in edges[root]:\n            if child in visited:\n                return False\n            else:\n                visited.add(child)\n                if not self.DFS(edges, child, visited):\n                    return False\n        return True\n        \n        \n    \n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        \n        master_list = leftChild + rightChild\n        children = set(master_list) - set([-1])\n        parent = set(range(n)) - children\n        if len(parent) != 1:\n            return False\n        parent = list(parent)[0]\n        \n        edges = defaultdict(list)\n        for i in range(n):\n            if leftChild[i] != -1:\n                edges[i].append(leftChild[i])\n                \n            if rightChild[i] != -1:\n                edges[i].append(rightChild[i])\n        visited = set()    \n        visited.add(parent)\n        if not self.DFS(edges, parent,visited):\n            return False\n        return len(visited) == n\n        \n                \n        \n        \n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        indegree = [0]*n\n        outdegree = [0]*n\n        visited = [False]*n\n        \n        possible_roots = []\n        for i in range(n):\n            if leftChild[i] != -1:\n                outdegree[i] += 1\n                indegree[leftChild[i]] += 1\n            if rightChild[i] != -1:\n                outdegree[i] += 1\n                indegree[rightChild[i]] += 1\n    \n        \n        for i in range(n):\n            if indegree[i] == 0 and outdegree[i] <= 2:\n                possible_roots.append(i)\n                # check for more than one root node\n                if len(possible_roots) > 1:\n                    return False\n\n            if outdegree[i] > 2:\n                return False\n            \n        if not possible_roots:\n            return False\n    \n        queue = deque()\n        queue.append(possible_roots[0])\n        while queue:\n            node = queue.popleft()\n            if visited[node]:\n                return False\n            \n            visited[node] = True\n            \n            lc = leftChild[node]\n            rc = rightChild[node]\n            if lc != -1:\n                queue.append(lc)\n            if rc != -1:\n                queue.append(rc)\n        \n        \n        return all(visited)", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n\n        # find root and do dfs\n        # look for cycle or things not visited from the root\n        visited = [False] * n\n        cycle = False\n        \n        def dfs(root):\n            nonlocal cycle\n            #print(root, visited, cycle)\n            if root == -1:\n                return\n            \n            if not visited[root]:\n                visited[root] = True\n                dfs(leftChild[root])\n                dfs(rightChild[root])\n            else:\n                cycle = True\n                \n            \n                   \n        def find_root():\n            in_degree = {}\n            \n            for i in range(n):\n                in_degree[i] = 0\n            # add -1 so u wont skip it\n            in_degree[-1] = 0    \n            for i in range(n):\n                in_degree[leftChild[i]] += 1\n                in_degree[rightChild[i]] += 1\n                \n            for k,v in list(in_degree.items()):\n                if v == 0:\n                    return k\n                \n        root = find_root()\n        #print(root)\n        if root == None:\n            return False\n        dfs(root)\n        #print(cycle)\n        if cycle:\n            #print('cycle')\n            return False\n        \n        #print(visited)\n        return all(visited)\n        \n        \n                \n            \n            \n        \n\n", "from typing import List\nfrom collections import defaultdict\n\nclass DS:\n    \n    def __init__(self, n):\n        self.sz = [1] * n\n        self.rt = [i for i in range(n)]\n        self.ccCt = n\n        \n    def query(self, x):\n        root = x\n        while root != self.rt[root]:\n            self.rt[root] = self.rt[self.rt[root]]\n            root = self.rt[root]\n        return root\n    \n    def union(self, x, y):\n        rootX, rootY = self.query(x), self.query(y)\n        if rootX != rootY:\n            self.ccCt -= 1\n            szX, szY = self.sz[rootX], self.sz[rootY]\n            if szX < szY:\n                self.sz[rootY] += szX\n                self.rt[rootX] = rootY\n            else:\n                self.sz[rootX] += szY\n                self.rt[rootY] = rootX\n                \n    def cc(self):\n        return self.ccCt\n\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        ds = DS(n)\n        edgeCt = 0\n        for node in range(n):\n            l, r = leftChild[node], rightChild[node] \n            for c in (l, r):\n                if c != -1:\n                    edgeCt += 1\n                    ds.union(node, c)\n        return (n - 1 == edgeCt) and ds.cc() == 1\n    \n    \n", "class DSU:\n    def __init__(self, n):\n        self.p = [-1]*n\n        self.r = [0]*n\n    \n    def find(self, x):\n        if self.p[x] == -1:\n            return x\n        self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    \n    def union(self, x, y):\n        r_x = self.find(x)\n        r_y = self.find(y)\n        if r_x == r_y:\n            return False\n        if self.r[r_x] > self.r[r_y]:\n            self.p[r_y] = r_x\n        else:\n            self.p[r_x] = r_y\n            if self.r[r_x] == self.r[r_y]:\n                self.r[r_x]+=1\n        return True\n        \n        \nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        dsu = DSU(n)\n        \n        for i in range(n):\n            if leftChild[i]!=-1 and not dsu.union(i,leftChild[i]):\n                return False\n            if rightChild[i]!=-1 and not dsu.union(i,rightChild[i]):\n                return False\n        \n        return len([ 1 for i in range(n) if dsu.p[i]==-1 ]) == 1", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        def find(u):\n            if p[u] != u:\n                p[u] = find(p[u])\n            return p[u]\n        def union(u, v):\n            pU, pV = find(u), find(v)\n            if pU == pV: return False\n            rmin, rmax = (pU, pV) if rank[pU] < rank[pV] else (pV, pU)\n            p[rmin] = rmax\n            rank[rmax] += rank[rmin] == rank[rmax]\n            return True\n        \n        group = n\n        p, rank = list(range(n)), [0] * n\n        for i in range(n):\n            for j in [leftChild[i], rightChild[i]]:\n                if j > -1:\n                    if not union(i, j): return False\n                    group -= 1\n        return group == 1", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, l: List[int], r: List[int]) -> bool:\n        s = set()\n        \n        d = [0] * n\n        for i in l:\n            if i != -1:\n                d[i] = 1\n        for i in r:\n            if i != -1:\n                d[i] = 1\n        q = []\n        for i in range(n):\n            if not d[i]:\n                q.append(i)\n                break\n        if len(q) == 0:\n            return False\n        \n        while len(q):\n            t = q.pop()\n            s.add(t)\n            if l[t] in s or r[t] in s:\n                return False\n            if l[t] != -1:\n                q.append(l[t])\n            if r[t] != -1:\n                q.append(r[t])\n        \n        if len(s) == n:\n            return True\n        else:\n            return False", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        def find(x):\n            if x != par[x]:\n                par[x] = find(par[x])\n            return par[x]\n        def union(x, y):\n            x, y = list(map(find, [x, y]))\n            if x != y:\n                if rank[x] < rank[y]:\n                    x, y = y, x\n                par[y] = x\n                rank[x] += rank[x] == rank[y]\n                return True\n            else:\n                return False\n            \n        indegree = [0] * n\n        cnt = n\n        par = list(range(n))\n        rank = [0] * n\n        for parent, (l, r) in enumerate(zip(leftChild, rightChild)):\n            if l != -1:\n                indegree[l] += 1\n                if union(parent, l):\n                    cnt -= 1\n            if r != -1:\n                indegree[r] += 1\n            \n                if union(parent, r):\n                    cnt -= 1\n        return sum(indegree) == n - 1 and cnt == 1\n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n)) \n        self.count = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]    \n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px != py:\n            self.count -= 1\n            self.parent[px] = py    \n            \nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        inDegree = [0] * n\n        \n        uf = UnionFind(n)\n        for parent, nodes in enumerate(zip(leftChild, rightChild)):\n            l, r = nodes\n            if l != -1:\n                inDegree[l] += 1 \n                uf.union(l, parent)\n                \n            if r != -1:\n                inDegree[r] += 1 \n                uf.union(r, parent)\n        \n        return sum(inDegree) == n - 1 and uf.count == 1", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        def bfs(n):\n            if n not in self.remainingNodes:\n                self.isValid = False\n                return\n            self.remainingNodes.remove(n)\n            if len(nodes[n]) > 2:\n                self.isValid = False\n                return\n            for child in nodes[n]:\n                if child != -1 and child not in self.remainingNodes:\n                    self.isValid = False\n                    return\n                if child != -1:\n                    bfs(child)\n                    \n        def findRoot():\n            if len(leftChild) == 1:\n                if leftChild[0] == rightChild[0] == -1:\n                    return 0\n            for node in parents:\n                for parent in parents[node]:\n                    if parent not in parents:\n                        return parent            \n        \n        nodes = collections.defaultdict(list)\n        parents = collections.defaultdict(list)\n        \n        for i in range(len(leftChild)):\n            if leftChild[i] != -1:\n                nodes[i].append(leftChild[i])\n                parents[leftChild[i]].append(i)\n            if rightChild[i] != -1:\n                nodes[i].append(rightChild[i])\n                parents[rightChild[i]].append(i)\n        \n        self.isValid = True\n        self.remainingNodes = set(i for i in range(n))\n        root = findRoot()\n        bfs(root)\n        return self.isValid and not self.remainingNodes", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        rec = set()\n        log = {}\n        \n        def check(ind, tar):\n            if ind == -1: return False\n            if ind in log:\n                if log[ind] == tar: return True\n                return check(log[ind], tar)\n            return False\n        for ind, (i, j) in enumerate(zip(leftChild,rightChild)):\n            # print(ind, i, j)\n            if i != -1:\n                if i in rec: return False\n                rec.add(i)\n                log[i] = ind\n                if check(ind, i): return False\n            if j != -1:\n                if j in rec: return False\n                rec.add(j)\n                log[j] = ind\n                if check(ind, j): return False\n        if len(rec)+1 != n: return False\n        return True\n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        parents = [-1] * n\n        for p in range(n):\n            if leftChild[p] != -1:\n                if parents[leftChild[p]] != -1:\n                    return False\n                parents[leftChild[p]] = p\n            if rightChild[p] != -1:\n                if parents[rightChild[p]] != -1:\n                    return False\n                parents[rightChild[p]] = p\n        \n        found = False\n        for p in parents:\n            if p == -1:\n                if found:\n                    return False\n                found = True  \n        \n        visit = [0] * n\n        \n        def dfs(ix):\n            if ix == -1:\n                return True\n            if visit[ix] == 1:\n                return False\n            visit[ix] = 1\n            if not dfs(parents[ix]):\n                return False\n            visit[ix] = 2\n            return True\n        \n        for i in range(n):\n            if visit[i] == 2:\n                continue\n            if not dfs(i):\n                return False\n        return True", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.count = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        parent_x, parent_y = self.find(x), self.find(y)\n        if parent_x != parent_y:\n            self.parent[parent_x] = parent_y\n            self.count -= 1\n            \nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        parent = [0] * n\n        \n        uf = UnionFind(n)\n        \n        for prev, childs in enumerate(zip(leftChild, rightChild)):\n            l, r = childs\n            if l != -1:\n                parent[l] += 1\n                uf.union(l, prev)\n            if r != -1:\n                parent[r] += 1\n                uf.union(r, prev)\n        \n        return sum(parent) == n - 1 and uf.count == 1\n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        visited = set()\n        for i in range(n):\n            if leftChild[i] != -1:\n                visited.add(leftChild[i]) \n            if rightChild[i] != -1:\n                visited.add(rightChild[i]) \n        queue = list(set(list(range(n))) - visited)\n        \n        if len(queue) != 1:\n            return False\n        \n        visited = set()\n        while(queue):\n            curr = queue.copy()\n            queue = []\n            for c in curr:\n                if c in visited:\n                    return False\n                visited.add(c)\n                \n                if leftChild[c] != -1:\n                    queue.append(leftChild[c])\n                if rightChild[c] != -1:\n                    queue.append(rightChild[c])\n        return len(visited) == n", "\n\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        check_list = [0] * n\n        \n        for node in range(n):\n            left_node = leftChild[node]\n            right_node = rightChild[node]\n            if left_node >= 0:\n                check_list[left_node] += 1\n            if right_node >= 0:\n                check_list[right_node] += 1\n        \n        print(check_list)\n        ## check if it's separated tree or there's mutual arrow\n        zero_num = check_list.count(0)\n        if zero_num != 1:\n            return False\n        if max(check_list) > 1:\n            return False\n        \n        ## check if it constructs binary tree\n        root_node = check_list.index(0)\n        check_list = [0] * n\n        def check_binary_tree(node, check_list):\n            check_list[node] += 1\n            left_node = leftChild[node]\n            right_node = rightChild[node]\n            if left_node >= 0:\n                check_binary_tree(left_node, check_list)\n            if right_node >= 0:\n                check_binary_tree(right_node, check_list)\n        \n        check_binary_tree(root_node, check_list)\n        min_n, max_n = min(check_list), max(check_list)\n        print(check_list)\n        if not (min_n == 1 and max_n == 1):\n            return False\n        \n        return True\n", "class Node:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        all_nodes, root_nodes = self.gen_graph(leftChild, rightChild)\n        # print(root_nodes)\n        \n        if len(root_nodes) != 1: return False\n        \n        visited = {all_nodes[root_nodes[0]]}\n        \n        def dfs(node):\n            if node.left and node.left in visited:\n                return False\n            if node.right and node.right in visited:\n                return False\n            \n            if node.left:\n                visited.add(node.left)\n                if not dfs(node.left): return False\n            \n            if node.right:\n                visited.add(node.right)\n                if not dfs(node.right): return False\n            \n            return True\n        \n        if not dfs(all_nodes[root_nodes[0]]): return False\n        # print(visited)\n        for i in range(len(leftChild)):\n            if all_nodes[i] not in visited: return False\n        \n        return True\n    \n    def gen_graph(self, left_child, right_child):\n        nodes = defaultdict(lambda: Node())\n        indegrees = defaultdict(int)\n        \n        for i in range(len(left_child)):\n            node = nodes[i]\n            if left_child[i] != -1:\n                node.left = nodes[left_child[i]]\n                indegrees[left_child[i]] += 1\n            \n            if right_child[i] != -1:\n                node.right = nodes[right_child[i]]\n                indegrees[right_child[i]] += 1\n        \n        root_nodes = [i for i in range(len(left_child)) if indegrees[i] == 0]\n        return nodes, root_nodes", "class Dsu:\n    def __init__(self,n):\n        self.p=[x for x in range(n)]\n        self.r=[0 for x in range(n)]\n    def find(self,x):\n        if self.p[x]!=x:\n            self.p[x]=self.find(self.p[x])\n        return self.p[x]\n    def union(self,x,y):\n        xx,yy=self.find(x),self.find(y)\n        if xx==yy:\n            return True\n        if self.r[xx]>self.r[yy]:\n            self.p[yy]=xx\n        elif self.r[yy]>self.r[xx]:\n            self.p[xx]=yy\n        else:\n            self.r[xx]+=1\n            self.p[yy]=xx\n        return False\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        n=len(leftChild)\n        x=0\n        y=0\n        z=0\n        f=[0 for i in range(n)]\n        h=Dsu(n)\n        for i in range(n):\n            if leftChild[i]!=-1:\n                f[leftChild[i]]+=1\n                h.union(i,leftChild[i])\n            if rightChild[i]!=-1:\n                f[rightChild[i]]+=1\n                h.union(i,rightChild[i])\n        for i,ii in enumerate(f):\n            if ii>1:\n                x+=1\n            if h.find(i)==i:\n                y+=1\n            if ii==0:\n                z+=1\n        if y!=1:\n            return False\n        elif z!=1:\n            return False\n        elif x>0:\n            return False\n        else:\n            return True\n        \n            \n            \n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        def find(u):\n            if p[u] != u:\n                p[u] = find(p[u])\n            return p[u]\n        def union(u, v):\n            pU, pV = find(u), find(v)\n            if pU == pV: return False\n            rmin, rmax = (pU, pV) if rank[pU] < rank[pV] else (pV, pU)\n            p[rmin] = rmax\n            rank[rmax] += rank[rmin] == rank[rmax]\n            return True\n        \n        graph = defaultdict(list)\n        for i in range(n):\n            l, r = leftChild[i], rightChild[i]\n            graph[i] += [l] if l > -1 else []\n            graph[i] += [r] if r > -1 else []\n\n        group = n\n        p, rank = list(range(n)), [0] * n\n        for i in range(n):\n            for j in graph[i]:\n                if not union(i, j): return False\n                group -= 1\n        return group == 1", "class UnionFind:\n    def __init__(self,n):\n        self.parents = list(range(n ))\n        self.count = n\n        \n    def find(self,x):\n        if self.parents[x] != x:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n    \n    def union(self,x,y):\n        px = self.find(x)\n        py = self.find(y)\n        if px != py:\n            self.count -= 1\n            self.parents[px] = py\n            \nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        uf = UnionFind(n)\n        indegree = [0] * n\n        \n        for parent,node in enumerate(zip(leftChild,rightChild)):\n            l,r = node\n            if l != -1:\n                indegree[l] += 1\n                uf.union(l,parent)\n                \n            if r != -1:\n                indegree[r] += 1\n                uf.union(r,parent)\n                \n        return sum(indegree) == n - 1 and uf.count == 1            ", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        allChildren = [n for n in leftChild + rightChild if n != -1]\n        allChildrenSet = set(allChildren)\n        if not(len(allChildren) == len(allChildrenSet)):\n            return False\n        \n        root = [i for i in range(n) if i not in allChildrenSet]\n        if len(root) != 1:\n            return False\n        \n        root = root[0]\n        stk = [root]\n        while stk:\n            n = stk.pop()\n            allChildrenSet.discard(n)\n            stk.extend([c for c in [leftChild[n], rightChild[n]] if c != -1])\n        \n        return not allChildrenSet", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.count = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        parent_x, parent_y = self.find(x), self.find(y)\n        if parent_x != parent_y:\n            self.parent[parent_x] = parent_y\n            self.count -= 1\n            \nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        parent = [0] * n\n        \n        uf = UnionFind(n)\n        \n        for prev, childs in enumerate(zip(leftChild, rightChild)):\n            l, r = childs\n            if l != -1:\n                parent[l] += 1\n                uf.union(l, prev)\n            if r != -1:\n                parent[r] += 1\n                uf.union(r, prev)\n        \n        return sum(parent) == n-1 and uf.count == 1\n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n)) \n        self.count = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]    \n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px != py:\n            self.count -= 1\n            self.parent[px] = py    \n            \nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        inDegree = [0] * n\n        \n        uf = UnionFind(n)\n        for parent, nodes in enumerate(zip(leftChild, rightChild)):\n            l, r = nodes\n            if l != -1:\n                inDegree[l] += 1 \n                uf.union(l, parent)\n                \n            if r != -1:\n                inDegree[r] += 1 \n                uf.union(r, parent)\n        \n        return sum(inDegree) == n - 1 and uf.count == 1\n", "class UnionFind:\n    def __init__(self, n):\n        self.reps = [i for i in range(n)]\n        self.size = n\n    \n    def find(self, x):\n        while x != self.reps[x]:\n            self.reps[x] = self.reps[self.reps[x]]\n            x = self.reps[x]\n        return x\n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        \n        if x_root == y_root:\n            return\n        self.size -= 1\n        self.reps[x] = y_root\n\n\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        p2c = collections.defaultdict(set)\n        c2p = collections.defaultdict(set)\n        uf = UnionFind(n)\n        for i, (l, r) in enumerate(zip(leftChild, rightChild)):\n            if l != -1: \n                p2c[i].add(l)\n                c2p[l].add(i)\n                uf.union(i, l)\n\n                if i in p2c[l]: return False\n            if r != -1: \n                p2c[i].add(r)\n                c2p[r].add(i)\n                uf.union(i, r)\n                if i in p2c[r]: return False\n                \n        for i in range(n):\n            if len(c2p[i]) > 1: return False\n\n            \n\n        return uf.size == 1", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        #  directed graph\n        # each node except root has exactly 1 indegree\n        # each node can have only 0~2 children\n        \n        graph = collections.defaultdict(list)\n        indegree = {nodeNum : 0 for nodeNum in range(n)}\n        \n        for nodeNum in range(n):\n            left = leftChild[nodeNum]\n            right = rightChild[nodeNum]\n            \n            graph[nodeNum] = []\n            if left != -1:\n                graph[nodeNum].append(left)\n                indegree[left] += 1\n            if right != -1:\n                graph[nodeNum].append(right)\n                indegree[right] += 1\n                \n        \n        # print(indegree)\n        zeroIndegrees = collections.deque([])\n        singleIndegrees = 0\n        \n        for nodeNum, indegrees in list(indegree.items()):\n            if indegrees == 0:\n                zeroIndegrees.append(nodeNum)\n            elif indegrees == 1:\n                singleIndegrees += 1\n            else:\n                return False\n            \n        if len(zeroIndegrees) != 1:\n            return False\n        \n        if len(zeroIndegrees) + singleIndegrees != n:\n            return False\n        \n        print(zeroIndegrees)\n        topological_sort = []\n        while zeroIndegrees:\n            nodeNum = zeroIndegrees.popleft()\n            topological_sort.append(nodeNum)\n            \n            if nodeNum in graph:\n                for child in graph[nodeNum]:\n                    indegree[child] -= 1\n                    if indegree[child] == 0:\n                        zeroIndegrees.append(child)\n                        \n        if len(topological_sort) == n:\n            return True\n        return False\n    \n# 4\n# [1,0,3,-1]\n# [-1,-1,-1,-1]\n\n# 0               2\n#     1         3\n        \n", "class Solution:\n    def validateBinaryTreeNodes(self, N: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        inNodes, outNodes = collections.defaultdict(set), collections.defaultdict(set)\n        \n        for n, c in enumerate(leftChild):\n            if c != -1:\n                outNodes[n].add(c)\n                inNodes[c].add(n)\n        \n        for n, c in enumerate(rightChild):\n            if c != -1:\n                outNodes[n].add(c)\n                inNodes[c].add(n)\n    \n        \n        # 1. all in degrees must be <= 1 and only one should have in degree 0\n        zeroInDegree = 0\n        root = None\n        for i in range(N):\n            if len(inNodes[i]) > 1:\n                return False\n            if not inNodes[i]:\n                root = i\n                zeroInDegree += 1\n        \n        if zeroInDegree != 1:\n            return False\n        \n        # 2. cycle detection        \n        def hasCycle(n, visited):\n            visited.add(n)\n            for nb in outNodes[n]:\n                if nb in visited:\n                    return True\n                if hasCycle(nb, visited):\n                    return True\n            return False\n                \n        visited = set()\n        if hasCycle(root, visited):\n            return False\n        if len(visited) != N:\n            return False\n        \n        return True\n        \n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        # all nodes shoud not have more than 1 in degrees\n        indegrees = [0]*n\n        root = -1\n        for i in range(n):\n            left = leftChild[i]\n            if left != -1:\n                indegrees[left] += 1\n                if indegrees[left] > 1:\n                    return False\n                \n            right = rightChild[i]\n            if right != -1:\n                indegrees[right] += 1\n                if indegrees[right] > 1:\n                    return False\n        \n        # find the root with indegree == 0\n        # if no root or multiple roots exist, return False\n        for i in range(n):\n            if indegrees[i] == 0:\n                if root == -1:\n                    root = i\n                else:\n                    return False\n                \n        if root == -1:\n            return False\n        \n        # start from root, check node count == n\n        def count(node):\n            if node == -1:\n                return 0\n            return 1 + count(leftChild[node]) + count(rightChild[node])\n        \n        return count(root) == n\n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        indegree = [0 for _ in range(n)]\n        roots = set(range(n))\n        children = set()\n        for left, right in zip(leftChild, rightChild):\n            if left != -1:\n                indegree[left] += 1\n                if left in roots:\n                    roots.remove(left)\n                    children.add(left)\n                if indegree[left] > 1:\n                    return False\n            if right != -1:\n                indegree[right] += 1\n                if right in roots:\n                    roots.remove(right)\n                    children.add(right)\n                if indegree[right] > 1:\n                    return False\n                \n        if len(roots) != 1:\n            return False\n        \n        while roots:\n            new_root = next(iter(roots))\n            roots.remove(new_root)\n            if leftChild[new_root] != -1:\n                children.remove(leftChild[new_root])\n                roots.add(leftChild[new_root])\n            if rightChild[new_root] != -1:\n                children.remove(rightChild[new_root])\n                roots.add(rightChild[new_root])\n        \n        return not children\n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        \n        indict = defaultdict(list)\n        outdict = defaultdict(list)\n        \n        for i in range(n):\n            if leftChild[i] != -1:\n                outdict[i].append(leftChild[i])\n                indict[leftChild[i]].append(i)\n            if rightChild[i] != -1:\n                outdict[i].append(rightChild[i])\n                indict[rightChild[i]].append(i)\n                \n        #print(indict, outdict)\n        rootcount = []\n        for nownode in range(n):\n            \n            innodelist = indict[nownode]\n            if len(innodelist) == 0:\n                rootcount.append(nownode)\n            if len(innodelist) > 1:\n                return False\n            for innode in innodelist:\n                if innode in outdict[nownode]:\n                    return False\n        \n        #print(rootcount)\n        if len(rootcount) != 1:\n            return False\n        \n        root = rootcount[0]\n        \n        ans = []\n        visited = {}\n        def traverse(node):\n            \n            if node == -1:\n                return True\n            \n            if node in visited:\n                return False\n            \n            visited[node] = 1\n            \n            resleft = traverse(leftChild[node])\n            \n            ans.append(node)\n            resright = traverse(rightChild[node])\n            \n            if resleft == False or resright == False:\n                return False\n            return True\n        \n        res = traverse(root)\n        \n        #print(ans)\n        if len(ans) == n and res == True:\n            return True\n        \n        return False\n        \n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        ingress = [0] * n\n        g = defaultdict(list)\n        \n        # construct a graph and ingress \n        for i in range(n):\n            if leftChild[i] != -1:\n                ingress[leftChild[i]] += 1\n                g[i].append(leftChild[i])\n            \n            if rightChild[i] != -1:\n                ingress[rightChild[i]] += 1\n                g[i].append(rightChild[i])\n            \n        # check only one root or two ingress\n        if ingress.count(0) > 1 or max(ingress) > 1:\n            return False\n        \n        # check any cycle\n        def dfs(node):\n            \n            visited.add(node)\n            visiting.add(node)\n            \n            for neigh in g[node]:\n                \n                if neigh not in visited and dfs(neigh):\n                    return True\n                elif neigh in visiting:\n                    return True\n            \n            visiting.remove(node)\n            return False\n        \n        visited = set() \n        visiting = set() \n        \n        for i in range(n):\n            if i not in visited:\n                if dfs(i):\n                    return False # cycle detected\n                \n        return True", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        \n        parent = {x:0 for x in range(n)}\n        child = [0]*n\n        val = {0:0,1:0}\n        for i in range(n):\n            if leftChild[i]!=-1:\n                parent[leftChild[i]]+=1\n                child[i]+=1\n                if parent[leftChild[i]]>1:\n                    return False\n                \n            if rightChild[i]!=-1:\n                parent[rightChild[i]]+=1\n                child[i]+=1\n                if parent[rightChild[i]]>1:\n                    return False\n                \n        self.ans = 1\n        def dfs(node):\n            if leftChild[node]!=-1:\n                self.ans+=1\n                dfs(leftChild[node])\n            if rightChild[node]!=-1:\n                self.ans+=1\n                dfs(rightChild[node])\n        for i in range(n):\n            val[parent[i]]+=1\n            if parent[i]==0:\n                dfs(i)\n           \n       \n        \n        if self.ans==n:\n            return True\n        \n        return False\n            \n            \n        \n                \n        \n            \n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        # find root and do dfs\n        # look for cycle or things not visited from the root\n        visited = [False] * n\n        cycle = False\n        \n        def dfs(root):\n            nonlocal cycle\n            #print(root, visited, cycle)\n            if root == -1:\n                return\n            \n            if not visited[root]:\n                visited[root] = True\n                dfs(leftChild[root])\n                dfs(rightChild[root])\n            else:\n                cycle = True\n                \n            \n                   \n        def find_root():\n            in_degree = {}\n            \n            for i in range(n):\n                in_degree[i] = 0\n            # add -1 so u wont skip it\n            in_degree[-1] = 0    \n            for i in range(n):\n                in_degree[leftChild[i]] += 1\n                in_degree[rightChild[i]] += 1\n                \n            for k,v in list(in_degree.items()):\n                if v == 0:\n                    return k\n                \n        root = find_root()\n        #print(root)\n        if root == None:\n            return False\n        dfs(root)\n        print(cycle)\n        if cycle:\n            #print('cycle')\n            return False\n        \n        #print(visited)\n        return all(visited)\n        \n        \n                \n            \n            \n        \n\n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        children = set()\n        children.add(0)\n        for i in range(n):\n            l = [leftChild[i], rightChild[i]]\n            \n            for c in l:\n                if c != -1:\n                    if i in children:\n                        if c in children:\n                            return False\n                        else:\n                            children.add(c)\n                    else:\n                        if c in children:\n                            children.add(i)\n                        else:\n                            return False\n                \n        \n        \n        return len(children) == n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        parent = list(range(n))\n        degree = [0]*n\n        count = n\n        \n        def find(x):\n            if parent[x]!=x:\n                parent[x]=find(parent[x])\n            return parent[x]\n        \n        def union(x,y):\n            nonlocal count, parent\n            xp, yp = find(x), find(y)\n            if xp!=yp:\n                count-=1\n                parent[yp]=xp\n                \n        for par, nodes in enumerate(zip(leftChild,rightChild)):\n            l,r = nodes\n            if l!=-1:\n                degree[l]+=1\n                union(par, l)\n            if r!=-1:\n                degree[r]+=1\n                union(par, r)\n                \n        return True if sum(degree)==n-1 and count==1 else False", "class Solution:\n    def validateBinaryTreeNodes(self, n, left, right):\n        roots={*range(n)}\n        for x in left+right:\n            if x==-1:\n                continue\n            if x not in roots:\n                return False\n            roots.discard(x)\n        if len(roots)!=1:\n            return False\n        root=roots.pop()\n        stk=[root]\n        k=0\n        while stk:\n            node=stk.pop()\n            k+=1\n            l,r=left[node],right[node]\n            if l!=-1:\n                stk.append(l)\n            if r!=-1:\n                stk.append(r)\n        return k==n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        # find root and do dfs\n        # look for cycle or things not visited from the root\n        visited = [False] * n\n        cycle = False\n        \n        def dfs(root):\n            nonlocal cycle\n            #print(root, visited, cycle)\n            if root == -1:\n                return\n            \n            if not visited[root]:\n                visited[root] = True\n                dfs(leftChild[root])\n                dfs(rightChild[root])\n            else:\n                print('cycle')\n                cycle = True\n                \n            \n                   \n        def find_root():\n            in_degree = {}\n            \n            for i in range(n):\n                in_degree[i] = 0\n            # add -1 so u wont skip it\n            in_degree[-1] = 0    \n            for i in range(n):\n                in_degree[leftChild[i]] += 1\n                in_degree[rightChild[i]] += 1\n                \n            for k,v in list(in_degree.items()):\n                if v == 0:\n                    return k\n                \n        root = find_root()\n        print(root)\n        if root == None:\n            return False\n        dfs(root)\n        print(cycle)\n        if cycle:\n            print('cycle')\n            return False\n        \n        print(visited)\n        return all(visited)\n        \n        \n                \n            \n            \n        \n\n", "\n\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        check_list = [0] * n\n        \n        for node in range(n):\n            left_node = leftChild[node]\n            right_node = rightChild[node]\n            if left_node >= 0:\n                check_list[left_node] += 1\n            if right_node >= 0:\n                check_list[right_node] += 1\n        \n        # print(check_list)\n        ## check if it's separated tree or there's mutual arrow\n        zero_num = check_list.count(0)\n        if zero_num != 1:\n            return False\n        if max(check_list) > 1:\n            return False\n        \n        ## check if it constructs binary tree\n        root_node = check_list.index(0)\n        check_list = [0] * n\n        def check_binary_tree(node, check_list):\n            check_list[node] += 1\n            left_node = leftChild[node]\n            right_node = rightChild[node]\n            if left_node >= 0:\n                check_binary_tree(left_node, check_list)\n            if right_node >= 0:\n                check_binary_tree(right_node, check_list)\n        \n        check_binary_tree(root_node, check_list)\n        min_n, max_n = min(check_list), max(check_list)\n        # print(check_list)\n        if not (min_n == 1 and max_n == 1):\n            return False\n        \n        return True\n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        g = defaultdict(list)\n        root = set(range(n))\n        \n        for i, (l, r) in enumerate(zip(leftChild, rightChild)):\n            g[i] += [l, r]\n            root.discard(l)\n            root.discard(r)\n        \n        if len(root) != 1:\n            return False\n        \n        seen = set()\n        \n        def trav(cur):\n            if cur in seen:\n                return False\n            if not g[cur]:\n                return True\n            seen.add(cur)\n            \n            if len(g[cur]) > 2:\n                return False\n            \n            return all(trav(nxt) for nxt in g[cur])\n        \n        if not trav(root.pop()):\n            return False\n        \n        return len(seen) == n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        def findRoot():\n            for l, r in zip(leftChild, rightChild):\n                if l != -1:\n                    inDegree[l] += 1\n                if r != -1:\n                    inDegree[r] += 1\n                \n            for i, count in enumerate(inDegree):\n                if count == 0:\n                    return i\n            \n            return -1\n            \n        def dfs(i):\n            l = leftChild[i]\n            r = rightChild[i]\n            \n            if visited[i] or (l != -1 and visited[l]) or (r != -1 and visited[r]):\n                return False\n            \n            visited[i] = True\n            \n            if l == -1 and r == -1:\n                return True\n            elif l == -1:\n                return dfs(r)\n            elif r == -1:\n                return dfs(l)\n            else:\n                return dfs(l) and dfs(r)\n            \n            \n        inDegree = [0 for _ in range(n)]\n        visited = [False for _ in range(n)]\n        \n        root = findRoot()\n        if root == -1:\n            return False\n        \n        ok = dfs(root)\n        if not ok:\n            return False\n        \n        return all(visited)\n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        graph = collections.defaultdict(list)\n        edges = 0\n        indegree = [0]*n\n        for i in range(n):\n            if leftChild[i] >= 0:\n                graph[i].append(leftChild[i])\n                indegree[leftChild[i]] += 1\n                edges += 1\n            if rightChild[i] >= 0:\n                graph[i].append(rightChild[i])\n                indegree[rightChild[i]] += 1\n                edges += 1\n        \n        if edges != n-1:\n            return False\n        q = []\n        for i in range(n):\n            if indegree[i] == 0:\n                q.append(i)\n        if len(q) != 1:\n            return False\n        \n        while q:\n            l = len(q)\n            for _ in range(l):\n                cur = q.pop()\n                n -= 1\n                for nei in graph[cur]:\n                    indegree[nei] -= 1\n                    if indegree[nei] == 0:\n                        q.append(nei)\n\n        \n        return n == 0\n", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        def find(u):\n            if p[u] != u:\n                p[u] = find(p[u])\n            return p[u]\n        def union(u, v):\n            pU, pV = find(u), find(v)\n            if pU == pV: return False\n            rmin, rmax = (pU, pV) if rank[pU] < rank[pV] else (pV, pU)\n            p[rmin] = rmax\n            rank[rmax] += rank[rmin] == rank[rmax]\n            return True\n        \n        incoming, outgoing = list(range(n)), defaultdict(list)\n        for i in range(n):\n            l, r = leftChild[i], rightChild[i]\n            # No cycle allowed\n            if l == i or r == i: return False\n            if l > -1:\n                # Every pair of nodes has only one edge: one-way not two-way edge\n                if i in outgoing[l]: return False\n                outgoing[i].append(l)\n                if incoming[l] != l: return False\n                incoming[l] = i\n            if r > -1:\n                if i in outgoing[r]: return False\n                outgoing[i].append(r)\n                if incoming[r] != r: return False\n                incoming[r] = i\n        # Only one node has no incoming edge, others have only one incoming node\n        # if sum([1 for i in range(n) if incoming[i] == i]) > 1: return False\n        group = n\n        p, rank = list(range(n)), [0] * n\n        for i in range(n):\n            for j in outgoing[i]:\n                if not union(i, j): return False\n                group -= 1\n        return group == 1", "class UnionFind:\n    def __init__(self,n):\n        self.parents = list(range(n))\n        self.count = n\n        \n    def find(self,x):\n        if self.parents[x] != x:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n    \n    def union(self,x,y):\n        px = self.find(x)\n        py = self.find(y)\n        \n        if px != py:\n            self.count -= 1\n            self.parents[px] = py\n            \n            \nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        uf = UnionFind(n)\n        indegree = [0] * n\n        \n        for parent,node in enumerate(zip(leftChild,rightChild)):\n            l,r = node\n            if l != -1:\n                indegree[l] += 1\n                uf.union(l,parent)\n                \n            if r != -1:\n                indegree[r] += 1\n                uf.union(r,parent)\n                \n        return sum(indegree) == n - 1 and uf.count == 1", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        uf = {}\n        def find(x):\n            uf.setdefault(x, x)\n            if uf[x] != x: uf[x] = find(uf[x])\n            return uf[x]\n        def union(x, y):\n            uf[find(x)] = find(y)\n        \n        indegree, outdegree = Counter(), Counter()\n        root_cnt = 0\n        \n        for i, node in enumerate(leftChild):\n            if node == -1: continue\n            indegree[node] += 1\n            outdegree[i] += 1\n            union(i, node)\n        for i, node in enumerate(rightChild):\n            if node == -1: continue\n            indegree[node] += 1\n            outdegree[i] += 1\n            union(i, node)\n        \n        for i in range(n):\n            if indegree[i] == 0:\n                root_cnt += 1\n            elif indegree[i] != 1:\n                return False\n            \n            if outdegree[i] > 2:\n                return False\n    \n        return root_cnt == 1 and len(set(map(find, list(range(n)))))==1\n    \n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n)) \n        self.count = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]    \n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px != py:\n            self.count -= 1\n            self.parent[px] = py \n            \nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        inDegree = [0] * n\n        \n        uf = UnionFind(n)\n        for parent, nodes in enumerate(zip(leftChild, rightChild)):\n            l, r = nodes\n            if l != -1:\n                inDegree[l] += 1 \n                uf.union(l, parent)\n                \n            if r != -1:\n                inDegree[r] += 1 \n                uf.union(r, parent)\n        \n        return sum(inDegree) == n - 1 and uf.count == 1", "class Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        parents = [idx for idx in range(n)]\n        \n        def find(idx):\n            original_idx = idx\n            height = 0\n            while parents[idx] != idx:\n                height += 1\n                idx = parents[idx]\n            parents[original_idx] = idx\n            return idx, height\n        \n        # Returns false if the two elements are already in the same group\n        def union(idx1, idx2):\n            parent1, _ = find(idx1)\n            parent2, _ = find(idx2)\n            if parent1 == parent2:\n                return False\n            parents[parent1] = parent2\n            return True\n        # [1, 3, 3, 3]\n        for idx1, idx2 in enumerate(leftChild):\n            if idx2 == -1:\n                continue\n            if not union(idx1, idx2):\n                return False\n            \n        for idx1, idx2 in enumerate(rightChild):\n            if idx2 == -1:\n                continue\n            if not union(idx1, idx2):\n                return False\n\n        \n        group, _ = find(0)\n        for idx in range(n):\n            if find(idx)[0] != group:\n                return False\n        return True", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n)) \n        self.count = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]    \n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px != py:\n            self.count -= 1\n            self.parent[px] = py\n\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        inDegree = [0] * n\n        \n        uf = UnionFind(n)\n        for parent, nodes in enumerate(zip(leftChild, rightChild)):\n            l, r = nodes\n            if l != -1:\n                inDegree[l] += 1 \n                uf.union(l, parent)\n                \n            if r != -1:\n                inDegree[r] += 1 \n                uf.union(r, parent)\n        print(inDegree, uf.count)\n        return sum(inDegree) == n - 1 and uf.count == 1", "from collections import deque\nclass Solution:\n    def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        q = deque()\n        visited = [0 for _ in range(len(leftChild))]\n        root = 0\n        store = set([i for i in range(len(leftChild))])\n        for i in range(len(leftChild)):\n            left = leftChild[i]\n            right = rightChild[i]\n            store.discard(left)\n            store.discard(right)\n        print(store)\n        for i in store:\n            root = i\n            break\n        q.append(root)\n        while len(q)>0:\n            element = q.popleft()\n            visited[element] = 1\n            left = leftChild[element]\n            right = rightChild[element]\n            if left != -1:\n                if left in q or visited[left] == 1:\n                    return False\n                else:\n                    q.append(left)\n            if right != -1:\n                if right in q or visited[right] == 1:\n                    return False\n                else:\n                    q.append(right)\n        for i in visited:\n            if i == 0:\n                return False\n        return True\n"]
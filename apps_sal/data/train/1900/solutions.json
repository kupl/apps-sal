["class Solution:\n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if not root:\n             return 0\n         s=1\n         a=[[root,1]]\n         while 1:\n             b=[]\n             for p in a:\n                 if p[0].left:\n                     b.append([p[0].left,2*p[1]-1])\n                 if p[0].right:\n                     b.append([p[0].right,2*p[1]])\n             a=b\n             if a:\n                 s=max(s,a[-1][1]-a[0][1]+1)\n             else:\n                 break\n         return s", "class Solution:\n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         \n         widths = []\n         \n         def traverse(root, height, pos):\n             nonlocal widths\n             if root is None:\n                 return\n             if len(widths) < (height + 1):\n                 widths.append([height, pos, pos])\n             else:\n                 if widths[height][1] > pos:\n                     widths[height][1] = pos\n                 if widths[height][2] < pos:\n                     widths[height][2] = pos\n             if pos == 0:\n                 traverse(root.left, 1, -1)\n                 traverse(root.right, 1, 1)\n             else:\n                 traverse(root.left, height + 1, (2 * pos - 1) if pos > 0 else (2 * pos))\n                 traverse(root.right, height + 1, (2 * pos) if pos > 0 else (2 * pos + 1))\n             \n         traverse(root, 0, 0)\n         ret = 0\n         for width in widths:\n             ret = max(ret, (width[2] - width[1]) if width[2] * width[1] < 0 else (width[2] - width[1] + 1))\n         return ret\n         \n", "class Wrapper:\n     def __init__(self, node, val=None):\n         self.node = node\n         self.val = val\n     \n     def isInt(self):\n         return self.val is not None\n     \n     def getValue(self):\n         if self.node:\n             return self.node\n         \n         return self.val\n     \n     def addValue(self, val):\n         self.val += val\n \n class Solution:\n     def testNode(self, node, newStack):\n         acc = 0\n         \n         if node:\n             newStack.append(Wrapper(node))\n             acc += 1\n         elif len(newStack):\n             acc += 1\n             if newStack[-1].isInt():\n                 newStack[-1].addValue(1)\n             else:\n                 newStack.append(Wrapper(None, 1))\n                 \n         return acc\n     \n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if not root:\n             return 0\n         \n         stack = [Wrapper(root)] \n         res = 1\n         \n         while len(stack):\n             newStack = []\n             acc = 0\n             \n             for node in stack:\n                 if node.isInt():\n                     if len(newStack):\n                         if newStack[-1].isInt():\n                             newStack[-1].addValue(2 * node.getValue())\n                         else:\n                             newStack.append(Wrapper(None, 2 * node.getValue()))\n \n                         acc += 2 * node.getValue()\n                 else:\n                     acc += self.testNode(node.getValue().left, newStack)\n                     acc += self.testNode(node.getValue().right, newStack)\n                 \n             stack = newStack\n             if len(newStack) and newStack[-1].isInt():\n                 acc -= stack.pop().getValue()\n             res = max(res, acc)\n                     \n         return res", "class Solution:\n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if root is None: return 0;\n         \n         q = [(root, 0)];\n         left = 0;\n         right = 0;\n         res = 1;\n         \n         while q:\n             qLength = len(q);\n             \n             for i in range(qLength):\n                 node, index = q.pop(0);\n                 if i == 0:\n                     left = index;\n                 if i == qLength - 1:\n                     right = index;\n                 \n                 if node.left is not None:\n                     q.append((node.left, (2*index)+1));\n                 if node.right is not None:\n                     q.append((node.right, (2*index)+2));\n                     \n             res = max(res, right-left+1);\n         \n         return res;\n", "class Solution:\n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         queue = [(root, 0, 0)]\n         cur_depth = left = ans = 0\n         for node, depth, pos in queue:\n             if node:\n                 queue.append((node.left, depth+1, pos*2))\n                 queue.append((node.right, depth+1, pos*2 + 1))\n                 if cur_depth != depth:\n                     cur_depth = depth\n                     left = pos\n                 ans = max(pos - left + 1, ans)\n \n         return ans", "class Solution:\n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         # perform iterative level traversal with null also accounted\n         # Notice each node can be represented with depth, position\n         # root.left = d+1, pos*2; root.right = d+1, pos*2-1\n         if not root: return 0\n         queue = collections.deque([[root, 0]])\n         ret = 0\n         while queue:\n             size = len(queue)\n             level = []\n             for _ in range(size):\n                 node, pos = queue.pop()\n                 level.append(pos)\n                 if node.left: queue.appendleft([node.left, pos*2])\n                 if node.right: queue.appendleft([node.right, 1 + pos*2])\n             print(level)        \n             ret = max(ret, level[-1] - level[0] + 1)        \n         return ret    \n                    \n", "class Solution:\n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         \n         def get_max_width(root, width, level, d):\n             if not root:\n                 return\n             \n             d[level].append(width)\n             # I want the nodes of a level numbered from 0.. 2^n-1\n             get_max_width(root.left, 2*width, level + 1, d)\n             get_max_width(root.right, 2*width + 1, level + 1, d)\n         \n         from collections import defaultdict\n         d = defaultdict(list)\n         \n         get_max_width(root, 0, 0, d)\n         \n         print(d)\n         max_width = 0\n         for level, elements in list(d.items()):\n             if elements: \n                 # if the len of elements is 1 i will still get width 1\n                 elements.sort()\n                 curr_width = elements[-1] - elements[0] + 1\n                 max_width = max(max_width, curr_width)\n         \n         return max_width\n             \n", "class Solution:\n     \n     \n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if not root: return 0\n \n         maxlen=1\n         start=1\n         end=1\n         tlen=1\n         l=[[root,1]]\n         \n         while tlen:\n             llen=tlen\n             tlen=0\n             while llen:\n                 cur=l.pop(0)\n                 llen-=1\n                 if cur[0]:\n                     l.append([cur[0].left,2*cur[1]-1])\n                     l.append([cur[0].right,2*cur[1]])\n                     tlen+=2\n \n             if len(l)>0:\n                 for item in reversed(l):\n                     if item[0]:\n                         end=item[1]\n                         break\n                 if end != item[1]: return maxlen\n                 \n                 for item in l:\n                     if item[0]:\n                         start=item[1]\n                         break;\n                 \n                 end = end - start + 1\n                 if(end > maxlen):  maxlen=end\n                 \n                 start=end=-1;\n                 \n         return maxlen", "class Solution:\n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         queue = [(root, 0, 0)]\n         cur_depth = left = ans = 0\n         for node, depth, pos in queue:\n             if node:\n                 queue.append((node.left, depth + 1, 2*pos))\n                 queue.append((node.right, depth + 1, 2*pos + 1))\n                 if cur_depth != depth:\n                     cur_depth = depth\n                     left = pos\n                 ans = max(pos - left + 1, ans)\n         return ans\n", "class Solution:\n     \n     \n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if not root: return 0\n \n         maxlen=1\n         start=1\n         end=1\n         tlen=1\n         l=[[root,1]]\n         \n         while tlen:\n             llen=tlen\n             tlen=0\n             while llen:\n                 cur=l.pop(0)\n                 llen-=1\n                 if cur[0]:\n                     l.append([cur[0].left,2*cur[1]-1])\n                     l.append([cur[0].right,2*cur[1]])\n                     tlen+=2\n \n             if len(l)>0:\n                 for item in reversed(l):\n                     if item[0]:\n                         end=item[1]\n                         break\n                 if end != item[1]: return maxlen\n                 \n                 for item in l:\n                     if item[0]:\n                         start=item[1]\n                         break;\n                 \n                 end = end - start + 1\n                 if(end > maxlen):  maxlen=end\n                 \n                 start=end=-1\n                 \n         return maxlen", "class Solution:\n     def isInt(self, e):\n         return type(e).__name__ == 'int'\n     \n     def testNode(self, node, newStack):\n         acc = 0\n         \n         if node:\n             newStack.append(node)\n             acc += 1\n         elif len(newStack):\n             acc += 1\n             if self.isInt(newStack[-1]):\n                 newStack[-1] += 1\n             else:\n                 newStack.append(1)\n                 \n         return acc\n     \n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if not root:\n             return 0\n         \n         stack = [root] \n         res = 1\n         \n         while len(stack):\n             newStack = []\n             acc = 0\n             \n             for node in stack:\n                 if self.isInt(node):\n                     if len(newStack):\n                         if self.isInt(newStack[-1]):\n                             newStack[-1] += 2 * node\n                         else:\n                             newStack.append(2 * node)\n \n                         acc += 2 * node\n                 else:\n                     acc += self.testNode(node.left, newStack)\n                     acc += self.testNode(node.right, newStack)\n                 \n             stack = newStack\n             if len(newStack) and self.isInt(newStack[-1]):\n                 acc -= stack.pop()\n             res = max(res, acc)\n                     \n         return res", "class Solution:\n     def widthOfBinaryTree(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         \n         table = {}\n         \n         stack = [(root, [])]\n         while stack:\n             node, path = stack.pop()\n             if not node:\n                 continue\n             \n             table.setdefault(len(path), []).append(path)\n             \n             stack.append((node.left, path + ['0']))\n             stack.append((node.right, path + ['1']))\n             \n         \n         maxwidth = 0\n         for n in sorted(table):\n             paths = table[n]\n             if len(paths) < 1:\n                 continue\n             if len(paths) == 1:\n                 maxwidth = max(1, maxwidth)\n                 continue\n                 \n             values = list(map(lambda p: int(''.join(p), 2), paths))\n             width = max(values) - min(values) + 1\n             \n             maxwidth = max(maxwidth, width)\n             \n         return maxwidth"]
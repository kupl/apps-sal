["class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        freq = [0] * k\n        \n        for n in arr:\n            freq[n%k] += 1\n \n        if freq[0] % 2: return False\n        \n        for i in range(1, (k//2)+1):\n            if freq[i] != freq[k-i]: return False\n        \n        if k%2 is 0:\n            if freq[k//2]%2: return False\n        \n        return True", "class Solution:\n    def canArrange(self, arr, k):\n        rem = [0] * k\n        for a in arr:\n            rem[a % k] += 1\n        if rem[0] % 2 != 0:\n            return False\n        for i in range(1, (k - 1) // 2 + 1):\n            if rem[k - i] != rem[i]:\n                return False\n        return True  ", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        if len(arr)==1:\n            return False\n        \n\n\n        arr = collections.Counter(([i%k for i in arr]))\n\n        if arr[0]%2 ==1:\n            return False\n\n        i = 1\n        j = k - 1\n        while i<=j:\n            if i==j:\n                if arr[i]%2==1:\n                    return False\n\n            if arr[i]!=arr[j]:\n                return False\n            i+=1\n            j-=1\n\n        return True\n                \n                \n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        if len(arr) % 2 != 0:\n            return False\n        import collections\n        ans = []\n        lookup = collections.defaultdict(list)\n        for i, num in enumerate(arr):\n            if (num % k) in lookup:\n                ans.append((arr[lookup[(num % k)].pop(0)], num))\n                if lookup[num % k] == []:\n                    del lookup[num % k]\n                continue\n            if num % k == 0:\n                lookup[0].append(i)\n            else:\n                lookup[(k - (num % k))].append(i)\n        return len(ans) == len(arr)//2\n", "class Solution:\n    def canArrange(self, A: List[int], k: int) -> bool:\n        A.sort(key=lambda x: x%k, reverse=True)\n        i, n = 1, len(A)\n        \n        while i < len(A) and A[-i] % k == 0:\n            if A[-i - 1] % k: return False\n            else:\n                i += 2\n        \n        if i < len(A):\n            j = 0\n            i0 = i\n            while A[-i] % k and j < (n - i0 + 1) // 2:\n                if (A[-i] + A[j]) % k: return False\n                i += 1\n                j += 1\n        \n        return True\n            \n            \n            \n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        recDict = {}\n        for i in range(0, k):\n            recDict[i] = 0\n        for i in arr:\n            recDict[i%k] += 1\n        for i in range(1, k):\n            if recDict[i] !=recDict[k-i]:\n                return False\n        if recDict[0]%2 !=0:\n            return False\n        return True\n", "from collections import Counter \nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        li=collections.Counter([x%k for x in arr])\n        print(li)\n        for i in li:\n            if i==0 or li[i]==0:\n                continue\n            # print(i,li[i])\n            if li[k-i]!=li[i] :\n                return False\n        if li[0]%2==0:\n            return True\n        else:\n            return False\n\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        '''\n                ## APPROACH : 2 SUM ##\n        ## LOGIC ##\n\\t\\t## 1. Store the remainders in the hashmap and check if the current number has remaining remainder available in the hashset ##\n        freq {remainder: remainder count}\n        return true if not any of the pairs are true => we check if the freq[k-x%k]!=freq[x%k]. If we find any of such instance to be true, we return false\n        \n        '''\n        freq = collections.Counter(map(lambda x: x%k, arr))\n        return not any(val%2 if not key else val!=freq[k-key] for key,val in freq.items())", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        cnt = [0] * k \n        \n        for a in arr:\n            a %= k\n            remainder = (k - a) % k\n            if cnt[remainder] > 0:\n                cnt[remainder] -= 1\n            else:\n                cnt[a] += 1\n        \n        return all(c == 0 for c in cnt)\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n          m = {i:0 for i in range(k)}\n          for a in arr:\n            m[a%k] += 1\n\n          for i in range(k):\n            if i == 0:\n              if m[i] % 2 != 0:\n                return False\n            elif m[i] != m[k-i]:\n              return False\n\n          return True\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        d=collections.Counter()\n        for e in arr:\n            t=e%k\n            d[t]+=1\n        key = d.keys()\n        print(d)\n        for e in key:\n            if e==0:\n                continue\n            if d[e]!=d[k-e]:\n                return False\n            else:\n                if e==k//2 and k%2==0 and d[e]%2!=0:\n                    return False\n        return True", "'''\n\u73b0\u5728\u9700\u8981\u628a\u6570\u7ec4\u6070\u597d\u5206\u6210 n /\u00a02 \u5bf9\uff0c\u4ee5\u4f7f\u6bcf\u5bf9\u6570\u5b57\u7684\u548c\u90fd\u80fd\u591f\u88ab k \u6574\u9664\u3002\n\u5982\u679c\u5b58\u5728\u8fd9\u6837\u7684\u5206\u6cd5\uff0c\u8bf7\u8fd4\u56de True \uff1b\u5426\u5219\uff0c\u8fd4\u56de False \u3002\n\n\u601d\u8def\uff1a\u9996\u5148\u548c\u5f97\u6574\u9664\u3002\u8981\u51d1\u5bf9\uff0c\u90a3\u5c31\u662fmod\u80fd\u51d1\u5bf9\uff0c\u7edf\u8ba1mod\u80fd\u5426\u51d1\u5bf9\u5373\u53ef\n'''\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        mod_count = [0 for i in range(k)]\n        for i in arr:\n            mod_count[i % k] += 1\n        if mod_count[0] % 2:\n            return False\n        for i in range(1, len(mod_count)):\n            if mod_count[i] != mod_count[k-i]:\n                return False\n        return True", "# # O(nlogn)  S(n)\n# class Solution:\n#     def canArrange(self, arr: List[int], k: int) -> bool:\n#         A = [a % k for a in arr]\n#         A.sort()\n#         l = 0\n#         r = len(A) - 1\n#         while l < len(A) and A[l] == 0:\n#             l += 1\n#         if l % 2 == 1:\n#             return False\n#         while l < r:\n#             if A[l] + A[r] != k:\n#                 return False\n#             l += 1\n#             r -= 1\n#         return True\n    \n    \n    \n    \n# O(n)  S(n)    \nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        c = collections.Counter([i%k for i in arr])\n        for j in c:\n            if j == 0:\n                if c[j]%2!=0: return False\n            else:\n                if c[j]!=c[k-j]:return False\n        return True", "from collections import Counter\n\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        remainders = [0 for _ in range(k)]\n        for number in arr:\n            rem = number % k\n            remainders[rem] += 1\n        for i in range(k):\n            if i == 0:\n                if remainders[0] % 2 != 0:\n                    return False\n                continue\n            if remainders[i] != remainders[k-i]:\n                return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        \n        #\u6d4b\u8bd5\u96c6\u4e0d\u5b8c\u6574\uff0c\u53ef\u4ee5\u901a\u8fc7\uff0c\u4f46\u662f\u903b\u8f91\u4e0d\u5bf9\n        # return sum(arr) % k == 0\n    \n        \n        nums = [i%k for i in arr]\n        nums = [i for i in nums if i != 0]\n        nums.sort()\n        \n        if len(nums) % 2 != 0:\n            return False\n        \n        for i in range(len(nums)//2):\n            if (nums[i] + nums[-1-i]) % k != 0:\n                return False\n        \n        return True", "import math\n\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        # count of elements in each class\n        moduloclasses = [0] * k\n        for n in arr:\n            moduloclasses[n % k] += 1\n        \n        # these two are 2*[n]=0\n        # if there's a class in the middle\n        # verify that it is even\n        if k % 2 == 0 and moduloclasses[k//2] % 2 != 0:\n            return False\n        # modulo class for 0\n        if moduloclasses[0] % 2 !=0:\n            return False\n        \n        for i in range(1, math.ceil(k / 2)):\n            # classes and their negatives\n            if moduloclasses[i] != moduloclasses[k - i]:\n                return False\n        \n        return True\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        count = defaultdict(int)\n        for x in arr:\n            count[x%k] += 1\n        \n        if 0 in count:\n            if count[0]%2:\n                return False\n            else:\n                count.pop(0)\n                \n        if k%2==0 and k//2 in count:\n            if count[k//2]%2:\n                return False\n            else:\n                count.pop(k//2)\n            \n        while count:\n            x = next(iter(count))\n            if k-x in count:\n                if count[k-x]==count[x]:\n                    count.pop(x)\n                    count.pop(k-x)\n                else:\n                    return False\n            else:\n                return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        freq=[0]*k\n        for num in arr:\n            num%=k\n            if num<0:\n                num+=k\n            freq[num]+=1\n        if freq[0]%2!=0:\n            return False\n        for i in range(1,k//2+1):\n            if freq[i]!=freq[k-i]:\n                return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        d = [0]*k\n        for i in range(len(arr)):\n            d[arr[i] % k] += 1\n        for i in range(len(d)):\n            if i == 0:\n                if d[i]%2 != 0:\n                    return False\n            else:\n                if d[i] != d[k-i]:\n                    return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        '''\n        ex 1\n        arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n        (2,8), (1,9), (3,7), (4,6), (5,10)\n        return True\n        \n        ex 2\n        arr = [1,2,3,4,5,6], k = 7\n        (1,6), (2,5), (3,4)\n        return True\n        \n        ex 3\n        arr = [1,2,3,4,5,6], k = 10\n        [1,2,3,5]\n        (4,6), \n        return False\n        \n        ex 4\n        arr = [-10,10], k = 2\n        return True\n        \n        ex 5\n        arr = [-1,1,-2,2,-3,3,-4,4], k = 3\n        (-1,-2), (1,2), (-3,3), (-4,4)\n        return True\n        \n        idea 1\n        greedy, two pointers\n        time - O(nlogn), space - O(n)\n        '''\n        arr_mod = [num % k for num in arr]\n        arr_mod.sort()\n        n = len(arr_mod)\n        left, right = 0, n-1\n        while left < n and arr_mod[left] == 0:\n            left += 1\n        if left % 2 != 0:\n            return False\n        while left < right:\n            if arr_mod[left] + arr_mod[right] == k:\n                left += 1\n                right -= 1\n            else:\n                return False\n        return True\n        \n        \n        \n        \n", "from collections import Counter \nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        li=collections.Counter([x%k for x in arr])\n        for i in li:\n            if i==0 or li[i]==0:\n                continue\n            print((i,li[i]))\n            if li[k-i]!=li[i] :\n                return False\n        if li[0]%2==0:\n            return True\n        else:\n            return False\n\n", "from collections import defaultdict\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        d = defaultdict(int)\n        for a in arr:\n            d[a % k] += 1\n        res = True\n        for i in range(1, (k+1)//2):\n            print(i, k)\n            if d[i] != d[k-i]:\n                res = False\n        if d[0] % 2 != 0:\n            res = False\n        if k % 2 == 0 and d[k//2] % 2 != 0:\n            res = False\n        return res", "from collections import defaultdict\n\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        \n        n: int = len(arr)\n            \n        # Get the modulus of each value\n        # we want to combine the mods so that they equal the target\n        mods = {ix: 0 for ix in range(k)}\n        \n        for val in arr:\n            mods[val % k] += 1\n        \n        # Need pairs for 0 mod\n        if mods[0] % 2 != 0:\n            return False\n        \n        # We need an equal number of complimenting pairs for\n        # each value\n        for mod in range(1, k):\n            \n            comp = (k - mod)\n\n            # print(f'mod: {mod}   comp: {comp}')\n            # print(f'mods: {mods}')\n\n            if mods[comp] != mods[mod]:\n                return False                \n    \n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        c = collections.Counter([a%k for a in arr])\n        return all((c[i] == c[k-i]) for i in range(1, k//2 + 1)) and (c[0] %2 == 0)", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        dic=defaultdict(int)\n        for u in arr:\n            dic[u%k]+=1\n        for i in range(1+k//2):\n            if i==0:\n                if dic[0]%2!=0:\n                    return False\n            else:\n                if dic[i]!=dic[k-i]:\n                    return False\n        return True\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        c = collections.Counter([i%k for i in arr])\n        \n        for j in c:\n            if j == 0:\n                if c[j]%2: \n                    return False\n            else:\n                if c[j]!=c[k-j]:\n                    return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        if sum(arr) % k != 0:\n            return False\n        mod = defaultdict(int)\n        for num in arr:\n            if k - num % k in mod and mod[k - num % k] != 0:\n                mod[k - num % k] -= 1\n            else:\n                mod[num % k] += 1\n        print(mod)\n        for k, v in mod.items():\n            if k * v != 0:\n                return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        \n        arr=[a%k for a in arr]\n        arr.sort()\n        \n        arr=[a for a in arr if a!=0]\n        if len(arr)%2==1:\n            return False\n        \n        l, r=0, len(arr)-1\n    \n        while l<r:\n            if arr[l]+arr[r]!=k:\n                return False\n            r-=1\n            l+=1\n            \n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        c = collections.Counter([i%k for i in arr])\n        print(c)\n        \n        for j in c:\n            if j == 0:\n                if c[j]%2: \n                    return False\n            else:\n                if c[j]!=c[k-j]:\n                    return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        d = collections.defaultdict(int)\n        for num in arr:\n            d[num%k]+=1\n        print(d)\n        for i in range(k):\n            if i in d:\n                if i!=k-i and k-i in d and d[i] ==d[k-i]:\n                    continue\n                elif (i == 0 or i==k-i) and d[i]%2 == 0:\n                    continue\n\n                else:\n                    return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        cnt = [0]*k\n        for num in arr:\n            cnt[num%k] +=1\n        i,j = 1,k-1\n        pairs = 0\n        while i<j:\n            if cnt[i]!=cnt[j]:\n                return False\n            pairs += cnt[i]\n            i +=1\n            j -=1\n            \n        if pairs>0 and i==j:\n            pairs += cnt[i]/2\n        pairs += cnt[0]/2\n        n = len(arr)\n        return pairs == n//2\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        counts = Counter([x%k for x in arr])\n        \n        for key in counts:\n            if key == 0 or key*2 == k:\n                if counts[key] % 2:\n                    return False\n            elif counts[key] != counts[k-key]:\n                    return False\n            \n            \n        return True\n", "from collections import defaultdict\n\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        counter = defaultdict(int)\n\n        for n in arr:\n            mod = n % k\n            complement = (k - mod) % k\n            if counter.get(complement, 0):\n                counter[complement] -= 1\n            else:\n                counter[mod] += 1\n        \n        return all(v == 0 for v in counter.values())", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        if len(arr)==1:\n            return False\n        \n        arr = collections.Counter(([i%k for i in arr]))\n        print(arr)\n        i = 1\n        j = k - 1\n        while i<=j:\n            if i==j:\n                if arr[i]%2==1:\n                    return False\n\n            if arr[i]!=arr[j]:\n                return False\n            i+=1\n            j-=1\n\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        ## save remainder in hashmap and then check if remaining remainder is in the hashmap\n        if len(arr)%2==1:\n            return False\n        mapping = defaultdict(int)\n        count=0\n        for i in arr:\n            key = k-i%k\n            \n            if key in mapping and mapping[key] >=1:\n                mapping[key]-=1\n                count+=1\n            else:\n                mapping[(i%k) or k] +=1\n                \n            \n            \n        \n        \n                \n        if count ==len(arr)//2:\n            return True\n        return False\n                \n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        cache = {}\n        \n        for x in arr:\n            if x%k:\n                comple = k - (x%k)\n            else:\n                comple = 0\n            if cache.get(comple,0):\n                cache[comple] -=1\n            else:\n                if x%k in cache:\n                    cache[x%k] += 1\n                else:\n                    cache[x%k] = 1\n        return not sum(cache.values())", "from collections import defaultdict\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        # ctr = set([])\n        # for i in range(len(arr)):\n        #     for j in range(i+1, len(arr)):\n        #         if (arr[i] + arr[j]) % k == 0:\n        #             if i in ctr or j in ctr:\n        #                 continue\n        #             else:\n        #                 ctr.add(i)\n        #                 ctr.add(j)\n        # return len(ctr)/2 == len(arr)/2\n        \n        if len(arr) % 2 == 1:\n            return False\n        lookup = defaultdict(int)\n        count = 0\n        for idx, num in enumerate(arr):\n            key = k - (num % k)\n            if key in lookup and lookup[key] >= 1:\n                count += 1\n                lookup[key] -= 1\n            else:\n                lookup[(num % k) or k] += 1\n        return count == len(arr)//2", "from collections import Counter\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        if len(arr) % 2 == 1: return False\n        \n        lookup = collections.defaultdict(int)\n        count = 0\n        for i, num in enumerate(arr):\n            key = k - (num % k)\n            if key in lookup and lookup[key] >= 1:\n                # print(key, num)\n                count += 1\n                lookup[key] -= 1\n            else:\n                lookup[(num % k) or k] += 1\n        return count == len(arr) // 2\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        if len(arr) % 2 or sum(arr) % k:\n            return False\n        \n        rems = [0] * k\n        \n        for a in arr:\n            rems[a % k] += 1\n        \n        if rems[0] % 2:\n            return False\n        \n        for i in range(1, k):\n            if rems[i] != rems[k - i]:\n                return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        \n        d ={}\n        \n        for num in arr:\n            rem = num % k\n            if rem in d:\n                d[rem].append(num)\n            else:\n                d[rem] = [num]                        \n                \n        for i in d:\n            \n            if i == 0 or (k%2 == 0 and i == k //2):\n                if len(d[i]) % 2 != 0:     \n                    return False\n            else:\n                if k-i in d:\n                    if len(d[i]) != len(d[k-i]):\n                        # print(\\\"----\\\")\n                        return False\n                else:\n                    # print(\\\"#####\\\")\n                    return False\n            \n            # if i > k //2:\n            #     break\n                \n        return True\n            \n    \n    \n            \n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        h = collections.defaultdict(int)\n        invalid = 0\n        for n in arr:\n            mod = n % k\n            completment = k - mod if mod > 0 else 0\n            if h[completment] > 0:\n                h[completment] -= 1\n                if h[completment] == 0:\n                    invalid -= 1\n            else:\n                h[mod] += 1\n                if h[mod] == 1:\n                    invalid += 1\n        return invalid == 0\n", "class Solution:\n    def canArrange(self, A: List[int], k: int) -> bool:\n        counter = Counter()\n        for a in A:\n            counter[a % k] += 1\n        \n        if counter[0] & 1 != 0:\n            return False\n        \n        for i in range(1, k // 2 + 1):\n            if counter[i] != counter[k - i]:\n                return False\n        \n        return True\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        from collections import defaultdict\n        modulo = defaultdict(int)\n        large_factor = 1e8\n        \n        for i, v in enumerate(arr):\n            modulo[(v + large_factor * k) % k] += 1\n        \n        for mod, cnt in list(modulo.items()):\n            if mod == 0 and cnt % 2 != 0:\n                return False\n            if modulo[(k - mod % k) % k] != cnt:\n                return False\n        \n        return True\n            \n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        \n        \n        \n        \n        counter = defaultdict(int)\n        \n        for ele in arr:\n            \n            ele %= k\n            \n            if counter[k-ele]:\n                counter[k-ele] -= 1\n            else:\n                counter[ele] += 1\n        \n        \n        # print(counter)\n        \n        if counter[0] % 2: return False\n        \n        counter[0] = 0\n        for k, v in list(counter.items()):\n            if v: return False\n            \n            \n        return True\n        \n        \n", "from collections import defaultdict\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        n=len(arr)\n        d={i:0 for i in range(k)}\n        for ele in arr:\n            d[ele%k]+=1\n        for i in range(k):\n            if d[0]%2!=0:\n                return False\n            elif i!=0 and d[i]!=d[k-i]:\n                return False\n        return True\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        if len(arr) % 2 != 0:\n            raise Exception('Input array is of odd size!')\n        \n        mod_dict = {}\n        \n        for i in arr:\n            mod = i % k\n            pair_mod = (k - mod) % k\n            if pair_mod in mod_dict:\n                if mod_dict[pair_mod] == 1:\n                    del mod_dict[pair_mod]\n                else:\n                    mod_dict[pair_mod] -= 1\n            else:\n                if mod not in mod_dict:\n                    mod_dict[mod] = 1\n                else:\n                    mod_dict[mod] += 1\n        \n        return len(mod_dict) == 0\n", "from collections import Counter\n\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        counter = Counter([num%k for num in arr])\n        return all([counter[i] == counter[k-i] for i in range(1,k//2+1)]) and counter[0] % 2 == 0", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        bag = {}\n        for i in arr:\n            if i < 0:\n                i += ((-i) // k +1) * k\n                \n            r = i % k\n            \n\n            if r != 0:\n                if k-r not in bag:\n                    if r not in bag:\n                        bag[r] = 0\n                    bag[r] += 1\n                else:\n                    bag[k-r] -= 1\n                    if bag[k-r] == 0:\n                        del bag[k-r]\n            else:\n                if 0 in bag:\n                    del bag[0]\n                else:\n                    bag[0]= 1\n        return len(bag) == 0", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        freqs = [0]*k\n        for n in arr:\n            freqs[n%k]+=1\n        for r in range(1, k//2+ k%2):\n            if freqs[r]!=freqs[k-r]:\n                return False\n        return not freqs[0]%2        ", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        remainder_cnt = {}\n        for n in arr:\n            if not n%k in remainder_cnt:\n                remainder_cnt[n%k] = 0\n            remainder_cnt[n%k] += 1\n        \n        for i in remainder_cnt:\n            if i==0 or i==k/2:\n                if remainder_cnt[i]%2!=0:\n                    return False\n            elif not k-i in remainder_cnt or remainder_cnt[i]!=remainder_cnt[k-i]:\n                # print(remainder_cnt,i)\n                return False\n        \n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        # int arr and integer k\n        # divide array into pairs such that the sum of each pair is divisible by k\n        # return True if possible, other false\n        \n        # [1, 2, 3, 4, 5, 10, 6, 7, 8, 9] k = 5   5, 10, 15, 20, 25, 30\n        #  4  3  2\n        #  9  8  7\n        # 14 13 12\n        # elem = 1 poss: 4, 9 k%5 == 4  \n        # elem = 2 poss: 3, 8 k%5 == 3\n        # elem = 3 poss: 2, 7 k%5 == 2\n        # elem = 4 poss: 1, 6 k%5 == 1\n        # elem = 5 poss: 10   k%5 == 0\n        # elem = 6 poss: 4, 9\n        # elem = 7 poss: 3, 8 # see if there are any pairs that have not been matched yet. if so, check their possible matches and see if one is available\n        # elem = 8 poss: 2, 7\n        # elem = 9 poss: 1, 6\n        # elem = 10 poss: 5\n        \n        # arr = [1,2,3,4,5,6], k = 10\n        # elem = 1 poss: x\n        \n        \n        # 1 - 4 6 - 9 \n        # 1 - 9 4 - 6\n        \n        # 2 - 3 8 - 7 \n        # 2 - 8 3 - 7\n        \n        # 5 - 10\n        modFrequencies = {}\n        for i in range(0, len(arr)):\n            difference = arr[i] % k\n            if difference not in modFrequencies:\n                modFrequencies[difference] = 0\n            modFrequencies[difference] += 1\n            \n        for mod in modFrequencies:\n            if mod == 0:\n                if modFrequencies[mod] % 2 == 1: \n                    return False\n            elif k-mod not in modFrequencies or modFrequencies[mod] != modFrequencies[k-mod]:\n                return False\n        return True\n            \n            \n            \n        \n", "from collections import defaultdict\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        if len(arr) % 2 == 1:\n            return False\n        d = defaultdict(int)\n        count = 0\n        for i, num in enumerate(arr):\n            key = k - (num % k)\n            if key in d and d[key] >= 1:\n                count += 1\n                d[key] -= 1\n            else:\n                d[(num % k) or k] += 1\n        return count == len(arr) // 2", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        \n        d ={}\n        \n        for num in arr:\n            rem = num % k\n            if rem in d:\n                d[rem].append(num)\n            else:\n                d[rem] = [num]                        \n                \n        print(d)\n        for i in d:\n            \n            if i == 0 or (k%2 == 0 and i == k //2):\n                if len(d[i]) % 2 != 0:     \n                    return False\n            else:\n                if k-i in d:\n                    if len(d[i]) != len(d[k-i]):                        \n                        return False\n                else:                    \n                    return False\n            \n            # if i > k //2:\n            #     break\n                \n        return True\n            \n    \n    \n            \n", "from collections import defaultdict\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        '''\n        x*k = num1 + num2 = a*k+remain1 + b*k+remain2\n                        = (a+b)*k + remain1+remain2\n                        remain1+remain2 = k,-k or 0\n        \n        \n        [1,2,3,4,5,10,6,7,8,9]\n        \n        [1,2,3,4,0,0,1,2,3,4]\n        '''\n        \n        d = defaultdict(int)\n        for num in arr:\n            sgn = 1 if num >= 0 else -1\n            num = sgn*(abs(num)%k)\n            if num==0:\n                if d[0]:\n                    d[0]-=1\n                    if d[0]==0: del d[0]\n                else:\n                    d[0]+=1\n            else:\n                if -num in d and d[-num]:\n                    d[-num]-=1\n                    if d[-num]==0: del d[-num]\n                elif -k-num in d and d[-k-num]:\n                    d[-k-num]-=1\n                    if d[-k-num]==0: del d[-k-num]\n                elif k-num in d and d[k-num]:\n                    d[k-num]-=1\n                    if d[k-num]==0: del d[k-num]\n                else:\n                    d[num]+=1\n        return len(d)==0", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        hashtable = dict()\n        count = 0\n        for x in arr:\n            corresp = abs(k - x%k)\n            if corresp in hashtable:# and k - corresp != corresp:\n                if k - corresp == corresp:\n                    if hashtable[corresp] == 1:\n                        hashtable[corresp] = 0\n                    else:\n                        hashtable[corresp] = 1 \n                else:      \n                    hashtable[corresp] -= 1\n            elif k - corresp in hashtable  :\n                if k - corresp != 0:# and 2 * corresp != k:\n                     hashtable[k - corresp] += 1\n                else:\n                    hashtable[k - corresp] = 0 \n            else:\n                hashtable[k-corresp] = 1\n        print(count)\n            \n        for x in hashtable:\n            if hashtable[x] != 0:\n                print(x, hashtable[x])\n                return False\n         \n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        c = collections.Counter([i%k for i in arr])\n        for j in c:\n            if j == 0:\n                if c[j]%2!=0: return False\n            else:\n                if c[j]!=c[k-j]:return False\n        return True\n                \n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        n = len(arr)\n        if n % 2:\n            return False\n        \n        tbl = dict()\n        for val in arr:\n            r = val % k\n            if tbl.get((k - r) % k, 0):\n                tbl[(k - r) % k] -= 1\n            else:\n                tbl[r] = tbl.get(r, 0) + 1\n        \n        for idx, cnt in tbl.items():\n            if cnt != 0:\n                return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        \n        modulo = [0]*k\n        \n        for a in arr:\n            modulo[a%k] += 1\n            \n        # print(modulo)\n        for i in range(1,k):\n            if i == k-i and modulo[i] % 2 != 0:\n                return False\n            elif modulo[i] != modulo[k-i]:\n                return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        a = arr\n        c = collections.Counter()\n        for x in a:\n            r = x % k\n            t = k - r if r else r\n            if t in c:\n                c[t] -= 1\n                if c[t] == 0:\n                    del c[t]\n            else:\n                c[r] += 1\n        return not c", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        from collections import Counter \n        mods = [a % k for a in arr]\n        \n        c = Counter(mods)\n        \n        possible = True\n        print(c)\n        for val, ct in c.items():\n            complement = (k - val) % k\n            if complement == val:\n                possible &= ct % 2 == 0\n            else:\n                possible &= c[complement] == ct\n        return possible", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        d=collections.Counter([i%k for i in arr])\n        pair=0\n        #print(d)\n        for i in list(d.keys()):\n            if k-i==i:\n                if i in d:\n                    if d[i]>1:\n                        pair+=d[i]//2\n                        d[i]=0\n                    else:\n                        continue\n            if k-i in d:\n                t=min(d[i],d[k-i])\n                pair+=t\n                d[i]-=t\n                d[k-i]-=t\n        #print(pair)\n        #print(len(arr))\n        #print(d.values())\n        if 0 in d:\n            pair+=d[0]//2\n            d[0]=0\n        print(pair)\n        if pair==len(arr)//2:\n            return 1\n        return 0\n                \n", "from collections import Counter\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        mods = [x%k for x in arr]\n        cMods= Counter(mods)\n        totalP = 0\n    \n        for cm in cMods:\n            if(cm == 0 or cMods[cm] == 0) :\n                totalP+=cMods[cm]\n                continue\n            if(cMods[cm] != cMods[k-cm]):\n                return False\n        if(cMods[0]%2==0):\n            return True\n        else:\n            return False\n                \n                \n        \n", "from collections import Counter\n\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        div = [num%k for num in arr]\n        counter = Counter(div)\n        print('Div : ',div)\n        print('Counter : ',counter)\n        \n        return all([counter[i] == counter[k-i] for i in range(1,k//2+1)]) and counter[0] % 2 == 0", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        ## save remainder in hashmap and then check if remaining remainder is in the hashmap\n        if len(arr)%2==1:\n            return False\n        mapping = defaultdict(int)\n        count=0\n        for i in arr:\n            key = k-i%k\n            print(key)\n            if key in mapping and mapping[key] >=1:\n                mapping[key]-=1\n                count+=1\n            else:\n                mapping[(i%k) or k] +=1\n                \n            \n            \n        \n        \n                \n        if count ==len(arr)//2:\n            return True\n        return False\n                \n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        freq = Counter([x % k for x in arr])\n        \n        for num in arr:\n          if freq[num % k] == 0: continue\n          freq[(num % k)] -= 1\n          if freq[(k - (num % k)) % k] == 0: return False\n          freq[(k - (num % k)) % k] -= 1\n        \n        \n      \n        return True\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        if len(arr) % 2 != 0:\n            return False\n        lookup = [0] * k\n        for num in arr:\n            lookup[num % k] += 1\n        \n        if lookup[0] % 2 != 0:\n            return False\n        for p in range(1, k):\n            if p != k - p:\n                if lookup[p] != lookup[k - p]:\n                    return False\n            else:\n                if lookup[p] % 2 != 0:\n                    return False\n        return True\n", "from collections import Counter\n\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        matches = Counter()\n        \n        c = 0\n        for e in arr:\n            me = -e % k\n            if matches[me] > 0:\n                matches[me] -= 1\n                c += 1\n            else:\n                matches[e%k] += 1\n                \n        return c == len(arr) // 2\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        if len(arr) == 0: return False\n        if len(arr) % 2 != 0: return False\n        Check = dict()\n        for i in range(len(arr)):\n            if arr[i] % k not in Check:\n                Check[arr[i] % k] = 0\n            Check[arr[i] % k] += 1\n        if 0 in Check and Check[0] % 2 != 0: \n            return False\n        for i in range(1,k):\n            if i in Check:\n                if k - i not in Check or Check[i] != Check[k-i]:\n                    return False\n        return True\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        tmp = collections.Counter()\n        for x in arr:\n            tmp[x%k] += 1\n        for c,v in list(tmp.items()):\n            if c == 0 and v % 2 != 0:\n                return False\n            elif c != 0 and v != tmp[k-c]:\n                return False\n        return True\n# class Solution:\n#     def canArrange(self, arr: List[int], k: int) -> bool:\n#         mod = [0] * k\n#         for num in arr:\n#             mod[num % k] += 1\n#         print(mod)\n#         if any(mod[i] != mod[k - i] for i in range(1, k // 2)):\n#             return False\n#         return mod[0] % 2 == 0\n\n# \u4f5c\u8005\uff1aLeetCode-Solution\n# \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/check-if-array-pairs-are-divisible-by-k/solution/jian-cha-shu-zu-dui-shi-fou-ke-yi-bei-k-zheng-chu-/\n# \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09\n# \u8457\u4f5c\u6743\u5f52\u4f5c\u8005\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u4f5c\u8005\u83b7\u5f97\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        from collections import Counter \n        arr = [a % k for a in arr]\n        \n        c = Counter(arr)\n        \n        possible = True\n        print(c)\n        for val, ct in c.items():\n            complement = (k - val) % k\n            if complement == val:\n                possible &= ct % 2 == 0\n            else:\n                possible &= c[complement] == ct\n        return possible", "from collections import Counter\n\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        c = Counter()\n        \n        f = 0\n        for e in arr:\n            ex = (k - (e%k)) % k\n            if c[ex] > 0:\n                c[ex] -= 1\n                f += 1\n            else:\n                c[e%k] += 1\n        \n        return f == len(arr) // 2", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        countMap = {}\n        for i in range(len(arr)):\n            arr[i] %= k\n            countMap[arr[i]] = countMap.get(arr[i], 0) + 1\n        print((countMap, arr))\n        \n        for char in arr:\n            if char == 0:\n                continue\n            \n            if k - char not in countMap:\n                return False\n            elif countMap[k - char] == 0:\n                return False\n            else:\n                countMap[k - char] -= 1\n        return True if (0 not in countMap or countMap[0] % 2 == 0) else False\n        \n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        arr = sorted([c%k for c in arr])\n        count = Counter(arr)\n        # print(arr)\n        # print(count)\n        for i in range(len(arr)//2):\n            if count[arr[i]] > 0:\n                count[arr[i]]-=1\n                if count[(k-arr[i])%k] == 0:\n                    return False\n                else:\n                    count[(k-arr[i])%k]-=1\n            \n            # print(\\\"{0} => {1}\\\".format(arr[i], count))\n        return True\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        # Stores count of remainders\n        c = collections.Counter([i%k for i in arr])\n        \n        for j in c:\n            # If there is a reminder of 0 check that the number of times 0 occurs is even\n            # THis guarantees pairing for the rest of remainders > 0\n            if j == 0:\n                if c[j]%2!=0: return False\n            # If remainder is not 0\n            # Check if the counts are even or have a pairing for remainders > 0\n            else:\n                if c[j]!=c[k-j]:return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        c = collections.Counter([i%k for i in arr])\n        for j in c:\n            if j == 0:\n                if c[j]%2: \n                    return False\n            else:\n                if c[j]!=c[k-j]:\n                    return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        arr = [a%k for a in arr]\n        arr = Counter(arr)\n        if arr.get(0,0) % 2 != 0:\n            return False\n        if k % 2 == 0 and arr.get(k/2,0) % 2 == 1:\n            return False\n        i = 1\n        k -= 1\n        while k > i:\n            if arr.get(k,0) != arr.get(i,0):\n                return False\n            i += 1\n            k -= 1\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        \n        rem = collections.Counter()\n        for a in arr: rem[a%k]+=1\n        \n        for a in arr:\n            one = a%k\n            if rem[one] == 0: continue\n            rem[one]-=1\n            two = one if one==0 else k-one\n            if rem[two]==0: return False\n            rem[two]-=1\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        #The idea is to count the residues\n        \n        #If every residue has the counter residue\n        #such that x+y == k,then we found a pair\n        \n        count = [0]*k\n        for num in arr:\n            count[num%k] +=1\n        \n        #Now since we have 0,1,2,.....k-1 as residues\n        #If count[1] == count[k-1],pairs+=count[0]  \n        print('count ',count)\n        for x in range(k):\n            comp = -x % k \n            # x+comp = 0 mod k, or\n            # (x+comp) mod k = 0\n            print('Comp : ',comp)\n            while count[x]>0:\n                count[x]-=1\n                count[comp]-=1\n                if count[comp]<0:\n                    return False\n        \n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        counts = defaultdict(lambda:0)\n        \n        for n in arr:\n            mod = n % k\n            \n            if counts[k - mod] == 0:\n                counts[mod] += 1\n            else:\n                counts[k - mod] -= 1\n                \n        \n        return counts[0] % 2 == 0 and sum(counts.values()) - counts[0] == 0", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        d=collections.Counter([i%k for i in arr])\n        pair=0\n        #print(d)\n        for i in list(d.keys()):\n            if k-i==i:\n                if i in d:\n                    if d[i]>1:\n                        pair+=d[i]//2\n                        d[i]=0\n                    else:\n                        continue\n            if k-i in d:\n                t=min(d[i],d[k-i])\n                pair+=t\n                d[i]-=t\n                d[k-i]-=t\n        #print(pair)\n        #print(len(arr))\n        #print(d.values())\n        if 0 in d:\n            pair+=d[0]//2\n            d[0]=0\n        #print(pair)\n        if pair==len(arr)//2:\n            return 1\n        return 0\n                \n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        \n        n = len(arr)\n        mod_count = [0 for i in range(0,k)]\n        \n        \n        for i in range(0,n):\n            mod_count[arr[i]%k]+=1\n            \n            \n        #print(mod_count)\n        \n        mid = int(k/2)\n        #print(\\\"mid = %d\\\" %mid)\n        \n        if(k%2==1):     #odd bucket [0], [1,k-1], [2,k-1], ...[mid-1,mid+1]\n            if(mod_count[0]%2==1):\n                #print(\\\"debug0\\\")\n                return False\n        else:           #even bucket [0], [1,k-1], [2,k-2], ...[mid]\n            if(mod_count[0]%2==1 or mod_count[mid]%2==1):\n                #print(\\\"debug1\\\")\n                return False\n\n        num = int((k-1)/2)\n        \n        for i in range(1,num+1):\n            #print(i,k-1-i)\n            if(mod_count[i]!=mod_count[k-i]):\n                #print(\\\"debug2\\\")\n                return False\n        \n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        n = len(arr)\n        if n & 1:\n            return False\n        bucket = [0] * k\n        for a in arr:\n            bucket[(k + a % k) % k] += 1\n        if bucket[0] % 2:            \n            return False\n        for i in range(1, k):\n            if bucket[i] != bucket[k - i]:\n                return False\n        return True                \n", "class Solution:\n    def canArrange(self, A: List[int], K: int) -> bool:\n        counts = [0]*K\n        \n        for num in A:\n            counts[num % K] += 1\n        \n        for x in range(K):\n            y = -x % K\n            while counts[x]:\n                counts[x] -= 1\n                counts[y] -= 1\n                \n                if counts[y] < 0:\n                    return False\n                \n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        \n        n = len(arr)\n        modulo_map = defaultdict(lambda: [])\n        \n        pairs = []\n        for a in arr:\n            \n            r = k - a % k if a % k != 0 else 0\n            if r in list(modulo_map.keys()) and len(modulo_map[r]) > 0:\n                pairs.append((a, modulo_map[r].pop(-1)))\n                \n                if len(modulo_map[r]) == 0:\n                    del modulo_map[r]\n                                \n            else:\n                modulo_map[a % k].append(a)\n\n        if len(pairs) == n // 2:\n            return True\n        \n        else:\n            return False\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        h=collections.Counter(i%k for i in arr)\n        if 0 in h:\n            if h[0]%2!=0:\n                return False\n        for x in h:\n            if x>0 and h[x]!=h[k-x]:\n                return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        d=collections.Counter()\n        for e in arr:\n            t=e%k\n            d[t]+=1\n        key = d.keys()\n        for e in key:\n            if e==0:\n                continue\n            if d[e]!=d[k-e]:\n                return False\n            else:\n                if e==k//2 and k%2==0 and d[e]%2!=0:\n                    return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        n=len(arr)\n        if n%2:\n            return 0\n        d=defaultdict(int)\n        for a in arr:\n            d[a%k]+=1\n        if k%2==0 and k//2 in d:\n            if d[k//2]%2:\n                return 0\n            del d[k//2]\n    \n        sd=sorted(d.items(),key=lambda x:x[0])\n        if sd[0][0]==0:\n            if sd[0][1]%2:\n                return 0\n            sd.pop(0)\n        if n%2 and len(sd)%2:\n            return 0\n        while sd:\n            a1=sd.pop(0)\n            s2=sd.pop(-1)\n            if a1[0]+s2[0]!=k or a1[1]!=s2[1]:\n                return 0 \n        return 1", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        count = [0]*k\n        for num in arr:\n            count[num%k] +=1\n        \n        #Now since we have 0,1,2,.....k-1 as residues\n        #If count[1] == count[k-1],pairs+=count[0]  \n        print(count)\n        for x in range(k):\n            comp = -x % k \n            # x+comp = 0 mod k, or\n            # (x+comp) mod k = 0\n            print(comp)\n            while count[x]>0:\n                count[x]-=1\n                count[comp]-=1\n                if count[comp]<0:\n                    return False\n        \n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        # \u4f59\u6570\u5b57\u5178\n        d = {i:0 for i in range(k)}\n        # \u6c42\u6bcf\u4e2a\u503c\u7684\u4f59\u6570\uff0c\u5e76\u7edf\u8ba1\u4e2a\u6570\n        for num in arr:\n            d[num % k] += 1\n        # \u82e5\u6b63\u597d\u9664\u5c3d\u7684\u4e2a\u6570\u4e3a\u5947\u6570\uff0c\u8bc1\u660e\u9664\u4e0d\u5c3d\u7684\u4e3a\u5947\u6570\u4e2a\uff0c\u65e0\u6cd5\u5f62\u6210pair\n        if d[0] % 2 != 0:\n            return False\n        for i in range(1, k):\n            # \u6b64\u5904\u6709\u4e00\u4e2atrick\uff0c\u82e5\u4e24\u4e2a\u6570\u4f59\u6570\u76f8\u52a0\u4e3ak,\u5219\u8fd9\u4e24\u4e2a\u6570\u7684\u548c\u53ef\u4ee5\u88abk\u6574\u9664\uff08\u76f8\u5f53\u4e8e\u591a\u52a0\u4e86\u4e00\u4e2ak\uff09\uff0c\u6240\u4ee5\u5982\u679c\u51fa\u73b0\u9891\u7387\u76f8\u7b49\uff0c\u8fd9\u4e24\u7ec4\u6570\u5373\u53ef\u4e24\u4e24\u914d\u5bf9\n            if i != k-i:\n                if d[i] != d[k-i]:\n                    return False\n            else:\n                if d[i] % 2 != 0:\n                    return False\n        \n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        seen = {}\n        for num in arr:\n            remainder = num % k\n            if remainder in seen:\n                seen[remainder] -= 1\n                if seen[remainder] == 0:\n                    del seen[remainder]\n            else:\n                if remainder == 0:\n                    seen[remainder] = 1\n                else:\n                    seen[k - remainder] = seen.get(k-remainder, 0) + 1\n        return len(seen) == 0\n", "from collections import Counter\n\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        counter = Counter([num%k for num in arr])\n        return all([counter[i] == counter[k-i] for i in range(1,k//2+1)]) and counter[0] % 2 == 0\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        c = collections.Counter([i%k for i in arr])\n        \n        for j in c:\n            if j == 0:\n                if c[j]%2!=0: return False\n            else:\n                if c[j]!=c[k-j]:return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        '''\n        # Note:\n            the arr's length is even\n        # Notes:\n            each pair has two numbers\n            get the remainder of each number divided by k\n        '''\n        n = len(arr)\n        for i in range(n):\n            arr[i] = arr[i] % k\n        lookup = defaultdict(int)\n        for i in range(n):\n            if not arr[i]:\n                continue\n            if k - arr[i] in lookup:\n                lookup[k-arr[i]] -= 1\n                if not lookup[k-arr[i]]:\n                    lookup.pop(k-arr[i])\n            else:\n                lookup[arr[i]] += 1\n\n        if not lookup:\n            return True\n        return False", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        dic=collections.defaultdict(int)\n        for i in range(len(arr)):\n            if arr[i]%k!=0:\n                dic[arr[i]%k]+=1\n        for ki in list(dic.keys()):\n            if ki!=0:\n                if dic[ki]!=dic[k-ki] or (2*ki==k and dic[ki]%2==1):\n                    return False\n        return True\n", "# O(nlogn)  S(n)\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        A = [a % k for a in arr]\n        A.sort()\n        l = 0\n        r = len(A) - 1\n        while l < len(A) and A[l] == 0:\n            l += 1\n        if l % 2 == 1:\n            return False\n        while l < r:\n            if A[l] + A[r] != k:\n                return False\n            l += 1\n            r -= 1\n        return True", "from collections import Counter\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        count = Counter(x % k for x in arr)\n        for x in count:\n            y = -x % k\n            if x == 0 and count[x] & 1:\n                return False\n            elif count[x] != count[y]:\n                return False\n        return True\n", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        # Stores count of remainders\n        c = collections.Counter([i%k for i in arr])\n        \n        for j in c:\n            # If reminder is 0\n            # Check if this remainder is even\n            if j == 0:\n                if c[j]%2!=0: return False\n            # If remainder is not 0\n            # Check if current remainder c[j] is not equal to c[k-j], divisor-current remainder\n            else:\n                if c[j]!=c[k-j]:return False\n        return True", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        c = collections.Counter()\n        for i in arr:\n            c[i%k] += 1\n        return all((i == 0 and c[i]%2 == 0) or (i != 0 and c[i] == c[k-i]) for i in c)", "import collections as clc\n\n\nclass Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        if len(arr) % 2 == 1:\n            return False\n        counts = clc.Counter([v % k for v in arr])\n        if k % 2 == 0:\n            if counts[k // 2] % 2 != 0:\n                return False\n        return all(counts[i] == counts[k - i] for i in range(1, k // 2 + 1))", "class Solution:\n    def canArrange(self, arr: List[int], k: int) -> bool:\n        count = collections.Counter()\n        for i in arr:\n            count[i % k] += 1\n        for i in range(1,k // 2 + 1):\n            if count[i] != count[k - i]:\n                return False\n            if count[0] % 2 != 0:\n                return False\n        return True"]
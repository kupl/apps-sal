["l = {j:i for i,j in enumerate('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')}\nl_ = dict(enumerate('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'))\n\nis_polydivisible = lambda n, base:next((0 for i in range(1, len(n) + 1) if get_base(n[:i], base) % i),1)\nget_base = lambda n, base:sum(int(l[j]) * (base ** i) for i, j in enumerate(n[::-1]))\ndef get_polydivisible(n, base):\n    c = i = 0; r = ''\n    while c < n:\n        t = to_base(i, base)\n        if is_polydivisible(t, base) : c += 1 ;  r = t\n        i += 1\n    return ''.join(r) or '0'\n\ndef to_base(n, base):\n      li = []\n      while n:\n          n, b = divmod(n, base)\n          li.append(l_[b])\n      return li[::-1]", "from itertools import count\n\ndigits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef convert_digits(s):\n    # converts each digit in base b in string s to its corresponding value in base 10\n    # @return list of integers from 0 to b-1\n    return [int(digits.index(d)) for d in s]\n\ndef convert_to_base_10(s,b):\n    # converts an integer in base b to base 10\n    # @input string representing integer and integer b representing base\n    # @return string representing integer in base 10\n    if b == 10:\n        return s\n    coeffs = convert_digits(s)[::-1]\n    return str(sum([coeffs[i]*b**i for i in range(len(s))]))\n\ndef convert_from_base_10(s,b):\n    #converts an integer from base 10 to base b\n    # @input string representing integer and integer b representing base\n    # @return string representing integer in base b\n    max_exp = 0\n    n = int(s)\n    coeffs = []\n    while b**(max_exp+1) <= n:\n        max_exp += 1\n    for k in range(max_exp+1):\n        coeffs.append(digits[n%b])\n        n = int((n-n%b)/b)\n    return \"\".join(coeffs[::-1])\n\ndef is_polydivisible(s,b):\n    # checks for polydivisibility in base b\n    base_b = [s[:k] for k in range(1,len(s)+1)]\n    #print(\"base_b = \" + str(base_b))\n    base10 = list(map(lambda s: convert_to_base_10(s,b), base_b))\n    #print(\"base10 = \" + str(base10))\n    divisible = [int(base10[k])%(k+1) == 0 for k in range(1,len(s))]\n    return not (False in divisible)\n\ndef get_polydivisible(n, b):\n    # @return the nth polydivisible number in base b\n    poly_count = 0\n    for k in count(start=0, step=1):\n        if is_polydivisible(convert_from_base_10(str(k),b), b):\n            temp = str(k)\n            poly_count += 1\n            if poly_count == n:\n                return convert_from_base_10(temp,b)", "CHARS=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef from10(n, b):\n    if b == 10: return n\n    new = ''\n    while n: \n        new += str(CHARS[n%b])\n        n //= b\n    return new[::-1]\n\ndef to10(n, b):\n    num = 0\n    for i, d in enumerate(str(n)[::-1]):\n        num += int(CHARS.index(d))*(b**i)\n    return num\n\ndef is_polydivisible(s, b):\n    for i in range(1, len(s)+1):\n        if to10(s[:i], b) % i != 0: return False\n    return True\n\n\ndef get_polydivisible(n, b):\n    if n == 1: return '0'\n    i = 0 \n    poly = []\n    while len(poly) < n:\n        fr = str(from10(i, b))\n        if is_polydivisible(str(fr), b): \n            poly.append(fr)\n            i += 1\n        else: i += 1\n    return poly[-1]", "b62 = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef atoi (n, b):\n    res = 0\n    n = str(n)\n    for i,c in enumerate(n):\n        res += b62.index(c) * b**(len(n)-i-1)\n    return res\n    \ndef itoa (n, b):\n    res = \"\"\n    while n > 0:\n        res = b62[n % b] + res\n        n //= b\n    return res or \"0\"\n\ndef is_polydivisible(s, b):\n    for i in range(len(s), 0, -1):\n        n = atoi(s[:i], b)\n        if n % i != 0:\n            return False\n    return True\n\ndef get_polydivisible(n, b):\n    res = \"\"\n    c = 0\n    for i in range(n):\n        while 1:\n            a = itoa(c, b)\n            c += 1\n            if is_polydivisible(a, b):\n                res = a\n                break\n    return res", "is_polydivisible, get_polydivisible = (lambda digits: ((lambda ds: lambda s, b: (lambda f: (lambda x: x(x))(lambda y: f(lambda *xs: y(y)(*xs))))(lambda f: lambda l, n, xs: n % l == 0 and (not xs or f(l+1, n*b+xs.pop(), xs)))(1, ds[s[0]], [ds[i] for i in reversed(s[1:])]))({i:n for n,i in enumerate(digits)}), (lambda n, b: '0' if n == 1 else (lambda f: (lambda x: x(x))(lambda y: f(lambda *xs: y(y)(*xs))))(lambda f: lambda n, l, ds, xs: (xs[n][0] if n < len(xs) else f(n-len(xs), l+1, ds, [(s+d, x*b+i) for s,x in xs for i,d in enumerate(ds) if (x*b+i)%l==0])) if xs else None)(n - 2, 2, digits[:b], list(zip(digits, range(b)))[1:]))))('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')", "CHARS=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef base(number, base):\n    return sum([num * base**coeff for coeff, num in enumerate(number[::-1])])\n\ndef bias_checker(n, b, slicer=0):\n    if n[0] == b:\n        n[0]=0\n        n.insert(0,1)\n    elif n[-1+ slicer] == b:\n        n[-1 + slicer] = 0\n        n[-2 + slicer] += 1\n        bias_checker(n, b, slicer-1)\n    return\n\ndef get_polydivisible(n, b):\n    num = [0]\n    count = 0\n    polydiv_num = 0\n    while count < n:\n        for x in range(1, len(num)+1):\n            if base(num[:x], b) % x != 0:\n                num[-1] += 1\n                bias_checker(num, b)                \n                break\n        else:\n            count += 1\n            polydiv_num = num\n            num[-1] += 1\n            bias_checker(num, b)\n    num[-1] -= 1\n    return \"\".join([CHARS[x] for x in num]) \n\ndef is_polydivisible(s, b):\n    num = [CHARS.find(x) for x in s]\n    for x in range(1,len(num)+1):\n        if base(num[:x],b) % x != 0:\n            return False\n    return True", "CHARS=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef todecimal(s,b):\n    l=len(s)\n    res=0\n    for i in range(l):\n        c=s[i]\n        val=CHARS.find(c)\n        res=res+val*b**(l-i-1)\n    return res\n\ndef tobaseb(n,b):\n    res=''\n    restant=n\n    while restant>0:\n        res=CHARS[restant%b]+res\n        restant=restant//b\n    return res\n\ndef is_polydivisible(s, b):\n    yes=True\n    for i in range(len(s)):\n        if b!=10:\n            bout=str(todecimal(s[:i+1],b))\n        else:\n            bout=s[:i+1]\n        if int(bout)%(i+1)!=0:\n            yes=False\n            break\n    return yes\n\ndef get_polydivisible(n, b):\n    if n==1:\n        return '0'\n    c=0\n    i=0\n    while c<n:\n        if b!=10:\n            ib=tobaseb(i,b)\n        else:\n            ib=str(i)\n        if is_polydivisible(ib,b):\n            c=c+1\n        i=i+1\n    return ib", "CHARS=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef to_dec(s,b):\n    n = 0\n    for i,v in enumerate(s[::-1]):\n        n += CHARS.index(v)*b**i\n    return n\n\ndef to_base(n,b):\n    r = ''\n    while n >= b:\n        n,x = divmod(n,b)\n        r += CHARS[:b][x]\n    r += CHARS[:b][n]\n    return r[::-1]\n         \ndef is_polydivisible(s,b):\n    return all(not to_dec(s[:i],b)%i for i in range(1,len(s)+1))\n\ndef get_polydivisible(x,b):\n    c = 0\n    n = 0\n    while c<x:\n        try:\n            if is_polydivisible(to_base(n,b),b):\n                c += 1\n        except:\n            pass\n        n += 1\n    return to_base(n-1,b) or '0'", "CHARS=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef is_polydivisible(s, b):\n    divide=1\n    while divide<=len(s):\n        temp=divide\n        index=0\n        num=0\n        while temp>0:                \n            num+=CHARS.index(s[index])*(b**(temp-1))\n            temp-=1\n            index+=1\n        if num%divide!=0:\n            return False\n        divide+=1\n        num=0\n    return True\ndef get_polydivisible(n, b):\n    count=0\n    count2=0\n    temp=1\n    s=\"\"\n    while True:\n        if count2>=b**temp:\n            temp+=1\n        record=count2\n        power=temp \n        while len(s)<temp:                    \n            some=record//b**(power-1)\n            s+=CHARS[some]\n            record-=some*(b**(power-1))\n            power-=1\n        count2+=1\n        if is_polydivisible(s, b):\n            count+=1\n        if count==n:\n            return s\n        s=\"\"", "CHARS=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef is_polydivisible(s, b):\n    divide=1\n    if b==10:        \n        while divide<=len(s):\n            num=int(s[0:divide])\n            if num%divide!=0:\n                return False\n            divide+=1\n        return True\n    else:\n        while divide<=len(s):\n            temp=divide\n            index=0\n            num=0\n            while temp>0:                \n                num+=CHARS.index(s[index])*(b**(temp-1))\n                temp-=1\n                index+=1\n            if num%divide!=0:\n                return False\n            divide+=1\n            num=0\n        return True\ndef get_polydivisible(n, b):\n    count=0\n    count2=0\n    temp=1\n    s=\"\"\n    while True:\n        if count2>=b**temp:\n            temp+=1\n        record=count2\n        power=temp \n        while len(s)<temp:                    \n            some=record//b**(power-1)\n            s+=CHARS[some]\n            record-=some*(b**(power-1))\n            power-=1\n        count2+=1\n        if is_polydivisible(s, b):\n            count+=1\n        if count==n:\n            return s\n        s=\"\""]
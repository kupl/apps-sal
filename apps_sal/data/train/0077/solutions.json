["3\n\nimport math\nimport os\nimport sys\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nINF = 10 ** 20\n\n\ndef solve(N, A, B):\n    dp = {A[0]: 0, A[0] + 1: B[0], A[0] + 2: B[0] * 2}\n    for i in range(1, N):\n        ndp = {}\n\n        h = A[i]\n        for ph, c in dp.items():\n            for inc in range(3):\n                nh = h + inc\n                if ph == nh:\n                    continue\n                if nh not in ndp:\n                    ndp[nh] = INF\n                ndp[nh] = min(ndp[nh], c + B[i] * inc)\n\n        dp = ndp\n\n    return min(dp.values())\n\n\ndef main():\n    Q = int(inp())\n    for _ in range(Q):\n        N = int(inp())\n        A = []\n        B = []\n        for _ in range(N):\n            a, b = [int(e) for e in inp().split()]\n            A.append(a)\n            B.append(b)\n        print(solve(N, A, B))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nq=int(input())\n\nfor testcases in range(q):\n    n=int(input())\n    f=[tuple(map(int,input().split())) for i in range(n)]\n\n    \n    DP0=[0]*n\n    DP1=[0]*n\n    DP2=[0]*n\n\n    DP1[0]=f[0][1]\n    DP2[0]=f[0][1]*2\n\n    for i in range(1,n):\n        x=f[i-1][0]\n        y=f[i][0]\n\n        if y==x:\n            DP0[i]=min(DP1[i-1],DP2[i-1])\n            DP1[i]=f[i][1]+min(DP0[i-1],DP2[i-1])\n            DP2[i]=f[i][1]*2+min(DP0[i-1],DP1[i-1])\n\n        elif y==x+1:\n            DP0[i]=min(DP0[i-1],DP2[i-1])\n            DP1[i]=f[i][1]+min(DP0[i-1],DP1[i-1])\n            DP2[i]=f[i][1]*2+min(DP0[i-1],DP1[i-1],DP2[i-1])\n\n        elif y==x+2:\n            DP0[i]=min(DP0[i-1],DP1[i-1])\n            DP1[i]=f[i][1]+min(DP0[i-1],DP1[i-1],DP2[i-1])\n            DP2[i]=f[i][1]*2+min(DP0[i-1],DP1[i-1],DP2[i-1])\n\n        elif y==x-1:\n            DP0[i]=min(DP0[i-1],DP1[i-1],DP2[i-1])\n            DP1[i]=f[i][1]+min(DP1[i-1],DP2[i-1])\n            DP2[i]=f[i][1]*2+min(DP0[i-1],DP2[i-1])\n\n        elif y==x-2:\n            DP0[i]=min(DP0[i-1],DP1[i-1],DP2[i-1])\n            DP1[i]=f[i][1]+min(DP0[i-1],DP1[i-1],DP2[i-1])\n            DP2[i]=f[i][1]*2+min(DP1[i-1],DP2[i-1])\n            \n        else:\n            DP0[i]=min(DP0[i-1],DP1[i-1],DP2[i-1])\n            DP1[i]=f[i][1]+min(DP0[i-1],DP1[i-1],DP2[i-1])\n            DP2[i]=f[i][1]*2+min(DP0[i-1],DP1[i-1],DP2[i-1])\n\n    print(min(DP0[n-1],DP1[n-1],DP2[n-1]))\n            \n            \n            \n\n    \n", "import sys\ninput = sys.stdin.readline\n\nQ = int(input())\nfor _ in range(Q):\n    N = int(input())\n    X = []\n    ne = [0] * 3\n    for i in range(N):\n        a, b = list(map(int, input().split()))\n        X.append((a, b))\n        if i == 0:\n            ne = [0, b, b*2]\n            continue\n        Y = ne\n        ne = [1<<100] * 3\n        if X[i][0] != X[i-1][0]: ne[0] = min(ne[0], Y[0])\n        if X[i][0] != X[i-1][0]+1: ne[0] = min(ne[0], Y[1])\n        if X[i][0] != X[i-1][0]+2: ne[0] = min(ne[0], Y[2])\n        if X[i][0]+1 != X[i-1][0]: ne[1] = min(ne[1], Y[0] + b)\n        if X[i][0]+1 != X[i-1][0]+1: ne[1] = min(ne[1], Y[1] + b)\n        if X[i][0]+1 != X[i-1][0]+2: ne[1] = min(ne[1], Y[2] + b)\n        if X[i][0]+2 != X[i-1][0]: ne[2] = min(ne[2], Y[0] + b * 2)\n        if X[i][0]+2 != X[i-1][0]+1: ne[2] = min(ne[2], Y[1] + b * 2)\n        if X[i][0]+2 != X[i-1][0]+2: ne[2] = min(ne[2], Y[2] + b * 2)\n        \n    print(min(ne))\n", "from sys import stdin\ninput = stdin.readline\nq = int(input())\nfor rwe in range(q):\n\tn = int(input())\n\ta = [0] * n\n\tb = [0] * n\n\tfor i in range(n):\n\t\tx, y = map(int, input().split())\n\t\ta[i] = x\n\t\tb[i] = y\n\tdp = [[0,0,0] for i in range(n)]\n\tdp[0][0] = 0\n\tdp[0][1] = b[0]\n\tdp[0][2] = 2 * b[0]\n\tfor i in range(1, n):\n\t\tfor pod in range(3):\n\t\t\tx = (dp[i-1][0] if a[i-1] != a[i] + pod else 100000000000000000000000000)\n\t\t\ty = (dp[i-1][1] if a[i-1] + 1 != a[i] + pod else 10000000000000000000000000000)\n\t\t\tz = (dp[i-1][2] if a[i-1] + 2 != a[i] + pod else 10000000000000000000000000000)\n\t\t\tdp[i][pod] = min(x, y, z) + pod*b[i]\n\tprint(min(dp[n-1]))", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\n\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm += i\n        res.append(sm)\n    return res\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = True\nfac_warm_up_size = 10 ** 5 + 100\noptimise_for_recursion = False  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    n = get_int()\n    lengths = []\n    costs = []\n\n    for _ in range(n):\n        a, b = get_tuple()\n        lengths.append(a)\n        costs.append(b)\n    dp = [[0, costs[0], 2*costs[0]]]\n    for i in range(1, n):\n        kt = [10 ** 20] * 3\n        for k in range(3):\n            for j, ele in enumerate(dp[-1]):\n                if lengths[i-1]+j!=lengths[i]+k:\n                    kt[k] = min(kt[k], ele+costs[i]*k)\n        dp.append(kt)\n    #print(dp)\n    print(min(dp[-1]))\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n", "import sys\ninput = sys.stdin.readline\n\nq = int(input())\nfor i in range(q):\n    n = int(input())\n    dp = [[0] * n for _ in range(3)]\n    prev = 0\n    for i in range(n):\n        l, c = [int(item) for item in input().split()]\n        if i == 0:\n            dp[0][0] = 0\n            dp[1][0] = c\n            dp[2][0] = c * 2\n            prev = l\n            continue\n        prev_min = min(dp[0][i-1], dp[1][i-1], dp[2][i-1])\n        if l > prev + 2:\n            dp[0][i] = prev_min\n            dp[1][i] = prev_min + c\n            dp[2][i] = prev_min + c * 2\n        elif l == prev + 2:\n            dp[0][i] = min(dp[0][i-1], dp[1][i-1])\n            dp[1][i] = prev_min + c\n            dp[2][i] = prev_min + c * 2\n        elif l == prev + 1:\n            dp[0][i] = min(dp[0][i-1], dp[2][i-1]) \n            dp[1][i] = min(dp[0][i-1], dp[1][i-1]) + c\n            dp[2][i] = prev_min + c * 2\n        elif l == prev:\n            dp[0][i] = min(dp[1][i-1], dp[2][i-1])\n            dp[1][i] = min(dp[0][i-1], dp[2][i-1]) + c\n            dp[2][i] = min(dp[0][i-1], dp[1][i-1]) + 2 * c\n        elif l == prev - 1:\n            dp[0][i] = prev_min\n            dp[1][i] = min(dp[1][i-1], dp[2][i-1]) + c\n            dp[2][i] = min(dp[0][i-1], dp[2][i-1]) + 2 * c\n        elif l == prev - 2:\n            dp[0][i] = prev_min\n            dp[1][i] = prev_min + c\n            dp[2][i] = min(dp[1][i-1], dp[2][i-1]) + 2 * c\n        elif l < prev - 2:\n            dp[0][i] = prev_min\n            dp[1][i] = prev_min + c\n            dp[2][i] = prev_min + c * 2\n        prev = l\n    print(min(dp[0][n-1], dp[1][n-1], dp[2][n-1]))", "import sys\ninput = sys.stdin.readline\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    d = [[-100, 0]] + [list(map(int, input().split())) for _ in range(n)]\n    dp = [[100 for j in range(3)] for i in range(n+1)]\n    dp[0] = [0, 0, 0, 0]\n    for i in range(n):\n        if d[i+1][0] == d[i][0]:\n            dp[i+1][0] = min(dp[i][1], dp[i][2])\n            dp[i+1][1] = min(dp[i][0], dp[i][2]) + d[i+1][1]\n            dp[i+1][2] = min(dp[i][0], dp[i][1]) + d[i+1][1] * 2\n        elif d[i+1][0] + 1 == d[i][0]:\n            dp[i+1][0] = min(dp[i])\n            dp[i+1][1] = min(dp[i][1], dp[i][2]) + d[i+1][1]\n            dp[i+1][2] = min(dp[i][0], dp[i][1]) + d[i+1][1] * 2\n        elif d[i+1][0] + 2 == d[i][0]:\n            dp[i+1][0] = min(dp[i])\n            dp[i+1][1] = min(dp[i]) + d[i+1][1]\n            dp[i+1][2] = min(dp[i][1], dp[i][2]) + d[i+1][1] * 2\n        elif d[i+1][0] - 1 == d[i][0]:\n            dp[i+1][0] = min(dp[i][0], dp[i][2])\n            dp[i+1][1] = min(dp[i][1], dp[i][0]) + d[i+1][1]\n            dp[i+1][2] = min(dp[i]) + d[i+1][1] * 2\n        elif d[i+1][0] - 2 == d[i][0]:\n            dp[i+1][0] = min(dp[i][0], dp[i][1])\n            dp[i+1][1] = min(dp[i]) + d[i+1][1]\n            dp[i+1][2] = min(dp[i]) + d[i+1][1] * 2\n        else:\n            dp[i+1][0] = min(dp[i])\n            dp[i+1][1] = min(dp[i]) + d[i+1][1]\n            dp[i+1][2] = min(dp[i]) + d[i+1][1] * 2\n    print(min(dp[n]))\n", "import sys\ninput=sys.stdin.readline\nq=int(input())\nfor _ in range(q):\n  n=int(input())\n  ans=0\n  a,b=list(map(int,input().split()))\n  cur=a\n  A=[0,b,2*b]\n  for i in range(n-1):\n    a=cur\n    na,nb=list(map(int,input().split()))\n    cur=na\n    a0,a1,a2=A\n    if na==a:\n      A[0]=min(a1,a2)\n      A[1]=nb+min(a0,a2)\n      A[2]=2*nb+min(a0,a1)\n    elif na==a-1:\n      A[0]=min(a0,a1,a2)\n      A[1]=nb+min(a1,a2)\n      A[2]=2*nb+min(a0,a2)\n    elif na==a-2:\n      A[0]=min(a0,a1,a2)\n      A[1]=nb+min(a0,a1,a2)\n      A[2]=2*nb+min(a1,a2)\n    elif na==a+1:\n      A[0]=min(a0,a2)\n      A[1]=nb+min(a0,a1)\n      A[2]=2*nb+min(a0,a1,a2)\n    elif na==a+2:\n      A[0]=min(a0,a1)\n      A[1]=nb+min(a0,a1,a2)\n      A[2]=2*nb+min(a0,a1,a2)\n    else:\n      A[0]=min(a0,a1,a2)\n      A[1]=nb+min(a0,a1,a2)\n      A[2]=2*nb+min(a0,a1,a2)\n \n  print(min(A))\n", "import sys\ninput = sys.stdin.readline\n\nQ = int(input())\ndata = []\nfor _ in range(Q):\n    N = int(input())\n    A = []\n    B = []\n    for _ in range(N):\n        a, b = list(map(int, input().split()))\n        A.append(a)\n        B.append(b)\n    data.append([N, A, B])\n\nfor N, A, B in data:\n    dp = [[0, 0, 0] for _ in range(N)]\n    dp[0][1] = B[0]\n    dp[0][2] = 2*B[0]\n    for i in range(1, N):\n        if A[i] == A[i-1]:\n            dp[i][0] = min(dp[i-1][1], dp[i-1][2])\n        elif A[i] == A[i-1]+1:\n            dp[i][0] = min(dp[i-1][0], dp[i-1][2])\n        elif A[i] == A[i-1]+2:\n            dp[i][0] = min(dp[i-1][0], dp[i-1][1])\n        else:\n            dp[i][0] = min([dp[i-1][0], dp[i-1][1], dp[i-1][2]])\n        \n        if A[i] == A[i-1]+1:\n            dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + B[i]\n        elif A[i] == A[i-1]:\n            dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + B[i]\n        elif A[i] == A[i-1]-1:\n            dp[i][1] = min(dp[i-1][1], dp[i-1][2]) + B[i]\n        else:\n            dp[i][1] = min([dp[i-1][0], dp[i-1][1], dp[i-1][2]]) + B[i]\n        \n        if A[i] == A[i-1]:\n            dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + 2*B[i]\n        elif A[i] == A[i-1]-1:\n            dp[i][2] = min(dp[i-1][0], dp[i-1][2]) + 2*B[i]\n        elif A[i] == A[i-1]-2:\n            dp[i][2] = min(dp[i-1][1], dp[i-1][2]) + 2*B[i]\n        else:\n            dp[i][2] = min([dp[i-1][0], dp[i-1][1], dp[i-1][2]]) + 2*B[i]\n    ans = min(dp[N-1])\n    print(ans)\n\n", "'''input\n3\n3\n2 4\n2 1\n3 5\n3\n2 3\n2 10\n2 6\n4\n1 7\n3 3\n2 6\n1000000000 2\n'''\nfrom sys import stdin\nfrom math import ceil, log\n\n\n# main starts\nq = int(stdin.readline().strip())\nfor _ in range(q):\n\tn = int(stdin.readline().strip())\n\th = []\n\tc  = []\n\tdp = dict()\n\tfor i in range(n):\n\t\ta, b = list(map(int, stdin.readline().split()))\n\t\th.append(a)\n\t\tc.append(b)\n\tdp = [[0 for x in range(3)] for y in range(n)]\n\tdp[0][0] = 0\n\tdp[0][1] = c[0]\n\tdp[0][2] = 2*c[0]\n\tfor i in range(1, n):\n\t\tif h[i] == h[i - 1]:\n\t\t\tdp[i][0] = min(dp[i - 1][1], dp[i- 1][2])\n\t\t\tdp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + c[i]\n\t\t\tdp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + 2 * c[i]\n\t\telif h[i] + 1 == h[i - 1]:\n\t\t\tdp[i][0] = min(dp[i - 1])\n\t\t\tdp[i][1] = min(dp[i - 1][1], dp[i - 1][2]) + c[i]\n\t\t\tdp[i][2] = min(dp[i - 1][0], dp[i - 1][2]) + 2 * c[i]\n\t\telif h[i] + 2 == h[i - 1]:\n\t\t\tdp[i][0] = min(dp[i - 1])\n\t\t\tdp[i][1] = min(dp[i - 1])+ c[i]\n\t\t\tdp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + 2 * c[i]\n\t\telif h[i] == h[i - 1] + 1:\n\t\t\tdp[i][0] = min(dp[i - 1][0], dp[i - 1][2])\n\t\t\tdp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + c[i]\n\t\t\tdp[i][2] = min(dp[i - 1]) + 2 * c[i]\n\t\telif h[i] == h[i - 1] + 2:\n\t\t\tdp[i][0] = min(dp[i - 1][:2])\n\t\t\tdp[i][1] = min(dp[i - 1])+ c[i]\n\t\t\tdp[i][2] = min(dp[i - 1]) + 2 * c[i]\n\n\t\telse:\n\t\t\tdp[i][0] = min(dp[i - 1])\n\t\t\tdp[i][1] = min(dp[i - 1])+ c[i]\n\t\t\tdp[i][2] = min(dp[i - 1]) + 2 * c[i]\n\tprint(min(dp[-1]))", "import sys\nfrom math import inf as inf\nfor _ in range(int(input())):\n    n=int(sys.stdin.readline())\n    dp=[[inf,inf,inf] for i in range(n+1)]\n    a=[]\n    for i in range(n):\n        a.append(list(map(int,sys.stdin.readline().split())))\n    dp[0][0]=0\n    dp[0][1]=a[0][1]\n    dp[0][2]=2*a[0][1]\n    for i in range(1,n):\n        for j in range(3):\n            for k in range(3):\n                if a[i][0] + j != a[i-1][0] + k:\n                    dp[i][j]=min(dp[i][j],dp[i-1][k] + j*a[i][1])\n    # print(dp)                \n    print(min(dp[n-1]))                ", "from sys import stdin\n\ntest = stdin.readlines()\ninf = float('infinity')\n\nq = int(test[0])\nk = 1\nfor _ in range(q):\n    n = int(test[k])\n\n    h, c = [], []\n    for j in range(k+1, k+n+1):\n        x, y = list(map(int, test[j].split()))\n        h.append(x)\n        c.append(y)\n\n    dp = [[0, c[0], 2 * c[0]]] + [[0, 0, 0] for i in range(n-1)]\n\n    for i in range(1, n):\n        for j in range(3):\n            x = (dp[i - 1][0] if h[i - 1] != h[i] + j else inf)\n            y = (dp[i - 1][1] if h[i - 1] + 1 != h[i] + j else inf)\n            z = (dp[i - 1][2] if h[i - 1] + 2 != h[i] + j else inf)\n            dp[i][j] = min(x, y, z) + j * c[i]\n\n    print(min(dp[n - 1]))\n\n    k += n + 1\n", "from sys import stdin\n\ntest = stdin.readlines()\ninf = float('infinity')\n\nq = int(test[0])\nk = 1\nfor _ in range(q):\n    n = int(test[k])\n\n    h, c = [], []\n    for j in range(k+1, k+n+1):\n        x, y = list(map(int, test[j].split()))\n        h.append(x)\n        c.append(y)\n\n    dp = [[0, c[0], 2 * c[0]]]\n    dp += [[0, 0, 0] for i in range(n-1)]\n\n    for i in range(1, n):\n        for j in range(3):\n            x = (dp[i - 1][0] if h[i - 1] != h[i] + j else inf)\n            y = (dp[i - 1][1] if h[i - 1] + 1 != h[i] + j else inf)\n            z = (dp[i - 1][2] if h[i - 1] + 2 != h[i] + j else inf)\n            dp[i][j] = min(x, y, z) + j * c[i]\n\n    print(min(dp[n - 1]))\n\n    k += n + 1\n", "from sys import stdin\n\ntest = stdin.readlines()\ninf = float('infinity')\n\nq = int(test[0])\nk = 1\nfor _ in range(q):\n    n = int(test[k])\n\n    h, c = [], []\n    for j in range(k+1, k+n+1):\n        x, y = list(map(int, test[j].split()))\n        h.append(x)\n        c.append(y)\n\n    dp = [[0, 0, 0] for i in range(n)]\n    dp[0] = [0, c[0], 2 * c[0]]\n\n    for i in range(1, n):\n        for j in range(3):\n            x = (dp[i - 1][0] if h[i - 1] != h[i] + j else inf)\n            y = (dp[i - 1][1] if h[i - 1] + 1 != h[i] + j else inf)\n            z = (dp[i - 1][2] if h[i - 1] + 2 != h[i] + j else inf)\n            dp[i][j] = min(x, y, z) + j * c[i]\n\n    print(min(dp[n - 1]))\n\n    k += n + 1\n", "from sys import stdin\n\ntest = stdin.readlines()\ninf = float('infinity')\n\nq = int(test[0])\nk = 1\nfor _ in range(q):\n    n = int(test[k])\n\n    h, c = [0]*n, [0]*n\n    for j in range(k+1, k+n+1):\n        h[j-k-1], c[j-k-1] = list(map(int, test[j].split()))\n\n    dp = [[0, c[0], 2 * c[0]]] + [[0, 0, 0] for i in range(n-1)]\n\n    for i in range(1, n):\n        for j in range(3):\n            x = (dp[i - 1][0] if h[i - 1] != h[i] + j else inf)\n            y = (dp[i - 1][1] if h[i - 1] + 1 != h[i] + j else inf)\n            z = (dp[i - 1][2] if h[i - 1] + 2 != h[i] + j else inf)\n            dp[i][j] = min(x, y, z) + j * c[i]\n\n    print(min(dp[n - 1]))\n\n    k += n + 1\n", "import sys\ninput = sys.stdin.readline\nt=int(input()) \nfor rainbow in range(t):\n    n=int(input())\n    f=[tuple(map(int,input().split())) for i in range(n)]\n    dp=[0]*n;dp1=[0]*n;dp2=[0]*n\n    dp1[0]=f[0][1];dp2[0]=f[0][1]*2\n    for i in range(1,n):\n        a=f[i-1][0]\n        b=f[i][0]\n        if b==a:\n            dp[i]=min(dp1[i-1],dp2[i-1])\n            dp1[i]=f[i][1]+min(dp[i-1],dp2[i-1])\n            dp2[i]=f[i][1]*2+min(dp[i-1],dp1[i-1])\n        elif b==a+1:\n            dp[i]=min(dp[i-1],dp2[i-1])\n            dp1[i]=f[i][1]+min(dp[i-1],dp1[i-1])\n            dp2[i]=f[i][1]*2+min(dp[i-1],dp1[i-1],dp2[i-1])\n        elif b==a+2:\n            dp[i]=min(dp[i-1],dp1[i-1])\n            dp1[i]=f[i][1]+min(dp[i-1],dp1[i-1],dp2[i-1])\n            dp2[i]=f[i][1]*2+min(dp[i-1],dp1[i-1],dp2[i-1])\n        elif b==a-1:\n            dp[i]=min(dp[i-1],dp1[i-1],dp2[i-1])\n            dp1[i]=f[i][1]+min(dp1[i-1],dp2[i-1])\n            dp2[i]=f[i][1]*2+min(dp[i-1],dp2[i-1])\n        elif b==a-2:\n            dp[i]=min(dp[i-1],dp1[i-1],dp2[i-1])\n            dp1[i]=f[i][1]+min(dp[i-1],dp1[i-1],dp2[i-1])\n            dp2[i]=f[i][1]*2+min(dp1[i-1],dp2[i-1])\n        else:\n            dp[i]=min(dp[i-1],dp1[i-1],dp2[i-1])\n            dp1[i]=f[i][1]+min(dp[i-1],dp1[i-1],dp2[i-1])\n            dp2[i]=f[i][1]*2+min(dp[i-1],dp1[i-1],dp2[i-1])\n    print(min(dp[n-1],dp1[n-1],dp2[n-1]))", "\"\"\"\nNTC here\n\"\"\"\nfrom sys import setcheckinterval, stdin, setrecursionlimit\nsetcheckinterval(1000)\nsetrecursionlimit(10**7)\n \n# print(\"Case #{}: {} {}\".format(i, n + m, n * m))\n \n \ndef iin(): return int(stdin.readline())\n \n \ndef lin(): return list(map(int, stdin.readline().split()))\n\nfor _ in range(iin()):\n    n=iin()\n    fence=[lin() for i in range(n)]\n    dp=[[0,j,2*j] for i,j in fence]\n    for i in range(1,n):\n        for j in range(3):\n            dp[i][j]+= min([dp[i-1][k] for k in range(3) if fence[i-1][0]+k!=fence[i][0]+j])\n    #print(*dp)\n    print(min(dp[-1]))", "# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\n# import random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n# @mt\ndef slv(N, AB):\n    \n    memo = [0, AB[0][1], AB[0][1]*2]\n\n    for i in range(1, N):\n        a, b = AB[i]\n        a1, _ = AB[i-1]\n        memo2 = [0] * 3\n        for j in range(3):\n            tmp = 1e+1000\n            for k in range(3):\n                if a + j != a1 + k:\n                    tmp = min(tmp, memo[k])\n            memo2[j] = tmp + j * b\n        memo = memo2\n    return min(memo)\n\n\ndef main():\n    Q = read_int()\n    for _ in range(Q):\n        N = read_int()\n        AB = [read_int_n() for _ in range(N)]\n        print(slv(N, AB))\n\n    # N = 100\n    # AB = [[1000000000, 1000000000] for _ in range(N)]\n    # print(slv(N, AB))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\n\nfor q in range(int(input())):\n    n = int(sys.stdin.readline())\n    data = []\n    for i in range(n):\n        data.append([int(j) for j in sys.stdin.readline().split()])\n    dp = [[0, data[0][1], 2 * data[0][1]]]\n    for i in range(1, n):\n        a, b = data[i]\n        lasta = data[i-1][0]\n        l = dp[-1]\n\n        vals = [(lasta + j) for j in range(3)]\n        ans = [0]*3\n        for j in range(3):\n            w = a + j\n            x = [ l[k] for k in range(3) if lasta + k != w ]\n            # print(w, dp[-1], x)\n            ans[j] = j*b + min(x)\n        dp.append(ans)\n    print(min(dp[-1]))\n    # print(dp)\n", "from math import inf as inf\nimport sys\nfor _ in range(int(input())):\n    n=int(sys.stdin.readline())\n    dp = [[inf,inf,inf] for _ in range(n+1)]\n    arr = []\n    for i in range(n):\n        arr.append(list(map(int,sys.stdin.readline().split())))\n    dp[0] = [0,arr[0][1],arr[0][1]*2]\n    \n    for i in range(1,n):\n        for j in range(3):\n            for k in range(3):\n                if arr[i][0]+j!=arr[i-1][0]+k:\n                    dp[i][j] = min(dp[i][j],dp[i-1][k]+j*arr[i][1])\n    print(min(dp[n-1]))\n\n", "import sys, math\nINF = float(\"inf\")\ndef main():\n    def input():\n        return sys.stdin.readline()[:-1]\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        w = [list(map(int,input().split())) for k in range(n)]\n        dp = [[INF,INF,INF] for k in range(n)]\n        dp[0] = [0,w[0][1],2*w[0][1]]\n        for k in range(1,n):\n            for l in range(3):\n                for m in range(3):\n                    if w[k-1][0]+l != w[k][0]+m:\n                        dp[k][m] = min(dp[k][m], dp[k-1][l] + w[k][1]*m)\n        print(min(dp[n-1]))\ndef __starting_point():\n    main()\n\n__starting_point()"]
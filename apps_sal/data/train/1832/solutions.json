["class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        conns = defaultdict(dict)\n        for i, j, n in edges:\n            conns[i][j] = n\n            conns[j][i] = n\n\n        heap = [(0, 0)]\n        visited = set()\n        ans = 0\n\n        while heap:\n            d, n = heapq.heappop(heap)\n            if n not in visited:\n                visited.add(n)\n                ans += 1\n                for m, inter in conns[n].items():\n                    if m in visited:\n                        ans += min(M-d, conns[n][m])\n                    else:\n                        if d+inter < M:\n                            heapq.heappush(heap, (d+inter+1, m))\n                            ans += inter\n                            conns[m][n] = 0\n                        else:\n                            ans += M-d\n                            conns[m][n] -= M-d\n\n        return ans", "#\n# @lc app=leetcode id=882 lang=python3\n#\n# [882] Reachable Nodes In Subdivided Graph\n#\n# https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/description/\n#\n# algorithms\n# Hard (40.58%)\n# Likes:    161\n# Dislikes: 139\n# Total Accepted:    6.1K\n# Total Submissions: 14.7K\n# Testcase Example:  '[[0,1,10],[0,2,1],[1,2,2]]\\\n6\\\n3'\n#\n# Starting with an\u00a0undirected graph (the \\\"original graph\\\") with nodes from 0 to\n# N-1, subdivisions are made to some of the edges.\n# \n# The graph is given as follows: edges[k] is a list of integer pairs (i, j, n)\n# such that (i, j) is an edge of the original graph,\n# \n# and n is the total number of new nodes on that edge.\u00a0\n# \n# Then, the edge (i, j) is deleted from the original graph,\u00a0n\u00a0new nodes (x_1,\n# x_2, ..., x_n) are added to the original graph,\n# \n# and n+1 new\u00a0edges (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n),\n# (x_n, j)\u00a0are added to the original\u00a0graph.\n# \n# Now, you start at node 0\u00a0from the original graph, and in each move, you\n# travel along one\u00a0edge.\u00a0\n# \n# Return how many nodes you can reach in at most mMoves moves.\n# \n# \n# \n# Example 1:\n# \n# \n# Input: edges = [[0,1,10],[0,2,1],[1,2,2]], mMoves = 6, N = 3\n# Output: 13\n# Explanation: \n# The nodes that are reachable in the final graph after mMoves = 6 moves are\n# indicated below.\n# \n# \n# \n# \n# Example 2:\n# \n# \n# Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], mMoves = 10, N = 4\n# Output: 23\n# \n# \n# \n# \n# Note:\n# \n# \n# 0 <= edges.length <= 10000\n# 0 <= edges[i][0] <\u00a0edges[i][1] < N\n# There does not exist any\u00a0i != j for which edges[i][0] == edges[j][0] and\n# edges[i][1] == edges[j][1].\n# The original graph\u00a0has no parallel edges.\n# 0 <= edges[i][2] <= 10000\n# 0 <= mMoves <= 10^9\n# 1 <= N <= 3000\n# A reachable node is a node that can be travelled to\u00a0using at most\u00a0mMoves moves\n# starting from\u00a0node 0.\n# \n# \n# \n# \n# \n# \n#\n\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], mMoves: int, N: int) -> int:\n        \\\"\\\"\\\"\n        :ref: https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/discuss/156739/C%2B%2BJavaPython-Dijkstra-%2B-Priority-Queue\n        \\\"\\\"\\\"\n        graph = collections.defaultdict(dict)\n        for i, j, lenInserted in edges: graph[i][j] = graph[j][i] = lenInserted\n        maxHeap = [(-mMoves, 0)]\n        seen = {}\n\n        while maxHeap:\n            negNumMoves, nodeIdx = heapq.heappop(maxHeap)\n            if nodeIdx not in seen:\n                seen[nodeIdx] = -negNumMoves\n                for neighborIdx in graph[nodeIdx]:\n                    nextNumMoves = -negNumMoves - graph[nodeIdx][neighborIdx] - 1\n                    if neighborIdx not in seen and nextNumMoves >= 0:\n                        heapq.heappush(maxHeap, (-nextNumMoves, neighborIdx))\n\n        res = len(seen)\n        for i, j, k in edges:\n            res += min(seen.get(i, 0) + seen.get(j, 0), graph[i][j])\n        return res\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = collections.defaultdict(dict)\n        for u, v, w in edges:\n            g[u][v] = w\n            g[v][u] = w\n        q = [(0, 0)]\n        visited = [10 ** 9 + 1 for i in range(N)]\n        visited[0] = 0\n        edges2 = set()\n        edges3 = {}\n        while q:\n            m, u = heapq.heappop(q)\n            if m > visited[u]:\n                continue\n            for v, w in list(g[u].items()):\n                mm = m + w + 1\n                t = (min(u, v), max(u, v))\n                if mm <= M:\n                    edges2.add(t)\n                else:\n                    if t not in edges3:\n                        edges3[t] = [0, 0]\n                    if u < v:\n                        edges3[t][0] = max(edges3[t][0], M - m)\n                    else:\n                        edges3[t][1] = max(edges3[t][1], M - m)\n                if mm <= M and mm < visited[v]:\n                    visited[v] = mm\n                    heapq.heappush(q, (mm, v))\n        result = 0\n        nodes = set()\n        for u, v in edges2:\n            result += g[v].get(u, 0)\n            nodes.add(u)\n            nodes.add(v)\n        result += len(nodes)\n        if result == 0:\n            result += 1\n        for k, v in list(edges3.items()):\n            if k in edges2:\n                continue\n            result += min(sum(v), g[k[0]][k[1]])\n        return result\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = collections.defaultdict(dict)\n        for s, e, v in edges:\n            g[s][e] = g[e][s] = v\n            \n        dist = {0:0}\n        pq = [(0, 0)]\n        used = {}\n        ans = 0\n\n        \n        while pq:\n            \n            d, node = heapq.heappop(pq)\n            if d > dist[node]:\n                continue\n                \n            ans += 1\n            \n            for e, w in g[node].items():\n                \n                v = min(w, M - d)\n                used[node, e] = v\n                \n                d2 = d + w + 1\n                if d2 < dist.get(e, M+1):\n                    heapq.heappush(pq, (d2, e))\n                    dist[e] = d2\n                    \n        for s, e, w in edges:\n            ans += min(w, used.get((s, e), 0) + used.get((e, s), 0))\n            \n        return ans", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        e = collections.defaultdict(dict)\n        for i, j, l in edges: e[i][j] = e[j][i] = l\n        pq = [(-M, 0)]\n        seen = {}\n        while pq:\n            moves, i = heapq.heappop(pq)\n            if i not in seen:\n                seen[i] = -moves\n                for j in e[i]:\n                    moves2 = -moves - e[i][j] - 1\n                    if j not in seen and moves2 >= 0:\n                        heapq.heappush(pq, (-moves2, j))\n        res = len(seen)\n        for i, j, k in edges:\n            res += min(seen.get(i, 0) + seen.get(j, 0), e[i][j])\n        return res", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = defaultdict(list)\n        e2i = {}\n        reach = {}\n        res = 0\n        heap = [(0, 0)]\n        hm = {0:0}\n        \n        for i, (u, v, w) in enumerate(edges):\n            graph[u].append([v, w])\n            graph[v].append([u, w])\n            e2i[(u, v)] = i\n            e2i[(v, u)] = i\n            reach[i] = 0\n\n        while heap:\n            moves, node = heapq.heappop(heap)\n            if moves>hm[node]: continue\n            \n            res += 1\n            for nei, cost in graph[node]:\n                idx = e2i[(node, nei)]\n                reach[idx] = min(cost, reach[idx]+M-moves)\n            \n                h = moves+cost+1\n                if h<hm.get(nei, M+1):\n                    hm[nei] = h\n                    heapq.heappush(heap, (h, nei))\n\n        return res+sum(reach.values())\n                \n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = collections.defaultdict(dict)\n        for u, v, w in edges:\n            g[u][v] = w\n            g[v][u] = w\n        q = [(0, 0, 0)]\n        visited = [[10 ** 9 + 1, -1] for i in range(N)]\n        visited[0] = [0, -1]\n        while q:\n            m, u, p = heapq.heappop(q)\n            if m > visited[u][0]:\n                continue\n            for v, w in list(g[u].items()):\n                if v == p:\n                    continue\n                mm = m + w + 1\n                if mm <= M and mm < visited[v][0]:\n                    visited[v][0] = mm\n                    visited[v][1] = u\n                    heapq.heappush(q, (mm, v, u))\n        edges2 = set()\n        edges3 = {}\n        for u, (m, v) in enumerate(visited):\n            if m > M:\n                continue\n            edges2.add((min(u, v), max(u, v)))\n            for k, w in list(g[u].items()):\n                if k == v:\n                    continue\n                t = (min(u, k), max(u, k))\n                if m + w + 1 <= M:\n                    edges2.add(t)\n                else:\n                    if t not in edges3:\n                        edges3[t] = [0, 0]\n                    if u < k:\n                        edges3[t][0] = max(edges3[t][0], M - m)\n                    else:\n                        edges3[t][1] = max(edges3[t][1], M - m)\n        result = 0\n        nodes = set()\n        for u, v in edges2:\n            result += g[v].get(u, 0)\n            nodes.add(u)\n            nodes.add(v)\n        result += len(nodes) - 1\n        for k, v in list(edges3.items()):\n            if k in edges2:\n                continue\n            result += min(sum(v), g[k[0]][k[1]])\n        return result\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = [[] for _ in range(N)]\n        for i,j,n in edges:\n            g[i].append((j,n))\n            g[j].append((i,n))\n        \n        q = [(-M, 0)]\n        visited = [-sys.maxsize] * N\n        ans = 0\n        while q:\n            hp, cur = heapq.heappop(q)\n            if visited[cur] != -sys.maxsize: continue\n            hp *= -1\n            visited[cur] = hp\n            ans += 1\n            for nxt, cost in g[cur]:\n                nxt_hp = hp - cost - 1\n                if visited[nxt] != -sys.maxsize or nxt_hp < 0:                     \n                    continue                \n                heapq.heappush(q, (-nxt_hp, nxt))\n                \n        for i,j,n in edges:\n            ui, uj = 0, 0\n            if visited[i] != -sys.maxsize: ui = visited[i]\n            if visited[j] != -sys.maxsize: uj = visited[j]\n            ans += min(n, (ui+uj))\n        return ans\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = collections.defaultdict(dict)\n        for u, v, w in edges:\n            graph[u][v] = graph[v][u] = w\n\n        pq = [(0, 0)]\n        dist = {0: 0}\n        used = {}\n        ans = 0\n\n        while pq:\n            d, node = heapq.heappop(pq)\n            if d > dist[node]: continue\n            # Each node is only visited once.  We've reached\n            # a node in our original graph.\n            ans += 1\n\n            for nei, weight in list(graph[node].items()):\n                # M - d is how much further we can walk from this node;\n                # weight is how many new nodes there are on this edge.\n                # v is the maximum utilization of this edge.\n                v = min(weight, M - d)\n                used[node, nei] = v\n\n                # d2 is the total distance to reach 'nei' (neighbor) node\n                # in the original graph.\n                d2 = d + weight + 1\n                if d2 < dist.get(nei, M+1):\n                    heapq.heappush(pq, (d2, nei))\n                    dist[nei] = d2\n\n        # At the end, each edge (u, v, w) can be used with a maximum\n        # of w new nodes: a max of used[u, v] nodes from one side,\n        # and used[v, u] nodes from the other.\n        for u, v, w in edges:\n            ans += min(w, used.get((u, v), 0) + used.get((v, u), 0))\n\n        return ans\n        \n                \n", "from collections import defaultdict\nimport heapq\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = defaultdict(dict)\n        for ii, jj, kk in edges:\n             g[ii][jj] = g[jj][ii] = kk\n        queue, flag = [(0, 0)], {0: 0}\n        used = {}\n        res = 0\n        while queue:\n            d, head = heapq.heappop(queue)\n            # print(d, head)\n            if d > flag.get(head):\n                continue\n            res += 1\n            for kk, vv in list(g[head].items()):\n                v = min(vv, M - d)\n                used[(head, kk)] = v\n                now_d = d + vv + 1\n                if now_d < flag.get(kk, M + 1):\n                    heapq.heappush(queue, (now_d, kk))\n                    flag[kk] = now_d\n                    \n        for ii, jj, kk in edges:\n            res += min(kk, used.get((ii, jj), 0) + used.get((jj, ii), 0))\n        return res\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        conns = defaultdict(dict)\n        for i, j, n in edges:\n            conns[i][j] = n\n            conns[j][i] = n\n\n        heap = [(0, 0)]\n        visited = set()\n        ans = 0\n\n        while heap:\n            d, n = heapq.heappop(heap)\n            if n not in visited:\n                visited.add(n)\n                ans += 1\n                for m, inter in list(conns[n].items()):\n                    if m in visited:\n                        ans += min(M-d, conns[n][m])\n                    else:\n                        if d+inter < M:\n                            heapq.heappush(heap, (d+inter+1, m))\n                            ans += inter\n                            conns[m][n] = 0\n                        else:\n                            ans += M-d\n                            conns[m][n] -= M-d\n\n        return ans\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = collections.defaultdict(list)\n        for u, v, insert_cnt in edges:\n            graph[u].append((v, insert_cnt))\n            graph[v].append((u, insert_cnt))\n            \n        hq = [(-M, 0)]          # (currently how many moves left, curr_node)\n        moves_left = collections.defaultdict(int)\n        \n        while len(hq) > 0:\n            curr_moves_left, curr_node = heappop(hq)  # \u8d2a\u5fc3\u5c31\u8d2a\u5728\u8fd9\uff0c\u6bcf\u6b21pop\u51fa\u6765\u7684\u90fd\u662f\u5269\u4f59\u6b65\u6570\u6700\u591a\uff08\u5373\u79bbsoure node\u6700\u8fd1\uff09\u7684node\n            curr_moves_left = -curr_moves_left\n            \n            if curr_node in moves_left:     # if we have already reached this node with less steps, then just skip it\n                continue\n            moves_left[curr_node] = curr_moves_left\n            \n            for next_node, insert_cnt in graph[curr_node]:\n                if insert_cnt >= curr_moves_left:   # we cannot reach the nextNode if there is not enough moves left\n                    continue\n                heappush(hq, (-(curr_moves_left - insert_cnt - 1), next_node))\n                \n        res = len(moves_left)\n        for u, v, insert_cnt in edges:\n            res += min(moves_left[u] + moves_left[v], insert_cnt)\n        return res", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = collections.defaultdict(dict)\n        for u, v, w in edges:\n            g[u][v] = w\n            g[v][u] = w\n        q = [(0, 0)]\n        visited = [10 ** 9 + 1 for i in range(N)]\n        visited[0] = 0\n        result = 0\n        edges2 = {}\n        while q:\n            m, u = heapq.heappop(q)\n            if m > visited[u]:\n                continue\n            result += 1\n            for v, w in list(g[u].items()):\n                edge = (min(u, v), max(u, v))\n                l = None\n                if edge not in edges2:\n                    l = edges2[edge] = [0, 0]\n                else:\n                    l = edges2[edge]\n                i = 0 if u < v else 1\n                l[i] = max(l[i], min(w, M - m))\n                mm = m + w + 1\n                if mm <= M and mm < visited[v]:\n                    visited[v] = mm\n                    heapq.heappush(q, (mm, v))\n        \n        for (u, v), (l1, l2) in list(edges2.items()):\n            result += min(l1 + l2, g[u][v])\n        return result\n", "class Solution:\n    \n    def reachableNodes(self, edges, M, N):\n        graph = defaultdict(dict)\n        for u, v, w in edges:\n            graph[u][v] = graph[v][u] = w\n        \n        heap = [(0, 0)]\n        dist = {0:0}\n        used = dict()\n        ans = 0\n        \n        while heap:\n            adist, anode = heapq.heappop(heap)\n            if adist > dist[anode]:\n                continue\n                \n            ans += 1\n            \n            for nei, weight in graph[anode].items():\n                v = min(weight, M-adist)\n                used[(anode, nei)] = v\n                \n                adist2 = adist + weight + 1\n                if adist2 < dist.get(nei, M+1):\n                    dist[nei] = adist2\n                    heapq.heappush(heap, (adist2, nei))\n        for u, v, w in edges:\n            ans += min(w, used.get((u,v), 0) + used.get((v, u), 0))\n        return ans\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    def reachableNodes2(self, edges, M, N):\n        # graph, dijkstra, heap, dist, used(u,v)=part of new nodes covered\n        graph = defaultdict(dict)\n        for u, v, w in edges:\n            graph[u][v] = graph[v][u] = w # # of new nodes between u and v\n        \n        heap = [(0, 0)]\n        dist = {0:0}\n        used = dict() # key=(u,v) value=covered new nodes\n        ans = 0 # final total num of nodes can be covered\n        \n        while heap:\n            adist, anode = heapq.heappop(heap)\n            if adist > dist[anode]: \n                continue\n            \n            ans += 1 # add one old node in the original graph\n            \n            for nei, weight in graph[anode].items():\n                v = min(weight, M-adist) # source -> anode -> nei\n                used[(anode, nei)] = v\n                \n                adist2 = adist + weight + 1 # cost of \\\"source -> anode -> nei\\\"\n                if adist2 < dist.get(nei, M+1):\n                    dist[nei] = adist2\n                    heapq.heappush(heap, (adist2, nei))\n        \n        for u, v, weight in edges:\n            ans += min(weight, used.get((u, v), 0) + used.get((v, u), 0))\n        return ans\n        \n    \n    def reachableNodes1(self, edges, M, N):\n        # bfs, dijkstra \u90fd\u6709\u5e0c\u671b\u8fc7\n        # subdivisions = \u7ec6\u5206\uff01\n        \n        e = collections.defaultdict(dict)\n        for i, j, l in edges: e[i][j] = e[j][i] = l\n        pq = [(-M, 0)]\n        seen = {}\n        while pq:\n            moves, i = heapq.heappop(pq)\n            if i not in seen:\n                seen[i] = -moves\n                for j in e[i]:\n                    moves2 = -moves - e[i][j] - 1\n                    if j not in seen and moves2 >= 0:\n                        heapq.heappush(pq, (-moves2, j))\n        res = len(seen)\n        for i, j, k in edges:\n            res += min(seen.get(i, 0) + seen.get(j, 0), e[i][j])\n        return res", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = [[] for _ in range(N)]\n        for i,j,n in edges:\n            g[i].append((j, n))\n            g[j].append((i, n))\n            \n        q = [(-M, 0)]\n        visited = [-10001] * N\n        ans = 0\n        while q:\n            #print(list(q))\n            hp, cur = heapq.heappop(q)\n            if visited[cur] != -10001:\n                #print(cur, visited[cur])\n                continue\n            hp = -hp\n            visited[cur] = hp\n            ans += 1\n            for node, cost in g[cur]:\n                nxt_hp = hp - cost - 1\n                if nxt_hp < 0: continue\n                heapq.heappush(q, (-nxt_hp, node))                    \n        \n        for i,j,n in edges:\n            ui, uj = 0, 0\n            if visited[i] != -10001: ui = visited[i]\n            if visited[j] != -10001: uj = visited[j]\n            ans += min(ui+uj, n)\n            \n        return ans\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = [[] for _ in range(N)]\n        for i,j,n in edges:\n            g[i].append((j, n))\n            g[j].append((i, n))\n            \n        q = [(-M, 0)]\n        visited = [-10001] * N\n        ans = 0\n        while q:\n            #print(list(q))\n            hp, cur = heapq.heappop(q)\n            if visited[cur] != -10001:\n                #print(cur, visited[cur])\n                continue\n            hp = -hp\n            visited[cur] = hp\n            ans += 1\n            for node, cost in g[cur]:\n                nxt_hp = hp - cost - 1\n                if nxt_hp >= 0: \n                    heapq.heappush(q, (-nxt_hp, node))                    \n        \n        for i,j,n in edges:\n            ui, uj = 0, 0\n            if visited[i] != -10001: ui = visited[i]\n            if visited[j] != -10001: uj = visited[j]\n            ans += min(ui+uj, n)\n            \n        return ans\n", "from heapq import heapify, heappop, heappush\n\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        adj = {}\n        for i, j, n in edges:\n            for n1, n2 in ((i,j), (j,i)):\n                adj[n1] = adj.get(n1, {})\n                adj[n1][n2] = n\n                \n        if 0 not in adj:\n            return 1\n            \n        length = [M+1 for _ in range(N)]\n        visited = set([0])\n        length[0] = 0\n        closest = [(e+1, 0, j) for j, e in list(adj[0].items())]\n        heapify(closest)\n            \n        while closest:\n            l, frm, to = heappop(closest)\n            if l > M:\n                break\n            if to in visited:\n                continue\n            length[to] = length[frm] + adj[frm][to] + 1\n            visited.add(to)\n            for to2, e in list(adj.get(to, {}).items()):\n                if to2 in visited:\n                    continue\n                heappush(closest, (length[to] + e + 1, to, to2))\n        \n        reach = sum(l <= M for l in length)\n        visited = set()\n        for i, l in enumerate(length):\n            visited.add(i)\n            # Count intermediate nodes reachable from either i, j\n            for j, e in list(adj.get(i, {}).items()):\n                if j in visited:\n                    continue\n                inter = max(min(2 * M - min(length[i], M) - min(length[j], M), e), 0)\n                reach += inter\n            \n        return reach\n            \n            \n            \n    \n        \n        \n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = collections.defaultdict(dict)\n        \n        for u, v, d in edges:\n            graph[u][v] = graph[v][u] = d\n        \n        visited = collections.defaultdict(int)\n        \n        pq = [(-M, 0)]\n        \n        while len(pq) > 0:\n            moves, node = heapq.heappop(pq)\n            moves = -moves\n            if node in visited and moves <= visited[node]:\n                continue\n            visited[node] = moves\n            \n            for nxt, dis in graph[node].items():\n                if dis+1 <= moves:\n                    nxt_moves = moves-dis-1\n                    heappush(pq, (-nxt_moves, nxt))\n        ret = sum(node in visited for node in range(N))\n        for u, v, d in edges:\n            ret += min(visited[u] + visited[v], d)\n        \n        return ret", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        \n        #Create graph using dictioary of dictioary\n        g=collections.defaultdict(dict)\n        for edge in edges:\n            g[edge[0]][edge[1]]=edge[2]+1\n            g[edge[1]][edge[0]]=edge[2]+1\n            \n        #Use negative move to apply max-heap\n        hq=[(-M,0)]*len(g[0])  #The move can be taken together for all outgoing edges\n        \n        if(len(hq)==0):  #There is no outgoing edges, it can visited minimum of 1\n            return 1\n        \n        #Use the dictionary to store the max remaining moves at this node\n        #This will make sure it will cover as many nodes as possible\n        visited={}\n        \n        while hq:\n            #Pop out the node with the highest remaining move\n            rem_move,node=heapq.heappop(hq)\n            if(node in visited):\n                continue\n\n            visited[node]=rem_move\n            \n            for nei in list(g[node].keys()):\n                weight=g[node][nei]\n                if(nei not in visited and (rem_move+weight)<=0):  #make this move if it satisfies\n                    #Don't update visited in this loop, becuase it can only be update after heappop\n                    heapq.heappush(hq,(rem_move+weight,nei))\n\n        #Count the number of nodes covered\n        res=len(visited)\n        \n        counted=set()\n        #Go through all edges \n        for edge in edges:\n            edge_tuple=(min(edge[:2]),max(edge[:2]))\n            if(edge[0] in visited and edge[1] in visited and edge_tuple not in counted):\n                counted.add(edge_tuple)  #Avoid double couting the same edge\n                res+=min(g[edge[0]][edge[1]]-1,-(visited[edge[0]]+visited[edge[1]]))\n            elif(edge[0] in visited):\n                res=res+(-visited[edge[0]])\n            elif(edge[1] in visited):\n                res=res+(-visited[edge[1]])\n                \n        return res\n    \n        \n        \n        \n        \n        \n            \n            \n", "class Solution(object):\n    def reachableNodes(self, edges, M, N):\n        graph = collections.defaultdict(dict)\n        for u, v, w in edges:\n            graph[u][v] = graph[v][u] = w\n\n        pq = [(0, 0)]\n        dist = {0: 0}\n        used = {}\n        ans = 0\n\n        while pq:\n            d, node = heapq.heappop(pq)\n            if d > dist[node]: continue\n            # Each node is only visited once.  We've reached\n            # a node in our original graph.\n            ans += 1\n\n            for nei in graph[node]:\n                weight=graph[node][nei]\n                # M - d is how much further we can walk from this node;\n                # weight is how many new nodes there are on this edge.\n                # v is the maximum utilization of this edge.\n                v = min(weight, M - d)\n                used[node, nei] = v\n\n                # d2 is the total distance to reach 'nei' (neighbor) node\n                # in the original graph.\n                d2 = d + weight + 1\n                if d2 < dist.get(nei, M+1):\n                    heapq.heappush(pq, (d2, nei))\n                    dist[nei] = d2\n\n        # At the end, each edge (u, v, w) can be used with a maximum\n        # of w new nodes: a max of used[u, v] nodes from one side,\n        # and used[v, u] nodes from the other.\n        for u, v, w in edges:\n            ans += min(w, used.get((u, v), 0) + used.get((v, u), 0))\n\n        return ans", "from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        # Dijkstra's\n        # Time  complexity: O(ElogN), where E is the length of edges.\n        # Space complexity: O(N)\n        graph = defaultdict(dict)\n        for u, v, w in edges:\n            graph[u][v] = graph[v][u] = w\n\n        pq = [(0, 0)]\n        dist = {0: 0}\n        used = {}\n        ans = 0\n\n        while pq:\n            d, node = heapq.heappop(pq)\n            if d > dist[node]: continue\n            # Each node is only visited once.  We've reached\n            # a node in our original graph.\n            ans += 1\n\n            for nei, weight in list(graph[node].items()):\n                # M - d is how much further we can walk from this node;\n                # weight is how many new nodes there are on this edge.\n                # v is the maximum utilization of this edge.\n                v = min(weight, M - d)\n                used[node, nei] = v\n\n                # d2 is the total distance to reach 'nei' (neighbor) node\n                # in the original graph.\n                d2 = d + weight + 1\n                if d2 < dist.get(nei, M + 1):\n                    heapq.heappush(pq, (d2, nei))\n                    dist[nei] = d2\n\n        # At the end, each edge (u, v, w) can be used with a maximum\n        # of w new nodes: a max of used[u, v] nodes from one side,\n        # and used[v, u] nodes from the other.\n        for u, v, w in edges:\n            ans += min(w, used.get((u, v), 0) + used.get((v, u), 0))\n\n        return ans\n\n\n", "from heapq import heappop, heappush\nfrom collections import defaultdict\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = defaultdict(dict)\n        for i, j, l in edges: graph[i][j] = graph[j][i] = l\n        heap_queue = [(-M, 0)]\n        seen = defaultdict(int)\n        while heap_queue:\n            move, s = heappop(heap_queue)\n            if s in seen: continue\n            seen[s] = - move\n            for child in graph[s]:\n                if child in seen: continue\n                nxt_move = - move - graph[s][child] - 1\n                if nxt_move >= 0: heappush(heap_queue, (-nxt_move, child))\n        result = len(seen)\n        for i, j, l in edges: result += min(seen.get(i, 0) + seen.get(j, 0), l)\n        return result", "from queue import PriorityQueue\nimport math\nfrom collections import defaultdict\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        adj = defaultdict(list) # list (adj_vertex, edge_weight)\n        for x, y, n in edges:\n            adj[x].append([y, n + 1])\n            adj[y].append([x, n + 1])\n        q = PriorityQueue() # (dist, vertex)\n        dist = [math.inf for _ in range(N)]\n        dist[0] = 0\n        q.put([0, 0])\n        while not q.empty():\n            d, x = q.get()\n            for y, w in adj[x]:\n                if d + w <= M and d + w < dist[y]:\n                    dist[y] = d + w\n                    q.put([dist[y], y])\n        cnt = len([1 for d in dist if d < math.inf])\n        for x, y, n in edges:\n            c1 = M - dist[x] if dist[x] < math.inf else 0\n            c2 = M - dist[y] if dist[y] < math.inf else 0\n            cnt += min(n, c1 + c2)\n        return cnt", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        costs = defaultdict(dict)\n        for i, j, c in edges:\n            costs[i][j] = c\n            costs[j][i] = c\n        visited = set()\n        spans = defaultdict(int) # (i, j): inner_nodes_visited, i < j\n        q = [(0, 0)] # total_cost, node\n        while q:\n            dist, a = heapq.heappop(q)\n            if a in visited:\n                continue\n            visited.add(a)\n            cons = costs[a]\n            for b, cost in list(cons.items()):\n                if dist + cost + 1 <= M:\n                    heapq.heappush(q, (dist + cost + 1, b))\n                spk = (min(a, b), max(a, b))\n                spans[spk] = min(spans[spk] + M - dist, cost)\n        return len(visited) + sum(spans.values())\n        \n        \n", "class Solution:\n    def reachableNodes(self, edges, M, N):\n        \\\"\\\"\\\"\n        :type edges: List[List[int]]\n        :type M: int\n        :type N: int\n        :rtype: int\n        \\\"\\\"\\\"\n        adjacency = defaultdict(set)                    # map node to set of (nbor, number of nodes on edge)\n        subdivisions = {}                               # map an edge to (number of nodes on edge, visited nodes)\n\n        for a, b, intermediate in edges:\n            subdivisions[(a, b)] = [intermediate, 0]\n            subdivisions[(b, a)] = [intermediate, 0]\n            adjacency[a].add((b, intermediate))\n            adjacency[b].add((a, intermediate))\n\n        queue = [(0, 0)]                                # (steps taken, node)\n        visited = set()\n\n        while queue and len(visited) < N:\n            steps, node = heapq.heappop(queue)\n            if node in visited:                         # already visited with lower or same steps\n                continue\n            visited.add(node)\n\n            for nbor, distance in adjacency[node]:      # visit as many nodes as possible along this edge\n                subdivisions[(node, nbor)][1] = min(distance, M - steps)\n\n                if steps + distance + 1 <= M:           # visited all node on edge, add nbor to queue\n                    heapq.heappush(queue, (steps + distance + 1, nbor))\n\n        result = len(visited)                           # all nodes\n        for (a, b), (distance, covered) in subdivisions.items():\n            if a < b:\n                result += min(distance, covered + subdivisions[(b, a)][1])  # sum edge nodes from both sides\n\n        return result  \n    \n    \n    def reachableNodes_(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = collections.defaultdict(list)\n        n = N \n        for i, j, ns in edges:\n            if not ns:\n                graph[i].append(j)\n                graph[j].append(i)\n                continue\n            u = i\n            v = n\n            for _ in range(ns):\n                graph[u].append(v)\n                graph[v].append(u)\n                u = v\n                n += 1\n                v = n\n            v -= 1\n            graph[v].append(j)\n            graph[j].append(v)\n        visited = {0}\n        q = collections.deque([(0, 0)]) # node, move\n        while q:\n            for _ in range(len(q)):\n                node, move = q.popleft()\n                visited.add(node)\n                if move == M:\n                    continue\n                for nxt in graph[node]:\n                    if nxt not in visited:\n                        q.append([nxt, move + 1])\n        return len(visited)\n                    \n        \n        ", "from collections import defaultdict, deque\nimport heapq\n\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        outgoing = defaultdict(dict)\n        \n        # O(E)\n        for src, dest, n in edges:\n            outgoing[src][dest] = n\n            outgoing[dest][src] = n\n        \n        traveled = defaultdict(dict)\n        n_reached = 1\n        visited = set([0])\n        to_traverse = [(outgoing[0][dest], 0, dest) for dest in outgoing[0]] # (dist_through_edge, src, dest)\n        heapq.heapify(to_traverse)\n        \n        while len(to_traverse) > 0:\n            dist, src, dest = heapq.heappop(to_traverse)\n            inter = outgoing[src][dest]\n            \n            dist_at_node = dist - inter\n            # if less than limit, we can travel along edge\n            if dist_at_node < M:\n                # the number of intermediate nodes already traveled on this edge\n                t = traveled.get(src, {}).get(dest, 0)\n                \n                try_dest = False\n                \n                # if positive traveled, we've already hit this edge from this dir.\n                # if zero, can travel up to full length of edge\n                # if negative, have traveled this dist from other edge\n                if t == 0:\n                    dist_edge = min(M - dist_at_node, inter)\n                    if dist_edge == inter:\n                        traveled[src][dest] = inter\n                        traveled[dest][src] = inter\n                        try_dest = M - dist_at_node - inter > 0\n                    else:\n                        traveled[src][dest] = dist_edge\n                        traveled[dest][src] = -dist_edge\n                    n_reached += dist_edge\n                elif t < 0:\n                    dist_edge = min(M - dist_at_node, inter + t)\n                    traveled[src][dest] = dist_edge\n                    n_reached += dist_edge\n                \n                if try_dest and dest not in visited:\n                    n_reached += 1\n                    visited.add(dest)\n                    for next_dest, next_inter in outgoing[dest].items():\n                        heapq.heappush(to_traverse, (dist_at_node + inter + 1 + next_inter, dest, next_dest))\n                        \n        return n_reached", "from collections import defaultdict, deque\nimport heapq\n\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        d = defaultdict(set)\n        for edge in edges:\n            d[edge[0]].add((edge[1], edge[2] + 1))\n            d[edge[1]].add((edge[0], edge[2] + 1))\n        q = [(0, 0)]\n        visited = defaultdict(lambda: float('inf'))\n        visited[0] = 0\n        sd = defaultdict(int)\n        \n        while len(q) > 0:\n            m, cur = heapq.heappop(q)\n            for adj, dis in d[cur]:\n                if visited[adj] > m + dis and m + dis <= M:\n                    heapq.heappush(q, (m + dis, adj))\n                    visited[adj] = m + dis\n                sd[cur, adj] = max(sd[cur, adj], min(dis - 1, M - m))\n        \n        ans = len([x for x in list(visited.values()) if x != float('inf')])\n        for a, b, c in edges:\n            ans += min(sd[a, b] + sd[b, a], c)\n        return ans\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = {}\n        for u, v, w in edges:\n            graph.setdefault(u, {})\n            graph[u][v] = w\n            graph.setdefault(v, {})\n            graph[v][u] = w\n            \n        q = []\n        HP = {}\n        q.append([0, M])\n        while q:\n            cur_node, cur_hp = q.pop(0)\n            if cur_node in HP and HP[cur_node] > cur_hp:\n                continue\n            HP[cur_node] = cur_hp\n            if cur_node in graph: \n                for next_node in graph[cur_node]:\n                    weight = graph[cur_node][next_node]\n                    next_hp = cur_hp - weight - 1\n                    if next_hp < 0 or (next_node in HP and HP[next_node] > next_hp):\n                        continue\n                    q.append([next_node, next_hp])\n        result = len(HP)\n        for u, v, w in edges:\n            uv = HP[u] if u in HP else 0\n            vu = HP[v] if v in HP else 0\n            result += min(uv+vu, w)\n        return result\n", "import heapq\nimport pprint\nfrom collections import defaultdict, deque\n\n\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        adj_list = defaultdict(dict)\n        for x, y, n in edges:\n            adj_list[x][y] = n\n            adj_list[y][x] = n\n\n        pq = [(0, 0)]\n        visited_node = set()\n        visited_edge = defaultdict(int)\n        while pq:\n            d, cur = heapq.heappop(pq)\n            if d > M:\n                break\n            if cur in visited_node:\n                continue\n\n            visited_node.add(cur)\n            for nxt, n in list(adj_list[cur].items()):\n                visited_edge[(cur, nxt)] = max(\n                    visited_edge[(cur, nxt)],\n                    min(M - d, n + 1),\n                )\n                heapq.heappush(pq, (d + n + 1, nxt))\n\n        count_visited_edge = sum(\n            min(visited_edge[(x, y)] + visited_edge[(y, x)], n)\n            for x, y, n in edges\n        )\n        return len(visited_node) + count_visited_edge\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = collections.defaultdict(dict)\n        for edge in edges:\n            u, v, w = edge\n            g[u][v] = w\n            g[v][u] = w\n        \n        pq = [(-M, 0)]\n        HP = {}\n        while pq:\n            hp, node = heapq.heappop(pq)\n            hp = -hp\n            if node in HP:\n                continue\n            HP[node] = hp\n            for child in g[node]:\n                if child not in HP and  hp - g[node][child] -1 >= 0:\n                    heapq.heappush(pq, (-(hp - g[node][child]-1), child))\n                    \n        res = len(HP)\n        for edge in edges:\n            u, v = edge[0], edge[1]\n            uv = HP[u] if u in HP else 0\n            vu = HP[v] if v in HP else 0\n            res += min(edge[2], uv + vu)\n        return res\n", "# class Solution:\n#     def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n#         graph = [[] for _ in range(N)]\n#         remain = [[0]*N for _ in range(N)]\n#         for edge in edges:\n#             i, j, t = edge\n#             graph[i].append((j, t))\n#             graph[j].append((i, t))\n#             remain[i][j] = remain[j][i] = t   #\u7528\u4e8e\u8bb0\u5f55i,j\u4e4b\u95f4\u7684edge\u4e0a\u8fd8\u5269\u591a\u5c11\u672a\u904d\u5386\u7684sub\u70b9\n#         pq = [(0,0)]\n#         seen = set() #\u5229\u7528\u4e86djikstra\u7b97\u6cd5\u53ef\u4ee5\u65f6\u6211\u4eec\u5bf9\u6bcf\u4e2a\u8282\u70b9\u81f3\u904d\u5386\u4e00\u6b21\u5373\u53ef\uff0c\u6545\u7528seen\u8bb0\u5f55\n#         res = 0\n#     #djikstra\n#         while pq:\n#             dist, node = heapq.heappop(pq)\n#             if node in seen: continue\n#             res += 1\n#             seen.add(node)\n#             for nei, d in graph[node]:\n#                 valid = min(M-dist, remain[node][nei])\n#                 res += valid\n#                 remain[node][nei] = remain[nei][node] = remain[nei][node] - valid\n#                 cost_to_nei = dist + d + 1\n#                 if cost_to_nei <= M and nei not in seen: heapq.heappush(pq, (cost_to_nei, nei))\n#         return res\n\nclass Solution(object):\n    def reachableNodes(self, edges, M, N):\n        graph = collections.defaultdict(dict)\n        for u, v, w in edges:\n            graph[u][v] = graph[v][u] = w\n\n        pq = [(0, 0)]\n        dist = {0: 0}\n        used = {}\n        ans = 0\n\n        while pq:\n            d, node = heapq.heappop(pq)\n            if d > dist[node]: continue\n            # Each node is only visited once.  We've reached\n            # a node in our original graph.\n            ans += 1\n\n            for nei, weight in graph[node].items():\n                # M - d is how much further we can walk from this node;\n                # weight is how many new nodes there are on this edge.\n                # v is the maximum utilization of this edge.\n                v = min(weight, M - d)\n                used[node, nei] = v\n\n                # d2 is the total distance to reach 'nei' (neighbor) node\n                # in the original graph.\n                d2 = d + weight + 1\n                if d2 < dist.get(nei, M+1):\n                    heapq.heappush(pq, (d2, nei))\n                    dist[nei] = d2\n\n        # At the end, each edge (u, v, w) can be used with a maximum\n        # of w new nodes: a max of used[u, v] nodes from one side,\n        # and used[v, u] nodes from the other.\n        for u, v, w in edges:\n            ans += min(w, used.get((u, v), 0) + used.get((v, u), 0))\n\n        return ans", "import heapq\nimport pprint\nfrom collections import defaultdict, deque\n\n\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        adj_list = defaultdict(list)\n        for x, y, n in edges:\n            adj_list[x].append((y, n))\n            adj_list[y].append((x, n))\n\n        pq = [(0, 0)]\n        visited_node = set()\n        visited_edge = defaultdict(int)\n        while pq:\n            d, cur = heapq.heappop(pq)\n            if d > M:\n                break\n            if cur in visited_node:\n                continue\n\n            visited_node.add(cur)\n            for nxt, n in adj_list[cur]:\n                visited_edge[(cur, nxt)] = max(\n                    visited_edge[(cur, nxt)],\n                    min(M - d, n + 1),\n                )\n                heapq.heappush(pq, (d + n + 1, nxt))\n\n        count_visited_edge = sum(\n            min(visited_edge[(x, y)] + visited_edge[(y, x)], n)\n            for x, y, n in edges\n        )\n        return len(visited_node) + count_visited_edge\n", "from queue import PriorityQueue\nfrom collections import defaultdict\n\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        e_dict = defaultdict(dict)\n        for i, j, n in edges:\n            e_dict[i][j] = e_dict[j][i] = n\n        \n        seen = {}\n        pq = PriorityQueue()\n        pq.put((-M, 0))\n        \n        while pq.qsize() > 0:\n            remaining_moves, idx = pq.get()\n            if idx not in seen:\n                seen[idx] = -remaining_moves\n                for j in e_dict[idx]:\n                    j_remaining_moves = seen[idx] - e_dict[idx][j] - 1 \n                    if j_remaining_moves >= 0 and j not in seen:\n                        pq.put((-j_remaining_moves, j))\n        \n        res = len(seen)\n        for i, j, k in edges:\n                res += min(seen.get(i, 0) + seen.get(j, 0), k)\n        \n        return res\n                \n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = collections.defaultdict(dict)\n        for u, v, w in edges:\n            graph[u][v] = graph[v][u] = w + 1\n\n        heap = [(-M, 0)]\n        d = {}\n\n        while heap:\n            moves, u = heapq.heappop(heap)\n            if u not in d:\n                d[u] = -moves\n                for v in graph[u]:\n                    temp = -moves - graph[u][v]\n                    if v not in d and temp >= 0:\n                        heapq.heappush(heap, (-temp, v))\n\n        res = len(d)\n        for u, v, w in edges:\n            res += min(d.get(u, 0)+ d.get(v, 0), w)\n\n        return res", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = [[] for _ in range(N)]\n        for i,j,n in edges:\n            g[i].append((j,n))\n            g[j].append((i,n))\n        \n        q = [(-M, 0)]\n        visited = [None] * N\n        ans = 0\n        while q:\n            hp, cur = heapq.heappop(q)\n            if visited[cur] is not None: continue\n            hp *= -1\n            visited[cur] = hp\n            ans += 1\n            for nxt, cost in g[cur]:\n                nxt_hp = hp - cost - 1\n                if visited[nxt] is not None or nxt_hp < 0:                     \n                    continue                \n                heapq.heappush(q, (-nxt_hp, nxt))\n                \n        for i,j,n in edges:\n            ui, uj = 0, 0\n            if visited[i] is not None: ui = visited[i]\n            if visited[j] is not None: uj = visited[j]\n            ans += min(n, (ui+uj))\n        return ans\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = [[] for _ in range(N)]\n        for i,j,n in edges:\n            g[i].append((j, n))\n            g[j].append((i, n))\n            \n        q = [(-M, 0)]\n        visited = [None] * N\n        ans = 0\n        while q:\n            hp, cur = heapq.heappop(q)\n            if visited[cur] is not None: continue\n            hp = -hp\n            visited[cur] = hp\n            ans += 1\n            for node, cost in g[cur]:\n                nxt_hp = hp - cost - 1\n                if visited[node] is not None or nxt_hp < 0: continue\n                heapq.heappush(q, (-nxt_hp, node))                    \n        \n        for i,j,n in edges:\n            ui, uj = 0, 0\n            if visited[i] is not None: ui = visited[i]\n            if visited[j] is not None: uj = visited[j]\n            ans += min(ui+uj, n)\n            \n        return ans\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        g = [[] for _ in range(N)]\n        for i,j,k in edges: \n            g[i].append((j,k))\n            g[j].append((i,k))\n            \n        q = [(-M, 0)]\n        HP = [-sys.maxsize] * N\n        ans = 0\n        while q:\n            hp, cur = heapq.heappop(q)            \n            if HP[cur] != -sys.maxsize: continue\n            hp *= -1\n            HP[cur] = hp\n            ans += 1\n            for nxt, nxt_hp in g[cur]:\n                nxt_hp = hp - nxt_hp - 1\n                if nxt_hp < 0 or HP[nxt] != -sys.maxsize: continue\n                heapq.heappush(q, (-nxt_hp, nxt))\n                \n        for i,j,k in edges:\n            uv = 0 if HP[i] == -sys.maxsize else HP[i]\n            vu = 0 if HP[j] == -sys.maxsize else HP[j]\n            ans += min(k, uv + vu)\n        return ans", "import collections\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = collections.defaultdict(dict)\n        for i, j, w in edges:\n            graph[i][j] = graph[j][i] = w\n        # min queue for dijastra (distance from source, vertex)\n        pq = [(0,0)]\n        # weight used from u to v\n        used = {}\n        # min distance from source\n        dist = {0: 0}\n        res = 0\n        \n        while pq:\n            d, v = heapq.heappop(pq)\n            # dist in this path greater than previous route, no need to searching\n            if d > dist[v]:\n                continue\n            # count this vertex\n            res += 1\n            \n            for nei, weight in list(graph[v].items()):\n                # insert how much weight/nodes can be used in edge v->nei\n                use_wei = min(weight, M - d)\n                used[v, nei] = use_wei\n                \n                # get min dis to next node\n                d_min = d + weight + 1\n                # if next node is not visited and distance smaller than M + 1\n                # or has been visited but has greater distance from source\n                # we can update distance and push new vertex to heap\n                if d_min < dist.get(nei, M + 1):\n                    dist[nei] = d_min\n                    heapq.heappush(pq,(d_min, nei))\n                    \n        # insert traveled mid nodes to res\n        for i, j, w in edges:\n            res += min(w, used.get((i, j), 0) + used.get((j, i), 0))\n        return res\n                \n            \n                    \n", "import math\nfrom collections import defaultdict\nfrom queue import PriorityQueue\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        adj = defaultdict(list)\n        for x, y, w in edges:\n            adj[x].append([y, w + 1])\n            adj[y].append([x, w + 1])\n        dist = [math.inf for _ in range(N)]\n        q = PriorityQueue() # queue of [dist, vertex_id]\n        q.put([0, 0])\n        dist[0] = 0\n        while not q.empty():\n            d, x = q.get()\n            for y, w in adj[x]:\n                if d + w <= M and dist[y] > d + w:\n                    dist[y] = d + w\n                    q.put([dist[y], y])\n        cnt = len([1 for d in dist if d < math.inf])\n        for x, y, w in edges:\n            covered = 0\n            if dist[x] < math.inf:\n                covered += M - dist[x]\n            if dist[y] < math.inf:\n                covered += M - dist[y]\n            cnt += min(w, covered)\n        return cnt", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = [[] for _ in range(N)]\n        remain = [[0]*N for _ in range(N)]\n        for edge in edges:\n            i, j, t = edge\n            graph[i].append((j, t))\n            graph[j].append((i, t))\n            remain[i][j] = remain[j][i] = t   #\u7528\u4e8e\u8bb0\u5f55i,j\u4e4b\u95f4\u7684edge\u4e0a\u8fd8\u5269\u591a\u5c11\u672a\u904d\u5386\u7684sub\u70b9\n        pq = [(0,0)]\n        seen = set() #\u5229\u7528\u4e86djikstra\u7b97\u6cd5\u53ef\u4ee5\u65f6\u6211\u4eec\u5bf9\u6bcf\u4e2a\u8282\u70b9\u81f3\u904d\u5386\u4e00\u6b21\u5373\u53ef\uff0c\u6545\u7528seen\u8bb0\u5f55\n        res = 0\n    #djikstra\n        while pq:\n            dist, node = heapq.heappop(pq)\n            if node in seen: continue\n            res += 1\n            seen.add(node)\n            for nei, d in graph[node]:\n                valid = min(M-dist, remain[node][nei])\n                res += valid\n                remain[node][nei] = remain[nei][node] = remain[nei][node] - valid\n                cost_to_nei = dist + d + 1\n                if cost_to_nei <= M and nei not in seen: heapq.heappush(pq, (cost_to_nei, nei))\n        return res\n\n# class Solution(object):\n#     def reachableNodes(self, edges, M, N):\n#         graph = collections.defaultdict(dict)\n#         for u, v, w in edges:\n#             graph[u][v] = graph[v][u] = w\n\n#         pq = [(0, 0)]\n#         dist = {0: 0}\n#         used = {}\n#         ans = 0\n\n#         while pq:\n#             d, node = heapq.heappop(pq)\n#             if d > dist[node]: continue\n#             # Each node is only visited once.  We've reached\n#             # a node in our original graph.\n#             ans += 1\n\n#             for nei, weight in graph[node].items():\n#                 # M - d is how much further we can walk from this node;\n#                 # weight is how many new nodes there are on this edge.\n#                 # v is the maximum utilization of this edge.\n#                 v = min(weight, M - d)\n#                 used[node, nei] = v\n\n#                 # d2 is the total distance to reach 'nei' (neighbor) node\n#                 # in the original graph.\n#                 d2 = d + weight + 1\n#                 if d2 < dist.get(nei, M+1):\n#                     heapq.heappush(pq, (d2, nei))\n#                     dist[nei] = d2\n\n#         # At the end, each edge (u, v, w) can be used with a maximum\n#         # of w new nodes: a max of used[u, v] nodes from one side,\n#         # and used[v, u] nodes from the other.\n#         for u, v, w in edges:\n#             ans += min(w, used.get((u, v), 0) + used.get((v, u), 0))\n\n#         return ans\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = defaultdict(dict)\n        for i, j, w in edges:\n            graph[i][j] = w\n            graph[j][i] = w\n        \n        seen = set()\n        edges_utilized = Counter()\n        h = [(0, 0)]\n        while h:\n            dist, node = heapq.heappop(h)\n            seen.add(node)\n            for nbr, w in graph[node].items():\n                if nbr not in seen and dist + w + 1 <= M:\n                    heapq.heappush(h, (dist + w + 1, nbr))\n                edges_utilized[node, nbr] = max(edges_utilized[node, nbr], M - dist)\n        \n        count = len(seen)\n        all_utilized_edges = edges_utilized.keys()\n        edges_covered = set()\n        for fro, to in all_utilized_edges:\n            e = min(fro, to), max(fro, to)\n            if e in edges_covered:\n                continue\n            edges_covered.add(e)\n            count += min(graph[fro][to], edges_utilized[fro, to] + edges_utilized[to, fro])\n        \n        return count", "class Solution:\n    # O(Elog(E)) time, O(E) space\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = defaultdict(dict)\n        for i, j, w in edges:\n            graph[i][j] = w\n            graph[j][i] = w\n        \n        seen = set()\n        edges_utilized = Counter()\n        h = [(0, 0)]\n        while h:\n            dist, node = heapq.heappop(h)\n            seen.add(node)\n            for nbr, w in graph[node].items():\n                if nbr not in seen and dist + w + 1 <= M:\n                    heapq.heappush(h, (dist + w + 1, nbr))\n                edges_utilized[node, nbr] = max(edges_utilized[node, nbr], M - dist)\n        \n        count = len(seen)\n        all_utilized_edges = edges_utilized.keys()\n        edges_covered = set()\n        for fro, to in all_utilized_edges:\n            e = min(fro, to), max(fro, to)\n            if e in edges_covered:\n                continue\n            edges_covered.add(e)\n            count += min(graph[fro][to], edges_utilized[fro, to] + edges_utilized[to, fro])\n        \n        return count", "class Solution:\n    def __init__(self):\n        self.graph = defaultdict(list)\n        self.visited = dict()\n        self.new_touched = dict()\n        self.new_vis_nodes_count = 0\n    \n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        \n        for u, v, w in edges:\n            self.graph[u].append((v,w))\n            self.graph[v].append((u,w))\n        \n        nodes_queue = [(0,0)]\n        self.visited[0] = 0\n        while len(nodes_queue):\n            v_dist, v = heappop(nodes_queue)\n            self.visited[v] = v_dist\n            for u, w in self.graph[v]:\n                \n                self.new_touched[(v,u)]=max(min(w,M-v_dist),self.new_touched.get((v,u),0))\n                \n                if u not in self.visited and M>=v_dist+w+1:\n                    heappush(nodes_queue,(v_dist+w+1,u))\n       \n        res = len(list(self.visited.items()))\n        for u, v, w in edges:\n            res += min(w, self.new_touched.get((u, v), 0) + self.new_touched.get((v, u), 0))\n        \n        return res\n", "class Solution:\n    def __init__(self):\n        self.graph = defaultdict(list)\n        self.visited = dict()\n        self.new_touched = dict()\n        self.new_vis_nodes_count = 0\n    \n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        \n        for u, v, w in edges:\n            self.graph[u].append((v,w))\n            self.graph[v].append((u,w))\n        \n        nodes_queue = [(0,0)]\n        self.visited[0] = 0\n        while len(nodes_queue):\n            v_dist, v = heappop(nodes_queue)\n            self.visited[v] = v_dist\n            for u, w in self.graph[v]:\n                \n                #self.new_touched[(v,u)]=max(min(w,M-v_dist),self.new_touched.get((v,u),0))\n                self.new_touched[(v,u)]=max(min(w,M-v_dist),self.new_touched.get((v,u),0))\n                \n                if u not in self.visited and M>=v_dist+w+1:\n                    heappush(nodes_queue,(v_dist+w+1,u))\n       \n        res = len(list(self.visited.items()))\n        for u, v, w in edges:\n            res += min(w, self.new_touched.get((u, v), 0) + self.new_touched.get((v, u), 0))\n        \n        return res\n", "class Solution:\n    def __init__(self):\n        self.graph = defaultdict(list)\n        self.visited = dict()\n        self.new_touched = dict()\n        self.new_vis_nodes_count = 0\n    \n    def dfs(self,v, M):\n        \n        self.visited[v]=M #0, 0_3_0, 0_3_1, 0_3_2,\n        if M <= 0:\n            return\n\n        for u, w in self.graph[v]:\n            self.new_touched[(v,u)]=max(min(w,M),self.new_touched.get((v,u),0))\n            if u in self.visited and self.visited[u] >= M:\n                continue\n            if M>w:\n                self.dfs(u, M-w-1)\n    \n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        \n        for u, v, w in edges:\n            self.graph[u].append((v,w))\n            self.graph[v].append((u,w))\n        \n        nodes_queue = [(0,0)]\n        self.visited[0] = 0\n        while len(nodes_queue):\n            v_dist, v = heappop(nodes_queue)\n            self.visited[v] = v_dist\n            for u, w in self.graph[v]:\n                \n                self.new_touched[(v,u)]=max(min(w,M-v_dist),self.new_touched.get((v,u),0))\n                \n                if u in self.visited and self.visited[u] <= v_dist+w+1:\n                    continue\n                \n                if M>=v_dist+w+1:\n                    heappush(nodes_queue,(v_dist+w+1,u))\n                    \n            \n        #self.dfs(0,M)\n        \n        res = len(list(self.visited.items()))\n        for u, v, w in edges:\n            res += min(w, self.new_touched.get((u, v), 0) + self.new_touched.get((v, u), 0))\n        \n        return res\n", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        if M == 0: return 1\n        graph = [[-1]*N for i in range(N)]\n        nodes = set()\n        for i,j,n in edges:\n            graph[i][j] = n\n            graph[j][i] = n\n            nodes.add(i)\n            nodes.add(j)\n        visited = [False]*N\n        q = [(-M, 0)]\n        cost = 0\n        count = 0\n        while q:\n            cur = heappop(q)\n            if count == len(nodes) + 1: break\n            if visited[cur[1]]: continue\n            count += 1\n            visited[cur[1]] = True\n            steps = -cur[0]\n            cost += 1\n            if steps <= 0: continue\n            for i in range(N):\n                if graph[cur[1]][i] == -1: continue\n                adj = (graph[cur[1]][i], i)\n                if adj[0] + 1 > steps:\n                    cost += steps\n                    graph[cur[1]][i] -= steps\n                    graph[i][cur[1]] -= steps\n                else:\n                    cost += adj[0]\n                    heappush(q,(-(steps-adj[0]-1), adj[1]))\n                    graph[cur[1]][adj[1]] = -1\n                    graph[adj[1]][cur[1]] = -1\n        return cost", "import heapq\n\n\nclass Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = collections.defaultdict(dict)\n        for u, v, cost in edges:\n            graph[u][v] = graph[v][u] = cost\n        \n        # Dijkstra\n        pq = [(-M, 0)]\n        seen = {}\n        while pq:\n            moves, i = heapq.heappop(pq)\n            if i not in seen:\n                seen[i] = -moves\n                for j in graph[i]:\n                    rem_moves = -moves - graph[i][j] - 1\n                    if j not in seen and rem_moves >= 0:\n                        heapq.heappush(pq, (-rem_moves, j))\n        res = len(seen) # Reachable big nodes\n        for i, j, cost in edges:\n            res += min(seen.get(i, 0) + seen.get(j, 0), cost)\n        return res", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        graph = collections.defaultdict(list)\n        for u, v, w, in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        \n        hq = [(-M, 0)]\n        hp = {}\n        \n        while hq:\n            m, node = heapq.heappop(hq)            \n            if node in hp:\n                continue\n            m = -m\n            hp[node] = m\n            \n            for v, w in graph[node]:\n                if m > w:\n                    remains = m - w - 1\n                    heapq.heappush(hq, (-remains, v))\n            \n        ans = len(hp)\n        for u, v, w in edges:\n            a = hp[u] if u in hp else 0\n            b = hp[v] if v in hp else 0\n            if a + b < w:\n                ans += a + b\n            else:\n                ans += w\n        return ans", "class Solution:\n    def reachableNodes(self, edges: List[List[int]], M: int, N: int) -> int:\n        # build graph (undirected)\n        graph = defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n\n        \n        # priority queue keep track of [(dist, node)]\n        min_heap = [(0, 0)]\n        min_dist = [M+1]*N\n        min_dist[0] = 0\n    \n        # keep track of max utilization for edge u->v\n        edge2used = defaultdict(int)\n        res = 0\n        while min_heap:\n            dist, u = heapq.heappop(min_heap)\n            if dist > min_dist[u]:\n                continue\n            \n            res += 1\n            \n            for v, w in graph[u]:\n                # try to relax the child v\n                used = min(M-dist, w)\n                edge2used[(u, v)] = used\n                # distance to reach child v from u\n                dist_v = dist + w + 1\n                if dist_v < min_dist[v]:\n                    min_dist[v] = dist_v\n                    heapq.heappush(min_heap, (dist_v, v))\n        \n        for u, v, w in edges:\n            res += min(w, edge2used[u, v] + edge2used[v, u])\n        \n        return res"]
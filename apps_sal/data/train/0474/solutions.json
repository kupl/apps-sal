["class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        let=Counter(letters)\n        sc={}\n        for i in range(26):\n            sc[chr(i+ord('a'))]=score[i]\n        word={}\n        for w in words:\n            word[w]=Counter(w)\n        self.ans=0\n        used=[]\n        def run(x,cur,let):\n            if x==len(words):\n                return\n            for i in range(x,len(words)):\n                if i not in used:\n                    tmp=dict(let)\n                    bx=True\n                    d=0\n                    for k,v in word[words[i]].items():\n                        if k not in let:\n                            bx=False\n                            break\n                        let[k]-=v\n                        d+=(sc[k]*v)\n                        if let[k]<0:\n                            bx=False\n                            break\n                    if bx:\n                        used.append(i)\n                        run(i+1,cur+d,let)\n                        if cur+d>self.ans:\n                            self.ans=max(self.ans,cur+d)\n                        used.pop()\n                        let=tmp\n                    let=tmp\n        run(0,0,let)\n        return self.ans", "class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        # Time O(2^N)\n        # Space O(1)\n        \n        def solve(idx, counter):\n            if idx == len(words):\n                return 0\n\n            wc = collections.Counter(words[idx])\n            if all(counter[key] >= wc[key] for key in wc):\n                ans = max(sum(score[ord(c)-ord('a')] for c in words[idx]) + solve(idx+1, counter-wc), solve(idx+1, counter))\n            else:\n                ans = solve(idx+1, counter) \n                \n            return ans\n        \n        return solve(0, collections.Counter(letters))\n", "from collections import defaultdict, Counter\nimport copy\n\n\nclass Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        def score_of_word(w, score=score):\n            ws = 0\n            for c in w:\n                ws += score[ord(c)-97]\n                \n            return ws\n        \n        letter_dict = defaultdict(int)\n        for c in letters: letter_dict[c]+=1\n            \n        def remove_word_from_letter_dict(w, let_dict):\n            for c in w:\n                let_dict[c] -= 1\n                if not let_dict[c]:\n                    del let_dict[c]\n                    \n        def is_word_exist_in_letter_dict(w, let_dict):\n            wc = Counter(w)\n            for c, f in wc.items():\n                if c not in let_dict or let_dict[c] < f:\n                    return False\n                \n            return True\n        \n        def search_best_score(words, letter_dict, current_score=0):\n            best_score = current_score\n            for i in range(len(words)):\n                w = words[i]\n                if is_word_exist_in_letter_dict(w, letter_dict):                    \n                    score = current_score + score_of_word(w)\n                    copy_letter_dict = copy.deepcopy(letter_dict)\n                    remove_word_from_letter_dict(w, copy_letter_dict)\n                    score = search_best_score(words[i+1:], copy_letter_dict, score)\n                    if score > best_score:\n                        best_score = score\n                        \n            return best_score\n        \n        return search_best_score(words, letter_dict)", "class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        lcnt = Counter(letters)\n        words = [w for w in words if all(Counter(w)[l] <= lcnt[l] for l in w)]\n        al = 'abcdefghijklmnopqrstuvwxyz'\n        scores = {w: sum(score[al.index(l)] for l in w) for w in words}\n        costs = {w: Counter(w) for w in words}\n        score = 0\n\n        for i in range(1, len(words)+1):\n            for comb in combinations(words, i):\n                if all(sum(costs[w][l] for w in comb) <= lcnt[l] for l in lcnt):\n                    score = max(score, sum(scores[w] for w in comb))\n\n        return score", "class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        let=Counter(letters)\n        x=0\n        sc={}\n        for i in range(26):\n            sc[chr(i+ord('a'))]=score[i]\n        while x<len(words):\n            dic=Counter(words[x])\n            bx=True\n            for k,v in dic.items():\n                if let[k]<v:\n                    words.pop(x)\n                    bx=False\n                    break\n            if bx:x+=1\n        word={}\n        for w in words:\n            word[w]=Counter(w)\n        self.ans=0\n        used=[]\n        def run(x,cur,let):\n            if x==len(words):\n                return\n            for i in range(x,len(words)):\n                if i not in used:\n                    tmp=dict(let)\n                    bx=True\n                    d=0\n                    for k,v in word[words[i]].items():\n                        let[k]-=v\n                        d+=(sc[k]*v)\n                        if let[k]<0:\n                            bx=False\n                            break\n                    if bx:\n                        used.append(i)\n                        run(i+1,cur+d,let)\n                        if cur+d>self.ans:\n                            self.ans=max(self.ans,cur+d)\n                        used.pop()\n                        let=tmp\n                    let=tmp\n        run(0,0,let)\n        return self.ans", "class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        def letterScore(c):\n\n            return score[ord(c) - ord('a')]\n\n        def helper(i, remaining, scoreSoFar):\n            if not remaining or i == len(words):\n                return scoreSoFar\n\n            # 1) Skip words[i]\n            res = helper(i + 1, remaining, scoreSoFar)\n\n            # 2) Take words[i] if possible\n            cw = Counter(words[i])\n            if not (cw - remaining):\n                res = max(res, helper(i + 1, remaining - cw, scoreSoFar + sum(map(letterScore, words[i]))))\n\n            return res\n\n        return helper(0, Counter(letters), 0)\n", "class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        n = len(words)\n        m = len(letters)\n        letters = collections.Counter(letters)\n        ans = 0\n        for i in range(1, n + 1):\n            combinations = list(itertools.combinations(words, i))\n            for combine in combinations:\n                tempScore = self.calculateScore(''.join(combine), letters, score)\n                ans = max(tempScore, ans)\n        \n        \n        return ans\n    \n    def calculateScore(self, s, letters, score):\n        counter = collections.Counter(s)\n        ans = 0\n        for ch in counter:\n            if counter[ch] > letters[ch]:\n                return float('-inf')\n            \n            ans += counter[ch] * score[ord(ch) - ord('a')]\n            \n        return ans\n", "from collections import Counter\nclass Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        letters_dict = Counter(letters)\n        res = []\n        max_score = 0\n        size = len(words)\n        def subsets(start, curr):\n            res.append(curr)\n            for i in range(start, len(words)):\n                subsets(i + 1, curr + [words[i]])\n        subsets(0, [])\n        flag = 0\n        for subset in res:\n            curr_score = 0\n            curr_letters_dict = dict(letters_dict)\n            #print(subset)\n            for word in subset:\n                for char in word:\n                    if char in curr_letters_dict and curr_letters_dict[char] > 0:\n                        curr_score += score[ord(char) - ord('a')]\n                        curr_letters_dict[char] -= 1\n                    else:\n                        flag = 1\n                        break\n                if flag:\n                    break\n            if flag:\n                flag = 0\n            else:\n                max_score = max(max_score, curr_score)\n            #print(\\\"flag and curr_score are:\\\", flag, curr_score)\n        return max_score\n            \n", "from collections import defaultdict as dt\ndef sc(w,z):\n    s=0\n    for i in w:s+=z[ord(i)-97] \n    return s\ndef ch(fi,s):\n    gi=dt(int)\n    for i in s:\n        for j in i:\n            gi[j]+=1\n    for i in gi:\n        if gi[i]>fi[i]:return False\n    return True\nclass Solution:\n    def maxScoreWords(self, x: List[str], y: List[str], z: List[int]) -> int:       \n        fi=dt(int)\n        for i in y:fi[i]+=1\n        ans=0\n        for j in range(1,len(x)+1):\n            for i in list(combinations (x,j)):\n                ss=0\n                if ch(fi,i):\n                    for k in i:ss+=sc(k,z)\n                    ans=max(ss,ans)\n        return ans", "from collections import defaultdict as dt\nclass Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        fi = dt(int)\n        for i in letters:\n            fi[i] += 1\n        ans = 0\n        for j in range(1,len(words)+1):\n            tt = list(combinations(words, j))\n            print(tt)\n            for i in tt:\n                ss = 0\n                if ch(fi,i):\n                    for k in i:\n                        ss+= sc(k,score)\n                    ans = max(ss,ans)\n        return ans\ndef sc(w,z):\n    s = 0\n    for i in w:\n        s+=z[ord(i)-97]\n    return s\n\ndef ch(fi,s):\n    gi = dt(int)\n    for i in s:\n        for j in i:\n            gi[j] += 1\n    for i in gi:\n        if gi[i]>fi[i]: return False\n    return True", "\nfrom copy import deepcopy\n\nclass Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        queue = [[letters, 0, words]]\n        visited = []\n        max = 0\n        \n        while len(queue) != 0:\n            item = queue.pop(0)\n            if (item[0]  in visited):\n                continue\n            visited.append(item[0])\n            \n            for word in item[2]:\n                lettersCopy = deepcopy(item[0])\n                hasEnoughChars = self.hasEnoughChars(lettersCopy, word, score)\n                if (hasEnoughChars != - 1 and lettersCopy not in visited):\n                    if (item[1]+hasEnoughChars > max):\n                        max = item[1]+hasEnoughChars\n                    wordsCopy = deepcopy(item[2])\n                    wordsCopy.remove(word)\n                    queue.append([lettersCopy, item[1]+hasEnoughChars, wordsCopy]) \n        \n        return max\n                \n            \n    def charValue(self, letter: str):\n        return ord(letter) - 97\n    \n    def hasEnoughChars(self, letters, word, score):\n        sum = 0\n        try:\n            for x in list(word):\n                letters.remove(x)\n                sum += score[self.charValue(x)]\n        except:\n            return -1\n            \n        return sum", "class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        res = []\n        i = 0\n        letters = collections.Counter(letters)\n        res = [0]\n        self.dfs(i, words, letters, score, 0, res)\n        return res[0]\n    \n    \n    def dfs(self, i, words, letters, score, current, res):\n        res[0] = max(res[0], current)\n        \n        for index in range(i, len(words)):\n            word = words[index]\n            cnt = collections.Counter(word)\n            temp = 0\n            valid = True\n            for ch in cnt:\n                if cnt[ch] > letters[ch]:\n                    valid = False\n                    break\n                temp += cnt[ch] * score[ord(ch) - ord('a')]\n            \n            if not valid:\n                continue\n            else:   \n                for ch in cnt:\n                    letters[ch] -= cnt[ch]\n                self.dfs(index+1, words, letters, score, current + temp, res)\n                for ch in cnt:\n                    letters[ch] += cnt[ch]\n        return\n            \n            \n                \n", "from collections import Counter\nclass Solution:\n    def subsets(self, words: List[str]) -> List[List[str]]:\n        def subsetsHelper(words: List[str]) -> List[List[str]]:\n            if len(words) == 0:\n                return [[]]\n            result = subsetsHelper(words[1:])\n            for i in range(len(result)):\n               if result[i] != None:\n                  l = result[i][:]\n                  l.append(words[0])\n                  result.append(l)\n            return result\n        return subsetsHelper(words)\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        def getScores(wordSet:List[str])->int:\n            scoreCount = 0\n            counter = Counter(letters)\n            for word in wordSet:\n                for c in word:\n                    if not c in counter or counter[c] == 0:\n                        return 0\n                    counter[c] -= 1\n                    scoreCount += score[ord(c)-ord('a')]\n            return scoreCount\n                \n        ans = 0\n        for wordSet in self.subsets(words):\n            currentScore = getScores(wordSet)\n            if currentScore > ans:\n                ans = currentScore\n        return ans\n                \n                  \n                \n                \n            \n", "class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        limit = Counter(letters)\n        n = len(words)\n        subsets = []\n        def back(i,curr):\n            if i==n:\n                subsets.append(curr)\n                return\n            back(i+1, curr+words[i])\n            back(i+1, curr)\n        back(0,'')\n        print(subsets)\n        ans = 0\n        \n        def findscore(wo):\n            freq = Counter(wo)\n            currscore = 0\n            for c in freq:\n                if freq[c]<=limit[c]:\n                    currscore+=score[ord(c)-ord('a')]*freq[c]\n                else:\n                    return 0\n            return currscore\n            \n        for x in subsets:\n            ans = max(ans, findscore(x))\n        return ans\n            \n", "class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        max_score = 0\n        word_limits = Counter(letters)\n        def helper(curr, chars, curr_words):\n            nonlocal max_score\n            if curr >= len(words):\n                if chars & word_limits == chars:\n                    curr_score = sum([chars[c] * score[ord(c) - 97] for c in chars])\n                    max_score = max(max_score, curr_score)\n                    print(chars)\n            else:\n                chars += Counter(words[curr])\n                helper(curr + 1, chars, curr_words + 1)\n                chars -= Counter(words[curr])\n                helper(curr + 1, chars, curr_words)         \n        helper(0, Counter(), 0)\n        return max_score\n    \n        \n        \n", "class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        \n        # Time O(2^N)\n        # Space O(1)\n        \n        def solve(idx, counter):\n            if idx == len(words):\n                return 0\n\n            wc = collections.Counter(words[idx])\n            if all(counter[key] >= wc[key] for key in wc):\n                ans = max(sum(score[ord(c)-ord('a')] for c in words[idx]) + solve(idx+1, counter-wc), solve(idx+1, counter))\n            else:\n                ans = solve(idx+1, counter) \n                \n            return ans\n        \n        return solve(0, collections.Counter(letters))", "class Solution:\n#     def maxScoreWords(self, words, letters, score):\n#         self.max_score = 0\n#         words_score = [sum(score[ord(c)-ord('a')] for c in word) for word in words]\n#         words_counter = [collections.Counter(word) for word in words]\n        \n#         def dfs(i, curr_score, counter):\n#             if curr_score + sum(words_score[i:]) <= self.max_score:\n#                 return\n#             self.max_score = max(self.max_score, curr_score)\n#             for j, wcnt in enumerate(words_counter[i:], i):\n#                 if all(n <= counter.get(c,0) for c,n in wcnt.items()):\n#                     dfs(j+1, curr_score+words_score[j], counter-wcnt)\n        \n#         dfs(0, 0, collections.Counter(letters))\n#         return self.max_score\n    \n    \n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        def solve(idx, counter):\n            if idx == len(words):\n                return 0\n\n            wc = collections.Counter(words[idx])\n            if all(counter[key] >= wc[key] for key in wc):\n                return max(\n                    sum(score[ord(c)-ord('a')] for c in words[idx]) + solve(idx+1, counter-wc), \n                    solve(idx+1, counter)\n                )\n            else:\n                return solve(idx+1, counter) \n        \n        return solve(0, collections.Counter(letters))", "class Solution:\n#     def maxScoreWords(self, words, letters, score):\n#         self.max_score = 0\n#         words_score = [sum(score[ord(c)-ord('a')] for c in word) for word in words]\n#         words_counter = [collections.Counter(word) for word in words]\n        \n#         def dfs(i, curr_score, counter):\n#             if curr_score + sum(words_score[i:]) <= self.max_score:\n#                 return\n#             self.max_score = max(self.max_score, curr_score)\n#             for j, wcnt in enumerate(words_counter[i:], i):\n#                 if all(n <= counter.get(c,0) for c,n in wcnt.items()):\n#                     dfs(j+1, curr_score+words_score[j], counter-wcnt)\n        \n#         dfs(0, 0, collections.Counter(letters))\n#         return self.max_score\n    \n    \n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        def solve(idx, counter):\n            if idx == len(words):\n                return 0\n\n            wc = collections.Counter(words[idx])\n            if all(counter[key] >= wc[key] for key in wc):\n                ans = max(sum(score[ord(c)-ord('a')] for c in words[idx]) + solve(idx+1, counter-wc), solve(idx+1, counter))\n            else:\n                ans = solve(idx+1, counter) \n                \n            return ans\n        \n        return solve(0, collections.Counter(letters))", "class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        lettersCounter = collections.Counter(letters)\n        scoreDict = { letter:score for letter, score in zip('abcdefghijklmnopqrstuvwxyz', score) }\n        self.cache = [{} for i in range(len(words))]\n        return self.backtracking(words, 0, lettersCounter, scoreDict)\n\n    def backtracking(self, words, cur, remainLC, scoreDict):\n        if cur >= len(words):\n            return 0\n        signature = tuple((key, remainLC[key]) for key in sorted(remainLC))\n        if signature in self.cache[cur]:\n            return self.cache[cur][signature]\n\n        notChoose = self.backtracking(words, cur+1, remainLC, scoreDict)\n        wc = collections.Counter(words[cur])\n        if any(remainLC[w] < wc[w] for w in wc.keys()):\n            return notChoose\n        diff = remainLC - wc\n        curScore = sum(scoreDict[ch] for ch in words[cur])\n        choose = self.backtracking(words,cur+1, diff, scoreDict)\n        ans = max(curScore+choose, notChoose)\n        self.cache[cur][signature] = ans\n        return ans       "]
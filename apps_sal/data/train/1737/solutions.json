["from collections import Counter\n\ndef runoff(voters):\n    while voters[0]:\n        poll = Counter(ballot[0] for ballot in voters)\n        winner, maxscore = max(poll.items(), key = lambda x: x[1])\n        minscore = min(poll.values())\n        if maxscore * 2 > len(voters):\n            return winner\n        voters = [[c for c in voter if poll[c] > minscore] for voter in voters]", "from collections import Counter\n\ndef runoff(voters):\n    numVoters = len(voters)\n    while voters[0]:\n        c = Counter( voters[i][0] for i in range(numVoters) )\n        \n        maxVote = max(c.values())\n        if maxVote > numVoters/2:\n            return [elt for elt in c if c[elt] == maxVote][0]\n        \n        for k in set(c.keys()) ^ set(voters[0]): c[k] = 0   # add those who addn't receive any \"first choice vote\"\n        minVote = min(c.values())\n        voters = [[ p for p in v if not p in [elt for elt in c if c[elt] == minVote] ] for v in voters]\n        \n    return None", "def runoff(voters):\n    if voters == []:\n        return None\n    elif len(voters[0]) == 1:\n        return voters[0][0]\n    voters_dict = {elem: [x[0] for x in voters].count(elem) for elem in voters[0]}\n    expelled = sorted([voters_dict.get(x) for x in voters_dict])[0]\n    return runoff([i for i in [[x for x in choices if\n                                voters_dict.get(x) != expelled] for choices in voters] if i != []])", "def runoff(voters):\n    if len(voters[0]) < 1:\n        return None\n    votes = count_votes(voters)\n    possible_winner = get_winner(votes)\n    if votes[possible_winner] > (len(voters) / 2):\n        return possible_winner\n    else:\n        losers = get_losers(votes)\n        new_voters = [[candidate for candidate in voter if candidate not in losers] for voter in voters]\n        return runoff(new_voters)\n\ndef count_votes(voters):\n    votes = {candidate: 0 for candidate in voters[0]}\n    for voter in voters:\n        votes[voter[0]] += 1\n    return votes\n\ndef get_winner(votes):\n    return max(votes, key=lambda x: votes[x])\n\ndef get_losers(votes):\n    min_vote = min(votes.values())\n    return [candidate for candidate in votes if votes[candidate] == min_vote]", "from collections import Counter\n\ndef runoff(voters):\n    cands = [cand for cand in voters[0] if cand]\n    first_col = [row[0] for row in voters]\n    counter = Counter(first_col)\n\n    for candidate in counter:\n        if counter[candidate] > len(voters)/2:\n            return candidate and candidate or None\n\n    excluded = [x for x in counter if counter[x] == min(counter.values())]\n    excluded.extend(set(cands) - set(first_col))\n\n    for arr in voters:\n        for i,x in enumerate(arr):\n            if x in excluded:\n                arr[i] = None\n    \n   \n    out = []\n    for arr in voters:\n        names, banned = [],[]\n        for val in arr:\n            if val:\n                names.append(val)\n            else:\n                banned.append(val)\n        \n        out.append(names + banned)\n    \n    return runoff(out)\n", "def runoff(votes):\n    voters, candidates = len(votes), votes[0]\n    while votes:\n        round = [vote[0] for vote in votes]\n        polls = sorted((round.count(candidate), candidate) for candidate in candidates)\n        min_poll, (max_poll, winner) = polls[0][0], polls[-1]\n        if max_poll / voters > 0.5:\n            return winner\n        if len(polls) > 1 and max_poll == min_poll:\n            return None\n        loosers = [candidate for poll, candidate in polls if poll == min_poll]\n        for voter in votes:\n            for candidate in loosers:\n                voter.remove(candidate)\n", "from collections import Counter\n\ndef runoff(voters):\n    while sum(voters, []):\n        poll = Counter(ballot[0] for ballot in voters)\n        \n        scores = sorted(poll.values())\n        if scores[-1] * 2 > len(voters):\n            return next((c for c in poll if poll[c] == scores[-1]))\n        elif scores[-1] == scores[0]:\n            return\n        voters = [[c for c in voter if poll[c]  > scores[ 0]] for voter in voters]\n", "def runoff(li):\n    while all(li) and not all(len(k) == 1 for k in li):\n        d = {l: 0 for k in li for l in k}\n        for i in range(len(li)):\n            d[li[i][0]] += 1\n        m = min(d.values())\n        li = [[j for j in i if d[j] != m] for i in li]\n    return li[0][0] if li[0] else None", "from collections import Counter\n\ndef runoff(voters):\n    half_voters = len(voters)/2\n    tally = {}\n    for votes in voters:\n        vote = votes[0]\n        if vote in tally:\n            tally[vote] += 1\n        else:\n            tally[vote] = 1\n            \n    high_counts = Counter(tally).most_common()\n        \n    if high_counts[0][1] > half_voters:\n        return high_counts[0][0]\n        \n    \n    lowest = []\n    \n    lowest_count = -1\n    \n    for i in range(len(high_counts)):\n        current = high_counts[(-1 - i)]\n        if current[1] == lowest_count or lowest_count == -1:\n            lowest_count = current[1]\n            lowest.append(current[0])\n        else: break\n    \n    if len(lowest) == len(high_counts):\n        return None\n    \n    voters = [[vote for vote in votes if (vote in tally) and (vote not in lowest)] for votes in voters]\n    \n    return runoff(voters)", "def runoff(voters):\n\n    candidate_votes = {candidate:0 for candidate in voters[0]}\n    #tally votes\n    for voter in voters:\n        candidate_votes[voter[0]] += 1\n    \n    #decide winner or runoff\n    total_votes = sum(candidate_votes.values())\n    #clear winner\n    for x in list(candidate_votes.keys()):\n        if candidate_votes[x] > total_votes/2:\n            return x\n    #runoff\n    least = min(candidate_votes.values())\n    losers = [x for x in list(candidate_votes.keys()) if candidate_votes[x] == least]\n    if len(losers) == len(list(candidate_votes.keys())):\n        return None\n    \n    for voter in voters:\n        for loser in losers:\n            voter.remove(loser)\n    return runoff(voters)\n    \n    \n    \n"]
["class Transaction:\n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n        \n    def array(self):\n        return f\\\"{self.name},{self.time},{self.amount},{self.city}\\\"\n\nfrom collections import defaultdict\nclass Solution:\n    def invalidTransactions(self, transactions):\n        transactions = [Transaction(*transaction.split(',')) for transaction in transactions]\n        transactions.sort(key=lambda t: t.time) # O(nlogn) time\n\n        trans_indexes = defaultdict(list)\n        for i, t in enumerate(transactions): # O(n) time\n            trans_indexes[t.name].append(i)\n\n        res = []\n        for name, indexes in trans_indexes.items(): # O(n) time\n            left = right = 0\n            for i, t_index in enumerate(indexes):\n                t = transactions[t_index]\n                if (t.amount > 1000):\n                    res.append(\\\"{},{},{},{}\\\".format(t.name, t.time, t.amount, t.city))\n                    continue\n                while left <= t_index and transactions[indexes[left]].time < t.time - 60: # O(60) time\n                    left += 1\n                while right <= len(indexes)-2 and transactions[indexes[right+1]].time <= t.time + 60: # O(60) time\n                    right += 1\n                for i in range(left,right+1): # O(120) time\n                    if transactions[indexes[i]].city != t.city:\n                        res.append(t.array())\n                        break\n\n        return res\n", "class Transaction:\n    \n    def __init__(self, s):\n        params = s.split(',')\n        \n        self.name, self.time, self.amount, self.city = params[0], int(params[1]), int(params[2]), params[3]\n        \n    def __str__(self):\n        return ','.join([self.name, str(self.time), str(self.amount), self.city])\n    \n    \n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        #sort transactions by the time, least to great\n        transactions = [Transaction(t) for t in transactions]\n        \n        transactions.sort(key = lambda t: t.time)\n        \n        #map name to list of idx that use that anem\n        trans_idxs = defaultdict(list)\n        \n        for i, t in enumerate(transactions):\n            trans_idxs[t.name].append(i)\n            \n        invalid = []\n        \n        #for each name, loop over the  associated transactions \n        # keep pointers left and right that start at 0\n        # for each transation move left pointer while trans[idxs[left]].time < t.time - 60\n        # do same for right\n        for name, idxs in list(trans_idxs.items()):\n            left = right = 0\n            \n            for trans_idx in idxs:\n                t = transactions[trans_idx]\n                if t.amount > 1000:\n                    invalid.append(str(t))\n                    continue\n                \n                while left <= len(idxs) - 2 and transactions[idxs[left]].time < t.time - 60:\n                    left += 1\n                    \n                # right = left\n                while right <= len(idxs) - 2 and transactions[idxs[right+1]].time < t.time + 60:\n                    right += 1\n                \n                for j in range(left, right+1):\n                    if transactions[idxs[j]].city != t.city:\n                        invalid.append(str(t))\n                        break\n                        \n        return invalid\n                    \n                \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        record, res = collections.defaultdict(list), set()\n        for trans in transactions:\n            name, time, amount, city = trans.split(',')\n            amount, time = int(amount), int(time)\n            if amount > 1000:\n                res.add(trans)\n            if name in record:\n                i, j = bisect.bisect_left(record[name], (time-60, '', 0)), bisect.bisect_right(record[name], (time+61, '', 0))\n                valid = True\n                for item in record[name][i:j]:\n                    if item[1] != city:\n                        valid = False\n                        res.add(','.join([name, str(item[0]), str(item[2]), item[1]]))\n                if not valid:\n                    res.add(trans)\n            bisect.insort(record[name], (time, city, amount))\n        return list(res)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        track = [] # (time, city, name)\n        ret = set()\n        \n        for t in transactions:\n            name, time, amt, city = t.split(\\\",\\\")\n            time = int(time)\n            if int(amt) > 1000:\n                ret.add(t)\n                track.append((time, city, name, t))\n                # continue\n            \n            # i = len(track) - 1\n            # while i >= 0:\n            # print(track, t)\n            for i in range(0, len(track)):\n                cmp = track[i]\n                # if cmp[0] >= max(time - 60, 0) and cmp[1] != city and cmp[2] == name:\n                # print(track, t, cmp[3])\n                if abs(cmp[0] - time) <= 60 and cmp[1] != city and cmp[2] == name:\n                    ret.add(t)\n                    ret.add(cmp[3])\n                    # break\n                # i -= 1\n            \n            track.append((time, city, name, t))\n        return ret", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid_idxes = set()\n        dct = {}\n        tracs = []\n        for idx, trc in enumerate(transactions):\n            name, time, amount, location = trc.split(\\\",\\\")\n            time = int(time)\n            amount = int(amount)\n            tracs.append((name, time, location, idx, amount))\n        # print(sorted(tracs))\n            \n        for name, time, location, idx, amount in tracs:\n            # if name == 'lee' and time == 152:\n            #     print(name, time, location, idx, amount )\n            #     print(dct['lee'])\n            if amount > 1000:\n                invalid_idxes.add(idx)\n                # continue\n            for prev_name, prev_time, prev_location, prev_idx, _ in tracs:\n                # prev_idx, prev_time, prev_location = dct[name]\n                if prev_name == name and abs(time - prev_time) <= 60 and prev_location != location:\n                    invalid_idxes.add(idx)\n                    invalid_idxes.add(prev_idx)\n            # dct[name] = (idx, time, location)\n            \n        return [transactions[idx] for idx in invalid_idxes]\n            ", "import collections\n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        def parse(S):\n            fields = S.split(',')\n            return [fields[0],int(fields[1]),int(fields[2]),fields[3]]\n        \n        hashMap = defaultdict(list)\n        for S in transactions:\n            fields = parse(S)\n            hashMap[fields[0]].append(fields[1:])\n            \n        invalid = set([])\n        for key in hashMap:\n            vals = hashMap[key]\n            \n                \n                \n            for i,val1 in enumerate(vals):\n                if val1[1] >= 1000:\n                    invalid = invalid.union(set([','.join([key,str(val1[0]),str(val1[1]),val1[2]])]))\n                if len(vals) <= 1:\n                    continue\n                for j,val2 in enumerate(vals[i+1:]):\n                    if abs(val1[0] - val2[0]) <= 60 and val1[2] != val2[2]:\n                        invalid = invalid.union(set([','.join([key,str(val1[0]),str(val1[1]),val1[2]])]))\n                        invalid = invalid.union(set([','.join([key,str(val2[0]),str(val2[1]),val2[2]])]))\n            \n        return list(invalid)\n            \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        temp=[]       \n        for t in transactions:\n            temp.append(t.split(','))\n        temp=sorted(temp, key=lambda x: x[0])  \n        \n        res=set()\n        for i in range(len(temp)):\n            if int(temp[i][2])>1000:\n                res.add(','.join(temp[i]))\n            for j in range(i+1, len(temp)):\n                if temp[i][0]==temp[j][0] and temp[i][3]!=temp[j][3] and abs(int(temp[i][1])-int(temp[j][1]))<=60:\n                            res.add(','.join(temp[i]))\n                            res.add(','.join(temp[j]))\n                \n                \n        return res\n            \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        temp=[]       \n        for t in transactions:\n            temp.append(t.split(','))\n            \n        res=set()\n        for i in range(len(temp)):\n            if int(temp[i][2])>1000:\n                res.add(','.join(temp[i]))\n            for j in range(i+1, len(temp)):\n                if temp[i][0]==temp[j][0] and temp[i][3]!=temp[j][3]:\n                    if abs(int(temp[i][1])-int(temp[j][1]))<=60:\n                            res.add(','.join(temp[i]))\n                            res.add(','.join(temp[j]))\n        return res\n            \n", "from collections import defaultdict\n\n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        out_idx = set()\n        q = []\n        bkt_max = -inf\n\n        for idx, transaction in enumerate(transactions):\n            name, time, amount, city = transaction.split(',')\n            time = int(time)\n            amount = int(amount)\n            \n            if amount > 1000:\n                out_idx.add(idx)\n                \n            bkt_max = max(bkt_max, time + 30)\n            \n            q.append((max(time - 30, 0), time + 30, name, city, idx))\n        \n        bkt = [None] * (bkt_max + 1)\n        for time_lower_bound, time_upper_bound, name, city, idx in q:\n            for i in range(time_lower_bound, time_upper_bound + 1):\n                if bkt[i] is None:\n                    bkt[i] = defaultdict(lambda: defaultdict(lambda: set()))\n                # if i == 676 - 60:\n                #     print(i, time_lower_bound, time_upper_bound, name, city, idx)\n                bkt[i][name][city].add(idx)\n                                \n        for b in bkt:\n            if b is not None:\n                for k, v in list(b.items()):\n                    if len(v) > 1:\n                        for v1 in list(v.values()):\n                            out_idx.update(v1)\n        \n        out = []\n        for idx in out_idx:\n            out.append(transactions[idx])\n        \n        return out\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        LIMIT_AMOUNT = 1000\n        LIMIT_TIME = 60\n        \n        invalid_list = set()\n        t_parsed = [x.split(\\\",\\\") for x in transactions]\n        \n        for t in t_parsed:\n            t[1] = int(t[1])\n            t[2] = int(t[2])\n        \n        for i in range(len(t_parsed)):\n            exceeding = t_parsed[i][2] > LIMIT_AMOUNT\n            if exceeding:\n                invalid_list.add(i)\n                \n            for j in range(i+1, len(t_parsed)):\n                if i != j and \\\\\n                        abs(t_parsed[i][1]-t_parsed[j][1]) <= LIMIT_TIME and \\\\\n                        t_parsed[i][0] == t_parsed[j][0] and \\\\\n                        t_parsed[i][3] != t_parsed[j][3]:\n                    invalid_list.add(i)\n                    invalid_list.add(j)\n                    \n        return [transactions[x] for x in invalid_list]\n            ", "class Solution:\n    from heapq import heappush, heappop\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        if not transactions:\n            return []\n        \n        memo = collections.defaultdict(list)    #create a dictionary to keep track of previous transaction \n        invalid_tran = set()                    #to store invalid transaction / I use set to avoid duplication\n        for i in range(len(transactions)):\n            \n            name, time, amount, city = (int(i) if i.isnumeric() else i for i in transactions[i].split(','))\n            \n            if amount > 1000:                   #if the amount is greater than 1000 add it to the invalid_tran\n                invalid_tran.add(transactions[i])               \n                 \n            if name in memo:                    # if there is any other previous transaction done by similar person , check it from the memo\n                for tran in memo[name]:         # bring all previous transaction done by similar person (iterate over the memo)\n                    _, prev_time, _, prev_city =(int(i) if i.isnumeric() else i for i in  tran.split(','))\n                    if abs(time-prev_time) <= 60 and prev_city != city:  #check if the absolute time difference is less than 60 and the city is the same\n                        invalid_tran.add(tran) \n                        invalid_tran.add(transactions[i])                    \n            \n            memo[name].append(transactions[i])  # add the transaction to the dictionary (memo) - always keep track of previous transaction \n        return invalid_tran", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        parsed_ts = []\n        invalid_ts = set()\n        for t in transactions:\n            t_list = t.split(',')\n            # print(t_list)\n            t_dict={}\n            t_dict['str'] = t\n            t_dict['name'] = t_list[0]\n            t_dict['time'] = int(t_list[1])\n            t_dict['amount'] = int(t_list[2])\n            t_dict['city'] = t_list[3]\n            \n            if t_dict['amount']>1000:\n                invalid_ts.add(t)\n            for t2 in parsed_ts:\n                if abs(t_dict['time']-t2['time'])<=60 and t_dict['city']!=t2['city'] and t_dict['name']==t2['name']:\n                    invalid_ts.add(t_dict['str'])\n                    invalid_ts.add(t2['str'])\n            parsed_ts.append(t_dict)\n        \n        return list(invalid_ts)\n", "class Transaction: \n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n        \nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        # convert each into object Transaction \n        for i in range(len(transactions)): \n            transact = transactions[i].split(',')\n            transactions[i] = Transaction(transact[0], transact[1], transact[2], transact[3])\n    \n        invalid = set()\n        transactions.sort(key=lambda t: t.time)\n        \n        for i, t in enumerate(transactions): \n            if t.amount > 1000: \n                invalid.add(self.toString(t))\n            for j in range(i+1, len(transactions)):\n                s = transactions[j]\n                if t.name == s.name and t.city != s.city and s.time - t.time <= 60:\n                    invalid.add(self.toString(s))\n                    invalid.add(self.toString(t))\n        return invalid\n                \n                \n    def toString(self, s):\n        return ('%s,%d,%d,%s' % (s.name, s.time, s.amount, s.city))\n        \n        \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        watch_set = set([])\n        prev_user = {}\n        # Loop once through transactions\n        for idx, trans in enumerate(transactions):\n            name, time, amt, city = trans.split(\\\",\\\")\n            time = int(time)\n            amt = int(amt)\n            if amt > 1000:\n                watch_set.add(idx)\n            if name in prev_user:\n                for p_idx, p_time, p_city in prev_user[name]:\n                    if abs(p_time - time) <= 60 and p_city != city:\n                        watch_set.add(idx)\n                        watch_set.add(p_idx)\n                prev_user[name].append((idx, time, city))\n            else:\n                prev_user[name] = [(idx, time, city)]\n        return [transactions[idx] for idx in watch_set]", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ts = []\n        for t in transactions:\n            name, stamp, amount, city = t.split(\\\",\\\")\n            ts.append([name, int(stamp), int(amount), city, t])\n        \n        s = set()\n        \n        for t in ts:\n            if t[2] > 1000: s.add(t[4])\n            for v in ts:\n                if t[0] == v[0] and abs(t[1] - v[1]) <= 60 and t[3] != v[3]: s.add(v[4])\n    \n        return list(s)\n                \n                     \n           \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        n=len(transactions)\n\n        invalid=[]\n        hashtime={}\n        hashcity={}\n        hashindex={}\n        \n        for i in range(n):\n            t=transactions[i].split(',')\n            n=t[0]\n            ti=int(t[1])\n            a=int(t[2])\n            c=t[3]\n\n            if hashtime.get(n) is None:\n                hashtime[n]=[ti]\n                hashcity[n]=[c]\n                hashindex[n]=[i]\n                \n            else:\n                for h in range(len(hashindex[n])):\n                    li=hashtime[n][h]\n                    lc=hashcity[n][h]\n                    in1=hashindex[n][h]\n                    if abs(li-ti)<=60 and not lc == c:\n                        if transactions[in1] not in invalid:\n                            invalid.append(transactions[in1])\n                        if transactions[i] not in invalid:\n                            invalid.append(transactions[i])\n                        \n                    \n            if a>1000:\n                if transactions[i] not in invalid:\n                    invalid.append(transactions[i])\n            \n            hashtime[n].append(ti)\n            hashcity[n].append(c)\n            hashindex[n].append(i)\n\n                            \n            # print(invalid, t)\n\n        return invalid\n                \n            \n        \n        \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        temp=[]       \n        for t in transactions:\n            temp.append(t.split(','))\n            \n        res=set()\n        for i in range(len(temp)):\n            if int(temp[i][2])>1000:\n                res.add(','.join(temp[i]))\n            for j in range(i+1, len(temp)):\n                if temp[i][0]==temp[j][0] and temp[i][3]!=temp[j][3] and abs(int(temp[i][1])-int(temp[j][1]))<=60:\n                            res.add(','.join(temp[i]))\n                            res.add(','.join(temp[j]))\n                \n        return res\n            \n", "class Solution:\n    def combineString(self,lis):\n        ans=\\\"\\\"\n        for i in range(len(lis)):\n            ans=ans+lis[i]\n        return ans\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ftran=[]\n        findex=set()\n        name=[]\n        time=[]\n        amt=[]\n        city=[]\n        for i in range(len(transactions)):\n            a,b,c,d=transactions[i].split(\\\",\\\")\n            name.append(self.combineString(a))\n            e=int(self.combineString(b))\n            time.append(e)\n            amt.append(self.combineString(c))\n            city.append(self.combineString(d))\n        for i in range(len(transactions)):\n            s=self.combineString(amt[i])\n            t=int(s)\n            if t>1000:\n                findex.add(i)\n        for i in range(len(name)):\n            for j in range(len(name)):\n                if i==j:\n                    continue\n                if name[i]==name[j] and abs(time[i]-time[j])<=60 and city[i]!=city[j]:\n                    findex.add(i)\n                    findex.add(j)\n        findexl=list(findex)\n        for i in range(len(findexl)):\n            ftran.append(transactions[findexl[i]])\n        return ftran\n                    \n            \n            \n                \n            \n        \n    \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        def formated(ob):\n            return ob['name']+\\\",\\\"+str(ob['time'])+\\\",\\\"+str(ob['amount'])+\\\",\\\"+ob['city']\n        l=[]\n        res=[]\n        for i in range(len(transactions)):\n            store=dict()\n            n,t,amount,city = transactions[i].split(\\\",\\\")\n            store['name']=n\n            store['time']=int(t)\n            store['amount']=int(amount)\n            store['city']=city\n            l.append(store)\n\n        sortedList= sorted(l, key = lambda i: i['time'])\n        \n        for i in range(len(sortedList)):\n            for j in range(len(sortedList)):\n                if i==j:\n                    continue\n                    \n                elif sortedList[i]['name']==sortedList[j]['name'] and abs(sortedList[i]['time'] - sortedList[j]['time'])<=60 and sortedList[i]['city']!=sortedList[j]['city']:\n                    res.append(formated(sortedList[i]))\n                    break\n\n                elif sortedList[i]['amount']>1000:\n                    res.append(formated(sortedList[i]))\n                    break\n                    \n                elif sortedList[j]['time'] - sortedList[i]['time']>60:\n                    break\n                    \n        return res\n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        dic = defaultdict(list)\n        res = []\n        def helper(s):\n            sl = s.split(\\\",\\\")\n            name = sl[0]\n            time = sl[1]\n            amount = sl[2]\n            city = sl[3]\n            return name,time,amount,city\n        \n        for i in transactions:\n            name,time,amount,city = helper(i)\n            \n            if int(amount) > 1000:\n                res.append(i)\n                \n            for j in dic[name]:\n                if abs(int(j[0])-int(time))<=60 and j[2] != city:\n                    if name+','+\\\",\\\".join(j) not in res:\n                        res.append(name+','+\\\",\\\".join(j))\n                    if i not in res:\n                        res.append(i)\n                \n            dic[name].append([time,amount,city])\n            \n        return res", "class Solution:\n    \n    def invalidTransactions(self, transactions):\n        if not transactions: return []\n        n = len(transactions)\n        splits = [trans.split(',') for trans in transactions]\n        valid = [True] * n\n\n        for i in range(n):   #   rule 1\n            if int(splits[i][2]) > 1000:\n                valid[i] = False\n\n        for i in range(n):       #   rule 2\n            for j in range(i+1, n):                \n                if valid[i] or valid[j]:\n                    name1, time1, city1 = splits[i][0], int(splits[i][1]), splits[i][3]\n                    name2, time2, city2 = splits[j][0], int(splits[j][1]), splits[j][3]\n                    if name1 == name2 and city1 != city2 and abs(time1-time2)<=60:\n                        valid[i], valid[j] = False, False\n\n        return [transactions[i] for i in range(n) if not valid[i]]\n    \n#     def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n# #         def asPerTime(string):\n# #             return string.split(',')[1]\n            \n        \n# #         transactions.sort(key=asPerTime)\n        \n#         #dictionary\n#         personDict = dict()\n        \n#         #outputList\n#         outSet = set()\n        \n#         for transaction in transactions:\n#             name, time, amount, city = transaction.split(',')\n#             if int(amount) > 1000:\n#                 outSet.add(transaction)\n                \n#             if name in personDict:\n#                 cityDict = personDict[name]\n#                 cityDict[city].append((time, amount))\n                \n#                 for key in cityDict:\n#                     if key != city:\n#                         for pair in cityDict[key]:\n#                             prevTime, prevAmount = pair\n#                             timeDiff = abs(int(time) - int(prevTime)) \n#                             if timeDiff <= 60:\n#                                 outSet.add(transaction)\n#                                 outSet.add(','.join([name, prevTime, prevAmount, key]))\n            \n            \n#             else:\n#                 personDict[name] = defaultdict(list)\n#                 personDict[name][city].append((time, amount)) \n        \n        \n#         return outSet\n        \n        \n        '''\n        sort the transaction list as per the time\n        \n        a dictionary where key is the name of the person and the the value is a dictionary where the key is the city and the value is time and amount        \n        \n        \n        \n        iterate over the transactions:\n            if the amount is greater than 1000:\n                add it to the list\n            \n            if that same person has done a transaction before\n                are the cities different:\n                    get the time of the latest transaction\n                    if difference is <60:\n                        add the latest transaction as well as this transaction\n                        update the latest transaction with this transaction info\n                        continue\n                        \n                 \n        '''\n        \n        \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        hash_table={}\n        invalid=[]\n        index=-1\n        lindex=[]\n        for trans in transactions:\n            count_coma=0\n            word=''\n            name=''\n            dl=[]\n            index+=1\n            lenght=0\n            ind=0\n            for l in trans:\n                lenght+=1\n                if l==',' or lenght==len(trans):\n                    count_coma+=1\n                    if count_coma==1:\n                        name=word\n                    elif count_coma==2:\n                        tl=[int(word)]\n                        dl.append(tl)\n                    elif count_coma==3:\n                        if int(word)>1000:\n                            ind=1\n                    else:\n                        cl=[word]\n                        dl.append(cl)\n                        dl.append([index])\n                        if name not in hash_table:\n                            hash_table[name]=dl\n                            if ind==1:\n                                invalid.append(trans)\n                                lindex.append(index)\n                        else:\n                            if ind==1:\n                                invalid.append(trans)\n                                lindex.append(index)\n                            for i in range(0,len(hash_table.get(name)[0])):\n                                if abs(hash_table.get(name)[0][i]-dl[0][0])<61 and hash_table.get(name)[1][i]!=dl[1][0]:\n                                    if index not in lindex:\n                                        invalid.append(trans)\n                                        lindex.append(index)\n                                    if hash_table.get(name)[2][i] not in lindex:\n                                        invalid.append(transactions[hash_table.get(name)[2][i]])\n                                        lindex.append(hash_table.get(name)[2][i])\n                            hash_table.get(name)[0].append(dl[0][0])\n                            hash_table.get(name)[1].append(dl[1][0])\n                            hash_table.get(name)[2].append(index)\n                    word=''\n                else:\n                    word+=l\n        return invalid\n", "class Transaction:\n    \n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n        \nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n            \n        tr = [Transaction(*t.split(',')) for t in transactions]\n        transactions = sorted(tr, key=lambda x : x.time)\n        \n        invalid = set()\n        for t in transactions:\n            if t.amount > 1000:\n                invalid.add(\\\"{},{},{},{}\\\".format(t.name, t.time, t.amount, t.city))\n            for o in transactions:\n                if t.name == o.name and abs(t.time - o.time) <= 60 and t.city != o.city:\n                    invalid.add(\\\"{},{},{},{}\\\".format(t.name, t.time, t.amount, t.city))\n                    invalid.add(\\\"{},{},{},{}\\\".format(o.name, o.time, o.amount, o.city))\n        return list(invalid)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        transactions_by_name = {}\n        suspicious_transactions = set()\n        for transaction in transactions:\n            name, time, amount, city = transaction.split(',')\n            if name not in transactions_by_name:\n                transactions_by_name[name] = [[name, time, amount, city]]\n            else:\n                transactions_by_name[name].append([name, time, amount, city])\n        for key in transactions_by_name.keys():\n            for transaction in transactions_by_name[key]:\n                for other_transaction in transactions_by_name[key]:\n                    if int(transaction[2]) >= 1000 and ','.join(transaction) not in suspicious_transactions:\n                        # over 1k\n                        suspicious_transactions.add(','.join(transaction))\n                        continue\n                    if transaction == other_transaction:\n                        continue\n                    time_diff = abs(int(transaction[1]) - int(other_transaction[1]))\n                    print(time_diff)\n                    if time_diff <= 60 and transaction[3] != other_transaction[3]:\n                        suspicious_transactions.add(','.join(transaction))\n        return list(suspicious_transactions)", "class Solution(object):\n    def invalidTransactions(self, transactions):\n        NAME, TIME, AMOUNT, CITY = list(range(4))\n        \n        txrows = []\n        for row in transactions:\n            name, time, amount, city = row.split(',')\n            time = int(time)\n            amount = int(amount)\n            txrows.append((name, time, amount, city))\n        \n        ans = []\n        for i, tx1 in enumerate(txrows):\n            if tx1[AMOUNT] >= 1000:\n                ans.append(transactions[i])\n                continue\n            for j, tx2 in enumerate(txrows):\n                if (i != j and abs(tx1[TIME] - tx2[TIME]) <= 60 and\n                        tx1[NAME] == tx2[NAME] and tx1[CITY] != tx2[CITY]):\n                    ans.append(transactions[i])\n                    break\n        \n        return ans\n", "from collections import defaultdict\nclass Transaction:\n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n    \nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        trans_index = defaultdict(list)\n        trans = []\n        for t in transactions:\n            name, time, amount, city = t.split(',')\n            trans.append(Transaction(name, time, amount, city))\n        trans.sort(key = lambda x: x.time)\n        \n        s = set()\n        for i in range(len(trans)):\n            t1 = trans[i]\n            if t1.amount > 1000:\n                s.add(\\\"{},{},{},{}\\\".format(t1.name, t1.time, t1.amount, t1.city))\n            for j in range(i + 1, len(trans)):\n                t2 = trans[j]\n                if t2.time - t2.time > 60:\n                    break\n                if t2.name == t1.name and t2.time - t1.time <= 60 and t1.city != t2.city:\n                    s.add(\\\"{},{},{},{}\\\".format(t1.name, t1.time, t1.amount, t1.city))\n                    s.add(\\\"{},{},{},{}\\\".format(t2.name, t2.time, t2.amount, t2.city))\n        return list(s)\n            \n        \n            \n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        mapping = {}\n        result = []\n        for trans in transactions:\n            info = trans.split(\\\",\\\")  \n            if int(info[2]) > 1000:\n                result.append(trans)\n            if info[0] not in mapping:\n                mapping[info[0]] = [info[1:]]\n            else:\n                \n                for mapTransaction in mapping[info[0]]:\n                    if (mapTransaction[2] != info[3]) and (abs(int(mapTransaction[0]) - int(info[1])) <= 60):\n                        trans1 = ','.join([info[0]] + mapTransaction[:])\n                        if trans1 not in result:\n                            result.append(trans1)\n                        if trans not in result:\n                            result.append(trans)        \n                mapping[info[0]].append(info[1:])\n            \n        return result\n            \n\n                \n\n        \n                    \n            \n                \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        temp = []\n        for transaction in transactions:\n            name, time, amount, city = transaction.split(\\\",\\\")\n            temp.append([name, int(time), int(amount), city, transaction])\n        \n        ans = set()\n        for transaction1 in temp:\n            if transaction1[2] > 1000:\n                ans.add(transaction1[4])\n            for transaction2 in temp:\n                if transaction1[0] == transaction2[0] and abs(transaction1[1] - transaction2[1]) <= 60 and transaction1[3] != transaction2[3]:\n                    ans.add(transaction2[4])\n        return list(ans)\n                \n                     \n           \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ts = []\n        for t in transactions:\n            name, stamp, amount, city = t.split(\\\",\\\")\n            ts.append([name, int(stamp), int(amount), city, t])\n        \n        s = set()\n        \n        for t in ts:\n            if t[2] > 1000: s.add(t[4])\n            for v in ts:\n                if t[0] == v[0] and abs(t[1] - v[1]) <= 60 and t[3] != v[3]: s.add(v[4])\n    \n        return list(s)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ts = []\n        for t in transactions:\n            name, stamp, amount, city = t.split(\\\",\\\")\n            ts.append([name, int(stamp), int(amount), city, t])\n        \n        s = set()\n        \n        for t in ts:\n            if t[2] > 1000: s.add(t[4])\n            for v in ts:\n                if t[0] == v[0] and abs(t[1] - v[1]) <= 60 and t[3] != v[3]: s.add(v[4])\n    \n        return list(s)\n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        poss = []\n        people = {}\n        for t in transactions:\n            items = t.split(\\\",\\\")\n            if int(items[2]) > 1000:\n                poss.append(t)\n           \n            if items[0] in people:\n                for a,b, c in people[items[0]]:\n                    if abs(a - int(items[1])) <= 60 and items[3] != b:\n                        if t not in poss: \n                            poss.append(t)\n                        if c not in poss: \n                            poss.append(c) \n                people[items[0]].append((int(items[1]), items[3], t))\n            else:\n                people[items[0]] = [(int(items[1]), items[3], t)]\n        return poss", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        dic = {}\n        result = []\n        for i, s in enumerate(transactions):\n            [n,m,a,c] = s.split(\\\",\\\")\n            if int(a)>1000:\n                result.append(s)\n            if n not in dic:\n                dic[n] = [[m,c,i]]\n            else:\n                dic[n].append([m,c,i])\n                for ml, cl, ii in dic[n]:\n                    if cl!=c:\n                        if abs(int(ml)-int(m))<=60:\n                            if s not in result: result.append(s)\n                            if transactions[ii] not in result: result.append(transactions[ii])\n            # print(dic)\n        return result", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        trans_map, suspect = {}, []\n        \n        for trans in transactions:\n            name, time, amount, city = trans.split(\\\",\\\")\n            \n            if name not in trans_map.keys():\n                trans_map[name] = [(int(time), int(amount), city, trans)]\n            else:\n                for prev in trans_map[name]:\n                    oth_time, oth_amount, oth_city, oth_trans = prev\n                \n                    if city != oth_city and abs(int(time) - oth_time) <= 60:\n                        if trans not in suspect:\n                            suspect.append(trans)\n                        \n                        if oth_trans not in suspect:\n                            suspect.append(oth_trans)\n                        \n                trans_map[name].append((int(time), int(amount), city, trans))\n                    \n            if int(amount) > 1000:\n                if trans not in suspect:\n                    suspect.append(trans)\n                \n        \n        return suspect\n            \n            \n                \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        def parseTransaction(t):\n            vals = t.split(',')\n            return vals[0], int(vals[1]), int(vals[2]), vals[3]\n\n        \n        invalid = set()\n        names = {}\n        for t in transactions:\n            name, time, amt, city = parseTransaction(t)\n            if amt > 1000:\n                invalid.add(t)\n            \n            if name in names:\n                for (other_t, other_time, other_city) in names[name]:\n                    if other_city != city and abs(other_time - time) <= 60:\n                        invalid.add(other_t)\n                        invalid.add(t)\n            else:\n                names[name] = []\n\n            names[name].append((t, time, city))\n        \n        return list(invalid)\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        seen={}\n        final=[]\n        \n        for i in transactions:\n            j=i.split(',')\n            \n            name=j[0]\n            time=int(j[1])\n            amount=int(j[2])\n            city=j[3]\n            \n            if name not in seen:\n                seen[name]=[[name,time,amount,city,i]]\n            else:\n                seen[name].append([name,time,amount,city,i])\n        \n        \n        for key in list(seen.keys()):\n            keys_by_time={}\n            # print(key,len(seen[key]))\n            # print(seen[key])\n            for i in range(len(seen[key])):\n                # print(seen[key][i][1])\n                keys_by_time[seen[key][i][1]]=i\n            seen[key].append(keys_by_time)\n            # print(seen[key])\n    \n        \n        for key in list(seen.keys()):\n            \n            for i in range(len(seen[key])-1):\n                \n                for j in range(i+1,len(seen[key])-1):\n                    \n                    current=seen[key][i]\n                    nex=seen[key][j]\n                    \n                    # print(\\\"current \\\",current[1],\\\"nex \\\",nex[1])\n                    if current[3] != nex[3] and abs(current[1]-nex[1]) <= 60:\n                        # print(\\\"condition1\\\")\n                        if current[4] not in final:\n                            final.append(current[4])\n                        if nex[4] not in final:\n                            final.append(nex[4])\n                        \n                    \n                if seen[key][i][4] not in final and seen[key][i][2] >1000:\n                    # print(\\\"condition2\\\")\n                    final.append(seen[key][i][4])\n        return final\n                \n\n", "class dsu:\n    def __init__(self, n):\n        self.parent = [x for x in range(n)]\n        self.rank = [0 for x in range(n)]\n        self.valid = [True for x in range(n)]\n        self.n = n\n        \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, s, t):\n        sp, tp = self.find(s), self.find(t)\n        if sp == tp:\n            return\n        if self.rank[sp] < self.rank[tp]:\n            self.parent[sp] = tp\n        elif self.rank[sp] > self.rank[tp]:\n            self.parent[tp] = sp\n        else:\n            self.parent[tp] = sp\n            self.rank[sp] += 1\n            \n    def cluster(self):\n        for x in range(self.n):\n            self.find(x)\n\n\n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        arrlen = len(transactions)\n        net = dsu(arrlen)\n        tplist = [t.split(',') for t in transactions]\n        for i in range(arrlen):\n            tp = tplist[i]\n            name, time, amt, city = tp[0], tp[1], tp[2], tp[3]\n            if int(amt) > 1000:\n                net.valid[i] = False\n            for j in range(i + 1, arrlen):\n                jtp = tplist[j]\n                jname, jtime, jamt, jcity = jtp[0], jtp[1], jtp[2], jtp[3]\n                if jname == name and jcity != city and abs(int(jtime) - int(time)) <= 60:\n                    net.union(i, j)\n        net.cluster()\n        for i in range(arrlen):\n            if net.parent[i] != i or net.rank[i] != 0:\n                net.valid[i] = False\n        return [transactions[i] for i in range(arrlen) if not net.valid[i]]\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid=[]\n        for i in range(len(transactions)):\n            name1,time1,amount1,city1=transactions[i].split(\\\",\\\")\n            if int(amount1)> 1000:\n                invalid.append(transactions[i])\n                #continue\n                \n            for j in range(i+1,len(transactions)):\n                name2,time2,amount2,city2=transactions[j].split(\\\",\\\")\n                if name1 == name2 and abs(int(time1)-int(time2)) <= 60 and city1!=city2:\n                            invalid.append(transactions[i])\n                            invalid.append(transactions[j])\n        return list(set(invalid))\n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid=[]\n        for i in range(len(transactions)):\n            name1,time1,amount1,city1=transactions[i].split(\\\",\\\")\n            if int(amount1)> 1000:\n                invalid.append(transactions[i])\n            for j in range(i+1,len(transactions)):\n                name2,time2,amount2,city2=transactions[j].split(\\\",\\\")\n                if name1 == name2 and abs(int(time1)-int(time2)) <= 60 and city1!=city2:\n                            invalid.append(transactions[i])\n                            invalid.append(transactions[j])\n        return list(set(invalid))", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid=set()\n        for i in range(len(transactions)):\n            name1,time1,amount1,city1=transactions[i].split(\\\",\\\")\n            if int(amount1)> 1000:\n                invalid.add(transactions[i])\n            for j in range(i+1,len(transactions)):\n                name2,time2,amount2,city2=transactions[j].split(\\\",\\\")\n                if name1 == name2 and abs(int(time1)-int(time2)) <= 60 and city1!=city2:\n                            invalid.add(transactions[i])\n                            invalid.add(transactions[j])\n        return list(invalid)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        res = []\n        \n        for i in range(len(transactions)):\n            action = transactions[i].split(',')\n            person = action[0]\n            time = action[1]\n            amt = action[2]\n            city = action[3]\n            if int(amt) > 1000:\n                res.append(transactions[i])\n                \n            for j in range(i+1, len(transactions)):\n                act2 = transactions[j].split(',')\n                if act2[0] == person and abs(int(act2[1]) - int(time)) <= 60 and city != act2[3]:\n                    res.extend([transactions[i], transactions[j]])\n        return list(set(res))", "class Solution:\n    def invalidTransactions(self, transactions):\n        transactions = [t.split(',') for t in transactions]\n        t = defaultdict(list)\n        res = set()\n        for x in transactions:\n            t[x[0]].append([int(x[1]), int(x[2]), x[3]])\n            \n        # print(t)\n        \n        for name in t:\n            t[name].sort(key = lambda x: x[0])\n            \n            for i in range(len(t[name])):\n                \n                time1, amount1, city1 = t[name][i]\n                if amount1 > 1000:\n                    res.add(','.join([name, str(time1), str(amount1), city1]))\n                    \n                for j in range(i+1, len(t[name])):\n                    time2, amount2, city2 = t[name][j]\n                    if amount2 > 1000:\n                        res.add(','.join([name, str(time2), str(amount2), city2]))\n                    if city1 == city2:\n                        continue\n                    if time2 - time1 <= 60:   \n                        res.add(','.join([name, str(time1), str(amount1), city1]))\n                        res.add(','.join([name, str(time2), str(amount2), city2]))\n                    else:  \n                        break \n            \n        # print(t)\n        return res\n", "class Solution:\n     def invalidTransactions(self, transactions):\n        \\\"\\\"\\\"\n        :type transactions: List[str]\n        :rtype: List[str]\n        \\\"\\\"\\\"\n        invalid=[]\n        for i in range(len(transactions)):\n            name1,time1,amount1,city1=transactions[i].split(\\\",\\\")\n            if int(amount1)> 1000:\n                invalid.append(transactions[i])\n                #continue\n                \n            for j in range(i+1,len(transactions)):\n                name2,time2,amount2,city2=transactions[j].split(\\\",\\\")\n                if name1 == name2 and abs(int(time1)-int(time2)) <= 60 and city1!=city2:\n                            invalid.append(transactions[i])\n                            invalid.append(transactions[j])\n        return list(set(invalid))", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid=[]\n        for i in range(len(transactions)):\n            name1,time1,amount1,city1=transactions[i].split(\\\",\\\")\n            if int(amount1)> 1000:\n                invalid.append(transactions[i])\n                #continue\n                \n            for j in range(i+1,len(transactions)):\n                name2,time2,amount2,city2=transactions[j].split(\\\",\\\")\n                if name1 == name2 and abs(int(time1)-int(time2)) <= 60 and city1!=city2:\n                            invalid.append(transactions[i])\n                            invalid.append(transactions[j])\n        return list(set(invalid))", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        res = []\n        records = []\n        \n        for t in transactions:\n            rec = t.split(',')\n            rec[1] = int(rec[1])\n            rec[2] = int(rec[2])\n            records.append(rec)\n        for rec in records:\n            if rec[2] > 1000:\n                rec[1] = str(rec[1])\n                rec[2] = str(rec[2])\n                res.append(','.join(rec))\n                continue\n            for x in records:\n                if rec[0] == x[0] and abs(rec[1] - int(x[1])) <=60 and rec[3] != x[3]:\n                    rec[1] = str(rec[1])\n                    rec[2] = str(rec[2])\n                    res.append(','.join(rec))\n                    break\n        return res", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        t = [x.split(',') for x in transactions]\n        t.sort(key = lambda x: int(x[1]))\n        invalid = set()\n        \n        for r in range(len(t)):\n            \n            if int(t[r][2]) > 1000:\n                \n                invalid.add(\\\",\\\".join(t[r]))\n                \n            for c in range(r+1, len(t)):\n                \n                if (int(t[c][1]) - int(t[r][1])) <= 60 and t[c][3] != t[r][3] and t[c][0] == t[r][0]:\n                    \n                    invalid.add(\\\",\\\".join(t[r]))\n                    invalid.add(\\\",\\\".join(t[c]))\n                    \n        return(invalid)\n                \n                \n                \n                \n            \n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        s = set()\n        for i in range(0,len(transactions)):\n            name,time,amount,city = transactions[i].split(\\\",\\\")\n            if int(amount) > 1000:\n                s.add(transactions[i])\n            for j in range(i+1,len(transactions)):\n                name1,time1,amount1,city1 = transactions[j].split(\\\",\\\")\n        \n                if name == name1 and abs(int(time)-int(time1))<=60 and city!=city1:\n                \n                    s.add(transactions[i])\n                    s.add(transactions[j])\n        return s\n                ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        if not transactions:\n            return []\n        \n        res = set()\n        n = len(transactions)\n        #transactions.sort()\n       \n        for i in range(n):\n            n1, t1, a1, d1 = transactions[i].split(',')\n            if int(a1) > 1000:\n                res.add(transactions[i])\n            for j in range(i+1, n):\n                n0, t0, a0, d0 = transactions[j].split(',')\n                if n0 == n1 and d1 != d0 and abs(int(t1)-int(t0)) <= 60:\n                    res.add(transactions[i])\n                    res.add(transactions[j])\n        \n        ans = []\n        for t in res:\n            ans.append(t)\n        print(res, ans)\n        return ans", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalidTct = []\n        for i in range(len(transactions)):\n            name1, time1, amount1, location1 = transactions[i].split(',')\n            if int(amount1) > 1000:\n                invalidTct.append(transactions[i])\n            for j in range(i + 1, len(transactions)):\n                name2, time2, amount2, location2 = transactions[j].split(',')\n                if name1 == name2 and abs(int(time1) - int(time2)) <= 60 and location1 != location2:\n                    invalidTct.append(transactions[i])\n                    invalidTct.append(transactions[j])\n        return list(set(invalidTct))", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        invalidSet = set()\n        for i, transaction in enumerate(transactions):\n            name1, time1, amount1, city1 = transaction.split(',')\n            if int(amount1) > 1000:\n                invalidSet.add(transaction)\n            for j in range(i+1, len(transactions)):\n                name2, time2, amount2, city2 = transactions[j].split(',')\n                if name1 == name2 and abs(int(time2) - int(time1)) <= 60 and city1 != city2:\n                    invalidSet.add(transactions[j])\n                    invalidSet.add(transaction)\n        \n        return invalidSet\n                \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        transactions = sorted(transactions, key=lambda transaction: int(transaction.split(\\\",\\\")[1]))\n        # print(transactions)\n        record = {}\n        invalid = []\n        for transaction  in transactions:\n            parse = transaction.split(',')\n            if int(parse[2]) > 1000:\n                invalid.append(transaction)\n                \n                \n            \n            if parse[0] in record:\n                for prev in record[parse[0]]:\n                    time = int(prev.split(\\\",\\\")[1])\n                    loc = prev.split(\\\",\\\")[3]\n                    if int(parse[1]) <= time + 60 and parse[3] != loc:\n\n                        if prev not in invalid:\n                            invalid.append(prev)\n                        if transaction not in invalid:\n                            invalid.append(transaction)\n\n#                 time = record[parse[0]][\\\"time\\\"]\n#                 loc = record[parse[0]][\\\"loc\\\"]\n                \n#                     \n                    \n#                 record[parse[0]][\\\"time\\\"] = int(parse[1])\n#                 record[parse[0]][\\\"loc\\\"] = parse[3]\n                record[parse[0]].append(transaction)\n\n            \n            else:\n                record[parse[0]] = [transaction]\n        \n        return invalid", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        s = set()\n        for i in range(0,len(transactions)):\n            name,time,amount,city = transactions[i].split(\\\",\\\")\n            if int(amount) > 1000:\n                s.add(transactions[i])\n            for j in range(i+1,len(transactions)):\n                name1,time1,amount1,city1 = transactions[j].split(\\\",\\\")\n        \n                if name == name1 and abs(int(time)-int(time1))<=60 and city!=city1:\n                \n                    s.add(transactions[i])\n                    s.add(transactions[j])\n        return s              ", "class Solution:    \n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        d = {}\n        invalid = []\n        answer = []\n        for i in range(len(transactions)):\n            trans = transactions[i].split(\\\",\\\")\n            name,time,amt,city,ind = trans[0],int(trans[1]),int(trans[2]),trans[3],i\n            \n            if amt > 1000:\n                invalid.append(i)\n                answer.append(transactions[i])\n                \n            if name not in d:\n                d[name] = [[name,time,amt,city,ind]]\n            elif name in d:\n                d[name].append([name,time,amt,city,ind])\n\n        for k,v in d.items():\n            v = sorted(v,key = lambda x: x[1])\n            for i in range(len(v)):\n                for j in range(len(v[i+1:])):\n                    if (abs(v[i][1] - v[i+1:][j][1]) <= 60) and (v[i][3] != v[i+1:][j][3]):\n                        if v[i][4] not in invalid:\n                            invalid.append(v[i][4])\n                            answer.append(transactions[v[i][4]])\n                        if v[i+1:][j][4] not in invalid:\n                            invalid.append(v[i+1:][j][4])\n                            answer.append(transactions[v[i+1:][j][4]])\n\n        \n        return answer", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        seen = {}\n        for transaction in transactions:\n            # print(transaction)\n            # print(seen)\n            name, time, amt, city = transaction.split(\\\",\\\")\n            named_t = seen.get(name)\n            if int(amt) > 1000:\n                invalid.append(transaction)\n                if named_t:\n                    named_t.append(transaction)\n                else:\n                    named_t = [transaction]\n                seen[name] = named_t\n            if named_t:\n                for ti in named_t:\n                    n, t, a, c = ti.split(\\\",\\\")\n                    if abs(int(time) - int(t)) <= 60 and c != city:\n                        if transaction not in invalid:\n                            invalid.append(transaction)\n                        if ti not in invalid:\n                            invalid.append(ti)\n                named_t.append(transaction)\n            else:\n                named_t = [transaction]\n            seen[name] = named_t\n        return invalid\n        ", "import collections\nimport bisect\n\nclass Solution:\n    def invalidTransactions(self, orig: List[str]) -> List[str]:\n        transactions = collections.defaultdict(lambda: [])\n        \n        for idx, t in enumerate(orig):\n            name, time, amount, city = t.split(\\\",\\\")\n            \n            time = int(time)\n            amount = int(amount)\n            \n            bisect.insort(transactions[name], [time, amount, city, idx])\n            \n        invalid_transactions = set([])\n        \n        for name in transactions:\n            lst = transactions[name]\n            lst = sorted(lst, key = lambda item: item[0])\n            \n            for idx in range(len(lst)):\n                t1, a1, c1, i1 = lst[idx]\n                \n                if a1 > 1000:\n                    invalid_transactions.add(i1)\n                \n                for idy in range(idx + 1, len(lst)):\n                    if idx == idy:\n                        continue\n                        \n                    t2, a2, c2, i2 = lst[idy]\n                    \n                    if (t2 - t1) <= 60 and c1 != c2:\n                        invalid_transactions.add(i1)\n                        invalid_transactions.add(i2)\n                    elif (t2 - t2) > 60:\n                        break\n                        \n        ret = []\n        for index in invalid_transactions:\n            ret.append(orig[index])\n            \n        return ret\n                    ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        lenth = len(transactions)\n        ans=set()\n        for i in range(lenth):\n            name,time,price,city=transactions[i].split(',')\n            if int(price)>1000:\n                ans.add(transactions[i])\n                \n            for j in range(i,lenth):\n                    n_name,n_time,n_price,n_city=transactions[j].split(',')\n                    if name==n_name and n_city !=city and abs(int(n_time)-int(time)) <=60:\n                        ans.add(transactions[i])\n                        ans.add(transactions[j])\n        return ans ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = set()\n        # transactions = [i.split(\\\",\\\") for i in transactions]\n        # transactions.sort(key = lambda x:(x[0],int(x[1])))\n        # temp = transactions[0]\n        # if int(temp[2])>1000:\n        #     invalid.add(\\\",\\\".join(temp))\n        # for i in transactions[1:]:\n        #     if int(i[2])>1000:\n        #         invalid.add(\\\",\\\".join(i))\n        #         if i[0]==temp[0] and i[3]!=temp[3] and (int(i[1])-int(temp[1]))<=60:\n        #             invalid.add(\\\",\\\".join(temp))\n        #         temp = i\n        #     elif i[0]==temp[0] and i[3]!=temp[3] and (int(i[1])-int(temp[1]))<=60:\n        #         invalid.add(\\\",\\\".join(temp))\n        #         invalid.add(\\\",\\\".join(i))\n        #         temp = i\n        #     else:\n        #         temp = i        \n        # return invalid\n        \n        for ind,val in enumerate(transactions):\n            temp = val.split(\\\",\\\")\n            if int(temp[2])>1000:\n                invalid.add(val)\n            for ind2 in range(ind+1, len(transactions)):\n                temp2 = transactions[ind2].split(\\\",\\\")\n                if temp2[0]==temp[0] and temp2[3]!=temp[3] and abs(int(temp2[1])-int(temp[1]))<=60:\n                    invalid.add(transactions[ind2])\n                    invalid.add(val)\n        return invalid           \n                \n                \n            \n            ", "class Solution:    \n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        d = {}\n        answer = []\n        for i in range(len(transactions)):\n            trans = transactions[i].split(\\\",\\\")\n            name,time,amt,city,ind = trans[0],int(trans[1]),int(trans[2]),trans[3],i\n            \n            if amt > 1000:\n                answer.append(transactions[i])\n                \n            if name not in d:\n                d[name] = [[name,time,amt,city,ind]]\n            elif name in d:\n                d[name].append([name,time,amt,city,ind])\n\n        for k,v in d.items():\n            v = sorted(v,key = lambda x: x[1])\n            for i in range(len(v)):\n                for j in range(len(v[i+1:])):\n                    if (abs(v[i][1] - v[i+1:][j][1]) <= 60) and (v[i][3] != v[i+1:][j][3]):\n                        if transactions[v[i][4]] not in answer:\n                            answer.append(transactions[v[i][4]])\n                        if transactions[v[i+1:][j][4]] not in answer:\n                            answer.append(transactions[v[i+1:][j][4]])\n                            \n        return answer", "import collections\n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        output = []\n        trans_dict = collections.defaultdict()\n        \n        for t in transactions:\n            name, time, amount, city = t.split(\\\",\\\")\n            if float(amount) > 1000:\n                output.append(t)\n            \n            if name not in trans_dict.keys():\n                trans_dict[name] = collections.defaultdict(list)\n            \n            trans_dict[name][city].append((int(time), amount))\n            \n            for c in trans_dict[name].keys():\n                # print(t, \\\"t1\\\")\n                if c != city:\n                    for ta in trans_dict[name][c]:\n                        t2, a2 = ta\n                        # print(t, \\\"t2\\\", t2, int(time), a2)\n                        if abs(t2-int(time))<=60:\n                            prev_trans = name+\\\",\\\"+str(t2)+\\\",\\\"+a2+\\\",\\\"+c\n                            if prev_trans not in output:\n                                output.append(prev_trans)\n                            if t not in output:\n                                output.append(t)\n\n\n        return output\n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ret = []\n        leng = len(transactions)\n        sorted_trans = sorted(transactions, key = lambda i: int(i.split(\\\",\\\", 3)[1]))\n        print(sorted_trans)\n        for i, trans in enumerate(sorted_trans):\n            name, time, amount, city = trans.split(\\\",\\\")\n            # first check amount\n            if int(amount) > 1000 and trans not in ret:\n                ret.append(trans)\n            # second, check 60 min of another in same city\n            for i in range(i+1, leng):\n                if int(sorted_trans[i].split(\\\",\\\")[1]) - int(time) <= 60:\n                    if sorted_trans[i].split(\\\",\\\")[3] != city and sorted_trans[i].split(\\\",\\\")[0] == name:\n                        if trans not in ret: ret.append(trans)\n                        if sorted_trans[i] not in ret: ret.append(sorted_trans[i])\n                    continue\n                else:\n                    break\n        return ret", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        inv = set()\n        \n        for i in range(len(transactions)):\n            cur = transactions[i].split(\\\",\\\")\n            if (int(cur[2]) > 1000):\n                inv.add(','.join(cur))\n                cur_inv = True\n            for j in range(i, len(transactions) - 1):\n                comp = transactions[j + 1].split(\\\",\\\")\n                if (comp[0] == cur[0]):\n                    if (abs(int(comp[1]) - int(cur[1])) <= 60 and comp[3] != cur[3]):\n                        inv.add(','.join(cur))\n                        inv.add(','.join(comp))\n        return inv", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        temp=[]        \n        for t in transactions:\n            temp.append(t.split(','))\n            \n        res=[]  \n        for i in range(len(temp)):\n            if int(temp[i][2])>1000 and ','.join(temp[i]) not in res :\n                res.append(','.join(temp[i]))\n            for j in range(i+1, len(temp)):\n                if temp[i][0]==temp[j][0] and temp[i][3]!=temp[j][3]:\n                    if abs(int(temp[i][1])-int(temp[j][1]))<=60:\n                        if ','.join(temp[i]) not in res:\n                            res.append(','.join(temp[i]))\n                        if ','.join(temp[j]) not in res:\n                            res.append(','.join(temp[j]))\n        return res\n            \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        arr = []\n        for x in transactions:\n            n, a, t, p = x.split(',')\n            arr.append([n, a, t, p])\n        \n        inv = []\n        for i in range(len(arr)):\n            n, t, a, p = arr[i]\n            added = False\n            if int(a) > 1000:\n                inv.append(arr[i])\n                added = True\n            for j in range(i + 1, len(arr)):\n                \n                nn, tt, aa, pp = arr[j]\n                \n                if abs(int(t) - int(tt)) <= 60 and n == nn and p != pp:\n                    if not added: \n                        inv.append(arr[i])\n                        added = True\n                    inv.append(arr[j])\n                    \n        \n        inv = [','.join(x) for x in inv]\n        inv = list(set(inv))\n        return (inv)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        arr = []\n        for x in transactions:\n            n, a, t, p = x.split(',')\n            arr.append([n, a, t, p])\n        \n        inv = []\n        for i in range(len(arr)):\n            n, t, a, p = arr[i]\n            added = False\n            if int(a) > 1000:\n                inv.append(arr[i])\n                added = True\n            for j in range(i + 1, len(arr)):\n                \n                nn, tt, aa, pp = arr[j]\n                \n                if abs(int(t) - int(tt)) <= 60 and n == nn and p != pp:\n                    if not added: inv.append(arr[i])\n                    inv.append(arr[j])\n                    continue\n        \n        inv = [','.join(x) for x in inv]\n        inv = list(set(inv))\n        return (inv)", "import collections\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        byName = collections.defaultdict(list)\n        invalids = set()\n        for transaction in transactions:\n            name, t_min, amt, city = transaction.split(',')\n            byName[name].append((int(t_min), int(amt), city, transaction))\n            if int(amt) > 1000:\n                invalids.add(transaction)\n        for name in byName:\n            trans = byName[name]\n            for i in range(len(trans)):\n                for j in range(i, len(trans)):\n                    if abs(trans[i][0] - trans[j][0]) <= 60 and trans[i][2] != trans[j][2]: \n                        invalids.add(trans[i][3])\n                        invalids.add(trans[j][3])\n        return list(invalids)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        transactionDict = {}\n        invalid = []\n        for i in transactions:\n            transactionData = i.split(',')\n            name, time, amount, city = transactionData[0], transactionData[1], transactionData[2], transactionData[3]\n            if name in transactionDict.keys():\n                transactionVal = transactionDict[name]\n            else:\n                transactionVal = []\n            transactionVal.append([time, amount, city])\n            transactionDict[name] = transactionVal\n        for i in transactionDict.keys():\n            for v in transactionDict[i]:\n                #test if transaction over 1000\n                if int(v[1]) > 1000:\n                    if '{},{},{},{}'.format(i, v[0], v[1], v[2]) not in invalid:\n                        invalid.append('{},{},{},{}'.format(i, v[0], v[1], v[2]))\n                #test if any other transaction time within 60 in a different city\n                for listd in transactionDict[i]:\n                    if listd != v:\n                        if abs(int(v[0]) - int(listd[0])) <= 60 and v[2] != listd[2]:\n                            if '{},{},{},{}'.format(i, v[0], v[1], v[2]) not in invalid:\n                                invalid.append('{},{},{},{}'.format(i, v[0], v[1], v[2]))\n        return invalid", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalids = set()\n        \n        for i in range(len(transactions)):\n            name, time, amount, city = transactions[i].split(',')\n            if int(amount) > 1000:\n                invalids.add(transactions[i])\n            j = i +1\n            while j < len(transactions):\n                nameJ, timeJ, amountJ, cityJ = transactions[j].split(',')\n                if nameJ == name and abs(int(timeJ) - int(time)) <= 60 and city != cityJ:\n                    invalids.add(transactions[i])\n                    invalids.add(transactions[j])\n                j+=1\n        return list(invalids)\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        name = []\n        time = []\n        amount = []\n        city = []\n        for t in transactions:\n            n,t,a,c = t.split(\\\",\\\")\n            name.append(n)\n            time.append(int(t))\n            amount.append(int(a))\n            city.append(c)\n        \n        ans = set()\n        N = len(transactions)\n        for i in range(N):\n            if amount[i] > 1000:\n                ans.add(transactions[i])\n            for j in range(N):\n                if i == j: continue\n                if name[i] == name[j] and abs(time[i]-time[j]) <= 60 and city[i] != city[j]:\n                    ans.add(transactions[j])\n        return ans", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        # { name -> {time -> amount city i} \n        invalidIdxList = set()\n        transDict = {}\n        for i, transaction in enumerate(transactions):\n            name, time, amount, city = transaction.split(',')\n            if int(amount) > 1000:\n                invalidIdxList.add(i)\n            j = i + 1\n            while j < len(transactions):\n                otherName, otherTime, otherAmount, otherCity = transactions[j].split(',')\n                if name == otherName and abs(int(time) - int(otherTime)) <= 60 and city != otherCity:\n                    invalidIdxList.add(i)\n                    invalidIdxList.add(j)\n                j = j + 1\n        res = []\n        for idx in invalidIdxList:\n            res.append(transactions[idx])\n        return res\n              \n\n                    \n                    \n                    \n                    \n            \n                \n            \n        \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        n = len(transactions)\n        invalid_check = [0]*n\n        for i in range(n):\n            i_info = transactions[i].split(',')\n            assert(len(i_info) == 4)\n            if(int(i_info[2]) >= 1000): invalid_check[i] = 1\n            for j in range(i+1, n):\n                j_info = transactions[j].split(',')\n                assert(len(j_info) == 4)\n                if(i_info[0] == j_info[0] and\n                   i_info[3] != j_info[3] and\n                    abs(int(i_info[1]) - int(j_info[1])) <= 60) :\n                    invalid_check[i] = invalid_check[j] = 1\n        ret = []\n        for i in range(n):\n            if(invalid_check[i]): ret.append(transactions[i])\n        return ret\n                \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        in_val = []\n        trans = []\n        for each in transactions:\n            temp = each\n            temp = temp.split(\\\",\\\")\n            trans.append(temp)\n        #print(trans)\n        \n        size = len(trans)\n        for i in range(size):\n            if int(trans[i][2]) > 1000:\n                if transactions[i] not in in_val:\n                    in_val.append(transactions[i])\n            else:\n                for j in range(size):\n                    if i != j and trans[i][0] == trans[j][0] and abs(int(trans[i][1])-int(trans[j][1])) <= 60 and trans[i][3] != trans[j][3]:\n                        if transactions[i] not in in_val:\n                            in_val.append(transactions[i])\n        return in_val\n        \n        \n        \n        \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalids = []\n        val_dict = defaultdict(list)\n        \n        for trs in transactions:\n            #print(val_dict)\n            trs_list = trs.split(\\\",\\\")\n            amount = int(trs_list[2])\n            \n            val_dict[trs_list[0]].append((int(trs_list[1]),int(trs_list[2]), trs_list[3]))\n\n            for trans in val_dict[trs_list[0]]:\n                if abs(int(trs_list[1]) - int(trans[0])) <= 60 and trs_list[3] != trans[2]:\n                    if trs not in invalids:\n                        invalids.append(trs)\n\n                    if str(trs_list[0])+\\\",\\\"+str(trans[0])+\\\",\\\"+str(trans[1])+\\\",\\\"+str(trans[2]) not in invalids:\n                        invalids.append(str(trs_list[0])+\\\",\\\"+str(trans[0])+\\\",\\\"+str(trans[1])+\\\",\\\"+str(trans[2]))\n                \n            \n            if amount > 1000:\n                invalids.append(trs)\n                \n                \n        return list(set(invalids))\n                \n            \n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ans = []\n        num = len(transactions)\n        added = set()\n        for i in range(num):\n            name1, time1, num1, city1 = transactions[i].split(',')\n            if int(num1) > 1000 and i not in added:\n                ans.append(transactions[i])\n                added.add(i)\n            for j in range(i+1, num):\n                name2, time2, num2, city2 = transactions[j].split(',')\n                if (name1 == name2 and \n                    abs(int(time2) - int(time1)) <= 60 \n                    and city2 != city1):\n                    if i not in added:\n                        ans.append(transactions[i])\n                        added.add(i)  \n                    if j not in added:\n                        ans.append(transactions[j])\n                        added.add(j)  \n        return ans\n            \n        \n            \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        res = set()\n        \n        for i in range(len(transactions) - 1):\n            t1 = transactions[i].split(',')\n            # transaction over $1000\n            if int(t1[2]) > 1000:\n                res.add(transactions[i])\n            for j in range(i + 1, len(transactions)):\n                t2 = transactions[j].split(',')\n                # names match, cities do not match, transactions within 60 min\n                if t1[0] == t2[0] and t1[3] != t2[3] and abs(int(t2[1]) - int(t1[1])) <= 60:\n                    res.add(transactions[i])\n                    res.add(transactions[j])\n                if int(t2[2]) > 1000:\n                    res.add(transactions[j])\n                    \n        return list(res)\n                \n                    \n                \n                \n                \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        M = collections.defaultdict(dict)\n        \n        ans = set()  # avoid duplicate\n        for t in transactions:\n            name, time, amount, city = t.split(',')\n            if int(amount) > 1000:              # invalid condition 1\n                ans.add(t)\n\n            Flag = False\n            if name in M:                       # have transaction under the name\n                for k,v in list(M[name].items()):     # iterate all (time, transaction) pairs under this name\n                    if abs(int(time)-k) <= 60 and v.split(',')[-1] != city:  # invalid condition 2\n                        ans.add(v)\n                        Flag = True             # add current transaction\n            M[name][int(time)] = t              # add transaction to HashMap\n            if Flag:\n                ans.add(t)\n        \n        return list(ans)\n", "class Solution:\n    def isinterval(self,a,b):\n        if abs(int(a)-int(b))<=60:\n            return True\n        return False\n    def issame(self,a,b):\n        if a!=b:\n            return True\n        return False\n    \n    def issamename(self,a,b):\n        if a==b:\n            return True\n        return False\n    def invalidTransactions(self, A: List[str]) -> List[str]:\n        arr=[]\n        index=0\n        n=len(A)\n        while index<n:\n            arr.append(list(A[index].split(',')))\n            index+=1\n        \n        arr=sorted(arr,key=lambda x:int(x[1]))\n        visited=[True for i in range(n)]\n        result=[]\n        for i in range(n):\n            if int(arr[i][2])>1000:\n                result.append(\\\",\\\".join(arr[i]))\n                visited[i]=False\n            for j in range(i+1,n):    \n                if self.isinterval(arr[i][1],arr[j][1]) and arr[i][3]!=arr[j][3] and arr[i][0]==arr[j][0]:\n                    if visited[i]:\n                        visited[i]=False\n                        result.append(\\\",\\\".join(arr[i]))                    \n                    if visited[j]:\n                        visited[j]=False\n                        result.append(\\\",\\\".join(arr[j]))                    \n                    \n                \n        result=list(set(result))                                                       \n                \n        return result\n            \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = set()\n        for i, t in enumerate(transactions):\n            name, time, amount, city = t.split(',')\n            if int(amount) > 1000:\n                invalid.add(i)\n                continue\n            for j in range(len(transactions)):\n                if i == j: continue\n                jname, jtime, jamount, jcity = transactions[j].split(',')\n                if jname == name and jcity != city and abs(int(jtime) - int(time)) <= 60:\n                    invalid.add(i)\n                    invalid.add(j)\n        \n        return [transactions[i] for i in invalid]", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        res = []\n        for i in range(len(transactions)):\n            added = False\n            for j in range(i + 1, len(transactions)):\n                a = transactions[i].split(',')\n                b = transactions[j].split(',')\n                if a[0] == b[0] and a[-1] != b[-1] and abs(int(a[1]) - int(b[1])) <= 60:\n                    res.append(','.join(a))\n                    res.append(','.join(b))\n                    added = True\n            if not added:\n                if int(transactions[i].split(',')[2]) > 1000:\n                    res.append(transactions[i])\n\n        return list(set(res))", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        res = set()\n        for i in range(len(transactions)):\n            added = False\n            for j in range(i + 1, len(transactions)):\n                a = transactions[i].split(',')\n                b = transactions[j].split(',')\n                if a[0] == b[0] and a[-1] != b[-1] and abs(int(a[1]) - int(b[1])) <= 60:\n                    res.add(','.join(a))\n                    res.add(','.join(b))\n                    added = True\n            if not added:\n                if int(transactions[i].split(',')[2]) > 1000:\n                    res.add(transactions[i])\n\n        return list(res)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalids = set()\n        \n        \n        for i in range(len(transactions)):\n            name, time, amount, city = transactions[i].split(',')\n            if int(amount) > 1000:\n                invalids.add(transactions[i])\n            j = i +1\n            while j < len(transactions):\n                nameJ, timeJ, amountJ, cityJ = transactions[j].split(',')\n                if nameJ == name and abs(int(timeJ) - int(time)) <= 60 and city != cityJ:\n                    invalids.add(transactions[i])\n                    invalids.add(transactions[j])\n                j+=1\n        return list(invalids)\n            \n                \n        print (invalids)\n        \\\"\\\"\\\"\n        Hashtable => NO\n        \n        Two Pointer yes\n        \n        \n        \n        \\\"\\\"\\\"\n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        transactions_dict = defaultdict(list)\n        invalid = []\n        for i in range(len(transactions)):\n            details = transactions[i].split(\\\",\\\")\n            if int(details[2]) > 1000:\n                invalid.append(transactions[i])\n            \n            for j in range(i+1, len(transactions)):\n                name,time, amount,city = transactions[j].split(\\\",\\\")\n                if abs(int(details[1]) - int(time)) <=60 and details[0] == name :\n                    if (details[3] != city):\n                        invalid.append(transactions[i])\n                        invalid.append(transactions[j])\n                \n        return list(set(invalid))\n        ", "class Solution:\n    def invalidTransactions(self, ts: List[str]) -> List[str]:\n        nts = [t.split(',') for t in ts]\n        nts = sorted([[a, int(b), int(c), d] for a, b, c, d in nts])\n        res = set()\n        for a in nts:\n            if a[2] > 1000: res.add(','.join(map(str,a)))\n        for i in range(len(nts)):\n            for j in range(i + 1, len(nts)):\n                a, b = nts[i], nts[j]\n                if a[0] != b[0] or abs(a[1] - b[1]) > 60: break\n                if a[3] != b[3]: \n                    res.add(','.join(map(str,a)))\n                    res.add(','.join(map(str,b)))\n        return list(res)", "class Transaction:  \n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        transactions = [Transaction(*t.split(',')) for t in transactions]\n        transactions.sort(key = lambda x: x.time)\n        nameMap = collections.defaultdict(list)\n        for i, t in enumerate(transactions):\n            nameMap[t.name].append(i)\n        invalid = []\n        for name, idxLst in nameMap.items():\n            left = 0\n            right = 0\n            for idx in idxLst:\n                t = transactions[idx]\n                if t.amount > 1000:\n                    invalid.append(f'{t.name},{t.time},{t.amount},{t.city}')\n                    continue\n                while left < len(idxLst) and transactions[idxLst[left]].time < t.time-60:\n                    left += 1\n                while right < len(idxLst) and transactions[idxLst[right]].time <= t.time+60:\n                    right += 1\n                for i in range(left, right):\n                    if t.city != transactions[idxLst[i]].city:\n                        invalid.append(f'{t.name},{t.time},{t.amount},{t.city}')\n                        break\n        return invalid", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        if not transactions or len(transactions) ==0:\n            return []\n        \n        d = collections.defaultdict(dict)\n        res = set()\n        \n        for t in transactions:\n            name,time,amount,city = t.split(',')\n            \n            if int(amount) > 1000:\n                res.add(t)\n            \n            flag = False\n            if name in d:\n                \n                for _time,_t in d[name].items():\n                    \n                    if abs(_time-int(time)) <= 60 and city != _t.split(',')[-1]:\n                        flag = True\n                        res.add(_t)\n            \n            if flag:\n                res.add(t)\n                \n            d[name][int(time)] = t\n        \n        return list(res)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        \n        for i, t1 in enumerate(transactions):\n            name1, time1, amount1, city1 = t1.split(',')\n            if int(amount1) > 1000:\n                invalid.append(t1)\n                continue\n            for j, t2 in enumerate(transactions):\n                if i != j: \n                    name2, time2, amount2, city2 = t2.split(',')\n                    if name1 == name2 and city1 != city2 and abs(int(time1) - int(time2)) <= 60:\n                        invalid.append(t1)\n                        break\n        \n        return invalid\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        for ind,trn in enumerate(transactions):\n            name,time,amt,city = trn.split(\\\",\\\")\n            if int(amt)>1000:\n                invalid.append(trn)\n                continue\n            for j,trn2 in enumerate(transactions):\n                if ind!=j:\n                    name1,time1,amt1,city1 = trn2.split(\\\",\\\")\n                    if name==name1 and abs(int(time)-int(time1))<=60 and city!=city1:\n                        invalid.append(trn)\n                        break\n        return invalid", "import collections\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        mapNameToTrans = collections.defaultdict(list)\n        \n        for t in transactions:\n            name, time, amount, city = t.split(',')\n            if int(amount) > 1000:\n                invalid.append(t)\n                did_add = True\n            else:\n                did_add = False\n            for past in mapNameToTrans[name]:\n                if abs(int(past[0]) - int(time)) <= 60 and past[1] != city:\n                    if not did_add:\n                        invalid.append(t)\n                        did_add = True\n                    if not past[2]:\n                        past[2] = True\n                        invalid.append(past[3])\n            mapNameToTrans[name].append([time, city, did_add, t])\n        return invalid\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        personalTransactions = {}\n        invalidTransactions = set()\n        for i in transactions:\n            name, time, amount, city = i.split(',')\n            if(int(amount) > 1000):\n                invalidTransactions.add(i)\n            if(name not in personalTransactions.keys()):\n                personalTransactions[name] = [(int(time), city, amount)]\n                continue\n            else:\n                personalTransactions[name].append((int(time), city, amount))\n                for j in personalTransactions[name]:\n                    if(city == j[1]):\n                        continue\n                    else:\n                        if(abs(j[0]-int(time)) <= 60):\n                            invalidTransactions.add(i)\n                            invalidTransactions.add(name+','+str(j[0])+','+j[2]+','+j[1])\n        return list(invalidTransactions)", "class Solution:\n    def invalidTransactions(self, arr: List[str]) -> List[str]:\n        self.memo = collections.defaultdict(list)\n        ans = set()\n        for s in arr:\n            name, mi, mon, place = s.split(\\\",\\\")\n            if int(mon) > 1000:\n                ans.add(s)\n            if self.memo[name]:\n                flag = False\n                for a,b,c,d in self.memo[name]:\n                    if d != place and abs(int(mi) - b) <= 60:\n                        flag = True\n                        ans.add(a + \\\",\\\" + str(b) + \\\",\\\" + str(c) + \\\",\\\" + d)\n                if flag:\n                    ans.add(s)\n            self.memo[name] += ((name, int(mi), int(mon), place)),\n        return ans", "class Solution:\n    def invalidTransactions(self, arr: List[str]) -> List[str]:\n        self.memo = collections.defaultdict(list)\n        ans = set()\n        for s in arr:\n            name, mi, mon, place = s.split(\\\",\\\")\n            if int(mon) > 1000:\n                ans.add(s)\n            if self.memo[name]:\n                flag = False\n                for a,b,c,d in self.memo[name]:\n                    if d != place and abs(int(mi) - b) <= 60:\n                        flag = True\n                        ans.add(a + \\\",\\\" + str(b) + \\\",\\\" + str(c) + \\\",\\\" + d)\n                if flag:\n                    ans.add(s)\n            self.memo[name] += ((name, int(mi), int(mon), place)),\n        return ans\n", "class T:\n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n    def get_string(self):\n        return self.name+\\\",\\\"+str(self.time)+\\\",\\\"+str(self.amount)+\\\",\\\"+self.city\n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        # create T object\n        ts = []\n        for tran in transactions:\n            ts.append(T(*tran.split(\\\",\\\")))\n        ts.sort(key=lambda t: t.time)\n        name2t = defaultdict(list)\n        \n        for t in ts:\n            name2t[t.name].append(t)\n        res = []\n        for name,ts in name2t.items():\n            for i,t in enumerate(ts):\n                left,right = 0,0\n                if t.amount > 1000: \n                    res.append(t.get_string())\n                    continue\n                \n                while left <= len(ts)-2 and ts[left].time < t.time-60: # O(60)\n                    left+=1 # \uc544\uc8fc\ub9e8\ub9c8\uc9c0\ub9c9\uae4c\uc9c0\uac00\ub294\uac70 \uac00\ub2a5\n                while right <= len(ts)-2 and ts[right+1].time <= t.time+60: # O(60)\n                    right+=1 # \uc544\uc8fc\ub9e8\ub9c8\uc9c0\ub9c9\uae4c\uc9c0\uac00\ub294\uac70 \uac00\ub2a5\n                    \n                for i in range(left, right+1): # O(120)\n                    cand_t = ts[i]\n                    if cand_t.city != t.city:\n                        res.append(t.get_string())\n                        break\n        return res", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        transMap = dict() # name: [time, city, t]\n        invalids = set()\n        \n        for t in transactions:\n            name, time, amount, city = t.split(',')\n            if int(amount) > 1000:\n                invalids.add(t)\n            if name in transMap:\n                for stime, scity, st in transMap[name]:\n                    if abs(int(time) - int(stime)) <= 60 and city != scity:\n                        invalids.add(st)\n                        invalids.add(t)\n            else:\n                transMap[name] = []\n            transMap[name].append((time, city, t))\n        return list(invalids)\n", "class Solution:\n    # > 1000\n    # same name, different city, <= 60 min\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n#         loop through transactions \n#             if amount is greater >= 1000 add it to invalid set\n#             have another loop, check every other transactions for invalid time\n         \n        # { invalidtransaction}\n        # {\n        #     alice: [\\\"transaction\\\",\\\"transaction\\\"]\n        #     bob: [\\\"transaction\\\"]\n        # }\n        \n        # userTransactions = collections.defaultdict(list)\n        invalidTransactions = set()\n        \n        for i,transaction in enumerate(transactions):\n            [name,time,amount,city] = transaction.split(\\\",\\\")\n            \n            if int(amount) > 1000: invalidTransactions.add(transaction)\n            # userTransactions[name].append(transaction)\n            \n            for j in range(len(transactions)):\n                if i!=j:\n                    [name2,time2,amount2,city2] = transactions[j].split(\\\",\\\")\n\n                    if name==name2 and abs(int(time)-int(time2)) <= 60 and city!=city2:\n                        invalidTransactions.add(transaction)\n                        invalidTransactions.add(transactions[j])\n                        break\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n            \n            \n            \n#         for name in userTransactions:\n#             userTrans = userTransactions[name]\n            \n#             for i in range(len(userTrans)-1):\n#                 for j in range(i+1,len(userTrans)):\n#                     [_,time,_,city] = userTrans[i].split(\\\",\\\")\n#                     [_,time2,_,city2] = userTrans[j].split(\\\",\\\")\n                    \n#                     if abs(int(time)-int(time2)) <= 60 and city != city2:\n#                         invalidTransactions.add(userTrans[i])\n#                         invalidTransactions.add(userTrans[j])\n                    \n        return list(invalidTransactions)\n            \n                \n        \n        \n        ", "class Transaction(object):\n    def __init__(self, txn):\n        name, time, amount, city = txn.split(',')\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n        \n    def __str__(self):\n        return \\\"{},{},{},{}\\\".format(self.name, self.time, self.amount, self.city)\n    \nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        d = defaultdict(list)\n        ans = []\n        txns = list(map(Transaction, transactions))\n        for i, t in enumerate(txns):\n            d[t.name].append(i)\n        for name, tid in d.items():    \n            l = r = 0\n            for t in (tid := sorted(tid, key=lambda x:txns[x].time)):\n                if txns[t].amount > 1000:\n                    ans.append(t)\n                    continue\n                while l + 1 < len(tid) and txns[tid[l]].time + 60 < txns[t].time:\n                    l += 1\n                while r + 1 < len(tid) and txns[tid[r+1]].time <= txns[t].time + 60:\n                    r += 1\n                for j in range(l, r+1):\n                    if txns[tid[j]].city != txns[t].city:\n                        ans.append(t)\n                        break\n        return [str(transactions[i]) for i in ans]      ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = set()\n        seen = {}\n        for i in range(len(transactions)):\n            trans = transactions[i].split(\\\",\\\")\n            if trans[0] in seen: \n                for old in seen[trans[0]]:\n                    if old[0] != trans[3] and abs(int(old[1])-int(trans[1])) <= 60:\n                        invalid.add(transactions[i])\n                        invalid.add(transactions[old[2]])\n            if int(trans[2]) > 1000:\n                invalid.add(transactions[i])\n            \n            if trans[0] in seen:\n                seen[trans[0]].append([trans[3],trans[1],i])\n            else:\n                seen[trans[0]] = [[trans[3],trans[1],i]]\n        \n        return invalid\n            \n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        res = set()\n        list_transactions = []\n        hash = defaultdict(list)\n        for i, t in enumerate(transactions):\n            temp = t.split(\\\",\\\")\n            temp.append(i)\n            list_transactions.append(temp)\n            \n        for i in range(len(list_transactions)):\n            t1 = list_transactions[i]\n            if int(t1[2]) > 1000:\n                res.add(transactions[i])\n            \n            if t1[0] in hash:\n                for t2 in hash[t1[0]]:\n                    if t2[3] != t1[3] and abs(int(t1[1]) - int(t2[1])) <= 60:\n                        res.add(transactions[t2[4]])\n                        res.add(transactions[i])\n            hash[t1[0]].append(t1)\n\n                    \n        return list(res)\n                \n                    \n                \n                \n                \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        res = set()\n        # list_transactions = []\n        hash = defaultdict(list)\n        # for i, t in enumerate(transactions):\n        #     temp = t.split(\\\",\\\")\n        #     temp.append(i)\n        #     list_transactions.append(temp)\n            \n#         for i in range(len(list_transactions)):\n#             t1 = list_transactions[i]\n#             if int(t1[2]) > 1000:\n#                 res.add(transactions[i])\n            \n#             if t1[0] in hash:\n#                 for t2 in hash[t1[0]]:\n#                     if t2[3] != t1[3] and abs(int(t1[1]) - int(t2[1])) <= 60:\n#                         res.add(transactions[t2[4]])\n#                         res.add(transactions[i])\n#             hash[t1[0]].append(t1)\n            \n        for i in range(len(transactions)):\n            t1 = transactions[i].split(\\\",\\\")\n            t1.append(i)\n            if int(t1[2]) > 1000:\n                res.add(transactions[i])\n            \n            if t1[0] in hash:\n                for t2 in hash[t1[0]]:\n                    if t2[3] != t1[3] and abs(int(t1[1]) - int(t2[1])) <= 60:\n                        res.add(transactions[t2[4]])\n                        res.add(transactions[i])\n            hash[t1[0]].append(t1)\n\n                    \n        return list(res)\n                \n                    \n                \n                \n                \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        trans , invalid = [ ] , [ ]\n        for t in transactions :\n            trans += t.split( ',' ) ,\n        trans.sort( key = lambda x : int( x[ 1 ] ) )\n        invalid = set()\n        for i in range( len( trans ) ) :\n            if int( trans[ i ][ 2 ] ) > 1000 :\n                invalid.add( ','.join( trans[ i ] ) )\n                if i :\n                    j = i\n                    while j and int( trans[ i ][ 1 ] ) - int( trans[ j - 1 ][ 1 ] ) < 61 :\n                        if trans[ i ][ 0 ] == trans[ j - 1 ][ 0 ] and trans[ i ][ 3 ] != trans[ j - 1 ][ 3 ] :\n                            invalid.add( ','.join( trans[ j - 1 ] ) )\n                        j -= 1\n\n            elif i and int( trans[ i ][ 1 ] ) - int( trans[ i - 1 ][ 1 ] ) < 61 :\n                j = i\n                while j and int( trans[ i ][ 1 ] ) - int( trans[ j - 1 ][ 1 ] ) < 61 :                    \n                    if trans[ i ][ 0 ] == trans[ j - 1 ][ 0 ] and trans[ i ][ 3 ] != trans[ j - 1 ][ 3 ] :\n                        invalid.add( ','.join( trans[ j - 1 ] ) )\n                        invalid.add( ','.join( trans[ i ] ) )\n                    j -= 1\n        return invalid\n    #Sanyam Rajpal\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        def giddy(item):\n            return item.split(',')\n        \n        result = set()\n        seen = collections.defaultdict(list)\n        transactions = list(map(giddy, transactions))\n        # transactions.sort(key=lambda x: x[1])\n        # print(transactions)\n        for i in range(len(transactions)):\n            val = transactions[i]\n            if int(val[2])>1000:\n                result.add(','.join(val))\n            if val[0] in seen:\n                # print(seen)\n                for x in seen[val[0]]:\n                    comp = transactions[x]\n                    # print(comp)\n                    if abs(int(comp[1])-int(val[1]))<=60 and comp[3] != val[3]:\n                        result.add(','.join(val))\n                        result.add(','.join(comp))\n            seen[val[0]].append(i)\n            # while seen[val[0]]:\n        return result", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        mp = {}\n        res = set()\n        for string in transactions:\n            l = string.split(',')\n            person = l[0]\n            time = l[1]\n            amount = l[2]\n            city = l[3]\n            \n            if int(amount)>1000:\n                res.add(string)\n                #continue\n                \n            if person in mp:\n                #print(mp[person])\n                for val in mp[person]:\n                    time_1 = val[0]\n                    if abs(int(time)-int(time_1))<=60 and val[2]!=city:\n                        print(abs(int(time)-int(time_1)))\n                        str1 = person+\\\",\\\"+time_1+\\\",\\\"+val[1]+\\\",\\\"+val[2]\n                        res.add(str1)\n                        res.add(string)\n            if person not in mp:\n                mp[person] = [[time,amount,city]]\n            else:\n                mp[person].append([time,amount,city])\n            \n        \n        r = [x for x in res]\n        return r", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        res = set()\n        past_ts = {}\n        for t in transactions:\n            vals = t.split(\\\",\\\")\n            name = vals[0]\n            time = int(vals[1])\n            amount = int(vals[2])\n            city = vals[3]\n            \n            if name in past_ts:\n                pre_trs = past_ts[name]\n                for pre_r in pre_trs:\n                    pre_t = pre_r.split(\\\",\\\")\n                    pre_time = int(pre_t[1])\n                    pre_city = pre_t[3]\n                    if abs(time - pre_time) <= 60 and city != pre_city:\n                        res.add(t)\n                        res.add(pre_r)\n            else:\n                past_ts[name] = []\n            if amount > 1000:\n                if t not in res:\n                    res.add(t)\n                    \n            past_ts[name].append(t)\n        return res", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        invalid_trans = set()\n        d = {}\n        for transaction in transactions:\n            t_list = transaction.split(',')\n            person, time, amount, loc = t_list[0], int(t_list[1]), int(t_list[2]), t_list[3]\n            \n            if amount > 1000:\n                invalid_trans.add(transaction)\n            \n            if person not in d:\n                d[person] = []\n            else:\n                for t in d[person]:\n                    old_t = t.split(',')\n                    old_time, old_loc = int(old_t[1]), old_t[3]\n                    \n                    if abs(old_time-time)<=60 and old_loc != loc:\n                        invalid_trans.add(transaction)\n                        invalid_trans.add(t)\n            \n            d[person].append(transaction)\n            \n        \n        return list(invalid_trans)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        if not transactions:\n            return []\n        invalid = set()\n        past_tran = {}\n        for transaction in transactions:\n            tran = transaction.split(',')\n            tran[2]=float(tran[2])\n            tran[1]=float(tran[1])\n            if tran[2]>1000:\n                invalid.add(transaction)\n            if tran[0] in past_tran:\n                for other_transaction in past_tran[tran[0]]:\n                    other_tran = other_transaction.split(',')\n                    other_tran[1]=float(other_tran[1])\n                    if other_tran[3]!=tran[3] and abs(tran[1]-other_tran[1])<=60:\n                        invalid.add(transaction)   \n                        invalid.add(other_transaction)\n                past_tran[tran[0]].append(transaction)\n                                                    \n            else:\n                past_tran[tran[0]]=[transaction]\n        return list(invalid)\n", "class Transaction:  \n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n        \n    def __str__(self):\n        return f'{self.name},{self.time},{self.amount},{self.city}'\n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        transactions = [Transaction(*t.split(',')) for t in transactions]\n        transactions.sort(key = lambda x: x.time)\n        nameMap = collections.defaultdict(list)\n        for i, t in enumerate(transactions):\n            nameMap[t.name].append(i)\n        invalid = []\n        for name, idxLst in nameMap.items():\n            left = 0\n            right = 0\n            for idx in idxLst:\n                t = transactions[idx]\n                if t.amount > 1000:\n                    invalid.append(str(t))\n                    continue\n                while left < len(idxLst) and transactions[idxLst[left]].time < t.time-60:\n                    left += 1\n                while right < len(idxLst) and transactions[idxLst[right]].time <= t.time+60:\n                    right += 1\n                for i in range(left, right):\n                    if t.city != transactions[idxLst[i]].city:\n                        invalid.append(str(t))\n                        break\n        return invalid", "import collections\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        mapNameToTrans = collections.defaultdict(list)\n        \n        for t in transactions:\n            name, time, amount, city = t.split(',')\n            did_add = False\n            if int(amount) > 1000:\n                invalid.append(t)\n                did_add = True\n            for past in mapNameToTrans[name]:\n                past_name, past_time, past_amount, past_city = past[0].split(',')\n                if past_city != city and abs(int(past_time) - int(time)) <= 60:\n                    if not did_add:\n                        invalid.append(t)\n                        did_add = True\n                    if not past[1]:\n                        past[1] = True\n                        invalid.append(past[0])\n            mapNameToTrans[name].append([t, did_add])\n        return invalid\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        res=[]\n        for i,t1 in enumerate(transactions):\n            item=t1.split(',')\n            val=int(item[2])\n            minute=int(item[1])\n            name=item[0]\n            city=item[-1]\n            if(val>1000):\n                res.append(t1)\n                continue\n            for j,t2 in enumerate(transactions):\n                if(i!=j):\n                    item=t2.split(',')\n                    val2=int(item[2])\n                    minute2=int(item[1])\n                    name2=item[0]\n                    city2=item[-1]\n                    if(abs(minute2-minute)<=60 and name2==name and city2!=city):\n                        res.append(t1)\n                        break\n           \n        return res", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        dic = defaultdict(list)\n        ans = set()\n        for trans in transactions:\n            name, time, amt, loc = trans.split(',')\n            if int(amt) > 1000:\n                ans.add(trans)\n            for trans2 in dic[name]:\n                other = trans2.split(',')\n                if other[3] != loc and abs(int(other[1]) - int(time)) <= 60:\n                    ans.add(trans)\n                    ans.add(trans2)\n            dic[name].append(trans)\n        \n        return ans", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        if not transactions:\n            return []\n        invalid = set()\n        past_tran = {}\n        for transaction in transactions:\n            tran = transaction.split(',')\n            tran[2]=float(tran[2])\n            tran[1]=float(tran[1])\n            if tran[2]>1000:\n                invalid.add(transaction)\n                # past_tran[tran[0]]=[transaction]\n            if tran[0] in past_tran:\n                for other_transaction in past_tran[tran[0]]:\n                    other_tran = other_transaction.split(',')\n                    other_tran[1]=float(other_tran[1])\n                    if other_tran[3]!=tran[3] and abs(tran[1]-other_tran[1])<=60:\n                        invalid.add(transaction)   \n                        invalid.add(other_transaction)\n                past_tran[tran[0]].append(transaction)                                \n            else:\n                past_tran[tran[0]]=[transaction]\n        return list(invalid)\n\n    \n", "from collections import defaultdict\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        # occurs within 60 mins of another transaction,\n        # does the previous transaction need to be valid? -> No\n        invalid = set()\n        records = defaultdict(list)\n        for transaction in transactions:\n            name, time, value, city = transaction.split(\\\",\\\")\n            if int(value) > 1000:\n                invalid.add(transaction)\n            if name in records:\n                for record in records[name]:\n                    last_name, last_time, last_value, last_city = record.split(\\\",\\\")\n                    if abs(int(time) - int(last_time)) <= 60 and city != last_city:\n                        invalid.add(record)\n                        invalid.add(transaction)\n            records[name].append(transaction)\n        return invalid\n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        # first check : if amount > 1000 invalid\n        # second check : else:\n        #       if name equals with another transaction : if time_this - time_that <60 and city not equal both invalid\n        #                                                 if time_this - time_that <60 and city equal both valid\n        \n        tr = {}\n        invalids = set()\n        \n        for t in transactions:\n            tl = t.split(',')\n            \n            if tl[0] not in tr:                 \n                tr[tl[0]] = [t]\n                if int(tl[2]) > 1000:  # amount > 1000\n                    invalids.add(t)                \n                    \n            else:   # name equal                \n                if int(tl[2]) > 1000:  # amount > 1000\n                    invalids.add(t)                   \n                tmp = tr[tl[0]]  # amount < 1000                 \n                for temp in tmp:                        \n                    tempo = temp.split(',')                        \n                    if tempo[3] != tl[3]: # city not equal\n                        if abs(int(tempo[1])- int(tl[1])) <= 60:  # less than 60 min\n                            invalids.add(t) \n                            invalids.add(temp)\n                                  \n                tr[tl[0]].append(t)               \n        return invalids\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        if not transactions:\n            return []\n        \n        res = set()\n        n = len(transactions)\n        transactions.sort()\n       \n        for i in range(n):\n            n1, t1, a1, d1 = transactions[i].split(',')\n            if int(a1) > 1000:\n                res.add(transactions[i])\n            for j in range(i+1, n):\n                n0, t0, a0, d0 = transactions[j].split(',')\n                if n0 == n1:\n                    if d1 != d0 and abs(int(t1)-int(t0)) <= 60:\n                        res.add(transactions[i])\n                        res.add(transactions[j])\n                else:\n                    break\n        \n        ans = []\n        for t in res:\n            ans.append(t)\n        print(res, ans)\n        return ans", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        output = []\n        names = {}\n        inOutput = set()\n        \n        for idx, trans in enumerate(transactions):\n            curr = trans.split(\\\",\\\")\n            print(curr)\n            \n            if curr[0] not in names:\n                names[curr[0]] = [idx]\n            else:\n                for transIdx in names[curr[0]]:\n                    personTrans = transactions[transIdx].split(\\\",\\\")\n                    if curr[3] != personTrans[3] and abs(int(curr[1]) - int(personTrans[1])) <= 60:\n                        if idx not in inOutput:\n                            output.append(trans)\n                            inOutput.add(idx)\n                        if transIdx not in inOutput:\n                            output.append(transactions[transIdx])\n                            inOutput.add(transIdx)\n                names[curr[0]].append(idx)\n                \n            if int(curr[2]) > 1000 and idx not in inOutput:\n                output.append(trans)\n                inOutput.add(idx)\n        \n        return output", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        from collections import defaultdict\n        newd =defaultdict(list)\n        result =set()\n        for j in range(len(transactions)):\n            details = transactions[j].split(\\\",\\\")\n            \n            if int(details[2])>1000:\n                result.add(transactions[j])\n                \n            if newd[details[0]]:\n                \n                for tran in newd[details[0]]:\n                    name, time,amount,city = tuple(tran.split(\\\",\\\"))\n                    if abs(int(details[1])-int(time))<=60 and details[3]!=city:\n                        result.add(transactions[j])\n                        result.add(tran)\n            \n            \n            newd[details[0]].append(transactions[j])\n\n        \n        return result", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = set()\n        trans_list = [[x for x in trans.split(\\\",\\\")] for trans in transactions]\n        transactions_by_name = collections.defaultdict(list)\n        for x in trans_list:\n            transactions_by_name[x[0]].append(x[1:])\n        res = []\n        for name, values_list in transactions_by_name.items():\n            for values in values_list:\n                time, amount, city = values\n                if int(amount) > 1000:\n                    res.append(','.join([name, time, amount, city]))\n                else:\n                    for other_values in values_list:\n                        otime, _, ocity = other_values\n                        if ocity != city and abs(int(time) - int(otime)) <= 60:\n                            res.append(','.join([name, time, amount, city]))\n                            break\n        return res\n                ", "class Solution:\n    def invalidTransactions(self, transactions):\n        \n        transactions.sort()\n        n = len(transactions)\n        \n        result = set()\n        for i in range(n):\n            i_name, i_time, i_amount, i_city = transactions[i].split(',')\n            \n            if int(i_amount) > 1000:\n                result.add(transactions[i])\n                \n            for j in range(i + 1, n):\n                j_name, j_time, j_amount, j_city = transactions[j].split(',')\n            \n                if j_name != i_name:\n                    break\n                    \n                if i_city != j_city and abs(int(i_time) - int(j_time)) <= 60:\n                    result.add(transactions[i])\n                    result.add(transactions[j])\n                    \n        return list(result)", "from collections import defaultdict\n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        transactions.sort(key=lambda t: int(t.split(',')[1]))\n        recent = defaultdict(lambda: [])\n        result = set()\n        for transaction in transactions:\n            name, time, amount, city = self.parse(transaction)\n            if amount > 1000:\n                result |= {transaction}\n            if name in recent:\n                for recent_transaction in recent[name]:\n                    _, recent_time, _, recent_city = self.parse(recent_transaction)\n                    if time - recent_time <= 60 and recent_city != city: \n                        result |=  {recent_transaction, transaction}\n            recent[name] += [transaction]\n        return result\n            \n    def parse(self, transaction):\n        name, time, amount, city = transaction.split(',')\n        return name, int(time), int(amount), city\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        trans = []\n        for k in range(len(transactions)):\n            trans.append(tuple(transactions[k].split(',')))\n        trans.sort(key = lambda x: x[0])\n        \n        print(trans)\n        \n        store, i = set(), 0\n        while i < len(trans):\n            j = i+1\n            while j < len(trans) and trans[j][0] == trans[i][0]:\n                if abs(int(trans[i][1]) - int(trans[j][1])) <= 60:\n                    if trans[i][3] != trans[j][3]:\n                        store.add(\\\",\\\".join(trans[i]))\n                        store.add(\\\",\\\".join(trans[j]))\n                j+=1\n            if int(trans[i][2]) > 1000: store.add(\\\",\\\".join(trans[i]))\n            i+=1\n        return list(store)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n#         transaction invalid -> > $1000 or within 60 minutes and same name and diff city\n        \n#         loop thru the list \n#         for each item, split the string by comma\n#         set dictionary with name for key\n#         list of tuple for value with time, cost, location\n        \n#         loop thru dictionary\n#         sort the list by time / 0 index \n            \n        clean = {}\n        results = set()\n        \n        for transaction in transactions:\n            item = transaction.split(',')\n            name, time, money, location = item\n            if name not in clean:\n                clean[name] = [(int(time), int(money), location)]\n            else:\n                clean[name].append((int(time), int(money), location))\n        \n        for person, info in clean.items():\n            sorted_items = sorted(info)\n            for idx in range(len(sorted_items)):\n                for idx_2 in range(len(sorted_items)):\n                    if (abs(sorted_items[idx_2][0] - sorted_items[idx][0]) <= 60) and (sorted_items[idx_2][2] != sorted_items[idx][2]) and (idx != idx_2): \n                        invalid_1 = [person, str(sorted_items[idx][0]), str(sorted_items[idx][1]), sorted_items[idx][2]]\n                        invalid_2 = [person, str(sorted_items[idx_2][0]), str(sorted_items[idx_2][1]), sorted_items[idx_2][2]]\n                        results.add(\\\",\\\".join(invalid_1))\n                        results.add(\\\",\\\".join(invalid_2))\n                \n                cost = sorted_items[idx][1]\n                if cost > 1000:\n                    invalid = [person, str(sorted_items[idx][0]), str(sorted_items[idx][1]), sorted_items[idx][2]]\n                    results.add(\\\",\\\".join(invalid))\n        \n        return list(results)\n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        if not transactions:    return []\n        # transactions = sorted(transactions)\n        # print(transactions)\n        res=set()\n        names = defaultdict(list)\n        time,amt,city=[],[],[]\n        for i,ele in enumerate(transactions):\n            s = ele.split(',')\n            names[s[0]] += [(int(s[1]), int(s[2]), s[3], s[0])]\n        for k,v in list(names.items()):\n            v = sorted(v)\n            for i,ele in enumerate(v):\n                b,c,d,a = ele\n                for j,ele1 in enumerate(v):\n                    if i != j:\n                        f,g,h,e = ele1\n                        if (abs(b-f) <= 60) and (a == e) and (d != h):   \n                            res.add(a+','+str(b)+','+str(c)+','+d)\n                            res.add(e+','+str(f)+','+str(g)+','+h)\n                if c > 1000:\n                    res.add(a+','+str(b)+','+str(c)+','+d)\n                        \n                # if i>=1:\n                #     f,g,h,e = v[i-1]\n                #     if (abs(b-f) <= 60) and (a == e) and (d != h):   \n                #         res.add(a+','+str(b)+','+str(c)+','+d)\n                #         res.add(e+','+str(f)+','+str(g)+','+h)\n                # if c > 1000:\n                #     res.add(a+','+str(b)+','+str(c)+','+d)\n                    \n        return res\n\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ret = set()\n        name = []\n        time = []\n        amount = []\n        city = []\n        for trans in transactions:\n            trans = trans.split(',')\n            name.append(trans[0])\n            time.append(int(trans[1]))\n            amount.append(int(trans[2]))\n            city.append(trans[3])\n        for i in range(len(transactions)):\n            if(amount[i] > 1000):\n                ret.add(transactions[i])\n            for j in range(i+1, len(transactions)):\n                if(name[i] == name[j] and abs(time[i] - time[j]) <= 60 and city[i] != city[j]):\n                    ret.add(transactions[i])\n                    ret.add(transactions[j])\n                    \n                      \n            \n        return ret\n\n        \n            \n            \n", "class Transaction:\n    def __init__(self, transaction):\n        trans_details = transaction.split(\\\",\\\")\n        self.name = trans_details[0]\n        self.time = int(trans_details[1])\n        self.amount = int(trans_details[2])\n        self.city = trans_details[3]\n        \n    def findAnotherTrans(self, transactions):\n        for transaction in transactions:\n            curTransact = Transaction(transaction)\n            if(curTransact.name==self.name and curTransact.city!=self.city and abs(curTransact.time - self.time)<=60):\n                return True\n        return False\n    \n    \nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        final_ans = []\n        for trans in transactions:\n            curTransact = Transaction(trans)\n            if(curTransact.amount>1000):\n                final_ans.append(trans)\n            else:\n                if(curTransact.findAnotherTrans(transactions)):\n                    final_ans.append(trans)\n                \n        return final_ans\n    \n            \n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        result = []\n        \n        stock = {}\n        for trans in transactions:\n            name, time, amount, city = trans.split(\\\",\\\")\n            time = int(time)\n            flg = False\n            if int(amount)>=1000:\n                flg = True\n            if name in stock:\n                for btime, bcity, btrans in stock[name]:\n                    if (btime+60>=time and time>=btime-60)and bcity!=city:\n                        if btrans not in result:\n                            result.append(btrans)\n                        flg = True\n            if flg:\n                result.append(trans)\n                \n            if name not in stock:\n                stock[name] = [(time, city, trans)]\n            else:\n                stock[name].append((time, city, trans))\n        return result", "class Solution:\n    # > 1000\n    # same name, different city, <= 60 min\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n#         loop through transactions \n#             if amount is greater >= 1000 add it to invalid set\n#             have another loop, check every other transactions for invalid time\n         \n        # { invalidtransaction}\n        # {\n        #     alice: [\\\"transaction\\\",\\\"transaction\\\"]\n        #     bob: [\\\"transaction\\\"]\n        # }\n        \n        userTransactions = collections.defaultdict(list)\n        invalidTransactions = set()\n        \n        for transaction in transactions:\n            [name,time,amount,city] = transaction.split(\\\",\\\")\n            \n            if int(amount) > 1000: invalidTransactions.add(transaction)\n            userTransactions[name].append(transaction)\n            \n        for name in userTransactions:\n            userTrans = userTransactions[name]\n            \n            for i in range(len(userTrans)-1):\n                for j in range(i+1,len(userTrans)):\n                    [_,time,_,city] = userTrans[i].split(\\\",\\\")\n                    [_,time2,_,city2] = userTrans[j].split(\\\",\\\")\n                    \n                    if abs(int(time)-int(time2)) <= 60 and city != city2:\n                        invalidTransactions.add(userTrans[i])\n                        invalidTransactions.add(userTrans[j])\n                    \n        return list(invalidTransactions)\n            \n                \n        \n        \n        ", "class Solution:\n    # 0) split each element of transactions on comma\n    # 1) iterate through transactions and if amount > 1000 add to ans array and transactions.pop(i)\n    # 2) create dict {name:[...(time, city)...]}    # sort by time\n    # 3) iterate through transactions and if within 60 minutes and diff city then add to ans array\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        # 0)\n        transactions = [string.split(',') for string in transactions]\n        \n        # 1)\n        ans, length = set(), len(transactions)\n        for i in range(length):\n            if int(transactions[i][2]) > 1000:\n                ans.add(','.join(transactions[i]))\n        \n        # 2)\n        dct = {}\n        for i in range(length):\n            name, time, city = transactions[i][0], transactions[i][1], transactions[i][-1]\n            if name in dct:\n                dct[name].append( (time, city) )\n                dct[name].sort()\n            else:\n                dct[name] = [(time, city)]\n        \n        # 3)\n        for name,time,amt,city in transactions:\n            for tme,cty in dct[name]:\n                if abs(int(time)-int(tme)) <= 60 and city != cty:\n                    ans.add(','.join([name,time,amt,city]))\n        return list(ans)\n        \n        \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        # time order?\n        # 30 60 90 how to assess?\n        \n        realTransactions = collections.defaultdict(list)\n        for each in transactions:\n            each = each.split(',')\n            realTransactions[each[0]].append(tuple(each[1:]))\n        \n        res = []\n        for name in realTransactions.keys(): # O(n) time\n            realTransactions[name].sort(key = lambda x: int(x[0]))\n            for i, trans in enumerate(realTransactions[name]):\n                left = right = i\n                time, amt, loc = trans\n                if int(amt) > 1000:\n                    res.append(\\\"{},{},{},{}\\\".format(name, time, amt, loc))\n                    continue\n                while left - 1 >= 0 and int(realTransactions[name][left - 1][0]) + 60 >= int(time):\n                    left -= 1\n                while right + 1 < len(realTransactions[name]) and int(realTransactions[name][right + 1][0]) - 60 <= int(time):\n                    right += 1\n                #print(left, right)\n                for idx in range(left, right + 1):\n                    if realTransactions[name][idx][2] != loc:\n                        res.append(\\\"{},{},{},{}\\\".format(name, realTransactions[name][i][0], realTransactions[name][i][1], realTransactions[name][i][2]))\n                        break\n\n        return res\n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ans = []\n        length = len(transactions)\n        if not length: return ans\n        name,time,money,city = [],[],[],[]\n        add = [1]*length\n        for trans in transactions:\n            tran = trans.split(',')\n            name.append(tran[0])\n            time.append(eval(tran[1]))\n            money.append(eval(tran[2]))\n            city.append(tran[3])\n        for i in range(length):\n            if money[i] > 1000:\n                add[i] = False\n            for j in range(i+1,length):\n                if name[i] == name[j] and abs(time[i]-time[j])<= 60 and city[i]!=city[j]:\n                    add[i] = False\n                    add[j] = False\n        for ind,val in enumerate(add):\n            if not val:\n                ans.append(transactions[ind])\n        return ans", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        if not transactions:\n            return []\n        l=[i.split(\\\",\\\") for i in transactions]\n        n=len(transactions)\n        valid=[True]*n\n        for i in range(n):\n            if int(l[i][2])>1000:\n                valid[i]=False\n        for i in range(n):\n            for j in range(i+1,n):\n                if valid[i] or valid[j]:\n                    name1,time1,city1=l[i][0],l[i][1],l[i][3]\n                    name2,time2,city2=l[j][0],l[j][1],l[j][3]\n                    if name1==name2 and city1!=city2 and abs(int(time1)-int(time2))<=60:\n                        valid[i],valid[j]=False,False\n        return [transactions[i] for i in range(n) if not valid[i]]", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ans = []\n        length = len(transactions)\n        if not length: return ans\n        name,time,money,city = [],[],[],[]\n        add = [1]*length\n        for trans in transactions:\n            tran = trans.split(',')\n            name.append(tran[0])\n            time.append(eval(tran[1]))\n            money.append(eval(tran[2]))\n            city.append(tran[3])\n        for i in range(length):\n            if money[i] > 1000:\n                add[i] = False\n            for j in range(i+1,length):\n                if name[i] == name[j] and abs(time[i]-time[j])<= 60 and city[i]!=city[j]:\n                    add[i] = False\n                    add[j] = False\n        for ind,val in enumerate(add):\n            if not val:\n                ans.append(transactions[ind])\n        return ans           \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        t = transactions.copy()\n        t.sort()\n        invalid = set()\n        name = \\\"\\\"\n        times = {}\n        for transaction in t:\n            vals = transaction.split(',')\n            if int(vals[2]) > 1000:\n                invalid.add(transaction)\n            if vals[0] != name:\n                name = vals[0]\n                times[name] = list()\n            else:\n                for seen in times[name]:\n                    vs = seen.split(',')\n                    if vs[3] != vals[3] and abs(int(vs[1]) - int(vals[1])) <= 60:\n                        invalid.add(seen)\n                        invalid.add(transaction)\n            times[name].append(transaction)\n        \n        return list(invalid)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        def reunite(temp):\n            return temp[0] + \\\",\\\" + str(temp[1]) + \\\",\\\" + str(temp[2]) + \\\",\\\" + temp[3]\n        new_transactions = []\n        for i in range(len(transactions)):\n            name, time, amount, city = transactions[i].split(\\\",\\\")\n            new_transactions.append([name,int(time),int(amount),city])\n            \n        new_transactions.sort(key = lambda x: x[1])\n        result = []\n        for i in range(len(new_transactions)):\n            if int(new_transactions[i][2]) > 1000:\n                result.append(reunite(new_transactions[i]))\n            \n            for j in range(i,len(new_transactions)):\n                if int(new_transactions[j][1]) - int(new_transactions[i][1]) <= 60 and new_transactions[j][3] != new_transactions[i][3] and new_transactions[j][0] == new_transactions[i][0]:\n                    result.append(reunite(new_transactions[j]))\n                    result.append(reunite(new_transactions[i]))\n                elif int(new_transactions[j][1]) - int(new_transactions[i][1]) > 60:\n                    break\n        result.sort()\n        new_result = [result[0]]\n        for i in range(len(result)-1):\n            if result[i] != result[i+1]:\n                new_result.append(result[i+1])\n                #print(new_result)\n                \n                \n        return new_result\n                \n            \n        ", "from collections import defaultdict\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        dic = defaultdict(list)\n        res = set()\n        for i in transactions: \n            i = i.split(',')\n            if int(i[2]) > 1000:\n                res.add(','.join(i))\n            if i[0] in dic: #we only care about time and place\n                    for j in dic[i[0]]:\n                        j = j.split(',')\n                        if i[3] != j[3] and abs(int(i[1]) - int(j[1])) <= 60:\n                            res.add(','.join(i))\n                            res.add(','.join(j))\n            dic[i[0]].append(','.join(i))\n        print(dic)\n        return list(res)\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        tf_arr = [True for _ in range(len(transactions))]\n        new_transactions = []\n        for x in transactions:\n            x = x.split(',')\n            x[1] = int(x[1])\n            x[2] = int(x[2])  \n            new_transactions.append(x)\n        def check(transaction, i, arr):\n            if transaction[2]>1000:\n                tf_arr[i] = False\n            for j,e in enumerate(arr[i+1:]):\n                if transaction[0] == e[0] and  transaction[3] != e[3] and abs(transaction[1] - e[1])<=60: \n                    tf_arr[i] = False\n                    tf_arr[i+j+1] = False\n        for i,t in enumerate(new_transactions):\n            check(t,i,new_transactions)\n        output = []\n        for i,truth in enumerate(tf_arr):\n            if not truth:\n                output.append(transactions[i])\n        return output", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ans=[]\n        n=len(transactions)\n        rank=[True]*n\n        name=[]\n        time=[]\n        amount=[]\n        city=[]\n        for t in transactions:\n            num=t.split(',')\n            name.append(num[0])\n            time.append(num[1])\n            amount.append(num[2])\n            city.append(num[3])\n        \n        for i in range(n):\n            if int(amount[i])>1000:\n                rank[i]=False\n            for j in  range(i+1,n):\n                if name[i]==name[j] and abs(int(time[i])-int(time[j]))<=60 and city[i]!=city[j]:\n                    rank[i]=False\n                    rank[j]=False\n        for t in range(n):\n            if not rank[t]:\n                ans.append(transactions[t])\n        \n        return ans\n        \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \\\"\\\"\\\"\n        There are two ways for transaction to be invalid.\n        1. Exceeds 1000. -> iterate and put each into a bin\n        2. Same name in a different city within a 60 second window\n        \\\"\\\"\\\"\n        invalid_transactions = set()\n        trans_by_name = {}\n        # For the trans_by_name, add by name, then by city\n        # As a new transaction arrives, check to see if the difference \n        #   between it and the transactions under a different name which \n        #   do not have the same city name. If not, add it to the table.\n        #   If so, also add it to the invalid_transactions list\n        for trans in transactions:\n            tname, tmin, tamt, tcity = trans.split(',')\n            if int(tamt) > 1000:\n                invalid_transactions.add(trans)\n            if tname in trans_by_name:\n                for city, time, amt in trans_by_name[tname]:\n                    if tcity != city and abs(int(tmin) - int(time)) <= 60:\n                        print(f'{tname} {time} {city} {amt}')\n                        invalid_transactions.add(trans)\n                        invalid_transactions.add(f'{tname},{time},{amt},{city}')\n            if tname not in trans_by_name:\n                trans_by_name[tname] = set()\n            trans_by_name[tname].add((tcity, tmin, tamt))\n        return invalid_transactions\n        ", "class Solution:\n    \n    \n    \n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n#         def asPerTime(string):\n#             return string.split(',')[1]\n            \n        \n#         transactions.sort(key=asPerTime)\n        \n        #dictionary\n        personDict = dict()\n        \n        #outputList\n        outSet = set()\n        \n        for transaction in transactions:\n            name, time, amount, city = transaction.split(',')\n            if int(amount) > 1000:\n                outSet.add(transaction)\n                \n            if name in personDict:\n                cityDict = personDict[name]\n                cityDict[city].append((time, amount))\n                \n                for key in cityDict:\n                    if key != city:\n                        for pair in cityDict[key]:\n                            prevTime, prevAmount = pair\n                            timeDiff = abs(int(time) - int(prevTime)) \n                            if timeDiff <= 60:\n                                outSet.add(transaction)\n                                outSet.add(','.join([name, prevTime, prevAmount, key]))\n            \n            \n            else:\n                personDict[name] = defaultdict(list)\n                personDict[name][city].append((time, amount)) \n        \n        \n        return outSet\n        \n        \n        '''\n        sort the transaction list as per the time\n        \n        a dictionary where key is the name of the person and the the value is a dictionary where the key is the city and the value is time and amount        \n        \n        \n        \n        iterate over the transactions:\n            if the amount is greater than 1000:\n                add it to the list\n            \n            if that same person has done a transaction before\n                are the cities different:\n                    get the time of the latest transaction\n                    if difference is <60:\n                        add the latest transaction as well as this transaction\n                        update the latest transaction with this transaction info\n                        continue\n                        \n                 \n        '''\n        \n        \n", "class Transaction:\n    \n    def __init__(self, s):\n        params = s.split(',')\n        \n        self.name, self.time, self.amount, self.city = params[0], int(params[1]), int(params[2]), params[3]\n        \n    def __str__(self):\n        return ','.join([self.name, str(self.time), str(self.amount), self.city])\n    \n    \n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        transactions = [Transaction(t) for t in transactions]\n        \n        transactions.sort(key = lambda t: t.time)\n        \n        #map name to transaction idx\n        trans_idxs = defaultdict(list)\n        \n        for i, t in enumerate(transactions):\n            trans_idxs[t.name].append(i)\n            \n        invalid = []\n        \n        for name, idxs in list(trans_idxs.items()):\n            left = right = 0\n            \n            for trans_idx in idxs:\n                t = transactions[trans_idx]\n                if t.amount > 1000:\n                    invalid.append(str(t))\n                    continue\n                \n                while left <= len(idxs) - 2 and transactions[idxs[left]].time < t.time - 60:\n                    left += 1\n                    \n                right = left\n                while right <= len(idxs) - 2 and transactions[idxs[right+1]].time < t.time + 60:\n                    right += 1\n                \n                for j in range(left, right+1):\n                    if transactions[idxs[j]].city != t.city:\n                        invalid.append(str(t))\n                        break\n                        \n        return invalid\n                    \n                \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        if not transactions:    return []\n        res=set()\n        names = defaultdict(list)\n        time,amt,city=[],[],[]\n        for i,ele in enumerate(transactions):\n            s = ele.split(',')\n            names[s[0]] += [(int(s[1]), int(s[2]), s[3], s[0])]\n            \n        for k,v in list(names.items()):\n\n            for i,ele in enumerate(v):\n                b,c,d,a = ele\n                for j in range(0, len(v)):\n                    if i != j:\n                        f,g,h,e = v[j]\n                        if (abs(b-f) <= 60) and (a == e) and (d != h):   \n                            res.add(a+','+str(b)+','+str(c)+','+d)\n                            res.add(e+','+str(f)+','+str(g)+','+h)\n                    if c > 1000:\n                        res.add(a+','+str(b)+','+str(c)+','+d)\n                    \n        return res\n\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        if not transactions:    return []\n        res=set()\n        names = defaultdict(list)\n        time,amt,city=[],[],[]\n        for i,ele in enumerate(transactions):\n            s = ele.split(',')\n            names[s[0]] += [(int(s[1]), int(s[2]), s[3], s[0])]\n            \n        for k,v in list(names.items()):\n\n            for i,ele in enumerate(v):\n                b,c,d,a = ele\n                for j in range(0, len(v)):\n                    if i != j:\n                        f,g,h,e = v[j]\n                        if (abs(b-f) <= 60) and (a == e) and (d != h):   \n                            res.add(a+','+str(b)+','+str(c)+','+d)\n                            res.add(e+','+str(f)+','+str(g)+','+h)\n                    if c > 1000:\n                        res.add(a+','+str(b)+','+str(c)+','+d)\n                        \n                # if i>=1:\n                #     e,f,g,h = v[i-1].split(',')\n                #     if (abs(int(b)-int(f)) <= 60) and (a == e) and (d != h):   \n                #         res.add(a+','+str(b)+','+str(c)+','+d)\n                #         res.add(e+','+str(f)+','+str(g)+','+h)\n                # if int(c) > 1000:\n                #     res.add(a+','+str(b)+','+str(c)+','+d)\n                    \n        return res\n\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ans = []\n        length = len(transactions)\n        if not length: return ans\n        name,time,money,city = [],[],[],[]\n        add = [1]*length\n        for trans in transactions:\n            tran = trans.split(',')\n            name.append(tran[0])\n            time.append(eval(tran[1]))\n            money.append(eval(tran[2]))\n            city.append(tran[3])\n        for i in range(length):\n            if money[i] > 1000:\n                add[i] = False\n            for j in range(i+1,length):\n                if name[i] == name[j] and abs(time[i]-time[j])<= 60 and city[i]!=city[j]:\n                    add[i] = False\n                    add[j] = False\n        for ind,val in enumerate(add):\n            if not val:\n                ans.append(transactions[ind])\n        \n        \n        return ans", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ans = []\n        length = len(transactions)\n        if not length: return ans\n        name,time,money,city = [],[],[],[]\n        add = [1]*length\n        for trans in transactions:\n            tran = trans.split(',')\n            name.append(tran[0])\n            time.append(eval(tran[1]))\n            money.append(eval(tran[2]))\n            city.append(tran[3])\n        for i in range(length):\n            if money[i] > 1000:\n                add[i] = False\n            for j in range(i+1,length):\n                if name[i] == name[j] and abs(time[i]-time[j])<= 60 and city[i]!=city[j]:\n                    add[i] = False\n                    add[j] = False\n        for ind,val in enumerate(add):\n            if not val:\n                ans.append(transactions[ind])\n                \n                \n        return ans", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        data_by_time = {}\n        for data in transactions:\n            orig_data = data\n            data = data.split(\\\",\\\")\n\n            transaction = {\\\"name\\\": data[0], \\\"amount\\\": int(data[2]), \\\"city\\\": data[3], \\\"orig\\\": orig_data}\n            if int(data[1]) not in data_by_time:\n                data_by_time[int(data[1])] = [transaction]\n            else:\n                data_by_time[int(data[1])].append(transaction)\n        result = set()\n        times = sorted(data_by_time.keys())\n        for time in times:\n            for trans in data_by_time[time]:\n                if trans[\\\"amount\\\"] > 1000:\n                    result.add(trans[\\\"orig\\\"])\n    \n        for (t_trans, trans_list) in data_by_time.items():\n            for trans in trans_list:\n                for time in times:\n                    if abs(t_trans - time) <= 60:\n                        for other_trans in data_by_time[time]:\n                            if other_trans[\\\"name\\\"] == trans[\\\"name\\\"] and other_trans[\\\"city\\\"] != trans[\\\"city\\\"]:\n                                result.add(other_trans[\\\"orig\\\"])\n                                #result.add(trans[\\\"orig\\\"])\n                    \n        return list(result)\n                    \n        \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        data_by_time = {}\n        for data in transactions:\n            orig_data = data\n            data = data.split(\\\",\\\")\n\n            transaction = {\\\"name\\\": data[0], \\\"amount\\\": int(data[2]), \\\"city\\\": data[3], \\\"orig\\\": orig_data}\n            if int(data[1]) not in data_by_time:\n                data_by_time[int(data[1])] = [transaction]\n            else:\n                data_by_time[int(data[1])].append(transaction)\n        result = set()\n        times = sorted(data_by_time.keys())\n        for time in times:\n            for trans in data_by_time[time]:\n                if trans[\\\"amount\\\"] > 1000:\n                    result.add(trans[\\\"orig\\\"])\n    \n        for (t_trans, trans_list) in data_by_time.items():\n            for trans in trans_list:\n                for time in times:\n                    if abs(t_trans - time) <= 60:\n                        for other_trans in data_by_time[time]:\n                            if other_trans[\\\"name\\\"] == trans[\\\"name\\\"] and other_trans[\\\"city\\\"] != trans[\\\"city\\\"]:\n                                result.add(other_trans[\\\"orig\\\"])\n                                result.add(trans[\\\"orig\\\"])\n                    \n        #for i in range(len(times) - 1):\n        #    if times[i+1] - times[i] <= 60:\n        #        seen_names = {}\n        #        for transaction in data_by_time[times[i]]:\n        #            seen_names[transaction[\\\"name\\\"]] = transaction\n        #        for transaction in data_by_time[times[i+1]]:\n        #            if transaction[\\\"name\\\"] in seen_names:\n        #                if transaction[\\\"city\\\"] != seen_names[transaction[\\\"name\\\"]][\\\"city\\\"]:\n        #                    result.add(transaction[\\\"orig\\\"])\n        #                    result.add(seen_names[transaction[\\\"name\\\"]][\\\"orig\\\"])\n        #                    #result.update([seen_names[x][\\\"orig\\\"] for x in seen_names[transaction[\\\"name\\\"]]])\n        return list(result)\n                    \n        \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        data_by_time = {}\n        for data in transactions:\n            orig_data = data\n            data = data.split(\\\",\\\")\n\n            transaction = {\\\"name\\\": data[0], \\\"amount\\\": int(data[2]), \\\"city\\\": data[3], \\\"orig\\\": orig_data}\n            if int(data[1]) not in data_by_time:\n                data_by_time[int(data[1])] = [transaction]\n            else:\n                data_by_time[int(data[1])].append(transaction)\n        result = set()\n        times = sorted(data_by_time.keys())\n        for time in times:\n            for trans in data_by_time[time]:\n                if trans[\\\"amount\\\"] > 1000:\n                    result.add(trans[\\\"orig\\\"])\n    \n        for (t_trans, trans_list) in data_by_time.items():\n            for trans in trans_list:\n                for time in times:\n                    if abs(t_trans - time) <= 60:\n                        for other_trans in data_by_time[time]:\n                            if other_trans[\\\"name\\\"] == trans[\\\"name\\\"] and other_trans[\\\"city\\\"] != trans[\\\"city\\\"]:\n                                #result.add(other_trans[\\\"orig\\\"])\n                                result.add(trans[\\\"orig\\\"])\n                    \n        return list(result)\n                    \n        \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        transactions = [ x.split(\\\",\\\") for x in transactions]\n        transactions =[ [x[0],int(x[1]),int(x[2]),x[3]] for x in transactions]\n        transactions.sort(key=lambda x:x[1])\n        res=set()\n        n=len(transactions)\n        for i in range(n):\n            nam1,tim1,amt1,city1=transactions[i]\n            \n            if int(amt1)>1000:\n                res.add(f\\\"{nam1},{tim1},{amt1},{city1}\\\")\n            for j in range(i+1,n):\n                nam2,tim2,amt2,city2=transactions[j]\n                if nam1==nam2 and int(tim2)-int(tim1)<=60 and city1!=city2:\n                    res.add(f\\\"{nam1},{tim1},{amt1},{city1}\\\")\n                    res.add(f\\\"{nam2},{tim2},{amt2},{city2}\\\")\n        return list(res)\n                \n                \n                \n            \n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        import collections\n        if not transactions:\n            return []\n        \n        memo = collections.defaultdict(list)    #create a dictionary to keep track of previous transaction \n        invalid_tran = set()                    #to store invalid transaction / I use set to avoid duplication\n        for i,transaction  in enumerate (transactions):\n            \n            name, time, amount, city = (int(i) if i.isnumeric() else i for i in transaction.split(','))\n            \n            if amount > 1000:                   #if the amount is greater than 1000 add it to the invalid_tran\n                invalid_tran.add(transaction)               \n                 \n            if name in memo:                    # if there is any other previous transaction done by similar person , check it from the memo\n                for tran in memo[name]:         # bring all previous transaction done by similar person (iterate over the memo)\n                    _, prev_time, _, prev_city =(int(i) if i.isnumeric() else i for i in  tran.split(','))\n                    if abs(time-prev_time) <= 60 and prev_city != city:  #check if the absolute time difference is less than 60 and the city is the same\n                        invalid_tran.add(tran) \n                        invalid_tran.add(transaction)                    \n            \n            memo[name].append(transaction)  # add the transaction to the dictionary (memo) - always keep track of previous transaction \n        return invalid_tran\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        if not transactions:\n            return []\n        dic=defaultdict(list)\n        invalid=set()\n        for i in range(len(transactions)):\n            name, time, amount, city=(int(i) if i.isnumeric() else i for i in transactions[i].split(','))\n            if amount>1000:\n                invalid.add(transactions[i])\n            if name in dic:\n                for tran in dic[name]:\n                    _, prev_time, _, prev_city=(int(i) if i.isnumeric() else i for i in tran.split(','))\n                    if prev_city!=city and abs(prev_time-time)<=60:\n                        invalid.add(tran)\n                        invalid.add(transactions[i])\n            dic[name].append(transactions[i])\n        return list(invalid)\n                    \n                    \n            \n        \n        \n        \n        \n        \n                    \n            \n                    \n                    \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         import collections\n#         if not transactions:\n#             return []\n        \n#         memo = collections.defaultdict(list)    #create a dictionary to keep track of previous transaction \n#         invalid_tran = set()                    #to store invalid transaction / I use set to avoid duplication\n#         for i in range(len(transactions)):\n            \n#             name, time, amount, city = (int(i) if i.isnumeric() else i for i in transactions[i].split(','))\n            \n#             if amount > 1000:                   #if the amount is greater than 1000 add it to the invalid_tran\n#                 invalid_tran.add(transactions[i])               \n                 \n#             if name in memo:                    # if there is any other previous transaction done by similar person , check it from the memo\n#                 for tran in memo[name]:         # bring all previous transaction done by similar person (iterate over the memo)\n#                     _, prev_time, _, prev_city =(int(i) if i.isnumeric() else i for i in  tran.split(','))\n#                     if abs(time-prev_time) <= 60 and prev_city != city:  #check if the absolute time difference is less than 60 and the city is the same\n#                         invalid_tran.add(tran) \n#                         invalid_tran.add(transactions[i])                    \n            \n#             memo[name].append(transactions[i])  # add the transaction to the dictionary (memo) - always keep track of previous transaction \n#         return invalid_tran\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        def giddy(item):\n            return item.split(',')\n        \n        result = set()\n        seen = collections.defaultdict(collections.deque)\n        transactions = list(map(giddy, transactions))\n        transactions.sort(key=lambda x: int(x[1]))\n        # print(transactions)\n        for i in range(len(transactions)):\n            val = transactions[i]\n            if int(val[2])>1000:\n                result.add(','.join(val))\n            if val[0] in seen:\n                # print(seen)\n                for x in seen[val[0]]:\n                    comp = transactions[x]\n                    # print(comp)\n                    if abs(int(comp[1])-int(val[1]))<=60 and comp[3] != val[3]:\n                        result.add(','.join(val))\n                        result.add(','.join(comp))\n            seen[val[0]].append(i)\n            # print(seen[val[0]], 'before pop')\n            while abs(int(transactions[seen[val[0]][0]][1])-int(val[1]))>60:\n                seen[val[0]].popleft()\n                # print(seen[val[0]], 'after pop')\n        return result", "from collections import defaultdict\n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        if not transactions:\n            return []\n        \n        d = defaultdict(list)\n        result = set()\n        \n        for i in range(len(transactions)):\n            name, time, amount, city = (int(i) if i.isnumeric() else i for i in transactions[i].split(\\\",\\\"))\n            \n            if amount > 1000:\n                result.add(transactions[i])\n                \n            if name in d:\n                for tran in d[name]:\n                    _, prev_time, _, prev_city = (int(i) if i.isnumeric() else i for i in tran.split(\\\",\\\"))\n                    if abs(time - prev_time) <= 60 and prev_city != city:\n                        result.add(tran)\n                        result.add(transactions[i])\n            \n            d[name].append(transactions[i])\n        \n        return result\n", "class Solution(object):\n    def invalidTransactions(self, transactions):\n        \\\"\\\"\\\"\n        :type transactions: List[str]\n        :rtype: List[str]\n        \n        memo = dictionary --> create a dictionary to keep track of previous transaction \n        invalid_tran = set --> to store invalid transaction / I use set to avoid duplication \n        \n        Iterate over transactions:\n            -> if the amount is greater than 1000 add it to the invalid_tran\n            -> if there is any other previous transaction done by similar person , check it from the memo\n                    -> bring all previous transaction done by similar person (iterate over the memo)\n                            -> check if the absolute time difference is less than 60 and the city is the same \n                                    -> if that is true add it to the invalid transaction \n            -> add the transaction to the dictionary (memo) - always keep track of previous transaction \n        \\\"\\\"\\\"\n        import collections\n        if not transactions:\n            return []\n        \n        memo = collections.defaultdict(list)    #create a dictionary to keep track of previous transaction \n        invalid_tran = set()                    #to store invalid transaction / I use set to avoid duplication\n        for i,transaction  in enumerate (transactions):\n            \n            name, time, amount, city = (int(i) if i.isnumeric() else i for i in transaction.split(','))\n            \n            if amount > 1000:                   #if the amount is greater than 1000 add it to the invalid_tran\n                invalid_tran.add(transaction)               \n                 \n            if name in memo:                    # if there is any other previous transaction done by similar person , check it from the memo\n                for tran in memo[name]:         # bring all previous transaction done by similar person (iterate over the memo)\n                    _, prev_time, _, prev_city =(int(i) if i.isnumeric() else i for i in  tran.split(','))\n                    if abs(time-prev_time) <= 60 and prev_city != city:  #check if the absolute time difference is less than 60 and the city is the same\n                        invalid_tran.add(tran) \n                        invalid_tran.add(transaction)                    \n            \n            memo[name].append(transaction)  # add the transaction to the dictionary (memo) - always keep track of previous transaction \n        return invalid_tran", "import collections\nclass Solution(object):\n    def invalidTransactions(self, transactions):\n        if not transactions:\n            return []\n        \n        memo = collections.defaultdict(list)    #create a dictionary to keep track of previous transaction \n        invalid_tran = set()                    #to store invalid transaction / I use set to avoid duplication\n        for i,transaction  in enumerate (transactions):\n            \n            name, time, amount, city = (int(i) if i.isnumeric() else i for i in transaction.split(','))\n            \n            if amount > 1000:                   #if the amount is greater than 1000 add it to the invalid_tran\n                invalid_tran.add(transaction)               \n                 \n            if name in memo:                    # if there is any other previous transaction done by similar person , check it from the memo\n                for tran in memo[name]:         # bring all previous transaction done by similar person (iterate over the memo)\n                    _, prev_time, _, prev_city =(int(i) if i.isnumeric() else i for i in  tran.split(','))\n                    if abs(time-prev_time) <= 60 and prev_city != city:  #check if the absolute time difference is less than 60 and the city is the same\n                        invalid_tran.add(tran) \n                        invalid_tran.add(transaction)                    \n            \n            memo[name].append(transaction)  # add the transaction to the dictionary (memo) - always keep track of previous transaction \n        return invalid_tran\n", "import collections\nclass Solution(object):\n    def invalidTransactions(self, transactions):\n        if not transactions:\n            return []\n        \n#        memo = collections.defaultdict(list)    #create a dictionary to keep track of previous transaction \n        memo = {}\n        invalid_tran = set()                    #to store invalid transaction / I use set to avoid duplication\n        for i,transaction  in enumerate (transactions):\n            \n            name, time, amount, city = (int(i) if i.isnumeric() else i for i in transaction.split(','))\n            \n            if amount > 1000:                   #if the amount is greater than 1000 add it to the invalid_tran\n                invalid_tran.add(transaction)               \n                 \n            if name in memo:                    # if there is any other previous transaction done by similar person , check it from the memo\n                for tran in memo[name]:         # bring all previous transaction done by similar person (iterate over the memo)\n                    _, prev_time, _, prev_city =(int(i) if i.isnumeric() else i for i in  tran.split(','))\n                    if abs(time-prev_time) <= 60 and prev_city != city:  #check if the absolute time difference is less than 60 and the city is the same\n                        invalid_tran.add(tran) \n                        invalid_tran.add(transaction)                    \n            if name not in memo:\n                memo[name] = []\n            memo[name].append(transaction)  # add the transaction to the dictionary (memo) - always keep track of previous transaction \n        return invalid_tran\n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        \n        transactionsByName = {}\n        invalidTransactions = set()\n        for t in transactions:\n            name, time, amount, city = t.split(\\\",\\\")\n            if int(amount) > 1000:\n                \n                invalidTransactions.add(t)\n                \n            item = {\n                \\\"name\\\": name,\n                \\\"time\\\": time,\n                \\\"amount\\\": amount,\n                \\\"city\\\": city,\n            }\n            \n            if name not in transactionsByName:\n                transactionsByName[name] = [item]\n            else:\n                transactionsByName[name].append(item)\n        \n        for key, values in transactionsByName.items():\n            # values.sort(key = lambda v: v[\\\"time\\\"]) \n            for i in range(len(values)):\n                for k in range(len(values)):\n                    if values[i][\\\"city\\\"] != values[k][\\\"city\\\"] and abs(int(values[i][\\\"time\\\"]) - int(values[k][\\\"time\\\"])) <=60:\n                        invalidTransactions.add(\\\",\\\".join(values[i].values()))\n                        invalidTransactions.add(\\\",\\\".join(values[k].values()))\n\n        return list(invalidTransactions)\n        # same name -> go through list \n        # sort by time\n        # if each one is next to other, put first into list if last, put that to list too\n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        if not transactions:\n            return []\n        dic=defaultdict(list)\n        invalid=set()\n        for i in range(len(transactions)):\n            name, time, amount, city=(int(i) if i.isnumeric() else i for i in transactions[i].split(','))\n            if amount>1000:\n                invalid.add(transactions[i])\n            if name in dic:\n                for tran in dic[name]:\n                    _, prev_time, _, prev_city=(int(i) if i.isnumeric() else i for i in tran.split(','))\n                    if prev_city!=city and abs(prev_time-time)<=60:\n                        invalid.add(transactions[i])\n                        invalid.add(tran)\n            dic[name].append(transactions[i])\n        return invalid\n                    \n            \n                    \n                    \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         import collections\n#         if not transactions:\n#             return []\n        \n#         memo = collections.defaultdict(list)    #create a dictionary to keep track of previous transaction \n#         invalid_tran = set()                    #to store invalid transaction / I use set to avoid duplication\n#         for i in range(len(transactions)):\n            \n#             name, time, amount, city = (int(i) if i.isnumeric() else i for i in transactions[i].split(','))\n            \n#             if amount > 1000:                   #if the amount is greater than 1000 add it to the invalid_tran\n#                 invalid_tran.add(transactions[i])               \n                 \n#             if name in memo:                    # if there is any other previous transaction done by similar person , check it from the memo\n#                 for tran in memo[name]:         # bring all previous transaction done by similar person (iterate over the memo)\n#                     _, prev_time, _, prev_city =(int(i) if i.isnumeric() else i for i in  tran.split(','))\n#                     if abs(time-prev_time) <= 60 and prev_city != city:  #check if the absolute time difference is less than 60 and the city is the same\n#                         invalid_tran.add(tran) \n#                         invalid_tran.add(transactions[i])                    \n            \n#             memo[name].append(transactions[i])  # add the transaction to the dictionary (memo) - always keep track of previous transaction \n#         return invalid_tran\n", "class Transaction:\n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = time\n        self.amount = amount\n        self.city = city\n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        def formatRes(t):\n            return \\\"{},{},{},{}\\\".format(t.name, t.time, t.amount, t.city)\n        l = []\n        res = set()\n        for transaction in transactions:\n            name, time, amount, city = transaction.split(\\\",\\\")\n            l.append(Transaction(name, int(time), int(amount), city))\n        l.sort(key=lambda t: t.time)\n        \n        for i in range(len(l)):\n            t1 = l[i]\n            if t1.amount > 1000:\n                res.add(formatRes(t1))\n            for j in range(i+1, len(l)):\n                t2 = l[j]\n                if t1.name == t2.name and t2.time-t1.time <= 60 and t2.city != t1.city:\n                    res.add(formatRes(t1))\n                    res.add(formatRes(t2))\n        res = list(res)\n        return res", "from collections import defaultdict\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        if not transactions:\n            return []\n        previous = defaultdict(list)\n        ans = set()\n        \n        for transaction in transactions:\n            \n            \n            name, time, amount, city = (int(i) if i.isnumeric() else i for i in transaction.split(','))\n            \n            if amount > 1000:\n                ans.add(transaction)\n                \n            for tran in previous[name]:\n                _, prev_time, _, prev_city = (int(i) if i.isnumeric() else i for i in tran.split(','))\n                \n                if abs(time - prev_time) <= 60 and city != prev_city:\n                    ans.add(tran)\n                    ans.add(transaction)\n            previous[name].append(transaction)\n        return ans\n                \n                                            \n", "class Solution:\n    def invalidTransactions(self, arr: List[str]) -> List[str]:\n        b = [0]*len(arr)\n        a = [0]*len(arr)\n        c = []\n        for i in range(len(arr)):\n            b[i] = arr[i].split(\\\",\\\")\n            if int(b[i][2]) > 1000:\n                a[i] = 1\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if b[i][0] == b[j][0] and b[i][3] != b[j][3]:\n                    if abs(int(b[i][1]) - int(b[j][1])) <= 60:\n                        a[i] = a[j] = 1\n        for i in range(len(arr)):\n            if a[i] == 1:\n                c.append(arr[i])\n        return(c)\n        ", "from collections import defaultdict\nclass Transaction:\n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n    \nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        trans_index = defaultdict(list)\n        trans = []\n        for t in transactions:\n            name, time, amount, city = t.split(',')\n            trans.append(Transaction(name, time, amount, city))\n        trans.sort(key = lambda x: x.time)\n        \n        s = set()\n        for i in range(len(trans)):\n            t1 = trans[i]\n            if t1.amount > 1000:\n                s.add(\\\"{},{},{},{}\\\".format(t1.name, t1.time, t1.amount, t1.city))\n            for j in range(i + 1, len(trans)):\n                t2 = trans[j]\n                if t2.name == t1.name and t2.time - t1.time <= 60 and t1.city != t2.city:\n                    s.add(\\\"{},{},{},{}\\\".format(t1.name, t1.time, t1.amount, t1.city))\n                    s.add(\\\"{},{},{},{}\\\".format(t2.name, t2.time, t2.amount, t2.city))\n        return list(s)\n            \n        \n            \n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        splits = [t.split(',') for t in transactions]\n        lists = {}\n        res = set()\n        for time, p, v, loc, t in sorted([[int(sp[1]),sp[0],int(sp[2]),sp[3], t] for sp, t in zip(splits, transactions)]):\n            if v>1000:\n                res.add(t)\n\n            tk = time%61\n            if p not in lists:\n                lists[p] = [None]*61\n            \n            lst = lists[p]\n            for i in range(61):\n                if lst[i] and abs(lst[i][0]-time)<=60 and lst[i][1]!=loc:\n                    res.add(t)\n                    res.add(lists[p][i][2])\n\n            lst[tk] = [time, loc, t]\n\n        return res\n            \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        transactions = [ x.split(\\\",\\\") for x in transactions]\n        transactions =[ [x[0],int(x[1]),int(x[2]),x[3]] for x in transactions]\n        transactions.sort(key=lambda x:x[1])\n        #print (transactions)\n        res=set()\n        n=len(transactions)\n        for i in range(n):\n            nam1,tim1,amt1,city1=transactions[i]\n            \n            if int(amt1)>1000:\n                res.add(f\\\"{nam1},{tim1},{amt1},{city1}\\\")\n            for j in range(i+1,n):\n                nam2,tim2,amt2,city2=transactions[j]\n                if nam1==nam2 and int(tim2)-int(tim1)<=60 and city1!=city2:\n                    print (nam1,tim1,amt1,city1, \\\"   \\\",nam2,tim2,amt2,city2)\n                    res.add(f\\\"{nam1},{tim1},{amt1},{city1}\\\")\n                    res.add(f\\\"{nam2},{tim2},{amt2},{city2}\\\")\n        return list(res)\n                \n                \n                \n            \n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        records = []\n        for transaction in transactions:\n            name, time, amount, city = transaction.split(\\\",\\\")\n            records.append((name, int(time), int(amount), city, transaction))\n        answer = set()\n        for record in records:\n            if record[2] > 1000:\n                answer.add(record[4])\n                continue\n            for other in records:\n                if record[0] == other[0] and record[3] != other[3] and abs(record[1] - other[1]) <= 60:\n                    answer.add(record[4])\n                    answer.add(other[4])\n        return list(answer)\n            ", "class Transactions: \n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = time\n        self.amount = amount\n        self.city = city \n\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        transact = []\n        for t in transactions:\n            t = t.split(',')\n            obj = Transactions(t[0], int(t[1]), int(t[2]), t[3])\n            transact.append(obj)\n        transact.sort(key=lambda t: t.time)\n        invalid = set() \n        for i in range(len(transact)):\n            first = transact[i]\n            if first.amount > 1000:\n                invalid.add(self.returnString(first))\n            for j in range(i+1, len(transact)):\n                second = transact[j]\n                if first.name == second.name and first.city != second.city and second.time - first.time <= 60:\n                    invalid.add(self.returnString(first))\n                    invalid.add(self.returnString(second))\n                    \n        return list(invalid)\n    \n    def returnString(self, first):\n        return first.name + ',' + str(first.time) + ',' + str(first.amount) + ',' + first.city\n", "class Transaction: \n    def __init__(self, name, time, amount, city):\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n        \nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        # convert each into object Transaction \n        for i in range(len(transactions)): \n            transact = transactions[i].split(',')\n            transactions[i] = Transaction(transact[0], transact[1], transact[2], transact[3])\n    \n        invalid = set()\n        def sortByTime(x):\n            return x.time\n        transactions.sort(key=sortByTime)\n        \n        for i, t in enumerate(transactions): \n            if t.amount > 1000: \n                invalid.add(self.toString(t))\n            for j in range(i+1, len(transactions)):\n                s = transactions[j]\n                if t.name == s.name and t.city != s.city and s.time - t.time <= 60:\n                    invalid.add(self.toString(s))\n                    invalid.add(self.toString(t))\n        return invalid\n                \n                \n    def toString(self, s):\n        return ('%s,%d,%d,%s' % (s.name, s.time, s.amount, s.city))\n        \n        \n", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = set()\n        trans = [i.split(\\\",\\\") for i in transactions]\n        for i in range(len(transactions)):\n            if int(trans[i][2]) > 1000:\n                invalid.add(transactions[i])\n            for j in range (i, len(transactions)):\n                if trans[i][0] == trans[j][0] and trans[i][3] != trans[j][3] and abs(int(trans[i][1]) - int(trans[j][1])) <= 60:\n                    invalid.add(transactions[i])\n                    invalid.add(transactions[j])\n        return list(invalid)", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        # brute force\n        invalid = set()\n        arr = [trans.split(',') for trans in transactions] \n        arr.sort(key = lambda t: int(t[1]))\n        print(arr)\n        for i in range(len(arr)):\n            if int(arr[i][2]) > 1000: invalid.add(','.join(arr[i]))\n            for j in range(i, len(transactions)):\n                if arr[j][0] == arr[i][0] and int(arr[j][1]) - int(arr[i][1]) <= 60 and arr[i][3] != arr[j][3]:\n                    print(\\\"together: \\\", ','.join(arr[j]), ','.join(arr[i]))\n                    invalid.add(','.join(arr[j]))\n                    invalid.add(','.join(arr[i]))\n        \n        return invalid\n            ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        ts = []\n        for t in transactions:\n            name, stamp, amount, city = t.split(\\\",\\\")\n            ts.append([name, int(stamp), int(amount), city, t])\n        \n        s = set()\n        \n        for t in ts:\n            if t[2] > 1000: s.add(t[4])\n            for v in ts:\n                if t[0] == v[0] and abs(t[1] - v[1]) <= 60 and t[3] != v[3]: s.add(v[4])\n    \n        return list(s)\n        \n        \n        ", "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        track = [] # (time, city, name)\n        ret = set()\n        \n        for t in transactions:\n            name, time, amt, city = t.split(\\\",\\\")\n            time = int(time)\n            if int(amt) > 1000:\n                ret.add(t)\n                track.append((time, city, name, t))\n\n            # print(track, t)\n            for i in range(0, len(track)):\n                cmp = track[i]\n                if abs(cmp[0] - time) <= 60 and cmp[1] != city and cmp[2] == name:\n                    ret.add(t)\n                    ret.add(cmp[3])\n            \n            track.append((time, city, name, t))\n        return ret"]
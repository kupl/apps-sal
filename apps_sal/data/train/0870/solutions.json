["# cook your dish here\nimport math;\nfrom math import gcd,sqrt,floor,factorial,ceil\nfrom bisect import bisect_left,bisect_right\nimport bisect;\nimport sys;\nfrom sys import stdin,stdout\nimport os\nsys.setrecursionlimit(pow(10,7))\nimport collections\nfrom collections import defaultdict,Counter\nfrom statistics import median\n# input=stdin.readline\n# print=stdout.write\nfrom queue import Queue\ninf = float(\"inf\")\nfrom operator import neg;\nmod=pow(10,9)+7\ndef fun(l):\n m=[[l[0]]]\n for i in range(1,n):\n  if m[-1][-1]==l[i]:\n   m[-1]+=[l[i]]\n  else:\n   m.append([l[i]])\n count=[]\n for i in range(len(m)):\n  count.append(len(m[i]))\n return count;\ndef function(l1,index,prev,count):\n tuple=(index,prev,count)\n if tuple in dict:\n  return dict[tuple]\n n=len(l1)\n if index==n:\n  return 0;\n if count>=3:\n  if index%2==prev:\n   dict[tuple]=function(l1,index+1,prev,count)\n   return function(l1,index+1,prev,count)\n  else:\n   dict[tuple]=l1[index]+function(l1,index+1,prev,count);\n   return dict[tuple]\n if prev==None:\n  skip=l1[index]+function(l1,index+1,prev,count)\n  not_skip=function(l1,index+1,index%2,count+1)\n  maxa=min(skip,not_skip)\n  dict[tuple]=maxa\n  return maxa;\n\n if index%2==prev:\n  dict[tuple]=function(l1,index+1,index%2,count)\n  return dict[tuple]\n if index%2!=prev:\n  skip=l1[index]+function(l1,index+1,prev,count)\n  not_skip=function(l1,index+1,index%2,1+count)\n  maxa = min(skip, not_skip)\n  dict[tuple]=maxa\n  return maxa;\n\nt=int(input())\nfor i in range(t):\n s=input()\n l=list(s)\n n=len(l)\n l=[int(i) for i in l]\n l1=fun(l)\n dict=defaultdict(int)\n theta=function(l1,0,None,0)\n print(theta)\n", "# cook your dish here\nimport math;\nfrom math import gcd,sqrt,floor,factorial,ceil\nfrom bisect import bisect_left,bisect_right\nimport bisect;\nimport sys;\nfrom sys import stdin,stdout\nimport os\nsys.setrecursionlimit(pow(10,7))\nimport collections\nfrom collections import defaultdict,Counter\nfrom statistics import median\ninput=stdin.readline\n# print=stdout.write\nfrom queue import Queue\ninf = float(\"inf\")\nfrom operator import neg;\nmod=pow(10,9)+7\ndef fun(l):\n m=[[l[0]]]\n for i in range(1,n):\n  if m[-1][-1]==l[i]:\n   m[-1]+=[l[i]]\n  else:\n   m.append([l[i]])\n count=[]\n for i in range(len(m)):\n  count.append(len(m[i]))\n return count;\ndef function(l1,index,prev,count):\n tuple=(index,prev,count)\n if tuple in dict:\n  return dict[tuple]\n n=len(l1)\n if index==n:\n  return 0;\n if count>=3:\n  if index%2==prev:\n\n   a1=l1[index]+function(l1,index+1,prev,count)\n   dict[tuple] =a1;\n   return a1;\n  else:\n\n   dict[tuple]=function(l1,index+1,prev,count);\n   return dict[tuple]\n if prev==None:\n  skip=function(l1,index+1,prev,count)\n  not_skip=l1[index]+function(l1,index+1,index%2,count+1)\n  maxa=max(skip,not_skip)\n  dict[tuple]=maxa;\n  return maxa;\n\n if index%2==prev:\n  dict[tuple]=l1[index]+function(l1,index+1,index%2,count)\n  return dict[tuple]\n if index%2!=prev:\n  skip=function(l1,index+1,prev,count)\n  not_skip=l1[index]+function(l1,index+1,index%2,1+count)\n  maxa = max(skip, not_skip)\n  dict[tuple]=maxa\n  return maxa;\n\nt=int(input())\nfor i in range(t):\n s=input()\n l=list(s)\n l.pop()\n n=len(l)\n l=[int(i) for i in l]\n l1=fun(l)\n dict=defaultdict(int)\n theta=function(l1,0,None,0)\n print(n-theta)\n", "# cook your dish here\nimport math;\nfrom math import gcd,sqrt,floor,factorial,ceil\nfrom bisect import bisect_left,bisect_right\nimport bisect;\nimport sys;\nfrom sys import stdin,stdout\nimport os\nsys.setrecursionlimit(pow(10,7))\nimport collections\nfrom collections import defaultdict,Counter\nfrom statistics import median\n# input=stdin.readline\n# print=stdout.write\nfrom queue import Queue\ninf = float(\"inf\")\nfrom operator import neg;\nmod=pow(10,9)+7\ndef fun(l):\n m=[[l[0]]]\n for i in range(1,n):\n  if m[-1][-1]==l[i]:\n   m[-1]+=[l[i]]\n  else:\n   m.append([l[i]])\n count=[]\n for i in range(len(m)):\n  count.append(len(m[i]))\n return count;\ndef function(l1,index,prev,count):\n tuple=(index,prev,count)\n if tuple in dict:\n  return dict[tuple]\n n=len(l1)\n if index==n:\n  return 0;\n if count>=3:\n  if index%2==prev:\n\n   a1=l1[index]+function(l1,index+1,prev,count)\n   dict[tuple] =a1;\n   return a1;\n  else:\n\n   dict[tuple]=function(l1,index+1,prev,count);\n   return dict[tuple]\n if prev==None:\n  skip=function(l1,index+1,prev,count)\n  not_skip=l1[index]+function(l1,index+1,index%2,count+1)\n  maxa=max(skip,not_skip)\n  dict[tuple]=maxa;\n  return maxa;\n\n if index%2==prev:\n  dict[tuple]=l1[index]+function(l1,index+1,index%2,count)\n  return dict[tuple]\n if index%2!=prev:\n  skip=function(l1,index+1,prev,count)\n  not_skip=l1[index]+function(l1,index+1,index%2,1+count)\n  maxa = max(skip, not_skip)\n  dict[tuple]=maxa\n  return maxa;\n\nt=int(input())\nfor i in range(t):\n s=input()\n l=list(s)\n n=len(l)\n l=[int(i) for i in l]\n l1=fun(l)\n dict=defaultdict(int)\n theta=function(l1,0,None,0)\n print(n-theta)\n", "# cook your dish here\nt = int(input())\nfor _ in range(t):\n s = input()\n n = len(s)\n o, z, oz, zo, ozo, zoz = 0,0,0,n,n,n\n for i in s:\n  if i=='1':\n   zo = min(zo,z)\n   z = z+1\n   ozo = min(ozo,oz)\n   oz = oz+1\n   zoz = zoz+1\n  else:\n   oz = min(oz, o)\n   o = o+1\n   zoz = min(zoz, zo)\n   zo = zo+1\n   ozo = ozo+1\n print(min(o, z, oz, zo, ozo, zoz))", "# cook your dish here\n# code by RAJ BHAVSAR\nfor _ in range(int(input())):\n s = str(input())\n dp = [0,0,len(s),len(s),len(s),len(s)]\n for i in s:\n  if(i == '1'):\n   dp[3] = min(dp[3],dp[0])\n   dp[0] += 1\n   dp[5] = min(dp[5],dp[2])\n   dp[2] += 1\n   dp[4] += 1\n  else:\n   dp[2] = min(dp[2],dp[1])\n   dp[1] += 1\n   dp[4] = min(dp[4],dp[3])\n   dp[3] += 1\n   dp[5] += 1\n print(min(dp))", "for _ in range(int(input())):\n bi = input().strip()\n dp = [0 if i < 2 else len(bi) for i in range(6)]\n for c in bi:\n  if c == '1':\n   dp[3] = min(dp[3], dp[0])\n   dp[0] += 1\n   dp[5] = min(dp[5], dp[2])\n   dp[2] += 1\n   dp[4] += 1\n  else:\n   dp[2] = min(dp[2], dp[1])\n   dp[1] += 1\n   dp[4] = min(dp[4], dp[3])\n   dp[3] += 1\n   dp[5] += 1\n print(min(dp))\n   \n", "t = int(input())\nwhile(t>0):\n st = input()\n dp = [0 if(i<2) else len(st) for i in range(6)] # dp is a 6 element array, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0where the first two elements signify the no. of ones and no. of zeros \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0respectively while, the 3rd and 4th element signifies the current 10 or \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a001 trend and the 5th and 6th element takes care of the 101 or 010 trend\n for c in st:\n  if(c=='1'):\n   dp[3] = min(dp[3],dp[1])\n   dp[1]+=1\n   dp[4] = min(dp[4],dp[2])\n   dp[2]+=1\n   dp[5]+=1\n  else:\n   dp[2] = min(dp[2],dp[0])\n   dp[0]+=1\n   dp[5] = min(dp[5],dp[3])\n   dp[3]+=1\n   dp[4]+=1\n print(min(dp))\n t=t-1\n", "for _ in range(int(input())):\n bi = input().strip()\n dp = [0 if i < 2 else len(bi) for i in range(6)]\n for c in bi:\n  if c == '1':\n   dp[3] = min(dp[3], dp[0])\n   dp[0] += 1\n   dp[5] = min(dp[5], dp[2])\n   dp[2] += 1\n   dp[4] += 1\n  else:\n   dp[2] = min(dp[2], dp[1])\n   dp[1] += 1\n   dp[4] = min(dp[4], dp[3])\n   dp[3] += 1\n   dp[5] += 1\n print(min(dp))\n", "import numpy as np\ni8 = np.int64\n\n\ndef solve_core(a, n):\n res = 0\n s1 = a[0]\n s2 = a[1]\n s3 = np.sum(a[2::2])\n for i in range(1, n, 2):\n  t3 = s3\n  for j in range(i + 1, n + 1, 2):\n   res = max(res, s1 + s2 + t3)\n   s2 += a[j + 1]\n   t3 -= a[j]\n  s1 += a[i + 1]\n  s2 = a[i + 2]\n  s3 -= a[i + 1]\n return res\n\n\ndef solve(S):\n N = len(S)\n a = np.zeros(N + 2, i8)\n i = 0\n prev = S[0]\n count = 0\n for c in S:\n  if c == prev:\n   count += 1\n  else:\n   a[i] = count\n   prev = c\n   count = 1\n   i += 1\n else:\n  a[i] = count\n  i += 1\n if i < 4:\n  return 0\n else:\n  res = max(solve_core(a, i), solve_core(a[1:], i - 1))\n  return N - res\n\ndef main():\n T = int(input())\n for _ in range(T):\n  S = input()\n  print(solve(S))\n\ndef __starting_point():\n main()\n__starting_point()", "T=int(input())\nfor _ in range(T):\n s=input()\n l=[]\n a=0\n b=0\n for i in s:\n  if i=='1':\n   if a!=0:\n    l.append(a)\n    a=0\n   b+=1\n  else:\n   if b!=0:\n    l.append(b)\n    b=0\n   a-=1\n if a!=0:\n  l.append(a)\n if b!=0:\n  l.append(b)\n A=[0]\n B=[0]\n for i in l:\n  if i<0:\n   A.append(-i+A[-1])\n   B.append(B[-1])\n  else:\n   A.append(A[-1])\n   B.append(i+B[-1])\n m=0\n x=len(A)-1\n for i in range(1,x+1):\n  for j in range(i,x+1):\n   m=max(m,A[j]-A[i-1]+B[i-1]+B[x]-B[j],B[j]-B[i-1]+A[i-1]+A[x]-A[j])\n print(len(s)-m)\n", "import sys\nfrom random import randint\n\n\ndef rec(x, y, b):\n if x == n:\n  return 0\n if y == 3:\n  return n\n if dp[x][y] != -1:\n  return dp[x][y]\n if y == 1:\n  p = b ^ 1\n else:\n  p = b\n res = n\n if a[x] != p:\n  res = min(res, rec(x, y+1, b))\n  res = min(res, 1+rec(x+1, y, b))\n else:\n  res = min(res, rec(x+1, y, b))\n dp[x][y] = res\n return dp[x][y]\n\n\nsys.setrecursionlimit(10**6)\nt = int(input())\n# t = 1\nfor _ in range(t):\n a = list(map(int, list(input())))\n # a = [randint(0, 1) for i in range(1000)]\n n = len(a)\n dp = [[-1, -1, -1] for i in range(n)]\n res = rec(0, 0, 0)\n dp = [[-1, -1, -1] for i in range(n)]\n res = min(res, rec(0, 0, 1))\n print(res)"]
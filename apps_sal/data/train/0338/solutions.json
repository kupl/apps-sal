["from functools import lru_cache\n\ndef failure(pat):\n    i, target, n = 1, 0, len(pat)\n    res = [0]\n    while i < n:\n        if pat[i] == pat[target]:\n            target += 1\n            res.append(target)\n            i+=1\n        elif target:\n            target = res[target-1]\n        else:\n            res.append(0)\n            i += 1\n    return res\n        \n    \nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            \n            if max_matched == len(evil): return 0\n            if idx == n: return 1\n            \n            l = s1[idx] if lb else 'a'\n            r = s2[idx] if rb else 'z'\n                \n            candidates = [chr(i) for i in range(ord(l), ord(r) + 1)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                next_matched = max_matched\n                while next_matched and evil[next_matched]!= c:\n                    next_matched = f[next_matched-1]\n                res += dfs(idx+1, next_matched + (evil[next_matched] == c), \n                          (lb and i==0), (rb and i == (len(candidates) - 1)))\n            return res\n            \n        return dfs(0) % (10**9 + 7)", "class Solution:\n    def findGoodStrings(self, N, *args) :\n        from functools import lru_cache\n        s1,s2, evil = [list(map(ord, i)) for i in args]\n        mod = 10 ** 9 + 7\n        \n        def kmp(l, c):\n            while l and evil[l] != c: l = f[l-1]\n            if evil[l] == c : l += 1\n            return l\n        \n        f = [0] * len(evil) \n        for i in range(1, len(evil)):\n            f[i] = kmp(f[i-1], evil[i])\n        \n        @lru_cache(None)\n        def dp(i = 0, lcp = 0 , f1 = False, f2 = False):\n            if lcp == len(evil): return 0 \n            if i == N : return 1\n            ans = 0\n            for char in range(f1 and 97 or s1[i], f2 and 123 or s2[i]+1):\n                ans += dp(i+1, kmp(lcp, char ), f1 or char > s1[i], f2 or char < s2[i])\n                ans %= mod \n            return ans \n\n        return dp()", "from functools import lru_cache\n\ndef failure(pat):\n    i, target, n = 1, 0, len(pat)\n    res = [0]\n    while i < n:\n        if pat[target] == pat[i]:\n            target+= 1\n            res.append(target)\n            i += 1\n        elif target:\n            target = res[target-1]\n        else:\n            res.append(0)\n            i += 1\n    return res\n\nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            if max_matched == len(evil): return 0\n            if idx == n: return 1\n            \n            l = s1[idx] if lb else 'a'\n            r = s2[idx] if rb else 'z'\n            \n            candidates = [chr(i) for i in range(ord(l), ord(r) + 1)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                next_match = max_matched\n                while next_match and evil[next_match] != c:\n                    next_match = f[next_match-1]\n                res += dfs(idx+1, next_match + (c == evil[next_match]), \n                          (lb and i == 0), (rb and i == ((len(candidates) -1))))\n            return res\n                    \n                \n        return dfs(0) % (10**9 + 7)", "class Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        \n        @lru_cache(None)\n        def dfs(k, j, b1, b2):\n            \n            if k==n:\n                return 1\n            \n            start = ord(s1[k]) if b1 else ord('a')\n            end = ord(s2[k]) if b2 else ord('z')\n            \n            res = 0\n            \n            for x in range(start, end+1):\n                \n                c = chr(x)\n                \n                l = j\n                \n                while l>0 and c!=evil[l]:\n                    l = lps[l-1]\n                \n                nevil = True\n                if c==evil[l]: # here\n                    l+=1\n                    if l==m:\n                        nevil = False\n                        \n                if nevil:\n                    res += dfs(k+1, l, b1 and c==s1[k] ,  b2 and c==s2[k])\n                    res %= mod\n            \n            return res\n                \n                \n    \n        m = len(evil)\n        \n        lps = [0]*m\n        \n        \n        for i in range(1, m):\n            \n            j = lps[i-1]\n            \n            while j>0 and evil[j]!=evil[i]:\n                j = lps[j-1]\n            \n            if evil[j]==evil[i]:   #here\n                lps[i] = j+1\n        \n        mod = 10**9+7\n        \n        return dfs(0, 0, True, True)\n        \n", "from functools import lru_cache\n\n        \ndef failure(pat):\n    i, target, n = 1, 0, len(pat)\n    res = [0]\n    while i < n:\n        if pat[target] == pat[i]:\n            target += 1\n            res.append(target)\n            i+=1\n        elif target:\n            target = res[target - 1]\n        else:\n            res.append(0)\n            i += 1\n    return res\n            \n    \nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            if max_matched == len(evil): return 0\n            if idx == n: return 1\n            \n            l = s1[idx] if lb else 'a'\n            r = s2[idx] if rb else 'z'\n            candidates = [chr(i) for i in range(ord(l), ord(r)+1)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                next_match = max_matched\n                while next_match and evil[next_match]!=c:\n                    next_match = f[next_match-1]\n                res += dfs(idx+1, next_match + (c == evil[next_match]), \n                          (lb and i == 0), (rb and i==(len(candidates)-1)))\n            return res\n        return dfs(0) % (10**9 + 7)", "class Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        M = 10**9 + 7\n        \n        table = [-1]\n        pos, cnd = 1, 0\n        while pos < len(evil):\n            if evil[pos] == evil[cnd]:\n                table.append(table[cnd])\n            else:\n                table.append(cnd)\n                cnd = table[cnd]\n                while cnd >= 0 and evil[pos] != evil[cnd]:\n                    cnd = table[cnd]\n            pos += 1\n            cnd += 1\n        table.append(cnd)\n        \n        @lru_cache(None)\n        def dfs(i, j, u, b):\n            if j == len(evil):\n                return 0\n            if i == n:\n                return 1\n            r = 0\n            for c in range(ord(s1[i]) if b else 97, ord(s2[i])+1 if u else 123):\n                if c == ord(evil[j]):\n                    t = dfs(i+1, j+1, u and c == ord(s2[i]), b and c == ord(s1[i]))\n                else:\n                    p = j\n                    while p >= 0:\n                        if c == ord(evil[p]):\n                            break\n                        p = table[p]\n                    t = dfs(i+1, p+1, u and c == ord(s2[i]), b and c == ord(s1[i]))\n                r += t\n            return r % M\n        \n        return dfs(0, 0, True, True)", "class Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        M = 10**9 + 7\n        \n        table = [-1]\n        pos, cnd = 1, 0\n        while pos < len(evil):\n            if evil[pos] == evil[cnd]:\n                table.append(table[cnd])\n            else:\n                table.append(cnd)\n                cnd = table[cnd]\n                while cnd >= 0 and evil[pos] != evil[cnd]:\n                    cnd = table[cnd]\n            pos += 1\n            cnd += 1\n        table.append(cnd)\n        \n        @lru_cache(None)\n        def dfs(i, j, u, b):\n            if j == len(evil):\n                return 0\n            if i == n:\n                return 1\n            r = 0\n            for c in range(ord(s1[i]) if b else 97, ord(s2[i])+1 if u else 123):\n                if c == ord(evil[j]):\n                    t = dfs(i+1, j+1, u and c == ord(s2[i]), b and c == ord(s1[i]))\n                else:\n                    p = j\n                    while p >= 0:\n                        if ord(evil[p]) == c:\n                            break\n                        p = table[p]\n                    t = dfs(i+1, p+1, u and c == ord(s2[i]), b and c == ord(s1[i]))\n                r += t\n            return r % M\n        \n        return dfs(0, 0, True, True)", "from functools import lru_cache\n\ndef failure(pat):\n    i, target, n = 1, 0, len(pat)\n    res = [0]\n    while i < n: \n        if pat[i] == pat[target]:\n            target += 1\n            res.append(target)\n            i += 1\n        elif target:\n            target = res[target-1]\n        else:\n            res.append(0)\n            i += 1\n    return res\n\ndef srange(a, b):\n    yield from (chr(i) for i in range(ord(a), ord(b)+1))\n    \nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            \n            if max_matched == len(evil): return 0\n            if idx == n: return 1\n            \n            l = s1[idx] if lb else 'a'\n            r = s2[idx] if rb else 'z'\n            \n            candidates = [*srange(l, r)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                next_matched = max_matched\n                while next_matched and evil[next_matched] != c:\n                    next_matched = f[next_matched-1]\n                res += dfs(idx+1, next_matched + (evil[next_matched] == c),\n                          (lb and i == 0), (rb and i == (len(candidates) - 1)))\n            return res\n                \n            \n            \n        return dfs(0) % (10**9 + 7)", "from functools import lru_cache\n\ndef failure(pat):\n    i, target, n = 1, 0, len(pat)\n    res = [0]\n    while i < n:\n        if pat[i] == pat[target]:\n            target+=1\n            res.append(target)\n            i += 1\n        elif target:\n            target = res[target-1]\n        else:\n            res.append(0)\n            i+=1\n    return res\n            \ndef srange(a, b):\n    return (chr(i) for i in range(ord(a), ord(b) + 1))\n\nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            \n            if max_matched == len(evil): return 0\n            if idx == n: return 1\n            \n            l = s1[idx] if lb else 'a'\n            r = s2[idx] if rb else 'z'\n            candidates = [*srange(l, r)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                next_match = max_matched \n                while next_match and evil[next_match] != c:\n                    next_match = f[next_match-1]\n                res += dfs(idx+1, next_match + (c == evil[next_match]), \n                          lb = (lb and i == 0), rb = (rb and i == len(candidates) -1))\n            \n            return res\n        return dfs(0) % (10**9 + 7)", "from functools import lru_cache\n\ndef srange(a, b):\n    yield from (chr(i) for i in range(ord(a), ord(b)+1))\n        \ndef failure(pat): \n    res = [0]\n    i, target = 1, 0\n    while i < len(pat): \n        if pat[i] == pat[target]: \n            target += 1\n            res += target,\n            i += 1\n        elif target: \n            target = res[target-1] \n        else: \n            res += 0,\n            i += 1\n    return res                        \n\nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            '''\n\\t\\t\\tidx: current_idx_on_s1_&_s2, \n\\t\\t\\tmax_matched: nxt_idx_to_match_on_evil, \n\\t\\t\\tlb, rb: is_left_bound, is_right_bound\n\\t\\t\\t'''\n            if max_matched == len(evil): return 0 # evil found, break\n            if idx == n: return 1 # base case\n            \n            l = s1[idx] if lb else 'a' # valid left bound\n            r = s2[idx] if rb else 'z' # valid right bound\n            candidates = [*srange(l, r)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                nxt_matched = max_matched\n                while evil[nxt_matched] != c and nxt_matched:\n                    nxt_matched = f[nxt_matched - 1]\n                res += dfs(idx+1, nxt_matched + (c == evil[nxt_matched]), \n                           lb=(lb and i == 0), rb=(rb and i == len(candidates)-1))\n            return res                \n        \n        return dfs(0) % (10**9 + 7)\n", "# 1397. Find All Good Strings\nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        e_len = len(evil)\n        par = [0] * e_len\n        \n        for i in range(1, e_len):\n            j = par[i-1]\n            while j and evil[i] != evil[j]:\n                j = par[j-1]\n            j += int(evil[i] == evil[j])\n            par[i] = j\n            \n        mod = (10 ** 9) + 7\n        @lru_cache(None)\n        def rec(cur, ei, sm, bg):\n            if ei == e_len:\n                return 0\n            if cur == n:\n                return 1\n            \n            ans = 0\n            st = ord('a') if bg else ord(s1[cur])\n            ed = ord('z') if sm else ord(s2[cur])\n                \n            for i in range(st, ed + 1):\n                if i == ord(evil[ei]):\n                    new_ei = ei + 1\n                else:\n                    new_ei = ei\n                    while new_ei and evil[new_ei] != chr(i):\n                        new_ei = par[new_ei - 1]\n                    if evil[new_ei] == chr(i):\n                        new_ei += 1\n                ans += rec(cur+1, new_ei, sm | (i < ord(s2[cur])), bg | (i > ord(s1[cur])))\n                \n            return ans%mod\n        \n        return rec(0, 0, False, False)%mod", "from functools import lru_cache\n\ndef srange(a, b):\n    yield from (chr(i) for i in range(ord(a), ord(b)+1))\n        \ndef failure(pat): \n    res = [0]\n    i, target = 1, 0\n    while i < len(pat): \n        if pat[i] == pat[target]: \n            target += 1\n            res += target,\n            i += 1\n        elif target: \n            target = res[target-1] \n        else: \n            res += 0,\n            i += 1\n    return res                        \n\nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            '''\n\\t\\t\\tidx: current_idx_on_s1_&_s2, \n\\t\\t\\tmax_matched: nxt_idx_to_match_on_evil, \n\\t\\t\\tlb, rb: is_left_bound, is_right_bound\n\\t\\t\\t'''\n            if max_matched == len(evil): return 0 # evil found, break\n            if idx == n: return 1 # base case\n            \n            l = s1[idx] if lb else 'a' # valid left bound\n            r = s2[idx] if rb else 'z' # valid right bound\n            candidates = [*srange(l, r)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                nxt_matched = max_matched\n                while evil[nxt_matched] != c and nxt_matched:\n                    nxt_matched = f[nxt_matched - 1]\n                res += dfs(idx+1, nxt_matched + (c == evil[nxt_matched]), \n                           lb=(lb and i == 0), rb=(rb and i == len(candidates)-1))\n            return res                \n        \n        return dfs(0) % (10**9 + 7)", "from functools import lru_cache\n\ndef failure(pat):\n    i, target, n = 1, 0, len(pat)\n    res =[0]\n    while i < n:\n        if pat[i] == pat[target]:\n            target += 1\n            res += target,\n            i += 1\n        elif target:\n            target = res[target-1]\n        else:\n            res += 0,\n            i += 1\n    return res\n\ndef srange(a, b):\n    yield from (chr(i) for i in range(ord(a), ord(b)+1))\n\n\nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        \n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            if max_matched == len(evil): return 0\n            if idx == n: return 1\n            \n            l = s1[idx] if lb else 'a'\n            r = s2[idx] if rb else 'z'\n            candidates = [*srange(l,r)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                next_matched = max_matched\n                while next_matched and evil[next_matched] != c:\n                    next_matched = f[next_matched-1]\n                res += dfs(idx+1, next_matched + (c == evil[next_matched]), \n                           lb=(lb and i==0), rb=(rb and i==len(candidates) - 1))\n            return res\n            \n        return dfs(0) % (10**9 + 7)", "def srange(a, b):\n    yield from (chr(i) for i in range(ord(a), ord(b)+1))\n        \ndef failure(pat): \n    res = [0]\n    i, target = 1, 0\n    while i < len(pat): \n        if pat[i] == pat[target]: \n            target += 1\n            res += target,\n            i += 1\n        elif target: \n            target = res[target-1] \n        else: \n            res += 0,\n            i += 1\n    return res                        \n\nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            '''\n\\t\\t\\tidx: current_idx_on_s1_&_s2, \n\\t\\t\\tmax_matched: nxt_idx_to_match_on_evil, \n\\t\\t\\tlb, rb: is_left_bound, is_right_bound\n\\t\\t\\t'''\n            if max_matched == len(evil): return 0 # evil found, break\n            if idx == n: return 1 # base case\n            \n            l = s1[idx] if lb else 'a' # valid left bound\n            r = s2[idx] if rb else 'z' # valid right bound\n            candidates = [*srange(l, r)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                nxt_matched = max_matched\n                while evil[nxt_matched] != c and nxt_matched:\n                    nxt_matched = f[nxt_matched - 1]\n                res += dfs(idx+1, nxt_matched + (c == evil[nxt_matched]), \n                           lb=(lb and i == 0), rb=(rb and i == len(candidates)-1))\n            return res                \n        \n        return dfs(0) % (10**9 + 7)\n", "from functools import lru_cache\n\ndef failure(pat):\n    i, target, n = 1, 0, len(pat)\n    res = [0]\n    while i < n:\n        if pat[i] == pat[target]:\n            target+=1\n            res.append(target)\n            i += 1\n        elif target:\n            target = res[target-1]\n        else:\n            res.append(0)\n            i+=1\n    return res\n            \ndef srange(a, b):\n    yield from (chr(i) for i in range(ord(a), ord(b) + 1))\n\nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        f = failure(evil)\n        @lru_cache(None)\n        def dfs(idx, max_matched=0, lb=True, rb=True):\n            \n            if max_matched == len(evil): return 0\n            if idx == n: return 1\n            \n            l = s1[idx] if lb else 'a'\n            r = s2[idx] if rb else 'z'\n            candidates = [*srange(l, r)]\n            \n            res = 0\n            for i, c in enumerate(candidates):\n                next_match = max_matched \n                while next_match and evil[next_match] != c:\n                    next_match = f[next_match-1]\n                res += dfs(idx+1, next_match + (c == evil[next_match]), \n                          lb = (lb and i == 0), rb = (rb and i == len(candidates) -1))\n            \n            return res\n        return dfs(0) % (10**9 + 7)", "# 1397. Find All Good Strings\nclass Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        e_len = len(evil)\n        par = [0] * e_len\n        \n        for i in range(1, e_len):\n            j = par[i-1]\n            while j and evil[i] != evil[j]:\n                j = par[j-1]\n            j += int(evil[i] == evil[j])\n            par[i] = j\n            \n        mod = (10 ** 9) + 7\n        @lru_cache(None)\n        def rec(cur, ei, sm, bg):\n            if ei == e_len:\n                return 0\n            if cur == n:\n                return 1\n            \n            ans = 0\n            st = ord('a') if bg else ord(s1[cur])\n            ed = ord('z') if sm else ord(s2[cur])\n                \n            for i in range(st, ed + 1):\n                if i == ord(evil[ei]):\n                    new_ei = ei + 1\n                else:\n                    new_ei = ei\n                    while new_ei and evil[new_ei] != chr(i):\n                        new_ei = par[new_ei - 1]\n                    if evil[new_ei] == chr(i):\n                        new_ei += 1\n                ans += rec(cur+1, new_ei, sm | (i < ord(s2[cur])), bg | (i > ord(s1[cur])))\n                if ans >= mod:\n                    ans -= mod\n            return ans\n        \n        return rec(0, 0, False, False)%mod", "from functools import lru_cache\nfrom itertools import takewhile\n\n\nclass Solution:\n    def findGoodStrings(self, n: int, A: str, B: str, evil: str) -> int:\n        MOD = 10 ** 9 + 7\n\n        evil_checker = KMPTable(evil)\n\n        @lru_cache(None)\n        def DP(i=0, startswith_A=True, startswith_B=True, match_evil=0):\n            # # <= s and not startwsith evil[e:]\n            if match_evil == len(evil):\n                return 0\n            if i == n:\n                return 1\n\n            start = A[i] if startswith_A else 'a'\n            end = B[i] if startswith_B else 'z'\n\n            return sum(\n                DP(\n                    i + 1,\n                    startswith_A and c == A[i],\n                    startswith_B and c == B[i],\n                    match_evil=evil_checker.match(c, idx=match_evil),\n                )\n                for c in map(chr, list(range(ord(start), ord(end) + 1)))\n            ) % MOD\n\n        return DP()\n\n\nclass KMPTable:\n    \n    def __init__(self, s):\n        self.s = s\n        self._init_table()\n        \n    def _init_table(self):\n        self.table = [0, 0]\n        for i in range(1, len(self.s)):\n            self.table.append(\n                self.match(self.s[i], idx=self.table[-1]),\n            )\n\n    def match(self, c, idx):\n        if c == self.s[idx]:\n            return idx + 1\n        return self.match(c, self.table[idx]) if idx > 0 else 0\n", "class Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        MOD = 1000000000 + 7\n        K = len(evil)\n        umap = [[[[0 for x in range(2)] for j in range(2)] for k in range(K)] for l in range(n)]\n        lps = list()\n        def computeLPS(s: str) -> List[int]:\n            N = len(s)\n            dp = [0 for i in range(N)]\n            \n            j = 0\n            for i in range(1, N):\n                while j > 0 and s[i] != s[j]:\n                    j = dp[j-1]\n                if s[i] == s[j]:\n                    j += 1\n                dp[i] = j\n            return dp\n        \n        def dfs(sp, ep, leftB, rightB) -> int:\n            if ep >= K:\n                return 0\n            if sp >= n:\n                return 1\n            \n            if umap[sp][ep][leftB][rightB] == 0:\n                i = s1[sp] if leftB == 1 else 'a'\n                j = s2[sp] if rightB == 1 else 'z'\n                \n                while ord(i) <= ord(j):\n                    nxt = ep\n                    while nxt > 0 and i != evil[nxt]:\n                        nxt = lps[nxt-1]\n                    \n                    res = umap[sp][ep][leftB][rightB] + dfs(sp+1, (nxt+1 if evil[nxt]==i else 0), (1 if (leftB==1 and i == s1[sp]) else 0), (1 if (rightB==1 and i == s2[sp]) else 0))\n                    umap[sp][ep][leftB][rightB] = res % MOD\n                    i = chr(ord(i)+1)\n            return umap[sp][ep][leftB][rightB]\n        \n        lps = computeLPS(evil)\n        return dfs(0, 0, 1, 1)\n", "import functools\n\n\nclass Solution:\n  def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n    def calc(k, char):\n      i = 0\n\n      while i <= k and not evil[i:k] + char == evil[:k - i + 1]:\n        i += 1\n\n      return k - i + 1\n\n    @functools.lru_cache(None)\n    def dp(i, k, limit_low, limit_high):\n      if k == len(evil):\n        return 0\n      if i == n:\n        return 1\n\n      ans = 0\n\n      min_char = s1[i] if limit_low else 'a'\n      max_char = s2[i] if limit_high else 'z'\n\n      for o in range(ord(min_char), ord(max_char) + 1):\n        curr = chr(o)\n\n        if curr == evil[k]:\n          ans += dp(i + 1, k + 1, limit_low and curr == min_char, limit_high and curr == max_char)\n        else:\n          ans += dp(i + 1, calc(k, curr), limit_low and curr == min_char, limit_high and curr == max_char)\n\n      return ans % (10 ** 9 + 7)\n\n    return dp(0, 0, True, True) % (10 ** 9 + 7)"]
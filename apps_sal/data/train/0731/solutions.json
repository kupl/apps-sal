["c,f=list(map(int,input().split()))\r\nl=[[1000001 for i in range(c)] for j in range(c)] \r\nwhile f:\r\n    x,y,cost=list(map(int,input().split()))\r\n    l[x-1][y-1]=cost\r\n    l[y-1][x-1]=cost\r\n    f-=1  \r\nfor i in range(c):\r\n    l[i][i]=0\r\nfor k in range(c): \r\n    for x in range(c):\r\n        for y in range(c): \r\n            if x==k or y==k or x==y:\r\n                continue\r\n            elif x!=y:\r\n                l[x][y]=min(l[x][y],l[x][k]+l[k][y]) \r\nm=-1 \r\nfor i in range(c):\r\n    for j in range(c):\r\n        if m<l[i][j]:\r\n            m=l[i][j]\r\nprint(m)\r\n    # cook your dish here\r\n", "I = int(10e15)\r\nc , f = [int(i) for i in input().split()]\r\narr = [[0 for i in range(c)] for j in range(c)] \r\n\r\nsdc = []\r\nfor x in range(f):\r\n    sdc.append( list(int(x) for x in input().split()))\r\n    \r\nfor i in sdc:\r\n    arr[i[0]-1][i[1]-1]=i[2]\r\n    arr[i[1]-1][i[0]-1]=i[2]\r\n    \r\nfor x in range(c):\r\n    for y in range(c):\r\n        if x != y :\r\n            if arr[x][y] == 0:\r\n                arr[x][y] = I\r\n\r\ndef f_w(v, arr):\r\n\tfor k in range(0, v):\r\n\t\tfor i in range(0, v):\r\n\t\t\tfor j in range(0, v):\r\n\t\t\t\tarr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j])\r\n\r\n\r\nf_w(c,arr)\r\nm = -1\r\nfor x in range(c):\r\n    m = max(m, max(arr[x]))\r\n           \r\nprint(m)", "c,f=list(map(int,input().split()))\nl=[[1000001 for i in range(c)] for j in range(c)] \nwhile f:\n    x,y,cost=list(map(int,input().split()))\n    l[x-1][y-1]=cost\n    l[y-1][x-1]=cost\n    f-=1  \nfor i in range(c):\n    l[i][i]=0\nfor k in range(c): \n    for x in range(c):\n        for y in range(c): \n            if x==k or y==k or x==y:\n                continue\n            elif x!=y:\n                l[x][y]=min(l[x][y],l[x][k]+l[k][y]) \nm=-1 \nfor i in range(c):\n    for j in range(c):\n        if m<l[i][j]:\n            m=l[i][j]\nprint(m)\n    # cook your dish here\n", "# cook your dish here\nc,f=list(map(int,input().split()))\nl=[[1000001 for i in range(c)] for j in range(c)] \nwhile f:\n    x,y,cost=list(map(int,input().split()))\n    l[x-1][y-1]=cost\n    l[y-1][x-1]=cost\n    f-=1  \nfor i in range(c):\n    l[i][i]=0\nfor k in range(c): \n    for x in range(c):\n        for y in range(c): \n            if x==k or y==k or x==y:\n                continue\n            elif x!=y:\n                l[x][y]=min(l[x][y],l[x][k]+l[k][y]) \nm=-1 \nfor i in range(c):\n    for j in range(c):\n        if m<l[i][j]:\n            m=l[i][j]\nprint(m)\n    \n", "c,f=list(map(int,input().split()))\nl=[[1000001 for i in range(c)] for j in range(c)] \nwhile f:\n    x,y,cost=list(map(int,input().split()))\n    l[x-1][y-1]=cost\n    l[y-1][x-1]=cost\n    f-=1  \nfor i in range(c):\n    l[i][i]=0\nfor k in range(c): \n    for x in range(c):\n        for y in range(c): \n            if x==k or y==k or x==y:\n                continue\n            elif x!=y:\n                l[x][y]=min(l[x][y],l[x][k]+l[k][y]) \nm=-1 \nfor i in range(c):\n    for j in range(c):\n        if m<l[i][j]:\n            m=l[i][j]\nprint(m)\n    \n", "c,f=list(map(int,input().split()))\nl=[[100001 for i in range(c)] for j in range(c)] \nwhile f:\n    x,y,cost=list(map(int,input().split()))\n    l[x-1][y-1]=cost\n    l[y-1][x-1]=cost\n    f-=1 \nfor k in range(c): \n    for x in range(c):\n        for y in range(c): \n            if x==k or y==k:\n                continue\n            elif x!=y:\n                l[x][y]=min(l[x][y],l[x][k]+l[k][y]) \n            else:\n                l[x][y]=0\nm=-1 \nfor i in range(c):\n    for j in range(c):\n        if m<l[i][j]:\n            m=l[i][j]\nprint(m)\n    \n", "c,f=list(map(int,input().split()))\nl=[[100000 for i in range(c)] for j in range(c)] \nwhile f:\n    x,y,cost=list(map(int,input().split()))\n    l[x-1][y-1]=cost\n    l[y-1][x-1]=cost\n    f-=1 \nfor k in range(c): \n    for x in range(c):\n        for y in range(c): \n            if x==k or y==k:\n                continue\n            elif x!=y:\n                l[x][y]=min(l[x][y],l[x][k]+l[k][y]) \n            else:\n                l[x][y]=0\nm=-1 \nfor i in range(c):\n    for j in range(c):\n        if m<l[i][j]:\n            m=l[i][j]\nprint(m)\n    \n", "c,f=list(map(int,input().split()))\nl=[[10000 for i in range(c)] for j in range(c)] \nwhile f:\n    x,y,cost=list(map(int,input().split()))\n    l[x-1][y-1]=cost\n    l[y-1][x-1]=cost\n    f-=1 \nfor k in range(c): \n    for x in range(c):\n        for y in range(c):\n            if x!=y:\n                l[x][y]=min(l[x][y],l[x][k]+l[k][y]) \n            else:\n                l[x][y]=0\nm=-1 \nfor i in range(c):\n    for j in range(c):\n        if m<l[i][j]:\n            m=l[i][j]\nprint(m)\n    \n", "# cook your dish here\nc,n=input().split()\nc,n=int(c),int(n)\na=[]\nfor i in range(c):\n    a.append([1000000]*c)\n        \nwhile(n>0):\n    n-=1 \n    x,y,p=input().split()\n    x,y,p=int(x)-1,int(y)-1,int(p)\n    a[x][y]=a[y][x]=p\n    \nfor k in range(c):\n    for i in range(c):\n        for j in range(c):\n            if(a[i][k]+a[k][j]<a[i][j]):\n                a[i][j]=a[i][k]+a[k][j]\n\nmx=0\n\nfor i in range(c):\n    for j in range(c):\n        if(i!=j and mx<a[i][j]):\n            mx=a[i][j]\n\n\nprint(mx)\n        \n        \n", "# cook your dish here\nc,n=input().split()\nc,n=int(c),int(n)\na=[]\nfor i in range(c):\n    a.append([1000000]*c)\n        \nwhile(n>0):\n    n-=1 \n    x,y,p=input().split()\n    x,y,p=int(x)-1,int(y)-1,int(p)\n    a[x][y]=a[y][x]=p\n    \nfor k in range(c):\n    for i in range(c):\n        for j in range(c):\n            if(a[i][k]+a[k][j]<a[i][j]):\n                a[i][j]=a[i][k]+a[k][j]\n\nmx=0\n\nfor i in range(c):\n    for j in range(c):\n        if(i!=j and mx<a[i][j]):\n            mx=a[i][j]\n\n\nprint(mx)\n        \n        \n", "# cook your dish here\nimport numpy as np\nimport sys\nimport heapq\n# class Graph(): \n  \n#     def __init__(self, vertices): \n#         self.V = vertices \n#         self.graph = [[0 for column in range(vertices)]  \n#                     for row in range(vertices)] \n  \n#     def minDistance(self, dist, sptSet, src): \n#         min = sys.maxsize\n#         min_index = -1\n#         for v in range(self.V): \n#             if dist[v] < min and sptSet[v] == False : \n#                 min = dist[v] \n#                 min_index = v \n  \n#         return min_index \n\n  \n#     def dijkstra(self, src): \n        \n#         # weights = self.graph[src]\n        \n#         # for i in range(self.V) :\n#         #     self.graph[src][i] = 0 \n#         #     self.graph[i][src] = 0\n            \n  \n#         dist = [sys.maxsize] * self.V \n#         dist[src] = 0\n#         sptSet = [False] * self.V \n  \n#         for cout in range(self.V): \n#             u = self.minDistance(dist, sptSet, src) \n#             if u == -1 : continue\n#             sptSet[u] = True\n#             for v in range(self.V): \n#                 if self.graph[u][v] > 0 and sptSet[v] == False and dist[v] > dist[u] + self.graph[u][v]: \n#                     dist[v] = dist[u] + self.graph[u][v] \n                    \n        \n#         # for i in range(self.V) :\n#         #     self.graph[src][i] = weights[i]\n#         #     self.graph[i][src] = weights[i]\n        \n#         dist.remove(0)\n#         MINIMUM = np.inf\n#         for idx in range(len(dist)):\n#             if idx != src and not self.graph[idx][src] and dist[idx] < MINIMUM : \n#                 MINIMUM = dist[idx]\n            \n#         return MINIMUM\n\n# def findCheapestPrice(n, flights, src , dst ) : \n#     graph = {}\n\n#     for u in range(n):\n#         graph[u] = []\n\n#     for u,v,w in flights:\n#         graph[u].append((v,w))\n\n#     heap = [(0,-n,src)]\n    \n\n#     while heap:\n#         (cost,i,u) = heapq.heappop(heap)\n\n#         if u == dst :\n#             return cost\n#             # if i >= n - 1 : continue\n#             # else:  return cost\n#             # if u not in list(zip(*graph[src]))[0] : return cost\n\n#         for v,w in graph[u]:\n#             nc = cost + w\n\n#             if i <= 0:\n#                 heapq.heappush(heap, (nc,i + 1,v))\n\n#     return -1\n\ndef eccentricities(graph, vertices):\n\tecc = []\n\tdist = floyd_warshall(graph, vertices)\n\t\n\tfor u in dist:\n\t\td = [dist[u][v] for v in dist[u] if dist[u][v] != INFINITY]\n\t\tif d: ecc.append(max(d))\n\t\t\n\treturn ecc\n\t\ndef floyd_warshall(graph, vertices):\n\tdist = {}\n\tfor u in vertices:\n\t\tdist[u] = {}\n\t\tfor v in vertices:\n\t\t\tdist[u][v] = INFINITY\n\t\n\t\t\t\n\tfor u in graph:\n\t\tdist[u][u] = 0\n\t\tfor v in graph[u]:\n\t\t\tdist[u][v[0]] = v[1]\n\t\n\tfor k in vertices:\n\t\tfor i in vertices:\n\t\t\tfor j in vertices:\n\t\t\t    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n\t\n\treturn dist\n\n\n  \n# MY SOLUTION = DIJKSTRA with at least 2 edges\nn, e = list(map(int, input().split()))\ngraph = {}\nfor _ in range(e):\n    u, v, w = list(map(int, input().split()))\n    u -= 1 \n    v -= 1\n    \n    if u in graph:\n            graph[u] += [[v, w]]\n    else:\n            graph[u] = [[v, w]]\n\n    if v in graph:\n            graph[v] += [[u, w]]\n    else:\n            graph[v] = [[u, w]]\n\nvertices = list(range(n))\n\nINFINITY = 10**9\necc = eccentricities(graph, vertices)\nradius = min(ecc)\ndiameter = max(ecc)\n\nprint(diameter)\n\n\n\n", "import numpy as np\nimport sys\nimport heapq\n# class Graph(): \n  \n#     def __init__(self, vertices): \n#         self.V = vertices \n#         self.graph = [[0 for column in range(vertices)]  \n#                     for row in range(vertices)] \n  \n#     def minDistance(self, dist, sptSet, src): \n#         min = sys.maxsize\n#         min_index = -1\n#         for v in range(self.V): \n#             if dist[v] < min and sptSet[v] == False : \n#                 min = dist[v] \n#                 min_index = v \n  \n#         return min_index \n\n  \n#     def dijkstra(self, src): \n        \n#         # weights = self.graph[src]\n        \n#         # for i in range(self.V) :\n#         #     self.graph[src][i] = 0 \n#         #     self.graph[i][src] = 0\n            \n  \n#         dist = [sys.maxsize] * self.V \n#         dist[src] = 0\n#         sptSet = [False] * self.V \n  \n#         for cout in range(self.V): \n#             u = self.minDistance(dist, sptSet, src) \n#             if u == -1 : continue\n#             sptSet[u] = True\n#             for v in range(self.V): \n#                 if self.graph[u][v] > 0 and sptSet[v] == False and dist[v] > dist[u] + self.graph[u][v]: \n#                     dist[v] = dist[u] + self.graph[u][v] \n                    \n        \n#         # for i in range(self.V) :\n#         #     self.graph[src][i] = weights[i]\n#         #     self.graph[i][src] = weights[i]\n        \n#         dist.remove(0)\n#         MINIMUM = np.inf\n#         for idx in range(len(dist)):\n#             if idx != src and not self.graph[idx][src] and dist[idx] < MINIMUM : \n#                 MINIMUM = dist[idx]\n            \n#         return MINIMUM\n\n# def findCheapestPrice(n, flights, src , dst ) : \n#     graph = {}\n\n#     for u in range(n):\n#         graph[u] = []\n\n#     for u,v,w in flights:\n#         graph[u].append((v,w))\n\n#     heap = [(0,-n,src)]\n    \n\n#     while heap:\n#         (cost,i,u) = heapq.heappop(heap)\n\n#         if u == dst :\n#             return cost\n#             # if i >= n - 1 : continue\n#             # else:  return cost\n#             # if u not in list(zip(*graph[src]))[0] : return cost\n\n#         for v,w in graph[u]:\n#             nc = cost + w\n\n#             if i <= 0:\n#                 heapq.heappush(heap, (nc,i + 1,v))\n\n#     return -1\n\ndef eccentricities(graph, vertices):\n\tecc = []\n\tdist = floyd_warshall(graph, vertices)\n\t\n\tfor u in dist:\n\t\td = [dist[u][v] for v in dist[u] if dist[u][v] != INFINITY]\n\t\tif d: ecc.append(max(d))\n\t\t\n\treturn ecc\n\t\ndef floyd_warshall(graph, vertices):\n\tdist = {}\n\tfor u in vertices:\n\t\tdist[u] = {}\n\t\tfor v in vertices:\n\t\t\tdist[u][v] = INFINITY\n\t\n\t\t\t\n\tfor u in graph:\n\t\tdist[u][u] = 0\n\t\tfor v in graph[u]:\n\t\t\tdist[u][v[0]] = v[1]\n\t\n\tfor k in vertices:\n\t\tfor i in vertices:\n\t\t\tfor j in vertices:\n\t\t\t    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n\t\n\treturn dist\n\n\n  \n# MY SOLUTION = DIJKSTRA with at least 2 edges\nn, e = list(map(int, input().split()))\ngraph = {}\nfor _ in range(e):\n    u, v, w = list(map(int, input().split()))\n    u -= 1 \n    v -= 1\n    \n    if u in graph:\n            graph[u] += [[v, w]]\n    else:\n            graph[u] = [[v, w]]\n\n    if v in graph:\n            graph[v] += [[u, w]]\n    else:\n            graph[v] = [[u, w]]\n\nvertices = list(range(n))\n\nINFINITY = 10**9\necc = eccentricities(graph, vertices)\nradius = min(ecc)\ndiameter = max(ecc)\n\nprint(diameter)\n\n\n\n", "import numpy as np\nimport sys\nimport heapq\n# class Graph(): \n  \n#     def __init__(self, vertices): \n#         self.V = vertices \n#         self.graph = [[0 for column in range(vertices)]  \n#                     for row in range(vertices)] \n  \n#     def minDistance(self, dist, sptSet, src): \n#         min = sys.maxsize\n#         min_index = -1\n#         for v in range(self.V): \n#             if dist[v] < min and sptSet[v] == False : \n#                 min = dist[v] \n#                 min_index = v \n  \n#         return min_index \n\n  \n#     def dijkstra(self, src): \n        \n#         # weights = self.graph[src]\n        \n#         # for i in range(self.V) :\n#         #     self.graph[src][i] = 0 \n#         #     self.graph[i][src] = 0\n            \n  \n#         dist = [sys.maxsize] * self.V \n#         dist[src] = 0\n#         sptSet = [False] * self.V \n  \n#         for cout in range(self.V): \n#             u = self.minDistance(dist, sptSet, src) \n#             if u == -1 : continue\n#             sptSet[u] = True\n#             for v in range(self.V): \n#                 if self.graph[u][v] > 0 and sptSet[v] == False and dist[v] > dist[u] + self.graph[u][v]: \n#                     dist[v] = dist[u] + self.graph[u][v] \n                    \n        \n#         # for i in range(self.V) :\n#         #     self.graph[src][i] = weights[i]\n#         #     self.graph[i][src] = weights[i]\n        \n#         dist.remove(0)\n#         MINIMUM = np.inf\n#         for idx in range(len(dist)):\n#             if idx != src and not self.graph[idx][src] and dist[idx] < MINIMUM : \n#                 MINIMUM = dist[idx]\n            \n#         return MINIMUM\n\n# def findCheapestPrice(n, flights, src , dst ) : \n#     graph = {}\n\n#     for u in range(n):\n#         graph[u] = []\n\n#     for u,v,w in flights:\n#         graph[u].append((v,w))\n\n#     heap = [(0,-n,src)]\n    \n\n#     while heap:\n#         (cost,i,u) = heapq.heappop(heap)\n\n#         if u == dst :\n#             return cost\n#             # if i >= n - 1 : continue\n#             # else:  return cost\n#             # if u not in list(zip(*graph[src]))[0] : return cost\n\n#         for v,w in graph[u]:\n#             nc = cost + w\n\n#             if i <= 0:\n#                 heapq.heappush(heap, (nc,i + 1,v))\n\n#     return -1\n\ndef eccentricities(graph, vertices):\n\tecc = []\n\tdist = floyd_warshall(graph, vertices)\n\t\n\tfor u in dist:\n\t\td = [dist[u][v] for v in dist[u] if dist[u][v] != INFINITY]\n\t\tif d: ecc.append(max(d))\n\t\t\n\treturn ecc\n\t\ndef floyd_warshall(graph, vertices):\n\tdist = {}\n\tfor u in vertices:\n\t\tdist[u] = {}\n\t\tfor v in vertices:\n\t\t\tdist[u][v] = INFINITY\n\t\n\t\t\t\n\tfor u in graph:\n\t\tdist[u][u] = 0\n\t\tfor v in graph[u]:\n\t\t\tdist[u][v[0]] = v[1]\n\t\n\tfor k in vertices:\n\t\tfor i in vertices:\n\t\t\tfor j in vertices:\n\t\t\t\tif dist[i][j] >= dist[i][k] + dist[k][j]:\n\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j]\n\t\n\treturn dist\n\n\n  \n# MY SOLUTION = DIJKSTRA with at least 2 edges\nn, e = list(map(int, input().split()))\ngraph = {}\nfor _ in range(e):\n    u, v, w = list(map(int, input().split()))\n    u -= 1 \n    v -= 1\n    \n    if u in graph:\n            graph[u] += [[v, w]]\n    else:\n            graph[u] = [[v, w]]\n\n    if v in graph:\n            graph[v] += [[u, w]]\n    else:\n            graph[v] = [[u, w]]\n\nvertices = list(range(n))\n\nINFINITY = 100000\necc = eccentricities(graph, vertices)\nradius = min(ecc)\ndiameter = max(ecc)\n\nprint(diameter)\n\n\n\n", "import numpy as np\nimport sys\nimport heapq\n# class Graph(): \n  \n#     def __init__(self, vertices): \n#         self.V = vertices \n#         self.graph = [[0 for column in range(vertices)]  \n#                     for row in range(vertices)] \n  \n#     def minDistance(self, dist, sptSet, src): \n#         min = sys.maxsize\n#         min_index = -1\n#         for v in range(self.V): \n#             if dist[v] < min and sptSet[v] == False : \n#                 min = dist[v] \n#                 min_index = v \n  \n#         return min_index \n\n  \n#     def dijkstra(self, src): \n        \n#         # weights = self.graph[src]\n        \n#         # for i in range(self.V) :\n#         #     self.graph[src][i] = 0 \n#         #     self.graph[i][src] = 0\n            \n  \n#         dist = [sys.maxsize] * self.V \n#         dist[src] = 0\n#         sptSet = [False] * self.V \n  \n#         for cout in range(self.V): \n#             u = self.minDistance(dist, sptSet, src) \n#             if u == -1 : continue\n#             sptSet[u] = True\n#             for v in range(self.V): \n#                 if self.graph[u][v] > 0 and sptSet[v] == False and dist[v] > dist[u] + self.graph[u][v]: \n#                     dist[v] = dist[u] + self.graph[u][v] \n                    \n        \n#         # for i in range(self.V) :\n#         #     self.graph[src][i] = weights[i]\n#         #     self.graph[i][src] = weights[i]\n        \n#         dist.remove(0)\n#         MINIMUM = np.inf\n#         for idx in range(len(dist)):\n#             if idx != src and not self.graph[idx][src] and dist[idx] < MINIMUM : \n#                 MINIMUM = dist[idx]\n            \n#         return MINIMUM\n\n# def findCheapestPrice(n, flights, src , dst ) : \n#     graph = {}\n\n#     for u in range(n):\n#         graph[u] = []\n\n#     for u,v,w in flights:\n#         graph[u].append((v,w))\n\n#     heap = [(0,-n,src)]\n    \n\n#     while heap:\n#         (cost,i,u) = heapq.heappop(heap)\n\n#         if u == dst :\n#             return cost\n#             # if i >= n - 1 : continue\n#             # else:  return cost\n#             # if u not in list(zip(*graph[src]))[0] : return cost\n\n#         for v,w in graph[u]:\n#             nc = cost + w\n\n#             if i <= 0:\n#                 heapq.heappush(heap, (nc,i + 1,v))\n\n#     return -1\n\ndef eccentricities(graph, vertices):\n\tecc = []\n\tdist = floyd_warshall(graph, vertices)\n\t\n\tfor u in dist:\n\t\td = [dist[u][v] for v in dist[u] if dist[u][v] != INFINITY]\n\t\tif d: ecc.append(max(d))\n\t\t\n\treturn ecc\n\t\ndef floyd_warshall(graph, vertices):\n\tdist = {}\n\tfor u in vertices:\n\t\tdist[u] = {}\n\t\tfor v in vertices:\n\t\t\tdist[u][v] = INFINITY\n\t\n\t\t\t\n\tfor u in graph:\n\t\tdist[u][u] = 0\n\t\tfor v in graph[u]:\n\t\t\tdist[u][v[0]] = v[1]\n\t\n\tfor k in vertices:\n\t\tfor i in vertices:\n\t\t\tfor j in vertices:\n\t\t\t\tif dist[i][j] > dist[i][k] + dist[k][j]:\n\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j]\n\t\n\treturn dist\n\n\n  \n# MY SOLUTION = DIJKSTRA with at least 2 edges\nn, e = list(map(int, input().split()))\ngraph = {}\nfor _ in range(e):\n    u, v, w = list(map(int, input().split()))\n    u -= 1 \n    v -= 1\n    \n    if u in graph:\n            graph[u] += [[v, w]]\n    else:\n            graph[u] = [[v, w]]\n\n    if v in graph:\n            graph[v] += [[u, w]]\n    else:\n            graph[v] = [[u, w]]\n\nvertices = list(range(n))\n\nINFINITY = 100000\necc = eccentricities(graph, vertices)\nradius = min(ecc)\ndiameter = max(ecc)\n\nprint(diameter)\n\n\n\n", "# cook your dish here\nMAX = 10**9\nc, f = list(map(int, input().split()))\nd = []\nfor i in range(c):\n    d.append([-1 for j in range(c)])\n\nfor i in range(f):\n    x, y, p = list(map(int, input().split()))\n    d[x-1][y-1] = p\n    d[y-1][x-1] = p\n\nfor i in range(c):\n    for j in range(c):\n        if i == j:\n            d[i][j] = 0\n        elif d[i][j] == -1:\n            d[i][j] = MAX\nfor k in range(c):\n    for i in range(c):\n        for j in range(c):\n            d[i][j] = min(d[i][j], (d[i][k] + d[k][j]))\np = 0\nfor i in range(c):\n    for j in range(c):\n        p = max(d[i][j], p)\nprint(p)\n", "MAX = 999999\r\nc, f = list(map(int, input().split()))\r\nd = []\r\nfor i in range(c):\r\n    d.append([-1 for j in range(c)] )\r\n\r\nfor i in range(f):\r\n    x, y, p = list(map(int, input().split()))\r\n    d[x-1][y-1] = p\r\n    d[y-1][x-1] = p\r\n\r\nfor i in range(c):\r\n    for j in range(c):\r\n        if i == j:\r\n            d[i][j] = 0\r\n        elif d[i][j] == -1:\r\n            d[i][j] = MAX\r\n\r\nfor w in range(c):\r\n    for i in range(c):\r\n        for j in range(c):\r\n            d[i][j] = min(d[i][j], (d[i][w] + d[w][j]))\r\n\r\np = 0\r\nfor i in range(c):\r\n    for j in range(c):\r\n        p = max(d[i][j], p)\r\n\r\nprint(p)\r\n\r\n\r\n\r\n", "MAX = 10**9\nc, f = map(int, input().split())\nd = []\nfor i in range(c):\n    d.append([-1 for j in range(c)])\n\nfor i in range(f):\n    x, y, p = map(int, input().split())\n    d[x-1][y-1] = p\n    d[y-1][x-1] = p\n\nfor i in range(c):\n    for j in range(c):\n        if i == j:\n            d[i][j] = 0\n        elif d[i][j] == -1:\n            d[i][j] = MAX\nfor k in range(c):\n    for i in range(c):\n        for j in range(c):\n            d[i][j] = min(d[i][j], (d[i][k] + d[k][j]))\np = 0\nfor i in range(c):\n    for j in range(c):\n        p = max(d[i][j], p)\nprint(p)", "MAX = 10**5\nc, f = map(int, input().split())\nd = []\nfor i in range(c):\n    d.append([-1 for j in range(c)])\n\nfor i in range(f):\n    x, y, p = map(int, input().split())\n    d[x-1][y-1] = p\n    d[y-1][x-1] = p\n\nfor i in range(c):\n    for j in range(c):\n        if i == j:\n            d[i][j] = 0\n        elif d[i][j] == -1:\n            d[i][j] = MAX\nfor k in range(c):\n    for i in range(c):\n        for j in range(c):\n            d[i][j] = min(d[i][j], (d[i][k] + d[k][j]))\np = 0\nfor i in range(c):\n    for j in range(c):\n        p = max(d[i][j], p)\nprint(p)", "try:\r\n    MAX=10**9\r\n    a, b=list(map(int, input().split()))\r\n    c=[]\r\n    for i in range(a):\r\n     c.append([-1 for j in range(a)])\r\n     \r\n    for j in range(b):\r\n     d, e, p=[int(i) for i in input().split()]\r\n     c[d-1][e-1]=p\r\n     c[e-1][d-1]=p\r\n    for i in range(a):\r\n     for j in range(a):\r\n         if i==j:\r\n            c[i][j]=0\r\n         elif c[i][j] == -1:\r\n            c[i][j]=MAX\r\n    for k in range(a):\r\n     for i in range(a):\r\n        for j in range(a):\r\n            c[i][j]=min(c[i][j], (c[i][k]+c[k][j]))\r\n\r\n    p=0\r\n    for i in range(a):\r\n     for j in range(a):\r\n        p=max(c[i][j], p)\r\n    print(p)\r\nexcept Exception:\r\n    pass\r\n", "# cook your dish here\nMAX = 10**9\nc, f = map(int, input().split())\ng = []\nfor i in range(c):\n    g.append([-1 for j in range(c)])\n\nfor i in range(f):\n    x, y, p = map(int, input().split())\n    g[x-1][y-1] = p\n    g[y-1][x-1] = p\n\nfor i in range(c):\n    for j in range(c):\n        if i == j:\n            g[i][j] = 0\n        elif g[i][j] == -1:\n            g[i][j] = MAX\nfor k in range(c):\n    for i in range(c):\n        for j in range(c):\n            g[i][j] = min(g[i][j], (g[i][k] + g[k][j]))\np = 0\nfor i in range(c):\n    for j in range(c):\n        p = max(g[i][j], p)\nprint(p)", "# cook your dish here\nc, f = map(int, input().split())\ndist=[[float('Inf') for _ in range(c)] for _ in range(c)]\nfor _ in range(f):\n    u, v, p = map(int, input().split())\n    u-=1 \n    v-=1\n    dist[u][v]=p \n    dist[v][u]=p \nfor i in range(c):\n    dist[i][i]=0\nfor k in range(c):\n    for i in range(c):\n        for j in range(c):\n            if dist[i][j] > dist[i][k] + dist[k][j] :\n                dist[i][j] = dist[i][k] + dist[k][j]\nmassimo=0\nfor i in range(c):\n    massimo=max(massimo, max(dist[i]))\nprint(massimo)", "a=input().split()\r\nc,f=int(a[0]), int(a[1])\r\nmindistance=[[float('inf') for i in range(c)] for i in range(c)]\r\n\r\nfor corner in range(c):\r\n    mindistance[corner][corner]=0\r\n\r\nfor i in range(f):\r\n    a=input().split()\r\n    x, y, p = int(a[0])-1, int(a[1])-1, int(a[2])\r\n    mindistance[x][y]=p\r\n    mindistance[y][x]=p\r\n    \r\nfor i in range(c):\r\n    for j in range(c):\r\n        for k in range(c):\r\n            if mindistance[i][k]!=float('inf') and mindistance[j][i]!=float('inf'):\r\n                if mindistance[j][k]>mindistance[j][i]+mindistance[i][k]:\r\n                    mindistance[j][k]=mindistance[j][i]+mindistance[i][k]\r\n\r\nmincost = -float('inf')\r\nfor i in mindistance:\r\n    if mincost<max(i):\r\n        mincost=max(i)\r\nprint(mincost)", "def floyd_warshall(graph, N):\r\n    dist = [[float('inf')] * (N + 1) for i in range(N + 1)]\r\n    for u in graph:\r\n        dist[u][u] = 0\r\n        for v in graph[u]:\r\n            dist[u][v] = graph[u][v]\r\n    for k in range(1, N + 1):\r\n        for i in range(1, N + 1):\r\n            for j in range(1, N + 1):\r\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\r\n    return dist\r\n\r\ndef solve(C, F, cost):\r\n    dist = floyd_warshall(cost, C)\r\n    maximum = 0\r\n    for i in range(1, C + 1):\r\n        for j in range(1, C + 1):\r\n            maximum = max(maximum, dist[i][j])\r\n    return maximum\r\n\r\ndef __starting_point():\r\n    C, F = list(map(int, input().strip().split()))\r\n    cost = {i:{} for i in range(1, C + 1)}\r\n    for flight in range(1, F + 1):\r\n        x, y, p = list(map(int, input().strip().split()))\r\n        cost[x][y] = p\r\n        cost[y][x] = p\r\n    print(solve(C, F, cost))\r\n\n__starting_point()"]
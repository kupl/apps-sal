["import sys\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nt=int(input())\nfor testcaess in range(t):\n    n,m,a,b=list(map(int,input().split()))\n    E=[[] for i in range(n+1)]\n\n    for i in range(m):\n        x,y=list(map(int,input().split()))\n        E[x].append(y)\n        E[y].append(x)\n\n    USE1=[0]*(n+1)\n\n    Q=deque()\n    Q.append(a)\n\n    USE1[a]=1\n\n    while Q:\n        x=Q.pop()\n\n        for to in E[x]:\n            if to==b:\n                continue\n            if USE1[to]==0:\n                USE1[to]=1\n                Q.append(to)\n\n    USE2=[0]*(n+1)\n\n    Q=deque()\n    Q.append(b)\n\n    USE2[b]=1\n\n    while Q:\n        x=Q.pop()\n\n        for to in E[x]:\n            if to==a:\n                continue\n            if USE2[to]==0:\n                USE2[to]=1\n                Q.append(to)\n\n    #print(USE1,USE2)\n\n    ANS1=0\n    ANS2=0\n\n    for i in range(n+1):\n        if i==a or i==b:\n            continue\n        if USE1[i]==1 and USE2[i]==0:\n            ANS1+=1\n        elif USE1[i]==0 and USE2[i]==1:\n            ANS2+=1\n\n    print(ANS1*ANS2)\n        \n\n    \n\n    \n", "import sys\nreadline = sys.stdin.readline\n\ndef dfs(s, t, Edge):\n    N = len(Edge)\n    used = [0]*N\n    used[s] = 1\n    used[t] = 1\n    stack = [s]\n    while stack:\n        vn = stack.pop()\n        for vf in Edge[vn]:\n            if not used[vf]:\n                used[vf] = 1\n                stack.append(vf)\n    return used\n\nT = int(readline())\nAns = [None]*T\nfor qu in range(T): \n    N, M, A, B = map(int, readline().split())\n    A -= 1\n    B -= 1\n    Edge = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, readline().split())\n        a -= 1\n        b -= 1\n        Edge[a].append(b)\n        Edge[b].append(a)\n    sa = dfs(A, B, Edge)\n    sb = dfs(B, A, Edge)\n    ca = 0\n    cb = 0\n    for fa, fb in zip(sa, sb):\n        if fa == fb:\n            continue\n        if fa:\n            ca += 1\n        elif fb:\n            cb += 1\n    Ans[qu] = ca*cb\nprint('\\n'.join(map(str, Ans)))", "\nfrom collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nclass UnionFind:\n    def __init__(self,N): # \u9802\u70b9\u6570 N\n        self.table = [i for i in range(N)]    # \u89aa table[x] == x \u3067\u6839\n        self.rank  = [1 for i in range(N)]    # \u6728\u306e\u9577\u3055\n        self.size  = [1 for i in range(N)]    # \u96c6\u5408\u306e\u30b5\u30a4\u30ba\n\n    def Find(self,x):    #x\u306e\u6839\u3092\u8fd4\u3059\n        if self.table[x] == x:\n            return x\n        else:\n            self.table[x] = self.Find(self.table[x]) #\u89aa\u306e\u66f4\u65b0\n            self.size[x] = self.size[self.table[x]]\n            return self.table[x]\n\n    def Unite(self,x,y):\n        x,y = self.Find(x), self.Find(y)\n        sx,sy = self.Size(x), self.Size(y)\n        if x == y: return\n        if self.rank[x] > self.rank[y]:\n            self.table[y] = x\n            self.size[x] = sx + sy\n        else:\n            self.table[x] = y\n            self.size[y] = sx + sy\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def Check(self,x,y):\n        return self.Find(x) == self.Find(y)\n\n    def Size(self,x):\n        return self.size[self.Find(x)]\n\n\nfor _ in range(inp()):\n    N,M,a,b = inpl()\n    a -= 1; b -= 1\n    a,b = min(a,b), max(a,b)\n    UF = UnionFind(N)\n    alines = []\n    blines = []\n    for _ in range(M):\n        s,t = inpl()\n        s-=1 ; t-=1\n        s,t = min(s,t), max(s,t)\n        if s == a and t == b: continue\n        elif s == a: alines.append(t)\n        elif t == a: alines.append(s)\n        elif s == b: blines.append(t)\n        elif t == b: blines.append(s)\n        else:\n            UF.Unite(s,t)\n\n    aconnects = set()\n    acnts = [0]*N\n    bcnts = [0]*N\n\n    for a in alines:\n        r = UF.Find(a)\n        aconnects.add(r)\n        acnts[r] = UF.Size(r)\n\n    for b in blines:\n        r = UF.Find(b)\n        if r in aconnects:\n            acnts[r] = 0\n        else:\n            bcnts[r] = UF.Size(r)\n\n    print(sum(acnts) * sum(bcnts))\n"]
["class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if n==2:return 1\n         if n==3:return 2\n         res=1\n         while n>4:\n             n=n-3\n             res*=3\n         return res*n\n", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         \n         import math\n         if n == 2 or n == 3:\n             return n-1\n         else:\n             if n % 3 == 1:\n                 m1 = 2           \n             elif n % 3 == 2:\n                 m1 = 1\n             else:\n                 m1 = 0\n             m2 = (n-2*m1) // 3\n             return 2**m1 * 3**m2\n         \n         \n         # import math\n         # if n == 2 or n == 3:\n         #     return n - 1\n         # else:\n         #     x = n/math.e\n         #     ans = 0\n         #     for y in [math.floor(x), math.ceil(x)]:\n         #         x1 = int(n/y)\n         #         x2 = x1 + 1\n         #         n2 = n - x1*y\n         #         n1 = y - n2\n         #         ans = max(ans, (x1**n1) * (x2**n2))\n         #     return int(ans)\n", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         memo = [0] * (n+1)\n         memo[0] = 0\n         memo[1] = 1\n         \n         for i in range(2, n+1):\n             maxprod = 1\n             for j in range(1, i):\n                 maxprod = max(maxprod, max(j, memo[j]) * max((i-j), memo[i-j]))\n             memo[i] = maxprod\n                 \n         return memo[n]\n", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         res = []\n         for i in range(n+1):\n             res.append(-1)\n         \n         for i in range(n+1):\n             for j in range(i):\n                 res[j] = max(j, res[j])\n                 res[i] = max(res[i], res[j]*(i-j))\n         \n         return res[n]", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         dp = [0 for i in range(n+1)]\n         dp[1] = 1\n         # for i in range(1, n+1):\n             # for j in range(1, n+1):\n         for i in range(2, n+1):\n             for j in range(1, i):\n                 dp[i] = max(max(dp[j],j) * max(dp[i-j], i-j), dp[i])\n         return dp[-1]", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         https://leetcode.com/problems/integer-break/discuss/80689/A-simple-explanation-of-the-math-part-and-a-O(n)-solution\n         use 3 as many as possible\n         \"\"\"\n         if n < 4:\n             return n - 1\n         ans = 1\n         while n > 4:\n             ans *= 3\n             n -= 3\n         ans *= n\n         return ans\n", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         ans = [1] * (n+1)\n         for i in range(2, n+1):\n             ans[i] = ans[i-1]\n             for j in range(1, 10):\n                 if i-j > 0 and ans[i-j] * j > ans[i]:\n                     ans[i] = ans[i-j] * j\n                 if i < n:\n                     ans[i] = max(ans[i], i)\n         return ans[n]\n             \n", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         ans = [1] * (n+1)\n         for i in range(2, n+1):\n             ans[i] = ans[i-1]\n             for j in range(1, 10):\n                 if i-j > 0 and ans[i-j] * j > ans[i]:\n                     ans[i] = ans[i-j] * j\n                 if i < n: # \u5173\u952e\u662f\u8fd9\u4e00\u6b65, \u5982\u679c\u4e0d\u7b49\u4e8e\u548c, \u90a3\u4e48\u53ef\u4ee5\u4e0d\u62c6\u5206\n                     ans[i] = max(ans[i], i)\n         return ans[n]\n", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         memo = [0] * (59)\n         memo[1] = 1\n         if n == 2:\n             return 1\n         if n == 3:\n             return 2\n         for i in range(2, n + 1):\n             tmp = []\n             for j in range(1, i):\n                 memo[i] = max(i, memo[i], (memo[j] * memo[i - j]))\n         return memo[n]\n", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         dp = [0 for _ in range(n+1)]\n         dp[1] = 1\n         for i in range(1, n+1):\n             for j in range(1, i):\n                 dp[i] = max(max(dp[j],j) * max(i-j, dp[i-j]), dp[i])\n         return dp[-1]", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         memo = [0] * (59)\n         memo[1] = 1\n         for i in range(2, n + 1):\n             tmp = []\n             for j in range(1, i):\n                 memo[i] = max((memo[i], max(memo[j], j) * max(i-j,memo[i - j])))\n         return memo[n]\n", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if n <= 3: return n - 1\n         if n == 4: return 4\n         if n > 4:\n             if n%3 ==0 : return 3 ** int(n/3)\n             if n%3 !=0 and (n-2)%3 ==0:  return (3 ** int((n-2)/3)) *2\n             else: return (3 ** int((n-2)/3)) * 4\n", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if n==2: return 1;\n         if n==3: return 2;\n         \n         prod = 1\n         \n         while n > 4:\n             prod *= 3\n             n-=3\n         \n         prod *= n\n         \n         return prod\n", "class Solution:\n     def integerBreak(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if n < 4:\n             return n - 1\n \n         #  Proof.\n         #  1. Let n = a1 + a2 + ... + ak, product = a1 * a2 * ... * ak\n         #      - For each ai >= 4, we can always maximize the product by:\n         #        ai <= 2 * (ai - 2)\n         #      - For each aj >= 5, we can always maximize the product by:\n         #        aj <= 3 * (aj - 3)\n         #  \n         #     Conclusion 1:\n         #      - For n >= 4, the max of the product must be in the form of\n         #        3^a * 2^b, s.t. 3a + 2b = n\n         # \n         #  2. To maximize the product = 3^a * 2^b s.t. 3a + 2b = n\n         #      - For each b >= 3, we can always maximize the product by:\n         #        3^a * 2^b <= 3^(a+2) * 2^(b-3) s.t. 3(a+2) + 2(b-3) = n\n         # \n         #     Conclusion 2:\n         #      - For n >= 4, the max of the product must be in the form of\n         #        3^Q * 2^R, 0 <= R < 3 s.t. 3Q + 2R = n\n         #        i.e.\n         #          if n = 3Q + 0,   the max of the product = 3^Q * 2^0\n         #          if n = 3Q + 2,   the max of the product = 3^Q * 2^1\n         #          if n = 3Q + 2*2, the max of the product = 3^Q * 2^2\n \n         res = 0\n         if n % 3 == 0:            #  n = 3Q + 0, the max is 3^Q * 2^0\n             res = 3 ** (n // 3)\n         elif n % 3 == 2:          #  n = 3Q + 2, the max is 3^Q * 2^1\n             res = 3 ** (n // 3) * 2\n         else:                     #  n = 3Q + 4, the max is 3^Q * 2^2\n             res = 3 ** (n // 3 - 1) * 4\n         return res   \n"]
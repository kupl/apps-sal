["# cook your dish here\nfor _ in range(int(input())):\n    n=int(input())\n    if n==1:\n        print(\"0\")\n    else:\n        s=[]\n        for i in range(n):\n            s.append(str(i))\n        print(''.join(s))\n        p=1\n        for i in range(n-1):\n            s.pop(n-1)\n            s=[str(p)]+s\n            print(''.join(s))\n            p+=1\n", "from sys import stdin, stdout, maxsize\nfrom math import sqrt, log, factorial, gcd\nfrom collections import defaultdict as D\nfrom bisect import insort\n\nfor _ in range(int(input())):\n    n = int(input()) - 1\n    for i in range(n, -1, -1):\n        for j in range(n - i, 0, -1): print(j, end = '')\n        for j in range(i + 1): print(j, end = '')\n        print()", "import sys\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\ninp = lambda: list(map(int,sys.stdin.readline().rstrip(\"\\r\\n\").split()))\r\n#______________________________________________________________________________________________________\r\n# from math import *\r\n# from bisect import *\r\n# from heapq import *\r\n# from collections import defaultdict as dd\r\n# from collections import OrderedDict as odict\r\nfrom collections import Counter as cc\r\n# from collections import deque\r\n# sys.setrecursionlimit(2*(10**5)+100) this is must for dfs\r\nmod = 10**9+7; md = 998244353\r\n# ______________________________________________________________________________________________________\r\n# segment tree for range minimum query\r\n# sys.setrecursionlimit(10**5)\r\n# n = int(input())\r\n# a = list(map(int,input().split()))\r\n# st = [float('inf') for i in range(4*len(a))]\r\n# def build(a,ind,start,end):\r\n# \tif start == end:\r\n# \t\tst[ind] = a[start]\r\n# \telse:\r\n# \t\tmid = (start+end)//2\r\n# \t\tbuild(a,2*ind+1,start,mid)\r\n# \t\tbuild(a,2*ind+2,mid+1,end)\r\n# \t\tst[ind] = min(st[2*ind+1],st[2*ind+2])\r\n# build(a,0,0,n-1)\r\n# def query(ind,l,r,start,end):\r\n# \tif start>r or end<l:\r\n# \t\treturn float('inf')\r\n# \tif l<=start<=end<=r:\r\n# \t\treturn st[ind]\r\n# \tmid = (start+end)//2\r\n# \treturn min(query(2*ind+1,l,r,start,mid),query(2*ind+2,l,r,mid+1,end))\r\n# ______________________________________________________________________________________________________\r\n# Checking prime in O(root(N))\r\n# def isprime(n):\r\n#     if (n % 2 == 0 and n > 2) or n == 1: return 0\r\n#     else:\r\n#         s = int(n**(0.5)) + 1\r\n#         for i in range(3, s, 2):\r\n#             if n % i == 0:\r\n#                 return 0\r\n#         return 1\r\n# def lcm(a,b):\r\n#   return (a*b)//gcd(a,b)\r\n# ______________________________________________________________________________________________________\r\n# nCr under mod\r\n# def C(n,r,mod):\r\n#   if r>n:\r\n#       return 0\r\n#   num = den = 1\r\n#   for i in range(r):\r\n#       num = (num*(n-i))%mod\r\n#       den = (den*(i+1))%mod\r\n#   return (num*pow(den,mod-2,mod))%mod\r\n# M = 10**5 +10\r\n# ______________________________________________________________________________________________________\r\n# For smallest prime factor of a number\r\n# M = 1000010\r\n# pfc = [i for i in range(M)]\r\n# def pfcs(M):\r\n#   for i in range(2,M):\r\n#       if pfc[i]==i:\r\n#           for j in range(i+i,M,i):\r\n#               if pfc[j]==j:\r\n#                   pfc[j] = i\r\n#   return\r\n# pfcs(M)\r\n# ______________________________________________________________________________________________________\r\ntc = 1\r\ntc, = inp()\r\nfor _ in range(tc):\r\n\tn, = inp()\r\n\ta = [[0 for i in range(n)] for j in range(n)]\r\n\tfor i in range(n):\r\n\t\tfor j in range(i+1,n):\r\n\t\t\ta[i][j] = a[i][j-1]+1\r\n\t\tfor j in range(i-1,-1,-1):\r\n\t\t\ta[i][j] = a[i][j+1]+1\r\n\tfor i in a:\r\n\t\tprint(*i,sep = \"\")", "for _ in range(int(input())):\r\n    n = int(input())\r\n\r\n    l = list(range(n))\r\n\r\n    for i in range(n):\r\n        print(*l, sep='')\r\n\r\n        for j in range(i+1):\r\n            l[j] += 1\r\n\r\n        for j in range(i+1, n):\r\n            l[j] -= 1\r\n", "from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nmod = pow(10, 9) + 7\nmod2 = 998244353\ndef inp(): return stdin.readline().strip()\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)//b\n\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n\nfor _ in range(int(inp())):\n    n = int(inp())\n    for i in range(n):\n        for j in range(n):\n            print(abs(i-j), end=\"\")\n        print()"]
["def hull_method(points):\n    sorted_points = sorted(points)\n    return half_hull(sorted_points) + half_hull(reversed(sorted_points))\n\ndef half_hull(sorted_points):\n    hull = []\n    for p in sorted_points:\n        while len(hull) > 1 and not is_ccw_turn(hull[-2], hull[-1], p):\n            hull.pop()\n        hull.append(p)\n    hull.pop()\n    return hull\n\ndef is_ccw_turn(p0, p1, p2):\n    return (p1[0] - p0[0]) * (p2[1] - p0[1]) - (p2[0] - p0[0]) * (p1[1] - p0[1]) > 0\n", "def get_direction(a, b, c, d, e, f):\n    x1, y1 = c - a, d - b\n    x2, y2 = e - a, f - b\n    return x1 * y2 - x2 * y1\n    \ndef get_distance(a, b, c, d):\n    return (abs(c - a) ** 2 + abs(d - b) ** 2) ** .5\n        \ndef hull_method(points):\n    index = points.index( min(points))\n    length, border, track = len(points), [], index\n\n    while True:\n        nxt = (track + 1) % length\n    \n        for i in range(length):\n            if i != track:\n                d = get_direction(*points[track], *points[i], *points[nxt])\n                if d > 0 or (d == 0 and get_distance(*points[track], *points[i]) > get_distance(*points[track], *points[nxt])) : nxt = i\n        track = nxt\n        border.append(points[track])\n        if track == index : break\n    \n    return sorted(border)", "import math\n\n\n# Check for left turns in constant time\ndef is_ccw_turn(p0, p1, p2):\n    return (p1[0] - p0[0]) * (p2[1] - p0[1]) - (p2[0] - p0[0]) * (p1[1] - p0[1]) > 0\n\n\n\"\"\"\nIteratively generate a hull by finding items with the maximum distance from the current hull, adding them, and repeating.\nCurrently very inefficient.\n\"\"\"\ndef quickhull(points):\n    \n    def dist(a, b, c):\n        A = b[1]-a[1]\n        B = a[0]-b[0]\n        C = a[1]*b[0]-a[0]*b[1]\n        return abs(A*c[0]+B*c[1]+C)\n    \n    def triangle_area(a, b, c):\n        return a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])\n    \n    def quickhull_recurse(a, b, targets, indent=1):\n        # Remove colinear points\n        targets = [p for p in targets if dist(a, b, p) != 0]\n        # If no targets exist, be done\n        if len(targets) == 0:\n            return []\n        max_dist = max([dist(a, b, p) for p in targets])\n        m = min([p for p in targets if dist(a, b, p) == max_dist])\n        l_targets = quickhull_recurse(a, m, [p for p in targets if not is_ccw_turn(m, a, p)], indent+1)\n        r_targets = quickhull_recurse(m, b, [p for p in targets if not is_ccw_turn(b, m, p)], indent+1)\n        return l_targets + [m] + r_targets\n    \n    # Grab two extreme points\n    least, most = min(points), max(points)\n    # Split into those points above and below\n    points = [p for p in points if p != most and p != least]\n    top = quickhull_recurse(least, most, [p for p in points if is_ccw_turn(least, most, p)])\n    bot = quickhull_recurse(most, least, [p for p in points if not is_ccw_turn(least, most, p)])\n    # Generate the final result\n    return [least] + top + [most] + bot\n\n\n\"\"\"\nGenerate a merged hull by splitting the hull arbitrarily, generating two parting hulls, and reconciling.\nFirst, remove all points in hull 2's inner edge, if the centroid of hull 1 is outside hull 2.\nThen, reconcile all points into a single queue, ordered by angle, then distance.\nFinally, run a graham scan on this new monotone ring.\nDOESN'T CURRENTLY RUN TOO WELL.\n\"\"\"\ndef unsorted_merge_hull(points):\n    # If the number of points is small enough, crank out a solution.\n    if len(points) <= 5:\n        return double_half_hull(points)\n    # If the number of points is high, divide and conquer.\n    else:\n        # Generate partial hulls\n        a, b = unsorted_merge_hull(points[:len(points)//2]), unsorted_merge_hull(points[len(points)//2:])\n        # Find a point inside the first partial hull\n        c = (sum([x for x, y in a[:3]]) / 3, sum([y for x, y in a[:3]]) / 3)\n        # Determine the targent line points of the second partial hull to the centroid, if applicable\n        i = 0\n        while i < len(b) or is_ccw_turn(c, b[i], b[(i + 1) % len(b)]) or is_ccw_turn(c, b[i], b[(i - 1) % len(b)]):\n            i += 1\n        # If one tangent is found, find the other\n        if i < len(b):\n            j = 0\n            while j < len(b) or is_ccw_turn(c, b[j], b[(j + 1) % len(b)]) or is_ccw_turn(c, b[j], b[(j - 1) % len(b)]):\n                j += 1\n            # Kill the points between the tangents\n            if i < j:\n                b = b[i:j]\n            else:\n                b = b[j:] + b[:i]\n        # Merge to partial hulls into a single queue\n        q = []\n        i_a, i_b = 0, 0\n        while i_a < len(a) or i_b < len(b):\n            pass\n        if i_a < len(a): q.extend(a[i_a:])\n        if i_b < len(b): q.extend(b[i_b:])\n        # Run a graham scan on the queue\n        # Return a valid hull\n\n\n\"\"\"\nGenerate a merged hull by splitting the hull along a single axis, generating a series of partial hulls, and merging.\nHas issues with colinear points, but that's fine. \nThe main benefit of this is the ability to parallel process. \nSo long as the final set of points is re-checked, you can still get great gains from this.\nSift 90%, then run a better algo on the final result.\n\"\"\"\ndef x_laced_merge_hull(points):\n    sorted_points = sorted(points)\n    # Remove doubles along the x axis\n    x_laced_points = []\n    for p in sorted_points:\n        x_laced_points.append(p)\n        if len(x_laced_points) >= 3 and x_laced_points[-1][0] == x_laced_points[-2][0] == x_laced_points[-3][0]:\n            x_laced_points.pop(-2)\n\n    def sew(l_h, r_h, l_o, r_o, direction):\n        # Start sewing at the extreme middle of the partial hulls.\n        l_i, r_i = l_o, r_o\n        found_both = False\n        while not found_both:\n            # If either the left or right is moved, re-loop.\n            found_both = True\n            # Shift the right pointer as much as possible toward the extreme\n            moving_right = True\n            while moving_right:\n                if direction == \"top\":\n                    m_res = is_ccw_turn(r_h[(r_i + 1) % len(r_h)], r_h[r_i], l_h[l_i])\n                    p_res = is_ccw_turn(r_h[(r_i - 1) % len(r_h)], r_h[r_i], l_h[l_i])\n                elif direction == \"bot\":\n                    m_res = is_ccw_turn(l_h[l_i], r_h[r_i], r_h[(r_i + 1) % len(r_h)])\n                    p_res = is_ccw_turn(l_h[l_i], r_h[r_i], r_h[(r_i - 1) % len(r_h)])\n                if m_res == p_res == False:\n                    moving_right = False\n                else:\n                    r_i = (r_i + (1 if direction == \"top\" else -1)) % len(r_h)\n                    found_both = False\n            # Shift the left pointer as much as possible towards the extreme\n            moving_left = True\n            while moving_left:\n                if direction == \"top\":\n                    m_res = is_ccw_turn(r_h[r_i], l_h[l_i], l_h[(l_i + 1) % len(l_h)])\n                    p_res = is_ccw_turn(r_h[r_i], l_h[l_i], l_h[(l_i - 1) % len(l_h)])\n                elif direction == \"bot\":\n                    m_res = is_ccw_turn(l_h[(l_i + 1) % len(l_h)], l_h[l_i], r_h[r_i])\n                    p_res = is_ccw_turn(l_h[(l_i - 1) % len(l_h)], l_h[l_i], r_h[r_i])\n                if m_res == p_res == False:\n                    moving_left = False\n                else:\n                    l_i = (l_i + (-1 if direction == \"top\" else 1)) % len(l_h)\n                    found_both = False\n        # Return indexes for the left and right nodes that will be bridged to merge the hulls.\n        return l_i, r_i\n\n    def x_laced_recurse(l_i=0, r_i=len(x_laced_points)):\n        # If there are under 5 points, use an inefficient algo.\n        if r_i - l_i <= 5:\n            sub_points = x_laced_points[l_i:r_i]\n            hull = double_half_hull(sub_points)\n            return hull.index(min(hull)), hull.index(max(hull)), hull\n        # If there are over 5 points, recurse.\n        else:\n            # Recurse until there are two half-hulls of equal heft\n            l_min_i, l_max_i, l_h = x_laced_recurse(l_i, (l_i+r_i) // 2)\n            r_min_i, r_max_i, r_h = x_laced_recurse((l_i+r_i) // 2, r_i)\n            # Start with a line from the rightmost left point to the leftmost right point, move until can no longer\n            # Move the two lines, one up, one down until they can no longer be rotated to increase their encompassings\n            bot_i_l, bot_i_r = sew(l_h, r_h, l_max_i, r_min_i, 'bot')\n            top_i_l, top_i_r = sew(l_h, r_h, l_max_i, r_min_i, 'top')\n            # Join along the highlighted points, so as to merge the two partial hulls into a single spanning hull\n            hull = []\n            l_i = bot_i_l\n            while l_i != top_i_l:\n                hull.append(l_h[l_i])\n                l_i = (l_i + 1) % len(l_h)\n            hull.append(l_h[l_i])\n            r_i = top_i_r\n            while r_i != bot_i_r:\n                hull.append(r_h[r_i])\n                r_i = (r_i + 1) % len(r_h)\n            hull.append(r_h[r_i])\n            # Return the result\n            return hull.index(min(hull)), hull.index(max(hull)), hull\n\n    return double_half_hull(x_laced_recurse()[2])\n\n\ndef graham_scan_hull(points):\n    # Get LTL\n    m = max([n[1] for n in points])\n    o = min(points, key=lambda p:(p[0]*m+p[1]))\n    # Sort according to angle from origin\n    points = sorted(points, key=lambda p:(p[0]*m+p[1]))\n    points = sorted(points[1:], key=lambda p:math.atan2(p[0]-o[0],p[1]-o[1]))\n    # Initialize the hull with origin and item with lowest or highest angle\n    h, points = [points[-1], o, points[0]], points[1:]\n    # Iterate over the points\n    for p in points:\n        # Append the next point\n        h.append(p)\n        # Kill 2nd-to-last until reaching a state of convexity\n        done = False\n        # Pop until not at a ccw turn\n        while len(h) > 3 and not is_ccw_turn(h[-1], h[-2], h[-3]):\n            h.pop(-2)\n    h = [[p[0], p[1]] for p in h[:-1]]\n    return (h[2:] + h[:2])[::-1]\n\n\n# Generate a merged hull by generating two max-size, half-hulls with CW and CCW cardinality, then joining them.\ndef double_half_hull(points):\n    # Sort the points along an axis to make them monotone.\n    sorted_points = sorted(points)\n    \n    # Define a function to get half-hulls in a single direction.\n    def half_hull(sorted_points):\n        hull = []\n        for p in sorted_points:\n            # It's okay to only check CCW, as this function will be run on both an initial and a reversed list.\n            while len(hull) > 1 and not is_ccw_turn(hull[-2], hull[-1], p):\n                hull.pop()\n            hull.append(p)\n        hull.pop()\n        return hull\n        \n    # Call the half-hull function twice - once to get the right side, once the left.\n    return half_hull(sorted_points) + half_hull(reversed(sorted_points))\n\n\ndef hull_method(points):\n    # Remove point doubles\n    points = [list(p) for p in set([tuple(p) for p in points])]\n    # Print the points\n    print(points if len(points) < 80 else \"{}...\".format(points[:80]), '\\n')\n    # print(\"unsorted_merge_hull:\")\n    # res_unsorted_merge_hull = unsorted_merge_hull(points)\n    # print(res_unsorted_merge_hull, '\\n')\n    print(\"quickhull:\")\n    res_quickhull = quickhull(points)\n    print(res_quickhull, '\\n')\n    print(\"x_laced_merge hull:\")\n    res_x_laced_merge_hull = x_laced_merge_hull(points)\n    print(res_x_laced_merge_hull, '\\n')\n    print(\"graham_scan_hull:\")\n    res_graham_scan_hull = graham_scan_hull(points)\n    print(res_graham_scan_hull, '\\n')\n    print(\"double_half_hull:\")\n    res_double_half_hull = double_half_hull(points)\n    print(res_double_half_hull, '\\n')\n    hash_checkers = []\n    for hull in [res_quickhull, res_x_laced_merge_hull, res_graham_scan_hull, res_double_half_hull]:\n        hash_checkers.append({tuple(p) for p in hull})\n    fail_to_matches = sum(hash_checkers[i] != hash_checkers[i+1] for i in range(len(hash_checkers)-1))\n    return [] if fail_to_matches > 0 else res_double_half_hull", "import math\n\ndef hull_method(pointlist):\n    workset = set(map(tuple, pointlist))\n    basepoint = edge = max(workset)\n    hull, ray = [], 0\n    \n    def seeker(p):\n        dx, dy = p[0] - edge[0], p[1] - edge[1]\n        turn = (math.atan2(dy, dx) - ray) % (2 * math.pi)\n        sqdistance = dx * dx + dy * dy\n        return turn, -sqdistance, p\n\n    while not hull or basepoint != edge:\n        turn, _, edge = min(list(map(seeker, workset - {edge})))\n        ray  +=  turn\n        hull += [edge]\n    return list(map(list, hull))\n", "def hull_method(points):\n    \"\"\"Computes the convex hull of a set of 2D points.\n\n    Input: an iterable sequence of (x, y) pairs representing the points.\n    Output: a list of vertices of the convex hull in counter-clockwise order,\n      starting from the vertex with the lexicographically smallest coordinates.\n    Implements Andrew's monotone chain algorithm. O(n log n) complexity.\n    \"\"\"\n\n    # Sort the points lexicographically (tuples are compared lexicographically).\n    # Remove duplicates to detect the case we have just one unique point.\n    points =  sorted(points)\n#     points = sorted(set(points))\n    \n\n    # Boring case: no points or a single point, possibly repeated multiple times.\n    if len(points) <= 1:\n        return points\n\n    # 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.\n    # Returns a positive value, if OAB makes a counter-clockwise turn,\n    # negative for clockwise turn, and zero if the points are collinear.\n    def cross(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    # Build lower hull \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    # Build upper hull\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    # Concatenation of the lower and upper hulls gives the convex hull.\n    # Last point of each list is omitted because it is repeated at the beginning of the other list. \n    return lower[:-1] + upper[:-1]\n\n# def hull_method(pointlist):\n\n#     pass\n", "import numpy as np\n\ndef slope(p1, p2):\n    dx, dy = vectorize(p1, p2)\n    return dy/dx if dx else float(\"inf\")\n\ndef vectorize(p1, p2):         return [b-a for a,b in zip(p1, p2)]\ndef getArea  (p1, p2, p3):     return np.cross(vectorize(p1, p2), vectorize(p1, p3)) / 2\ndef isConcave(p1, pivot, p2):  return getArea(pivot, p1, p2) >= 0\n\ndef hull_method(points):\n    if len(points) < 3: return 0\n    \n    Z = min(points)                                                         # Leftmost point in the graph (lowest if several ones at the same x)\n    q = sorted( (pt for pt in points if pt != Z),\n                key = lambda pt: (-slope(pt, Z), -np.linalg.norm(vectorize(Z,pt))))                             # sorted points accordingly to the slope of the line formed by \"pt\" and \"Z\" (in reversed order)\n    \n    hull = [Z, q.pop()]                                                     # Construct the convex hull (Graham Scan)\n    while q:\n        pt = q.pop()\n        while len(hull) > 1 and isConcave(hull[-2], hull[-1], pt):\n            hull.pop()\n        hull.append(pt)\n    return hull", "from math import atan2, pi\ntau=2*pi\n\ndef hull_method(pointlist):\n    pointlist = sorted(set((x,y) for [x,y] in pointlist))\n    s=min(pointlist, key=lambda p:p[1]); p=s; d=0; l=[]\n    while (p!=s or len(l)<1):\n        tp = min([(x-p[0],y-p[1]) for x,y in pointlist if x!=p[0] or y!=p[1]], key=lambda p:((atan2(p[1],p[0])-d+tau)%tau,-p[0]**2-p[1]**2))\n        p = (tp[0]+p[0],tp[1]+p[1]); l.append(p); d=(atan2(tp[1],tp[0])+tau)%tau;\n    return [[x,y] for x,y in l]", "from functools import cmp_to_key\ndef hull_method(pointlist):\n    # handles the duplicate inputs\n    pointlist = list(set(map(tuple,pointlist)))\n    # find the bottom most and left most point\n    first_idx = min(range(len(pointlist)), key = lambda x: (pointlist[x][1], pointlist[x][0]))\n    pointlist[first_idx], pointlist[0] = pointlist[0], pointlist[first_idx]\n    # sort from the first\n    p = pointlist[0]\n    def custom_compare(q, r):\n        px, py = p\n        qx, qy = q\n        rx, ry = r\n        compare = (qy - py)*(rx - qx) - (qx - px)*(ry - qy)\n        if compare < 0:\n            return -1\n        elif compare > 0:\n            return 1\n        else:\n            return -1 if (rx-px)**2 + (ry-py)**2 >= (qx-px)**2 + (qy-py)**2 else 1\n    def get_angle(p, q, r):\n        px, py = p\n        qx, qy = q\n        rx, ry = r\n        return (qy - py)*(rx - qx) - (qx - px)*(ry - qy)\n        \n    pointlist[1:] = sorted(pointlist[1:], key = cmp_to_key(custom_compare))\n#     print(\"pointlist = \", pointlist)\n    lst, i = [pointlist[0]], 2\n    while i < len(pointlist):\n        while i < len(pointlist) and get_angle(p, pointlist[i-1], pointlist[i]) == 0:\n            i += 1\n        if i < len(pointlist):\n            lst.append(pointlist[i-1])\n            i += 1\n    lst.append(pointlist[i-1])\n#     print(\"sorted list = \", lst)\n    if len(lst) < 3:\n        return []\n    stck = [lst[0], lst[1], lst[2]]\n    for i in range(3, len(lst)):\n        while get_angle(stck[-2], stck[-1], lst[i]) >= 0:\n            stck.pop()\n        stck.append(lst[i])\n    return list(map(list, stck))", "import numpy as np\nimport itertools as it\n\ndef convertToPolar(points, refpoint):\n    \"\"\"Converts a list-like of 2D points to polar coordinates, first column containing the radii, second column containing the angles from [2, 2*pi]\"\"\"\n    points = np.asarray(points)\n    refpoint = np.asarray(refpoint)\n    points_c = points - refpoint\n    \n    rads = np.linalg.norm(points_c, axis = 1)\n    angles = np.angle(np.apply_along_axis(lambda args: [complex(*args)], 1, points_c))%(2*np.pi)\n    return np.column_stack((rads, angles))\n\n\ndef getSorted(points):\n    \"\"\"Converts a list of 2D points to polar coordinates and then lexsorts the result list first by angle, then by radius.\"\"\"\n    points = np.asarray(points)\n    midpoint = sum(points)/len(points)\n    points_polar = convertToPolar(points, midpoint)\n    lexsortindices = np.lexsort((points_polar[:,0], points_polar[:,1]))\n    points_polar_sorted = points_polar[lexsortindices]\n    points_sorted = points[lexsortindices]\n    \n    _, idx_start, count = np.unique(points_polar_sorted[:,1], return_counts=True, return_index=True)\n    points_polar_sorted_oneperangle = points_polar_sorted[idx_start + count - 1]\n    points_sorted_oneperangle = points_sorted[idx_start + count - 1]\n    outmostidx = np.argmax(points_polar_sorted_oneperangle[:,0])\n    \n    return np.roll(points_sorted_oneperangle, -outmostidx, axis = 0)\n\ndef areCollinear(point1, point2, point3):\n    point1, point2, point3 = np.asarray(point1), np.asarray(point2), np.asarray(point3)\n    return np.linalg.det(np.column_stack((point1 - point2, point2 - point3))) == 0\n\ndef hull_method(pointlist):\n    points = getSorted(pointlist)\n    outlist = [points[0].tolist()]\n    previous_idx, previous = 0, points[0]\n    \n    for current_idx, current in enumerate(points[1:], 1):\n        \n        #check that all other points are in the left halfplane specified by previous_point, current_point:\n        hyperplanevector = current - previous\n        normalvector = np.array([-hyperplanevector[1], hyperplanevector[0]])\n        \n        #check whether all points are in the left halfspace of the hyperplane (= line) defined by the point \"previous\" and the vector \"hyperplanevector\"\n        halfspace_check = True\n        for vec in it.chain(points[current_idx+1:,:], points[:previous_idx,:], points[previous_idx + 1: current_idx,:]):\n            vec_c = vec - previous\n            if np.dot(vec_c, normalvector) < 0:\n                halfspace_check = False\n                break\n        \n        if halfspace_check:\n            #remove previous point if collinearity or duplicate would arise\n            if len(outlist) >= 2:\n                if areCollinear(current, outlist[-1], outlist[-2]):\n                    outlist.pop(-1)\n                    \n            #add current point\n            outlist.append(current.tolist())\n            previous_idx, previous = current_idx, current\n                \n    #remove collinearities from last three outlist points or from connecting outlist points to a closed curve        \n    if len(outlist) >= 3:        \n        for i in (-2,-1,0): \n            if areCollinear(outlist[i-1], outlist[i], outlist[i+1]):\n                outlist.pop(i)\n       \n    return outlist", "from math import acos,sqrt,pi,atan2\neucelid = lambda a,b:((a[0]-b[0])**2+(a[1]-b[1])**2)**0.5\ndef cpd(x,y,z):\n    cpd=(y[0]-x[0])*(z[1]-x[1])-(y[1]-x[1])*(z[0]-x[0])\n    if cpd < 0 : return -1\n    if cpd > 0 : return 1\n    return 0\ndef cc(s,z):\n    x_s,y_s=s[0]-z[0],s[1]-z[1]\n    return atan2(y_s,x_s)\n\ndef hull_method(pointlist):\n    d, stack = min(pointlist, key=lambda x: (x[1],x[0])), []\n    pointlist.sort(key=lambda x: (cc(x,d),eucelid(x,d)))\n    stack+=pointlist[:2]\n    for i in range(2, len(pointlist)):\n        nx, pp = pointlist[i], stack.pop()\n        while len(stack) and stack[-1] and cpd(stack[-1], pp, nx) <= 0:\n                pp = stack.pop()\n        stack += [pp, nx]\n    return stack\n"]
["class BIT():\n    \"\"\"\u533a\u9593\u52a0\u7b97\u3001\u4e00\u70b9\u53d6\u5f97\u30af\u30a8\u30ea\u3092\u305d\u308c\u305e\u308cO(logN)\u3067\u5fdc\u3048\u308b\u30c7\u30fc\u30bf\u69cb\u9020\u3092\u69cb\u7bc9\u3059\u308b\n    add: \u533a\u9593[begin, end)\u306bval\u3092\u52a0\u3048\u308b\n    get_val: i\u756a\u76ee(0-indexed)\u306e\u5024\u3092\u6c42\u3081\u308b\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def get_val(self, i):\n        i = i + 1\n        s = 0\n        while i <= self.n:\n            s += self.bit[i]\n            i += i & -i\n        return s\n\n    def _add(self, i, val):\n        while i > 0:\n            self.bit[i] += val\n            i -= i & -i\n\n    def add(self, i, j, val):\n        self._add(j, val)\n        self._add(i, -val)\n\n\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\ndef eular_tour(tree: list, root: int):\n    \"\"\"\u9802\u70b9\u306b\u5bfe\u3059\u308b\u30aa\u30a4\u30e9\u30fc\u30c4\u30a2\u30fc\u3092\u884c\u3046\n    pos\u306e\u90e8\u5206\u6728\u306b\u533a\u9593[begin[pos], end[pos])\u304c\u5bfe\u5fdc\u3059\u308b\n    \"\"\"\n    n = len(tree)\n    res = []\n    begin = [-1] * n\n    end = [-1] * n\n    visited = [False] * n\n    visited[root] = True\n    q = deque([root])\n    while q:\n        pos = q.pop()\n        res.append(pos)\n        end[pos] = len(res)\n        if begin[pos] == -1:\n            begin[pos] = len(res) - 1\n        for next_pos in tree[pos]:\n            if visited[next_pos]:\n                continue\n            else:\n                visited[next_pos] = True\n                q.append(pos)\n                q.append(next_pos)\n\n    return res, begin, end\n\nn, q = map(int, input().split())\ninit_cost = list(map(int, input().split()))\ninfo = [list(map(int, input().split())) for i in range(n-1)]\nquery = [list(map(int, input().split())) for i in range(q)]\n\ntree = [[] for i in range(n)]\nfor i in range(n-1):\n    a, b = info[i]\n    a -= 1\n    b -= 1\n    tree[a].append(b)\n    tree[b].append(a)\n\nres, begin, end = eular_tour(tree, 0)\neven_res = []\nodd_res = []\nfor i in range(len(res)):\n    if i % 2 == 0:\n        even_res.append(res[i])\n    else:\n        odd_res.append(res[i])\n\neven_bit = BIT(len(even_res))\nodd_bit = BIT(len(odd_res))\n\nfor i in range(q):\n    if query[i][0] == 1:\n        _, pos, cost = query[i]\n        pos -= 1\n        if begin[pos] % 2 == 0:\n            even_bit.add(begin[pos] // 2, (end[pos] + 1) // 2, cost)\n            odd_bit.add(begin[pos] // 2, end[pos] // 2, -cost)    \n        else:\n            odd_bit.add(begin[pos] // 2, end[pos] // 2, cost) \n            even_bit.add((begin[pos] + 1) // 2, end[pos] // 2, -cost) \n    else:\n        _, pos = query[i]\n        pos -= 1\n        if begin[pos] % 2 == 0:\n            ans = even_bit.get_val(begin[pos] // 2)\n        else:\n            ans = odd_bit.get_val(begin[pos] // 2)\n        print(ans + init_cost[pos])"]
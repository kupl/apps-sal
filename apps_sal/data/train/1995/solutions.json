["class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        d = defaultdict(int)\n        \n        for a, b, c in trips:\n            d[b] += a\n            d[c] -= a\n        \n        k = 0\n        for t in sorted(d.keys()):\n            k += d[t]\n            if k > capacity:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        from collections import defaultdict\n        \n        log = defaultdict(int)\n        \n        for num, start, end in trips:\n            log[start] += num\n            log[end] -= num\n        \n        on_bus = 0\n        for stop in sorted(log.keys()):\n            on_bus += log[stop]\n            if on_bus > capacity:\n                return False\n        \n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        timestamp = []\n        for trip in trips:\n            timestamp.append([trip[1], trip[0]])\n            timestamp.append([trip[2], -trip[0]])\n\n        timestamp.sort()\n\n        used_capacity = 0\n        for time, passenger_change in timestamp:\n            used_capacity += passenger_change\n            if used_capacity > capacity:\n                return False\n\n        return True", "from queue import PriorityQueue\n\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        sorted_trips = sorted(trips, key=lambda x: (x[1], x[2]))        \n        pq = PriorityQueue()\n        total_pnum = 0\n        \n        for trip in sorted_trips:\n            pnum, start_loc, end_loc = trip[0], trip[1], trip[2]            \n            total_pnum += pnum   \n            \n            while pq.qsize() > 0:\n                prev_end_loc, prev_pnum = pq.get()\n                if prev_end_loc > start_loc:                    \n                    pq.put((prev_end_loc, prev_pnum))\n                    break                    \n                total_pnum -= prev_pnum                \n                \n            if end_loc > start_loc: \n                pq.put((end_loc, pnum))\n                \n            if total_pnum > capacity: \n                return False\n            \n        return True\n\n# Time complexity: O(nlogn)\n# Time complexity: O(n) for the priorioty queue\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        # data = []\n        # for t in trips:\n        #     data.append((t[1],1, t[0]))\n        #     data.append((t[2], 0, t[0]))\n        # data = sorted(data)\n        # maxp = 0\n        # for d in data:\n        #     if d[1] == 0:\n        #         maxp -= d[2]\n        #     else:\n        #         maxp += d[2]\n        #     if maxp > capacity: return False\n        # return True\n    \n        passenger = 0\n        onboard = defaultdict(int)\n        offboard = defaultdict(int)\n        for t in trips:\n            onboard[t[1]] += t[0]\n            offboard[t[2]] += t[0]\n        for d in range(10001):\n            \n            if d in onboard: passenger += onboard[d]\n            if d in offboard: passenger -= offboard[d]\n            if passenger > capacity: return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        if not trips or len(trips) == 0 or capacity == 0:\n             return False\n        \n        # sorting by starting point\n        trips.sort(key=lambda x:x[1])\n        \n        arr = []        \n        for num, start, end in trips:\n            arr.append([start, num])\n            arr.append([end, -num])\n        \n        arr.sort(key=lambda x:x[0])        \n        total = 0\n        \n        for a in arr:\n            total += a[1]\n            \n            if total > capacity:\n                return False\n        return True", "from queue import PriorityQueue\n\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        if len(trips) == 0: return True\n        \n        pq = PriorityQueue()\n        total_pnum = 0\n        \n        for trip in trips:\n            pq.put((trip[1], trip[0]))\n            pq.put((trip[2], -trip[0]))\n        \n        while pq.qsize() > 0:\n            cur_loc, pnum = pq.get()\n            total_pnum += pnum        \n                \n            if total_pnum > capacity: \n                return False\n            \n        return True\n\n# Time complexity: O(nlogn)\n# Time complexity: O(n) for the priorioty queue\n", "\\\"\\\"\\\"\n[[2,1,5],[3,5,7]]\n3 return T\n\n[[3,2,8],[4,4,6],[10,8,9]]\n11 return T\n\n[[2,1,5],[3,3,7]]\n4 return F\n\n[[4, 1, 3], [8, 2, 3], [1, 3, 6], [8, 4, 6], [4, 4, 8]]\n12 return F\n\\\"\\\"\\\"\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        if not trips: return True\n        curr_capacity = capacity\n        trips.sort(key=lambda x: (x[1], x[2]))\n        print(trips)\n        d = collections.defaultdict(list)\n        for i, (c, s, e) in enumerate(trips):\n            # print(i, c, s, e, d, curr_capacity)\n            # if e in d or s in d:\n            indexes = []\n            # for loc, end_locs in list(d.items():\n            for loc in list(d):\n                if loc <= s:\n                    indexes.extend(d[loc])\n                    del d[loc]\n                    # indexes = d[s] + d[e]\n                    # indexes = d[e]\n                    # indexes.extend(d[s])\n                    # indexes.ex\n                    # print(indexes)\n            for index in indexes:\n                curr_capacity += trips[index][0]\n                    \n            curr_capacity -= c\n            # print(i)\n            if curr_capacity < 0: \n                return False\n            d[e].append(i)\n            # print(curr_capacity)\n        return True", "from collections import defaultdict\n\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        d = defaultdict(int)\n        for n, s, e in trips:\n            d[s] += n\n            d[e] -= n\n        \n        cur = 0\n        for k in sorted(d):\n            cur += d[k]\n            if cur > capacity: return False\n        \n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        if not trips or len(trips) == 0 or capacity == 0:\n             return False\n        \n        # sorting by starting point\n        trips.sort(key=lambda x:x[1])\n        \n        arr = []        \n        for num, start, end in trips:\n            arr.append([start, num])\n            arr.append([end, -num])\n        \n        arr.sort()        \n        total = 0\n        \n        for a in arr:\n            total += a[1]\n            \n            if total > capacity:\n                return False\n        return True", "import heapq\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        # print(sorted(x for n, i, j in trips for x in [[i, n], [j, - n]]))\n        \n        \n        for i, v in sorted(x for n, i, j in trips for x in [[i, n], [j, - n]]):\n            capacity -= v\n            if capacity < 0:\n                return False\n        return True\n        \n#         left = capacity\n#         h = []\n#         trips = sorted(trips, key=lambda x: x[1])\n        \n#         for t in trips:\n#             if h:\n#                 while h and t[1] >= h[0][0]:\n#                     mint = h[0]\n#                     left += mint[1][0]\n#                     heapq.heappop(h)\n            \n#             if left < t[0]:\n#                 return False\n\n#             heapq.heappush(h, (t[2], t))\n#             left -= t[0]\n            \n#         return True\n\n#         path = [0] * 1001\n#         for t in trips:\n#             for i in range(t[1], t[2]):\n#                 path[i] += t[0]\n#                 if path[i] > capacity:\n#                     return False\n                \n#         return True\n            \n        \n", "class Solution:\n    def carPooling(self, trips: List[List[int]], c: int) -> bool:\n        \n        f, t = float('inf'), -1\n        b = collections.defaultdict(int)\n        for n, s, e in trips:\n            b[s] += n\n            b[e] -= n\n    \n            f = min(f, s)\n            t = max(t, e)\n    \n        for i in range(f, t + 1):\n            b[i] += b[i - 1]\n            if b[i] > c:\n                return False\n        \n        return True    \n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        timestamp = [0] * 1001\n        for trip in trips:\n            timestamp[trip[1]] += trip[0]\n            timestamp[trip[2]] -= trip[0]\n\n        used_capacity = 0\n        for passenger_change in timestamp:\n            used_capacity += passenger_change\n            if used_capacity > capacity:\n                return False\n\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips_pickup = sorted(trips,key=lambda x:x[1])\n        trips_drop = sorted(trips,key=lambda x:x[2])\n        passengers = 0\n        i=0\n        j=0\n        while(i<len(trips)):\n            if trips_pickup[i][1] <trips_drop[j][2]:\n                passengers +=trips_pickup[i][0]\n            else:\n                passengers-=trips_drop[j][0]\n                j+=1\n                continue\n            i+=1\n            if passengers>capacity:\n                return False\n        return True", "#### dict - get keys - dict.keys()\n#### dict initialization : dict [key] = val OR dict = [key:value]\n\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n    \n        ## sort trips by starting point to process them in correct order to detect overlap\n        trips = sorted(trips, key=lambda x:x[1])\n        currentPassengerCt = trips[0][0]\n        tripList = dict()\n        tripList[trips[0][2]] = trips[0][0]\n    \n        for idx in range(1,len(trips)):\n            numPassengers = trips[idx][0]\n            startPt = trips[idx][1]\n            endPt = trips[idx][2]\n\n            for prevEndPoint in sorted(tripList.keys()):\n                if startPt >= prevEndPoint:\n                    ## overlaps with 1 or more trips\n                    ## remove finished trips from tripList \n                    ## deduct passengers from currentPassengerCt\n                    \n                    ## dont overlap with ANY previous trips, capacity <= target    \n                    ## reset currentPassengerCt\n                    ## empty tripList\n                    currentPassengerCt -= tripList[prevEndPoint]\n                    del tripList[prevEndPoint]\n\n            ## add current trip to tripList\n            ## update currentPassengerCt\n            if endPt in tripList:\n                tripList[endPt] += numPassengers\n            else:\n                tripList[endPt] = numPassengers\n            currentPassengerCt += numPassengers \n\n            ## if overlap, then sum(passengers) for all concurrent trips <= capacity\n            ## if no overlap, #passengers for trip  <= capacity\n            ##  currentPassengerCt exceeded\n            if currentPassengerCt > capacity:\n                return False\n\n        return True\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trip_travel=[]\n        for passengers,start,end in trips:\n            trip_travel.append((start,passengers,1)) #start times so adding people\n            trip_travel.append((end,passengers,0)) #start times so removing people\n        \n        trip_travel.sort(key=lambda x:(x[0],x[2])) #sort and make sure removing people(increase capacity) before adding people - that way if adding and removing at same location-capacity not temporarily < 0 \n        for travel in trip_travel:\n            if travel[2]==1:\n                capacity-=travel[1]\n            else:\n                capacity+=travel[1]\n                \n            if capacity<0:\n                return False\n        \n        return True\n        \n                \n        \n", "import heapq\n\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        \n        trips = sorted(trips, key = lambda k: k[1])\n        \n        \n        car_passengers = 0\n        drop_location = []\n        \n        for trip in trips:\n            \n            passengers, start_location, end_location = trip\n            \n            car_passengers += passengers\n            \n            while len(drop_location) != 0 and heapq.nsmallest(1, drop_location)[0][0] <= start_location:\n                print(\\\"hi\\\")\n                passed_location, drop_passengers  = heapq.heappop(drop_location)\n                car_passengers -= drop_passengers\n                \n            heapq.heappush(drop_location, [end_location, passengers])\n            \n            if car_passengers > capacity:\n                return False\n            \n            car_passengers = max(car_passengers, 0) # don't want 0\n            \n        return True\n        ", "#### dict - get keys - dict.keys()\n#### dict initialization : dict [key] = val OR dict = [key:value]\n\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n    \n        ## sort trips by starting point to process them in correct order to detect overlap\n        trips = sorted(trips, key=lambda x:x[1])\n        currentPassengerCt = trips[0][0]\n        tripList = dict()\n        tripList[trips[0][2]] = trips[0][0]\n    \n        for idx in range(1,len(trips)):\n            numPassengers = trips[idx][0]\n            startPt = trips[idx][1]\n            endPt = trips[idx][2]\n\n            #overlap = False\n            for prevEndPoint in sorted(tripList.keys()):\n                if startPt >= prevEndPoint:\n                    ## overlaps with 1 or more trips\n                    ## remove finished trips from tripList \n                    ## deduct passengers from currentPassengerCt\n                    \n                    ## dont overlap with ANY previous trips, capacity <= target    \n                    ## reset currentPassengerCt\n                    ## empty tripList\n                    currentPassengerCt -= tripList[prevEndPoint]\n                    del tripList[prevEndPoint]\n\n            ## add current trip to tripList\n            ## update currentPassengerCt\n            if endPt in tripList:\n                tripList[endPt] += numPassengers\n            else:\n                tripList[endPt] = numPassengers\n            currentPassengerCt += numPassengers \n\n            ## if overlap, then sum(passengers) for all concurrent trips <= capacity\n            ## if no overlap, #passengers for trip  <= capacity\n            ##  currentPassengerCt exceeded\n            if currentPassengerCt > capacity:\n                return False\n\n        return True\n", "#### dict - get keys - dict.keys()\n#### dict initialization : dict [key] = val OR dict = [key:value]\n\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n    \n        ## sort trips by starting point to process them in correct order to detect overlap\n        trips = sorted(trips, key=lambda x:x[1])\n        currentPassengerCt = trips[0][0]\n        tripList = dict()\n        tripList[trips[0][2]] = trips[0][0]\n    \n        for idx in range(1,len(trips)):\n            numPassengers = trips[idx][0]\n            startPt = trips[idx][1]\n            endPt = trips[idx][2]\n\n            #overlap = False\n            for prevEndPoint in sorted(tripList.keys()):\n                if startPt >= prevEndPoint:\n                    ## overlaps with 1 or more trips\n                    ## remove finished trips from tripList \n                    ## deduct passengers from currentPassengerCt\n                    \n                    ## dont overlap with ANY previous trips, capacity <= target    \n                    ## reset currentPassengerCt\n                    ## empty tripList\n                    currentPassengerCt -= tripList[prevEndPoint]\n                    del tripList[prevEndPoint]\n\n            ## add current trip to tripList\n            ## update currentPassengerCt\n            if endPt in tripList:\n                tripList[endPt] += numPassengers\n            else:\n                tripList[endPt] = numPassengers\n            currentPassengerCt += numPassengers \n\n            ## if overlap, then sum(passengers) for all concurrent trips <= capacity\n            ## if no overlap, #passengers for trip  <= capacity\n            ##  currentPassengerCt exceeded\n            print(currentPassengerCt)\n            if currentPassengerCt > capacity:\n                return False\n\n        return True\n", "#### dict - get keys - dict.keys()\n#### dict initialization : dict [key] = val OR dict = [key:value]\n\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n    \n        ## sort trips by starting point to process them in correct order to detect overlap\n        trips = sorted(trips, key=lambda x:x[1])\n        currentPassengerCt = trips[0][0]\n        tripList = dict()\n        tripList[trips[0][2]] = trips[0][0]\n    \n        for idx in range(1,len(trips)):\n            numPassengers = trips[idx][0]\n            startPt = trips[idx][1]\n            endPt = trips[idx][2]\n\n            #overlap = False\n            for prevEndPoint in sorted(tripList.keys()):\n                if startPt >= prevEndPoint:\n                    ## overlaps with 1 or more trips\n                    ## remove finished trips from tripList \n                    ## deduct passengers from currentPassengerCt\n                    currentPassengerCt -= tripList[prevEndPoint]\n                    del tripList[prevEndPoint]\n                    #overlap = True\n\n\n            ## dont overlap with ANY previous trips, capacity <= target    \n            ## reset currentPassengerCt\n            ## empty tripList\n            \n            #if not overlap:\n            #    tripList = []\n            #    currentPassengerCt = 0\n\n            ## add current trip to tripList\n            ## update currentPassengerCt\n            if endPt in tripList:\n                tripList[endPt] += numPassengers\n            else:\n                tripList[endPt] = numPassengers\n            currentPassengerCt += numPassengers \n\n            ## if overlap, then sum(passengers) for all concurrent trips <= capacity\n            ## if no overlap, #passengers for trip  <= capacity\n            ##  currentPassengerCt exceeded\n            print(currentPassengerCt)\n            if currentPassengerCt > capacity:\n                return False\n\n        return True\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        import numpy as np\n        timestamp = np.zeros(1001)\n    \n        for trip in trips:\n            timestamp[trip[1]:] += trip[0]\n            timestamp[trip[2]:] -= trip[0]\n        \n        if max(timestamp) > capacity:\n            return False\n        return True\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n    \n        def Sort(sub_li): \n            sub_li.sort(key = lambda x: x[1]) \n            return sub_li \n        \n        trips = Sort(trips)\n        \n        people = 0\n        on_board = []\n        \n        for [n,a,b] in trips:\n            people +=n\n            \n            while on_board and on_board[0][1]<=a:\n                t = on_board.pop(0)\n                people -= t[0]\n                \n            if people>capacity:\n                return False\n            \n            on_board.append([n,b])\n            on_board = Sort(on_board)\n            \n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        if not trips:\n            return 0\n        tmp = sorted(x for v, i, j in trips for x in [[i, v], [j, -v]])\n        \n        n = 0\n        for _, v in tmp:\n            n += v\n            if n > capacity:\n                return False\n        return True\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips.sort(key=lambda x: x[1])\n        capacity_needed, hp = 0, []\n        for trip in trips:\n            while hp and hp[0][0]<=trip[1]:\n                end,start,c =heapq.heappop(hp)\n                capacity_needed-=c\n            capacity_needed+=trip[0]\n            if capacity_needed>capacity:\n                return False\n            heapq.heappush(hp,(trip[2],trip[1],trip[0]))\n        return True\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips.sort(key=lambda x : x[1])\n        print(trips)\n        start=trips[0][1]\n        end=trips[0][2]\n        capacity=capacity-trips[0][0]\n        if(capacity < 0):\n            return False\n        q=[(trips[0][2],trips[0][0])]\n        n=len(trips)\n        for trip in trips[1::]:\n            s=trip[1]\n            dup=q[::]\n            while(q):\n                if(q[0][0]<=s):\n                    capacity+=q[0][1]\n                    q.pop(0)\n                else:\n                    break\n            capacity -= trip[0]\n            q.append((trip[2],trip[0]))\n            q.sort(key = lambda x: x[0])\n            if capacity < 0:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips=sorted(trips, key=lambda x:x[1])\n        cap=capacity\n        st=[]\n        for trip in trips:\n            if not st:\n                if cap<trip[0]:\n                    return False\n                st.append((trip[0], trip[-1]))\n                cap-=trip[0]\n            else:\n                st=sorted(st, key=lambda x:x[1])\n                while st and trip[1]>=st[0][1]:\n                    cap+=st[0][0]\n                    st.pop(0)\n                if cap<trip[0]:\n                    return False\n                st.append((trip[0], trip[-1]))\n                cap-=trip[0]\n        return True\n                \n                    \n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips.sort(key = lambda x: x[1])\n        length = len(trips)\n        \n        count = 0\n        queue = []\n        for trip in trips:\n            num_passengers, start_location, end_location = trip\n            while queue and queue[0][2] <= start_location:\n                count -= queue[0][0]\n                queue = queue[1:]\n            queue.append(trip)\n            queue.sort(key = lambda x: x[2])\n            count += num_passengers\n            if count > capacity:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        r = True;\n        active = [];\n        currContent = 0;\n        maxCapacity = 0;\n        time = 0;\n        trips.sort(key=lambda x: x[1]); #sort tips by start time\n        lenTrips = len(trips);\n        \n        #for each trip\n        for i in range(0, lenTrips): #figure out the capacity required at the start of each trip\n            time = trips[i][1]; #set time to start of ith trip\n            \n            #add people for ith trip\n            currContent += trips[i][0];\n            active.append(i);\n            \n            #remove people for completed trips\n            for j in range(len(active)-1, -1, -1):\n                if trips[active[j]][2] <= time:\n                    currContent -= trips[active[j]][0];\n                    active.pop(j);\n                    \n            #track maximum capacity required\n            maxCapacity = max(maxCapacity, currContent);\n            \n            if maxCapacity > capacity:\n                r = False;\n                break;\n            \n        return r;", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        # (2,6) (3,5) (4,5)\n        sorted_trips = sorted(trips, key=lambda x:x[1])\n        in_trip = [sorted_trips[0]]\n        cap = capacity - sorted_trips[0][0]\n        cur_time = 0\n        i = 1        \n        while i < len(sorted_trips):\n            #print('b', in_trip)\n            waiting_passenger = sorted_trips[i]\n            if not in_trip:\n                cap -= waiting_passenger[0]\n                in_trip.append(waiting_passenger)\n                #print('add new', waiting_passenger)\n                i += 1\n                \n            else:\n                first_passenger = in_trip[0]\n                \n                if waiting_passenger[1] >= first_passenger[2]:\n                    # pop out\n                    in_trip.pop(0)\n                    cap += first_passenger[0]\n                    #print('pop current', first_passenger)\n                elif cap >= waiting_passenger[0]:\n                    cap -= waiting_passenger[0]\n                    in_trip.append(waiting_passenger)\n                    in_trip = sorted(in_trip, key=lambda x:x[2])\n                    #print('add new', waiting_passenger)\n                    i += 1\n                else:\n                    return False\n            #print('a', in_trip)\n\n        return True\n                \n                \n            \n            \n        \n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        sorted_trips = sorted(trips, key=lambda x: x[1])\n        print(sorted_trips)\n        \n        cur_capacity = 0\n        left = 0\n        location = [0 for i in range(1000 + 1)]\n        for trip in trips:\n            new_capacity = trip[0]\n            new_start, new_end = trip[1], trip[2]\n            location[new_start:new_end] = [cap + new_capacity for cap in location[new_start:new_end]]\n        # print(location)\n        for loc in location:\n            if loc > capacity:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        ind = 0\n        \n        for a,b,c in trips:\n            \n            ind = max(ind, b, c)\n            \n        res = [0] * (ind+1)\n        \n        for a, b, c in trips:\n            \n            for i in range(b, c):\n                res[i] += a\n        return not any([x > capacity for x in res])\n                    \n                \n                \n", "class Solution:\n\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        def add_list(pool, start, end, num):\n            for idx in range(start, end):\n                pool[idx] += num\n        pool = [0]*1000\n        for trip in trips:\n            num, start,end = trip\n            add_list(pool, start,end, num)\n        if max(pool)> capacity:\n            return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        occupied = [0 for i in range(1001)]\n        for num_passengers, start_location, end_location in trips:\n            for i in range(start_location, end_location):\n                occupied[i] += num_passengers\n        return max(occupied) <= capacity\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        end = 0\n        for _,_,e in trips:\n            end = max(end, e)\n\n        dp = [0 for _ in range(end)]\n        for passengers, start, end in trips:\n            for i in range(start, end):\n                dp[i] += passengers\n        return max(dp) <= capacity", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        lst=[]\n        for people,st,end in trips:\n            lst.append((st,people,1))\n            lst.append((end,people,0))\n        lst.sort(key=lambda x: (x[0],x[2]))\n        current=0\n        for time,people,pickup in lst:\n            if pickup:\n                current+=people\n            else:\n                current-=people\n            if current > capacity: return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        \n        \n        ind = 0\n        \n        for a,b,c in trips:\n            \n            ind = max(ind, b, c)\n            \n        res = [0] * (ind+1)\n        \n        for a, b, c in trips:\n            \n            for i in range(b, c):\n                res[i] += a\n        return not any([x > capacity for x in res])\n        \n        \n            \n            \n            \n        \n#         trips.sort(key=lambda x: (x[1], x[2]))\n        \n#         print(trips)\n        \n#         pas, start, end = trips[0]\n        \n#         for i in range(1, len(trips)):\n            \n#             if trips[i][1] < end:\n                \n#                 pas += trips[i][0]\n#                 if pas > capacity:\n#                     return False\n#                 end = max(end, trips[i][2])\n#             else:\n#                 pas = trips[i][0]\n#         return True\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        buckets = [0]*1001\n        for trip in trips:\n            passengers, start, end = trip\n            for i in range(start, end):\n                buckets[i] += passengers\n\n        for elem in buckets:\n            if elem > capacity:\n                return False\n\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        self.remainSeats=capacity\n        self.tripsOnBoard=[]\n        trips = sorted(trips, key=lambda trip:trip[1])\n        for trip in trips:\n            self.offBoard(trip[1])\n            if not self.onBoardTrip(trip):\n                return False\n        return True\n    def offBoard(self, currentLocation: int):\n        trips2OffBoard = [trip for trip in self.tripsOnBoard if trip[2]<=currentLocation]\n        for trip in trips2OffBoard:\n            self.remainSeats += trip[0]\n        self.tripsOnBoard = [trip for trip in self.tripsOnBoard if trip[2]>currentLocation]\n    \n    def onBoardTrip(self, trip: List[int]) -> bool:\n        if trip[0]<=self.remainSeats:\n            self.remainSeats-=trip[0]\n            self.tripsOnBoard.append(trip)\n            return True\n        else:\n            return False\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        #cus_num = [i[0] for i in trips]\n        #starts = [i[1] for i in trips]\n        ends  = [i[2] for i in trips]\n        max_ends = max(ends)\n        all_stops = [0 for i in range(0, max_ends+1)]\n        #print(all_stops)\n        for trip in trips:\n            l, r = trip[1], trip[2]\n            #print(all_stops)\n            all_stops[l:r] = [i + trip[0] for i in all_stops[l:r] ]\n            if max(all_stops[l:r]) > capacity:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n\n        final = 0\n\n        for trip in trips:\n            final = max(final, trip[2])\n        people = [0] * (final + 1)\n\n        for trip in trips:\n            for board in range(trip[1], trip[2]):\n                people[board] += trip[0]\n\n        if max(people) > capacity:\n            return False        \n        else:\n            return True\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        total_trip = [0 for _ in range(1000)]\n        for tt in trips:\n            for loc in range(tt[1],tt[2]):\n                total_trip[loc] += tt[0]\n        if max(total_trip) <= capacity:\n            return True\n        return False", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        dests = [x[2] for x in trips]\n        myl = [0 for i in range(max(dests)+1)]\n        for x in trips:\n            for c in range(x[1], x[2]):\n                myl[c] += x[0]\n        \n        for i in myl:\n            if i>capacity:\n                return False\n            \n        return True\n        \n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        # trips: List[[num_passengers, start_idx, end_idx]]\n        # for each position, count number of people required\n        \n        n = len(trips)\n        \n        # 1. arrange trips by start date\n        sorted_trips = sorted(trips, key=lambda t: t[1])\n        \n        # 2. for min_idx, max_idx keep track of all active trips overlapping\n        min_idx = sorted_trips[0][1]\n        max_idx = max([t[2] for t in sorted_trips])\n        \n        merged = [0 for _ in range(max_idx + 1)]\n        \n        # base case\n        for num_passenger, start_idx, end_idx in sorted_trips:\n            for idx in range(start_idx, end_idx):\n                merged[idx] += num_passenger\n                if merged[idx] > capacity:\n                    # print(f\\\"merged={merged}; idx={idx}\\\")\n                    return False\n        \n        return True\n            \n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips = sorted(trips, key=lambda x: x[1])\n        curr = []\n        \n        for i in trips:\n            \n            curr.append([i[0], i[2]])\n            \n            s = 0\n            for c in curr:\n                if c[1] <= i[1]:\n                    continue\n                s += c[0]\n            \n            if s > capacity:\n                return False\n        \n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        d=[0 for i in range(1001)]\n        for i in trips:\n            for j in range(i[1], i[2]):\n                d[j]+=i[0]\n        # print(d)\n        for i in range(1001):\n            if d[i]>capacity:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n#         # time O(max(N, 1001)); space O(1001)\n#         timestamp = [0] * 1001\n#         for trip in trips:\n#             timestamp[trip[1]] += trip[0]\n#             timestamp[trip[2]] -= trip[0]\n        \n#         used = 0\n#         for change in timestamp:\n#             used += change\n#             if used > capacity:\n#                 return False\n            \n#         return True\n\n        # time O(nlogn); space O(n)\n        pooling = []\n        for num, start, end in trips:\n            pooling.extend([[start, num], [end, -num]])\n        pooling.sort()\n        \n        for loc, num in pooling:\n            capacity -= num\n            if capacity < 0:\n                return False\n        return True", "from collections import defaultdict, OrderedDict\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips = sorted(trips, key=lambda x: x[1])\n        passengers = 0\n        \n        dropoffs = defaultdict(int)\n        for i in range(len(trips)):\n            dropoffs[trips[i][2]] += trips[i][0]\n        dropoffs = OrderedDict(sorted(dropoffs.items()))\n\n        for lis in trips:\n            passengers += lis[0]\n            for key in dropoffs:\n                if lis[1] >= key:\n                    passengers -= dropoffs[key]\n                    dropoffs[key] = 0\n            # print(passengers)\n            if passengers > capacity:\n                return False\n        return True\n            \n        \n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        load = [0] * 1001\n        for count, from_idx, to_idx in trips:\n            for i in range(from_idx, to_idx):\n                load[i] += count\n                if load[i] > capacity:\n                    return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        passengers = [0] * 1000\n        \n        for trip in trips:\n            p, start, end = trip\n            for i in range(start, end):\n                passengers[i] += p\n                if passengers[i] > capacity:\n                    return False\n        return True\n", "class Solution:\n\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        def add_list(pool, start, end, num):\n            for idx in range(start, end):\n                pool[idx] += num\n                if pool[idx] > capacity:\n                    return False\n        pool = [0]*1000\n        for trip in trips:\n            num, start, end = trip\n            is_false = add_list(pool, start, end, num)\n            if is_false == False:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        \n        \\\"\\\"\\\"\n        [[2,1,5],[3,3,7]]\n        \n        1 2 3 4 5 6 7\n        2 2 2 2 2\n        2 2 5 2 2        \n        \n        c = 4\n        \\\"\\\"\\\"\n            \n        count_vec = [0]*1001\n                        \n        for num_pass, start, end in trips:\n            for i in range(start, end):\n                count_vec[i] += num_pass\n                if count_vec[i] > capacity:\n                    return False\n                \n        return True\n        ", "\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        totals = [0] * 1001\n        for (passengers, start, end) in trips:\n            for x in range(start, end):\n                totals[x] += passengers\n                if totals[x] > capacity:\n                    return False\n        return True", "from operator import itemgetter\n\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        cp_arr = []\n        print(trips)\n        trips = sorted(trips, key=lambda x: x[1], reverse=False)\n        print(trips)\n        min_val = min([i[1] for i in trips])\n        max_val = max([i[2] for i in trips])\n        offset = max_val - min_val\n        print(f\\\"max:{max_val} min:{min_val}\\\")\n        check_arr = [0] * offset\n        print(check_arr)\n        \n        for trip in trips:\n            low = trip[1]\n            high = trip[2]\n            for i in range(low, high):\n                check_arr[i - offset] += trip[0]\n        \n        print(check_arr)\n        \n        if max(check_arr) <= capacity:\n            return True\n        return False", "from operator import itemgetter\n\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        cp_arr = []\n        trips = sorted(trips, key=lambda x: x[1], reverse=False)\n        min_val = min([i[1] for i in trips])\n        max_val = max([i[2] for i in trips])\n        offset = max_val - min_val\n        check_arr = [0] * offset\n        \n        for trip in trips:\n            low = trip[1]\n            high = trip[2]\n            for i in range(low, high):\n                check_arr[i - offset] += trip[0]\n\n        if max(check_arr) <= capacity:\n            return True\n        return False", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        dp = [capacity] * 1000\n        for trip in trips:\n            for loc in range(trip[1], trip[2]):\n                dp[loc] -= trip[0]\n        return not (min(dp) < 0)\n", "from operator import itemgetter\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        #trips = sorted(trips,key=itemgetter(2))\n        dp = [0] * 1001\n        for t in trips:\n            for j in range(t[1],t[2]):\n                dp[j] += t[0]\n                #print(dp)\n                if dp[j] > capacity:\n                    return False\n    \n        return True", "class Solution:\n    \\\"\\\"\\\"\n    return false when a pickup exceeds capacity\n    pickup & drop off can happen at same location\n    [2,1,5]\n    car = 4, 4, \n    \n    \n    create pickup_dict = {start_location : [[num_passenger = trip[0], end_location=trip[2]]]}\n    dropoff_dict = {drop_off location : num_passengers}\n    car = [0]*capacity\n    car is full when all elem in car > 0\n    \n    for location in locations:\n        decement remaining for passengers in car (make sure no negatives)\n        check if location is a pickup:\n            if capacity full:\n                return false\n            else:\n                update car\n    return True\n    \n    \\\"\\\"\\\"\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        pickups = {} # start location : [[num_passengers]\n        drops = {} # drop location: num\n        for trip in trips:\n            pickups[trip[1]] = pickups.get(trip[1], 0)+trip[0]\n            drops[trip[2]] = drops.get(trip[2],0)+trip[0]\n        \n        count_passengers = 0\n        for start in range(1001):\n            if start in pickups.keys():\n                count_passengers += pickups[start]\n                # increment passenger count\n            if start in drops.keys():\n                count_passengers -= drops[start]\n            if count_passengers > capacity:\n                return False\n        return True\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        count_pass = trips[len(trips)-1][2]*[0]\n        for i in trips:\n            if len(count_pass)< i[2]:\n                count_pass += [0]*(i[2]-len(count_pass))\n            for j in range(i[1],i[2]):\n                count_pass[j] += i[0] \n                if count_pass[j]> capacity:\n                    return False\n        return True\n", "from operator import itemgetter\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips = sorted(trips,key=itemgetter(2))\n        dp = [0] * (trips[-1][2]+1)\n        for t in trips:\n            for j in range(t[1],t[2]):\n                dp[j] += t[0]\n                #print(dp)\n                if dp[j] > capacity:\n                    return False\n    \n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        cap = [capacity]*1000\n        for trip in trips:\n            for i in range(trip[1], trip[2]):\n                cap[i] -= trip[0]\n                if cap[i] < 0:\n                    return False\n        return True\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        if len(trips) <=0:\n            return False\n        \n        trips.sort(key = lambda x : x[1]) # Sorting array by start time\n        stack = [] # maintaing list to store indexes so that we can compare start time of previous and with current end time\n        if trips[0][0] > capacity:\n            return False\n        else:\n            stack.append(0)\n            capacity-=trips[0][0]\n            \n        for i in range(1, len(trips)):\n            n = 0\n            # if current start time >= any one of previous indices start time--> inc capacity\n            while stack and n < len(stack): \n                if trips[i][1] >= trips[stack[n]][2]:\n                    capacity += trips[stack[n]][0]\n                    stack.pop(n)\n                else: n+=1\n                \n            if trips[i][0] <= capacity:\n                capacity-=trips[i][0]\n            elif trips[i][0] > capacity:\n                return False\n            stack.append(i)\n        return True\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips = sorted(trips, key = lambda x : x[1])\n        \n        pos = 0\n        curr_capacity = capacity\n        ht = {} # drop off location : passengers\n        for trip in trips:\n            # if dropOff < trip[1]:\n            #     curr_capacity -= \n            # elif trip[0] > curr_capacity:\n            #     return False\n            for prev in ht:\n                if prev <= trip[1]:\n                    curr_capacity += ht[prev]\n                    # del ht[prev]\n                    ht[prev] = 0\n            \n            if trip[0] > curr_capacity:\n                return False\n            \n            if trip[2] not in ht:\n                ht[trip[2]] = trip[0]\n            else:\n                ht[trip[2]] += trip[0]\n            \n            curr_capacity -= trip[0]\n        \n        return True\n              \n", "class Solution:\n#     def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n#         curr_end, max_end = 0, 0\n#         list_curr = []\n#         for trip in trips:\n#             max_end = trip[2]\n#             list_curr.extend([0] * (max_end - curr_end))\n#             # print(len(list_curr))\n#             for _ in range(trip[1], trip[2]):\n#                 list_curr[_] += trip[0]\n#             curr_end = max_end\n            \n#             if max(list_curr) > capacity:\n#                 return False\n#         return True\n    # def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n    #     list_end = []\n    #     for _ in trips:\n    #         list_end.extend([_[2]])\n    #     len_list = max(list_end)\n    #     list_curr = [0]*len_list\n    #     for trip in trips:\n    #         for _ in range(trip[1], trip[2]):\n    #             list_curr[_] += trip[0]\n    #         if max(list_curr) > capacity:\n    #             return False\n    #     return True\n    \n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        list_curr = [0]*1000\n        for trip in trips:\n            for _ in range(trip[1], trip[2]):\n                list_curr[_] += trip[0]\n            if max(list_curr) > capacity:\n                return False\n        return True\n        \n    \n            \n            \n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trip_start = min([trip[1] for trip in trips])\n        trip_end = max([trip[2] for trip in trips])\n        \n        trip_register = [0]*(trip_end+1)\n        for trip in trips:\n            for idx in range(trip[1], trip[2]):\n                trip_register[idx] += trip[0]\n        \n        return capacity >= max(trip_register)", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        \n        m = [ 0 for i in range(1000)]\n        \n        for x in trips:\n            if  x[0] > capacity:\n                return False\n            \n            for i in range(x[1],x[2]):\n                m[i]+=x[0]\n            \n            if max(m)> capacity:\n                return False\n        \n        if max(m) > capacity:\n            return False\n        return True\n                \n", "import heapq\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        \n#         left = capacity\n#         h = []\n#         trips = sorted(trips, key=lambda x: x[1])\n        \n#         for t in trips:\n#             if h:\n#                 while h and t[1] >= h[0][0]:\n#                     mint = h[0]\n#                     left += mint[1][0]\n#                     heapq.heappop(h)\n            \n#             if left < t[0]:\n#                 return False\n\n#             heapq.heappush(h, (t[2], t))\n#             left -= t[0]\n            \n#         return True\n\n        path = [0] * 1001\n        for t in trips:\n            for i in range(t[1], t[2]):\n                path[i] += t[0]\n                if path[i] > capacity:\n                    return False\n                \n        return True\n            \n        \n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        pickups = sorted([lst[:2] for lst in trips], key = lambda lst : lst[1])\n        dropoffs = sorted([lst[::2] for lst in trips], key = lambda lst: lst[1])\n        print(pickups, dropoffs)\n        \n        currentCap = 0\n        i, j = 0, 0\n        nextP, nextD = pickups[0], dropoffs[0]\n        while i < len(pickups):\n            if nextP[1] < nextD[1] or not nextD:\n                currentCap += nextP[0]\n                i += 1\n                if i < len(pickups):\n                    nextP = pickups[i]\n                else:\n                    nextP = None\n            elif nextP[1] > nextD[1] or not nextP:\n                currentCap -= nextD[0]\n                j += 1\n                if j < len(dropoffs):\n                    nextD = dropoffs[j]\n                else:\n                    nextD = None\n            else:\n                currentCap += nextP[0] - nextD[0]\n                i += 1\n                j += 1\n                if i < len(pickups):\n                    nextP = pickups[i]\n                else:\n                    nextP = None\n                if j < len(dropoffs):\n                    nextD = dropoffs[j]\n                else:\n                    nextD = None\n                \n            print(i, j, currentCap)\n            if currentCap > capacity:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips.sort(key=lambda x: x[1] )\n        last_dest = max([x[2] for x in trips])\n        curr_pos = 0\n        \n        cap_ls = [0] * last_dest\n        for i in range(len(trips)):\n            for j in range(trips[i][1], trips[i][2]):\n                cap_ls[j] += trips[i][0]\n        \n        return max(cap_ls) <= capacity\n\n            \n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        ans_dic = [0]*1000\n        for i in trips:\n            for j in range(i[1], i[2]):\n                if ans_dic[j]:\n                    ans_dic[j] += i[0]\n                    if ans_dic[j] > capacity:\n                        return False\n                else:\n                    ans_dic[j] = i[0]\n        # print(ans_dic)\n        return True\n", "\nclass Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        totals = [0] * 1001\n        for (passengers, start, end) in trips:\n            for x in range(start, end):\n                totals[x] += passengers\n        return not any([x > capacity for x in totals])", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        counter = [0]* 1000\n        for elem in trips:\n            for i in range(elem[1], elem[2]):\n                counter[i] += elem[0]\n        if max(counter) > capacity:\n            return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        n = len(trips)\n        dp = [0]*1000\n        \n        for trip in trips:\n            num, s, e = trip[0], trip[1], trip[2]\n            for i in range(s, e):\n                dp[i] += num\n        print(dp)\n        for i in range(len(dp)):\n            if dp[i] > capacity:\n                return False\n            \n        return True\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n      milesDict = {}\n\n      for trip in trips:\n        passengers = trip[0]\n        start = trip[1]\n        end = trip[2]\n\n        mile = start\n\n        while mile < end:\n          if mile in milesDict:\n            milesDict[mile] = milesDict[mile] + passengers\n          else:\n            milesDict[mile] = passengers\n\n          mile = mile + 1\n\n      if max(milesDict.values()) <= capacity:\n        return True\n      else:\n        return False\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        d=dict()\n        ppl=0        \n        for i in trips:\n            d[i[1]]=d.get(i[1],0)+i[0]\n            for j in range(i[1]+1,i[2]):\n                d[j]=d.get(j,0)+i[0]\n        for i in list(d.values()):\n            if i>capacity:\n                return False\n        return True\n        \n        \n            \n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        d={}\n        for i in trips:\n            for j in range(i[1]+1,i[2]+1):\n                if j not in d:\n                    d[j]=i[0]\n                else:\n                    d[j]+=i[0]\n        #print(d)\n        for i in d:\n            if d[i]>capacity:\n                return 0\n        return 1\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        kmlist = {}\n        trips.sort(key=lambda x: (x[1], x[2]))\n        for trip in trips:\n            for i in range(trip[1], trip[2]):\n                if i in kmlist:\n                    kmlist[i] += trip[0]\n                else:\n                    kmlist[i] = trip[0]\n        maxval = max(kmlist.values())\n        return maxval <= capacity\n                    \n\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n          milesDict = {}\n          for trip in trips:\n            passengers = trip[0]\n            start = trip[1]\n            end = trip[2]\n            mile = start\n            while mile < end:\n              if mile in milesDict:\n                milesDict[mile] = milesDict[mile] + passengers\n              else:\n                milesDict[mile] = passengers\n              mile = mile + 1\n          if max(milesDict.values()) <= capacity:\n            return True\n          else:\n            return False", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        events = [[x[1],x[0]] for x in trips] + [[x[2],-x[0]] for x in trips]\n        events.sort()\n        n = 0\n        for event in events:\n            n += event[1]\n            if n > capacity:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        # create a array res, res[i] == passenger at place i\n        # go through list and add trips[0] to [trips[1], trips[2])\n        # check if max(res) <= capacity, if not, false\n        \n        res = [0]*1000\n        \n        for trip in trips:\n            passenger, start,end = trip\n            for i in range(start,end):\n                res[i]+= passenger\n        return max(res) <=capacity ", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        if not trips:\n            return True\n        firstStop = 1001\n        lastStop = -1\n        for trip in trips:\n            firstStop = min(firstStop, trip[1])\n            lastStop = max(lastStop, trip[2])\n        stops = [0] * (lastStop-firstStop+1)\n        for trip in trips:\n            for i in range(trip[1], trip[2]):\n                stops[i-firstStop] += trip[0]\n                if stops[i-firstStop] > capacity:\n                    return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        p_list = list()\n        for p, s, e in trips:\n            if len(p_list) < e:\n                p_list += [0]*(e - len(p_list))\n            for i in range(s, e):\n                p_list[i] += p\n                if p_list[i] > capacity:\n                    return False\n        \n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        def car_pooling(trips, capacity):\n            trips.sort(key=lambda x: x[1])\n\n            timeline = {}\n            for trip in trips:\n                for t in range(trip[1], trip[2]):\n                    timeline[t] = timeline.get(t, 0) + trip[0]\n\n            for t in timeline:\n                if timeline[t] > capacity:\n                    return False\n            return True\n        return car_pooling(trips, capacity)", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        ma = float('-inf')\n        trips = sorted(trips, key=lambda v: v[1])\n        for i in range(len(trips)):\n            tmp = 0\n            for j in range(i+1):\n                if trips[j][2] > trips[i][1]:\n                    tmp += trips[j][0]\n            ma = max(tmp, ma)\n        return ma <= capacity", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        passIn = [[item[1],item[0]] for item in trips]\n        passOut = [[item[2],-item[0]] for item in trips]\n        setOfTimes = list(set([item[1] for item in trips]+[item[2] for item in trips]))\n        setOfTimes.sort()\n        ans = True\n        counter = 0\n        for time in setOfTimes:\n            if ans == True:\n                for item in passIn+passOut:\n                    if item[0] == time:\n                        counter += item[1]\n                if counter>capacity:\n                    ans = False\n        return ans\n", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        d = {}\n        for (passengers, start, end) in trips:\n            for i in range(start, end):\n                if d.get(i) == None:\n                    d[i] = passengers\n                else:\n                    d[i] += passengers\n\n        for x in d:\n            if d[x] > capacity:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        end = 0\n        inCar = 0\n        for i in range(0,len(trips)):\n            if trips[i][2] > end:\n                end = trips[i][2]\n        for i in range(1,end):\n            for item in trips:\n                if item[2] == i:\n                    inCar -= item[0]\n                elif item[1] == i:\n                    inCar += item[0]\n            if inCar > capacity:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        d = {}\n        for (passengers, start, end) in trips:\n            # print(passengers, start, end)\n            for i in range(start, end):\n                if d.get(i) == None:\n                    d[i] = passengers\n                    # print(d[i])\n                else:\n                    d[i] += passengers\n                    # print(d[i])\n\n        for x in d:\n            if d[x] > capacity:\n                return False\n        return True", "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        \n        \n        trips.sort(key = lambda x: x[1])\n        heap = []\n        cur = 0\n        \n        for pas, start, end in trips:\n            \n            while heap and heap[0][0] <= start:\n                cur -= heappop(heap)[1]\n            \n            heappush(heap, (end, pas))\n            cur += pas\n            if cur > capacity:\n                return False\n        return True\n"]
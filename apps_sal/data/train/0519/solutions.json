["# cook your dish here\r\nimport bisect\r\nn, k1, *l = map(int, input().split())\r\nv_l, b_l = l[:n], l[n:]\r\n\r\nb_inv = {key:[] for key in range(2*k1)}\r\nfor i in range(n):\r\n    b_l[i] -= 1\r\n    b_inv[b_l[i]].append(i)\r\n\r\ndp = [[0 for _ in range(n)] for _ in range(n)]\r\nfor k in range(1, n):\r\n    for j in range(n-2, -1, -1):\r\n        if j+k >= n:\r\n            continue\r\n        \r\n        dp[j][j+k] = max(dp[j][j+k], dp[j][j+k-1])\r\n        if b_l[j+k] >= k1:\r\n            left = bisect.bisect_right(b_inv[b_l[j+k]-k1], j)\r\n            \r\n            if b_l[j+k] >= k1:\r\n                for i in b_inv[b_l[j+k]-k1][left:]:\r\n                    if i > j+k:\r\n                        break\r\n                    if i > j:\r\n                        dp[j][j+k] = max(dp[j][j+k], dp[j][i-1]+dp[i][j+k])\r\n                \r\n        if b_l[j+k]-k1 == b_l[j]:\r\n            if j+k-1 < n:\r\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j]+dp[j+1][j+k-1])\r\n            else:\r\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j])\r\n        \r\n\r\nprint(dp[0][-1])", "a,b,*c=list(map(int,input().strip().split()))\r\nd=[]\r\ne=[]\r\nfor i in range(a):\r\n    e.append(c[i])\r\n    d.append(c[i+a])\r\nDP1=[[-1 for i in range(a)] for j in range(a)]\r\ndef DP(l,r):\r\n    nonlocal d,e,b,DP1\r\n    if l>=r:\r\n        return 0\r\n    elif DP1[l][r]!=-1:\r\n        return DP1[l][r]\r\n    else:\r\n        DP1[l][r]=max(DP1[l][r],DP(l+1,r))\r\n        DP1[l][r]=max(DP1[l][r],DP(l,r-1))\r\n        if d[l]+b==d[r]:\r\n            DP1[l][r]=max(DP1[l][r],e[l]+e[r]+DP(l+1,r-1))\r\n        for i in range(l,r):\r\n            if d[l]+b==d[i] or d[i]+b==d[r]:\r\n                DP1[l][r]=max(DP1[l][r],DP(l,i)+DP(i+1,r))\r\n    return DP1[l][r]\r\nprint(DP(0,a-1))\r\n", "a,b,*c=list(map(int,input().strip().split()))\r\nd=[]\r\ne=[]\r\nfor i in range(a):\r\n    e.append(c[i])\r\n    d.append(c[i+a])\r\nDP1=[[-1 for i in range(a)] for j in range(a)]\r\ndef DP(l,r):\r\n    nonlocal d,e,b,DP1\r\n    if l>=r:\r\n        return 0\r\n    elif DP1[l][r]!=-1:\r\n        return DP1[l][r]\r\n    else:\r\n        #DP1[l][r]=max(DP1[l][r],DP(l+1,r))\r\n        #DP1[l][r]=max(DP1[l][r],DP(l,r-1))\r\n        if d[l]+b==d[r]:\r\n            DP1[l][r]=max(DP1[l][r],e[l]+e[r]+DP(l+1,r-1))\r\n        for i in range(l,r):\r\n            DP1[l][r]=max(DP1[l][r],DP(l,i)+DP(i+1,r))\r\n    return DP1[l][r]\r\nprint(DP(0,a-1))\r\n", "# cook your dish here\nimport bisect\nn, k1, *l = map(int, input().split())\nv_l, b_l = l[:n], l[n:]\n\nb_inv = {key:[] for key in range(2*k1)}\nfor i in range(n):\n    b_l[i] -= 1\n    b_inv[b_l[i]].append(i)\n\ndp = [[0 for _ in range(n)] for _ in range(n)]\nfor k in range(1, n):\n    for j in range(n-2, -1, -1):\n        if j+k >= n:\n            continue\n        \n        dp[j][j+k] = max(dp[j][j+k], dp[j][j+k-1])\n        if b_l[j+k] >= k1:\n            left = bisect.bisect_right(b_inv[b_l[j+k]-k1], j)\n            \n            if b_l[j+k] >= k1:\n                for i in b_inv[b_l[j+k]-k1][left:]:\n                    if i > j+k:\n                        break\n                    if i > j:\n                        dp[j][j+k] = max(dp[j][j+k], dp[j][i-1]+dp[i][j+k])\n                \n        if b_l[j+k]-k1 == b_l[j]:\n            if j+k-1 < n:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j]+dp[j+1][j+k-1])\n            else:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j])\n        \n\nprint(dp[0][-1])", "# cook your dish here\r\ninpu=list(map(int,input().split()))\r\nn,k=inpu[0],inpu[1]\r\nv=inpu[2:n+2]\r\nb=inpu[n+2:2*n+2]\r\nbrac={i:set() for i in range(n)}\r\nfor i in range(n):\r\n    for j in range(i+1,n):\r\n        if b[j]-b[i]==k:\r\n            brac[i].add(j)\r\n        \r\ndp=[[0 for i in range(n)] for j in range(n)]\r\nfor j in range(1,n):\r\n    for  i in range(n-j):\r\n        ans=-float(\"inf\")\r\n        if i+j in brac[i]:\r\n            if j==1:\r\n                ans=max(ans,v[i+j]+v[i])\r\n            else:\r\n                ans=max(ans,v[i+j]+v[i]+dp[i+1][i+j-1])\r\n        for l in brac[i]:\r\n            if l>=i+j:\r\n                continue\r\n            if b[l]-b[i]==k:\r\n                if l==i+1:\r\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j])\r\n                else:\r\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j]+dp[i+1][l-1])\r\n        ans=max(ans,dp[i+1][i+j])\r\n        dp[i][i+j]=ans\r\nprint(dp[0][n-1])\r\n", "# cook your dish here\nimport bisect\n# def recur(s_i, e_i, end_i):\n#     # if end_i in dp[s_i] and e_i in dp[s_i][end_i]:\n#     #     return dp[s_i][end_i][e_i]\n        \n#     inside = 0\n#     for i in range(s_i+1, e_i):\n#         if b_l[i] < k:\n#             if e_i not in dp[i]:\n#                 dp[i][e_i] = 0\n#                 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#                 for ind in b_inv[b_l[i]+k][bi_i:]:\n#                     if i < ind < e_i:\n#                         dp[i][e_i] = max(dp[i][e_i], recur(i, ind, e_i))\n#             inside = max(inside, dp[i][e_i])\n#     outside = 0\n#     for i in range(e_i+1, min(n, end_i)):\n#         if b_l[i] < k:\n#             if end_i not in dp[i]:\n#                 dp[i][end_i] = 0\n#                 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#                 for ind in b_inv[b_l[i]+k][bi_i:]:\n#                     if i < ind < end_i:\n#                         dp[i][end_i] = max(dp[i][end_i], recur(i, ind, end_i))\n#             outside = max(outside, dp[i][end_i])\n                    \n#     # if end_i not in dp[s_i]:\n#     #     dp[s_i][end_i] = {}\n#     # dp[s_i][end_i].update({e_i: v_l[s_i] + v_l[e_i] + outside + inside})\n#     # return dp[s_i][end_i][e_i]\n#     return v_l[s_i] + v_l[e_i] + outside + inside\n    \nn, k1, *l = map(int, input().split())\nv_l, b_l = l[:n], l[n:]\n\nb_inv = {key:[] for key in range(2*k1)}\nfor i in range(n):\n    b_l[i] -= 1\n    b_inv[b_l[i]].append(i)\n\ndp = [[0 for _ in range(n)] for _ in range(n)]\nfor k in range(1, n):\n    for j in range(n-2, -1, -1):\n        if j+k >= n:\n            continue\n        \n        dp[j][j+k] = max(dp[j][j+k], dp[j][j+k-1])\n        if b_l[j+k] >= k1:\n            left = bisect.bisect_right(b_inv[b_l[j+k]-k1], j)\n            \n            if b_l[j+k] >= k1:\n                for i in b_inv[b_l[j+k]-k1][left:]:\n                    if i > j+k:\n                        break\n                    if i > j:\n                        dp[j][j+k] = max(dp[j][j+k], dp[j][i-1]+dp[i][j+k])\n                \n        if b_l[j+k]-k1 == b_l[j]:\n            if j+k-1 < n:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j]+dp[j+1][j+k-1])\n            else:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j])\n        \n# dp = [{} for _ in range(n)]\n# ans = 0\n# for i in range(n):\n#     if b_l[i] < k:\n#         if n+1 not in dp[i]:\n#             dp[i][n+1] = 0\n#             bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#             for ind in b_inv[b_l[i]+k][bi_i:]:\n#                 if i < ind:\n#                     dp[i][n+1] = max(dp[i][n+1], recur(i, ind, n+1))\n#         ans = max(ans, dp[i][n+1])\n# print(dp)\nprint(dp[0][-1])", "# cook your dish here\nimport bisect\n# def recur(s_i, e_i, end_i):\n#     # if end_i in dp[s_i] and e_i in dp[s_i][end_i]:\n#     #     return dp[s_i][end_i][e_i]\n        \n#     inside = 0\n#     for i in range(s_i+1, e_i):\n#         if b_l[i] < k:\n#             if e_i not in dp[i]:\n#                 dp[i][e_i] = 0\n#                 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#                 for ind in b_inv[b_l[i]+k][bi_i:]:\n#                     if i < ind < e_i:\n#                         dp[i][e_i] = max(dp[i][e_i], recur(i, ind, e_i))\n#             inside = max(inside, dp[i][e_i])\n#     outside = 0\n#     for i in range(e_i+1, min(n, end_i)):\n#         if b_l[i] < k:\n#             if end_i not in dp[i]:\n#                 dp[i][end_i] = 0\n#                 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#                 for ind in b_inv[b_l[i]+k][bi_i:]:\n#                     if i < ind < end_i:\n#                         dp[i][end_i] = max(dp[i][end_i], recur(i, ind, end_i))\n#             outside = max(outside, dp[i][end_i])\n                    \n#     # if end_i not in dp[s_i]:\n#     #     dp[s_i][end_i] = {}\n#     # dp[s_i][end_i].update({e_i: v_l[s_i] + v_l[e_i] + outside + inside})\n#     # return dp[s_i][end_i][e_i]\n#     return v_l[s_i] + v_l[e_i] + outside + inside\n    \nn, k1, *l = map(int, input().split())\nv_l, b_l = l[:n], l[n:]\n\nb_inv = {key:[] for key in range(2*k1)}\nfor i in range(n):\n    b_l[i] -= 1\n    b_inv[b_l[i]].append(i)\n\ndp = [[0 for _ in range(n)] for _ in range(n)]\nfor k in range(1, n):\n    for j in range(n-2, -1, -1):\n        if j+k >= n:\n            continue\n        \n        dp[j][j+k] = max(dp[j][j+k], dp[j][j+k-1])\n        if b_l[j+k] >= k1:\n            left = bisect.bisect_left(b_inv[b_l[j+k]-k1], j)\n            \n            if b_l[j+k] >= k1:\n                for i in b_inv[b_l[j+k]-k1][left:]:\n                    if i > j+k:\n                        break\n                    dp[j][j+k] = max(dp[j][j+k], dp[j][i-1]+dp[i][j+k])\n                \n        if b_l[j+k]-k1 == b_l[j]:\n            if j+k-1 < n:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j]+dp[j+1][j+k-1])\n            else:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j])\n        \n# dp = [{} for _ in range(n)]\n# ans = 0\n# for i in range(n):\n#     if b_l[i] < k:\n#         if n+1 not in dp[i]:\n#             dp[i][n+1] = 0\n#             bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#             for ind in b_inv[b_l[i]+k][bi_i:]:\n#                 if i < ind:\n#                     dp[i][n+1] = max(dp[i][n+1], recur(i, ind, n+1))\n#         ans = max(ans, dp[i][n+1])\n# print(dp)\nprint(dp[0][-1])", "# cook your dish here\n# import bisect\n# def recur(s_i, e_i, end_i):\n#     # if end_i in dp[s_i] and e_i in dp[s_i][end_i]:\n#     #     return dp[s_i][end_i][e_i]\n        \n#     inside = 0\n#     for i in range(s_i+1, e_i):\n#         if b_l[i] < k:\n#             if e_i not in dp[i]:\n#                 dp[i][e_i] = 0\n#                 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#                 for ind in b_inv[b_l[i]+k][bi_i:]:\n#                     if i < ind < e_i:\n#                         dp[i][e_i] = max(dp[i][e_i], recur(i, ind, e_i))\n#             inside = max(inside, dp[i][e_i])\n#     outside = 0\n#     for i in range(e_i+1, min(n, end_i)):\n#         if b_l[i] < k:\n#             if end_i not in dp[i]:\n#                 dp[i][end_i] = 0\n#                 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#                 for ind in b_inv[b_l[i]+k][bi_i:]:\n#                     if i < ind < end_i:\n#                         dp[i][end_i] = max(dp[i][end_i], recur(i, ind, end_i))\n#             outside = max(outside, dp[i][end_i])\n                    \n#     # if end_i not in dp[s_i]:\n#     #     dp[s_i][end_i] = {}\n#     # dp[s_i][end_i].update({e_i: v_l[s_i] + v_l[e_i] + outside + inside})\n#     # return dp[s_i][end_i][e_i]\n#     return v_l[s_i] + v_l[e_i] + outside + inside\n    \nn, k1, *l = map(int, input().split())\nv_l, b_l = l[:n], l[n:]\n\nb_inv = {key:[] for key in range(2*k1)}\nfor i in range(n):\n    b_l[i] -= 1\n    b_inv[b_l[i]].append(i)\n\ndp = [[0 for _ in range(n)] for _ in range(n)]\nfor k in range(1, n):\n    for j in range(n-2, -1, -1):\n        if j+k >= n:\n            continue\n        \n        dp[j][j+k] = max(dp[j][j+k], dp[j][j+k-1])\n        if b_l[j+k] >= k1:\n            for i in reversed(b_inv[b_l[j+k]-k1]):\n                if i <= j:\n                    break\n                dp[j][j+k] = max(dp[j][j+k], dp[j][i-1]+dp[i][j+k])\n            \n        if b_l[j+k]-k1 == b_l[j]:\n            if j+k-1 < n:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j]+dp[j+1][j+k-1])\n            else:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j])\n        \n# dp = [{} for _ in range(n)]\n# ans = 0\n# for i in range(n):\n#     if b_l[i] < k:\n#         if n+1 not in dp[i]:\n#             dp[i][n+1] = 0\n#             bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#             for ind in b_inv[b_l[i]+k][bi_i:]:\n#                 if i < ind:\n#                     dp[i][n+1] = max(dp[i][n+1], recur(i, ind, n+1))\n#         ans = max(ans, dp[i][n+1])\n# print(dp)\nprint(dp[0][-1])", "# cook your dish here\n# import bisect\n# def recur(s_i, e_i, end_i):\n#     # if end_i in dp[s_i] and e_i in dp[s_i][end_i]:\n#     #     return dp[s_i][end_i][e_i]\n        \n#     inside = 0\n#     for i in range(s_i+1, e_i):\n#         if b_l[i] < k:\n#             if e_i not in dp[i]:\n#                 dp[i][e_i] = 0\n#                 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#                 for ind in b_inv[b_l[i]+k][bi_i:]:\n#                     if i < ind < e_i:\n#                         dp[i][e_i] = max(dp[i][e_i], recur(i, ind, e_i))\n#             inside = max(inside, dp[i][e_i])\n#     outside = 0\n#     for i in range(e_i+1, min(n, end_i)):\n#         if b_l[i] < k:\n#             if end_i not in dp[i]:\n#                 dp[i][end_i] = 0\n#                 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#                 for ind in b_inv[b_l[i]+k][bi_i:]:\n#                     if i < ind < end_i:\n#                         dp[i][end_i] = max(dp[i][end_i], recur(i, ind, end_i))\n#             outside = max(outside, dp[i][end_i])\n                    \n#     # if end_i not in dp[s_i]:\n#     #     dp[s_i][end_i] = {}\n#     # dp[s_i][end_i].update({e_i: v_l[s_i] + v_l[e_i] + outside + inside})\n#     # return dp[s_i][end_i][e_i]\n#     return v_l[s_i] + v_l[e_i] + outside + inside\n    \nn, k1, *l = map(int, input().split())\nv_l, b_l = l[:n], l[n:]\n\nb_inv = {key:[] for key in range(2*k1)}\nfor i in range(n):\n    b_l[i] -= 1\n    b_inv[b_l[i]].append(i)\n\ndp = [[0 for _ in range(n)] for _ in range(n)]\nfor k in range(1, n):\n    for j in range(n-2, -1, -1):\n        if j+k >= n:\n            continue\n        \n        dp[j][j+k] = max(dp[j][j+k], dp[j][j+k-1])\n        dp[j][j+k] = max(dp[j][j+k], dp[j+1][j+k])\n        if b_l[j+k] >= k1:\n            for i in b_inv[b_l[j+k]-k1]:\n                dp[j][j+k] = max(dp[j][j+k], dp[j][i-1]+dp[i][j+k])\n            \n        if b_l[j+k]-k1 == b_l[j]:\n            if j+k-1 < n:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j]+dp[j+1][j+k-1])\n            else:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j])\n        \n# dp = [{} for _ in range(n)]\n# ans = 0\n# for i in range(n):\n#     if b_l[i] < k:\n#         if n+1 not in dp[i]:\n#             dp[i][n+1] = 0\n#             bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#             for ind in b_inv[b_l[i]+k][bi_i:]:\n#                 if i < ind:\n#                     dp[i][n+1] = max(dp[i][n+1], recur(i, ind, n+1))\n#         ans = max(ans, dp[i][n+1])\n# print(dp)\nprint(dp[0][-1])", "# cook your dish here\n# import bisect\n# def recur(s_i, e_i, end_i):\n#     # if end_i in dp[s_i] and e_i in dp[s_i][end_i]:\n#     #     return dp[s_i][end_i][e_i]\n        \n#     inside = 0\n#     for i in range(s_i+1, e_i):\n#         if b_l[i] < k:\n#             if e_i not in dp[i]:\n#                 dp[i][e_i] = 0\n#                 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#                 for ind in b_inv[b_l[i]+k][bi_i:]:\n#                     if i < ind < e_i:\n#                         dp[i][e_i] = max(dp[i][e_i], recur(i, ind, e_i))\n#             inside = max(inside, dp[i][e_i])\n#     outside = 0\n#     for i in range(e_i+1, min(n, end_i)):\n#         if b_l[i] < k:\n#             if end_i not in dp[i]:\n#                 dp[i][end_i] = 0\n#                 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#                 for ind in b_inv[b_l[i]+k][bi_i:]:\n#                     if i < ind < end_i:\n#                         dp[i][end_i] = max(dp[i][end_i], recur(i, ind, end_i))\n#             outside = max(outside, dp[i][end_i])\n                    \n#     # if end_i not in dp[s_i]:\n#     #     dp[s_i][end_i] = {}\n#     # dp[s_i][end_i].update({e_i: v_l[s_i] + v_l[e_i] + outside + inside})\n#     # return dp[s_i][end_i][e_i]\n#     return v_l[s_i] + v_l[e_i] + outside + inside\n    \nn, k1, *l = map(int, input().split())\nv_l, b_l = l[:n], l[n:]\n\n# b_inv = {key:[] for key in range(2*k)}\nfor i in range(n):\n    b_l[i] -= 1\n    # b_inv[b_l[i]].append(i)\n\ndp = [[0 for _ in range(n)] for _ in range(n)]\nfor k in range(1, n):\n    for j in range(n-2, -1, -1):\n        if j+k >= n:\n            continue\n        elif b_l[j+k]-k1 == b_l[j]:\n            if j+k-1 < n:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j]+dp[j+1][j+k-1])\n            else:\n                dp[j][j+k] = max(dp[j][j+k], v_l[j+k]+v_l[j])\n        for i in range(j, j+k):\n            dp[j][j+k] = max(dp[j][j+k], dp[j][i]+dp[i+1][j+k])\n        \n# dp = [{} for _ in range(n)]\n# ans = 0\n# for i in range(n):\n#     if b_l[i] < k:\n#         if n+1 not in dp[i]:\n#             dp[i][n+1] = 0\n#             bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n#             for ind in b_inv[b_l[i]+k][bi_i:]:\n#                 if i < ind:\n#                     dp[i][n+1] = max(dp[i][n+1], recur(i, ind, n+1))\n#         ans = max(ans, dp[i][n+1])\n# print(dp)\nprint(dp[0][-1])", "# cook your dish here\nimport bisect\ndef recur(s_i, e_i, end_i):\n    # if end_i in dp[s_i] and e_i in dp[s_i][end_i]:\n    #     return dp[s_i][end_i][e_i]\n        \n    inside = 0\n    for i in range(s_i+1, e_i):\n        if b_l[i] < k:\n            if e_i not in dp[i]:\n                dp[i][e_i] = 0\n                bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n                for ind in b_inv[b_l[i]+k][bi_i:]:\n                    if i < ind < e_i:\n                        dp[i][e_i] = max(dp[i][e_i], recur(i, ind, e_i))\n            inside = max(inside, dp[i][e_i])\n    outside = 0\n    for i in range(e_i+1, min(n, end_i)):\n        if b_l[i] < k:\n            if end_i not in dp[i]:\n                dp[i][end_i] = 0\n                bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n                for ind in b_inv[b_l[i]+k][bi_i:]:\n                    if i < ind < end_i:\n                        dp[i][end_i] = max(dp[i][end_i], recur(i, ind, end_i))\n            outside = max(outside, dp[i][end_i])\n                    \n    # if end_i not in dp[s_i]:\n    #     dp[s_i][end_i] = {}\n    # dp[s_i][end_i].update({e_i: v_l[s_i] + v_l[e_i] + outside + inside})\n    # return dp[s_i][end_i][e_i]\n    return v_l[s_i] + v_l[e_i] + outside + inside\n    \nn, k, *l = map(int, input().split())\nv_l, b_l = l[:n], l[n:]\n\nb_inv = {key:[] for key in range(2*k)}\nfor i in range(n):\n    b_l[i] -= 1\n    b_inv[b_l[i]].append(i)\n\ndp = [{} for _ in range(n)]\nans = 0\nfor i in range(n):\n    if b_l[i] < k:\n        if n+1 not in dp[i]:\n            dp[i][n+1] = 0\n            bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n            for ind in b_inv[b_l[i]+k][bi_i:]:\n                if i < ind:\n                    dp[i][n+1] = max(dp[i][n+1], recur(i, ind, n+1))\n        ans = max(ans, dp[i][n+1])\n# print(dp)\nprint(ans)", "# cook your dish here\nimport bisect\ndef recur(s_i, e_i, end_i):\n    if end_i in dp[s_i] and e_i in dp[s_i][end_i]:\n        return dp[s_i][end_i][e_i]\n        \n    inside = 0\n    for i in range(s_i+1, e_i):\n        if b_l[i] < k:\n            bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n            for ind in b_inv[b_l[i]+k][bi_i:]:\n                if i < ind < e_i:\n                    inside = max(inside, recur(i, ind, e_i))\n    outside = 0\n    for i in range(e_i+1, min(n, end_i)):\n        if b_l[i] < k:\n            bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n            for ind in b_inv[b_l[i]+k][bi_i:]:\n                if i < ind < end_i:\n                    outside = max(outside, recur(i, ind, end_i))\n    if end_i not in dp[s_i]:\n        dp[s_i][end_i] = {}\n    dp[s_i][end_i].update({e_i: v_l[s_i] + v_l[e_i] + outside + inside})\n    return dp[s_i][end_i][e_i]\n    \nn, k, *l = map(int, input().split())\nv_l, b_l = l[:n], l[n:]\n\nb_inv = {key:[] for key in range(2*k)}\nfor i in range(n):\n    b_l[i] -= 1\n    b_inv[b_l[i]].append(i)\n\ndp = [{} for _ in range(n)]\nans = 0\nfor i in range(n):\n    if b_l[i] < k:\n        bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n        for ind in b_inv[b_l[i]+k][bi_i:]:\n            if i < ind:\n                ans = max(ans, recur(i, ind, n+1))\n# print(dp)\nprint(ans)", "# cook your dish here\nimport bisect\ndef recur(s_i, e_i, end_i):\n    inside = 0\n    for i in range(s_i+1, e_i):\n        if b_l[i] < k:\n            bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n            for ind in b_inv[b_l[i]+k][bi_i:]:\n                if i < ind < e_i:\n                    dp[i][e_i] = recur(i, ind, e_i)\n                    inside = max(inside, dp[i][e_i])\n    outside = 0\n    for i in range(e_i+1, min(n, end_i)):\n        if b_l[i] < k:\n            bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n            for ind in b_inv[b_l[i]+k][bi_i:]:\n                if i < ind < end_i:\n                    dp[i][end_i] = recur(i, ind, end_i)\n                    outside = max(outside, dp[i][end_i])\n    return v_l[s_i] + v_l[e_i] + outside + inside\n    \nn, k, *l = map(int, input().split())\nv_l, b_l = l[:n], l[n:]\n\nb_inv = {key:[] for key in range(2*k)}\nfor i in range(n):\n    b_l[i] -= 1\n    b_inv[b_l[i]].append(i)\n\ndp = [{} for _ in range(n)]\nans = 0\nfor i in range(n):\n    if b_l[i] < k:\n        bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)\n        for ind in b_inv[b_l[i]+k][bi_i:]:\n            if i < ind:\n                dp[i][n+1] = recur(i, ind, n+1)\n                ans = max(ans, dp[i][n+1])\n# print(dp)\nprint(ans)", "# -*- coding: utf-8 -*-\r\n\r\nimport math\r\nimport collections\r\nimport bisect\r\nimport heapq\r\nimport time\r\nimport random\r\nimport itertools\r\nimport sys\r\n\r\n\"\"\"\r\ncreated by shhuan at 2019/11/30 21:18\r\n\r\n\"\"\"\r\n\r\nL = [int(x) for x in input().split()]\r\nN = L[0]\r\nK = L[1]\r\nV = L[2: 2+N]\r\nB = L[2+N:]\r\n\r\n# N = 700\r\n# K = 7\r\n# V = [random.randint(0, 10) for _ in range(N)]\r\n# B = [random.randint(1, K*2) for _ in range(N)]\r\n# N, K = 6, 3\r\n# V = [4, 5, -2, 1, 1, 6]\r\n# B = [1, 3, 4, 2, 5, 6]\r\n\r\n# t0 = time.time()\r\nbi = collections.defaultdict(list)\r\nfor i, v in enumerate(B):\r\n    bi[v].append(i)\r\n\r\n\r\ndp = [[float('-inf') for _ in range(N+1)] for _ in range(N)]\r\nfor i in range(N):\r\n    dp[i][1] = 0\r\n    dp[i][0] = 0\r\n\r\nans = 0\r\nfor l in range(2, N+1):\r\n    for s in range(N-l+1):\r\n        t = s+l-1\r\n        dp[s][l] = max(dp[s][l], dp[s][l-1])\r\n\r\n        pres = bi[B[t]-K]\r\n        pl, pr = bisect.bisect_left(pres, s), bisect.bisect_right(pres, t)\r\n        for i in pres[pl: pr]:\r\n            dp[s][l] = max(dp[s][l], V[i] + V[t] + dp[s][max(i-s, 0)] + dp[i+1][max(t-i-1, 0)])\r\n            ans = max(ans, dp[s][l])\r\nprint(ans)\r\n", "# -*- coding: utf-8 -*-\r\n\r\nimport math\r\nimport collections\r\nimport bisect\r\nimport heapq\r\nimport time\r\nimport random\r\nimport itertools\r\nimport sys\r\n\r\n\"\"\"\r\ncreated by shhuan at 2019/11/30 21:18\r\n\r\n\"\"\"\r\n\r\nL = [int(x) for x in input().split()]\r\nN = L[0]\r\nK = L[1]\r\nV = L[2: 2+N]\r\nB = L[2+N:]\r\n\r\n# N = 700\r\n# K = 7\r\n# V = [random.randint(0, 10) for _ in range(N)]\r\n# B = [random.randint(1, K*2) for _ in range(N)]\r\n# N, K = 6, 3\r\n# V = [4, 5, -2, 1, 1, 6]\r\n# B = [1, 3, 4, 2, 5, 6]\r\n\r\n# t0 = time.time()\r\nbi = [[] for _ in range(20)]\r\nL = []\r\nfor i, v in enumerate(B):\r\n    bi[v].append(i)\r\n    if v <= K:\r\n        L.append(i)\r\n\r\n\r\ndp = [[float('-inf') for _ in range(N+1)] for _ in range(N)]\r\nfor i in range(N):\r\n    dp[i][1] = 0\r\n    dp[i][0] = 0\r\n\r\nans = 0\r\nfor l in range(2, N+1):\r\n    for s in range(N-l+1):\r\n        t = s+l-1\r\n        dp[s][l] = max(dp[s][l], dp[s][l-1])\r\n\r\n        pres = bi[B[t]-K]\r\n        pl, pr = bisect.bisect_left(pres, s), bisect.bisect_right(pres, t)\r\n        for i in pres[pl: pr]:\r\n            dp[s][l] = max(dp[s][l], V[i] + V[t] + dp[s][max(i-s, 0)] + dp[i+1][max(t-i-1, 0)])\r\n            ans = max(ans, dp[s][l])\r\nprint(ans)\r\n", "# -*- coding: utf-8 -*-\r\n\r\nimport math\r\nimport collections\r\nimport bisect\r\nimport heapq\r\nimport time\r\nimport random\r\nimport itertools\r\nimport sys\r\n\r\n\"\"\"\r\ncreated by shhuan at 2019/11/30 21:18\r\n\r\n\"\"\"\r\n\r\nL = [int(x) for x in input().split()]\r\nN = L[0]\r\nK = L[1]\r\nV = L[2: 2+N]\r\nB = L[2+N:]\r\n\r\n# N = 700\r\n# K = 7\r\n# V = [random.randint(0, 10) for _ in range(N)]\r\n# B = [random.randint(1, K*2) for _ in range(N)]\r\n# N, K = 6, 3\r\n# V = [4, 5, -2, 1, 1, 6]\r\n# B = [1, 3, 4, 2, 5, 6]\r\n\r\n# t0 = time.time()\r\nbi = [[] for _ in range(20)]\r\nL = []\r\nfor i, v in enumerate(B):\r\n    bi[v].append(i)\r\n    if v <= K:\r\n        L.append(i)\r\n\r\n\r\ndp = [[float('-inf') for _ in range(N+1)] for _ in range(N)]\r\nfor i in range(N):\r\n    dp[i][1] = 0\r\n    dp[i][0] = 0\r\n\r\nans = 0\r\nfor l in range(2, N+1):\r\n    for s in range(N-l+1):\r\n        t = s+l-1\r\n        dp[s][l] = max(dp[s][l], dp[s][l-1])\r\n        for i in range(s, t+1):\r\n            if B[i] + K == B[t]:\r\n                dp[s][l] = max(dp[s][l], V[i] + V[t] + dp[s][max(i-s, 0)] + dp[i+1][max(t-i-1, 0)])\r\n                ans = max(ans, dp[s][l])\r\nprint(ans)\r\n", "# -*- coding: utf-8 -*-\r\n\r\nimport math\r\nimport collections\r\nimport bisect\r\nimport heapq\r\nimport time\r\nimport random\r\nimport itertools\r\nimport sys\r\n\r\n\"\"\"\r\ncreated by shhuan at 2019/11/30 21:18\r\n\r\n\"\"\"\r\n\r\nL = [int(x) for x in input().split()]\r\n\r\nN = L[0]\r\nK = L[1]\r\nV = L[2: 2+N]\r\nB = L[2+N:]\r\n\r\n\r\nbi = collections.defaultdict(list)\r\nfor i, v in enumerate(B):\r\n    bi[v].append(i)\r\n\r\n\r\nmemo = {}\r\n\r\n\r\ndef dfs(l, r):\r\n    if l >= r:\r\n        return 0\r\n\r\n    k = (l, r)\r\n    if k in memo:\r\n        return memo[k]\r\n\r\n    ans = 0\r\n    for i in range(l, r):\r\n        br = bi[B[i]+K]\r\n        jl, jr = bisect.bisect_left(br, i), bisect.bisect_right(br, r)\r\n        for j in br[jl: jr]:\r\n            if i < j <= r:\r\n                ans = max(ans, V[i]+V[j] + dfs(i+1, j-1) + dfs(j+1, r))\r\n    memo[k] = ans\r\n\r\n    return ans\r\n\r\n\r\nprint(dfs(0, N-1))", "# -*- coding: utf-8 -*-\r\n\r\nimport math\r\nimport collections\r\nimport bisect\r\nimport heapq\r\nimport time\r\nimport random\r\nimport itertools\r\nimport sys\r\n\r\n\"\"\"\r\ncreated by shhuan at 2019/11/30 21:18\r\n\r\n\"\"\"\r\n\r\nL = [int(x) for x in input().split()]\r\n\r\nN = L[0]\r\nK = L[1]\r\nV = L[2: 2+N]\r\nB = L[2+N:]\r\n\r\n\r\nbi = collections.defaultdict(list)\r\nfor i, v in enumerate(B):\r\n    bi[v].append(i)\r\n\r\n\r\nmemo = {}\r\n\r\n\r\ndef dfs(l, r):\r\n    if l >= r:\r\n        return 0\r\n\r\n    k = (l, r)\r\n    if k in memo:\r\n        return memo[k]\r\n\r\n    ans = 0\r\n    for i in range(l, r):\r\n        for j in bi[B[i]+K]:\r\n            if i < j <= r:\r\n                ans = max(ans, V[i]+V[j] + dfs(i+1, j-1) + dfs(j+1, r))\r\n    memo[k] = ans\r\n\r\n    return ans\r\n\r\n\r\nprint(dfs(0, N-1))", "# cook your dish here\ninpu=list(map(int,input().split()))\nn,k=inpu[0],inpu[1]\nv=inpu[2:n+2]\nb=inpu[n+2:2*n+2]\nbrac={i:set() for i in range(n)}\nfor i in range(n):\n    for j in range(i+1,n):\n        if b[j]-b[i]==k:\n            brac[i].add(j)\n        \ndp=[[0 for i in range(n)] for j in range(n)]\nfor j in range(1,n):\n    for  i in range(n-j):\n        ans=-float(\"inf\")\n        if i+j in brac[i]:\n            if j==1:\n                ans=max(ans,v[i+j]+v[i])\n            else:\n                ans=max(ans,v[i+j]+v[i]+dp[i+1][i+j-1])\n        for l in brac[i]:\n            if l>=i+j:\n                continue\n            if b[l]-b[i]==k:\n                if l==i+1:\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j])\n                else:\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j]+dp[i+1][l-1])\n        ans=max(ans,dp[i+1][i+j])\n        dp[i][i+j]=ans\nprint(dp[0][n-1])\n", "# cook your dish here\ninpu=list(map(int,input().split()))\nn,k=inpu[0],inpu[1]\nv=inpu[2:n+2]\nb=inpu[n+2:2*n+2]\ndp=[[0 for i in range(n)] for j in range(n)]\nfor j in range(1,n):\n    for  i in range(n-j):\n        ans=-float(\"inf\")\n        if b[i+j]-b[i]==k:\n            if j==1:\n                ans=max(ans,v[i+j]+v[i])\n            else:\n                ans=max(ans,v[i+j]+v[i]+dp[i+1][i+j-1])\n        for l in range(i+1,i+j):\n            if b[l]-b[i]==k:\n                if l==i+1:\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j])\n                else:\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j]+dp[i+1][l-1])\n        ans=max(ans,dp[i+1][i+j])\n        dp[i][i+j]=ans\nprint(dp[0][n-1])\n\n", "# cook your dish here\ninpu=list(map(int,input().split()))\nn,k=inpu[0],inpu[1]\nv=inpu[2:n+2]\nb=inpu[n+2:2*n+2]\ndp=[[0 for i in range(n)] for j in range(n)]\nfor j in range(1,n):\n    for  i in range(n-j):\n        ans=-float(\"inf\")\n        if b[i+j]-b[i]==k:\n            if j==1:\n                ans=max(ans,v[i+j]+v[i])\n            else:\n                ans=max(ans,v[i+j]+v[i]+dp[i+1][i+j-1])\n        for l in range(i+1,i+j):\n            if b[l]-b[i]==k:\n                if l==i+1:\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j])\n                else:\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j]+dp[i+1][l-1])\n        ans=max(ans,dp[i+1][i+j])\n        dp[i][i+j]=ans\nprint(dp[0][n-1])\n", "inpu=list(map(int,input().split()))\r\nn,k=inpu[0],inpu[1]\r\nv=inpu[2:n+2]\r\nb=inpu[n+2:2*n+2]\r\nbrac={i:set() for i in range(n)}\r\nfor i in range(n):\r\n    for j in range(i+1,n):\r\n        if b[j]-b[i]==k:\r\n            brac[i].add(j)\r\n        \r\ndp=[[0 for i in range(n)] for j in range(n)]\r\nfor j in range(1,n):\r\n    for  i in range(n-j):\r\n        ans=-float(\"inf\")\r\n        if i+j in brac[i]:\r\n            if j==1:\r\n                ans=max(ans,v[i+j]+v[i])\r\n            else:\r\n                ans=max(ans,v[i+j]+v[i]+dp[i+1][i+j-1])\r\n        for l in brac[i]:\r\n            if l>=i+j:\r\n                continue\r\n            if b[l]-b[i]==k:\r\n                if l==i+1:\r\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j])\r\n                else:\r\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j]+dp[i+1][l-1])\r\n        ans=max(ans,dp[i+1][i+j])\r\n        dp[i][i+j]=ans\r\nprint(dp[0][n-1])\r\n", "inpu=list(map(int,input().split()))\r\nn,k=inpu[0],inpu[1]\r\nv=inpu[2:n+2]\r\nb=inpu[n+2:2*n+2]\r\ndp=[[0 for i in range(n)] for j in range(n)]\r\nfor j in range(1,n):\r\n    for  i in range(n-j):\r\n        ans=-float(\"inf\")\r\n        if b[i+j]-b[i]==k:\r\n            if j==1:\r\n                ans=max(ans,v[i+j]+v[i])\r\n            else:\r\n                ans=max(ans,v[i+j]+v[i]+dp[i+1][i+j-1])\r\n        for l in range(i+1,i+j):\r\n            if b[l]-b[i]==k:\r\n                if l==i+1:\r\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j])\r\n                else:\r\n                    ans=max(ans,v[l]+v[i]+dp[l+1][i+j]+dp[i+1][l-1])\r\n        ans=max(ans,dp[i+1][i+j])\r\n        dp[i][i+j]=ans\r\nprint(dp[0][n-1])\r\n"]
["def b(n):\n    if not n: return '0'\n    r = []\n    while n:\n        r.append(n % 2)\n        n = (n - n % 2) / -2\n    return ''.join(str(c) for c in r[::-1])\n\ndef d(n):\n    r = 0\n    for c in n: r = -2 * r + int(c)\n    return r\n\ndef skrzat(base, n):\n    if base == 'b': return 'From binary: %s is %d' % (n, d(n))\n    if base == 'd': return 'From decimal: %d is %s' % (n, b(n))\n    raise ValueError('unknown base')", "from math import log\nfrom math import ceil\n\ndef skrzat(base, number):\n    \n    if base == 'b':\n        return 'From binary: ' + number + ' is ' + str(toDecimal(number))\n    \n    if base == 'd':\n        return 'From decimal: ' + str(number) + ' is ' + toWBinary(number)\n    \ndef toDecimal(number):\n    if len(number) == 1:\n        return int(number)    \n    # e.g  (A) 1    -> 1    \n    # e.g  (B) 10   -> ( (1) * (-2) + 0 )\n    # e.g  (C) 101  -> ( (1) * (-2) + 0 ) * (-2) + 1 = B * (-2) + 1\n    # e.g  (D) 1010 -> C * (-2) + 0\n    # ...\n    return toDecimal(number[:-1]) * (-2) + int(number[-1])\n    \n# posCurrentOne is the position (0 is position of the right digit) of \n# the last 1 knew (left to right)\n# at the begining we don't know this position so we arbitrarily initialize\n# this to -1. It is useful for insert the zerros after\ndef toWBinary(number, posCurrentOne = int(-1)):\n    s = ''\n            \n    if not(number) :\n        if posCurrentOne == -1:\n            return '0'\n        # if we know the last 1 is in position 2, and the number is egal to 0,\n        # then we can complete with 2 zerros after and return the result  \n        s += '0' * posCurrentOne\n        return s    \n    \n    # We begin by calculate the number of digit necessary\n    # if number is egal to  1 we need 1 digits\n    # if number is egal to  2 we need 3 digits\n    # if number is egal to -1 we need 2 digits\n    # ...\n    \n    # if the number is > 0, we need odd  digits\n    # if the number is < 0, we need even digits\n    \n    # if number is > 0, if the number of digits usefull is N, then the greatest\n    # number possible is :\n    \n    # (-2 ** 0)                         = 1 for 1 digit\n    # (-2 ** 0) + (-2 ** 2)             = 5 for 3 digits\n    # (-2 ** 0) + (-2 ** 2) + (-2 ** 4) = 21 for 4 digits\n    \n    # so with S the max number with N digits we have:\n    # S = sum(i=1,(N+1)/2) [(-2) ** (2 * (i - 1))]\n    # it is egal to\n    # S = sum(i=0,(N-1)/2) [4 ** i]\n    # so \n    # S  = 1 + 4 + ... + 4 ** ((N-1)/2)\n    # in multiply per 4\n    # 4S =     4 + ... + 4 ** ((N-1)/2) + 4 ** ((N+1)/2)\n    # with substraction\n    # 4S - S = 4 ** ((N+1)/2) - 1\n    # S = (4 ** ((N+1)/2) - 1) / 3\n    \n    # with x the decimal number to convert,\n    # whe surch N so that \n    # S >= x\n    \n    # 4 ** ((N+1)/2) - 1 / 3 >= x\n    # 4 ** ((N+1)/2)         >= 3x + 1\n    \n    # we use the log\n    # ((N+1) / 2) log(4)     >= log(3x + 1)\n    \n    # but log(4) = log(2*2) = 2log(2) so\n    # (N+1) log(2)           >= log(3x + 1)\n    #                      N >= (log(3x + 1) / log(2)) - 1\n    #\n    # and we must have N integer and odd\n    # so we use ceil and if the result is even we add 1\n    # we have also N the number of digit necessary. And so we know\n    # the digit in position N-1 is egal to 1\n    \n    if number > 0 :\n        N = int( ceil(log( 3  *number +1, 2)) - 1)\n        if not(N % 2) :\n            N += 1    \n            \n    # by the same way we calculate N if number is > 0 \n    else :\n        N = int( ceil(log((-3)*number + 2, 2)) - 1)\n        if (N % 2) :\n            N += 1\n\n    # if the last one calculate is in position 2 and we need 1 digit\n    # we insert 2 - 1 = 1 zerro and one 1\n    s += '0' * (posCurrentOne - N)\n    s += '1'\n        \n    # if we have N digits, the digit in position N-1 is to one \n    # and correspond to (-2) ** (N-1). So we can substract this value\n    # and iterate. We indicate so the position N -1\n    \n    return s + toWBinary(number - ((-2) ** (N-1)), N - 1 )", "toDex = lambda n: int(n[-1]) - 2*toDex(n[:-1]) if n else 0\ntoBin = lambda n: toBin((n-n%2)/-2) + str(n%2) if n else ''\n    \ndef skrzat(base, number):\n    if not number: return 'From decimal: 0 is 0'\n    elif base in 'b': return 'From binary: %s is %d'%(number, toDex(number))\n    elif base in 'd': return 'From decimal: %d is %s'%(number, toBin(number))", "def skrzat(t, i):\n    return \"From binary: \"+str(i)+\" is \"+str((2863311530^int(i,2))-2863311530) if t=='b' else \"From decimal: \"+str(i)+\" is \"+str(bin((2863311530+i)^2863311530))[2:]", "import math\n\n\ndef convert_to_base(a, b):\n    if a == 0:\n        return 0\n\n    remainders = []\n\n    while a != 0:\n        c = a / b\n        if c < 1:\n            c = math.ceil(c)\n        else:\n            c = math.floor(c)\n\n        d = a - b*c\n        while d < 0:\n            c += 1\n            d = a - b*c\n\n        a = c\n        remainders.append(str(int(d)))\n\n    remainders.reverse()\n    return int(\"\".join(remainders))\n\n\ndef skrzat(base, number):\n    if base == 'b':  # b->d\n        bits = reversed([int(bit) for bit in number])\n        dec = 0\n        for power, bit in enumerate(bits):\n            dec += bit * ((-2)**power)\n\n        return \"From binary: {0} is {1}\".format(number, dec)\n    else:  # d->b\n        binary = convert_to_base(number, -2)\n        return \"From decimal: {0} is {1}\".format(number, binary)", "def skrzat(base, n):\n    if base == \"b\" : return 'From binary: {} is {}'.format(n,sum([int(j)*((-2)**i)for i,j in enumerate(n[::-1])]))  \n    else:\n        def do(n1):\n            li = []\n            while n1 != 0:\n                li.append(str(abs(n1 % (-2)))) ; n1 //= -2\n            return li[::-1]\n        return 'From decimal: {} is {}'.format(n,\"\".join([do(abs(n)),do(-n)][n>0]) or 0)", "def skrzat(base, number):\n    convertor = { \"b\": {\"name\": \"binary\", \"func\": from_weird_binary},\n          \"d\": {\"name\": \"decimal\", \"func\": to_weird_binary} }\n    return \"From {}: {} is {}\".format(convertor[base][\"name\"], number, convertor[base][\"func\"](number))\n\ndef to_weird_binary(number):\n    res = \"\"\n    while number:\n        number, x = divmod(number, -2)\n        if x < 0:\n            number += 1\n        res += str(abs(x))\n    return res[::-1] or \"0\"\n\ndef from_weird_binary(number):\n    return sum([int(d) * (-2) ** i for i, d in enumerate(reversed(number))])", "def skrzat(base, number):\n    s = 0xAAAAAAAA\n\n    if base == 'b':\n        i = int(number, 2)\n        return f\"From binary: {number} is {(s ^ i) - s}\"\n    elif base == 'd':    \n        return f\"From decimal: {number} is {(number + s) ^ s:b}\"", "def skrzat(base, number):\n    def to_binary(number):\n        schroeppel2 = 0xAAAAAAAA\n        return \"From decimal: {} is {}\".format(number, bin((int(number) + schroeppel2) ^ schroeppel2)[2:])\n    def to_decimal(number):\n        return \"From binary: {} is {}\".format(number, sum(int(d)*(-2)**i for i, d in enumerate(reversed(number))))\n\n    if base == \"b\":\n        return to_decimal(number)\n    return to_binary(number)", "def to_dec(binary):\n    sum = 0\n    binary = binary[::-1]\n    for index, bit in enumerate(binary):\n        sum += int(bit) and (-2)**index or 0\n    return sum\n\ndef test_to_dec():\n    assert to_dec(\"00000\") == 0\n    assert to_dec(\"00001\") == 1\n    assert to_dec(\"00010\") == -2\n    assert to_dec(\"00011\") == -1\n    assert to_dec(\"00100\") == 4\n    assert to_dec(\"00101\") == 5\n    assert to_dec(\"00110\") == 2\n    assert to_dec(\"00111\") == 3\n    assert to_dec(\"01000\") == -8\n    assert to_dec(\"01001\") == -7\n    assert to_dec(\"01010\") == -10\n    assert to_dec(\"10000\") == 16\n    assert to_dec(\"10001\") == 17\n    assert to_dec(\"10010\") == 14\n    assert to_dec(\"11000\") == 8\n    assert to_dec(\"11001\") == 9\n    assert to_dec(\"11010\") == 6\n    assert to_dec(\"1001101\") == 61\n    assert to_dec(\"0111111\") == -21\n\nBINARIES = dict(\n    [(to_dec(binary[2:]), binary[2:]) \n      for binary in map(bin, range(2**15))\n      ])\n\ndef to_binary(decimal):\n    return BINARIES[int(decimal)]\n\ndef test_to_binary():\n    assert to_binary(to_dec(\"00000\")) == \"0\"        # 0\n    assert to_binary(to_dec(\"00001\")) == \"1\"        # 1\n    assert to_binary(to_dec(\"00010\")) == \"10\"       # -2\n    assert to_binary(to_dec(\"00011\")) == \"11\"       # -1\n    assert to_binary(to_dec(\"00100\")) == \"100\"  # 4\n    assert to_binary(to_dec(\"00101\")) == \"101\"  # 5\n    assert to_binary(to_dec(\"00110\")) == \"110\"  # 2\n    assert to_binary(to_dec(\"00111\")) == \"111\"  # 3\n    assert to_binary(to_dec(\"01000\")) == \"1000\" # -8\n    assert to_binary(to_dec(\"01001\")) == \"1001\" # -7\n    assert to_binary(to_dec(\"01010\")) == \"1010\" # -10\n    assert to_binary(to_dec(\"10000\")) == \"10000\"\n    assert to_binary(to_dec(\"10001\")) == \"10001\"\n    assert to_binary(to_dec(\"10010\")) == \"10010\"\n    assert to_binary(to_dec(\"11000\")) == \"11000\"\n    assert to_binary(to_dec(\"11001\")) == \"11001\"\n    assert to_binary(to_dec(\"11010\")) == \"11010\"\n    assert to_binary(to_dec(\"1001101\")) == \"1001101\"\n    assert to_binary(to_dec(\"0111111\")) == \"111111\"\n\ndef skrzat(base, number):\n    basename = base == 'b' and 'binary' or 'decimal'\n    result = base == 'b' and to_dec(number) or to_binary(number)\n    return 'From {0}: {1} is {2}'.format(basename, number, result)\n\ndef test_skrzat():\n    assert skrzat('b', '10001011') == 'From binary: 10001011 is -137'\n    assert skrzat('b', '110011001') == 'From binary: 110011001 is 137'\n    assert skrzat('b', '1001101') == 'From binary: 1001101 is 61'\n    assert skrzat('b', '0111111') == 'From binary: 0111111 is -21'\n    assert skrzat('d', 0) == 'From decimal: 0 is 0'\n    assert skrzat('d', -137) == 'From decimal: -137 is 10001011'\n    assert skrzat('d', 137) == 'From decimal: 137 is 110011001'"]
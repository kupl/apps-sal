["class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        ans = 1\n        for x, y in points: \n            angles = []\n            for x1, y1 in points: \n                if (x1 != x or y1 != y) and (d:=sqrt((x1-x)**2 + (y1-y)**2)) <= 2*r: \n                    angle = atan2(y1-y, x1-x)\n                    delta = acos(d/(2*r))\n                    angles.append((angle-delta, +1)) #entry\n                    angles.append((angle+delta, -1)) #exit\n            angles.sort(key=lambda x: (x[0], -x[1]))\n            val = 1\n            for _, entry in angles: \n                ans = max(ans, val := val+entry)\n        return ans \n\n\n\n        \n#https://www.geeksforgeeks.org/angular-sweep-maximum-points-can-enclosed-circle-given-radius/    \n#        class Solution {\n#    public int numPoints(int[][] points, int r) {\n#        int count = 1;\n#        for(int i = 0; i < points.length; i++) {\n#            Map<Double, Integer> angles = new HashMap<>();\n#            for(int j = 0; j < points.length; j++) {\n#                if (i != j) {\n#                    if (points[i][0] != points[j][0] || points[i][1] != points[j][1]) {\n#                        int d = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n#                        double angle = Math.atan2(points[j][1] - points[i][1], points[j][0] - points[i][0]);\n#                        double delta = acos(d / (2 * r));\n#                        double entry = angle - delta;\n#                        double exit = angle + delta;\n#                        map.put(entry, map.getOrDefault(entry, 0) + 1);\n#                        map.put(exit, map.getOrDefault(exit, 0) - 1);\n#                    }\n#                }\n#            }\n#            Map<String, Integer> result = angles.entrySet().stream()\n#                .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))\n#                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,\n#                        (oldValue, newValue) -> oldValue, LinkedHashMap::new));\n#            \n#        }\n#        return count;\n#    }\n#}\n", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        res = 1\n        for x, y in points:\n            order = []\n            for x1, y1 in points:\n                if x != x1 or y != y1:\n                    d = math.sqrt((x1 - x)**2 + (y1 - y)**2)\n                    if d <= 2 * r:\n                        delta = math.acos(d / (2 * r))\n                        angle = math.atan2(y1 - y, x1 - x)\n                        order.append((angle - delta, 1))\n                        order.append((angle + delta, -1))\n            order.sort(key=lambda x: (x[0], -x[1]))\n            val = 1\n            for _, entry in order: \n                res = max(res, val := val+entry)\n            # count = 1\n            # for _, entry in order:\n            #     count += entry\n            #      res = max(res, count)\n        return res", "from math import sqrt\n\nclass Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n\n        n = len(points)\n        if n <= 2:\n            return n\n\n        best = 1\n\n        rr = r ** 2\n        for i in range(n):\n            for j in range(i + 1, n):\n                [x1, y1] = points[i]\n                [x2, y2] = points[j]\n\n                xm = (x1 + x2) / 2\n                ym = (y1 + y2) / 2\n\n                q = sqrt((x2 - x1)**2 + (y2 - y1)**2)\n                qq = (q / 2)**2\n                rq = rr - qq\n                if rq < 0:\n                    continue\n\n                xc = xm + sqrt(rq) * (y1 - y2) / q\n                yc = ym + sqrt(rq) * (x2 - x1) / q\n\n                curr = 2\n                for k in range(n):\n                    if k == i or k == j:\n                        continue\n\n                    [x, y] = points[k]\n                    if sqrt((x - xc)**2 + (y - yc)**2) <= r:\n                        curr += 1\n\n                best = max(best, curr)\n\n        return best\n\n\n\n", "class Solution:\n    def numPoints(self, A: List[List[int]], r: int) -> int:\n            # def numPoints(self, A, r):\n        res = 1\n        for (x1, y1), (x2, y2) in itertools.combinations(A, 2):\n            d = ((x1 - x2) ** 2 + (y1 - y2) ** 2)/4.0\n            if d > r * r: continue\n            x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d) **0.5 / (d * 4) ** 0.5\n            y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d) ** 0.5/(d * 4) **0.5\n            #     x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n            #     y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n            res = max(res, sum((x - x0)**2 + (y - y0)**2 <= r * r + 0.00001 for x, y in A))\n            # res = max(res, sum((x-x0)**2 + (y - y0)**2 <= r * r + 0.0001 for x, y in A))\n        return res\n        # res = 1\n        # for (x1, y1), (x2, y2) in itertools.combinations(A, 2):\n        #     d = ((x1 - x2)**2 + (y1 - y2)**2) / 4.0\n        #     if d > r * r: continue\n        #     x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n        #     y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n        #     res = max(res, sum((x - x0)**2 + (y - y0)**2 <= r * r + 0.00001 for x, y in A))\n        # return res\n", "class Solution:\n    def numPoints(self, A: List[List[int]], r: int) -> int:\n            # def numPoints(self, A, r):\n        res = 1\n        for (x1, y1), (x2, y2) in itertools.combinations(A, 2):\n            d = ((x1 - x2) ** 2 + (y1 - y2) ** 2)/4.0\n            if d > r * r: continue\n            x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d) **0.5 / (d * 4) ** 0.5\n            y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d) **0.5 / (d * 4) ** 0.5\n            #     x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n            #     y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n            res = max(res, sum((x - x0)**2 + (y - y0)**2 <= r * r + 0.00001 for x, y in A))\n            # res = max(res, sum((x-x0)**2 + (y - y0)**2 <= r * r + 0.0001 for x, y in A))\n        return res\n        # res = 1\n        # for (x1, y1), (x2, y2) in itertools.combinations(A, 2):\n        #     d = ((x1 - x2)**2 + (y1 - y2)**2) / 4.0\n        #     if d > r * r: continue\n        #     x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n        #     y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n        #     res = max(res, sum((x - x0)**2 + (y - y0)**2 <= r * r + 0.00001 for x, y in A))\n        # return res\n", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        max_pts = 500\n        dis = [[0 for _ in range(max_pts)] for _ in range(max_pts)]\n\n        def getPointsInside(i, r, n):\n            # This vector stores alpha and beta and flag\n            # is marked true for alpha and false for beta\n            angles = []\n\n            for j in range(n):\n                if i != j and dis[i][j] <= 2 * r:\n                    # acos returns the arc cosine of the complex\n                    # used for cosine inverse\n                    B = math.acos(dis[i][j] / (2 * r))\n\n                    # arg returns the phase angle of the complex\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    A = math.atan2(y1 - y2, x1 - x2)\n                    alpha = A - B\n                    beta = A + B\n                    angles.append((alpha, False))\n                    angles.append((beta, True))\n\n            # angles vector is sorted and traversed\n            angles.sort()\n            # count maintains the number of points inside\n            # the circle at certain value of theta\n            # res maintains the maximum of all count\n            cnt, res = 1, 1\n            for angle in angles:\n                # entry angle\n                if angle[1] == 0: cnt += 1\n                # exit angle\n                else: cnt -= 1\n\n                res = max(cnt, res)\n\n            return res\n\n        # Returns count of maximum points that can lie\n        # in a circle of radius r.\n        # dis array stores the distance between every\n        # pair of points\n        n = len(points)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                # abs gives the magnitude of the complex\n                # number and hence the distance between\n                # i and j\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                dis[i][j] = dis[j][i] = sqrt((x1 - x2)**2 + (y1 - y2)**2)\n\n        # This loop picks a point p\n        ans = 0\n        # maximum number of points for point arr[i]\n        for i in range(n):\n            ans = max(ans, getPointsInside(i, r, n))\n\n        return ans", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        ans = 1\n        for (x1, y1), (x2, y2) in itertools.combinations(points, 2):\n            q = math.sqrt((x1-x2)**2+(y1-y2)**2)\n            if q > 2*r + 0.00001:\n                continue\n            # only need to calculate a circle on one side\n            # consider 1-D case\n            x0 = (x1+x2)/2 + math.sqrt(r**2-(q/2)**2)*(y1-y2)/q\n            y0 = (y1+y2)/2 + math.sqrt(r**2-(q/2)**2)*(x2-x1)/q\n            #print(x0, x1)\n            ans = max(ans, sum(1 for x, y in points if (x-x0)**2+(y-y0)**2 <= r**2 + 0.00001))\n        return ans", "import math\nfrom typing import List\n\n\nclass Solution:\n  def numPoints(self, points: List[List[int]], r: int) -> int:\n    max_pts = 500\n    dis = [[0 for _ in range(max_pts)] for _ in range(max_pts)]\n\n    def getPointsInside(i, r, n):\n      # This vector stores alpha and beta and flag\n      # is marked true for alpha and false for beta\n      angles = []\n\n      for j in range(n):\n        if i != j and dis[i][j] <= 2 * r:\n          # acos returns the arc cosine of the complex\n          # used for cosine inverse\n          B = math.acos(dis[i][j] / (2 * r))\n\n          # arg returns the phase angle of the complex\n          x1, y1 = points[i]\n          x2, y2 = points[j]\n          A = math.atan2(y1 - y2, x1 - x2)\n          alpha = A - B\n          beta = A + B\n          angles.append((alpha, False))\n          angles.append((beta, True))\n\n      # angles vector is sorted and traversed\n      angles.sort()\n      # count maintains the number of points inside\n      # the circle at certain value of theta\n      # res maintains the maximum of all count\n      cnt, res = 1, 1\n      for angle in angles:\n        # entry angle\n        if angle[1] == 0:\n          cnt += 1\n        # exit angle\n        else:\n          cnt -= 1\n\n        res = max(cnt, res)\n\n      return res\n\n    # Returns count of maximum points that can lie\n    # in a circle of radius r.\n    # dis array stores the distance between every\n    # pair of points\n    n = len(points)\n    for i in range(n - 1):\n      for j in range(i + 1, n):\n        # abs gives the magnitude of the complex\n        # number and hence the distance between\n        # i and j\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        dis[i][j] = dis[j][i] = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n    # This loop picks a point p\n    ans = 0\n    # maximum number of points for point arr[i]\n    for i in range(n):\n      ans = max(ans, getPointsInside(i, r, n))\n\n    return ans", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        res = 1\n        for (x1, y1), (x2, y2) in itertools.combinations(points, 2):\n            d = (x2 - x1) ** 2 + (y2 - y1) ** 2\n            if d > 4 * r ** 2 or d == 0:\n                continue\n            \n            x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d / 4) ** 0.5 / d ** 0.5\n            y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d / 4) ** 0.5 / d ** 0.5\n            res = max(res, sum((x - x0) ** 2 + (y - y0) ** 2 <= r * r + 0.00001 for x, y in points))\n            \n            x0 = (x1 + x2) / 2.0 - (y2 - y1) * (r * r - d / 4) ** 0.5\n            y0 = (y1 + y2) / 2.0 + (x2 - x1) * (r * r - d / 4) ** 0.5\n            res = max(res, sum((x - x0) ** 2 + (y - y0) ** 2 <= r * r + 0.00001 for x, y in points))\n        return res", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        \n        def count(x0, y0):\n            nonlocal ans\n            \n            cnt = 0\n            for x, y in points:\n                if (x - x0) * (x - x0) + (y - y0) * (y - y0) <= r * r + 1e-6:\n                    cnt += 1\n            \n            ans = max(ans, cnt)\n            \n        \n        n = len(points)\n        ans = 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                x_mid, y_mid = (x1 + x2) / 2, (y1 + y2) / 2\n                sq = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n                d = r * r - sq / 4\n                if d < 0:\n                    continue\n                d = sqrt(d)\n                sq = sqrt(sq)\n                sin = abs(x1 - x2) / sq\n                cos = abs(y1 - y2) / sq\n                if (x2 - x1) * (y1 - y2) < 0:\n                    cos = -cos\n                x0, y0 = x_mid - d * cos, y_mid - d * sin\n                count(x0, y0)\n                x0, y0 = x_mid + d * cos, y_mid + d * sin\n                count(x0, y0)\n                \n        return ans", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:        \n        res = 1\n        for (x1, y1), (x2, y2) in itertools.combinations(points, 2):\n            d = (x2 - x1) ** 2 + (y2 - y1) ** 2\n            if d > 4 * r ** 2 or d == 0:\n                continue\n            \n            x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d / 4) ** 0.5 / d ** 0.5\n            y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d / 4) ** 0.5 / d ** 0.5\n            res = max(res, sum((x - x0) ** 2 + (y - y0) ** 2 <= r * r + 0.00001 for x, y in points))\n            \n            x0 = (x1 + x2) / 2.0 - (y2 - y1) * (r * r - d / 4) ** 0.5\n            y0 = (y1 + y2) / 2.0 + (x2 - x1) * (r * r - d / 4) ** 0.5\n            res = max(res, sum((x - x0) ** 2 + (y - y0) ** 2 <= r * r + 0.00001 for x, y in points))\n        return res        ", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        res = 1\n        for x, y in points:\n            order = []\n            for x1, y1 in points:\n                if x != x1 or y != y1:\n                    d = math.sqrt((x1 - x)**2 + (y1 - y)**2)\n                    if d <= 2 * r:\n                        delta = math.acos(d / (2 * r))\n                        angle = math.atan2(y1 - y, x1 - x)\n                        order.append((angle - delta, 1))\n                        order.append((angle + delta, -1))\n            order.sort(key=lambda x: (x[0], -x[1]))\n            count = 1\n            for _, entry in order:\n                count += entry\n                res = max(res, count)\n        return res", "class Solution:\n    def numPoints(self, A, r):\n        res = 1\n        for (x1, y1), (x2, y2) in itertools.combinations(A, 2):\n            d = ((x1 - x2) ** 2 + (y1 - y2) ** 2) / 4.0\n            if d > r * r:\n                continue\n            x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d) ** 0.5 / (d * 4) ** 0.5\n            y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d) ** 0.5 / (d * 4) ** 0.5\n            res = max(res, sum((x - x0) ** 2 + (y - y0) ** 2 <= r * r + 0.00001 for x, y in A))\n\n            x0 = (x1 + x2) / 2.0 - (y2 - y1) * (r * r - d) ** 0.5\n            y0 = (y1 + y2) / 2.0 + (x2 - x1) * (r * r - d) ** 0.5\n            res = max(res, sum((x - x0) ** 2 + (y - y0)**2 <= r * r + 0.00001 for x, y in A))\n        return res", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        \n        n=len(points)\n        ans=1\n        for i in range(n-1):\n            x1,y1=points[i][0],points[i][1]\n            for j in range(i+1,n):\n                x2,y2=points[j][0],points[j][1]\n                d=(x1-x2)**2+(y1-y2)**2\n                \n                if d>4*r*r:\n                    continue\n                \n                cx,cy=(x1+x2)/2,(y1+y2)/2\n                h=math.sqrt(r*r-d/4)\n                \n                \n                \n                if y1==y2:\n                    dx,dy=0,h\n                \n                else:\n                    m=-(x1-x2)/(y1-y2)\n                    dx,dy=h/math.sqrt(1+m*m),h*m/(math.sqrt(1+m*m))\n                    \n                for sign in [1,-1]:\n                    count=0\n                    px,py=cx+sign*dx,cy+sign*dy\n                    \n                    for k,(x,y) in enumerate(points):\n                        if (x-px)**2+(y-py)**2<=r*r+1e-7:\n                            count+=1\n                    ans=max(ans,count)\n                    \n        return ans \n                    \n                    \n                    \n                    \n                    \n                \n", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        max_pts = 500\n        dis = [[0 for _ in range(max_pts)] for _ in range(max_pts)]\n\n        def getPointsInside(i, r, n):\n            # This vector stores alpha and beta and flag\n            # is marked true for alpha and false for beta\n            angles = []\n\n            for j in range(n):\n                if i != j and dis[i][j] <= 2 * r:\n                    # acos returns the arc cosine of the complex\n                    # used for cosine inverse\n                    B = math.acos(dis[i][j] / (2 * r))\n\n                    # arg returns the phase angle of the complex\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    A = math.atan2(y1 - y2, x1 - x2)\n                    alpha = A - B\n                    beta = A + B\n                    angles.append((alpha, False))\n                    angles.append((beta, True))\n\n            # angles vector is sorted and traversed\n            angles.sort()\n            # count maintains the number of points inside\n            # the circle at certain value of theta\n            # res maintains the maximum of all count\n            cnt, res = 1, 1\n            for angle in angles:\n                # entry angle\n                if angle[1] == 0: cnt += 1\n                # exit angle\n                else: cnt -= 1\n\n                res = max(cnt, res)\n\n            return res\n\n        # Returns count of maximum points that can lie\n        # in a circle of radius r.\n        # dis array stores the distance between every\n        # pair of points\n        n = len(points)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                # abs gives the magnitude of the complex\n                # number and hence the distance between\n                # i and j\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                dis[i][j] = dis[j][i] = sqrt((x1 - x2)**2 + (y1 - y2)**2)\n\n        # This loop picks a point p\n        ans = 0\n        # maximum number of points for point arr[i]\n        for i in range(n):\n            ans = max(ans, getPointsInside(i, r, n))\n\n        return ans        ", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        best = 1\n        for i in range(len(points)):\n            p1 = complex(*points[i])\n            for j in range(i+1, len(points)):\n                p2 = complex(*points[j])\n                d = abs(p1 - p2)\n                if d > 2 * r:\n                    continue\n                h = math.sqrt(r * r - d * d / 4)\n                c = (p1 + p2) / 2 + (p1 - p2) * h / d * 1j\n                \n                count = 0\n                for x, y in points:\n                    if (x - c.real) ** 2 + (y - c.imag) ** 2 <= r ** 2 + 1e-6:\n                        count += 1\n                best = max(best, count)\n        return best", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        eps = 1e-9\n        \n        ret = 1\n        n = len(points)\n        if n == 1:\n            return ret\n        \n        points.sort()\n        \n        def isect(x1, y1, x2, y2):\n            dx2 = (x2 - x1) ** 2\n            dy2 = (y2 - y1) ** 2\n            if dx2 + dy2 > 4 * r * r:\n                return []\n            cx = (x1 + x2) / 2\n            cy = (y1 + y2) / 2\n            if dx2 + dy2 == 4 * r * r:\n                return [(cx, cy)]\n            ss2 = (dx2 + dy2) / 4\n            ol = math.sqrt(r ** 2 - ss2)\n            diffx = ol * math.sqrt(dy2 / (dx2 + dy2))\n            diffy = ol * math.sqrt(dx2 / (dx2 + dy2))\n            return [(cx - diffx, cy + diffy), (cx + diffx, cy - diffy)]\n        \n        for i in range(n-1):\n            a, b = points[i]\n            for j in range(i+1, n):\n                c, d = points[j]\n                l = isect(a, b, c, d)\n                for x, y in l:\n                    cur = 0\n                    lb = bisect.bisect_left(points, [x-r-eps,y-r-eps])\n                    ub = bisect.bisect_right(points, [x+r+eps,y+r+eps])\n                    for k in range(lb, ub):\n                        dx = points[k][0] - x\n                        dy = points[k][1] - y\n                        if dx ** 2 + dy ** 2 <= (r + eps) ** 2:\n                            cur += 1\n                    ret = max(ret, cur)\n        return ret\n", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        \\\"\\\"\\\"\n        :type points: List[List[int]]\n        :type r: int\n        :rtype: int\n        \\\"\\\"\\\"\n        res = 1\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                x1 = points[i][0]\n                y1 = points[i][1]\n                x2 = points[j][0]\n                y2 = points[j][1]\n                d = ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) ** 0.5\n                if d > r * 2:\n                   continue\n                _x = (y2 - y1) * ((r * r - d * d/ 4.0) ** 0.5) / d\n                _y = (x2 - x1) * ((r * r - d * d/ 4.0) ** 0.5) / d\n                res = max(res, self.count(points, (x1 + x2) / 2.0 + _x, (y1 + y2) / 2.0 - _y, r))\n                res = max(res, self.count(points, (x1 + x2) / 2.0 - _x, (y1 + y2) / 2.0 + _y, r))\n        return res\n        \n    def count(self, points, x, y, r):\n        count = 0\n        for a, b in points:\n            d = ((a - x)*(a - x) + (b - y)*(b - y))**0.5\n            if d <= r + 0.0001 :\n                count += 1\n        return count", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        @functools.lru_cache(None)\n        def find(cx, cy, r):\n            ans = 0\n            for x, y in points:\n                if (x-cx) ** 2 + (y-cy) ** 2 <= r ** 2 + 1e-6:\n                    ans += 1\n            return ans\n        \n        ans = 1\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            for j in range(i+1, len(points)):\n                x2, y2 = points[j]\n                deno = (y1-y2) ** 2 + (x1-x2) ** 2\n                if deno > 4 * r * r:\n                    continue\n                k = math.sqrt(r * r / deno - 0.25)\n                ans = max(ans, max(find((x1+x2)/2 + t*(y1-y2), (y1+y2)/2 - t * (x1-x2), r) for t in (k, -k)))\n        return ans", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        def find(cx, cy, r):\n            ans = 0\n            for x, y in points:\n                if (x-cx) ** 2 + (y-cy) ** 2 <= r ** 2 + 1e-6:\n                    ans += 1\n            return ans\n        \n        ans = 1\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            for j in range(i+1, len(points)):\n                x2, y2 = points[j]\n                deno = (y1-y2) ** 2 + (x1-x2) ** 2\n                if deno > 4 * r * r:\n                    continue\n                k = math.sqrt(r * r / deno - 0.25)\n                ans = max(ans, max(find((x1+x2)/2 + t*(y1-y2), (y1+y2)/2 - t * (x1-x2), r) for t in (k, -k)))\n        return ans", "import math as m\nclass Solution(object):\n    def dist(self, p1, p2):\n        dx = p1[0] - p2[0]\n        dy = p1[1] - p2[1]\n        return m.sqrt(dx * dx + dy * dy)\n    \n    def intersect(self, p1, p2, r):\n        res = []\n        d = self.dist(p1, p2) - 2 * r\n        if (d > 0):\n            res = []\n        elif (d == 0):\n            res = [[(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2]] \n        else:\n            mid_x = (0.0 + p1[0] + p2[0]) / 2\n            mid_y = (0.0 + p1[1] + p2[1]) / 2\n            # ep ^ 2 + fun ^ 2 == r ^ 2 - dist(mid, p1) ^ 2;\n            # ep * (p1[0] - p2[0]) + fun * (p1[1] - p2[1]) == 0 -> fun = -(p1[0] - p2[0]) / (p1[1] - p2[1])  * eps;\n            if (p1[1] != p2[1]):\n                ratio = - (0.0 + p1[0] - p2[0]) / (0.0 + p1[1] - p2[1])\n                eps = m.sqrt((r ** 2 - self.dist([mid_x, mid_y], p1) ** 2) / (ratio ** 2 + 1))\n                fun =  eps * ratio\n            else:\n                eps = 0\n                fun = m.sqrt(r ** 2 - self.dist([mid_x, mid_y], p1) ** 2)\n            # res update    \n            res  =[[mid_x + eps, mid_y + fun], [mid_x - eps, mid_y - fun]]\n        return res    \n            \n    def numPoints(self, points, r):\n        l = len(points)\n        result = 1\n        for i in range(l):\n            for j in range(i + 1, l):\n                c = self.intersect(points[i], points[j], r)\n                for p in c:\n                    au = 0\n                    for k in range(l):\n                        if (self.dist(p, points[k]) <= r): au += 1\n                    result = max(result, au)\n        return result\n            \n", "import math\nclass Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        ##We have that the circle that will contain the most points can be chosen so that at least one point lies on the circumference. Indeed, suppose the best circle contains no points on circumference. Then, we can do a contraction of the circle at center until it hits the first point (still be maximum number of points). Then we can do a dilation from that first point till we have a circle of original radius, and we see that it any point that was originally in the smaller circle will be in the larger dilated circle.\n        ##So we need to essentially ask the question if a circle of radius r passes through each given point, what is maximum number of points the circle can contain then. Then over all points we take the maximum.\n        self.total = len(points)\n        maxPoints = 0\n        for i in range(self.total):\n            maxPoints = max(maxPoints,self.numPointsInCircle(points,r,i))\n        return maxPoints\n    def numPointsInCircle(self,points,r,chosenIndex):\n        maxPoints = 0\n        enterList = []\n        exitList = []\n        numberPoints = 0\n        for i in range(self.total):\n            answer = self.computeRange(points,r,chosenIndex,i)\n            if answer != None:\n                if len(answer) == 0:\n                    numberPoints += 1\n                else:\n                    enterAngle,exitAngle = answer\n                    enterList.append(enterAngle)\n                    exitList.append(exitAngle)\n                    if enterAngle > exitAngle:##includes case where the enterAngle = pi and exitAngle = -pi, because at exact angle of -pi we have the point included.\n                        numberPoints += 1\n        exitList.sort()\n        enterList.sort()\n        maxPoints = numberPoints\n        exitCounter = 0\n        enterCounter = 0\n        pointsToCheck = len(exitList)\n        while max(exitCounter,enterCounter) < pointsToCheck:\n            currentExit = exitList[exitCounter]\n            currentEnter = enterList[enterCounter]\n            if currentEnter <= currentExit:\n                numberPoints += 1\n                maxPoints = max(maxPoints,numberPoints)\n                enterCounter += 1\n            else:\n                numberPoints -= 1\n                exitCounter += 1\n        while exitCounter < pointsToCheck:\n            numberPoints -= 1\n            exitCounter += 1\n        while enterCounter < pointsToCheck:\n            numberPoints += 1\n            maxPoints = max(maxPoints,numberPoints)\n            enterCounter += 1\n        return maxPoints\n        \n        \n        \n    def computeRange(self,points,r,chosenIndex,otherIndex):##\n        chosenPair = points[chosenIndex]\n        otherPair = points[otherIndex]\n        if chosenPair == otherPair:\n            return []##this will be used to indicate that this will not be considered in computeEnterExit\n        else:\n            distance = self.distanceBetweenPoints(chosenPair,otherPair)\n            if distance > 2*r:\n                return None\n            else:\n                angleOne = self.computeAngle(chosenPair,otherPair)\n                angleTwo = math.acos(distance/(2*r))##remember which objects and modules you are using.\n                exit = angleOne+angleTwo\n                exit = exit-2*math.pi if exit >= math.pi else exit##assures exit is in range of [-math.pi,math.pi)\n                enter = angleOne-angleTwo\n                enter = enter + 2*math.pi if enter < -math.pi else enter ##assures enter is in range of (-math.pi,math.pi]\n                return [enter,exit]\n    def computeAngle(self,pairOne,pairTwo):\n        x1,y1 = pairOne\n        x2,y2 = pairTwo\n        return math.atan2((y2-y1),(x2-x1))\n    def numberPointsStart(self,enterList,exitList):\n        pass\n    def distanceBetweenPoints(self,pairOne,pairTwo):\n        x1,y1 = pairOne\n        x2,y2 = pairTwo\n        return math.sqrt((x1-x2)**2+(y1-y2)**2)", "import math as m\nclass Solution(object):\n    def dist(self, p1, p2):\n        dx = p1[0] - p2[0]\n        dy = p1[1] - p2[1]\n        return m.sqrt(dx * dx + dy * dy)\n    \n    def intersect(self, p1, p2, r):\n        res = []\n        d = self.dist(p1, p2) - 2 * r\n        if (d > 0):\n            res = []\n        elif (d == 0):\n            res = [[(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2]] \n        else:\n            mid_x = (0.0 + p1[0] + p2[0]) / 2\n            mid_y = (0.0 + p1[1] + p2[1]) / 2\n            # ep ^ 2 + fun ^ 2 == r ^ 2 - dist(mid, p1) ^ 2;\n            # ep * (p1[0] - p2[0]) + fun * (p1[1] - p2[1]) == 0 -> fun = -(p1[0] - p2[0]) / (p1[1] - p2[1])  * eps;\n            if (p1[1] != p2[1]):\n                ratio = - (0.0 + p1[0] - p2[0]) / (0.0 + p1[1] - p2[1])\n                eps = m.sqrt((r ** 2 - self.dist([mid_x, mid_y], p1) ** 2) / (ratio ** 2 + 1))\n                fun =  eps * ratio\n            else:\n                eps = 0\n                fun = m.sqrt(r ** 2 - self.dist([mid_x, mid_y], p1) ** 2)\n            # res update    \n            res  =[[mid_x + eps, mid_y + fun], [mid_x - eps, mid_y - fun]]\n        return res    \n            \n    def numPoints(self, points, r):\n        l = len(points)\n        result = 1\n        for i in range(l):\n            for j in range(i + 1, l):\n                c = self.intersect(points[i], points[j], r)\n                for p in c:\n                    au = 0\n                    for k in range(l):\n                        if (self.dist(p, points[k]) <= r): au += 1\n                    result = max(result, au)\n        return result", "import math\nfrom decimal import Decimal as D\nclass Solution:\n#     def numPoints(self, points: List[List[int]], r: int) -> int:\n#         def find_intersect(point1,point2,r):\n#             x1 = point1[0]\n#             y1 = point1[1]\n#             x2 = point2[0]\n#             y2 = point2[1]\n#             d = math.sqrt((x1-x2)**2 + (y1-y2)**2)/2\n#             ans = set([])\n#             if d <= r:\n#                 x = (x1+x2)/2\n#                 y = (y1+y2)/2\n#                 de = math.sqrt(r**2-d**2)\n#                 #ans.add((x + de*(y1-y)/d, y + de*(x-x1)/d))\n#                 #ans.add((x - de*(y1-y)/d, y - de*(x-x1)/d))\n#                 tmp = sqrt(4*(r**2-d**2)/((x1-x2)**2 + (y1-y2)**2))\n#                 print(tmp)\n#                 ans.add((x + tmp*(y1-y), y + tmp*(x-x1)))\n#                 ans.add((x - tmp*(y1-y), y - tmp*(x-x1)))\n                \n#             return ans\n        \n#         record = {}\n#         for i in range(len(points)-1):\n#             for j in range(i+1,len(points)):\n#                 point1 = points[i]\n#                 point2 = points[j]\n#                 ans = find_intersect(point1,point2,r)\n#                 #print(ans,point1,point2)\n#                 for a in ans:\n#                     if a not in record:\n#                         record[a] = set([i,j])\n#                     else:\n#                         record[a].add(i)\n#                         record[a].add(j)\n       \n        \n#         return max([len(record[k]) for k in record])\n    def numPoints(self, points: List[List[int]], r: int) -> int:        \n        def circles_from_p1p2r(p1, p2, r):\n            (x1, y1), (x2, y2) = p1, p2\n\n            # delta x, delta y between points\n            dx, dy = x2 - x1, y2 - y1\n\n            # dist between points\n            q = math.sqrt(dx**2 + dy**2)\n\n            # if two points are too far away, there is no such circle\n            if q > 2.0*r:\n                return []\n\n            # find the halfway point\n            x3, y3 = (x1+x2)/2, (y1+y2)/2\n\n            # distance along the mirror line\n            d = math.sqrt(r**2-(q/2)**2)\n\n            # One circle\n            c1 = [x3 - d*dy/q, y3 + d*dx/q]\n\n            # The other circle\n            c2 = [x3 + d*dy/q, y3 - d*dx/q]\n            return [c1, c2]\n\n        # now the main function\n        res = 0\n        n = len(points)\n\n        for p in range(n):\n            for q in range(p+1, n):\n\n                # Find the two candidate circle for each pair of points\n                TwoCirs = circles_from_p1p2r(points[p], points[q], r)\n\n                # count how many dots are inside the circle\n                for center in TwoCirs: # center = TwoCirs[1]\n                    cnt = 0\n\n                    for dots in points: # dots =points[0]\n                        if (dots[0]-center[0])**2 + (dots[1]-center[1])**2 <= r**2+10**-6:\n                            cnt += 1\n                    res = max(res, cnt)\n\n        return res if res else 1", "class Solution:\n    def getC(self, p1, p2, r):\n        [x1, y1], [x2, y2] = p1, p2\n        dist = sqrt(((x1-x2)**2)+((y1-y2)**2))\n        if(dist>2.0*r):\n            return []\n        x3, y3 = (x1+x2)/2, (y1+y2)/2\n        magnitude = sqrt((r**2)-((dist/2)**2))\n        c1 = [x3 - magnitude*(y1-y2)/dist, y3 + magnitude*(x1-x2)/dist]\n        c2 = [x3 + magnitude*(y1-y2)/dist, y3 - magnitude*(x1-x2)/dist]\n        return [c1,c2]\n        \n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        ans=0\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                C = self.getC(points[i], points[j], r)\n                for c in C:\n                    cnt=0\n                    for pt in points:\n                        if(((pt[0]-c[0])**2)+((pt[1]-c[1])**2)<=(r**2)+1e-6):\n                            cnt+=1\n                    ans = max(ans, cnt)\n        return ans if ans else 1\n", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        \n        def circle_centers(p1, p2):\n            [x1,y1], [x2,y2] = p1, p2\n            half_dist_2 = ((x2-x1) ** 2 + (y2-y1) ** 2) / 4\n            \n            offset2 = r**2 - half_dist_2\n            midx, midy = (x1+x2)/2, (y1+y2)/2\n            \n            if abs(offset2) < 1e-4:\n                return [[midx, midy]]\n            \n            if offset2 < 0:\n                return []\n            \n            offset = offset2 ** 0.5\n            dist = ((x2-x1) ** 2 + (y2-y1) ** 2) ** .5\n            \n            \n            dx, dy = offset * (y1-y2) / dist, offset * (x2-x1) / dist\n            return [[midx+dx,midy+dy], [midx-dx,midy-dy]]\n        \n        \n        def count_members_around(cx, cy):\n            print(cx, cy)\n            return len([0 for px, py in points if (px-cx)**2 + (py-cy)**2 < r**2 + 1e-4])\n        \n        result = [count_members_around(cx, cy)\\\\\n                    for i in range(len(points))\\\\\n                    for j in range(i+1, len(points))\\\\\n                    for cx, cy in circle_centers(points[i], points[j])]\n        \n        if len(result) == 0:\n            return 1\n        print(result)\n        return max(result)\n\n\n\n                    ", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        def circles_from_p1p2r(p1, p2, r):\n            (x1, y1), (x2, y2) = p1, p2\n\n\n            # delta x, delta y between points\n            dx, dy = x2 - x1, y2 - y1\n\n\n            # dist between points\n            q = math.sqrt(dx**2 + dy**2)\n\n\n            # if two points are too far away, there is no such circle\n            if q > 2.0*r:\n                return []\n\n\n            # find the halfway point\n            x3, y3 = (x1+x2)/2, (y1+y2)/2\n\n\n            # distance along the mirror line\n            d = math.sqrt(r**2-(q/2)**2)\n\n\n            # One circle\n            c1 = [x3 - d*dy/q, y3 + d*dx/q]\n\n\n            # The other circle\n            c2 = [x3 + d*dy/q, y3 - d*dx/q]\n            return [c1, c2]\n\n\n        # now the main function\n        res = 0\n        n = len(points)\n\n\n        for p in range(n):\n            for q in range(p+1, n):\n\n\n                # Find the two candidate circle for each pair of points\n                TwoCirs = circles_from_p1p2r(points[p], points[q], r)\n\n\n                # count how many dots are inside the circle\n                for center in TwoCirs: # center = TwoCirs[1]\n                    cnt = 0\n\n\n                    for dots in points: # dots =points[0]\n                        if (dots[0]-center[0])**2 + (dots[1]-center[1])**2 <= r**2+10**-6:\n                            cnt += 1\n                    res = max(res, cnt)\n\n        return res if res else 1", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        def valid(x1,y1,x2,y2,r):\n            L=math.sqrt((y2-y1)**2+(x2-x1)**2)\n            if 2*r<L:\n                return False\n            else:\n                return True\n        def getcenter(x1,y1,x2,y2,r):\n            L=math.sqrt((y2-y1)**2+(x2-x1)**2)\n            if r**2-(L/2)**2<0:\n                return None\n            d=math.sqrt(r**2-(L/2)**2)\n            a,b=d*(y1-y2)/L, d*(x2-x1)/L\n            midx=(x1+x2)*0.5\n            midy=(y1+y2)*0.5\n            return midx+a,midy+b,midx-a,midy-b\n        def check(x,y,r):\n            count=0\n            for u in points:\n                if (u[0]-x)**2+(u[1]-y)**2<=r**2+0.001:\n                    count+=1\n            return count\n        L=len(points)\n        if L<=1:\n            return L\n        ans=1\n        for i in range(L-1):\n            for j in range(i+1,L):\n                if valid(points[i][0],points[i][1],points[j][0],points[j][1],r):\n                    cx1,cy1,cx2,cy2=getcenter(points[i][0],points[i][1],points[j][0],points[j][1],r)\n                    print(cx1,cy1,cx2,cy2)\n                    ans=max(ans,check(cx1,cy1,r))\n                    ans=max(ans,check(cx2,cy2,r))\n        return ans", "class Solution:\n    # O(n^3) time, O(1) space\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        n = len(points)\n        result = 1\n        \n        def calc_dist(pt1, pt2):\n            x1, y1 = pt1\n            x2, y2 = pt2\n            return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n        \n        def get_centers(i, j):\n            d_xy = calc_dist(points[i], points[j])\n            if d_xy > r * 2:\n                return []\n            delta_x = points[j][0] - points[i][0]\n            delta_y = points[j][1] - points[i][1]\n            x_mid = points[i][0] + delta_x / 2\n            y_mid = points[i][1] + delta_y / 2\n            if d_xy == r * 2:\n                return [(x_mid, y_mid)]\n            \n            d = math.sqrt(r ** 2 - (d_xy / 2) ** 2)\n            return [\n                (x_mid + d * delta_y / d_xy, y_mid - d * delta_x / d_xy),\n                (x_mid - d * delta_y / d_xy, y_mid + d * delta_x / d_xy)\n            ]\n        \n        def count_points_inside(center, i, j):\n            count = 2\n            for idx in range(n):\n                if idx == i or idx == j:\n                    continue\n                count += calc_dist(center, points[idx]) <= r\n            return count\n        \n        for i in range(n):  # O(n)\n            for j in range(i + 1, n):  # O(n)\n                centers = get_centers(i, j)\n                for center in centers:\n                    result = max(result, count_points_inside(center, i, j))  # O(n)\n        \n        return result\n", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n\n        def within(pt, cen, r2):\n            a1, a2 = pt\n            p1, p2 = cen\n            return (a1 - p1)**2 + (a2 - p2)**2 <= r2\n\n        ans = 1\n\n        for idx, a in enumerate(points):\n            for b in points[:idx]:\n                a1, a2 = a\n                b1, b2 = b\n\n                if (a1-b1)**2+(a2-b2)**2 <= 4*r**2:\n                    pos_cir = 0\n                    neg_cir = 0\n\n                    mid = ((a1+b1)/2, (a2+b2)/2)\n                    perp = (b2-a2, a1-b1)\n                    perp_dis = (perp[0]**2 + perp[1]**2)**.5\n                    p_dis = (r**2 - ((a1-b1)**2+(a2-b2)**2)/4)**.5\n\n                    cen = (mid[0]+perp[0]*p_dis/perp_dis,\n                           mid[1]+perp[1]*p_dis/perp_dis)\n\n                    ocen = (mid[0]+perp[0]*p_dis/perp_dis,\n                            mid[1]+perp[1]*p_dis/perp_dis)\n\n                    for c in points:\n\n                        if within(c, cen, r**2+0.00000001):\n                            pos_cir += 1\n                        if within(c, ocen, r**2+0.00000001):\n                            neg_cir += 1\n\n                    ans = max(ans, pos_cir, neg_cir)\n\n        return ans", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        def getpoints(l,i,r,n,dis):\n            d={}\n            pi=3.1415626\n            angles=[]\n            for j in range(n):\n                if i!=j and dis[i][j]<=2*r:\n                    #print(dis[i][j]/(2*r))\n                    B=math.acos(dis[i][j]/(2*r))\n                    A=math.acos((l[j][0]-l[i][0])/dis[i][j])\n                    if l[j][1]-l[i][1]<0:\n                        A=2*pi-A\n                    a=A-B\n                    b=A+B\n                    #print(i,j,(A/3.14)*180,(B*180/3.14))\n                    angles.append((a,0))  #start\n                    angles.append((b,1))  #end\n\n            angles.sort()\n            #print(l[i],angles)\n            ct=1\n            res=1\n            for a in angles:\n                if a[1]==0:\n                    ct+=1\n                else:\n                    ct-=1\n                res=max(res,ct)\n            #print(i,res)\n            return res\n        n=len(points)\n        dis=[[0 for j in range(n)] for i in range(n)]\n        \n        for i in range(n-1):\n            for j in range(i+1,n):\n                dis[i][j]=((points[i][0]-points[j][0])**2+(points[i][1]-points[j][1])**2)**(0.5)\n                dis[j][i]=((points[i][0]-points[j][0])**2+(points[i][1]-points[j][1])**2)**(0.5)\n        ans=0\n        #print(dis)\n        #print(dis[0][3],dis[3][0])\n        for i in range(n):\n            ans=max(ans,getpoints(points,i,r,n,dis))\n        return ans", "class Solution:\n     def numPoints(self, A, r):\n        res = 1\n        for (x1, y1), (x2, y2) in itertools.combinations(A, 2):\n            d = ((x1 - x2)**2 + (y1 - y2)**2) / 4.0\n            if d > r * r: continue\n            x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n            y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n            res = max(res, sum((x - x0)**2 + (y - y0)**2 <= r * r + 0.00001 for x, y in A))\n        return res", "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        res = 1\n        for (x1, y1), (x2, y2) in itertools.combinations(points, 2):\n            d = ((x1 - x2)**2 + (y1 - y2)**2) / 4.0\n            if d > r * r: continue\n            x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n            y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n            res = max(res, sum((x - x0)**2 + (y - y0)**2 <= r * r + 0.00001 for x, y in points))\n        return res\n                \n", "import itertools\n\nclass Solution:\n  def numPoints(self, points: List[List[int]], r: int) -> int:\n    # http://www4.comp.polyu.edu.hk/~csbxiao/paper/2004/ISPAN04_cover.pdf\n    # TC: O(N^3), possible O(N^2logN), SC: O(1)\n    ans = 1\n    for (x1, y1), (x2, y2) in itertools.combinations(points, 2):\n      d = ((x1 - x2) ** 2 + (y1 - y2) ** 2) / 4.0\n      if d <= r * r:\n        x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d) ** 0.5 / (d * 4) ** 0.5\n        y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d) ** 0.5 / (d * 4) ** 0.5\n        ans = max(ans, sum((x - x0) ** 2 + (y - y0) ** 2 <= r * r + 0.00001 for x, y in points))\n    return ans", "class Solution:\n\\tdef numPoints(self, P: List[List[int]], r: int) -> int:\n\\t\\tans = 1\n\\t\\tfor (x1, y1), (x2, y2) in itertools.combinations(P, 2):\n\\t\\t\\td = ((x1 - x2)**2 + (y1 - y2)**2) / 4.0\n\\t\\t\\tif d > r * r:\n\\t\\t\\t\\tcontinue\n\\t\\t\\tx0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d) ** 0.5 / (d * 4) ** 0.5\n\\t\\t\\ty0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d) ** 0.5 / (d * 4) ** 0.5\n\\t\\t\\tans = max(ans, sum((x - x0)**2 + (y - y0)**2 <= r * r + 0.00001 for x, y in P))\n\\t\\treturn ans\n\\t\\t\\t\n", "class Solution:\n    def numPoints(self, A: List[List[int]], r: int) -> int:\n            # def numPoints(self, A, r):\n        res = 1\n        for (x1, y1), (x2, y2) in itertools.combinations(A, 2):\n            d = ((x1 - x2) ** 2 + (y1 - y2) ** 2)/4.0\n            if d > r * r: continue\n            x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n            y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n            res = max(res, sum((x - x0)**2 + (y - y0)**2 <= r * r + 0.00001 for x, y in A))\n            # res = max(res, sum((x-x0)**2 + (y - y0)**2 <= r * r + 0.0001 for x, y in A))\n        return res\n        # res = 1\n        # for (x1, y1), (x2, y2) in itertools.combinations(A, 2):\n        #     d = ((x1 - x2)**2 + (y1 - y2)**2) / 4.0\n        #     if d > r * r: continue\n        #     x0 = (x1 + x2) / 2.0 + (y2 - y1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n        #     y0 = (y1 + y2) / 2.0 - (x2 - x1) * (r * r - d)**0.5 / (d * 4) ** 0.5\n        #     res = max(res, sum((x - x0)**2 + (y - y0)**2 <= r * r + 0.00001 for x, y in A))\n        # return res\n"]
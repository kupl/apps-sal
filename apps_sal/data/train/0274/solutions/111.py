from sortedcontainers import SortedList


class Solution:

    def longestSubarray(self, nums: List[int], limit: int) -> int:
        minheap = [[nums[0], 0]]
        maxheap = [[-nums[0], 0]]
        left = -1
        res = 1
        for (i, val) in enumerate(nums[1:]):
            j = i + 1
            while len(maxheap) and len(minheap) and (max(val, -maxheap[0][0]) - min(val, minheap[0][0]) > limit):
                if val == max(val, -maxheap[0][0]):
                    (v, l) = heapq.heappop(minheap)
                if minheap and val == min(val, minheap[0][0]):
                    (v, l) = heapq.heappop(maxheap)
                left = max(l, left)
            res = max(j - left, res)
            heapq.heappush(minheap, [val, j])
            heapq.heappush(maxheap, [-val, j])
        return res
        '\n        s = SortedList()\n        # we keep on adding new values to the sortedList and when we get max - min greater than target then we keep on removing values from the list till the sorted list becomes valid again\n        # thus we have a solution with O(nlogn) complexity and faster than the one with sortedDict although it is having same complexity\n        max_length = 0\n        j = 0\n        for i in range(len(nums)):\n            s.add(nums[i])\n            while s and s[-1] - s[0] > limit:\n                s.remove(nums[j])\n                j += 1\n            max_length = max(max_length,i-j + 1)\n        return max_length\n        '
        "\n        # i.e. if min is our problem then we need to increase i till we find new min \n        # i.e we need to start from i = i + max_index of current_min\n        # and if max is our problem then we need to increase i till we find new max\n        # i.e we need to start from i = i + max_index of current_max\n        # and if both are a problem then we need to increase i till max when both are changed\n        # this we can do if we use a hashmap mapping each value from i to j with its max index in the array we do not care for intermediate indices\n        max_length = -float('inf')\n        mapping = SortedDict()\n        Min = nums[0]\n        Max = nums[0]\n        mapping[Min] = 0\n        i = 0\n        while i < len(nums):\n            j = i\n            # print('a',i,j,Max,Min)\n            while j < len(nums) and abs(nums[j] - Min) <= limit and abs(nums[j] - Max) <= limit:\n                Max = max(Max,nums[j])\n                Min = min(Min,nums[j])\n                # we are just concerned with the max value\n                mapping[nums[j]] = j\n                j += 1\n                max_length = max(max_length,j - i)\n                \n            # print('b',i,j,Min,Max)\n            if j >= len(nums)-1:\n                break\n            else:\n                mapping[nums[j]] = j\n                while i <= j and (abs(nums[j] - Min) > limit or abs(nums[j] - Max) > limit):\n                    if abs(nums[j] - Min) > limit and abs(nums[j] - Max) > limit:\n                        i = max(i,max(mapping[Min],mapping[Max]) + 1)\n                        del mapping[Max]\n                        if Min in mapping.keys():\n                            del mapping[Min]\n\n                    elif abs(nums[j] - Min) > limit:\n                        i = max(i,mapping[Min] + 1)\n                        del mapping[Min]\n                        \n                    elif abs(nums[j] - Max) > limit:\n                        i = max(i,mapping[Max] + 1)\n                        del mapping[Max]\n                    # after each update we need to update min and max and the following steps will take O(n)\n                    Min = mapping.peekitem(0)[0]\n                    Max = mapping.peekitem()[0]\n                    while mapping[Min] < i:\n                        del mapping[Min]\n                        Min = mapping.peekitem(0)[0]\n                    while mapping[Max] < i:\n                        del mapping[Max]\n                        Max = mapping.peekitem()[0]\n                    \n                # print(mapping)\n                # print('c',i,j,Max,Min)\n        return max_length\n        \n        "
        "\n        max_length = -float('inf')\n        Min = nums[0]\n        Max = nums[0]\n        i = 0\n        while i < len(nums):\n            j = i \n            #print('a',i,j,Max,Min)\n            while j < len(nums) and abs(nums[j] - Min) <= limit and abs(nums[j] - Max) <= limit:\n                Max = max(Max,nums[j])\n                Min = min(Min,nums[j])\n                j += 1\n                max_length = max(max_length,j - i)\n            #print('b',i,j,Max,Min,len(nums))\n            if j >= len(nums)-1:\n                break\n            else:\n                while i < j and nums[i] != Min and nums[i] != Max:\n                    i += 1\n                while i < j and (abs(nums[j] - Min) > limit or abs(nums[j] - Max) > limit):\n                    i += 1\n                    #print(i)\n                    Min = min(nums[i:j+1])\n                    Max = max(nums[i:j+1])\n                    #print('c',i,j,Max,Min)\n        return max_length\n        "

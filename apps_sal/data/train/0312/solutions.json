["import collections\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        cum_sum = 0\n        queue = collections.deque([(-1, 0)])\n        result = len(A) + 1\n        for i, v in enumerate(A):\n            cum_sum += v    \n            if v > 0:\n                # find any matches and remove them, since will never have a better match\n                while queue and cum_sum - queue[0][1] >= K:\n                    e = queue.popleft()\n                    #print('remove candidate from start:', e)\n                    result = min(result, i - e[0])\n            else:\n                # for negative numbers pop off any greater cum sums, which will never be a better target\n                while queue and cum_sum <= queue[-1][1]:\n                    e = queue.pop()\n                    #print('remove lesser from end:', e)\n        \n            queue.append((i, cum_sum))\n            #print(queue)            \n        return result if result <= len(A) else -1    ", "# The solution looks good, \n# also: https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        queue = collections.deque([(0, -1)])\n        prefix_sum = 0\n        res = float('inf')\n        for i in range(len(A)):\n            prefix_sum += A[i]\n            while queue and queue[-1][0] > prefix_sum:\n                queue.pop()\n                \n            while queue and prefix_sum - queue[0][0] >= K:\n                res = min(res, i - queue[0][1])\n                queue.popleft()\n            \n            queue.append((prefix_sum, i))\n        return res if res != float('inf') else -1\n        \n", "import collections\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        cum_sum = 0\n        queue = collections.deque([(-1, 0)])\n        result = len(A) + 1\n        for i, v in enumerate(A):\n            cum_sum += v    \n            # find any matches and remove them, since will never have a better match\n            while queue and cum_sum - queue[0][1] >= K:\n                e = queue.popleft()\n                #print('remove candidate from start:', e)\n                result = min(result, i - e[0])\n            # pop off any greater cum sums, which will never be a better target\n            while queue and cum_sum <= queue[-1][1]:\n                e = queue.pop()\n                #print('remove greater from end:', e)\n        \n            queue.append((i, cum_sum))\n            #print(queue)            \n        return result if result <= len(A) else -1    ", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        B = [0]\n        \n        for a in A:\n            B.append(B[-1] + a)\n        \n        print(B)\n        \n        dq = collections.deque()\n        res = float('inf')\n        \n        for i, n in enumerate(B):\n            \n            while dq and B[dq[-1]] >= n:\n                dq.pop()\n                \n            while dq and n - B[dq[0]] >= K:\n                res = min(res, i-dq[0])\n                dq.popleft()\n            \n            dq.append(i)\n        \n        return -1 if res == float('inf') else res\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        total = 0\n        q = deque()\n        q.append([-1, 0])\n\n        res = float('inf')\n        for i, v in enumerate(A):\n            total += v\n            #print(q[0])\n            while q and total - q[0][1] >=K:\n                res = min(res, i - q[0][0])\n                q.popleft()\n                \n            while q and total < q[-1][1]:\n                q.pop()\n                \n            q.append([i, total])\n\n        return res if res != float('inf') else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        if not A:\n            return -1\n        dq = deque([[0, 0]])\n        curr_sum = 0\n        min_size = len(A) + 1\n        for i in range(len(A)):\n            curr_sum += A[i]\n            while dq and curr_sum - dq[0][1] >= K:\n                min_size = min(min_size, i - dq.popleft()[0] + 1)\n            while dq and curr_sum <= dq[-1][1]:\n                dq.pop()\n            dq.append([i+1, curr_sum])\n        return min_size if min_size != len(A) + 1 else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        profits = [0]\n        for num in A:\n            profits.append(profits[-1] + num)\n        \n        ans = float('inf')\n        q = collections.deque()\n        for i in range(len(profits)):\n            \n            py = profits[i]\n            while q and py - profits[q[0]] >= K:\n                ans = min(ans, i - q[0])\n                q.popleft()\n            \n            while q and py - profits[q[-1]] <= 0:\n                q.pop()\n            \n            q.append(i)\n        \n        return ans if ans != float('inf') else -1 ", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        n = len(A)\n        preSum = [0 for i in range(n+1)]\n        for i in range(1, n+1):\n            preSum[i] = preSum[i-1] + A[i-1]\n        # print(preSum)\n        deque = []\n        i = 0\n        ans = n + 1\n        while i <= n:\n            while deque and preSum[i] - preSum[deque[0]] >= K:\n                ans = min(ans, i-deque[0])\n                print(ans)\n                deque.pop(0)\n            while deque and preSum[deque[-1]] >= preSum[i]:\n                deque.pop()\n            deque.append(i)\n            i += 1\n            # print(deque)\n        return ans if ans < n+1 else -1\n", "from collections import deque\n\nclass Solution:\n    def shortestSubarray(self, A, K):\n        d = collections.deque([[0, 0]])\n        res, cur = float('inf'), 0\n        for i, a in enumerate(A):\n            cur += a\n            while d and cur - d[0][1] >= K:\n                res = min(res, i + 1 - d.popleft()[0])\n            while d and cur <= d[-1][1]:\n                d.pop()\n            d.append([i + 1, cur])\n        return res if res < float('inf') else -1", "from collections import deque\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        if not A:\n            return -1\n        \n        sum_A = [0]\n        for a in A:\n            sum_A.append(a + sum_A[-1])\n            \n        d = deque()\n        res = len(A) + 1\n        for i in range(len(sum_A)):\n            while d and sum_A[i] <= sum_A[d[-1]]:\n                d.pop()\n                \n            while d and sum_A[i] - sum_A[d[0]] >= K:\n                res = min(res, i - d.popleft())\n            \n            d.append(i)\n            \n        return res if res != len(A) + 1 else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        L = len(A)\n        min_length = L+1\n        queue = collections.deque([(0, -1)])\n        cursum = 0\n        for i in range(L):\n            cursum += A[i]\n            while queue and cursum-queue[0][0]>=K:\n                prevSum, prevIdx = queue.popleft()\n                min_length = min(min_length, i-prevIdx)\n            while queue and queue[-1][0]>=cursum:\n                queue.pop()\n            queue.append((cursum,i))\n            \n        return min_length if min_length<=L else -1\n        \n", "class Solution(object):\n    def shortestSubarray(self, A, K):\n        d = collections.deque([[0, 0]])\n        res, cur = float('inf'), 0\n        for i, a in enumerate(A):\n            cur += a\n            while d and cur - d[0][1] >= K:\n                res = min(res, i + 1 - d.popleft()[0])\n            while d and cur <= d[-1][1]:\n                d.pop()\n            d.append([i + 1, cur])\n        return res if res < float('inf') else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], k: int) -> int:\n        \n#         left, right = 0, 0 \n#         _sum = 0\n#         out = sys.maxsize\n#         while right<len(A): \n#             _sum += A[right]\n            \n#             while left<=right and _sum>=k:\n#                 if right-left+1<out: \n#                     out = right-left+1\n#                 _sum -= A[left]\n#                 left +=1\n            \n                \n#             right +=1\n            \n#         return out if out!=sys.maxsize else -1\n\n# Fail example\n#     [84,-37,32,40,95]\n# 167\n        prefixSum = [0] \n    \n        for i in range(len(A)): \n            prefixSum.append(prefixSum[-1]+A[i])\n\n        q = collections.deque()\n        out = sys.maxsize\n        \n        for i in range(len(prefixSum)): \n            \n            while q and prefixSum[i] - prefixSum[q[0]]>=k: \n                out = min(out, i-q.popleft())\n            \n            while q and prefixSum[i] <= prefixSum[q[-1]]: \n                q.pop()\n                \n            q.append(i)\n            \n                \n            # q.append(i)\n            \n        return out if out!=sys.maxsize else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        q = collections.deque()\n        n = len(A)\n        B = [0] * (n + 1)\n        for i in range(n):\n            B[i+1] = A[i] + B[i]\n        \n        res = float('inf')\n        for i in range(n + 1):\n            while q and B[i] < B[q[-1]]:   # maintain increasing Manatonic queue\n                q.pop()\n            \n            while q and B[i] - B[q[0]] >= K:   # find the nearest previous element with sum at least K\n                res = min(res, i - q.popleft())\n            \n            q.append(i)\n        \n        return res if res != float('inf') else -1", "from typing import List\nimport heapq\nimport math\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], k: int) -> int:\n        shortest = math.inf \n        sum = 0\n        #priority queue to store tuples (partial_sum, index_last_element)\n        pq = []\n        #we iterate over array\n        for counter, value in enumerate(A):\n            sum += value\n            if sum >= k:\n                shortest = counter + 1 if counter < shortest else shortest\n            \n            while pq and sum - pq[0][0] >= k:\n                shortest = counter - pq[0][1] if counter - pq[0][1] < shortest else shortest\n                heapq.heappop(pq)  \n                            \n            heapq.heappush(pq, (sum, counter))\n            \n        return shortest if shortest != math.inf else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        sm = 0\n        pref = []\n        mn = sys.maxsize\n\n        for i in range(len(A)):\n            pref.append(A[i] + sm)\n            sm += A[i]\n        \n        st = [(0, -1)]\n        \n        for i in range(len(A)):\n            while len(st) and pref[i] < st[-1][0] :\n                st.pop()\n                \n            while len(st) and pref[i] - st[0][0] >= K:\n                mn = min(mn, i - st[0][1])\n                st.pop(0)\n                \n            st.append([pref[i], i])\n            \n        return mn if mn != sys.maxsize else -1\n                \n            \n                \n            \n", "class Solution:\n    def shortestSubarray(self, A: List[int], k: int) -> int:\n        # d = collections.deque([[0, 0]])\n        # res, cur = float('inf'), 0\n        # for i, a in enumerate(A):\n        #     cur += a\n        #     while d and cur - d[0][1] >= K:\n        #         res = min(res, i + 1 - d.popleft()[0])\n        #     while d and cur <= d[-1][1]:\n        #         d.pop()\n        #     d.append([i + 1, cur])\n        # return res if res < float('inf') else -1\n        \n        d = collections.deque([[0,0]])\n        cur = 0\n        res = float('inf')\n        \n        for i, a in enumerate(A):\n            cur += a\n            while d and cur - d[0][1] >= k:\n                l = d.popleft()[0]\n                res = min(res, i - (l-1))\n            while d and cur <= d[-1][1]:\n                d.pop()\n            d.append([i+1, cur])\n        return res if res < float('inf') else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        presum = [0]\n        for x in A: \n            if x>=K: return 1\n            presum.append(presum[-1]+x)\n        \n        q = collections.deque()\n        ans = math.inf\n        for i, x in enumerate(A):\n            while q and presum[i+1]-presum[q[-1]]<=x: q.pop()\n            q.append(i)\n            while q and (presum[i+1]-presum[q[0]]>=K or i+1-q[0]>=ans):\n                ans = min(ans, i+1-q[0])\n                q.popleft()\n        return ans if ans!=math.inf else -1\n            \n        \n", "from typing import List\n\n\n\nclass Solution:\n    def shortestSubarray(self, arr: List[int], K: int) -> int:\n        pr_arr = [arr[i] for i in range(len(arr))]\n        for i in range(1, len(arr)):\n            pr_arr[i] = pr_arr[i - 1] + arr[i]\n\n        q = []\n        q.append((0, -1))\n        min_window_size = float('inf')\n        for i, val in enumerate(pr_arr):\n            while len(q) > 0 and q[len(q) - 1][0] >= val:\n                q.pop()\n\n            q.append((val, i))\n\n            window_sum = val - q[0][0]\n            while window_sum >= K:\n                min_window_size = min(min_window_size, i - q[0][1])\n                q.pop(0)\n\n                if len(q) == 0:\n                    break\n\n                window_sum = val - q[0][0]\n\n        if min_window_size == float('inf'):\n            return -1\n        return min_window_size", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        pref = [0] + [*accumulate(A)]\n        \n        ans = math.inf\n        q = deque()\n        for i, s in enumerate(pref):\n            while q and pref[q[-1]] >= s:\n                q.pop()\n            \n            while q and s - pref[q[0]] >= K:\n                ans = min(i - q[0], ans)\n                q.popleft()\n            \n            q.append(i)\n        \n        return -1 if ans == math.inf else ans\n        \n        # keep smallest prefix sum\n        # current sum - smallest prefix sum >= K\n        # record smallest length\n        # pop it out\n        \n        # 2, 5, 6\n        # 6\n        # 8\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        return shortest_subarray(A, K)\n\ndef shortest_subarray(A: List[int], K: int) -> int:\n    n = len(A)\n    sums = [0] * (n + 1)\n    for i in range(n):\n        sums[i+1] = sums[i] + A[i]\n    result = n + 1\n    q = deque()\n    for i, total in enumerate(sums):\n        while q and total < sums[q[-1]]:\n            q.pop()\n        while q and total - sums[q[0]] >= K:\n            result = min(result, i - q.popleft())\n        q.append(i)\n    return result if result <= n else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        \n        n = len(A)\n        \n    \n        if n == 1:\n            return  -1 if A[0]<K else 1\n        \n        if any(A) >= K:\n            return 1\n        \n        s = [0]\n        \n        \n        for i in range(n):\n            \n            s.append(s[-1]+A[i])\n            \n            \n            \n            \n        print(s)    \n        i = 0\n        \n        deque = []\n        min_length = n+1\n        while i<n+1:\n            \n            #print(deque)\n\n            while len(deque) > 0 and s[deque[-1]]>=s[i]:\n                \n                deque.pop()\n                \n               \n            while len(deque) > 0 and s[i]-s[deque[0]]>=K:\n                k = deque.pop(0)\n                \n                min_length = min(min_length, i - k)\n            \n            deque.append(i)\n            i+=1\n        return min_length if min_length<n+1 else -1\n            \n                \n                \n        \n                \n                \n                \n                \n", "from collections import deque\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        if not len(A):\n            return -1\n        A += [0]\n        prefsum = [0]\n        for n in A:\n            prefsum.append(prefsum[-1] + n)\n        ans = len(A) + 1\n        deq = deque()\n        for i in range(len(A)):\n            while len(deq) and prefsum[i] - prefsum[deq[0]] >= K:\n                ans = min(i - deq[0], ans)\n                deq.popleft()\n            while len(deq) and prefsum[i] <= prefsum[deq[-1]]:\n                deq.pop()\n            deq.append(i)\n        if ans == len(A) + 1:\n            return -1\n        return ans", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        l= 0 \n        summ = 0\n        A.insert(0,0)\n        ln = len(A)\n        for i in range(1,ln):\n            A[i]+=A[i-1]\n        minq = collections.deque([0])\n        best = float('inf')\n        for r in range(1,ln):\n            while minq and A[r]-A[minq[0]]>=K:\n                best = min(best,r-minq[0])\n                minq.popleft()\n            while minq and A[minq[-1]]>A[r]:\n                minq.pop()\n            minq.append(r)\n        return best if best!=float('inf') else -1", "from collections import deque\nclass Solution:\n    def shortestSubarray(self, A, K):\n        acc = [0]\n        for v in A:\n            acc.append(acc[-1] + v)\n        ans, monoq = float('inf'), deque()\n        for size, curS in enumerate(acc):\n            while monoq and curS < acc[monoq[-1]]:\n                monoq.pop()\n            while monoq and curS - acc[monoq[0]] >= K:\n                ans = min(ans, size - monoq.popleft())\n            monoq.append(size)\n        return ans if ans != float('inf') else -1\n", "import collections\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        n = len(A)\n        p = [0]\n        \n        for x in A:\n            p.append(p[-1] + x)\n            \n        # print(p)\n        \n        ans = n+1\n        q = collections.deque()\n        \n        for key,val in enumerate(p):\n            while q and val <= p[q[-1]]:\n                q.pop()\n            \n            while q and val - p[q[0]] >= K:\n                ans = min(ans, key - q.popleft())\n                \n            q.append(key)\n            # print(q)\n            \n        return ans if ans < n+1 else -1\n        \n        \n        \n            \n                \n            \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        s = [0]\n        \n        for x in A: \n            s += s[-1] +x, \n      \n        q = []\n        res = len(A) + 2\n        \n        for i, val in enumerate(s): \n            \n            while q and val - q[0][0] >= K:\n                res = min(res, i - heapq.heappop(q)[1]) \n            \n            heapq.heappush(q, (val, i))\n            \n        return res if res < len(A) + 2 else -1 \n\n            \n        \n", "from collections import deque\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        d = deque([(0,0)])\n        curr = 0\n        n = len(A)\n        res = n + 1\n        \n        for r in range(n):\n            curr += A[r]\n\n            while d and curr - d[0][1] >= K:\n                res = min(res, r - d.popleft()[0] + 1)\n            while d and curr <= d[-1][1]:\n                d.pop()\n            d.append((r + 1, curr))\n\n        return res if res != n + 1 else -1\n        \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        if max(A) >= K:\n            return 1\n        n = len(A)\n        prefix = [0] * (n+1)\n        for i in range(1, n+1):\n            prefix[i] = prefix[i-1] + A[i-1]\n        res = n+1\n        dq = deque()\n        for y, py in enumerate(prefix):\n            while dq and prefix[dq[-1]] > py:\n                dq.pop()\n            while dq and py - prefix[dq[0]] >= K:\n                res = min(res, y-dq.popleft())\n            dq.append(y)\n        return res if res <= n else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        d = collections.deque([[0, 0]])\n        res, cur = float('inf'), 0\n        for i, a in enumerate(A):\n            cur += a\n            while d and cur - d[0][1] >= K:\n                res = min(res, i + 1 - d.popleft()[0])\n            while d and cur <= d[-1][1]:\n                d.pop()\n            d.append([i + 1, cur])\n        return res if res < float('inf') else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n       \n        N = len(A)\n        P = [0]\n        for x in A:\n            P.append(P[-1] + x)\n\n        #Want smallest y-x with Py - Px >= K\n        ans = N+1 # N+1 is impossible\n        monoq = collections.deque() #opt(y) candidates, represented as indices of P\n        for y, Py in enumerate(P):\n            #Want opt(y) = largest x with Px <= Py - K\n            while monoq and Py <= P[monoq[-1]]:\n                monoq.pop()\n\n            while monoq and Py - P[monoq[0]] >= K:\n                ans = min(ans, y - monoq.popleft())\n\n            monoq.append(y)\n\n        return ans if ans < N+1 else -1", "class Solution:\n    def shortestSubarray(self, arr, k):\n        n = len(arr)\n        \n        # build prefix sums\n        pSums = [0]\n        for x in arr:\n            pSums.append(pSums[-1] + x)\n            \n        res = n + 1\n        q = deque()\n        \n        for y, Py in enumerate(pSums):\n            while q and Py <= pSums[q[-1]]:\n                q.pop()\n                \n            while q and Py - pSums[q[0]] >= k:\n                res = min(res, y - q.popleft())\n\n            q.append(y)\n            \n        return res if res < n + 1 else -1\n        \n            \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        queue = [[0,0]]\n        x = 0\n        ans = float('inf')\n        for index, val in enumerate(A):\n            x += val\n            while queue and x - queue[0][1] >= K:\n                ans = min(ans, index+1-queue[0][0])\n                queue.pop(0)\n            while queue and x <= queue[-1][1]:\n                queue.pop()\n            queue.append([index+1, x])\n        if ans == float('inf'):\n            return -1\n        return ans\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        pref = [0] + list(itertools.accumulate(A))\n        \n        q = deque()\n        \n        ans = math.inf\n        for i, n in enumerate(pref):\n            while q and pref[q[-1]] > n:\n                q.pop()\n                \n            while q and n - pref[q[0]] >= K:\n                ans = min(ans, i - q.popleft())\n            \n            q.append(i)\n        \n        return -1 if ans == math.inf else ans", "class Solution(object):\n    def shortestSubarray(self, A, K):\n        N = len(A)\n        P = [0]\n        for x in A:\n            P.append(P[-1] + x)\n\n        #Want smallest y-x with Py - Px >= K\n        ans = N+1 # N+1 is impossible\n        monoq = collections.deque() #opt(y) candidates, represented as indices of P\n        for y, Py in enumerate(P):\n            #Want opt(y) = largest x with Px <= Py - K\n            while monoq and Py <= P[monoq[-1]]:\n                monoq.pop()\n\n            while monoq and Py - P[monoq[0]] >= K:\n                ans = min(ans, y - monoq.popleft())\n\n            monoq.append(y)\n\n        return ans if ans < N+1 else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        S = [0]\n        res = float('inf')\n        for num in A:\n            S.append(S[-1]+num)\n        q = []\n        for i, s in enumerate(S):\n            while q and S[q[-1]] >= s:\n                q.pop()\n            while q and S[q[0]] + K <= s:\n                cur_i = q.pop(0)\n                res = min(res, i-cur_i)\n            q.append(i)\n        if res == float('inf'):\n            return -1\n        else:\n            return res\n        # n = len(A)\n        # dp = [[0]*n for _ in range(n)]\n        # res = float('inf')\n        # for i in range(len(A)):\n        #     if i == 0:\n        #         dp[0][i] = A[i]\n        #     else:\n        #         dp[0][i] = dp[0][i-1] + A[i]\n        #     if dp[0][i] >= K:\n        #         res = min(res, i+1)\n        # for i in range(1,n):\n        #     for j in range(i,n):\n        #         dp[i][j] = dp[i-1][j] - A[i-1]\n        #         if dp[i][j] >= K:\n        #             res = min(res, j-i+1)\n        # if res == float('inf'):\n        #     return -1\n        # return res\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        # Sliding window approach with prefix sums and monotonic queue\n        prefix_sums = [0]\n        prefix_sum = 0\n        for a in A:\n            prefix_sum += a\n            prefix_sums.append(prefix_sum)\n            \n        # Monotonic queue to hold increasing indices\n        from collections import deque\n        mono_q = deque()\n        min_len = len(A) + 1\n        \n        # Sliding window        \n        for y, Py in enumerate(prefix_sums):\n            # Pop the indices that will break the monotonically increasing characteristic \n            # from the right\n            while mono_q and Py <= prefix_sums[mono_q[-1]]:\n                mono_q.pop()\n            \n            while mono_q and Py - prefix_sums[mono_q[0]] >= K:\n                min_len = min(y - mono_q.popleft(), min_len)\n            \n            mono_q.append(y)                        \n        return min_len if min_len < len(A) + 1 else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        s = [0]\n        \n        for x in A:\n            s += s[-1] + x, \n        \n        stack = []\n        res = len(s) + 1\n        \n        for i, x in enumerate(s):\n            \n            while stack and x <= s[stack[-1]]:\n                stack.pop()\n            \n            while stack and x - s[stack[0]] >=K:\n                res = min(res, i - stack.pop(0))\n            \n            stack += i,\n        \n        return res if res < len(s) + 1 else -1 \n        \n        \n", "from bisect import bisect_left\nfrom itertools import accumulate\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        MAX_L = 10**9\n        res = Solver(A, K, MAX_L).solve(0, len(A)-1)\n        return res if res < MAX_L else -1\n        \nclass Solver:\n    def __init__(self, A, K, MAX_L):\n        self.A = A\n        self.K = K\n        self.MAX_L = MAX_L\n        \n    def solve(self, i, j):\n        if i == j:\n            return 1 if self.A[i] >= self.K else self.MAX_L\n        \n        if sum((abs(self.A[v]) for v in range(i, j+1))) < self.K:\n            return self.MAX_L\n        \n        m = (i + j) // 2\n        return min(self.solve(i,m), self.solve(m+1,j), self.solve_pivot(i,j,m))\n    \n    def bin_search(self, arr, val, v):   \n        if arr[-1] < v:\n            return self.MAX_L\n        \n        return val[bisect_left(arr, v)]\n    \n    def solve_pivot(self, i, j, m):\n        leftv, leftc = self.min_arr(m, i-1, -1)\n        rightv, rightc = self.min_arr(m+1, j+1, 1)\n        ans = self.MAX_L\n        \n        for li in range(len(leftv)):\n            l_v,l_cnt = leftv[li], leftc[li]\n            r_cnt = self.bin_search(rightv, rightc, self.K-l_v)\n            ans = min(ans, l_cnt + r_cnt)\n        \n        return ans\n         \n    def min_arr(self, start, stop, step):\n        resv, resc = [], []\n        acc = 0\n        for i in range(start, stop, step):\n            acc += self.A[i]\n            if (not resv) or acc > resv[-1]:\n                resv.append(acc)\n                resc.append(abs(start-i)+1)\n        return resv, resc", "from collections import deque\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        q = deque([(0, 0)])\n        presum, ans = 0, float('inf')\n        for idx, n in enumerate(A):\n            presum += n\n            while q and presum - q[0][1] >= K:\n                ans = min(ans, idx + 1 - q.popleft()[0])\n            while q and q[-1][1] >= presum: q.pop()\n            q.append((idx + 1, presum))\n        \n        return ans if ans < float('inf') else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        psum = 0\n        total = 0\n        dq = deque([(0,-1)])\n        res = float('inf')\n        for i, a in enumerate(A):\n            psum += a\n            # print(dq, i, a, psum)\n            while dq and dq[-1][0]>psum:\n                dq.pop()\n            \n            while dq and psum-dq[0][0]>=K:\n                res = min(res, i-dq.popleft()[1])\n            #  print(dq, res)  \n            dq.append((psum, i))\n        #print(dq)\n        return res if res!=float('inf') else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        N = len(A)\n        P = [0]\n        for x in A:\n            P.append(P[-1] + x)  #append the current sum +=x\n            \n        ans = N + 1 \n        monoq = collections.deque()\n        for y, Py in enumerate(P):\n            while monoq and Py < P[monoq[-1]]:\n                monoq.pop()\n                \n            while monoq and Py - P[monoq[0]] >=K:\n                ans = min(ans, y-monoq.popleft())\n            monoq.append(y)\n        if ans < N+1:\n            \n            return ans\n        else:\n            return -1 \n        \n        \n        \n        \n        # if not A:\n        #     return -1 \n        # sum = 0 \n        # for i in range(len(A)):\n        #     sum += A[i] \n        #     if sum < K:\n        #         i +=1 \n        #     elif sum > K:\n        #         i -=1 \n        #     else:\n        #         return i+1 \n        # return -1 \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        pre = [0]\n        n = len(A)\n        for num in A:\n            pre.append(num + pre[-1])\n            \n        ans = n + 1\n        stack = deque() # indices of possible start positions\n        for i in range(n + 1):\n            while stack and pre[i] - pre[stack[0]] >= K:\n                ans = min(ans, i - stack.popleft())\n            \n            while stack and pre[i] <= pre[stack[-1]]:\n                stack.pop()\n            stack.append(i)\n            \n        return ans if ans <= n else -1\n    \n", "class Solution:\n    def shortestSubarray(self, nums: List[int], K: int) -> int:\n        possible_lefts = deque([(0,-1)])\n        shortest = float('inf')\n        \n        total = 0\n        \n        for right, num in enumerate(nums):\n            total += num\n            \n            while possible_lefts and total-possible_lefts[0][0] >= K:\n                shortest = min(shortest, right-possible_lefts.popleft()[1])\n            \n            while possible_lefts and possible_lefts[-1][0] > total:\n                possible_lefts.pop()\n            \n            possible_lefts.append((total, right))\n        \n        \n        return shortest if shortest != float('inf') else -1\n        \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        # (index, value)\n        queue = collections.deque([[0, 0]])\n        res = float('inf')\n        \n        curr = 0\n        for i, a in enumerate(A):\n            curr += a\n            while queue and curr - queue[0][1] >= K:\n                tmp = queue.popleft()\n                res = min(res, i - tmp[0] + 1)\n            while queue and curr < queue[-1][1]:\n                queue.pop()\n            queue.append([i+1, curr])\n        \n        return res if res != float('inf') else -1\n", "from bisect import bisect_left\nfrom itertools import accumulate\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        MAX_L = 10**9\n        res = Solver(A, K, MAX_L).solve(0, len(A)-1)\n        return res if res < MAX_L else -1\n        \nclass Solver:\n    def __init__(self, A, K, MAX_L):\n        self.A = A\n        self.K = K\n        self.MAX_L = MAX_L\n        \n    def solve(self, i, j):\n        if i == j:\n            return 1 if self.A[i] >= self.K else self.MAX_L\n        \n        if sum((abs(self.A[v]) for v in range(i, j+1))) < self.K:\n            return self.MAX_L\n        \n        m = (i + j) // 2\n        return min([self.solve(i,m), self.solve(m+1,j), self.solve_pivot(i,j,m)])\n    \n    def bin_search(self, arr, v):   \n        if arr[-1][0] < v:\n            return self.MAX_L\n        \n        i = bisect_left(arr, (v, 0))\n        return arr[i][1]\n    \n    def solve_pivot(self, i, j, m):\n        left = self.min_arr(m, i-1, -1)\n        right = self.min_arr(m+1, j+1, 1)\n        ans = self.MAX_L\n        \n        for l_v, l_cnt in left:\n            r_cnt = self.bin_search(right, self.K-l_v)\n            ans = min(ans, l_cnt + r_cnt)\n        \n        return ans\n         \n    def min_arr(self, start, stop, step):\n        res = []\n        acc = 0\n        for i in range(start, stop, step):\n            acc += self.A[i]\n            if (not res) or acc > res[-1][0]:\n                res.append((acc, abs(start-i)+1))\n        return res", "from queue import deque\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        sums=[0]\n        for i in A:\n            sums.append(sums[-1]+i)\n        \n        min_l=len(A)+1\n        q=deque([])\n        \n        for i in range(len(sums)):\n            while q and sums[q[-1]]>=sums[i]:\n                q.pop()\n            while q and sums[i]-sums[q[0]]>=K:\n                min_l=min(min_l,i-q.popleft())\n                \n            q.append(i)\n        \n        if min_l>len(A): return -1\n        else: return min_l\n", "import collections\n\nclass Solution:\n    def shortestSubarray(self, A, K):\n        d = collections.deque()\n        cummulative_sum = [0]\n        \n        for a in A:\n            cummulative_sum.append(cummulative_sum[-1] + a)\n        \n        ans = len(cummulative_sum)\n\n        for idx, x in enumerate(cummulative_sum):\n            while d and x <= cummulative_sum[d[-1]]:\n                d.pop()\n            \n            while d and x - cummulative_sum[d[0]] >= K:\n                ans = min(ans, idx - d[0])\n                d.popleft()\n            \n            d.append(idx)\n        \n        return ans if ans != len(cummulative_sum) else -1", "from heapq import *\nclass Solution:\n    def shortestSubarray(self, A, K):\n        heap, curS, ans = [(0, -1)], 0, float('inf')\n        for i, v in enumerate(A):\n            curS += v\n            while heap and curS - heap[0][0] >= K:\n                ans = min(ans, i - heappop(heap)[1])\n            heappush(heap, (curS, i))\n        return ans if ans != float('inf') else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        prefix = [0] * (len(A)+1)\n        for i in range(len(A)):\n            prefix[i+1] = prefix[i] + A[i]\n            \n        monoq = deque()\n        ans = len(prefix)\n        for i, p in enumerate(prefix):\n            while monoq and prefix[monoq[-1]]>=p:\n                monoq.pop()\n            while monoq and p - prefix[monoq[0]]>=K:\n                ans = min(ans, i-monoq.popleft())\n            monoq.append(i)\n            \n        return ans if ans<len(prefix) else -1", "from bisect import bisect_left\nfrom itertools import accumulate\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        MAX_L = 10**9\n        res = Solver(A, K, MAX_L).solve(0, len(A)-1)\n        return res if res < MAX_L else -1\n        \nclass Solver:\n    def __init__(self, A, K, MAX_L):\n        self.A = A\n        self.K = K\n        self.MAX_L = MAX_L\n        \n    def solve(self, i, j):\n        if i == j:\n            return 1 if self.A[i] >= self.K else self.MAX_L\n        \n        if sum((abs(self.A[v]) for v in range(i, j+1))) < self.K:\n            return self.MAX_L\n        \n        m = (i + j) // 2\n        return min(self.solve(i,m), self.solve(m+1,j), self.solve_pivot(i,j,m))\n    \n    def bin_search(self, arr, v):   \n        if arr[-1][0] < v:\n            return self.MAX_L\n        \n        i = bisect_left(arr, (v, 0))\n        return arr[i][1]\n    \n    def solve_pivot(self, i, j, m):\n        left = self.min_arr(m, i-1, -1)\n        right = self.min_arr(m+1, j+1, 1)\n        ans = self.MAX_L\n        \n        for l_v, l_cnt in left:\n            r_cnt = self.bin_search(right, self.K-l_v)\n            ans = min(ans, l_cnt + r_cnt)\n        \n        return ans\n         \n    def min_arr(self, start, stop, step):\n        res = []\n        acc = 0\n        for i in range(start, stop, step):\n            acc += self.A[i]\n            if (not res) or acc > res[-1][0]:\n                res.append((acc, abs(start-i)+1))\n        return res", "import bisect\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        n = len(A)\n        preSums = [0] * (n + 1)\n        for i in range(n): \n            preSums[i + 1] = preSums[i] + A[i]\n            \n        dque = collections.deque()\n        shortest = n + 1\n        for i in range(n + 1):\n            while dque and preSums[i] - preSums[dque[0]] >= K: \n                shortest = min(shortest, i - dque.popleft())\n            while dque and preSums[i] <= preSums[dque[-1]]: \n                dque.pop()\n            dque.append(i)\n        return shortest if shortest <= n else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        presum = [0]\n        for x in A: \n            # if x>=K: return 1, faster without this one\n            presum.append(presum[-1]+x)\n        \n        q = collections.deque()\n        ans = math.inf\n        for i, x in enumerate(A):\n            while q and presum[i+1]-presum[q[-1]]<=x: q.pop()\n            q.append(i)\n            while q and (presum[i+1]-presum[q[0]]>=K):# or i+1-q[0]>=ans:\n                ans = min(ans, i+1-q[0])\n                q.popleft()\n        return ans if ans!=math.inf else -1\n            \n        \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        # make p array which is a cumulative sum\n        p=[0]\n        \n        for i in range(len(A)):\n            p.append(p[-1]+A[i])\n            \n        q=[]\n        result=len(A)+1 # a high value\n        for i in range(len(A)+1):\n            \n            while(q and p[i]-p[q[0]]>=K):\n                result = min( result , i-q[0])\n                q.pop(0)\n                \n            while(q and p[i]-p[q[-1]]<=0):\n                q.pop()\n            \n            q.append(i)\n            \n        return(-1 if result==len(A)+1 else result)\n            \n", "import collections\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        suma = [0]\n        \n        for item in A:\n            suma.append(suma[-1] + item)\n            \n            \n        ansr = len(A) + 1\n        \n        queue = collections.deque()\n        \n        for i in range( len(suma)):\n           \n            while queue and suma[i] - suma[queue[0]] >= K:\n                ansr = min(ansr, i-queue[0])\n                queue.popleft()\n            \n            #shrink the window from left\n            while queue and suma[i] <= suma[queue[-1]]:\n                queue.pop()\n                \n            queue.append(i)\n            \n        \n        if ansr == len(A) + 1:\n            return -1\n        else:\n            return ansr\n", "from collections import deque\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        rs = [0]\n        for n in A: rs.append(rs[-1]+n)\n        print(rs)\n        q = deque()\n        mn = float('inf')\n        for i,s in enumerate(rs):\n            while q and s <= rs[q[-1]]:\n                q.pop()\n            while q and s-rs[q[0]] >= K:\n                mn = min(mn,i-q.popleft())\n            q.append(i)\n        return mn if mn != float('inf') else -1", "import collections\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        if not A:\n            return -1\n        \n        if len(A) == 1:\n            if A[0] >= K:\n                return 1\n            return -1\n        \n        increasing_A = [0]\n        for i in A:\n            increasing_A.append(increasing_A[-1]+i)\n            \n        min_length = float('inf')\n        queue = collections.deque()\n        \n        for i,v in enumerate(increasing_A):\n            while queue and v <= increasing_A[queue[-1]]:\n                queue.pop()\n                \n            while queue and v-increasing_A[queue[0]] >= K:\n                min_length = min(min_length, i-queue.popleft())\n            \n            queue.append(i)\n            \n        if min_length == float('inf'):\n            return -1\n        return min_length", "class Solution(object):\n    def shortestSubarray(self, A, K):\n        N = len(A)\n        P = [0]\n        for x in A:\n            P.append(P[-1] + x)\n\n        #Want smallest y-x with Py - Px >= K\n        ans = N+1 # N+1 is impossible\n        monoq = collections.deque() #opt(y) candidates, represented as indices of P\n        for y, Py in enumerate(P):\n            #Want opt(y) = largest x with Px <= Py - K\n            while monoq and Py <= P[monoq[-1]]:\n                monoq.pop()\n\n            while monoq and Py - P[monoq[0]] >= K:\n                ans = min(ans, y - monoq.popleft())\n\n            monoq.append(y)\n\n        return ans if ans < N+1 else -1\n                \n        \n                \n        \n        \n            \n        \n            \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        \n        preSum = [0]\n        for e in A:\n            preSum.append(preSum[-1] + e)\n        \n        min_len = sys.maxsize\n        \n        \n        #0 2 1 3 7 \n        \n        #0 1 3 7\n        \n        q = collections.deque([])\n        for i in range(len(preSum)):\n            while q and preSum[q[-1]] > preSum[i]:\n                q.pop()\n            while q and preSum[i] - K >= preSum[q[0]]:\n                min_len = min(min_len, i-q.popleft())       \n\n            q.append(i)\n        \n        return min_len if min_len != sys.maxsize else -1\n", "# Prepare\n# From @Sarmon:\n# \\\"What makes this problem hard is that we have negative values.\n# If you haven't already done the problem with positive integers only,\n# I highly recommend solving it first\\\"\n\n# Minimum Size Subarray Sum\n\n# Explanation\n# Calculate prefix sum B of list A.\n# B[j] - B[i] represents the sum of subarray A[i] ~ A[j-1]\n# Deque d will keep indexes of increasing B[i].\n# For every B[i], we will compare B[i] - B[d[0]] with K.\n\n\n# Complexity:\n# Every index will be pushed exactly once.\n# Every index will be popped at most once.\n\n# Time O(N)\n# Space O(N)\n\n\n# How to think of such solutions?\n# Basic idea, for array starting at every A[i], find the shortest one with sum at leat K.\n# In my solution, for B[i], find the smallest j that B[j] - B[i] >= K.\n# Keep this in mind for understanding two while loops.\n\n\n# What is the purpose of first while loop?\n# For the current prefix sum B[i], it covers all subarray ending at A[i-1].\n# We want know if there is a subarray, which starts from an index, ends at A[i-1] and has at least sum K.\n# So we start to compare B[i] with the smallest prefix sum in our deque, which is B[D[0]], hoping that [i] - B[d[0]] >= K.\n# So if B[i] - B[d[0]] >= K, we can update our result res = min(res, i - d.popleft()).\n# The while loop helps compare one by one, until this condition isn't valid anymore.\n\n\n# Why we pop left in the first while loop?\n# This the most tricky part that improve my solution to get only O(N).\n# D[0] exists in our deque, it means that before B[i], we didn't find a subarray whose sum at least K.\n# B[i] is the first prefix sum that valid this condition.\n# In other words, A[D[0]] ~ A[i-1] is the shortest subarray starting at A[D[0]] with sum at least K.\n# We have already find it for A[D[0]] and it can't be shorter, so we can drop it from our deque.\n\n\n# What is the purpose of second while loop?\n# To keep B[D[i]] increasing in the deque.\n\n\n# Why keep the deque increase?\n# If B[i] <= B[d.back()] and moreover we already know that i > d.back(), it means that compared with d.back(),\n# B[i] can help us make the subarray length shorter and sum bigger. So no need to keep d.back() in our deque.\n\n\n\n\n\nclass Solution:\n    def shortestSubarray(self, A, K):\n        d = collections.deque([[0, 0]])\n        res, cur = float('inf'), 0\n        for i, a in enumerate(A):\n            cur += a\n            while d and cur - d[0][1] >= K:\n                res = min(res, i + 1 - d.popleft()[0])\n            while d and cur <= d[-1][1]:\n                d.pop()\n            d.append([i + 1, cur])\n        return res if res < float('inf') else -1\n\n                \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        d = collections.deque([[0, 0]])\n        res, cur = len(A)+1, 0\n        for i, a in enumerate(A):\n            cur += a\n            while d and cur - d[0][1] >= K:\n                res = min(res, i + 1 - d.popleft()[0])\n            while d and cur <= d[-1][1]: # new i make the further subarray length shorter and sum bigger \n                d.pop()\n            d.append([i + 1, cur])\n        return res if res < len(A)+1 else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        prefix = [0] * (len(A) + 1)\n        for i in range(len(A)):\n            prefix[i + 1] = prefix[i] + A[i]\n            \n        \n        ans = sys.maxsize \n        deque = collections.deque([])\n        \n        for i in range(len(A) + 1):\n            while deque and prefix[i] - prefix[deque[0]] >= K:\n                ans = min(ans, i - deque[0])\n                deque.popleft()\n            while deque and prefix[i] <= prefix[deque[-1]]:\n                deque.pop()\n            deque.append(i)\n            \n        return ans if ans != sys.maxsize else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        if max(A) >= K:\n            return 1\n        n = len(A)\n        prefix = [0] + list(itertools.accumulate(A))\n        res = n+1\n        dq = deque()\n        for y, py in enumerate(prefix):\n            while dq and prefix[dq[-1]] > py:\n                dq.pop()\n            while dq and py - prefix[dq[0]] >= K:\n                res = min(res, y-dq.popleft())\n            dq.append(y)\n        return res if res <= n else -1", "class Solution(object):\n    def shortestSubarray(self, A, K):\n        n = len(A)\n        pref = [0]*(n+1)\n        for i in range(1, n+1):\n            pref[i] = pref[i-1] + A[i-1]\n        \n        node = deque(); ans = n + 1\n        for i in range(len(pref)):\n            while node and pref[i] - pref[node[0]] >= K:\n                ans = min(ans, i-node[0])\n                node.popleft()\n            while node and pref[i] <= pref[node[-1]]:\n                node.pop()\n            node.append(i)\n        \n        return ans if ans < n+1 else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        ans = len(A) + 1\n        S = deque()\n        S.append([0, -1])\n        for i, x in enumerate(A):\n            cur = S[-1][0] + x\n            while S and S[-1][0] >= cur:\n                S.pop()\n            S.append([cur, i])\n            while S[-1][0] >= S[0][0] + K:\n                ans = min(ans, S[-1][1] - S.popleft()[1])\n                \n        return ans if ans <= len(A) else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        d = collections.deque([[0, 0]])\n        res, cur = float('inf'), 0\n        for i, a in enumerate(A):\n            cur += a\n            while d and cur - d[0][1] >= K:\n                res = min(res, i + 1 - d.popleft()[0])\n            while d and cur <= d[-1][1]:\n                d.pop()\n            d.append([i + 1, cur])\n            \n        return res if res != float('inf') else -1", "class Solution(object):\n    def shortestSubarray(self, A, K):\n        n = len(A)\n        d = collections.deque([(A[0],0)])\n        res = n+1\n        \n        for i in range(1, n):\n            A[i] += A[i-1]\n        A = [0] + A\n        for i in range(n+1):\n            while d and d[-1][0] > A[i]: d.pop()\n            d.append((A[i], i))\n            while d and A[i] - d[0][0] >= K:\n                res = min(res, i-d[0][1])\n                d.popleft()\n            \n        return res if res <= n else -1\n                \n        \n", "from heapq import heappush, heappop\ndef kmin(a,k):\n    cur_sum = 0\n    h = [(0, -1)]\n    min_ = float('inf')\n    for i in range(0, len(a)):\n        cur_sum +=a[i]\n        while h and h[0][0]<=cur_sum-k:\n            min_ = min(min_, i-h[0][1])\n            heappop(h)\n        heappush(h, (cur_sum, i))\n    return min_ if min_ != float('inf') else -1\nfrom collections import deque\ndef ksumalt(a,k):\n    q = deque()\n    q.append((-1, 0))\n    cur_sum = 0\n    min_len = float('inf')\n    for i in range(len(a)):\n        cur_sum += a[i]\n        while q and cur_sum - q[0][-1] >=k:\n            min_len = min(min_len, i-q[0][0])\n            q.popleft()\n        while q and cur_sum <= q[-1][-1]:\n            q.pop()\n        q.append((i, cur_sum))\n    return -1 if min_len == float('inf') else min_len\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        return ksumalt(A, K)", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        p,n = [0],len(A)\n        for i in range(n):\n            p.append(p[-1]+A[i])\n        # p[i] = A[0]+A[1]+...+A[i-1]\n        # p[j]-p[i] = sum(A[i:j])\n        i,ret = 0,float('inf')\n        q = collections.deque()\n        while i < n+1:\n            while q and p[q[-1]] > p[i]:\n                q.pop()\n            q.append(i)\n            while q and p[q[-1]] - p[q[0]] >= K:\n                ind = q.popleft()\n                ret = min(ret,q[-1]-ind)\n            i += 1\n        return ret if ret!=float('inf') else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        n, store = len(A), [0]\n        for x in A: store.append(store[-1] + x)\n        res = n + 1\n        queue = deque()\n        for i, x in enumerate(store):\n            while queue and x <= store[queue[-1]]: queue.pop()\n            while queue and x - store[queue[0]] >= K: res = min(res, i-queue.popleft())\n            queue.append(i)\n\n        return res if res < n + 1 else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        if K == 0:\n            return 0\n        if not A:\n            return -1\n        if len(A) == 1:\n            if A[0] >= K:\n                return 1\n            return 0\n        from collections import deque\n        ret = float('inf')\n        for element in A:\n            if element >= K:\n                return 1\n        for i in range(1, len(A)):\n            A[i] += A[i-1]\n        current_ele = deque()\n        current_ele.append((-1, 0))\n        for i, element in enumerate(A):\n            while current_ele and current_ele[-1][1] >= element:\n                current_ele.pop()\n            current_ele.append((i, element))\n            while current_ele[-1][1] >= current_ele[0][1]+K:\n                ret = min(ret, current_ele[-1][0]-current_ele[0][0])\n                current_ele.popleft()\n        return ret if ret != float('inf') else -1", "from collections import deque\n\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        d = deque()\n        n = len(A)\n        res = n+1\n\n        prefixArr = [0] * (n + 1)\n\n        for i in range(n):\n            prefixArr[i + 1] = A[i] + prefixArr[i]\n\n        for end in range(n+1):\n            while d and prefixArr[end] - prefixArr[d[0]] >= K:\n                res = min(res, end - d.popleft())\n            while d and prefixArr[d[-1]] >= prefixArr[end]:\n                d.pop()\n            d.append(end)\n\n        return -1 if res == n+1 else res\n\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        deq = collections.deque([])\n        prefix = [0]\n        res = float('inf')\n        for a in A:\n            prefix.append(prefix[-1] + a)\n        for i, x in enumerate(prefix):\n            while deq and prefix[deq[-1]] >= x:\n                deq.pop()\n            while deq and prefix[deq[0]] <= x - K:\n                res = min(res, i - deq.popleft())\n            deq.append(i)\n        return res if res < float('inf') else -1       ", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        P = [0]\n        for x in A:\n            P.append(P[-1] + x)\n        \n        q = collections.deque()\n        min_length_K = -1\n        for j, Pj in enumerate(P):\n            while len(q) > 0 and P[q[-1]] >= Pj:\n                q.pop()\n            while len(q) > 0 and Pj - P[q[0]] >= K:\n                if min_length_K == -1 or j - q[0] < min_length_K:\n                    min_length_K = j - q[0]\n                q.popleft()\n            q.append(j)\n            \n        return min_length_K", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        d = collections.deque([[0, 0]])\n        res, cur = float('inf'), 0\n        for i, a in enumerate(A):\n            cur += a\n            while d and cur - d[0][1] >= K:\n                res = min(res, i + 1 - d.popleft()[0])\n            while d and cur <= d[-1][1]:\n                d.pop()\n            d.append([i + 1, cur])\n        return res if res < float('inf') else -1        ", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        #First check this problem >> https://leetcode.com/problems/minimum-size-subarray-sum/\n        #>>> Important <<<<\n        #https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/262641/Python-Prefix-Sum-and-Sliding-Window\n        #As left and right index keeps increasing, time complexity is O(N).\n        n = len(A)\n        res = n+1\n        Sum = 0\n        dq  = collections.deque([(-1,0)]) #-1 for index, 0 for sum \n        \n        for i, val in enumerate(A):\n            Sum += val\n            if val > 0:\n                while dq and Sum - dq[0][1] >= K:\n                    res = min(res, i-dq.popleft()[0])\n            else:\n                while dq and Sum < dq[-1][1]:\n                    dq.pop()\n            dq.append((i, Sum))\n            \n        if res <= n:\n            return res\n        else:\n            return -1\n        \n", "from collections import deque\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        dq = deque()\n        pre = [0]\n        l = len(A)\n        ans = l+1\n        for i in range(l):\n            pre.append(pre[-1] + A[i])\n        for i in range(l+1):\n            while dq and pre[dq[-1]] >= pre[i]:\n                dq.pop()\n            while dq and pre[dq[0]] + K  <= pre[i]:\n                ans = min(ans, i-dq.popleft())\n            dq.append(i)\n        #print(ans)\n        return (ans if ans < l+1 else -1)", "from collections import deque\n\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        if max(A) >= K:\n            return 1\n        \n        if K <= 0:\n            return -1\n            \n        psum = [0]\n        for a in A:\n            psum.append(psum[-1] + a)\n            \n        window = deque([(0, 0)])\n        res = float('inf')\n        for right in range(len(A)):\n            while window and psum[right + 1] <= window[-1][1]:\n                window.pop()\n            \n            window.append((right + 1, psum[right + 1]))\n            while window and window[-1][1] - window[0][1] >= K:\n                res = min(res, window[-1][0] - window[0][0])\n                window.popleft()\n        \n        return res if res != float('inf') else -1\n", "class Solution:\n    def shortestSubarray(self, nums: List[int], K: int) -> int:\n        sum1=0\n        flag=False\n        min1=float('inf')\n        cums=[0]\n        dq=collections.deque()\n        \n        for i in range(len(nums)):\n            cums.append(cums[-1]+nums[i])\n        print(cums)\n        \n        for i in range(len(nums)+1):\n            while dq and cums[i]-cums[dq[0]]>=K:\n                val=dq.popleft()\n                min1=min(min1,i-val)\n            while dq and cums[i]<=cums[dq[-1]]:\n                dq.pop()\n            dq.append(i)\n                \n                #This loop is used because if there is [2,-1,2] and K=3 for cums=[0,2,1,3] we know that from 2 to 1 the value decreased from 1 to x increased so the min will be from 1 to x rather than 2 to x so eliminated(because length b/w 1 to x < 2 to x)\n            \n            \n        if min1==float('inf'):\n            return -1\n        return min1\n                \n", "from collections import deque\nclass Solution:    \n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        n=len(A)\n        prefix_sum= [0 for _ in range(n+1)]\n        for i in range(1,len(prefix_sum)):\n            prefix_sum[i] = prefix_sum[i-1]+ A[i-1]\n        dq= deque()\n        ans=n+1\n        for i in range(len(prefix_sum)):\n            while dq and prefix_sum[i]-prefix_sum[dq[0]]>=K:\n                ans = min(ans,i-dq[0])\n                dq.popleft()\n            while dq and prefix_sum[i]<=prefix_sum[dq[-1]]:\n                dq.pop()        \n            dq.append(i)\n        return -1 if ans==n+1 else ans", "from collections import deque\n\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        prefix_arr = [0]\n        for i in range(len(A)):\n            prefix_arr.append(prefix_arr[i] + A[i])\n\n        deq = deque()\n        result = len(A) + 1\n\n        for i in range(len(prefix_arr)):\n            while len(deq) > 0 and prefix_arr[i] < prefix_arr[deq[-1]]:\n                deq.pop()\n            deq.append(i)\n\n            while len(deq) > 0 and prefix_arr[deq[-1]] - prefix_arr[deq[0]] >= K:\n                result = min(result, deq[-1]-deq[0])\n                deq.popleft()\n\n        if result == len(A) + 1:\n            return -1\n\n        return result\n", "import heapq\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        q = [(0, -1)]\n        cum = 0\n        res = float('inf')\n        for i, x in enumerate(A):\n            cum += x\n            \n            while q and cum - q[0][0] >= K:\n                res = min(res, i - heapq.heappop(q)[1])\n                \n            heapq.heappush(q, (cum, i))\n        return res if res < float('inf') else -1\n        \n        \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        Sum, res, heap, flag = 0, len(A), [(0, -1)], False\n        \n        for i, v in enumerate(A):\n            Sum += v\n            while heap and Sum - heap[0][0] >= K:\n                flag = True\n                res = min(res, i - heapq.heappop(heap)[1])\n            heapq.heappush(heap, (Sum, i))\n        \n        return res if flag else -1\n            \n", "from heapq import heappush, heappop\ndef kmin(a,k):\n    cur_sum = 0\n    h = [(0, -1)]\n    min_ = float('inf')\n    for i in range(0, len(a)):\n        cur_sum +=a[i]\n        while h and h[0][0]<=cur_sum-k:\n            min_ = min(min_, i-h[0][1])\n            heappop(h)\n        heappush(h, (cur_sum, i))\n    return min_ if min_ != float('inf') else -1\n        \nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        return kmin(A, K)", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        queue = collections.deque()\n        Sum, res = 0, float('inf')\n        queue.append((0, -1))\n        for i, v in enumerate(A):\n            Sum += v\n            \n            while queue and Sum - queue[0][0] >= K:\n                res = min(res, i - queue.popleft()[1])\n            while queue and Sum <= queue[-1][0]:\n                queue.pop()\n            queue.append((Sum, i))\n            \n        return res if res < float('inf') else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        cumsum = itertools.accumulate(A)\n        \n        mono = collections.deque([(0, -1)])\n        result = math.inf\n        for ind, val in enumerate(cumsum):\n            while mono and mono[-1][0] >= val:\n                mono.pop()\n            mono.append((val, ind))\n            \n            while val - mono[0][0] >= K:\n                result = min(result, ind - mono.popleft()[1])\n        \n        if result == math.inf:\n            return -1\n        else:\n            return result", "from collections import deque\n\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        psum = [0]\n        for a in A:\n            psum.append(psum[-1] + a)\n            \n        window = deque([(0, 0)])\n        res = float('inf')\n        for right in range(len(A)):\n            while window and psum[right + 1] <= window[-1][1]:\n                window.pop()\n            \n            window.append((right + 1, psum[right + 1]))\n            while window and window[-1][1] - window[0][1] >= K:\n                res = min(res, window[-1][0] - window[0][0])\n                window.popleft()\n        \n        return res if res != float('inf') else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        # Step 1: create a prefix (left) sum for the array\n        n = len(A)\n        if n == 0:\n            return -1\n        dp = [0] * (n + 1)  # dp[i] is the sum of A[0: i]\n        for i in range(1, n+1):\n            dp[i] = dp[i-1] + A[i-1]\n        \n        # Step 2: iterate over a monotonic (increasing) queue, whenever a new\n        # prefix sum is >= most left ele + K, left pop\n        queue = collections.deque()\n        queue.append((0, 0))  # First ele is the index, second ele in the dop array\n        \n        # The minimum of the sequence length\n        res = (n + 1)\n\n        for i in range(1, n+1):\n            # Check if dp[i] minus the left end is no less than K\n            while queue:\n                qi, qe = queue[0]\n                if qe  + K <= dp[i]:\n                    res = min(res, i - qi)\n                    queue.popleft()\n                else:\n                    break\n            \n            # Update the monotonic queue\n            while queue:\n                _, qe = queue[-1]\n                if qe >= dp[i]:\n                    queue.pop()\n                else:\n                    break\n            queue.append((i, dp[i]))\n\n        if res == (n+1):\n            return -1\n        else:\n            return res\n            \n", "class Solution:\n    def shortestSubarray(self, A: List[int], k: int) -> int:\n        s = collections.deque()    # Inc    # (sum, ind)\n        curr = 0\n        ans = math.inf\n        for i in range(len(A)):\n            curr += A[i]\n            if curr>=k: ans=min(ans, i+1)\n            while s and curr - s[0][0]>=k:\n                ans = min(ans, i-s.popleft()[1])\n            while s and s[-1][0]>curr:\n                s.pop()\n            s.append((curr, i))\n        \n        return ans if ans!=float('inf') else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        dq = deque([(0,0)])\n        res = float('inf')\n        p = 0\n        for i, a in enumerate(A):\n            p += a\n            while dq and p<=dq[-1][0]:\n                dq.pop()\n                \n            while dq and p-dq[0][0]>=K:\n                res = min(res, i+1-dq.popleft()[1])\n                \n            dq.append((p, i+1))\n            \n        return res if res!=float('inf') else -1\n        \n                \n                \n", "from collections import deque\nclass Solution:\n    def shortestSubarray(self, A: List[int], k: int) -> int:\n        for ele in A:\n            if ele>=k:\n                return 1\n        s=[0]\n        for i in range(len(A)):\n            s.append((s[-1] if len(s) else 0)+A[i])\n        print(s)\n        queue=deque()\n        #queue.append((0,0))\n        ans=float('inf')\n        for i,e in enumerate(s):\n            #print(queue)\n            if len(queue)==0:\n                queue.append((i,e))\n                \n            elif len(queue) and queue[-1][1]<e:\n                \n                if e-queue[0][1]>=k:\n                    while len(queue) and e-queue[0][1]>=k:\n                        ans=min(ans,i-queue[0][0])\n                        queue.popleft()\n                queue.append((i,e))\n                \n            elif len(queue) and queue[-1][1]>=e:\n                while len(queue) and queue[-1][1]>=e:\n                    queue.pop()\n                queue.append((i,e))\n        \n        if len(queue)>1 and queue[-1][1]>=queue[0][1]+k:\n            ans=min(ans,i-queue[-1][0])\n            \n        return -1 if ans==float('inf') else ans\n                \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        Sum, res, heap, flag = 0, len(A), [(0, -1)], False\n        \n        for i, v in enumerate(A):\n            Sum += v\n            while heap and Sum - heap[0][0] >= K:\n                flag = True\n                res = min(res, i - heapq.heappop(heap)[1])\n            \n            heapq.heappush(heap, (Sum, i))\n        \n        return res if flag else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        queue = collections.deque([(0, 0)])\n        cur_sum = 0\n        res = len(A) +1\n        \n        for right, val in enumerate(A):\n            cur_sum += val\n            while queue and cur_sum - queue[0][1] >= K:\n                res = min(res, right+1-queue.popleft()[0])\n            while queue and queue[-1][1] >= cur_sum:\n                queue.pop()\n                \n            queue.append((right+1, cur_sum))\n                \n        if res <= len(A):\n            return res\n        return -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        curr_sum = 0\n        s_sum = []\n        s_ind = []\n        res = math.inf\n        for i, num in enumerate(A):\n            curr_sum += num\n            while s_sum and s_sum[-1] >= curr_sum:\n                s_sum.pop()\n                s_ind.pop()\n            \n            if not s_sum:\n                if curr_sum >= K:\n                    res = min(res, i + 1)\n            else:\n                ind = bisect_right(s_sum, curr_sum - K)\n                if ind - 1 >= 0:\n                    res = min(res, i - s_ind[ind - 1])\n                elif curr_sum >= K:\n                    res = min(res, i + 1)\n            \n            s_sum.append(curr_sum)\n            s_ind.append(i)\n        \n        return -1 if math.isinf(res) else res", "import heapq\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        prefix = 0\n        pq = [[0, -1]]\n        res = float('inf')\n        for i, a in enumerate(A):\n            prefix += a\n            while pq and prefix - pq[0][0] >= K:\n                res = min(res, i - heapq.heappop(pq)[1])\n            heapq.heappush(pq, [prefix, i])\n        return res if res < float('inf') else -1\n            \n        \n#         prefix = [0]\n#         for a in A:\n#             prefix.append(prefix[-1] + a)\n#         res = float('inf')\n#         deq = collections.deque()\n        \n        \n#         prefix = [0]\n#         for a in A:\n#             prefix.append(prefix[-1] + a)\n#         res = float('inf')\n#         deq = collections.deque()\n#         for i, x in enumerate(prefix):\n#             while deq and prefix[deq[-1]] >= x:\n#                 deq.pop()\n#             while deq and prefix[deq[0]] <= x - K:\n#                 res = min(res, i - deq.popleft())\n#             deq.append(i)\n#         return res if res < float('inf') else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        prefix = [0] * (len(A)+1)\n        for i in range(len(A)):\n            prefix[i+1] = A[i] + prefix[i]\n        \n        ans = len(A) + 1\n        monoq = deque()\n        for i in range(len(prefix)):\n            while monoq and prefix[i] <= prefix[monoq[-1]]:\n                monoq.pop()\n            while monoq and prefix[i] - prefix[monoq[0]]>=K:\n                ans = min(ans, i-monoq.popleft())\n                \n            monoq.append(i)\n            \n        return ans if ans<len(A)+1 else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        running = [0]\n        for num in A: \n            running.append(running[-1] + num)\n            \n        result = math.inf\n        deque = collections.deque([0]) # left idx\n        r = 1 \n        \n        while r < len(running): \n            if not deque: \n                deque.append(r)\n                r += 1 \n                continue \n                \n            while deque and r < len(running) and running[r] - running[deque[0]] < K:\n                        \n                #pop the last of the queue if it is smaller to maintain mono increasing queue \n                while deque and running[r] <= running[deque[-1]]: \n                    deque.pop()\n                    \n                deque.append(r)\n                r += 1 \n            \n            # right reached the end yet still not satisfied \n            if r == len(running): \n                break\n                \n            while deque and running[r] - running[deque[0]] >= K:\n                l = deque.popleft()\n                result = min(result, r-l)   \n    \n            # r += 1\n            \n        return result if result != math.inf else -1\n            \n\n\n        '''\n        \n                    #pop the last of the queue if it is smaller to maintain mono increasing queue \n                while deque and running[r] <= running[deque[-1]]: \n                    deque.pop()\n                    \n                    \n        l = 0\n        r = 1 \n        \n        while r < len(running): \n            \n            while r < len(running) and running[r] - running[l] < K: \n                r += 1 \n            while l < r and running[r] - running[l+1] >= K: \n                l += 1\n            result = min(result, r-l)\n            r += 1\n            l  += 1\n            \n        return result\n            \n        \n            while r < len(running): \n            while deque and running[r] - running[deque[0]] >= K:\n                result = min(result, i-deque[0])\n                deque.popleft()\n            while deque and running[r] <= running[deque[-1]]:\n                deque.pop()\n            deque.append(r)\n            \n        return result if result != math.inf else -1\n    \n    \n                \n            while r < len(running)-1 and running[r] - running[l] < s: \n                r += 1 \n\n            while l < r and running[r] - running[l] >= s:\n                result = min(result, r-l)                \n                l += 1\n                \n            r += 1\n        '''\n", "import bisect\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        cur, stack, idx, ans = 0, [0], [-1], float('inf')\n        for i, x in enumerate(A):\n            cur += x\n            while len(stack) > 0 and stack[-1] >= cur:\n                stack.pop()\n                idx.pop()\n            j = bisect.bisect_right(stack, cur - K)\n            if j > 0:\n                ans = min(ans, i - idx[j - 1])\n            stack.append(cur)\n            idx.append(i)\n        \n        if ans == float('inf'):\n            return -1\n        return ans\n        \n", "class Solution:\n    def shortestSubarray(self, A, K):\n        N, acc = len(A), [0]\n        for v in A:\n            acc.append(acc[-1] + v)\n        ans, monoq = float('inf'), deque()\n        for size, curS in enumerate(acc):\n            while monoq and curS <= acc[monoq[-1]]:\n                monoq.pop()\n            while monoq and curS - acc[monoq[0]] >= K:\n                ans = min(ans, size - monoq.popleft())\n            monoq.append(size)\n        return ans if ans != float('inf') else -1\n    \nfrom heapq import *\nclass Solution:\n    def shortestSubarray(self, A, K):\n        heap, curS, ans = [(0, -1)], 0, float('inf')\n        for i, v in enumerate(A):\n            curS += v\n            while heap and curS - heap[0][0] >= K:\n                ans = min(ans, i - heappop(heap)[1])\n            heappush(heap, (curS, i))\n        return ans if ans != float('inf') else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        '''\n        idea 1: sliding window:\n                   r      \n        [2, -1, 2, 3] 4\n             l. \n        if cur_sum > k -> move l otherwise move r\n        '''\n        P = [0]\n        for x in A:\n            P.append(P[-1] + x)\n        # the largest i for j such that  A[j] - A[i] >= k\n        # [2, -1, 2, 3]  -> [0, 2, 1, 3, 5]\n        # [0, 1, 3, 5]\n        # \n        ans = len(A)+1\n        dq = collections.deque([])\n        for i, y in enumerate(P):\n            while dq and y < P[dq[-1]]:\n                dq.pop()\n            while dq and y - P[dq[0]] >= K:\n                ans = min(ans, i - dq.popleft())\n            dq.append(i)\n        return ans if ans < len(A)+1 else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        if not A:\n            return -1\n        \n        if len(A) == 1:\n            if A[0] < K:\n                return -1\n            return 1\n        \n        min_length = float('inf')\n        temp = [0]\n        for i in A:\n            temp.append(i + temp[-1])\n        queue = []\n        \n        for c, v in enumerate(temp):\n            \n            while queue and v <= temp[queue[-1]]:\n                queue.pop()\n                \n            while queue and v-temp[queue[0]] >= K:\n                min_length = min(min_length, c-queue.pop(0))\n                \n            queue.append(c)\n            \n        if min_length == float('inf'):\n            return -1\n        return min_length\n        \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        # algorihtm\n        # find the minimum length of the subarray, where there sum >= k\n        # when dealing sum, sum prifix?\n        \n        # sliding window -classis?  O(N^2)\n        # holding a deque ?yes\n        #   decreasing or increasing?\n        #   decresaing? X    no need to save the one before  ==> choose increasing\n        #   save number or index??? we need to i - index, so save index in deque\n        #   when add / delete our dequeue: \n        #          add ==> in for loop\n        #          delete ==> sum_[i] <= sum_[queue[-1]], pop()\n        #                     sum_[i] - sum_[deque[0]] >= K, pop(0)\n        \n        # deque\n        sum_ = [0]\n        for num in A:\n            sum_.append(sum_[-1] + num)\n        result = len(A)+1\n        deque = []\n        for i,num in enumerate(sum_):\n            while(deque and num <= sum_[deque[-1]]):\n                deque.pop()\n            while(deque and num - sum_[deque[0]] >= K):\n                result = min(result, i - deque[0])\n                deque.pop(0)\n            deque.append(i)\n                \n        return result if result != len(A)+1 else -1\n        \n\n\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        Sum, res, heap, flag = 0, len(A), [(0, -1)], False\n        for i, v in enumerate(A):\n            Sum += v\n            while heap and Sum - K >= heap[0][0]:\n                flag = True\n                res = min(res, i - heapq.heappop(heap)[1])\n            heapq.heappush(heap, (Sum, i))\n        return res if flag else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        N = len(A)\n        P = [0]\n        for x in A:\n            P.append(P[-1] + x)\n\n        ans = N+1 # N+1 is impossible\n        monoq = [] #opt(y) candidates, represented as indices of P\n        for y, Py in enumerate(P):\n            #Want opt(y) = largest x with Px <= Py - K\n            while monoq and Py <= P[monoq[-1]]:\n                monoq.pop()\n\n            while monoq and Py - P[monoq[0]] >= K:\n                ans = min(ans, y - monoq.pop(0))\n\n            monoq.append(y)\n\n        return ans if ans < N+1 else -1", "class Solution:\n    def shortestSubarray(self, A, K):\n        from heapq import heappush,heapify,heappop\n        heap = []\n        length = float('inf')\n        summation = 0\n        heapify(heap)\n        heappush(heap,[0,-1])\n        for i,number in enumerate(A):\n            summation += number\n            difference = summation - K\n            while heap and (heap[0][0] <=difference or i - heap[0][1] >= length):\n                previous_summation , previous_index = heappop(heap)\n                length = min(length,i - previous_index)\n            heappush(heap,[summation,i])\n        return length if length != float('inf') else -1", "class Solution:\n    def shortestSubarray(self, nums: List[int], k: int) -> int:\n        nums = [0] + nums\n        \n        deque = [ (0,0) ]\n        cur = 0\n        res = 1+len(nums)\n        \n        for i in range(1,len(nums)):\n            #print(deque)\n            cur += nums[i]\n            while deque and cur-deque[0][1]>=k :\n                res = min(res,i-deque[0][0])\n                deque.pop(0)\n                \n            while deque and deque[-1][1]>=cur:\n                deque.pop(-1)\n                \n            deque.append( (i,cur) )\n        \n        if res>len(nums):\n            return -1\n        return res\n    \n\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        if len(A) == 1:\n            \n            return 1 if A[0] <= K else -1\n        \n        min_len = len(A) + 1\n        \n        dq = []\n        \n        pref = [0]\n        \n        for i in range(len(A)):\n            \n            pref.append(pref[- 1] + A[i])\n            \n        for i in range(len(pref)):\n            \n            # print(dq)\n            \n            while dq and pref[i] <= pref[dq[-1]]:\n                \n                dq.pop(-1)\n                \n            while dq and pref[i] - pref[dq[0]] >= K:\n                \n                min_len = min(min_len, i - dq[0])\n                \n                dq.pop(0)\n                \n            dq.append(i)\n            \n        return min_len if min_len < len(A) + 1 else -1", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        N = len(A)\n        P = [0]\n        for x in A:\n            P.append(P[-1] + x)\n\n        #Want smallest y-x with Py - Px >= K\n        ans = N+1 # N+1 is impossible\n        monoq = collections.deque() #opt(y) candidates, represented as indices of P\n        for y, Py in enumerate(P):\n            #Want opt(y) = largest x with Px <= Py - K\n            while monoq and Py <= P[monoq[-1]]:\n                monoq.pop()\n\n            while monoq and Py - P[monoq[0]] >= K:\n                ans = min(ans, y - monoq.popleft())\n\n            monoq.append(y)\n\n        return ans if ans < N+1 else -1", "from collections import deque\n\nclass Solution:\n    def shortestSubarray(self, A, K):\n        possible_starts = deque([0])\n        \n        prefix_sums = [0 for i in range(len(A) + 1)]\n        for i in range(len(A)):\n            prefix_sums[i + 1] = prefix_sums[i] + A[i]\n       \n        shortest_found = len(A) + 1\n        curr_sum = 0\n        for i in range(len(A) + 1):\n            while len(possible_starts) > 0 and prefix_sums[i] - prefix_sums[possible_starts[0]] >= K:\n                shortest_found = min(shortest_found, i - possible_starts.popleft())\n            while len(possible_starts) > 0 and prefix_sums[i] <= prefix_sums[possible_starts[-1]]:\n                possible_starts.pop()\n            possible_starts.append(i)\n        return shortest_found if shortest_found <= len(A) else -1", "import heapq\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        '''\n        idea 1: sliding window:\n                   r      \n        [2, -1, 2, 3] 4\n             l. \n        if cur_sum > k -> move l otherwise move r\n        \n        longest?\n        [0, 2, -3, 5]   5\n        '''\n        P = [0]\n        for x in A:\n            P.append(P[-1] + x)\n            \n        # the largest i for j such that  A[j] - A[i] >= k\n        # [2, -1, 2, 3]  -> [0, 2, 1, 3, 5]    k =3\n        #                   [0, 1 ]\n        # [0, 1, 3, 5]\n        # [0, 2, 1, 3, 5]\n        # [1, 3]\n         # \n        '''\n        heapq[1, 2, 3]\n        \n        '''\n\n        heap = []\n        min_l = len(A)+1\n        for i, num in enumerate(P):\n            while heap and num - heap[0][0] >= K:\n                v , idx =  heapq.heappop(heap)\n                min_l = min(min_l, i-idx)\n            heapq.heappush(heap, (num, i))\n        return min_l if min_l < len(A)+1 else -1\n        # ans = len(A)+1\n        # dq = collections.deque([])\n        # for i, y in enumerate(P):\n        #     while dq and y < P[dq[-1]]:\n        #         dq.pop()\n        #     while dq and y - P[dq[0]] >= K:\n        #         ans = min(ans, i - dq.popleft())\n        #     dq.append(i)\n        # return ans if ans < len(A)+1 else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        mx = sys.maxsize\n        if A[0] == K:\n            return 1\n        for i in range(1, len(A)):\n            A[i] += A[i-1]\n            if A[i] >= K:\n                mx = min(mx, i+1)\n                \n        st = [0]\n        for i in range(1, len(A)):\n            while len(st) and A[i] - A[st[0]] >= K:\n                popped = st.pop(0)\n                mx = min(mx, i - popped)\n                \n            while len(st) and A[i] <= A[st[-1]]:\n                st.pop()\n                \n            st.append(i)\n        return mx if mx != sys.maxsize else -1\n        '''\n        d = []\n        o = []\n        res, cur = float('inf'), 0\n        for i, a in enumerate(A):\n            cur += a\n            o.append(cur)\n            while d and cur - d[0][1] >= K:\n                res = min(res, i - d.pop(0)[0])\n            while d and cur <= d[-1][1]:\n                d.pop()\n            d.append([i, cur])\n        print(o)\n        return res if res < float('inf') else -1\n    '''\n                \n                \n        \n        \n        \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        d = [[0, 0]]\n        res, cur = float('inf'), 0\n        for i, a in enumerate(A):\n            cur += a\n            while d and cur - d[0][1] >= K:\n                res = min(res, i-d.pop(0)[0]+1)\n            while d and cur <= d[-1][1]:\n                d.pop()\n            d.append([i+1, cur])\n        return res if res < float('inf') else -1", "from collections import deque\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        # prefix_sums[i] == sum(A[:i - 1])\n        prefix_sums = [0]\n        for num in A:\n            prefix_sums.append(prefix_sums[-1] + num)\n        \n        shortest_length = math.inf\n        # a deque of indices i_1, ..., i_k s.t. P[i_1] <= P[i_2] ...\n        cands = deque()\n        for i, prefix_sum in enumerate(prefix_sums):\n            while len(cands) > 0 and prefix_sum <= prefix_sums[cands[-1]]:\n                cands.pop()\n            while len(cands) > 0 and prefix_sum - prefix_sums[cands[0]] >= K:\n                shortest_length = min(shortest_length, i - cands.popleft())\n            cands.append(i)\n        \n        return shortest_length if shortest_length != math.inf else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        prefixSum = [0]*(len(A)+1)\n        for i in range(1,len(prefixSum)):\n            prefixSum[i] = prefixSum[i-1]+A[i-1]\n        \n        dq = deque()\n        shortestLen = sys.maxsize\n        \n        for i in range(len(prefixSum)):\n            while dq and prefixSum[dq[-1]] >= prefixSum[i]:\n                dq.pop()\n            \n            while dq and prefixSum[i]-prefixSum[dq[0]] >= K:\n                shortestLen = min(shortestLen,i-dq[0])\n                dq.popleft()\n            \n            dq.append(i)\n        return shortestLen if shortestLen != sys.maxsize else -1\n", "from collections import deque\n\nclass Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        \n        n = len(A)\n        B = [0 for _ in range(n+1)]\n        for i in range(n):\n            B[i+1] = A[i] + B[i]\n        \n        res = n+1\n        d = deque()\n        for j in range(n+1):\n            while d and B[j] - B[d[0]] >= K:\n                res = min(res, j - d[0])\n                d.popleft()\n            while d and B[d[-1]] > B[j]:\n                d.pop()\n            d.append(j)\n            \n        return res if res <= n else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        p = [0]\n        p[0] = A[0]\n        for i in range(1,len(A)):\n            p.append(p[i-1] + A[i])\n        \n        s = []\n        s.append((-1,0))\n        min_len = float('inf')\n        for i in range(len(p)):\n            while s and  p[i] - s[0][1] >= K:\n                min_len = min(min_len, i - s[0][0])\n                s.pop(0)\n                \n                \n            while s and p[i] <= s[-1][1]:\n                s.pop()\n            \n            s.append((i,p[i]))\n            \n        if min_len != float('inf'):\n            return min_len\n        else:\n            return -1\n            \n                \n            \n        \n            \n            \n            \n            \n                \n                \n            \n                    \n                \n                \n            \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        ans = 1 if A[0] >= K else sys.maxsize\n        \n        \n        for i in range(1, len(A)):\n            A[i] += A[i-1]\n            if A[i] >= K:\n                ans = min(ans, i+1)\n        \n        \n        st = [(A[0],0)]\n        for i in range(1, len(A)):\n            while len(st) and A[i] - st[0][0] >= K:\n                ans = min(ans, i - st[0][1])\n                st.pop(0)\n                \n            while len(st) and A[i] <= st[-1][0]:\n                st.pop()\n\n            st.append((A[i], i))\n            \n        return ans if ans != sys.maxsize else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        psum = 0\n        total = 0\n        dq = deque([(0,-1)])\n        res = float('inf')\n        for i, a in enumerate(A):\n            psum += a\n            # print(dq, i, a, psum)\n            while dq and dq[-1][0]>psum:\n                dq.pop()\n            \n            while dq and psum-dq[0][0]>=K:\n                res = min(res, i-dq.popleft()[1])\n            #  print(dq, res)  \n            dq.append((psum, i))\n        # print(dq)\n        return res if res!=float('inf') else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        '''\n        monoqueue + prefixsum + sliding window\n        '''\n        n = len(A)\n        prefix_sum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n        end = 0\n        res = float('inf')\n        mono_queue = collections.deque()\n        while end < n + 1:\n            while mono_queue and prefix_sum[mono_queue[-1]] >= prefix_sum[end]:\n                mono_queue.pop()\n            while mono_queue and prefix_sum[end] - prefix_sum[mono_queue[0]] >= K:\n                start_index = mono_queue.popleft()\n                res = min(res, end - start_index)\n            mono_queue.append(end)\n            end += 1\n        return res if res != float('inf') else -1\n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        mx = sys.maxsize\n        if A[0] == K:\n            return 1\n        for i in range(1, len(A)):\n            A[i] += A[i-1]\n            if A[i] >= K:\n                mx = min(mx, i+1)\n                \n        st = [0]\n\n        for i in range(1, len(A)):\n            while len(st) and A[i] - A[st[0]] >= K:\n                popped = st.pop(0)\n                mx = min(mx, i - popped)\n                \n            while len(st) and A[i] <= A[st[-1]]:\n                st.pop()\n                \n            st.append(i)\n        return mx if mx != sys.maxsize else -1\n        '''\n        d = []\n        o = []\n        res, cur = float('inf'), 0\n        for i, a in enumerate(A):\n            cur += a\n            o.append(cur)\n            while d and cur - d[0][1] >= K:\n                res = min(res, i - d.pop(0)[0])\n            while d and cur <= d[-1][1]:\n                d.pop()\n            d.append([i, cur])\n        print(o)\n        return res if res < float('inf') else -1\n    '''\n                \n                \n        \n        \n        \n", "class Solution:\n    def shortestSubarray(self, A: List[int], K: int) -> int:\n        total = 0\n        q = deque()\n        q.append([-1, 0])\n\n        res = float('inf')\n        for i, v in enumerate(A):\n            total += v\n            #print(q[0])\n         \n                \n            while q and total < q[-1][1]:\n                q.pop()\n                \n            q.append([i, total])\n            while q and total - q[0][1] >=K:\n                res = min(res, i - q[0][0])\n                q.popleft()\n\n        return res if res != float('inf') else -1"]
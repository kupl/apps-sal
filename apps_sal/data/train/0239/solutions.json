["class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        \n        \n        \n        # my solution ... 128 ms ... 99 % ... 17.9 MB ... 85 %\n        #  time: O(nlogn)\n        # space: O(n)\n        \n        l2v = collections.defaultdict(list)\n        for v,l in zip(values, labels):\n            l2v[l].append(v)\n        pool = []\n        for l in l2v:\n            pool += sorted(l2v[l])[-use_limit:]\n        return sum(sorted(pool)[-num_wanted:])\n        \n        \n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n            val_label = list(sorted(zip(values, labels), key = lambda x: x[0], reverse = True))\n\n            cnt_label  = collections.Counter()\n            chosen = 0\n            res = 0\n\n            \n            for val, lab in val_label:\n                if chosen < num_wanted:\n                    if cnt_label[lab] < use_limit:\n                        res += val\n                        chosen += 1\n                        cnt_label[lab] += 1\n            return res\n\n", "class Item:\n    def __init__(self,label,value):\n        self.label=label\n        self.value=value\n\nclass Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        labelvalues=[]\n        i=0\n        while i <len(values):\n            labelvalues.append(Item(labels[i],values[i]))\n            i+=1\n        lv=[]\n        \n        for item in labelvalues:\n            heapq.heappush(lv,(-item.value,item.label))\n        countlabels=collections.defaultdict(int)\n        maximum_sum=0\n        while num_wanted>0 and lv:\n            max_value=heapq.heappop(lv)\n            curr_max=max_value[0]\n            curr_label_value=max_value[1]\n            if countlabels.get(curr_label_value,0)<use_limit:\n                countlabels[curr_label_value]+=1\n                maximum_sum-=curr_max\n                num_wanted-=1\n        return maximum_sum", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        res = 0\n        heap = [[-v, i] for v, i in zip(values, labels)]\n        heapq.heapify(heap)\n        counter = Counter()\n        \n        while heap and num_wanted:\n            v, i = heapq.heappop(heap)\n            if counter[i] == use_limit:\n                continue\n            \n            counter[i] += 1\n            res += -v\n            num_wanted -= 1\n            \n        return res", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n#         # maintain max heap, get largest value for each label\n#         # this brute force solution is O(nlogn + num_wanted)\n#         values_by_label = defaultdict(list)\n#         for i, val in enumerate(values):\n#                 heapq.heappush(values_by_label[labels[i]], -1 * val)\n        \n#         total = 0\n#         label_use_limit = defaultdict(int)\n#         for label in values_by_label.keys():\n#             label_use_limit[label] = use_limit\n\n            \n#         for _ in range(num_wanted - 1, -1, -1):\n#             max_num = -1\n#             for k, v in values_by_label.items():\n#                 if label_use_limit[k] > 0 and len(v) > 0 and -1 * v[0] > max_num:\n#                     max_num = -1 * v[0]\n#                     best_label = k  \n#             if max_num != -1:\n#                 total += max_num\n#                 heapq.heappop(values_by_label[best_label])\n#                 label_use_limit[best_label] -= 1\n        \n#         return total\n\n        ordered_values = [] # maxheap\n        label_use_limit = defaultdict(int)\n        for i, val in enumerate(values):\n            heapq.heappush(ordered_values, (-1 * val, labels[i]))\n            if labels[i] not in label_use_limit:\n                label_use_limit[labels[i]] = use_limit\n        total = 0\n        while len(ordered_values) > 0 and num_wanted > 0:\n            top_elem = heapq.heappop(ordered_values)\n            if label_use_limit[top_elem[1]] > 0:\n                total += (-1 * top_elem[0])\n                label_use_limit[top_elem[1]] -= 1\n                num_wanted -= 1\n        return total\n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        label2values = defaultdict(list)\n        for value, label in zip(values, labels):\n            label2values[label].append(value)\n            \n        all_top_nums = []\n        for values in list(label2values.values()):\n            if use_limit >= len(values):\n                top_nums = values\n            else:\n                top_nums = self.quick_select(use_limit, values)\n            all_top_nums.extend(top_nums)\n            \n        if num_wanted >= len(all_top_nums):\n            return sum(all_top_nums)\n        return sum(self.quick_select(num_wanted, all_top_nums))\n    \n    def quick_select(self, use_limit, nums):\n        low = 0\n        high = len(nums) - 1\n        use_limit -= 1\n        while low <= high:\n            pivot = self.partition(nums, low, high)\n            if pivot == use_limit:\n                return nums[:pivot + 1]\n            elif pivot < use_limit:\n                low = pivot + 1\n            else:\n                high = pivot - 1\n        return nums\n        \n    def partition(self, nums, low, high):\n        pivot = random.randint(low, high)\n        self._swap(nums, pivot, high)\n        pivot = low\n        for i in range(low, high):\n            if nums[i] > nums[high]:\n                self._swap(nums, pivot, i)\n                pivot += 1\n        self._swap(nums, pivot, high)\n        return pivot\n    \n    def _swap(self, nums, i, j):\n        nums[i], nums[j] = nums[j], nums[i]\n        \n# Follow-up 1\n# Do beter than O(nlogn).\n\n# Follow-up 2\n# Can you do it in O(n) time?\n\n# What about using QuickSelect?\n\n# Steps:\n\n# Separate all elements by label => HashMap<Label, Array> m;\n# Use QuickSelect on each label's elements to find the largest m elements.\n# Merge the largest m elements from each label into an array\n# Use QuickSelect again on the resulting array to get the largest k elements.\n# *each step can be done in O(N).\n", "import heapq \n\nclass Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        \n        maxHeap = []\n        \n        for value, label in zip(values, labels):\n            print((value, label))\n            heappush(maxHeap, (-value, label))\n            \n        labelFrequencies = {} \n        maxSum = 0\n        numChosen = 0\n        \n        while maxHeap and numChosen < num_wanted: \n            value, label = heappop(maxHeap)\n            value = -value\n            \n            #when you can't use that value \n            if label in labelFrequencies and labelFrequencies[label] >= use_limit:\n                continue \n            \n            if label not in labelFrequencies:\n                labelFrequencies[label] = 0 \n                \n            labelFrequencies[label] += 1 \n            numChosen += 1 \n            maxSum += value \n            \n        return maxSum \n                \n            \n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        # Greedy search\n        # 1. sorted each item based on used frequency\n        # 2. loop through and items until bag full\n        \n        items = sorted(list(zip(values, labels)), key=lambda x: -x[0])\n        \n        res = 0\n        freq = defaultdict(int)\n        n = 0\n        for i, (val, label) in enumerate(items):\n            if freq[label] < use_limit:\n                freq[label] += 1\n                res += val\n                n += 1\n            \n            if n == num_wanted:\n                break\n        \n        return res\n            \n            \n", "from collections import defaultdict\n\nclass Solution:\n    def quickselect(self, nums, K):\n        def swap(nums, i, j):\n            nums[i], nums[j] = nums[j], nums[i]\n\n        def partition(nums, left, right, pivotIdx):\n            if right-left <= 1:\n                return left\n            \n            pivot = nums[pivotIdx]\n            swap(nums, pivotIdx, right-1)\n            \n            read_idx = left\n            write_idx = left\n            while read_idx < right-1:\n                if nums[read_idx] > pivot:\n                    swap(nums, read_idx, write_idx)\n                    write_idx += 1\n                read_idx += 1\n            \n            swap(nums, write_idx, right-1)\n            return write_idx\n        \n        left = 0\n        right = len(nums)\n        pivotIdx = -1\n        while pivotIdx != K:\n            pivotIdx = left + (right-left)//2\n            pivotIdx = partition(nums, left, right, pivotIdx)\n            \n            if pivotIdx < K:\n                left = pivotIdx+1\n            elif pivotIdx > K:\n                right = pivotIdx\n                \n\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        valuesByLabel = defaultdict(list)\n        for value, label in zip(values, labels):\n            valuesByLabel[label].append(value)\n            \n        valuesWithinLimit = []\n        for i_label, i_values in valuesByLabel.items():\n            self.quickselect(i_values, use_limit)\n            valuesWithinLimit += i_values[:use_limit]\n            \n        self.quickselect(valuesWithinLimit, num_wanted)\n        return sum(valuesWithinLimit[:num_wanted])", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        dic = {}\n        for i,j in zip(values,labels):\n            if j not in dic:\n                dic[j] = [i]\n            else:\n                dic[j].append(i)\n        \n        res_arr = []\n        \n        for i in dic:\n            res_arr.extend(sorted(dic[i],reverse=True)[0:use_limit])\n        \n        res_arr.sort()\n        count = 0\n        res = 0\n        while count < num_wanted and len(res_arr) > 0:\n            tmp  = res_arr.pop()\n            res += tmp\n            count += 1\n        return res\n        \n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        res = 0\n        arr = sorted(list(zip(values, labels)), key=lambda x: x[0], reverse=1)\n        cnt_label = {}\n        cnt_tot = 0\n        for val, lab in arr:\n            if cnt_tot < num_wanted and cnt_label.get(lab, 0) < use_limit:\n                cnt_tot += 1\n                cnt_label[lab] = cnt_label.get(lab, 0) + 1\n                res += val\n        return res\n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        d =defaultdict(list)\n        n = len(labels)\n        for i in range(n):\n            d[labels[i]].append(values[i])\n        \n        arr = []\n        for k,v in list(d.items()):\n            d[k].sort(reverse=True)\n            d[k] = d[k][:use_limit]\n            arr.extend(d[k])\n        \n        arr.sort(reverse=True)\n        return sum(arr[:num_wanted])\n        \n        \n            \n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        heap = []\n        for v, l in zip(values, labels):\n            heapq.heappush(heap, (-v, l))\n        \n        count = collections.Counter()\n        res = []\n        while heap and len(res) < num_wanted:\n            v, l = heapq.heappop(heap)\n            if count[l] < use_limit:\n                res.append(v)\n                count[l] += 1\n        return -sum(res)\n        \n", "from collections import defaultdict\n\nclass Solution:\n\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        \n        if len(values) == 0:\n            return 0\n        if len(values) != len(labels):\n            raise ValueError\n        \n        sorted_value_labels = sorted(zip(values, labels), key=lambda x: -x[0])\n        label_counter = defaultdict(lambda: 0)\n        \n        i = 0\n        total = 0\n        S = 0\n\n        while S != num_wanted and i < len(values):\n            val, label = sorted_value_labels[i]\n            if label_counter[label] < use_limit:\n                total += val\n                label_counter[label] += 1\n                S += 1\n            i += 1\n        \n        return total\n                \n            \n            \n        \n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        sum = 0\n        ct = {}\n        import numpy as np\n        sorted_idx = np.argsort(-np.array(values))\n        select_ct = 0\n        for v in sorted_idx:\n            print(v)\n            if select_ct == num_wanted:\n                break\n            label = labels[v]\n            if label not in list(ct.keys()):\n                ct[label] = 1\n                sum += values[v]\n                select_ct += 1\n            elif ct[label] < use_limit:\n                ct[label] += 1\n                sum += values[v]\n                select_ct += 1\n            else:\n                continue\n            print(sum)\n        return sum\n        \n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        newList = [(v, l) for v, l in zip(values, labels)]\n        newList.sort(reverse = True)\n        \n        ans = 0\n        i = 0\n        labelCounter = defaultdict(int)\n        for v, l in newList:\n            if labelCounter[l] < use_limit:\n                # print(v, l)\n                ans += v\n                i += 1\n                labelCounter[l] += 1\n                if i == num_wanted:\n                    break\n        return ans", "from collections import defaultdict\n\nclass Solution:\n    def largestValsFromLabels(self, values, labels, num_wanted, use_limit):\n        if not values or not labels:\n            return 0\n        index = [i for i in range(len(values))]\n        index.sort(key=lambda i: values[i], reverse=True)\n        res = 0\n        lab_to_count = defaultdict(int)\n        for i in index:\n            if num_wanted == 0:\n                return res\n            l = labels[i]\n            v = values[i]\n            if l not in lab_to_count or lab_to_count[l] < use_limit:\n                res += v\n                lab_to_count[l] += 1\n                num_wanted -= 1    \n        return res\n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        all_value_labels = [(value, label) for value, label in zip(values, labels)]\n        all_value_labels.sort(reverse=True)\n        used = Counter()\n        ans = []\n        for value, label in all_value_labels:\n            if used[label] + 1 <= use_limit:\n                used[label] += 1\n                ans.append(value)\n                if len(ans) == num_wanted:\n                    break\n        return sum(ans)\n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        heap = []\n        for i in range(len(values)):\n            heappush(heap, (-values[i], labels[i]))\n        selected, label_counts = [], {}\n        while len(selected) < num_wanted and heap:\n            value, label = heappop(heap)\n            if (cur_num := label_counts.get(label, 0)) < use_limit:\n                label_counts[label] = cur_num + 1\n                selected.append(value)\n        print(selected)\n        return -sum(selected)", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        counts = collections.defaultdict(int)\n        vl = sorted(zip(values,labels))\n        ans = 0\n        while num_wanted and vl:\n            val,lab = vl.pop()\n            if counts[lab] < use_limit:\n                ans += val\n                counts[lab] += 1\n                num_wanted -= 1\n        return ans", "from collections import defaultdict\n\nclass Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        \n        counts = defaultdict(int)\n        s = 0\n        total_count = 0\n        \n        inds = sorted(list(range(len(values))), key=lambda x: values[x], reverse=True)\n        \n        sorted_values = [values[idx] for idx in inds]\n        sorted_labels = [labels[idx] for idx in inds]\n        \n        for i, val in enumerate(sorted_values):\n            label = sorted_labels[i]\n            if total_count < num_wanted and counts[label] < use_limit:\n                counts[label] += 1\n                total_count += 1\n                s += val\n                \n            if total_count == num_wanted:\n                break\n        return s\n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        vls = sorted(zip(values, labels), reverse=True)\n        l2v = defaultdict(list)\n        for v,l in vls:\n            l2v[l].append(v)\n        chosen = []\n        l_use = defaultdict(int)\n        for i, (v, l) in enumerate(vls):\n            if l_use[l] < use_limit:\n                chosen.append((v,l))\n                l_use[l] += 1\n                if len(chosen) >= num_wanted:\n                    break\n        # print(chosen)\n        return sum(v for v,l in chosen)", "from collections import Counter\nimport heapq\n\nclass Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        h = list(zip([-v for v in values], labels))\n\n        heapq.heapify(h)\n        \n        counter = Counter()\n\n        ans = 0\n        while num_wanted and h:\n            heap_item = heapq.heappop(h)\n            val, label = heap_item\n            if counter[label] == use_limit:\n                continue\n                \n            counter[label] += 1\n            ans += -val\n            num_wanted -= 1\n            \n        return ans\n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        items = []\n        for i in range(len(values)):\n            items.append((values[i], labels[i]))\n    \n        items.sort(key = lambda item: item[0], reverse=True)\n        dic = Counter(labels)\n\n        \n        for item in dic:\n            if dic[item] > use_limit:\n                dic[item] = use_limit\n                \n        largest = 0\n        print(dic)\n        print(items)\n        for num in items:\n            if num_wanted == 0:\n                break\n            current_label = num[1]\n            value = num[0]\n            print(current_label)\n            \n            if dic[current_label] > 0:\n                num_wanted -= 1\n                dic[current_label] -= 1\n                largest += value\n        return largest\n", "from queue import PriorityQueue\n\nclass Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        pq = PriorityQueue()\n        for i in range(len(values)):\n            pq.put((-values[i],labels[i]))\n        \n        subset_sum = 0\n        ecount = 0\n        label_usage_count_map = {}\n        \n        while (pq.qsize()>0):\n            popped_element = pq.get()\n            v = -popped_element[0]\n            l = popped_element[1]\n            \n            if (v<0):\n                break\n            \n            if (ecount>=num_wanted):\n                break\n            \n            lusage = label_usage_count_map.get(l,0)\n            if (lusage>=use_limit):\n                continue\n            \n            ecount += 1\n            subset_sum += v\n            label_usage_count_map[l] = label_usage_count_map.get(l,0) + 1\n        \n        return subset_sum\n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        empty = {i : use_limit for i in set(labels)}\n        ans = 0\n        pairs = [(values[i], labels[i]) for i in range(len(values))]\n        pairs.sort(key = lambda x : (-x[0]))\n        for index, pair in enumerate(pairs):\n            if empty[pair[1]] > 0 and num_wanted > 0:\n                ans += pair[0]\n                empty[pair[1]] -= 1\n                num_wanted -= 1\n        return ans", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        val_label_tuple = [(-1*val, lab) for val, lab in zip(values, labels)]\n        import heapq\n        heapq.heapify(val_label_tuple) #maximum val is at the top\n        counts = collections.defaultdict(int)\n        \n        ans = 0\n        while val_label_tuple:\n            val, lab = heapq.heappop(val_label_tuple)\n            if counts.get(lab, 0) < use_limit:\n                ans += abs(val)\n                num_wanted -= 1\n                if num_wanted == 0:\n                    break\n                counts[lab] += 1\n        \n        return ans\n                \n        \n        \n        '''\n        val_label_tuple = [(val, lab) for val, lab in zip(values, labels)]\n        val_label_tuple = sorted(val_label_tuple, key=lambda x: x[0], reverse=True)\n        \n        count_items = defaultdict(int)\n        ret_value = 0\n        \n        for val, label in val_label_tuple:\n            if count_items.get(label, 0) < use_limit:\n                ret_value += val\n                count_items[label] += 1\n                num_wanted -= 1\n                if num_wanted == 0:\n                    break\n        \n        return ret_value\n        '''", "from collections import defaultdict\nfrom queue import PriorityQueue\n\n\nclass Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        q = PriorityQueue()\n        for i in range(len(values)):\n            q.put((-values[i], values[i], labels[i]))\n        d = defaultdict(lambda: 0)\n        ans = []\n        while len(ans) < num_wanted and not q.empty():\n            _, n, l = q.get()\n            if d[l] < use_limit:\n                ans.append(n)\n                d[l] += 1\n        return sum(ans)", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        values_w_labels = [(values[i], labels[i]) for i in range(len(values))]\n        values_w_labels.sort(reverse=True)\n        label_count = {}\n        total = 0\n        count = 0\n        for value, label in values_w_labels:\n            if label not in label_count:\n                label_count[label] = 0\n            if label_count[label] < use_limit:\n                total += value\n                label_count[label] += 1\n                count += 1\n            if count == num_wanted:\n                break\n        return total", "from heapq import *\nclass Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        maxHeap = []\n        maxSum = 0\n        \n        for i in range(len(values)):\n            heappush(maxHeap, (-values[i], labels[i]))\n            \n        usedLabels = defaultdict(int)\n        \n        while num_wanted > 0 and len(maxHeap) > 0:\n            currVal, currLabel = heappop(maxHeap)\n            \n            if usedLabels[currLabel] < use_limit:\n                usedLabels[currLabel] += 1\n                maxSum -= currVal\n                num_wanted -= 1\n                \n        return maxSum\n                \n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        \n        hashmap = collections.defaultdict(int)\n        \n        maxHeap = [(-v,labels[i]) for i,v in enumerate(values)]\n        heapq.heapify(maxHeap)\n        out = 0\n        while num_wanted>0:\n            if len(maxHeap)==0: \n                break \n            value, label = heapq.heappop(maxHeap)\n            if hashmap[label]<use_limit:\n                hashmap[label] = hashmap[label] +1 \n                num_wanted -= 1\n                out = out - value\n        return out\n        \n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        heap = []\n        \n        for i in range(len(values)):\n            heappush(heap, (-values[i], labels[i]))\n            \n        if use_limit == 0 or num_wanted == 0:\n            return 0\n            \n        used = {}\n        ret = 0\n        while len(heap) > 0:\n            heap_item = heappop(heap)\n            value = heap_item[0]\n            label = heap_item[1]\n            \n            used[label] = used.get(label, 0) + 1\n            if used[label] <= use_limit:\n                ret += (-value)\n                num_wanted -= 1\n                \n                if num_wanted == 0:\n                    break\n        \n        return ret\n            \n", "class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        from heapq import heapify, heappop\n        from collections import Counter\n        counter = Counter()\n        pq, ans = [[-value, label] for value, label in zip(values, labels)], []\n        heapify(pq)\n        while pq:\n            cur = heappop(pq)\n            if counter[cur[1]] < use_limit:\n                counter[cur[1]] += 1\n                ans.append(-cur[0])\n                if len(ans) == num_wanted:\n                    break\n        return sum(ans)"]
["class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        max_distance_between = (position[-1] - 1) // (m - 1)\n        min_distance_between = 1\n        \n        if self.isDistancePossible(max_distance_between, position, m): return max_distance_between\n        \n        while max_distance_between > min_distance_between + 1:\n            middle_distance = (min_distance_between + max_distance_between) // 2\n            \n            if self.isDistancePossible(middle_distance, position, m):\n                min_distance_between = middle_distance\n            else:\n                max_distance_between = middle_distance\n                \n        return min_distance_between\n    \n    def isDistancePossible(self, distance, position, m):\n        used_ball_count = 0\n        previous_used_position = float('-inf')\n        \n        for pos in position:\n            if pos - previous_used_position >= distance:\n                used_ball_count += 1\n                previous_used_position = pos\n                \n        return used_ball_count >= m", "class Solution:\n    def maxDistance(self, p: List[int], m: int) -> int:\n        \n        def isvalid(f: int):            \n            buckets, pos = 1, p[0]           \n            for x in p:\n                if f <= x - pos:\n                    buckets += 1\n                    if buckets == m:  return True\n                    pos = x            \n            return False\n        \n        p.sort()        \n        lb, ub = 1, (p[-1] - p[0]) // (m - 1) + 1\n        \n        while 1 < ub - lb:\n            \n            f = (lb + ub) // 2\n            \n            if isvalid(f): lb = f  \n            else: ub = f\n            \n        return lb\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        res = -1\n        if m == 2:\n            return position[-1]-position[0]\n        \n        def count(spacing):\n            count = 1\n            prev_pos = position[0]\n            for pos in position:\n                if pos-prev_pos>=spacing:\n                    count+=1\n                    prev_pos = pos\n            return count\n        \n        \n        left,right = 1,math.ceil(position[-1]/(m-1))\n        while left<=right:\n            mid = (left+right)//2\n            if count(mid)>=m:\n                res = mid\n                left = mid+1\n            else:\n                right = mid-1\n        \n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        sorted_position = sorted(position)\n        \n        N = len(position)\n        lo = 1\n        hi = sorted_position[N-1] - sorted_position[0]\n        \n        last_achieved = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if self._try_target(mid, sorted_position, m):\n                lo = mid+1\n                last_achieved = mid\n            else:\n                hi = mid-1\n        \n        return last_achieved\n    \n    def _try_target(self, target: int, positions: List[int], m:int) -> bool:\n        slotted = 1\n        last_slotted = positions[0]\n        \n        for i in range(1, len(positions)):\n            if positions[i] - last_slotted >= target:\n                slotted += 1\n                last_slotted = positions[i]\n        \n        return slotted >= m\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        @lru_cache(maxsize=None)\n        def dfs(i, k, i0):\n            # put k balls into position[i:] with max min force\n            # i0 is the position with the largest index between position[0] and position[i-1]\n            # d0 is the max min force between balls placed between position[0] and position[i-1]\n            if k > (n-i):\n                return 0\n            if k == 1:\n                return position[n-1]-position[i0]\n            if k == 0:\n                return 1e20\n\n            d = 0\n            for j in range(i, n):\n                d_new = dfs(j+1, k-1, j)\n                d = max(min(d_new, position[j]-position[i0]), d)\n                        \n            return d\n        \n        #return dfs(1, m-1, 0)\n            \n        @lru_cache(None)\n        def f(i, k):\n            if k == 0:\n                return float('inf')\n            if i == len(position):\n                return float('-inf')\n               \n            ret = f(i+1, k)\n            for x in range(i+1, len(position)):\n                v = min(position[x] - position[i], f(x, k-1))\n                ret = max(ret, v)\n            \n            return ret\n        \n        #return f(0, m-1)\n\n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n    \n    # position = [1,2,3,4,7], m = 3, n=5\n    # dfs(0, 3, -1e20, 1e20)\n    # i=0, k=3, n-i=5\n    # j=0, d0_new = 1e20, \n    # dfs(1, 2, 0, 1e20): d_new = ?\n    # dfs(2, 2, 1, 1e20): d_new = ?\n    # dfs(3, 2, 2, 1e20): d_new = \n    # dfs(4, 2, 3, 1e20): k=2 > 5-4=1, d_new = 0\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        res = 0\n        \n        def count(d):\n            cur, ans = position[0], 1\n            for i in range(1, n):\n                if position[i] - cur >= d:\n                    ans += 1\n                    cur = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        return self.binaryS(0, position[-1], position, m)\n    \n\n    def binaryS(self, left, right, position, m):\n        while left < right:\n            mid = (left + right) // 2\n            val = self.check(position, mid + 1, m)\n            if val: left = mid + 1\n            else: right = mid\n        return right\n                \n        \n        \n    def check(self, position, interval, m) -> bool:\n        total = 1\n        start = position[0]\n        for i in range(1, len(position)):\n            if position[i] - start  >= interval:\n                total += 1\n                start = position[i]\n        return total >= m", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def isPossible(x):\n            count = m-1\n            curr = position[0]\n            for i in range(1,n):\n                if position[i]-curr>=x:\n                    count-=1\n                    curr = position[i]\n                if not count:\n                    return True\n            return False\n        \n        n = len(position)\n        position.sort()\n        lo = 1\n        hi = position[-1]-position[0]+1\n        \n        while hi-lo>1:\n            mid = lo + (hi-lo)//2\n            \n            if isPossible(mid):\n                lo = mid\n            else:\n                hi = mid\n        \n        return lo", "import numpy as np\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # Choose m values from n such that the minimum of the differences is maximized\n        position.sort()\n        \n        def check(check_val):\n            temp_m = m-1\n            \n            previous_pos = position[0]\n            \n            for p in position[1:]:\n                if p - previous_pos >= check_val:\n                    previous_pos = p\n                    temp_m -= 1\n                    if temp_m == 0:\n                        return True\n            return False\n        \n        l = 0   # min return value\n        r = (position[-1] - position[0]) # max return value\n        \n        ret = l\n        while l <= r:\n            val = (l+r)//2\n            if check(val):\n                ret = max(ret, val)\n                l = val + 1\n            else:\n                r = val-1\n        return ret\n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        return self.binaryS(0, position[-1], position, m)\n    \n\n    def binaryS(self, left, right, position, m):\n        while left < right:\n            mid = (left + right) // 2\n            val = self.check(position, mid + 1, m)\n            if val: left = mid + 1\n            else: right = mid\n        return left\n                \n        \n        \n    def check(self, position, interval, m) -> bool:\n        total = 1\n        start = position[0]\n        for i in range(1, len(position)):\n            if position[i] - start  >= interval:\n                total += 1\n                start = position[i]\n        return total >= m", "class Solution:\n    def maxDistance(self, A: List[int], m: int) -> int:\n        n = len(A)\n        A.sort()\n        \n        def count(d):\n            ans, curr = 1, A[0]\n            for i in range(1, n):\n                if A[i] - curr >= d:\n                    ans += 1\n                    curr = A[i]\n            return ans\n        \n        l, r = 0, A[-1] - A[0]\n        while l < r:\n            mid = (l+r+1) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l <= r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return r\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def helper(distance):\n            balls = m - 1\n            previous = position[0]\n            for i in position[1:]:\n                if i - previous >= distance:\n                    balls -= 1\n                    if balls == 0:\n                        return True\n                    previous = i\n            return False\n            \n        position.sort()\n        min_distance = 1\n        max_distance = (position[-1] - position[0]) // (m - 1)\n        # max_distance = position[-1] - position[0]\n        result = 1\n        while min_distance <= max_distance:\n            mid = (min_distance + max_distance) // 2\n            if helper(mid):\n                result = mid\n                min_distance = mid + 1\n            else:\n                max_distance = mid - 1\n        return result", "import bisect\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def is_ok(x):\n            cur = -x\n            for i in range(m):\n                j = bisect.bisect_left(position, cur+x)\n                if 0 <= j < len(position):\n                    cur = position[j]\n                else:\n                    return False\n            else:\n                return True\n                    \n            \n        l = 0\n        r = 10**18\n        while l+1 < r:\n            c = (l+r)//2\n            if is_ok(c):\n                l = c\n            else:\n                r = c\n        return l\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "import math\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        max_possible_answer = (position[-1] - position[0]) // (m-1) #3\n        \n        # linear search - time limit exceed\n        # for i in range(1,1+max_possible_answer): \n        #     if not self.is_possible( position, m, i):\n        #         break\n        # return i-1\n\n        # binary search\n        l = 1\n        r = max_possible_answer + 1 \n        # T T T T T F F -> want to know last T\n        # similar to 278\n        while l < r :\n            # why + 1?? because we use l = mid (inclusive) if we don't round up \n            # it will get stuck\n            # mid = (r+l) // 2  + 1\n            mid = math.ceil((r+l)/2)\n            if self.is_possible( position, m, mid):\n                l = mid # mid may be answer\n            else:\n                r = mid-1 # mid can't be answer\n        return l\n        \n    def is_possible(self, position, m, gap):\n        i = 1\n        prev = position[0]\n        m -= 1\n        while i < len(position) and m > 0:\n            if position[i] - prev >= gap:\n                m -= 1\n                prev = position[i]\n            else:\n                i += 1\n\n        return m == 0\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = (r+l+1) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def getBallCount(position, force):\n            res, prev = 1, 0\n            for i in range(1, len(position)):\n                if position[i] - position[prev] >= force:\n                    res += 1\n                    prev = i\n            return res\n        \n        # position.sort()\n        # l,r,ans=0,position[-1],0\n        # while l<=r:\n        #     gap=l+(r-l)//2\n        #     if getBallCount(position, gap) >= m:\n        #         ans=gap\n        #         l=gap+1\n        #     else:\n        #         r=gap-1\n        # return ans\n        \n        position.sort()\n        if m == 2:\n            return position[-1] - position[0]\n        l, r, res = 0, position[-1] + 1, 0\n        while l < r:\n            mid = l + (r - l) // 2\n            # force is too small\n            if getBallCount(position, mid) >= m:\n                l = mid + 1\n                res = mid\n            else:\n                r = mid\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position.sort()\n        left = 0\n        right = position[-1] - position[0]\n        \n        best = 0\n        while left <= right:\n            target = left + (right-left)//2\n            if self.solve(position, m, target):\n                left = target+1\n                best = max(best, target)\n            else:\n                right = target-1\n        \n        return best\n\n    \n    def solve(self, position, m, target):\n        p = position[0]\n        m -= 1\n        \n        for p2 in position[1:]:\n            if p2 - p >= target:\n                m -= 1\n                p = p2\n            \n            if m == 0:\n                return True\n        \n        return False\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l = 0\n        r = (position[-1]-1) // (m-1) * 2\n        while l < r:\n            intrv = (l+r) // 2\n            c = 0\n            prev = float('-inf')\n            for p in position:\n                if p >= prev + intrv:\n                    c += 1\n                    prev = p\n            if c >= m:\n                best = intrv\n                l = intrv + 1\n            else:\n                r = intrv\n        return best\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        max_possible_answer = (position[-1] - position[0]) // (m-1) #3\n        \n        # linear search - time limit exceed\n        # for i in range(1,1+max_possible_answer): \n        #     if not self.is_possible( position, m, i):\n        #         break\n        # return i-1\n\n        # binary search\n        l = 1\n        r = max_possible_answer + 1 \n        # T T T T T F F -> want to know last T\n        # similar to 278\n        while l < r :\n            # why + 1?? because we use l = mid (inclusive) if we don't round up \n            # it will get stuck\n            mid = (r+l) // 2  + 1\n            if self.is_possible( position, m, mid):\n                l = mid # mid may be answer\n            else:\n                r = mid-1 # mid can't be answer\n        return l\n        \n    def is_possible(self, position, m, gap):\n        i = 1\n        prev = position[0]\n        m -= 1\n        while i < len(position) and m > 0:\n            if position[i] - prev >= gap:\n                m -= 1\n                prev = position[i]\n            else:\n                i += 1\n\n        return m == 0\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check(position,val,m):\n            balls = 1\n            prev = position[0]\n            for i in range(1,len(position)):\n                if (position[i]-prev) >= val:\n                    prev = position[i]\n                    balls += 1\n            if balls >= m:\n                return True\n            return False\n        \n        position.sort()\n        lo,hi = 0 , position[-1]-position[0]\n        while lo < hi:\n            mid = (hi+lo+1)//2\n            if check(position,mid,m):\n                lo = mid\n            else:\n                hi = mid-1\n        return lo", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        left, right = 1, position[-1] - position[0]\n        while left <= right:\n            mid = left + (right - left)//2\n            num_balls = self.count(position, m, mid)\n            if num_balls > m:  # too many balls can fit in the given baskets, force is too small, search the right hal\n                left = mid + 1\n            elif num_balls == m:  # need to find the maximum force, continue to search the right half\n                left = mid + 1\n            else:\n                right = mid -1\n        return left -1\n\n    def count(self, position, m, mid):\n        prev = position[0]\n        m =1\n        for i in position[1:]:\n            # if i - mid == prev:\n            if i - prev >=mid:\n                m+=1\n                prev = i\n        return m\n", "class Solution:\n    # https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/803580/Python-Solution-or-Binary-Search\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def getBallCount(position, force):\n            # res starts from 1, since we put one ball at index = 0.\n            res, prev = 1, 0\n            for i in range(1, len(position)):\n                if position[i] - position[prev] >= force:\n                    res += 1\n                    prev = i\n            return res\n        \n        position.sort()\n        if m == 2:\n            return position[-1] - position[0]\n        l, r, res = 0, position[-1] + 1, 0\n        while l < r:\n            mid = l + (r - l) // 2\n            # force is too small\n            if getBallCount(position, mid) >= m:\n                l = mid + 1\n                res = mid\n            else:\n                r = mid\n        # return res, not l.\n        return res", "import bisect\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        def possible(gap):\n            prev = position[0]\n            idx = 0\n            left = m - 1\n            while left > 0:\n                idx = bisect.bisect_left(position, prev+gap, idx + 1, n)\n                if idx >= n:\n                    return False\n                else:\n                    prev = position[idx]\n                    left -= 1\n            return True\n        \n        position.sort()\n        min_gap = 1\n        max_gap = position[-1] - position[0]\n        while min_gap < max_gap:\n            cur_gap = (min_gap + max_gap + 1) // 2\n            \n            prev = position[0]\n            idx = 0\n            left = m - 1\n            res = True\n            while left > 0:\n                idx = bisect.bisect_left(position, prev + cur_gap, idx + 1, n)\n                if idx >= n:\n                    res = False\n                    break\n                else:\n                    prev = position[idx]\n                    left -= 1\n            \n            if res:\n                min_gap = cur_gap\n            else:\n                max_gap = cur_gap - 1\n                \n        return min_gap", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def helper(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        left, right = 0, position[-1] - position[0]\n        while left <= right:\n            mid = left + (right - left) // 2\n            if helper(mid) < m:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return left - 1\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def getBallCount(position, force):\n            res, prev = 1, 0\n            for i in range(1, len(position)):\n                if position[i] - position[prev] >= force:\n                    res += 1\n                    prev = i\n            return res\n        \n        # position.sort()\n        # l,r,ans=0,position[-1],0\n        # while l<=r:\n        #     gap=l+(r-l)//2\n        #     if getBallCount(position, gap) >= m:\n        #         ans=gap\n        #         l=gap+1\n        #     else:\n        #         r=gap-1\n        # return ans\n        \n        position.sort()\n        if m == 2:\n            return position[-1] - position[0]\n        l, r, res = 0, position[-1] + 1, 0\n        while l < r:\n            mid = l + (r - l) // 2\n            # force is too small\n            if getBallCount(position, mid) >= m:\n                l = mid + 1\n                res = mid\n            else:\n                r = mid\n        # return res, not l.\n        return res", "class Solution:\n    # https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/803580/Python-Solution-or-Binary-Search\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def getBallCount(position, force):\n            # res starts from 1, since we put one ball at index = 0.\n            res, prev = 1, 0\n            for i in range(1, len(position)):\n                if position[i] - position[prev] >= force:\n                    res += 1\n                    prev = i\n            return res\n        \n        position.sort()\n        if m == 2:\n            return position[-1] - position[0]\n        l, r, res = 0, position[-1] + 1, 0\n        while l < r:\n            mid = l + (r - l) // 2\n            # force is too small\n            if getBallCount(position, mid) >= m:\n                l = mid + 1\n                # record res \n                res = mid\n            else:\n                r = mid\n        # return res, not l.\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def possible(force):\n            prev = float('-inf')\n            balls_placed = 0\n            for x in position:\n                if x-prev >= force:  \n                \n                    prev= x\n                    balls_placed+=1  \n                \n            return(balls_placed>=m)\n        \n        lo,hi = 0, max(position)\n        while lo<hi:\n            mid = (lo+hi+1)//2\n            if possible(mid):\n                lo=mid\n                \n            else:\n                hi=mid-1\n                \n        return(lo)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def valid(position, force):\n            prev, j = 0, 1\n            for i in range(1, m):\n                while j < len(position) and position[j] - position[prev] < force:\n                    j += 1\n                if j == len(position):\n                    return False\n                prev = j\n            return True\n        \n        def getBallCount(position, force):\n            res, prev = 1, 0\n            for i in range(1, len(position)):\n                if position[i] - position[prev] >= force:\n                    res += 1\n                    prev = i\n            return res\n        \n        # position.sort()\n        # l,r,ans=0,position[-1],0\n        # while l<=r:\n        #     gap=l+(r-l)//2\n        #     if getBallCount(position, gap) >= m:\n        #         ans=gap\n        #         l=gap+1\n        #     else:\n        #         r=gap-1\n        # return ans\n        \n        position.sort()\n        if m == 2:\n            return position[-1] - position[0]\n        l, r, res = 0, position[-1] + 1, 0\n        while l < r:\n            mid = l + (r - l) // 2\n            # force is too small\n            if getBallCount(position, mid) >= m:\n                l = mid + 1\n                res = mid\n            else:\n                r = mid\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position.sort()\n        \n        def is_valid(guess):\n            prev = position[0]\n            balls = 1\n            for p in position[1:]:\n                if p-prev >= guess:\n                    prev = p\n                    balls += 1\n                if balls == m:  \n                    return True\n            return False\n                    \n        l, r = 1, (position[-1]-position[0]) // (m-1)\n        while l < r:\n            guess = (l + r + 1) >> 1 \n            if is_valid(guess):\n                l = guess\n            else:    \n                r = guess-1\n        return l        \n        \n\n\n    #    position.sort()\n    #    l, r = 1, position[-1] - position[0]\n    #    while l < r:\n    #        cand = (l + r + 1) >> 1\n    #        if self.is_valid(position, m, cand):\n    #            l = cand\n    #        else:    \n    #            r = cand - 1\n    #    return l        \n    #\n    #def is_valid(self, position, m, cand):\n    #    prev = position[0]\n    #    rem = m - 1\n    #    for pos in position[1:]: \n    #        if pos >= prev + cand:\n    #            prev = pos\n    #            rem -= 1\n    #        if rem == 0:    \n    #            return True\n    #    return False\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        l, r = 0, position[n-1]-position[0]\n        while l < r:\n            mid = (r + l + 1) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    # https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/803580/Python-Solution-or-Binary-Search\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def getBallCount(position, force):\n            res, prev = 1, 0\n            for i in range(1, len(position)):\n                if position[i] - position[prev] >= force:\n                    res += 1\n                    prev = i\n            return res\n        \n        position.sort()\n        if m == 2:\n            return position[-1] - position[0]\n        l, r, res = 0, position[-1] + 1, 0\n        while l < r:\n            mid = l + (r - l) // 2\n            # force is too small\n            if getBallCount(position, mid) >= m:\n                l = mid + 1\n                res = mid\n            else:\n                r = mid\n        # return res, not l.\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        if len(position) < m:\n            return 0\n        \n        def valid_force(f):\n            ball_pos = 0\n            balls = m - 1\n            for i in range(1, len(position)):\n                if position[i] - position[ball_pos] >= f:\n                    balls -= 1\n                    ball_pos = i\n                    if balls == 0:\n                        return True\n            \n            return False\n        \n        position.sort()\n        l, h = 1, position[-1]\n        while l < h:\n            f = l + (h - l + 1) // 2\n            if valid_force(f):\n                l = f\n            else:\n                h = f - 1\n        \n        return l\n            \n", "class Solution:\n    def is_force_valid(self, position: List[int], m: int, force: int) -> bool:\n        last_pos = position[0]\n        m -= 1\n        for i in range(1, len(position)):\n            if position[i] - last_pos >= force:\n                m -= 1\n                if m == 0:\n                    return True\n                last_pos = position[i]\n        return False\n        \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        left = 1\n        right = position[-1] - position[0]\n        \n\n        while right > left:\n            mid = (right + left + 1) // 2\n            if self.is_force_valid(position, m, mid):\n                left = mid\n            else:\n                right = mid - 1\n\n        return left\n    \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n#         def pd(i, m):\n#             if m == 1:\n#                 return float(\\\"inf\\\")\n            \n#             if memo[i][m]:\n#                 return memo[i][m]\n            \n#             res = 0\n            \n#             for j in range(i+1, len(position)):\n#                 res = max(res, min(position[j] - position[i], pd(j, m-1)))\n                \n#             memo[i][m] = res\n            \n#             return res\n        \n#         position = sorted(position)\n        \n#         memo = [(1 + m) * [0] for _ in range(1 + len(position))]\n        \n#         res = pd(0, m)\n    \n        position = sorted(position)\n        \n        if m == 2:\n            return position[-1] - position[0]\n        \n        def solve(threshold, m):\n            last_ball_pos = position[0]\n            \n            for pos in position[1:]:\n                if pos - last_ball_pos >= threshold:\n                    m -= 1\n                    last_ball_pos = pos\n                \n                if m == 0:\n                    return True\n                \n            return False\n        \n        start = 0\n        end = position[-1] - position[0]\n        \n        res = 0\n        \n        while start <= end:\n            middle = (start + end) // 2\n                \n            if solve(middle, m-1):\n                start = middle + 1\n                res = max(res, middle)\n                \n            else:\n                end = middle - 1\n    \n        return res", "class Solution:\n    def maxDistance(self, position, m):\n        position = sorted(position)\n        start, end = 1, position[-1] - position[0]\n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if self.check(position, m, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(position, m, end):\n            return end\n        if self.check(position, m, start):\n            return start\n    \n    def check(self, position, m, delta):\n        n = len(position)\n        i = 1\n        last = position[0]\n        for j in range(1, n):\n            if position[j] >= last + delta:\n                last = position[j]\n                i += 1\n                if i == m:\n                    return True\n        return i == m", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def possible(force):\n            prev = float('-inf')\n            balls_placed = 0\n            for x in position:\n                if x-prev >= force:  # then that means we have that required force and we can keep a new ball here at position x\n                    prev= x\n                    balls_placed+=1\n                    \n                if balls_placed ==m: # if at any moment we are able to place m balls, we stop and return True.\n                    return(True)     \n            return(False)\n        \n        lo,hi = 0, max(position)\n        while lo<hi:\n            mid = (lo+hi+1)//2\n            if possible(mid):\n                lo=mid\n                \n            else:\n                hi=mid-1\n                \n        return(lo)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check(x: int):\n            pre = position[0]\n            num = 1\n            for ii in range(1, N):\n                if position[ii] - pre >= x:\n                    pre = position[ii]\n                    num += 1\n            return num >= m\n            \n        N = len(position)\n        position = sorted(position)\n        left, right, res = 0, position[-1] - position[0], -1\n        while left <= right:\n            mid = (left + right) >> 1\n            if check(mid):\n                res = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        return res\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        s = 1 \n        e = (position[-1]-position[0]) // max(m-1, 1) + 1\n        \n        def check(mid) :\n            t = position[0]\n            ret_val = 1\n            for k in position :\n                if ret_val == m :\n                    return True\n                if k - t >= mid :\n                    ret_val += 1\n                    t = k\n            return ret_val == m\n        \n        while e > s + 1 :\n            mid = (e+s)//2\n            if check(mid) :\n                s = mid\n            else :\n                e = mid\n        return s\n        \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        length = len(position)\n        position.sort()\n\n        def count(d):\n            minmax = 1\n            curr = position[0]\n            for i in range(1, length):\n                if position[i] - curr >= d:\n                    minmax += 1\n                    curr = position[i]\n            return minmax\n\n        lo, hi = 0, position[-1] - position[0]\n        while lo < hi:\n            mid = hi - (hi - lo) // 2\n            if count(mid) >= m:\n                lo = mid\n            else:\n                hi = mid - 1\n        return lo\n    \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # sort balls\n        position.sort()\n        # number of balls that can be placed while the difference of two balls is at least diff\n        def count_balls(diff):\n            nballs, cur = 1, position[0]\n            for i in range(1, len(position)):\n                if position[i] - cur >= diff:\n                    nballs += 1\n                    cur = position[i]\n            return nballs\n        # m can range from 1 to position[-1] - position[0]\n        # try out values of m using binary search on left and right\n        left, right = 1, position[-1] - position[0]\n        while left <= right:\n            mid = (left + right) // 2\n            if count_balls(mid) >= m:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return right\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    curr, ans = position[i], ans + 1\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n    def maxDistancwe(self, position: List[int], m: int) -> int:\n        def count(mid):\n            r, c = 1, position[0]\n            for i in range(1,len(position)):\n                if position[i]-c >= mid:\n                    c, r = position[i], r + 1\n            return r\n        position.sort()\n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = (r + l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def isfail(mid):\n            ans = 1\n            curr = position[0] # alike greedy idea, we just put the first ball at position 0!\n            for i in range(1, n):\n                if position[i] - curr >= mid:\n                    ans += 1\n                    curr = position[i]\n            return ans < m\n        \n        left = 0 # \u6ce8\u610f\uff0c\u4e0d\u5e94\u8be5\u628aleft\u8d4b\u503c\u4e3amin(position)! \u56e0\u4e3a\u6211\u4eec\u6c42\u5f97\u662fdistance!\n        # note that, left = min(position) is wrong, since we are looking for 'distance'!\n        right = max(position) - min(position) + 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if isfail(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left - 1 # left is the min value to fail, so left-", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        res = 0\n        l, r = 1, (position[-1] - position[0]) // (m - 1)\n        \n        while l <= r:\n            mid = (l + r) // 2\n            prev = position[0]\n            ball = 1\n            for i in position[1:]:\n                if i - prev >= mid:\n                    ball += 1\n                    prev = i\n                if ball == m:\n                    break\n            if ball == m:\n                l = mid + 1\n                res = mid\n            else:\n                r = mid - 1\n        return res\n        \n                \n", "class Solution:\n    def maxDistance(self, pos: [int], m: int) -> int:\n        pos.sort()\n        N = len(pos)\n        \n        high = (pos[-1]-pos[0])//(m-1)\n        low = 1\n        \n        def check(dist):\n            cnt = 1\n            loc = pos[0]\n            for i in range(1, N):\n                if pos[i]-loc>=dist:\n                    cnt += 1\n                    loc = pos[i]\n                    if cnt == m:\n                        return True\n            return False\n        \n        while high!=low:\n            mid = (high+low+1)//2\n            if check(mid):\n                low = mid\n            else:\n                high = mid-1\n        \n        return high\n                \n        \n        \n            \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        N = len(position)\n        A = position\n        A.sort()\n        \n        lo, hi = 1, A[-1] - A[0]\n        while lo <= hi:\n            mid = (lo + hi + 1) // 2\n            \n            prev = A[0]\n            left = m - 1\n            for i in range(1, N):\n                if A[i] - prev >= mid:\n                    prev = A[i]\n                    left -= 1\n                    if left == 0:\n                        break\n                        \n            if left == 0:\n                answer = mid\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return answer\n        \n", "def solve(positions, m, target):\n    p = positions[0]\n    m -= 1\n    for p2 in positions[1:]:\n        if p2 - p >= target:\n            m -= 1\n            p = p2\n        if m == 0:\n            return True\n    return False                            \n    \nclass Solution:\n    def maxDistance(self, positions: List[int], m: int) -> int:\n        positions.sort()\n        l, r = 0, positions[-1] - positions[0] \n        best = 0\n        while l <= r:\n            target = (l + r) // 2\n            if solve(positions, m, target):\n                l = target + 1\n                best = max(best, target)\n            else:\n                r = target - 1\n        return best                ", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        n = len(position)\n        \n        def countBalls(d):\n            n_balls, cur = 1, position[0]\n            \n            for i in range(1, n):\n                if position[i] - cur >= d:\n                    n_balls += 1\n                    cur = position[i]\n                \n            return n_balls\n        \n        left = 1\n        right = position[n-1] - position[0]\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if countBalls(mid) >= m:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position.sort()\n        def ifvalid(diff,num_division):\n            selected=0\n            cur=position[0]\n            for i,f in enumerate(position):\n                if selected>=num_division:\n                    return True\n                if (f-cur)>=diff:\n                    selected+=1\n                    cur=position[i]\n                else:\n                    if i==len(position)-1:\n                        return False\n            return selected>=num_division\n                    \n                    \n        \n        def search(l,r):\n            while l<r:\n                mid=l+(r-l)//2\n                if not ifvalid(mid,m-1):\n                    r=mid\n                else:\n                    l=mid+1\n            return l-1\n        \n        max_diff=(position[-1]-position[0])//(m-1) +1\n        return search(1,max_diff+1)\n                    \n            \n                    \n                \n                \n                    \n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def count(d):\n            ans = 1\n            pre_pos = position[0]\n            \n            for i in range(1, n):\n                if position[i] - pre_pos >= d:\n                    ans += 1\n                    pre_pos = position[i]\n            \n            return ans\n            \n        n = len(position)\n        position.sort()\n        \n        left = 1\n        right = position[-1] - position[0]\n        \n        while left < right:\n            mid = left + (right-left+1) // 2\n            \n            if count(mid) >= m:\n                left = mid\n            else:\n                right = mid - 1\n                \n        return left", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def count_d(dis):\n            ans, cur = 1, position[0]\n            for i in range(1, len(position)):\n                if position[i] - cur >= dis:\n                    ans += 1\n                    cur = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r-l)//2\n            if count_d(mid) >= m:\n                l = mid \n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def is_possible(gap,left):\n            prev=position[0]\n            for i in range(1,len(position)):\n                if position[i]-prev>=gap:\n                    prev=position[i]\n                    left-=1\n                if not left: return True\n            return False\n        position.sort()\n        l,r,ans=0,position[-1],0\n        while l<=r:\n            gap=(r+l)//2\n            if is_possible(gap,m-1):\n                ans=gap\n                l=gap+1\n            else:\n                r=gap-1\n        return ans\n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def is_possible(gap,left):\n            prev=position[0]\n            for i in range(1,len(position)):\n                if position[i]-prev>=gap:\n                    prev=position[i]\n                    left-=1\n                if not left: return True\n            return False\n        position.sort()\n        l,r,ans=0,position[-1],0\n        while l<=r:\n            gap=l+(r-l)//2\n            if is_possible(gap,m-1):\n                ans=gap\n                l=gap+1\n            else:\n                r=gap-1\n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # \u6700\u5927\u95f4\u9699\u4f7f\u7528\u4e8c\u5206\u6cd5\u67e5\u627e\n        # \u68c0\u67e5\u6700\u5927\u95f4\u9699\u7684\u5408\u7406\u6027\n        # \u4ece\u4e00\u5806\u95f4\u9699\u4e2d\uff0c\u5bfb\u627e\u8fde\u7eed\u957f\u5ea6\u4e3adist\u7684m\u4e2a\u95f4\u9699\n        interval = []\n        sort_pos = sorted(position)\n        for i in range(len(sort_pos)-1):\n            interval.append(sort_pos[i+1]-sort_pos[i])\n        \n        def is_valid(dist,interval):\n            ball = 1\n            count = 0\n            for i in interval:\n                count += i\n                if count>=dist:\n                    ball += 1\n                    count = 0\n            if ball>=m:\n                return True\n            return False\n        \n        left = 1\n        right = sum(interval)//(m-1)\n        # \u5982\u679c\u6700\u4f18\u503c\u505c\u5728right\u4e0a\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5faa\u73af\u6c38\u8fdc\u4e0d\u80fd\u7ed3\u675f\n        while left<right:\n            mid = right - (right-left)//2\n            if is_valid(mid,interval):\n                left = mid\n            else:\n                right = mid - 1\n        return left\n            \n", "class Solution:\n    def fit_balls(self, positions, n, min_dist):\n        \n        last_position = positions[0]\n        placement_count = 1\n        \n        for p in positions:\n            if p - last_position >= min_dist:\n                last_position = p\n                placement_count += 1\n                if placement_count >= n:\n                    return True\n                \n        return False\n        \n    def maxDistance(self, position: List[int], m: int) -> int:\n        pos = sorted(position)\n        \n        lo = 0\n        hi = pos[-1]-pos[0]\n        \n        while lo < hi:\n            mid = hi - (hi-lo) // 2\n            can_fit = self.fit_balls(pos, m, mid)\n            \n            if not can_fit:\n                hi = mid-1\n            else:\n                lo = mid\n                \n        \n        return lo\n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def valid(force):\n            nonlocal position, m\n            \n            start = count = 0\n            for index, value in enumerate(position):\n                if value - force >= position[start]:\n                    count += 1\n                    start = index\n\n            return count >= m - 1\n        \n        lo, hi = 1, position[-1] - position[0]\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            \n            if valid(mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        \n        return lo", "class Solution:\n    def maxDistance(self, positions: List[int], m: int) -> int:\n        \n        positions.sort()\n        \n        \n        def possible(positions,m,v):\n            \n            cur=0\n            for i in range(1,len(positions)):\n                \n                if positions[i]-positions[cur]>=v:\n                    m-=1\n                    cur=i\n                    if m==1: return True\n            \n            return m<=1\n             \n        left,right=1,positions[-1]-positions[0]\n        \n        ans=0\n        while left<=right:\n            \n            v=(left+right)//2\n            # print(possible(positions,m,v),m,v)\n            if possible(positions,m,v):\n                ans=v\n                left=v+1\n            else:\n                right=v-1\n        \n        return ans", "from math import ceil\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        minPos, maxPos = position[0], position[len(position) - 1]\n        lo, hi = 0, maxPos - minPos\n        curAns = -1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if self.canFitAllBalls(mid, m, position):\n                curAns = max(curAns, mid)\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return curAns\n                \n    def canFitAllBalls(self, dist, m, position):\n        prev = None\n        for pos in position:\n            if prev == None or (pos - prev >= dist):\n                m -= 1\n                prev = pos\n            if m == 0:\n                break\n        return m == 0", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        positions = position\n        positions.sort()\n        n = len(positions)\n        def f(d):\n            prev = 0\n            balls = 1\n            for i in range(1, n):\n                if positions[i] - positions[prev] >= d:\n                    prev = i\n                    balls += 1\n                    if balls >= m:\n                        return True\n            return False\n        lo, hi = 0, positions[-1] - positions[0]\n        while lo < hi:\n            mi = lo + (hi - lo + 1) // 2\n            if f(mi):\n                lo = mi\n            else:\n                hi = mi - 1\n        return lo\n        \n                    \n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:        \n        ''' DP causing timeout \n        def get_max_force(pos, count):\n            \n            #print(f\\\"get_max_force pos_index {pos} posistion {position[pos]} count {count}\\\")\n            if count <=1 :\n                return float('inf')\n            \n            if dp[pos][count-1] > -1: \n                #print(\\\"saved time\\\")\n                return dp[pos][count-1] \n            \n            if n - pos == count:\n                min_force = float('inf')\n                for pos_index in range(pos+1, n):\n                    min_force = min(min_force, position[pos_index]-position[pos_index-1])\n                #print(f\\\"dp 3 pos_index {pos} position {position[pos]} count{count} : {dp[pos][count-1]}\\\")  \n                dp[pos][count-1] = min_force\n                return min_force\n                        \n            if count == 2:\n                dp[pos][count-1] = position[-1] - position[pos]\n                #print(f\\\"dp 2 pos_index {pos} position {position[pos]} position[-1] {position[-1]} count{count} : {dp[pos][count-1]}\\\")\n                return dp[pos][count-1]\n            \n            max_force = 0\n            \n            for pos_index in range(pos+1, n):\n                if n - pos_index < count - 1:\n                    break\n                max_force = max(max_force, min(position[pos_index]-position[pos], get_max_force(pos_index, count-1)))\n            \n            dp[pos][count-1] = max_force\n            #print(f\\\"dp 1 pos_index {pos} position {position[pos]} count{count} : {max_force}\\\")\n            return max_force\n        \n        n = len(position)\n        position.sort()\n        dp = [[-1] * m for _ in position]\n        if m == n:\n            return get_max_force(0, m)            \n        \n        if m == 2:\n            return position[-1] - position[0]\n        \n\n        max_force = 0       \n        for pos_index in range(0, n):\n            max_force = max(max_force, get_max_force(pos_index, m))\n        \n        return max_force\n        '''\n        n = len(position)\n        position.sort()\n        def calc(d):#return number of balls while maintaining distance d\n            #print(f\\\"calc {d}\\\")\n            curr = position[0]\n            ans = 1\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    index = i\n                    curr = position[i]\n                    ans += 1\n            #print(f\\\"return {ans}\\\")\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        #d = r\n        d = 0\n        while l < r:\n            \n            #mid = (r + l + 1) // 2\n            #print(f\\\"l {l} r{r} d {mid}\\\")\n            mid = l + (r-l) // 2\n            count = calc(mid)\n            if count < m:\n                r = mid\n            else:\n                l = mid + 1\n            \n            \n            ''' \n            if count < m:\n                r = mid - 1\n            elif count >= m:\n                l = mid\n            '''\n        #print(l, r)\n        #print(f\\\"{calc(l)}\\\")\n        #print(f\\\"{calc(l-1)}\\\")\n        if calc(l) == m:\n            return l\n        else:\n            return l - 1\n                \n                \n        \n        \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n= len(position)\n        position.sort()\n        if m==2:\n            return position[-1]- position[0]\n        cache={}\n        def F(x):\n            placed=1\n            prev= position[0]\n            for i in range(1, n):\n                if position[i]- prev>= x:\n                    placed+=1\n                    prev= position[i]\n                if placed== m:\n                    return True\n            return False\n        def get_x():\n            l= 1\n            r= position[n-1]- position[0]\n            while l<=r:\n                mid= (l+r)//2\n                if mid not in cache:\n                    cache[mid]= F(mid)\n                c= cache[mid]\n                if c:\n                    l= mid+1\n                    ans= mid\n                else:\n                    r=mid-1\n            return ans\n        return (get_x())\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def canPlace(force):\n            balls = 1\n            curr_dist = curr_i = 0\n            for i in range(1, len(position)):\n                curr_dist = position[i] - position[curr_i]\n                if curr_dist >= force:\n                    curr_i = i\n                    curr_dist = 0\n                    balls += 1\n            return balls\n        position.sort()\n        left, right = 0, position[-1] - position[0]\n        while left < right:\n            mid = (left + right + 1) // 2\n            if canPlace(mid) < m:\n                right = mid - 1\n            else:\n                left = mid\n        return left", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        diff = position[-1] - position[0]\n        right = diff // (m - 1)\n        left = 1\n        \n        def condition(num):\n            k = m - 1\n            prev = position[0]\n            for n in position[1:]:\n                if n - prev >= num:\n                    k -= 1\n                    prev = n\n                if k == 0:\n                    return True\n            return False\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            # print(mid, condition(mid))\n            if condition(mid):\n                left = mid + 1\n            else:\n                right = mid\n        if condition(left):\n            return left\n        else:\n            return left - 1\n        # print(left)\n        return left", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # dp \u4e00\u5b9a\u8d85\u65f6\n        #minimax\u7684\u9898\u76ee\uff0c\u57fa\u672c\u4e0a\u90fd\u662fbinary search + greedy helper function\n        # \u7528count(d)\u8868\u793a\uff1a\u5f53\u6700\u5c0f\u7684\u8ddd\u79bb\u662fd\u65f6\uff0c\u6700\u591a\u80fd\u591f\u653e\u7684\u7403\u7684\u4e2a\u6570\uff0c\u76ee\u6807\u5c31\u662f\u53bb\u627ecount(d)==m\u65f6\uff0c\u6700\u5927\u7684d\n        # \u7528\u4e8c\u5206\u601d\u60f3:\n        # \u5f53count(d)<m\u65f6\uff0c\u8bf4\u660ed\u592a\u5927\u4e86\uff0c\u6709\u7684\u7403\u653e\u4e0d\u4e0b\n        # \u5f53count(d)>m\u65f6\uff0c\u8bf4\u660ed\u592a\u5c0f\u4e86\uff0c\u8fd8\u6709\u66f4\u591a\u7684\u7403\u80fd\u653e\n        \n        position.sort()\n        \n        l = 1\n        r = position[-1] - position[0]\n        while l < r:\n            mid = r - (r-l)//2\n            if self.helper(mid, position) >= m:\n                l = mid\n            else:\n                r = mid-1\n        \n        return l\n    \n    \n    def helper(self, d, position):\n        res = 1\n        cur = position[0]\n        for i in range(1, len(position)):\n            if position[i] - cur >= d:\n                cur = position[i]\n                res += 1\n        return res\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        if m == 2: return position[-1] - position[0]\n        l, r = 1, position[-1]\n        ans = 0\n        while l < r:\n            mid = (l + r) // 2\n            prev, balls = -1000000000, 0\n            for p in position:\n                if p - prev >= mid:\n                    balls += 1\n                    if balls == m: break\n                    prev = p\n            if balls == m:\n                ans = mid\n                l = mid + 1\n            else:\n                r = mid\n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def count(d):\n            res, prev=1, 0\n            for i in range(1, n):\n                if position[i]-position[prev]>=d:\n                    prev=i\n                    res+=1\n            return res\n        \n        n=len(position)\n        position.sort()\n        l, r=1, position[-1]-position[0]\n        while l<r:\n            mid=(l+r)//2+1\n            if count(mid)<m: r=mid-1\n            else: l=mid\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position = sorted(position)\n        low, high = 1, position[-1]\n        ans = 0\n        while low <= high:\n            mid = low + (high - low) // 2\n            prev = position[0]\n            cnt = 1\n            for pos in position[1:]:\n                if (pos - prev) >= mid:\n                    cnt += 1\n                    prev = pos\n            if cnt >= m:\n                ans = max(ans, mid)\n                low = mid + 1\n            else:\n                high = mid - 1\n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n#         1 2 3 4 5 6 7\n#         | | | |     |\n#         b     b     b\n#         forces: 3, 3, 6\n#         results = 3\n        \n#         1 2 3 4 5 ...... 100000000  m = 2\n#         | | | | |            |\n#         b                    b\n#         result = 100000000 - 1\n        \n#         1 2 3 4 5 ...... 100    m = 3\n#         | | | | |         |\n#         b                 b\n#               mid =  50\n# distance = 0 1 2 3 4 99\n#\n#                mid = 25\n# distance = 0 1 2 3 4 99 \n#                mid = 11\n# distance = 0 1 2 3 4 99 \n#                mid = 5\n# distance = 0 1 2 3 4 99 \n#                mid = 4\n# distance = 0 1 2 3 4 99\n\n#         1 2 3 4 5 ...... 100    m = 4\n#         | | | | |         |\n#         b                 b\n#               mid =  50\n# distance = 0 1 2 3 4 99\n#\n#                mid = 25\n# distance = 0 1 2 3 4 99 \n#                mid = 12\n# distance = 0 1 2 3 4 99 \n#                mid = 6\n# distance = 0 1 2 3 4 99 \n#                mid = 3\n# distance = 1 2 3 1 96\n# mid = 1\n# mid = 2\n\n\n        def find_distance(mid_pos):\n        \n            count = 1\n            pre = position[0]\n            for i in range(1, len(position)):\n                distance = position[i] - pre\n                if distance >= mid_pos:\n                    count += 1\n                    pre = position[i]\n            return count\n        \n        position = sorted(position)\n        lo = 0\n        hi = position[-1]\n        while lo <= hi:\n            mid = lo + (hi-lo)//2\n            if find_distance(mid) >= m:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n            \n        return hi\n       \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # \u5c0f\u5fc3\u5730\u4f7f\u7528\u66b4\u529b\u6cd5\u6c42\u89e3: \u53ef\u4ee5\u5c1d\u8bd5\u6240\u6709\u53ef\u80fd\u7684\u95f4\u8ddd, \u627e\u5230\u6700\u5927\u7684\u503c\n        # \u4e24\u4e2a\u89c2\u5bdf:\n        # 1. \u8981\u8fbe\u5230\u6700\u4f18\u89e3\u7b2c\u4e00\u4e2a\u7403\u4e00\u5b9a\u653e\u5728\u7b2c\u4e00\u4e2a\u7bee\u5b50\u91cc\n        # 2. \u5982\u679c\u6700\u5c0f\u95f4\u8ddd\u4e3ax\u65f6\u65e0\u6cd5\u6446\u4e0b\u6240\u6709\u7403, \u90a3\u4e48\u6bd4x\u5927\u7684\u95f4\u8ddd(x+1, x+2...)\u4e5f\u4e0d\u53ef\u80fd\u6446\u4e0b\u6240\u6709\u7403\n        # \u4f7f\u7528\u4e8c\u5206\u67e5\u627e, \u641c\u7d22\u80fd\u6446\u4e0b\u6240\u6709\u7403\u7684\u95f4\u8ddd\n        # \u9700\u8981\u786e\u5b9a: \u4e8c\u5206\u67e5\u627e\u7684\u8303\u56f4, \u8981\u6ee1\u8db3\u7684\u6761\u4ef6\u662f\u5565\n        # \u4e8c\u5206\u67e5\u627e\u6a21\u677f->cond(k)\u6210\u7acb\u7684\u60c5\u51b5\u4e0b\u6700\u5927\u5316k\n        position.sort()\n        lo = 1\n        # \u663e\u7136\u6700\u5927\u95f4\u8ddd\u4e0d\u4f1a\u8d85\u8fc7\u8fd9\u4e2a\u503c\n        hi = position[-1] - position[0]\n        while lo < hi:\n            # \u5f80\u53f3\u504f\u79fb\u7684mid(corner case: lo=3, hi=4)\n            mid = (lo + hi + 1) // 2\n            if self.check(position, mid, m):\n                lo = mid\n            else:\n                # mid\u4e0d\u80fd\u6ee1\u8db3\u6761\u4ef6\n                hi = mid - 1\n        # \u5f53\u9000\u51fa\u5faa\u73af\u65f6hi\u662f\u6ee1\u8db3\u6761\u4ef6\u7684\u6700\u5927\u503c\n        return hi\n\n    # \u68c0\u67e5\u6700\u5c0f\u95f4\u8ddd\u4e3ax\u65f6\u662f\u5426\u80fd\u653e\u4e0b\u6240\u6709\u7684\u7403\n    def check(self, pos, x, m):\n        remain_ball = m - 1 # \u7b2c\u4e00\u4e2a\u7403\u5c31\u653e\u5728\u7b2c\u4e00\u4e2a\u7bee\u5b50\u91cc\u4e86\n        n = len(pos)\n        prev = 0\n        for i in range(1, n):\n            if pos[i] - pos[prev] >= x:\n                remain_ball -= 1\n                prev = i\n                if remain_ball == 0:\n                    return True\n            else:\n                continue\n        return False\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        N = len(position)\n        A = sorted(position)\n        max_gap = A[-1] - A[0]\n        min_gap = min(A[i] - A[i-1] for i in range(1, N))\n        if m == 2:\n            return max_gap\n        if m == N:\n            return min_gap\n        \n        def check(min_dist):\n            prev = A[0]\n            left = m - 1\n            for i in range(1, N):\n                if A[i] - prev >= mid:\n                    prev = A[i]\n                    left -= 1\n                    if left == 0:\n                        return True\n            return False\n\n        lo, hi = min_gap, max_gap\n        while lo < hi:\n            mid = (lo + hi + 1) // 2\n            c = check(mid)\n            if c:\n                lo = mid\n            else:\n                hi = mid - 1\n        return lo\n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, int(math.ceil((position[-1] - position[0])/(m-1)))\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position, m):\n        position.sort()\n        N = len(position)\n        l = math.inf\n        for i in range(1, N):\n            l = min(l, position[i] - position[i-1])\n        r = position[-1] - position[0] + 1\n        def check(k):\n            last = position[0]\n            res = 0\n            for i in range(1, N):\n                if position[i] - last >= k:\n                    res += 1\n                    last = position[i]\n            return res\n            \n        \n        while l < r:\n            k = (l + r) // 2\n            if check(k) <= m - 2:\n                r = k\n            else:\n                l = k + 1\n        return r - 1", "class Solution:\n    def maxDistance(self, arr: List[int], m: int) -> int:\n        arr = sorted(arr)\n        small = sys.maxsize\n        for a, b in zip(arr, arr[1:]):\n            small = min(small, b-a)\n        def count(d):\n            cur = arr[0]\n            res = 1\n            for i in range(1, len(arr)):\n                if arr[i] - cur >= d:\n                    res += 1\n                    cur = arr[i]\n            return res >= m\n        \n        def bs(l, r):\n            if l > r: return 0\n            mid = l + (r-l)//2\n            if count(mid):\n                return bs(mid+1, r) or mid\n            else:\n                return bs(l, mid-1)\n                        \n        return bs(small, arr[-1]-arr[0])\n        \n                    \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()        \n        w = (position[-1] - position[0]) // (m-1)\n        \n        def count(w, m):\n            idx = 0\n            m -= 1\n            for i in range(1, len(position)):\n                if position[i] - position[idx] >= w:\n                    idx = i\n                    m -= 1\n                \n                if m == 0:\n                    break\n                    \n            return m == 0\n\n\n        if count(w, m):\n            return w\n        else:    \n            l ,r = 0, w\n            while l < r:\n                mid = r - (r - l) // 2\n                if count(mid, m):\n                    l = mid\n                else:\n                    r = mid - 1\n                \n            return l\n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def possible(force):\n            prev = float('-inf')\n            balls_placed = 0\n            for x in position:\n                if x-prev >= force:  # then that means we have that required force and we can keep a new ball here at position x\n                    prev= x\n                    balls_placed+=1  \n                \n            return(balls_placed>=m)\n        \n        lo,hi = 0, max(position)\n        while lo<hi:\n            mid = (lo+hi+1)//2\n            if possible(mid):\n                lo=mid\n                \n            else:\n                hi=mid-1\n                \n        return(lo)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check(position, m, target):\n            ct = 1\n            j = 0\n            k = 1\n            flag = False\n            while k < len(position) and ct < m:\n                if position[k] -position[j] >= target:\n                    ct += 1\n                    if not flag:\n                        kk = k\n                        flag = True\n                    j = k\n                k += 1\n            return (ct==m), kk\n        \n        position = sorted(position)\n        max_p = position[-1]\n        i = position[0]\n        if m == 2:\n            return max_p - i\n        else:\n            target = (max_p-i)//(m-1)\n            ct = 1\n            b, kk = check(position, m, target)\n            if not b:\n                while not b and kk!=1:\n                    target = position[kk] - i \n                    target2 = position[kk-1] - i\n                    b, kk = check(position, m, target2)\n                if not b:\n                    left = 1\n                else:\n                    left = position[kk] - i\n                right = target\n                while left + 1 < right:\n                    target = (left + right)//2\n                    if check(position, m, target)[0]:\n                        left = target\n                    else:\n                        right = target\n                target = left\n            \n            return target\n", "class Solution:\n    def put(self, position, d, m):\n        n = 1\n        curr = position[0]\n        for i in range(1, len(position)):\n            if position[i] - curr >= d:\n                n += 1\n                curr = position[i]\n            if n >= m:\n                return 1\n        return 0\n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        low, high = 0, position[-1]\n        \n        while low < high:\n            mid = (high + low + 1) // 2\n            comp = self.put(position, mid, m)\n            \n            if comp > 0:\n                low = mid\n            else:\n                high = mid - 1\n        return low", "class Solution:\n    def fit_balls(self, positions, n, min_dist):\n        if n == 0:\n            return True\n        \n        if len(positions) < 1:\n            return False\n        \n        last_position = positions[0]\n        placement_count = 1\n        \n        for p in positions:\n            if p - last_position >= min_dist:\n                last_position = p\n                placement_count += 1\n                \n        return n <= placement_count\n        \n    def maxDistance(self, position: List[int], m: int) -> int:\n        pos = sorted(position)\n        \n        lo = 0\n        hi = pos[-1]-pos[0]\n        \n        while lo < hi:\n            mid = hi - (hi-lo) // 2\n            can_fit = self.fit_balls(pos, m, mid)\n            \n            if not can_fit:\n                hi = mid-1\n            else:\n                lo = mid\n                \n        \n        return lo\n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r = 0, position[-1]\n        while l + 1 < r:\n            mid = (l + r) // 2\n            if self.is_ok(position, mid, m):\n                l = mid\n            else:\n                r = mid\n        if self.is_ok(position, r, m):\n            return r\n        return l\n    \n    def is_ok(self, position, target, m):\n        count = 1\n        prev = position[0]\n        for i in range(1, len(position)):\n            diff = position[i] - prev\n            if diff >= target:\n                count += 1\n                prev = position[i]\n                \n        return count >= m", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def helper(dist):\n            count = 1\n            prev = position[0]\n            for i in range(1, len(position)):\n                if position[i] - prev >= dist:\n                    prev = position[i]\n                    count += 1\n            return count\n                \n        low = 1\n        high = position[-1] - position[0]\n        res = float('-inf')\n        while low <= high:\n            mid = low + (high - low) // 2\n            if helper(mid) < m:\n                high = mid - 1\n            else:\n                res = max(res, mid)\n                low = mid + 1\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        res = 0\n        \n        def feasible(distance):\n            balls, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i]-curr >= distance+1:### +1 to account for buckets\n                    balls += 1\n                    curr = position[i]                    \n            return balls >= m\n                           \n        left, right = 0, position[-1]-position[0]\n        while left<right:\n            mid = left + (right-left)//2\n            if feasible(mid):\n                left = mid+1\n            else:\n                right = mid\n        return left\n        # return right\n\n        \n        \n#         n = len(position)\n#         position.sort()\n        \n#         def count(d):\n#             ans, curr = 1, position[0]\n#             for i in range(1, n):\n#                 if position[i] - curr >= d:\n#                     ans += 1\n#                     curr = position[i]\n#             return ans >= m\n        \n#         l, r = 0, position[-1] - position[0]\n#         while l < r:\n#             mid = r - (r - l) // 2   ###speed_up\n#             # mid = l + (r-l)//2  ###TLE\n#             if count(mid):\n#                 l = mid\n#             else:\n#                 r = mid - 1\n#         return l\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # Sort the array and evenly distribute the m balls\n        position.sort()\n        ans = top = (position[-1] - position[0]) // (m-1)\n        down = 0\n        while ans != down:\n            if self._test(position, ans, m-1): down = ans\n            else: top = ans\n            ans = (top + down) // 2\n            #print(ans, top, down)\n        return down\n        \n    def _test(self, position, force, m):\n        i = 0\n        while i < len(position) and m > 0:\n            if len(position) - 1 - i < m:\n                return False\n            total = 0\n            while total < force:\n                i += 1\n                if i >= len(position): break\n                total += position[i] - position[i-1]\n            if total >= force: m -= 1\n            #print(i, total, force, m)\n        if m == 0: return True\n        return False\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        def check(d):\n            i, b = 0, 1\n            for j in range(1, n):\n                if position[j]-position[i] >= d:\n                    b += 1\n                    i = j\n            return b >= m\n        \n        position = sorted(position)\n        lo, hi = 1, position[-1]\n        while lo < hi:\n            mid = (lo+hi)//2\n            if check(mid):\n                lo = mid+1\n            else:\n                hi = mid\n        return lo-1\n", "class Solution:\n    \n    def nnpossible(self, pos, k, m) -> bool:\n        prev = pos[0]\n        k -= 1\n        for i in pos:\n            if i - prev >= m:\n                k -= 1\n                prev = i\n            if k == 0:\n                break\n        return k == 0\n    \n    def maxDistance(self, position: List[int], k: int) -> int:\n        position.sort()\n        l = 0\n        r = position[-1] + 1\n        \n        while r - l > 1:\n            m = (l + r) // 2\n            if self.nnpossible(position, k, m):\n                l = m\n            else:\n                r = m\n        return l\n        \n    \n    \n# TTTFFF\n", "import numpy as np\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # Choose m values from n such that the minimum of the differences is maximized\n        position.sort()\n        \n        def check(check_val):\n            temp_m = m-1\n            \n            previous_pos = position[0]\n            \n            for p in position[1:]:\n                if p - previous_pos >= check_val:\n                    previous_pos = p\n                    temp_m -= 1\n                    if temp_m == 0:\n                        return True\n            return False\n        \n        l = 0   # min return value\n        r = (position[-1] - position[0])//(m-1)+1 # max return value\n        \n        ret = l\n        while l <= r:\n            val = (l+r)//2\n            if check(val):\n                ret = max(ret, val)\n                l = val + 1\n            else:\n                r = val-1\n        return ret\n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        def check(d):\n            i, b = 0, 1\n            for j in range(1, n):\n                if position[j]-position[i] >= d:\n                    b += 1\n                    i = j\n                    if b >= m:\n                        return True\n            return False\n        \n        position = sorted(position)\n        lo, hi = 1, position[-1]\n        while lo < hi:\n            mid = (lo+hi)//2\n            if check(mid):\n                lo = mid+1\n            else:\n                hi = mid\n        return lo-1\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def possible(force):\n            prev = float('-inf')\n            balls_placed = 0\n            for x in position:\n                if x-prev >= force:  # then that means we have that required force and we can keep a new ball here at position x\n                    prev= x\n                    balls_placed+=1  \n                if balls_placed ==m:\n                    return(True)\n                \n            return(False)\n        \n        lo,hi = 0, max(position)\n        while lo<hi:\n            mid = (lo+hi+1)//2\n            if possible(mid):\n                lo=mid\n                \n            else:\n                hi=mid-1\n                \n        return(lo)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        def canFindGaps(d):\n            left = 0\n            found = i = 1\n            while i < len(position) and found < m:\n                if position[i] - position[left] >= d:\n                    found += 1\n                    left = i\n                i += 1\n            return found == m\n                \n        \n        position.sort()\n        max_diff = position[-1] - position[0]\n        if m == 2: return max_diff\n        \n        left, right = 1, max_diff//(m-1)\n        while left < right:\n            mid = (left+right)//2\n            if canFindGaps(mid):\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        if right < left:\n            return right\n        return left if canFindGaps(left) else left-1\n        \n            \n        \n", "class Solution:\n    def maxDistance(self, positions: List[int], m: int) -> int:\n        \n        positions.sort()\n        \n        \n        def possible(positions,m,v):\n            \n            cur=0\n            for i in range(1,len(positions)):\n                \n                if positions[i]-positions[cur]>=v:\n                    m-=1\n                    cur=i\n                    if m==1: return True\n            \n            return m<=1\n             \n        left,right=1,positions[-1]-positions[0]\n        \n        ans=0\n        while left<=right:\n            \n            v=(left+right)//2\n            if possible(positions,m,v):\n                ans=v\n                left=v+1\n            else:\n                right=v-1\n        \n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def isPossible(lst, m, force):\n            pos = lst[0]\n            for i in range(1, len(lst)):\n                if lst[i] - pos >= force:\n                    m -= 1\n                    pos = lst[i]\n            return m<2\n        \n        l = 0\n        r = 1000000000\n        position.sort()\n        \n        while l<r:\n            mid = ((l+r) >> 1) + 1\n            if isPossible(position,m,mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        '''\n        binary search\n        similar to 278. First Bad Version\n        '''\n        n = len(position)\n        position.sort()\n        \n        def isfail(mid):\n            ans = 1\n            curr = position[0] # alike greedy idea, we just put the first ball at position 0!\n            for i in range(1, n):\n                if position[i] - curr >= mid:\n                    ans += 1\n                    curr = position[i]\n            return ans < m\n        \n        res = float('-inf')\n        left = 1\n        right = position[-1] - position[0]\n        \n        while left <= right:\n            mid = (left+right)//2\n            if isfail(mid):\n                right = mid-1\n            else:\n                left = mid + 1\n                res = max(res,mid)\n        return res ", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        mx = position[-1]\n        lo, hi = 1, mx\n\n        def judge(x):\n            pre, cnt = -mx, 0\n            for p in position:\n                if p - pre >= x:\n                    pre = p\n                    cnt += 1\n                if cnt >= m:\n                    return True\n            return False\n\n        while lo <= hi:\n            mid = (lo+hi)//2\n            if judge(mid):\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return hi", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r = 1, position[-1]-position[0] + 1\n        while l != r:\n            mid = (l+r)//2 + (l+r)%2\n            x = self.balls(position, mid)\n            if x < m:\n                r = mid-1\n            elif x >= m:\n                l = mid\n        return l\n        \n    \n    \n    def balls(self, position, d):\n        ans = 1\n        cur = position[0]\n        for i in range(1, len(position)):\n            if position[i] - cur >= d:\n                cur = position[i]\n                ans += 1\n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        ###weirdly not working :(\n        n = len(position)\n        position.sort()\n        res = 0\n        \n        def feasible(distance):\n            balls, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i]-curr >= distance+1:\n                    balls += 1\n                    curr = position[i]                    \n            return balls >= m\n                           \n        left, right = 0, position[-1]-position[0]\n        while left<right:\n            mid = left + (right-left)//2\n            if feasible(mid):\n                left = mid+1\n            else:\n                right = mid\n        return left\n\n#         n = len(position)\n#         position.sort()\n        \n#         def count(d):\n#             ans, curr = 1, position[0]\n#             for i in range(1, n):\n#                 if position[i] - curr >= d:\n#                     ans += 1\n#                     curr = position[i]\n#             return ans >= m\n        \n#         l, r = 0, position[-1] - position[0]\n#         while l < r:\n#             mid = r - (r - l) // 2   ###speed_up\n#             # mid = l + (r-l)//2  ###TLE\n#             if count(mid):\n#                 l = mid\n#             else:\n#                 r = mid - 1\n#         return l\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # binary search and check easy \n        # this function will check if all the balls can be placed at a distance of m or not. Then we just binary search all the \n        # distances. O(nlogn)\n        position.sort()\n        def check(mid):\n            curr = position[0]\n            placed = 1\n            for i in range(len(position)):\n                if position[i] >= curr + mid:\n                    placed += 1\n                    curr = position[i]\n            return placed >= m\n                \n        l, r = 1, 10**9 + 1\n        while l < r:\n            mid = (l+r+1)//2\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n        \n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        if m==2:\n            return max(position)-min(position)\n        position.sort()\n        l,r=1,(max(position)-min(position)+1)//(m-1)\n        #print(l,r)\n        def helper(mindist):\n            #print(mindist)\n            cnt=m-1\n            cur=min(position)\n            for i in position[1:]:\n                if i-cur>=mindist:\n                    cur=i\n                    cnt-=1\n                    if cnt==0:\n                        return True\n            return False\n        if helper(r):\n            return r\n        while l<r:\n            mid=l+(r-l)//2\n            if helper(mid):\n                l=mid+1\n            else:\n                r=mid\n        #if helper(l):\n            #return l\n        #else:\n        return l-1\n", "def check(x,pos,m):\n    c=0\n    prev=-1000000000000000\n    for i in range(len(pos)):\n        if abs(pos[i]-prev)>=x:\n            c+=1\n            prev=pos[i]\n    return c>=m\nclass Solution:\n    def maxDistance(self, pos: List[int], m: int) -> int:\n        pos.sort()\n        n = len(pos)\n        #print(pos)\n        #pos = [-1000000000000000 pos + [10000000000000000]\n        l=1\n        r=pos[-1]\n        while l<=r:\n            mid =  l + (r-l)//2\n            if check(mid,pos,m):\n                l=mid+1\n            else:\n                r=mid-1\n        if check(l,pos,m):\n            return l\n        else:\n            return r\n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        delta = []\n        for i in range(len(position)-1):\n            delta.append(position[i+1]-position[i])\n            \n        lo = min(delta)\n        hi = sum(delta)\n        m -= 1\n        \n        def isPossible(minForce):\n            total = 0\n            count = 0\n            for d in delta:\n                total += d\n                if total >= minForce:\n                    count += 1\n                    total = 0\n                    if count == m:\n                        return True\n            return False\n        \n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if isPossible(mid):\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        \n        return lo-1\n", "# class Solution:\n#     def maxDistance(self, position: List[int], m: int) -> int:\n#         #\u9996\u5148\u6392\u5e8f\n#         position.sort()\n#         print(position)\n        \n#         left = 1000000000\n#         right = position[-1] - position[0]\n#         for i in range(len(position)-1):\n#             diff = abs(position[i] - position[i+1])\n#             left = min(left, diff)\n            \n            \n#         def check(diff, p, m):\n#             m -= 1\n#             last = p[0]\n#             for i in range(1, len(p)):\n#                 if abs(p[i] - last) >= diff:\n#                     m -= 1\n#                     last = p[i]\n#                     if m <= 0:\n#                         print(diff, \\\"True\\\")\n#                         return True\n#                 else:\n#                     pass\n#             print(diff, \\\"False\\\")\n#             return False\n            \n#         print(\\\"left\\\", left, \\\"right\\\", right)\n#         while left < right:\n#             mid = (left + right) // 2\n#             if check(mid, position, m) == True:\n#                 left = mid\n#                 if left == right:\n#                     print(\\\"find 1\\\", left)\n#                     break\n#                 if left + 1 == right:\n#                     if check(right, position, m):\n#                         left = right\n#                         print(\\\"find 2\\\", left)\n#                     break\n#             else:\n#                 right = mid - 1\n        \n                \n#         print(\\\"find 3\\\", left)\n#         return left\n\n# class Solution:\n#     def maxDistance(self, position: List[int], m: int) -> int:\n#         #\u9996\u5148\u6392\u5e8f\n#         position.sort()\n#         # print(position)\n        \n#         distance = [0 for _ in range(len(position)-1)]\n#         for i in range(len(position)-1):\n#             diff = position[i+1] - position[i]\n#             distance[i] = diff\n#         left = min(distance)\n#         right = ceil((position[-1] - position[0]) / (m-1))\n            \n#         def check(diff, m):\n#             m -= 1\n#             pre_dis = 0\n#             for i in range(0, len(distance)):\n#                 if distance[i]+pre_dis >= diff:\n#                     m -= 1\n#                     if m <= 0:\n#                         # print(diff, \\\"True\\\")\n#                         return True\n#                     pre_dis = 0\n#                 else:\n#                     pre_dis += distance[i]\n#             # print(diff, \\\"False\\\")\n#             return False\n            \n#         # print(\\\"left\\\", left, \\\"right\\\", right)\n#         while left < right:\n#             mid = (left + right+1) // 2\n#             if check(mid, m) == True:\n#                 left = mid\n#                 # if left == right:\n#                 #     print(\\\"find 1\\\", left)\n#                 #     break\n#                 # if left + 1 == right:\n#                 #     if check(right, position, m):\n#                 #         left = right\n#                 #         print(\\\"find 2\\\", left)\n#                 #     break\n#             else:\n#                 right = mid - 1\n        \n                \n#         # print(\\\"find 3\\\", left)\n#         return left\n        \nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n\n        result = 0\n\n        # can we place m balls each separated by x distance?\n        def check(x) -> bool:\n            nonlocal position, m\n\n            last = position[0]\n            placed = 1\n            for pos in position:\n                if pos - last >= x:\n                    placed += 1\n                    if placed >= m:\n                        return True\n                    last = pos\n\n            return False\n\n\n\n        first = 0\n        last = int(ceil((position[-1] - position[0])/(m-1)))\n        while first < last:\n\n            mid = (first + last + 1)//2\n\n            if check(mid):\n                result = mid\n                first = mid\n            else:\n                last = mid - 1\n\n        return first", "# 1552. Magnetic Force Between Two Balls\n# Binary search\n\ndef can_distribute (baskets, ball_count, min_dist):\n    last = []\n    for basket in baskets:\n        if not last or last[-1] + min_dist <= basket:\n            last.append (basket)\n            if len (last) == ball_count:\n                return True\n    return False\n\ndef first (a, b, p):\n    if a >= b:\n        return a\n    elif p(a):\n        return a\n    elif not p(b-1):\n        return b\n    else:\n        m = (a + b) // 2\n        if p(m-1):\n            return first (a, m, p)\n        elif not p(m):\n            return first (m, b, p)\n        else:\n            return m\n\ndef last (a, b, p):\n    return first (a, b, lambda x: not p(x)) - 1\n\ndef max_dist (baskets, ball_count):\n    baskets = sorted (baskets)\n    theoretical_max_dist = (baskets[-1] - baskets[0]) // (ball_count - 1)\n    return last (1, theoretical_max_dist + 1, lambda dist: can_distribute (baskets, ball_count, dist))\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        return max_dist(position, m)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        \n        position = sorted(position)\n        res = 0\n            \n        def check(n):\n            count = 0\n            cur = -1\n            for i in range(len(position)):\n                if cur < 0:\n                    cur = position[i]\n                    continue\n                if position[i]- cur >= n:\n                    cur = position[i]\n                    count+=1\n            return count+1\n                \n        l, r = 0, position[-1]- position[0]\n        \n        while l <= r:\n            mid = (l+r)//2\n            \n            if check(mid) >= m:\n                res = max(mid, res)\n                l= mid+1\n                \n            else:\n                r = mid-1\n                \n        return res\n", "class Solution:\n  def maxDistance(self, position: List[int], m: int) -> int:\n    position.sort()\n    def getCount(d: int) -> int:\n      last, count = position[0], 1\n      for x in position:\n        if x - last >= d:\n          last = x\n          count += 1\n      return count\n    l, r = 0, position[-1] - position[0] + 1\n    t = r\n    while l < r:\n      mid = l + (r - l) // 2\n      if getCount(t - mid) >= m:\n        r = mid\n      else:\n        l = mid + 1\n    return t - l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        pos = sorted(position)\n        l = 0\n        r = pos[-1] - pos[0]\n        while l < r:\n            mid = (l + r + 1) // 2\n\n            cum = pos[0]\n            putted = 1\n            for p in pos:\n                if p >= cum + mid:\n                    cum = p\n                    putted += 1\n            if putted >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l ", "class Solution:\n   def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        high = position[-1] - position[0]\n        if m == 2:\n            return high\n        low = high\n        for i in range(1, len(position)):\n            low = min(position[i] - position[i - 1], low)\n        if m == len(position):\n            return low\n\n        def count(step):\n            c = 1\n            pivot = 0\n            for i in range(1, len(position)):\n                if step <= (position[i] - position[pivot]):\n                    c += 1\n                    pivot = i\n            return c\n        res = None\n        while low <= high:\n            mid = low + (high - low) // 2\n            num = count(mid)\n            if num >= m:\n                res = mid\n                low = mid+1\n            if num < m:\n                high = mid-1\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r = 1, position[-1] - position[0]\n        while l < r:\n            mid = (l + r) // 2\n            if self.check(position, mid, m):\n                l = mid + 1\n            else:\n                r = mid\n        return l if self.check(position, l, m) else l-1\n    \n    def check(self, position, k, m):\n        last_placed_position = None\n        for i,p in enumerate(position):\n            if i == 0 or p-last_placed_position >= k:\n                m -= 1\n                if m == 0:\n                    return True\n                last_placed_position = p\n        return False\n", "class Solution:\n    def is_valid(self, arr, force, m):\n        cnt = 1\n        prev = arr[0]\n        \n        for i in range(1, len(arr)):\n            if arr[i] - prev >= force:\n                cnt += 1\n                prev = arr[i]\n            \n            if cnt == m:\n                return True\n            \n        return False\n            \n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        res = -1\n        \n        position.sort()\n        \n        left = 1\n        right = position[len(position) - 1]\n        \n        while left + 1 < right:\n            mid = (right - left) // 2 + left\n            \n            if (self.is_valid(position, mid, m)):\n                # Too small\n                left = mid\n                res = max(res, mid)\n            else:\n                # Too big\n                right = mid\n                \n        for i in range(left, right + 1):\n            if self.is_valid(position, i, m):\n                res = max(res, i)\n            \n        return res\n            \n                \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        def small_enough(mid):\n            count = prev = 0\n            for i, p in enumerate(position):\n                if i == 0:\n                    count += 1\n                elif p - prev >= mid:\n                    count += 1\n                else:\n                    continue\n                prev = p\n            return count >= m\n        \n        l, h = 1, position[-1] - position[0]\n        while l < h:\n            mid = (l + h + 1) // 2\n            if small_enough(mid):\n                l = mid\n            else:\n                h = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def possible(force):\n            prev = float('-inf')\n            balls_placed = 0\n            for x in position:\n                if x-prev >= force:  \n                    prev= x\n                    balls_placed+=1  \n                \n            return(balls_placed>=m)\n        \n        lo,hi = 0, max(position)\n        while lo<hi:\n            mid = (lo+hi+1)//2\n            if possible(mid):\n                lo=mid\n                \n            else:\n                hi=mid-1\n                \n        return(lo)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        posSorted = position\n        low = 1\n        high = posSorted[-1]\n        mid = (low+high)//2\n\n        while low < high:\n            if self.validForce(posSorted, m, mid):\n               low = mid\n            else:\n                high = mid-1\n\n            mid = high-(high-low)//2\n        \n        return low \n\n    def validForce(self, positions, m, mid):\n        used = 0\n        lastpos = 0\n        for i, pos in enumerate(positions):\n            if i == 0:\n                used += 1\n                continue\n            if (pos - positions[lastpos]) >= mid:\n                lastpos = i  \n                used += 1\n        if used >= m:\n            return True\n\n        return False", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        if m == 2:\n            return position[-1] - position[0]\n        \n        def checkPossible(ans0):\n            preV = position[0]\n            leftM = m - 1\n            for num in position[1:]:\n                if num - preV >= ans0:\n                    leftM -= 1\n                    preV = num\n                    if leftM == 0:\n                        return True\n            return False\n        \n        l = 0\n        r = position[-1]\n        ans = position[1]-position[0]\n        while r > l:\n            mid = (r+l)//2\n            # print(l, r, mid)\n            if checkPossible(mid):\n                ans = mid\n                l = mid + 1\n            else:\n                r = mid\n        return ans\n        \n#         dp = {}\n#         minDelta = [position[i]-position[i-1] for i in range(1, n)]\n#         # print(position)\n#         # print(minDelta)\n#         for i in range(n-3, -1, -1):\n#             if minDelta[i] > minDelta[i+1]:\n#                 minDelta[i] = minDelta[i+1]\n        \n#         def placeABall(preI, m0):\n#             if (preI, m0) in dp:\n#                 return dp[(preI, m0)]\n#             if m0 == 1:\n#                 return position[-1] - position[preI]\n#             if n-preI-1 == m0:\n#                 subAns = minDelta[preI]\n#                 dp[(preI, m0)] = subAns\n#                 return subAns\n#             subAns = 0\n            \n#             l = preI+1\n#             r = n-m0\n#             if position[l] - position[preI] >= placeABall(l, m0-1):\n#                 subAns = placeABall(l, m0-1)\n#             elif position[r] - position[preI] <= placeABall(r, m0-1):\n#                 subAns = position[r] - position[preI]\n#             else:\n#                 while l < r:\n#                     m = (l+r)//2\n#                     temp = placeABall(m, m0-1)\n#                     if position[m] - position[preI] < temp:\n#                         l = m + 1\n#                     elif position[m] - position[preI] > temp:\n#                         r = m\n#                     else:\n#                         l = m\n#                         break\n#                 subAns = (min(position[l] - position[preI], temp))\n#                 if l + 1 <= n-m0:\n#                     subAns = max(subAns, (min(position[l+1] - position[preI], placeABall(l+1, m0-1))))\n#                 if l - 1 >= preI + 1:\n#                     subAns = max(subAns, (min(position[l-1] - position[preI], placeABall(l-1, m0-1))))\n                    \n#             # for i1 in range(preI+1, n-m0+1):\n#             #     subAns = max(subAns, min(position[i1] - position[preI], placeABall(i1, m0-1)))\n#             dp[(preI, m0)] = subAns\n#             return subAns\n        \n#         return placeABall(0, m-1)\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        hi = position[-1] - position[0] + 1\n        lo = 0\n        \n        def x(target):\n            currMin = position[0] \n            count = 1\n            \n            for pos in position:\n                if pos - currMin >= target:\n                    currMin = pos\n                    count += 1\n                if count >= m:\n                    return False\n            return True\n                    \n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if x(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo - 1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def distributable(n):\n            pos = len(position) - 1\n            balls = m\n            while pos >= 0 and balls:\n                balls -= 1\n                np = position[pos] - n\n                while pos >= 0 and position[pos] > np:\n                    pos -= 1\n            return not balls       \n        position = sorted(position)\n        lo, hi = 1, (position[-1] - position[0]) // (m -1) + 1\n        ans = lo\n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if distributable(mid):\n                ans = mid\n                lo = mid + 1\n            else:\n                hi = mid\n        return ans        ", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        \n        l = 1\n        r = position[-1] - position[0]\n        \n        def check(diff, m):\n            ctr = 1\n            prev = 0\n            \n            for i in range(1, len(position)):\n                if ctr==m:\n                    return True\n                if position[i]-position[prev]>=diff:\n                    ctr+=1\n                    prev = i\n                    \n            if ctr==m:\n                return True\n            return False\n        \n        val = -10**10\n        \n        while l<=r:\n            mid = (l+r)//2\n            \n            if check(mid, m):\n                val = max(val, mid)\n                l = mid+1\n            else:\n                r = mid-1\n                \n        return val", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n=len(position)\n        position.sort()\n        \n        def count(d):\n            cur=position[0]\n            ans=1\n            for i in range(1,n):\n                if position[i]-cur>=d:\n                    ans+=1\n                    cur=position[i]\n            return ans\n        l,r=0,position[-1]-position[0]\n        while l<r:\n            mid=r-(r-l)//2\n            if count(mid)>=m:\n                l=mid\n            else:\n                r=mid-1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def distributable(n):\n            pos = len(position) - 1\n            balls = m\n            while pos >= 0 and balls:\n                balls -= 1\n                np = position[pos] - n\n                while pos >= 0 and position[pos] > np:\n                    pos -= 1\n            return not balls       \n        position = sorted(position)\n        lo, hi = 1, (position[-1] - position[0]) // (m -1) + 1\n        ans = lo\n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if distributable(mid):\n                ans = mid\n                lo = mid + 1\n            else:\n                hi = mid\n        return ans   ", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def isOK(x):\n            rest = m - 1\n            pre = position[0]\n            for p in position[1:]:\n                if p - pre >= x:\n                    pre = p\n                    rest -= 1\n                    if rest == 0:\n                        return True\n            return False\n        \n        left = 1\n        right = position[-1] - position[0]\n        while left < right:\n            mid = (left + right + 1) // 2\n            # print(f'{mid=}')\n            # print(f'{isOK(mid)=}')\n            if isOK(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return right\n", "from array import array\nclass Solution:\n   def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        position = array('i', position)\n        high = position[-1] - position[0]\n        low = high\n        for i in range(1, len(position)):\n            low = min(position[i] - position[i - 1], low)\n        def count(step):\n            c = 1\n            pivot = 0\n            for i in range(1, len(position)):\n                if step <= (position[i] - position[pivot]):\n                    c += 1\n                    pivot = i\n            return c\n        res = None\n        while low <= high:\n            mid = low + (high - low) // 2\n            num = count(mid)\n            if num >= m:\n                res = mid\n                low = mid+1\n            if num < m:\n                high = mid-1\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check(arr, n, m, mid): \n            magnet=1\n            pos=arr[0] \n            for i in range(1, n): \n                if arr[i]-pos>=mid: \n                    magnet+=1 \n                    pos=arr[i] \n                    if magnet==m: \n                        return 1\n            return 0\n\n        position.sort() \n        l=0 \n        n=len(position)\n        r=position[n - 1] \n        res=0 \n        \n        while l<=r: \n            mid=(l+r)//2 \n            if not check(position, n, m, mid): \n                r=mid-1\n            else: \n                res=max(res, mid) \n                l=mid + 1\n        return res \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        \n        def count(d):\n            ans = 1\n            pos = position[0]\n            for i in range(1,n):\n                if position[i]-pos>=d:\n                    ans+=1\n                    pos = position[i]\n            return ans\n        \n        l = 0\n        r = position[-1] - position[0]\n        \n        while l<r:\n            mid = (l+r+1)//2\n            \n            if count(mid)>=m: \n                l = mid\n            else:\n                r = mid-1\n        \n        return l        ", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        lo,hi=1,position[-1]-position[0]\n        while lo<hi:\n            mi,t,y=(lo+hi+1)//2,1,position[0]\n            for x in position:\n                if x-y>=mi: y,t=x,t+1\n            if t<m: hi=mi-1\n            else: lo=mi\n        return lo", "class Solution:\n    def maxDistance(self, position, m: int) -> int:\n    # binary search and check easy\n    # this function will check if all the balls can be placed at a distance of m or not. Then we just binary search all the\n    # distances. O(nlogn)\n        position.sort()\n\n        def check(mid):\n            curr = position[0]\n            placed = 1\n            for i in range(len(position)):\n                if position[i] >= curr + mid:\n                    placed += 1\n                    curr = position[i]\n            return placed >= m\n\n        l, r = 1, 10 ** 9 + 1\n        while l < r:\n            mid = (l + r + 1) // 2\n            if check(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n        \n            \n            \n", "class Solution:\n    def maxDistance(self, a: List[int], m: int) -> int:        \n        def check(d):\n            x, k = 0, m            \n            for i in range(len(a)):\n                if a[i] >= x: \n                    x, k = a[i] + d, k - 1\n                    if k == 0: break                             \n            return k == 0            \n        a.sort()                \n        l, r = 1, (max(a) - min(a)) // (m-1)                        \n        while l < r:\n            d =  r - (r - l) // 2        \n            if check(d): l = d\n            else: r = d - 1                            \n        return r if check(r) else l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n=len(position)\n        \n        def posb(t):\n            k=0\n            s=0\n            for i in range(n-1):\n                k+=position[i+1]-position[i]\n                if k>=t:\n                    k=0\n                    s+=1\n            \n            return s>=m-1\n                \n        hgh=position[-1]-position[0]\n        low=0\n        while low<hgh:\n            mid=hgh-(hgh-low)//2\n            \n            \n          \n          \n            if posb(mid):\n                low=mid\n          \n            else:\n                hgh=mid-1\n        return low\n       \n            \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # sort balls\n        position.sort()\n        # max number of balls that can preserve a min difference of diff between any two balls\n        def count_balls(diff):\n            nballs, cur = 1, position[0]\n            for i in range(1, len(position)):\n                if position[i] - cur >= diff:\n                    nballs += 1\n                    cur = position[i]\n            return nballs\n        # m can range from 1 to position[-1] - position[0]\n        left, right = 1, position[-1] - position[0]\n        while left <= right:\n            mid = (left + right) // 2\n            if count_balls(mid) >= m:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return right\n", "def count(position,m,n,d):\n    ans,curr=1,position[0]\n    for i in range(1,n):\n        if position[i]-curr>=d:\n            ans+=1\n            curr = position[i]\n            if ans==m:\n                return True\n    return False\n    \nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        l,r = 1,10**9+7\n        res = -1\n        while l<r:\n            mid = (l+r)//2\n            if count(position,m,n,mid):\n                res = max(res,mid)\n                l = mid+1\n            else:\n                r = mid\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        # Counts number of balls that can be placed into baskets if minimum distance is d\n        # Find maximum d where count(d) == m\n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        \n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n                \n        return l", "class Solution:\n    def maxDistance(self, A: List[int], m: int) -> int:\n        A.sort()\n        n = len(A)\n        l, r = 1, A[-1] - A[0]\n        \n        def get_m(d):\n            res = 1\n            i = 1\n            prev = A[0]\n            while i < n:\n                if A[i] - prev >= d:\n                    res += 1\n                    prev = A[i]\n                i += 1\n            return res\n        \n        while l < r:\n            mid = r - (r - l) // 2\n            if get_m(mid) < m:\n                r = mid - 1\n            else:\n                l = mid\n        return l\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        length = len(position)\n        position.sort()\n\n        def count(d):\n            minmax = 1\n            curr = position[0]\n            for i in range(1, length):\n                if position[i] - curr >= d:\n                    minmax += 1\n                    curr = position[i]\n            return minmax\n\n        lo, hi = 0, position[-1] - position[0]\n        while lo < hi:\n            mid = hi - (hi - lo) // 2\n            if count(mid) >= m:\n                lo = mid\n            else:\n                hi = mid - 1\n        return lo", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def ispossible(A,force,n):\n            n-=1\n            last=A[0]\n            for i in range(1,len(A)):\n                if n>0:\n                    if A[i]-last>=force:\n                        n-=1\n                        last=A[i]\n                else:\n                    break\n                    \n            if n==0:\n                return True\n            return False\n                        \n            \n                \n                \n            \n            \n        \n        A=position\n        A.sort()\n        l=1\n        r=A[-1]\n        ans=1\n        while r>=l:\n            mid=(r+l)//2\n            \n            if ispossible(A,mid,m):\n                ans=mid\n                l=mid+1\n            else:\n                r=mid-1\n                \n        return ans\n                \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r = 1, position[-1] - position[0] + 1\n        \n        def isInvalid(val):\n            ball = 1\n            previous = position[0]\n            for p in position:\n                if p - previous < val:\n                    continue\n                ball += 1\n                previous = p\n            return ball < m\n        \n        while l < r:\n            mid = l + (r - l) // 2\n            if isInvalid(mid):\n                r = mid\n            else:\n                l = mid + 1\n                \n        return l - 1", "class Solution:\n    def maxDistance(self, a: List[int], m: int) -> int:        \n        def check(d):\n            x, k = 0, m            \n            for i in range(len(a)):\n                if a[i] >= x: \n                    x, k = a[i] + d, k - 1\n                    if k == 0: break                             \n            return k == 0\n            \n        a.sort()                \n        l, r = 1, (max(a) - min(a)) // (m-1)                        \n        while l+1 < r:\n            d = (l + r) // 2            \n            if check(d): l = d\n            else: r = d - 1                            \n        return r if check(r) else l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        high=position[-1]-position[0]\n        low=1\n        output=[0]\n        k=[m]\n        def check(distance):\n            previous=-1\n            m=k[-1]\n            previous=position[0]\n            m-=1\n            if m==0:\n                return True\n            for i in range(1,len(position)):\n                \n               \n                if position[i]-previous>=distance:\n                    previous=position[i]\n                    m-=1\n                    if m==0:\n                        break\n            if m==0:\n                return True\n            return False\n        \n        def binary(low,high):\n         \n            mid=(low+high)//2\n            \n             \n            if low>high:\n                \n                return\n            if check(mid):\n                \n                \n                output[0]=mid\n               \n                binary(mid+1,high)\n            else:\n                binary(low,mid-1)\n        binary(low,high)\n        return output[-1]", "# class Solution:\n#     def maxDistance(self, position: List[int], m: int) -> int:\n#         #\u9996\u5148\u6392\u5e8f\n#         position.sort()\n#         print(position)\n        \n#         left = 1000000000\n#         right = position[-1] - position[0]\n#         for i in range(len(position)-1):\n#             diff = abs(position[i] - position[i+1])\n#             left = min(left, diff)\n            \n            \n#         def check(diff, p, m):\n#             m -= 1\n#             last = p[0]\n#             for i in range(1, len(p)):\n#                 if abs(p[i] - last) >= diff:\n#                     m -= 1\n#                     last = p[i]\n#                     if m <= 0:\n#                         print(diff, \\\"True\\\")\n#                         return True\n#                 else:\n#                     pass\n#             print(diff, \\\"False\\\")\n#             return False\n            \n#         print(\\\"left\\\", left, \\\"right\\\", right)\n#         while left < right:\n#             mid = (left + right) // 2\n#             if check(mid, position, m) == True:\n#                 left = mid\n#                 if left == right:\n#                     print(\\\"find 1\\\", left)\n#                     break\n#                 if left + 1 == right:\n#                     if check(right, position, m):\n#                         left = right\n#                         print(\\\"find 2\\\", left)\n#                     break\n#             else:\n#                 right = mid - 1\n        \n                \n#         print(\\\"find 3\\\", left)\n#         return left\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        #\u9996\u5148\u6392\u5e8f\n        position.sort()\n        # print(position)\n        \n        distance = [0 for _ in range(len(position)-1)]\n        for i in range(len(position)-1):\n            diff = position[i+1] - position[i]\n            distance[i] = diff\n        left = min(distance)\n        right = position[-1] - position[0]\n            \n        def check(diff, m):\n            m -= 1\n            pre_dis = 0\n            for i in range(0, len(distance)):\n                if distance[i]+pre_dis >= diff:\n                    m -= 1\n                    if m <= 0:\n                        # print(diff, \\\"True\\\")\n                        return True\n                    pre_dis = 0\n                else:\n                    pre_dis += distance[i]\n            # print(diff, \\\"False\\\")\n            return False\n            \n        # print(\\\"left\\\", left, \\\"right\\\", right)\n        while left < right:\n            mid = (left + right+1) // 2\n            if check(mid, m) == True:\n                left = mid\n                # if left == right:\n                #     print(\\\"find 1\\\", left)\n                #     break\n                # if left + 1 == right:\n                #     if check(right, position, m):\n                #         left = right\n                #         print(\\\"find 2\\\", left)\n                #     break\n            else:\n                right = mid - 1\n        \n                \n        # print(\\\"find 3\\\", left)\n        return left\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        if m == 2:\n            return position[-1]-position[0]\n        print(position)\n        left, right = 1, position[-1]-position[0]\n        def valid(mid):\n            count = 1\n            last = position[0]\n            for i in range(1, len(position)):\n                if position[i] - last>=mid:\n                    #print('-',position[i], last)\n                    last = position[i]\n                    count += 1\n            #print(mid, count)\n            return count>=m\n        while left<right:\n            mid = (right-left+1)//2+left\n            #print(mid)\n            if valid(mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left", "class Solution:\n    def maxDistance(self, pos: List[int], m: int) -> int:\n        pos.sort()\n        def check(force, m):\n            last = pos[0]\n            m -= 1\n            for i in range(1, len(pos)):\n                if pos[i] - last >= force:\n                    last = pos[i]\n                    m -= 1\n                if not m: return True\n            return False\n\n        left, right = 2, 10**9\n        while left <= right:\n            mid = left + (right - left) // 2\n            if check(mid, m):\n                left = mid+1\n            else:\n                right = mid-1\n        return right", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        \n        lo = 1\n        hi = position[-1]\n        \n        while (lo < hi):\n            mid = lo + (hi - lo) // 2 + 1\n            \n            if (self.can_be_put(position, m , mid)):\n                lo = mid\n            else:\n                hi = mid - 1\n                \n        return lo\n    \n    def can_be_put(self, position, m, force):\n        next_pos = position[0]\n        \n        for i in range(len(position)):\n            if (next_pos <= position[i]):\n                m -= 1\n                next_pos = position[i] + force\n                \n        return m <= 0", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        \n        def check(force):\n            k = m - 1\n            pre = 0\n            i = 1\n            while i < n:\n                while i < n and position[i] - position[pre] < force:\n                    i += 1\n                if i < n:\n                    k -= 1\n                if k == 0:\n                    return True\n                pre = i\n                i += 1\n            return False\n        lo, hi = 1, position[-1]\n        while lo < hi:\n            mi = lo + (hi - lo) // 2\n            if check(mi):\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo - 1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n\n        n = len(position)\n        \n        # count number of balls that can be put in basket with min_force d\n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans    \n\n        \n        l, r = 1, position[-1] - position[0]\n        while l < r:\n            f = r - (r - l) // 2 # l + (r - l) // 2\n            if count(f) >= m:\n                l = f\n            else:\n                r = f - 1\n        \n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        N = len(position)\n        def place(d):\n            pre = position[0]\n            idx = 1\n            for i in range(m-1):\n                while idx<N:\n                    if position[idx]>=pre+d:\n                        break\n                    else:\n                        idx+=1\n                if idx==N:\n                    return False\n                else:\n                    pre = position[idx]\n                    \n            return True\n        \n        l = 1\n        r = position[-1]-position[0]\n        while l<r:\n            mid = (l+r+1)//2\n            if place(mid):\n                l = mid\n            else:\n                r = mid-1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l = 1\n        r = (position[-1]-position[0])//(m-1)\n        #print(l,r)\n        while (l<=r):\n            mid = (l+r)//2\n            placed = 1\n            distance = 0\n            start = position[0]\n            for i in range(1,len(position)):\n                distance = position[i]-start\n                if distance >= mid:\n                    placed +=1\n                    distance = 0\n                    start = position[i]\n            #print(placed)\n            if placed >=m:\n                answer = mid #we placed all balls\n                l = mid +1\n            else:\n                r = mid -1\n                \n        return(answer)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        high=position[-1]-position[0]\n        low=1\n        output=[0]\n        k=[m]\n        def check(distance):\n            previous=-1\n            \n            m=k[-1]\n            for i in range(len(position)):\n                if m==0:\n                    break\n                if i==0:\n                    previous=position[0]\n                    m-=1\n                    continue\n                if position[i]-previous>=distance:\n                    previous=position[i]\n                    m-=1\n            if m==0:\n                return True\n            return False\n        \n        def binary(low,high):\n         \n            mid=(low+high)//2\n            \n             \n            if low>high:\n                \n                return\n            if check(mid):\n                \n                \n                output[0]=mid\n               \n                binary(mid+1,high)\n            else:\n                binary(low,mid-1)\n        binary(low,high)\n        return output[-1]", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def isPossible(dist):\n            count = 1\n            prev = position[0]\n            for x in position[1:]:\n                if x - prev >= dist:\n                    count += 1\n                    prev = x\n                    if count == m:\n                        return True\n            return False\n        left, right = 0, position[-1]-position[0]\n        while left <= right:\n            mid = left + (right-left)//2\n            if isPossible(mid):\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n    \n        \n", "class Solution:\n    def possible(self, position, dist, m):\n        prev = float('-inf')\n        cnt = 0\n        for x in position:\n            if x < prev + dist:\n                continue\n            cnt += 1\n            prev = x\n        return cnt >= m\n        \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        low, high = 0, max(position)\n        while low + 1 < high:\n            mid = (low + high) // 2\n            if self.possible(position, mid, m):\n                low = mid\n            else:\n                high = mid\n        \n        if self.possible(position, high, m):\n            return high\n        \n        return low\n                \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check(f):\n            nonlocal position\n            nonlocal m\n            nonlocal res\n            for i in range(len(position)):\n                balls_cnt = 1 \n                last_ball_pos = 0\n\n                for i in range(1, len(position)):\n                    last_ball_val_pos = position[last_ball_pos]\n                    curr_ball_val_pos = position[i]\n                    cur_force = curr_ball_val_pos - last_ball_val_pos\n                    if cur_force >= f:\n                        balls_cnt +=1\n                        last_ball_pos = i\n                        if balls_cnt == m:  \n                            res = max(res, f)                      \n                            return True\n\n                return False\n\n\n        res = 0\n        position.sort()\n        left = 1\n        right = position[-1]\n\n        while left < right:\n            mid = left + (right - left) // 2\n            if check(mid):\n                # add to answer, check if can do better increase mid and look up in right part\n                left = mid + 1\n            else:\n                right = mid\n\n        return res   \n      \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        N = len(position)\n        \n        left, right = 0, position[-1] - position[0]\n        \n        while left + 1 < right:\n            mid = int((right - left) / 2 + left)\n            \n            if self.count(mid, position) >= m:\n                left = mid\n            else:\n                right = mid\n        \n        if self.count(right, position) == m:\n            return right\n        return left\n    \n    def count(self, n: int, position: List[int]) -> int:\n        ans, curr = 1, position[0]\n        \n        for i in range(1, len(position)):\n            if position[i] - curr >= n:\n                curr = position[i] \n                ans += 1\n                \n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        def good(d):\n            c, prev = 1, 0\n            for i in range(1,len(position)):\n                if position[i] - position[prev] >= d:\n                    c += 1\n                    prev = i\n                \n                if c == 0:\n                    break\n                    \n            return c\n          \n        position.sort()\n        l, r = 0, position[-1] - position[0]\n        \n        while l <= r:\n            mid = (r + l) // 2\n            \n            if good(mid) >= m:\n                l = mid + 1\n            \n            else:\n                r = mid - 1\n                        \n        return r", "class Solution:\n    def maxDistance(self,position, m) -> int:\n        position.sort()\n        l = 0\n        r = position[-1]-position[0]\n\n        def isValid(dist):\n            used = 1\n            curr = position[0]\n            for j in range(1,len(position)):\n                if position[j]-curr>=dist:\n                    used+=1\n                    curr = position[j]\n            return used\n\n        while l<r:\n            # 1 2 3 4 5\n            # l       r\n            # l-> bigger\n            # <-r smaller\n            d = r-(r-l)//2\n            used = isValid(d)\n            if used>=m:\n               l = d\n            else:\n                r = d-1\n        return r\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position = sorted(position)\n        \n        def count(d, position):\n            m_num, cur = 1, position[0]\n            for p in position:\n                if p - cur >= d:\n                    m_num += 1\n                    cur = p\n            return m_num\n        \n        l = 0\n        r = position[-1] - position[0]\n        \n        while l < r:\n            mid = l + (r-l)//2\n            m_num = count(mid+1, position)\n            if m_num < m:\n                r = mid\n            else:\n                l = mid + 1\n        return l\n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n#         n = len(position)\n#         position.sort()\n#         res = 0\n        \n#         def feasible(distance):\n#             balls, curr = 1, position[0]\n#             for i in range(1, n):\n#                 if position[i]-curr >= distance+1:### +1 to account for buckets\n#                     balls += 1\n#                     curr = position[i]                    \n#             return balls >= m\n                           \n#         left, right = 0, position[-1]-position[0]\n#         while left<right:\n#             mid = left + (right-left)//2\n#             if feasible(mid):\n#                 left = mid+1\n#             else:\n#                 right = mid\n#         return left\n#         # return right\n\n ############################################       \n        \n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans >= m\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2   ###speed_up\n            # mid = l + (r - l) // 2  ###TLE\n            print((l, r))\n            if count(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n  def maxDistance(self, position: List[int], m: int) -> int:\n    # we will binary search for the result\n    position.sort()\n    \n    # the minimum possible distance between balls is 1\n    lo = 1\n    # the maximum possible distance is the distance from the end to the start\n    hi = position[-1] - position[0]\n    \n    def isPossible(minDistance):\n      remaining = m\n      prev = float('-inf')\n      for p in position:\n        if p - prev >= minDistance:\n          prev = p\n          remaining -= 1\n      return remaining < 1\n    \n    while lo < hi:\n      mid = hi - ((hi - lo) >> 1)\n      if isPossible(mid):\n        lo = mid\n      else:\n        hi = mid - 1\n    return lo\n      \n    \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        l,r = 1, position[-1]-position[0]\n        res = r\n        while l <= r:\n            mid = (l+r)//2\n            prev,i,cnt = position[0],1,m-1\n            while i < n and cnt > 0:\n                if position[i] - prev >= mid:\n                    cnt -= 1\n                    prev = position[i]\n                i += 1\n            if cnt > 0:\n                r = mid - 1\n            else:\n                res = mid\n                l = mid + 1\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            num, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    num += 1\n                    curr = position[i]\n            return num\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, A: List[int], m: int) -> int:\n        A.sort()\n        def valid(i):\n            cnt = 1\n            cur = A[0]\n            for x in A[1:]:\n                if x - cur >= i:\n                    cnt += 1\n                    cur = x\n                if cnt >= m:\n                    return True\n            return False\n        \n        #print(valid(1), valid(2), valid(3), valid(4))\n        l, r = 1, A[-1]\n        \n        while l < r:\n            mid = (l + r) // 2\n            if valid(mid):\n                l = mid + 1\n            else:\n                r = mid\n        return l - 1\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        def isPossible(mid, m):\n            m -= 1\n            i = 1\n            prev = position[0]\n            while i < n and m:\n                if position[i] - prev >= mid:\n                    prev = position[i]\n                    m -= 1\n                i += 1\n            return m == 0\n        \n        \n        position.sort()\n        n = len(position)\n        lo = hi = position[-1] - position[0]\n        for i in range(n - 1):\n            lo = min(lo, position[i + 1] - position[i])\n        ans = 0\n        while lo <= hi:\n            mid = lo + (hi - lo)//2\n            if isPossible(mid, m):\n                ans = mid\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        left,right = 0,position[-1]-position[0] # search space is sorted\n        \n        def count_balls(force):\n            balls,prev = 1,position[0]\n            for cur in position[1:]:\n                if cur-prev >= force:\n                    balls += 1\n                    prev = cur\n            return balls\n            \n        \n        while left < right:\n            # mid = left + (right-left)//2\n            mid = right - (right-left) // 2\n            # mid = (left+right+1)//2\n            if count_balls(mid) >= m:\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n            \n            \n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def checkForce(force, positions, m):\n            i, prev = 1, positions[0]\n            while m > 0 and i < len(positions):\n                while positions[i] - force < prev:\n                    i += 1\n                    if i >= len(positions): return False\n                prev = positions[i]\n                m -= 1\n                i += 1\n            return m <= 0\n        \n        l, r = 0, position[-1] \n        while l < r:\n            mid = r - (r - l) // 2\n            # force is acceptable, let's see if we can achieve a higher force \n            if checkForce(mid, position, m-1):\n                l = mid\n            else:\n                r = mid - 1\n        return l \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def count(d):\n            res = 1\n            cur = position[0]\n            for i in range(1, n):\n                if position[i] - cur >= d:\n                    res += 1\n                    cur = position[i]\n            return res\n        n = len(position)\n        position.sort()\n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()        \n        w = (position[-1] - position[0]) // (m-1)\n        print(position)\n        \n        def count(w, m):\n            idx = 0\n            m -= 1\n            for i in range(1, len(position)):\n                if position[i] - position[idx] >= w:\n                    idx = i\n                    m -= 1\n                \n                if m == 0:\n                    break\n                    \n            return m == 0\n\n\n        if count(w, m):\n            return w\n        else:    \n            l ,r = 0, w\n            while l < r:\n                mid = r - (r - l) // 2\n                if count(mid, m):\n                    l = mid\n                else:\n                    r = mid - 1\n                \n            return l\n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def count(dist):\n            last_pos = position[0]\n            cnt = 1\n            \n            for pos in position:\n                if pos - last_pos >= dist:\n                    cnt += 1\n                    last_pos = pos\n            \n            return cnt\n        \n        # Binary Search on the answer\n        l = 1\n        r = position[-1] - position[0]\n        \n        while l < r:\n            mid = (l + r + 1) // 2\n            if count(mid) < m:\n                r = mid-1\n            else:\n                l = mid\n        \n        return l\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort() \n        def findcount(d):\n            res = 1 \n            current = position[0]\n            i = 1\n            while i < len(position):\n                if position[i] >= current+d:\n                    current = position[i]\n                    i+=1 \n                    res+=1 \n                else :\n                    i+=1 \n            return res \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if findcount(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n    \n            \n            \n            \n                \n                \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n=len(position)\n        res=-1\n        \n        left=position[0]\n        right=position[n-1]\n        while left<right:\n            mid=(left+right)//2\n            if self.isFeasible(position,mid,m):\n                res=max(res,mid)\n                left=mid+1\n            else:\n                right=mid\n                \n        if res==-1:\n            left=0\n            right=position[0]\n            while left<right:\n                mid=(left+right)//2\n                if self.isFeasible(position,mid,m):\n                    res=max(res,mid)\n                    left=mid+1\n                else:\n                    right=mid\n\n        return res\n        \n        \n    def isFeasible(self,arr,mid,m):\n        n=len(arr)\n        pos=arr[0]\n        count=1\n        for i in range(1,n):\n            if arr[i]-pos>=mid:\n                pos=arr[i]\n                count+=1\n                if count==m:\n                    return True\n        return False\n        \n", "class Solution:\n    def maxDistance(self, position, m):\n        position.sort()\n        N = len(position)\n        l = math.inf\n        for i in range(1, N):\n            l = min(l, position[i] - position[i-1])\n        r = position[-1] - position[0] + 1\n        def check(k):\n            last = position[0]\n            res = 0\n            for i in range(1, N):\n                if position[i] - last >= k:\n                    res += 1\n                    last = position[i]\n            return res\n            \n        \n        while l < r:\n            k = (l + r) // 2\n            if check(k) < m - 1:\n                r = k\n            else:\n                l = k + 1\n        return r - 1\n            \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n=len(position)\n        def distance(d):\n            p=0 # current position\n            c=1 # count of balls put into basket\n            while p<n-1:\n                \n                for i in range(p,n):\n                    if position[i]-position[p]>=d:\n                        c+=1\n                        break\n                p=i\n                if c==m:\n                    return True\n            return False\n        \n        l,r=0,position[-1]\n        while l<r:\n            md=r-(r-l)//2\n            #print(md,distance(md))\n            if distance(md):\n                l=md\n            else:\n                r=md-1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        \n        position.sort()\n        \n        def place(d):\n            print(d)\n            ans =  1\n            pos =  position[0]+d\n            j =  1\n            \n            while pos <= position[-1]:\n                while j < len(position) and position[j] < pos:\n                    j += 1\n                if j == len(position):\n                    break\n                ans += 1\n                pos = position[j]+d\n                j += 1\n                \n            print('ans')\n            print(ans)\n            return ans\n        \n        \n        l = 0\n        r = position[-1]-position[0]\n        \n        while l <= r:\n            mid = (l+r)//2\n            if place(mid)>=m:\n                l = mid+1\n            else:\n                r = mid-1\n                \n        \n        return l-1\n            \n                \n            \n                \n                \n        \n        \n", "class Solution:\n    def maxDistance(self,position, m) -> int:\n        position.sort()\n        l = 0\n        r = position[-1]-position[0]\n\n        def isValid(dist):\n            used = 1\n            curr = position[0]\n            for j in range(1,len(position)):\n                if position[j]-curr>=dist:\n                    used+=1\n                    curr = position[j]\n            return used\n\n        while l<r:\n            d = r-(r-l)//2\n            used = isValid(d)\n            if used>=m:\n               l = d\n            else:\n                r = d-1\n        return r\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        lo=0   \n        hi=position[-1]-position[0]\n        n=len(position)\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n                    \n            \n        while lo<hi:\n            #mid= (lo+hi+1)//2\n            mid=hi-(hi-lo)//2\n            res=count(mid)\n            if res>=m:\n                lo=mid\n            elif res<m:\n                hi=mid-1\n        return lo\n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def check(d):\n            i = 0\n            j = 1\n            for _ in range(m-1):\n                while j < len(position) and position[j] - position[i] < d:\n                    j += 1\n                if j >= len(position):\n                    return False\n                i = j\n                j = j + 1\n            return True\n        a = 1\n        b = position[-1] - position[0]\n        ans = 0\n        while a <= b:\n            c = (a + b) // 2\n            if check(c):\n                ans = c\n                a = c + 1\n            else:\n                b = c - 1\n        return ans", "# class Solution:\n#     def maxDistance(self, position: List[int], m: int) -> int:\n#         #\u9996\u5148\u6392\u5e8f\n#         position.sort()\n#         print(position)\n        \n#         left = 1000000000\n#         right = position[-1] - position[0]\n#         for i in range(len(position)-1):\n#             diff = abs(position[i] - position[i+1])\n#             left = min(left, diff)\n            \n            \n#         def check(diff, p, m):\n#             m -= 1\n#             last = p[0]\n#             for i in range(1, len(p)):\n#                 if abs(p[i] - last) >= diff:\n#                     m -= 1\n#                     last = p[i]\n#                     if m <= 0:\n#                         print(diff, \\\"True\\\")\n#                         return True\n#                 else:\n#                     pass\n#             print(diff, \\\"False\\\")\n#             return False\n            \n#         print(\\\"left\\\", left, \\\"right\\\", right)\n#         while left < right:\n#             mid = (left + right) // 2\n#             if check(mid, position, m) == True:\n#                 left = mid\n#                 if left == right:\n#                     print(\\\"find 1\\\", left)\n#                     break\n#                 if left + 1 == right:\n#                     if check(right, position, m):\n#                         left = right\n#                         print(\\\"find 2\\\", left)\n#                     break\n#             else:\n#                 right = mid - 1\n        \n                \n#         print(\\\"find 3\\\", left)\n#         return left\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        #\u9996\u5148\u6392\u5e8f\n        position.sort()\n        # print(position)\n        \n        distance = [0 for _ in range(len(position)-1)]\n        for i in range(len(position)-1):\n            diff = position[i+1] - position[i]\n            distance[i] = diff\n        left = min(distance)\n        right = ceil((position[-1] - position[0]) / (m-1))\n            \n        def check(diff, m):\n            m -= 1\n            pre_dis = 0\n            for i in range(0, len(distance)):\n                if distance[i]+pre_dis >= diff:\n                    m -= 1\n                    if m <= 0:\n                        # print(diff, \\\"True\\\")\n                        return True\n                    pre_dis = 0\n                else:\n                    pre_dis += distance[i]\n            # print(diff, \\\"False\\\")\n            return False\n            \n        # print(\\\"left\\\", left, \\\"right\\\", right)\n        while left < right:\n            mid = (left + right+1) // 2\n            if check(mid, m) == True:\n                left = mid\n                # if left == right:\n                #     print(\\\"find 1\\\", left)\n                #     break\n                # if left + 1 == right:\n                #     if check(right, position, m):\n                #         left = right\n                #         print(\\\"find 2\\\", left)\n                #     break\n            else:\n                right = mid - 1\n        \n                \n        # print(\\\"find 3\\\", left)\n        return left\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position.sort()\n        min_p, max_p = position[0], position[-1]\n        \n        def enough(x):\n            prev, cnt = min_p, 1\n            for i, p in enumerate(position):\n                if p - prev >= x:\n                    prev = p\n                    cnt += 1\n                    \n                    if cnt >= m:\n                        return True\n            return False\n        \n        l, r = 1, max_p - min_p\n        while l < r:\n            mid = (l + r + 1) // 2\n            if enough(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return l\n                \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        n = len(position)\n        if m == 2: return position[-1] - position[0]\n        \n        \n        lp = 0\n        rp = (position[-1] - position[0])\n        \n        def can(gap):\n            lidx = 0\n            left = m - 1\n            ptr = 1\n            while left > 0 and ptr < n:\n                if position[ptr] - position[lidx] >= gap:\n                    left -= 1\n                    lidx = ptr\n                    ptr = lidx + 1\n                    continue\n                ptr += 1\n            return left == 0\n        \n        ans = 0\n        while lp < rp:\n            mid = (lp+rp+1)//2\n            if can(mid):\n                lp = mid\n            else:\n                rp = mid-1\n        return lp", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check_works(position, m, dist):\n#             placing ball 1\n            balls_to_place = m - 1\n            last_ball_pos = 0\n            for ind in range(last_ball_pos, len(position)):\n                # print(position[ind])\n                if position[ind] - position[last_ball_pos] >= dist:\n                    balls_to_place -= 1\n                    last_ball_pos = ind\n                if balls_to_place == 0:\n                    break\n            if balls_to_place == 0:\n                return 1\n            else:\n                return 0\n            \n        \n#       let's try between 1 and 1000000000\n        position.sort()\n        lb = 1\n        rb = 1000000000\n        while (lb != rb - 1):\n            ret = check_works(position, m, int((lb + rb)/2))\n            \n            if(ret == 0):\n                rb = int((lb + rb)/2)\n            else:\n                lb = int((lb + rb)/2)\n            \n            print(lb,rb)\n        return lb", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        \n        def count(d):\n            c, cur = 1, position[0]\n            for i in range(1, n):\n                if position[i] - cur >= d:\n                    c += 1\n                    cur = position[i]\n            \n            return c\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n            \n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def possible(force):\n            prev = float('-inf')\n            balls_placed = 0\n            for x in position:\n                if x-prev < force:\n                    continue\n                \n                prev= x\n                balls_placed+=1  \n                \n            return(balls_placed>=m)\n        \n        lo,hi = 0 , max(position)\n        while lo<hi:\n            mid = lo+hi+1>>1\n            if possible(mid):\n                lo=mid\n                \n            else:\n                hi=mid-1\n                \n        return(lo)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        \n        def check(dis):\n            num = 0\n            presum = 0\n            for i in range(1, n):\n                presum += position[i] - position[i-1]\n                if presum >= dis:\n                    presum = 0\n                    num += 1\n            return num\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r-1:\n            mid = (l + r) // 2\n            if check(mid) >= m-1:\n                l = mid\n            else:\n                r = mid - 1\n        return r if check(r) >= m-1 else l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l = 1\n        r = (position[-1]-position[0])//(m-1)\n        #print(l,r)\n        while (l<r):\n            mid = (l+r)//2 +1\n            placed = 1\n            distance = 0\n            start = position[0]\n            for i in range(1,len(position)):\n                distance = position[i]-start\n                if distance >= mid:\n                    placed +=1\n                    distance = 0\n                    start = position[i]\n            #print(placed)\n            if placed >=m:\n                #answer = mid #we placed all balls\n                l = mid \n            else:\n                r = mid -1\n                \n        return(l)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        # diffs = [position[i] - position[i-1] for i in range(1, n)]\n        n = len(position)\n        def check(target_min_force):\n            put_count = 1\n            cur_force = 0\n            for i in range(1, n):\n                cur_force += position[i] - position[i-1]\n                if cur_force >= target_min_force:\n                    cur_force = 0 \n                    put_count += 1\n                    if put_count == m:\n                        return True\n            return False\n                \n        l, r = -1, position[-1] - position[0] + 1\n        while r - l > 1:\n            mid = (l + r) // 2\n            if check(mid):\n                l = mid\n            else:\n                r = mid\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def guess(position, m, guess):\n            placed = 1\n            last = position[0]\n            i = 1\n            while i < len(position):\n                #print(position[i], last, placed, m)\n                if position[i] - last >= guess:\n                    placed += 1\n                    last = position[i]\n                \n                if placed == m:\n                    return True\n                \n                i += 1\n            \n           # print(\\\"final \\\", placed, m)\n            return placed >= m\n        \n        position.sort()\n        l = 0\n        r = position[-1] - position[0]\n        # l: checked OK\n        # r: haven't check\n        while l < r:\n            mid = (l + r + 1) // 2\n            #print(l, mid, r)\n            if guess(position, m, mid):\n                #print(\\\"guess OK\\\", mid)\n                l = mid\n            else:\n                r = mid - 1\n        \n        return l\n    \n    \n    #placed = 1, last = 1, i = 1\n    # \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position) \n        \n        def checkForce(force, positions, m):\n            prev = positions[0]\n            i = 1\n            while m > 0 and i < len(positions):\n                while positions[i] - force < prev:\n                    i += 1\n                    if i >= len(positions): return False\n                m -= 1\n                prev = positions[i]\n                i += 1\n            return m <= 0\n        \n        # print(checkForce(2, position, m - 1))\n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            # force is acceptable, let's see if we can achieve a higher force \n            if checkForce(mid, position, m-1):\n                l = mid\n            else:\n                r = mid - 1\n        return l \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def bs(mid, m):\n            pre = position[0]\n            m -= 1\n            \n            for x in position:\n                if x - pre >= mid:\n                    pre = x\n                    m -= 1\n                    if m == 0:\n                        return True\n            \n            if m == 0:\n                return True\n            else:\n                return False\n                \n        \n        l = 1\n        r = 10 ** 9\n        \n        position.sort()\n        \n        while l < r:\n            mid = l + (r - l) // 2\n            if bs(mid, m):\n                l = mid + 1\n            else:\n                r = mid\n        \n        return l - 1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        \n        def count(d):\n            res = 1\n            curr = position[0]\n            for i in range(1,n):\n                if position[i] - curr >= d:\n                    res += 1\n                    curr = position[i]\n            return res\n        l = 0\n        r = position[-1] - position[0]\n        while l < r:\n            mid = l + (r-l) // 2 + 1\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # binary search on answer\n        n = len(position)\n        position.sort()\n        left = 1\n        right = max(position)\n        while right - left > 1:\n            mid = (left + right) // 2\n            if self.ok(position, m, mid):\n                left = mid\n            else:\n                right = mid\n        if self.ok(position, m, right):\n            return right\n        elif self.ok(position, m, left):\n            return left\n        \n    def ok(self, position, m, force):\n        # first one at the \n        n = len(position)\n        stack = [position[0]]\n        i = 0\n        while i < n:\n            if position[i] - stack[-1] >= force:\n                stack.append(position[i])\n            i += 1\n        return len(stack) >= m\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def distributable(n):\n            pos = position.copy()\n            balls = m\n            while pos and balls:\n                balls -= 1\n                np = pos[-1] - n\n                while pos and pos[-1] > np:\n                    pos.pop()\n            return not balls       \n        position = sorted(position)\n        lo, hi = 1, (position[-1] - position[0]) // (m -1) + 1\n        ans = lo\n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if distributable(mid):\n                ans = mid\n                lo = mid + 1\n            else:\n                hi = mid\n        return ans        ", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort() \n        \n        left = 1\n        right = (position[-1] - position[0]) // (m-1)\n        \n        def placeable(gap):\n            count = 0\n            x = -gap\n            for n in position:\n                if n-x >= gap:\n                    count +=1 \n                    x = n\n                    if count == m:\n                        return True \n            return False \n                \n    \n        while left < right:\n            mid = (left + right + 1) // 2\n            if placeable(mid):\n                left = mid\n            else:\n                right = mid - 1\n                \n        return left", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        highest_f = int((position[-1] - position[0]) / (m - 1))\n        def helper(position, m, high_f, low_f, curr_f):\n            selected_pos = [position[0]]\n            for i in position:\n                if i - selected_pos[-1] >= curr_f:\n                    selected_pos.append(i)\n            if high_f > low_f + 1:\n                if len(selected_pos) < m:\n                    new_curr_f = int((low_f + curr_f) / 2)\n                    return helper(position, m, curr_f, low_f, new_curr_f)\n                else:\n                    new_curr_f = int((curr_f + high_f) / 2)\n                    return helper(position, m, high_f, curr_f, new_curr_f)\n            else:\n                if len(selected_pos) < m:\n                    return low_f\n                else:\n                    return curr_f\n        return int(helper(position, m, highest_f, 1, highest_f))", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def c(p,m,d):\n            b=m-1\n            l=len(p)\n            acc=0\n            for i in range(1,l):\n                acc+=p[i]-p[i-1]\n                if acc>=d:\n                    acc=0\n                    b-=1\n                if b==0:\n                    return True\n            return False\n        low=1\n        high=max(position)\n        mid=0\n        position.sort()\n        while low<=high:\n            mid=(low+high)//2\n            if c(position,m,mid):\n                low=mid+1\n            else:\n                high=mid-1\n        return high", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def distance(d):\n            p=0 # current position\n            c=1 # count of balls put into basket\n            while p<len(position)-1:\n                \n                for i in range(p,len(position)):\n                    if position[i]-position[p]>=d:\n                        c+=1\n                        break\n                    \n                p=i\n                \n                if c==m:\n                    return True\n            return False\n        l,r=0,position[-1]\n        while l<r:\n            md=r-(r-l)//2\n            #print(md,distance(md))\n            if distance(md):\n                l=md\n            else:\n                r=md-1\n        return l", "class Solution:\n\n  def verify(self, position: List[int], dis: int, balls: int) -> bool:\n    result = True\n    start = position[0]\n    cur = 1\n    counter = 1\n    while cur < len(position):\n      if position[cur] >= start + dis:\n        start = position[cur]\n        counter += 1\n        if counter >= balls:\n          return True\n      cur += 1\n\n    return False\n\n  def maxDistance(self, position: List[int], m: int) -> int:\n\n    result = 0\n    position = sorted(position)\n    minvalue = sys.maxsize\n    maxvalue = -sys.maxsize\n    for value in position:\n      minvalue = min(minvalue, value)\n      maxvalue = max(maxvalue, value)\n\n    left = 1\n    right = maxvalue - minvalue\n    while left <= right:\n      mid = left + (right - left) // 2\n      checked = self.verify(position, mid, m)\n      if checked:\n        left = mid + 1\n        result = mid\n      else:\n        right = mid - 1\n\n    return result\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom typing import List, Dict\n\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        a = position\n        a.sort()\n        M = m\n\n        def isok(m):\n            c = 0\n            prev = - (1 << 30)\n            for x in a:\n                if x - prev >= m:\n                    c += 1\n                    prev = x\n            return c >= M\n\n        l = 0\n        r = 10 ** 9\n        while l < r:\n            m = (l + r + 1) // 2\n            if isok(m):\n                l = m\n            else:\n                r = m - 1\n        return l\n\n\ndef _case(*a):\n    assert Solution().maxDistance(*a[:-1]) == a[-1]\n    pass\n\n\ndef test():\n    _case([1, 100], 2, 99)\n    _case([1,2,3,4,7], 3, 3)\n    _case([5,4,3,2,1,1000000000], 2, 999999999)\n    pass\n", "from collections import deque\n\nclass Solution:\n    def helper(self, minforce, position, m):\n        #returns if minforce is valid or not\n        counter = 1\n        prev = position[0]\n        i = 1\n        while i < len(position) and counter < m:\n            if position[i] - prev < minforce:\n                i += 1\n            else:\n                counter += 1\n                prev = position[i]\n                i += 1\n        if counter == m:\n            return True\n        else:\n            return False\n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        left = 1\n        right = position[-1] - position[0]\n        if m==2:\n            return right\n        while left < right:\n            mid = left + (right - left)//2\n            #print(mid)\n            if self.helper(mid, position, m):\n                left = mid + 1\n            else:\n                right = mid\n        return left-1", "class Solution:\n    def maxDistance(self, A: List[int], m: int) -> int:\n        n = len(A)\n        A.sort()\n        \n        def balls(d):\n            count, cur = 1, A[0]\n            \n            for i in range(1, len(A)):\n                if A[i] - cur >= d:\n                    count += 1\n                    cur = A[i]\n            return count\n        \n        \n        l, r = 1, A[-1] - A[0]\n        \n        while l < r:\n            mid = (l + r + 1) // 2\n            \n            if balls(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n                \n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        \n        def num(dist):\n            count = 1\n            curr = position[0]\n            for i in range(1, n):\n                if position[i] - curr >= dist:\n                    count += 1\n                    curr = position[i]\n            return count\n        \n        start = 0\n        end = position[-1] - position[0]\n        res = 0\n        while start < end:\n            mid = (start + end) // 2\n            if num(mid) >= m:\n                start = mid + 1\n                res = mid\n            else:\n                end = mid\n        if num(start) >= m:\n            return start\n        else:\n            return start - 1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check(position,mid):\n            i=position[0]\n            count=0\n            for j in position:\n                if((j-i)>=mid):\n                    count+=1\n                    i=j\n            return count+1\n        l=0\n        position.sort()\n        r=position[-1]\n        while(r>(l+1)):\n            mid=math.ceil((l+r)/2)\n            print(mid)\n            k=check(position,mid)\n            if(k<m):\n                r=mid\n            else:\n                l=mid\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r = 1, position[-1] - position[0] + 2\n        ans = 0\n        while l < r:\n            mid = (l+r+1) //2\n            cnt, i, j = 1, 1, 0\n            while i < len(position):\n                if position[i] - position[j] >= mid:\n                    cnt += 1\n                    j = i\n                i += 1\n            if cnt >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = (r - l + 1) // 2 + l\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        left, right = 0, position[-1] - position[0]\n\n        def check(dist):\n            pre = position[0]\n            n = m - 1\n            i = 1\n            while n:\n                while i < len(position) and position[i] - pre < dist:\n                    i += 1\n                if i >= len(position): return False\n                pre = position[i]\n                i += 1\n                n -= 1\n            return True\n\n        while left <= right:\n            mid = (left + right) // 2\n            if check(mid):\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left - 1", "class Solution:\n    def _MaxPossibleForce(self, position):\n        return position[-1] - position[0]\n    \n    def _GetNumAssignedBallsForGivenForce(self, position, force):\n        i = 1\n        assigned = 1\n        # 0th item is the first ball\n        last_assigned_position = 0\n        while i < len(position):\n            if position[i] - position[last_assigned_position] >= force:\n                assigned += 1\n                last_assigned_position = i\n            i += 1\n        return assigned\n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        max_force = self._MaxPossibleForce(position)\n        min_force = 1 # as m <= len(position)\n        while min_force <= max_force:\n            search_force = (min_force + max_force)//2\n            num_assigned = self._GetNumAssignedBallsForGivenForce(position, search_force)\n            if num_assigned < m:\n                max_force = search_force - 1\n            else:\n                min_force = search_force + 1\n        return max_force\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check(position, d, m):\n            last = position[0]\n            balls = m - 1\n            i = 1\n            while balls and i < len(position):\n                if position[i] - last < d:\n                    i += 1\n                else:\n                    last = position[i]\n                    balls -= 1\n            return balls == 0\n                                  \n        position.sort()\n        hi = position[-1]\n        lo = 1\n\n        while lo < hi:\n            mi = (lo + hi + 1) // 2\n            if check(position, mi, m):\n                lo = mi\n            else:\n                hi = mi - 1\n        return lo\n", "#829\nclass Solution:\n  def maxDistance(self, arr: List[int], m: int) -> int:\n    arr.sort()\n    low = 1\n    high = arr[-1] - arr[0]\n    \n    def place(limit):\n      prev = -1e10\n      j = 0\n      for i in range(m):\n        while j < len(arr) and arr[j] - prev < limit:\n          j += 1\n        if j == len(arr):\n          return False\n        prev = arr[j]\n        j += 1\n        \n      return True\n    \n    while low <= high:\n      cur = int((low + high) / 2)\n      #print(low, high, cur, place(cur))\n      if place(cur):\n        low = cur + 1\n      else:\n        high = cur - 1\n    return high\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def helper(d):\n            cnt = 1\n            cur = position[0]\n            for i in range(1, len(position)):\n                if cur + d <= position[i]:\n                    cur = position[i]\n                    cnt += 1\n            return cnt\n        \n        l, r = 0, position[-1] - position[0]\n        res = -float('inf')\n        while l <= r:\n            # print(l, r)\n            # if l == r and helper(l) == m:\n            #     return l\n            mid = (l + r) >> 1\n            if helper(mid) == m:\n                res = max(mid, res)\n                l = mid + 1\n            elif helper(mid) > m:\n                # res = max(mid, res)\n                l = mid + 1\n            else:\n                r = mid - 1\n        return max(res, l-1)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check(threshold):\n            last = position[0]\n            count = 1\n            for p in position[1:]:\n                if p - last >= threshold:\n                    count += 1\n                    last = p\n                if count == m:\n                    return True\n            return False\n            \n        # binary search for max distance, l, r indicates distance\n        position.sort()\n        l, r = 1, position[-1]-position[0]\n\n        while l <= r:\n            mid = l + (r-l)//2\n            if  check(mid):\n                l = mid + 1\n            else:\n                r = mid - 1\n\n        return r", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # m\u8868\u793a\u7403\u7684\u6570\u91cf\n        # \u5bfb\u627em-1\u4e2a\u7a7a\u9699\uff0c\u6765\u6ee1\u8db3\u8ddd\u79bb\u8981\u6c42\n        def dist_valid(interval, k):\n            count,k_count = 0,0\n            for i in interval:\n                count += i\n                if count>=k:\n                    count = 0\n                    k_count += 1\n                    if k_count>=m-1:\n                        return True\n            return False\n            \n        interval = []\n        sort_pos = sorted(position)\n        for i in range(len(sort_pos)-1):\n            interval.append(sort_pos[i+1]-sort_pos[i])\n        left = 1\n        right = (max(sort_pos)-min(sort_pos))//(m-1)\n        while left<right:\n            mid = right - (right-left)//2\n            if dist_valid(interval,mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, cur = 1, position[0]\n            for i in range(1, n):\n                if position[i] - cur >= d:\n                    ans += 1\n                    cur = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        \n        while l < r:\n            mid = l + (r - l + 1)// 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n                \n        return l", "import bisect\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        def possible(gap):\n            prev = position[0]\n            idx = 0\n            left = m - 1\n            while left > 0:\n                idx = bisect.bisect_left(position, prev+gap, idx + 1, n)\n                if idx >= n:\n                    return False\n                else:\n                    prev = position[idx]\n                    left -= 1\n            return True\n        \n        position.sort()\n        min_gap = 1\n        max_gap = position[-1] - position[0]\n        while min_gap <= max_gap:\n            cur_gap = (min_gap + max_gap) // 2\n            if possible(cur_gap):\n                # print(\\\"possible\\\", cur_gap)\n                min_gap = cur_gap + 1\n            else:\n                # print(\\\"impossible\\\", cur_gap)\n                max_gap = cur_gap - 1\n                \n        return min_gap - 1\n    \n                \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        lo = 1\n        hi = position[-1] - position[0]\n        def count(dis):\n            res = 1\n            i = 0\n            curr = 0\n            while i < len(position):\n                if position[i]-position[curr] >= dis:\n                    res += 1\n                    curr = i\n                i += 1\n            return res\n        # def count(d):\n        #     ans, curr = 1, position[0]\n        #     for i in range(1, len(position)):\n        #         if position[i] - curr >= d:\n        #             ans += 1\n        #             curr = position[i]\n        #     return ans\n        while lo < hi:\n            mid = hi-(hi-lo)//2\n            if count(mid) >= m:\n                lo = mid\n            else:\n                hi = mid-1\n        return lo", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        left,right = 0,position[-1]-position[0] # search space is sorted\n        \n        def count_balls(force):\n            balls,prev = 1,position[0]\n            for cur in position[1:]:\n                if cur-prev >= force:\n                    balls += 1\n                    prev = cur\n            return balls\n            \n        \n        while left < right:\n            # mid = left + (right-left)//2\n            mid = right - (right-left) // 2\n            # mid = (left+right+1)//2\n            if count_balls(mid) >= m:\n                left = mid\n            else:\n                right = mid - 1\n        return left\n            \n            \n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n\n        def is_possible(threshold):\n            count = 0\n            prev = -math.inf \n            for x in position:\n                if x - prev >= threshold:\n                    count += 1\n                    prev = x\n            return count >= m\n\n        span = position[-1] - position[0]\n        lo, hi = 0, span\n        while lo < hi:\n            mid = (lo + hi + 1) // 2\n            if is_possible(mid):\n                lo = mid \n            else:\n                hi = mid - 1\n        return lo", "class Solution:\n    # min-max, dp?\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def feasible(dist):\n            placed, pos = 0, 0\n            prev = float('-inf')\n            while pos < len(position):\n                if position[pos] - prev >= dist:  # can place one more\n                    placed += 1\n                    prev = position[pos]\n                pos += 1\n                if placed == m:\n                    return True\n            return False\n                \n        \n        left, right = 1, position[-1]\n        while left < right:\n            dist = (left + right) // 2\n            if feasible(dist):\n                left = dist + 1\n            else:\n                right = dist\n                \n        return left - 1\n        \n                \n                \n                \n                \n        \n", "class Solution:\n    def maxDistance(self, position, m):\n        position = sorted(position)\n        start, end = 1, position[-1] - position[0]\n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if self.check(position, m, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(position, m, end):\n            return end\n        if self.check(position, m, start):\n            return start\n    \n    def check(self, position, m, delta):\n        n = len(position)\n        i = 1\n        j = 1\n        last = position[0]\n        while i <= m - 1 and j <= n - 1:\n            if position[j] >= last + delta:\n                last = position[j]\n                i += 1\n            j += 1\n        return i == m", "class Solution:\n    def maxDistance(self, A: List[int], m: int) -> int:\n        A, n = sorted(A), len(A)\n        left, right = 0, A[-1] - A[0]\n        while left < right:\n            mid = (right + left + 1) // 2\n            ct, idx = 1, 0\n            for i in range(1, n):\n                if A[i] - A[idx] >= mid:\n                    ct += 1\n                    idx = i\n            if ct < m:\n                right = mid - 1\n            else:\n                left = mid\n        return right", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def num_balls(min_dist: int) -> int:\n            ans, curr = 1, 0\n            \n            for i in range(1,n):\n                if position[i] - position[curr] >= min_dist:\n                    ans += 1\n                    curr = i\n            return ans\n        \n        l, r = 0, position[n-1] - position[0]\n        \n        while l < r:\n            mid = r - (r - l) // 2\n            \n            if num_balls(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        lo,hi = 1,(position[-1]-position[0])//(m-1) + 1\n        res = 0\n        \n        \n        def possible(gap):\n            balls = m\n            prev = None\n            for i in range(len(position)):\n                if not prev:\n                    prev = position[i]\n                    balls-=1\n                else:\n                    if abs(prev - position[i])<gap:\n                        continue\n                    else:\n                        prev = position[i]\n                        balls-=1\n            if balls<=0:\n                return True\n            return False\n        \n        while lo<=hi:\n            # print(lo,hi)\n            mid = (lo+hi)//2\n            \n            if possible(mid):\n                res = mid\n                lo = mid+1\n            else:\n                hi = mid-1\n                \n        return res", "class Solution:\n    def maxDistance(self, positions: List[int], m: int) -> int:\n        positions.sort()\n        \n        def possible(force):\n            placed = 0\n            pos = -math.inf\n            \n            for p in positions:\n                if p - pos >= force:\n                    placed += 1\n                    pos = p\n            \n            return placed >= m\n            \n        (lo, hi) = (0, positions[-1])\n        \n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if possible(mid):\n                lo = mid + 1\n            else:\n                hi = mid - 1\n                \n        return hi", "def pos(mid, position, m):\n    res = 1\n    curr_pos = 0\n    for i in range(1, len(position)):\n        if position[i] - position[curr_pos] >= mid:\n            curr_pos = i\n            res += 1\n            if res == m:\n                return True\n    return False\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l = 0\n        h = position[-1] - position[0]\n        res = 0\n        while l <= h:\n            mid = int((h + l) / 2)\n            if pos(mid, position, m) == False:\n                h = mid - 1\n            else:\n                res = max(res, mid)\n                l = mid + 1\n        return res", "class Solution:\n    def _MaxPossibleForce(self, position):\n        return position[-1] - position[0]\n    \n    def _AssignBallsWithKDistance(self, position, force):\n        i = 1\n        assigned = 1\n        # 0th item is the first ball\n        last_assigned_position = 0\n        while i < len(position):\n            if position[i] - position[last_assigned_position] >= force:\n                assigned += 1\n                last_assigned_position = i\n            i += 1\n        return assigned\n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        max_force = self._MaxPossibleForce(position)\n        min_force = 1\n        print((self._AssignBallsWithKDistance(position, 4)))\n        while min_force <= max_force:\n            search_force = (min_force + max_force)//2\n            num_assigned = self._AssignBallsWithKDistance(position, search_force)\n            if num_assigned < m:\n                max_force = search_force - 1\n            else:\n                min_force = search_force + 1\n        return max_force\n", "#https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/854038/Beginner-Friendly-solution-or-Explained-with-time-complexity-analysis\n    \nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        def check(dist):\n            prev = position[0]\n            cnt = 1\n            idx = 0\n            while idx<len(position):\n                curr = position[idx]\n                if curr-prev>=dist:\n                    cnt += 1\n                    prev = curr\n                idx += 1\n                if cnt>m:\n                    break\n            return cnt\n        \n        position.sort()\n        L = 1\n        R = position[-1]-position[0]\n        \n        while L<R:\n            # print ('a ', L, R)\n            if L==R-1:\n                if check(R)>=m:\n                    return R\n                else:\n                    return L\n            mid = L+(R-L)//2\n            if check(mid)<m:\n                R = mid-1\n            else:\n                L = mid\n            # print (L, R)\n        return L", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # Binary search solution.\n        # https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/794070/Python-Binary-search-solution-with-explanation-and-similar-questions\n        \n        position.sort()\n        \n        def num_balls_placed(tested_distance):\n            num_placed, current = 1, position[0]\n            \n            for i in range(1, len(position)):\n                if position[i] - current >= tested_distance:\n                    current = position[i]\n                    num_placed += 1\n            \n            return num_placed\n        \n        low, high = 0, position[-1] - position[0]\n        best = -1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if num_balls_placed(mid) < m:\n                high = mid - 1\n            else:\n                best = mid\n                low = mid + 1\n                \n        return best", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        maxrange = position[-1] - position[0]\n        # print(maxrange)\n        l, r = 1, maxrange\n        while l <= r:\n            mid = l + (r - l) // 2\n            cnt = self.count(position, mid)\n            if cnt >= m:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return r\n        \n    def count(self, poss: list, dist: int) -> int:\n        res = 1\n        last = poss[0]\n        for i in range(1, len(poss)):\n            if poss[i] - last >= dist:\n                res += 1\n                last = poss[i]\n        return res", "class Solution:\n    \n    def allow(self, mid, position, m):\n        #check if the given distance is possible\n        #greedy approach: putting each ball in the first place\n        balls = 1\n        last = position[0]\n        for i in range(1, len(position)):\n            if(position[i] - last >= mid):\n                balls+=1\n                last = position[i]\n        return balls>=m\n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        o = Solution()\n        #binary search\n        position.sort()\n        low = 0\n        high = 1000000000\n        pos = 0\n        while(low<=high):\n            mid = int((high+low)/2)\n            if(o.allow(mid, position, m)):\n                low = mid+1\n                pos = mid\n            else:\n                high = mid-1\n        return pos", "class Solution:\n    def maxDistance(self, p: List[int], m: int) -> int:\n        def isFeasible(mid, arr, n, k): \n            pos = arr[0] \n            elements = 1\n            for i in range(1, n): \n                if (arr[i] - pos >= mid):\n                    pos = arr[i] \n                    elements += 1\n                    if (elements == k): \n                        return True\n            return False\n\n        p.sort()\n        #[1,2,3,4,5,100000]\n        #Cm(n)\n        n = len(p) \n        res = -1\n        left = 0\n        right = p[n - 1]\n  \n        while left < right: \n            mid = (left + right) // 2\n            if (isFeasible(mid, p, n, m)): \n                res = max(res, mid) \n                left = mid + 1\n            else: \n                right = mid \n  \n        return res\n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        def count(d):\n            answer, curr = 1, position[0]\n            for i in range(1,n):\n                if position[i] - curr >= d:\n                    answer+=1\n                    curr = position[i]\n            return answer\n        left, right = 0, position[-1] - position[0]\n        while left < right :\n            mid = right - (right- left)//2\n            if count(mid) >= m :\n                left = mid\n            else:\n                right = mid - 1\n        return left", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # position = sorted(position)\n        # def enough(distance):\n        #     cur = position[0]\n        #     c = 1\n        #     for i in range(len(position)):\n        #         if position[i] >= cur + distance:\n        #             cur = position[i]\n        #             c += 1\n        #     return c>=m\n        # cur_max = position[-1]-position[0] + 1\n        # cur_min = 1\n        # while abs(cur_min-cur_max)>1:\n        #     mid = cur_min + (cur_max-cur_min)//2\n        #     if enough(mid):\n        #         cur_min = mid\n        #     else:\n        #         cur_max = mid\n        # return cur_min\n    \n        position = sorted(position)\n        n = len(position)\n        if n == 2:\n            return position[-1]-position[0]\n        \n        cur_min = 1\n        cur_max = position[-1]-position[0]+1\n        \n        def enough(distance):\n            ini = position[0]\n            c = 1\n            for i in range(1, n):\n                if position[i]-ini >= distance:\n                    ini = position[i]\n                    c += 1\n                \n            return c>=m\n            \n        while(abs(cur_max-cur_min)>1):\n            mid = (cur_max+cur_min)//2\n            if enough(mid):\n                cur_min = mid\n            else:\n                cur_max = mid\n        \n        return cur_min\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n            \n\n\n            \n\n", "class Solution:\n    def isPossible(self, position , m , force):\n        lastKept = position[0]\n        m -= 1\n        for i in range(1,len(position)):\n            currentPosition = position[i]\n            if currentPosition - lastKept >= force:\n                lastKept = currentPosition\n                m -= 1\n        return m <= 0\n            \n            \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        left , right = 1, 10 ** 9 + 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if self.isPossible(position,m,mid):\n                result = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n", "class Solution:\n    def distribute(self, position, m, dist):\n        prev = position[0]\n        m -= 1\n        for i in range(1, len(position)):\n            if position[i]-prev >= dist:\n                prev = position[i]\n                m -= 1\n            if m==0:\n                return True\n        return False\n            \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        low, high = 0, position[-1]-position[0]\n        res = 0\n        while low <= high:\n            mid = (high-low)//2 + low\n            if self.distribute(position, m, mid):\n                res = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        lo, hi = 0, position[-1] - position[0]\n        \n        def possible(target, m):\n            idx = prev = 0            \n            while m:\n                if idx >= len(position):\n                    return False\n                if not prev or position[idx] >= prev + target:\n                    m -= 1\n                    prev = position[idx]\n                else:\n                    idx += 1\n            return True\n                \n        \n        while lo < hi:\n            mid = (lo + hi + 1) // 2\n            if possible(mid, m):\n                lo = mid\n            else:\n                hi = mid - 1\n        \n        return lo", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def count(d):\n            c = position[0]\n            res = 1\n            for n in position[1:]:\n                if n-c>=d:\n                    res += 1\n                    c = n\n            return res\n        \n        l = 1\n        r = (position[-1] - position[0])//(m-1)\n        while l <= r:\n            mid = (l+r)//2\n            if count(mid) < m:\n                r = mid - 1\n            elif count(mid+1)<m: \n                return mid\n            else:\n                l = mid +1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        arr = sorted(position)\n        \n        if m == 2:\n            return arr[-1] - arr[0]\n        \n        def is_possible(f):\n            count = 1\n            origin = arr[0]\n            for i in range(1, n):\n                if arr[i] - origin >= f:\n                    count += 1\n                    origin = arr[i]\n                if count >= m:\n                    return True\n            \n            if count < m - 1 or arr[-1] - origin < f:\n                return False\n            \n            return True\n        \n        low, high = 1, arr[-1] - arr[0]\n        \n        while low + 1 < high:\n            f = ceil((high + low) / 2)\n            if is_possible(f):\n                low = f\n            else:\n                high = f\n\n        if is_possible(high):\n            return high\n        return low\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check(f):\n            nonlocal position\n            nonlocal m\n            nonlocal res\n            for i in range(len(position)):\n                balls_cnt = 1 \n                last_ball_pos = 0\n\n                for i in range(1, len(position)):\n                    last_ball_val_pos = position[last_ball_pos]\n                    curr_ball_val_pos = position[i]\n                    cur_force = curr_ball_val_pos - last_ball_val_pos\n                    if cur_force >= f:\n                        balls_cnt +=1\n                        last_ball_pos = i\n                        if balls_cnt == m:  \n                            res = max(res, f)                      \n                            return True\n\n                return False\n\n\n        res = 0\n        position.sort()\n        left = 1\n        right = max(position)\n\n        while left < right:\n            mid = left + (right - left) // 2\n            if check(mid):\n                # add to answer, check if can do better increase mid and look up in right part\n                left = mid + 1\n            else:\n                right = mid\n\n        return res   \n      \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        def check(position,m,f):\n            \n            prev=0\n            balls=1\n            index=1\n            \n            while index<len(position) and balls<=m:\n                if position[index]-position[prev]>=f:\n                    prev=index\n                    index+=1\n                    balls+=1\n                else:\n                    index+=1\n            \n            if balls>=m:\n                return True\n            else:\n                return False\n            \n        position=sorted(position)\n        start=1\n        end=max(position)\n        \n        \n        while start<end:\n            mid=(start+end)//2\n            \n            if check(position,m,mid):\n                start=mid+1\n            else:\n                end=mid\n        \n        return start-1", "class Solution:\n    def feasible(self, d, m):\n        last_pos = self.position[0]\n        i = 1\n        num_placed = 1\n        while num_placed < m and i < self.plen:\n            if self.position[i] - last_pos >= d:\n                last_pos = self.position[i]\n                num_placed += 1\n            i += 1\n        return num_placed == m\n\n    def maxDistance(self, position: List[int], m: int) -> int:\n        self.position = position\n        self.plen = len(self.position)\n        self.position.sort()\n        left = 1\n        right = self.position[-1] - self.position[0] + 1\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if self.feasible(mid, m):\n                left = mid\n            else:\n                right = mid\n        return left", "class Solution:\n    def maxDistance(self, pos: List[int], m: int) -> int:\n        pos.sort()\n        n = len(pos)\n        if m == 2: return pos[-1] - pos[0]\n        \n        def valid(k):\n            count, cur = 1, pos[0]\n            for p in pos[1:]:\n                if p - cur >= k:\n                    count += 1\n                    cur = p\n            return count >= m\n        \n        l, r = 0, pos[-1] - pos[0]\n        ans = 0\n        while l < r:\n            mid = (l + r) // 2\n            if valid(mid):\n                ans = max(ans, mid) \n                l = mid + 1\n            else:\n                r = mid\n        return ans\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        \n        def isvalid(gap, m):\n            j = 0\n            for i in range(len(position)):\n                if(position[i]-position[j]>=gap):\n                    m -= 1\n                    j = i\n                    if m == 0:\n                        return True\n            return False\n        \n        low, high = 1, position[-1]\n        sem = 0\n        while(low<=high):\n            mid = (high + low)//2\n            if isvalid(mid, m-1):\n                sem = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return sem\n        \n        \n        \n        \n        \n        \n        \n            \n        \n        \n        \n", "class Solution:\n    def maxDistance(self, pos: List[int], m: int) -> int:\n        pos.sort()\n        def isfeasible(dist):\n            cur = pos[0]\n            n = 1\n            for i in range(len(pos)):\n                if pos[i] >= cur + dist:\n                    cur = pos[i]\n                    n += 1\n            return n>=m\n        ng = pos[-1] - pos[0] + 1\n        ok = 1\n        while abs(ok-ng)>1:\n            mid = ok + (ng-ok)//2\n            if isfeasible(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position.sort()\n        ## need to find the maximum minmum distance \n        ## feasibility is a function of distance\n        ## need to find the last feasible solution \n        ## that is the last T \n        \n        def check (dist: int) -> bool:\n            \n            curr = position[0]\n            count = 1 \n            \n            for i in range (len(position)):\n                \n                #print(abs(position[i]-curr))\n                \n                if (abs(position[i]-curr)>= dist):\n                    \n                    curr = position[i]\n                    count +=1\n                    \n                if(i == (len(position)-1)):\n                    \n                    if (count >= m):\n                        return True \n                    else:\n                        return False \n                    \n        \n        ## BS for optimal length \n        \n        lo = 1\n        hi = (max(position)- min(position))\n        \n        while (lo<hi):\n            \n            mid= lo + ((hi-lo+1)//2)\n            #print(mid)\n            \n            if(check(mid)):\n                \n                lo = mid \n            \n            else : \n                hi = mid -1 \n                \n        \n        return (lo)\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "def isPossible(arr, n, C, mid):\n    magnet = 1\n    currPosition = arr[0]\n    for i in range(1, n): \n        if (arr[i] - currPosition >= mid):\n            magnet += 1\n            currPosition = arr[i]\n            if (magnet == C):\n                return True\n    return False\n\ndef binarySearch(n, C, arr):\n    arr.sort(reverse = False) \n    lo = 0\n    hi = arr[n - 1] \n    ans = 0\n    while (lo <= hi):\n        mid = int((lo + hi) / 2)\n        if (isPossible(arr, n, C, mid) == False): \n            hi = mid - 1\n        else: \n            ans = max(ans, mid) \n            lo = mid + 1\n    return ans \n\nclass Solution:\n    def maxDistance(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        return binarySearch(n, k, arr)\n", "class Solution:\n    def maxDistance(self, pos: List[int], m: int) -> int:\n        pos.sort()\n        n = len(pos)\n                \n        l = 1\n        r = 10 ** 9\n#         def isOK(gap):\n#             i = 0\n#             ii = 0\n#             nn = 1\n#             while i < n:\n#                 if pos[i] - pos[ii] >= gap:\n#                     nn += 1\n#                     ii = i\n#                 i += 1\n#             return nn >= m\n        \n#         while l < r:\n#             mid = (l + r + 1) // 2\n#             if isOK(mid):\n#                 l = mid\n#             else:\n#                 r = mid - 1 \n#         return l\n    \n        def isNotOK(gap):\n            i = 0\n            ii = 0\n            nn = 1\n            while i < n:\n                if pos[i] - pos[ii] >= gap:\n                    nn += 1\n                    ii = i\n                i += 1\n            return nn < m\n        \n        # find the smallest unvalid solve then minus 1\n        while l < r:\n            mid = (l + r) // 2\n            if isNotOK(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l - 1\n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position.sort()\n        ## need to find the maximum minmum distance \n        ## feasibility is a function of distance\n        ## need to find the last feasible solution \n        ## that is the last T \n        \n        def check (dist: int) -> bool:\n            \n            curr = position[0]\n            count = 1 \n            \n            for i in range (len(position)):\n                \n                #print(abs(position[i]-curr))\n                \n                if (abs(position[i]-curr)>= dist):\n                    \n                    curr = position[i]\n                    count +=1 \n                \n                if(i == (len(position)-1)):\n                    \n                    if (count >= m):\n                        return True \n                    else:\n                        return False \n                    \n        \n        ## BS for optimal length \n        \n        lo = 1\n        hi = (max(position)- min(position))\n        \n        while (lo<hi):\n            \n            mid= lo + ((hi-lo+1)//2)\n            #print(mid)\n            \n            if(check(mid)):\n                \n                lo = mid \n            \n            else : \n                hi = mid -1 \n                \n        \n        return (lo)\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        l, r, res = 0, max(position), 0\n        position.sort()\n        while l < r:\n            mid = l + (r - l) // 2\n            i, cnt = 0, 1\n            while i < len(position):\n                j = i + 1\n                while j < len(position):\n                    if position[j] - position[i] >= mid:\n                        cnt += 1\n                        break\n                    j += 1\n                i = j\n                if cnt == m:\n                    break\n            if cnt == m:\n                l = mid + 1\n                res = max(res, mid)\n            else:\n                r = mid\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        left , right = 0, position[-1] - position[0]\n        while left <= right:\n            mid = (left + right) // 2\n            count = 1\n            curr = position[0]\n            for x in position[1:]:\n                if x - curr >= mid:\n                    count += 1\n                    curr = x\n            if count >= m:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right", "from math import floor\n\nclass Solution:\n    def is_min_dis_possible(self, positions, m, min_dis):\n        prev = 0\n        cur = 0\n\n        while m > 0:\n            m -= 1\n\n            while cur < len(positions) and positions[cur] - positions[prev] < min_dis:\n                cur += 1\n\n            if cur >= len(positions):\n                break\n\n            prev = cur\n\n        return True if m == 0 else False\n\n    def maxDistance(self, position, m):\n        position_sorted = sorted(position)\n        high = position_sorted[-1]\n        low = 0\n\n        while low <= high:\n            mid = floor((high + low) / 2)\n            if mid == low:\n                break\n\n            is_min_dis_possible = self.is_min_dis_possible(position_sorted, m, mid)\n            if is_min_dis_possible:\n                low = mid\n            else:\n                high = mid\n\n        return low", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def possible(d):\n            cnt = 1\n            cur = position[0]\n            for i in range(1, len(position)):\n                if position[i] - cur >= d:\n                    cnt += 1\n                    cur = position[i]\n                if cnt >= m:\n                    return True\n            return False\n        \n        lo = 0\n        hi = position[-1] - position[0]\n        while lo < hi:\n            mid = hi - (hi - lo) // 2\n            if possible(mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        return lo", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def valid(dis):\n            prev = 0\n            balls = 1\n            for i in range(1, n):\n                if position[i] - position[prev] >= dis:\n                    balls += 1\n                    prev = i\n            return balls >= m\n        \n        lo, hi = 0, position[-1] - position[0]\n        while lo < hi:\n            mid = lo + (hi - lo + 1) // 2\n            if valid(mid):\n                lo = mid\n            else:\n                hi = mid - 1\n        return lo", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # \u4e8c\u5206\u67e5\u627e\n        # \u5224\u65ad\u82e5x\u4e3a\u6700\u5c0f\u78c1\u529b,\u80fd\u5426\u5206\u9694\u51fam-1\u4e2a\u95f4\u9694\n        def Valid(x):\n            ans = 0\n            target = position[0]\n            for i in range(1,len(position)):\n                if position[i] - target >= x:\n                    ans += 1\n                    target = position[i]\n            return ans >= m - 1\n        position.sort()\n        l,r = min(position[i + 1] - position[i] for i in range(len(position) - 1)),(position[-1] - position[0]) // (m - 1)\n        while l <= r:\n            mid = l + (r - l) // 2\n            # \u82e5\u6700\u5c0f\u78c1\u529b\u53ef\u4ee5\u5206\u6210m-1\u4e2a\u95f4\u9694,\u5219\u53ef\u80fd\u5b58\u5728\u66f4\u5927\u503c,\u5426\u5219\u6700\u5c0f\u78c1\u529b\u503c\u5e94\u5f53\u66f4\u5c0f\n            if Valid(mid):\n                l = mid+1\n            else:\n                r = mid - 1\n        return l-1\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        lo, hi = 0, position[-1] - position[0]\n        \n        def possible(target, m):\n            idx = prev = 0            \n            while m:\n                if idx >= len(position):\n                    return False\n                if not prev or position[idx] >= prev + target:\n                    m -= 1\n                    prev = position[idx]\n                else:\n                    idx += 1\n            return True\n                \n        \n        while lo <= hi:\n            mid = (lo + hi) >> 1\n            if possible(mid, m):\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        \n        return lo - 1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def feasible(min_req_dist, b):\n            i = 0\n            prev_pos = None\n            while i < len(position) and b > 0:\n                if prev_pos == None or position[i] - prev_pos >= min_req_dist:\n                    b -= 1\n                    prev_pos = position[i]\n                i += 1\n            return b == 0\n        \n        position.sort()\n        n = len(position)\n        low = 1\n        high = position[-1]\n        while low < high:\n            mid = (low + high) // 2 + 1\n            if feasible(mid, m):\n                low = mid\n            else:\n                high = mid - 1\n        return low\n                \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        start, end = 0, position[-1]\n    \n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.isValid(position, mid) < m:\n                end = mid\n            else:\n                start = mid\n                \n        if self.isValid(position, end) < m:\n            return start\n        else:\n            return end\n        \n        \n    def isValid(self, position, dist):\n        cnt = 1\n        i = 1\n        current = position[0] + dist\n        while i < len(position):\n            if position[i] >= current:\n                cnt += 1\n                current = position[i] + dist\n            i += 1\n        return cnt\n        \n            \n\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def feasible(d, position):\n            # print(\\\"Check d: \\\", d)\n            balls = [position[0]]\n            placed = 1\n            i = 1\n            while i <= len(position) - 1:\n                if position[i] - balls[-1] >= d:\n                    balls.append(position[i])\n                    # print(balls)\n                    placed += 1\n                    if placed == m:\n                        return True\n                i += 1 \n            return False\n        \n        position.sort()\n        \n        left, right = 1, max(position)\n                \n        while left < right:\n            mid = right - (right - left) // 2\n            if feasible(mid, position):\n                left = mid \n            else:\n                right = mid - 1\n        return left", "class Solution:\n    def isSolution(self, m, position, minforce):\n        index = 0\n        remaining = m\n        for bin in position:\n            if bin >= index:\n                remaining-=1\n                index = bin + minforce\n            if remaining == 0:\n                return True\n        return False\n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        maxDist = position[-1]\n        minDist = 0\n        while maxDist > minDist + 1:\n            average = (minDist + maxDist) // 2\n            #print (\\\"average \\\", average)\n            if Solution.isSolution (self, m, position, average):\n                #print (\\\"is Sol\\\")\n                minDist = average\n            else:\n                maxDist = average  \n                #print (\\\"not Sol\\\")\n        if Solution.isSolution (self, m, position, maxDist):\n            return maxDist\n        else:\n            return minDist\n            \n            \n             \n            \n            \n", "class Solution:\n    def maxDistance(self, pos: List[int], m: int) -> int:\n        pos.sort()\n        n = len(pos)\n#         def check(gap):\n#             i = 0\n#             ii = 0\n#             nn = 1\n#             while i < n:\n#                 if pos[i] - pos[ii] >= gap:\n#                     nn += 1\n#                     ii = i\n#                 i += 1\n#             return nn >= m\n        \n#         l = 1\n#         r = 10 ** 9\n        \n#         while l < r:\n#             mid = (l + r + 1) // 2\n#             if check(mid):\n#                 l = mid\n#             else:\n#                 r = mid - 1 \n#         return l\n    \n        def isNotOK(gap):\n            i = 0\n            ii = 0\n            nn = 1\n            while i < n:\n                if pos[i] - pos[ii] >= gap:\n                    nn += 1\n                    ii = i\n                i += 1\n            return nn < m\n        \n        l = 1\n        r = 10 ** 9\n        \n        while l < r:\n            mid = (l + r) // 2\n            if isNotOK(mid):\n                r = mid\n            else:\n                l = mid + 1 \n        return l - 1\n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        \n        def check(min_force):\n            count = 1\n            k = position[0]\n            for n in position:\n                if n-k >= min_force:\n                    count += 1\n                    k = n\n                    if count >= m:\n                        return True\n            return False\n        \n        \n        i, j = 1, position[-1]-position[0]\n        while i <= j:\n            mid = (i+j)//2\n            c1 = check(mid)\n            c2 = check(mid+1)\n            if c1 and not c2:\n                return mid\n            if not c1:\n                j = mid-1\n            else:\n                i = mid+1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r = 0, position[-1] - position[0] + 1\n        \n        def c(x):\n            y = m\n            y -= 1\n            last = 0\n            j = 0\n            for _ in range(y):\n                while j < len(position) and position[j] - position[last] < x:\n                    j += 1\n                if j == len(position):\n                    # print(j, last, x)\n                    return 0\n                last = j\n            return 1\n        \n        while l < r:\n            mid = (r+l)//2\n            dist = c(mid)\n            # print('len', mid, l, r, dist)\n            if not dist:\n                r = mid\n            else:\n                l = mid+1\n        return l-1", "class Solution:\n    \n        \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def f(mid,position,m):\n            f=position[0]\n            m=m-1\n            for j in range(1,len(position)):\n                if position[j]-f>=mid:\n                    f=position[j]\n                    m=m-1\n                if m<0:\n                    break\n            if m<=0:\n                return True\n            return False\n        h=(position[-1]-position[0])//(m-1)+1\n        l=0\n        while h>=l:\n            mid=(h+l)//2\n            \n            print(mid)\n            if f(mid,position,m):\n                l=mid+1\n            else:\n                h=mid-1\n        return l-1", "class Solution:\n    def maxDistance(self, positions: List[int], m: int) -> int:\n        \n        positions.sort()\n               \n        def possible(positions,m,v):\n            \n            cur=0\n            for i in range(1,len(positions)):\n                if positions[i]-positions[cur]>=v:\n                    m-=1\n                    cur=i\n                    if m==1: return True            \n            return m<=1\n\n        \n        left,right=1,positions[-1]-positions[0]\n        ans=0\n        while left<=right:\n            \n            v=(left+right)//2\n            if possible(positions,m,v):\n                ans=v\n                left=v+1\n            else:\n                right=v-1\n        \n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        high=position[-1]-position[0]\n        low = high\n        for i in range(1, len(position)):\n            low = min(low, position[i]-position[i-1])\n        \n        def feasible(force):\n            last = position[0]\n            count=1\n            for i in range(1,len(position)):\n                if (position[i]-last)>=force:\n                    last=position[i]\n                    count+=1\n            if count >= m:\n                return True\n            return False\n        \n        while low < high:\n            mid = (low+high)//2\n            if not feasible(mid):\n                high=mid\n            else:\n                low=mid+1\n        low-=1\n        ans=float('inf')\n        last=position[0]\n        for i in range(1, len(position)):\n            if (position[i]-last)>=low:\n                ans=min(ans, position[i]-last)\n                last=position[i]\n        \n        return ans\n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        n = len(position)\n        position.sort()\n\n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n\n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n\n        print(l)\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def valid_distance(d):\n            cur, idx, total = 0, 1, 1\n            \n            while idx < len(position) and total < m:\n                if position[idx] - position[cur] >= d:\n                    total += 1\n                    cur = idx\n                idx += 1\n            return total == m\n        \n        position.sort()\n        s, e= 0, position[-1] - position[0] + 1\n        \n        while s < e:\n            mid = s + (e - s) // 2\n            if valid_distance(mid):\n                s = mid + 1\n            else:\n                e = mid\n        return s - 1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def isfail(mid):\n            ans = 1\n            curr = position[0] # alike greedy idea, we just put the first ball at position 0!\n            for i in range(1, n):\n                if position[i] - curr >= mid:\n                    ans += 1\n                    curr = position[i]\n            return ans < m\n        \n        left = 0 \n        right = max(position) - min(position) + 1\n        while left < right:\n            mid = (left+right)//2\n            if isfail(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left - 1 # left is the min value to fail, so left-1 is the max value to succeed!\n        # \u56e0\u4e3a\u6c42\u7684\u662f\u6700\u5927\u503c\uff01\u6240\u4ee5\u9700\u8981\u5de7\u5999\u4f7f\u7528binary search!\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position = sorted(position)\n        lo = 1\n        hi = position[-1]-position[0]\n        \n        while lo<hi:\n            \n            mid = (lo+hi+1)//2\n            \n            # count number of balls that can be placed if distance at least mid\n            ind1 = 0\n            ind2 = 1\n            count = 1\n            while ind2<len(position) and count<m:\n                \n                if position[ind2]-position[ind1]>=mid:\n                    count += 1\n                    ind1 = ind2\n                    \n                ind2 += 1\n                \n            if count>=m:\n                lo = mid\n            else:\n                hi = mid-1\n        \n        return lo", "from functools import lru_cache\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        if m == 2:\n            return position[-1] - position[0]\n        \n        def can_place(mid): # mid is candidate for minimum magnetic force\n            num_placed = 1\n            prev = position[0]\n            \n            for num in position[1:]:\n                if num - prev >= mid:\n                    num_placed += 1\n                    prev = num\n\n            return num_placed >= m  \n        \n        left = 0\n        right = position[-1] - position[0]\n        \n        res = 0\n        while left < right:\n            mid = (left + right) // 2\n\n            if can_place(mid):\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left - 1\n        \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def feasible(min_req_dist, b):\n            i = 0\n            prev_pos = None\n            while i < len(position) and b > 0:\n                if prev_pos == None or position[i] - prev_pos >= min_req_dist:\n                    b -= 1\n                    prev_pos = position[i]\n                i += 1\n            return b == 0\n        \n        # This is a fantastic example of establishing a monotonic predicate and \n        # squeeze from the right side of the search space (instead of the usual left-side)\n        position.sort()\n        low = 1\n        high = position[-1]\n        while low < high:\n            # Since we constantly trying to see if we could find a feasible solution that's\n            # greater than the current one, we want to always make progress by advancing\n            # mid to the right. (low + high) // 2 + 1 guarantees this, even when we have\n            # just two elements. mid will be pointing at high. Otherwise we'd get an infinite\n            # loop with (low + high) // 2\n            mid = (low + high) // 2 + 1\n            if feasible(mid, m):\n                low = mid\n            else:\n                high = mid - 1\n        return low\n                \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def distributable(n):\n            pos = len(position) - 1\n            balls = m\n            while pos >= 0 and balls:\n                balls -= 1\n                np = position[pos] - n\n                while pos >= 0 and position[pos] > np:\n                    pos -= 1\n            return not balls       \n        position = sorted(position)\n        lo, hi = 1, (position[-1] - position[0]) // (m -1) + 1\n        ans = lo\n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if distributable(mid):\n                ans = mid\n                lo = mid + 1\n            else:\n                hi = mid\n        return ans ", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def trial(n):\n            prev, curr, ct = 0, 1, 1\n            while True:\n                if curr >= len(position):\n                    return False\n                if position[curr] - position[prev] >= n:\n                    prev = curr\n                    ct += 1\n                if ct == m:\n                    return True\n                curr += 1\n        \n        l, r = 1, position[-1] - position[0] + 1\n        ret = 0\n        while l < r:\n            mid = (l + r) // 2\n            ans = trial(mid)\n            if ans:\n                l = mid + 1\n            else:\n                r = mid\n        return r - 1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position.sort()\n        \n        def ispossible(f: int) -> bool:\n            Count, pos = 1, 0\n            \n            for i in range(1, len(position)):\n                \n                if position[i]  - position[pos] >= f:\n                    pos = i\n                    Count += 1\n                    \n            return bool(Count >= m)\n        \n        start, end = 1, position[-1] - position[0]\n        \n        while start < end:\n            \n            mid = (start + end)//2\n            if ispossible(mid) and not ispossible(mid + 1): return mid\n            elif ispossible(mid): start = mid + 1\n            else: end = mid - 1\n                \n        return start\n        \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        @lru_cache(None)\n        def helper(gap):\n            prev = 0\n            cnt = 1\n            while cnt < m:\n                idx = prev + 1\n                while idx < len(position) and position[idx] - position[prev] < gap:\n                    idx += 1\n                if idx >= len(position): break    \n                prev = idx\n                cnt += 1\n            return cnt == m\n        \n        lb, ub = 1, position[-1] - position[0] + 1\n        while lb < ub:\n            mid = lb + (ub - lb)//2\n            if helper(mid):\n                if not helper(mid + 1): return mid\n                else: lb = mid + 1\n            else: ub = mid\n                \n        return lb", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        high = position[-1] - position[0]\n        low = 1\n        while high != low:\n            mid = (high + low + 1) // 2\n            balls = 1\n            start = position[0]\n            for i in range(1, n):\n                if position[i] - start >= mid:\n                    balls += 1\n                    start = position[i]\n            if balls >= m:\n                low = mid\n            else:\n                high = mid - 1\n        return low\n            \n            \n\n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        left, right = 1, (position[-1]-position[0])//(m-1) + 2 \n        while left < right:\n            mid = left + (right-left)//2 + 1\n            \n            if self.can_use_as_min(position, mid, m):\n                left = mid\n            else:\n                right = mid-1\n            \n        return left    \n    \n    def can_use_as_min(self, position, min_distance, m):\n        m -= 1\n        i = 1    \n        last_position = position[0] \n        \n        while m > 0:\n            while position[i] - last_position < min_distance:\n                i += 1\n                \n                if i >= len(position):\n                    return False\n                \n            last_position = position[i]    \n            m -= 1\n        \n        return True ", "import bisect\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        pos = sorted(position)\n        if m == 2:\n            return pos[-1] - pos[0]\n        \n        def isFeasible(d):\n            j = 0\n            for k in range(1, m):\n                j = bisect.bisect_left(pos, pos[j] + d, j + 1)\n                if j == n:\n                    return False\n            return True\n        \n        res = -1\n        lo, hi = 1, pos[-1] - pos[0] + 1\n        while lo < hi: \n            d = (lo + hi) // 2\n            print(lo, hi, d)\n            if isFeasible(d):\n                lo = d + 1\n            else: \n                hi = d\n        return hi - 1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r, sol = 0, position[-1] - position[0], -1\n        \n        def helper(target):\n            pre, cnt = position[0], 1\n            \n            for n in position:\n                temp = n - pre\n                \n                if temp >= target: \n                    cnt += 1\n                    pre = n                    \n                                                            \n            if (position[-1] - pre) >= target: cnt += 1\n                \n            if cnt >= m: return True\n            \n            return False\n            \n        while l <= r:\n            mid = (l + r) // 2\n            \n            if (helper(mid)):\n                l = mid + 1\n                \n            else:\n                r = mid - 1\n                \n        return l - 1\n            \n            \n                \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position.sort()\n        L = len(position)\n        \n        left = 1\n        right = position[-1]-position[0]\n        \n        def can_place(f):\n            n_ball = m-1\n            cum_dis = 0\n            p = 1\n            #n_ball -= 1\n            while n_ball >0 and p<L :\n                cum_dis += position[p]-position[p-1]\n                if cum_dis >= f:\n                    n_ball -= 1\n                    cum_dis = 0\n                p += 1\n            \n            if n_ball == 0:\n                return True\n            else:\n                return False\n                    \n                \n        #return can_place(4)\n        # 1, 9, 5 false\n        # 1, 4, 2, true\n        # 2, 4, 3, true\n        # 3, 4, 3,\n        \n        while left < right:\n            mid = (left+right)//2\n            if can_place(mid):\n                left = mid\n            else:\n                right = mid-1\n            if right-left == 1:\n                if can_place(right):\n                    return right\n                else:\n                    return left\n\n        \n        #return can_place(3)\n        return left\n            \n#         if m == 2:\n#             return position[-1] - position[0]\n        \n#         L = len(position)\n        \n#         hp = []\n#         f_set = {}\n#         b_set = {}\n#         for i in range(L-1):\n#             heapq.heappush(hp, (position[i+1]-position[i], position[i], position[i+1]))\n#             f_set[position[i]] = position[i+1]\n#             b_set[position[i+1]] = position[i]\n        \n#         total = L-1\n        \n#         while total > m-1:\n#             l, x, y = heapq.heappop(hp)\n#             if x in f_set and y in b_set and f_set[x] == y and b_set[y] == x:\n#                 left_len = float(inf)\n#                 right_len = float(inf)\n#                 if y in f_set:\n#                     right_len = f_set[y]-y\n#                 if x in b_set:\n#                     left_len = x-b_set[x]\n#                 if left_len < right_len:\n#                     #merge with left\n#                     new_y = y\n#                     new_x = b_set[x]\n#                     del f_set[x]\n#                     del b_set[x]\n#                     f_set[new_x] = new_y\n#                     b_set[new_y] = new_x\n#                     ret = new_y - new_x\n#                 else:\n#                     # merge with right\n#                     new_y = f_set[y]\n#                     new_x = x\n#                     del f_set[y]\n#                     del b_set[y]\n#                     f_set[new_x] = new_y\n#                     b_set[new_y] = new_x\n#                     ret = new_y - new_x\n#                 heapq.heappush(hp, (new_y-new_x, new_x, new_y))\n#                 total -= 1\n        \n#         ret = float(inf)\n#         for k in f_set.keys():\n#             ret = min(ret, f_set[k]-k)\n        \n#         return f_set\n                         \n            \n        \n        \n            \n", "class Solution:\n    def maxDistance(self, A, m: int) -> int:\n        \n        \n        A.sort()\n        \n        def test(mid):\n            cnt = m - 1\n            cur = A[0]\n            for i in A[1:]:\n                if i - cur >= mid:\n                    cnt -= 1\n                    cur = i\n                else:\n                    continue\n                if cnt == 0: return True\n            return False\n        \n        mi = 1\n        ma = (A[-1] - A[0]) // (m - 1)\n        while mi <= ma:\n            mid = (mi + ma) // 2\n            if test(mid):\n                mi = mid + 1\n            else:\n                ma = mid - 1\n        return ma", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        minp, maxp = position[0], position[-1]\n        lo, hi = 1, (maxp - minp) // (m -1) + 1\n        ans = lo\n        def distributable(n):\n            pos = position.copy()\n            balls = m\n            while pos and balls:\n                balls -= 1\n                np = pos[-1] - n\n                while pos and pos[-1] > np:\n                    pos.pop()\n            return not balls       \n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if distributable(mid):\n                ans = mid\n                lo = mid + 1\n            else:\n                hi = mid\n        return ans        ", "class Solution:\n    def maxDistance(self, position: List[int], cuts: int) -> int:\n        position = sorted(position)\n        l, r = 1, position[-1] - position[0]\n        while l != r:\n            m = (l + r) // 2 + 1\n            if self.isValid(position, m, cuts):\n                l = m\n            else:\n                r = m - 1\n        return l\n\n    def isValid(self, position, force, cuts):\n        c = 0\n        l = 0\n        for r in range(1, len(position)):\n            if position[r] - position[l] >= force:\n                c += 1\n                l = r\n        return c >= cuts-1", "class Solution:\n    def maxDistance(self, p: List[int], m: int) -> int:\n        n=len(p)\n        p.sort()\n        def check(x):\n            st=p[0]\n            cnt=1\n            for i in range(1,n):\n                if abs(p[i]-st)>=x:\n                    st=p[i]\n                    cnt+=1 \n            return cnt>=m\n        lo=1\n        hi=max(p)+4\n        print(check(999999999))\n        while lo<=hi:\n            mi=(lo+hi)//2\n            if check(mi):\n                ans=mi \n                lo=mi+1 \n            else:\n                hi=mi-1 \n            #print(mi,check(mi))\n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # binary search\n        def isValid(f, k):\n            # return true if it is possible to arrange m elements in array such that minimum distance is f\n            pos = position[0]\n            count = 1\n            for i in range(1, n):\n                if (position[i] - pos >= f):\n                    # put it here\n                    pos = position[i]\n                    count += 1\n                    \n                    if count == k:\n                        return True\n                    \n            return False\n        \n        n = len(position)\n        position.sort()\n        res = 0\n        \n        l, r = 0, position[n-1] - position[0] + 1\n        while l < r:\n            mid = (l+r) >> 1\n            if isValid(mid, m):\n                res = max(res, mid)\n                l = mid + 1\n                \n            else:\n                r = mid\n                \n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position.sort()\n        ## need to find the maximum minmum distance \n        ## feasibility is a function of distance\n        ## need to find the last feasible solution \n        ## that is the last T \n        \n        def check (dist: int) -> bool:\n            \n            curr = position[0]\n            count = 1 \n            \n            for i in range (len(position)):\n                \n                #print(abs(position[i]-curr))\n                \n                if (abs(position[i]-curr)>= dist):\n                    \n                    curr = position[i]\n                    count +=1 \n                    \n                    if (count>=m):\n                        return True \n                    \n                    \n                if(i == (len(position)-1)):\n                    \n                    if (count >= m):\n                        return True \n                    else:\n                        return False \n                    \n        \n        ## BS for optimal length \n        \n        lo = 1\n        hi = (max(position)- min(position))\n        \n        while (lo<hi):\n            \n            mid= lo + ((hi-lo+1)//2)\n            #print(mid)\n            \n            if(check(mid)):\n                \n                lo = mid \n            \n            else : \n                hi = mid -1 \n                \n        \n        return (lo)\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def possible(mid):\n            temp = m-1\n            prev = position[0]\n            for i in range(len(position)):\n                if(position[i] - prev>=mid):\n                    prev = position[i]\n                    temp-=1\n            return(temp<=0)\n        l,r = 0,max(position)\n        position.sort()\n        while(l<r):\n            mid = (l+r)//2\n            print((l,mid,r))\n            if(r == l+1):\n                if(possible(r)):\n                    l = r\n                else:\n                    r = l\n                break\n            if(possible(mid)):\n                l = mid\n            else:\n                r = mid - 1\n        return(l)\n        \n", "class Solution:\n    def maxDistance(self, arr: List[int], m: int) -> int:\n        arr.sort()\n        \n        def isFeasible(mid): \n            pos = arr[0] \n\n            # Initialize count of elements placed. \n            elements = 1\n\n            # Try placing k elements with minimum \n            # distance mid. \n            for i in range(1, len(arr)): \n                if (arr[i] - pos >= mid): \n\n                    # Place next element if its distance  \n                    # from the previously placed element \n                    # is greater than current mid \n                    pos = arr[i] \n                    elements += 1\n\n                    # Return if all elements are placed \n                    # successfully \n                    if (elements == m): \n                        return True\n            return 0\n  \n        \n        hi = arr[-1] - arr[0]\n        lo = float('inf')\n        for i in range(len(arr)-1):\n            lo = min(lo, arr[i+1]-arr[i])\n        \n        ans = float('-inf')\n        \n        while lo<=hi:\n            mid = (lo+hi)//2\n            if isFeasible(mid):\n                ans = max(ans, mid)\n                lo = mid+1\n            else:\n                hi = mid-1\n        \n        return ans\n    \n    \n    \n                \n   \n        \n        \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        def maxNumberBallsCanBePlaced(minDis):\n            count = 1\n            end = position[0]\n            for i in range(len(position)):\n                if(position[i] - end >= minDis):\n                    end = position[i]\n                    count += 1\n            return count\n        \n        position.sort()\n        left = 1\n        right = position[-1]\n        while(left < right):\n            mid = left + (right - left) // 2\n            \n            if(maxNumberBallsCanBePlaced(mid) >= m):\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left - 1\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        size = len(position)\n        \n        # --------------------------------------------\n        def satisfy( gap ) -> bool:\n            '''\n            input: gap\n            output: True, if m balls can be placed with distance >= gap.\n                    False, otherwise.\n            '''\n            \n            next_valid_pos = position[0] + gap\n            \n            # start from smallest position\n            good_positions = 1\n            \n            for idx in range(1, size):\n                \n                if position[idx] >= next_valid_pos:\n                    good_positions += 1\n                    next_valid_pos = position[idx] + gap\n                \n                if good_positions == m:\n                    return True\n            \n            return False\n        \n        # --------------------------------------------\n        \n        # preprocessing, keep it sorted in ascending order\n        position.sort()\n        \n        # maximum gap between two balls\n        max_gap = (position[-1] - position[0]) // (m - 1)\n        \n        # minimum gap between two balls\n        min_gap = min( position[i] - position[i-1] for i in range(1, size) )\n        \n        \n        \n        if m == 2:\n            \n            # Quick response for simple case\n            return max_gap\n        \n        \n        \n        # launch binary search to find optimal gap\n        left, right = min_gap, max_gap\n        \n        while left <= right:\n            \n            gap_trial = left + (right - left) // 2\n            \n            if satisfy(gap=gap_trial):\n                \n                # m balls can be placed with gap_trial\n                # make gap_trial larger, and try again\n                left = gap_trial + 1\n                \n            else:\n\n                # m balls cannot be placed with gap_trial\n                # make it smaller, and try again\n                right = gap_trial - 1\n        \n        \n        # because left = gap_trial + 1\n        # left - 1 is the optimal gap\n        return left-1\n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def valid(dis):\n            count = 1\n            prev = position[0]\n            for n in position:\n                if n-prev >= dis:\n                    count += 1\n                    prev = n\n                if count == m: return True\n            return False\n        \n        l, r = 0, position[-1]\n        ret = 0\n        # print(position, l, r)\n        while l < r:\n            mid = l + (r-l)//2\n            # print(l, r, mid)\n            if valid(mid):\n                ret = max(ret, mid)\n                l = mid+1\n            else:\n                r = mid\n        return ret", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def trial(n):\n            prev, curr, ct = 0, 1, 1\n            while True:\n                if curr >= len(position):\n                    return False\n                if position[curr] - position[prev] >= n:\n                    prev = curr\n                    ct += 1\n                if ct == m:\n                    return True\n                curr += 1\n        \n        l, r = 1, position[-1] - position[0] + 1\n        ret = 0\n        while l < r:\n            mid = (l + r + 1) // 2\n            ans = trial(mid)\n            if ans:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position.sort()\n        L = len(position)\n        \n        left = 1\n        right = position[-1]-position[0]\n        \n        def can_place(f):\n            n_ball = m-1\n            cum_dis = 0\n            p = 1\n            #n_ball -= 1\n            while n_ball >0 and p<L :\n                cum_dis += position[p]-position[p-1]\n                if cum_dis >= f:\n                    n_ball -= 1\n                    cum_dis = 0\n                p += 1\n            \n            if n_ball == 0:\n                return True\n            else:\n                return False\n                    \n                \n        #return can_place(4)\n        # 1, 9, 5 false\n        # 1, 4, 2, true\n        # 2, 4, 3, true\n        # 3, 4, 3,\n        \n        while left < right:\n            mid = right- (-left+right)//2\n            #mid = (left+right)//2\n            if can_place(mid):\n                left = mid\n            else:\n                right = mid-1\n            # if right-left == 1:\n            #     if can_place(right):\n            #         return right\n            #     else:\n            #         return left\n\n        \n        #return can_place(3)\n        return left\n            \n#         if m == 2:\n#             return position[-1] - position[0]\n        \n#         L = len(position)\n        \n#         hp = []\n#         f_set = {}\n#         b_set = {}\n#         for i in range(L-1):\n#             heapq.heappush(hp, (position[i+1]-position[i], position[i], position[i+1]))\n#             f_set[position[i]] = position[i+1]\n#             b_set[position[i+1]] = position[i]\n        \n#         total = L-1\n        \n#         while total > m-1:\n#             l, x, y = heapq.heappop(hp)\n#             if x in f_set and y in b_set and f_set[x] == y and b_set[y] == x:\n#                 left_len = float(inf)\n#                 right_len = float(inf)\n#                 if y in f_set:\n#                     right_len = f_set[y]-y\n#                 if x in b_set:\n#                     left_len = x-b_set[x]\n#                 if left_len < right_len:\n#                     #merge with left\n#                     new_y = y\n#                     new_x = b_set[x]\n#                     del f_set[x]\n#                     del b_set[x]\n#                     f_set[new_x] = new_y\n#                     b_set[new_y] = new_x\n#                     ret = new_y - new_x\n#                 else:\n#                     # merge with right\n#                     new_y = f_set[y]\n#                     new_x = x\n#                     del f_set[y]\n#                     del b_set[y]\n#                     f_set[new_x] = new_y\n#                     b_set[new_y] = new_x\n#                     ret = new_y - new_x\n#                 heapq.heappush(hp, (new_y-new_x, new_x, new_y))\n#                 total -= 1\n        \n#         ret = float(inf)\n#         for k in f_set.keys():\n#             ret = min(ret, f_set[k]-k)\n        \n#         return f_set\n                         \n            \n        \n        \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r = 1, position[-1]-position[0]\n        while l<r:\n            mid = l+(r-l+1)//2\n            placefind = 1\n            preIndex = 0\n            for i in range(1, len(position)):\n                if position[i]-position[preIndex]>=mid:\n                    placefind += 1\n                    preIndex = i\n            if placefind >= m:\n                l = mid\n            else:\n                r = mid-1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        lo=0   \n        hi=position[-1]-position[0]\n        n=len(position)\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n                    \n            \n        while lo<hi:\n            mid= (lo+hi+1)//2\n            res=count(mid)\n            if res>=m:\n                lo=mid\n            elif res<m:\n                hi=mid-1\n        return lo\n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n\n        def check(space):\n            count = start = 0\n            for i in range(1, len(position)):\n                if position[i] - position[start] >= space:\n                    count += 1\n                    start = i\n            print(space, count)\n            return count >= m - 1\n\n        def find_space(lo, hi):\n            while lo < hi:\n                mid = int((lo / 2) + (hi / 2))\n                if check(mid) and not check(mid + 1):\n                    return mid\n                if check(mid):\n                    lo = max(mid, lo + 1)\n                else:\n                    hi = mid\n            hi -= 1\n            while check(hi):\n                hi += 1\n            return hi - 1\n\n        position.sort()\n        return find_space(1, position[-1] - position[0])", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r = 1, 10**9\n        while l < r:\n            mid = (l+r+1)//2\n            count = 1\n            prev = position[0]\n            for i in range(1, len(position)):\n                if position[i] - prev >= mid:\n                    count += 1\n                    prev = position[i]\n            \n            \n            if count >= m :\n                l = mid\n            else:\n                r = mid-1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def is_feasible(force):\n            count = 1\n            cur = position[0]\n            for i in range(1, n):\n                # print(position[i], cur)\n                if position[i] - cur >= force:\n                    count += 1\n                    cur = position[i]\n            return count >= m\n        \n        l = 1\n        r = position[-1] - position [0] + 1\n        while l < r:\n            med = (l + r) // 2\n            if is_feasible(med):\n                l = med + 1\n            else:\n                r = med\n        return l - 1\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # \u4e8c\u5206\u67e5\u627e\n        # \u5224\u65ad\u82e5x\u4e3a\u6700\u5c0f\u78c1\u529b,\u80fd\u5426\u5206\u9694\u51fam-1\u4e2a\u95f4\u9694\n        def Valid(x):\n            ans = 0\n            target = position[0]\n            for i in range(1,len(position)):\n                if position[i] - target >= x:\n                    ans += 1\n                    target = position[i]\n            return ans >= m - 1\n        position.sort()\n        l,r = min(position[i + 1] - position[i] for i in range(len(position) - 1)),(position[-1] - position[0]) // (m - 1)\n        while l <= r:\n            mid = l + (r - l) // 2\n            # \u82e5\u6700\u5c0f\u78c1\u529b\u53ef\u4ee5\u5206\u6210m-1\u4e2a\u95f4\u9694,\u5219\u53ef\u80fd\u5b58\u5728\u66f4\u5927\u503c,\u5426\u5219\u6700\u5c0f\u78c1\u529b\u503c\u5e94\u5f53\u66f4\u5c0f\n            if Valid(mid):\n                l = mid+1\n            else:\n                r = mid-1\n        return l-1\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def realizable(value):\n            last = position[0]\n            placed = 1\n            for k in range(1, len(position)):\n                if position[k] - last >= value:\n                    placed += 1\n                    last = position[k]\n            return placed >= m\n        \n        min_dist, max_dist = position[1] - position[0], position[-1] - position[0]\n        for k in range(1,len(position)):\n            min_dist = min(min_dist, position[k]-position[k-1])\n        \n        left, right = min_dist, max_dist + 1\n        print(left, right)\n        while left < right:\n            mid = left + (right - left) // 2\n            if not realizable(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left - 1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check_force(position, pivot, m):\n            anchor = position[0]\n            cnt = 1\n            for i in range(1, len(position)):\n                if position[i] - anchor >= pivot:\n                    anchor = position[i]\n                    cnt += 1\n                    \n                    if cnt == m:\n                        #print(\\\"Successfully placed all baskets\\\")\n                        return True\n            return False\n                \n        position = sorted(position)\n        low, high = 0, position[-1]       \n        output = -1\n        \n        # Standard binary search recipe\n        while low < high:\n            pivot = (low + high) // 2\n            if check_force(position, pivot, m):\n                output = max(output, pivot)\n                low = pivot + 1\n            else:\n                high = pivot        \n        return output", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n\n        def check(space):\n            count = start = 0\n            for i in range(1, len(position)):\n                if position[i] - position[start] >= space:\n                    count += 1\n                    start = i\n#            print(space, count)\n            return count >= m - 1\n\n        def find_space(lo, hi):\n            while lo < hi:\n                mid = int((lo / 2) + (hi / 2))\n                if check(mid) and not check(mid + 1):\n                    return mid\n                if check(mid):\n                    lo = max(mid, lo + 1)\n                else:\n                    hi = mid\n            hi -= 1\n            while check(hi):\n                hi += 1\n            return hi - 1\n\n        position.sort()\n        return find_space(1, position[-1] - position[0])", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        # print('------------')\n        maxVal = position[-1] - position[0]\n        answer = 0\n        \n        low, high = 1, maxVal\n        \n        def isValid(mid):\n            pos = position[0]\n            elements = 1\n            for i in range(1, len(position)): \n                if (position[i] - pos >= mid): \n                    pos = position[i] \n                    elements += 1\n                    if (elements == m): \n                        return True\n            return False\n\n        while low <= high:\n            mid = (low+high)//2\n            # print(mid)\n            if isValid(mid):\n                answer = max(answer, mid)\n                low = mid + 1\n            else:\n                high = mid - 1\n                \n        return answer", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        mid = max(position) // 2\n        gap = max(1,mid//2)\n        \n        t = 0\n        best = 0\n        \n        while True:\n            c = 1\n            last = position[0]\n            for i in range(1,len(position)):\n                if position[i] - mid >= last:\n                    c+=1\n                    last = position[i]\n                    \n            \n                    \n            if c>=m:\n                best = max(best,mid)\n                mid = mid + gap\n                \n                \n            else:\n                mid = mid - gap\n                \n            gap = gap//2\n            gap = max(1,gap)\n            t+=1\n            \n            if t==50:\n                break\n                \n        return (best)\n                \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def isPossible(arr, n, C, mid): \n            # Variable magnet will store count of \n            # magnets that got placed and \n            # currPosition will store the position \n            # of last placed magnet \n            magnet = 1\n            currPosition = arr[0] \n\n            for i in range(1, n): \n\n                # If difference between current index \n                # and last placed index is greater than \n                # or equal to mid it will allow placing \n                # magnet to this index \n                if (arr[i] - currPosition >= mid): \n                    magnet += 1\n\n                    # Now this index will become \n                    # last placed index \n                    currPosition = arr[i] \n\n                    # If count of magnets placed becomes C \n                    if (magnet == C): \n                        return True\n\n            # If count of placed magnet is \n            # less than C then return false \n            return False\n\n        # Function for modified binary search \n        def binarySearch(n, C, arr): \n            # Sort the indices in ascending order \n            arr.sort(reverse = False) \n\n            # Minimum possible distance \n            lo = 0\n\n            # Maximum possible distance \n            hi = arr[n - 1] \n            ans = 0\n\n            # Run the loop until lo becomes \n            # greater than hi \n            while (lo <= hi): \n                mid = int((lo + hi) / 2) \n\n                # If not possibble, decrease value of hi \n                if (isPossible(arr, n, C, mid) == False): \n                    hi = mid - 1\n                else: \n\n                    # Update the answer \n                    ans = max(ans, mid) \n                    lo = mid + 1\n\n            # Return maximum possible distance \n            return ans\n        \n        n = len(position)\n        return binarySearch(n, m, position)\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        def cnt(mid) -> int:\n            ans, cur = 1, position[0]\n            for i in range(1, n):\n                if position[i] - cur >= mid:\n                    ans += 1\n                    cur = position[i]\n            return ans\n            \n        l, r = 0, position[-1] - position[0]\n        while(l < r):\n            mid = r - (r - l)//2\n            if cnt(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n         \n        def helper(position, x, m):\n            prev = position[0]\n            m -= 1\n            #greedy\n            for i in range(1, len(position)):\n                if position[i] - prev>= x:\n                    prev = position[i]\n                    m -=1                  \n                if m == 0:\n                    break            \n            if m == 0:\n                return x\n            else:\n                return -1\n        \n        l = 1\n        r = position[-1] - position[0] + 1\n        ans = 0\n        while l < r:\n            mid = (l + r)//2\n            realMinimumForce = helper(position, mid, m)\n            print((mid, realMinimumForce))\n            if realMinimumForce == -1:\n                r = mid\n            \n            else:\n                l = mid + 1\n                ans = max(ans,realMinimumForce)\n                \n        \n        \n        \n        return ans\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def isfail(mid):\n            ans = 1\n            curr = position[0] # alike greedy idea, we just put the first ball at position 0!\n            for i in range(1, n):\n                if position[i] - curr >= mid:\n                    ans += 1\n                    curr = position[i]\n            return ans < m\n        \n        res = float('-inf')\n        left = 1\n        right = position[-1] - position[0]\n        \n        while left <= right:\n            mid = (left+right)//2\n            if isfail(mid):\n                right = mid-1\n            else:\n                left = mid + 1\n                res = max(res,mid)\n        return res ", "class Solution:\n    def checkDistance(self, position, minDist, m):\n        lastBallPos = position[0]\n        ballLeft = m - 1\n        i = 1\n        while i < len(position) and ballLeft != 0:\n            if minDist <= position[i] - lastBallPos:\n                lastBallPos = position[i]\n                ballLeft -= 1\n            i += 1\n        return ballLeft == 0\n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        high = 1000000000\n        low = 1\n        ans = 1\n        while low < high:\n            middle = (high + low + 1) // 2\n            if self.checkDistance(position, middle, m):\n                low = middle\n            else:\n                high = middle - 1\n        return low", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def count(d):\n            prev, tot = position[0], m-1\n            for i in range(1, len(position)):\n                if position[i] - prev >= d:\n                    prev = position[i]\n                    tot -= 1\n                    if tot == 0: return True\n            return False\n        position.sort()\n        low, high = 0, position[-1]-position[0]\n        res = None\n        while low <= high:\n            mid = (low + high)//2\n            if count(mid):\n                res = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        return res\n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n         \n        def helper(position, x, m):\n            res = float('inf')\n            prev = position[0]\n            m -= 1\n            for i in range(1, len(position)):\n                if position[i] - prev>= x:\n                    res = min(position[i] - prev, res)\n                    prev = position[i]\n                    m -=1\n                    \n                    \n                if m == 0:\n                    break\n            \n            if m == 0:\n                return res\n            else:\n                return -1\n                \n        \n        l = 1\n        r = position[-1] - position[0] + 1\n        ans = 0\n        while l < r:\n            mid = (l + r)//2\n            realMinimumForce = helper(position, mid, m)\n            #print(mid, realMinimumForce)\n            if realMinimumForce == -1:\n                r = mid\n            \n            else:\n                l = mid + 1\n                ans = max(ans,realMinimumForce)\n                \n        \n        \n        \n        return ans\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        lo, hi = 0, position[-1] - position[0]\n        def check(amt):\n            curr = position[0]\n            cnt = 1\n            for x in position[1:]:\n                if x - curr >= amt:\n                    cnt += 1\n                    curr = x\n            return cnt >= m\n        while lo < hi:\n            mi = (hi + lo + 1) // 2\n            if check(mi):\n                lo = mi\n            else:\n                hi = mi-1\n        return lo", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def validPlacement(spacing):\n            placed, curPosition = 1, position[0]\n            for p in position:\n                if p - curPosition >= spacing:\n                    placed += 1\n                    curPosition = p\n            return placed >= m\n                \n        ## IDEA: do binary search to find the minimum foracce (maximum space)\n        position.sort()\n        lo, hi = 0, position[-1] - position[0]\n        while (lo < hi):\n            mid = hi - (hi - lo) // 2 # midpoint formula to prevent integer overflow in other languages\n            if validPlacement(mid):\n                lo = mid\n            else:\n                hi = mid -1\n        return lo", "import bisect\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        n = len(position)\n        if m == 2: return position[-1] - position[0]\n        \n        \n        lp = 0\n        rp = (position[-1] - position[0])\n        \n        def can(gap):\n            lidx = 0\n            left = m - 1\n            ptr = 1\n            while left > 0 and ptr < n:\n                if position[ptr] - position[lidx] >= gap:\n                    left -= 1\n                    lidx = ptr\n                    ptr = lidx + 1\n                    continue\n                ptr += 1\n            return left == 0\n        \n        ans = 0\n        while lp < rp:\n            mid = (lp+rp+1)//2\n            if can(mid):\n                lp = mid\n            else:\n                rp = mid-1\n        return lp", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        \n        def check(min_force):\n            count = 1\n            k = position[0]\n            for n in position:\n                if n-k >= min_force:\n                    count += 1\n                    k = n\n            print(min_force, count)\n            if count >= m:\n                return True\n            return False\n        \n        \n        i, j = 1, position[-1]-position[0]\n        while i <= j:\n            mid = (i+j)//2\n            c1 = check(mid)\n            c2 = check(mid+1)\n            if c1 and not c2:\n                return mid\n            if not c1:\n                j = mid-1\n            else:\n                i = mid+1", "class Solution:\n    def search(s,e,m,l):\n        mid=(s+e)//2\n        if s>e:\n            return e\n        return Solution.search(mid+1,e,m,l) if Solution.ispossible(mid,m,l) else Solution.search(s,mid-1,m,l)\n    \n    def ispossible(n, m, l):\n        count=1\n        p=l[0]\n        for i in range(1,len(l)):\n            if l[i]-p >= n:\n                count+=1\n                p=l[i]\n            if count>=m:\n                return True\n        return False\n        \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        return Solution.search(1,position[-1]-position[0], m, position)\n", "class Solution:\n    \n    def check(self,position,mid,m):\n        prev=position[0]\n        rem=m-1\n        \n        i=1\n        \n        while i<len(position) and rem:\n            if position[i]-prev<mid:\n                i+=1\n                \n            else:\n                rem-=1\n                prev=position[i]\n                \n                \n        return rem==0\n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        l=1\n        h=1000000000\n        \n        position.sort()\n        \n        while l<h:\n            mid=(l+h+1)//2\n            \n            if self.check(position,mid,m):\n                l=mid\n                \n            else:\n                h=mid-1\n                \n        return l\n", "class Solution:\n    def checkDistance(self, position, minDist, m):\n        lastBallPos = position[0]\n        ballLeft = m - 1\n        i = 1\n        while i < len(position) and ballLeft != 0:\n            if minDist <= position[i] - lastBallPos:\n                lastBallPos = position[i]\n                ballLeft -= 1\n            i += 1\n        return ballLeft == 0\n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        print(position)\n        high = 1000000000\n        low = 1\n        ans = 1\n        while low < high:\n            middle = (high + low + 1) // 2\n            if self.checkDistance(position, middle, m):\n                low = middle\n            else:\n                high = middle - 1\n            print(high, low)\n        return low", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        def can_place(force):\n            count = 1\n            curr = position[0]\n            for i in range(1, len(position)):\n                if position[i] - curr >= force:\n                    count += 1\n                    curr = position[i]\n            return count\n        \n        position.sort()\n        \n        lo, hi = 0, position[-1] - position[0]\n        while lo < hi:\n            mid = (lo + hi + 1) // 2\n            if can_place(mid) >= m:\n                lo = mid\n            else:\n                hi = mid - 1\n        return lo", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        left = 1\n        right = (position[-1]-position[0]) // (m-1) + 1\n        while left<right:\n            mid = (left+right)//2\n            if self.can(position, mid, m):\n                left = mid + 1\n            else:\n                right = mid\n        return left if self.can(position, left, m) else left-1\n    \n    def can(self, position, mid, m):\n        n = len(position)\n        pos = [0 for i in range(m)]\n        i = 1\n        j = 1\n        while i < n and j < m:\n            if position[i] - position[pos[j-1]] >= mid:\n                pos[j] = i\n                j += 1\n            i += 1\n        if j==m:\n            return True\n        return False", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n    \n    def check(self,position,m,mid):\n        \n        lastpos=position[0]\n        rem=m-1\n        \n        i=1\n        \n        while i<len(position) and rem:\n            \n            if position[i]-lastpos<mid:\n                i+=1\n                \n                \n            else:\n                rem-=1\n                lastpos=position[i]\n                \n                \n        return rem==0\n                \n    \n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        low=1\n        high=10**9\n        \n        while low<high:\n            mid=low+(high-low)//2\n            \n            if self.check(position,m,mid):\n                low=mid+1\n                \n            else:\n                high=mid\n                \n        return low-1\n            \n        \n        \n", "class Solution:\n  def maxDistance(self, position: List[int], m: int) -> int:\n    # binary search O(NlogQ), n = len(position), q = max(position)\n    position.sort()\n    def maxBalls(d):\n      # O(N), if distance >= d, how many magnetic balls can be placed?\n      count, p = 0, -d\n      for x in position:\n        if x - p >= d:\n          count, p = count + 1, x\n      return count\n    l, r = 0, max(position)\n    while l < r:\n      d = r - (r - l) // 2\n      if maxBalls(d) >= m:\n        l = d\n      else:\n        r = d - 1\n    return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        # all_dists = set()\n        # for i in range(len(position) - 1):\n        #     for j in range(i + 1, len(position)):\n        #         all_dists.add(position[j] - position[i])\n                \n#         all_dists_list = list(all_dists)\n#         all_dists_list.sort(reverse=True)\n\n        lo = 1\n        hi = position[-1]\n        \n        while lo < hi:\n            dist = (hi + lo) // 2 + 1\n         \n            if self.maxBalls(position, dist) >= m:\n                lo = dist\n            else:\n                hi = dist - 1\n                \n            # print(lo, hi)\n                \n        return lo\n                \n        \n    def maxBalls(self, sorted_position: List[int], distance: int) -> int:\n        l_ind = 0\n        r_ind = 1\n        count = 1\n        \n        while r_ind < len(sorted_position):\n            if sorted_position[r_ind] - sorted_position[l_ind] >= distance:\n                count += 1\n                l_ind = r_ind\n            r_ind += 1\n            \n        return count", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        # print(position)\n        high=int((position[-1]-position[0])/(m-1))\n        low=0\n        while high-1>low:\n            mid=int((high+low)/2)\n            # print('high:'+str(high)+'low:'+str(low)+'mid:'+str(mid))\n            if self.helper(position,mid,m):\n                # print('True')\n                low=mid\n            else:\n                # print('False')\n                high=mid-1\n        if self.helper(position,high,m):\n            return high\n        else:\n            return low\n        \n    def helper(self,position,max_d,m):\n        count=1\n        pre_ind=0\n        ind=1\n        while ind<len(position):\n            if count>=m:\n                break\n            # print('ind:'+str(ind)+'count:'+str(count))\n            if position[ind]-position[pre_ind]<max_d:\n                ind+=1\n            else:\n                pre_ind=ind\n                ind+=1\n                count+=1\n        if count>=m:\n            return True\n        else:\n            return False", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        lo, hi = 1, 10**9\n        while hi>lo:\n            mid = (lo+hi+1)//2\n            lapo = position[0]\n            co = 1\n            for po in position[1:]:\n                if po-lapo >= mid:\n                    lapo = po\n                    co += 1\n            if co >= m:\n                lo = mid\n            else:\n                hi = mid-1\n        return lo", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        \n        def count(d):\n            res = 1\n            curr = position[0]\n            for i in range(1,n):\n                if position[i] - curr >= d:\n                    res += 1\n                    curr = position[i]\n            return res\n        l = 0\n        r = position[-1] - position[0]\n        while l < r:\n            mid = (l + r + 1) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        arr = sorted(position)\n        if m == 2:\n            return arr[-1] - arr[0]\n        \n        def check(n):\n            cnt = 2\n            pre = arr[0]\n            for i in range(1, len(arr) - 1):\n                if arr[i] - pre >= n:\n                    pre = arr[i]\n                    cnt += 1\n                    if cnt == m:\n                        break\n            return cnt == m and arr[-1] - pre >= n\n        \n        lo, hi = 1, arr[-1] - arr[0]\n        while lo <= hi:\n            mi = lo + (hi - lo) // 2\n            if check(mi):\n                lo = mi + 1\n            else:\n                hi = mi - 1\n        return hi", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        def is_good(position, target_distance, m):\n            prev = position[0]\n            count = 1\n            for i in range(1, len(position)):\n                pos = position[i]\n                if pos - prev >= target_distance:\n                    prev = pos\n                    count += 1\n                    if count == m:\n                        return True\n            return False\n                    \n        left = 1\n        right = max(position)\n        while right > left + 1:\n            mid = (left+right)//2\n            if is_good(position, mid, m):\n                left = mid\n            else:\n                right = mid\n        if is_good(position, right, m):\n            return right\n        else:\n            return left", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n    \n        position.sort()\n        \n        def count(d):\n            curr = position[0]  \n            ans = 1\n            for i in range(1, len(position)):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:         \n            mid = r - (r - l) // 2\n            c = count(mid)\n            if c >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        minp,maxp = min(position),max(position)\n        if m == 2:\n            return maxp-minp\n        \n            \n        position.sort()\n        def valid(i):\n  \n            count = 1\n            ending = position[0]\n            for j in range(1,len(position)):\n                if position[j] >= ending+i:\n                    count += 1\n                    ending = position[j]   \n           \n            return True if count >= m else False\n                        \n\n        left,right = 0, maxp-minp+1\n        \n        while right-left > 1:\n            #print(left,right)\n            mid = left+(right-left)//2\n            if valid(mid):\n                left = mid\n            else:\n                right = mid\n        return left", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def distributable(n):\n            pos = len(position) - 1\n            balls = m\n            while pos >= 0 and balls:\n                balls -= 1\n                np = position[pos] - n\n                while pos >= 0 and position[pos] > np:\n                    pos -= 1\n            return not balls       \n        position = sorted(position)\n        lo, hi = 1, (position[-1] - position[0]) // (m -1) + 1\n        ans = lo\n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if distributable(mid):\n                ans = mid\n                lo = mid + 1\n            else:\n                hi = mid\n        return ans   \n        \n", "class Solution:\n    def maxDistance(self, pp: List[int], k: int) -> int:\n        n=len(pp)\n        pp.sort()\n        l=1\n        r=pp[-1]-pp[0]+1\n\n        def ok(m):\n            i=1\n            pre=pp[0]\n            for _ in range(k-1):\n                while i<n and pp[i]-pre<m:i+=1\n                if n==i:return False\n                pre=pp[i]\n                i+=1\n            return True\n\n        while l+1<r:\n            m=(l+r)//2\n            if ok(m):l=m\n            else:r=m\n\n        return l\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n\n        def foo( d):\n            ans = 1; last = position[0]\n            for i in range( 1, len( position)):\n                if position[i] - last >= d:\n                    ans += 1\n                    last = position[i]\n            return ans\n        \n        left = 0; right = position[-1] - position[0]\n\n        while left < right:\n            mid = right - ( right - left) // 2\n            if foo( mid) >= m:\n                left = mid\n            else:\n                right = mid - 1\n        return left", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:            \n        position.sort()\n        n = len(position)\n        \n        def check(d):\n            k, pre = 1, position[0]\n            for i in range(1, n):\n                if position[i] - pre >= d:\n                    k += 1\n                    pre = position[i]\n            return k >= m\n\n        lo, hi = 0, position[-1] - position[0]\n        while lo < hi:\n            mid = hi - (hi - lo) // 2\n            if check(mid):\n                lo = mid\n            else:\n                hi = mid - 1\n            \n        return lo\n\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def can_reach(force):\n            last = position[0]\n            placed = 1\n            \n            for i in range(1, len(position)):\n                pos = position[i]\n                \n                if pos - last >= force:\n                    last = pos\n                    placed += 1\n                if placed >= m:\n                    break\n            \n            return placed >= m\n        \n        l = 1\n        r = position[-1] - position[0] + 1\n        \n        while l < r:\n            mid = (l+r)//2\n            if not can_reach(mid):\n                r = mid\n            else:\n                l = mid+1\n        \n        return l-1\n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r = 0, 10**9 + 2\n        while l < r:\n            \n            mid = (l + r) // 2\n            prev = position[0]\n            cnt = 1\n            for p in position:\n                if p >= prev + mid:\n                    prev = p\n                    cnt += 1\n            # print(l, r, mid, cnt)\n            if cnt < m:\n                r = mid\n            else:\n                l = mid + 1\n        return l-1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def c(p,m,d):\n            b=m-1\n            l=len(p)\n            acc=0\n            for i in range(1,l):\n                acc+=p[i]-p[i-1]\n                if acc>=d:\n                    acc=0\n                    b-=1\n                if b==0:\n                    return True\n            return False\n        low=1\n        high=1000000000\n        mid=0\n        position.sort()\n        while low<=high:\n            mid=(low+high)//2\n            if c(position,m,mid):\n                low=mid+1\n            else:\n                high=mid-1\n        return high", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n\n        def possible(num):\n            Count, pos = 1, 0\n\n            for i in range(1, len(position)):\n\n                if position[i]  - position[pos] >= num:\n                    pos = i\n                    Count += 1\n                if Count==m:\n                    return True\n\n            return Count >= m\n\n        def search(left,right):\n\n            if left == right: \n                return left\n\n            mid = (left + right)//2\n\n            if possible(mid) and not possible(mid + 1):\n                return mid\n            elif possible(mid): \n                \n                return search(mid + 1, right)\n            return search(left, mid - 1)\n\n        return search(1, position[-1] - position[0])\n", "class Solution:\n    def maxDistance(self, positions: List[int], m: int) -> int:\n        positions.sort()\n        # try to add balls and record the position\n        def check(mid):\n            p = 0\n            count = 0\n            for q in range(len(positions)):\n                if positions[q] - positions[p] >= mid:\n                    p = q\n                    count += 1\n            return count >= m-1                  \n        \n        low, high = 0, positions[-1]-positions[0]\n        # print(low, high)\n        \n        res = 0\n        \n        while low <= high:\n            mid = (low + high)//2\n            if check(mid):\n                low = mid + 1\n                res = max(res, mid)\n            else:\n                high = mid - 1\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n#         def feasible(distance):\n#             balls, curr = 1, position[0]\n#             for i in range(1, len(position)):\n#                 if position[i]-curr >= distance:\n#                     balls += 1\n#                     curr = position[i]\n                    \n#             return balls >= m\n            \n        \n#         position.sort()\n#         left, right = 0, position[-1]-position[0]\n#         while left<right:\n#             mid = left + (right-left)//2\n#             if feasible(mid):\n#                 right = mid\n#             else:\n#                 left = mid+1\n#         return left\n\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        lo = 1\n        hi = 10**18\n        position.sort()\n        def func(mid):\n            cnt = 1\n            cur = position[0]\n            for i in range(1,len(position)):\n                if position[i]>=cur+mid:\n                    cur = position[i]\n                    cnt+=1\n            if cnt>=m:\n                return True\n            else:\n                return False\n            \n        while lo<hi:\n            mid = (lo+hi)//2\n            x = func(mid)\n            if x==True:\n                lo = mid\n            else:\n                hi = mid\n            if hi-lo==1:\n                break\n        if func(hi)==True:\n            return hi\n        return lo\n            \n", "class Solution:\n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        def helper(pos, mid, k):\n            temp = pos[0]\n            done = 1\n            for i in range(1, len(pos)):\n                if pos[i] - temp >= mid:\n                    temp = pos[i]\n                    done += 1\n                if done == k:\n                    return True\n            \n            return False\n        \n        position.sort()\n        res = -1\n        l, r = 0, position[-1]\n        \n        while l < r:\n            mid = l + (r - l) // 2\n            if helper(position, mid, m):\n                res = max(res, mid)\n                l = mid + 1\n            else:\n                r = mid\n        \n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position = sorted(position)\n        m_vals = []\n        distance = position[-1] - position[0]\n        def works(min_dist):\n            i = 1\n            count = 1\n            prev = 0\n            while count < m and i < n:\n                if position[i] - position[prev] >= min_dist:\n                    count += 1\n                    prev = i\n                i += 1\n            return count == m\n        \n        low = 0\n        high = 1 << 32\n        while high - low > 1:\n            mid = (low + high) // 2\n            if works(mid):\n                low = mid\n            else:\n                high = mid - 1\n        if works(high):\n            return high\n        return low\n", "class Solution:\n    def maxDistance(self, positions: List[int], m: int) -> int:\n        positions.sort()\n        def valid(mid):\n            count = 0\n            last = -math.inf\n            for pos in positions:\n                if pos >= last + mid:\n                    count += 1\n                    last = pos\n            return count >= m\n            \n        left, right = 0, positions[-1]\n        while left <= right:\n            mid = (left + right) // 2\n            if valid(mid):\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right", "# class Solution:\n#     def maxDistance(self, position: List[int], m: int) -> int:            \n#         position.sort()\n        \n#         def check(d):\n#             k = 1\n#             pre = position[0]\n#             for i in range(1, len(position)):\n#                 if position[i] - pre >= d:\n#                     k += 1\n#                     pre = position[i]\n#             return k >= m\n\n#         lo, hi = 0, position[-1] - position[0]\n#         while lo < hi:\n#             mid = (lo + hi)//2\n#             if check(mid):\n#                 lo = mid\n#             else:\n#                 hi = mid - 1\n            \n#         return lo\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n", "class Solution:\n    def isSafe(self,lst,m,key):\n        n = len(lst)\n        pre = lst[0]\n        index = 1\n        while(index<n):    \n            while(index<n and lst[index]-pre<key):\n                index+=1\n            \n\n            m-=1\n            if(m==0):\n                return True\n            if(index==n):\n                return False\n            pre = lst[index]\n            \n        \n        return False\n        \n        \n            \n           \n    def maxDistance(self, lst: List[int], m: int) -> int:\n        lst.sort()\n        n    = len(lst)\n        low  = 0\n        high = lst[-1] - lst[0]\n        ans  = 0\n        \n        while(low<=high):\n            mid = (low+high)//2\n            if(self.isSafe(lst,m,mid)):\n                ans  = mid\n                low  = mid + 1\n            else:\n                high = mid - 1\n        \n        return ans\n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def maxDistance(self, pos: List[int], m: int) -> int:\n        pos.sort()\n        n = len(pos)\n        def check(gap):\n            i = 0\n            ii = 0\n            nn = 1\n            while i < n:\n                if pos[i] - pos[ii] >= gap:\n                    nn += 1\n                    ii = i\n                i += 1\n            return nn < m\n        \n        l = float('inf')\n        for i in range(n-1):\n            l = min(l, pos[i+1] - pos[i])\n        r = pos[-1] - pos[0] + 1\n        \n        while l < r:\n            mid = (l + r) // 2\n            if check(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l - 1\n#         if check(l):\n#             return l\n#         else:\n#             return l - 1\n            \n", "import numpy as np\nimport itertools as it\nclass Solution:\n# #     def maxDistance(self, position: List[int], m: int) -> int:\n#         arr = np.sort(position)\n#         md = max(arr)\n#         # print(arr)\n        \n#         combList = list(it.combinations(arr, m))\n#         # print(combList)\n#         maxmindiff = 0\n#         targetList = []\n#         for comb in combList:\n#             cb = list(it.combinations(comb, 2))\n#             minDiff = md\n#             for k in range(len(cb)):\n#                 curDiff = abs(cb[k][0]-cb[k][1])\n#                 if curDiff< minDiff:\n#                     minDiff= curDiff\n                \n#             if minDiff>maxmindiff:\n#                 maxmindiff = minDiff\n#                 targetList = comb\n#         # print(maxmindiff)\n#         # print(targetList)\n#         return maxmindiff\n\n\n    def maxDistance(self, position: List[int], m: int) -> int:\n        arr = np.sort(position)\n        arr = arr -np.min(arr)\n        print(arr)\n        def isFeasible(mid, arr, m):\n            pos = arr[0]\n            n = len(arr)\n            count = 1\n            for i in range(n):\n                if arr[i] - pos>=mid:\n                    pos = arr[i]\n                    count+=1\n                if count>=m:\n                    return True\n            return False\n        \n        left = arr[0]\n        right = arr[-1]\n        \n        if m ==2:\n            return right-left\n        res = -1\n        count = 0\n        while left < right:\n            # mid = np.ceil((right+left)/2)\n            mid = (right+left)//2\n            # mid = right-(right-left)//2\n            # print(mid)\n            count +=1\n            if isFeasible(mid, arr, m):\n                res = max(res,mid)\n                left = mid +1\n                \n            else:\n                right = mid\n        print(count)\n        return int(res)\n\n############################3\n# class Solution:\n#     def maxDistance(self, position: List[int], m: int) -> int:\n#         n = len(position)\n#         position.sort()\n        \n#         def count(d):\n#             ans, curr = 1, position[0]\n#             for i in range(1, n):\n#                 if position[i] - curr >= d:\n#                     ans += 1\n#                     curr = position[i]\n#             return ans\n        \n#         l, r = 0, position[-1] - position[0]\n#         while l < r:\n#             mid = r - (r - l) // 2\n#             if count(mid) >= m:\n#                 l = mid\n#             else:\n#                 r = mid - 1\n#         return l\n       \n \n\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        low, high = 1, 10 ** 9\n        answer = 0\n        while low <= high:\n            mid = (low + high) >> 1\n            cnt = 0\n            temp = -(10 ** 9)\n            for i in position:\n                if i - temp >= mid:\n                    cnt += 1\n                    temp = i\n            if cnt >= m:\n                answer = max(answer, mid)\n                low = mid + 1\n            else:\n                high = mid - 1\n        return answer\n", "class Solution:\n    def fun(self, arr, dist):\n        pos = arr[0]\n        cows = 1\n        for i in range(1, len(arr)):\n            e = arr[i]\n            if e-pos >= dist:\n                pos = e\n                cows += 1\n            if cows == self.m: return True\n        return False\n    \n    def bs(self, arr):\n        lef = 0\n        rit = arr[-1]\n        while lef < rit:\n            mid = (lef+rit)//2\n            # print('mid, mid+1', mid, mid+1)\n            me = self.fun(arr, mid)\n            nex = self.fun(arr, mid+1)\n            # print('me, nex', me, nex)\n            if me and not nex:\n                return mid\n            elif me and nex:\n                lef = mid + 1\n            else:\n                rit = mid - 1\n            # print('lef, rit', lef, rit)\n        return lef\n        \n    def maxDistance(self, position: List[int], m: int) -> int:\n        self.m = m\n        position.sort()\n        return self.bs(position)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def isFeasible(positions, mid, k): \n            taken = 1\n            last = positions[0]\n            for i in range(1, len(positions)):\n                if positions[i] - last >= mid:\n                    taken += 1\n                    last = positions[i]\n            return taken >= k\n        \n        def largestMinDist(positions, n, k): \n            low = 0\n            high = max(positions) - min(positions) + 1\n            while high - low > 1:\n                mid = (low + high) // 2\n                if isFeasible(positions, mid, k):\n                    low = mid\n                else:\n                    high = mid\n            return low\n        \n        n = len(position) \n        \n        position = sorted(position)\n        \n        '''\n        if m == len(position):\n            ans = max(position) - min(position)\n            for i in range(1, n):\n                diff = position[i] - position[i - 1]\n                if diff < ans:\n                    ans = diff\n            return ans\n        '''\n    \n        return largestMinDist(position, n, m)", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l=1\n        r=position[-1]\n        pos=0\n        print((l,r))\n        def check(mid):\n            cow_cnt=1\n            last_pos=position[0]\n            for i in range(1,len(position)):\n                if position[i]-last_pos>=mid:\n                    cow_cnt+=1\n                    if cow_cnt==m:\n                        return True\n                    last_pos=position[i]\n            return False\n            \n        while l<=r:\n            mid=l+(r-l)//2\n            if check(mid):\n                pos=mid\n                l=mid+1\n                # print(mid)\n            else:\n                r=mid-1\n        return pos\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def check(pos):\n            placed = 1\n            i = 0\n            j = 1\n            while j < l:\n                if position[j] - position[i] >= pos:\n                    placed +=1\n                    if placed == m:\n                        return True\n                    i = j\n                    j = i + 1\n                else:\n                    j +=1\n            return (True if placed == True else False)\n                \n        l = len(position)\n        mx = max(position) - min(position)\n        position.sort()\n        lo = 1\n        hi = mx\n        ans = -1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if check(mid):\n                ans = mid\n                lo = mid + 1\n            else:\n                hi = mid  - 1\n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n\n        def check(dist):\n            balls = m\n            prev = None\n            res = float('inf')\n            for p in position:\n                if prev is None or p - prev >= dist:\n                    if prev:\n                        res = min(res, p - prev)\n                    prev = p\n                    balls -= 1\n\n            if balls > 0:\n                return None\n            return res\n\n        lo, hi = 1, (position[-1] - position[0]) // (m - 1)\n        res = 0\n        # print('lohi', lo, hi)\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            r = check(mid)\n            # print('dist', mid, res)\n            if r:\n                res = r\n                lo = mid + 1\n            else:\n                hi = mid - 1\n\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        mn = sys.maxsize\n        mx = position[-1] - position[0]\n        \n        for i in range(1, len(position)):\n            mn = min(mn, position[i] - position[i-1])\n            \n        def isPoss(diff):\n            count = 1\n            start = 0\n            cd = 0\n            f = sys.maxsize\n            for i in range(1, len(position)):\n                if cd + position[i] - position[i-1] < diff:\n                    cd += position[i] - position[i-1]\n                else:\n                    count += 1\n                    f = min(f, position[i] - position[start])\n                    start = i\n                    cd = 0\n                    if count == m:\n                        break\n                    \n            if count == m:\n                return f\n            return -1\n        \n        ans = -1\n        while mn <= mx:\n            mid = (mn + mx)//2\n            v = isPoss(mid)\n            if v != -1:\n                ans = v\n                mn = mid + 1\n            else:\n                mx = mid - 1\n        return ans\n        \n            \n            \n        \n", "import bisect\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        def possible(gap):\n            prev = position[0]\n            idx = 0\n            left = m - 1\n            while left > 0:\n                idx = bisect.bisect_left(position, prev+gap, idx + 1, n)\n                if idx >= n:\n                    return False\n                else:\n                    prev = position[idx]\n                    left -= 1\n            return True\n        \n        position.sort()\n        min_gap = 1\n        max_gap = position[-1] - position[0]\n        while min_gap < max_gap:\n            cur_gap = (min_gap + max_gap + 1) // 2\n            if possible(cur_gap):\n                min_gap = cur_gap\n            else:\n                max_gap = cur_gap - 1\n                \n        return min_gap\n    \n", "class Solution:\n    def maxDistance(self, position, m):\n        position.sort()\n        n = len(position)\n        \n        def canFit(gap):\n            ct = 1\n            i = 0\n            j = 1\n            while j < n:\n                while j<n and position[j]-position[i] < gap:\n                    j += 1\n                # print(i, j, ct)\n                if j<n:\n                    ct += 1\n                    i = j\n                    j += 1\n                \n                if ct == m:\n                    return True\n            return False\n        \n        # print(canFit(999999999))\n        \n        lo = 1\n        hi = position[-1] - position[0]\n        res = 0\n        ct = 0\n        while lo<=hi:\n            mid = (lo + hi) >> 1\n            ct += 1\n            if canFit(mid):\n                res = mid\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        if len(position) < m: return 0\n        \n        position.sort()\n        \n        def can(force):\n            cnt = 1\n            pos = 0\n            for i in range(1, len(position)):\n                if position[i] - position[pos] >= force:\n                    cnt += 1\n                    pos = i\n            return cnt >= m\n        \n        \n        low, high = 0, position[-1] - position[0]\n        while low < high:\n            mid = (low + high + 1) // 2\n            if can(mid):\n                low = mid\n            else:\n                high = mid - 1\n        return low", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def feasible(dist, m):\n            pre_pos = position[0]\n            placed = 1\n            for i in range(1, len(position)):\n                if position[i] - pre_pos >= dist:\n                    placed +=1 \n                    if placed >= m:\n                        return True\n                    pre_pos = position[i]\n            return False\n            \n        l = 1\n        r = position[-1] - position[0]\n        while l <= r:\n            mid = l + (r - l) // 2\n            if feasible(mid, m):\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l-1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for i in range(1, n):\n                if position[i] - curr >= d:\n                    ans += 1\n                    curr = position[i]\n            return ans\n        \n        l, r = 0, position[-1] - position[0]\n        while l < r:\n            mid = r - (r - l) // 2\n            if count(mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n        \n", "def possible(min_diff,arr,m):\n    start = 0\n    total = 1\n    end = 1\n    while end < len(arr):\n        if arr[end]-arr[start] >= min_diff:\n            total += 1\n            start = end\n        \n        end += 1\n    \n    if total >= m:\n        return True\n    \n    return False\n\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        ans = -1\n        low = 1\n        high = 10**9\n        while low <= high:\n            mid = (low+high)//2\n            if possible(mid,position,m):\n                low = mid+1\n                ans = mid\n            else:\n                high = mid-1\n            \n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position = sorted(position)\n        i,j = 1,1000000001\n        ans = 0 \n        while i<=j :\n            prevCow = position[0] \n            mid = (i+j)//2 \n            currCows = 1 \n            for k in range(1,len(position)) : \n                if position[k] - prevCow >= mid : \n                    currCows += 1 \n                    prevCow = position[k]\n            if currCows < m :\n                j = mid - 1\n            else :\n                i = mid + 1 \n                ans = mid \n        return ans ", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def valid(interval,m):\n            last=-interval\n            for p in position:\n                if p-last>=interval:\n                    m-=1\n                    last=p\n            return True if m<=0 else False\n        #binary search interval: return the maxiumal interval\n        lo,hi=1,max(position)//(m-1) # the interval cannot be than the ideal condition\n        while lo<=hi:\n            mid=lo+(hi-lo)//2\n            if valid(mid,m):# the correct value can be bigger\n                lo=mid+1#[min,lo-1] is valid all the time\n            else:\n                hi=mid-1#[hi+1,max] is not valid all the time\n        # lo=hi+1; [min,lo-1] is valid, [lo,max] is not valid\n        return hi\n        \n        \n                    \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        \n        def count(d):\n            cnt = 1\n            cur = position[0]\n            for p in position[1:]:\n                if p>=cur+d: cur, cnt = p, cnt+1\n            return cnt\n        \n        l, r = 0, position[-1]-position[0]\n        while l<r:\n            mid = r - (r-l)//2\n            # count_mid = count(mid)\n            # if count(mid) >= m: return r-l\n            if count(mid) < m:\n                r = mid-1 \n            else:\n                l = mid\n            # print(mid, count(mid))\n        return r\n            \n        \n        \n        \n                    \n", "class Solution:\n    def checkDistance(self, position, minDist, m):\n        lastBallPos = position[0]\n        ballLeft = m - 1\n        i = 1\n        while i < len(position) and ballLeft != 0:\n            if minDist <= position[i] - lastBallPos:\n                lastBallPos = position[i]\n                ballLeft -= 1\n            i += 1\n        return ballLeft == 0\n    \n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        high = position[-1]\n        low = 1\n        while low < high:\n            middle = (high + low + 1) // 2\n            if self.checkDistance(position, middle, m):\n                low = middle\n            else:\n                high = middle - 1\n        return low", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def isFeasible(mid, arr, n, k): \n            pos = arr[0] \n            elements = 1\n  \n            for i in range(1, n): \n                if arr[i] - pos >= mid: \n                    pos = arr[i] \n                    elements += 1\n  \n                    if elements == k: \n                        return True\n            return False\n        \n        position = sorted(position)\n        if m == 2:\n            return position[-1] - position[0]    \n        dist = []\n        for i in range(len(position) -1):\n            dist.append(position[i+1] - position[i])\n        if m == len(position):\n            return min(dist)\n        \n        left = 0\n        right = position[-1]\n        res = 1\n        \n        while left < right: \n            mid = (left + right) // 2\n         \n            if isFeasible(mid, position, len(position), m): \n                res = max(res, mid) \n                left = mid + 1\n            else: \n                right = mid \n  \n        return res \n        \n            \n            \n            \n        \n", "class Solution:\n    import bisect\n    def maxDistance(self, position: List[int], m: int) -> int:\n        l, r = 1, max(position)-min(position)\n        if m == 2: return r\n        position = sorted(position)\n       \n\n        def fea(D):\n            #print(\\\"   \\\",D)\n            s = min(position)\n            need = 1\n            last = 1\n            while(True):\n                for i in range(last,len(position)):\n                    if position[i]>=s+D:\n                        need += 1\n                        s = position[i]\n                        last = i\n                        break\n                if last == len(position)-1 or position[-1]<s+D:\n                    break\n            #print(\\\" \\\",need)\n            return need\n        \n        print((fea(2)))\n        while(l<r):\n            mid = l+(r-l)//2\n            if fea(mid)<m:\n                r = mid\n            else:\n                l = mid+1\n            \n        return l-1\n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        # distances = [i for i in range(10**9)]\n        # distances.sort()\n        \n        \n        hi = 10**9-1\n        li = 0\n        while li <= hi:\n            # print(\\\"li \\\",li,\\\"hi \\\",hi)\n            if li == hi:\n                return li\n            mid = (hi+li)//2\n            if hi == li+1:\n                mid += 1\n                \n            d = mid\n            i = 0\n            j = 0\n            count = 1\n            flag = True\n\n            while count < m:\n                while position[j]<position[i] + d:\n                    j += 1\n                    if j == n and count < m:\n                        flag = False\n                        break\n                if j == n and count <m:\n                    flag = False\n                    break\n                i = j\n                count += 1\n                \n            if hi == li+1:\n                if flag:    \n                    return hi\n                else:\n                    return li\n            \n    \n            if flag:\n                li = mid\n            else:\n                hi = mid-1\n            \n            \n                    \n    \n", "class Solution:\n    def maxDistance(self, arr: List[int], m: int) -> int:\n        \n        \n        arr = sorted(arr)\n        low, high = 1, arr[-1]-arr[0]+1\n        \n        def isValid(k, balls):\n            balls-=1\n            prev = arr[0]\n            res = float('inf')\n            for i in range(1,len(arr)):\n                if arr[i]-prev >= k:\n                    res = min(res, arr[i]-prev)\n                    balls-=1\n                    prev = arr[i]\n                \n                if balls == 0: break\n                    \n            return res if balls == 0 else -1\n        \n        ans = 0\n        \n        while low < high:\n            mid = low + (high-low)//2\n            tmp = isValid(mid, m)\n            \n            if tmp != -1:\n                ans = tmp\n                low = mid+1\n            else:\n                high = mid\n        \n        return ans\n            \n            \n            \n            \n            \n", "class Solution:\n    def maxDistance(self, pos: List[int], m: int) -> int:\n        pos = sorted(pos)\n        \n        def test(gap, pos = pos, m = m):\n            cur = pos[0]\n            i = 1\n            m -= 1\n            while i < len(pos):\n                if pos[i] - cur >= gap:\n                    cur = pos[i]\n                    m -= 1\n                    if m == 0: return True\n                i += 1\n            return False\n        \n        lower, upper = 1, pos[-1]-pos[0]\n        if test(upper): return upper\n        while True:\n            gap = (lower + upper) // 2\n            if test(gap): lower = gap\n            else: upper = gap\n            if upper - lower == 1: return lower", "class Solution:\n    def maxDistance(self, pos: List[int], m: int) -> int:\n        if m < 2: return -1\n        pos.sort()\n        avg = (pos[-1]-pos[0]+1)//(m-1)+1\n        #boolean\n        def check(f):\n            nonlocal pos, m\n            cnt = 0\n            pidx = 0\n            for i in range(1, len(pos)):\n                if (pos[i]-pos[pidx]+1) >= f:\n                    cnt += 1\n                    pidx = i\n            #print(\\\"cnt:\\\", cnt)\n            return cnt >= m-1\n\n        l, r = 1, avg\n        #print(\\\"l:\\\", l, \\\"r:\\\", r)\n        while l+1<r:\n            mid = l+(r-l)//2\n            if check(mid):\n                l = mid\n            else:\n                r = mid-1\n        #print(\\\"l:\\\", l, \\\"r:\\\", r)\n        if check(r): return r-1\n        else: return l-1\n\n\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        lo = 1\n        hi = position[-1] - position[0]\n        res = 0\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            count = 1\n            prev = position[0]\n            for i in range(1, n):\n                if position[i] - prev >= mid:\n                    count += 1\n                    prev = position[i]\n                    \n            if count >= m:\n                res = max(res, mid)\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return res\n", "class Solution:\n    def maxDistance(self, pos: List[int], m: int) -> int:\n        \n        pos.sort()\n        \n        low = 0\n        \n        high = pos[-1] - pos[0]\n        \n        def chk(d):\n            \n            nonlocal m\n            \n            n = len(pos)\n            \n            c = m            \n            p = 0\n            \n            for i in range(n):\n                \n                if c == 0:\n                    return True\n                \n                if i == 0:                    \n                    c -= 1\n                    p = pos[0]                    \n                    continue\n                    \n                if pos[i] - p >= d:\n                    c -= 1\n                    p = pos[i]\n                    \n            return c <= 0\n        \n        \n        while low < high:\n            \n            mid = int( math.ceil( (low + high) / 2 ) )\n            \n            if chk(mid):\n                low = mid\n            else:\n                high = mid - 1\n                \n        return low\n        \n        \n                    \n            \n                    \n                    \n                \n                    \n        \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        start = 0\n        position.sort()\n        end = position[-1]\n        def good(x):\n            s = -1e100\n            count = 0\n            for p in position:\n                if p - s >= x:\n                    count += 1\n                    s = p\n            return count >= m\n        while start < end:\n            mid = (start + end) // 2\n            if good(mid + 1):\n                start = mid + 1\n            else:\n                end = mid\n        return start", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        def count(dist):\n            prev, balls = -1e9, 0\n            for p in position:\n                if p - prev >= dist:\n                    balls += 1\n                    if balls == m:\n                        break\n                    prev = p\n            return balls\n        \n        position.sort()\n        l, r = 1, position[-1]\n        res = 0\n        while l < r:\n            mid = (l + r) // 2\n            balls = count(mid)\n            if balls == m:\n                res = mid\n                l = mid + 1\n            else:\n                r = mid\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        if m == 2:\n            return position[-1] - position[0]\n\n        else:\n            maxd = position[-1] // (m-1)\n\n\n        start = 1\n        end = maxd\n\n        while start < end:\n            middle = (start+end) // 2\n            result = self.is_satisfy(position, middle, m)\n            if result:\n                if start == middle:\n                    result2= self.is_satisfy(position, middle+1, m)\n                    if result2:\n                        return middle + 1\n                    else:\n                        return middle\n                start = middle\n            else:\n                end = middle - 1\n\n        return start\n\n    def is_satisfy(self, position, maxd, m):\n        pre_postion = position[0]\n        index = 1\n        left_count = m-1\n\n        pcount = len(position)\n\n        while index < pcount:\n            if position[index] - pre_postion < maxd:\n                index += 1\n                continue\n\n            left_count -= 1\n            if left_count == 0:\n                return True\n\n            pre_postion = position[index]\n            index+=1\n\n        return False\n\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l,r = 1, position[-1]\n        while l < r:\n            mid = ( r + l +1  ) //2 \n            cnter = 0\n            lst = - (2*mid)\n            for i in position:\n                if i - lst >=  mid:\n                    cnter += 1\n                    lst = i \n            if cnter >= m:\n                l = mid\n            else:\n                r = mid -1\n        return l\n", "class Solution:\n    # [22,57,74,79]\n    def possibleForce (self,force, position):\n        count = 0\n        lastBall = 0\n        for i in range (0,len(position)):\n            if (i == 0 or (position[i]- position[lastBall]) >= force):\n                count +=1\n                lastBall =i\n        return  count \n                \n            \n            \n    def maxDistance(self, position: List[int], m: int) -> int:   \n        position.sort()\n        #print(position)\n        maxReally = (position[-1] -position[0] )/ (m-1)\n        #print (maxReally)\n        maxForce = maxReally\n        minForce = 1\n        result = -1\n        \n        while (minForce <= maxForce and minForce >0 and maxForce <= maxReally):\n            middleForce = minForce + (maxForce - minForce) // 2\n            print((minForce, maxForce, middleForce))\n            count =  self.possibleForce(middleForce, position)\n            print (count)\n            if count >= m:\n                # go right\n                minForce = middleForce + 1\n                result = middleForce\n            else:\n                # go left\n                maxForce = middleForce - 1\n\n        return int(result )\n                \n                    \n                \n            \n        \n        \n   \n    \n    #x o o x o o x - o x\n            \n             \n             \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n\n        result = 0\n\n        # can we place m balls each separated by x distance?\n        def check(x) -> bool:\n            nonlocal position, m\n\n            last = position[0]\n            placed = 1\n            for pos in position:\n                if pos - last >= x:\n                    placed += 1\n                    if placed >= m:\n                        return True\n                    last = pos\n\n            return False\n\n\n\n        first = 0\n        last = int(ceil((position[-1] - position[0])/(m-1)))\n        while first < last:\n\n            mid = (first + last + 1)//2\n\n            if check(mid):\n                result = mid\n                first = mid\n            else:\n                last = mid - 1\n\n        return first", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        left = 1\n        right = position[-1] - position[0]\n        \n        def countBalls(dist):\n            curr, balls = position[0], 1;\n            for i in position:\n                if (i-curr >= dist):\n                    balls += 1\n                    curr = i\n            return balls\n        \n        while (left <= right):\n            mid = (left + right) // 2\n            if (countBalls(mid) >= m):\n                left = mid + 1\n            else:    \n                right = mid - 1\n        \n        return right\n            \n            \n                \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l = 0\n        r = 1 + position[-1] - position[0]\n        while l + 1 < r:\n            med = (l + r) // 2\n            cnt = 0\n            pre = position[0] - 2*med\n            for x in position:\n                if x - pre >= med:\n                    pre = x\n                    cnt += 1\n            if cnt >= m: l = med\n            else: r = med\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        positions = sorted(position)\n        l, r = 1, positions[len(position) - 1] - positions[0]\n        while l < r:\n            mid = math.ceil((l + r) / 2)\n            if self.balls(positions, mid) >= m:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n\n    def balls(self, positions, d):\n        curr, ans = -10 ** 10, 0\n        for position in positions:\n            if position - curr >= d:\n                curr = position\n                ans += 1\n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        if m==2:\n            return position[-1]-position[0]\n        else:\n            l=1;r=position[-1]\n            while l<r:\n                mid=(l+r)//2\n                prev,balls=-1000000000,0\n                for p in position:\n                    if p-prev>=mid:\n                        balls+=1\n                        if balls==m: break\n                        prev=p\n                if balls==m:\n                    ans=mid\n                    l=mid+1\n                else: r=mid\n\n        return ans", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def count(dist):\n            prev, balls = position[0], 1\n            for p in position[1:]:\n                if p - prev >= dist:\n                    balls += 1\n                    if balls == m:\n                        break\n                    prev = p\n            return balls\n        \n        l, r = 1, position[-1]\n        res = 0\n        while l < r:\n            mid = (l + r) // 2\n            balls = count(mid)\n            if balls == m:\n                res = mid\n                l = mid + 1\n            else:\n                r = mid\n        return res", "from bisect import bisect_left\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # log(D) * log(N) * M\n        n = len(position)\n        position.sort()\n        left, right = 1, (position[-1]-position[0])//(m-1)\n        ans = 1\n        while left <= right:\n            mid = (left+right)//2\n            #print(left, right, mid)\n            head = 0\n            remains = m-1\n            while remains > 0:\n                target = position[head] + mid\n                if target > position[-1]:\n                    break\n                head = bisect_left(position, target, head)\n                remains -= 1\n                \n            if remains == 0:\n                #ans = mid\n                left = mid+1\n            else:\n                right = mid-1\n                \n        return right", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        \n        def count(d):\n            ans, curr = 1, position[0]\n            for x in position[1:]:\n                if x - curr >= d:\n                    ans, curr = ans+1, x\n            return ans\n        \n        l, r = 1, position[-1] - position[0] + 1\n        while l < r:\n            p = l + (r - l) // 2\n            if count(p) >= m: l = p+1\n            else: r = p\n        return l-1", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        if m == 2:\n            return position[-1] - position[0]\n        \n        def count(dist):\n            prev, balls = position[0], 1\n            for p in position[1:]:\n                if p - prev >= dist:\n                    balls += 1\n                    if balls == m:\n                        break\n                    prev = p\n            return balls\n        \n        l, r = 1, position[-1]\n        res = 0\n        while l < r:\n            mid = (l + r) // 2\n            balls = count(mid)\n            if balls == m:\n                res = mid\n                l = mid + 1\n            else:\n                r = mid\n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n#         def pd(i, m):\n#             if m == 1:\n#                 return float(\\\"inf\\\")\n            \n#             if memo[i][m]:\n#                 return memo[i][m]\n            \n#             res = 0\n            \n#             for j in range(i+1, len(position)):\n#                 res = max(res, min(position[j] - position[i], pd(j, m-1)))\n                \n#             memo[i][m] = res\n            \n#             return res\n        \n#         position = sorted(position)\n        \n#         memo = [(1 + m) * [0] for _ in range(1 + len(position))]\n        \n#         res = pd(0, m)\n    \n        position = sorted(position)\n        \n        if m == 2:\n            return position[-1] - position[0]\n        \n        def solve(threshold, m):\n            last_ball_pos = position[0]\n            tot = 1\n            \n            for pos in position:\n                if pos - last_ball_pos >= threshold:\n                    tot += 1\n                    last_ball_pos = pos\n                \n            return tot >= m\n        \n        start = 0\n        end = position[-1] - position[0]\n        \n        res = 0\n        \n        while start <= end:\n            middle = start + (end - start) // 2\n                \n            if solve(middle, m):\n                start = middle + 1\n                res = max(res, middle)\n                \n            else:\n                end = middle - 1\n    \n        return res", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        \n        position.sort()\n        maxForce = (position[-1] - position[0]) // (m - 1)\n        minForce = 1        \n        \n        while maxForce > minForce:\n            maxMinForce = (maxForce + minForce + 1) // 2\n            #print(minForce, maxForce, maxMinForce)\n            if self.canPut(position, m, maxMinForce):\n                minForce = maxMinForce\n            else:\n                maxForce = maxMinForce - 1\n        \n        return minForce\n    \n    def canPut(self, position: List[int], m: int, force: int) -> bool:\n        putCnt = 0\n        prePos = -1\n        for pos in position:\n            if prePos == -1 or pos - prePos >= force:\n                putCnt += 1\n                prePos = pos\n                if putCnt == m:\n                    return True\n        \n        return False", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position = sorted(position)\n        max_possible = (position[-1] - position[0]) // (m - 1)\n        right = max_possible\n        left = 0\n        mid = max_possible // 2\n        while left <= right:\n            if self.check(position, m, mid):\n                left = mid + 1\n                mid = (left + right) // 2\n            else:\n                right = mid - 1\n                mid = (left + right) // 2\n        \n        return mid\n        \n    \n    def check(self, position, m, force):\n        p = 1\n        m -= 1\n        prev_pos = position[0]\n        while p < len(position):\n            if position[p] - prev_pos >= force:\n                m -= 1\n                prev_pos = position[p]\n            if not m:\n                return True\n            p += 1\n        return False\n\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        left = 1\n        right = position[-1] - position[0]\n        \n        def countBalls(dist):\n            curr, balls = position[0], 1;\n            for i in position:\n                if (i-curr >= dist):\n                    balls += 1\n                    curr = i\n            return balls\n        \n        while (left <= right):\n            mid = (left + right) // 2\n            \n            if (countBalls(mid) >= m):\n                left = mid + 1\n            else:    \n                right = mid - 1\n        \n        return right\n            \n            \n                \n        \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r = 1, position[-1] - position[0]\n        \n        def isValid(val):\n            ball = 1\n            previous = position[0]\n            for p in position:\n                if p - previous < val:\n                    continue\n                ball += 1\n                previous = p\n            return ball >= m\n        \n        while l < r:\n            mid = l + (r - l + 1) // 2\n            if isValid(mid):\n                l = mid\n            else:\n                r = mid - 1\n        return r", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        if m == 2: return position[-1] - position[0]\n        l, r = 1, position[-1]\n        ans = 0\n        while l < r:\n            mid = (l + r) // 2\n            prev, balls = -1000000000, 0\n            for p in position:\n                if p - prev >= mid:\n                    balls += 1\n                    if balls == m: break\n                    prev = p\n            if balls == m:\n                ans = mid\n                l = mid + 1\n            else:\n                r = mid\n        return ans\n        \n                \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        if m == 2: return position[-1] - position[0]\n        l, r = 1, position[-1]\n        ans = 0\n        while l < r:\n            mid = (l + r) // 2\n            prev, balls = -1000000000, 0\n            for p in position:\n                if p - prev >= mid:\n                    balls += 1\n                    if balls == m: break\n                    prev = p\n            if balls == m:\n                ans = mid\n                l = mid + 1\n            else:\n                r = mid\n        return ans\n        \n", "class Solution:\n    def maxDistance(self, a: List[int], m: int) -> int:        \n        def check(d):\n            x, k = 0, m            \n            for i in range(len(a)):\n                if a[i] >= x: \n                    x, k = a[i] + d, k - 1\n                    if k == 0: break                             \n            return k == 0            \n        a.sort()                \n        l, r = 1, (max(a) - min(a)) // (m-1)                        \n        while l + 1 < r:\n            d = (l + r) // 2            \n            if check(d): l = d\n            else: r = d - 1                            \n        return r if check(r) else l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        res = 0\n        l, r = 1, (position[-1] - position[0]) // (m - 1) + 1\n        \n        while l < r:\n            mid = (l + r) // 2\n            prev = position[0]\n            ball = 1\n            for i in position[1:]:\n                if i - prev >= mid:\n                    ball += 1\n                    if ball == m:\n                        break\n                    prev = i\n                    \n            if ball == m:\n                l = mid + 1\n                res = mid\n            else:\n                r = mid\n        return res\n        \n                \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        def ball_count(distance):\n            prev,cnt=position[0],1\n            for pos in position[1:]:\n                if pos-prev>=distance:\n                    cnt+=1\n                    prev=pos\n            return cnt\n                \n            \n            \n            \n            \n        position.sort()\n        n=len(position)\n        l,r=0,position[-1]-position[0]\n        while l<r:\n            mid=r-(r-l)//2\n            if ball_count(mid)>=m:\n                l=mid\n            else:\n                r=mid-1\n        return l\n        \n", "import bisect\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        position_set = set(position)\n        position.sort()\n        max_force = (position[-1] - position[0])//(m-1)\n        min_force = 1\n        last_idx = len(position)-1\n        \n        \n        while min_force != max_force:\n            mid_force = (min_force + max_force + 1) // 2\n            first_ball = next_ball = position[0]\n            next_idx = 1\n            \n            for _ in range(m-2):\n                next_ball = first_ball+mid_force\n                \n                if next_ball not in position_set:\n                    \n                    # search the next larger\n                    next_idx = bisect.bisect_left(position, next_ball, next_idx, last_idx)\n                    next_ball = position[next_idx]\n                    if next_idx == last_idx:\n                        break\n\n                next_idx += 1\n                first_ball = next_ball\n            else:\n                if position[-1] - next_ball >= mid_force:\n                    min_force = mid_force\n                else:\n                    max_force = mid_force-1\n                continue\n            max_force = mid_force-1\n        \n        return min_force\n            \n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        def check(dist, m):\n            last = position[0]\n            for i in range(1, len(position)):\n                if(position[i]-last >= dist):\n                    m-=1\n                    last=position[i]\n            return(m<=1)\n        l=0; r=position[-1]-position[0]\n        while(l<r):\n            mid=l+((r-l+1)>>1)\n            if(check(mid, m)):\n                l=mid\n            else:\n                r=mid-1\n        return(l)", "class Solution:\n    def maxDistance(self, positions: List[int], m: int) -> int:\n        positions.sort()\n\n        def check(value) -> bool:\n            last = positions[0]\n            count = 1\n\n            for pos in positions:\n                if pos-last > value:\n                    count += 1\n                    last = pos\n                    if count >= m:\n                        return False\n\n            return True\n\n        left, right = 1, max(positions)\n        while left < right:\n            mid = left + (right - left) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n\n        return left", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        #\u6c42\u4e24\u7403\u4e4b\u95f4\u7684\u6700\u5c0f\u6700\u5927\u503c\n        position.sort()\n        l,r=0,position[-1]-position[0]  #\u4e24\u7403\u4e4b\u95f4\u7684\u8ddd\u79bb\n        while l<r:\n            mid=(l+r+1)//2\n            count=1\n            last=position[0]\n            for a in position[1:]:\n                if a-last>=mid:\n                    count+=1\n                    last=a\n            if count<m:\n                r=mid-1\n            else:\n                l=mid\n        return l", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        \n        def canPut(distance: int)->bool:\n            count = 1\n            curr = position[0]\n            for pos in position[1:]:\n                if pos >= curr+distance:\n                    count += 1\n                    curr = pos\n                    if count >= m:\n                        return True\n            return False\n        \n        position.sort()\n        lo, hi = 1, position[-1]-position[0]\n        max_distance = lo\n        \n        while lo <= hi:\n            mi = (lo+hi)//2\n            if canPut(mi):\n                lo = mi+1\n                max_distance = max(max_distance, mi)\n            else:\n                hi = mi-1\n            #print(lo, hi)\n        \n        return max_distance\n            \n", "class Solution:\n    def maxDistance(self, a: List[int], m: int) -> int:        \n        def check(d):\n            x, k = 0, m            \n            for i in range(len(a)):\n                if a[i] >= x: \n                    x, k = a[i] + d, k - 1\n                    if k == 0: break                             \n            return k == 0            \n        a.sort()                \n        l, r = 1, (max(a) - min(a)) // (m-1)                        \n        while l + 1 < r:\n            d = (l + r) // 2            \n            if check(d): l = d\n            else: r = d - 1                            \n        return r if check(r) else l\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        def working(mid: int):\n            prev_stall = 0\n            stall = 1\n            # print(position)\n            for i in range(1, m):\n                while (position[stall] - position[prev_stall]) < mid:\n                    stall+=1\n                    if stall == len(position):\n                        return False\n                prev_stall = stall\n            \n            return True\n        \n        L = max(position)\n        \n        low = 1\n        high = int(L/(m-1))\n        largest = 0\n        position = sorted(position)\n        \n        while low <= high:\n            mid = int((low+high)/2)\n            \n            if working(mid):\n                if mid < int(L/(m-1)):\n                    low = mid + 1\n                else:\n                    largest = max(largest, mid)\n                    break\n                largest = max(largest, mid)\n            elif mid > 0:\n                high = mid - 1\n        \n        return largest\n                \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        n = len(position)\n        left,right = 0,position[-1]-position[0] // (m-1) # search space is sorted\n        def count_balls(force):\n            balls,prev = 1,position[0]\n            for cur in position[1:]:\n                if cur-prev >= force:\n                    balls += 1\n                    prev = cur\n            return balls\n        while left < right:\n            # mid = left + (right-left)//2\n            mid = right - (right-left) // 2\n            # mid = (left+right+1)//2\n            if count_balls(mid) >= m:\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n            \n            \n            \n            \n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        left = 1\n        right = max(position)\n        position.sort()\n        \n        while left < right:\n            mid = left + (right - left)//2\n            legal = self.evaluate(position, m, mid)\n            if legal:\n                right = mid \n            else:\n                left = mid + 1\n        \n        return left - 1\n            \n            \n    def evaluate(self, position, m, force):\n        balls_placed = 0 \n        prev_val = None\n        for val in position:\n            if not prev_val:\n                prev_val = val\n                balls_placed += 1\n            else:\n                if val - prev_val >= force:\n                    balls_placed += 1\n                    prev_val = val\n        if balls_placed > m-1:\n            return False\n        return True", "import math\nclass Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        n = len(position)\n        position.sort()\n        diff = []\n        for i in range(n-1):\n            diff.append(position[i+1]-position[i])\n        \n        def check(force,diff,num):\n            i = 0\n            j = 0\n            curr = 0\n            while i < len(diff):\n                curr += diff[i]\n                if curr >= force:\n                    j += 1\n                    curr = 0\n                i += 1\n            return j >= num\n        \n        if m == 2:\n            return position[n-1]-position[0]\n        \n        start = 1\n        end = math.ceil((position[n-1]-position[0])/(m-1))\n        mid = (start+end)//2\n        ansList = []\n        while start < end:\n            if check(mid,diff,m-1):\n                start = mid+1\n                ansList.append(mid)\n            else:\n                end = mid-1\n            mid = (start+end)//2\n        if check(mid,diff,m-1):\n            ansList.append(mid)\n        return max(ansList)\n                \n\n", "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        l, r = 1, position[len(position) - 1] - position[0]\n        def is_doable(gap):\n            count, pre  = 0, position[0] - 2 * gap, \n            for element in position:\n                if element - pre >= gap:\n                    pre = element\n                    count += 1\n                    if count == m:\n                        return True\n            return False\n            \n        while True:\n            mid = (l + r) // 2\n            if is_doable(mid):\n                if mid == position[len(position) - 1] - position[0]:\n                    return mid\n                elif is_doable(mid + 1):\n                    l = mid + 1\n                else:\n                    return mid\n            else:\n                r = mid - 1\n            \n", "class Solution:\n    def maxDistance(self, position: List[int], k: int) -> int:\n        position.sort()\n        def check(m):\n            prev = -1e20\n            c = 0\n            for i in position:\n                if i - prev >= m:\n                    prev = i\n                    c+=1\n            return c>=k\n        l = 0\n        r = max(position)\n        while l < r:\n            m = (l+r+1)//2\n            if check(m):\n                l = m\n            else:\n                r = m-1\n        return l"]
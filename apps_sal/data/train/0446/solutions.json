["# O(n) time and space\n# Hashmap and array\n# Count number then count occurrence:\n# Count the occurrences of each number using HashMap;\n# Keep a count of different occurences\n# From small to big, for each unvisited least frequent element, deduct from k the multiplication with the number of elements of same occurrence, check if reaching 0, then deduct the corresponding unique count remaining.\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        freq = collections.Counter(arr)\n        distinct = len(freq)\n        freq_count = collections.Counter(list(freq.values()))\n        \n        idx = 1\n        while k>0:\n            if k - idx*freq_count[idx] >= 0:\n                k -= idx*freq_count[idx]\n                distinct -= freq_count[idx]\n                idx += 1\n            else:\n                # can't remove all, but can remove partially\n                # [2,4,1,8,3,5,1,3], 3\n                return distinct - k // idx\n        return distinct\n                \n        \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count = Counter(arr)\n        unique = len(count)\n        for v in sorted(count.values()):\n            if v <= k:\n                unique -= 1\n                k -= v\n            else:\n                break\n        return unique", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        char_freq_map = {}\n        for num in arr:\n            if num in char_freq_map:\n                char_freq_map[num] += 1\n            else:\n                char_freq_map[num] = 1\n        \n        freq_to_char_map = {}\n        freqs = []\n        for key in char_freq_map:\n            if char_freq_map[key] in freq_to_char_map:\n                freq_to_char_map[char_freq_map[key]].append(key)\n            else:\n                freqs.append(char_freq_map[key])\n                freq_to_char_map[char_freq_map[key]] = [key]\n        \n        i = 0\n        freqs.sort()\n        ans = 0\n        while(1):\n            if k == 0:\n                break\n            freq = freqs[i]\n            if k >= len(freq_to_char_map[freq])*freq:\n                k -= len(freq_to_char_map[freq])*freq\n                i += 1\n            else:\n                ans += len(freq_to_char_map[freq]) - k//freq\n                k = 0\n                i += 1\n        \n        print(freq_to_char_map)\n        while(i < len(freqs)):\n            ans += len(freq_to_char_map[freqs[i]])\n            i += 1\n        return ans ", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        #heap with key to be count of each number\n        d = defaultdict(int)\n        for i in arr:\n            d[i] += 1\n        \n        heap = []\n        for key, val in d.items():\n            heappush(heap, (val, key))\n        if k == 0:\n            return len(heap)\n        while k > 0:\n            if not heap:\n                return 0\n            count = heappop(heap)[0]\n            if k < count:\n                res = len(heap) + 1\n                break\n            elif k == count:\n                \n                res = len(heap)\n                break\n            else:\n                k -= count\n        return res", "import heapq\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        nums = {}\n        \n        for i in arr:\n            \n            if i in nums:\n                nums[i] += 1\n            else:\n                nums[i] = 1\n        \n        # print(nums)\n        \n        \n        queue = [ (nums[i], i) for i in nums]\n        \n        # print(queue)\n        \n        heapq.heapify(queue)\n        \n        # print(queue)\n        \n        while len(queue) > 0 and k > 0:\n            \n            count, n = heapq.heappop(queue)\n            \n            if k >= count:\n                k = k - count\n            else:\n                # print('yes', queue, count, n, k)\n                count = count - k\n                k = 0\n                heapq.heappush(queue, (count, n))\n                # print(queue)\n            \n        \n        # print(queue)\n        \n        return len(queue)\n        \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter = Counter(arr)\n        items = sorted(list(counter.items()), key=lambda x: -x[1])\n        left = k\n        while left > 0 and items:\n            if items[-1][1] <= left:\n                left -= items[-1][1]\n                items.pop()\n            else:\n                break\n        return len(items)\n\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        s = sorted(arr,key = lambda x:(c[x],x))\n        return len(set(s[k:]))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        \n        \n        count = Counter(arr)\n        nums = [(v, k) for k, v in list(count.items())]\n        heapq.heapify(nums)\n        for _ in range(k):\n            v, k = heapq.heappop(nums)\n            if v > 1:\n                heapq.heappush(nums, (v-1, k))\n        return len(nums)\n", "from collections import Counter\n\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        L = len(arr)\n        d = [[] for _ in range(L+1)]\n        counter = Counter(arr)\n\n        for key, count in list(counter.items()):\n            d[count].append(key)\n        \n        for count in range(L+1):\n            if k == 0:\n                break\n\n            while d[count] and k >= count:\n                item = d[count].pop()\n                del counter[item]\n                k -= count\n\n        return len(counter)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counts = collections.Counter(arr)\n        arr.sort()\n        arr1 = sorted(arr, key=lambda x: counts[x])\n        print(arr1)\n        if k != 0:\n            del arr1[:k]\n            \n        return len(set(arr1))", "from collections import Counter\nimport heapq\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        arrCount = Counter(arr)\n        heap = []\n        for num in arr:\n            heapq.heappush(heap, (arrCount[num], num))\n        \n        while k > 0:\n            num = heapq.heappop(heap)[1]\n            arrCount[num] -= 1\n            if arrCount[num] == 0:\n                del arrCount[num]\n            k-=1\n        return len(arrCount)    ", "from collections import Counter\nimport heapq\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        freq = Counter(arr)\n        count_num = []\n        for num, count in freq.items():\n            count_num.append((count, num))\n        heapq.heapify(count_num)\n        print(count_num)\n        while k > 0:\n            count, num = heapq.heappop(count_num)\n            k -= count\n        if k == 0:\n            return len(count_num)\n        elif k < 0:\n            return len(count_num) + 1", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr, k):\n        c = Counter(arr)\n        s = sorted(arr, key = lambda x: (c[x],x))\n        return len(set(s[k:]))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        nums = {}\n        \n        for i in arr:\n            \n            if i in nums:\n                nums[i] += 1\n            else:\n                nums[i] = 1\n        \n        # print(nums)\n        \n        import heapq\n        \n        queue = [ (nums[i], i) for i in nums]\n        \n        # print(queue)\n        \n        heapq.heapify(queue)\n        \n        # print(queue)\n        \n        while len(queue) > 0 and k > 0:\n            \n            count, n = heapq.heappop(queue)\n            \n            if k >= count:\n                k = k - count\n            else:\n                # print('yes', queue, count, n, k)\n                count = count - k\n                k = 0\n                heapq.heappush(queue, (count, n))\n                # print(queue)\n            \n        \n        # print(queue)\n        \n        return len(queue)\n        \n", "import collections\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter = collections.Counter(arr)\n        \n        value_counter = collections.Counter(list(counter.values()))\n        remaining = len(counter)\n        \n        for val_count_key in range(1, len(arr) + 1):\n            if k >= val_count_key * value_counter[val_count_key]:\n                k -= val_count_key * value_counter[val_count_key]\n                remaining -= value_counter[val_count_key]\n            else:\n                return remaining - k//val_count_key\n            \n        return remaining\n        \n        \n        \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        cnts = Counter(arr)\n        \n        sorted_cnts = sorted(cnts.items(), key=lambda x: x[1])\n        for key, val in sorted_cnts:\n            if val <= k:\n                del cnts[key]\n                k -= val\n            else:\n                break\n        return len(cnts)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        A = dict(Counter(arr))\n        B = [(item, A[item]) for item in A]\n        B.sort(key=lambda x:x[1], reverse = True)\n        result = len(B)\n        while k > 0:\n            if k >= B[-1][1]:\n                k -= B[-1][1]\n                result -= 1\n                B.pop()\n            else:\n                k = 0\n        return result", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        freq = defaultdict(lambda : 0)\n        for i in arr:\n            freq[i] += 1\n        tup = []\n        for i in freq:\n            tup.append((freq[i], i))\n        tup = sorted(tup)\n        count = len(freq)\n        \n        for i in tup:\n            k -= i[0]\n            if k < 0:\n                break\n            count -= 1\n        return count\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        temp = sorted(c, key= lambda x: (c[x], -x))\n        for i in temp:\n            if k > 0:\n                k -= c[i]\n                if k < 0:\n                    c[i] = -k\n                else:\n                    c[i] = 0\n        return sum(c[i] > 0 for i in c)\n                \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        if k == len(arr):\n            return 0\n        d = dict()\n        for i in arr:\n            if i in list(d.keys()):\n                d[i] += 1\n            else:\n                d[i] = 1\n        lst = [[v, k] for k, v in list(d.items())]\n        lst.sort()\n        res = []\n        for i in lst:\n            for _ in range(i[0]):\n                res.append(i[1])\n        return len(set(res[k:]))\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        d = {}\n        \n        for i in arr:\n            if i in d:\n                d[i]+=1\n            else:\n                d[i]=1\n                \n        values  = [[v,k] for k,v in list(d.items())]\n        \n        values.sort()\n        \n        for i in values:\n            if i[0] <=k:\n                k = k - i[0]\n                i[0] = 0\n        count = 0\n        for i in values:\n            if i[0]!=0:\n                count = count +1\n        return count\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        import collections\n        d = collections.Counter(arr).most_common()[::-1]\n        for i in range(len(d)):\n            k -= d[i][1]\n            if k < 0:\n                return len(d) - i\n        return 0\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        if k >= len(arr) - 1:\n            return len(arr) - k\n\n        counter = sorted(Counter(arr).values())\n        print(counter)\n        ptr = 0\n        while k >= 0:\n            k -= counter[ptr]\n            ptr += 1\n        \n        return len(counter) - ptr + 1\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n\n        # create a dictionary of {number: count}\n        num_count_dict = {}\n        for num in arr:\n            if num in num_count_dict:\n                num_count_dict[num] += 1\n            else:\n                num_count_dict[num] = 1\n                \n        # create a dictionary of {count: a_list_of_number}\n        num_dict = {}\n        for num in num_count_dict.keys():\n            count = num_count_dict[num] \n            if count in num_dict:\n                num_dict[count].append(num)\n            else:\n                num_dict[count] = [num]\n        \n        # sorted num_dict by each number's count\n        sorted_num_by_count = sorted(num_count_dict.items(), key=lambda x: x[1])\n        print(sorted_num_by_count)\n        for i in range (0, len(sorted_num_by_count)):\n            num = sorted_num_by_count[i][0] # get dict key\n            #print('num={}, k={}, num_count_dict={}'.format(num, k, num_count_dict[num]))\n            num_count = num_count_dict[num]\n            if num_count <= k:\n                del num_count_dict[num]\n            else:\n                num_count_dict[num] = num_count_dict[num]-k\n            k = k-num_count\n            if k == 0:\n                break\n        return len(num_count_dict)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        s = sorted(arr,key = lambda x:(c[x],x))\n        print(s)\n        return len(set(s[k:]))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter = {}\n        for id in arr:\n            counter[id] = counter.get(id, 0) + 1\n        id2count = sorted([[count, id] for id, count in counter.items()], key=lambda x: (-x[0], x[1]))\n        for i in range(len(id2count) - 1, -1, -1):\n            count = id2count[i][0]\n            if k - count < 0:\n                break\n            id2count.pop()\n            k -= count\n        return len(id2count)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        freq = defaultdict(int)\n        for num in arr: freq[num] += 1\n        freq_arr = []\n        for t, v in freq.items():\n            freq_arr.append([v,t])\n        freq_arr.sort(reverse= True)\n        while k > 0:\n            amount, rem = freq_arr.pop()\n            if amount <= k:\n                del freq[rem]\n                k -= amount\n            else:\n                freq[rem] = amount - k\n                k = 0\n        return len(freq)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        freqm = collections.defaultdict(int)\n        \n        for a in arr:\n            freqm[a] += 1\n            \n        heap = []\n        \n        for key, val in freqm.items():\n            heapq.heappush(heap, (val, key))\n            \n        totalKeys = len(heap)\n        count = 0\n        \n        while k > 0 and heap:\n            val, key = heapq.heappop(heap)\n            if k >= val:\n                k -= val\n                count += 1\n            else:\n                break\n        \n        return totalKeys - count", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        if not arr:\n            return 0\n        \n        dic = collections.defaultdict(int)\n        for n in arr:\n            dic[n] += 1\n        \n        l = []\n        \n        for key, val in dic.items():\n            l.append([key,val])\n            \n        l.sort(key = lambda x: x[1])\n        # print(l)\n        count = len(l)\n        \n        for i in range(len(l)):\n            if k == 0:\n                break\n            n = min(k, l[i][1])\n            l[i][1] -= n\n            k -= n\n            if l[i][1] == 0:\n                count -= 1\n                i -= 1\n            \n        # print(l)\n        return count", "from collections import Counter\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        # im going to use a map, and we need to sort the map based on \n        m = Counter(arr)\n        \n        for x,y in sorted(list(m.items()), key=lambda x: x[1]):\n            if k < 1:\n                break\n            \n            a = max(y-k, 0)\n            if a == 0:\n                m.pop(x)\n            k = max(k-y, 0)\n        \n        return len(m)\n            \n\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter = collections.Counter(arr)\n        for i,value in sorted(counter.items(), key = lambda x: x[1]):\n            val = k\n            k -= value\n            counter[i] -= val\n            if counter[i] <= 0:\n                del counter[i]\n        return len(counter)", "from collections import OrderedDict\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        # im going to use a map, and we need to sort the map based on \n        m = {}\n        for i in arr:\n            m[i] = m.get(i, 0) +1\n        \n        for x,y in sorted(list(m.items()), key=lambda x: x[1]):\n            if k < 1:\n                break\n            \n            a = max(y-k, 0)\n            if a == 0:\n                m.pop(x)\n            k = max(k-y, 0)\n        \n        return len(m)\n            \n\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        dic, a = {}, []\n        for x in arr:\n            dic[x] = dic.get(x, 0) + 1\n        for x in dic:\n            a.append(dic[x])\n        a.sort(reverse = True)\n        while a:\n            x = a.pop()\n            if x > k:\n                return len(a) + 1\n            k -= x\n        return 0\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         dic, count = {}, []\n#         for x in arr:\n#             dic[x] = dic.get(x,0)+1\n        \n#         for x in dic:\n#             count.append(dic[x])\n#         count.sort(reverse = True)\n#         while k > 0 and count:\n#             if k - count[-1] >= 0:\n#                 k -= count[-1]\n#                 count.pop()\n#             else:\n#                 k -= count[-1]\n\n#         return(len(count))\n                \n                \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        s = sorted(arr,key = lambda x:(c[x],x))\n        return len(set(s[k:]))\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        cnts = collections.Counter(arr)\n        heap = [(v, k) for k, v in cnts.items()]\n        heapq.heapify(heap)\n        for _ in range(k):\n            cnt, val = heapq.heappop(heap)\n            cnt -= 1\n            if cnt != 0:\n                heapq.heappush(heap, (cnt, val))\n\n        return len(heap)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        c = collections.Counter(arr)\n        for n in sorted(c, key = lambda num: c[num]):\n            if c[n] <= k:\n                k -= c[n]\n                del c[n]\n            else:\n                break\n        \n        return len(c)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        if k==len(arr):\n            return(0)\n        \n        countDict = dict()\n        \n        for x in arr:\n            if x not in countDict:\n                countDict[x] = 0\n            countDict[x] += 1\n            \n        from heapq import heappush, heappop, heapify\n        \n        minHeap = []\n        \n        for x in list(countDict.keys()):\n            heappush(minHeap, [countDict[x], x])\n        \n        while(k>0):\n            if k>=minHeap[0][0]:\n                k -= minHeap[0][0]\n                heappop(minHeap)\n            else:\n                if len(minHeap)==1:\n                    minHeap[0][0] -= k\n                    k = 0\n                else:\n                    k = 0\n                    \n        return(len(minHeap))\n                    \n", "from collections import Counter\n\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        s = sorted(arr, key = lambda x:(c[x],x))\n        return len(set(s[k:]))\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count = collections.Counter(arr)\n        \n        arr = list(reversed([item for items, c in count.most_common() for item in [items] * c]))\n        \n        #print(arr, arr[k:])\n        return len(collections.Counter(arr[k:]))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        import heapq\n        \n        vals = {}\n        \n        for val in arr:\n            if val in vals:\n                vals[val] += 1\n            else:\n                vals[val] = 1\n        \n        hp = []\n        for val in vals:\n            hp.append(vals[val])\n        \n        heapq.heapify(hp)\n    \n        #count represents the number of elements popped\n        while(k > 0 and len(hp)):\n            curr = heapq.heappop(hp)\n            if curr <= k:\n                k = k - curr\n            else:\n                k = curr - k\n                heapq.heappush(hp, k)\n                break\n        return len(hp)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        mapp = {}\n        for item in arr:\n            if item in list(mapp.keys()):\n                mapp[item] += 1\n            else:\n                mapp[item] = 1\n                \n        sort_mapp = {c: v for c, v in sorted(list(mapp.items()), key=lambda x: x[1])}\n        \n        for c, v in list(sort_mapp.items()):\n            if v - k > 0:\n                sort_mapp[c] -= k\n                break\n            else:\n                k = (v - k) * -1\n                sort_mapp[c] = 0\n                if k <= 0:\n                    break\n                \n        count = 0\n        for c, v in list(sort_mapp.items()):\n            if v > 0:\n                count += 1\n                \n        return count\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        cnt = collections.Counter(arr)\n        key = sorted(cnt, key = lambda x: cnt[x])\n        n_unique = len(key)\n        # print(key)\n        for i in range(n_unique):\n            # print(key[i])\n            k = k-cnt[ key[i] ]\n            if k<0:\n                return n_unique-i\n            elif k == 0:\n                return n_unique-i-1\n        \n        return 0", "from collections import Counter\nfrom collections import deque\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count = Counter(arr)\n        count = deque(sorted([(count[k], k) for k in count]))\n        # print(count)\n        while count and k >= count[0][0]:\n            k-=count.popleft()[0]\n        return len(count)\n                \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = collections.Counter(arr)\n        \n        for cnt, num in sorted((v,k) for k, v in c.items()):\n            if cnt <= k:\n                del c[num]\n                k -= cnt\n        \n        return len(c)", "class CountClass:\n    def __init__(self, value, frequency):\n        self.value = value\n        self.frequency = frequency\n    def __lt__(self, other):\n        return self.frequency < other.frequency\n    def getValue(self):\n        return self.value\n    def getFrequency(self):\n        return self.frequency\n    \nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        if not arr:\n            return 0\n        \n        import heapq\n        \n        # This map will keep track of the counts\n        records = {}\n        # Initiate the min-heap\n        q = []\n        \n        # Saving the counts\n        for i in arr:\n            if i not in list(records.keys()):\n                records[i] = 0\n            records[i] += 1\n          \n        for key, value in list(records.items()):\n            heapq.heappush(q, CountClass(key, value))\n        \n        while k != 0 and q:\n            node = heapq.heappop(q)\n            key = node.getValue()\n            val = node.getFrequency()\n            if val == 1:\n                del records[key]\n            else:\n                val -= 1\n                heapq.heappush(q, CountClass(key, val))\n            k -= 1\n        \n        return len(records)\n        \n        \n        \n        \n        \n        \n", "from collections import Counter\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count = Counter(arr)\n        arr = sorted(arr, key = lambda x: (count[x], x))\n        return len(set(arr[k:]))", "import heapq\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        counter = collections.Counter(arr)\n        heap = [(value, key) for key, value in list(counter.items())]\n        \n        heapq.heapify(heap)\n        \n        while k > 0:\n            k -= heapq.heappop(heap)[0]\n        \n        return len(heap) + (k < 0)\n        \n", "import queue\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        temp = {}\n        for n in arr:\n            if n not in temp:\n                temp[n] = 0\n            temp[n] += 1\n        \n        q = queue.PriorityQueue()\n        for n, c in temp.items():\n            q.put((c, n))\n        \n        while k > 0:\n            c, n = q.get()\n            if k < c:\n                q.put((c, c - k))\n                break\n            k -= c\n        \n        return len(q.queue)", "from collections import Counter\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        s = sorted(arr, key=lambda x: (c[x], x))\n        return len(set(s[k:]))", "import queue\n\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n\n        counter = {}\n        for i in arr:\n            if counter.__contains__(i):\n                counter[i] += 1\n            else:\n                counter[i] = 1\n        q = queue.PriorityQueue()\n        for i in counter:\n            q.put((counter[i], i))\n\n        lastCutted = True\n        while k > 0:\n            element = q.get()\n            count = element[0]\n            if k >= count:\n                lastCutted = True\n            else:\n                lastCutted = False\n            k -= count\n\n        if lastCutted:\n            return q.qsize()\n        else:\n            return q.qsize() + 1", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        if k==len(arr):\n            return(0)\n        \n        countDict = dict()\n        \n        for x in arr:\n            if x not in countDict:\n                countDict[x] = 0\n            countDict[x] += 1\n            \n        from heapq import heappush, heappop, heapify\n        \n        minHeap = []\n        \n        for x in list(countDict.keys()):\n            heappush(minHeap, [countDict[x], x])\n        \n        while(k>0):\n            if k>=minHeap[0][0]:\n                k -= minHeap[0][0]\n                heappop(minHeap)\n            else:\n                k -= minHeap[0][0]\n                \n        return(len(minHeap))\n                    \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        d = {}\n        for num in arr:\n            try:\n                d[num] += 1\n            except:\n                d[num] = 1\n        heap = []\n        \n        for key in list(d.keys()):\n            heapq.heappush(heap, (d[key], key))\n        \n        while k:\n            popped = heapq.heappop(heap)\n            key = popped[1]\n            d[key] -= 1\n            if not d[key]:\n                del d[key]\n            else:\n                heapq.heappush(heap, (d[key], key))\n            k -= 1\n        \n        return len(list(d.keys()))\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        a=collections.Counter(arr)\n        b=sorted(a,key=lambda x:a[x])\n        i=0\n        while k:\n            if a[b[i]]<=k:\n                k-=a[b[i]]\n                del b[i]\n            else:\n                k=0\n        return len(b)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        if len(arr) == 0:\n            return 0\n        #sa = list(set(arr))\n        arrcounts = collections.Counter(arr)#[(x, arr.count(x)) for x in sa]\n        #print(arrcounts)\n        #arrcounts.sort(key = lambda x:x[1])\n        arrcounts = sorted(arrcounts.items(), key = lambda x: x[1])\n        i = k\n        j = 0\n        #print(arrcounts)\n        while i > 0 and j < len(arrcounts):\n            i -= arrcounts[j][1]\n            if i >= 0:\n                arrcounts.pop(j)\n            else:\n                j += 1\n        #print(arrcounts)\n        return len(arrcounts)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count=Counter(arr)\n        temp=sorted(arr,key=lambda x:(count[x],x))\n        return len(set(temp[k:]))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        dic = {}\n        for i in arr:\n            if i not in dic:\n                dic[i] = 1\n            else:\n                dic[i] += 1\n        keys = dic.keys()\n        keys = sorted(keys, key=lambda a: dic[a])\n        for index in range(len(keys)):\n            if k == 0:\n                return len(keys)-index\n            elif k-dic[keys[index]] < 0:\n                return len(keys)-index\n            else:\n                k -= dic[keys[index]]\n        return 0", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        h={}\n        for e in arr:\n            if e in h:\n                h[e] +=1\n            else:\n                h[e] =1\n        l=list(h.values())\n        l.sort()\n        while k>0:\n            k= k-l[0]\n            if k>=0:\n                l.pop(0)\n        return len(l)                \n", "from collections import Counter\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        cnt = Counter(arr)\n        cnt = sorted(cnt.values())\n        while k > 0:\n            num = cnt.pop(0)\n            k -= num\n        if k < 0:\n            return len(cnt)+1\n        elif k == 0:\n            return len(cnt)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        cnt = collections.Counter(arr)\n        cnt = sorted(cnt.values())\n        while cnt:\n            num = cnt.pop(0)\n            k -= num\n            if k < 0:\n                return len(cnt)+1\n            elif k == 0:\n                return len(cnt)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        cnt = collections.Counter(arr)\n        cnt = sorted(cnt.values())\n        while k > 0:\n            num = cnt.pop(0)\n            k -= num\n        if k < 0:\n            return len(cnt)+1\n        elif k == 0:\n            return len(cnt)\n", "from collections import Counter\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        cnt = Counter(arr)\n        cnt = sorted(cnt.values())\n        while k>0:\n            num = cnt.pop(0)\n            k -= num\n        if k < 0:\n            return len(cnt)+1\n        elif k == 0:\n            return len(cnt)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        dic={}\n        for i in arr:\n            if i not in dic:\n                dic[i]=1\n            else:\n                dic[i]+=1\n        stack=[u for u in dic.values()]\n        stack.sort()\n        L=len(stack)\n        ans=0\n        while k>0:\n            test=stack.pop(0)\n            if test<=k:\n                ans+=1\n            k-=test         \n        return L-ans", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count = {}\n        for num in arr:\n            if num not in count:\n                count[num] = 0\n            count[num] += 1\n        \n        values = sorted([v for v in count.values()])\n        for _ in range(k):\n            values[0] -= 1\n            if values[0] == 0:\n                del values[0]\n        return len(values)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        dic=collections.defaultdict(int)\n        for i in range(len(arr)):\n            dic[arr[i]]+=1\n        num=[]\n        total=0\n        for key in list(dic.keys()):\n            num.append(dic[key])\n            total+=1\n        num.sort()\n        count=0\n        while(k>0 and num):\n            k-=num[0]\n            num.pop(0)\n            if k<0:\n                break\n            count+=1\n        return total-count\n        \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        arr.sort()\n        occ = []\n        count = 1\n        for i in range(1,len(arr)):\n            if arr[i]==arr[i-1]:\n                count += 1\n            else:\n                occ.append(count)\n                count = 1\n        occ.append(count)\n        occ.sort()\n        res = len(occ)\n        for i in occ:\n            if i<=k:\n                res -= 1\n                k -= i\n            else:\n                break\n        return res\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr) \n        return len(set(sorted(arr, key= lambda x: (c[x], x))[k:]))\n                \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        dic = {}\n        for num in arr:\n            if num not in dic:\n                dic[num] = 0\n            dic[num] += 1\n            \n        l = [v for k, v in sorted(dic.items(), key = lambda item: item[1])]\n        \n        while len(l) > 0 and l[0] <= k:\n            k -= l.pop(0)\n            \n        return len(l)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counted_arr = dict(Counter(arr))\n        counted_arr = sorted(list(counted_arr.items()), key=lambda kv: kv[1], reverse=False)\n        print(counted_arr)\n        \n        while k > 0 and len(counted_arr) > 0:\n            val = counted_arr[0]\n            # print(val)\n            freq = val[1]\n            k -= freq\n            \n            if k >= 0:\n                counted_arr.pop(0)\n            \n        return len(counted_arr)\n", "#from collections import Counter\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        if not arr:\n            return 0\n        dic = collections.Counter(arr)\n        L = sorted(list(dic.values()))\n        \n        while k>=L[0]:\n            k -= L.pop(0)\n            if len(L)==0:\n                return 0\n        return len(L)\n", "from collections import defaultdict\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        nums = defaultdict(int)\n        for num in arr:\n            nums[num] += 1\n        sorted_nums = sorted(nums.items(), key=lambda x: x[1])\n        tmp = k\n        while tmp > 0:\n            n = sorted_nums[0][1]\n            if tmp < n:\n                break\n            tmp -= n\n            sorted_nums.pop(0)\n        return len(sorted_nums)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counts = {}\n        for element in arr:\n            if element in counts:\n                counts[element] += 1\n            else:\n                counts[element] = 1\n        counts_sorted = sorted(counts.items(), key=lambda x: x[1], reverse=False)\n        while len(counts_sorted) > 0 and k >= counts_sorted[0][1]:\n            removed = counts_sorted.pop(0)\n            k -= removed[1]\n        return len(counts_sorted)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        d = dict()\n        for num in arr:\n            if num in d:\n                d[num] += 1\n            else:\n                d[num] = 1\n        \n        for key, value in sorted(d.items(), key=lambda item: item[1]):\n            if k >= value:\n                k -= value\n                del d[key]\n            else:\n                break\n        return len(d)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter = Counter(arr)\n        res = len(counter)\n        \n        for key in list(sorted(counter.keys(),key=lambda x: counter[x])):\n            freq = counter[key]\n            if k>=freq:\n                res -= 1\n                k -= freq\n        \n        return res", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count=collections.Counter(arr)\n        count=sorted(count.values())\n        a=len(count)\n        for i in count:\n            if k>=i:\n                k-=i\n                a-=1\n        return a\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        m = {}\n        for a in arr:\n            if not a in m:\n                m[a] = 1\n            else:\n                m[a] += 1\n        m = dict(sorted(m.items(), key=lambda x: x[1]))\n        count = 0\n        for key, value in m.items():\n            if value <= k:\n                m[key] = 0\n                k -= value\n                count += 1\n            else:\n                break\n        return len(m) - count", "from heapq import heappush, heappop\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        d = {}\n        for i in arr:\n            d[i] = d.get(i,0)+1\n          \n        heap = []\n        for i in d.keys():\n            heappush(heap, (d[i]))\n            \n        while k >0:\n            count = heappop(heap)\n            k-= count\n            if k < 0:\n                return len(heap) + 1\n            \n        return len(heap)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        freq = {}\n        for i in arr:\n            if i in freq.keys():\n                freq[i] += 1\n            else:\n                freq[i] = 1\n        \n        values = []\n        frequencies = []\n        for key in freq.keys():\n            values.append(key)\n            frequencies.append(freq[key])\n        \n        frequencies = sorted(frequencies)\n        distinct = len(frequencies)\n        ind = 0\n        for i in range(distinct):\n            k -= frequencies[i]\n            if (k < 0):\n                return distinct-i\n            elif (k == 0):\n                return distinct-i-1\n            i += 1\n            \n        return 0", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter = collections.Counter(arr)\n        \n        for elem, cnt in sorted(counter.items(), key = lambda x: x[1]):\n            k -= cnt\n            if k >= 0:\n                del counter[elem]\n        return len(counter)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        print(c)\n        cnt, remaining = Counter(c.values()), len(c)\n        print(cnt)\n        \n        for key in range(1, len(arr) + 1): \n            print(cnt[key],key)\n            if k >= key * cnt[key]:\n                k -= key * cnt[key]\n                remaining -= cnt[key]\n            else:\n                #print('In Else during key',key)\n                return remaining - k // key\n                #print('After Return',key)\n        return remaining", "class Solution(object):\n    def findLeastNumOfUniqueInts(self, arr, numLettersToRemove):\n        dictionary = {}\n\n        for num in arr:\n            if num in dictionary:\n                dictionary[num] = dictionary[num] + 1\n            else:\n                dictionary[num] = 1\n\n        # Sort Dictionary by Value\n        dictionary = {key:value for key,value in sorted(dictionary.items(), key=lambda item: item[1])}\n        #print(\\\"Sorted: \\\", dictionary)\n\n\n        keyList = list(dictionary.keys())\n        valueList = list(dictionary.values())\n        keyPointer = 0\n        valuePointer = 0\n        while numLettersToRemove > 0:\n\n            if (valueList[valuePointer] > 0):\n                valueList[valuePointer] = valueList[valuePointer] - 1\n\n            if valueList[valuePointer] == 0:\n                keyPointer += 1\n                valuePointer += 1\n\n            #print(\\\"Key Pointer: \\\", keyPointer)\n            numLettersToRemove -= 1\n\n        outputList = keyList[keyPointer:]\n\n\n        output = outputList.__len__()\n\n        return output", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        #first creating a dictionary of element counts\n        H = dict()\n        for element in arr:\n            if element in H:\n                H[element] += 1 \n            else:\n                H[element] = 1\n        \n        #sort the dictionary\n        H  = {k: v for k, v in sorted(list(H.items()), key=lambda item: item[1])}\n        \n        #initialize some useful variables\n        S = 0\n        M  = len(H)\n        c = 0\n        for val in list(H.values()):\n            S += val\n            c += 1\n            if S == k:\n                return M - c\n            elif S > k:\n                return M - c + 1\n            else:\n                continue\n", "from collections import defaultdict\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        di=defaultdict(int)\n        for i in arr:di[i]+=1\n        p=sorted(list(di.items()),key=lambda x:x[1])\n        n=len(p)\n        i=0\n        while(k>0):\n            if k-p[i][1]>=0:\n                n-=1\n            k-=p[i][1]\n            i+=1\n        return n\n            \n            \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        size = 0\n        adict = {}\n        for item in arr:\n            if item not in adict:\n                adict[item] = 1\n                size += 1\n            else: \n                adict[item] += 1\n        \n        sort = sorted(adict.items(), key=lambda x: x[1])\n        \n        for i in sort:\n            #print(i[1])\n            if k >= i[1]:\n                #print(i[1])\n                k -= i[1]\n                size -= 1\n                #print(k)\n                #print(size)\n        \n        return size", "from collections import Counter\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        mapper = Counter(arr)\n        count = 0\n        size = len(mapper)\n        values = sorted(mapper.values())\n        for val in values:\n            if val <= k:\n                k -= val\n                count += 1\n            else:\n                return size - count\n        return size - count", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        # 9:21\n        c=collections.Counter(arr)\n        items=[(k,v) for k,v in list(c.items())]\n        items.sort(key=lambda x:x[1])\n        removals=0\n        i=0\n        while removals<k and i<len(items):\n            ky=items[i][0]\n            if c[ky]==1:\n                del c[ky]\n                i+=1\n            else:\n                c[ky]-=1\n            removals+=1\n        return len(c)\n            \n            \n            \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        dic = {}\n        \n        for i in range(len(arr)):\n            if(arr[i] in dic):\n                dic[arr[i]] += 1\n            else:\n                dic[arr[i]] = 1\n                \n        dic = {k: v for k, v in sorted(list(dic.items()), key=lambda item: item[1])}\n        \n        for i in dic:\n            if(k > 0):\n                if(k > dic[i]):\n                    k -= dic[i]\n                    dic[i] = 0\n                else:\n                    dic[i] -= k\n                    k = 0\n            else:\n                break\n         \n        ans = 0\n        \n        for i in dic:\n            if(dic[i]>0):\n                ans += 1\n                \n        return ans\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        d={}\n        for i in arr:\n            if i not in d:\n                d[i]=1\n            else:\n                d[i]+=1\n        d=sorted(list(d.items()),key=lambda x:-x[1])\n        d=[list(i) for i in d]\n        for k0 in range(k):\n            d[-1][1]-=1\n            if d[-1][1]==0:\n                d.pop()\n        return len(d)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        bucket = [[] for _ in range(len(arr)+1)]\n        counter = collections.Counter(arr)\n        for key, value in counter.items():\n            bucket[value].append(key)\n        for c in range(len(bucket)):\n            if k==0:\n                break\n            while bucket[c] and k>=c:\n                del counter[bucket[c].pop()]\n                k -= c\n        return len(counter)", "import collections\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        buckets = [[] for _ in range(len(arr) + 1)]\n        counter = collections.Counter(arr)\n        for key, count in counter.items():\n            buckets[count].append(key)\n        for count in range(len(arr) + 1):\n            if k == 0: break\n            while buckets[count] and k >= count:\n                del counter[buckets[count].pop()]\n                k -= count\n        return len(counter)", "from collections import Counter \nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter = collections.Counter(arr)\n        for i, j in reversed(counter.most_common()):\n            if k:\n                if k - j >= 0:\n                    del counter[i]\n                    k -= j\n                else:\n                    break    \n        return len(counter)\n            \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter = collections.Counter(arr)\n        for i,value in sorted(list(counter.items()), key = lambda x: x[1]):\n            val = k\n            k -= value\n            counter[i] -= val\n            if counter[i] <= 0:\n                del counter[i]\n        return len(counter)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter = collections.Counter(arr)\n        for i,value in sorted(list(counter.items()), key = lambda x: x[1]):\n            val = k\n            k -= value\n            counter[i] -= val\n            if counter[i] <= 0:\n                del counter[i]\n        return len(counter)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n\n        dict = {}\n        for num in arr:\n            dict[num] = dict.get(num,0) + 1\n            \n            \n            \n        size = len(arr) + 1\n        buckets = [[] for _ in range(size)]\n        \n                \n        for num, freqency in list(dict.items()):\n            buckets[freqency].append(num)\n            \n            \n        for i in range(size):\n            if k == 0: \n                break\n                \n            while buckets[i] and k >= i:\n                num = buckets[i].pop()\n                del dict[num]\n                k -= i\n        return len(dict)\n    \n    \n#         buckets = [[] for _ in range(len(arr) + 1)]\n#         counter = collections.Counter(arr)\n#         for key, count in counter.items():\n#             buckets[count].append(key)\n#         for count in range(len(arr) + 1):\n#             if k == 0: break\n#             while buckets[count] and k >= count:\n#                 del counter[buckets[count].pop()]\n#                 k -= count\n#         return len(counter)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        counts = defaultdict(list)\n        for num, freq in list(c.items()):\n            counts[freq].append(num)\n        for freq in range(1, len(arr) + 1):\n            while counts[freq] and k >= freq:\n                del c[counts[freq].pop()]\n                k -= freq\n        return len(c)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter = collections.Counter(arr)\n        freq = sorted(counter.values())\n        \n        ans = len(freq)\n        \n        for f in freq:\n            if k>=f:\n                k-=f\n                ans-=1\n        return ans", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        from collections import Counter\n        from heapq import heapify, heappop\n        heap = [(val, key) for key, val in list(Counter(arr).items())]\n        heapify(heap)\n        while k > 0:\n            k -= heappop(heap)[0]\n        return len(heap) + (k < 0)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n\n        dict = {}\n        for num in arr:\n            dict[num] = dict.get(num,0) + 1\n            \n    \n        size = len(arr) + 1\n        counters = [[] for _ in range(size)]\n        \n                \n        for num in dict:\n            counters[dict[num]].append(num)\n            \n        result = len(dict)    \n        for i in range(size):\n            if k == 0: \n                break\n                \n            while counters[i] and k >= i:\n                num = counters[i].pop()\n                #del dict[num]\n                result -=1\n                k -= i\n        return result\n    \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        buckets = [[] for _ in range(len(arr) + 1)]\n        counter = collections.Counter(arr)\n        for key, count in counter.items():\n            buckets[count].append(key)\n        for count in range(len(arr) + 1):\n            if k == 0: break\n            while buckets[count] and k >= count:\n                del counter[buckets[count].pop()]\n                k -= count\n        return len(counter)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n\n        dict = {}\n        for num in arr:\n            dict[num] = dict.get(num,0) + 1\n            \n            \n            \n        size = len(arr) + 1\n        buckets = [[] for _ in range(size)]\n        \n                \n        for num, freqency in list(dict.items()):\n            buckets[freqency].append(num)\n            \n        result = len(dict)    \n        for i in range(size):\n            if k == 0: \n                break\n                \n            while buckets[i] and k >= i:\n                num = buckets[i].pop()\n                result -=1\n                k -= i\n                \n        return result\n    \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        buckets = [[] for _ in range(len(arr) + 1)]\n        counter = collections.Counter(arr)\n        for key, count in list(counter.items()):\n            buckets[count].append(key)\n        for count in range(len(arr) + 1):\n            if k == 0: break\n            while buckets[count] and k >= count:\n                del counter[buckets[count].pop()]\n                k -= count\n        return len(counter)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n\n        dict = {}\n        for num in arr:\n            dict[num] = dict.get(num,0) + 1\n            \n    \n        size = len(arr) + 1\n        counters = [[] for _ in range(size)]\n        \n                \n        for num in dict:\n            counters[dict[num]].append(num)\n            \n        result = len(dict)    \n        for i in range(size):\n            if k == 0: \n                break\n                \n            while counters[i] and k >= i:\n                num = counters[i].pop()\n                del dict[num]\n                result -=1\n                k -= i\n        return result\n    \n", "from collections import Counter\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        # trivous solution\n        \n        # sort numbers by count\n        \n        num_count = Counter(arr)\n        \n        sort_nums = list(num_count.most_common())\n        \n        while sort_nums and sort_nums[-1][1] <= k:\n            k -= sort_nums[-1][1]\n            sort_nums.pop()\n        \n        return len(sort_nums)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count = collections.Counter(arr)\n        \n        arr = list(reversed([item for items, c in count.most_common() for item in [items] * c]))\n        \n        print(arr, arr[k:])\n        return len(collections.Counter(arr[k:]))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        heap = []\n        for key, val in list(collections.Counter(arr).items()):\n            heapq.heappush(heap, (val, key))\n            \n        for _ in range(k):\n            val, key = heapq.heappop(heap)\n            if val > 1:\n                heapq.heappush(heap, (val - 1, key))\n        return len(heap)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count = [(v, k) for k, v in collections.Counter(arr).items()]\n        heapq.heapify(count)\n        while k > 0:\n            k -= heapq.heappop(count)[0]\n        return len(count) if k >= 0 else len(count) + 1", "from collections import Counter\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        freqDict = Counter(arr)\n        values = sorted(list(freqDict.values()))\n        sumForK = 0\n        for idx, value in enumerate(values):\n            if sumForK + value == k:\n                return len(values)-idx-1\n            elif sumForK + value > k:\n                return len(values)-idx\n            sumForK += value\n        return 0\n            \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter= collections.Counter(arr)\n        import heapq\n        heap= []\n        for key in counter:\n            heapq.heappush(heap,(counter[key], key))\n        \n        while (heap and k):\n            count, key = heapq.heappop(heap)\n            \n            if k >= count:\n                k -= count\n            else:\n                return len(heap) +1\n        return len(heap)\n    \n# class Solution(object):\n#     def findLeastNumOfUniqueInts(self, arr, k):\n#         heap = []\n#         count = collections.Counter(arr)\n#         for key in count:\n#             heapq.heappush(heap, (count[key], key))\n        \n#         while(heap and k):\n#             count, key = heapq.heappop(heap)\n#             if k >= count:\n#                 k -= count\n#             else:\n#                 return len(heap) + 1\n#         return len(heap)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        heap = []\n        for key, val in list(collections.Counter(arr).items()):\n            heapq.heappush(heap, (val, key))\n            \n        while k > 0:\n            val, key = heapq.heappop(heap)\n            if val > k:\n                heapq.heappush(heap, (val - k, key))\n                break\n            else:\n                k -= val\n        return len(heap)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        heap = []\n        for key, val in list(collections.Counter(arr).items()):\n            heapq.heappush(heap, (val, key))\n            \n        for _ in range(k):\n            val, key = heapq.heappop(heap)\n            if val > 1:\n                heapq.heappush(heap, (val - 1, key))\n        return len(heap)\n\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        hp = [[val, key] for key, val in collections.Counter(arr).items()]\n        heapq.heapify(hp)\n        \n        while k > 0:\n            k -= 1\n            hp[0][0] -= 1\n            if hp[0][0] == 0:\n                heapq.heappop(hp)\n            #k -= heapq.heappop(hp)[0]\n            \n        return len(hp) + (k < 0)   ", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        heap = []\n        for key, val in list(collections.Counter(arr).items()):\n            heapq.heappush(heap, (val, key))\n            \n        for _ in range(k):\n            val, key = heapq.heappop(heap)\n            if val > 1:\n                heapq.heappush(heap, (val - 1, key))\n        return len(heap)\n\n \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        acnt=collections.Counter(arr)\n        nt=[[val,key] for key,val in acnt.items()]\n        heapq.heapify(nt)\n        while k>0:\n            fre,val=heapq.heappop(nt)\n            k-=fre\n        if k==0: return len(nt)\n        return len(nt)+1", "class Solution:\n    # Time: O(n*log(n))\n    # Space: O(n)\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        heap = []\n        for key, val in collections.Counter(arr).items():\n            heapq.heappush(heap, (val, key))\n            \n        for _ in range(k):\n            val, key = heapq.heappop(heap)\n            if val > 1:\n                heapq.heappush(heap, (val - 1, key))\n        return len(heap)", "class Solution:\n  def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n    counter = {}\n\n    for item in arr:\n      counter[item] = 1 + counter.get(item, 0)\n\n    values = sorted(counter.values())\n    \n    removed = 0\n\n    for v in values:\n      if v > k:\n        break\n      else:\n        k -= v\n        removed += 1\n\n    return len(values) - removed", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        from collections import Counter\n        from heapq import heappush,heappop\n        d=Counter(arr)\n        q=sorted(arr,key=lambda x:(d[x],x))\n        \n        return (len(set(q[k:])))\n        \n    \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        heap = []\n        for key, val in collections.Counter(arr).items():\n            heapq.heappush(heap, (val, key))\n            \n        for _ in range(k):\n            val, key = heapq.heappop(heap)\n            if val > 1:\n                heapq.heappush(heap, (val - 1, key))\n        return len(heap)", "import heapq\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        heap = []\n        counter = collections.Counter()\n        for num in arr:\n            counter[num] = counter[num] + 1\n            \n        for num,cnt in counter.items():\n            heapq.heappush(heap, (cnt, num))\n            \n        while k > 0:\n            top = heapq.heappop(heap)\n            if k >= top[0]:\n                k -= top[0]\n            else:\n                heapq.heappush(heap, top)\n                k = 0\n        return len(heap)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        from collections import Counter\n        \n        d=Counter(arr)\n        q=sorted(arr,key=lambda x:(d[x],x))\n        \n        return (len(set(q[k:])))\n        \n    \n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        heap = []\n        counts = collections.Counter()\n        for num in arr:\n            counts[num] += 1\n        \n        for num,cnt in counts.items():\n            heapq.heappush(heap, (cnt, num))\n            \n        while k > 0:\n            top = heapq.heappop(heap)\n            if k >= top[0]:\n                k -= top[0]\n            else:\n                heapq.heappush(heap, top)\n                k = 0\n        return len(heap)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        from collections import Counter\n        \n        counter = Counter(arr)\n        \n        counter = sorted(counter.most_common(),key=lambda x: (x[1],x[0]),reverse=True)\n        \n        #print(counter)\n        \n        while k > 0 and counter:\n            \n            #counter[-1][1] -= 1\n            \n            edge = list(counter[-1])\n            \n            edge[1] -= 1\n            \n            counter[-1] = tuple(edge)\n            \n            if counter[-1][1] == 0:\n                counter.pop()\n             \n            k -= 1\n        \n        return len(counter)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        dic = collections.Counter(arr)\n        arrs = sorted(arr, key=lambda x: (-dic[x], x))\n    \n        for i in range(k):\n            arrs.pop()\n        return len(set(arrs))", "from collections import Counter\n\nclass Solution:\n\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        counter = Counter(arr)\n        freq_sorted = sorted(arr, key=lambda x: (counter[x],x))\n        return len(set(freq_sorted[k:]))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        d = {}\n        for i in range(len(arr)):\n            if arr[i] in d:\n                d[arr[i]] += 1\n            else:\n                d[arr[i]] = 1\n                \n        m = sorted(d.values())\n        ans = len(m)\n        for c in m:\n            if k >= c:\n                k -= c\n                ans -= 1\n        return ans\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        freqs = collections.Counter(arr)\n        #{1: 2 , 2:1 , 3:3, 4:1}\n        \n        heap = []\n        \n        for key, val in list(freqs.items()):\n            heapq.heappush(heap, [val, key])\n            \n        while k > 0:\n            heap[0][0] -= 1\n            if heap[0][0] == 0:\n                heapq.heappop(heap)\n            k -= 1\n        \n        return len(heap)\n            \n", "from collections import Counter\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        s = sorted(arr,key = lambda x:(c[x],x))\n        return (len(set(s[k:])))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        heap = []\n        dic = collections.Counter(arr)\n        for element, count in list(dic.items()):\n            heapq.heappush(heap, [count, element])\n        while k > 0:\n            count, element = heapq.heappop(heap)\n            if count > 1:\n                heapq.heappush(heap, [count-1,element])\n            k-=1\n        return len(heap)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        s = sorted(arr, key=lambda x: (c[x], x))\n        return len(set(s[k:]))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = collections.Counter(arr)\n        count = 0\n        for i in sorted(list(c.items()), key = lambda x: x[1]):\n            # print(i)\n            if k - i[1] >= 0:\n                k -= i[1]\n                count += 1\n            elif k - i[1] < 0:\n                break\n        return len(c)-count\n        \n            \n        \n", "from heapq import heappop, heappush\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        freq_map = {}\n        heap = []\n        \n        for elem in arr:\n            if elem not in freq_map:\n                freq_map[elem] = 0\n                \n            freq_map[elem] += 1\n            \n        \n        \n        for key in freq_map:\n            heappush(heap,(freq_map[key],key))\n            \n        while k > 0:\n            \n            count, num = heappop(heap)\n            k -= count\n            \n        return len(heap)+1 if k < 0 else len(heap)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        num_count = defaultdict(int)\n        \n        for i in arr:\n            num_count[i] += 1\n        \n        h = []\n        \n        \n        key_count = 0\n        \n        for key in list(num_count.keys()):\n            heapq.heappush(h,(num_count[key],key))\n            key_count += 1\n    \n        result = key_count\n    \n        while k > 0:\n            count,num = heapq.heappop(h)\n            k = k-count\n            if k >= 0:\n                result -= 1\n                continue\n            if k < 0:\n                break\n                \n                \n                \n        return result\n            \n            \n            \n        \n        \n        \n        \n", "from collections import Counter\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        l = k\n        if k == 0: l = -len(arr)\n        L = [item for items, c in Counter(arr).most_common() for item in [items] * c][:-l]\n        print(L)\n        return len(set(L))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        l = {}\n        for i in arr:\n            if i in l:\n                l[i] += 1\n            else:\n                l[i] = 1\n        l = sorted(l.items(), key=lambda x: x[1])\n        i = 0\n        while k > 0:\n            if l[i][1] <= k:\n                k -= l[i][1]\n            else:\n                break\n            i += 1\n        return len(l) - i", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count = sorted(collections.Counter(arr).items(), key=lambda x: x[1])\n        c = 0\n        for kk, v in count:\n            if k >= v:\n                k -= v\n                c += 1\n            else:\n                break\n        return len(count) - c", "import heapq\nfrom collections import defaultdict\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        heap = []\n        dic = defaultdict(int)\n        for i in arr:\n            dic[i] += 1\n        for i in dic:\n            heapq.heappush(heap, (dic[i], i))\n        print(heap)\n        while k:\n            top = heap[0]\n            if top[0] > k:\n                break\n            else:\n                k -= top[0]\n                heapq.heappop(heap)\n        return len(heap)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        di=collections.defaultdict(int)\n        for v in arr:\n            di[v]+=1\n        ar=sorted([v for k,v in list(di.items())],reverse=True)\n        while ar and k>=ar[-1]:\n            k-=ar.pop()\n        return len(ar)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        heap = []\n        for key, val in collections.Counter(arr).items():\n            heapq.heappush(heap, (val, key))\n            \n        for _ in range(k):\n            val, key = heapq.heappop(heap)\n            #val -= 1\n            if val > 1:\n                heapq.heappush(heap, (val - 1, key))\n            \n        return len(heap)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n\n        # create a dictionary of {number: count}\n        num_count_dict = {}\n        for num in arr:\n            if num in num_count_dict:\n                num_count_dict[num] += 1\n            else:\n                num_count_dict[num] = 1\n                \n        # create a dictionary of {count: a_list_of_number}\n        num_dict = {}\n        for num in num_count_dict.keys():\n            count = num_count_dict[num] \n            if count in num_dict:\n                num_dict[count].append(num)\n            else:\n                num_dict[count] = [num]\n        \n        # sorted num_dict by each number's count\n        sorted_num_by_count = sorted(num_count_dict.items(), key=lambda x: x[1])\n        #print(sorted_num_by_count)\n        \n        # remove number of the list\n        for i in range (0, len(sorted_num_by_count)):\n            num = sorted_num_by_count[i][0] # get dict key\n            #print('num={}, k={}, num_count_dict={}'.format(num, k, num_count_dict[num]))\n            num_count = num_count_dict[num]\n            if num_count <= k:\n                del num_count_dict[num]\n            else:\n                num_count_dict[num] = num_count_dict[num]-k\n            k = k-num_count\n            if k == 0:\n                break\n        return len(num_count_dict)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        s = sorted(arr, key = lambda x:(c[x], x))\n        return len(set(s[k:]))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = collections.Counter(arr)\n        ans = len(c)\n        for v in sorted(c.values()):\n            if v <= k:\n                ans -= 1\n                k -= v\n        return ans", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        import heapq\n        heap = []\n        temp = {}\n        for i in arr:\n            if i in temp:\n                temp[i] +=1\n            else:\n                temp[i] =1\n        \n        for key in temp:\n            heapq.heappush(heap, (temp[key], key ))\n       \n    \n        print(heap)\n        \n        while (heap and k):\n            count ,key = heapq.heappop(heap)\n            print((count , key , k))\n            if k >= count:\n                k -=count\n            else:\n                return len(heap) +1\n        return len(heap)\n    \n# class Solution(object):\n#     def findLeastNumOfUniqueInts(self, arr, k):\n#         heap = []\n#         count = collections.Counter(arr)\n#         for key in count:\n#             heapq.heappush(heap, (count[key], key))\n        \n#         while(heap and k):\n#             count, key = heapq.heappop(heap)\n#             if k >= count:\n#                 k -= count\n#             else:\n#                 return len(heap) + 1\n#         return len(heap)\n", "from typing import List\nfrom collections import Counter\nimport heapq\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        element_count = Counter(arr)\n        count_heap = []\n        for element, count in element_count.most_common():\n            heapq.heappush(count_heap, [count, element])\n        \n        while k > 0:\n            curr_count, curr_elem = heapq.heappop(count_heap)\n            if k < curr_count:\n                curr_count -= k\n                k = 0\n                heapq.heappush(count_heap, [curr_count, curr_elem])\n            elif k > curr_count:\n                k -= curr_count\n            else:\n                k = 0\n        \n\n        return len(count_heap)", "import heapq \nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        dictv = {}\n        li = []\n        for i in arr:\n            if i in dictv:\n                dictv[i] +=1\n            else:\n                dictv[i] = 1\n        \n        li = []\n        for i in dictv:\n            heapq.heappush(li,(dictv[i], i))\n            \n        for _ in range(k):\n            val, key = heapq.heappop(li)\n            if val > 1:\n                heapq.heappush(li, (val - 1, key))\n        return len(li)\n", "from typing import List\nfrom heapq import *\n\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        hashmap = {}\n        def insert(num):\n            if num in hashmap:\n                hashmap[num] += 1\n            else:\n                hashmap[num] = 1\n\n        for num in arr:\n            insert(num)\n\n        valkeys = [ (hashmap[key], key) for key in list(hashmap.keys()) ] \n\n        kSmallest = nsmallest(k, valkeys)\n        uniqueCount = len(valkeys)\n        removals = k\n\n        for (occ, num) in kSmallest:\n            if (removals - occ) >= 0:\n                removals -= occ\n                uniqueCount -= 1\n            else:\n                break\n\n        return uniqueCount\n\n\n\n\n            \n\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        c = Counter(arr)\n        sarr = sorted(arr, key = lambda x: (c[x], x))\n        return len(set(sarr[k:]))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count = collections.Counter(arr)\n        pq = [(val, key) for key, val in list(count.items())]\n        heapq.heapify(pq)\n        \n        while pq and k>0:\n            freq, val = heapq.heappop(pq)\n            if freq <= k:\n                k -= freq\n            else:\n                heapq.heappush(pq, (freq-k, val))\n                k = 0\n                \n        return len(pq)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        from collections import Counter\n        from heapq import heappush,heappop\n        d=Counter(arr)\n        q=[]\n        \n        for ele in d:\n            \n            heappush(q,[d[ele],ele])\n        print(q)   \n        for i in range(k):\n            temp=q[0]\n            if temp[0]==1:\n                print(temp)\n                heappop(q)\n            else:\n                temp[0]-=1\n        return len( q)\n", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        cnts = collections.Counter(arr)\n        heap = [(v, k) for k, v in cnts.items()]\n        heapq.heapify(heap)\n        for _ in range(k):\n            cnt, val = heapq.heappop(heap)\n            cnt -= 1\n            if cnt != 0:\n                heapq.heappush(heap, (cnt, val))\n        return len(heap)", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        \n        c = Counter(arr)\n        s = sorted(arr,key = lambda x:(c[x],x))\n        print(s)\n        return len(set(s[k:]))", "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        cnt = collections.defaultdict(int)\n        \n        for num in arr:\n            cnt[num] += 1\n            \n        a = [(cnt[key], key) for key in cnt]\n        a.sort(key = lambda x:x[0])\n        \n        ret = len(a)\n        \n        i = 0\n        while k:\n            if a[i][0] <= k:\n                k -= a[i][0]\n                ret -= 1\n                \n            else:\n                break\n                \n            i += 1\n            \n        return ret"]
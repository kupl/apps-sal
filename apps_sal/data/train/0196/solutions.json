["class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        N = len(A)\n        if(N==0):\n            return 0\n        curr_max = A[0]\n        global_max = A[0]\n        curr_min = A[0]\n        global_min = A[0]\n        flag = 0 \n        if(A[0]>=0):\n            flag=1\n    \n        for i in range(1, N):\n            if(A[i]>=0):\n                flag=1\n            if(curr_max >= 0):\n                curr_max = curr_max + A[i]    \n            else:\n                curr_max = A[i]\n            \n            if(curr_min >= 0):\n                curr_min = A[i]\n            else:\n                curr_min = curr_min + A[i] \n            \n            if(curr_max > global_max):\n                global_max = curr_max\n            if(curr_min < global_min):\n                global_min = curr_min\n        if(flag==0):\n            return max(A)\n        return max(global_max, sum(A) - global_min)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        \n        curr_max = A[0]\n        max_sum = A[0]\n        \n        curr_min = A[0]\n        min_sum = A[0]\n        \n        for i in range(1, len(A)):\n            \n            curr_max = max(A[i], A[i] + curr_max)\n            max_sum = max(curr_max, max_sum)\n            \n            curr_min = min(A[i], A[i] + curr_min)\n            min_sum = min(curr_min, min_sum)\n            \n        if max_sum > 0:\n            return max(sum(A) - min_sum, max_sum)\n        else:\n            return max(A)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        max_A = max(A)\n        if max_A <= 0:\n            return max_A\n        max_sum = 0\n        cur_sum = 0\n        for i in range(len(A)):\n            cur_sum = max(cur_sum, 0) + A[i]\n            max_sum = max(max_sum, cur_sum)\n        if len(A) <= 2:\n            return max_sum\n        \n        right_sum = A[-1]\n        right_max = [A[-1]]\n        for i in A[len(A)-2::-1]:\n            right_sum += i\n            right_max.append(max(right_max[-1], right_sum))\n        right_max = right_max[::-1]\n        # print(right_max)\n        \n        left_max = A[0]\n        left_sum = A[0]\n        for i in range(1, len(A)-1):\n            # print(A[i], left_max, left_sum)\n            left_sum += A[i]\n            left_max = max(left_max, left_sum)\n            max_sum = max(max_sum, left_max + right_max[i+1])\n            \n        return max_sum\n        \n            \n        \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        mini = maxi = A[0]\n        curMin = curMax = total = 0\n        for num in A:\n            curMin = min(curMin + num, num) # 2\n            curMax = max(curMax + num, num) # 7\n            maxi = max(maxi, curMax) # 7\n            mini = min(mini, curMin) # -3\n            total += num\n        return max(maxi, total - mini) if maxi > 0 else maxi\n            \n            \n            \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        \n        def _get_max(lo, hi, flag):\n            m = float('-inf')\n            s = 0\n            for i in range(lo, hi):\n                s = max(s, 0) + flag * A[i]\n                m = max(m, s)\n            return m\n        \n        s = sum(A)\n        \n        return max(_get_max(0, len(A), 1), s + _get_max(0, len(A) - 1, -1), s + _get_max(1, len(A), -1))", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        mx = curr = A[0]\n        cumSum = [A[0]]\n        for i in range(1, len(A)):\n            if curr >= 0:\n                curr += A[i]\n            else:\n                curr = A[i]\n            mx = max(mx, curr)\n            cumSum.append(cumSum[-1]+A[i])\n        revCumSum = []\n        curr = 0\n        for x in reversed(A):\n            curr += x\n            if revCumSum:\n                revCumSum.append(max(revCumSum[-1], curr))\n            else:\n                revCumSum.append(curr)\n        for i in range(len(A)-1):\n            mx = max(mx, cumSum[i]+revCumSum[len(A)-2-i])\n        mx = max(mx, cumSum[-1])\n        return mx\n        \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        def maxSubarray (A):\n            dp = [0] * len(A)\n            max_c = A[0]\n            flag = True\n            for idx,num in enumerate(A):\n                if num < 0:\n                    flag = False\n                if idx == 0:\n                    dp[0]=num\n                else:\n                    dp[idx]=max(num, dp[idx-1] + num)\n            return max(dp), flag\n        \n        temp,nonNeg = maxSubarray(A)\n        if nonNeg:\n            return temp\n        \n        res = float('-inf')\n        \n        rightWindow = [A[0]] + [0] * (len(A)-1)\n        for idx,i in enumerate(A[1:]):\n            rightWindow[idx+1] = i+rightWindow[idx]\n\n            \n        currMax = float('-inf')\n        MaxIdx = float('inf')\n        reversedA = A.reverse()\n        leftWindow = [A[0]] + [0] * (len(A)-1)\n        \n        for idx,i in enumerate(A[1:]):\n            leftWindow[idx +1] = i+leftWindow[idx]\n            \n            if MaxIdx >= len(A)-idx-1:\n                currMax = max(rightWindow[:len(A)-idx-1])\n                MaxIdx = rightWindow.index(currMax)\n\n            res = max(res,currMax + leftWindow[idx])\n        \n\n        return max(res,temp)\n", "import heapq\n\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        N = len(A)\n        best = A[0]\n        \n        heap = [(0, 0)]    \n        cumsums = [0]\n        for n in A:\n            cumsums.append(cumsums[-1] + n)\n        for n in A:\n            cumsums.append(cumsums[-1] + n)\n        \n        for i in range(1, len(cumsums)):\n            while len(heap) > 0 and i - heap[0][1] > N:\n                heapq.heappop(heap)\n            \n            best = max(best, cumsums[i] - heap[0][0])\n            heapq.heappush(heap, (cumsums[i], i))\n        \n        return best", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        total, maxSum, curMax, minSum, curMin = 0, A[0], 0, A[0], 0\n        for a in A:\n            curMax = max(curMax + a, a)\n            maxSum = max(maxSum, curMax)\n            curMin = min(curMin + a, a)\n            minSum = min(minSum, curMin)\n            total += a\n        return max(maxSum, total - minSum) if maxSum > 0 else maxSum\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        # case 1, kadane's algo\n        totalSum = sum(A)\n        curr = A[0]\n        maxSum = A[0]\n        \n        for i in range(1, len(A)):\n            if A[i] + curr > A[i]:\n                curr = A[i] + curr\n            else:\n                curr = A[i]\n            \n            maxSum = max(maxSum, curr)\n        \n        # case 2, wrapping\n        \n        curr = A[0]\n        minSum = totalSum\n        \n        for i in range(1, len(A)):\n            curr = min(A[i]+curr, A[i])\n            \n            minSum = min(minSum, curr)\n        \n        if totalSum == minSum:\n            return maxSum\n        return max(totalSum - minSum, maxSum)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n\n        def kadane(array):\n            global_max = array[0]\n            local_max = array[0]\n\n            for i in range(1,len(array)):\n                if local_max < 0:\n                    local_max = 0\n                local_max = array[i] + local_max \n                if local_max > global_max:\n                    global_max = local_max\n\n            return global_max\n        \n        def kadane_inverse(array):\n            global_min = array[0]\n            local_min = array[0]\n            \n            for i in range(1,len(array)):\n                if local_min > 0:\n                    local_min = 0\n                local_min = array[i] + local_min \n                if local_min < global_min:\n                    global_min = local_min\n\n            return global_min\n        \n        total = sum(A)\n        inv = kadane_inverse(A)\n        reg = kadane(A)\n        if total == inv:\n            return reg\n        return max(total-inv, reg)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        def maxSubarray (A):\n            dp = [0] * len(A)\n            max_c = A[0]\n            for idx,num in enumerate(A):\n                if idx != 0:\n                    dp[idx]=max(num, dp[idx-1] + num)\n                else:\n                    dp[0]=num\n                    \n            return max(dp)\n        \n        temp = maxSubarray(A)\n\n        res = float('-inf')\n        rightMax = [max(A[0],0)] + [0] * (len(A)-1)\n        currMax = max(A[0],0)\n        rightWindow = [A[0]] + [0] * (len(A)-1)\n        for idx,i in enumerate(A[1:]):\n            currMax = max(i+rightWindow[idx], currMax)\n            rightMax[idx+1] = currMax\n            rightWindow[idx+1] = i+rightWindow[idx]\n        \n\n        reversedA = A.reverse()\n        leftWindow = [A[0]] + [0] * (len(A)-1)\n        \n        for idx,i in enumerate(A[1:]):\n            leftWindow[idx +1] = i+leftWindow[idx]\n            currMax = rightMax[len(A)-idx-2]\n            res = max(res,currMax + leftWindow[idx])\n        \n\n        return max(res,temp)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        n = len(A)\n        cur_sum = A[0]\n        result1 = A[0]\n        for i in range(1,n):\n            cur_sum = max(A[i],cur_sum+A[i])\n            result1 = max(cur_sum,result1)\n        \n        if n == 1: return result1\n        \n        cur_sum = A[1]\n        result2 = A[1]\n        for i in range(2,n-1):\n            cur_sum = min(A[i],cur_sum+A[i])\n            result2 = min(cur_sum, result2)\n            \n        return max(result1,sum(A)-result2)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        total, maxSum, curMax, minSum, curMin = 0, A[0], 0, A[0], 0\n        for a in A:\n            curMax = max(curMax + a, a)\n            maxSum = max(maxSum, curMax)\n            curMin = min(curMin + a, a)\n            minSum = min(minSum, curMin)\n            total += a\n        return max(maxSum, total - minSum) if maxSum > 0 else maxSum", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)\n        if n == 1:\n            return A[0]\n        \n        def kadane(it):\n            max_ = current = float('-inf')\n            for num in it:\n                current = num + max(current, 0)\n                max_ = max(max_, current)\n            return max_\n                \n        total = sum(A)\n        max1 = kadane(num for num in A)\n        max2 = total + kadane(-A[idx] for idx in range(n - 1))\n        max3 = total + kadane(-A[idx] for idx in range(1, n))\n\n        return max(max1, max2, max3)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        if A is None or not A:\n            return 0\n\n        N = len(A)\n        A = A + A\n\n        acc = [0]\n        for d in A:\n            acc.append(acc[-1] + d)\n\n        ret = -sys.maxsize\n        queue = deque([0])\n\n        for j in range(1, 2 * N):\n            while queue and queue[0] < j - N:\n                queue.popleft()\n\n            ret = max(ret, acc[j] - acc[queue[0]])\n\n            while queue and acc[queue[-1]] >= acc[j]:\n                queue.pop()\n\n            queue.append(j)\n\n        return ret", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        def maxSubarray (A):\n            dp = [0] * len(A)\n            max_c = A[0]\n            flag = True\n            for idx,num in enumerate(A):\n                if num < 0:\n                    flag = False\n                if idx == 0:\n                    dp[0]=num\n                else:\n                    dp[idx]=max(num, dp[idx-1] + num)\n            return max(dp), flag\n        \n        temp,nonNeg = maxSubarray(A)\n\n        \n        res = float('-inf')\n        rightMax = [max(A[0],0)] + [0] * (len(A)-1)\n        currMax = max(A[0],0)\n        rightWindow = [A[0]] + [0] * (len(A)-1)\n        for idx,i in enumerate(A[1:]):\n            currMax = max(i+rightWindow[idx], currMax)\n            rightMax[idx+1] = currMax\n            rightWindow[idx+1] = i+rightWindow[idx]\n        \n\n        reversedA = A.reverse()\n        leftWindow = [A[0]] + [0] * (len(A)-1)\n        \n        for idx,i in enumerate(A[1:]):\n            leftWindow[idx +1] = i+leftWindow[idx]\n            currMax = rightMax[len(A)-idx-2]\n            res = max(res,currMax + leftWindow[idx])\n        \n\n        return max(res,temp)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        sm = sum(A)\n        mx = mn = cur_mx = cur_mn = A[0]\n        for i in range(1, len(A)):\n            cur_mn = min(cur_mn + A[i], A[i])\n            mn = min(mn, cur_mn)\n            cur_mx = max(cur_mx + A[i], A[i])\n            mx = max(mx, cur_mx)\n        return max(mx, (mn if mn==sm else (sm - mn)))", "class Solution:\n    def maxSubarraySumCircular(self, a: List[int]) -> int:\n        n = len(a)\n        ans = float('-inf')\n        current = 0\n        for num in a:\n            current = num + max(0, current)\n            ans = max(ans, current)\n        \n        right_sum = [0] * n\n        right_sum[-1] = a[-1]\n        right_most = [float('-inf')] * n\n        right_most[-1] = right_sum[-1]\n        for i in range(n - 2, -1, -1):\n            right_sum[i] = right_sum[i + 1] + a[i]\n            right_most[i] = max(right_sum[i], right_most[i + 1])\n        left_sum = 0\n        for i in range(n - 2):\n            left_sum += a[i]\n            ans = max(ans, left_sum + right_most[i + 2])\n        return ans\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        max_subarray = float('-inf')\n        cur_max_subarray = 0\n        min_subarray = float('inf')\n        cur_min_subarray = 0\n        total = 0\n        max_value = float('-inf')\n        for num in A:\n            cur_max_subarray += num\n            if cur_max_subarray < 0:\n                cur_max_subarray = 0\n            else:\n                max_subarray = max(max_subarray, cur_max_subarray)\n            cur_min_subarray += num\n            if cur_min_subarray > 0:\n                cur_min_subarray = 0\n            else:\n                min_subarray = min(min_subarray, cur_min_subarray)\n            total += num\n            max_value = max(max_value, num)\n        if max_value <= 0:\n            return max_value\n        return max(max_subarray, total-min_subarray)\n        \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        dp = [0]\n        for _ in range(2):\n            for num in A:\n                dp.append(dp[-1]+num)        \n        \n        res = A[0]\n        deque = collections.deque([0]) # i's, increasing by P[i]\n        for j in range(1, len(dp)):\n            # If the smallest i is too small, remove it.\n            if deque[0] < j-len(A):\n                deque.popleft()\n\n            # The optimal i is deque[0], for cand. answer P[j] - P[i].\n            res = max(res, dp[j] - dp[deque[0]])\n\n            # Remove any i1's with P[i2] <= P[i1].\n            while deque and dp[j] <= dp[deque[-1]]:\n                deque.pop()\n\n            deque.append(j)\n        return res\n        '''\n        As before, sum(nums[i:i+k]) = dp[i+k]-dp[i]\n        now, sum[i+k:i] = dp[len(A)-(i+k)]+dp[i]\n        '''\n        cur_max = -float('inf')\n        dp = [0]\n        for num in A:\n            dp.append(dp[-1]+num)\n        \n        for i in range(len(A)):\n            for j in range(i+1,i+len(A)+1):\n                if j <= len(A):\n                    cur_max = max(cur_max,dp[j]-dp[i])\n                else:\n                    cur_max = max(cur_max,dp[len(A)]-dp[i]+dp[j%len(A)])\n        return cur_max\n                \n                \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        ansIfOne = kadane(A)\n        \n        ansIfTwo = sum(A) - kadaneMin(A[1:len(A)-1])\n        \n        return max(ansIfOne, ansIfTwo)\n        \n        \n        \ndef kadane(A):\n    prevMax = -math.inf\n    result = -math.inf\n    for x in A:\n        curMax = max(prevMax + x, x)\n        prevMax = curMax\n        result = max(result, curMax)\n    return result\n\ndef kadaneMin(A):\n    prevMin = math.inf\n    result = math.inf\n    for x in A:\n        curMin = min(prevMin + x, x)\n        prevMin = curMin\n        result = min(result, curMin)\n    return result\n", "class Solution:\n    def maxSubarraySumCircular1(self, A: List[int]) -> int:\n        maxSubarraySum = [i for i in A]\n        minSubarraySum = [i for i in A]\n        for i in range(1,len(A)):\n            maxSubarraySum[i] = max(maxSubarraySum[i-1]+A[i],A[i])\n        for i in range(1,len(A)):\n            minSubarraySum[i] = min(minSubarraySum[i-1]+A[i],A[i])\n        return max(max(maxSubarraySum),sum(A)-min(minSubarraySum)) if max(maxSubarraySum) >0 else max(maxSubarraySum)\n    \n    def maxSubarraySumCircular(self, A):\n        total = 0\n        curMax = 0\n        maxSubArraySum = A[0]\n        curMin = 0\n        minSubArraySum = A[0]\n        \n        for a in A:\n            curMax = max(curMax+a,a)\n            maxSubArraySum = max(maxSubArraySum,curMax)\n            curMin = min(curMin+a,a)\n            minSubArraySum = min(minSubArraySum,curMin)\n            total += a \n        return max(maxSubArraySum,total-minSubArraySum) if maxSubArraySum > 0 else maxSubArraySum", "import sys\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        def kadane(A,n):\n            maxG = 0\n            curr_max = 0\n            for i in range(n):\n                curr_max += A[i]\n                curr_max = max(0,curr_max)\n                maxG = max(maxG, curr_max)\n            \n            return maxG\n        \n        flag = None\n        for i in A:\n            if i > 0:\n                flag=1\n                break\n        if not flag:\n            return max(A)\n        \n        n = len(A)\n        noWrap = kadane(A,n)\n        total = 0\n        for i in range(n):\n            total += A[i]\n            A[i] *= -1\n        minTotal = kadane(A,n)\n        maxG = total+minTotal\n        return max(noWrap,maxG)", "class Solution:\n    def maxSubarraySumCircular(self, A):\n        def kadane(gen):\n            ans = cur = float('-inf') # maximum non-empty subarray sum\n            for x in gen:\n                cur = max(cur, 0) + x\n                ans = max(ans, cur)\n            return ans\n\n        S = sum(A)\n        ans1 = kadane(iter(A))\n        ans2 = S + kadane(-A[i] for i in range(1, len(A)))\n        ans3 = S + kadane(-A[i] for i in range(len(A) - 1))\n\n        return max(ans1, ans2, ans3)", "class Solution:\n    def maxSubarraySumCircular1(self, A: List[int]) -> int:\n        maxSubarraySum = [i for i in A]\n        minSubarraySum = [i for i in A]\n        for i in range(1,len(A)):\n            maxSubarraySum[i] = max(maxSubarraySum[i-1]+A[i],A[i])\n        for i in range(1,len(A)):\n            minSubarraySum[i] = min(minSubarraySum[i-1]+A[i],A[i])\n        return max(max(maxSubarraySum),sum(A)-min(minSubarraySum)) if max(maxSubarraySum) >0 else max(maxSubarraySum)\n    \n    def maxSubarraySumCircular(self, A):\n        total, maxSum, curMax, minSum, curMin = 0, A[0], 0, A[0], 0\n        for a in A:\n            curMax = max(curMax + a, a)\n            maxSum = max(maxSum, curMax)\n            curMin = min(curMin + a, a)\n            minSum = min(minSum, curMin)\n            total += a\n        return max(maxSum, total - minSum) if maxSum > 0 else maxSum", "class Solution:\n    def maxSubarraySumCircular(self, arr: List[int]) -> int:\n        max_eh = arr[0]\n        min_eh = arr[0]\n        max_sf = arr[0]\n        min_sf = arr[0]\n        total = sum(arr)\n        for i in range(1,len(arr)):\n            max_eh = max(max_eh+arr[i],arr[i])\n            max_sf = max(max_eh,max_sf)\n            min_eh = min(min_eh+arr[i],arr[i])\n            min_sf = min(min_eh,min_sf)\n\n        if min_sf == total:\n            return max_sf\n        else:\n            return max(max_sf,total-min_sf)\n\n\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        res = A[0]\n        cur = A[0]\n        sumn = sum(A)\n        \n        \n        for num in A[1:]:\n            cur = num + max(0, cur)\n            res = max(cur, res)\n        \n        if len(A) >= 2:\n            mincur = -A[1]\n            minres = -A[1]\n            for num in A[2:]:\n                mincur = -num + max(0, mincur)\n                minres = max(minres, mincur)\n                \n            res = max(res, sumn + minres)\n            \n            mincur = -A[0]\n            minres = -A[0]\n            for num in A[1:(len(A)-1)]:\n                mincur = -num + max(0, mincur)\n                minres = max(minres, mincur)\n                \n                \n            res = max(res, sumn + minres)\n        \n        return res\n            \n", "# case1: ---------|\n    \n# case2: ---------|----------\n#             |--------|\n#              suf  pre\n#        maxsubarray = total - min(subarray)\n\n\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        local_min = 0\n        local_max = 0\n        global_min = A[0]\n        global_max = A[0]\n        total = 0\n        for num in A:\n            total += num\n            local_min = min(local_min+num, num)\n            global_min = min(global_min, local_min)\n            local_max = max(local_max+num, num)\n            global_max = max(global_max, local_max)\n            \n            \n        if global_max < 0: return global_max \n        else: return max(global_max, total-global_min)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        max_sum = min_sum = A[0]\n        curr_max = curr_min = tot = 0\n        for a in A:\n            curr_max = max(curr_max + a, a)\n            curr_min = min(curr_min + a, a)\n            max_sum = max(curr_max, max_sum)\n            min_sum = min(curr_min, min_sum)\n            tot += a\n        return max(max_sum, tot - min_sum) if max_sum > 0 else max_sum\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        # Maximum Sum Circular Subarray\n        # 8/22/20 3:41\n        total, maxSum = 0, A[0]\n        curMax, minSum, curMin = 0, A[0], 0\n        for a in A:\n            curMax = max(curMax + a, a)\n            maxSum = max(maxSum, curMax)\n            curMin = min(curMin + a, a)\n            minSum = min(minSum, curMin)\n            total += a\n        return max(maxSum, total - minSum) if total != minSum else maxSum\n    \n    \n\n# input: [5,-3,5]\n# Output:7\n# Expected:10\n\n                    \n                \n            \n            \n         \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        maxsum = minsum = A[0]\n        curmax = curmin = total = 0\n        \n        for num in A:\n            curmax = max(num, curmax + num)\n            maxsum = max(maxsum, curmax)\n            curmin = min(num, curmin + num)\n            minsum = min(minsum, curmin)\n            total += num\n        \n        return max(maxsum, total - minsum) if maxsum > 0 else maxsum", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        curmax, curmin = 0 , 0\n        total = 0\n        maxsum = minsum = A[0]\n        \n        for num in A:\n            curmax = max(num, curmax + num)\n            maxsum = max(maxsum, curmax)\n            curmin = min(num, curmin + num)\n            minsum = min(minsum, curmin)\n            total += num\n        return max(maxsum, total - minsum) if maxsum > 0 else maxsum", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        maxSubarraySum = [i for i in A]\n        minSubarraySum = [i for i in A]\n        for i in range(1,len(A)):\n            maxSubarraySum[i] = max(maxSubarraySum[i-1]+A[i],A[i])\n        for i in range(1,len(A)):\n            minSubarraySum[i] = min(minSubarraySum[i-1]+A[i],A[i])\n        return max(max(maxSubarraySum),sum(A)-min(minSubarraySum)) if max(maxSubarraySum) >0 else max(maxSubarraySum)", "class Solution:\n    def maxSubarraySumCircular(self, A):\n        n = len(A)\n        S = sum(A)\n        m1 = self.kadane(A)\n        m2 = S + self.kadane([-A[i] for i in range(1, n)])\n        m3 = S + self.kadane([-A[i] for i in range(n-1)])\n        return max(m1, m2, m3)\n    \n    def kadane(self, arr):\n        res = cur = -float('inf')\n        for a in arr:\n            cur = a + max(0, cur)\n            res = max(cur, res)\n        return res\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)\n        B = [0]+A+A\n        for i in range(1, len(B)):\n            B[i] += B[i-1]\n        maxv = B[1]\n        \n        stack = [0]\n        for end in range(1, len(B)):\n            num = B[end]\n            while stack and num < B[stack[-1]]:\n                stack.pop()\n            stack.append(end)\n            if end-stack[0] == n+1:\n                stack.pop(0)\n            maxv = max(num-B[stack[0]], maxv)\n            #print(end, stack, maxv)\n        if all(x<0 for x in A):\n            return max(A)\n        return maxv\n                \n                \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        if A == None or len(A) == 0:\n            return 0\n        max_sum , min_sum , total = -100000000, 1000000000, 0\n        curr_max_sum, curr_min_sum = 0, 0\n        for i in A:\n            curr_max_sum += i\n            max_sum = max(curr_max_sum, max_sum)\n            curr_max_sum = max(curr_max_sum, 0)\n            curr_min_sum += i\n            min_sum = min(curr_min_sum, min_sum)\n            curr_min_sum = min(curr_min_sum, 0)\n            total += i\n        return max_sum if max_sum < 0 else max(max_sum, total-min_sum)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        #naive will be n^2: try every possible start position\n        \n        #3 cases\n        \n        minSum = A[0]\n        maxSum = A[0]\n        maximum = A[0]\n        minimum = A[0]\n        for i in range(1, len(A)):\n            if A[i] > maxSum + A[i]:\n                maxSum = A[i]\n            else:\n                maxSum += A[i]\n            maximum = max(maximum, maxSum)\n            if A[i] < minSum + A[i]:\n                minSum = A[i]\n            else:\n                minSum += A[i]\n            minimum = min(minimum, minSum)\n        \n        minimum = sum(A) - minimum\n        if minimum == 0: #means the entire araay is negative, so we take the max element\n            return maximum\n        return max(maximum, minimum)\n        \n        #take the max of 3 cases\n        #1. maximum\n        #2. total - minimum\n        #3. if all negatives, then the max should be the maximum\n        \n        #[-2,-3,-1]. Take a look at this case, for example. \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        maxSum=A[0]\n        minSum=A[0]\n        currMax=0\n        currMin=0\n        total=0\n        for a in A:\n            currMax=max(currMax+a,a)\n            maxSum=max(currMax,maxSum)\n            currMin=min(currMin+a,a)\n            minSum=min(currMin,minSum)\n            total+=a\n        return max(maxSum,total-minSum) if maxSum>0 else maxSum", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        mx = float('-inf')\n        curr = 0\n        for x in A:\n            if curr >= 0:\n                curr += x\n            else:\n                curr = x\n            mx = max(mx, curr)\n        cumSum = []\n        curr = 0\n        for x in A:\n            curr += x\n            cumSum.append(curr)\n        revCumSum = []\n        curr = 0\n        for x in reversed(A):\n            curr += x\n            revCumSum.append(curr)\n        for i in range(1, len(A)):\n            revCumSum[i] = max(revCumSum[i-1], revCumSum[i])\n        for i in range(len(A)-1):\n            mx = max(mx, cumSum[i]+revCumSum[len(A)-2-i])\n        mx = max(mx, cumSum[-1])\n        return mx\n        \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        max_seen = max(A)\n        if max_seen < 0:\n            return max_seen\n        min_seen = float('inf')\n        curr_max = 0\n        curr_min = 0\n        total = 0\n        \n        for num in A:\n            total += num\n            curr_max = max(0, curr_max + num)\n            curr_min = min(0, curr_min + num)\n            max_seen = max(max_seen, curr_max)\n            min_seen = min(min_seen, curr_min)\n        \n        return max(max_seen, total - min_seen)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        def maxSubarray (A):\n            dp = [0] * len(A)\n            max_c = A[0]\n            for idx,num in enumerate(A):\n                if idx != 0:\n                    dp[idx]=max(num, dp[idx-1] + num)\n                else:\n                    dp[0]=num\n                    \n            return max(dp)\n        \n        temp = maxSubarray(A)\n\n        \n        res = float('-inf')\n        rightMax = [max(A[0],0)] + [0] * (len(A)-1)\n        currMax = max(A[0],0)\n        rightWindow = [A[0]] + [0] * (len(A)-1)\n        for idx,i in enumerate(A[1:]):\n            currMax = max(i+rightWindow[idx], currMax)\n            rightMax[idx+1] = currMax\n            rightWindow[idx+1] = i+rightWindow[idx]\n        \n\n        reversedA = A.reverse()\n        leftWindow = [A[0]] + [0] * (len(A)-1)\n        \n        for idx,i in enumerate(A[1:]):\n            leftWindow[idx +1] = i+leftWindow[idx]\n            currMax = rightMax[len(A)-idx-2]\n            res = max(res,currMax + leftWindow[idx])\n        \n\n        return max(res,temp)\n", "from sys import maxsize\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        i=1\n        n=len(A)\n        # A=A+A\n        # end = n\n        ans = A[0]\n        ans_max = A[0]\n        ans_min = A[0]\n        ans_f = A[0]\n        sumi = A[0]\n        while i < n:\n            sumi += A[i]\n            if ans+A[i%n]>A[i%n]:\n                ans+=A[i%n]\n            else:\n                ans=A[i%n]\n                \n            if ans_f+A[i%n]<A[i%n]:\n                ans_f+=A[i%n]\n            else:\n                ans_f=A[i%n]\n            ans_max = max(ans_max, ans)\n            ans_min = min(ans_min, ans_f)\n            i+=1\n            \n        return max(ans_max,sumi-ans_min) if ans_min!=sumi else ans_max", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        for i in range(1, len(A)):\n            A[i] += A[i-1]\n        pre_min, pre_max = float('inf'), float('-inf')\n        res1, res2 = A[0], A[0]\n        for a in A:\n            res1 = max(res1, a-pre_min)\n            res2 = min(res2, a-pre_max)\n            pre_min = min(pre_min, a)\n            pre_max = max(pre_max, a)\n        res1 = max(res1, A[-1])\n        res2 = min(res2, A[-1])\n        if res2 == A[-1]:\n            return res1\n        else:\n            return max(res1, A[-1]-res2)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)\n        if n == 1:\n            return A[0]\n        \n        max_ = A[0]\n        current = 0\n        for num in A:\n            current += num\n            max_ = max(max_, current)\n            if current < 0:\n                current = 0\n        \n        max_from_left = [0] * n\n        max_from_left[0] = float('-inf')\n        current = A[0]\n        for idx in range(1, n):\n            max_from_left[idx] = max(max_from_left[idx - 1], current)\n            current += A[idx]\n        max_from_left[0] = 0\n        \n        so_far = 0\n        for idx in range(n - 1, -1, -1):\n            so_far += A[idx]\n            max_ = max(max_, so_far + max_from_left[idx])\n        return max_\n        \n#         left_acc = [0] * n\n#         left_acc[0] = A[0]\n#         for idx in range(1, n):\n#             left_acc[idx] = A[idx] + left_acc[idx - 1]\n            \n        \n#         right_acc = [0] * n\n#         right_acc[-1] = A[-1]\n#         for idx in range(n - 2, -1, -1):\n#             right_acc[idx] = A[idx] + right_acc[idx + 1]\n        \n#         print(left_acc)\n#         print(right_acc)\n#         left, right = 0, n - 1\n#         while left < right:\n#             max_ = max(max_, left_acc[left] + right_acc[right])\n#             if left_acc[left] > right_acc[right]:\n#                 right -= 1\n#             else:\n#                 left += 1\n        \n#         return max_\n", "import math\n\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        total = 0\n        maxss, maxss_cur = -math.inf, -math.inf\n        minss, minss_cur = 0, 0\n        for a in A:\n            maxss_cur = a + max(maxss_cur, 0)\n            maxss = max(maxss, maxss_cur)\n            \n            minss_cur = a + min(minss_cur, 0)\n            minss = min(minss, minss_cur)\n            \n            total += a\n        \n        return maxss if total == minss else max(maxss, total - minss)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        currMaxSum = 0\n        currMinSum = 0\n        maxSum = float('-inf')\n        minSum = float('inf')\n        flag = False\n        \n        totalSum = 0\n        \n        for i in range(len(A)):\n            currMaxSum += A[i]\n            maxSum = max(maxSum, currMaxSum)\n            if currMaxSum < 0:\n                currMaxSum = 0\n\n            \n            totalSum += A[i]\n            if A[i] >= 0: \n                flag = True\n            \n            currMinSum += A[i]\n            minSum = min(minSum, currMinSum)\n            if currMinSum > 0:\n                currMinSum = 0\n            \n        if flag:\n            return max(totalSum-minSum, maxSum)\n        else:\n            return maxSum\n                \n \n            \n        \n            \n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n#             currMaxSum = 0\n#             currMinSum = 0\n#             flag = False\n#             maxSum = float('-inf')\n#             minSum = float('inf')\n#             totalSum = 0\n            \n#             for i in range(len(A)):\n                \n#                 currMaxSum += A[i]\n#                 maxSum = max(maxSum, currMaxSum)\n#                 if currMaxSum < 0:\n#                     currMaxSum = 0\n                    \n#                 totalSum += A[i]\n#                 if A[i] >= 0:\n#                     flag = True\n                    \n                 \n#                 currMinSum += A[i]\n#                 minSum = min(minSum, currMinSum)\n#                 if currMinSum > 0:\n#                     currMinSum = 0\n                    \n#             if not flag:\n#                 return maxSum \n\n#             else:\n#                 return max(maxSum, totalSum-minSum)\n            \n                    \n                \n                \n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n#         ans1 = cur = None \n#         for x in A:\n#             cur = x + max(cur, 0)\n#             ans1 = max(ans1, cur)\n            \n#         ans2 = cur = float(\\\"inf\\\")\n#         for i in range(1, len(A)):\n#             cur = A[i] + min(cur, 0)\n#             ans2 = min(ans2, cur)\n#         ans2 = sum(A) - ans2\n        \n#         ans3 = cur = float(\\\"inf\\\")\n#         for i in range(len(A)-1):\n#             cur = A[i] + min(cur, 0)\n#             ans3 = min(ans3, cur)\n#         ans3 = sum(A) - ans3\n        \n#         return max(ans1, ans2, ans3)\n        \n        \n        \n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         track = [[0 for j in range(len(A))] for j in range(len(A))]\n#         max_val = min(A)\n#         for i in range(len(A)):\n#             track[i][i] = A[i]\n#             for j in range(i+1, len(A)):\n#                     track[i][j] = track[i][j-1] + A[j]\n#                     max_val = max(max_val, track[i][j])\n#             max_val = max(max_val, track[i][i])\n                    \n#         #print(track)\n#         for i in range(len(A)-1, 0, -1):\n#             for j in range(0, i):\n#                 track[i][j] = track[i][len(track) - 1] + track[0][j]\n#                 max_val = max(max_val, track[i][j])\n                \n#         #print(track)\n#         return max_val]\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n            \n            currMaxSum = 0\n            currMinSum = 0\n            flag = False\n            maxSum = float('-inf')\n            minSum = float('inf')\n            totalSum = 0\n            \n            for i in range(len(A)):\n                \n                currMaxSum += A[i]\n                maxSum = max(maxSum, currMaxSum)\n                if currMaxSum < 0:\n                    currMaxSum = 0\n                    \n                totalSum += A[i]\n                if A[i] >= 0:\n                    flag = True\n                    \n                 \n                currMinSum += A[i]\n                minSum = min(minSum, currMinSum)\n                if currMinSum > 0:\n                    currMinSum = 0\n                    \n            if not flag:\n                return maxSum \n\n            else:\n                return max(maxSum, totalSum-minSum)\n            \n                    \n                \n                \n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n#         ans1 = cur = None \n#         for x in A:\n#             cur = x + max(cur, 0)\n#             ans1 = max(ans1, cur)\n            \n#         ans2 = cur = float(\\\"inf\\\")\n#         for i in range(1, len(A)):\n#             cur = A[i] + min(cur, 0)\n#             ans2 = min(ans2, cur)\n#         ans2 = sum(A) - ans2\n        \n#         ans3 = cur = float(\\\"inf\\\")\n#         for i in range(len(A)-1):\n#             cur = A[i] + min(cur, 0)\n#             ans3 = min(ans3, cur)\n#         ans3 = sum(A) - ans3\n        \n#         return max(ans1, ans2, ans3)\n        \n        \n        \n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         track = [[0 for j in range(len(A))] for j in range(len(A))]\n#         max_val = min(A)\n#         for i in range(len(A)):\n#             track[i][i] = A[i]\n#             for j in range(i+1, len(A)):\n#                     track[i][j] = track[i][j-1] + A[j]\n#                     max_val = max(max_val, track[i][j])\n#             max_val = max(max_val, track[i][i])\n                    \n#         #print(track)\n#         for i in range(len(A)-1, 0, -1):\n#             for j in range(0, i):\n#                 track[i][j] = track[i][len(track) - 1] + track[0][j]\n#                 max_val = max(max_val, track[i][j])\n                \n#         #print(track)\n#         return max_val\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n#         total, maxSum, curMax, minSum, curMin = 0, float('-inf'), 0, float('inf'), 0\n        \n#         for a in A:\n#             curMax = max(curMax + a, a)\n#             maxSum = max(maxSum, curMax)\n#             curMin = min(curMin + a, a)\n#             minSum = min(minSum, curMin)\n#             total += a\n            \n#         return max(maxSum, total - minSum) if maxSum > 0 else maxSum\n    \n    \n        if not A:\n            return 0\n        \n        dp_max = [-99999] * len(A)\n        dp_min = [-99999] * len(A)\n        dp_max[0], dp_min[0] = A[0], A[0]\n        \n        for i in range(1, len(A)):\n            dp_max[i] = max(A[i], dp_max[i - 1] + A[i])\n            dp_min[i] = min(A[i], dp_min[i - 1] + A[i])\n        \n        if min(dp_min) == sum(A):\n            return max(dp_max)\n        else:\n            return max(max(dp_max), sum(A) - min(dp_min))", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        # max(the max subarray sum, the total sum - the min subarray sum)\n        max_sum = -float('inf')\n        cur_max = -float('inf')\n        total_sum = 0\n        cur_min = float('inf')\n        min_sum = float('inf')\n        for i in A:\n            total_sum += i\n            \n            cur_max = max(cur_max + i, i)\n            cur_min = min(cur_min + i, i)\n            \n            max_sum = max(max_sum, cur_max)\n            min_sum = min(min_sum, cur_min)\n            \n        if total_sum - min_sum == 0:\n            return max_sum\n        return max(max_sum, total_sum - min_sum) ", "# method 1  append array's copy at back of it. then apply kadane's algorithm\n# *not work* because we can only attain maximum n size window but here it can be 2n\n\n# method 2  sliding window  max window size = n\n# *not work* because there is no way to move back of window\n\n# method 3  modified kadane's algorithm(see in lee215's solution)\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        \n        max_sum, cur_max, min_sum, cur_min, total = A[0], 0, A[0], 0, 0\n        for a in A:\n            cur_max = max(a + cur_max, a)\n            max_sum = max(max_sum, cur_max)\n            \n            cur_min = min(a + cur_min, a)\n            min_sum = min(min_sum, cur_min)\n            \n            total += a\n        \n        return max(max_sum, total - min_sum) if total > min_sum else max_sum", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        total = sum(A)\n        minSum = self.maxSum([-x for x in A]) + total\n        maxSum = self.maxSum(A)\n        #print(maxSum)\n        #print(minSum)\n        return max(maxSum, minSum) if minSum > 0 else maxSum\n        \n    def maxSum(self, A: List[int]) -> int:\n        current = 0\n        max_sum = float('-inf')\n        for num in A:\n            current += num\n            \n            if current > max_sum:\n                max_sum = current\n            \n            if current < 0:\n                current = 0\n        \n        return max_sum\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        # 1. get max subarray sum\n        maxSum = curSum = A[0]\n        for i in range(1, len(A)):\n            curSum = max(A[i], A[i] + curSum)\n            maxSum = max(maxSum, curSum)\n        \n        if maxSum < 0:\n            return maxSum\n        \n        # 2. get min subarray sum\n        minSum = curSum = A[0]\n        for i in range(1, len(A)):\n            curSum = min(A[i], A[i] + curSum)\n            minSum = min(minSum, curSum)\n        \n        # 3. compare (max subarray sum) with (total sum - min subarray sum)\n        return max(sum(A)-minSum, maxSum)", "#Two cases:\n#MaxSubarray = normal -> proceed normally\n#MaxSubarray = circular -> total sum - minSubarray\n#return max(maxSubarray, maxSubarraycircular\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        total_sum = 0\n        global_max = A[0]\n        global_min = A[0]\n        local_max = 0\n        local_min = 0\n        for num in A:\n            local_max = max(num, local_max + num)\n            local_min = min(num, local_min + num)\n            global_max = max(global_max, local_max)\n            global_min = min(global_min, local_min)\n            total_sum += num\n            \n        circular_max = total_sum - global_min\n        if global_max <= 0:\n            return global_max\n        return max(circular_max, global_max)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        SUM = 0\n        MIN = 0\n        minsum = sys.maxsize\n        MAX = 0\n        maxsum = -sys.maxsize\n        \n        for num in A:\n            SUM += num\n            maxsum = max(maxsum, SUM-MIN)\n            MIN = min(MIN,SUM)\n            minsum = min(minsum, SUM-MAX)\n            MAX = max(MAX,SUM)\n        if minsum == SUM:\n            return maxsum\n        return max(maxsum, SUM-minsum)", "#Two cases:\n#MaxSubarray = normal -> proceed normally\n#MaxSubarray = circular -> total sum - minSubarray\n#return max(maxSubarray, maxSubarraycircular\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        total_sum = 0\n        global_max = A[0]\n        global_min = A[0]\n        local_max = 0\n        local_min = 0\n        for num in A:\n            local_max = max(num, local_max + num)\n            local_min = min(num, local_min + num)\n            global_max = max(global_max, local_max)\n            global_min = min(global_min, local_min)\n            total_sum += num\n            \n        circular_max = total_sum - global_min\n        return max(circular_max, global_max) if global_max > 0 else global_max", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)\n        \n        if n == 1:\n            return A[0]\n        \n        global_max = float('-inf')\n        global_min = float('inf')\n        \n        local_max = 0\n        local_min = 0\n        \n        for i, a in enumerate(A):\n            local_max = max(local_max + a, a)\n            global_max = max(global_max, local_max)\n            \n            if 0 < i < n - 1:\n                local_min = min(local_min + a, a)\n                global_min = min(global_min, local_min)\n        \n        return max(global_max, sum(A) - global_min)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        max1 = -float('inf')\n        maxc = -float('inf')\n        for i in range(len(A)):\n            maxc = max(maxc+A[i],A[i])\n            max1 = max(max1,maxc)\n        \n        \n        min1 = float('inf')\n        minc = float('inf')\n        for i in range(len(A)):\n            minc = min(minc+A[i],A[i])\n            min1 = min(min1,minc)\n        \n        if min1==sum(A):\n            return max1\n\n        return max(max1,sum(A)-min1)\n        \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        # n = len(A)\n        # max_sub_ending = [A[0]]\n        # max_sub_start_index = [0]\n        \n#         A.extend(A)\n#         print(A)\n#         for i in range(1, len(A)):\n#             prev = max_sub_ending[i-1]\n#             if prev <= 0:\n#                 max_sub_start_index.append(i)\n#                 max_sub_ending.append(A[i])\n#             if i - max_sub_start_index[-1] < n:\n#                 max_sub_start_index.append(max_sub_start_index[-1])\n#                 max_sub_ending.append(A[i]+max_sub_ending[-1])\n#             elif (i - max_sub_start_index[-1]) == n:\n#                 index_len = len(max_sub_start_index)\n#                 val = max_sub_start_index[index_len-n]\n#                 current_sum = max_sub_ending[-1] - val\n#                 if current_sum <= 0:\n#                     max_sub_start_index.append(i)\n#                     max_sub_ending.append(A[i])\n#                 else:\n#                     max_sub_start_index.append(max_sub_start_index[-1]+1)\n#                     max_sub_ending.append(A[i]+current_sum)\n#         print(max_sub_ending)\n#         return max(max_sub_ending)\n        n = len(A)\n        max_sub_ending = [A[0]]\n        max_sub_ending_index = [0]\n        \n        for i in range(1, len(A)):\n            prev = max_sub_ending[i-1]\n            if prev <= 0:\n                max_sub_ending_index.append(i)\n                max_sub_ending.append(A[i])\n            else:\n                max_sub_ending_index.append(max_sub_ending_index[-1])\n                max_sub_ending.append(A[i]+max_sub_ending[-1])\n        print(max_sub_ending)\n        posmax = max(max_sub_ending)\n        total = sum(A)\n        \n        for i in range(len(A)):\n            A[i] = -A[i]\n        max_sub_ending = [A[0]]\n        max_sub_ending_index = [0]\n        \n        for i in range(1, len(A)):\n            prev = max_sub_ending[i-1]\n            if prev <= 0:\n                max_sub_ending_index.append(i)\n                max_sub_ending.append(A[i])\n            else:\n                max_sub_ending_index.append(max_sub_ending_index[-1])\n                max_sub_ending.append(A[i]+max_sub_ending[-1])\n        print(max_sub_ending)\n        negmax = max(max_sub_ending)+total   \n        if negmax > posmax and negmax != 0:\n            return negmax\n        else:\n            return posmax\n        \n#         cycle = max_sub_ending[-1]\n#         if cycle <= 0:\n#             return max(max_sub_ending)\n        \n#         for i in range(max_sub_ending_index[-1]):\n#             if cycle <= 0:\n#                 return max(max_sub_ending)\n            \n#             max_sub_ending_index[i] = cycle+A[i]\n#             cycle = max_sub_ending_index[i]\n#         return max(max_sub_ending)\n        \n#         total = sum(A)\n        \n#         #left sum\n#         left_sum = [A[0]]\n#         left = A[0]\n        \n#         for i in range(1, len(A)):\n            \n#             left = left+A[i]\n#             left_sum.append(left)\n        \n#         #right sum\n#         right = A[-1]\n#         right_sum = [right]\n        \n#         for i in range(len(A)-2, -1, -1):\n            \n#             right += A[i]\n#             right_sum.append(right)\n\n#         right_sum.reverse()\n        \n#         max_sub = total\n\n#         for i in range(0, len(A)):\n#             for j in range(i, len(A)):\n#                 left, right = 0, 0\n#                 if i != 0:\n#                     left = left_sum[i-1]\n#                 if j != (len(A) -1):\n#                     right = right_sum[j+1]\n#                 max_sub = max(max_sub, total - left - right , left+right)\n        \n#         #corner case\n#         if max(A) < 0:\n#             return max(A)\n#         return max_sub\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        #On\n        n=len(A)\n        total=A[0]\n        curmax=A[0]\n        curmin=A[0]\n        maxsum=curmax\n        minsum=curmin\n        for i in range(1,n):\n            curmax=max(curmax+A[i],A[i])\n            maxsum=max(maxsum,curmax)\n            curmin=min(curmin+A[i],A[i])\n            minsum=min(minsum,curmin)\n            total+=A[i]\n        #get maxsum and minsum\n        # total-minsum and maxsum\n        if total==minsum:\n            return maxsum\n        else:\n            return max(maxsum,total-minsum)\n            \n        \n        \n        \n        \n        \n        \n        \n#         dp=[0]*n\n#         optsum=[A[0]]*n\n#         pre=A[0]\n#         dp[0]=A[0]\n#         first=dp[0]\n#         for i in range(1,n):\n#             dp[i]=max(dp[i-1]+A[i],A[i])\n#             first=max(first,dp[i])\n            \n#             pre+=A[i]\n#             if pre>optsum[i-1]:\n#                 optsum[i]=pre\n#             else:\n#                 optsum[i]=optsum[i-1]\n#         # get second case now\n#         #print(optsum)\n#         pre=0\n#         for j in range(n-1,0,-1):\n#             first=max(first,pre+A[j]+optsum[j-1])\n#             pre+=A[j]\n            \n#         return first\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        #N2 solution\n#         n = len(A)\n#         maxSum = -float('inf')\n\n#         for i in range(n):\n#             currSum = 0\n#             for j in range(n):\n#                 ind = (i+j)%n\n#                 ele = A[ind]\n                \n#                 newSum = currSum +ele\n#                 maxSum = max(maxSum,newSum)\n                \n#                 if currSum>0 and newSum<0:\n#                     currSum = 0\n#                 elif currSum<0 and newSum<currSum:\n#                     currSum=0\n                    \n#                 else:\n#                     currSum = newSum\n\n#         return maxSum\n    \n        n = len(A)\n        maxSum = -float('inf')\n\n        currSum = 0\n        for j in range(n):\n            ele = A[j]\n\n            newSum = currSum +ele\n            maxSum = max(maxSum,newSum)\n\n            if currSum>0 and newSum<0:\n                currSum = 0\n            elif currSum<=0 and newSum<currSum:\n                currSum=0\n\n            else:\n                currSum = newSum\n\n        lSum = 0\n        bestLSum=0\n        totalSum = sum(A)\n        for i in range(n):\n            currSum= totalSum-lSum\n            currSum+=bestLSum\n            maxSum = max(maxSum,currSum)\n            \n            lSum+=A[i]\n            bestLSum=max(lSum,bestLSum)\n            \n        return maxSum", "\nclass Solution:\n    def maxSubarraySumCircular(self, arr: List[int]) -> int:\n        def maxsub(a,n):\n            maxsum = a[0]\n            currsum= 0\n            for i in range(n):\n                if currsum+a[i]>0:\n                    currsum+=a[i]\n                    maxsum = max(maxsum,currsum)\n                else:\n                    currsum=0\n                    maxsum= max(maxsum,a[i])\n            return maxsum\n        b =[i*-1 for i in arr]\n        n  = len(arr)\n        s=sum(arr)\n        ans2=0\n        ans2 = maxsub(b,n)\n        if s==-ans2:\n            ans2 = -ans2\n        return max(maxsub(arr,n),s+ans2)\n                    \n                    \n            \n        \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        if len(A) == 0:\n            return 0\n        minS = minT = maxS = maxT = s = A[0]\n        for i in range(1,len(A)):\n            minS = min(A[i],minS + A[i])\n            minT = min(minS,minT)\n            \n            maxS = max(A[i],maxS + A[i])\n            maxT = max(maxT,maxS)\n            \n            s += A[i]\n        if s == minT:\n            return maxT\n        return max(s - minT,maxT)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        if len(A) == 1:\n            return A[0]\n        s = sum(A)\n        nums = A\n        m = nums[0]\n        last = m\n        num = 1\n        last_max = m\n        res = last\n        res_max = last_max\n        for i in A[1:]:\n            if i + last < i:\n                last = i + last\n                num += 1\n            else:\n                last = i\n                num = 1\n            if num != len(A):\n                res = min(res, last)\n            last_max = max(i, i+last_max)\n            res_max = max(res_max, last_max)\n        return max(s-res, res_max)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        currentMax = totalMax = currentMin = totalMin = A[0]\n        s = A[0]\n        for i in range(1, len(A)):\n            currentMax = max(currentMax + A[i], A[i])\n            totalMax = max(totalMax, currentMax)\n            currentMin = min(currentMin + A[i], A[i])\n            totalMin = min(totalMin, currentMin)\n            s += A[i] \n        if s - totalMin != 0:\n            return max(totalMax, s - totalMin)\n        else: return totalMax", "import math\nimport random\nimport string\nfrom functools import lru_cache\nfrom operator import truediv\nfrom typing import List, Set\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\nimport numpy as np\nimport collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\n\n'''\n53. Maximum Subarray \u65e0\u5faa\u73af\n    dp[i] = max(A[i], dp[i-1] + A[i])\n    \u663e\u7136\u5f53dp[i-1] < 0 \u65f6\uff0c dp[i] = A[i]\uff0c\u5219\u6709\uff1a\n    dp[i] = A[i] + max(dp[i-1], 0)\n\n\u7c7b\u6bd453\uff0c\u6b64\u9898\u52a0\u4e86\u5faa\u73af\u3002\u4e5f\u5c31\u662f\u627e\u5230\u5c3e\u90e8\u548c\u5f00\u5934\u7684\u6700\u5927\u6b63\u6570\u7ec4\u3002\n\nhttps://leetcode.com/problems/maximum-sum-circular-subarray/discuss/178422/One-Pass\n\n\u4f46\u5176\u5b9e\u5c31\u662f\u627e\u5230\u4e2d\u95f4\u7684\u6700\u8d1f\u5b50\u6570\u7ec4\u3002\n'''\n\n\nclass Solution:\n    def maxSubarraySumCircular(self, A):\n        total, maxSum, curMax, minSum, curMin = 0, A[0], 0, A[0], 0\n        for a in A:\n            curMax = max(curMax + a, a)\n            maxSum = max(maxSum, curMax)\n            curMin = min(curMin + a, a)\n            minSum = min(minSum, curMin)\n            total += a\n        return max(maxSum, total - minSum) if maxSum > 0 else maxSum\n\n\n# r = Solution()\n# a = r.maxSubarraySumCircular([3,-1,2,-1])\n# print(a)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        #On\n        n=len(A)\n        dp=[0]*n\n        optsum=[A[0]]*n\n        pre=A[0]\n        dp[0]=A[0]\n        first=dp[0]\n        for i in range(1,n):\n            dp[i]=max(dp[i-1]+A[i],A[i])\n            first=max(first,dp[i])\n            \n            pre+=A[i]\n            if pre>optsum[i-1]:\n                optsum[i]=pre\n            else:\n                optsum[i]=optsum[i-1]\n        # get second case now\n        #print(optsum)\n        pre=0\n        for j in range(n-1,0,-1):\n            first=max(first,pre+A[j]+optsum[j-1])\n            pre+=A[j]\n            \n        return first", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        ans1 = cur = 0\n        for x in A:\n            cur = x + max(cur, 0)\n            ans1 = max(ans1, cur)\n        \n        ans2 = cur = 0\n        for x in A[1:]:\n            cur = x + min(cur, 0)\n            ans2 = min(ans2, cur)\n        ans2 = sum(A) - ans2\n        \n        ans3 = cur = 0\n        for x in A[:-1]:\n            cur = x + min(cur, 0)\n            ans3 = min(ans3, cur)\n        ans3 = sum(A) - ans3\n        \n        ans = max(ans1, ans2, ans3)\n        return ans if ans != 0 else max(A)\n", "class Solution:\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        greatest: int = -sys.maxsize + 1\n        smallest: int = sys.maxsize\n        x = y = total = 0\n\n        for i in range(len(nums)):\n            x += nums[i]\n            greatest = max(greatest, x)\n            x = max(x, 0)\n\n            y += nums[i]\n            smallest = min(smallest, y)\n            y = min(y, 0)\n\n            total += nums[i]\n\n        return greatest if greatest < 0 else max(greatest, total - smallest)\n\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        N = len(A)\n\n        ans = cur = 0\n        for x in A:\n            cur = x + max(cur, 0)\n            ans = max(ans, cur)\n\n        rightsums = [None] * N\n        rightsums[-1] = A[-1]\n        for i in range(N-2, -1, -1):\n            rightsums[i] = rightsums[i+1] + A[i]\n\n        # maxright[i] = max_{j >= i} rightsums[j]\n        maxright = [None] * N\n        maxright[-1] = rightsums[-1]\n        for i in range(N-2, -1, -1):\n            maxright[i] = max(maxright[i+1], rightsums[i])\n\n        leftsum = 0\n        for i in range(N-2):\n            leftsum += A[i]\n            ans = max(ans, leftsum + maxright[i+1])\n        if max(A) < 0:\n            return max(A)\n        return ans\n    \n    \n#         total = sum(A)\n#         max_sum_ending_i = [A[0]]\n#         prev = max_sum_ending_i[-1]\n        \n        \n#         for i in range(1, len(A)):\n#             if prev <= 0:\n#                 max_sum_ending_i.append(A[i])\n#             else:\n#                 max_sum_ending_i.append(max_sum_ending_i[-1]+A[i])\n#             prev = max_sum_ending_i[-1]\n        \n#         min_sum_ending_i = [A[0]]\n#         prev = min_sum_ending_i[-1]\n\n#         for i in range(1, len(A)):\n#             if prev >= 0:\n#                 min_sum_ending_i.append(A[i])\n#             else:\n#                 min_sum_ending_i.append(min_sum_ending_i[-1]+A[i])\n#             prev = min_sum_ending_i[-1]\n        \n#         if max(A) > 0:\n#             return max(total - min(min_sum_ending_i), max(max_sum_ending_i))\n#         else:\n#             return max(A)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        sums = sum(A)\n        min_res = min_s = sys.maxsize\n        max_res = max_s = -sys.maxsize\n        n = len(A)\n        for i in range(n):\n            min_s = min(A[i], min_s + A[i])\n            max_s = max(A[i], max_s + A[i])\n            min_res = min(min_res, min_s)\n            max_res = max(max_res, max_s)\n        if min_res == sums:\n            min_res = min(A)\n        else:\n            min_res = sums - min_res\n        return max(min_res, max_res)", "import numpy as np\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        total, maxSum, curMax, minSum, curMin = 0, A[0], -np.Infinity, A[0], np.Infinity\n        for a in A:\n            curMax = max(curMax + a, a)\n            maxSum = max(maxSum, curMax)\n            curMin = min(curMin + a, a)\n            minSum = min(minSum, curMin)\n            total += a\n        return max(maxSum, total - minSum) if maxSum>0 else maxSum", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        if max(A) <= 0: return max(A)\n        endmax = [i for i in A]\n        endmin = [i for i in A]\n        for i in range(len(A)-1):\n            if endmax[i] > 0: endmax[i+1] += endmax[i]\n            if endmin[i] < 0: endmin[i+1] += endmin[i]\n        return max(max(endmax), sum(A) - min(endmin))", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        def kadane(gen):\n            ans = None\n            cur = None\n            for x in gen:\n                if cur:\n                    cur = x + max(cur, 0)\n                else:\n                    cur = x\n                if ans:\n                    ans = max(ans, cur)\n                else:\n                    ans = cur\n            return ans\n        S = sum(A)\n        ans1 = kadane((A))\n        if len(A) > 1:\n            ans2 = S + kadane([-A[i] for i in range(1, len(A))])\n            ans3 = S + kadane([-A[i] for i in range(len(A) - 1)])\n            return max(ans1, ans2, ans3)\n        else:\n            return ans1\n", "# class Solution(object):\n#     def maxSubarraySumCircular(self, A):\n#         N = len(A)\n\n#         ans = float('-inf')\n#         cur = 0\n#         for x in A:\n#             cur = x + max(cur, 0)\n#             ans = max(ans, cur)\n\n#         # ans is the answer for 1-interval subarrays.\n#         # Now, let's consider all 2-interval subarrays.\n#         # For each i, we want to know\n#         # the maximum of sum(A[j:]) with j >= i+2\n\n#         # rightsums[i] = sum(A[i:])\n#         rightsums = [None] * N\n#         rightsums[-1] = A[-1]\n#         for i in xrange(N-2, -1, -1):\n#             rightsums[i] = rightsums[i+1] + A[i]\n\n#         # maxright[i] = max_{j >= i} rightsums[j]\n#         maxright = [None] * N\n#         maxright[-1] = rightsums[-1]\n#         for i in xrange(N-2, -1, -1):\n#             maxright[i] = max(maxright[i+1], rightsums[i])\n\n#         leftsum = 0\n#         for i in xrange(N-2):\n#             leftsum += A[i]\n#             ans = max(ans, leftsum + maxright[i+2])\n#         return ans\n    \nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        N = len(A)\n        ans = float('-inf')\n        cur = 0\n        for x in A:\n            cur = x + max(cur, 0)\n            ans = max(ans, cur)\n        \n        rightsums = [None] * N\n        rightsums[-1] = A[-1]\n        for i in range(N-2, -1, -1):\n            rightsums[i] = rightsums[i+1] + A[i]\n        \n        maxright = [None] * N\n        maxright[-1] = rightsums[-1]\n        for i in range(N-2, -1, -1):\n            maxright[i] = max(maxright[i+1], rightsums[i])\n        \n        leftsum = 0\n        for i in range(N-2):\n            leftsum += A[i]\n            ans = max(ans, leftsum + maxright[i+2])\n        \n        return ans\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)\n        ans = cur = float('-inf')\n        for x in A:\n            cur = x + max(cur, 0)\n            ans = max(ans, cur)\n            \n        rightsums = [0]*n\n        rightsums[-1] = A[-1]\n        for i in range(n-2, -1, -1):\n            rightsums[i] = rightsums[i+1] + A[i]\n            \n        maxright = [0]*n\n        maxright[-1] = rightsums[-1]\n        for i in range(n-2, -1, -1):\n            maxright[i] = max(maxright[i+1], rightsums[i])\n            \n        leftsum = 0\n        for i in range(n-2):\n            leftsum += A[i]\n            ans = max(ans, leftsum + maxright[i+2])\n            \n        return ans", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        ans1 = cur = 0\n        for x in A:\n            cur = x + max(cur, 0)\n            ans1 = max(ans1, cur)\n        \n        ans2 = cur = 0\n        for i in range(1, len(A)):\n            cur = A[i] + min(cur, 0)\n            ans2 = min(ans2, cur)\n        ans2 = sum(A) - ans2\n        \n        ans3 = cur = 0\n        for i in range(len(A)-1):\n            cur = A[i] + min(cur, 0)\n            ans3 = min(ans3, cur)\n        ans3 = sum(A) - ans3\n        \n        ans = max(ans1, ans2, ans3)\n        return ans if ans != 0 else max(A)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        def kadane(A):\n            ts=A[0]\n            ms=A[0]\n            for i in range(1,len(A)):\n                ts=max(A[i],ts+A[i])\n                ms=max(ms,ts)\n            return ms\n        x=kadane(A)\n        for i in range(len(A)):\n            A[i]*=-1\n        s=sum(A)\n        y=kadane(A)\n        if y==s:\n            y=-1e10\n        else:\n            y=-s+y\n        return max(x,y)\n            \n                \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        def find_max_sum(A):\n            curr_sum = 0\n            max_sum = -math.inf\n            for num in A:\n                if curr_sum > 0:\n                    curr_sum += num\n                else:\n                    curr_sum = num\n                max_sum = max(max_sum, curr_sum)\n            return max_sum\n        max_sum = find_max_sum(A)\n        min_sum_1 = -find_max_sum(-num for num in A[1:])\n        min_sum_2 = -find_max_sum(-num for num in A[:-1])\n        return max(sum(A) - min(min_sum_1, min_sum_2), max_sum)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)\n        A *= 2\n        ans = [0] * len(A)\n        q = collections.deque()\n        cur = 0\n        for i, a in enumerate(A):\n            while q and i - q[0][0] > n:\n                q.popleft()\n            cur += a\n            ans[i] = cur - q[0][1] if q else cur\n            while q and q[-1][1] >= cur:\n                q.pop()\n            q.append((i, cur))\n        return max(ans)\n        \n        \n        # n = len(A)\n        # A *= 2\n        # ans = [A[0]] + [0] * (len(A) - 1)\n        # q = collections.deque([(0, A[0])])\n        # cur = A[0]\n        # for i, a in enumerate(A[1:], 1):\n        #     while q and i - q[0][0] > n:\n        #         q.popleft()\n        #     cur += a\n        #     ans[i] = cur - q[0][1]\n        #     while q and q[-1][1] >= cur:\n        #         q.pop()\n        #     q.append((i, cur))\n        # return max(ans)\n", "class Solution:\n  def maxSubarraySumCircular(self, A: List[int]) -> int:\n    def kadane(gen):\n      # maximum non-empty subarray sum\n      ans = - sys.maxsize\n      cur = - sys.maxsize\n      for x in gen:\n        cur = x + max(cur, 0)\n        ans = max(ans, cur)\n      \n      return ans\n    \n    S = sum(A)\n    ans1 = kadane(iter(A))\n    ans2 = S + kadane(-A[i] for i in range(1, len(A)))\n    ans3 = S + kadane(-A[i] for i in range(len(A) - 1))\n    \n    return max(ans1, ans2, ans3)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        '''\n        12341234\n        limit of  len[] < a.length\n        \n        \n        p[i], i\n        \n        '''\n        def kaden(gen):\n            ans = cur = gen[0]\n            for n in gen[1:]:\n                cur = n + max(0, cur)\n                ans = max(ans, cur)\n            return ans\n        \n        ans1 = kaden(A)\n        if len(A)>1: \n            s = sum(A)\n            ans2 = s + kaden([-a for a in A[1:]])\n            ans3 = s + kaden([-a for a in A[:-1]])\n        else:\n            ans2 = ans3 = -float('inf')\n        \n        return max(ans1, ans2, ans3)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        def kadane(gen):\n            ans = cur = -float('inf')\n            for x in gen:\n                cur = x + max(cur, 0)\n                ans = max(ans, cur)\n            return ans\n        S = sum(A)\n        ans1 = kadane(iter(A))\n        ans2 = S + kadane(-A[i] for i in range(1, len(A)))\n        ans3 = S + kadane(-A[i] for i in range(len(A)-1))\n        return max(ans1, ans2, ans3)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        B = A.copy()\n        for i in range(1,len(B)):\n            if B[i-1] > 0:\n                B[i] += B[i-1]\n        maxsum = max(B)\n        C = A.copy()\n        for i in range(1, len(C)):\n            if C[i-1] < 0:\n                C[i] += C[i-1]\n        minsum = min(C)\n        if minsum == sum(A):\n            return max([maxsum, max(A)])\n        return max([maxsum, sum(A)-minsum])", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        '''\n        12341234\n        limit of  len[] < a.length\n        \n        \n        p[i], i\n        \n        '''\n        def kaden(gen):\n            ans = cur = -float('inf')\n            for n in gen:\n                cur = n + max(0, cur)\n                ans = max(ans, cur)\n            return ans\n        ans1 = kaden(iter(A))\n        if len(A)>1: \n            s = sum(A)\n            ans2 = s + kaden(-a for a in A[1:])\n            ans3 = s + kaden(-a for a in A[1:])\n        else:\n            ans2 = ans3 = -float('inf')\n        \n        return max(ans1, ans2, ans3)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        def kadane(gen):\n            #ans = None\n            #cur = None\n            #for x in gen:\n            #    if cur:\n            #        cur = x + max(cur, 0)\n            #    else:\n            #        cur = x\n            #    if ans:\n            #        ans = max(ans, cur)\n            #    else:\n            #        ans = cur\n            #return ans\n            \n            size = len(gen)\n            ans = cur = gen[0]\n            for i in range(1,size):\n                cur = max(gen[i], cur + gen[i])\n                ans = max(ans, cur)\n            return ans\n        S = sum(A)\n        ans1 = kadane((A))\n        if len(A) > 1:\n            ans2 = S + kadane([-A[i] for i in range(1, len(A))])\n            ans3 = S + kadane([-A[i] for i in range(len(A) - 1)])\n            return max(ans1, ans2, ans3)\n        else:\n            return ans1\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)\n        A *= 2\n        ans = [A[0]] + [0] * (len(A) - 1)\n        q = collections.deque([(0, A[0])])\n        cur = A[0]\n        for i, a in enumerate(A[1:], 1):\n            while q and i - q[0][0] > n:\n                q.popleft()\n            cur += a\n            ans[i] = cur - q[0][1]\n            while q and q[-1][1] >= cur:\n                q.pop()\n            q.append((i, cur))\n        return max(ans)\n        \n        \n        # n = len(A)\n        # A *= 2\n        # ans = [0] * len(A)\n        # q = collections.deque()\n        # cur = 0\n        # for i, a in enumerate(A):\n        #     while q and i - q[0][0] > n:\n        #         q.popleft()\n        #     cur += a\n        #     ans[i] = cur - q[0][1] if q else cur\n        #     while q and q[-1][1] >= cur:\n        #         q.pop()\n        #     q.append((i, cur))\n        # return max(ans)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)   \n        ans = cur = float('-inf') \n        for v in A:\n            cur = v + max(cur, 0) \n            ans = max(ans, cur)\n       \n        rightsum = [0] * n\n        rightsum[-1] = A[-1]\n        for i in range(n-2, -1, -1):\n            rightsum[i] = rightsum[i+1] + A[i]\n        \n        rightmax = [0]*n\n        rightmax[-1] = rightsum[-1]\n        for i in range(n-2, -1, -1):\n            rightmax[i] = max(rightmax[i+1], rightsum[i])\n        \n        \n        cur = 0\n        for i in range(n-2):\n            cur += A[i]\n            ans = max(ans, cur+rightmax[i+2])\n            \n        return ans\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)\n        \n        ans = -float('inf')\n        currmax = -float('inf')\n        for i in range(n):\n            currmax = max(currmax+A[i], A[i])\n            ans = max(ans, currmax)\n        \n        right_sums = [0]*n\n        right_sums[-1] = A[-1]\n        for i in range(1, n):\n            right_sums[n-1-i] = right_sums[n-i] + A[n-i-1]\n            \n        maxright = [0]*n\n        maxright[-1] = right_sums[-1]\n        for i in range(1, n):\n            maxright[n-i-1] = max(maxright[n-i], right_sums[n-i-1])\n        \n        \n        lefts = 0\n        for i in range(n-2):\n            lefts += A[i]\n            ans = max(ans, lefts+maxright[i+2])\n        \n        return ans", "class Solution:\n    def maxSubarraySumCircular(self, A):\n        total = sum(A)\n        max_sum = [0 for i in range(len(A))]\n        min_sum = [0 for i in range(len(A))]\n\n        max_sum[0] = A[0]\n        min_sum[0] = A[0]\n\n        best_non_loop = max_sum[0]\n        best_inverse_loop = min_sum[0]\n\n        for i in range(1, len(A)):\n            max_sum[i] = A[i] + max(max_sum[i - 1], 0)\n            min_sum[i] = A[i] + min(min_sum[i - 1], 0)\n            \n            best_non_loop = max(best_non_loop, max_sum[i])\n            best_inverse_loop = min(best_inverse_loop, min_sum[i])\n\n        ret = max(best_non_loop, total - best_inverse_loop)\n        if ret == 0:\n            return max(A)\n        return ret", "class Solution(object):\n    def maxSubarraySumCircular(self, A):\n        N = len(A)\n\n        # Compute P[j] = sum(B[:j]) for the fixed array B = A+A\n        P = [0]\n        for _ in range(2):\n            for x in A:\n                P.append(P[-1] + x)\n\n        # Want largest P[j] - P[i] with 1 <= j-i <= N\n        # For each j, want smallest P[i] with i >= j-N\n        ans = A[0]\n        deque = collections.deque([0]) # i's, increasing by P[i]\n        for j in range(1, len(P)):\n            # If the smallest i is too small, remove it.\n            if deque[0] < j-N:\n                deque.popleft()\n\n            # The optimal i is deque[0], for cand. answer P[j] - P[i].\n            ans = max(ans, P[j] - P[deque[0]])\n\n            # Remove any i1's with P[i2] <= P[i1].\n            while deque and P[j] <= P[deque[-1]]:\n                deque.pop()\n\n            deque.append(j)\n\n        return ans", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        tot = sum(A)\n        B = A[:]\n        \n        for i in range(1, len(A)):\n            if A[i - 1] > 0:\n                A[i] += A[i - 1]\n            if B[i - 1] < 0:\n                B[i] += B[i - 1]\n        \n        submax = max(A)\n        submin = min(B)\n        \n        return max(submax, tot - submin) if tot != submin else submax\n            \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        N = len(A)\n        prefix = [0]\n        for _ in range(2):\n            for x in A:\n                prefix.append(prefix[-1] + x)\n        \n        res = A[0]\n        deque = collections.deque([0])\n        for j in range(1, len(prefix)):\n            if deque[0] < j-N:\n                deque.popleft()\n                \n            res = max(res, prefix[j] - prefix[deque[0]])\n            \n            while deque and prefix[j] <= prefix[deque[-1]]:\n                deque.pop()\n            \n            deque.append(j)\n            \n        return res", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        total, maxSum, curMax, minSum, curMin = 0, A[0], 0, A[0], 0\n        for a in A:\n            curMax = max(curMax + a, a)\n            maxSum = max(maxSum, curMax)\n            curMin = min(curMin + a, a)\n            minSum = min(minSum, curMin)\n            total += a\n        return max(maxSum, total - minSum) if maxSum > 0 else maxSum\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        maxHere = currentMax = float('-inf')\n        minHere = currentMin = float('inf')\n        for i in A:\n            currentMax = i + max(0, currentMax)\n            currentMin = i + min(0, currentMin)\n            maxHere = max(currentMax, maxHere)\n            minHere = min(currentMin, minHere)\n        print(maxHere, minHere)\n        if minHere == sum(A) and 0 not in A:\n            return maxHere\n        return max(maxHere, sum(A)-minHere)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        # find linear max subarray sum\n        maxSum = A[0]\n        curMaxSum = A[0]\n        for i in range(1, len(A)):\n            curMaxSum = max(curMaxSum + A[i], A[i])\n            maxSum = max(maxSum, curMaxSum)\n        \n        # find linear min subarray sum\n        minSum = A[0]\n        curMinSum = A[0]\n        for i in range(1, len(A)):\n            curMinSum = min(curMinSum + A[i], A[i])\n            minSum = min(minSum, curMinSum)\n        \n        # edge case: all values of A are negative\n        if maxSum < 0:\n            return maxSum\n        \n        # compare (linear max) with (total sum - linear min)\n        return max(maxSum, sum(A)-minSum)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        l = len(A)\n        A = A+A\n        q = collections.deque([(0, -1)])\n        cur = 0\n        ret = float('-inf')\n        for i, num in enumerate(A):\n            cur += num\n            ret = max(ret, cur-q[0][0])\n            if q[0][1]+l == i:\n                q.popleft()\n            while len(q) > 0 and q[-1][0] > cur:\n                q.pop()\n            q.append((cur, i))\n        return ret\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        def kadane(aa):\n            ans= cur =float('-inf') \n            for v in aa:\n                cur = max(cur, 0) + v\n                ans = max(ans, cur)\n            return ans    \n        S = sum(A)\n        ans1 = kadane(A)\n        ans2 = S + kadane(-A[i] for i in range(1, len(A)))\n        ans3 = S + kadane(-A[i] for i in range(len(A) - 1))\n        return max(ans1, ans2, ans3) \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        L = len(A)\n        cum_sum = [0]*L\n        cum_max = [0]*L\n        cum_max_final = [0]*L\n        sum_ = 0\n        for i in range(L):\n            sum_ += A[i]\n            cum_sum[i] = sum_\n            if i==0:\n                cum_max[i] = A[i]\n            else:\n                if cum_max[i-1]>0:\n                    cum_max[i] = cum_max[i-1] + A[i]\n                else:\n                    cum_max[i] = A[i]\n        m = A[L-1]\n        for i in range(L-1,-1,-1):\n            if i!=0:\n                cur = cum_sum[L-1] - cum_sum[i-1]\n                cum_max_final[i] = max(cur,m)\n                m = max(m,cur)\n                \n            else:\n                cum_max_final[i] = max(m,cum_sum[L-1])\n                \n        res = -float('inf')\n        for i in range(L):\n            if i!=L-1:\n                cur = cum_max[i]\n                cur = max(cur,cum_sum[i]+cum_max_final[i+1])\n                res = max(res,cur)\n            else:\n                res = max(res,cum_max[L-1])\n        return res\n            \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        pre = 0\n        rtn = float('-inf')\n        if max(A) <= 0:\n            return max(A)\n        \n        for i in range(len(A)):\n            pre += A[i]\n            if pre <= 0:\n                pre = 0\n            else:\n                rtn = max(rtn, pre)\n        left_sum = [0]*(len(A)+1)\n        left = 0\n        for i in range(len(A)):\n            left += A[i]\n            left_sum[i+1] = max(left, left_sum[i])\n        right = 0\n        for j in reversed(range(len(A))):\n            right += A[j]\n            rtn = max(rtn, right+left_sum[j])\n        return rtn", "class Solution:\n    def maxSubarraySumCircular(self, A):\n        # compute pre(k)\n        # maximum continuous subarray that ends at end of A and starts after k\n        pre = [0 for i in range(len(A))]\n\n        pre_continuous = [0 for i in range(len(A))]\n        pre_earlystop = [0 for i in range(len(A))]\n\n        for i in range(len(A) - 2, -1, -1):\n            pre_continuous[i] = pre_continuous[i + 1] + A[i + 1]\n            pre_earlystop[i] = max(pre_earlystop[i + 1], pre_continuous[i])\n            pre[i] = max(pre_continuous[i], pre_earlystop[i])\n\n        # compute regular dp\n        dp = [0 for i in range(len(A))]\n        dp[0] = A[0]\n\n        running_sum = A[0]\n        best = dp[0] + pre[0]\n        \n        for i in range(1, len(A)):\n            dp[i] = max(dp[i - 1] + A[i], A[i])\n\n            best = max(best, dp[i], running_sum + pre[i])\n            running_sum += A[i]\n\n        return best", "from collections import deque\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        B = A + A\n        N = len(A)\n        queue = deque([0])\n        pre_sum = [0]\n        for i in range(len(B)):\n            pre_sum.append(pre_sum[-1] + B[i])\n        ans = A[0]\n        for j in range(1, len(pre_sum)):\n            if j - queue[0] > N:\n                queue.popleft()\n            ans = max(ans, pre_sum[j] - pre_sum[queue[0]])\n            while queue and pre_sum[queue[-1]] >= pre_sum[j]:\n                queue.pop()\n            queue.append(j)\n        return ans \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        negateA=[-x for x in A]\n        print(negateA)\n        cursum=0\n        res=float('-inf')\n        for v in negateA:\n            cursum=max(v,cursum+v)\n            res=max(res,cursum)\n        \n        print(res)\n        res1=float('-inf')\n        cursum=0\n        for v in A:\n            cursum=max(v,cursum+v)\n            res1=max(res1,cursum)\n        print(res1)\n        return max(res1,sum(A)+(res)) if res1>0 else res1\n#         min maxsum\n#         0,6\n        \n        # total, maxSum, curMax, minSum, curMin = 0, A[0], 0, A[0], 0\n        # for a in A:\n        #     curMax = max(curMax + a, a)\n        #     maxSum = max(maxSum, curMax)\n        #     curMin = min(curMin + a, a)\n        #     minSum = min(minSum, curMin)\n        #     total += a\n        # print(maxSum, total , minSum)\n        # return max(maxSum, total - minSum) if maxSum > 0 else maxSum\n#1 -2 3 -2\n#  [-1,2,-3,2]\n# cu -1  2  -1 1\n# re. -1  2  2 2\n\n# sum-min(subARR)\n# SUM+MAX()\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        # there are two cases, one, includes end points, two, not include end points\n        ans = float('-inf')\n        csum = 0\n        for x in A:\n            csum = max(x,csum+x)\n            ans = max(ans,csum)\n            \n        mi = float('inf')\n        csum = 0 # notice that it can be zero\n        for i in range(1,len(A)-1):\n            csum = min(csum+A[i],A[i])\n            mi = min(mi,csum)\n\n        ans = max(ans, sum(A)-mi)\n        return ans", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        N = len(A)\n        P = [0]\n        for _ in range(2):\n            for v in A:\n                P.append(P[-1] + v)\n        \n        ans = A[0]\n        q = collections.deque([0])\n        for j in range(1, len(P)):\n            while q and  j - q[0]  > N:\n                q.popleft()\n            \n            ans = max(ans, P[j] - P[q[0]])\n            \n            while q and P[q[-1]] >= P[j]:\n                q.pop()\n            q.append(j)     \n            \n        return ans\n", "from collections import deque\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        arr = A + A\n        arr = arr[:-1]\n        \n        prefix = [0] * len(arr)\n        prefix[0] = arr[0]\n        for i in range(1, len(prefix)):\n            prefix[i] = prefix[i-1] + arr[i]\n        \n        prefix.insert(0, 0)\n        #monotonic increasing array\n        dq = deque([0])\n        res = -float('inf')\n        for i in range(1, len(prefix)):\n\n            while dq and i - dq[0] > len(A):\n                dq.popleft()\n            if dq:\n                res = max(res, prefix[i] - prefix[dq[0]])\n            \n            while dq and prefix[i] <= prefix[dq[-1]]:\n                dq.pop()\n            dq.append(i)\n            \n        return res\n                \n", "class Solution:\n    def maxSubarraySumCircular(self, A):\n        total, maxSum, curMax, minSum, curMin = 0, A[0], 0, A[0], 0\n        for a in A:\n            curMax = max(curMax + a, a)\n            maxSum = max(maxSum, curMax)\n            curMin = min(curMin + a, a)\n            minSum = min(minSum, curMin)\n            total += a\n        return max(maxSum, total - minSum) if maxSum > 0 else maxSum", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        # case 1, kadane's algo\n        totalSum = sum(A)\n        curr = A[0]\n        maxSum = A[0]\n        \n        for i in range(1, len(A)):\n            \n            curr = max(A[i] + curr, A[i])\n            maxSum = max(maxSum, curr)\n        \n        # case 2, wrapping\n        \n        curr = A[0]\n        minSum = totalSum\n        \n        for i in range(1, len(A)):\n            curr = min(A[i]+curr, A[i])\n            \n            minSum = min(minSum, curr)\n        \n        if totalSum == minSum:\n            return maxSum\n        return max(totalSum - minSum, maxSum)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)\n        \n        if n == 1:\n            return A[0]\n        \n        pre_sum = 0\n        pre_min_sum = 0\n        pre_max_sum = 0\n        \n        \n        pre_max_sum_i = -1\n        min_sum_left = -1\n        min_sum_right = -1\n        max_sum = float('-inf')\n        min_sum = float('inf')\n        \n        for i, a in enumerate(A):\n            pre_sum += a\n            \n            max_sum = max(max_sum, pre_sum - pre_min_sum)\n            min_sum_tmp = pre_sum - pre_max_sum\n            if min_sum_tmp < min_sum:\n                min_sum = min_sum_tmp\n                min_sum_right = i\n                min_sum_left = pre_max_sum_i + 1\n            \n            pre_min_sum = min(pre_min_sum, pre_sum)\n            if pre_sum > pre_max_sum:\n                pre_max_sum = pre_sum\n                pre_max_sum_i = i\n        \n        total = sum(A)\n        \n        if total == min_sum and min_sum_left == 0 and min_sum_right == n - 1:\n            return max_sum\n        return max(max_sum, total - min_sum)\n        \n                \n            \n        \n        \n        \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        # Main idea: if we iterate over A twice to generate\n        # a prefix array, then we can get subarrays in const\n        # time by checking windows of size j - i <= len(A)\n        \n        # Once we have the prefix array, this problem reduces\n        # to sliding window maximum (except we're looking for\n        # the minimum). With the sliding window minimum, we \n        # can then update the result with \n        # result = max(result, curr_elem - minimum)\n        \n        from collections import deque\n        dq = deque()\n        prefix = [0]\n        N = len(A)\n        \n        for _ in range(2):\n            for elem in A:\n                prefix.append(elem + prefix[-1])\n        \n        result = A[0]\n        for i in range(len(prefix)):\n            if dq and dq[0] < i - N:\n                dq.popleft()\n            if dq:\n                result = max(result, prefix[i] - prefix[dq[0]])\n            while dq and prefix[dq[-1]] > prefix[i]:\n                dq.pop()\n            dq.append(i)\n        return result", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        N = len(A)\n\n        # Compute P[j] = sum(B[:j]) for the fixed array B = A+A\n        P = [0]\n        for _ in range(2):\n            for x in A:\n                P.append(P[-1] + x)\n\n        # Want largest P[j] - P[i] with 1 <= j-i <= N\n        # For each j, want smallest P[i] with i >= j-N\n        ans = A[0]\n        deque = collections.deque([0]) # i's, increasing by P[i]\n        for j in range(1, len(P)):\n            # If the smallest i is too small, remove it.\n            while deque[0] < j-N:\n                deque.popleft()\n\n            # The optimal i is deque[0], for cand. answer P[j] - P[i].\n            ans = max(ans, P[j] - P[deque[0]])\n\n            # Remove any i1's with P[i2] <= P[i1].\n            while deque and P[j] <= P[deque[-1]]:\n                deque.pop()\n\n            deque.append(j)\n\n        return ans\n", "from copy import deepcopy\n\ndef cumsum(A: list) -> list:\n    cum = 0\n    res = []\n    for x in A:\n        cum += x\n        res.append(cum)\n    return res\n\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        # normal kadane's algo\n        opt = deepcopy(A)\n        n = len(A)\n        \n        for i in range(1, n, 1):\n            if opt[i-1] + A[i] > opt[i]:\n                opt[i] = opt[i-1] + A[i]\n        \n        # forward cumsum and backward cumsum\n        forward_cumsum = cumsum(A)\n        \n        back_cumsum = cumsum(A[::-1])\n        tmp = [back_cumsum[0]]\n        for i in range(1, n):\n            tmp.append(max(tmp[i-1], back_cumsum[i]))\n        back_cumsum = tmp\n        \n        # update opt estimates (if needed)\n        for i in range(0, n-1):\n            potential_replacement = forward_cumsum[i] + back_cumsum[(n-2)-i]\n            opt[i] = max(opt[i], potential_replacement)\n        \n        # return max\n        return max(opt)\n        \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        N = len(A)\n\n        # Compute P[j] = sum(B[:j]) for the fixed array B = A+A\n        P = [0]\n        for _ in range(2):\n            for x in A:\n                P.append(P[-1] + x)\n\n        ans = A[0]\n        deque = collections.deque([0])\n        for j in range(1, len(P)):\n            if deque[0] < j-N:\n                deque.popleft()\n\n            # The optimal i is deque[0], for cand. answer P[j] - P[i].\n            ans = max(ans, P[j] - P[deque[0]])\n\n            # Remove any i1's with P[i2] <= P[i1].\n            while deque and P[j] <= P[deque[-1]]:\n                deque.pop()\n\n            deque.append(j)\n\n        return ans", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        max_sums_left = []\n        max_sums_right = collections.deque()\n        sum_up_to_index = []\n        max_sums_index_right = collections.deque()\n        min_sum_right = 0\n        min_sum_left = 0\n        max_sum_right = 0\n        max_sum_left = 0\n        sum_left = 0\n        sum_right = 0\n        ret = -999999999\n        \n        \n        for i in range(len(A)):\n            sum_left += A[i]\n            sum_right += A[-i - 1]\n            sum_up_to_index.append(sum_left)\n            max_sums_left.append(sum_left - min_sum_left)\n            max_sums_right.appendleft(sum_right - min_sum_right)\n            \n\n            if (sum_left < min_sum_left):\n                min_sum_left = sum_left\n\n                \n            if (sum_right > max_sum_right):\n                max_sums_index_right.appendleft((len(A) - i - 1, sum_right, ))\n                max_sum_right = sum_right\n            elif (sum_right < min_sum_right):\n                min_sum_right = sum_right\n            else:    \n                pass\n            \n        sum_left = 0\n \n        \n        for i in range(len(A)):\n            if (len(max_sums_index_right) and i == max_sums_index_right[0][0]):\n                max_sums_index_right.popleft()\n\n            sum_left += A[i]\n            candidates = [max_sums_left[i] + max_sums_right[i] - A[i], sum_right + max_sum_left]\n            sum_right -= A[i]\n            \n            \n            if (sum_left > max_sum_left):\n                max_sum_left = sum_left\n            \n            \n            if (len(max_sums_index_right)):\n                candidates.append(sum_left + max_sums_index_right[0][1])\n                \n            candidate = max(candidates)\n            \n            \n            if (candidate > ret):\n                ret = candidate\n               \n        return ret   ", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)\n        B = A + A\n        pfx = [0]\n        for x in B:\n            pfx.append(pfx[-1] + x)\n        dq = collections.deque()\n        ans = A[0]\n        dq.append(0)\n        #monoqueue dq that contains indices i such that P[i]s are non-decreasing\n        for j in range(1,len(pfx)):\n            if j - dq[0] > n:\n                dq.popleft()\n            \n            ans = max(ans, pfx[j] - pfx[dq[0]])\n            \n            while dq and pfx[dq[-1]] > pfx[j]:\n                dq.pop()\n            \n            dq.append(j)\n        return ans", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        def max_subarray(nums):\n            for i in range(1, len(nums)):\n                if nums[i-1] > 0:\n                    nums[i] += nums[i-1]\n                    \n            return max(nums)\n        \n        max_sum ,cur_sum = max_subarray(A[:]), sum(A)\n        \n        if max_sum < 0:\n            return max_sum\n        final_sum = cur_sum + max_subarray(list(map(lambda x: -x, A)))\n        \n        return max(max_sum, final_sum)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        n = len(A)\n        B = [0]+A+A\n        for i in range(1, len(B)):\n            B[i] += B[i-1]\n        maxv = B[1]\n        \n        stack = deque([0])\n        for end in range(1, len(B)):\n            num = B[end]\n            while stack and num < B[stack[-1]]:\n                stack.pop()\n            stack.append(end)\n            if end-stack[0] == n+1:\n                stack.popleft()\n            maxv = max(num-B[stack[0]], maxv)\n            #print(end, stack, maxv)\n        if all(x<0 for x in A):\n            return max(A)\n        return maxv\n                \n                \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        # edge case: all values of A are negative\n        allNeg = True\n        for i in A:\n            if i > 0:\n                allNeg = False\n        if allNeg:\n            return max(A)\n        \n        # find linear max subarray sum\n        maxSum = A[0]\n        curMaxSum = A[0]\n        for i in range(1, len(A)):\n            curMaxSum = max(curMaxSum + A[i], A[i])\n            maxSum = max(maxSum, curMaxSum)\n        \n        # find linear min subarray sum\n        minSum = A[0]\n        curMinSum = A[0]\n        for i in range(1, len(A)):\n            curMinSum = min(curMinSum + A[i], A[i])\n            minSum = min(minSum, curMinSum)\n        \n        # compare (linear max) with (total sum - linear min)\n        return max(maxSum, sum(A)-minSum)\n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        res = A[0]\n        cur = A[0]\n        \n        for num in A[1:]:\n            cur = num + max(0, cur)\n            res = max(cur, res)\n        \n        presum = []\n        accu = 0\n        for num in A:\n            accu += num\n            presum.append(accu)\n        \n        \n        postsum = [0 for i in range(len(A))]\n        postsum[-1] = A[-1]\n        accu = A[-1]\n        curmax = A[-1]\n        for i in range(len(A) - 2, -1, -1):\n            accu += A[i]\n            curmax = max(curmax, accu)\n            postsum[i] = curmax\n        \n        \n        for i in range(0, len(A) - 2):\n            res = max(presum[i] + postsum[i + 2], res)\n            \n        \n        \n        return res\n            \n", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        '''\n        Case 1. The first is that the subarray take only a middle part, and we know how to find the max subarray sum.\n        Case2. The second is that the subarray take a part of head array and a part of tail array.\n        \n        in case two, you have two sub arrays, one at the front and one at the end. The middle segment actually now is the MIN\n        subarray.\n         The maximum result equals to the total sum minus the minimum subarray sum.\n        '''\n        total=0\n        maxSum=A[0] #case1\n        minSum=A[0] #case2\n        curr_sum=0\n        curr_sum_min=0\n        for val in A:\n            total+=val #calculate total sum\\\\\n            #calculate max sum with kadanes normally for case1, assuming NO WRAP\n            curr_sum=max(val,curr_sum+val)\n            maxSum=max(maxSum,curr_sum)\n            #now calculate the minsum\n            curr_sum_min=min(val,curr_sum_min+val)\n            minSum=min(minSum,curr_sum_min)\n            print(maxSum)\n        wrap_maxSum=total-minSum\n  \n        if maxSum>0:\n            return max(wrap_maxSum,maxSum)\n        else:\n            return maxSum", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        tot = 0\n        mn, mx = float('inf'), float('-inf')\n        curmx, curmn = 0, 0\n        for num in A:\n            curmn = min(curmn + num, num)\n            mn = min(mn, curmn)\n            curmx = max(curmx + num, num)\n            mx = max(mx, curmx)\n            tot += num\n        \n        if tot == mn:\n            return mx\n        return max(mx, tot-mn)", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        def maxSum(gen):\n            res = cur = -float('inf')\n            for n in gen:\n                cur = n + max(0, cur)\n                res = max(res, cur)\n            return res\n        \n        total = sum(A)\n        res1 = maxSum(iter(A))\n        res2 = total + maxSum(-A[i] for i in range(1, len(A))) # min sum of the unwated sub array\n        res3 = total + maxSum(-A[i] for i in range(len(A)-1))\n        return max(res1, res2, res3)", "import heapq\n\nclass Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        N = len(A)\n        best = A[0]\n        \n        heap = [(0, -1)]    \n        current_sum = 0\n        for i in range(2 * N):\n            current_sum += A[i % N]\n            while len(heap) > 0 and i - heap[0][1] > N:\n                heapq.heappop(heap)\n            \n            best = max(best, current_sum - heap[0][0])\n            heapq.heappush(heap, (current_sum, i))\n        \n        return best", "class Solution:\n    def maxSubarraySumCircular(self, A: List[int]) -> int:\n        N = len(A)\n        P = []\n        P.append(0)\n        for _ in range(2):\n            for x in A:\n                P.append(P[-1] + x)\n        \n        ans = A[0]\n        queue = []\n        queue.append(0)\n        \n        for j in range(1, len(P)):\n            if queue[0] < j - N:\n                queue.pop(0)\n            ans = max(ans, P[j] - P[queue[0]])\n            \n            while queue and P[j] <= P[queue[-1]]:\n                queue.pop()\n            queue.append(j)\n        \n        return ans"]
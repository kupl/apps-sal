["import math\nn = int(input())\na=list(map(int,input().split()))\ndp = [0 for x in range(n)]\ndp[0] = a[0]\ndp[1] = a[1]\ndp[2] = a[2]\nfor x in range(3,n):\n    dp[x] = a[x] + min(dp[x-1],dp[x-2],dp[x-3])\n\nprint(min(dp[-3:]))\n", "# cook your dish here\nINT_MAX=1000000000000000000\nn=int(input())\nar=list(map(int,input().split()))\nbr=[0]*1 \nbr.extend(ar)\ndel ar\n\nfor i in range(n-3,0,-1):\n   br[i]=min(br[i+1],br[i+2],br[i+3])+br[i]\n    \nprint(min(br[1:4]))\n", "import sys\ndef time(i, free):\n    if free == 3:\n        return sys.maxsize\n    elif i == n:\n        return 0\n    elif mt[i][free] != -1:\n        return mt[i][free]\n    else:\n        mt[i][free] =  min(minutes[i] + time(i+1, 0), time(i+1, free+1))\n        return mt[i][free]\n \nn = int(input().strip())\nminutes = list(map(int, input().strip().split()))\n \nsys.setrecursionlimit(3*n)\n \nmt = [[-1 for i in range(3)] for j in range(n)]\n \nprint(time(0, 0))", "# cook your dish here\nn=int(input())\narr=[int(x) for x in input().split()]\nif n<3:\n    ans=min(arr)\n    print(ans)\nelse:\n    dp=[None for x in range(n)]\n    dp[0]=arr[0];dp[1]=arr[1];dp[2]=arr[2]\n    for i in range(3,n):\n        dp[i]=min(dp[i-1],dp[i-2],dp[i-3])+arr[i]\n    print(min(dp[-1],dp[-2],dp[-3]))\n", "# cook your dish here\nn=int(input())\narr=list(map(int,input().split()))\ni=0\nif(n<3):\n    print(0)\n    return\ndp=[n for n in arr]\nfor i in range(3,n):\n    dp[i]=arr[i]+min(dp[i-1],dp[i-2],dp[i-3])\nprint(min(dp[-1],dp[-2],dp[-3]))", "# cook your dish here\nimport math\nn = int(input())\na = [int(i) for i in input().split()]\ndp = [0 for i in range(n)]\ndp[0] = a[0]\ndp[1] = a[1]\ndp[2] = a[2]\nfor i in range(3,n):\n    dp[i] = a[i] + min(dp[i-1],dp[i-2],dp[i-3])\nans = min(dp[-3:])\nprint(ans)\n", "# cook your dish here\nn = int(input())\nnums = list(map(int, input().split()))\nif n < 3:\n    print(0)\nelse:\n    for i in range(3, n):\n        nums[i] = nums[i] + min(nums[i-1], nums[i-2], nums[i-3])\n    print(min(nums[-1], nums[-2], nums[-3]))\n", "# cook your dish here\nn = int(input())\nnums = list(map(int, input().split()))\nif n < 3:\n    print(0)\nelse:\n    for i in range(3, n):\n        nums[i] = nums[i] + min(nums[i-1], nums[i-2], nums[i-3])\n    print(min(nums[-1], nums[-2], nums[-3]))\n", "n = int(input())\nnums = list(map(int, input().split()))\nif n < 3:\n    print(0)\nelse:\n    for i in range(3, n):\n        nums[i] = nums[i] + min(nums[i-1], nums[i-2], nums[i-3])\n    print(min(nums[-1], nums[-2], nums[-3]))", "# cook your dish here\nn = int(input())\na = list(map(int,input().split()))\nnode = [0]*n\nif(n == 1):\n    print(a[0])\nelif(n == 2):\n    print(min(a[0],a[1]))\nelif(n == 3):\n    print(min(a[0],a[1],a[2]))\nelse:\n    node[n-1] = a[n-1]\n    node[n-2] = a[n-2]\n    node[n-3] = a[n-3]\n    for i in range(n-4,-1,-1):\n        node[i] = min(node[i+1],node[i+2],node[i+3]) + a[i]\n    \n    print(min(node[0],node[1],node[2]))\n    \n", "n = int(input())\r\nsupw = list(map(int, input().split()))\r\nif len(supw) in [1,2]:\r\n    print(0)\r\nelif len(supw) == 3:\r\n    print(min(supw[0], min(supw[1], supw[2])))\r\nelse:\r\n    dp = list()\r\n    for i in range(1, len(supw)+1):\r\n        dp.append(0)\r\n    dp[0] = supw[0]\r\n    dp[1] = supw[1]\r\n    dp[2] = supw[2]\r\n    for i in range(3, len(supw)):\r\n        dp[i] = supw[i] + min(dp[i-1], min(dp[i-2], dp[i-3]))\r\n\r\n    print(min(dp[n-1], min(dp[n-2], dp[n-3])))\r\n", "# ZOC14002\ndp = [-1] * int(1e6)\n\ndef solve(nums, n) : \n    \n    if n < 2 : return 0\n    \n    if dp[n] != - 1 : return dp[n]\n    \n    dp[n] = min( nums[n] + solve(nums, n - 1),\n                 nums[n - 1] + solve(nums, n - 2),\n                 nums[n - 2] + solve(nums, n - 3)\n               )\n               \n    return dp[n]\n\n        \ndef main(): \n    from sys import stdin, stdout, setrecursionlimit\n    setrecursionlimit(int(5e5))\n    N = int(input())\n    hours = list(map(int, input().split()))\n    solution = solve(hours, N - 1)\n    print(solution)\n\t\n\nmain()\n    \n", "# ZOC14002\ndp = [-1] * int(1e6)\n\ndef solve(nums, n) : \n    \n    if n < 2 : return 0\n    \n    if dp[n] != - 1 : return dp[n]\n    \n    dp[n] = min( nums[n] + solve(nums, n - 1),\n                 nums[n - 1] + solve(nums, n - 2),\n                 nums[n - 2] + solve(nums, n - 3)\n               )\n               \n    return dp[n]\n\n        \ndef main(): \n    from sys import stdin, stdout, setrecursionlimit\n    setrecursionlimit(int(5e5))\n    N = int(input())\n    hours = list(map(int, input().split()))\n    solution = solve(hours, N - 1)\n    print(solution)\n\t\n\nmain()\n    \n", "# cook your dish here\n\nN = int(input().strip())\nactivity_choices = [int(i) for i in input().strip().split(\" \")]\nstored_values = activity_choices[:3]\nfor i in range(3, N):\n    stored_values.append(activity_choices[i] + min(stored_values[-1], stored_values[-2], stored_values[-3]))\nprint(min(stored_values[-1], stored_values[-2], stored_values[-3]))\n\n", "# cook your dish here\nimport sys\ninput=sys.stdin.readline\nn=int(input())\nl=input().split()\nli=[int(i) for i in l]\ndp=[0 for i in range(n)]\nif(n<=3):\n    print(0)\n    return\ndp[0]=li[0]\ndp[1]=li[1]\ndp[2]=li[2]\nfor i in range(3,n):\n    dp[i]=li[i]+min(dp[i-1],dp[i-2],dp[i-3])\nprint(min(dp[n-1],dp[n-2],dp[n-3]))\n", "dp = [-1] * int(1e6)\n\ndef solve(nums, n) : \n    \n    if n < 2 : return 0\n    \n    if dp[n] != - 1 : return dp[n]\n    \n    dp[n] = min( nums[n] + solve(nums, n - 1),\n                 nums[n - 1] + solve(nums, n - 2),\n                 nums[n - 2] + solve(nums, n - 3)\n               )\n               \n    return dp[n]\n\n        \ndef main(): \n    from sys import stdin, stdout, setrecursionlimit\n    setrecursionlimit(int(5e5))\n    N = int(input())\n    hours = list(map(int, input().split()))\n    solution = solve(hours, N - 1)\n    print(solution)\n\t\n\nmain()\n    \n", "dp = [-1] * int(1e6)\n\ndef solve(nums, n) : \n    \n    if n < 2 : return 0\n    \n    if dp[n] != - 1 : return dp[n]\n    \n    dp[n] = min( nums[n] + solve(nums, n - 1),\n                 nums[n - 1] + solve(nums, n - 2),\n                 nums[n - 2] + solve(nums, n - 3)\n               )\n               \n    return dp[n]\n\n        \ndef main(): \n    from sys import stdin, stdout, setrecursionlimit\n    setrecursionlimit(int(5e5))\n    N = int(input())\n    hours = list(map(int, input().split()))\n    solution = solve(hours, N - 1)\n    print(solution)\n\t\n\nmain()\n    \n", "import math\r\nn = int(input())\r\na = [int(i) for i in input().split()]\r\ndp = [0 for i in range(n)]\r\ndp[0] = a[0]\r\ndp[1] = a[1]\r\ndp[2] = a[2]\r\nfor i in range(3,n):\r\n    dp[i] = a[i] + min(dp[i-1],dp[i-2],dp[i-3])\r\nans = min(dp[-3:])\r\nprint(ans)", "import sys\n# import math as mt\n# from collections import Counter\n# from itertools import permutations\n# from functools import reduce\n# from heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace\n\ndef get_inpt(): return sys.stdin.readline().strip()\ndef get_int(): return int(sys.stdin.readline().strip())\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\n\n# sys.setrecursionlimit(10**7)\n# INF = float('inf')\n# MOD1, MOD2 = 10**9+7, 998244353\n\nn = get_int()\narr = get_array()\n\ndp = [0 for _ in range(n)]\n\ndp[-1] = arr[-1]\ndp[-2] = arr[-2]\n# dp[-3] = min(arr[-1], arr[-2], arr[-3])\ndp[-3] = arr[-3]\n\nfor i in range(n-4, -1, -1):\n   \n   dp[i] = arr[i] + min(dp[i+1], dp[i+2], dp[i+3])\n   \nprint(min(dp[0], dp[1], dp[2]))", "# cook your dish here\nn=int(input())\narray=list(map(int, input().split()))\nfor i in range(3,n):\n    array[i]+=min([array[i-1],array[i-2],array[i-3]])\nprint(min([array[-1],array[-2],array[-3]]))", "from sys import stdin, stdout\nimport math,sys,heapq\nfrom itertools import permutations, combinations\nfrom collections import defaultdict,deque,OrderedDict\nfrom os import path\nimport random\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\nif (path.exists('input.txt')): \n    #------------------Sublime--------------------------------------#\n    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n    def I():return (int(input()))\n    def In():return(map(int,input().split()))\nelse:\n    #------------------PYPY FAst I/o--------------------------------#\n    def I():return (int(stdin.readline()))\n    def In():return(map(int,stdin.readline().split()))\n#sys.setrecursionlimit(1500)\ndef dict(a):\n    d={} \n    for x in a:\n        if d.get(x,-1)!=-1:\n            d[x]+=1\n        else:\n            d[x]=1\n    return d\ndef find_gt(a, x):\n    'Find leftmost value greater than x'\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:            \n        return -1\n\ndef main():\n    try:\n        n=I()\n        l=list(In())\n        dp=[0 for x in range(n)]\n        for x in range(n):\n            if x<3:\n                dp[x]=l[x]\n            else:\n                dp[x]=min(dp[x-1],dp[x-2],dp[x-3])+l[x]\n        print(min(dp[-1],dp[-2],dp[-3]))\n    except:\n        pass\n        \nM = 998244353\nP = 1000000007\n \ndef __starting_point():\n    #for _ in range(I()):main()\n    for _ in range(1):main()\n__starting_point()", "n = int(input())\r\na = list(map(int, input().split()))\r\nfor i in reversed(range(0,n-3)):\r\n    a[i] += min(a[i+1],a[i+2],a[i+3])\r\nprint(min(a[:3]))", "from sys import stdin,setrecursionlimit\r\nsetrecursionlimit(10**6)\r\ndef fn(pos):\r\n    if pos>=n:return 0\r\n    if pos in dp:return dp[pos]\r\n    dp[pos]=a[pos]+min(fn(pos+1),fn(pos+2),fn(pos+3))\r\n    return dp[pos]\r\nfor _ in range(1):#int(stdin.readline())):\r\n    n=int(stdin.readline())\r\n    a=list(map(int,stdin.readline().split()))\r\n    dp={}\r\n    if n<=2:\r\n        print(min(a))\r\n        continue\r\n    print(min(fn(0),fn(1),fn(2)))", "from sys import stdin,stdout\r\ndef fn(pos):\r\n    if pos>=n:return 0\r\n    if pos in dp:return dp[pos]\r\n    op1=op2=op3=float('inf')\r\n    op1=a[pos]+fn(pos+3)\r\n    if pos+1<n:op2=a[pos+1]+fn(pos+3)\r\n    if pos+2<n:op3=a[pos+2]+fn(pos+3)\r\n    dp[pos]=min(op1,op2,op3)\r\n    return dp[pos]\r\nfor _ in range(1):#int(stdin.readline())):\r\n    n=int(stdin.readline())\r\n    a=list(map(int,stdin.readline().split()))\r\n    # print(dp)\r\n    dp=[0]*n\r\n    dp[0]=a[0]\r\n    if n==1:\r\n        print(dp[0])\r\n        continue\r\n    dp[1]=a[1]\r\n    if n==2:\r\n        print(min(dp))\r\n        continue\r\n    dp[2]=a[2]\r\n    if n==3:\r\n        print(min(dp))\r\n        continue\r\n    for i in range(3,n):\r\n        dp[i]=min(dp[i-3],dp[i-1],dp[i-2])+a[i]\r\n    print(min(dp[-1],dp[-2],dp[-3]))"]
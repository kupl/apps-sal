["t=int(input())\n\nfor _ in range(t):\n n,q=map(int,input().split())\n s=input()\n l=[0]*(n-1)\n for i in range(n-2):\n  a,b,c=s[i],s[i+1],s[i+2]\n  if len(set([a,b,c]))<3:\n   l[i]=l[i-1]+1\n  else:\n   l[i]=l[i-1]\n   \n for i in range(q):\n  left,right=map(int,input().split())\n  left-=1\n  right-=1\n  if right-left+1 <3:\n   print('NO')\n   continue\n  if (l[right-2]-l[left-1])>0:\n   print('YES')\n  else:\n   print('NO')", "# cook your dish here\nfrom bisect import bisect_left\nfor _ in range(int(input())):\n n,q=map(int,input().split())\n s=input()\n l=[]\n for i in range(n-2):\n  a,b,c=s[i],s[i+1],s[i+2]\n  if len(set([a,b,c]))<3:\n   l.append(i)\n for i in range(q):\n  left,right=map(int,input().split())\n  left-=1\n  right-=1\n  if right-left+1 <3:\n   print('NO')\n   continue\n  p1 = bisect_left(l,left)\n  if p1!=len(l) and l[p1]<=right-2:\n   print('YES')\n  else:\n   print('NO')", "def precumpute(s, n):\n a = [0 for i in range(n)]\n b = [0 for i in range(n)]\n if n < 3:\n  return b\n for i in range(n - 3, -1, -1):\n  if s[i] == s[i + 1] or s[i + 1] == s[i + 2] or s[i] == s[i + 2]:\n   a[i] = 1\n prev = -1\n for i in range(n - 1, -1, -1):\n  if a[i] == 1:\n   prev = i\n  b[i] = prev\n return b\n\n\ndef solve(b, n, l, r):\n if n < 3:\n  print(\"NO\")\n  return\n x = b[l]\n if x>=l and x <= r-2:\n  print(\"YES\")\n else:\n  print(\"NO\")\n\n\ndef read():\n t = int(input())\n for j in range(t):\n  n, q = list(map(int, input().strip().split()))\n  s = input().strip()\n  b = precumpute(s, n)\n  for i in range(q):\n   l, r = list(map(int, input().strip().split()))\n   solve(b, n, l-1, r-1)\n\n\nread()\n", "# cook your dish here\ndef precumpute(s, n):\n a = [0 for i in range(n)]\n b = [0 for i in range(n)]\n if n < 3:\n  return b\n for i in range(n - 3, -1, -1):\n  if s[i] == s[i + 1] or s[i + 1] == s[i + 2] or s[i] == s[i + 2]:\n   a[i] = 1\n # print(a)\n prev = -1\n for i in range(n - 1, -1, -1):\n  if a[i] == 1:\n   prev = i\n  b[i] = prev\n return b\n\n\ndef solve(b, n, l, r):\n if n < 3:\n  print(\"NO\")\n  return\n x = b[l]\n if x>=l and x <= r-2:\n  print(\"YES\")\n else:\n  print(\"NO\")\n\n\ndef read():\n t = int(input())\n for j in range(t):\n  n, q = list(map(int, input().strip().split()))\n  s = input().strip()\n  b = precumpute(s, n)\n  # print(b)\n  for i in range(q):\n   l, r = list(map(int, input().strip().split()))\n   solve(b, n, l-1, r-1)\n\n\nread()\n", "def isvalid(s):\n if(s[0]==s[1] or s[1]==s[2] or s[0]==s[2]):\n  return 1\n return 0\nt=int(input())\nfor you in range(t):\n l=input().split()\n n=int(l[0])\n q=int(l[1])\n s=input()\n count=[0 for i in range(n-2)]\n fre=0\n for i in range(n-2):\n\n  if(isvalid(s[i:i+3])):\n   fre+=1\n  count[i]=fre\n\n for i in range(q):\n  l=input().split()\n  L=int(l[0])\n  R=int(l[1])\n  if(R-L+1<3):\n   print(\"NO\")\n  else:\n   if(L==1):\n    if(count[R-3]>0):\n     print(\"YES\")\n    else:\n     print(\"NO\")\n   else:\n    if(count[R-3]-count[L-2]>0):\n     print(\"YES\")\n    else:\n     print(\"NO\")", "# cook your dish here\nT = int(input())\nfor _ in range(T):\n N,Q = [int(b) for b in input().split()]\n S = input()\n b = [0,0]\n l = 0\n for i in range(len(S)-2):\n  a = S[i:i+3]\n  if(a[0]==a[1] or a[0]==a[2] or a[1]==a[2]):\n   l+=1 \n  b.append(l)\n # print(b)\n for i in range(Q):\n  L,R = [int(b) for b in input().split()]\n  if(R-L<2):\n   print(\"NO\")\n   continue\n  if(b[R-1]-b[L]>0):\n   print(\"YES\")\n  else:\n   print(\"NO\")", "# cook your dish here\nimport sys\nfrom math import ceil,floor\nimport bisect\n\nRI = lambda : [int(x) for x in sys.stdin.readline().split()]\nrw = lambda : sys.stdin.readline().strip()\n\nfor _ in range(int(input())):\n n,q = RI()\n st = input()\n bi = []\n for i in range(len(st)-2):\n  if st[i] == st[i+1] or st[i] == st[i+2] or st[i+1] == st[i+2]:\n   bi.append(i)\n # print(bi)\n for qq in range(q):\n  a,b = RI()\n  a-=1\n  b-=1\n  pos = bisect.bisect_right(bi,a-1)\n  if pos == len(bi) or bi[pos] + 2 > b:\n   print(\"NO\")\n  else:\n   print(\"YES\")\n", "def compute_rich_substr(s):\n rich = [0 for _ in range(len(s)+1)]\n\n for i in range(len(s) - 2):\n  if (s[i] == s[i+1]) or (s[i] == s[i+2]) or (s[i+1] == s[i+2]):\n   rich[i+1] = rich[i] + 1\n  else:\n   rich[i+1] = rich[i]\n\n rich[len(s) - 1] = rich[len(s)] = rich[len(s) - 2]\n return rich\n\n\nt = int(input())\n\nfor _ in range(t):\n n, q = list(map(int, input().strip().split()))\n s = input()\n\n rich = compute_rich_substr(s)\n\n for _ in range(q):\n  l, r = list(map(int, input().strip().split()))\n\n  if r - l + 1 < 3:\n   print(\"NO\")\n  elif rich[r - 2] - rich[l - 1] > 0:\n   print(\"YES\")\n  else:\n   print(\"NO\")\n", "for _ in range(int(input())):\n N,Q=map(int,input().split())\n S=input()\n Z=[0]*N\n LC=0\n for I in range(2,N):\n  if S[I-2]==S[I-1] or S[I-2]==S[I] or S[I-1]==S[I]:\n   LC+=1\n  Z[I]=LC\n for I in range(Q):\n  L,R=map(int,input().split())\n  F=0\n  if R-L<2:\n   print('NO')\n  else:\n   if Z[R-1]==Z[L]:\n    print('NO')\n   else:\n    print('YES')", "for _ in range(int(input())):\n N,Q=map(int,input().split())\n S=input()\n Z=[0 for x in range(N)]\n LC=0\n for I in range(2,N):\n  if S[I-2]==S[I-1] or S[I-2]==S[I] or S[I-1]==S[I]:\n   LC+=1\n  Z[I]=LC\n for I in range(Q):\n  L,R=map(int,input().split())\n  F=0\n  if R-L<2:\n   print('NO')\n  else:\n   if Z[R-1]==Z[L]:\n    print('NO')\n   else:\n    print('YES')", "for _ in range(int(input())):\n N,Q=map(int,input().split())\n S=input()\n Z=[0]*N\n LC=0\n for I in range(2,N):\n  if S[I-2]==S[I-1] or S[I-2]==S[I] or S[I-1]==S[I]:\n   LC+=1\n  Z[I]=LC\n for I in range(Q):\n  L,R=map(int, input().split())\n  F=0\n  if R-L<2:\n   print('NO')\n  else:\n   if Z[R-1]==Z[L]:\n    print('NO')\n   else:\n    print('YES')", "for _ in range(int(input())):\n N, Q = map(int, input().split())\n S = input()\n Z = [0]*N\n LC = 0\n for I in range(2, N):\n  if S[I-2] == S[I-1] or S[I-2]==S[I] or S[I-1]==S[I]:\n   LC+=1\n  Z[I] = LC\n for I in range(Q):\n  L, R = map(int, input().split())\n  F = 0\n  if R - L < 2:\n   print('NO')\n  else:\n   if Z[R-1] == Z[L]:\n    print('NO')\n   else:\n    print('YES')", "t=int(input())\nwhile t>0:\n x,q=input().split()\n x=int(x)\n q=int(q)\n s=input()\n list=[]\n list.append(0)\n list.append(0)\n #list.append(0)\n sum=0\n ptr=0\n for i in s:\n  # print(i)\n  if(ptr+2>(len(s)-1)):\n   break\n  else:\n   a=s[ptr]\n   b=s[ptr+1]\n   c=s[ptr+2]\n   if ((a==b)|(b==c)|(a==c)):\n    sum+=1\n   list.append(sum) \n \n   ptr+=1 \n #print(list)            \n while q>0:\n  l,r=input().split()\n  l=int(l)\n  r=int(r)\n  if(r-l)<2:\n   print(\"NO\")\n  else:\n   res=list[r-1]-list[l]\n   if res>0:\n    print(\"YES\")\n   else:\n    print(\"NO\")\n  q-=1\n t-=1 \n", "t=int(input())\nfor _ in range(t):\n n,m=list(map(int,input().split()))\n s=input()\n if n<3:\n  for i in range(m):\n   a,b=list(map(int,input().split()))\n   print('NO')\n else:\n  k=[s[0],s[1],s[2]]\n  if k[0]==k[1] or k[1]==k[2] or k[0]==k[2]:\n   c=1\n  else:\n   c=0\n  ans=[0,c]\n  for i in range(3,n):\n   del(k[0])\n   k.append(s[i])\n   if k[0]==k[1] or k[1]==k[2] or k[0]==k[2]:\n    c+=1\n   ans.append(c)\n  for i in range(m):\n   a,b=list(map(int,input().split()))\n   if b-a<2:\n    print('NO')\n    continue\n   b-=2\n   a-=1\n   if ans[b]-ans[a]==0:\n    print('NO')\n   else:\n    print('YES')\n   \n\n", "from bisect import bisect_left as bl\n\nt=int(input())\nfor i in range(t):\n n,q=map(int,input().split())\n s=input()\n\n c=[]\n for i in range(len(s)-2):\n  if s[i]==s[i+1] or s[i+1]==s[i+2] or s[i]==s[i+2]:\n    c.append(i+1)\n\n for i in range(q):\n  l,r=map(int,input().split())\n  x=bl(c,l)\n  if len(c)==0 or (r-l)<2 or x==len(c):\n   print(\"NO\")\n  else:\n   st=c[x]\n   if st+2<=r:\n    print(\"YES\")\n   else:\n    print(\"NO\")", "for t in range(int(input())):\n n,q=map(int,input().split())\n s=input()\n index=[-1]*n\n temp=-1\n for i in range(n-2):\n  if((s[i]==s[i+1]) or (s[i]==s[i+2]) or(s[i+2]==s[i+1])):\n   temp=i\n  index[i+2]=temp\n for Q in range(q):\n  l,r=map(int,input().split())\n  if(index[r-1]>=l-1):\n    print(\"YES\")\n  else:\n   print(\"NO\")", "\n\n\nT = int(input())\nfor test in range(T):\n N, Q = [int(v) for v in input().split()]\n S = input()\n start_points = [len(set(S[i:i+3])) < 3 for i in range(N-2)]\n if N < 3:\n  count = []\n else:\n  counts = [int(start_points[0])]+[0]*(N-3)\n  for i in range(1,N-2):\n   counts[i] = counts[i-1]+start_points[i]\n # print(\"counts = \"+str(counts))\n for query in range(Q):\n  L, R = [int(v) for v in input().split()]\n  if L+2 > R:\n   print(\"NO\")\n   continue\n  if L == 1:\n   left = 0\n  else:\n   left = counts[L-2]\n  right = counts[R-3]\n  # print(\"query = \"+str((L,R))+\" left, right = \"+str((left,right)))\n  if left < right:\n   print(\"YES\")\n  else:\n   print(\"NO\")\n", "from itertools import accumulate\nfrom collections import Counter \n\n\ndef is_dominant(ss):\n wc=Counter(ss)\n for i in wc.values():\n  if( i > 1 ):\n   return True\n return False\n\nt=int(input())\nfor _ in range(t):\n n,q = map(int,input().split(\" \"))\n s=input()\n p = []\n if (n>2):\n  for i in range(n-2):\n   ss=s[i:i+3]\n   if is_dominant(ss):\n    val=1\n   else:\n    val=0\n   p.append(val)\n  p1=list(accumulate(p))\n for i in range(q):\n  l,r=map(int,input().split(\" \"))\n  len=r-(l-1)\n  if (n<3 or len<3):\n   ans=\"NO\"\n  else:\n   sum=p1[r-3]\n   if (l>1):\n    sum-=p1[l-2]\n   if (sum>0):\n    ans=\"YES\"\n   else:\n    ans=\"NO\"\n  print(ans)", "t=int(input())\nfor _ in range(t):\n n,q=map(int,input().split())\n s=input()\n dp=[0]*(n+1)\n for i in range(n-2):\n  p=s[i:i+3]\n  if p.count(p[0])>=2 or p.count(p[1])>=2:\n   dp[i+1]=dp[i]+1\n  else:\n   dp[i+1]=dp[i]\n for _ in range(q):\n  l,r=map(int,input().split())\n  if n<3 or (r-l)<2:\n   print(\"NO\")\n   continue\n  if dp[r-2]-dp[l-1]>0:\n   print(\"YES\")\n  else:\n   print(\"NO\")", "# from collections import Counter\n# class Node(object):\n#     def __init__(self, start, end):\n#         self.start = start\n#         self.end = end\n#         self.rich = None\n#         self.left = None\n#         self.right = None\n\n# class SegmentTree(object):\n#     def __init__(self):\n#         self.root = None\n \n#     def addToTree(self, l, r, string):\n#         node = Node(l,r)\n\n#         if r == len(string) - 1:\n#             self.root = Node(l,r)\n#             node = self.root\n  \n#         if r - l < 3:\n#             node.rich = False\n#             return node\n#         else:\n#             m = int((l+r)/2)\n#             left, right = self.addToTree(l, m, string), self.addToTree(m+1, r, \u00a0\u00a0\u00a0\u00a0string)\n#             node.weight = any()\n#             node.left = left\n#             node.right = right\n#             return node\n  \n# T = int(input())        \n# for _ in range(T):\n#     N, Q = map(int,input().split())\n#     string = input()\n#     ans = 1\n#     for __ in range(Q):\n#         L, R = map(int, input().split())\n#         if R-L >= 2:\n#             L -= 1\n#             sub_str = string[L:R]\n#             cnt = Counter(sub_str)\n#             for value in cnt.values():\n#                 if value > 2:\n#                     ans = 0\n#                     print('yes')\n#                     break\n#         else:\n#             ans = 0\n#             print('no')\n\n#         if ans:\n#             print('no')\n\nt=int(input())\nfor _ in range(t):\n n,q=map(int,input().split())\n s=input()\n dp=[0]*(n+1)\n for i in range(n-2):\n  p=s[i:i+3]\n  if p.count(p[0])>=2 or p.count(p[1])>=2:\n   dp[i+1]=dp[i]+1\n  else:\n   dp[i+1]=dp[i]\n for _ in range(q):\n  l,r=map(int,input().split())\n  if n<3 or (r-l)<2:\n   print(\"NO\")\n   continue\n  if dp[r-2]-dp[l-1]>0:\n   print(\"YES\")\n  else:\n   print(\"NO\")", "from bisect import *\ndef sub_string(temp,n,l,r):\n index=bisect_left(temp,l-1)\n if(index>=n):\n  print('NO')\n  return\n if(temp[index]+2<=r-1):\n  print(\"YES\")\n else:\n  print('NO')\nfor _ in range(int(input())):\n n,q=map(int,input().split())\n s=[x for x in input()]\n temp=[]\n for i in range(n-2):\n  if(s[i]==s[i+1] or s[i+1]==s[i+2] or s[i]==s[i+2]):\n   temp.append(i)\n n=len(temp)\n for i in range(q):\n  l,r=map(int,input().split())\n  sub_string(temp,n,l,r)"]
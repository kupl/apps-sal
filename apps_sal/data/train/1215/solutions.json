["def isSolvable( W, R):\r\n        LW, LR, F, ML, AW, V, LMap = len(W), len(R), set([w[0] for w in W+[R]]), max(map(len, W+[R])), W+[R], set(), {}\r\n        if LR < ML: return False\r\n        def dfs(d,i,c):\r\n            if d == ML: return c == 0\r\n            if i == len(W) + 1:\r\n                s = sum(LMap[w[-d-1]] if d < len(w) else 0 for w in W) + c\r\n                return dfs(d+1,0,s//10) if s % 10 == LMap[R[-d-1]] else False\r\n            if i < LW and d >= len(W[i]): return dfs(d,i+1,c)\r\n            ch = AW[i][-d-1]\r\n            if ch in LMap: return dfs(d,i+1,c)\r\n            for x in range((ch in F), 10):\r\n                if x not in V:\r\n                    LMap[ch], _ = x, V.add(x)\r\n                    if dfs(d,i+1,c): return True\r\n                    V.remove(LMap.pop(ch))\r\n        return dfs(0,0,0)\r\nn=int(input())\r\nW=[]\r\nfor i in range(n):\r\n    W.append(str(input()))\r\nR=input()    \r\na=(isSolvable(W,R))\r\nif a==True:\r\n    print(\"true\")\r\nelse:\r\n    print(\"false\")", "# Solution link: https://leetcode.com/problems/verbal-arithmetic-puzzle/discuss/939496/Python-Optimizations-to-beat-TLE-Top-Down-DP-(93)\r\n\r\n\r\n#dt = {} for i in x: dt[i] = dt.get(i,0)+1\r\nimport sys;input = sys.stdin.readline\r\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\r\n\r\nimport functools,collections\r\ndef isSolvable(words, result):\r\n\r\n    @functools.lru_cache(None)\r\n    def helper(i, total, nums):\r\n\r\n        if i == len(chars):\r\n            return total == 0\r\n\r\n        if i - 1 in checkpoints:\r\n            t = str(abs(total))[::-1]\r\n            for j in checkpoints[i-1]:\r\n                if (j < len(t)) and (t[j] != '0'):\r\n                    return False\r\n\r\n        for j in range(len(nums)):\r\n            if (nums[j] == 0) and (chars[i] not in not_zero) and helper(i+1, total, nums[:j]+nums[j+1:]):\r\n                return True\r\n            elif (nums[j] != 0) and helper(i+1, total + nums[j] * mult[chars[i]], nums[:j] + nums[j+1:]):\r\n                return True\r\n\r\n        return False\r\n\r\n    # 1. Check the lengths of each word and result\r\n    longest_word = len(max(words, key = len))\r\n    if (len(result) < longest_word) or (len(result) > longest_word + 1):\r\n        return False\r\n\r\n    # 2. Check if result is in words\r\n    if result in words:\r\n        return len(words) < 3 and all(word == result or len(word) == 1 for word in words)\r\n\r\n    # 3. Leading letters cannot be zero unless the length of the word is 1\r\n    not_zero = set((word[0] for word in words if len(word) > 1))\r\n    if len(result) > 1: not_zero.add(result[0])\r\n\r\n    # 4. Set of all letters\r\n    chars = set(result + ''.join(words))\r\n\r\n    # 5. Letters in words add to the total\r\n    mult = {char:0 for char in chars}\r\n    groups = collections.defaultdict(set)\r\n    for word in words:\r\n        for i,char in enumerate(reversed(word)):\r\n            mult[char] += 10**i\r\n            groups[i].add(char)\r\n\r\n    # 6. And letters in result subtract from the total\r\n    for i,char in enumerate(reversed(result)):\r\n        mult[char] -= 10**i\r\n        groups[i].add(char)\r\n\r\n    # 7. Letters that add and subtract the same amount can be any number, so ignore them.\r\n    chars = {char for char in chars if mult[char]}\r\n    for g in groups:\r\n        groups[g] = groups[g].intersection(chars)\r\n    chars = list(chars)\r\n\r\n    # 8. All letters that occur later in the word may affect letters ealrier in the word\r\n    for g in range(1, len(groups)):\r\n        groups[g] |= groups[g-1]\r\n    chars.sort(key = lambda c: min(g for g in range(len(groups)) if c in groups[g]))\r\n\r\n    # 9. Once a number has been assigned to all the letters in a group\r\n    #    the digit in total at position 10**i must be zero for a solution to exist\r\n    checkpoints = collections.defaultdict(list)\r\n    seen = set()\r\n    checked = set()\r\n    for i,char in enumerate(chars):\r\n        seen.add(char)\r\n        for g in groups:\r\n            if (g not in checked) and groups[g].issubset(seen):\r\n                checked.add(g)\r\n                checkpoints[i].append(g)\r\n\r\n    return helper(0, 0, tuple(range(10)))\r\n\r\nn = inp()\r\nx = [input().strip() for i in range(n)]\r\ny = input().strip()\r\nans = isSolvable(x,y)\r\nif ans:\r\n    print(\"true\")\r\nelse:\r\n    print(\"false\")\r\n"]
["class Solution(object):\n    def splitIntoFibonacci(self, S):\n        \\\"\\\"\\\"\n        :type S: str\n        :rtype: List[int]\n        \\\"\\\"\\\"\n        n = len(S)\n        for i in range(1, 11):\n            for j in range(1, 11):\n                if i + j >= n:\n                    break\n                L = self.buildFibo(S, i, j)\n                if L:\n                    return L\n        return []\n    \n    def buildFibo(self, s, i, j):\n        a = s[:i]\n        b = s[i:i+j]\n        if a[0] == '0' and i > 1:\n            return []\n        if b[0] == '0' and j > 1:\n            return []\n        \n        offset = i + j\n        n = len(s)\n        x, y = int(a), int(b)\n        arr = [x, y]\n        while offset < n:\n            z = x + y\n            if z > 2147483647:\n                return []\n            \n            c = str(z)\n            k = len(c)\n            if offset + k > n or s[offset:offset+k] != c:\n                return []\n            offset += k\n            arr.append(z)\n            x, y = y, z\n        return arr", "class Solution:\n    def splitIntoFibonacci(self, S):\n        for i in range(min(10, len(S))):\n            x = S[:i+1]\n            if x != '0' and x.startswith('0'): break\n            a = int(x)\n            for j in range(i+1, min(i+10, len(S))):\n                y = S[i+1: j+1]\n                if y != '0' and y.startswith('0'): break\n                b = int(y)\n                fib = [a, b]\n                k = j + 1\n                while k < len(S):\n                    nxt = fib[-1] + fib[-2]\n                    nxtS = str(nxt)\n                    if nxt <= 2**31 - 1 and S[k:].startswith(nxtS):\n                        k += len(nxtS)\n                        fib.append(nxt)\n                    else:\n                        break\n                else:\n                    if len(fib) >= 3:\n                        return fib\n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str):\n        self.res = []\n        self.dfs(S, [], 0)\n        return self.res\n    \n    def dfs(self, S, temp, count):\n        if not S and count >= 3:\n            self.res = temp[:]\n            return\n        for step in range(1, min(len(S)+1, 11)):\n            val = S[:step]\n            if str(int(val)) == val and 0 <= int(val) <= pow(2, 31) - 1: # \u9632\u6b62\u524d\u5bfc 0 \u7684\u51fa\u73b0\n                if count < 2:\n                    temp.append(int(val))\n                    self.dfs(S[step:], temp, count+1)\n                    temp.pop()\n                elif temp[count-2] + temp[count-1] == int(val):\n                    temp.append(int(val))\n                    self.dfs(S[step:], temp, count+1)\n                    temp.pop()", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def backtrack(path=[], i=0):\n            if i == len(S): return path if len(path) >= 3 else []\n            for j in range(i+1, min(i+10, len(S)) + 1):\n                if S[i] == '0' and j > i + 1: continue\n                x = int(S[i:j])\n                if x < 2**31 and (len(path) < 2 or (len(path) >= 2 and x == sum(path[-2:]))):\n                    new = backtrack(path + [x], j)\n                    if new: return new\n            return []\n        \n        return backtrack()", "class Solution:\n    def dfs(self,final,S,path,original):\n        #print(path)\n        if not S and len(path)>2 and all([int(i)<=2**31 - 1 for i in path]):\n            final.append(path)\n        for i in range(1,len(S)+1):\n            temp = int(S[:i])\n            if i>1 and S[:i][0]=='0': continue\n            if int(S[:i])>=2**31 - 1 : return\n            if len(path)<2 or (len(path)>=2 and int(path[-1])+int(path[-2])==temp ):\n                self.dfs(final,S[i:],path+[S[:i]],original)\n                \n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        final = []\n        path = []\n        self.dfs(final,S,path,S)\n        if final : return final[0]\n        return []", "'''\nI think Idea is to consider for all possible starting pairs (so number1,startingIndex1,number2,startingIndex2), what is longest pair we can get moving forward\n'''\nclass Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        BIG_NUMBER = 2**31-1##python can interpret long numbers so we will use this to compute.\n        numSplits = {}##tells what the number is represented by the substring from a to b b exclusive.\n        sLength = len(S)\n        reverseSplits = {}\n        for i in range(sLength):\n            currentNum = 0\n            for j in range(i+1,sLength+1):\n                currentNum *= 10\n                currentNum += int(S[j-1])\n                if currentNum == 0:\n                    numSplits[(i,j)] = currentNum\n                    if currentNum not in reverseSplits:\n                        reverseSplits[currentNum] = {}\n                    if i not in reverseSplits[currentNum]:\n                        reverseSplits[currentNum][i] = set([j])\n                    else:\n                        reverseSplits[currentNum][i].add(j)\n                    break\n                elif currentNum > BIG_NUMBER:\n                    break\n                else:\n                    numSplits[(i,j)] = currentNum\n                    if currentNum not in reverseSplits:\n                        reverseSplits[currentNum] = {}\n                    if i not in reverseSplits[currentNum]:\n                        reverseSplits[currentNum][i] = set([j])\n                    else:\n                        reverseSplits[currentNum][i].add(j)\n        fibonacciSequences = {}\n        def computeFibonacciSequences(startingIndex):##if startingIndex == \n            if startingIndex not in fibonacciSequences:\n                if startingIndex == sLength:\n                    answer = [[]]\n                else:\n                    answer = []\n                    for i in range(startingIndex+1,sLength+1):\n                        if (startingIndex,i) in numSplits:##so this is a valid number.\n                            nextNumber = numSplits[(startingIndex,i)]\n                            ithFibonaccis = computeFibonacciSequences(i)\n                            for fibSeq in ithFibonaccis:\n                                if len(fibSeq) > 1:\n                                    largeNumber = fibSeq[-2]\n                                    smallNumber = fibSeq[-1]\n                                    if nextNumber == largeNumber-smallNumber:\n                                        appended = fibSeq+[nextNumber]\n                                        answer.append(appended)\n                                else:\n                                    appended = fibSeq + [nextNumber]\n                                    answer.append(appended)\n                        else:\n                            break\n                fibonacciSequences[startingIndex] = answer\n                return answer\n            else:\n                return fibonacciSequences[startingIndex]\n        computeFibonacciSequences(0)\n        for sequence in fibonacciSequences[0]:\n            if len(sequence) >= 3:\n                sequence.reverse()\n                return sequence\n        else:\n            return []\n\n                                    \n                                \n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def f(l, i):\n            if i == len(S) and len(l) >= 3:\n                return l\n            r = []\n            t = 0\n            for j in range(i, len(S)):\n                t *= 10\n                t += int(S[j])\n                if t <= 2**31 - 1:\n                    if len(l) > 1 and l[-1] + l[-2] != t:\n                        continue\n                    l.append(t)\n                    temp = f(l, j + 1)\n                    if temp:\n                        return temp\n                    l.pop()\n                    if t == 0:\n                        return []\n            return r\n        return f([], 0)       ", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n                \n            \n        n = len(S)\n        \n        for i in range(1, min(32, (n-1)//2+1)):\n            for j in range(i+1, 2 * n//3 + 1):\n                a, b = int(S[:i]), int(S[i:j])\n                idx = len( str(a+b) )\n                tmp = [a, b]\n                l = j\n                while int(S[l:l+idx]) == a+b:\n                    if int(S[l:l+idx]) > 2 ** 31 - 1:\n                        break\n                    tmp.append( int(S[l:l+idx]) )\n                    if l + idx == n:\n                        return tmp\n                    a = b\n                    b = int(S[l:l+idx])\n                    l += idx\n                    idx = len(str(a+b))\n        return []\n        \n", "class Solution:\n    def trysolve(self, s, seq, n):\n        seq.append(n)\n        if self.solve(s, seq):\n            return True\n        seq.pop()\n        return False\n       \n    def solve(self, s, seq):\n        if not s:\n            return True\n        target = sum(seq[-2:])\n        if target > 2 ** 31 - 1:\n            return False\n        if s[0] == '0':\n            if target == 0:\n                return self.trysolve(s[1:], seq, 0) ;\n            else:\n                return False\n        for end in range(1, len(s)+1):\n            n = int(s[:end])\n            if n == target and self.trysolve(s[end:], seq, n):\n                return True\n        return False       \n     \n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        limit = 2**31 - 1;\n        for i in range(1, len(S)):\n            n1 = int(S[:i]);\n            if(n1>limit):\n                return [];\n            if(n1!=0 and S[0]=='0'):\n                return [];\n            for j in range(i+1, len(S)):\n                n2 = int(S[i:j])\n                if n2 != 0 and S[i] == '0':\n                    break\n                if n2 > limit:\n                    break \n                seq = [n1, n2]\n                if self.solve(S[j:], seq):\n                    return seq;\n        return []\n                \n            \n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def f(l, i, leng):\n            if leng == len(S) and len(l) >= 3:\n                return l\n            r = []\n            t = 0\n            for j in range(i, len(S)):\n                t *= 10\n                t += int(S[j])\n                leng += 1\n                if t <= 2**31 - 1:\n                    if len(l) > 1 and l[-1] + l[-2] != t:\n                        continue\n                    l.append(t)\n                    temp = f(l, j + 1, leng)\n                    if temp:\n                        return temp\n                    l.pop()\n                    if t == 0:\n                        return []\n            print(r)\n            return r\n        return f([], 0, 0)       ", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        #backtrack way\n        n, ans = len(S), []\n\n\n        def dfs(pos):\n            if pos == n:\n                return len(ans) >= 3\n        \n            num = 0\n            for i in range(pos, n):\n                if (S[pos] == '0' and i == pos) or S[pos] != '0':\n                    num = num * 10 + ord(S[i]) - ord('0')\n                    if num < 2 ** 31 - 1:\n                        if len(ans) < 2 or (ans[-1] + ans[-2] == num):\n                            ans.append(num)\n                            if dfs(i + 1):\n                                return True #end early\n                            ans.pop()\n            return False\n        dfs(0)\n        return ans\n        \n# iteration\n#         l = len(S)\n#         m = 2 ** 31 - 1\n#         for i in range(1, l):\n#             if S[0] == '0' and i != 1:\n#                 break\n                \n#             for j in range(i + 1, l):\n#                 if S[i] == '0' and j != i + 1:\n#                     break\n                        \n#                 pre = int(S[:i])\n#                 cur = int(S[i:j])\n#                 res = [pre, cur]\n\n#                 k = j\n#                 while k < l:\n#                     pre, cur = cur, pre + cur\n#                     if cur <= m and int(S[k:k+len(str(cur))]) == cur:\n#                         res.append(cur)\n#                         k += len(str(cur))\n#                     else:\n#                         break\n#                 if k == l and len(res) >= 3:\n#                     return res\n#         return []\n                        \n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def startswith(S, k, x):\n            y = 0\n            for i in range(k, len(S)):\n                y = 10*y + int(S[i])\n                if y == x:\n                    return i-k+1\n                elif y > x:\n                    break\n            return 0\n\n        MAX_INT = 2**31-1\n        a = 0\n        for i in range(len(S)-2):\n            a = 10*a + int(S[i])\n            b = 0\n            for j in range(i+1, len(S)-1):\n                b = 10*b + int(S[j])\n                fib = [a, b]\n                k = j+1\n                while k < len(S):\n                    if fib[-2] > MAX_INT-fib[-1]:\n                        break\n                    c = fib[-2]+fib[-1]\n                    length = startswith(S, k, c)\n                    if length == 0:\n                        break\n                    fib.append(c)\n                    k += length\n                else:\n                    return fib\n                if b == 0:\n                    break\n            if a == 0:\n                break\n        return []\n                \n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        exp = 2**31 - 1\n        def works(x,y,i):\n            res = [x,y]\n            while i < len(S):\n                target = res[-2] + res[-1]\n                if target > exp:\n                    return []\n                build = S[i]\n                i += 1\n                while i < len(S) and build < target:\n                    if build == 0:\n                        return []\n                    build = build*10 + S[i]\n                    i += 1\n                if build != target:\n                    return []\n                res.append(build)\n            return res\n        S = [int(c) for c in S]\n        N = len(S)\n        x = 0\n        for i in range(N-2):\n            if i > 0 and x == 0:\n                break\n            x = x*10 + S[i]\n            y = 0\n            for j in range(i+1, N-1):\n                if j > i+1 and y == 0:\n                    break\n                y = y*10 + S[j]\n                res = works(x,y,j+1)\n                if res: return res\n            \n        return []", "class Solution:\n  def dfs(self, grandpa, parent, S, start):\n    # return the fibonacci seqs of S[start:] given grandpa and parent\n    if start >= len(S):\n      return [], True\n    for i in range(start+1, len(S)+1):\n      sub = S[start: i]\n      if len(sub) > 1 and sub[0] == '0':\n        # invalid\n        continue\n      num = int(sub)\n      if num > 2**31 - 1:\n        continue\n      if grandpa >= 0 and parent >= 0 and num != grandpa + parent:\n        continue\n        \n      ans, found = self.dfs(parent, num, S, i)\n      if grandpa < 0 and parent < 0 and len(ans) < 2:\n        continue\n      if found:\n        return [num] + ans, True\n    return [], False\n  \n  def splitIntoFibonacci(self, S: str) -> List[int]:\n    return self.dfs(-1, -1, S, 0)[0]", "class Solution:\n    def splitIntoFibonacci(self, S) :\n        self.res=[]\n        def dfs(index,prev2,prev,count,cur_path):\n            if index==len(S) and count>=3:\n                self.res=cur_path\n                return\n\n            for i in range(index,len(S)):\n                x=int(S[index:i+1])\n                if count==0:\n                    dfs(i+1,0,x,count+1,cur_path+[x])\n\n                else:\n                    if x>(1<<31):\n                        return False\n                    if x==prev2+prev or count==1:\n                        if dfs(i + 1, prev, x, count + 1, cur_path + [x]):\n                            return True\n                if x==0:\n                    break\n\n\n        dfs(0,0,0,0,[])\n        return self.res", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        if len(S) < 3: return []\n        \n        def dfs(S, path):\n            if not S:\n                if len(path) >= 3:\n                    return path\n                return []\n                \n            for l in range(1, len(S) + 1):\n                if (len(S[:l]) > 1 and S[0] == \\\"0\\\") or (int(S[:l]) > 2**31 -1):\n                    continue \n                    \n                if len(path) < 2:\n                    temp = dfs(S[l:], path + [int(S[:l])])\n                    if temp:\n                        return temp\n                    \n                else:\n                    if path[-1] + path [-2] == int(S[:l]):\n                        temp = dfs(S[l:], path + [int(S[:l])])\n                        if temp:\n                            return temp\n            return []\n        \n        return dfs(S, [])\n                \n                        \n            ", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def check(i, a, b):\n            if int(a) > 2147483647 or int(b) > 2147483647:\n                return [], False\n            if i == len(S):\n                return [str(a), str(b)], True\n            s = str(a + b)\n            if S[i: i + len(s)] == s:\n                out, good = check(i + len(s), b, int(s))\n                if good:\n                    return [str(a)] + out, True\n            return [], False\n                \n        for i in range(len(S) - 2):\n            a = int(S[:i+1])\n            if S[0] == '0' and a != 0:\n                break\n            for j in range(i + 1, len(S) - 1):\n                b = int(S[i + 1: j + 1])\n                if S[i + 1] == '0' and b != 0:\n                    break\n                out, _ = check(j + 1, a, b)\n                if out:\n                    return out\n        return []\n                \n                \n", "class Solution(object):\n    def splitIntoFibonacci(self, S):\n        \\\"\\\"\\\"\n        :type S: str\n        :rtype: List[int]\n        \\\"\\\"\\\"\n        def backtrack(cur, temp_state):\n            if len(temp_state) >= 3 and cur == n:  # \u9000\u51fa\u6761\u4ef6\n                self.res = temp_state[:]\n                return\n            for i in range(cur, n):\n                if S[cur] == \\\"0\\\" and i > cur:  # \u5f53\u6570\u5b57\u4ee50\u5f00\u5934\u65f6,\u5e94\u8be5\u8df3\u8fc7\n                    return\n                if int(S[cur: i+1]) > 2 ** 31 - 1 or int(S[cur: i+1]) < 0:  # \u526a\u679d\n                    continue\n                if len(temp_state) < 2:\n                    backtrack(i+1, temp_state + [int(S[cur: i+1])])\n                else:\n                    if int(S[cur: i+1]) == temp_state[-1] + temp_state[-2]:\n                        backtrack(i+1, temp_state + [int(S[cur: i+1])])\n\n        n = len(S)\n        self.res = []\n        backtrack(0, [])\n        return self.res\n        ", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        \n        def helper(a, i, j, cur_ans):\n            if S[i]=='0' and j!=i+1:\n                cur_ans=[]\n                return False\n            if a>2**31-1:\n                return False\n            b=int(S[i:j])\n            c=a+b\n            if b>2**31-1 or c>2**31-1:\n                return False\n            c_s=str(c)\n            if c_s==S[j:j+len(c_s)]:\n                k=j+len(c_s)\n                cur_ans.append(c)\n                if k==len(S):\n                    return True\n                if helper(b, j, k, cur_ans):\n                    return True\n                else:\n                    cur_ans=[]\n                    return False\n            cur_ans=[]\n            return False\n        if len(S)==0:\n            return []\n        \n        for i in range(1, len(S)):\n            \n            if i>1 and S[0]=='0':\n                break\n            a=int(S[:i])\n            for j in range(i+1, len(S)):\n                cur_ans=[a, int(S[i:j])]\n                if helper(a, i, j, cur_ans):\n                    return cur_ans\n        \n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        ans=0\n        def helper(pp,p,i,no):\n            nonlocal ans\n            if(i==len(S) and len(no)>=3):\n                ans=no\n                return True\n            else:\n                for j in range(i+1,len(S)+1):\n                    ok=S[i:j]\n                    if(ok[0]==\\\"0\\\" and len(S[i:j])>1):\n                        continue\n                    if(int(S[i:j])>(2**31)-1):\n                        continue\n                    let=int(S[i:j])\n                    if(pp==-1):\n                        if(helper(let,p,j,no+[let])):\n                            return True\n                    elif(p==-1):\n                        if(helper(pp,let,j,no+[let])):\n                            return True\n                    else:\n                        if(let==pp+p):\n                            if(helper(p,let,j,no+[let])):\n                                return True\n            return False\n        if(helper(-1,-1,0,[])==False):\n            return []\n        else:\n            return ans\n                ", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        for i in range(len(S))[::-1]:\n            for j in range(i+1,len(S)):\n                b,c = int(S[i:j]), int(S[j:])\n                if c >= 2**31: continue\n                if b >= 2**31: continue\n\n                parts = [b,c]\n                a = c-b\n                while a >= 0 and a <= 2**31 - 1:\n                    parts.insert(0, a)\n                    b,c = a,b\n                    a = c-b\n\n                    if S == ''.join(map(str,parts)):\n                        return parts\n        \n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        ans = []\n        limit = 2**31 - 1\n        def helper(n, prefix):\n            nonlocal S, ans\n            if ans:\n                return\n            if n == len(S):\n                ans = prefix\n                return\n            num = sum(prefix[-2:])\n            if S[n:].startswith(str(num)) and num <= limit:\n                return helper(n + len(str(num)), prefix + [num])\n        for i in range(2, len(S) * 2 // 3 + 1):\n            for j in range(1, i):\n                helper(i, [int(S[:j]), int(S[j:i])])\n                if ans:\n                    break\n            if ans:\n                break\n        return ans", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        n = len(S)\n        ans = []\n        \n        def dfs(position):\n            # means at end of string\n            if position == n:\n                return True if len(ans) > 2 else False\n            \n            num = 0\n            \n            for i in range(position, n):\n                # build number from string\n                num = num * 10 + ord(S[i]) - ord('0')\n                \n                # check for integer overflow\n                if num >= 2**31:\n                    break\n                    \n                # check len and last elem in ans + 2nd to last elem in ans = num\n                if len(ans) < 2 or ans[-1] + ans[-2] == num:\n                    # add to ans, start of backtracking portion\n                    ans.append(num)\n                    # recurse on next index, if true return true\n                    if dfs(i+1):\n                        return True\n                    # pop recently add num from ans\n                    ans.pop()\n                \n                # check for trailing/leading 0s and i == position\n                if i == position and S[i] == '0':\n                    return False\n            \n            return False\n        # call\n        dfs(0)\n        return ans", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        \n        def impl(s, pos, output):\n            if pos >= len(s):\n                return len(output) >= 3\n            loop_end = len(s) + 1\n            if s[pos] == '0':\n                loop_end = pos + 2\n            for p in range(pos + 1, loop_end):\n                this_number = int(s[pos:p])\n                if this_number > pow(2, 31) - 1:\n                    continue\n                if len(output) >= 2 and output[-1] + output[-2] == this_number:\n                    output.append(this_number)\n                    if impl(s, p, output):\n                        return True\n                    else:\n                        output.pop()\n                elif len(output) < 2:\n                    output.append(this_number)\n                    if impl(s, p, output):\n                        return True\n                    else:\n                        output.pop()\n            return False\n        \n        result = []\n        impl(S, 0, result)\n        \n        return result\n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        ans = []\n        limit = 2**31 - 1\n        def helper(n, prefix):\n            nonlocal S, ans\n            if ans:\n                return\n            if n == len(S):\n                ans = prefix\n                return\n            num = sum(prefix[-2:])\n            if S[n:].startswith(str(num)) and num <= limit:\n                return helper(n + len(str(num)), prefix + [num])\n        for i in range(2, len(S) * 2 // 3 + 1):\n            for j in range(1, i):\n                helper(i, [int(S[:j]), int(S[j:i])])\n        return ans", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        ans = []\n        limit = 2**31 - 1\n        \n        @lru_cache(None)\n        def helper(n, prefix):\n            nonlocal S, ans\n            if n == len(S):\n                ans = prefix\n                return\n            num = int(S[prefix[-2]:prefix[-1]]) + int(S[prefix[-1]:n])\n            if S[n:].startswith(str(num)) and num <= limit:\n                return helper(n + len(str(num)), prefix + (n,))\n            \n        for i in range(2, len(S) * 2 // 3 + 1):\n            for j in range(1, i):\n                helper(i, (0, j))\n                if ans:\n                    break\n            if ans:\n                break\n        return [int(S[i:j]) for i, j in zip(ans, ans[1:] + (len(S),))] if ans else []\n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        ans = []\n        dfs(S, [], ans)\n        return ans[0] if ans else []\n\n        \ndef dfs(S, temp, ans):\n    # print(S)\n    # print(temp)\n    if len(temp) >= 3 and not is_valid_fibonacci(temp):\n        return\n    if S == \\\"\\\":\n        if len(temp) >= 3:\n            ans.append(temp.copy())\n        return \n    for i in range(1, len(S) + 1):\n        sub_str = S[:i]\n        rest_str = S[i:]\n        # '01' is not allowed\n        if sub_str.startswith('0') and len(sub_str) != 1:\n            continue\n        num = int(sub_str)\n        # 0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type);\n        if num < 0 or num > 2 ** 31 - 1:\n            continue\n        # print(sub_str)\n        # print(rest_str)\n        temp.append(num)\n        dfs(rest_str, temp, ans)\n        temp.pop()\n        \ndef is_valid_fibonacci(items):\n    # check last 3 elements\n    return items[-1] == items[-2] + items[-3]\n        ", "class Solution:\n    def splitIntoFibonacci(self, num: str) -> List[int]:\n        b = []\n        c = []\n        def additivenumber(num,b):\n            if len(c) == 1:\n                return \\\"\\\"\n            if len(b) > 2 and num == \\\"\\\":\n                c.append(b)\n            else:\n                for x in range(len(num)):\n                    if len(num[0:x+1]) == 1:\n                        if len(b) >= 2:\n                            if int(num[0:x+1]) == b[-1] + b[-2]:\n                                additivenumber(num[x+1:],b+[int(num[0:x+1])])\n                        else:\n                            additivenumber(num[x+1:],b+[int(num[0:x+1])])\n                    else:\n                        if num[0:x+1][0] != str(0) and int(num[0:x+1]) <= 2147483647:\n                            if len(b) >= 2:\n                                if int(num[0:x+1]) == b[-1] + b[-2]:\n                                    additivenumber(num[x+1:],b+[int(num[0:x+1])])\n                            else:\n                                additivenumber(num[x+1:],b+[int(num[0:x+1])])\n        additivenumber(num,b)\n        if c == []:\n            return c\n        return c[0]\n        ", "class Solution:\n    def splitIntoFibonacci(self, S):\n        \\\"\\\"\\\"\n        :type S: str\n        :rtype: List[int]\n        \\\"\\\"\\\"\n        limit=2**31 - 1\n        for i in range(1,len(S)):\n            if S[0]==\\\"0\\\" and i!=1:\n                break\n            for j in range(i+1,len(S)):\n                if S[i]==\\\"0\\\" and j!=i+1:\n                    break\n                pre=int(S[:i])\n                cur=int(S[i:j])\n                ans=[pre,cur]\n                k=j\n                while k<len(S):\n                    cur,pre=pre+cur,cur\n                    if cur<=limit and str(cur)==S[k:k+len(str(cur))]:\n                        ans.append(cur)\n                        k=k+len(str(cur))\n                    else:\n                        break\n                if k==len(S):\n                    return ans\n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        ans=0\n        c=(2**31)-1\n        def helper(pp,p,i,no):\n            nonlocal ans\n            if(i==len(S) and len(no)>=3):\n                ans=no\n                return True\n            else:\n                for j in range(i+1,len(S)+1):\n                    ok=S[i:j]\n                    if(ok[0]==\\\"0\\\" and len(S[i:j])>1):\n                        continue\n                    if(int(S[i:j])>c):\n                        continue\n                    let=int(S[i:j])\n                    if(pp==-1):\n                        if(helper(let,p,j,no+[let])):\n                            return True\n                    elif(p==-1):\n                        if(helper(pp,let,j,no+[let])):\n                            return True\n                    else:\n                        if(let==pp+p):\n                            if(helper(p,let,j,no+[let])):\n                                return True\n            return False\n        if(helper(-1,-1,0,[])==False):\n            return []\n        else:\n            return ans\n                ", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        \n        \n        def dfs(index,res,s): \n            #print(res)\n            if index == len(s) and len(res)>=3:\n                return True\n            num = 0 \n            for i in range(index,len(s)):\n                num = num * 10 + (ord(s[i]) - ord('0'))\n                if num > 2**31-1:\n                    break\n                if len(res)>2 and  (num > res[-1]+res[-2]):\n                    break\n                if s[index] == '0' and i > index:\n                    break\n                if len(res) < 2 or (res[-1]+res[-2] == num):\n                    res.append(num)       \n                    if dfs(i+1,res,s):\n                        return True\n                    res.pop()\n                \n            return False\n        result = []\n        dfs(0,result,S)\n        return result\n                \n                \n            \n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        \n        if len(S) < 2: return []\n    \n        def dfs(s, path):\n            if not s:\n                if len(path) >= 3:\n                    return path\n                return []\n\n            for  i in range(len(s)):\n                if (len(s[:i+1]) > 1 and s[0]==\\\"0\\\") or int(s[:i+1]) > 2**31-1:\n                    continue \n                if len(path) < 2:\n                    tmp = dfs(s[i+1:], path + [s[:i+1]])\n                    if tmp:\n                        return tmp\n                else:\n                    if int(path[-2]) + int(path[-1]) == int(s[:i+1]):\n                        tmp = dfs(s[i+1:], path +[s[:i+1]])\n                        if tmp:\n                            return tmp\n            return []\n        \n        return dfs(S,[])", "class Solution:\n    def ok(self, S, j, res):\n        # print(j, res)\n        if j == len(S):\n            return True        \n        for k in range(j + 1, len(S) + 1):\n            third = S[j:k]\n            if len(third) > 1 and third[0] == '0' or int(third) >= 2 ** 31:\n                continue                \n            third = int(third)\n            if third  == res[-1] + res[-2]:\n                res.append(third)\n                if self.ok(S, k, res):\n                    return True\n                else:\n                    res.pop()\n        return False\n    \n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        n = len(S)\n        res = []\n        for i in range(1, n - 1):\n            first = S[0:i]\n            if len(first) > 1 and first[0] == '0' or int(first) >= 2 ** 31:\n                continue            \n            for j in range(i + 1, n):\n                second = S[i:j]\n                if len(second) > 1 and second[0] == '0' or int(second) >= 2 ** 31:\n                    continue                \n                res = [int(first), int(second)]\n                if self.ok(S, j, res):\n                    return res\n                else:\n                    res = []\n        return res", "class Solution:\n    \n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def helper(S: str, curr_path: List[int]):\n            if not S:\n                if self.isValidPath(curr_path):\n                    return curr_path\n                return None\n            \n            \n            for partition_point in range(1, len(S)+1):\n                prefix, suffix = S[:partition_point], S[partition_point:]\n                valid_prefix = prefix == '0' or prefix[0] != '0' and int(prefix) <= (2**31-1)\n                new_curr_path = curr_path + [int(prefix)]\n                if valid_prefix and (len(new_curr_path) < 3 or self.isValidPath(new_curr_path)):\n                    recurse = helper(suffix, new_curr_path)\n                    if recurse:\n                        return recurse\n            return None\n            \n        return helper(S, [])\n    \n    def isValidPath(self, path: List[str]) -> bool:\n        return len(path) > 2 and int(path[-1]) == (int(path[-2]) + int(path[-3]))\n        \n    \n", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\n\ndef split(f1, f2, si, S):\n    N = len(S)\n    if N <= si:\n        return []\n    prefixNum = f1 + f2\n    if prefixNum >= (1 << 31):\n        return []\n    prefixS = str(f1 + f2)\n\n    if S[si] == '0':\n        if prefixNum > 0:\n            return []\n        else:\n            if si == N - 1:\n                return [0]\n            else:\n                tail = split(f2, 0, si + 1, S)\n                if len(tail):\n                    tail.append(0)\n                    return tail\n                else:\n                    return []\n\n    else:\n        nextSi = si + len(prefixS)\n        if nextSi <= N and S[si:nextSi] == prefixS:\n            if nextSi == N:\n                return [prefixNum]\n            else:\n                #print(\\\"split!!\\\")\n                tail = split(f2, prefixNum, si + len(prefixS), S)\n                if len(tail):\n                    tail.append(prefixNum)\n                    return tail\n    return []\n\n\nclass Solution:\n\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        N = len(S)\n        for firstEI in range(N - 2):\n            if S[0] == '0' and firstEI > 0:\n                continue\n            firstN = int(S[:firstEI + 1])\n            for secondEI in range(firstEI + 1, N - 1):\n                if S[firstEI + 1] == '0' and secondEI > firstEI + 1:\n                    continue\n                secondN = int(S[firstEI + 1:secondEI + 1])\n\n                tail = split(firstN, secondN, secondEI + 1, S)\n                if len(tail):\n                    tail.reverse()\n                    ans = [firstN, secondN]\n                    ans.extend(tail)\n                    return ans\n\n        return []\n\n\\\"\\\"\\\"\nS = Solution()\ns = \\\"123456579\\\"\ns = \\\"112358130\\\"\ns = \\\"0123\\\"\ns = \\\"011\\\"\ns = \\\"0123\\\"\ns = \\\"11235813\\\"\ns = \\\"1101111\\\"\ns = \\\"0000\\\"\nprint(S.splitIntoFibonacci(s))\n\\\"\\\"\\\"\n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        for i in range(len(S)):\n            x = S[:i+1]\n            if x != '0' and x.startswith('0'):\n                break\n            a = int(x)\n            for j in range(i+1, len(S)):\n                y = S[i+1:j+1]\n                if y != '0' and y.startswith('0'):\n                    break\n                b = int(y)\n                fib = [a, b]\n                k = j+1\n                while k < len(S):\n                    nxt = fib[-1] + fib[-2]\n                    nxtS = str(nxt)\n                    if nxt <= 2**31 - 1 and S[k:].startswith(nxtS):\n                        k += len(nxtS)\n                        fib.append(nxt)\n                    else:\n                        break\n                else:\n                    if len(fib) >= 3:\n                        return fib\n        return []", "class Solution:\n    def splitIntoFibonacci(self, S):\n        upper_limit = 2 ** 31 - 1\n        def split_fib(s, res):\n            if s == \\\"\\\"  and len(res) > 2 and int(res[-1]) == int(res[-2]) + int(res[-3]):\n                return True\n            if len(res) > 2 and int(res[-1]) != int(res[-2]) + int(res[-3]):\n                return False\n            if int(res[-1]) >= upper_limit:\n                return False\n            \n            for i in range(1, len(s)+1):\n                if (i > 1 and s[:i][0] == '0'):\n                    continue\n                res.append(s[:i])\n                if split_fib(s[i:], res):\n                    return True\n                res.pop()\n            return False\n\n        res = []\n        for i in range(1, len(S)):\n            if S[:i][0] == '0' and i > 1:\n                continue\n            res.append(S[:i])\n            if split_fib(S[i:], res) and int(res[-1]) <= upper_limit:\n                return res\n            res.pop()\n        return []\n        ", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        if len(S) < 3: return []\n        for i in range(1, len(S) - 2):\n            first = S[:i]\n            for j in range(i, len(S) - 1):\n                j += 1\n                second = S[i:j]\n                split = self.dfs(first, second, S[j:], [first, second])\n                if split: return split\n                \n        return []\n    \n    def notvalid(self, s):\n        if int(s) != 0 and s[0] == 0:\n            return True\n        if int(s) > 2**31 - 1:\n            return True\n        return False\n\n    \n    def dfs(self, s1, s2, rem, seq):\n        if self.notvalid(s1) or self.notvalid(s2):\n            return []\n        s3 = str(int(s1) + int(s2))\n        if self.notvalid(s3): return []\n        l = len(s3)\n        if rem[:l] == s3:\n            seq.append(s3)\n            if len(rem) > l:\n                return self.dfs(s2, s3, rem[l:], seq)\n            else:\n                return seq\n        return []\n", "class Solution:\n    \n    def __init__(self):\n        self.q = []\n        \n    def splitIntoFibonacci(self, s: str) -> List[int]:\n        self.dfs(s,[],0)\n        return self.q\n    \n    def dfs(self,s,q,i):\n        if i == len(s):\n            if len(q) >= 3: self.q = q[::]\n            return len(q) >= 3\n        \n        for j in range(i , min(len(s), i + 10 ) ):\n            v = int(s[i:j+1])\n            b1 = (v< 2 ** 31 -1)\n            b2 = v == 0 or (v and s[i] != '0')\n            b3 = len(q) < 2 or (q[-1] + q[-2] == v)\n            if b1 and b2 and b3 and self.dfs(s,q + [v], j + 1):\n                return True\n        return False", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        # When the first two numbers are decided,\n        # all next numbers are decided too.\n\n        for i in range(1, len(S) - 1):\n            # need have at least 1 chracter left for third number\n            for j in range(i + 1, len(S)):\n                first = to_number(S[:i])\n                second = to_number(S[i:j])\n                ans = [first, second]\n                if is_valid_fibonacci(S, j, first, second, ans):\n                    return ans\n        return []\n        \ndef to_number(s):\n    # print(s)\n    num = int(s)\n    if s.startswith('0') and num != 0:\n        return None\n    if num < 0 or num > 2 ** 31 - 1:\n        return None\n    return num\n\ndef is_valid_fibonacci(s, curr_index, first, second, ans):\n    if first is None or second is None:\n        return False\n    if curr_index == len(s):\n        return True\n    expected = first + second\n    len_next_num = len(str(expected))\n    end_index = curr_index + len_next_num\n    next_num = to_number(s[curr_index: end_index])\n    if next_num != expected:\n        return False\n    ans.append(next_num)\n    return is_valid_fibonacci(s, end_index, second, next_num, ans)", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        unvisited = []\n        for i1 in range(1, len(S)):\n            s1 = S[:i1]\n            if s1 != \\\"0\\\" and s1.startswith(\\\"0\\\"):\n                continue\n            for i2 in range(i1 + 1, len(S)):\n                s2 = S[i1:i2]\n                if s2 != \\\"0\\\" and s2.startswith(\\\"0\\\"):\n                    continue\n                unvisited.append(([int(s1), int(s2)], i2))\n        \n        while unvisited:\n            sequence, suffix_i = unvisited.pop()\n\n            if suffix_i == len(S):\n                return sequence\n\n            next_term = sequence[-2] + sequence[-1]\n\n            if next_term <= (1 << 31) - 1:\n                next_term_s = str(next_term)\n\n                new_suffix_i = suffix_i + len(next_term_s)\n                # if S[suffix_i:suffix_i + len(next_term_s)] == next_term_s:\n                if S[suffix_i:new_suffix_i] == next_term_s:\n                    # new_suffix_i = suffix_i + len(next_term_s)\n                    unvisited.append((sequence + [next_term], new_suffix_i))\n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        unvisited = []\n        for i1 in range(1, len(S)):\n            s1 = S[:i1]\n            if s1 != \\\"0\\\" and s1.startswith(\\\"0\\\"):\n                continue\n            for i2 in range(i1 + 1, len(S)):\n                s2 = S[i1:i2]\n                if s2 != \\\"0\\\" and s2.startswith(\\\"0\\\"):\n                    continue\n                unvisited.append(([int(s1), int(s2)], i2))\n        \n        while unvisited:\n            sequence, suffix_i = unvisited.pop()\n\n            if suffix_i == len(S):\n                return sequence\n\n            next_term = sequence[-2] + sequence[-1]\n\n            if next_term <= (1 << 31) - 1:\n                next_term_s = str(next_term)\n                new_suffix_i = suffix_i + len(next_term_s)\n                if S[suffix_i:new_suffix_i] == next_term_s:\n                    unvisited.append((sequence + [next_term], new_suffix_i))\n", "from math import pow\n\nclass Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        total = len(S)\n        if total < 3:\n            return []\n\n        if S[0] == '0' and S[1] == '0':\n            for item in S:\n                if item != '0':\n                    return []\n            return [0] * len(S)\n\n        if S[0] == \\\"0\\\":\n            first_index = 0\n            for second_index in range(first_index+1, total-1):\n                result = [0, int(S[1:second_index+1])]\n                if self.do_calc(S, second_index+1, total, result):\n                    return result\n            return []\n\n\n        for first_index in range(0, total - 2):\n            if S[first_index+1] == \\\"0\\\":\n                result = [int(S[:first_index+1]), 0]\n                if self.do_calc(S, first_index+2, total, result):\n                    return result\n                continue\n\n            for second_index in range(first_index+1, total-1):\n                result = [int(S[:first_index+1]), int(S[first_index+1:second_index+1])]\n                if self.do_calc(S, second_index+1, total, result):\n                    return result\n        return []\n\n    def do_calc(self, S, current_index, total, result):\n        if current_index >= total:\n            return True\n\n        new_value = (result[-1] + result[-2])\n        new_value_str = str(new_value)\n        new_value_len = len(new_value_str)\n        S_value = S[current_index:current_index+new_value_len]\n        if S_value == new_value_str and new_value <= pow(2, 31) -1:\n            result.append(new_value)\n            return self.do_calc(S, current_index + new_value_len, total, result)\n        return False", "class Solution:\n    def get_values(self, s, idx):\n        for i in range(idx, len(s)):\n            yield (i, s[idx:i+1])\n        \n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        for i, a in self.get_values(S, 0):\n            if a != '0' and a.startswith('0'): break\n            for j, b in self.get_values(S, i+1):\n                if b != '0' and b.startswith('0'): break\n                k = j+1\n                out = [a,b]\n                while k < len(S):\n                    v = int(a) + int(b)\n                    str_v = str(v)\n                    if v <= 2**31 - 1 and S[k:].startswith(str_v):\n                        k = k + len(str_v)\n                        a, b  = b, str_v\n                        out.append(v)\n                    else:\n                        break\n                if len(out) >= 3:                        \n                    if len(''.join(map(str, out))) == len(S):\n                         return out\n        return [] \n                \n            \n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        unvisited = []\n        for i1 in range(1, len(S)):\n            s1 = S[:i1]\n            if s1 != \\\"0\\\" and s1.startswith(\\\"0\\\"):\n                continue\n            for i2 in range(i1 + 1, len(S)):\n                s2 = S[i1:i2]\n                if s2 != \\\"0\\\" and s2.startswith(\\\"0\\\"):\n                    continue\n                unvisited.append(([int(s1), int(s2)], S[i2:]))\n        \n        while unvisited:\n            sequence, suffix = unvisited.pop()\n            \n            if not suffix:\n                return sequence\n            \n            next_term = sequence[-2] + sequence[-1]\n            \n            if next_term <= (1 << 31) - 1:\n                next_term_s = str(next_term)\n\n                if suffix.startswith(str(next_term)):\n                    new_suffix = suffix[len(next_term_s):]\n                    unvisited.append((sequence + [next_term], new_suffix))\n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def dfs1(prev, cur, pos):\n            if pos == len(S)-1:\n                return True\n            \n            nex = prev + cur\n            prev = cur\n            cur = nex\n            if cur > 2 ** 31 - 1:\n                return False\n            \n            if S[pos+1:pos+1+len(str(nex))] == str(nex):\n                if len(S[pos+1:pos+1+len(str(nex))]) != 1 and S[pos+1:pos+1+len(str(nex))][0] == '0':\n                    return False\n                else:\n                    return dfs1(prev, cur, pos+len(str(nex)))\n            else:\n                return False\n        \n        def dfs2(res, prev, cur, pos):\n            res.append(prev)\n            if pos == len(S)-1:\n                res.append(cur)\n                return\n            \n            nex = prev + cur\n            prev = cur\n            cur = nex\n            dfs2(res, prev, cur, pos+len(str(nex)))\n        \n        for i in range(len(S)-1):\n            for j in range(i+1, len(S)-1):\n                if (len(S[:i+1]) > 1 and S[:i+1][0] == '0') or (len(S[i+1:j+1]) > 1 and S[i+1:j+1][0] == '0'):\n                    continue\n                if dfs1(int(S[:i+1]), int(S[i+1:j+1]), j):\n                    res = []\n                    dfs2(res, int(S[:i+1]), int(S[i+1:j+1]), j)\n                    return res\n        \n        return []\n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        stack = []\n        def solve(index):\n            if stack and int(stack[-1]) > 2**31-1:\n                return False\n            #print(stack, S[index:])\n            if index == len(S):\n                return len(stack) >= 3\n            if len(stack) < 2:\n                if S[index] == '0':\n                    stack.append('0')\n                    if solve(index+1):\n                        return True\n                    stack.pop()\n                    return False\n                for i in range(index, len(S)):\n                    stack.append(S[index:i+1])\n                    if solve(i+1):\n                        return True\n                    stack.pop()\n            elif int(stack[-1]) + int(stack[-2]) > int(S[index:]):\n                return False\n            else:\n                if S[index] == '0':\n                    if stack[-1] == '0' and stack[-2] == '0':\n                        stack.append('0')\n                        if solve(index+1):\n                            return True\n                        stack.pop()\n                    return False\n                for i in range(index, len(S)):\n                    if int(stack[-1]) + int(stack[-2]) == int(S[index:i+1]):\n                        stack.append(S[index:i+1])\n                        if solve(i+1):\n                            return True\n                        stack.pop()\n            return False\n        solve(0)\n        return stack", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        n = len(S)\n        for i in range(n):\n            fs = S[:i+1]\n            if fs != \\\"0\\\" and fs.startswith(\\\"0\\\"):\n                continue\n            for j in range(i+1, n):\n                ss = S[i+1:j+1]\n                if ss != \\\"0\\\" and ss.startswith(\\\"0\\\"):\n                    break\n                a, b = int(fs), int(ss)\n                fibs = [a, b]\n                k = j + 1\n                while k < n:\n                    next_s = str(fibs[-1] + fibs[-2])\n                    next_val = int(next_s)\n                    if next_val < 2**31 and S[k:].startswith(next_s):\n                        fibs.append(next_val)\n                        k += len(next_s)\n                    else:\n                        break\n                if k == n and len(fibs) >= 3:\n                    return fibs\n        return []\n                ", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n#         res = []\n#         self.dfs(res, S, [])\n#         return res[0] if res else []\n    \n#     def dfs(self, res, S, path):\n#         if len(path) >= 3 and not S:\n#             res.append(path[:])\n#             return True\n        \n#         for i in range(1, len(S)+1):\n#             if i > 1 and S[0] == '0' or int(S[:i]) > 2**31-1:\n#                 return\n#             if len(path) <= 1:\n#                 path.append(int(S[:i]))\n#                 if self.dfs(res, S[i:], path):\n#                     return True\n#                 path.pop()\n#             elif path[-1] + path[-2] == int(S[:i]):\n#                 path.append(int(S[:i]))\n#                 if self.dfs(res, S[i:], path):\n#                     return True\n#                 path.pop()\n                \n        # second try\n        res = []\n        self.dfs(res, S, 0, [])\n        return res[0] if res else []\n    \n    def dfs(self, res, S, index, path):\n        # print(path)\n        if index == len(S) and len(path) >= 3:\n            res.append(path[:])\n            return\n        \n        for i in range(index+1, len(S)+1):\n            if (i > index + 1 and S[index] == '0') or int(S[index:i]) > 2**31 - 1:\n                return\n            temp_num = int(S[index:i])\n            if (len(path) >= 2 and temp_num == path[-1] + path[-2]) or len(path) < 2:\n                path.append(temp_num)\n                self.dfs(res, S, i, path)\n                path.pop()\n\n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        \n        if len(S) < 2: return []\n    \n        def dfs(s, path, res):\n\n            if not s:\n                if len(path) >= 3:\n                    res.append(path)\n                    if not res:\n                        return \n\n            for  i in range(len(s)):\n                \n                if (len(s[:i+1]) > 1 and s[0]==\\\"0\\\") or int(s[:i+1]) > 2**31-1:\n                    continue \n                    \n                if len(path) < 2:\n                    dfs(s[i+1:], path + [s[:i+1]], res)\n                else:\n                    if int(path[-2]) + int(path[-1]) == int(s[:i+1]):\n                        dfs(s[i+1:], path +[s[:i+1]], res)\n        res = []               \n        dfs(S,[], res)\n        return res[0] if res else []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def isFib(i, a, b, count):\n            if i == len(S):\n                return [] if count >= 3 else None\n            if a > (1<<31) - 1 or b > (1<<31) - 1 or a + b > (1<<31):\n                return None\n            if S[i:i+1] == ['0'] and a != 0:\n                return False\n            j = i + len(str(a))\n            if S[j:j+1] == ['0'] and b != 0:\n                return False\n            if S[i:i+len(str(a+b))] != str(a+b):\n                return False\n            rest =  isFib(i+ len(str(a+b)), b, a+b, count + 1)\n            if rest or rest == []:\n                return [a+b] + rest\n        \n        for len_a in range(1, len(S)):\n            for len_b in range(1, len(S)):\n                str_a  = S[:len_a]\n                str_b  = S[len_a:len_a + len_b]\n                a, b = int(str_a), int(str_b)\n                if a > (1<<31) - 1 or b > (1<<31) - 1:\n                    continue\n                if (str_a[0] == '0' and len_a > 1) or (str_b[0] == '0' and len_b > 1):\n                    continue\n                val = isFib(len_a + len_b, int(S[:len_a]), int(S[len_a:len_a + len_b]), 2 )\n                if val: return [int(str_a), int(str_b)] + val\n                if S[0] == '0':\n                    break\n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        N = len(S)\n        \n        for i, j in itertools.combinations(range(1, N), 2):\n            a, b = S[:i], S[i:j]\n            if(str(int(a)) != a or str(int(b)) != b or int(a) > 2**31-1 or int(b) > 2**31-1):\n                continue\n            res = []\n            res.append(a)\n            while(j < N):\n                c = str(int(a)+int(b))\n                if(not S.startswith(c, j) or int(c) > 2**31-1):\n                    res = []\n                    break\n                res.append(b)\n                a, b = b, c\n                j += len(c)\n            res.append(c)\n            if(j == N):\n                return res\n        return []", "class Solution:\n    def validFib(self, S, n1, n2, i, ret):\n        \n        if (n1[0] != '0' and len(n1) >= 1) or n1 == '0':\n            num1 = int(n1)\n        else:\n            return False\n        if (n2[0] != '0' and len(n2) >= 1) or n2 == '0':\n            num2 = int(n2)\n        else:\n            return False\n        \n        num3 = num1 + num2\n        # if num1 == 123 and num2 == 456:\n        #     print(num3, i)\n        n3 = str(num3)\n        \n        j = 0\n        while j + i < len(S) and j < len(n3):\n            c1 = n3[j]\n            c2 = S[j+i]\n            if c1 != c2:\n                return False\n            j += 1\n        \n        if len(n1) + len(n2) + len(n3) > len(S):\n            return False\n        \n        if i + len(n3) == len(S) and num3 <= 2**31 - 1:\n            ret.append(str(num3))\n            return True\n        \n        if self.validFib(S, n2, n3, i+len(n3), ret) and num3 <= 2**31 - 1:\n            ret.append(str(num3))\n            return True\n        \n        return False\n    \n    \n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        \n        ret = []\n        \n        # print(\\\"01\\\".isnumeric())\n        \n        i = 0\n        while i < len(S):\n            j = 1\n            while i + j < len(S):\n                n1 = S[ : i+1]\n                n2 = S[i+1 : i+j+1]\n                # print(n1, n2)\n                if self.validFib(S, n1, n2, i+j+1, ret):\n                    ret.append(n2)\n                    ret.append(n1)\n                    return reversed(ret)\n                \n                j += 1\n            i += 1\n        \n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        N = 2 ** 31 - 1\n        \n        def dfs(s, path, res):\n            if not s and len(path) > 2:\n                res.append(path)\n                return\n            for i in range(len(s)):\n                if len(s[:i + 1]) != len(str(int(s[:i + 1]))) or int(s[:i + 1]) > N: continue\n                if len(path) < 2: dfs(s[i + 1:], path + [s[:i + 1]], res)\n                elif len(path) > 1 and int(s[:i + 1]) == int(path[-1]) + int(path[-2]):\n                    dfs(s[i + 1:], path + [s[:i + 1]], res)\n        \n        res, ans = [], []\n        dfs(S, [], res)\n        if not res: return []\n        for elem in res[0]:\n            ans.append(int(elem))\n        return ans\n            \n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        N = 2 ** 31 - 1\n        \n        def dfs(s, path, res):\n            if not s and len(path) > 2:\n                res.append(path)\n                return\n            for i in range(len(s)):\n                if len(s[:i + 1]) != len(str(int(s[:i + 1]))) or int(s[:i + 1]) > N: continue\n                if len(path) < 2: dfs(s[i + 1:], path + [s[:i + 1]], res)\n                elif len(path) > 1 and int(s[:i + 1]) == int(path[-1]) + int(path[-2]):\n                    dfs(s[i + 1:], path + [s[:i + 1]], res)\n        \n        res, ans = [], []\n        dfs(S, [], res)\n        print(res)\n        if not res: return []\n        for elem in res[0]:\n            ans.append(int(elem))\n        return ans\n            \n", "class Solution:\n    def splitIntoFibonacci(self, S: str):\n        self.res = []\n        self.dfs(S, [], 0)\n        return self.res\n    \n    def dfs(self, S, temp, count):\n        if not S and count >= 3:\n            self.res = temp[:]\n            return\n        for step in range(1, len(S)+1):\n            val = S[:step]\n            if str(int(val)) == val and 0 <= int(val) <= pow(2, 31) - 1: # \u9632\u6b62\u524d\u5bfc 0 \u7684\u51fa\u73b0\n                if count < 2:\n                    temp.append(int(val))\n                    self.dfs(S[step:], temp, count+1)\n                    temp.pop()\n                elif temp[count-2] + temp[count-1] == int(val):\n                    temp.append(int(val))\n                    self.dfs(S[step:], temp, count+1)\n                    temp.pop()", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        result = []\n        # return arry contains list of possible start in form (num1,num2, start of remain)\n        def getStarter():\n            arr = []\n            for i in range(1,len(S)-1):\n                for j in range(i+1,len(S)):\n                    s1,s2 = S[:i],S[i:j]\n                    if (s1[0] == '0' and len(s1)>1) or (s2[0] == '0' and len(s2)>1):\n                        continue\n                    arr.append((int(s1),int(s2),j))\n            return arr\n\n        def dfs(arr, start):\n            if start == len(S) and len(arr) >=3:\n                result.append(arr)\n                return True\n            sum = arr[-2] + arr[-1]\n            # get next possible target by len of sum\n            length = len(str(sum))\n            nextNum = int(S[start:start+length])\n            if 0 <= sum <= mx and nextNum == sum:\n                return dfs(arr+[sum], start+length)\n        \n        arr = getStarter()\n        mx = 2**31-1\n        for num1,num2,start in arr:\n            if dfs([num1,num2],start):\n                return result\n        return []\n\n            \n\n            \n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        # Time  complexity: O(N^2)\n        # Space complexity: O(N)\n        L, T, t = len(S), \\\"\\\", []\n        for i in range(1, L - 2):\n            for j in range(1, L - i -1):\n                if i > 1 and S[0] == '0' or j > 1 and S[i] == '0':\n                    continue\n                a, b = int(S[:i]), int(S[i:i+j])\n                T, t = S[:i+j], [a, b]\n                while len(T) < L:\n                    c = a + b\n                    T += str(c)\n                    t += [c]\n                    a, b = b, c\n                if len(T) == L and T == S and len(t) > 2 and t[-1] < 2**31 -1:\n                    return t\n\n        return []\n        ", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def getStarter():\n            arr = []\n            for i in range(1, len(S) - 1):\n                for j in range(i + 1, len(S)):\n                    s1, s2 = S[:i], S[i:j]\n                    if (s1[0] == \\\"0\\\" and len(s1) > 1) or (s2[0] == \\\"0\\\" and len(s2) > 1): \n                        continue\n                    arr.append((int(s1), int(s2), j))\n            return arr                 \n        def dfs(arr, i):\n            if i == len(S):\n                return arr\n            sm = arr[-2] + arr[-1]\n            l = len(str(sm))\n            new = int(S[i:i + l])\n            return new == sm and 0 <= sm <= mx and dfs(arr + [new], i + l)\n        q, mx = getStarter(), 2 ** 31 - 1\n        for p1, p2, i in q:\n            seq = dfs([p1, p2], i)\n            if seq:\n                return seq\n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        ans = []\n        limit = 2**31 - 1\n        def helper(n, prefix):\n            nonlocal S, ans\n            if n == len(S):\n                ans = prefix\n                return\n            num = sum(prefix[-2:])\n            if S[n:].startswith(str(num)) and num <= limit:\n                return helper(n + len(str(num)), prefix + [num])\n        for i in range(2, min(20, len(S) * 2 // 3 + 1)):\n            for j in range(max(1, i-10), min(i, 10)):\n                helper(i, [int(S[:j]), int(S[j:i])])\n                if ans: break\n            if ans: break\n        return ans", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        L, T, t = len(S), \\\"\\\", []\n        for i in range(1,L-2):\n        \\tfor j in range(1,L-i-1):\n        \\t\\tif (i > 1 and S[0] == '0') or (j > 1 and S[i] == '0'): continue\n        \\t\\ta, b = int(S[:i]), int(S[i:i+j])\n        \\t\\tT, t = S[:i+j], [a,b]\n        \\t\\twhile len(T) < L:\n        \\t\\t\\tc = a + b\n        \\t\\t\\tT += str(c)\n        \\t\\t\\tt += [c]\n        \\t\\t\\ta, b = b, c\n        \\t\\tif len(T) == L and T == S and len(t) > 2 and t[-1] < 2**31 - 1: return t\n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def getfirst():\n            pairs = []\n            for i in range(1, len(S)-2):\n                for j in range(i+1, len(S)-1):\n                    pairs.append((i, j))\n            return pairs\n                    \n        def helper(s, e):\n            ans = [S[:s], S[s:e]]\n            newS = S[e:]\n            while newS:\n                nex = int(ans[-1]) + int(ans[-2])\n                nex = str(nex)\n                if int(nex) >= 2**31:\n                    return\n                # if nex != '0' and nex[0] == '0':\n                #     return \n                if newS[:len(nex)] == nex:\n                    newS = newS[len(nex):]\n                    ans += nex,\n                else:\n                    return\n            return ans\n        \n        pairs = getfirst()\n        for s, e in pairs:\n            ans = helper(s, e)\n            if ans:\n                return ans\n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        \n        for i, l in enumerate(S): \n            \n            if str(int(S[:i+1])) == S[:i+1]:\n                \n                for j in range(i+1, len(S)-1): \n                    \n                    if str(int(S[i+1:j+1])) == S[i+1:j+1]: \n                        \n                        pre, cur = int(S[:i+1]), int(S[i+1:j+1])\n                        res = [pre, cur]\n                        \n                        start = j+1 \n                        while start < len(S):\n                            nxt = str(pre+cur)\n                            length = len(nxt)\n                            if pre + cur <= 2**31 -1  and S.startswith(nxt, start):\n                                \n                                pre, cur = cur, int(S[start: start+length])\n                                res += cur,\n                                start += length\n                            \n                            else:\n                                break \n                        else:\n                            return res\n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        for i in range(len(S)):\n            for j in range(len(S)):\n                arr=[]\n                if(S[0:i+1][0]=='0' and len(S[0:i+1])>=2):\n                    break\n                arr.append(int(S[0:i+1]))\n                if(S[i+1:i+j+1]!=''):\n                    arr.append(int(S[i+1:i+j+1]))\n                flag=0\n                k=i+j+1\n                while(k < len(S)):\n                    if(len(arr) > 1):\n                        val=arr[-1]+arr[-2]\n                        if(k+len(str(val)) > len(S) or str(val)!=S[k:k+len(str(val))]):\n                            flag=1\n                            break\n                        else:\n                            k+=len(str(val))\n                            arr.append(val)\n                    else:\n                        flag=1\n                        break\n                if(flag==0):\n                    if(len(arr)>2):\n                        for i in arr:\n                            if(i<0 or i>2**31-1):\n                                return []\n                        return arr\n        if(len(arr)<=2):\n            return []\n        return arr\n                        \n                        \n                \n                    \n                    \n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        for i in range(len(S)):\n            for j in range(len(S)):\n                arr=[]\n                if(S[0:i+1][0]=='0' and len(S[0:i+1])>=2):\n                    continue\n                arr.append(int(S[0:i+1]))\n                if(S[i+1:i+j+1]!=''):\n                    arr.append(int(S[i+1:i+j+1]))\n                flag=0\n                k=i+j+1\n                while(k < len(S)):\n                    if(len(arr) > 1):\n                        val=arr[-1]+arr[-2]\n                        if(k+len(str(val)) > len(S) or str(val)!=S[k:k+len(str(val))]):\n                            flag=1\n                            break\n                        else:\n                            k+=len(str(val))\n                            arr.append(val)\n                    else:\n                        flag=1\n                        break\n                if(flag==0):\n                    if(len(arr)>2):\n                        for i in arr:\n                            if(i<0 or i>2**31-1):\n                                return []\n                        return arr\n        if(len(arr)<=2):\n            return []\n        return arr\n                        \n                        \n                \n                    \n                    \n", "#\n# @lc app=leetcode id=842 lang=python3\n#\n# [842] Split Array into Fibonacci Sequence\n#\n# https://leetcode.com/problems/split-array-into-fibonacci-sequence/description/\n#\n# algorithms\n# Medium (35.93%)\n# Likes:    481\n# Dislikes: 168\n# Total Accepted:    20.5K\n# Total Submissions: 56.4K\n# Testcase Example:  '\\\"123456579\\\"'\n#\n# Given a string S\u00a0of digits, such as S = \\\"123456579\\\", we can split it into a\n# Fibonacci-like sequence\u00a0[123, 456, 579].\n# \n# Formally, a Fibonacci-like sequence is a list\u00a0F of non-negative integers such\n# that:\n# \n# \n# 0 <= F[i] <= 2^31 - 1, (that is,\u00a0each integer fits a 32-bit signed integer\n# type);\n# F.length >= 3;\n# and F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.\n# \n# \n# Also, note that when splitting the string into pieces, each piece must not\n# have extra leading zeroes, except if the piece is the number 0 itself.\n# \n# Return any Fibonacci-like sequence split from S, or return [] if it cannot be\n# done.\n# \n# Example 1:\n# \n# \n# Input: \\\"123456579\\\"\n# Output: [123,456,579]\n# \n# \n# Example 2:\n# \n# \n# Input: \\\"11235813\\\"\n# Output: [1,1,2,3,5,8,13]\n# \n# \n# Example 3:\n# \n# \n# Input: \\\"112358130\\\"\n# Output: []\n# Explanation: The task is impossible.\n# \n# \n# Example 4:\n# \n# \n# Input: \\\"0123\\\"\n# Output: []\n# Explanation: Leading zeroes are not allowed, so \\\"01\\\", \\\"2\\\", \\\"3\\\" is not\n# valid.\n# \n# \n# Example 5:\n# \n# \n# Input: \\\"1101111\\\"\n# Output: [110, 1, 111]\n# Explanation: The output [11, 0, 11, 11] would also be accepted.\n# \n# \n# Note: \n# \n# \n# 1 <= S.length\u00a0<= 200\n# S contains only digits.\n# \n# \n#\n\nclass Solution:\n    def splitIntoFibonacci(self, S):\n        \\\"\\\"\\\"\n        :ref: https://leetcode.com/problems/split-array-into-fibonacci-sequence/discuss/143035/Same-Problem-as-306-Python-simple-and-short-DFS-solution\n        \\\"\\\"\\\"\n        def getStarter():\n            arr = []\n            for i in range(1, len(S) - 1):\n                for j in range(i + 1, len(S)):\n                    s1, s2 = S[:i], S[i:j]\n                    if (s1[0] == \\\"0\\\" and len(s1) > 1) or (s2[0] == \\\"0\\\" and len(s2) > 1): \n                        continue\n                    arr.append((int(s1), int(s2), j))\n            return arr                 \n        def dfs(arr, i):\n            if i == len(S):\n                return arr\n            sm = arr[-2] + arr[-1]\n            l = len(str(sm))\n            new = int(S[i:i + l])\n            return new == sm and 0 <= sm <= mx and dfs(arr + [new], i + l)\n        q, mx = getStarter(), 2 ** 31 - 1\n        for p1, p2, i in q:\n            seq = dfs([p1, p2], i)\n            if seq:\n                return seq\n        return []\n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def split(N,s):\n            if not s: \n                return N\n\n            c = sum(N[-2:])\n            if s.startswith(str(c)):\n                return split(N + [c], s[len(str(c)):])\n\n        for i in range(1,len(S)):\n            for j in range(i+1, len(S)):\n                a = int(S[:i])\n                b = int(S[i:j])\n                if str(a) == S[:i] and str(b) == S[i:j]:\n                    ans = split([a, b], S[j:])\n                    if ans and all(x<=2**31-1 for x in ans):\n                        return ans\n                \n        return []", "class Solution:\n    def splitIntoFibonacci(self, s: str) -> List[int]:\n        def isTrue(a,b,s):\n            if len(str(a)+str(b)+s) != self.n:return []\n            l = [a,b]\n            while True:\n                c = str(a + b)\n                if int(c) > 2147483647:return []\n                l.append(int(c))\n                if c == s[:len(c)]:\n                    a = b;b = int(c)\n                    s = s[len(c):]\n                    if s == '':return l\n                else:return []\n        self.n = len(s)\n        for i in range(1,len(s)):\n            for j in range(i):\n                l = isTrue(int(s[0:j+1]),int(s[j+1:i+1]),s[i+1:])\n                if l:return l\n        return []\n", "class Solution:\n    def splitIntoFibonacci(self, s: str) -> List[int]:\n        def isTrue(a,b,s):\n            if len(str(a)+str(b)+s) != self.n:return []\n            l = [a,b]\n            while True:\n                c = str(a + b)\n                if int(c) > 2147483647:return []\n                l.append(int(c))\n                if c == s[:len(c)]:\n                    a = b;b = int(c)\n                    s = s[len(c):]\n                    if s == '':return l\n                else:return []\n        self.n = len(s)\n        for i in range(1,len(s)):\n            for j in range(i):\n                l = isTrue(int(s[0:j+1]),int(s[j+1:i+1]),s[i+1:])\n                if l:return l\n        return []", "class Solution:\n    def get_num(self, S, i, j, cache):\n        if i == j:\n            return int(S[i])\n        key = '{}-{}'.format(i, j)\n        if key in cache:\n            return cache[key]\n        v = int(S[i:j+1])\n        cache[key] = v\n        return v\n    \n    def check(self, st, v):\n        if v > 2**31-1:\n            return False\n        if len(st) < 2:\n            return True\n        return st[-2] + st[-1] == v\n    \n    def get_st_key(self, st):\n        k1 = None\n        k2 = None\n        ln = len(st)\n        if ln == 0:\n            pass\n        elif ln == 1:\n            k1 = st[-1]\n        else:\n            k1 = st[-1]\n            k2 = st[-2]\n            if k1 > k2:\n                k1, k2 = k2, k1\n        return '{}-{}'.format(k1, k2)\n    \n    def split(self, S, i, st, res, cache, cache_res):\n        # print(i, st, res)\n        ln = len(S)\n        if i >= ln:\n            if len(st) >= 3:\n                res[0] = list(st)\n                return True\n            return False\n        key = self.get_st_key(st)\n        if key in cache_res:\n            return cache_res[key]\n        res_local = False\n        if S[i] == '0':\n            new_v = 0\n            if self.check(st, new_v):\n                st.append(new_v)\n                res_local = self.split(S, i+1, st, res, cache, cache_res)\n                del st[-1]\n        else:\n            for j in range(i, len(S)):\n                new_v = self.get_num(S, i, j, cache)\n                if self.check(st, new_v):\n                    st.append(new_v)\n                    res_local = self.split(S, j+1, st, res, cache, cache_res)\n                    del st[-1]\n                    if res_local:\n                        break\n                if len(st) >= 2 and new_v > st[-2] + st[-1]:\n                    break\n        cache_res[key] = res_local\n        return res_local\n            \n    \n    def solve(self, S):\n        res = [None]\n        self.split(S, 0, [], res, {}, {})\n        if res[0] is None:\n            return []\n        # st = res[0]\n        # for i in range(2, len(st)):\n        #     if st[i-2] + st[i-1] != st[i]:\n        #         print('aha!')\n        # ln = 0\n        # for num in st:\n        #     ln += len(str(num))\n        # if ln != len(S):\n        #     print('wrong len!')\n        return res[0]\n    \n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        return self.solve(S)", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        if len(S) < 3: return []\n        for i in range(1, len(S) - 2):\n            first = S[:i]\n            for j in range(i, len(S) - 1):\n                j += 1\n                second = S[i:j]\n                split = self.dfs(first, second, S[j:], [first, second])\n                if split: return split\n                \n        return []\n    \n    def notvalid(self, s):\n        if int(s) != 0 and s[0] == 0:\n            return True\n        if int(s) > 2**31 - 1:\n            return True\n        return False\n\n    \n    def dfs(self, s1, s2, rem, seq):\n        s3 = str(int(s1) + int(s2))\n        if self.notvalid(s3): return []\n        l = len(s3)\n        if rem[:l] == s3:\n            seq.append(s3)\n            if len(rem) > l:\n                return self.dfs(s2, s3, rem[l:], seq)\n            else:\n                return seq\n        return []\n", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        res = []\n        max_len = len(S) // 3 + 1\n            \n        def add_fibonacci(x, left):\n            # print(x)\n            # print(left)\n            temp1 = x[0]\n            temp2 = x[1]\n            res = None\n            res_left = left\n            for i in range(len(left)):\n                temp3 = int(left[:i + 1])\n                if temp3 == temp1 + temp2 and temp3 < 2 ** 31 - 1:\n                    # print(temp3)\n                    res = temp3\n                    res_left = res_left[i + 1:]\n                    break\n                elif temp3 > temp1 + temp2:\n                    break\n            # print(res, res_left)\n            return res, res_left\n            \n        for i in range(1, max_len + 1):\n            c1 = S[0:i]\n            if len(c1) > 1 and c1[0] == '0':\n                break\n            for j in range(i + 1, max_len + i + 1):\n                c2 =S[i:j]\n                if len(c2) > 1 and c2[0] == '0':\n                    break\n                # next_length = max(len(c1), len(c2))\n                next_index = j\n                left = S[next_index:]\n                res.append(int(c1))\n                res.append(int(c2))\n                while len(left) > 0:\n                    # print(res)\n                    # print(res[-2:])\n                    temp, left = add_fibonacci(res[-2:], left)\n                    if temp is None:\n                        res.clear()\n                        break\n                    res.append(temp)\n                #     print(res, left, len(left))\n                # print(res)\n                if len(res) > 0:\n                    break\n                res.clear()\n            if len(res) > 0:\n                break\n            \n            res.clear()\n        return res", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        \n        for i, l in enumerate(S): \n            \n            if str(int(S[:i+1])) == S[:i+1]:\n                \n                for j in range(i+1, len(S)-1): \n                    \n                    if str(int(S[i+1:j+1])) == S[i+1:j+1]: \n                        \n                        pre, cur = int(S[:i+1]), int(S[i+1:j+1])\n                        res = [pre, cur]\n                        \n                        start = j+1 \n                        while S.startswith(str(pre + cur), start):\n                            length = len(str(pre+cur)) \n                            pre, cur = cur, int(S[start: start+length])\n                            res += cur,\n                            start += length \n            \n                            if start >= len(S): \n                                return res\n                            \n                            if pre + cur >= 2**31:\n                                break \n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        n = len(S)\n               \n        for i, j in itertools.combinations(range(1, n), 2):\n            res = []\n            a, b = S[:i], S[i:j]\n            #if b != str(int(b)):\n            if a != str(int(a)) or b != str(int(b)):\n                continue\n            res.append(int(a))\n            res.append(int(b))\n            while j < n:\n                c = str(int(a) + int(b))\n                if not S.startswith(c, j):\n                    break\n                res.append(int(c))\n                j += len(c)\n                a, b = b, c\n            if j == n:\n                for item in res:\n                    if item > 2**31 -1:\n                        return []\n                return res\n        return []", "class Solution:\n    def splitIntoFibonacci(self, S):\n        def getStarter():\n            arr = []\n            for i in range(1, len(S) - 1):\n                for j in range(i + 1, len(S)):\n                    s1, s2 = S[:i], S[i:j]\n                    if (s1[0] == \\\"0\\\" and len(s1) > 1) or (s2[0] == \\\"0\\\" and len(s2) > 1): \n                        continue\n                    arr.append((int(s1), int(s2), j))\n            return arr                 \n        def dfs(arr, i):\n            if i == len(S):\n                return arr\n            sm = arr[-2] + arr[-1]\n            l = len(str(sm))\n            new = int(S[i:i + l])\n            return new == sm and 0 <= sm <= mx and dfs(arr + [new], i + l)\n        q, mx = getStarter(), 2 ** 31 - 1\n        for p1, p2, i in q:\n            seq = dfs([p1, p2], i)\n            if seq:\n                return seq\n        return []", "class Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        \n        S_len = len(S)\n        res = []\n        prev = None\n        \n        def check(index, prev_back, prev):\n            if index == S_len:\n                return ['#']\n            \n            buffer = \\\"\\\"\n            \n            for i in range(index, S_len, 1):\n                \n                if S[index] == '0' and i - index > 0:\n                    break\n                \n                buffer += S[i]\n                buffer_int = int(buffer)\n                \n                if buffer_int > 2**31 - 1:\n                    break\n                \n                if buffer_int == prev_back + prev:\n                    x = check(i + 1, prev, buffer_int)\n                    if x:\n                        return [buffer_int] + x\n                    \n                elif buffer_int > prev_back + prev:\n                    break\n                    \n            return []\n        \n        for i in range(0, S_len - 2, 1):\n            \n            if S[0] == '0' and i + 1 > 1:\n                break\n            \n            for j in range(i+1, S_len - 1, 1):\n                \n                if S[i+1] == '0' and j - i > 1:\n                    break\n                \n                prev_back = int(S[:i + 1])\n                prev = int(S[i+1 : j+1])\n                \n                x = check(j + 1, prev_back, prev)\n                if x:\n                    return [prev_back, prev] + x[:-1]\n                \n            \n        return []\n                ", "#\n# @lc app=leetcode id=842 lang=python3\n#\n# [842] Split Array into Fibonacci Sequence\n#\nclass Solution:\n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        size = len(S)\n        if size < 3: return []\n        INT_MAX = (1 << 31) - 1\n        def dfs(start, expect, prev, res):\n            if start >= size: return len(res) >= 3\n            for end in range(start, size):\n                number = S[start:end+1]\n                if len(number) > 1 and number[0] == '0': break\n                num = int(number)\n                if num > INT_MAX: break\n                if num == expect:\n                    res.append(num)\n                    if dfs(end + 1, expect + prev, expect, res):\n                        return True\n                    else:\n                        res.pop()\n                        break\n                elif num > expect: break\n            return False\n        for end in range(1, size):\n            for mid in range(end):\n                if S[0] == '0' and mid != 0: continue\n                if S[mid+1] == '0' and end != mid + 1: continue\n                first = int(S[:mid+1])\n                second = int(S[mid+1:end+1])\n                res = [first, second]\n                if dfs(end + 1, second + first, second, res):\n                    return res\n        return []\n\n", "class Solution:\n    def splitIntoFibonacci(self, s: str) -> List[int]:\n        result = []\n        n = len(s)\n        \n        self.backtrack(s, 0, n, [], result)\n        \n        return result\n    \n    def backtrack(self, s, left, n, currArr, result):        \n        if len(currArr) > 2:\n            if currArr[-1] != currArr[-2] + currArr[-3]:\n                return False\n            else:\n                if left >= n:\n                    result.append(currArr)\n                    return True\n        \n        for i in range(left, n):\n            \n            if (s[left] == \\\"0\\\" and i != left) or int(s[left:i+1]) > (2**31)-1:\n                return False\n                \n            newArr = currArr.copy()\n            newArr.append(int(s[left:i+1]))\n            \n            if (len(newArr) > 2):\n                if (newArr[-1] != newArr[-2] + newArr[-3]):\n                    continue\n            \n            res = self.backtrack(s, i+1, n, newArr, result)\n            \n            if res == True:\n                return True\n            ", "class Solution:\n    def splitIntoFibonacci(self, S: str):    \n        max_len = len(S)\n        for first_size in range(1, max_len-1):\n            for second_size in range(1, max_len-1-first_size):\n                res = self.test(S, first_size, second_size)\n                if len(res) >= 3 and int(res[-1]) <  2 ** 31 - 1:\n                    return res\n        return []\n        \n    def test(self, s, first_size, second_size):\n        cursor = 0\n        fibo = []\n        \n        first_number = int(s[:first_size])\n        if first_size != len(str(first_number)):\n            return []\n        \n        fibo.append(str(first_number))\n        cursor += first_size\n        \n        second_number = int(s[cursor:cursor+second_size])\n        fibo.append(str(second_number))\n        cursor += second_size\n        \n        while cursor <= len(s)-1:\n            possible_next = first_number + second_number\n            len_next = len(str(possible_next))\n            \n            next_number = int(s[cursor:cursor+len_next])\n            \n            if cursor+len_next > len(s):\n                return []\n            elif not next_number == possible_next:\n                return []\n            \n            fibo.append(str(next_number))\n            \n            first_number, second_number = second_number, next_number\n            cursor += len_next \n                \n        return fibo", "class Solution:\n    def splitIntoFibonacci(self, s: str) -> List[int]:\n        \n        def dfs(start, string, sequence):\n            if start==len(string):\n                if len(sequence)>2:\n                    return sequence\n                return None\n            \n            num = 0\n            for i in range(start, len(string)):\n                if i!=start and string[start] == '0':\n                    return None\n                num  = num*10 + ord(string[i]) - ord('0')\n                if num>=2**31:\n                    break\n                if len(sequence)>1 and sequence[-1] + sequence[-2] != num:\n                    continue\n                    \n                sequence.append(num)\n                seq = dfs(i+1, string, sequence)\n                if seq != None:\n                    return seq\n                sequence.pop()   \n        \n        \n        \n        for  sticks in range(2, len(s)):\n            seq = dfs(0, s, [])\n            if seq:\n                return seq\n        return []", "class Solution:\n    def __init__(self):\n        self.res = []\n    \n    def splitIntoFibonacci(self, S: str) -> List[int]:\n        def helper(pos, temp):\n            if pos == len(S): \n                if len(temp) > 2:\n                    self.res = temp[:]\n                return \n            if S[pos] == '0':\n                if len(temp) > 1:\n                    if temp[-1] + temp[-2] != 0:\n                        return\n                temp.append(0)\n                helper(pos + 1, temp)\n                temp.pop()\n            else:\n                for i in range(pos + 1, len(S) + 1):\n                    curr = int(S[pos : i])\n                    if len(temp) < 2:\n                        temp.append(curr)\n                        helper(i, temp)\n                        temp.pop()\n                    else:\n                        if curr > temp[-1] + temp[-2] or curr > 2 ** 31 - 1:\n                            return\n                        if curr == temp[-1] + temp[-2]:\n                            temp.append(curr)\n                            helper(i, temp)\n                            temp.pop()\n        helper(0, [])\n        return self.res"]
["class Solution:\n     def minWindow(self, s, t):\n         \"\"\"\n         :type s: str\n         :type t: str\n         :rtype: str\n         \"\"\"\n         left=-1\n         right = 0\n         result = \"\"\n         totalMatch = 0\n         d = {}\n         for c in t:\n             d[c] = d.get(c, 0) + 1\n \n         for right in range(len(s)):\n             c = s[right]\n             d[c] = d.get(c, 0) - 1\n \n             # good match\n             if d[c] >=0:\n                 totalMatch +=1\n \n                 #over match \u53ef\u4ee5\u4e0d\u79fb\u52a8left\n                 #total match, need to advance left\n                 if totalMatch == len(t):\n                     totalMatch -= 1\n \n                     left +=1\n                     while d[s[left]]<0:\n                         d[s[left]] += 1\n                         left += 1\n \n                     # we dec the count here so that next round right need to match one more s[left], \n                     d[s[left]] += 1\n \n                     if result == \"\" or len(result) > right - left:\n                         result = s[left: right+1]\n \n         return result", "class Solution:\n     def minWindow(self, s, t):\n         \"\"\"\n         :type s: str\n         :type t: str\n         :rtype: str\n         \"\"\"\n         table = {}\n         for c in t:\n             table[c] = table[c] + 1 if c in table else 1\n         start, end, count = 0, 0, len(t)\n         min_start, min_end = None, None\n         for i in range(len(s)):\n             if s[i] in table:\n                 if table[s[i]] > 0:\n                     count -= 1\n                 table[s[i]] -= 1\n             if count == 0:\n                 while count == 0:\n                     if s[start] in table:\n                         if table[s[start]] >= 0:\n                             count += 1\n                             if min_start == None or i - start < min_end - min_start:\n                                 min_start, min_end = start, i\n                         table[s[start]] += 1\n                     start += 1\n         if min_start == None:\n             return \"\"\n         else:\n             return s[min_start:(min_end + 1)]\n         \n         '''\n         def check(m, n, mode=1):\n             table = dict(zip(t, [0]*len(t)))\n             for i in range(m, n+1):\n                 if s[i] in table:\n                     if mode == 1 and table[s[i]] != None:\n                         continue\n                     else:\n                         table[s[i]] = i\n \n             a, b = None, None\n             for k, v in table.items():\n                 if v == None:\n                     return 0, 0, False\n                 if a == None or a > v:\n                     a = v\n                 if b == None or b < v:\n                     b = v\n             return a, b, True\n         \n         first, last, result = check(0, len(s)-1, 1)\n         if not result:\n             return False\n         a, b = first, last\n         for i in range(last+1, len(s)):\n             t_a, t_b, result = check(i-(b-a+1), i, 2)\n             if result == True:\n                 a, b = t_a, t_b\n         \n         return s[a:(b+1)]\n         '''\n", "class Solution:\n     def minWindow(self, s, t):\n         \"\"\"\n         :type s: str\n         :type t: str\n         :rtype: str\n         \"\"\"\n         # assume t doesn't have duplicated chars\n         left=-1\n         right = 0\n         result = \"\"\n \n         totalMatch = 0\n         d = {}\n         for c in t:\n             d[c] = d.get(c, 0) + 1\n \n         for right in range(len(s)):\n             c = s[right]\n             if c in d:\n                 d[c]-=1\n                 if d[c] >=0:\n                     # good match\n                     totalMatch +=1\n \n                     if left == -1:\n                         left = right\n \n                     #find a sustring\n                     if totalMatch == len(t):\n                         if result == \"\" or len(result) > right - left:\n                             result = s[left: right+1]\n \n                         d[s[left]]+=1\n                         totalMatch -=1\n                         while left<right:\n                             left +=1\n \n                             if s[left] in d:\n                                 if d[s[left]] <0:\n                                     # skip over matched letter\n                                     d[s[left]] +=1\n                                 else:\n                                     break\n                 \n                 elif c == s[left]:\n                     d[c]+=1\n                     while left < right:\n                         left +=1\n                         # skip over matched letter\n                         if s[left] in d:\n                             if d[s[left]] <0:\n                                 d[s[left]] +=1\n                             else:\n                                 break\n         return result", "class Solution:\n     def minWindow(self, s, t):\n         \"\"\"\n         :type s: str\n         :type t: str\n         :rtype: str\n         \"\"\"\n         if len(t) > len(s):\n             return \"\"\n         dic = {}\n         for i in t:\n             if i in dic:\n                 dic[i] += 1\n             else:\n                 dic[i] = 1\n         counter = len(dic)\n         start = end = 0\n         minl = len(s)+1\n         res = \"\"\n         \n         while end < len(s):\n             j = s[end]\n             if j in dic:\n                 dic[j] -= 1\n                 if dic[j] == 0:\n                     counter -= 1\n             end += 1\n             while counter == 0:\n                 i = s[start]\n                 if i in dic:\n                     dic[i] += 1\n                     if dic[i] > 0:\n                         counter += 1\n                     if end-start < minl:\n                         minl = end-start\n                         res = s[start:end]\n                 start += 1\n         return res\n             \n             \n             \n             \n             \n             \n             \n             \n             \n             \n             \n             \n             \n"]
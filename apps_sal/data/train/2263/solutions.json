["#!/usr/bin/env python3\n\n\nM = 998244353\n\ndef powmod(a, x, m = M):\n    y = 1\n    while 0 < x:\n        if x % 2 == 1:\n            y *= a\n            y %= m\n        x //= 2\n        a = a ** 2\n        a %= m\n\n    return y\n\n\ndef solve(s):\n    n = len(s)\n\n    nb = nc = 0\n    ch = s[0]\n    if ch == 'b':\n        nb += 1\n    elif ch == 'c':\n        nc += 1\n    sf = True\n    tf = True\n    left = ch\n    for ch in s[1:]:\n        if ch == 'b':\n            nb += 1\n        elif ch == 'c':\n            nc += 1\n        if ch == left:\n            sf = False\n        else:\n            tf = False\n        left = ch\n\n\n    if tf:\n        return 1\n    if n == 3:\n        if (nb + nc * 2) % 3:\n            return 7 if sf else 6\n        else:\n            return 3\n    if n % 3:\n        return (powmod(3, n - 1) + M - powmod(2, n - 1) + (1 if sf else 0)) % M\n    else:\n        if (nb + nc * 2) % 3:\n            return (powmod(3, n - 1) + M - (powmod(2, n - 1) - powmod(2, n // 3 - 1)) + (1 if sf else 0)) % M\n        else:\n            return (powmod(3, n - 1) + M - (powmod(2, n // 3) + 4 * powmod(8, n // 3 - 1)) + (1 if sf else 0)) % M\n\ndef main():\n    s = input()\n\n    print((solve(s)))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "import itertools\n\nS = input()\nN = len(S)\nif all(S[0] == c for c in S):\n    print((1))\n    return\nif N == 2:\n    print((1 if S[0]==S[1] else 2))\n    return\n\nif N == 3:\n    def another(a,b):\n        s = set('abc')\n        s -= set([a,b])\n        return list(s)[0]\n    ptn = set()\n    stack = [S]\n    while stack:\n        a = stack.pop()\n        ptn.add(a)\n        if a[0] != a[1]:\n            b = another(a[0],a[1])*2 + a[2]\n            if not b in ptn:\n                stack.append(b)\n        if a[1] != a[2]:\n            c = a[0] + another(a[1],a[2])*2\n            if not c in ptn:\n                stack.append(c)\n    print((len(ptn)))\n    return\n\n#N >= 4\nMOD = 998244353\ndp = [[[0 for u in range(2)] for l in range(3)] for s in range(3)]\n#dp[sum%3][last][exist'xx'?]\nfor ptn in itertools.product(list(range(3)),repeat=4):\n    seq = (ptn[0]==ptn[1] or ptn[1]==ptn[2] or ptn[2]==ptn[3])\n    dp[sum(ptn)%3][ptn[3]][seq] += 1\n\nfor n in range(4,N):\n    dp2 = [[[0 for u in range(2)] for l in range(3)] for s in range(3)]\n    for s in range(3):\n        for l in range(3):\n            for u in range(2):\n                for l2 in range(3):\n                    s2 = (s+l2)%3\n                    u2 = u or l==l2\n                    dp2[s2][l2][u2] += dp[s][l][u]\n                    dp2[s2][l2][u2] %= MOD\n    dp = dp2\n\nsm = 0\nfor c in S:\n    sm += ord(c) - ord('a')\nseq = False\nfor c1,c2 in zip(S,S[1:]):\n    if c1 == c2:\n        seq = True\n        break\nans = sum([dp[sm%3][i][1] for i in range(3)])\nif not seq: ans += 1\nprint((ans % MOD))\n", "def solve(s):\n    if all(a == b for a, b in zip(s, s[1:])):\n        return 1\n    if len(s) == 2:\n        return 2\n    elif len(s) == 3:\n        if s[0] == s[1] or s[1] == s[2]:\n            return 6\n        elif s[0] == s[2]:\n            return 7\n        else:\n            return 3\n    # dp[has succession=0][mod 3][last char], dp[has succession=1][mod 3]\n    dp = [[[0] * 3 for _ in range(3)], [0] * 3]\n    dp[0][0][0] = 1\n    dp[0][1][1] = 1\n    dp[0][2][2] = 1\n    MOD = 998244353\n    for _ in range(len(s) - 1):\n        ndp = [[[0] * 3 for _ in range(3)], [0] * 3]\n        dp0, dp1 = dp\n        ndp0, ndp1 = ndp\n        sdp1 = sum(dp1)\n        ndp0[0][0] = (dp0[0][1] + dp0[0][2]) % MOD\n        ndp0[1][0] = (dp0[1][1] + dp0[1][2]) % MOD\n        ndp0[2][0] = (dp0[2][1] + dp0[2][2]) % MOD\n        ndp0[0][1] = (dp0[2][0] + dp0[2][2]) % MOD\n        ndp0[1][1] = (dp0[0][0] + dp0[0][2]) % MOD\n        ndp0[2][1] = (dp0[1][0] + dp0[1][2]) % MOD\n        ndp0[0][2] = (dp0[1][0] + dp0[1][1]) % MOD\n        ndp0[1][2] = (dp0[2][0] + dp0[2][1]) % MOD\n        ndp0[2][2] = (dp0[0][0] + dp0[0][1]) % MOD\n        ndp1[0] = (dp0[0][0] + dp0[1][2] + dp0[2][1] + sdp1) % MOD\n        ndp1[1] = (dp0[1][0] + dp0[2][2] + dp0[0][1] + sdp1) % MOD\n        ndp1[2] = (dp0[2][0] + dp0[0][2] + dp0[1][1] + sdp1) % MOD\n        dp = ndp\n    return (dp[1][sum(map(ord, s)) % 3] + all(a != b for a, b in zip(s, s[1:]))) % MOD\n\n\ns = input()\nprint((solve(s)))\n", "def solve(s):\n    if len(s) == 2:\n        return 1 if s[0] == s[1] else 2\n    elif len(s) == 3:\n        if s[0] == s[1] == s[2]:\n            return 1\n        elif s[0] == s[1] or s[1] == s[2]:\n            return 6\n        elif s[0] == s[2]:\n            return 7\n        else:\n            return 3\n    if all(a == b for a, b in zip(s, s[1:])):\n        return 1\n    dp = [[[0] * 3 for _ in range(3)] for _ in range(2)]\n    dp[0][0][0] = 1\n    dp[0][1][1] = 1\n    dp[0][2][2] = 1\n    MOD = 998244353\n    for _ in range(len(s) - 1):\n        ndp = [[[0] * 3 for _ in range(3)] for _ in range(2)]\n        ndp[0][0][0] = (dp[0][1][0] + dp[0][2][0]) % MOD\n        ndp[0][0][1] = (dp[0][1][1] + dp[0][2][1]) % MOD\n        ndp[0][0][2] = (dp[0][1][2] + dp[0][2][2]) % MOD\n        ndp[0][1][0] = (dp[0][0][2] + dp[0][2][2]) % MOD\n        ndp[0][1][1] = (dp[0][0][0] + dp[0][2][0]) % MOD\n        ndp[0][1][2] = (dp[0][0][1] + dp[0][2][1]) % MOD\n        ndp[0][2][0] = (dp[0][0][1] + dp[0][1][1]) % MOD\n        ndp[0][2][1] = (dp[0][0][2] + dp[0][1][2]) % MOD\n        ndp[0][2][2] = (dp[0][0][0] + dp[0][1][0]) % MOD\n        ndp[1][0][0] = (dp[0][0][0] + dp[1][0][0] + dp[1][1][0] + dp[1][2][0]) % MOD\n        ndp[1][0][1] = (dp[0][0][1] + dp[1][0][1] + dp[1][1][1] + dp[1][2][1]) % MOD\n        ndp[1][0][2] = (dp[0][0][2] + dp[1][0][2] + dp[1][1][2] + dp[1][2][2]) % MOD\n        ndp[1][1][0] = (dp[0][1][2] + dp[1][0][2] + dp[1][1][2] + dp[1][2][2]) % MOD\n        ndp[1][1][1] = (dp[0][1][0] + dp[1][0][0] + dp[1][1][0] + dp[1][2][0]) % MOD\n        ndp[1][1][2] = (dp[0][1][1] + dp[1][0][1] + dp[1][1][1] + dp[1][2][1]) % MOD\n        ndp[1][2][0] = (dp[0][2][1] + dp[1][0][1] + dp[1][1][1] + dp[1][2][1]) % MOD\n        ndp[1][2][1] = (dp[0][2][2] + dp[1][0][2] + dp[1][1][2] + dp[1][2][2]) % MOD\n        ndp[1][2][2] = (dp[0][2][0] + dp[1][0][0] + dp[1][1][0] + dp[1][2][0]) % MOD\n        dp = ndp\n    return (sum(dp[1][x][sum(map(ord, s)) % 3] for x in range(3)) + all(a != b for a, b in zip(s, s[1:]))) % MOD\n\n\ns = input()\nprint((solve(s)))\n", "def main():\n    md = 998244353\n    s = input()\n    n = len(s)\n    al = True  # all\u3059\u3079\u3066\u540c\u3058\u6587\u5b57\n    an = 1  # any\u9023\u7d9a\u304c\u5b58\u5728\u3059\u308b\u30680\n    for c0, c1 in zip(s, s[1:]):\n        if c0 == c1:\n            an = 0\n        else:\n            al = False\n        if an == 0 and not al: break\n    if al:\n        print((1))\n        return\n    if n == 2:\n        print((2))\n        return\n    if n == 3:\n        if s[0] == s[-1]:\n            print((7))\n        elif s[0] == s[1] or s[1] == s[2]:\n            print((6))\n        else:\n            print((3))\n        return\n    #print(n)\n    #print(an)\n    ord0=ord(\"a\")\n    r = sum(ord(c) - ord0 for c in s) % 3\n    if n%3==0:\n        d=pow(2,n//3-1,md)\n        if r==0:\n            an-=d*2\n        else:\n            an+=d\n    print(((pow(3, n - 1, md) - pow(2, n - 1, md) + an) % md))\n\nmain()\n", "def solve(s):\n    if all(a == b for a, b in zip(s, s[1:])):\n        return 1\n    if len(s) == 2:\n        return 2\n    elif len(s) == 3:\n        if s[0] == s[1] or s[1] == s[2]:\n            return 6\n        elif s[0] == s[2]:\n            return 7\n        else:\n            return 3\n    # dp[has succession=0][mod 3][last char], dp[has succession=1][mod 3]\n    dp = [[[0] * 3 for _ in range(3)], [0] * 3]\n    dp[0][0][0] = 1\n    dp[0][1][1] = 1\n    dp[0][2][2] = 1\n    MOD = 998244353\n    for _ in range(len(s) - 1):\n        ndp = [[[0] * 3 for _ in range(3)], [0] * 3]\n        dp0, dp1 = dp\n        ndp0, ndp1 = ndp\n        sdp1 = sum(dp1)\n        ndp0[0][0] = (dp0[0][1] + dp0[0][2]) % MOD\n        ndp0[1][0] = (dp0[1][1] + dp0[1][2]) % MOD\n        ndp0[2][0] = (dp0[2][1] + dp0[2][2]) % MOD\n        ndp0[0][1] = (dp0[2][0] + dp0[2][2]) % MOD\n        ndp0[1][1] = (dp0[0][0] + dp0[0][2]) % MOD\n        ndp0[2][1] = (dp0[1][0] + dp0[1][2]) % MOD\n        ndp0[0][2] = (dp0[1][0] + dp0[1][1]) % MOD\n        ndp0[1][2] = (dp0[2][0] + dp0[2][1]) % MOD\n        ndp0[2][2] = (dp0[0][0] + dp0[0][1]) % MOD\n        ndp1[0] = (dp0[0][0] + dp0[1][2] + dp0[2][1] + sdp1) % MOD\n        ndp1[1] = (dp0[1][0] + dp0[2][2] + dp0[0][1] + sdp1) % MOD\n        ndp1[2] = (dp0[2][0] + dp0[0][2] + dp0[1][1] + sdp1) % MOD\n        dp = ndp\n    return (dp[1][sum(map(ord, s)) % 3] + all(a != b for a, b in zip(s, s[1:]))) % MOD\n\n\ns = input()\nprint((solve(s)))\n", "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nMOD = 998244353\n\nS = input().rstrip()\n\narr = np.array(list(S.replace('a','0').replace('b','1').replace('c','2')),dtype=np.int32)\n\nif (arr == arr[0]).all():\n    print(1)\n    return\n\ndef solve_naive(S):\n    se = set([S])\n    q = [S]\n    while q:\n        S = q.pop()\n        for i in range(len(S)-1):\n            x,y = S[i:i+2]\n            if x == y:\n                continue\n            for t in 'abc':\n                if t != x and t != y:\n                    T = S[:i] + t+t + S[i+2:]\n                    if T not in se:\n                        q.append(T)\n                        se.add(T)\n    return len(se)\n\nLS = len(S)\nif LS < 6:\n    answer = solve_naive(S)\n    print(answer)\n    return\n\n# \u9069\u5f53\u306a\u5fc5\u8981\u6761\u4ef6\u306e\u3082\u3068\u5168\u90e8\u4f5c\u308c\u308b\n# mod 3\u4e0d\u5909\u91cf\nanswer = pow(3,LS-1,MOD)\n# \u540c\u4e00\u5024\u306e\u9023\u7d9a\u304c\u5b58\u5728\u3057\u306a\u3044\u3082\u306e\u3092\u9593\u5f15\u304f\nif LS%3 == 0:\n    x,y = (3+MOD)//2,0\n    for _ in range(LS//3):\n        x,y = 4*x+4*y,2*x+6*y\n        x %= MOD\n        y %= MOD\n    if arr.sum()%3 == 0:\n        answer -= x\n    else:\n        answer -= y\nelse:\n    answer -= pow(2,LS-1,MOD)\n# \u521d\u624b\u306b\u5b8c\u6210\u3057\u3066\u3044\u308b\u3084\u3064\u306f\u4f7f\u3063\u3066\u826f\u3044\nif (arr[:-1] != arr[1:]).all():\n    answer += 1\n\nanswer %= MOD\nprint(answer)", "def main():\n    a = input().strip()\n    l = len(a)\n    if l < 6:\n        s = set()\n        s.add(a)\n        q = [a]\n        oa = ord('a')\n        while q:\n            a = q.pop()\n            for i in range(l - 1):\n                if a[i] != a[i+1]:\n                    t = chr(oa + 3 - (ord(a[i]) - oa) - (ord(a[i+1]) - oa))\n                    na = a[:i] + t * 2 + a[i+2:]\n                    if na not in s:\n                        s.add(na)\n                        q.append(na)\n        print(len(s))\n        return\n    t = a[0] * l\n    if t == a:\n        print(1)\n        return\n    x = 0\n    for c in a:\n        if c == 'b':\n            x += 1\n        elif c == 'c':\n            x += 2\n    ans = 0\n    if all(a[i] != a[i+1] for i in range(l - 1)):\n        ans += 1\n    mod = 998244353\n    dp = (1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)\n    for i in range(l - 1):\n        s = (dp[-1] + dp[-2] + dp[-3]) % mod\n        dp = ((dp[3]+dp[6])%mod,(dp[4]+dp[7])%mod,(dp[5]+dp[8])%mod,(dp[2]+dp[8])%mod,(dp[0]+dp[6])%mod,(dp[1]+dp[7])%mod,(dp[1]+dp[4])%mod,(dp[2]+dp[5])%mod,(dp[0]+dp[3])%mod,(dp[0]+dp[5]+dp[7]+s)%mod,(dp[1]+dp[3]+dp[8]+s)%mod,(dp[2]+dp[4]+dp[6]+s)%mod)\n    print((ans + dp[9+x%3]) % mod)\nmain()\n", "M=998244353\ns=input()\nn=len(s)-1\nv=sum(map(ord,s))\nr=pow(3,n,M)-pow(2,n,M)+pow(2,n//3,M)*(n%3==2)*(1-3*(v%3==0))+all(s[i]!=s[i+1]for i in range(n))-(v==294)\nif all(s[0]==k for k in s):r=1\nprint(r%M)", "from collections import defaultdict\nimport sys\nS=input()\nN=len(S)\nif N==3:\n    if S[0]==S[1]:\n        if S[1]==S[2]:\n            print((1))\n        else:\n            print((6))\n    else:\n        if S[0]==S[2]:\n            print((7))\n        elif S[1]==S[2]:\n            print((6))\n        else:\n            print((3))\n    return\na=S[0]\nt=1\nfor i in range(N):\n    if S[i]!=a:\n        t=0\n        break\nif t==1:\n    print((1))\n    return\n\nmod=998244353\nM=0\nfor s in S:\n    if s=='b':\n        M+=1\n    elif s=='c':\n        M+=2\n    M%=3\ndp=[]\nfor i in range(2):\n    for k in range(3):\n        for l in range(3):\n            dp.append((i,k,l))\ndd=[[[0]*3 for i in range(3)] for i in range(2)]\nfor i in range(3):\n    dd[0][i][i]=1\nfor k in range(2,N+1):\n    nd=[[[0]*3 for i in range(3)] for i in range(2)]\n    for p in dp:\n        con,moji,m=p\n        n=dd[con][moji][m]\n        #print(con,moji,m)\n        if con==0:\n            for k in range(3):\n                if moji==k:\n                    nd[1][k][ (m + k) % 3] += n\n                    nd[1] [k ][(m + k) % 3] %=mod\n                else:\n                    nd[0][k][(m+k)%3]+=n\n                    nd[0][ k] [(m+k) % 3] %=mod\n        else:\n            for k in range(3):\n                nd[1][k][(m + k) % 3] += n\n                nd[1][k][(m + k) % 3] %=mod\n    #print(nd)\n    dd=nd\nflag=1\nfor i in range(N-1):\n    if S[i]==S[i+1]:\n        flag=0\nans=flag\nfor k in range(3):\n    ans+=dd[1][k][M]\n    ans%=mod\nprint(ans)\n\n\n\n\n", "s = input()\nn = len(s)\nflg = 0\nfor i in range(1,n):\n  if s[i-1] != s[i]:\n    flg += 1\nif flg == 0:\n  print(1)\n  return\npar = (s.count(\"a\")+s.count(\"b\")*2+2)%3\ndp = [[0 for i in range(9)] for j in range(n)]\nmod = 998244353\ndp[0][0] = 1\ndp[0][4] = 1\ndp[0][8] = 1\nfor i in range(1,n):\n  dp[i][0] = dp[i-1][5]+dp[i-1][8]\n  dp[i][1] = dp[i-1][3]+dp[i-1][6]\n  dp[i][2] = dp[i-1][4]+dp[i-1][7]\n  dp[i][3] = dp[i-1][1]+dp[i-1][7]\n  dp[i][4] = dp[i-1][2]+dp[i-1][8]\n  dp[i][5] = dp[i-1][0]+dp[i-1][6]\n  dp[i][6] = dp[i-1][0]+dp[i-1][3]\n  dp[i][7] = dp[i-1][1]+dp[i-1][4]\n  dp[i][8] = dp[i-1][2]+dp[i-1][5]\n  for j in range(9):\n    dp[i][j] %= mod\nans = pow(3,n-1,mod)-dp[-1][par]-dp[-1][par+3]-dp[-1][par+6]\nif flg == n-1:\n  ans += 1\nif n == 3 and flg == n-1 and par == 2:\n  ans -= 1\nprint(ans%mod)", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\ndef solve():\n    s = input()\n    n = len(s)\n    if all(s[0] == k for k in s):\n        return 1\n    \n    somesame = 0\n    for j in range(n-1):\n        if s[j] == s[j+1]:\n            somesame = 1\n            break\n\n    x = [(ord(i)-1)%3 for i in s]\n    v = sum(x)%3\n\n    if n==2: return 2\n    if n==3:\n        if v==0: return 3\n        if somesame==0:\n            return 7\n        else:\n            return 6\n    \n    dp = [[1,0,0],[0,1,0],[0,0,1]]\n    for _ in range(n-1):\n        ndp = [[0]*3 for i in range(3)]\n        for i in range(3):\n            for j in range(3):\n                for k in range(3):\n                    if k == j: continue\n                    ndp[(i+k)%3][k] += dp[i][j]\n                    ndp[(i+k)%3][k] %= MOD\n        dp = ndp    \n        #for c in dp:\n        #    print(3**(_+1) - sum(c), end = \" \")\n        #print(dp)\n        \n    c = pow(3,n-1,MOD)    \n    c -= sum(dp[v])\n    if somesame==0:\n        c += 1\n    return c%MOD\n        \n\n        \nMOD = 998244353    \nprint(solve())\n\n\n\n\"\"\"\ndef check(n):\n    from itertools import product\n    res = 0\n    for a in product(range(3),repeat=n):\n        for j in range(n-1):\n            if a[j] == a[j+1]: break\n        else:\n            continue\n        #print(a)\n        if sum(a)%3==0:\n            res += 1\n    print(res)\n\n\n\ndef check2(a):\n    n = len(a)\n    s = set()\n    s.add(tuple(a))\n    from random import randrange\n    for _ in range(2000):\n        co = a[:]\n        for k in range(1000):\n            i = randrange(0,n-1)\n            if co[i] != co[i+1]:\n                co[i] = co[i+1] = 2*(co[i]+co[i+1])%3\n            s.add(tuple(co))\n            if all(co[0] == k for k in co): break\n    print(a)\n    print(len(s),s)            \n\n\n            \ncheck(5)\n#check2([0,1,2,0,1,2])\n\n\n\"\"\"", "s = list(input())\n\nn = len(s)\n\na = [0] * n\n\nMOD = 998244353\n\nfor i in range(n):\n    a[i] = ord(s[i]) - ord('a')\n\nif max(a) == min(a):\n    print((1))\n    return\nelif n == 3:\n    def solver(m):\n        x = m // 100\n        y = ( m % 100 ) // 10\n        z = m % 10\n        if x != y:\n            c = (3 - x - y) % 3\n            temp = c * 110 + z\n            if temp not in ans:\n                ans.add(temp)\n                solver(temp)\n        if y != z:\n            c = (3 - y - z) % 3\n            temp = x * 100 + c * 11\n            if temp not in ans:\n                ans.add(temp)\n                solver(temp)\n\n    t = a[0] * 100 + a[1] * 10 + a[2]\n    ans = set()\n    ans.add(t)\n    solver(t)\n    print((len(ans)))\n    return\nelif n == 2:\n    print((2))\n    return\n\ndp = [[0,0,0] for _ in range(3)]\n\ndp[0][0] = 1\ndp[1][1] = 1\ndp[2][2] = 1\n\nfor i in range(n-1):\n    T = [[0,0,0] for _ in range(3)]\n    T[0][0] = (dp[1][0] + dp[2][0]) % MOD\n    T[0][1] = (dp[1][1] + dp[2][1]) % MOD\n    T[0][2] = (dp[1][2] + dp[2][2]) % MOD\n    T[1][0] = (dp[0][2] + dp[2][2]) % MOD\n    T[1][1] = (dp[0][0] + dp[2][0]) % MOD\n    T[1][2] = (dp[0][1] + dp[2][1]) % MOD\n    T[2][0] = (dp[0][1] + dp[1][1]) % MOD\n    T[2][1] = (dp[0][2] + dp[1][2]) % MOD\n    T[2][2] = (dp[0][0] + dp[1][0]) % MOD\n    dp, T = T, dp\n\nm = sum(a) % 3\n\nans = 3 ** (n-1) - (dp[0][m] + dp[1][m] + dp[2][m])\n\ncheck = 1\nfor i in range(n-1):\n    if a[i] == a[i+1]:\n        check = 0\n        break\n\nans += check\n\n#print(dp, 2 ** (n-1))\n\nprint((ans % MOD))\n", "def solve(s):\n    if all(a == b for a, b in zip(s, s[1:])):\n        return 1\n    if len(s) == 2:\n        return 2\n    elif len(s) == 3:\n        if s[0] == s[1] or s[1] == s[2]:\n            return 6\n        elif s[0] == s[2]:\n            return 7\n        else:\n            return 3\n    # dp[has succession][mod 3][last char]\n    dp = [[[0] * 3 for _ in range(3)] for _ in range(2)]\n    dp[0][0][0] = 1\n    dp[0][1][1] = 1\n    dp[0][2][2] = 1\n    MOD = 998244353\n    for _ in range(len(s) - 1):\n        ndp = [[[0] * 3 for _ in range(3)] for _ in range(2)]\n        dp0, dp1 = dp\n        ndp0, ndp1 = ndp\n        sdp10, sdp11, sdp12 = sum(dp1[0]), sum(dp1[1]), sum(dp1[2])\n        ndp0[0][0] = (dp0[0][1] + dp0[0][2]) % MOD\n        ndp0[1][0] = (dp0[1][1] + dp0[1][2]) % MOD\n        ndp0[2][0] = (dp0[2][1] + dp0[2][2]) % MOD\n        ndp0[0][1] = (dp0[2][0] + dp0[2][2]) % MOD\n        ndp0[1][1] = (dp0[0][0] + dp0[0][2]) % MOD\n        ndp0[2][1] = (dp0[1][0] + dp0[1][2]) % MOD\n        ndp0[0][2] = (dp0[1][0] + dp0[1][1]) % MOD\n        ndp0[1][2] = (dp0[2][0] + dp0[2][1]) % MOD\n        ndp0[2][2] = (dp0[0][0] + dp0[0][1]) % MOD\n        ndp1[0][0] = (dp0[0][0] + sdp10) % MOD\n        ndp1[1][0] = (dp0[1][0] + sdp11) % MOD\n        ndp1[2][0] = (dp0[2][0] + sdp12) % MOD\n        ndp1[0][1] = (dp0[2][1] + sdp12) % MOD\n        ndp1[1][1] = (dp0[0][1] + sdp10) % MOD\n        ndp1[2][1] = (dp0[1][1] + sdp11) % MOD\n        ndp1[0][2] = (dp0[1][2] + sdp11) % MOD\n        ndp1[1][2] = (dp0[2][2] + sdp12) % MOD\n        ndp1[2][2] = (dp0[0][2] + sdp10) % MOD\n        dp = ndp\n    return (sum(dp[1][sum(map(ord, s)) % 3]) + all(a != b for a, b in zip(s, s[1:]))) % MOD\n\n\ns = input()\nprint((solve(s)))\n", "def solve(s):\n    if all(a == b for a, b in zip(s, s[1:])):\n        return 1\n    if len(s) == 2:\n        return 2\n    elif len(s) == 3:\n        if s[0] == s[1] or s[1] == s[2]:\n            return 6\n        elif s[0] == s[2]:\n            return 7\n        else:\n            return 3\n    # dp[has succession=0][mod 3][last char], dp[has succession=1][mod 3]\n    dp = [[[0] * 3 for _ in range(3)], [0] * 3]\n    dp[0][0][0] = 1\n    dp[0][1][1] = 1\n    dp[0][2][2] = 1\n    MOD = 998244353\n    for _ in range(len(s) - 1):\n        ndp = [[[0] * 3 for _ in range(3)], [0] * 3]\n        dp0, dp1 = dp\n        ndp0, ndp1 = ndp\n        sdp1 = sum(dp1)\n        ndp0[0][0] = (dp0[0][1] + dp0[0][2]) % MOD\n        ndp0[1][0] = (dp0[1][1] + dp0[1][2]) % MOD\n        ndp0[2][0] = (dp0[2][1] + dp0[2][2]) % MOD\n        ndp0[0][1] = (dp0[2][0] + dp0[2][2]) % MOD\n        ndp0[1][1] = (dp0[0][0] + dp0[0][2]) % MOD\n        ndp0[2][1] = (dp0[1][0] + dp0[1][2]) % MOD\n        ndp0[0][2] = (dp0[1][0] + dp0[1][1]) % MOD\n        ndp0[1][2] = (dp0[2][0] + dp0[2][1]) % MOD\n        ndp0[2][2] = (dp0[0][0] + dp0[0][1]) % MOD\n        ndp1[0] = (dp0[0][0] + dp0[1][2] + dp0[2][1] + sdp1) % MOD\n        ndp1[1] = (dp0[1][0] + dp0[2][2] + dp0[0][1] + sdp1) % MOD\n        ndp1[2] = (dp0[2][0] + dp0[0][2] + dp0[1][1] + sdp1) % MOD\n        dp = ndp\n    return (dp[1][sum(map(ord, s)) % 3] + all(a != b for a, b in zip(s, s[1:]))) % MOD\n\n\ns = input()\nprint((solve(s)))\n", "M=998244353;s=input();n=len(s)-1;v=sum(map(ord,s));print((pow(3,n,M)-pow(2,n,M)+pow(2,n//3,M)*(n%3==2)*(1-3*(v%3==0))+all(s[i]!=s[i+1]for i in range(n))-(v==294)-1)*any(s[0]!=k for k in s)%M+1)", "def main():\n    md = 998244353\n    s = input()\n    n = len(s)\n    if s.count(s[0]) == n:\n        print((1))\n        return\n    if n == 2:\n        print((2))\n        return\n    if n == 3:\n        if s[0] == s[-1]:\n            print((7))\n        elif s[0] == s[1] or s[1] == s[2]:\n            print((6))\n        else:\n            print((3))\n        return\n    ord0 = ord(\"a\")\n    a = [ord(c) - ord0 for c in s]\n    r = sum(a) % 3\n    dp = [[[[0] * 3 for _ in range(2)] for _ in range(3)] for _ in range(n)]\n    for m in range(3):\n        dp[0][m][0][m] = 1\n    # print(a)\n    # print(dp)\n    for i in range(n - 1):\n        for j in range(3):\n            for k in range(2):\n                for m in range(3):\n                    pre = dp[i][j][k][m]  # i\u3051\u305f j\u4f59\u308a k\u9023\u7d9a\u6709\u7121 m\u524d\u306e\u4f4d\n                    for nm in range(3):\n                        nj = (j + nm) % 3\n                        if nm == m:\n                            dp[i + 1][nj][1][nm] = (dp[i + 1][nj][1][nm] + pre) % md\n                        else:\n                            dp[i + 1][nj][k][nm] = (dp[i + 1][nj][k][nm] + pre) % md\n    d = 1\n    for c0, c1 in zip(s, s[1:]):\n        if c0 == c1:\n            d = 0\n            break\n    print(((sum(dp[n - 1][r][1]) + d) % md))\n\nmain()\n", "from collections import Counter\nimport sys\nsys.setrecursionlimit(10**6)\n\nMOD = 998244353\n\nABC = \"abc\".index\n*S, = map(ABC, input())\nN = len(S)\n\ndef bruteforce(S):\n    used = set()\n    def dfs(s):\n        key = tuple(s)\n        if key in used:\n            return\n        used.add(key)\n        for i in range(len(s)-1):\n            if s[i] != s[i+1]:\n                a = s[i]; b = s[i+1]\n                s[i] = s[i+1] = 3 - a - b\n                dfs(s)\n                s[i] = a; s[i+1] = b\n    dfs(S)\n    return len(used)\n\nif len(S) <= 3:\n    print(bruteforce(S))\nelse:\n    c = Counter(S)\n    if c[0] == N or c[1] == N or c[2] == N:\n        print(1)\n    else:\n        P = [[[0,0] for i in range(3)] for j in range(3)]\n        Q = [[[0,0] for i in range(3)] for j in range(3)]\n        P[0][0][0] = P[1][1][0] = P[2][2][0] = 1\n        for i in range(N-1):\n            for p in range(3):\n                for q in range(3):\n                    for r in range(2):\n                        Q[p][q][r] = 0\n            for p in range(3):\n                for q in range(3):\n                    for r in range(2):\n                        for k in range(3):\n                            Q[k][(q+k)%3][r | (p == k)] += P[p][q][r] % MOD\n            P, Q = Q, P\n        ans = 0\n        r = sum(S) % 3\n        for i in range(3):\n            ans += P[i][r][1]\n        if all(S[i] != S[i+1] for i in range(N-1)):\n            ans += 1\n        print(ans % MOD)"]
["def subsets_parity(n, k):\n    return 'EVEN' if ~n & k else 'ODD'", "subsets_parity=lambda n,k:~n&k and\"EVEN\"or\"ODD\"", "subsets_parity=s=lambda n,k:n<k and\"EVEN\"or n<2and\"ODD\"or(lambda b:s(n&~b,k&~b))(1<<n.bit_length()-1)", "#Courtesy of giants :D\ndef subsets_parity(n,k):\n    N,K = bin(n)[2:][::-1], bin(k)[2:][::-1]\n    for i in range(len(K)):\n        if K[i] > N[i]:\n            return 'EVEN'\n    return 'ODD'", "#using lucas's theorem https://en.wikipedia.org/wiki/Lucas%27s_theorem\n\ndef to_bin(n):\n    k = 0\n    while n >= 2**k: k += 1\n    s = \"\"\n    for i in range(k - 1, -1, -1):\n        if n - 2**i >= 0: \n            s += \"1\"\n            n -= 2**i\n        else: s += \"0\"\n    return s\n\ndef subsets_parity(n, k):\n    s1 = to_bin(n)\n    s2 = to_bin(k)\n    for i in range(-1, -len(s2) - 1, -1):\n        if s1[i] == \"0\" and s2[i] == \"1\": return \"EVEN\"\n    return \"ODD\"", "def subsets_parity(n,k):\n    string_set = \"{:02b}\".format(n)\n    length = len(string_set)\n    string_subset = \"{:02b}\".format(k).zfill(length)\n    for i in range(0, length):\n        if not int(string_set[i]) and int(string_subset[i]):\n            return \"EVEN\"\n            break\n    else:\n        return \"ODD\"", "import math\n\ndef f1(n):\n    x,s=1,0\n    while 2**x<=n:\n        s=s+ math.floor(n/2**x)\n        x=x+1\n    return (s)\n\ndef subsets_parity(n,k):\n    if n==k:\n        return \"ODD\"\n    if n>0 and k>0 and n-k>0:\n        if f1(n) == f1(k) + f1(n-k):\n            return \"ODD\"\n        else:\n            return \"EVEN\"\n        \n    \n", "def subsets_parity(n,k):\n  while k:\n    if not n & 1 and k & 1: return 'EVEN'\n    n, k = n // 2, k // 2\n  return 'ODD'", "def c(n):\n    m = 0\n    while n > 0:\n        n = n // 2\n        m += n\n    return m\n\ndef subsets_parity(n,k):\n    return \"EVEN\" if (c(n)-c(k)-c(n-k))>0 else \"ODD\"", "def subsets_parity(n,k):\n    return 'ODD' if n==k|(n-k) else 'EVEN'"]
["class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        A = stoneValue\n        dp = [0] * 3\n        for i in range(len(A) - 1, -1, -1):\n            dp[i % 3] = max(sum(A[i:i + k]) - dp[(i + k) % 3] for k in (1, 2, 3))\n        \n        if dp[0] > 0:\n            return 'Alice'\n        elif dp[0] < 0:\n            return 'Bob'\n        else:\n            return 'Tie'\n", "from itertools import accumulate\nclass Solution:\n    def stoneGameIII(self, sv: List[int]) -> str:\n        m = len(sv)\n        dp = [-sys.maxsize] * m\n        dp.append(0)\n        ps = list(accumulate(sv))\n        sm = sum(sv)\n\n        for i in range(m-1, -1, -1):\n            if i == m-1:\n                dp[i] = sv[i]\n            elif i == m-2:\n                dp[i] = max(dp[i], sv[i] + (ps[-1] - ps[i] - dp[i+1]))\n                dp[i] = max(dp[i], sv[i] + sv[i+1])\n            else:\n                dp[i] = max(dp[i], sv[i] + (ps[-1] - ps[i] - dp[i+1]))\n                dp[i] = max(dp[i], sv[i] + sv[i+1] + (ps[-1] - ps[i+1] - dp[i+2]))\n                dp[i] = max(dp[i], sv[i] + sv[i+1] + sv[i+2] + (ps[-1] - ps[i+2] - dp[i+3]))\n        if dp[0] * 2 == sm:\n            return 'Tie'\n        if dp[0] * 2 > sm:\n            return 'Alice'\n        return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        dp = [0] * 3\n        for i in range(len(stoneValue) - 1, -1, -1):\n            dp[i % 3] = max(sum(stoneValue[i:i + k]) - dp[(i + k) % 3] for k in (1, 2, 3))\n        if dp[0] == 0:\n            return 'Tie'\n        elif dp[0] > 0:\n            return 'Alice'\n        else:\n            return 'Bob'\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n#         cumsum = [0]*(n+1)\n#         for i in range(1,n+1):\n#             cumsum[i] = cumsum[i-1] + stoneValue[i-1]\n        \n#         @functools.lru_cache(None)\n#         def helper(i, turn):\n#             if turn == 0:\n#                 if i == n:\n#                     return 0\n#                 if i == n-1:\n#                     return stoneValue[-1]\n#                 return max([cumsum[i+k]-cumsum[i] + helper(i+k,1) for k in [1,2,3] if i+k <= n])\n#             else:\n#                 if i == n:\n#                     return 0\n#                 if i == n-1:\n#                     return 0\n#                 return min([helper(i+k,0) for k in [1,2,3] if i+k <= n])\n            \n#         c = helper(0,0)\n#         if c > sum(stoneValue) / 2.0:\n#             return 'Alice'\n#         elif c == sum(stoneValue) / 2.0:\n#             return 'Tie'\n#         else:\n#             return 'Bob'\n        A = stoneValue\n        dp = [0] * 3\n        for i in range(n - 1, -1, -1):\n            dp[i % 3] = max(sum(A[i:i + k]) - dp[(i + k) % 3] for k in (1, 2, 3))\n        c = dp[0]\n        if c > 0:\n            return 'Alice'\n        elif c == 0:\n            return 'Tie'\n        else:\n            return 'Bob'", "class Solution:\n    def stoneGameIII(self, arr: List[int]) -> str:\n        ln, dp = len(arr), [float('-inf') for _ in range(len(arr))]\n        dp.append(0)\n        \n        for i in range(ln-1, -1,-1):\n            sm =0\n            for j in range(i, min(ln, i+3)):\n                sm +=arr[j]\n                dp[i] = max(dp[i], sm - dp[j+1])\n        if dp[0]>0:\n            return 'Alice'\n        elif dp[0]<0:\n            return 'Bob'\n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        dp = [float('-inf')] * n # max score after i\n        dp[-1] = stoneValue[-1]\n        dp.append(0)\n        for i in range(n-2, -1, -1):\n            temp = 0\n            for j in range(3):\n                if i+j+1>n:\n                    break\n                temp += stoneValue[i+j]\n                dp[i] = max(dp[i], temp-dp[i+j+1])\n        if dp[0]>0:\n            return 'Alice'\n        elif dp[0]<0:\n            return 'Bob'\n        return 'Tie'\n", "class Solution:\n    def stoneGameIII(self, S: List[int]) -> str:\n        \n        n = len(S)\n        \n        dp = [0] * n\n        \n        for i in range(n)[::-1]:\n            dp[i] =  max(sum(S[i:i+k]) - (dp[i+k] if i + k < n else 0) for k in (1,2,3)  )\n            \n        \n        if dp[0] > 0:\n            return 'Alice'\n        elif dp[0] < 0:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, nums: List[int]) -> str:\n        n = len(nums)\n        total = sum(nums)\n        presum = [nums[-1]]\n        if n > 1:\n            presum.insert(0, nums[-2]+presum[0])\n            nums[-2] = max(nums[-2], presum[0])\n        if n > 2:\n            presum.insert(0, nums[-3]+presum[0])\n            nums[-3] = max([nums[-3] + presum[1] - nums[-2], nums[-3] + presum[1] - presum[2], presum[0]])\n        for i in range(n-4, -1, -1):\n            get_one = nums[i] + presum[0] - nums[i+1]\n            get_two = nums[i] + presum[0] - presum[1] + presum[1] - nums[i+2]\n            get_three = nums[i] + presum[0] - presum[2] + presum[2] - nums[i+3]\n            presum.pop()\n            presum.insert(0, presum[0] + nums[i])\n            nums[i] = max([get_one, get_two, get_three])\n        # print(nums)\n        if nums[0] == presum[0]/2:\n            return 'Tie'\n        elif nums[0] > presum[0]/2:\n            return 'Alice'\n        return 'Bob'", "class Solution:\n    def stoneGameIII(self, stns: List[int]) -> str:\n        stns.reverse()\n        if len(stns)>1:\n            ans = [0, stns[0], stns[1]+abs(stns[0])]\n            for i in range(2, len(stns)):\n                ans.append(max(stns[i]+stns[i-1]+stns[i-2]-ans[-3],\n                               stns[i]+stns[i-1]-ans[-2],\n                               stns[i]-ans[-1]))\n        else:\n            ans = stns\n        return 'Alice' if ans[-1]>0 else 'Tie' if ans[-1]==0 else 'Bob'        ", "class Solution:\n    def stoneGameIII(self, A: List[int]) -> str:\n        n = len(A)\n        dp = [-float('inf')]*n\n        A.reverse()\n        for i, x in enumerate(A):\n            adding = 0\n            for j in range(3):\n                if i-j>=0:\n                    adding += A[i-j]\n                    dp[i] = max(dp[i], adding - (dp[i-j-1] if i-j>=1 else 0))\n        if dp[-1] < 0:\n            return 'Bob'\n        return 'Tie' if dp[-1] == 0 else 'Alice'", "from functools import lru_cache\n\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        psum = [0] * (n + 1)\n        for i in range(n):\n            psum[i + 1] = psum[i] + stoneValue[i]\n            \n        @lru_cache(None)\n        def dp(start: int) -> int:\n            if start >= n:\n                return 0\n            min_next = 2 ** 30\n            for i in range(1, 4):\n                min_next = min(min_next, dp(start + i))\n            return psum[n] - psum[start] - min_next\n        \n        alice = dp(0)\n        bob = psum[n] - alice\n        return 'Alice' if alice > bob else 'Bob' if bob > alice else 'Tie'", "class Solution:\n    def stoneGameIII(self, A: List[int]) -> str:\n        dp=[0]*3\n        for i in range(len(A)-1,-1,-1):\n            dp[i%3]=max(sum(A[i:i+k])-dp[(i+k)%3] for k in range(1,4))\n        if dp[0]>0:\n            return 'Alice'\n        if dp[0]<0:\n            return 'Bob'\n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        arr = stoneValue[:]\n        dp = [0 for _ in range(3)]\n        \n        for i in range(len(arr)-1, -1, -1):\n            dp[i%3] = max(sum(arr[i:i+k])- dp[(i+k)%3] for k in range(1, 4))\n        return 'Alice' if dp[0] > 0 else 'Bob' if dp[0] <0 else 'Tie'\n", "import math\nfrom functools import lru_cache\nclass Solution:\n    def stoneGameIII(self, stoneValue):\n        n = len(stoneValue)\n        @lru_cache(None)\n        def solve(i):\n            nonlocal stoneValue\n            nonlocal n\n            if i == n :\n                return 0\n            ans = -math.inf\n            cursum = 0\n            for j in range(i , i + 3):\n                if j < n :\n                    cursum += stoneValue[j]\n                    ans = max(cursum - solve(j + 1) , ans)\n            return ans\n\n        ans = solve(0)\n        if ans > 0 :\n            return 'Alice'\n        elif ans < 0 :\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # aliceScore = [0]\n        # bobScore = [0]\n        # INVALID = 's'\n        # def helper(stoneValues,index,aliceScore,bobScore,aliceTurn):\n        #     scoreToUpdate = aliceScore\n        #     if not aliceTurn:\n        #         scoreToUpdate = bobScore\n        #     if len(stoneValues) - 1 == index:\n        #         scoreToUpdate[0] += stoneValues[index]\n        #         return\n        #     bck = scoreToUpdate[0]\n        #     sums = []\n        #     for i in range(1,4):\n        #         scoreToUpdate[0] = bck\n        #         if i + index <= len(stoneValues):\n        #             for j in range(i):\n        #                 scoreToUpdate[0] += stoneValues[index+j]\n        #             helper(stoneValues,index + i,aliceScore,bobScore,not aliceTurn)\n        #             sums.append(scoreToUpdate[0])\n        #     if len(sums) > 0:\n        #         scoreToUpdate[0] = max(sums)\n        #     else:\n        #         scoreToUpdate[0] = bck\n        #     return\n        # helper(stoneValue,0,aliceScore,bobScore,True)\n        # if aliceScore[0] > bobScore[0]:\n        #     return 'Alice'\n        # elif bobScore[0] > aliceScore[0]:\n        #     return 'Bob'\n        # return 'Tie'\n        mem = {}\n        def helper(stoneValues,index):\n            if index in mem:\n                return mem[index]\n            if index >= len(stoneValues):\n                return 0\n            ans = stoneValues[index] - helper(stoneValues,index+1)\n            if index + 1 < len(stoneValues):\n                temp = stoneValues[index] + stoneValues[index+1] - helper(stoneValues,index+2)\n                ans = max(ans,temp)\n            if index + 2 < len(stoneValues):\n                temp = stoneValues[index] + stoneValues[index+1] + stoneValues[index+2] - helper(stoneValues,index+3)\n                ans = max(ans,temp)\n            mem[index] = ans\n            return ans\n        ans = helper(stoneValue,0)\n        if ans > 0:\n            return 'Alice'\n        elif ans < 0:\n            return 'Bob'\n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        N = len(stoneValue)\n        F = [0] * (N + 1)\n        S = [0] * (N + 1)\n\n        for i in range(N - 1, -1, -1):\n            max_val = -100000000\n            for x in range(min(3, N - i)):\n                val = sum(stoneValue[i:i + x + 1]) + S[i + x + 1]\n                if max_val < val:\n                    max_val = val\n                    F[i] = val\n                    S[i] = F[i + x + 1]\n        \n        if F[0] == S[0]:\n            return 'Tie'\n        return 'Alice' if F[0] > S[0] else 'Bob'\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # def pick(player, stones):\n        #     if len(stones) == 0:\n        #         return 0\n        #     if player == 1:\n        #         return max(\n        #             [stones[0] + pick(2,stones[1:]), \n        #              sum(stones[:2]) + pick(2,stones[2:]), \n        #              sum(stones[:3]) + pick(2,stones[3:])\n        #             ])\n        #     else:\n        #         return min(\n        #             [-stones[0] + pick(1,stones[1:]), \n        #              -sum(stones[:2]) + pick(1,stones[2:]), \n        #              -sum(stones[:3]) + pick(1,stones[3:])\n        #             ])\n        # ans = pick(1,stoneValue)\n        # if ans == 0:\n        #     return 'Tie'\n        # elif ans < 0:\n        #     return 'Bob'\n        # else:\n        #     return 'Alice'\n        dp = [0]*(len(stoneValue)+1)\n        for i in range(len(stoneValue)-1,-1,-1):\n            take = 0\n            dp[i] = -float('inf')\n            for k in range(3):\n                if i+k >= len(stoneValue):\n                    continue\n                take += stoneValue[i+k]\n                dp[i]= max(dp[i],take-dp[i+k+1])\n\n        if dp[0] < 0: return 'Bob'\n        if dp[0] > 0: return 'Alice'\n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        A=stoneValue\n        N=len(A)\n        MIN=-float('inf')\n        dp=[0]*(N+1)\n        \n        for i in range(N-1, -1, -1):\n            take=A[i]\n            dp[i]=take-dp[i+1]\n            if i+1<N:\n                take+=A[i+1]\n                dp[i]=max(dp[i], take-dp[i+2])\n            if i+2<N:\n                take+=A[i+2]\n                dp[i]=max(dp[i], take-dp[i+3])\n        if dp[0]==0:\n            return 'Tie'\n        return 'Alice' if dp[0]>0 else 'Bob'", "class Solution:\n    def stoneGameIII(self, stones: List[int]) -> str:\n        rowlen=len(stones)\n        i=rowlen-1\n        i_1,i_2,i_3=0,0,0\n        \n        while i >= 0:\n            \n            answer=-float('inf')\n            \n            answer=max(answer,stones[i] - i_1)\n            \n            if i+1 < rowlen:\n                answer=max(answer,stones[i]+stones[i+1] - i_2)  \n                \n            if i+2 < rowlen:\n                answer=max(answer,stones[i]+stones[i+1]+stones[i+2] - i_3)\n        \n            i_3=i_2\n            i_2=i_1\n            i_1 = answer \n            i-=1\n            \n        if i_1 > 0:\n            return 'Alice'\n        elif i_1 < 0:\n            return 'Bob'\n        else:\n            return 'Tie'\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        postsum, dp = 0, [0]*(len(stoneValue)+3)\n        for i in range(len(stoneValue)-1, -1, -1):\n            postsum += stoneValue[i]\n            dp[i] = postsum - min(dp[i+1], dp[i+2], dp[i+3])\n        alice, bob = dp[0], postsum - dp[0]\n        if alice == bob:\n            return 'Tie'\n        if alice > bob:\n            return 'Alice'\n        return 'Bob'", "class Solution:\n    def stoneGameIII(self, S: List[int]) -> str:\n        \n        n = len(S)\n        \n        dp = [0] * n\n        \n        for i in range(n)[::-1]:\n            M = float('-inf')\n            for k in range(1, 4):\n                M = max(M, sum(S[i:i+k]) - (dp[i+k] if i + k < n else 0))\n            dp[i] = M\n        \n        if dp[0] > 0:\n            return 'Alice'\n        elif dp[0] < 0:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        stoneValue.insert(0, 0)\n        # dp[i] means the max score we can get when i piles have been taken\n        dp = [-sys.maxsize] * (n + 1)\n        \n        presum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            presum[i] = presum[i - 1] + stoneValue[i]\n        \n        dp[n] = 0\n        for i in reversed(range(n)):\n            temp = 0\n            for j in range(1, 4):\n                if i + j > n:\n                    break\n                \n                temp += stoneValue[i + j]\n                dp[i] = max(dp[i], temp + presum[n] - presum[i + j] - dp[i + j])\n        \n        if dp[0] > presum[n] - dp[0]:\n            return 'Alice'\n        elif dp[0] < presum[n] - dp[0]:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        length = len(stoneValue)\n        dp = [0 for _ in range(length+1)]\n\n        for i in range(length-1, -1, -1):\n            take = 0\n            dp[i] = -sys.maxsize\n            for j in range(3):\n                if i+j < length:\n                    take += stoneValue[i+j]\n                    dp[i] = max(dp[i], take - dp[i+j+1])\n\n        # print(stoneValue)\n        # print(dp)\n        if dp[0] > 0:\n            return 'Alice'\n        elif dp[0] < 0:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stones: List[int]) -> str:\n        \n        rowlen=len(stones)\n        index=0\n        memo=[-1] * rowlen\n             \n        def helper(index,memo):\n            \n            if index >= rowlen:\n                return 0\n            elif memo[index] != -1:\n                return memo[index] \n            else:\n                answer=-float('inf')\n                answer=max(answer,stones[index] - helper(index+1,memo))\n                if index + 1 < rowlen:\n                    answer=max(answer,stones[index]+stones[index+1] - helper(index+2,memo))\n                \n                if index + 2 < rowlen:\n                    answer=max(answer,stones[index]+stones[index+1]+stones[index+2] - helper(index+3,memo))\n                \n                memo[index]=answer\n                return memo[index]      \n                \n        answer=helper(0,memo)\n        print(answer)\n        \n        if answer < 0:\n            return 'Bob'\n        elif answer > 0:\n            return 'Alice'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stones):\n        total = sum(stones)\n        alice_value = self._dfs(stones, 0, {})\n        if alice_value > 0:\n            return 'Alice'\n        elif alice_value < 0:\n            return 'Bob'\n        return 'Tie'\n\n    def _dfs(self, stones, start, memo):\n        if start >= len(stones):\n            return 0\n        \n        if start in memo:\n            return memo[start]\n        \n        res = -2 ** 31\n        curr_total = 0\n        for i in range(start, min(start + 3, len(stones))):\n            curr_total += stones[i]\n            next_player_values = self._dfs(stones, i + 1, memo)\n            \n            res = max(\n                res,\n                curr_total - next_player_values,\n            )\n        \n        memo[start] = res\n        return res\n", "class Solution:\n    def stoneGameIII(self, cards):\n        dp = [0]*3\n        \n        for i in range(len(cards)-1, -1, -1):\n            dp[i%3] = max(sum(cards[i:i+k]) - dp[(i+k)%3] for k in [1,2,3])\n        \n        if dp[0] <0:\n            return 'Bob'\n        elif dp[0] >0:\n            return 'Alice'\n        else:\n            return 'Tie'\n", "def answer(x, y, alice, bob):\n    if alice[x]>bob[y]:\n        return 'Alice'\n    elif alice[x]<bob[y]:\n        return 'Bob'\n    else:\n        return 'Tie'\n\n\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        if len(stoneValue)==1:\n            if stoneValue[0]>0:\n                return 'Alice'\n            elif stoneValue[0]==0:\n                return 'Tie'\n            else:\n                return 'Bob'\n        alice = [0]*len(stoneValue)\n        bob = [0]*len(stoneValue)\n        alice[-1] = stoneValue[-1]\n        bob[-1] = stoneValue[-1]\n        \n        cumSumm = [0]*len(stoneValue)\n        summ = stoneValue[-1]\n        cumSumm[-1] = summ\n        for i in range(len(stoneValue)-2, -1, -1):\n            summ+=stoneValue[i]\n            cumSumm[i] = summ\n            if i+2==len(stoneValue):\n                alice[i] = max(stoneValue[i]+stoneValue[i+1], stoneValue[i]+cumSumm[i+1]-bob[i+1])\n                bob[i] = max(stoneValue[i]+stoneValue[i+1], stoneValue[i]+cumSumm[i+1]-alice[i+1])\n                continue\n            if i+3==len(stoneValue):\n                alice[i] = max(stoneValue[i]+cumSumm[i+1]-bob[i+1], stoneValue[i]+stoneValue[i+1]+cumSumm[i+2]-bob[i+2], stoneValue[i]+stoneValue[i+1]+stoneValue[i+2])\n                bob[i] = max(stoneValue[i]+cumSumm[i+1]-alice[i+1], stoneValue[i]+stoneValue[i+1]+cumSumm[i+2]-alice[i+2], stoneValue[i]+stoneValue[i+1]+stoneValue[i+2])\n                continue\n\n            alice[i] = max(stoneValue[i]+cumSumm[i+1]-bob[i+1], stoneValue[i]+stoneValue[i+1]+cumSumm[i+2]-bob[i+2], stoneValue[i]+stoneValue[i+1]+stoneValue[i+2]+cumSumm[i+3]-bob[i+3])\n            bob[i] = max(stoneValue[i]+cumSumm[i+1]-alice[i+1], stoneValue[i]+stoneValue[i+1]+cumSumm[i+2]-alice[i+2], stoneValue[i]+stoneValue[i+1]+stoneValue[i+2]+cumSumm[i+3]-alice[i+3])\n            \n            \n        if len(stoneValue)==2:\n            i = 0\n            if alice[0]==stoneValue[i]+cumSumm[i+1]-bob[i+1]:\n                x, y = i, i+1\n            return answer(x, y, alice, bob)\n        if len(stoneValue)==3:\n            i = 0\n            if alice[0]==stoneValue[i]+cumSumm[i+1]-bob[i+1]:\n                x, y = i, i+1\n            elif alice[0]==stoneValue[i]+stoneValue[i+1]+cumSumm[i+2]-bob[i+2]:\n                x, y = i, i+2\n            return answer(x, y, alice, bob)\n        i = 0\n        if alice[0]==stoneValue[i]+cumSumm[i+1]-bob[i+1]:\n            x, y = i, i+1\n        elif alice[0]==stoneValue[i]+stoneValue[i+1]+cumSumm[i+2]-bob[i+2]:\n            x, y = i, i+2\n        elif alice[0]==stoneValue[i]+stoneValue[i+1]+stoneValue[i+2]+cumSumm[i+3]-bob[i+3]:\n            x, y = i, i+3\n        return answer(x, y, alice, bob)\n          \n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        self.mem = dict()\n        self.n = len(stoneValue)\n        self.values = stoneValue\n        me, oppo = self.dfs(0)\n        \n        if me > oppo:\n            return 'Alice'\n        elif oppo > me:\n            return 'Bob'\n        return 'Tie'\n        \n        \n    def dfs(self, idx):\n        if idx >= self.n:\n            return 0, 0\n        if idx in self.mem:\n            return self.mem[idx]\n        \n        oppo = 0\n        rv = -float('inf')\n        tmp = 0\n        for i in range(idx, min(self.n, idx+3)):\n            rv1, rv2 = self.dfs(i+1)\n            tmp += self.values[i]\n            if rv < tmp + rv2:\n                rv = tmp + rv2\n                oppo = rv1\n                \n        self.mem[idx] = rv, oppo\n        return self.mem[idx]", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        \n        prefix = [0] * (len(stoneValue) + 1)\n        for i in range(len(stoneValue)):\n            prefix[i+1] = prefix[i] + stoneValue[i]\n            \n        memo = {}\n        aliceScore = self.dfs(stoneValue, 0, memo, prefix)\n        \n        total = sum(stoneValue)\n        if total - aliceScore > aliceScore:\n            return 'Bob'\n        elif total - aliceScore < aliceScore:\n            return 'Alice'\n        return 'Tie'\n    \n    \n    def dfs(self, stoneValue, i, memo, prefix):\n        if i == len(stoneValue):\n            return 0\n        if i in memo:\n            return memo[i]\n        \n        ans = stoneValue[i] + prefix[-1] - prefix[i+1] - self.dfs(stoneValue, i+1, memo, prefix)\n        \n        if i + 1 < len(stoneValue):\n            ans = max(ans, stoneValue[i] + stoneValue[i+1] + prefix[-1] - prefix[i+2] - self.dfs(stoneValue, i+2, memo, prefix))\n        if i + 2 < len(stoneValue):\n            ans =  max(ans, stoneValue[i] + stoneValue[i+1] + stoneValue[i+2] + prefix[-1] - prefix[i+3] - self.dfs(stoneValue, i+3, memo, prefix))\n            \n        memo[i] = ans\n        return memo[i]\n        \n        \n", "class Solution:\n    # Time: O(n * k), Space: O(n) - where k is number of maximum stones a player can pick\n    def bottomUpDP(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        suffix_sum = [0 for _ in range(n + 1)]\n        # dp[i] - maximum sum a player can accumulate he/she starts at position i\n        dp = [0 for _ in range(n + 1)]\n        \n        for i in range(n - 1, -1, -1):\n            suffix_sum[i] = stoneValue[i] + suffix_sum[i+1]\n        \n        for i in range(n - 1, -1, -1):\n            player_pick_two_stones, player_pick_three_stones = float('-inf'), float('-inf')\n            player_pick_one_stone = stoneValue[i] + suffix_sum[i + 1] - dp[i + 1]\n            if i + 1 < n:\n                player_pick_two_stones = stoneValue[i] + stoneValue[i + 1] + suffix_sum[i + 2] - dp[i + 2]\n            if i + 2 < n:\n                player_pick_three_stones = stoneValue[i] + stoneValue[i + 1] + stoneValue[i + 2] + suffix_sum[i + 3] - dp[i + 3]\n            dp[i] = max(player_pick_one_stone, player_pick_two_stones, player_pick_three_stones)\n        \n        if 2 * dp[0] == suffix_sum[0]:\n            return 'Tie'\n        elif 2 * dp[0] > suffix_sum[0]: # Alice score > Bob's score, dp[0] > suffix_sum[0] - dp[0]\n            return 'Alice'\n        else:\n            return 'Bob'\n    \n    # top down solution using lru_cache\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        prefix = list(itertools.accumulate(stoneValue))\n        \n        @lru_cache(maxsize = None)\n        def getScore(i):\n            if i > len(stoneValue):\n                return 0\n            \n            stones = float('-inf')\n            for j in range(1, 3 + 1):\n                prev = prefix[i - 1] if i - 1 >= 0 else 0\n                stones = max(stones, prefix[-1] - prev - getScore(i + j))\n            return stones\n        \n        alice_score = getScore(0)\n        \n        if alice_score > prefix[-1] - alice_score:\n            return 'Alice'\n        elif alice_score < prefix[-1] - alice_score:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        length = len(stoneValue)\n        \n        @lru_cache(maxsize=None)\n        def helper(current_idx):\n            if current_idx >= length:\n                return 0\n            \n            res = float('-inf')\n            sum = 0\n            \n            for i in range(3):\n                if current_idx + i < length:\n                    sum += stoneValue[current_idx + i]\n                    res = max(res, sum - helper(current_idx + i + 1))\n            \n            return res\n        \n        result = helper(0)\n        \n        if result == 0:\n            return 'Tie'\n        elif result > 0:\n            return 'Alice'\n        return 'Bob'\n", "class Solution:\n    def stoneGameIII(self, s: List[int]) -> str:\n        \n        cost = [-1]*(len(s))\n        def helper(s, i):\n            if i >= len(s):\n                return 0\n            if cost[i] != -1:\n                return cost[i]\n            \n            ans = -sys.maxsize\n            ans = max(ans, s[i] - helper(s, i+1))\n            if i+1 < len(s):\n                ans = max(ans, s[i]+s[i+1] - helper(s, i+2))\n            if i+2 < len(s):\n                ans = max(ans, s[i]+s[i+1]+s[i+2] - helper(s, i+3))\n            cost[i] = ans\n            return cost[i]\n        \n        a = helper(s, 0)\n        if a > 0:\n            return 'Alice'\n        if a == 0:\n            return 'Tie'\n        return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        length = len(stoneValue)\n        \n        @lru_cache(maxsize=None)\n        def helper(current_idx):\n            if current_idx >= length:\n                return 0\n            \n            res = float('-inf')\n            sum = 0\n            \n            for i in range(3):\n                if current_idx + i < length:\n                    sum += stoneValue[current_idx + i]\n                    res = max(res, sum - helper(current_idx + i + 1))\n            \n            return res\n        \n        result = helper(0)\n        \n        if result == 0:\n            return 'Tie'\n        elif result > 0:\n            return 'Alice'\n        return 'Bob'", "class Solution:\n    # Time: O(n * k), Space: O(n) - where k is number of maximum stones a player can pick\n    def bottomUpDP(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        suffix_sum = [0 for _ in range(n + 1)]\n        # dp[i] - maximum sum a player can accumulate he/she starts at position i\n        dp = [0 for _ in range(n + 1)]\n        \n        for i in range(n - 1, -1, -1):\n            suffix_sum[i] = stoneValue[i] + suffix_sum[i+1]\n        \n        for i in range(n - 1, -1, -1):\n            player_pick_two_stones, player_pick_three_stones = float('-inf'), float('-inf')\n            player_pick_one_stone = stoneValue[i] + suffix_sum[i + 1] - dp[i + 1]\n            if i + 1 < n:\n                player_pick_two_stones = stoneValue[i] + stoneValue[i + 1] + suffix_sum[i + 2] - dp[i + 2]\n            if i + 2 < n:\n                player_pick_three_stones = stoneValue[i] + stoneValue[i + 1] + stoneValue[i + 2] + suffix_sum[i + 3] - dp[i + 3]\n            dp[i] = max(player_pick_one_stone, player_pick_two_stones, player_pick_three_stones)\n        \n        if 2 * dp[0] == suffix_sum[0]:\n            return 'Tie'\n        elif 2 * dp[0] > suffix_sum[0]: # Alice score > Bob's score, dp[0] > suffix_sum[0] - dp[0]\n            return 'Alice'\n        else:\n            return 'Bob'\n        \n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        prefix = list(itertools.accumulate(stoneValue))\n        \n        @lru_cache(maxsize = None)\n        def getScore(i):\n            if i > len(stoneValue):\n                return 0\n            \n            stones = float('-inf')\n            for j in range(1, 3 + 1):\n                prev = prefix[i - 1] if i - 1 >= 0 else 0\n                stones = max(stones, prefix[-1] - prev - getScore(i + j))\n            return stones\n        \n        alice_score = getScore(0)\n        \n        if alice_score > prefix[-1] - alice_score:\n            return 'Alice'\n        elif alice_score < prefix[-1] - alice_score:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        \n        n = len(stoneValue)\n        dp = [float('-inf')] * n\n        dp[-1] = stoneValue[-1]\n        for i in range(n - 2, -1, -1):\n            s = 0\n            for j in range(i, i + 3):\n                s += stoneValue[j] if j < n else 0\n                nxt = dp[j + 1] if j + 1 < n else 0\n                dp[i] = max(dp[i], s - nxt)\n        \n                \n                \n#         @lru_cache(None)\n#         def dp(cur):\n#             if cur == len(stoneValue) - 1:\n#                 return stoneValue[cur]\n#             if cur >= len(stoneValue):\n#                 return 0\n#             ret = float('-inf')\n#             s = 0\n#             for i in range(3):\n#                 nxt = dp(cur + i + 1)\n#                 s += stoneValue[cur + i] if cur + i < len(stoneValue) else 0\n#                 ret = max(ret, s - nxt)\n#             return ret\n\n#         ans = dp(0)\n        ans = dp[0]\n        if ans > 0:\n            return 'Alice'\n        elif ans < 0:\n            return 'Bob'\n        else:\n            return 'Tie'\n\n            \n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        memo = {}\n        n = len(stoneValue)\n        def solve(s):\n            if s >= n: return 0\n            elif s in memo :  return memo[s]\n            currValue = 0\n            best = -2**31\n            for i in range(3):\n                if s+i >= n:\n                    break\n                currValue += stoneValue[s+i]\n                best = max(best, currValue - solve(s+i+1))\n            memo[s] = best\n            return best\n        ans = solve(0)\n        if ans > 0: return 'Alice'\n        elif ans < 0 : return 'Bob'\n        else: return 'Tie'", "class Solution:\n#     # Time: O(n * k), Space: O(n) - where k is number of maximum stones a player can pick\n#     def stoneGameIII(self, stoneValue: List[int]) -> str:\n#         n = len(stoneValue)\n#         suffix_sum = [0 for _ in range(n + 1)]\n#         # dp[i] - maximum sum a player can accumulate he/she starts at position i\n#         dp = [0 for _ in range(n + 1)]\n        \n#         for i in range(n - 1, -1, -1):\n#             suffix_sum[i] = stoneValue[i] + suffix_sum[i+1]\n        \n#         for i in range(n - 1, -1, -1):\n#             player_pick_two_stones, player_pick_three_stones = float('-inf'), float('-inf')\n#             player_pick_one_stone = stoneValue[i] + suffix_sum[i + 1] - dp[i + 1]\n#             if i + 1 < n:\n#                 player_pick_two_stones = stoneValue[i] + stoneValue[i + 1] + suffix_sum[i + 2] - dp[i + 2]\n#             if i + 2 < n:\n#                 player_pick_three_stones = stoneValue[i] + stoneValue[i + 1] + stoneValue[i + 2] + suffix_sum[i + 3] - dp[i + 3]\n#             dp[i] = max(player_pick_one_stone, player_pick_two_stones, player_pick_three_stones)\n        \n#         if 2 * dp[0] == suffix_sum[0]:\n#             return 'Tie'\n#         elif 2 * dp[0] > suffix_sum[0]: # Alice score > Bob's score, dp[0] > suffix_sum[0] - dp[0]\n#             return 'Alice'\n#         else:\n#             return 'Bob'\n        \n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        prefix = list(itertools.accumulate(stoneValue))\n        \n        @lru_cache(maxsize = None)\n        def getScore(i):\n            if i > len(stoneValue):\n                return 0\n            \n            stones = float('-inf')\n            \n            for j in range(1, 3 + 1):\n                prev = prefix[i - 1] if i - 1 >= 0 else 0\n                stones = max(stones, prefix[-1] - prev - getScore(i + j))\n            return stones\n        \n        alice_score = getScore(0)\n        \n        if alice_score > prefix[-1] - alice_score:\n            return 'Alice'\n        elif alice_score < prefix[-1] - alice_score:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # Get the highest socre of Alice s1, \n        # then score of Bob is sum(stoneValue) - s.\n        # If s1 > s2 => Alice, if s1 == s2 => Tie, else\n        # Bob\n        \n        # [1,2,3,6]\n        # TLE, because in getScore we have to sum(stoneValue) since we \n        # don't need to get the explict score, we can optimize it, which\n        # is the second approach.\n#         memo = {}\n#         def getScore(start):\n#             if start >= len(stoneValue):\n#                 return 0\n#             if start in memo:\n#                 return memo[start]\n#             res = -math.inf\n#             front = 0\n#             behind = sum(stoneValue[start:])\n#             for i in range(start, min(start+3, len(stoneValue))):\n#                 front += stoneValue[i]\n#                 behind -= stoneValue[i]\n#                 cur = front + behind - getScore(i+1)\n#                 res = max(cur, res)\n            \n#             return res\n                \n#         s1 = getScore(0)\n#         s2 = sum(stoneValue) - s1\n        \n#         if s1 > s2:\n#             return 'Alice'\n#         elif s1 == s2:\n#             return 'Tie'\n#         else:\n#             return 'Bob'\n        \n        # Second approach\n        memo = {}\n        def dfs(start):\n            if start >= len(stoneValue):\n                return 0\n            if start in memo:\n                return memo[start]\n            memo[start] = -math.inf\n            score = 0\n            for i in range(start, min(len(stoneValue), start+3)):\n                score += stoneValue[i]\n                memo[start] = max(memo[start], score - dfs(i+1))\n            \n            return memo[start]\n        score = dfs(0)\n        \n        if score > 0:\n            return 'Alice'\n        elif score == 0:\n            return 'Tie'\n        else:\n            return 'Bob'", "class Solution:\n    def stoneGameIII(self, sv: List[int]) -> str:\n        n=len(sv)\n        sv+=[0,0]\n        dp=[0 for _ in range(n+3)]\n        for i in range(n-1,-1,-1):\n            dp[i]=max(sv[i]-dp[i+1],sv[i]+sv[i+1]-dp[i+2], sv[i]+sv[i+1]+sv[i+2]-dp[i+3])\n        if dp[0]>0:\n            return 'Alice'\n        elif dp[0]<0:\n            return 'Bob'\n        return 'Tie'\n\n                \n                \n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        @lru_cache(None)\n        def dp(cur):\n            if cur == len(stoneValue) - 1:\n                return stoneValue[cur]\n            if cur >= len(stoneValue):\n                return 0\n            ret = float('-inf')\n            s = 0\n            for i in range(3):\n                # if cur + i + 1 >= len(stoneValue):\n                #     break\n                nxt = dp(cur + i + 1)\n                s += stoneValue[cur + i] if cur + i < len(stoneValue) else 0\n                ret = max(ret, s - nxt)\n            # print(cur, ret)\n            return ret\n\n        ans = dp(0)\n        if ans > 0:\n            return 'Alice'\n        elif ans < 0:\n            return 'Bob'\n        else:\n            return 'Tie'\n\n            \n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # \u91c7\u7528\u548c\u7c7b\u4f3c\u4e8estoneGameII\u7684\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5417\uff1f\n        # \u6b8b\u5c40\n        # solve(s) score diff\n        # M=1,2,3\n        # x=[1,2,3]\n        # solve(s) = max(sum(sv[s:s+x-1]) - solve(s+x))\n        \n        n = len(stoneValue)\n        \n        cache = dict() # s:score\n        \n        def solve(s):\n            if s>=n: return 0\n            \n            if s in cache: return cache[s]\n            \n            best = -2**31\n            presum = 0\n            \n            for x in range(1, 4):\n                if s+x-1 >= n:\n                    break\n                presum += stoneValue[s+x-1]\n                best = max(best, presum - solve(s+x))\n            cache[s] = best\n            return best\n        score = solve(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'", "from functools import lru_cache\n\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        vals = stoneValue\n        n = len(vals)\n        dp = collections.deque([None] * 3)\n        dp[0] = [0, 0]\n        \n        for i in range(n - 1, -1, -1):\n            p1, p2 = -1e9, -1\n            s = 0\n            for j in range(i, min(i + 3, n)):\n                s += vals[j]\n                p1_, p2_ = dp[j - i]\n                p2_ += s\n                if p2_ > p1:\n                    p1 = p2_\n                    p2 = p1_\n            dp.pop()\n            dp.appendleft((p1, p2))\n        \n        p1, p2 = dp[0]\n        # print(p1, p2)\n        # p2 = sum(vals) - p1\n        if p1 > p2:\n            return 'Alice'\n        elif p1 == p2:\n            return 'Tie'\n        return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # take 1, 2, or 3 stones from the first remaining stones of the row\n        \n        # memorized dp, with mimmax process\n        \n        # state = dp[s], start from index s\n        \n        # take one, stoneValue[s] - dp[s+1]\n        # take two, stoneValue[s,s+1] - dp[s+2]\n        # take three, stoneValue[s, s+1, s+2] - dp[s+3]\n        # max value of these three branches\n        \n        # dp[s] > 0\n        \n        memo = {}\n        n = len(stoneValue)\n        \n        def dp(s):\n            if s>=n: return 0\n            if s in memo:\n                return memo[s]\n            \n            ans = -2**31\n            for i in range(1, 4):\n                if s + i > n: # was bad, s+i>=n was not correct!\n                    break\n                ans = max(ans, sum(stoneValue[s:s+i]) - dp(s+i))\n            memo[s] = ans\n            return ans\n        \n        score = dp(0) - sum(stoneValue)/2\n        #print(score, sum(stoneValue)/2)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n    def stoneGameIII(self, stoneValue: List[int]) -> str:       \n        # \u91c7\u7528\u548c\u7c7b\u4f3c\u4e8estoneGameII\u7684\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5417\uff1f-> works!! great \u592a\u597d\u4e86\uff0cget\u4e00\u4e2aminmax\u7684\u6c42\u89e3\u7684\u6a21\u677f\uff01\uff01\uff01\n        # \u6b8b\u5c40\n        # solve(s) score diff\n        # M=1,2,3\n        # x=[1,2,3]\n        # solve(s) = max(sum(sv[s:s+x-1]) - solve(s+x))\n        \n        n = len(stoneValue)\n        \n        cache = dict() # s:score\n        \n        def solve(s):\n            if s>=n: return 0\n            if s in cache: return cache[s]\n            \n            best = -2**31\n            presum = 0\n            \n            for x in range(1, 4):\n                if s+x-1 >= n:\n                    break\n                presum += stoneValue[s+x-1]\n                best = max(best, presum - solve(s+x))\n            cache[s] = best\n            return best\n        score = solve(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'", "class Solution:\n    \n    def stoneGameIII(self, stones):\n        # only allow to take from the head, 1,2,3\n        \n        # recursive dp method\n        memo = dict()\n        n = len(stones)\n        def dp(s):\n            if s == n: return 0\n            if s in memo: return memo[s]\n            \n            ans = -2**31\n            \n            presum = 0\n            for i in range(1, 4):\n                if s+i-1>= n:\n                    break\n                presum += stones[s+i-1]\n                ans = max(ans, presum - dp(s+i))\n            memo[s] = ans\n            return ans\n        score = dp(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    def stoneGameIII5(self, stoneValue):\n        # memorized dp\n        n = len(stoneValue)\n        \n        memo = dict()\n        \n        def dp(s):\n            if s>=n:return 0\n            if s in memo:\n                return memo[s]\n            \n            ans = -2**31\n            for i in range(1, 4):\n                if s+i > n:\n                    break\n                ans = max(ans, sum(stoneValue[s:s+i]) - dp(s+i))\n            memo[s] = ans\n            return ans\n        \n        score = dp(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    def stoneGameIII1(self, stoneValue):\n        # memorized dp\n        n = len(stoneValue)\n        memo = dict()\n        def dp(s):\n            # start index of stonevlaue\n            if s >= n:\n                return 0\n            if s in memo:\n                return memo[s]\n            \n            ans = -2**31\n            \n            for i in range(1, 4):\n                # first 1 to 3\n                if s+i>n:\n                    break;\n                ans = max(ans, sum(stoneValue[s:s+i]) - dp(s+i))\n            memo[s] = ans\n            return ans\n        score  = dp(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\nclass Solution1:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # take 1, 2, or 3 stones from the first remaining stones of the row\n        # memorized dp, with mimmax process\n        \n        # state = dp[s], start from index s\n        \n        # take one, stoneValue[s] - dp[s+1]\n        # take two, stoneValue[s,s+1] - dp[s+2]\n        # take three, stoneValue[s, s+1, s+2] - dp[s+3]\n        # max value of these three branches\n        \n        # dp[s] > 0\n        \n        memo = {}\n        n = len(stoneValue)\n        \n        def dp(s):\n            if s>=n: return 0\n            if s in memo:\n                return memo[s]\n            \n            ans = -2**31  # \u8fd9\u4e2a\u6709\u9519\u8bef\uff01\uff0cans=0\u4e86\uff0c\u662f\u4e0d\u5bf9\u7684\uff01\n            for i in range(1, 4):\n                if s + i > n: # was bad, s+i>=n was not correct! \u8fd9\u4e2a\u4e5f\u6709\u9519\u8bef\uff01\u5199\u6210\u4e86s+i>n\uff0c\u4e5f\u662f\u9519\u8bef\u7684\uff01\n                    break\n                ans = max(ans, sum(stoneValue[s:s+i]) - dp(s+i))\n            memo[s] = ans\n            return ans\n        \n        score = dp(0)# - sum(stoneValue)/2 \u8ddf\u8fd9\u4e2asum(stoneValue)/2\u6ca1\u6709\u5173\u7cfb\uff01\u9519\u8bef3\uff01\n        #print(score, sum(stoneValue)/2)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n    def stoneGameIII2(self, stoneValue: List[int]) -> str:       \n        # \u91c7\u7528\u548c\u7c7b\u4f3c\u4e8estoneGameII\u7684\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5417\uff1f-> works!! great \u592a\u597d\u4e86\uff0cget\u4e00\u4e2aminmax\u7684\u6c42\u89e3\u7684\u6a21\u677f\uff01\uff01\uff01\n        # \u6b8b\u5c40\n        # solve(s) score diff\n        # M=1,2,3\n        # x=[1,2,3]\n        # solve(s) = max(sum(sv[s:s+x-1]) - solve(s+x))\n        \n        n = len(stoneValue)\n        \n        cache = dict() # s:score\n        \n        def solve(s):\n            if s>=n: return 0\n            if s in cache: return cache[s]\n            \n            best = -2**31\n            presum = 0\n            \n            for x in range(1, 4):\n                if s+x-1 >= n:\n                    break\n                presum += stoneValue[s+x-1]\n                best = max(best, presum - solve(s+x))\n            cache[s] = best\n            return best\n        score = solve(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        length = len(stoneValue)\n        \n        memo = {}\n        \n        def helper(current_idx):\n            if current_idx >= length:\n                return 0\n            \n            if current_idx in memo:\n                return memo[current_idx]\n            \n            res = float('-inf')\n            sum = 0\n            \n            for i in range(3):\n                if current_idx + i < length:\n                    sum += stoneValue[current_idx + i]\n                    res = max(res, sum - helper(current_idx + i + 1))\n            \n            memo[current_idx] = res\n            return res\n        \n        result = helper(0)\n        \n        if result == 0:\n            return 'Tie'\n        elif result > 0:\n            return 'Alice'\n        return 'Bob'\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        first, second = self.memo_search(0, stoneValue, {})\n        if first > second:\n            return 'Alice'\n        if first == second:\n            return 'Tie'\n        return 'Bob'\n    \n    def memo_search(self, pos, stoneValue, memo):\n        if pos in memo:\n            return memo[pos]\n        \n        if pos == len(stoneValue):\n            return 0, 0\n        \n        ans = -sys.maxsize\n        value = 0\n        for i in range(3):\n            if pos + i < len(stoneValue):\n                value += stoneValue[pos + i]\n                second, first = self.memo_search(pos + i + 1, stoneValue, memo)\n                total = first + second + value\n                if first + value > ans:\n                    ans = first + value\n        memo[pos] = ans, total - ans\n        return ans, total - ans\n", "class Solution:\n    def stoneGameIII(self, stoneValue):\n      def dfs(start):\n        if start >= len(stoneValue):\n          return 0\n        \n        if dp[start] != None:\n          return dp[start]\n\n        i = start\n        curSum = 0\n        maxValue = -float('inf')\n\n        while i < len(stoneValue) and i < start + 3:\n          curSum += stoneValue[i]\n          maxValue = max(maxValue, curSum - dfs(i + 1))\n          i += 1\n\n        dp[start] = maxValue\n\n        return dp[start]  \n\n      dp = [None] * len(stoneValue)\n\n      res = dfs(0)\n\n    \n      if res > 0:\n        return 'Alice'\n      elif res < 0:\n        return 'Bob'\n      return 'Tie'  \n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        cursum = 0\n        dp1 = [float('-inf')] * (n + 1)\n        dp1[-1] = 0\n        for i in range(n - 1, -1, -1):\n            cursum += stoneValue[i]\n            for k in range(3):\n                if i + k >= n:\n                    break\n                dp1[i] = max(dp1[i], cursum - dp1[i + k + 1])\n        if dp1[0] > cursum - dp1[0]:\n            return 'Alice'\n        if dp1[0] < cursum - dp1[0]:\n            return 'Bob'\n        return 'Tie'\n                \n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # dont take the below, because it can be negative, [-1,-2,-3]\n        #if len(stoneValue) <= 3:\n        #    return 'Alice'\n        p1, p2, p3 = 0, 0, 0\n        post_sum = 0\n        for i in range(len(stoneValue) - 1, -1, -1):\n            val = stoneValue[i]\n            post_sum += val\n            best = post_sum - min([p1, p2, p3])\n            p1, p2, p3 = best, p1, p2\n        if p1 > post_sum - p1:\n            return 'Alice'\n        elif p1 < post_sum - p1:\n            return 'Bob'\n        else:\n            return 'Tie'\n        \n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        total = [0] * (len(stoneValue) + 4)\n        for i in range(len(stoneValue) - 1, -1, -1):\n            total[i] = total[(i + 1)] + stoneValue[i]\n        dp = [0] * (len(total))\n        for i in range(len(stoneValue) - 1, -1, -1):\n            dp[i] = total[i] - min(dp[i + 1: i + 4], default = 0)\n        \n        alice = dp[0]\n        bob = total[0] - alice\n        if alice > bob:\n            return 'Alice'\n        elif alice < bob:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # take 1, 2, or 3 stones from the first remaining stones of the row\n        \n        # memorized dp, with mimmax process\n        \n        # state = dp[s], start from index s\n        \n        # take one, stoneValue[s] - dp[s+1]\n        # take two, stoneValue[s,s+1] - dp[s+2]\n        # take three, stoneValue[s, s+1, s+2] - dp[s+3]\n        # max value of these three branches\n        \n        # dp[s] > 0\n        \n        memo = {}\n        n = len(stoneValue)\n        \n        def dp(s):\n            if s>=n: return 0\n            if s in memo:\n                return memo[s]\n            \n            ans = -2**31  # \u8fd9\u4e2a\u6709\u9519\u8bef\uff01\uff0cans=0\u4e86\uff0c\u662f\u4e0d\u5bf9\u7684\uff01\n            for i in range(1, 4):\n                if s + i > n: # was bad, s+i>=n was not correct! \u8fd9\u4e2a\u4e5f\u6709\u9519\u8bef\uff01\u5199\u6210\u4e86s+i>n\uff0c\u4e5f\u662f\u9519\u8bef\u7684\uff01\n                    break\n                ans = max(ans, sum(stoneValue[s:s+i]) - dp(s+i))\n            memo[s] = ans\n            return ans\n        \n        score = dp(0)# - sum(stoneValue)/2 \u8ddf\u8fd9\u4e2asum(stoneValue)/2\u6ca1\u6709\u5173\u7cfb\uff01\u9519\u8bef3\uff01\n        #print(score, sum(stoneValue)/2)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n    def stoneGameIII2(self, stoneValue: List[int]) -> str:       \n        # \u91c7\u7528\u548c\u7c7b\u4f3c\u4e8estoneGameII\u7684\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5417\uff1f-> works!! great \u592a\u597d\u4e86\uff0cget\u4e00\u4e2aminmax\u7684\u6c42\u89e3\u7684\u6a21\u677f\uff01\uff01\uff01\n        # \u6b8b\u5c40\n        # solve(s) score diff\n        # M=1,2,3\n        # x=[1,2,3]\n        # solve(s) = max(sum(sv[s:s+x-1]) - solve(s+x))\n        \n        n = len(stoneValue)\n        \n        cache = dict() # s:score\n        \n        def solve(s):\n            if s>=n: return 0\n            if s in cache: return cache[s]\n            \n            best = -2**31\n            presum = 0\n            \n            for x in range(1, 4):\n                if s+x-1 >= n:\n                    break\n                presum += stoneValue[s+x-1]\n                best = max(best, presum - solve(s+x))\n            cache[s] = best\n            return best\n        score = solve(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n\n        length = len(stoneValue)\n\n        # dp[i] denote sum of items selected by Alice subtract sum of Bob from i to last\n        dp = {}\n        kA = 'Alice'\n        kB = 'Bob'\n        for index in range(length-1, -1, -1):\n            minus = length - index\n            rA = rB = 0\n            if minus >= 3:  # normal case >=3; three choices\n                # choice 1: select all the three\n                c1 = stoneValue[index] + stoneValue[index + 1] + stoneValue[index + 2]\n\n                # choice 2: select first two\n                c2 = stoneValue[index] + stoneValue[index + 1]\n\n                # choice 3: select first one\n                c3 = stoneValue[index]\n\n                # Alice\n                rA = max(c1 + dp.get((index + 3, kB), 0), c2 + dp.get((index + 2, kB), 0),\n                         c3 + dp.get((index + 1, kB), 0))\n\n                # Bob\n                rB = min(-c1 + dp.get((index + 3, kA), 0), -c2 + dp.get((index + 2, kA), 0),\n                         -c3 + dp.get((index + 1, kA), 0))\n            elif minus == 2:  # remain two, two choices\n                # choice 1: select all the two\n                c1 = stoneValue[index] + stoneValue[index + 1]\n\n                # choice 2: select the first of the two\n                c2 = stoneValue[index]\n\n                # Alice select\n                rA = max(c1, c2 + dp.get((index + 1, kB), 0))\n\n                # Bob select\n                rB = min(-c1, -c2 + dp.get((index + 1, kA), 0))\n            elif minus == 1:  # remain one, only one choice\n                c1 = stoneValue[index]\n                rA = c1\n                rB = -c1\n\n            dp[(index, kA)] = rA\n            dp[(index, kB)] = rB\n\n        #print(stoneValue)\n        #print(dp)\n        result = dp.get((0, kA))\n        if result > 0:\n            return 'Alice'\n        elif result < 0:\n            return 'Bob'\n        else:\n            return 'Tie'", "from functools import lru_cache\n\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        minimal = -2 ** 31\n        n = len(stoneValue)\n        dp = [minimal] * (n + 1)  # net difference between two players for stones[i:]\n        dp[n] = 0  # iterate backwards\n\n        for i in range(n - 1, -1, -1):\n            curr_net = 0\n            for j in range(1, min(4, n - i + 1)):\n                curr_net += stoneValue[i + j - 1]\n                dp[i] = max(dp[i], curr_net - dp[i + j])\n\n        return 'Alice' if dp[0] > 0 else 'Bob' if dp[0] < 0 else 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        self.cache = [0] * 50001\n        total = sum(stoneValue)\n        first = (total + self.helper(stoneValue, 0)) // 2\n        second = total - first\n        if first > second:\n            return 'Alice'\n        elif first < second:\n            return 'Bob'\n        else:\n            return 'Tie'\n    \n    def helper(self, stoneValue, index):\n        if self.cache[index]:\n            return self.cache[index]\n        \n        n = len(stoneValue)\n        if index == n:\n            return 0\n        \n        cur = 0\n        best = -sys.maxsize\n        for i in range(3):\n            if index + i >= n:\n                break\n            \n            cur += stoneValue[index + i]\n            best = max(best, cur - self.helper(stoneValue, index + i + 1))\n        \n        self.cache[index] = best\n        return best\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        dp = [-float('inf')] * (len(stoneValue) + 5)\n        dp[len(stoneValue):len(stoneValue)+5] = [0] * 5\n        # postfix= [0] * (len(stoneValue) + 1)\n        # for i in range(len(stoneValue)-1, -1, -1):\n        #     postfix[i] = postfix[i+1] + stoneValue[i]\n        s = stoneValue\n        # dp[i], from ith, the value that we can get \n        # because i=0 is Alice's option so we just need to judge how many value we can get at this point \n        \n        # for ind in range(len(s)-1, -1, -1):\n        #     take = 0\n        #     for i in range(3):\n        #         if ind + i >= len(s):\n        #             break\n        #         take += s[ind+i]\n        #         dp[ind] = max(dp[ind], take-dp[ind+i+1])\n        # if dp[0] == 0:\n        #     return 'Tie'\n        # return 'Alice' if dp[0] > 0 else 'Bob'\n        dp = dict()\n        def search(i):\n            if i >= len(stoneValue):\n                return 0 \n            res = -float('inf')\n            score = 0\n            if i in dp: return dp[i]\n            for j in range(3):\n                if i + j < len(stoneValue):\n                    score += stoneValue[i+j] \n                    res = max(score - search(i+j+1), res)\n            dp[i] = res\n            return dp[i]\n        \n        ans = search(0)\n        if dp[0] == 0:\n            return 'Tie'\n        return 'Alice' if dp[0] > 0 else 'Bob'\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # take 1, 2, or 3 stones from the first remaining stones of the row\n        \n        # memorized dp, with mimmax process\n        \n        # state = dp[s], start from index s\n        \n        # take one, stoneValue[s] - dp[s+1]\n        # take two, stoneValue[s,s+1] - dp[s+2]\n        # take three, stoneValue[s, s+1, s+2] - dp[s+3]\n        # max value of these three branches\n        \n        # dp[s] > 0\n        \n        memo = {}\n        n = len(stoneValue)\n        \n        def dp(s):\n            if s>=n: return 0\n            if s in memo:\n                return memo[s]\n            \n            ans = -2**31  # \u8fd9\u4e2a\u6709\u9519\u8bef\uff01\uff0cans=0\u4e86\uff0c\u662f\u4e0d\u5bf9\u7684\uff01\n            for i in range(1, 4):\n                if s + i > n: # was bad, s+i>=n was not correct! \u8fd9\u4e2a\u4e5f\u6709\u9519\u8bef\uff01\u5199\u6210\u4e86s+i>n\uff0c\u4e5f\u662f\u9519\u8bef\u7684\uff01\n                    break\n                ans = max(ans, sum(stoneValue[s:s+i]) - dp(s+i))\n            memo[s] = ans\n            return ans\n        \n        score = dp(0)# - sum(stoneValue)/2\n        #print(score, sum(stoneValue)/2)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n    def stoneGameIII2(self, stoneValue: List[int]) -> str:       \n        # \u91c7\u7528\u548c\u7c7b\u4f3c\u4e8estoneGameII\u7684\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5417\uff1f-> works!! great \u592a\u597d\u4e86\uff0cget\u4e00\u4e2aminmax\u7684\u6c42\u89e3\u7684\u6a21\u677f\uff01\uff01\uff01\n        # \u6b8b\u5c40\n        # solve(s) score diff\n        # M=1,2,3\n        # x=[1,2,3]\n        # solve(s) = max(sum(sv[s:s+x-1]) - solve(s+x))\n        \n        n = len(stoneValue)\n        \n        cache = dict() # s:score\n        \n        def solve(s):\n            if s>=n: return 0\n            if s in cache: return cache[s]\n            \n            best = -2**31\n            presum = 0\n            \n            for x in range(1, 4):\n                if s+x-1 >= n:\n                    break\n                presum += stoneValue[s+x-1]\n                best = max(best, presum - solve(s+x))\n            cache[s] = best\n            return best\n        score = solve(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'", "from functools import lru_cache\n\nclass Solution:\n  @lru_cache(None)\n  def recursive(self, i):\n    if i >= self.n:\n      return 0\n    ans, score = float('-inf'), 0\n    for k in range(3):\n      if i + k < self.n:\n        score += self.s[i + k]\n        ans = max(ans, score - self.recursive(i + k + 1))\n    return ans\n  def stoneGameIII(self, stoneValue: List[int]) -> str:\n    self.n, self.s = len(stoneValue), stoneValue\n    self.recursive.cache_clear()\n    x = self.recursive(0)\n    return 'Alice' if x > 0 else 'Tie' if x == 0 else 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        dp = [[-math.inf, -math.inf] for _ in range(n + 1)]\n        dp[-1] = [0, 0]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, min(i + 4, n + 1)):\n                if dp[i][0] < dp[j][1] + sum(stoneValue[i:j]):\n                    dp[i][0] = dp[j][1] + sum(stoneValue[i:j])\n                    dp[i][1] = dp[j][0]\n        alice, bob = dp[i]\n        # print(dp)\n        if alice > bob:\n            return 'Alice'\n        elif alice < bob:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stones: List[int]) -> str:\n        rowlen=len(stones)\n        dp=[0] * (rowlen+1)\n        i=rowlen-1\n        \n        \n        while i >= 0:\n            \n            answer=-float('inf')\n            \n            answer=max(answer,stones[i] - dp[i+1])\n            \n            if i+1 < rowlen:\n                answer=max(answer,stones[i]+stones[i+1] - dp[i+2])  \n                \n            if i+2 < rowlen:\n                answer=max(answer,stones[i]+stones[i+1]+stones[i+2] - dp[i+3])\n        \n            dp[i] = answer \n            i-=1\n        \n        print(dp)\n        if dp[0] > 0:\n            return 'Alice'\n        elif dp[0] < 0:\n            return 'Bob'\n        else:\n            return 'Tie'\n        \n        \n        \n        \n        '''\n        # Recursion + TopDown\n        rowlen=len(stones)\n        index=0\n        memo=[-1] * rowlen\n             \n        def helper(index,memo):\n            \n            if index >= rowlen:\n                return 0\n            elif memo[index] != -1:\n                return memo[index] \n            else:\n                answer=-float('inf')\n                answer=max(answer,stones[index] - helper(index+1,memo))\n                if index + 1 < rowlen:\n                    answer=max(answer,stones[index]+stones[index+1] - helper(index+2,memo))\n                \n                if index + 2 < rowlen:\n                    answer=max(answer,stones[index]+stones[index+1]+stones[index+2] - helper(index+3,memo))\n                \n                memo[index]=answer\n                return memo[index]      \n                \n        answer=helper(0,memo)\n        print(answer)\n        \n        if answer < 0:\n            return 'Bob'\n        elif answer > 0:\n            return 'Alice'\n        else:\n            return 'Tie'\n            \n        '''      ", "class Solution:\n    def stoneGameIII(self, stoneValue):\n        # memorized dp\n        n = len(stoneValue)\n        memo = dict()\n        def dp(s):\n            # start index of stonevlaue\n            if s >= n:\n                return 0\n            if s in memo:\n                return memo[s]\n            \n            ans = -2**31\n            \n            for i in range(1, 4):\n                # first 1 to 3\n                if s+i>n:\n                    break;\n                ans = max(ans, sum(stoneValue[s:s+i]) - dp(s+i))\n            memo[s] = ans\n            return ans\n        score  = dp(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\nclass Solution1:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # take 1, 2, or 3 stones from the first remaining stones of the row\n        # memorized dp, with mimmax process\n        \n        # state = dp[s], start from index s\n        \n        # take one, stoneValue[s] - dp[s+1]\n        # take two, stoneValue[s,s+1] - dp[s+2]\n        # take three, stoneValue[s, s+1, s+2] - dp[s+3]\n        # max value of these three branches\n        \n        # dp[s] > 0\n        \n        memo = {}\n        n = len(stoneValue)\n        \n        def dp(s):\n            if s>=n: return 0\n            if s in memo:\n                return memo[s]\n            \n            ans = -2**31  # \u8fd9\u4e2a\u6709\u9519\u8bef\uff01\uff0cans=0\u4e86\uff0c\u662f\u4e0d\u5bf9\u7684\uff01\n            for i in range(1, 4):\n                if s + i > n: # was bad, s+i>=n was not correct! \u8fd9\u4e2a\u4e5f\u6709\u9519\u8bef\uff01\u5199\u6210\u4e86s+i>n\uff0c\u4e5f\u662f\u9519\u8bef\u7684\uff01\n                    break\n                ans = max(ans, sum(stoneValue[s:s+i]) - dp(s+i))\n            memo[s] = ans\n            return ans\n        \n        score = dp(0)# - sum(stoneValue)/2 \u8ddf\u8fd9\u4e2asum(stoneValue)/2\u6ca1\u6709\u5173\u7cfb\uff01\u9519\u8bef3\uff01\n        #print(score, sum(stoneValue)/2)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n    def stoneGameIII2(self, stoneValue: List[int]) -> str:       \n        # \u91c7\u7528\u548c\u7c7b\u4f3c\u4e8estoneGameII\u7684\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5417\uff1f-> works!! great \u592a\u597d\u4e86\uff0cget\u4e00\u4e2aminmax\u7684\u6c42\u89e3\u7684\u6a21\u677f\uff01\uff01\uff01\n        # \u6b8b\u5c40\n        # solve(s) score diff\n        # M=1,2,3\n        # x=[1,2,3]\n        # solve(s) = max(sum(sv[s:s+x-1]) - solve(s+x))\n        \n        n = len(stoneValue)\n        \n        cache = dict() # s:score\n        \n        def solve(s):\n            if s>=n: return 0\n            if s in cache: return cache[s]\n            \n            best = -2**31\n            presum = 0\n            \n            for x in range(1, 4):\n                if s+x-1 >= n:\n                    break\n                presum += stoneValue[s+x-1]\n                best = max(best, presum - solve(s+x))\n            cache[s] = best\n            return best\n        score = solve(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'", "from functools import lru_cache\nclass Solution(object):\n    def stoneGameIII(self, Values):\n        N = len(Values)\n        @lru_cache(None)\n        def dp(i):\n            if i>=N:\n                return (0,0)\n            if i == N-1:\n                return (Values[-1], 0)\n            one, two, three = -float('inf'), -float('inf'), -float('inf')\n            one = (Values[i]+dp(i+1)[1], dp(i+1)[0])\n            if i< N-1:\n                two =(Values[i]+Values[i+1]+dp(i+2)[1], dp(i+2)[0])\n                one = max(one, two)\n            if i<N-2:\n                three = (Values[i]+Values[i+1]+Values[i+2]+dp(i+3)[1], dp(i+3)[0])\n                one = max(one, three)\n            return one\n        res = dp(0)\n        return 'Alice' if res[0]>res[1] else 'Bob' if res[1]>res[0] else 'Tie'\n\n", "class Solution:\n    def stoneGameIII(self, sv: List[int]) -> str:\n        n=len(sv)\n        sv.append(0)\n        sv.append(0)\n        dp=[0 for _ in range(n+3)]\n        for i in range(n-1,-1,-1):\n            dp[i]=max(sv[i]-dp[i+1],sv[i]+sv[i+1]-dp[i+2], sv[i]+sv[i+1]+sv[i+2]-dp[i+3])\n        # print(dp)\n        if dp[0]>0:\n            return 'Alice'\n        elif dp[0]<0:\n            return 'Bob'\n        return 'Tie'\n\n                \n                \n", "class Solution:\n    def stoneGameIII(self, stones: List[int]) -> str:\n        #dp[i]: max value can get after i piles stone removed\n        n = len(stones)\n        dp = [-math.inf for _ in range(n + 1)]\n        dp[n] = 0\n        prefix = [0 for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            prefix[i] = prefix[i - 1] + stones[i - 1]\n        \n        for i in range(n - 1, -1, -1):\n            for k in range(1, 4):\n                if i + k > n:\n                    break\n                dp[i] = max(dp[i], sum(stones[i: i + k]) + prefix[-1] - prefix[i + k] - dp[i + k])\n                \n        if dp[0] * 2 > sum(stones):\n            return 'Alice'\n        elif dp[0] * 2 < sum(stones):\n            return 'Bob'\n        else:\n            return 'Tie'\n        \n        \n", "class Solution:\n    \n    def stoneGameIII(self, stoneValue):\n        # memorized dp\n        n = len(stoneValue)\n        \n        memo = dict()\n        \n        def dp(s):\n            if s>=n:return 0\n            if s in memo:\n                return memo[s]\n            \n            ans = -2**31\n            for i in range(1, 4):\n                if s+i > n:\n                    break\n                ans = max(ans, sum(stoneValue[s:s+i]) - dp(s+i))\n            memo[s] = ans\n            return ans\n        \n        score = dp(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    def stoneGameIII1(self, stoneValue):\n        # memorized dp\n        n = len(stoneValue)\n        memo = dict()\n        def dp(s):\n            # start index of stonevlaue\n            if s >= n:\n                return 0\n            if s in memo:\n                return memo[s]\n            \n            ans = -2**31\n            \n            for i in range(1, 4):\n                # first 1 to 3\n                if s+i>n:\n                    break;\n                ans = max(ans, sum(stoneValue[s:s+i]) - dp(s+i))\n            memo[s] = ans\n            return ans\n        score  = dp(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\nclass Solution1:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # take 1, 2, or 3 stones from the first remaining stones of the row\n        # memorized dp, with mimmax process\n        \n        # state = dp[s], start from index s\n        \n        # take one, stoneValue[s] - dp[s+1]\n        # take two, stoneValue[s,s+1] - dp[s+2]\n        # take three, stoneValue[s, s+1, s+2] - dp[s+3]\n        # max value of these three branches\n        \n        # dp[s] > 0\n        \n        memo = {}\n        n = len(stoneValue)\n        \n        def dp(s):\n            if s>=n: return 0\n            if s in memo:\n                return memo[s]\n            \n            ans = -2**31  # \u8fd9\u4e2a\u6709\u9519\u8bef\uff01\uff0cans=0\u4e86\uff0c\u662f\u4e0d\u5bf9\u7684\uff01\n            for i in range(1, 4):\n                if s + i > n: # was bad, s+i>=n was not correct! \u8fd9\u4e2a\u4e5f\u6709\u9519\u8bef\uff01\u5199\u6210\u4e86s+i>n\uff0c\u4e5f\u662f\u9519\u8bef\u7684\uff01\n                    break\n                ans = max(ans, sum(stoneValue[s:s+i]) - dp(s+i))\n            memo[s] = ans\n            return ans\n        \n        score = dp(0)# - sum(stoneValue)/2 \u8ddf\u8fd9\u4e2asum(stoneValue)/2\u6ca1\u6709\u5173\u7cfb\uff01\u9519\u8bef3\uff01\n        #print(score, sum(stoneValue)/2)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n        \n    def stoneGameIII2(self, stoneValue: List[int]) -> str:       \n        # \u91c7\u7528\u548c\u7c7b\u4f3c\u4e8estoneGameII\u7684\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5417\uff1f-> works!! great \u592a\u597d\u4e86\uff0cget\u4e00\u4e2aminmax\u7684\u6c42\u89e3\u7684\u6a21\u677f\uff01\uff01\uff01\n        # \u6b8b\u5c40\n        # solve(s) score diff\n        # M=1,2,3\n        # x=[1,2,3]\n        # solve(s) = max(sum(sv[s:s+x-1]) - solve(s+x))\n        \n        n = len(stoneValue)\n        \n        cache = dict() # s:score\n        \n        def solve(s):\n            if s>=n: return 0\n            if s in cache: return cache[s]\n            \n            best = -2**31\n            presum = 0\n            \n            for x in range(1, 4):\n                if s+x-1 >= n:\n                    break\n                presum += stoneValue[s+x-1]\n                best = max(best, presum - solve(s+x))\n            cache[s] = best\n            return best\n        score = solve(0)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        dp = [float('-inf')] * n\n        \n        def dfs(i):\n            if i >= n: return 0\n            if dp[i] != float('-inf'): return dp[i]\n            \n            ssum = 0\n            for j in range(3):\n                if i + j < n:\n                    ssum += stoneValue[i+j]\n                    dp[i] = max(dp[i], ssum - dfs(i+j+1))\n            return dp[i]\n        score = dfs(0)\n        if score > 0: return 'Alice'\n        elif score < 0: return 'Bob'\n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        memo = {}\n        \n        def dfs(start):\n            if start >= len(stoneValue):\n                return 0\n            \n            if start in memo:\n                return memo[start]\n            \n            memo[start] = float('-inf') \n            score = 0\n            \n            for i in range(start, min(len(stoneValue), start + 3)):\n                score += stoneValue[i]\n                memo[start] = max(memo[start], score - dfs(i + 1))\n            \n            return memo[start]\n        \n        score = dfs(0)  \n        return 'Tie' if score == 0 else 'Alice' if score > 0 else 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        @lru_cache(None)\n        def dp(cur):\n            if cur >= n:\n                return 0, 0\n            first, second = -math.inf, -math.inf\n            for i in range(1, 4):\n                first_tmp, second_tmp = dp(cur + i)\n                if first < second_tmp + sum(stoneValue[cur:cur + i]):\n                    first = second_tmp + sum(stoneValue[cur:cur + i])\n                    second = first_tmp\n            return first, second\n        alice, bob = dp(0)\n        if alice > bob:\n            return 'Alice'\n        elif alice < bob:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        self.cache = {}\n        score = self.solve(0, stoneValue)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n    \n\n    def solve(self, i, stoneValue): # score diff\n        n = len(stoneValue)\n        if i>=n: \n            return 0\n\n        if i in self.cache: \n            return self.cache[i]\n\n        res = float('-inf')\n        presum = 0\n\n        for x in range(1, 4):\n            if i+x-1>=n:\n                break\n            presum += stoneValue[i+x-1]\n            res = max(res, presum - self.solve(i+x, stoneValue)) # min-max process\n        self.cache[i] = res\n        return res\n    \n    \n    \n    \n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        dp = [-float('inf')] * (len(stoneValue) + 5)\n        dp[len(stoneValue):len(stoneValue)+5] = [0] * 5\n        postfix= [0] * (len(stoneValue) + 1)\n        for i in range(len(stoneValue)-1, -1, -1):\n            postfix[i] = postfix[i+1] + stoneValue[i]\n        s = stoneValue\n        # dp[i], from ith, the value that we can get \n        # because i=0 is Alice's option so we just need to judge how many value we can get at this point \n        \n        # for ind in range(len(s)-1, -1, -1):\n        #     take = 0\n        #     for i in range(3):\n        #         if ind + i >= len(s):\n        #             break\n        #         take += s[ind+i]\n        #         dp[ind] = max(dp[ind], take-dp[ind+i+1])\n        # if dp[0] == 0:\n        #     return 'Tie'\n        # return 'Alice' if dp[0] > 0 else 'Bob'\n        dp = dict()\n        def search(i):\n            if i >= len(stoneValue):\n                return 0 \n            res = -float('inf')\n            score = 0\n            if i in dp: return dp[i]\n            for j in range(3):\n                if i + j < len(stoneValue):\n                    score += stoneValue[i+j] \n                    res = max(score - search(i+j+1), res)\n            dp[i] = res\n            return dp[i]\n        \n        ans = search(0)\n        if dp[0] == 0:\n            return 'Tie'\n        return 'Alice' if dp[0] > 0 else 'Bob'\n        # class Solution:\n#     def stoneGameIII(self, stoneValue: List[int]) -> str:\n#         memo = {}\n        \n#         def dfs(start):\n#             if start >= len(stoneValue):\n#                 return 0\n            \n#             if start in memo:\n#                 return memo[start]\n            \n#             memo[start] = float('-inf') \n#             score = 0\n            \n#             for i in range(start, min(len(stoneValue), start + 3)):\n#                 score += stoneValue[i]\n#                 memo[start] = max(memo[start], score - dfs(i + 1))\n            \n#             return memo[start]\n        \n#         score = dfs(0)  \n#         return 'Tie' if score == 0 else 'Alice' if score > 0 else 'Bob'\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        \n        self.memo = collections.defaultdict(int)\n        self.stoneValue = stoneValue\n        score = self.dfs(0)  \n        return 'Tie' if score == 0 else 'Alice' if score > 0 else 'Bob'\n        \n    def dfs(self,start):\n        if start >= len(self.stoneValue):\n            return 0\n\n        if start in self.memo:\n            return self.memo[start]\n        \n        res = float('-inf')\n        score = 0\n\n        for i in range(start, min(len(self.stoneValue), start + 3)):\n            score += self.stoneValue[i]\n            res = max(res, score - self.dfs(i + 1))\n        \n        self.memo[start] = res\n        \n        return res\n        \n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        memo = {}\n        post_sum = [0] * (n + 1)\n        for i in range(n)[::-1]:\n            post_sum[i] = stoneValue[i] + post_sum[i + 1]\n        \n        def dfs(i):\n            if i >= n:\n                return 0\n            \n            if i in memo:\n                return memo[i]\n            \n            res = float('-inf')\n            cur = 0\n            for j in range(i, min(i + 3, n)):\n                cur += stoneValue[j]\n                res = max(res, cur + post_sum[j + 1] - dfs(j + 1))\n            \n            memo[i] = res\n            return res\n        \n        res = dfs(0)\n        if res * 2 == post_sum[0]:\n            return 'Tie'\n        \n        if res * 2 > post_sum[0]:\n            return 'Alice'\n        \n        return 'Bob'\n", "fmax = lambda x,y: x if x>y else y\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        \n        i = n - 1\n        \n        i1, i2, i3 = 0, 0, 0\n        \n        while i>=0:\n            ans = float('-inf')\n            \n            ans = fmax(ans, stoneValue[i] - i1)\n            \n            if i+1 < n:\n                ans = fmax(ans, stoneValue[i] + stoneValue[i+1] - i2)\n                \n            if i+2 < n:\n                ans = fmax(ans, stoneValue[i] + stoneValue[i+1] + stoneValue[i+2] - i3)\n                \n            i3 = i2\n            i2 = i1\n            i1 = ans\n            i -= 1\n        \n        if i1 > 0:\n            return 'Alice'\n        elif i1 < 0:\n            return 'Bob'\n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        best = {}; S =0; N = len(stoneValue)\n        cumsum = [0 for val in stoneValue]+[0];\n        for ii in range(len(stoneValue)-1,-1,-1):\n            S = S+stoneValue[ii]\n            cumsum[ii] = S\n        def findbest(index,stoneValue):\n#            print(index,best)\n            if index in best:\n                res = best[index]\n            elif index==len(stoneValue)-1:\n                res= stoneValue[-1]\n            elif index>=len(stoneValue):\n                res = 0  \n            else:\n                res = -10000000\n                for j in range(index+1,min(index+4,N+1)):\n                    res = max(res,sum(stoneValue[index:j]) + cumsum[j]-findbest(j,stoneValue))\n#                    print(index,j,res)\n            best[index] = res\n            return best[index]\n        res= findbest(0,stoneValue)\n#        print(best)\n        if res>sum(stoneValue)/2:\n            return 'Alice'\n        elif res<sum(stoneValue)/2:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        @lru_cache(None)\n        def helper(idx):\n            if idx == len(stoneValue): return 0, idx\n            # if idx + 2 >= len(stoneValue) - 1: return sum(stoneValue[idx:]), len(stoneValue)\n            score, max_score = 0, -sys.maxsize + 1\n            op_idx = idx + 1\n            for num in range(3):\n                if idx + num < len(stoneValue):\n                    score += stoneValue[idx + num]\n                    b_score, a_idx = helper(idx + num + 1)\n                    if helper(a_idx)[0] + score >= max_score:\n                        max_score = helper(a_idx)[0] + score\n                        op_idx = idx + num + 1\n            return max_score, op_idx\n        \n        score, op_idx = helper(0)\n        op_score = helper(op_idx)[0]\n        \n        # print(score, op_idx)\n        if score > op_score: return 'Alice'\n        elif score == op_score: return 'Tie'\n        else: return 'Bob'\n            \n", "class Solution:\n    def stoneGameIII(self, stoneValue: list) -> str:\n        def play(preSum, index, cache):\n            if index == len(preSum) - 1:\n                return preSum[index]\n            if index in cache:\n                return cache[index]\n            res = -2**31\n            for i in range(1, 4):\n                if index + i >= len(preSum):\n                    break\n                take = preSum[index] - preSum[index + i]\n                res = max(\n                    res,\n                    take + preSum[index + i] - play(preSum, index + i, cache))\n            cache[index] = res\n\n            return res\n\n        for i in range(len(stoneValue) - 2, -1, -1):\n            stoneValue[i] += stoneValue[i + 1]\n        aliceScore = play(stoneValue + [0], 0, {})\n        bobScore = stoneValue[0] - aliceScore\n        if bobScore > aliceScore:\n            return 'Bob'\n        elif aliceScore > bobScore:\n            return 'Alice'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        dp = {}\n        piles = stoneValue\n        n = len(piles)\n        sums = 0\n        for pile in piles:\n            sums += pile\n\n        def rec_max(i,n,sums):\n            if i == n:\n                return 0\n            if i in dp:\n                return dp[i][0]\n            m = min(3,n-i)\n            res_sum = float('-inf')\n            res_gap = float('-inf')\n            remains = sums\n            for x in range(m):\n                remains -= piles[i+x]\n                other = rec_max(i+x+1,n,remains)\n                res = sums - other\n                gap = res - other\n                if gap > res_gap:\n                    res_gap = gap\n                    res_sum = res\n            dp[i] = res_sum,res_gap\n            return res_sum\n        rec_max(0,n,sums) \n        res = dp[0][1]\n        if res < 0:\n            return 'Bob'\n        elif res > 0:\n            return 'Alice'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        memo = {}\n        def helper(i,total):\n            if i>=n:\n                return 0\n            elif (i) in memo:\n                return memo[i]\n            res = -math.inf\n            for x in range(1, min(4, n-i+1)):\n                s = sum(stoneValue[i:i+x])\n                res = max(res, total - helper(i+x,total-s))\n            memo[i] = res\n            return res\n        \n        total = sum(stoneValue)\n        a = helper(0,total)\n        b = total - a\n        if a == b:\n            return 'Tie'\n        elif a > b:\n            return 'Alice'\n        else:\n            return 'Bob'", "#dp\n#f(>=N) = 0\n#f(i) = suffixsum[i] - min(f(i+x) for x in range(1,4))\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        N = len(stoneValue)\n        dp = [0] * (N+3)\n        acc = 0\n        for i in range(N-1, -1, -1):\n            acc += stoneValue[i]\n            dp[i] = acc - min(dp[i+x] for x in range(1,4))\n        alice = dp[0]\n        bob = acc - alice\n        if alice > bob:\n            return 'Alice'\n        elif alice == bob:\n            return 'Tie'\n        else:\n            return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        for i in range(n-2, -1,-1):\n            stoneValue[i] += stoneValue[i+1]\n        \n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(i):\n            if i >= n:\n                return 0\n            return stoneValue[i] - min(dp(i+x) for x in [1,2,3])\n            \n        \n        Alice = dp(0)\n        Bob = stoneValue[0] - Alice\n        \n        if Alice > Bob:\n            return 'Alice'\n        elif Alice < Bob:\n            return 'Bob'\n        else:\n            return 'Tie'\n        \n    def stoneGameIII(self, A: List[int]) -> str:\n        @lru_cache(None)\n        def dp(i):\n            # beyond the scope, return 0\n            if i>=len(A):return 0\n            # if only one element left, return this value\n            if i==len(A)-1:return A[-1]\n            # three actions: pick up 1, pick up 2, pick up 3. \n            # alice_score_of_alice at i = \n            #  max(action_score_of_alice - (action_score_of_bob at i+j+1) for action in 3 cases)\n            res = -float('inf')\n            for j in range(3):\n                if i+j<len(A):\n                    this_res = sum(A[i:i+j+1])-dp(i+j+1)\n                    res = max(res, this_res)\n            return res\n        \n        if dp(0)>0:return 'Alice'\n        elif dp(0)<0:return 'Bob'\n        else:return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        \n        self.memo = collections.defaultdict(int)\n        self.stoneValue = stoneValue\n        score = self.dfs(0)  \n        return 'Tie' if score == 0 else 'Alice' if score > 0 else 'Bob'\n        \n    def dfs(self,start):\n        if start >= len(self.stoneValue):\n            return 0\n\n        if start in self.memo:\n            return self.memo[start]\n        \n        self.memo[start] = float('-inf')\n        score = 0\n\n        for i in range(start, min(len(self.stoneValue), start + 3)):\n            score += self.stoneValue[i]\n            self.memo[start] = max(self.memo[start], score - self.dfs(i + 1))\n\n        return self.memo[start]\n        \n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        dp = [0]*len(stoneValue)\n        for i in range(len(stoneValue)-1, -1, -1):\n            ans = float('-inf')\n            ans = max(ans, stoneValue[i] - (dp[i+1] if i+1<len(stoneValue) else 0))\n            if i+1 < len(stoneValue):\n                ans = max(ans, stoneValue[i] + stoneValue[i+1] - (dp[i+2] if i+2 < len(stoneValue) else 0))\n            \n            if i+2 < len(stoneValue):\n                ans = max(ans, stoneValue[i] + stoneValue[i+1] + stoneValue[i+2] - (dp[i+3] if i+3<len(stoneValue) else 0))\n            dp[i]  = ans \n            # num += stoneValue[i] # s[i]\n            # ans = max(ans, num-(dp[i+1] if i+1<len(stoneValue) else 0))            \n            # # if i+1<len(stoneValue):\n            # #     num += stoneValue[i+1] # s[i]+s[i+1]\n            # #     ans = max(ans, num-(dp[i+2] if i+2<len(stoneValue) else 0))\n            # #     dp[i] = ans\n            # # if i+2<len(stoneValue):\n            # #     num += stoneValue[i+2] # s[i]+s[i+1]+s[i+2]\n            # #     ans = max(ans, num-(dp[i+3] if i+3<len(stoneValue) else 0))\n            # #     dp[i] = ans\n            # dp[i] = ans\n\n        if dp[0]>0: return 'Alice'\n        elif dp[0]<0: return 'Bob'\n        else: return 'Tie'\n# dp[i] means the difference between the scores of Alice and Bob (relative score the current player can obtain). We want to maximize this difference, in order to make Alice win. Therefore, we traverse the list from the end to the beginning, and calculate this difference as max(s[i]-dp[i+1], s[i]+s[i+1]-dp[i+2], s[i]+s[i+1]+s[i+2]-dp[i+3]). Of course, if any index runs over the boundary of the list, no need to calculate it.\n\n", "#dp\n#f(i) = suffixsum[i] - min(f(i+x) for x in range(1,4))\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        memo = dict()\n        def dfs(i):\n            if i >= N:\n                return 0\n            if i in memo:\n                return memo[i]\n            memo[i] = suffixsum[i] - min([dfs(i+x) for x in range(1, 4)])\n            return memo[i]\n        N = len(stoneValue)\n        suffixsum, acc = [0] * N, 0\n        for i, v in enumerate(reversed(stoneValue)):\n            acc += v\n            suffixsum[~i] = acc\n        alice = dfs(0)\n        bob = suffixsum[0] - alice\n        if alice > bob:\n            return 'Alice'\n        elif alice == bob:\n            return 'Tie'\n        else:\n            return 'Bob'", "class Solution:    \n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        l = len(stoneValue)\n        dp = [0]*(l+1)\n        for i in range(l-1,-1,-1):\n            val = stoneValue[i]\n            dp[i] = val - dp[i+1]\n            if i+1 < l:\n                val += stoneValue[i+1]\n                dp[i] = max(dp[i], val - dp[i+2])\n            if i+2 < l:\n                val += stoneValue[i+2]\n                dp[i] = max(dp[i], val - dp[i+3])\n        if dp[0] > 0:\n            return 'Alice'\n        elif dp[0] == 0:\n            return 'Tie'\n        else:\n            return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        memo = {}\n        def dfs(stoneValue, i, memo):\n            if i in memo:\n                return memo[i]\n            if i >= len(stoneValue):\n                return 0\n            if i == len(stoneValue) - 1:\n                return stoneValue[i]\n            \n            maxi = stoneValue[i] + min(dfs(stoneValue, i+2, memo), dfs(stoneValue, i+3, memo), dfs(stoneValue, i+4, memo))\n            # print(maxi)\n            if i+1 <len(stoneValue):\n                maxi = max(maxi, stoneValue[i] + stoneValue[i+1] + min(dfs(stoneValue, i+3, memo), dfs(stoneValue, i+4, memo), dfs(stoneValue, i+5, memo)))\n            # print(maxi)\n            if i+2 < len(stoneValue):\n                maxi = max(maxi, sum(stoneValue[i:i+3]) + min(dfs(stoneValue, i+4, memo), dfs(stoneValue, i+5, memo), dfs(stoneValue, i+6, memo)))\n            # print(maxi)\n            # print(stoneValue, maxi)\n            memo[i] = maxi\n            return maxi\n            \n            \n            \n        aliceScore = dfs(stoneValue, 0, memo)\n        # print(aliceScore)\n        bobScore = sum(stoneValue) - aliceScore\n        # print(bobScore)\n        \n        \n        if aliceScore > bobScore:\n            return 'Alice'\n        \n        elif aliceScore < bobScore:\n            return 'Bob'\n        \n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        record = {}\n        def helper(i):\n            if i in record:\n                return record[i]\n            if i >= len(stoneValue):\n                return [0,0]\n            a, b = float('-inf'), float('-inf')\n            for x in range(i, min(i+3, len(stoneValue))):\n                temp = helper(x+1)\n                tempa, tempb = sum(stoneValue[i:x+1])+temp[1], temp[0]\n                if tempa > a:\n                    a, b = tempa, tempb\n            record[i] = [a, b]\n            return [a,b]\n        \n        a, b = helper(0)\n        #print(a,b)\n        if a > b:\n            return 'Alice'\n        elif a < b:\n            return 'Bob'\n        else:\n            return 'Tie'\n", "#dp\n#f(i) = suffixsum[i] - min(f(i+x) for x in range(1,4))\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        memo = dict()\n        def dfs(i):\n            if i > N-1:\n                return 0\n            if i in memo:\n                return memo[i]\n            memo[i] = suffixsum[i] - min([dfs(i+x) for x in range(1, 4)])\n            return memo[i]\n        N = len(stoneValue)\n        suffixsum, acc = [0] * N, 0\n        for i, v in enumerate(reversed(stoneValue)):\n            acc += v\n            suffixsum[~i] = acc\n        alice = dfs(0)\n        bob = suffixsum[0] - alice\n        if alice > bob:\n            return 'Alice'\n        elif alice == bob:\n            return 'Tie'\n        else:\n            return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        memo = [float('-inf')] * (n + 1)\n        score = 0\n        @lru_cache\n        def dfs(start, score=0):\n            for i in range(start, min(n, start + 3)):\n                score += stoneValue[i]\n                memo[start] = max(memo[start], score - dfs(i + 1))\n            return memo[start] if memo[start] != float('-inf') else 0 \n        return 'Tie' if dfs(0) == 0 else 'Alice' if dfs(0) > 0 else 'Bob'\n        \n        \n", "class Solution:\n    def stoneGameIII(self, nums: List[int]) -> str:\n        presum = list(itertools.accumulate(nums))\n        def sum(i, j):\n            if i == 0:\n                return presum[j]\n            return presum[j] - presum[i-1]\n        \n        n = len(nums)\n        if n > 1:\n            nums[-2] = max(sum(n-2, n-2), sum(n-2, n-1))\n        if n > 2:\n            # print(f' {nums[n-3]}+{sum(n-2, n-1)}-{nums[-2]}')\n            nums[-3] = max(nums[n-3]+sum(n-2, n-1)-nums[-2], sum(n-3, n-2), sum(n-3, n-1))\n        for i in range(n-4, -1, -1):\n            get_one = nums[i] + sum(i+1, n-1) - nums[i+1]\n            get_two = sum(i, i+1) + sum(i+2, n-1) - nums[i+2]\n            get_three = sum(i, i+2) + sum(i+3, n-1) - nums[i+3]\n            nums[i] = max([get_one, get_two, get_three])\n        # print(nums)\n        if nums[0] == sum(0, n-1)/2:\n            return 'Tie'\n        elif nums[0] > sum(0, n-1)/2:\n            return 'Alice'\n        return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        total = sum(stoneValue)\n        dp = {}\n        alice_get = self.find_score(stoneValue, 0, dp)\n        if alice_get * 2 > total:\n            return 'Alice'\n        elif alice_get * 2 < total:\n            return 'Bob'\n        else:\n            return 'Tie'\n    \n    \n    def find_score(self, stoneValue, i, dp):\n        if i in dp:\n            return dp[i]\n        if i == len(stoneValue) - 1:\n            return stoneValue[i]\n        elif i >= len(stoneValue):\n            return 0\n        elif i == len(stoneValue) - 2:\n            return max(stoneValue[i] + stoneValue[i + 1], stoneValue[i])\n        else:\n            dp[i] = max(stoneValue[i] + min(self.find_score(stoneValue, i + 2, dp), self.find_score(stoneValue, i + 3, dp),self.find_score(stoneValue, i + 4, dp)),\n                        stoneValue[i] + stoneValue[i + 1] + min(self.find_score(stoneValue, i + 5, dp), self.find_score(stoneValue, i + 3, dp),self.find_score(stoneValue, i + 4, dp)),\n                        stoneValue[i] + stoneValue[i + 1] + stoneValue[i + 2] + min(self.find_score(stoneValue, i + 5, dp), self.find_score(stoneValue, i + 6, dp),self.find_score(stoneValue, i + 4, dp))        \n            )\n            return dp[i]", "from functools import lru_cache\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # time complexity: O(n)\n        # space complexity: O(n)\n        @lru_cache(maxsize=None)\n        def score(i):\n            if i >= len(stoneValue): return 0\n            return max([sum(stoneValue[i:i+k]) - score(i+k) for k in [1,2,3]])\n        \n        s = score(0)\n        if s > 0: return 'Alice'\n        elif s < 0: return 'Bob'\n        else: return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        \n        n = len(stoneValue)\n        dp = [float('-inf')] * n\n        dp[-1] = stoneValue[-1]\n        for i in range(n - 2, -1, -1):\n            s = 0\n            for j in range(i, i + 3):\n                s += stoneValue[j] if j < n else 0\n                nxt = dp[j + 1] if j + 1 < n else 0\n                dp[i] = max(dp[i], s - nxt)\n        \n                \n                \n#         @lru_cache(None)\n#         def dp(cur):\n#             if cur == len(stoneValue) - 1:\n#                 return stoneValue[cur]\n#             if cur >= len(stoneValue):\n#                 return 0\n#             ret = float('-inf')\n#             s = 0\n#             for i in range(3):\n#                 nxt = dp(cur + i + 1)\n#                 s += stoneValue[cur + i] if cur + i < len(stoneValue) else 0\n#                 ret = max(ret, s - nxt)\n#             return ret\n\n#         ans = dp(0)\n        print(dp)\n        ans = dp[0]\n        if ans > 0:\n            return 'Alice'\n        elif ans < 0:\n            return 'Bob'\n        else:\n            return 'Tie'\n\n            \n", "# Relative easy DP problem, time and space complexity are both O(N)\nfrom functools import lru_cache\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        c=0\n        sums=[]\n        for i in range(len(stoneValue)-1,-1,-1):\n            c+=stoneValue[i]\n            sums.append(c)\n        @lru_cache(None)\n        def optimalValue(s):\n            if not s:\n                return 0\n            return max([sums[s-1]-optimalValue(s-i) for i in range(1,4) if s-i>=0])\n        half=0.5*sums[-1]\n        res=optimalValue(len(stoneValue))\n        return 'Alice' if res>half else 'Bob' if res<half else 'Tie'\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        \n        n = len(stoneValue)\n        presum = [0] * (n + 1)\n        for i, num in enumerate(stoneValue):\n            presum[i+1] = presum[i] + num\n        presum += [presum[-1]] * 3\n        \n        dp = [[0] * 2 for _ in range(n+3)]\n        for i in range(n-1, -1, -1):\n            for k in range(2):\n                dp[i][k] = max(-dp[j][1-k] + presum[j] - presum[i] for j in range(i+1, i+4))\n        \n        if dp[0][0] > 0:\n            return 'Alice'\n        elif dp[0][0] < 0:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        stone_sum = 0\n        dp = [0] * (len(stoneValue) + 1) + [float('inf')] * 2\n        for i in range(len(stoneValue) - 1, -1, -1):\n            stone_sum += stoneValue[i]\n            chose = min(dp[i+1], dp[i+2], dp[i+3])\n            dp[i] = stone_sum - chose\n        if dp[i] > stone_sum / 2: return 'Alice'\n        elif dp[i] < stone_sum / 2: return 'Bob'\n        else: return 'Tie'\n", "# Sample [1,2,3,7], max gain at each step: [6, 12, 10, 7, 0]\n# for [9,-12,8,12,-12,-16,-13,-11,2,2,-10,-5,13,12,-4,13,4,-4,-16,6,-2,13,-8]\n# exp [-7, -12, 0, -4, -16, -4, -20, 12, 23, 21, -7, 27, 32, 19, -5, 24, 11, 7, -18, 17, 11, 13, -8, 0]\n\nclass Solution:\n    # TLE\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        \n        # remaining total value at each index\n        remain = list(itertools.accumulate(stoneValue[::-1]))[::-1]\n        \n        @lru_cache(None)\n        def dp(idx):\n            if idx >= len(stoneValue):\n                return 0\n            return remain[idx] - min(dp(idx+i) for i in range(1,4))\n        \n        first = dp(0)\n        second = remain[0] - first\n        # print([dp(i) for i in range(len(stoneValue))])\n        return 'Alice' if first > second else 'Tie' if first == second else 'Bob'\n        \n\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        \n        # remaining total value at each index\n        remain = list(itertools.accumulate(stoneValue[::-1]))[::-1]\n        n = len(stoneValue)\n        dp = [0] * (n + 4)\n        \n        for idx in range(n-1,-1,-1):\n            dp[idx] = remain[idx] - min(dp[idx+i] for i in range(1,4))\n        \n        first = dp[0]\n        second = remain[0] - first\n        print([dp[i] for i in range(len(stoneValue))])\n        return 'Alice' if first > second else 'Tie' if first == second else 'Bob'\n\n\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        dic = collections.defaultdict(int)\n        \n        sums = {-1: 0}\n        total = sum(stoneValue)\n        for i, s in enumerate(stoneValue):\n            sums[i] = sums[i - 1] + s\n        for i in sums:\n            sums[i] = total - sums[i] + stoneValue[i]\n        sums.pop(-1)\n        \n        def dfs(s=0):\n            if s not in dic and s < len(stoneValue):\n                dic[s] = sums[s] - min([dfs(s + i + 1) for i in range(3)])\n            return dic[s]\n        dfs()\n        return 'Bob' if total > 2 * dic[0] else 'Alice' if total < 2 * dic[0] else 'Tie'", "from functools import lru_cache\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        c=0\n        sums=[]\n        for i in range(len(stoneValue)-1,-1,-1):\n            c+=stoneValue[i]\n            sums.append(c)\n        \n        @lru_cache(None)\n        def optimalValue(s):\n            if not s:\n                return 0\n            return max([sums[s-1]-optimalValue(s-i) for i in range(1,4) if s-i>=0])\n        half=0.5*sum(stoneValue)\n        res=optimalValue(len(stoneValue))\n        return 'Alice' if res>half else 'Bob' if res<half else 'Tie'\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        dp = [float('-inf')]*len(stoneValue)\n        self.presum = [0]*(len(stoneValue) + 1)\n        for idx, num in enumerate(stoneValue[::-1]):\n            self.presum[len(stoneValue) - idx - 1] = self.presum[len(stoneValue) - idx] + num\n        self.presum.pop()\n        \n        alice_score = self.helper(stoneValue, 0, dp)\n        if alice_score > sum(stoneValue) - alice_score:\n            return 'Alice'\n        elif alice_score < sum(stoneValue) - alice_score:\n            return 'Bob'\n        else:\n            return 'Tie'\n    \n    def helper(self, nums, start, dp):\n        if dp[start] != float('-inf'):\n            return dp[start]\n        \n        if start == len(nums) - 1:\n            dp[start] = nums[start]\n            return nums[start]\n        \n        if start == len(nums) - 2:\n            dp[start] = max(self.presum[start], nums[start])\n            return dp[start]\n        \n        if start == len(nums) - 3:\n            dp[start] = max(self.presum[start], self.presum[start] - self.helper(nums, start + 1, dp), self.presum[start] - self.helper(nums, start + 2, dp))\n            return dp[start]\n        \n        num1 = self.presum[start] - self.helper(nums, start + 1, dp)\n        num2 = self.presum[start] - self.helper(nums, start + 2, dp) if start + 2 < len(nums) else float('-inf')\n        num3 = self.presum[start] - self.helper(nums, start + 3, dp) if start + 3 < len(nums) else float('-inf')\n        dp[start] = max(num1, num2, num3)\n        return dp[start]", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # aliceScore = [0]\n        # bobScore = [0]\n        # INVALID = 's'\n        # def helper(stoneValues,index,aliceScore,bobScore,aliceTurn):\n        #     scoreToUpdate = aliceScore\n        #     if not aliceTurn:\n        #         scoreToUpdate = bobScore\n        #     if len(stoneValues) - 1 == index:\n        #         scoreToUpdate[0] += stoneValues[index]\n        #         return\n        #     bck = scoreToUpdate[0]\n        #     sums = []\n        #     for i in range(1,4):\n        #         scoreToUpdate[0] = bck\n        #         if i + index <= len(stoneValues):\n        #             for j in range(i):\n        #                 scoreToUpdate[0] += stoneValues[index+j]\n        #             helper(stoneValues,index + i,aliceScore,bobScore,not aliceTurn)\n        #             sums.append(scoreToUpdate[0])\n        #     if len(sums) > 0:\n        #         scoreToUpdate[0] = max(sums)\n        #     else:\n        #         scoreToUpdate[0] = bck\n        #     return\n        # helper(stoneValue,0,aliceScore,bobScore,True)\n        # if aliceScore[0] > bobScore[0]:\n        #     return 'Alice'\n        # elif bobScore[0] > aliceScore[0]:\n        #     return 'Bob'\n        # return 'Tie'\n        # def helper(stoneValues,index):\n        #     if index in mem:\n        #         return mem[index]\n        #     if index >= len(stoneValues):\n        #         return 0\n        #     ans = stoneValues[index] - helper(stoneValues,index+1)\n        #     if index + 1 < len(stoneValues):\n        #         temp = stoneValues[index] + stoneValues[index+1] - helper(stoneValues,index+2)\n        #         ans = max(ans,temp)\n        #     if index + 2 < len(stoneValues):\n        #         temp = stoneValues[index] + stoneValues[index+1] + stoneValues[index+2] - helper(stoneValues,index+3)\n        #         ans = max(ans,temp)\n        #     mem[index] = ans\n        #     return ans\n        # ans = helper(stoneValue,0)\n        mem = {i:0 for i in range(len(stoneValue)+1)}\n        mem1, mem2, mem3 = 0, 0, 0\n        i = len(stoneValue) - 1\n        while i >= 0:\n            ans = stoneValue[i] - mem1\n            if i + 1 < len(stoneValue):\n                ans = max(ans,stoneValue[i] + stoneValue[i+1] - mem2)\n            if i + 2 < len(stoneValue):\n                 ans = max(ans,stoneValue[i] + stoneValue[i+1] + stoneValue[i+2] - mem3)\n            mem3 = mem2\n            mem2 = mem1\n            mem1 = ans\n            i -= 1\n        if ans > 0:\n            return 'Alice'\n        elif ans < 0:\n            return 'Bob'\n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, stones: List[int]) -> str:\n        n = len(stones)\n        dp = [-math.inf] * (n + 1)\n        dp[n] = 0\n        for i in range(n - 1, -1, -1):\n            take = 0\n            for j in range(i + 1, min(i + 3, n) + 1):\n                take += stones[j - 1]\n                dp[i] = max(dp[i], take - dp[j])\n        return 'Alice' if dp[0] > 0 else 'Bob' if dp[0] < 0 else 'Tie'\n\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        @lru_cache(maxsize=None)\n        def solve(i: int) -> int:\n            if i >= len(stoneValue):\n                return 0\n            \n            res = -math.inf\n            for stones in range(1, 4):\n                curr_val = sum(stoneValue[i: i + stones]) + min(solve(i + stones + 1), solve(i + stones + 2), solve(i + stones + 3))\n                res = max(res, curr_val)\n            \n            return res\n        \n        alice = solve(0)\n        bob = sum(stoneValue) - alice\n        if alice == bob:\n            return 'Tie'\n        elif alice > bob:\n            return 'Alice'\n        else:\n            return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        self.cache = [0] * 50001\n        total = sum(stoneValue)\n        first = (total + self.helper(stoneValue, 0)) // 2\n        second = total - first\n        if first > second:\n            return 'Alice'\n        elif first < second:\n            return 'Bob'\n        else:\n            return 'Tie'\n    \n    def helper(self, stoneValue, index):\n        if self.cache[index]:\n            return self.cache[index]\n        \n        n = len(stoneValue)\n        if index == n:\n            return 0\n\n        if index == n - 1:\n            return stoneValue[-1]\n        \n        cur = 0\n        best = -sys.maxsize\n        for i in range(3):\n            if index + i >= n:\n                break\n            \n            cur += stoneValue[index + i]\n            best = max(best, cur - self.helper(stoneValue, index + i + 1))\n        \n        self.cache[index] = best\n        return best\n", "from functools import lru_cache\n\n\nclass Solution:\n    def stoneGameIII(self, s: List[int]) -> str:\n        nums = len(s)\n        \n        @lru_cache(None)\n        def helper(index, first):\n            r = nums - index\n            \n            if r == 0:\n                return 0, 0\n\n            if r == 1:\n                if first:\n                    return s[-1], 0\n                else:\n                    return 0, s[-1]\n            \n            if r == 2:\n                x, y = s[-2:]\n                if 0 <= x and 0 <= y or x < 0 and y > 0:\n                    if first:\n                        return x+y, 0\n                    return 0, x+y\n                if first:\n                    return x, y\n                return y, x\n            \n            a1, b1 = helper(index+1, not first)\n            a2, b2 = helper(index+2, not first)\n            a3, b3 = helper(index+3, not first)\n            \n            if first:\n                a1 += s[index]\n                a2 += sum(s[index:index+2])\n                a3 += sum(s[index:index+3])\n            else:\n                b1 += s[index]\n                b2 += sum(s[index:index+2])\n                b3 += sum(s[index:index+3])\n            \n            choices = [(a1, b1), (a2, b2), (a3, b3)]\n            if first:\n                return max(choices)\n            return min(choices)\n        \n        a, b = helper(0, True)\n        if a == b:\n            return 'Tie'\n        if a < b:\n            return 'Bob'\n        return 'Alice'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        numStones = len(stoneValue)\n        dp = [-float('inf')] * numStones\n        for i in range(numStones - 1, -1, -1):\n            localTotal = 0\n            for j in range(i, min(i+3, numStones)):\n                localTotal += stoneValue[j]\n                otherPlayerMax = dp[j+1] if j+1 < numStones else 0\n                dp[i] = max(dp[i], localTotal - otherPlayerMax)\n        #print(dp)\n        winner = 'Alice' if dp[0] > 0 else 'Bob' if dp[0] < 0 else 'Tie'\n        return winner\n                \n", "from functools import lru_cache\n\n\nclass Solution:\n    def stoneGameIII(self, s: List[int]) -> str:\n        nums = len(s)\n        \n        @lru_cache(maxsize=10000)\n        def helper(index, first):\n            r = nums - index\n            \n            if r == 0:\n                return 0, 0\n\n            if r == 1:\n                if first:\n                    return s[-1], 0\n                else:\n                    return 0, s[-1]\n            \n            if r == 2:\n                x, y = s[-2:]\n                if 0 <= x and 0 <= y or x < 0 and y > 0:\n                    if first:\n                        return x+y, 0\n                    return 0, x+y\n                if first:\n                    return x, y\n                return y, x\n            \n            a1, b1 = helper(index+1, not first)\n            a2, b2 = helper(index+2, not first)\n            a3, b3 = helper(index+3, not first)\n            \n            if first:\n                a1 += s[index]\n                a2 += sum(s[index:index+2])\n                a3 += sum(s[index:index+3])\n            else:\n                b1 += s[index]\n                b2 += sum(s[index:index+2])\n                b3 += sum(s[index:index+3])\n            \n            choices = [(a1, b1), (a2, b2), (a3, b3)]\n            if first:\n                return max(choices)\n            return min(choices)\n        \n        a, b = helper(0, True)\n        if a == b:\n            return 'Tie'\n        if a < b:\n            return 'Bob'\n        return 'Alice'", "from functools import lru_cache\n\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        vals = stoneValue\n        n = len(vals)\n        @lru_cache(None)\n        def play(i):\n            if i == n:\n                return 0, 0\n            p1, p2 = -1e9, -1\n            s = 0\n            for j in range(i, min(i + 3, n)):\n                s += vals[j]\n                p1_, p2_ = play(j + 1)\n                p2_ += s\n                if p2_ > p1:\n                    p1 = p2_\n                    p2 = p1_\n            return p1, p2\n        \n        p1, p2 = play(0)\n        # print(p1, p2)\n        # p2 = sum(vals) - p1\n        if p1 > p2:\n            return 'Alice'\n        elif p1 == p2:\n            return 'Tie'\n        return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        dp = {}\n        total = sum(stoneValue)\n        def help(start, s):\n            if start in dp: return dp[start]\n            if start >= len(stoneValue): return 0\n            dp[start] = max(s - help(start+1, s-stoneValue[start]), s- help(start+2,s-sum(stoneValue[start:start+2])), s-help(start+3,s-sum(stoneValue[start: start+3])))\n            return dp[start]\n        \n        \n        A = help(0, total)\n       \n        if 2*A > total: return 'Alice'\n        elif 2*A == total: return 'Tie'\n        else: return 'Bob'", "from functools import lru_cache\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        @lru_cache(None)\n        def getScore(idx,aliceNext):#score = Alice-Bob\n            if idx==n:\n                return 0\n            if aliceNext:\n                res=-float('inf')\n                t=0\n                for i in range(3):\n                    if idx+i==n:\n                        break\n                    t+=values[idx+i]\n                    res=max(res,t+getScore(idx+i+1,False))\n                return res\n            else:\n                res=float('inf')\n                t=0\n                for i in range(3):\n                    if idx+i==n:\n                        break\n                    t+=values[idx+i]\n                    res=min(res,-t+getScore(idx+i+1,True))\n                return res\n        values=stoneValue            \n        n=len(values)\n        for i in range(n-1,-1,-1):\n            getScore(i,True)\n            getScore(i,False)\n        \n        ans=getScore(0,True)\n        \n        ans2='Tie'\n        if ans>0:\n            ans2='Alice'\n        if ans<0:\n            ans2='Bob'\n        return ans2", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(index, my_turn):\n            if index >= len(stoneValue):\n                return 0\n            if my_turn:\n                rst = float('-inf')\n                for i in range(3):\n                    rst = max(rst, sum(stoneValue[index:index+i+1]) + dp(index+i+1, False))\n                return rst\n            \n            rst = float('inf')\n            for i in range(3):\n                rst = min(rst, dp(index+i+1, True))\n            return rst\n        \n        score = dp(0, True) * 2\n        if score < sum(stoneValue):\n            return 'Bob'\n        if score == sum(stoneValue):\n            return 'Tie'\n        return 'Alice'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        firstSelect = True  # True denoted Alice select first, False for Bob\n        initIndex = 0\n        stoneValueLength = len(stoneValue)\n        mem = {}\n\n        if stoneValueLength == 0:\n            return 'Tie'\n        else:\n            result = self.recursiveHelper(stoneValue, stoneValueLength, initIndex, firstSelect, mem)\n            #print(result)\n            if result > 0:\n                return 'Alice'\n            elif result < 0:\n                return 'Bob'\n            else:\n                return 'Tie'\n\n    def recursiveHelper(self, stoneValue: List[int], length: int, index: int, flag: bool, mem: dict) -> int:\n\n        if index >= length:\n            return 0\n\n        memV = mem.get((index, flag))\n        if memV is not None:\n            return memV\n\n        minus = length - index\n        if minus == 1:  # only one choice\n            curr = stoneValue[index]\n            c1 = curr if flag else -curr\n            mem[(index, flag)] = c1\n            return c1\n        elif minus == 2:  # two choices\n            # 1 select all two\n            curr = stoneValue[index] + stoneValue[index + 1]\n            c1 = curr if flag else -curr\n\n            # 2 select the first one\n            curr = stoneValue[index]\n            c2 = (curr if flag else -curr) + self.recursiveHelper(stoneValue, length, index + 1, not flag, mem)\n\n            result = max(c1, c2) if flag else min(c1, c2)\n            mem[(index, flag)] = result\n            return result\n        else:  # >= 3; three choices\n            # 1 select all three\n            curr = stoneValue[index] + stoneValue[index + 1] + stoneValue[index + 2]\n            c1 = (curr if flag else -curr) + self.recursiveHelper(stoneValue,length, index + 3, not flag, mem)\n\n            # 2 select the first two\n            curr = stoneValue[index] + stoneValue[index + 1]\n            c2 = (curr if flag else -curr) + self.recursiveHelper(stoneValue, length, index + 2, not flag, mem)\n\n            # 3 select the first one\n            curr = stoneValue[index]\n            c3 = (curr if flag else -curr) + self.recursiveHelper(stoneValue, length, index + 1, not flag, mem)\n            result = max(c1, c2, c3) if flag else min(c1, c2, c3)\n            mem[(index, flag)] = result\n            return result\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        @lru_cache(None)\n        def dp(i, t):\n            if i == len(stoneValue):\n                return 0\n            if t == 0:\n                m = -math.inf\n                s = 0\n                for j in range(i, min(i+3, len(stoneValue))):\n                    s += stoneValue[j]\n                    m = max(m, s + dp(j+1, 1))\n            else:\n                m = math.inf\n                s = 0\n                for j in range(i, min(i+3, len(stoneValue))):\n                    s -= stoneValue[j]\n                    m = min(m, s + dp(j+1, 0))\n            return m\n        \n        ans = dp(0, 0)\n        if ans > 0:\n            return 'Alice'\n        elif ans < 0:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        self.cache = {}\n        score = self.solve(0, stoneValue)\n        return 'Alice' if score > 0 else 'Bob' if score < 0 else 'Tie'\n    \n\n    def solve(self, s, stoneValue): # score diff\n        n = len(stoneValue)\n        if s>=n: \n            return 0\n\n        if s in self.cache: \n            return self.cache[s]\n\n        best = -2**31\n        presum = 0\n\n        for x in range(1, 4):\n            if s+x-1>=n:\n                break\n            presum += stoneValue[s+x-1]\n            best = max(best, presum - self.solve(s+x, stoneValue)) # min-max process\n        self.cache[s] = best\n        return best\n    \n    \n    \n    \n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        ts = sum(stoneValue)\n        n = len(stoneValue)\n        \n        a = [0 for i in range(n)]\n        for i in range(n-1, -1, -1):\n            if i == n-1:\n                a[i] = stoneValue[i]\n            else:\n                a[i] = a[i+1] + stoneValue[i]\n        \n        cache = {}\n        def process(i):\n            if i == n:\n                return 0\n            else:\n                if not i in cache:\n                    ans = -float('inf')\n                    if i < n:\n                        ans = max(ans, stoneValue[i] + (a[i+1] - process(i+1) if i+1 < n else 0))\n                    if i+1 < n:\n                        ans = max(ans, stoneValue[i]+stoneValue[i+1] + (a[i+2] - process(i+2) if i+2 < n else 0))\n                    if i+2 < n:\n                        ans = max(ans, stoneValue[i]+stoneValue[i+1]+stoneValue[i+2] + (a[i+3] - process(i+3) if i+3 < n else 0))\n                    cache[i] = ans\n                return cache[i]\n        \n        Alice = process(i)\n        Bob = ts - Alice\n        if Alice > Bob:\n            return 'Alice'\n        elif Bob > Alice:\n            return 'Bob'\n        else:\n            return 'Tie'\n", "from functools import lru_cache\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        @lru_cache(None)\n        def getScore(idx,aliceNext):#score = Alice-Bob\n            if idx==n:\n                return 0\n            if aliceNext:\n                res=-float('inf')\n                t=0\n                for i in range(3):\n                    if idx+i==n:\n                        break\n                    t+=values[idx+i]\n                    res=max(res,t+getScore(idx+i+1,False))\n                return res\n            else:\n                res=float('inf')\n                t=0\n                for i in range(3):\n                    if idx+i==n:\n                        break\n                    t+=values[idx+i]\n                    res=min(res,-t+getScore(idx+i+1,True))\n                return res\n        values=stoneValue            \n        n=len(values)\n        ans=getScore(0,True)\n        \n        ans2='Tie'\n        if ans>0:\n            ans2='Alice'\n        if ans<0:\n            ans2='Bob'\n        return ans2", "class Solution:\n    def stoneGameIII(self, stoneValue) -> str:\n        total_value = sum(stoneValue)\n        num_stones = len(stoneValue)\n        \n        @lru_cache(None)\n        def helper(ind, player):\n            if ind >= num_stones:\n                return 0\n            \n            if player == 'A': # Alex as the player\n                tmp_result = []\n                for i in range(1, 4):\n                    if ind + i <= num_stones:\n                        tmp_result.append( sum(stoneValue[ind: ind+i]) + helper(ind+i, 'L')  )\n                    else:\n                        tmp_result.append( sum(stoneValue[ind: ]) + helper(num_stones, 'L')  )\n                return max(tmp_result)\n            elif player == 'L':\n                tmp_result = []\n                for i in range(1, 4):\n                    if ind + i <= num_stones:\n                        tmp_result.append(helper(ind+i, 'A')  )\n                    else:\n                        tmp_result.append(helper(num_stones, 'A')  )\n                    \n                return min(tmp_result)\n        \n        alex_score = helper(0, 'A')\n        \n        if alex_score > total_value / 2.:\n            return 'Alice'\n        elif alex_score < total_value / 2.:\n            return 'Bob'\n        else:\n            return 'Tie'", "from functools import lru_cache\n\n\nclass Solution:\n    def stoneGameIII(self, s: List[int]) -> str:\n        nums = len(s)\n        memo = {}\n        \n        def helper(index, first):\n            if (index, first) in memo:\n                return memo[index, first]\n            \n            r = nums - index\n            \n            if r == 0:\n                return 0, 0\n\n            if r == 1:\n                if first:\n                    return s[-1], 0\n                else:\n                    return 0, s[-1]\n            \n            if r == 2:\n                x, y = s[-2:]\n                if 0 <= x and 0 <= y or x < 0 and y > 0:\n                    if first:\n                        return x+y, 0\n                    return 0, x+y\n                if first:\n                    return x, y\n                return y, x\n            \n            a1, b1 = helper(index+1, not first)\n            a2, b2 = helper(index+2, not first)\n            a3, b3 = helper(index+3, not first)\n            \n            if first:\n                a1 += s[index]\n                a2 += sum(s[index:index+2])\n                a3 += sum(s[index:index+3])\n            else:\n                b1 += s[index]\n                b2 += sum(s[index:index+2])\n                b3 += sum(s[index:index+3])\n            \n            choices = [(a1, b1), (a2, b2), (a3, b3)]\n            if first:\n                ans = max(choices)\n            else:\n                ans = min(choices)\n            \n            memo[index, first] = ans\n            return ans\n        \n        a, b = helper(0, True)\n        if a == b:\n            return 'Tie'\n        if a < b:\n            return 'Bob'\n        return 'Alice'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        if not stoneValue:\n            return 'Tie'\n        \n        pre_sum = [0 for _ in range(len(stoneValue) + 1)]\n        for i in range(len(stoneValue)):\n            pre_sum[i+1] = pre_sum[i] + stoneValue[i]\n        \n        @lru_cache(None)\n        def dfs(idx, player):\n            if idx > len(stoneValue) - 1:\n                return 0\n            if player == 1:\n                res = float('-inf')\n                for i in range(1, 4):\n                    # Take 1, 2, 3 stones from head.\n                    if idx + i > len(stoneValue):\n                        break\n                    res = max(res, pre_sum[idx + i] - pre_sum[idx] + dfs(idx + i, -player))\n            else:\n                res = float('inf')\n                for i in range(1, 4):\n                    res = min(res, dfs(idx+i, -player))\n            \n            return res\n        \n        a_sum = dfs(0, 1)\n        b_sum = pre_sum[-1] - a_sum\n        \n        if a_sum == b_sum:\n            return 'Tie'\n        elif a_sum > b_sum:\n            return 'Alice'\n        else:\n            return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        memo = {}\n        \n        def dfs(i, bob):\n            if (i, bob) in memo:\n                return memo[i, bob]\n            \n            if i >= n:\n                return 0\n            \n            ans = float('inf') if bob else float('-inf')\n            for x in [1, 2, 3]:\n                sub = dfs(i + x, 1 - bob)\n                if bob: \n                    ans = min(ans, sub)     # minimize what alex get\n                else:\n                    ans = max(ans, sub + sum(stoneValue[i:i + x]))\n            \n            memo[i, bob] = ans\n            return ans\n        \n        \n        dfs(0, 0)\n        dfs(0, 1)\n        if memo[0, 1] == memo[0, 0]:\n            return 'Tie'\n        \n        return 'Bob' if memo[0, 1] > memo[0, 0] else 'Alice'\n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        \n        stoneN = len(stoneValue)\n        totalScore = sum(stoneValue)\n        \n        dp = {}\n        \n        def play(i0, ARound):\n            if i0 == stoneN:\n                return 0\n            if (i0, ARound) in dp:\n                return dp[(i0, ARound)]\n            if ARound:\n                subAns = float('-inf')\n                thisRoundScore = 0\n                for j in range(i0, min(i0+3, stoneN)):\n                    thisRoundScore += stoneValue[j]\n                    subAns = max(subAns, thisRoundScore + play(j+1, False))\n            else:\n                subAns = float('inf')\n                for j in range(i0, min(i0+3, stoneN)):\n                    subAns = min(subAns, play(j+1, True))\n            \n            dp[(i0, ARound)] = subAns\n            return subAns\n        \n        aScore = play(0, True) \n        bScore = totalScore - aScore\n        # print(aScore, bScore)\n        \n        if aScore == bScore:\n            return 'Tie'\n        elif aScore > bScore:\n            return 'Alice'\n        else:\n            return 'Bob'\n        \n#         AliceWinDict = {}\n#         TieDict = {}\n#         BobWinDict = {}\n#         dp = {}\n        \n#         def play(i0, ARound, aScore, bScore):\n#             if i0 == stoneN:\n#                 if aScore == bScore:\n#                     return 'Tie'\n#                 elif aScore > bScore:\n#                     return 'Alice'\n#                 else:\n#                     return 'Bob'\n            \n#             if (i0, ARound, aScore, bScore) in dp:\n#                 return dp[(i0, ARound, aScore, bScore)]\n            \n#             if (i0, ARound) in TieDict:\n#                 if aScore > TieDict[(i0, ARound)]:\n#                     ans = 'Alice'\n#                 elif aScore < TieDict[(i0, ARound)]:\n#                     ans = 'Bob'\n#                 return 'Tie'\n#                 # ans = 'Tie'\n#             else:\n            \n#                 if (i0, ARound) in AliceWinDict:\n#                     if aScore >= AliceWinDict[(i0, ARound)]:\n#                         return 'Alice'\n\n#                 if (i0, ARound) in BobWinDict:\n#                     if bScore >= BobWinDict[(i0, ARound)]:\n#                         return 'Bob'\n\n#                 if ARound:\n#                     ans = None\n#                     thisRoundScore = 0\n#                     for j in range(i0, min(i0+3, stoneN)):\n#                         thisRoundScore += stoneValue[j]\n#                         subAns = play(j+1, False, aScore + thisRoundScore, bScore)\n\n#                         if subAns == 'Alice':\n#                             ans = 'Alice'\n#                             break\n#                         elif subAns == 'Tie':\n#                             if ans == None:\n#                                 ans = 'Tie'\n#                     if ans == None:\n#                         ans = 'Bob'\n#                 else:\n#                     ans = None\n#                     thisRoundScore = 0\n#                     for j in range(i0, min(i0+3, stoneN)):\n#                         thisRoundScore += stoneValue[j]\n#                         subAns = play(j+1, True, aScore, bScore + thisRoundScore)\n#                         if subAns == 'Bob':\n#                             ans = 'Bob'\n#                             break\n#                         elif subAns == 'Tie':\n#                             if ans == None:\n#                                 ans = 'Tie'\n#                     if ans == None:\n#                         ans = 'Alice'\n                    \n#             if ans == 'Tie':\n#                 TieDict[(i0, ARound)] = aScore\n                \n#             elif ans == 'Alice':\n#                 if (i0, ARound) in AliceWinDict:\n#                     AliceWinDict[(i0, ARound)] = min(aScore, AliceWinDict[(i0, ARound)])\n#                 else:\n#                     AliceWinDict[(i0, ARound)] = aScore\n                    \n#             elif ans == 'Bob':\n#                 if (i0, ARound) in BobWinDict:\n#                     BobWinDict[(i0, ARound)] = min(bScore, BobWinDict[(i0, ARound)])\n#                 else:\n#                     BobWinDict[(i0, ARound)] = bScore   \n                    \n#             dp[(i0, ARound, aScore, bScore)] = ans\n#             return ans\n        \n#         return play(0, True, 0, 0)\n", "class Solution:\n    def stoneGameIII(self, cards):\n        dp = [float('-inf')]*(len(cards))\n        \n        for i in range(len(dp)-1,-1, -1):\n            if len(dp)-1 - i >= 3:\n                dp[i] = max(sum(cards[i:i+3]) - dp[i+3], sum(cards[i:i+2]) - dp[i+2], sum(cards[i:i+1]) - dp[i+1])\n            elif len(dp)-1 - i == 2:\n                dp[i] = max(sum(cards[i:i+3]), sum(cards[i:i+2]) - dp[i+2], sum(cards[i:i+1]) - dp[i+1])\n            elif len(dp)-1 - i == 1:\n                dp[i] = max(sum(cards[i:i+2]), sum(cards[i:i+1]) - dp[i+1])\n            elif len(dp)-1 - i == 0:\n                dp[i] = cards[i]\n        print(dp)\n        if dp[0] >0:\n            return 'Alice'\n        elif dp[0] < 0:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, cards):\n        lookup = {}\n        val = self.scoreGivenCards(cards, 0, True, lookup)\n        result =  val - sum(cards)/2\n        if result > 0:\n            return 'Alice'\n        elif result < 0:\n            return 'Bob'\n        else:\n            return 'Tie'\n\n    def scoreGivenCards(self, cards, index, is_it_your_turn, lookup):\n        if index >= len(cards):\n            return 0    \n        if is_it_your_turn:\n            # pick 1\n            if (index + 1, not is_it_your_turn) not in lookup:\n                lookup[(index + 1, not is_it_your_turn)] = self.scoreGivenCards(cards, index + 1, not is_it_your_turn, lookup)\n            score_with_one = cards[index] + lookup[(index + 1, not is_it_your_turn)]\n            # pick 2\n            if (index + 2, not is_it_your_turn) not in lookup:\n                lookup[(index + 2), not is_it_your_turn] = self.scoreGivenCards(cards, index + 2, not is_it_your_turn, lookup)\n            score_with_two = sum(cards[index:index+2]) +  lookup[(index + 2, not is_it_your_turn)]\n            # pick 3\n            if (index + 3, not is_it_your_turn) not in lookup:\n                lookup[(index + 3, not is_it_your_turn)] = self.scoreGivenCards(cards, index + 3, not is_it_your_turn, lookup)\n            score_with_three = sum(cards[index:index+3]) +  lookup[(index + 3, not is_it_your_turn)]\n            return max(score_with_one, score_with_two, score_with_three)\n        else:\n            # pick 1\n            if (index + 1, not is_it_your_turn) not in lookup:\n                lookup[(index + 1, not is_it_your_turn)] = self.scoreGivenCards(cards, index + 1, not is_it_your_turn, lookup)\n            score_with_one = lookup[(index + 1, not is_it_your_turn)]\n            # pick 2\n            if (index + 2, not is_it_your_turn) not in lookup:\n                lookup[(index + 2, not is_it_your_turn)] = self.scoreGivenCards(cards, index + 2, not is_it_your_turn, lookup)\n            score_with_two = lookup[(index + 2, not is_it_your_turn)]\n            # pick 3\n            if (index + 3, not is_it_your_turn) not in lookup:\n                lookup[(index + 3, not is_it_your_turn)] = self.scoreGivenCards(cards, index + 3, not is_it_your_turn, lookup)\n            score_with_three = lookup[(index + 3, not is_it_your_turn)]\n            return min(score_with_one, score_with_two, score_with_three)", "class Solution:\n    def stoneGameIII(self, S: List[int]) -> str:\n        \n        n = len(S)\n        \n        dp = [0] * n\n        \n        for i in range(n)[::-1]:\n            for k in range(1, 4):\n                dp[i] =  max(sum(S[i:i+k]) - (dp[i+k] if i + k < n else 0) for k in (1,2,3)  )\n            \n        \n        if dp[0] > 0:\n            return 'Alice'\n        elif dp[0] < 0:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        presum = [0]\n        for num in stoneValue:\n            presum.append(presum[-1] + num)\n        \n        @lru_cache(None)\n        def dfs(i):\n            if i >= len(stoneValue):\n                return 0\n            ans = float('-inf')\n            temp = 0\n            for k in range(3):\n                if i + k < len(stoneValue):\n                    temp += stoneValue[i + k]\n                    remain = presum[-1] - presum[i + k + 1]\n                    ans = max(ans, temp + remain - dfs(i + k + 1))\n                    \n            return  ans\n            \n        total = dfs(0)\n        if total * 2 > presum[-1]:\n            return 'Alice'\n        elif total * 2 < presum[-1]:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stones: List[int]) -> str:\n        n = len(stones)\n        memo = {}\n        def solve(i):\n            if i == n:\n                return 0\n            if i in memo:\n                return memo[i]\n            ans, curr = -math.inf, 0\n            for j in range(i, min(n, i+3)):\n                curr += stones[j]\n                ans = max(ans, curr-solve(j+1))\n            memo[i] = ans\n            return ans\n        score = solve(0)\n        if score > 0:\n            return 'Alice'\n        elif score < 0:\n            return 'Bob'\n        else:\n            return 'Tie'\n", "from functools import lru_cache\n\n\nclass Solution:\n    def stoneGameIII(self, s: List[int]) -> str:\n        nums = len(s)\n        memo = {}\n        \n        def helper(index, first):\n            r = nums - index\n            \n            if r == 0:\n                return 0, 0\n\n            if r == 1:\n                if first:\n                    return s[-1], 0\n                else:\n                    return 0, s[-1]\n            \n            if r == 2:\n                x, y = s[-2:]\n                if 0 <= x and 0 <= y or x < 0 and y > 0:\n                    if first:\n                        return x+y, 0\n                    return 0, x+y\n                if first:\n                    return x, y\n                return y, x\n            \n            if (index, first) in memo:\n                return memo[index, first]\n            \n            a1, b1 = helper(index+1, not first)\n            a2, b2 = helper(index+2, not first)\n            a3, b3 = helper(index+3, not first)\n            \n            if first:\n                a1 += s[index]\n                a2 += sum(s[index:index+2])\n                a3 += sum(s[index:index+3])\n            else:\n                b1 += s[index]\n                b2 += sum(s[index:index+2])\n                b3 += sum(s[index:index+3])\n            \n            choices = [(a1, b1), (a2, b2), (a3, b3)]\n            if first:\n                ans = max(choices)\n            else:\n                ans = min(choices)\n            \n            memo[index, first] = ans\n            return ans\n        \n        a, b = helper(0, True)\n        if a == b:\n            return 'Tie'\n        if a < b:\n            return 'Bob'\n        return 'Alice'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        @lru_cache(None)\n        def dp(i,chance):\n            n = len(stoneValue)\n            if i >= len(stoneValue):\n                return 0\n            \n            if not chance:\n                ans = float('-inf')\n                for j in range(i,i+3):\n                    if j < n:\n                        ans = max(ans, dp(j+1,1)+sum(stoneValue[i:j+1]))\n                \n            else:\n                ans = float('inf')\n                for j in range(i,i+3):\n                    if j < n:\n                        ans = min(ans, dp(j+1,0)-sum(stoneValue[i:j+1]))\n            return ans\n        \n        score = dp(0,0)\n        if score > 0:\n            return 'Alice'\n        if score < 0:\n            return 'Bob'\n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, piles: List[int]) -> str:\n        N = len(piles)\n\n        @lru_cache(None)\n        def sg(idx,turn):\n\n            if idx == N:\n                return 0\n\n            res = float('-inf')\n\n            if turn == -1:\n                res = float('inf')\n\n            ps = 0\n\n            for i in range(idx,min(idx+3, N)):\n                ps += piles[i]\n\n                nxt = (ps * turn) + sg(i+1,-turn)\n\n                if turn == 1:\n                    res = max(res,nxt)\n                else:\n                    res = min(res,nxt)\n\n            return res\n\n        res = sg(0,1)\n\n        if res > 0:\n            return 'Alice'\n        elif res < 0:\n            return 'Bob'\n\n        return 'Tie'        ", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # dont take the below, because it can be negative, [-1,-2,-3]\n        #if len(stoneValue) <= 3:\n        #    return 'Alice'\n        p1, p2, p3 = 0, 0, 0\n        post_sum = 0\n        for i in range(len(stoneValue) - 1, -1, -1):\n            val = stoneValue[i]\n            post_sum += val\n            best = post_sum - min([p1, p2, p3])\n            p1, p2, p3 = best, p1, p2\n        if p1 > post_sum - p1:\n            return 'Alice'\n        elif p1 < post_sum - p1:\n            return 'Bob'\n        else:\n            return 'Tie'", "from functools import lru_cache\n\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        vals = stoneValue\n        n = len(vals)\n        dp = collections.deque([None] * 3)\n        dp[0] = [0, 0]\n        for i in range(n - 1, -1, -1):\n            s = vals[i]\n            p1, p2 = dp[0][1] + s, dp[0][0]\n            for j in range(i + 1, min(i + 3, n)):\n                s += vals[j]\n                p1_, p2_ = dp[j - i]\n                p2_ += s\n                if p2_ > p1:\n                    p1 = p2_\n                    p2 = p1_\n            dp.pop()\n            dp.appendleft((p1, p2))\n        \n        p1, p2 = dp[0]\n        if p1 > p2:\n            return 'Alice'\n        elif p1 == p2:\n            return 'Tie'\n        return 'Bob'", "class Solution:\n    def stoneGameIII(self, stones: List[int]) -> str:\n        rowlen=len(stones)\n        #dp=[0] * (rowlen+1)\n        i=rowlen-1\n        i_1,i_2,i_3=0,0,0\n        \n        \n        while i >= 0:\n            \n            answer=-float('inf')\n            \n            answer=max(answer,stones[i] - i_1)\n            \n            if i+1 < rowlen:\n                answer=max(answer,stones[i]+stones[i+1] - i_2)  \n                \n            if i+2 < rowlen:\n                answer=max(answer,stones[i]+stones[i+1]+stones[i+2] - i_3)\n        \n            i_3=i_2\n            i_2=i_1\n            i_1 = answer \n            i-=1\n            \n        if i_1 > 0:\n            return 'Alice'\n        elif i_1 < 0:\n            return 'Bob'\n        else:\n            return 'Tie'\n        \n        \n        \n        \n        '''\n        # Recursion + TopDown\n        rowlen=len(stones)\n        index=0\n        memo=[-1] * rowlen\n             \n        def helper(index,memo):\n            \n            if index >= rowlen:\n                return 0\n            elif memo[index] != -1:\n                return memo[index] \n            else:\n                answer=-float('inf')\n                answer=max(answer,stones[index] - helper(index+1,memo))\n                if index + 1 < rowlen:\n                    answer=max(answer,stones[index]+stones[index+1] - helper(index+2,memo))\n                \n                if index + 2 < rowlen:\n                    answer=max(answer,stones[index]+stones[index+1]+stones[index+2] - helper(index+3,memo))\n                \n                memo[index]=answer\n                return memo[index]      \n                \n        answer=helper(0,memo)\n        print(answer)\n        \n        if answer < 0:\n            return 'Bob'\n        elif answer > 0:\n            return 'Alice'\n        else:\n            return 'Tie'\n            \n        '''      ", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        \n        i = n - 1\n        \n        i1, i2, i3 = 0, 0, 0\n        \n        while i>=0:\n            ans = float('-inf')\n            \n            ans = max(ans, stoneValue[i] - i1)\n            \n            if i+1 < n:\n                ans = max(ans, stoneValue[i] + stoneValue[i+1] - i2)\n                \n            if i+2 < n:\n                ans = max(ans, stoneValue[i] + stoneValue[i+1] + stoneValue[i+2] - i3)\n                \n            i3 = i2\n            i2 = i1\n            i1 = ans\n            i -= 1\n        \n        if i1 > 0:\n            return 'Alice'\n        elif i1 < 0:\n            return 'Bob'\n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, s: List[int]) -> str:\n        i_1 = i_2 = i_3 = 0\n        i = len(s)-1\n        while i>=0:\n            ans = -sys.maxsize\n            ans = max(ans, s[i] - i_1)\n            if i+1 < len(s):\n                ans = max(ans, s[i]+s[i+1] - i_2)\n            if i+2 < len(s):\n                ans = max(ans, s[i]+s[i+1]+s[i+2] - i_3)\n            i_3 = i_2\n            i_2 = i_1\n            i_1 = ans\n            i -= 1\n            \n        a = i_1\n        if a > 0:\n            return 'Alice'\n        if a == 0:\n            return 'Tie'\n        return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        dp = [-2**31]*n # max diff points Alice can win over Bob\n        for i in range(n-1, -1, -1):\n            take = 0\n            for j in range(i, min(i+3, n)):\n                take += stoneValue[j]\n                dp[i] = max(dp[i], take - (dp[j+1] if j+1 < n else 0))\n        \n        if dp[0] > 0:\n            return 'Alice'\n        elif dp[0] < 0:\n            return 'Bob'\n        else:\n            return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # time complexity: O(N)\n        # space complexity: O(N)\n        N = len(stoneValue)\n        stoneValue += [0, 0, 0]        \n        dp = [-sys.maxsize] * N + [0, 0, 0]\n        for i in range(N-1, -1, -1):\n            for k in (1,2,3):\n                dp[i] = max(dp[i], sum(stoneValue[i:i+k]) - dp[i+k])\n        if dp[0] > 0: return 'Alice'\n        elif dp[0] < 0: return 'Bob'\n        else: return 'Tie'\n", "from functools import lru_cache\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        @lru_cache(maxsize=None)\n        def score(i):\n            if i >= N: return 0\n            return max(stoneValue[i] - score(i+1),\n                   sum(stoneValue[i:i+2]) - score(i+2),\n                   sum(stoneValue[i:i+3]) - score(i+3))\n        N = len(stoneValue)\n        s = score(0)\n        if s > 0: return 'Alice'\n        elif s < 0: return 'Bob'\n        else: return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # aliceScore = [0]\n        # bobScore = [0]\n        # INVALID = 's'\n        # def helper(stoneValues,index,aliceScore,bobScore,aliceTurn):\n        #     scoreToUpdate = aliceScore\n        #     if not aliceTurn:\n        #         scoreToUpdate = bobScore\n        #     if len(stoneValues) - 1 == index:\n        #         scoreToUpdate[0] += stoneValues[index]\n        #         return\n        #     bck = scoreToUpdate[0]\n        #     sums = []\n        #     for i in range(1,4):\n        #         scoreToUpdate[0] = bck\n        #         if i + index <= len(stoneValues):\n        #             for j in range(i):\n        #                 scoreToUpdate[0] += stoneValues[index+j]\n        #             helper(stoneValues,index + i,aliceScore,bobScore,not aliceTurn)\n        #             sums.append(scoreToUpdate[0])\n        #     if len(sums) > 0:\n        #         scoreToUpdate[0] = max(sums)\n        #     else:\n        #         scoreToUpdate[0] = bck\n        #     return\n        # helper(stoneValue,0,aliceScore,bobScore,True)\n        # if aliceScore[0] > bobScore[0]:\n        #     return 'Alice'\n        # elif bobScore[0] > aliceScore[0]:\n        #     return 'Bob'\n        # return 'Tie'\n        # def helper(stoneValues,index):\n        #     if index in mem:\n        #         return mem[index]\n        #     if index >= len(stoneValues):\n        #         return 0\n        #     ans = stoneValues[index] - helper(stoneValues,index+1)\n        #     if index + 1 < len(stoneValues):\n        #         temp = stoneValues[index] + stoneValues[index+1] - helper(stoneValues,index+2)\n        #         ans = max(ans,temp)\n        #     if index + 2 < len(stoneValues):\n        #         temp = stoneValues[index] + stoneValues[index+1] + stoneValues[index+2] - helper(stoneValues,index+3)\n        #         ans = max(ans,temp)\n        #     mem[index] = ans\n        #     return ans\n        # ans = helper(stoneValue,0)\n        mem = {i:0 for i in range(len(stoneValue)+1)}\n        i = len(stoneValue) - 1\n        while i >= 0:\n            ans = stoneValue[i] - mem[i+1]\n            if i + 1 < len(stoneValue):\n                ans = max(ans,stoneValue[i] + stoneValue[i+1] - mem[i+2])\n            if i + 2 < len(stoneValue):\n                 ans = max(ans,stoneValue[i] + stoneValue[i+1] + stoneValue[i+2] - mem[i+3])\n            mem[i] = ans\n            i -= 1\n        if ans > 0:\n            return 'Alice'\n        elif ans < 0:\n            return 'Bob'\n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, s: List[int]) -> str:\n        cost = [0]*(len(s)+1)\n        i = len(s)-1\n        while i>=0:\n            ans = -sys.maxsize\n            ans = max(ans, s[i] - cost[i+1])\n            if i+1 < len(s):\n                ans = max(ans, s[i]+s[i+1] - cost[i+2])\n            if i+2 < len(s):\n                ans = max(ans, s[i]+s[i+1]+s[i+2] - cost[i+3])\n            cost[i] = ans\n            i -= 1\n            \n        a = cost[0]\n        if a > 0:\n            return 'Alice'\n        if a == 0:\n            return 'Tie'\n        return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # Get the highest socre of Alice s1, \n        # then score of Bob is sum(stoneValue) - s.\n        # If s1 > s2 => Alice, if s1 == s2 => Tie, else\n        # Bob\n        \n        # [1,2,3,6]\n        # TLE, because in getScore we have to sum(stoneValue) since we \n        # don't need to get the explict score. Instead we only need to\n        # consider the highest score that the first player win over the\n        # other. Therefore, we can optimize it, which is the second \n        # approach. DP solution also uses this idea.\n#         memo = {}\n#         def getScore(start):\n#             if start >= len(stoneValue):\n#                 return 0\n#             if start in memo:\n#                 return memo[start]\n#             res = -math.inf\n#             front = 0\n#             behind = sum(stoneValue[start:])\n#             for i in range(start, min(start+3, len(stoneValue))):\n#                 front += stoneValue[i]\n#                 behind -= stoneValue[i]\n#                 cur = front + behind - getScore(i+1)\n#                 res = max(cur, res)\n            \n#             return res\n                \n#         s1 = getScore(0)\n#         s2 = sum(stoneValue) - s1\n        \n#         if s1 > s2:\n#             return 'Alice'\n#         elif s1 == s2:\n#             return 'Tie'\n#         else:\n#             return 'Bob'\n        \n#         # Second approach\n#         memo = {}\n#         def dfs(start):\n#             if start >= len(stoneValue):\n#                 return 0\n#             if start in memo:\n#                 return memo[start]\n#             memo[start] = -math.inf\n#             score = 0\n#             for i in range(start, min(len(stoneValue), start+3)):\n#                 score += stoneValue[i]\n#                 memo[start] = max(memo[start], score - dfs(i+1))\n            \n#             return memo[start]\n#         score = dfs(0)\n        \n#         if score > 0:\n#             return 'Alice'\n#         elif score == 0:\n#             return 'Tie'\n#         else:\n#             return 'Bob'\n            \n        # DP solution\n        n = len(stoneValue)\n        dp = [-math.inf] * n\n        for i in range(n-1, -1, -1):\n            take = 0\n            for j in range(i, min(i+3, n)):\n                take += stoneValue[j]\n                if j + 1 == n:\n                    dp[i] = max(dp[i], take)\n                else:\n                    dp[i] = max(dp[i], take - dp[j+1])\n        if dp[0] > 0:\n            return 'Alice'\n        elif dp[0] == 0:\n            return 'Tie'\n        else:\n            return 'Bob'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        #--- corner case\n        if not stoneValue:\n            return 'Tie'\n        \n        #--- setup\n        n = len(stoneValue)\n        dp = [0 for _ in range(n+3)]\n        stoneValue = stoneValue + [0,0,0]\n        #--- main\n        for i in range(n-1, -1, -1):\n            max_v = float('-inf')\n            curr = stoneValue[i]\n            for j in range(i+1, i+4):\n                max_v = max(max_v, curr - dp[j])\n                curr += stoneValue[j]\n            dp[i] = max_v\n        # print(dp)\n        if dp[0] > 0:\n            return 'Alice'\n        if dp[0] < 0:\n            return 'Bob'\n        return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n: int = len(stoneValue)\n        dp: List[int] = [0 for _ in range(n + 1)]\n        for i in range(n - 1, -1, -1):\n            dp[i] = float('-inf')\n            taken: int = 0\n            for j in range(3):\n                if i + j < n:\n                    taken += stoneValue[i + j]\n                    dp[i] = max(dp[i], taken - dp[i + j + 1])\n        if dp[0] > 0:\n            return 'Alice'\n        elif dp[0] < 0:\n            return 'Bob'\n        else:\n            return 'Tie'", "from functools import lru_cache\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        @lru_cache(maxsize=None)\n        def score(i):\n            if i == N - 1: return stoneValue[i]\n            if i == N - 2: \n                return max(stoneValue[i] + stoneValue[i+1],\n                          stoneValue[i] - stoneValue[i+1],)\n            if i == N - 3:\n                return max(sum(stoneValue[i:]), stoneValue[i] - score(i+1),\n                          sum(stoneValue[i:i+2]) - score(i+2))\n            return max(stoneValue[i] - score(i+1),\n                   sum(stoneValue[i:i+2]) - score(i+2),\n                   sum(stoneValue[i:i+3]) - score(i+3))\n        N = len(stoneValue)\n        s = score(0)\n        if s > 0: return 'Alice'\n        elif s < 0: return 'Bob'\n        else: return 'Tie'", "\nclass Solution:\n  def stoneGameIII(self, stoneValue: List[int]) -> str:\n    n = len(stoneValue)\n    dp = [0] * (n + 3)\n\n    total = 0\n    for i in range(n - 1, -1, -1):\n      total += stoneValue[i]\n      dp[i] = -float('inf')\n      for k in range(1, 4, 1):\n        dp[i] = max(total - dp[i + k], dp[i])\n\n    oppo = total - dp[0]\n    if dp[0] > oppo:\n      return 'Alice'\n    elif dp[0] < oppo:\n      return 'Bob'\n    return 'Tie'\n", "from functools import lru_cache\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        @lru_cache\n        def score(i):\n            if i == N - 1: return stoneValue[i]\n            if i == N - 2: \n                return max(stoneValue[i] + stoneValue[i+1],\n                          stoneValue[i] - stoneValue[i+1],)\n            if i == N - 3:\n                return max(sum(stoneValue[i:]), stoneValue[i] - score(i+1),\n                          sum(stoneValue[i:i+2]) - score(i+2))\n            return max(stoneValue[i] - score(i+1),\n                   sum(stoneValue[i:i+2]) - score(i+2),\n                   sum(stoneValue[i:i+3]) - score(i+3))\n        N = len(stoneValue)\n        s = score(0)\n        if s > 0: return 'Alice'\n        elif s < 0: return 'Bob'\n        else: return 'Tie'", "from typing import List\n\nclass Solution:\n    def stoneGameIII(self, stones: List[int]) -> str:\n        suffix_sum = [0]\n        for stone in stones[::-1]:\n            suffix_sum += suffix_sum[-1] + stone,\n\n        suffix_sum = suffix_sum[::-1][:-1]\n        length = len(stones)\n        dp = [float('-inf')] * (length - 3) + suffix_sum[-3:]\n        for i in range(length - 2, -1, -1):\n            dp[i] = max(dp[i], suffix_sum[i] - min(dp[i + j] for j in range(1, 4) if i + j < length))\n\n        alice = dp[0]\n        bob = suffix_sum[0] - dp[0]\n        return 'Tie' if alice == bob else 'Alice' if alice > bob else 'Bob'", "from functools import lru_cache\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # time complexity: O(n)\n        # space complexity: O(n)\n        @lru_cache(maxsize=None)\n        def score(i):\n            if i >= len(stoneValue): return 0\n            #return max([sum(stoneValue[i:i+k]) - score(i+k) for k in [1,2,3]])\n            return max([sum(stoneValue[i:i+1]) - score(i+1),\n                        sum(stoneValue[i:i+2]) - score(i+2),\n                        sum(stoneValue[i:i+3]) - score(i+3)])\n        \n        s = score(0)\n        if s > 0: return 'Alice'\n        elif s < 0: return 'Bob'\n        else: return 'Tie'", "from functools import lru_cache\nclass Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        # time complexity: O(n)\n        # space complexity: O(n)\n        @lru_cache(maxsize=None)\n        def score(i):\n            if i >= len(stoneValue): return 0\n            return max([sum(stoneValue[i:i+1]) - score(i+1),\n                        sum(stoneValue[i:i+2]) - score(i+2),\n                        sum(stoneValue[i:i+3]) - score(i+3)])\n            #return max([sum(stoneValue[i:i+k]) - score(i+k) for k in [1,2,3]])\n        \n        s = score(0)\n        if s > 0: return 'Alice'\n        elif s < 0: return 'Bob'\n        else: return 'Tie'", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        n = len(stoneValue)\n        p = [0] * n\n        for i in range(n-1,-1,-1):\n            if i == n-1: p[i] = stoneValue[i]\n            else: p[i] = stoneValue[i] + p[i+1]\n\n        dp = [0] * (n+1)\n        for i in range(n-1,-1,-1):\n            dp[i] = p[i] - min(dp[i+1:i+4])\n        if dp[0] * 2 == p[0]: return 'Tie'\n        elif dp[0] * 2 > p[0]: return 'Alice'\n        else: return 'Bob'\n                \n            \n", "class Solution:\n    def stoneGameIII(self, stoneValue: List[int]) -> str:\n        dp = [0]*3\n        for i in range(len(stoneValue) - 1, -1, -1):\n            dp[i % 3] = max(sum(stoneValue[i: i+k]) - dp[(i + k) % 3] for k in (1, 2, 3))\n        if dp[0] == 0:\n            return 'Tie'\n        elif dp[0] < 0:\n            return 'Bob'\n        return 'Alice'\n"]
["class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        dist = [float(\\\"inf\\\")] * n\n        remain = set()\n        for i in range(0,n):\n            remain.add(i)\n        dist[0] = 0\n        remain.discard(0)\n        curr = 0\n        res = 0\n        while len(remain) > 0:\n            lo = float(\\\"inf\\\")\n            loind = -1\n            # curr is the next lowest\n            a,b = points[curr]\n            for r in remain:\n                x,y = points[r]\n                tempdist = abs(x-a) + abs(y-b)\n                if tempdist < dist[r]:\n                    dist[r] = tempdist\n                tempdist = dist[r]\n                \n                if tempdist < lo:\n                    lo = tempdist\n                    loind = r\n            \n            res += lo\n            \n            curr = loind\n            # remove curr from remain\n            remain.discard(curr)\n            \n        return res\n            ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        score = [-1] * len(points)\n        total_score = 0\n        for i in range(1, len(points)):\n            x, y = points[i-1][0], points[i-1][1]\n            cur_min_idx, cur_min_val = -1, -1\n            for j in range(i, len(points)):\n                cur_dist = abs(x - points[j][0]) + abs(y - points[j][1])\n                if score[j] == -1:\n                    score[j] = cur_dist\n                elif cur_dist < score[j]:\n                    score[j] = cur_dist\n                if cur_min_val == -1 or score[j] < cur_min_val:\n                    cur_min_val, cur_min_idx = score[j], j\n            total_score += cur_min_val\n            if i != j:\n                score[cur_min_idx], score[i] = score[i], score[cur_min_idx]\n                points[cur_min_idx], points[i] = points[i], points[cur_min_idx]\n        return total_score\n                    \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        '''\n        prim's algorithm.\n        for each left over points:\n                add the shortest edge to the tree.\n                update the shortest edge from the left over points.\n        '''\n        cost = 0\n        Left_over_points_minEdge = [(abs(points[i][0]-points[0][0])+abs(points[i][1]-points[0][1]),0,i) for i in range(1,len(points))]\n        heapq.heapify(Left_over_points_minEdge)\n        #mst = [] # to store the minimal spanning tree. Not necessary here.\n        while Left_over_points_minEdge: # K for K in N-1... 1\n            shortest, frm, to = heapq.heappop(Left_over_points_minEdge) #(O(1))\n            cost += shortest\n            #mst.append((frm,to))\n            \n            # \\\"add or rather use\\\" new edges from \\\"to\\\" and update the min distance to the tree\n            for pos,(d, _, i ) in enumerate( Left_over_points_minEdge ): #O(K-1)\n                dist = abs(points[i][0]-points[to][0])+abs(points[i][1]-points[to][1])\n                if dist < d:\n                    Left_over_points_minEdge[pos] = (dist,to,i)\n                    heapq._siftdown(Left_over_points_minEdge,0,pos) #(O(log(K))\n            \n            #heapq.heapify(Left_over_points_minEdge) #O(K-1)\n            \n        #print(mst)    \n        return cost\n            \n        \n        \n        \n        \n        \n                \n        \n        \n        \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def manhattan(x, y):\n            return abs(x[0] - y[0]) + abs(x[1] - y[1])\n        ans, n = 0, len(points)\n        seen = set()\n        edges = [(0, 0, 0)]\n        while len(seen) < n:\n            w, u, v = heapq.heappop(edges)\n            if v in seen:\n                continue\n            seen.add(v)\n            ans += w\n            for i in range(len(points)):\n                if i not in seen and i != u:\n                    heapq.heappush(edges, (manhattan(points[v], points[i]), v, i))\n        return ans                           \n                \n        \n                \n                \n            \n            \n", "class DisjointSet:\n    def __init__(self, n):\n        self.parent = [-1] * n #If a node is root, its parent is the negative size\n        \n    def find(self, x):\n        if self.parent[x] < 0:\n            return x\n        else:\n            # Path compression\n            root = self.find(self.parent[x])\n            self.parent[x] = root\n            return root\n    \n    def union(self, a, b):\n        root_a = self.find(a)\n        root_b = self.find(b)\n        if root_a == root_b:\n            return False\n        \n        if self.parent[root_a] > self.parent[root_b]:\n            temp = root_a\n            root_a = root_b\n            root_b = temp\n            \n        self.parent[root_a] += self.parent[root_b]\n        self.parent[root_b] = root_a\n        return True\n        \n    def size(self, x):\n        root = self.find(x)\n        return self.parent[root] *-1\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        edges = []\n        for i, point1 in enumerate(points):\n            for j in range(i+1, len(points)):\n                point2 = points[j]\n                cost = abs(point2[0] - point1[0]) + abs(point2[1] - point1[1])\n                edges.append([cost, i, j])\n                \n        ans = 0\n        edges.sort()\n        graph = DisjointSet(len(points))\n        for edge in edges:\n            if graph.union(edge[1], edge[2]):\n                ans += edge[0]\n                \n        return ans\n                \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        parent = [i for i in range(len(points))]\n        size = [1 for _ in range(len(points))]\n        \n        def root(p):\n            while parent[p] != p:\n                parent[p] = parent[parent[p]]\n                p = parent[p]\n                \n            return p\n        \n        def union(p, q):\n            root_p, root_q = root(p), root(q)\n            if root_p != root_q:\n                if size[root_p] < size[root_q]:\n                    parent[root_p] = root_q\n                    size[root_q] += size[root_p]\n                else:\n                    parent[root_q] = root_p\n                    size[root_p] += size[root_q]\n        \n        def connected(p, q):\n            return root(p) == root(q)\n        \n        # connected = set()\n        p = points\n        ans = 0\n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        d = [ [(0, _)] * (len(p)) for _ in range(len(p))]\n        heap = []\n        for i in range(len(p)):\n            for j in range(i+1, len(p)):\n                temp = dist(p[i],p[j])\n                d[i][j] = (temp, j)\n                d[j][i] = (temp, i)\n                heappush(heap, (temp, (i, j)))\n        \n        while heap:\n            dis, (i, j) = heappop(heap)\n            if not connected(i, j):\n                ans += dis\n                union(i, j)\n                                \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # try minimum spanning treee\n        \n        to_visit = set(range(1, len(points)))\n        pq = [(abs(points[0][0] - points[x][0]) + abs(points[0][1] - points[x][1]), x) for x in range(1, len(points))]\n        heapq.heapify(pq)\n        ans = 0\n        while pq:\n            cost, to = heapq.heappop(pq)\n            if to in to_visit:\n                to_visit.remove(to)\n                ans += cost\n                for nei in to_visit:\n                    x, y = points[nei]\n                    heapq.heappush(pq, (abs(x-points[to][0]) + abs(y-points[to][1]), nei))\n\n        return ans\n        \n        \n        \n            \n            \n\n", "import queue\nimport sys\n\nclass Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        n = len(p)\n        graph = [[] for i in range(n + 1)]\n        dist = [1000000000 for i in range(n + 1)]\n        for i in range(len(p)):\n            for j in range(len(p)):\n                if i == j: \n                    continue\n                graph[i].append((j, abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])))\n                graph[j].append((i, abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])))\n        pq = queue.PriorityQueue()\n        pq.put((0, 0))\n        dist[0] = 0\n        res = 0\n        while pq.empty() == False:\n            (du, u) = pq.get()\n            if du != dist[u]:\n                continue\n\n            dist[u] = 0\n            res += du\n            for (v, uv) in graph[u]:\n                if dist[v] > uv:\n                    dist[v] = uv\n                    pq.put((uv, v))\n        return res                ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def build_graph(points):\n            g = {i:{} for i in range(len(points))}\n            for i in range(len(points)):\n                for j in range(i+1, len(points)):\n                    dist = abs(points[j][0] - points[i][0]) + abs(points[j][1] - points[i][1])\n                    g[i][j] = dist\n                    g[j][i] = dist\n            return g\n        \n        def min_span_tree(g):\n            import heapq\n            \n            cost = 0\n            min_heap = []\n            heapq.heappush(min_heap, (0, 0))\n            visited = set()\n            \n            while len(min_heap):\n                nxt_cost, idx = heapq.heappop(min_heap)\n                if idx in visited:\n                    continue\n                visited.add(idx)\n                cost += nxt_cost\n                # print('visit', idx, nxt_cost, cost, visited, min_heap)\n\n                for adj in g[idx]:\n                    if adj not in visited:\n                        heapq.heappush(min_heap, (g[idx][adj], adj))\n            return cost\n        \n        g = build_graph(points)\n        return min_span_tree(g)", "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1]*N\n        \n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        \n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n            \n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        return True\n    \n    def size(self, x):\n        return self.sz[self.find(x)]\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        edges = []\n        N = len(points)\n        for i in range(N):\n            for j in range(i+1,N):\n                d = abs(points[i][0]-points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append([d, i, j])\n                \n        edges.sort()\n        \n        u = DSU(N)\n        res = 0\n        \n        for edge in edges:\n            if u.union(edge[1], edge[2]):\n                res += edge[0]\n                \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dist = collections.defaultdict(dict)\n        n = len(points)\n        for i in range(n):\n            for j in range(i+1,n):\n                d = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                dist[i][j] = dist[j][i] = d\n        # print(dist)\n        ret = 0\n        visited = set([])\n        pq = [(0,0)] # dist to s, index, dist to neighbour\n        while pq:\n            cnt,ind = heapq.heappop(pq)\n            if ind not in visited:\n                ret += cnt\n                visited.add(ind)\n                # print(ret,pq)\n                for nei in dist[ind]:\n                    if nei not in visited:\n                        heapq.heappush(pq,(dist[ind][nei],nei))\n        return ret\n                \n                \n", "class Solution:\n    \n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(a):\n            if parents[a]!=a:\n                return find(parents[a])\n            return a\n\n\n        def union(a,b):\n            xa=find(a)\n            xb=find(b)\n            if xa==xb:\n                return\n            if rank[xa]>rank[xb]:\n                parents[xb]=xa\n\n            elif rank[xa]<rank[xb]:\n                parents[xa]=xb\n            else:\n                parents[xa]=xb\n                rank[xb]+=1\n        n=len(points)\n        parents=[i for i in range(n)]\n        rank=[i for i in range(n)]\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        \n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                res += cost\n        \n        return res\n                    \n", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = []\n        d = collections.defaultdict(list)\n        \n        n = len(points)\n        for i in range(n):\n            for j in range(i+1, n):\n                x = tuple(points[i])\n                y = tuple(points[j])\n                distance = abs(x[0]-y[0]) + abs(x[1]- y[1])\n                d[x].append((distance, y))\n                d[y].append((distance, x))\n        \n        start=tuple(points[0])\n        heap = d[start].copy()\n        heapify(heap)\n        res, s = 0, set([start])\n        while len(s) < n:\n            closest = heappop(heap)\n            while closest[1] in s:\n                closest = heappop(heap)\n            \n            s.add(closest[1])\n            res += closest[0]\n            for neig in d[closest[1]]:\n                if neig not in s:\n                    heappush(heap, neig)\n        \n        return res\n            \n            \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) <= 1:\n            return 0\n        \n        def find(x):\n            if x != parent[x]:\n                parent[x] = find(parent[x])\n                return parent[x]\n            \n            return x\n                \n        n = len(points)\n                \n        parent = list(range(n))\n        \n        dists = []\n        \n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                mand = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(dists, (mand, i, j))\n                \n        # dists.sort(key=lambda item: item[0])\n        \n        res = 0\n        \n        while dists:\n            w, a, b = heapq.heappop(dists)\n            pa = find(a)\n            pb = find(b)\n            \n            if pa != pb:\n                res += w\n                parent[pa] = parent[pb]\n                    \n        return res", "\\\"\\\"\\\"\nThis is a minimum spanning tree problem, which can be solved by kruskal's algo or Prim's algo.\nWe need to pre-compute all the possible edges' weights\n\\\"\\\"\\\"\nimport heapq\nfrom typing import Tuple\nclass Solution:\n    def __init__(self):\n      self.roots = {}\n      self.ranks = {}\n      \n    def find(self, point: Tuple[int, int]) -> Tuple[int, int]:\n      self.roots.setdefault(point, point)\n      self.ranks.setdefault(point, 1)\n      if point != self.roots[point]:\n        self.roots[point] = self.find(self.roots[point])\n      return self.roots[point]\n    \n    def union(self, point1: Tuple[int, int], point2: Tuple[int, int], root1: Tuple[int, int], root2: Tuple[int, int]):\n      if self.ranks[root1] > self.ranks[root2]:\n        self.roots[root2] = root1\n      elif self.ranks[root1] < self.ranks[root2]:\n        self.roots[root1] = root2\n      else:\n        self.roots[root1] = root2\n        self.ranks[root2] += 1\n      \n    \\\"\\\"\\\"\n    Kruskal's algo: always select the lightest edge, and use a union find to detect cycles. If there are cycles ignore that edge.\n    Time:\n    For minimum spanning tree, V vertices have E=V-1 edges.\n      * Compute all edge weights and sort: E^2 + ElogE\n      * union find: amortized O(1), need to do this for all edges, so O(V). (Yes union-find with path compession and rank by union, has amortized time O(1))\n      Over all E^2 + ElogE + V\n    Interestingly, bisect performs a lot worse than heapq for this question. bisect.insort would result in a TLE.\n    \\\"\\\"\\\"\n#     def minCostConnectPoints(self, points: List[List[int]]) -> int:\n#       min_cost = 0\n#       edge_count = 0\n#       all_weights = []\n#       for i in range(len(points)):\n#         for j in range(i + 1, len(points)):\n#           xi, yi, xj, yj = (*points[i], *points[j])\n#           dist = abs(xi - xj) + abs(yi - yj)\n#           heapq.heappush(all_weights, (dist, xi, yi, xj, yj))\n      \n#       # print(\\\"all_weights: \\\", all_weights)\n      \n#       while len(all_weights) > 0:\n#         weight, xi, yi, xj, yj = heapq.heappop(all_weights)\n#         rooti, rootj = self.find((xi, yi)), self.find((xj, yj))\n#         if rooti != rootj:\n#           self.union((xi, yi), (xj, yj), rooti, rootj)\n#           # print(\\\"selected: \\\", weight, xi, yi, xj, yj)\n#           min_cost += weight\n#           edge_count += 1\n          \n#           if edge_count == len(points) - 1: break\n      \n#       return min_cost\n    \\\"\\\"\\\"\n    Prim's algo: this is very similar to Dijkstra's algo: start from one point, and BFS to expand to other points. \n    \\\"\\\"\\\"\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n      if len(points) == 0: return 0\n      min_cost = 0\n      cur = points[0]\n      unvisited = {(x, y) for x, y in points[1:]}\n      all_edges = []\n\n      while cur:\n        if len(unvisited) == 0: break\n        for nbr in unvisited:\n          dist = abs(cur[0] - nbr[0]) + abs(cur[1] - nbr[1])\n          heapq.heappush(all_edges, (dist, tuple(cur), tuple(nbr)))\n\n        while all_edges:\n          weight, cur, nbr = heapq.heappop(all_edges)\n          if nbr in unvisited:\n            min_cost += weight\n            cur = nbr\n            unvisited.remove(nbr)\n            break\n      return min_cost\n\n            \n          \n        \n        \n        \n      ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        costMap = [0] * len(points)\n        \n        minHeap = []\n        heappush(minHeap, (0, points[0], 0))\n        visited = set()\n        \n        while minHeap:\n            cost, [currentX, currentY], currentIndex = heappop(minHeap)\n            if (currentX, currentY) in visited:\n                if costMap[currentIndex] <= cost:\n                    continue\n\n            for i, p in enumerate(points):\n                if not ((p[0], p[1]) in visited) and i != currentIndex:\n                    nextCost = abs(currentX - p[0]) + abs(currentY - p[1])\n                    heappush(minHeap, (nextCost, p, i))\n            if (currentX, currentY) in visited:\n                costMap[currentIndex] = min(costMap[currentIndex], cost)\n            else:\n                costMap[currentIndex] = cost\n\n            visited.add((currentX, currentY) )\n        \n        return sum(costMap)", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        distance = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist= abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                distance.append((dist, i, j))\n        heapq.heapify(distance)\n        \n        parent = [i for i in range(N)]\n        def find(x):\n            while x != parent[x]:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n\n        res = 0\n        while distance:\n            dist, i, j = heapq.heappop(distance)\n            pi = find(i)\n            pj = find(j)\n            if pi != pj:\n                parent[pi] = pj\n                res += dist\n        \n        return res", "from heapq import heappush, heappop\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = [[0 for j in range(len(points))] for i in range(len(points))]\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                edges[i][j] = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                edges[j][i] = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n        inf = 1234567890\n        # distances = [inf for i in range(n)]\n        frontier = [(0, 0)]\n        gotem = set()\n        ans = 0\n        while len(frontier) > 0:\n            cost, ex = heappop(frontier)\n            if ex in gotem:\n                continue\n            ans += cost\n            gotem.add(ex)\n            for i in range(len(points)):\n                if i not in gotem and i != ex:\n                    heappush(frontier, (edges[ex][i], i))\n        return ans\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def cost_of(i, j):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            \n            return abs(x1 - x2) + abs(y1 - y2)\n            \n        N = len(points)\n        parent = list(range(N))\n        size = [1] * N\n        \n        def union(x, y):\n            x = find(x)\n            y = find(y)\n            \n            if x == y:\n                return False\n            \n            if size[x] < size[y]:\n                x, y = y, x\n            \n            parent[y] = x\n            size[x] += size[y]\n            \n            return True\n            \n            \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        edges = []\n        \n        for i in range(N):\n            for j in range(i + 1, N):\n                edges.append((cost_of(i, j), i, j))\n        \n        heapq.heapify(edges)\n        total_cost = 0\n        \n        while edges:\n            cost, p1, p2 = heapq.heappop(edges)\n            \n            if union(p1, p2):\n                total_cost += cost\n        \n        return total_cost\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        connections = []\n        for i in range(N):\n            for j in range(i+1, N):\n                connections.append([abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j])\n        \n        if len(connections) < N - 1:\n            return -1\n        elif N == 1:\n            return 0\n        uf = {}\n        def find(x):\n            uf.setdefault(x, x)\n            if uf[x] != x:\n                uf[x] = find(uf[x])\n            return uf[x]\n        def union(x, y):\n            uf[find(x)] = find(y)\n        \n        res = 0\n        for cost, start, end in sorted(connections):\n            if find(start) != find(end):\n                res += cost\n                union(start, end)\n        if len({find(c) for c in uf}) == 1:\n            return res\n        return -1\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    # 940        \n        dsu = DSU()\n        min_heap = []\n        for i in range(len(points)):\n            x1, y1 = points[i][0], points[i][1]\n            for j in range(i + 1, len(points)):\n                x2, y2 = points[j][0], points[j][1]\n                heappush(min_heap, (abs(x1 - x2) + abs(y1 - y2), (x1,y1,x2,y2)))\n    \n        cost = 0\n        while min_heap:\n            c, (x1,y1,x2,y2) = heappop(min_heap)\n            if dsu.find((x1,y1)) != dsu.find((x2,y2)):\n                cost += c\n                dsu.union((x1,y1), (x2, y2))\n        return cost\n    \n    \n    \nclass DSU:\n    def __init__(self):\n        self.father = {}\n    \n    def find(self, a):\n        self.father.setdefault(a, a)\n        if a != self.father[a]:\n            self.father[a] = self.find(self.father[a])\n        return self.father[a]\n    \n    def union(self, a, b):\n        _a = self.find(a)\n        _b = self.find(b)\n        if _a != _b:\n            self.father[_a] = _b\n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        e = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                e.append([i,j])\n        def h(x):\n            return abs(points[x[0]][0]-points[x[1]][0]) + abs(points[x[0]][1]-points[x[1]][1])\n        e.sort(key=lambda x : h(x))\n        \n        #print([[points[x], points[y], h((x,y))] for x,y in e])\n                \n        n = len(points)\n        v = set()\n        s = 0\n        c = []\n        \n        def find(x):\n            nonlocal c\n            for i,cc in enumerate(c):\n                if x in cc:\n                    return i\n        \n        for ee in e:\n            x,y = ee\n            if y not in v and x not in v:\n                c.append([x,y])    \n                v.add(x)\n                v.add(y)\n                s+=h(ee)\n            elif x not in v:\n                yi = find(y)\n                c[yi].append(x)\n                v.add(x)\n                s+=h(ee)\n            elif y not in v:\n                xi = find(x)\n                c[xi].append(y)\n                v.add(y)\n                s+=h(ee)\n            else:\n                xi = find(x)\n                yi = find(y)\n                if xi == yi:\n                    continue\n                s+=h(ee)\n                c[xi]+=c[yi]\n                del c[yi]\n                if len(v) == n and len(c) == 1:\n                    return s\n        #print(v)\n        return s", "class UnionFind:\n    def __init__(self, n): \n        self.parent = list(range(n))\n        self.count = n\n        self.rank = [1]*n\n        \n    def find(self, p): \n        if p != self.parent[p]:\n            self.parent[p] = self.find(self.parent[p]) # path compression \n        return self.parent[p]\n    \n    def union(self, p, q): \n        prt = self.find(p)\n        qrt = self.find(q)\n        if prt == qrt: return False # already connected \n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\n        self.parent[prt] = qrt \n        self.rank[qrt] += self.rank[prt]\n        return True \n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        uf = UnionFind(n)\n        \n        hp = [] # min heap \n        \n        for i in range(n):\n            x, y = points[i]\n            for ii in range(i+1, n):\n                xx, yy = points[ii]\n                cost = abs(x - xx) + abs(y - yy)\n                heappush(hp, (cost, i, ii))\n        \n        ans = 0\n        while hp and uf.count != 1: \n            cost, i, ii = heappop(hp)\n            if uf.union(i, ii): ans += cost \n        return ans ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 1:\n            return 0\n        \n        distances = []\n        for i in range(n):\n            for j in range(i+1, n):\n                xi, yi = points[i]\n                xj, yj = points[j]\n                heapq.heappush(distances, (abs(xi-xj) + abs(yi-yj), i, j))\n        \n        uf = {}\n        \n        def find(i: int) -> int:\n            if i not in uf:\n                uf[i] = i\n\n            while uf[i] != uf[uf[i]]:\n                uf[i] = find(uf[i])\n            return uf[i]\n        \n        def union(i: int, j: int) -> None:\n            uf[find(i)] = find(j)\n        \n        dist = 0\n        \n        while distances:\n            d, i, j = heapq.heappop(distances)\n            if find(i) != find(j):\n                union(i, j)\n                dist += d\n        \n        return dist\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        parents = [i for i in range(len(points))]\n        \n        pq = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                x, y = points[i], points[j]\n                heapq.heappush(pq, (abs(x[0] - y[0]) + abs(x[1] - y[1]), i, j))\n        \n        res = 0\n        while pq:\n            dist, i, j = heapq.heappop(pq)\n            if self.find(i, parents) == self.find(j, parents):\n                continue\n            # print(i, j, dist)\n            res += dist\n            self.union(i, j, parents)\n        \n        return res\n    \n    def find(self, p, parents):\n        while p != parents[p]:\n            parents[p] = parents[parents[p]]\n            p = parents[p]\n        return p\n    \n    def union(self, p, q, parents):\n        p_root = self.find(p, parents)\n        q_root = self.find(q, parents)\n        if p_root != q_root:\n            parents[p_root] = q_root", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n, curr, ans = len(points), 0, 0 # curr is a random point as the base of the MST\n        cost = [math.inf] * n # the minimum cost to add point i to form the MST\n        used = set()\n        for i in range(n - 1): # n - 1 is because we need n - 1 edges totally\n            x, y = points[curr]\n            used.add(curr)\n            for j, (u, v) in enumerate(points):\n                if j in used: continue\n                cost[j] = min(cost[j], abs(u - x) + abs(v - y))\n            delta, curr = min((d, j) for j, d in enumerate(cost))\n            cost[curr] = math.inf\n            ans += delta\n        return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n=len(points)\n        if n==1:\n            return 0\n        heap=[]\n        dsu=DisjointSetUnion(n)\n        for i in range(n-1):\n            for j in range(i+1,n):\n                distance=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                heappush(heap,(distance,i,j))\n        ans=0\n        while heap:\n            distance,i,j=heappop(heap)\n            if dsu.find(i)!=dsu.find(j):\n                ans += distance\n                dsu.union(i,j)\n        return ans\n            \nclass DisjointSetUnion(object):\n\n    def __init__(self, size):\n        # initially, each node is an independent component\n        self.parent = [i for i in range(size+1)]\n        # keep the size of each component\n        self.size = [1] * (size+1)\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        \n        # the two nodes share the same set\n        if px == py:\n            return px\n        \n        # otherwise, connect the two sets (components)\n        if self.size[px] > self.size[py]:\n            # add the node to the union with less members.\n            # keeping px as the index of the smaller component\n            px, py = py, px\n        # add the smaller component to the larger one\n        self.parent[px] = py\n        self.size[py] += self.size[px]\n        # return the final (merged) group\n        return py          ", "# Python program for Kruskal's algorithm to find \n# Minimum Spanning Tree of a given connected, \n# undirected and weighted graph \nfrom collections import defaultdict \n  \n#Class to represent a graph \nclass Graph: \n  \n    def __init__(self,vertices): \n        self.V= vertices #No. of vertices \n        self.graph = [] # default dictionary  \n                                # to store graph \n          \n   \n    # function to add an edge to graph \n    def addEdge(self,u,v,w): \n        self.graph.append([u,v,w]) \n  \n    # A utility function to find set of an element i \n    # (uses path compression technique) \n    def find(self, parent, i): \n        if parent[i] == i: \n            return i \n        return self.find(parent, parent[i]) \n  \n    # A function that does union of two sets of x and y \n    # (uses union by rank) \n    def union(self, parent, rank, x, y): \n        xroot = self.find(parent, x) \n        yroot = self.find(parent, y) \n  \n        # Attach smaller rank tree under root of  \n        # high rank tree (Union by Rank) \n        if rank[xroot] < rank[yroot]: \n            parent[xroot] = yroot \n        elif rank[xroot] > rank[yroot]: \n            parent[yroot] = xroot \n  \n        # If ranks are same, then make one as root  \n        # and increment its rank by one \n        else : \n            parent[yroot] = xroot \n            rank[xroot] += 1\n  \n    # The main function to construct MST using Kruskal's  \n        # algorithm \n    def KruskalMST(self): \n  \n        result =[] #This will store the resultant MST \n  \n        i = 0 # An index variable, used for sorted edges \n        e = 0 # An index variable, used for result[] \n  \n            # Step 1:  Sort all the edges in non-decreasing  \n                # order of their \n                # weight.  If we are not allowed to change the  \n                # given graph, we can create a copy of graph \n        self.graph =  sorted(self.graph,key=lambda item: item[2]) \n  \n        parent = [] ; rank = [] \n  \n        # Create V subsets with single elements \n        for node in range(self.V): \n            parent.append(node) \n            rank.append(0) \n      \n        # Number of edges to be taken is equal to V-1 \n        while e < self.V -1 : \n  \n            # Step 2: Pick the smallest edge and increment  \n                    # the index for next iteration \n            u,v,w =  self.graph[i] \n            i = i + 1\n            x = self.find(parent, u) \n            y = self.find(parent ,v) \n  \n            # If including this edge does't cause cycle,  \n                        # include it in result and increment the index \n                        # of result for next edge \n            if x != y: \n                e = e + 1     \n                result.append([u,v,w]) \n                self.union(parent, rank, x, y)             \n            # Else discard the edge \n  \n        # print the contents of result[] to display the built MST \n        # print \\\"Following are the edges in the constructed MST\\\"\n        minSum = 0\n        for u,v,weight  in result: \n            #print str(u) + \\\" -- \\\" + str(v) + \\\" == \\\" + str(weight) \n            print (\\\"%d -- %d == %d\\\" % (u,v,weight))\n            minSum += weight\n        return minSum\n\n# Driver code \n# g = Graph(4) \n# g.addEdge(0, 1, 10) \n# g.addEdge(0, 2, 6) \n# g.addEdge(0, 3, 5) \n# g.addEdge(1, 3, 15) \n# g.addEdge(2, 3, 4) \n\n# g.KruskalMST() \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # generate the graph\n        \n        nV = len(points)\n        g = Graph(nV)\n        for i in range(nV):\n            for j in range(nV):\n                modX = abs(points[i][0] - points[j][0])\n                modY = abs(points[i][1] - points[j][1])\n                manhattanDist = modX + modY\n                g.addEdge(i, j, manhattanDist)\n        \n        # implement Kruskal's\n        return g.KruskalMST()\n        \n        # return 0", "class dsu:\n    def __init__(self,n):\n        self.parents = [i for i in range(n)]\n        self.rank = [0 for i in range(n)]\n    def find(self,u):\n        if u != self.parents[u]:\n            self.parents[u] = self.find(self.parents[u])\n        return self.parents[u]\n    def union(self,u,v):\n        pu = self.parents[u]\n        pv = self.parents[v]\n        if pu != pv:\n            if self.rank[pu] < self.rank[pv]:\n                self.parents[pu] = pv\n            elif self.rank[pu] > self.rank[pv]:\n                self.parents[pv] = pu\n            else:\n                self.parents[pu] = pv\n                self.rank[pv] += 1\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def get_dist(i,j):\n            return abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n        h = []\n        n = len(points)\n        uf = dsu(n)\n        for i in range(n):\n            for j in range(i):\n                heapq.heappush(h,(get_dist(i,j),i,j))\n        # print(h)\n        cost = 0\n        count = 0\n        while h:\n            c,u,v = heapq.heappop(h)\n            if uf.find(u) != uf.find(v):\n                uf.union(u,v)\n                cost += c\n                count += 1\n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        eg = defaultdict(list)\n        n = len(points)\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    eg[i].append([j, abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])])\n        d, q = {}, [[0, 0]]\n        while q:\n            dis, a = heapq.heappop(q)\n            if a not in d:\n                d[a] = dis\n                for b, c in eg[a]:\n                    if b not in d:\n                        heapq.heappush(q, [c, b])\n        return sum(d.values())", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        if len(points) ==1:\n            return 0\n        heap = []\n        \n        f = [d for d in range(len(points))]\n        \n        def find(x):\n            if x!=f[x]:\n                f[x] = find(f[x])\n            return f[x]\n        \n        def union(x, y):\n            f[find(x)] = find(y)\n            \n                \n        res = 0\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                heapq.heappush(heap, (abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]), i, j))\n                \n        while heap:\n            val, i, j = heapq.heappop(heap)\n            if find(i)!= find(j):\n                union(i, j)\n                res+=val\n        return res\n            \n        \n", "class UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\n    def union(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n\n        if px != py:\n            self.parents[py] = px\n\n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = []\n        uf = UnionFind(len(points))\n        res = 0\n\n        for i in range(len(points)):\n            for j in range(len(points)):\n                if i != j:\n                    graph.append((i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])))\n        graph.sort(key=lambda x: x[2])\n\n        for i, j, w in graph:\n            if not uf.connected(i, j):\n                uf.union(i, j)\n                res += w\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def dist(i, j):\n            p1, p2 = points[i], points[j]\n            res = abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n            \n            return res\n        \n        graph = collections.defaultdict(list)\n        \n        for i in range(len(points)):\n            for j in range(len(points)):\n                if i != j:\n                    graph[i].append((dist(i, j), j))\n        \n        visited = set([])\n        root = 0\n        visited.add(root)\n        edges = [pair for pair in graph[root]]\n        res = 0\n        heapq.heapify(edges)\n      \n        while edges:\n            cost, nex = heapq.heappop(edges)\n            \n            if nex not in visited:\n                #print(cost, nex)\n                res += cost\n                visited.add(nex)\n                \n                for pair in graph[nex]:\n                    if pair[1] not in visited:\n                        heapq.heappush(edges, pair)\n            #print(edges)\n        return res\n        \n                    \n                    \n", "class Solution:\n    parents = [i for i in range(1005)]\n    def findParent(i):\n        if(Solution.parents[i] != i):\n            Solution.parents[i] = Solution.findParent(Solution.parents[i])\n        return Solution.parents[i]\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        distances = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                distance = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                distances.append([distance, i, j])\n        distances.sort()\n        ans = 0\n        for distance in distances:\n            if(Solution.findParent(distance[1]) != Solution.findParent(distance[2])):\n                Solution.parents[Solution.parents[distance[1]]] = Solution.parents[Solution.parents[distance[2]]]\n                ans += distance[0]\n        Solution.parents = [i for i in range(1005)]\n        return ans\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #prims\n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n        g = collections.defaultdict(list)\n        n = len(points)\n        #create graph\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    g[i].append((manhattan(points[i], points[j]), j))\n\n        heap = [(0,0)]\n        ans = 0\n        visited = set()\n        while heap:\n            weight, to = heapq.heappop(heap)\n            if to in visited:\n                continue\n            ans += weight\n            visited.add(to)\n\n            for cost, nei in g[to]:\n                if nei not in visited:\n                    heapq.heappush(heap, (cost, nei))\n\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points)<=1:return 0\n        ans=0\n        par={}\n        def find(x):\n            if x not in par:return x\n            res=find(par[x])\n            par[x]=res\n            return res\n        def union(a,b):\n            n1=find(a)\n            n2=find(b)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n                return True\n            else:return False\n        arr=set()\n        for i in range(len(points)):\n            _min=10e9\n            ix=-1\n            for j in range(len(points)):\n                if i!=j:\n                    n=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                    arr.add((n,(min(i,j),max(i,j))))\n                    if n<_min:\n                        ix=j\n                        _min=n\n            if union(i,ix):\n                ans+=_min\n        arr=list(arr)\n        arr.sort()\n        for x in arr:\n            i=x[1][0]\n            j=x[1][1]\n            n1=find(i)\n            n2=find(j)\n            if n1!=n2:\n                union(i,j)\n                ans+=x[0]\n        return ans         ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # # https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/843995/Python-3-or-Min-Spanning-Tree-or-Prim's-Algorithm\n        # manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        # n, c = len(points), collections.defaultdict(list)\n        # for i in range(n):\n        #     for j in range(i+1, n):\n        #         d = manhattan(points[i], points[j])\n        #         c[i].append((d, j))\n        #         c[j].append((d, i))\n        # cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        # visited[0] = 1\n        # heapq.heapify(heap)\n        # while heap:\n        #     d, j = heapq.heappop(heap)\n        #     if not visited[j]:\n        #         visited[j], cnt, ans = 1, cnt+1, ans+d\n        #         for record in c[j]: heapq.heappush(heap, record)\n        #     if cnt >= n: break        \n        # return ans\n    \n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for _ in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            dis[curr] = math.inf\n            res += delta\n            \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        l = len(points)\n        h = []\n        for i in range(l):\n            for j in range(i):\n                (x1, y1), (x2, y2) = points[i], points[j]\n                dis = abs(x1-x2) + abs(y1-y2)\n                heapq.heappush(h,[dis,i,j])\n        dp = [i for i in range(l)]\n        \n        def find(x):\n            if dp[x] != x:\n                dp[x] = find(dp[x])\n            return dp[x]\n            \n        ans = 0\n        while h:\n            dis, x, y = heapq.heappop(h)\n            if find(x) != find(y):\n                ans += dis\n            dp[find(x)] = find(y)\n            \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def cost_of(i, j):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            \n            return abs(x1 - x2) + abs(y1 - y2)\n            \n        N = len(points)\n        parent = list(range(N))\n        size = [1] * N\n        \n        def union(x, y):\n            x = find(x)\n            y = find(y)\n            \n            if x == y:\n                return False\n            \n            if size[x] < size[y]:\n                x, y = y, x\n            \n            parent[y] = x\n            size[x] += size[y]\n            \n            return True\n            \n            \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        edges = []\n        \n        for i in range(N):\n            for j in range(i + 1, N):\n                edges.append((cost_of(i, j), i, j))\n        \n        heapq.heapify(edges)\n        total_cost = 0\n        c = 0\n        \n        while edges:\n            cost, p1, p2 = heapq.heappop(edges)\n            \n            if union(p1, p2):\n                c += 1\n                total_cost += cost\n                if c == N:\n                    break\n        \n        return total_cost\n        \n", "'''\nhttps://leetcode.com/problems/min-cost-to-connect-all-points/\n'''\nfrom typing import List\nimport heapq\n\nclass Solution:\n    '''\n    Minimum Spanning Tree (Kruskal)\n    https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/843940/C%2B%2B-Minimum-Spanning-Tree-(Kruskal)\n\n    Intuition:\n    Imagine all the points form a complete graph, and length of an edge is the manhattan distance between the 2 points\n    To find the min cost, we therefore need to find the minimum spanning tree\n\n    Algorithm:\n    Use the Kruskal algorithm, which invovles min heap to pick the smallest edge, and union-find to check if the edge is redundant.\n    Exit when all points are connected.\n\n    The complexity when using sort is O(n * n log (n * n)) - we have n * n edges. Using a min heap is O(k log (n * n)),\n    where k is the number of edges we need to pull to complete the tree. It's much smaller than n * n in the average case.\n    '''\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        n, cost = len(points), 0\n        p = list(range(n))\n        arr = []\n        for i in range(n):\n            for j in range(i+1, n):\n                heapq.heappush(arr, [abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]), i, j])\n\n        def find(x):\n            if x != p[x]: p[x] = find(p[p[x]])\n            return p[x]\n\n        while arr:\n            w, i, j = heapq.heappop(arr)\n            i, j = find(i), find(j)\n            if i == j: continue\n            cost += w\n            p[i] = j\n\n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        min_cost = 0\n        msp = set()\n        distances = self.compute_all_distances(points)\n        groups = defaultdict(set)\n        for i in range(len(points)):\n            groups[i].add(i)\n        while distances:\n            next_min = heapq.heappop(distances)\n            g1 = self.find_group(groups, next_min[1])\n            g2 = self.find_group(groups, next_min[2])\n            if g1 != g2:\n                min_cost += next_min[0]\n                groups[g1] = groups[g1] | groups[g2]\n                del groups[g2]\n        return min_cost\n    \n    def find_group(self, groups: dict, i: int) -> int:\n        for group in groups: \n            if i in groups[group]: return group\n        return 0\n    \n    def compute_all_distances(self, points: List[List[int]]) -> List[int]:\n        distances = list()\n        for i in range(len(points)-1):\n            p1 = points[i]\n            for j in range(i+1, len(points)):\n                p2 = points[j]\n                d = self.dist(p1, p2)\n                distances.append((d, i, j))\n        heapq.heapify(distances)\n        return distances\n    \n    def dist(self, p1: List[int], p2: List[int]) -> int:\n        return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dis = lambda x,y,x1,y1: abs(x-x1) + abs(y-y1)\n        distances = []\n        for i, (x, y) in enumerate(points):\n            for x1, y1 in points[i+1:]:\n                d = dis(x, y, x1, y1)\n                distances.append((d, x, y, x1, y1))\n        uf = UnionFind(len(points))\n        for x, y in points:\n            uf.parents[(x, y)] = (x, y)\n        distances.sort()\n        ans = 0\n        for d, x, y, x1, y1 in distances:\n            if uf.union((x, y), (x1, y1)):\n                ans += d\n        return ans\n        \n        \nclass UnionFind:\n    def __init__(self, n):\n        self.component_count = n\n        self.parents = {}\n\n    def find(self, x):\n        if self.parents[x] != x:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\n    # return true if two are newly unioned, false if already unioned.\n    def union(self, x, y):\n        x0 = self.find(x)\n        y0 = self.find(y)\n        if x0 == y0:\n            return False\n        self.parents[y0] = x0\n        return True", "class Solution:\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(i,j):\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        \n        n = len(points)\n        fa = [i for i in range(n)]\n        def findfa(x):\n            if fa[x] == x:\n                return x\n            else:\n                fa[x] = findfa(fa[x])\n                return fa[x]\n        e = [(dist(i,j),i,j) for j in range(n) for i in range(n)]\n        e.sort()\n        ans = 0\n        for edge in e:\n            if findfa(edge[1]) != findfa(edge[2]):\n                ans += edge[0]\n                fa[findfa(edge[1])] = findfa(edge[2])\n        return ans\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 1:\n            return 0\n\n        graph = defaultdict(list)\n\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dist = abs(points[i][0]-points[j][0]) + \\\\\n                        abs(points[i][1]-points[j][1])\n                    graph[i].append((j, dist))\n\n        def mst(graph):\n            total = 0\n            seen = set()\n            start = next(iter(graph))\n            unseen = [(0, start)]\n            while unseen:\n                cost, node = heappop(unseen)\n                if node not in seen:\n                    seen.add(node)\n                    total += cost\n                    for nei, cost in graph[node]:\n                        if nei not in seen:\n                            heappush(unseen, (cost, nei))\n            return total\n\n        return mst(graph)", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        graph = defaultdict(list)\n        start = 0\n        for src in range(N):\n            for dst in range(N):\n                wt = abs(points[src][0]-points[dst][0]) + abs(points[src][1]-points[dst][1])\n                graph[src].append((dst, wt))\n                #graph[dst].append((src, wt))\n         \n        dist = {}\n        heap = [(0, start)]\n        while heap:\n            ddist, node = heapq.heappop(heap)\n            if node in dist:\n                continue        \n            dist[node] = ddist\n            for neighbor, d in graph[node]:\n                if neighbor not in dist:\n                    heapq.heappush (heap, (d, neighbor))\n                    \n        return sum(dist.values())", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda x, y: abs(x[0] - y[0]) + abs(x[1] - y[1])\n        res, length, heap, visited = 0, len(points), [(0, 0)], set()\n        while len(visited) < length:\n            w, u = heapq.heappop(heap)\n            if u not in visited:\n                res += w\n                visited.add(u)\n                for v in range(length):\n                    if v not in visited:\n                        heapq.heappush(heap, (manhattan(points[u], points[v]), v))\n        return res", "class Solution:\n    def find(self, pt):\n        if pt == self.roots[pt]:\n            return pt\n        self.roots[pt] = self.find(self.roots[pt])\n        return self.roots[pt]\n    \n    def union(self, p1, p2):\n        parent1, parent2 = self.find(p1), self.find(p2)\n        if parent1 == parent2:\n            return False\n        if self.rank[parent2] < self.rank[parent1]:\n            parent1, parent2 = parent2, parent1\n            p1, p2 = p2, p1\n        if self.rank[parent1] == self.rank[parent2]:\n            self.rank[parent2] += 1\n        self.roots[parent1] = parent2\n        # self.find(p1)\n        # self.find(p2)\n        return True\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        self.roots = {(x, y): (x, y) for (x, y) in points}\n        self.rank = {(x, y): 0 for (x, y) in points}\n        ans = 0\n        edges = []\n        for i in range(len(points)):\n            p1 = points[i][0], points[i][1]\n            for j in range(i+1, len(points)):\n                p2 = points[j][0], points[j][1]\n                # if p1 != p2:\n                dist = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n                edges.append((dist, p1, p2))\n        edges.sort()\n        for dist, p1, p2 in edges:\n            if self.union(p1, p2):\n                ans += dist\n        return ans\n        \n        # for i in range(len(points)):\n        #     x1, y1 = points[i]\n        #     best = (float('inf'), (x1, y1))\n        #     for j in range(len(points)):\n        #         if i == j:\n        #             continue\n        #         x2, y2 = points[j]\n        #         dist = abs(x1-x2) + abs(y1-y2)\n        #         best = min(best, (dist, (x2, y2)))\n        #     p1 = x1, y1\n        #     dist, p2 = best\n        #     if self.union(p1, p2):\n        #         print(\\\"connecting {}, {} distance {}\\\".format(p1, p2, dist))\n        #         ans += dist\n        # return ans\n", "import heapq\n\nclass DSU:\n    def __init__(self, n):\n        self.roots = [i for i in range(n)]\n    def find(self, x):\n        if self.roots[x] != x:\n            self.roots[x] = self.find(self.roots[x])\n        return self.roots[x]\n    def union(self, x, y):\n        self.roots[self.find(x)] = self.find(y)\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        # minimum spanning tree\n        \n        n = len(points)\n        if n == 1:\n            return 0\n        \n        heap = []\n        \n        for i in range(n-1):\n            for j in range(i+1, n):\n                ax, ay = points[i]\n                bx, by = points[j]\n                heapq.heappush(heap, [abs(ax-bx) + abs(ay-by), i, j])\n        #print(heap)\n        count = 0\n        dsu = DSU(n)\n        while heapq:\n            \n            dist, i, j = heapq.heappop(heap)\n            \n            if dsu.find(i) != dsu.find(j):\n                #print(dist, i, j)\n                count += dist\n                dsu.union(i, j)\n            for i in range(n):\n                dsu.find(i)\n            if len(set(dsu.roots)) == 1:\n                break\n        \n        return count", "class Solution:\n    \n    def d(self,p1,p2):\n        return abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n      \n        f = [[x] for x in points]\n        c = [float('inf') for x in points]\n        g = [-1 for x in points]\n        \n        r = []\n        \n        while len(f)>1:\n            i = 0\n            c = [float('inf') for x in f]\n            \n            while i<len(f):\n                dx = -1\n                j = 0\n                while j<len(f):\n                    if i!=j:\n                        for x in f[i]:\n                            for y in f[j]:\n                                val = self.d(x,y)\n                                if val<c[i]:\n                                    c[i]=val\n                                    g[i]=i\n                                    dx = j\n                            \n                                \n                    j+=1\n                if dx!=-1:\n                    \n                    r.append(c[i])\n                    f[i]+=f[dx]\n                    del f[dx]\n                    del c[dx]\n                    del g[dx]\n                \n                    i-=1\n                \n                i+=1\n        \n        return sum(r)\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        dis = [[0] * N for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if i == j: continue\n                dis[i][j] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        vis = [False] * N\n        heap = [(0, 0)]\n        res = 0\n        while heap:\n            weight, node = heapq.heappop(heap)\n            if vis[node]: continue\n            vis[node] = True\n            res += weight\n            for i in range(N):\n                if vis[i]: continue\n                heapq.heappush(heap, (dis[node][i], i))\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n=len(points)\n        def find(x):\n            if par[x]==x:\n                return x\n            par[x]=find(par[x])\n            return par[x]\n        def union(x,y):\n            a,b=find(x),find(y)\n            \n            if a==b:\n                return False\n            par[a]=b\n            return True\n        edges=[]\n        for i in range(n):\n            for j in range(i+1,n):\n                edges.append([abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),i,j])\n        edges.sort()\n       \n        par=[i for i in range(n)]\n        ans=0\n        for i in edges:\n            d,u,v=i[0],i[1],i[2]\n            if union(u,v):\n                ans+=d\n           \n        return ans", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        heap, total_cost = [], 0\n        for u in range(N-1):\n            for v in range(u+1, N):\n                heappush(heap, [dist(points[u], points[v]), u, v])\n        while heap:\n            cost, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                N -= 1\n                total_cost += cost\n                if N == 0:\n                    break\n        return total_cost\n\n    \n    \n    \n    \n    \n    \n    \n    \nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        dist = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        heap = []\n        for i in range(N-1):\n            for j in range(i+1, N):\n                heappush(heap, (dist(points[i], points[j]), i, j))\n        res = 0\n        while heap:\n            d, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                res += d\n                N -= 1\n                if N == 0:\n                    break\n        return res\n            \n                \n \n    \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #prims\n        g = defaultdict(list)\n        n = len(points)\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    g[i].append((abs(points[j][0]-points[i][0])+abs(points[j][1]-points[i][1]), j))\n        # print(g)\n        heap = [(0,0)]\n        ans = 0\n        visited = set()\n        while heap:\n            weight, to = heapq.heappop(heap)\n            if to in visited:\n                continue\n            ans += weight\n            visited.add(to)\n            \n            for cost, nei in g[to]:\n                if nei not in visited:\n                    heapq.heappush(heap, (cost, nei))\n            \n        \n\n        \n        return ans\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        hp, uf = [], UF(len(points))\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                p1, p2 = points[i], points[j]\n                weight = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n                heapq.heappush(hp, (weight, i, j))\n        res = 0\n        while hp:\n            weight, a, b = heapq.heappop(hp)\n            if uf.find(a) != uf.find(b):\n                uf.union(a, b)\n                res += weight\n        return res\n    \nclass UF:\n    def __init__(self, n):\n        self.uf = list(range(n))\n        self.sz = [1] * n\n        self.root_cnt = n\n    \n    def find(self, c):\n        root = c\n        while root != self.uf[root]:\n            root = self.uf[root]\n        while self.uf[c] != root:\n            p = self.uf[c]\n            self.uf[c] = root\n            c = p\n        return root\n    \n    def union(self, a, b):\n        ra, rb = self.find(a), self.find(b)\n        if ra == rb: return False\n        if self.sz[ra] < self.sz[rb]:\n            self.uf[ra] = rb\n            self.sz[rb] += self.sz[ra]\n        else:\n            self.uf[rb] = ra\n            self.sz[ra] += self.sz[rb]\n        self.root_cnt -= 1\n        return True", "class Solution:\n  def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    def manhattan(p1,p2):\n      x1,y1 = p1\n      x2,y2 = p2\n      return abs(x1-x2) + abs(y1-y2)\n         \n    s = len(points)\n    components = [i for i in range(s)]\n    costs = [(manhattan(points[j],points[i]),j,i) for i in range(s) for j in range(s)]\n    costs = sorted(costs, key=lambda x: x[0])\n    \n    totalCost = 0\n    for c, p1, p2 in costs:\n      if p1 != p2:\n        if not self.find(p1,p2, components):\n          self.union(p1,p2, components)\n          totalCost += c\n    \n    return totalCost\n  \n  def root(self, a, roots):\n    while(roots[a] != a):\n      roots[a] = roots[roots[a]]\n      a = roots[a]\n    return a\n  \n  def find(self, a,b, roots):\n    return self.root(a,roots) == self.root(b, roots)\n  \n  def union(self, a,b, roots):\n    ra = self.root(a, roots)\n    rb = self.root(b, roots)\n    \n    roots[rb] = ra", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        res = 0\n        dis = [math.inf] * n\n        curr = 0\n        explored = set()\n        for _ in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for i, (x, y) in enumerate(points):\n                if i in explored : continue\n                dis[i] = min(dis[i], abs(x - x0) + abs(y - y0))\n            delta, curr = min( (d, idx) for idx, d in enumerate(dis))\n            res += delta\n            dis[curr] = math.inf\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        total = 0\n        edges = []\n        N = len(points)\n        parent = [x for x in range(N)]\n        \n        def ufind(x):\n            if parent[x] != x:\n                return ufind(parent[x])\n            return x\n            \n        def uunion(x, y):\n            ux = ufind(x)\n            uy = ufind(y)\n            \n            parent[uy] = ux\n            \n        def dist(xi, yi, xj, yj):\n            return abs(xi-xj) + abs(yi-yj)\n        \n        for i in range(N):\n            xi, yi = points[i]\n            for j in range(i+1, N):\n                xj, yj = points[j]\n                edges.append((dist(xi, yi, xj, yj), i, j))\n                \n        edges.sort()\n        \n        for edge, i, j in edges:\n            if ufind(i) != ufind(j):\n                uunion(i, j)\n                total += edge\n        \n        return total", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def find(e1):\n            if a[e1]==-1:\n                return e1\n            return find(a[e1])\n            \n        n=len(points)\n        a=[-1]*n\n        def dist(i,j):\n            return abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n        temp=[]\n        for i in range(n):\n            for j in range(i+1,n):\n                temp.append((dist(i,j),i,j))\n        temp.sort()\n        #print(temp)\n        ans=0\n        for d,x,y in temp:\n            u1,u2=find(x),find(y)\n            if u1!=u2:\n                a[u2]=u1\n                ans+=d\n                #print(d,x,y)\n        return ans\n            \n        \n        \n        \n", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dis(s, e):\n            return abs(s[0] - e[0]) + abs(s[1] - e[1])\n        \n        def find(u):\n            if root[u] != u:\n                root[u] = find(root[u])\n            return root[u]\n        \n        def union(u, v):\n            ru, rv = find(u), find(v)\n            if ru == rv:\n                return False\n            if rank[ru] < rank[rv]:\n                root[ru] = rv\n                rank[rv] = rank[ru] + rank[rv]\n            else:\n                root[rv] = ru\n                rank[ru] = rank[ru] + rank[rv]\n            return True\n        \n        n = len(points)\n        res = 0\n        queue = []\n        root = [i for i in range(n)]\n        rank = [1] * n\n        for i in range(n):\n            s = points[i]\n            for j in range(i+1, n):\n                e = points[j]\n                heapq.heappush(queue, (dis(s, e), i, j))\n        while queue:\n            dis, s, e = heapq.heappop(queue)\n            if union(s, e):\n                res += dis\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        min_cost = 0\n        msp = set()\n        distances = self.compute_all_distances(points)\n        groups = defaultdict(set)\n        for i in range(len(points)):\n            groups[i].add(i)\n            \n        #print(distances)\n        while distances:\n            #print(groups)\n            next_min = heapq.heappop(distances)\n            #print(f\\\"considering dist: {next_min}\\\")\n            g1 = self.find_group(groups, next_min[1])\n            g2 = self.find_group(groups, next_min[2])\n            if g1 != g2:\n                min_cost += next_min[0]\n                groups[g1] = groups[g1] | groups[g2]\n                del groups[g2]\n        return min_cost\n    \n    def find_group(self, groups: dict, i: int) -> int:\n        for group in groups:\n            if i in groups[group]: return group\n        return 0\n    \n    def compute_all_distances(self, points: List[List[int]]) -> List[int]:\n        distances = list()\n        for i in range(len(points)-1):\n            p1 = points[i]\n            for j in range(i+1, len(points)):\n                p2 = points[j]\n                d = self.dist(p1, p2)\n                distances.append((d, i, j))\n        heapq.heapify(distances)\n        return distances\n    \n    def dist(self, p1: List[int], p2: List[int]) -> int:\n        return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ll = len(points)\n        if ll == 1:\n            return 0\n        distances = []\n        def get_distance(i, j):\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        \n        for i in range(ll):\n            for j in range(i + 1, ll):\n                distances.append((get_distance(i, j), i, j))\n        distances.sort()\n        parents = list(range(len(points)))\n    \n        def ufind(x):\n            if parents[x] != x:\n                return ufind(parents[x])\n            return x\n        \n        def uunion(x, y):\n            ux = ufind(x)\n            uy = ufind(y)\n            parents[uy] = ux\n        res = 0\n        for d, x, y in distances:\n            ux = ufind(x)\n            uy = ufind(y)\n            if ux != uy:\n                uunion(ux, uy)\n                res += d\n        return res\n                \n        \n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        \n        self.parent[px] = py\n        return True\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n, res, pq = len(points), 0, list()\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(pq, (d, i, j))\n                \n        uf = UnionFind(n)\n        while pq:\n            d, i, j = heapq.heappop(pq)\n            if uf.union(i, j):\n                res += d\n        return res", "class DSU:\n    \n    def __init__(self, N):\n        self.parents = list(range(N))\n        self.size = [1] * N\n    \n    def __find(self, x):\n        if self.parents[x] != x:\n            self.parents[x] = self.__find(self.parents[x])\n        \n        return self.parents[x]\n    \n    def union(self, x, y):\n        x = self.__find(x)\n        y = self.__find(y)\n        \n        if x == y:\n            return False\n    \n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        \n        self.parents[y] = x\n        self.size[x] += self.size[y]\n    \n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # minimum spanning tree.\n        edges = []\n        \n        def kruskals(N, edges):\n            cost = 0\n            dsu = DSU(N)\n            for i,j, dist in edges:\n                if dsu.union(i,j):\n                    cost += dist\n            \n            return cost\n        \n        for i, (x,y) in enumerate(points):\n            for j, (x1,y1) in enumerate(points):\n                \n                if i != j:\n                    dist = abs(x1 - x) + abs(y1 - y)\n                    edges.append([i, j, dist])\n            \n        edges.sort(key = lambda v : v[2])\n    \n        return kruskals(len(points), edges)", "#Build weighted graph and then use Union-Find to get MST\nimport heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N, g = len(points), []\n        res = 0\n        \n        #build the weighted graph\n        for i in range(N - 1):\n            x0, y0 = points[i]\n            for j in range(i + 1, N):                \n                x1, y1 = points[j]\n                dist = abs(x0 - x1) + abs(y0 - y1)\n                g.append((dist, (i, j)))\n                \n        #Heap sort the array: O(|E|)\n        heapq.heapify(g)\n        \n        #Union-Find to get MST\n        parents = [None] * N\n        for i in range(N): parents[i] = i\n            \n        def findParent(x):\n            if parents[x] != x:\n                parents[x] = findParent(parents[x])\n            \n            return parents[x]\n        \n        while g:\n            w, (a, b) = heapq.heappop(g)\n            pa = findParent(a)\n            pb = findParent(b)\n            \n            #union sub-graphs if not connected yet\n            if pa != pb:\n                res += w\n                parents[pa] = pb\n        \n        return res\n", "class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        \n    def find(self, i):\n        if self.p[i] != i:\n            self.p[i] = self.find(self.p[i])\n        return self.p[i]\n    \n    def union(self, x, y):\n        rx, ry = self.find(x), self.find(y)\n        self.p[rx] = ry\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) < 2:\n            return 0\n        hq = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(hq, (dist, i, j))\n        connect = 0\n        uf = UnionFind(len(points))\n        cost = 0\n        while connect != len(points) - 1 and hq:\n            d, i, j = heapq.heappop(hq)\n            ri, rj = uf.find(i), uf.find(j)\n            if ri != rj:\n                cost += d\n                uf.union(i, j)\n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            dis[curr] = math.inf\n            res += delta\n            \n        return res    \n    def minCostConnectPoints2(self, P: List[List[int]]) -> int:\n        res=0\n        n=len(P)\n        px,py=P[0]\n        seen={0}\n        todo=set(range(1,n))\n        while len(seen)<n:\n            mn=float('inf')\n            used=-1\n            for i in todo:\n                cx,cy=P[i]\n                for j in seen:\n                    px,py=P[j]\n                    can=abs(cx-px)+abs(cy-py)\n                    if can <mn:\n                        mn=can\n                        used=i\n            res+=mn\n            todo.remove(used)\n            seen.add(used)\n        return res\n\n    # def minCostConnectPoints1(self, P: List[List[int]]) -> int:\n    #     P.sort(key=lambda a:(abs(a[0])+abs(a[1])))\n    #     print(P)\n    #     res=0\n    #     px,py=P[0]\n    #     for cx,cy in P[1:]:\n    #         res+=abs(cx-px)+abs(cy-py)\n    #         px,py=cx,cy\n    #     return res    \n", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dic = {}\n        for i in range(len(points)):\n            val = []\n            for j in range(len(points)):\n                if points[j] != points[i]:\n                    val = (abs(points[j][0]-points[i][0]) + abs(points[j][1] - points[i][1]))   \n                    dic[i,j] = val\n        #print(dic)\n        g = Graph(len(points))\n        for k,v in dic.items():\n            g.addEdge(k[0],k[1],v)\n        \n        #g.printAll()\n        res = g.Prims()\n        #print(res)\n        return res\n        \nclass Graph:\n    def __init__(self, N):\n        self.V = N\n        self.adj = [[] for i in range(self.V)]\n        \n    def addEdge(self, u,v,w):\n        self.adj[u].append([v,w])\n        \n    def printAll(self):\n        for i in range(self.V):\n            print(i, self.adj[i])\n            \n    def Prims(self):\n        pq = [(0,0)]\n        visited = [False for i in range(self.V)]\n        cost = 0\n        #print(pq)\n        while len(pq) != 0:\n            cur_cost, cur_node = heapq.heappop(pq)\n            #print(cur_cost, cur_node)\n            if visited[cur_node]:\n                continue\n            visited[cur_node] = True\n            cost += cur_cost\n            \n            for neighbor_node, w in self.adj[cur_node]:\n                if not visited[neighbor_node]:\n                    heapq.heappush(pq, (w, neighbor_node))\n                    \n        return -1 if sum(visited) != self.V else cost\n            \n\\\"\\\"\\\"\nclass Graph:\n    def __init__(self, vertices):\n        self.v = vertices\n        self.graph = []\n        \n    def addEdge(self, u, v, w):\n        self.graph.append([u,v,w])\n        \n    def find(self,parent, i):\n        if parent[i] == -1:\n            return i\n        return self.find(parent, parent[i])\n    \n    def union(self, parent, x, y):\n        x_set = self.find(parent, x)\n        y_set = self.find(parent, y)\n        parent[x_set] = y_set\n        \n    def KruskalMST(self):\n        MST = []\n        i = 0\n        e = 0\n        self.graph = sorted(self.graph, key = lambda e:e[2])\n        parent = [-1] * self.v\n        while e < self.v -1:\n            u,v,w = self.graph[i]\n            i += 1\n            x = self.find(parent,u)\n            y = self.find(parent, v)\n            #print(x,y)\n            if x!= y:\n                e += 1\n                MST.append([u,v,w])\n                self.union(parent,x,y)\n                #print(MST)\n        s = 0\n        for u,v,w in MST:\n            s += w\n        return s\n\\\"\\\"\\\"\n        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dists = []\n        n = len(points)\n        for i in range(n - 1):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                dists.append((abs(x1 - x2) + abs(y1 - y2), i, j))\n        \n        roots = [-1] * n\n        def find(p1):\n            while roots[p1] >= 0:\n                p1 = roots[p1]\n            return p1\n        \n        def union(r1, r2):\n            if roots[r1] < roots[r2]:\n                roots[r1] += roots[r2]\n                roots[r2] = r1\n            else:\n                roots[r2] += roots[r1]\n                roots[r1] = r2\n                \n        #print(roots)\n        #union(0, 3)\n        #print(roots)\n        \n        res = 0\n        heapq.heapify(dists)\n        while dists:\n            dist, p1, p2 = heapq.heappop(dists)\n            r1 = find(p1)\n            r2 = find(p2)\n            if r1 != r2:\n                union(r1, r2)\n                res += dist\n        \n        return res\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        total = 0\n        edges = []\n        N = len(points)\n        parent = [x for x in range(N)]\n        rank = [1 for x in range(N)]\n        \n        def ufind(x):\n            if parent[x] == x:\n                return parent[x]\n            return ufind(parent[x])\n            \n        def uunion(x, y):\n            ux = ufind(x)\n            uy = ufind(y)\n            if rank[ux] > rank[uy]:\n                parent[uy] = ux\n                rank[ux] += rank[uy]\n            else:\n                parent[ux] = uy\n                rank[uy] += rank[ux]\n            \n        def dist(xi, yi, xj, yj):\n            return abs(xi-xj) + abs(yi-yj)\n        \n        for i in range(N):\n            xi, yi = points[i]\n            for j in range(i+1, N):\n                xj, yj = points[j]\n                edges.append((dist(xi, yi, xj, yj), i, j))\n                \n        heapq.heapify(edges)\n        \n        for v in range(len(edges)):\n            edge, i, j = heapq.heappop(edges)\n            if ufind(i) != ufind(j):\n                uunion(i, j)\n                total += edge\n        # for edge, i, j in edges:\n        #     if ufind(i) != ufind(j):\n        #         uunion(i, j)\n        #         total += edge\n        \n        return total", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        d = {}\n        min_heap = []\n        n = len(points)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1 = points[i][0], points[i][1]\n                x2, y2 = points[j][0], points[j][1]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                d[(x1, y1)] = (x1, y1)\n                d[(x2, y2)] = (x2, y2)\n                heapq.heappush(min_heap, (dist, (x1, y1), (x2, y2)))\n        \n        def find(x):\n            px = d[x]\n            if px != x:\n                d[x] = find(px)\n            return d[x] \n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            if px != py:\n                d[px] = py\n                \n        min_cost = 0\n        while min_heap:\n            c, p1, p2 = heapq.heappop(min_heap)\n            pa1, pa2 = find(p1), find(p2)\n            if pa1 != pa2:\n                union(p1, p2)\n                min_cost += c\n        return min_cost\n", "from queue import PriorityQueue\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        q = []\n        N = len(points)\n        \n        for i in range(N):\n            for j in range(i+1, N):\n                a,b = points[i]\n                c,d = points[j]\n                dist = abs(a-c) + abs(b-d)\n                q.append((dist, i, j))\n        \n        heapify(q)\n        ans = 0\n        par = list(range(N))\n        rank = [0] * N\n        \n        def find_parent(a):\n            if par[a] == a:\n                return a\n            par[a] = find_parent(par[a])\n            return par[a]\n        \n        def join(a, b):\n            pa, pb = find_parent(a), find_parent(b)\n            if pa == pb:\n                return 0\n            # Attach smaller rank tree under root of  \n            # high rank tree (Union by Rank) \n            if rank[pa] < rank[pb]: \n                par[pa] = pb\n            elif rank[pa] > rank[pb]: \n                par[pb] = pa \n            # If ranks are same, then make one as root  \n            # and increment its rank by one \n            else : \n                par[pb] = pa\n                rank[pa] += 1\n            return 1\n        \n        while q:\n            dist, i, j = heappop(q)\n            if join(i, j):\n                ans += dist\n        \n        return ans", "class DSU:\n    \n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.sizes = [1] * n\n        \n    def find(self, x):\n        p = self.parents[x]\n        if p == x: return x\n        self.parents[x] = self.find(p)\n        return self.parents[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return False\n        sx, sy = self.sizes[px], self.sizes[py]\n        if sy > sx: px, py = py, px\n        self.parents[py] = px\n        self.sizes[px] = sx + sy\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        for i1, p1 in enumerate(points):\n            for i2 in range(i1+1, len(points)):\n                p2 = points[i2]\n                d = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n                edges.append([d, i1, i2])\n                \n        edges.sort()\n        \n        dsu = DSU(len(points))\n        \n        t = 0\n        for c, i1, i2 in edges:\n            if dsu.union(i1, i2):\n                t += c\n                \n        return t\n            \n", "class UnionFind:\n    def __init__(self, size):\n        self.parent = [i for i in range(size)]\n        self.rank = [1] * size\n    \n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        \n        return self.parent[x]\n    \n    def union(self, x, y):\n        p_x, p_y = self.find(x), self.find(y)\n        \n        if p_x == p_y:\n            return \n        \n        if self.rank[p_x] < self.rank[p_y]:\n            self.parent[p_x] = p_y\n            self.rank[p_y] += self.rank[p_x]\n        else:\n            self.parent[p_y] = p_x\n            self.rank[p_x] += self.rank[p_y]\n        \n        \n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # build graph by using edge list (x, y, weight)\n        n = len(points)\n        \n        edge_list = []\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    edge_list.append([i, j, self.dist(points[i], points[j])])\n        \n        # find the final result: each time select the edge with minimun weight, and vertices come from different component, merge the component, add the cost\n        uf = UnionFind(n)\n        cost = 0\n        edge_list.sort(key = lambda x : x[2])\n        \n        for u, v, w in edge_list:\n            p_u, p_v = uf.find(u), uf.find(v)\n            \n            if p_u == p_v:\n                continue\n            \n            uf.union(u, v)\n            cost += w\n        \n        return cost\n    \n    def dist(self, point1, point2):\n        return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n                \n", "import heapq\n\nclass UnionFind:\n    \\\"\\\"\\\"\n    Class that implements the union-find structure with\n    union by rank and find with path compression\n    \\\"\\\"\\\"\n     \n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0 for x in range(n)]\n \n    def find(self, v):\n        if not v == self.parent[v]:\n            self.parent[v] = self.find(self.parent[v])\n        return self.parent[v]\n \n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n        if xRoot == yRoot:\n            return\n        if self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        else:\n            self.parent[xRoot] = yRoot\n            if self.rank[xRoot] == self.rank[yRoot]:\n                self.rank[yRoot] += 1\n                \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        mat = [[0] * len(points) for _ in range(len(points))]\n        heap = []\n        union_find = UnionFind(len(points))\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                mat[i][j] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(heap, (mat[i][j], i, j))\n        \n        total_cost = 0\n        while heap:\n            dist, a, b = heapq.heappop(heap)\n            \n            # if a, b not in same group:\n            if union_find.find(a) != union_find.find(b):\n                union_find.union(a, b)\n                total_cost += dist\n            \n        return total_cost", "#Build weighted graph and then use Union-Find to get MST\nimport heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N, g = len(points), []\n        res = 0\n        \n        #build the weighted graph\n        for i in range(N - 1):\n            x0, y0 = points[i]\n            for j in range(i + 1, N):                \n                x1, y1 = points[j]\n                dist = abs(x0 - x1) + abs(y0 - y1)\n                g.append((dist, (i, j)))\n                \n        #Heap sort the array: O(|E|)\n        heapq.heapify(g)\n        \n        #Union-Find to get MST\n        parents = [None] * N\n        for i in range(N): parents[i] = i\n            \n        def findParent(x):\n            if parents[x] != x:\n                parents[x] = findParent(parents[x])\n            \n            return parents[x]\n        \n        used_edges = 0\n        while used_edges < N - 1 and g:\n            w, (a, b) = heapq.heappop(g)\n            pa = findParent(a)\n            pb = findParent(b)\n            \n            #union sub-graphs if not connected yet\n            if pa != pb:\n                res += w\n                parents[pa] = pb\n                used_edges += 1\n        \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        visited = set()\n        res = 0\n        for idx1, point1 in enumerate(points):\n            for idx2, point2 in enumerate(points):\n                if idx1 != idx2:\n                    man = abs(point1[0]-point2[0]) + abs(point1[1]-point2[1])\n                    graph[idx1].append((man,idx2))\n                    graph[idx2].append((man,idx1))\n        con = set([0])\n        heap = graph[0][:]\n        heapify(heap)\n        while len(con) != len(points):\n            while heap:\n                cur = heappop(heap)\n                if cur[1] not in con:\n                    for neig in graph[cur[1]]:\n                        heappush(heap, neig)\n                    con.add(cur[1])\n                    res += cur[0]\n                    break\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        p = [0]*len(points)\n        for i in range(len(points)):\n            p[i] = i\n        pq = []\n        for i in range(len(points)-1):\n            for j in range(i+1, len(points)):\n                dis = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                heapq.heappush(pq, [dis, i, j])\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n        def union(x, y):\n            if x > y:\n                x, y = y, x\n            p[y] = x\n        \n        res = 0\n        while len(pq) > 0:\n            dis, i, j = heapq.heappop(pq)\n            if find(i) == find(j):\n                continue\n            res += dis\n            union(find(i), find(j))\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        parents = [i for i in range(n)]\n        groups = n\n        def find(x):\n            if parents[x] != x:\n                parents[x] = find(parents[x])\n            return parents[x]\n        \n#         def merge(x, y):\n            \n#             rx, ry = find(x), find(y)\n#             if rx != ry:\n#                 groups -= 1\n#                 parents[rx] = ry\n        \n        distance = 0\n        heap = []\n        for i in range(n):\n            for j in range(i):\n                heapq.heappush(heap, (abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j))\n        \n        while heap or groups > 1:\n            dist, i, j = heapq.heappop(heap)\n            ri, rj = find(i), find(j)\n            if ri != rj:\n                groups -= 1\n                parents[ri] = rj\n                distance += dist\n        return distance\n            \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        graph = []\n        self.parent = [i for i in range(len(points))]\n        cost = 0\n        \n        for i in range(len(points)-1):\n            for j in range(len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                graph.append([i, j, dist])\n                \n        graph = sorted(graph, key = lambda x: x[2])\n        \n        for u, v, c in graph:\n            if self.union(u, v):\n                cost += c\n                \n        return cost\n    \n    \n    def union(self, x, y):\n        parentX = self.find(x)\n        parentY = self.find(y)\n        \n        if parentX == parentY:\n            return False\n        \n        if self.parent[parentX] <= self.parent[parentY]:\n            self.parent[parentY] = parentX\n        else:\n            self.parent[parentX] = parentY\n            \n        return True\n    \n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n            \n        return self.parent[x]", "\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = collections.defaultdict(list)\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dist = abs(points[j][1]-points[i][1]) + abs(points[j][0] - points[i][0])\n                \n                graph[i].append((j, dist))\n                graph[j].append((i, dist))\n        #print(graph)\n        dist = {}\n\\t\\t# Using heap to find min wt\n        heap = [(0, 0)]\n        while heap:\n            ddist, node = heapq.heappop(heap)\n            if node in dist:\n                continue\n            dist[node] = ddist\n            for neighbor, d in graph[node]:\n                if neighbor not in dist:\n                    heapq.heappush (heap, (d, neighbor))\n        return sum(dist.values())", "from heapq import heappush, heappop\n\nclass UnionFind:\n    def __init__(self, n):\n        self.group = list(range(n))\n        self.size = [0] * n\n    \n    def find(self, i):\n        if i == self.group[i]:\n            return i\n        p = self.find(self.group[i])\n        self.group[i] = p\n        return p\n    \n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if self.size[i] <= self.size[j]:\n            self.group[i] = j\n            self.size[j] += self.size[i]\n        else:\n            self.group[j] = i\n            self.size[i] += self.size[j]\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # minuim spining tree\n        weights = []\n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                weight = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                heappush(weights, (weight, i,j))\n                \n                \n        # print(weights)\n        uf = UnionFind(len(points))\n        res = 0\n        \n        while weights:\n            min_edge, i, j = heappop(weights)\n            if uf.find(i) == uf.find(j):\n                continue\n            uf.union(i, j)\n            res += min_edge\n                \n        return res\n            \n            \n        \n      \n\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def cal(p1, p2):\n            return abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n        d, q = {}, [[0, 0]]\n        ans = 0\n        while q:\n            dis, a = heapq.heappop(q)\n            if a not in d:\n                d[a] = dis\n                ans += dis\n                for b in range(len(points)):\n                    if b not in d:\n                        heapq.heappush(q, [cal(points[a], points[b]), b])\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        parent = collections.defaultdict(int)\n\n        def find(p):\n            if parent[p] == 0:\n                return p\n            return find(parent[p])\n\n        def union(p1, p2):\n            if p1 != p2:\n                if p1 < p2:\n                    parent[p2] = p1\n                else:\n                    parent[p1] = p2\n\n        V = points\n        E = []\n        for p1 in V:\n            for p2 in V:\n                if p1 != p2:\n                    E.append((tuple(p1),tuple(p2)))\n        W = {}\n        for edge in E:\n            W[edge] = abs(edge[0][0]-edge[1][0]) + abs(edge[0][1]-edge[1][1])\n        sorted_W = {k: v for k, v in sorted(W.items(), key=lambda item: item[1])}\n    \n        count = 0\n        cost = 0\n        for e in sorted_W:\n            x, y = e[0], e[1]\n            x_set, y_set = find(x), find(y)\n            if x_set != y_set:\n                union(x_set, y_set)\n                count += 1\n                cost += sorted_W[e]\n            if count ==  len(V) - 1:\n                break\n        return cost", "class Solution:\n    \n    def calculateDistance(self, point1, point2):\n        return abs(point1[0]-point2[0]) + abs(point1[1]-point2[1])\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        queue = []\n        queueSet = [0]*len(points)\n        setDict = {}\n        for i in range(len(points)):\n            for j in range(i+1,len(points)): \n                heappush(queue, (self.calculateDistance(points[i],points[j]),points[i],points[j]))\n            queueSet[i]=[tuple(points[i])]\n            setDict[tuple(points[i])] = i\n        totalCost = 0\n        while queue:\n            p = heappop(queue)\n            t1 = tuple(p[1])\n            t2 = tuple(p[2])\n            if setDict[t1]!=setDict[t2]:\n                totalCost = totalCost + p[0]\n                if setDict[t1]<setDict[t2]:\n                    queueSet[setDict[t1]].extend(queueSet[setDict[t2]])\n                    for ch in queueSet[setDict[t2]]:\n                        setDict[ch] = setDict[t1]\n                    setDict[t2] = setDict[t1]\n                else:\n                    queueSet[setDict[t2]].extend(queueSet[setDict[t1]])\n                    for ch in queueSet[setDict[t1]]:\n                        setDict[ch] = setDict[t2]\n                    \n                    setDict[t1] = setDict[t2]\n    \n        return totalCost\n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        graph = []\n        self.parent = [i for i in range(len(points))]\n        cost = 0\n        self.N = len(points)\n        \n        for i in range(len(points)-1):\n            for j in range(len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                graph.append([i, j, dist])\n                \n        graph = sorted(graph, key = lambda x: x[2])\n        \n        for u, v, c in graph:\n            if self.union(u, v):\n                cost += c\n            if self.N == 0:\n                break\n                \n        return cost\n    \n    \n    def union(self, x, y):\n        parentX = self.find(x)\n        parentY = self.find(y)\n        \n        if parentX == parentY:\n            return False\n        \n        if self.parent[parentX] <= self.parent[parentY]:\n            self.parent[parentY] = parentX\n        else:\n            self.parent[parentX] = parentY\n        self.N -= 1\n        return True\n    \n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n            \n        return self.parent[x]", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1: return 0\n        \n        res = 0\n        n = len(points)\n        visited = set([0])\n        cur = 0\n        dist = [float('inf')] * n\n        \n        for _ in range(n-1):\n            x, y = points[cur]\n            for j, (u, v) in enumerate(points):\n                if j in visited: continue\n                dist[j] = min(dist[j], abs(x - u) + abs(y - v))\n\n            d, cur = min([(d, j) for j, d in enumerate(dist)])\n            dist[cur] = float('inf')\n            res += d\n            visited.add(cur)\n\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        visited = [False] * len(points)\n        distance = [[0]*len(points) for p in points]\n        queue = [(0,0)] # cost, point_index\n        for i in range(len(points)):\n            for j in range(len(points)):\n                distance[i][j] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n\n        res = 0\n        while queue:\n            cost, point = heapq.heappop(queue)\n            if visited[point] == True: continue\n            visited[point] = True\n            res += cost\n            for i in range(len(points)):\n                if not visited[i]:\n                    heapq.heappush(queue, (distance[point][i], i))\n        \n        return res           \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        parent = {}\n        size = defaultdict(lambda: 1)\n\n        def find(u):\n            if u != parent.get(u, u):\n                parent[u] = find(parent[u])  # path compression\n            return parent.get(u, u)\n\n        def union(u, v):\n            u, v = find(u), find(v)\n            if u != v:\n                if size[u] < size[v]:  # union by size / rank\n                    u, v = v, u\n\n                parent[u] = v\n                size[u] += size[v]\n\n        total = 0\n        edges = []\n        for i in range(len(points)):\n            for j in range(len(points)):\n                if i!=j:\n                    edges.append((abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),i,j))\n        edges.sort()\n\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                total += cost\n                union(u, v)\n\n        return total\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def calculate_distance(x1, y1, x2, y2):\n            return abs(x1 - x2) + abs(y1 - y2)\n\n        res = 0\n        n = len(points)\n        visited = set()\n        d = defaultdict(list)\n\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    d[i].append((calculate_distance(points[i][0], points[i][1], points[j][0], points[j][1]), j))\n                    d[j].append((calculate_distance(points[i][0], points[i][1], points[j][0], points[j][1]), i))\n\n        heap = d[0]\n        heapq.heapify(heap)\n        visited.add(0)\n        count = 1\n\n        while heap and count < n:\n            dist, j = heapq.heappop(heap)\n\n            if j not in visited:\n                visited.add(j)\n                res += dist\n                count += 1\n                for r in d[j]:\n                    heapq.heappush(heap, r)\n\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if not points: return 0        \n        \n        n = len(points)\n        dist = [[0] * n for _ in range(n)]\n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(n):\n                x2, y2 = points[j]\n                dist[i][j] = abs(x1 - x2) + abs(y1 - y2)\n                \n        origin = 0\n        q = []\n        for j, d in enumerate(dist[0]):\n            heapq.heappush(q, (d, j))\n        \n        ans = 0\n        visited = set([0])\n        while q:\n            d, child = heapq.heappop(q)\n            if child not in visited:\n                ans += d\n                visited.add(child)\n                for j, n_d in enumerate(dist[child]):\n                    if j not in visited:\n                        heapq.heappush(q, (n_d, j))\n        return ans\n            \n        \n        \n        \n                \n", "class Solution:\n    def minCostConnectPoints(self,points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        costs = []\n        for i in range(n):\n            cost = [0] * n\n            costs.append(cost)\n\n        for i in range(n):\n            ax = points[i][0]\n            ay = points[i][1]\n            for j in range(i + 1, n):\n                bx = points[j][0]\n                by = points[j][1]\n                costs[i][j] = abs(ax - bx) + abs(ay - by)\n                costs[j][i] = costs[i][j]\n        conn = [-1] * n\n\n        for i in range(n):\n            for j in range(n):\n                cs = costs[i][j]\n                if cs != 0:\n                    if conn[i] == -1:\n                        conn[i] = j\n                    else:\n                        if cs < costs[i][conn[i]]:\n                            conn[i] = j\n        groups = []\n        toset = list(range(n))\n        conngroupcost = 0\n        while len(toset) > 0:\n            point = toset[0]\n            g = [point]\n            toset.remove(point)\n            while conn[point] not in g:\n                g.append(conn[point])\n                conngroupcost+=costs[point][conn[point]]\n                toset.remove(conn[point])\n                point = conn[point]\n            while len(toset) > 0:\n                npoint = []\n                for x in toset:\n                    if conn[x] in g:\n                        npoint.append(x)\n                        g.append(x)\n                        conngroupcost += costs[x][conn[x]]\n                if len(npoint) == 0:\n                    break\n                else:\n                    for np in npoint:\n                        toset.remove(np)\n            groups.append(g)\n\n        while len(groups) > 1:\n            minlen=-1\n            minindex=-1\n            for gi in range(len(groups)):\n                if minlen==-1:\n                    minlen=len(groups[gi])\n                    minindex=gi\n                else:\n                    if len(groups[gi])<minlen:\n                        minlen = len(groups[gi])\n                        minindex = gi\n            gps = groups[minindex]\n            mincost = -1\n            mincostp = -1\n            for gp in gps:\n                for i in range(n):\n                    if i not in gps:\n                        if mincost == -1:\n                            mincost = costs[gp][i]\n                            mincostp = i\n                        else:\n                            if mincost > costs[gp][i]:\n                                mincost = costs[gp][i]\n                                mincostp = i\n\n            conngroupcost += mincost\n            conngindex = -1\n            for gindex in range(len(groups)):\n                if mincostp in groups[gindex]:\n                    conngindex = gindex\n                    break\n            groups[minindex] = groups[minindex] + groups[conngindex]\n            del groups[conngindex]\n        return conngroupcost\n                    \n        \n        \n                \n                \n", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        points = [tuple(point) for point in points]\n        currPoint = points[0]\n        vis = set()\n        que = [[0, currPoint]]\n        \n        def getDist(a, b):\n            return abs(a[0]-b[0])+abs(a[1]-b[1])\n        ans = 0\n        while que:\n            dist, cpoint = heappop(que);\n            if cpoint in vis:\n                continue\n            ans+=dist\n            vis.add(cpoint)\n            for point in points:\n                if point not in vis:\n                    newDist = getDist(cpoint, point)\n                    heappush(que, [newDist, point])\n        return ans\n            \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <=1: return 0\n        minHeap = []\n        for i in range(n):\n            for j in range(i+1, n):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                dx, dy = abs(x1-x2), abs(y1-y2)\n                heapq.heappush(minHeap,(dx+dy, i, j))\n                \n        #print(minHeap)\n        \n        uf = [i for i in range(n)]\n        \n        def find(x):\n            if uf[x] == x:\n                return x\n            uf[x] = find(uf[x])\n            return uf[x]\n        \n        res = 0 \n        while minHeap:\n            d, x, y = heapq.heappop(minHeap)\n            px, py = find(x), find(y)\n            if px == py:\n                continue\n            else:\n                res += d\n                uf[px] = py\n        return res", "import heapq\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def add(self, x):\n        self.parent[x] = x\n        self.rank[x] = 0\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xRoot, yRoot = self.find(x), self.find(y)\n\n        if xRoot == yRoot:\n            return\n\n        xRank, yRank = self.rank[xRoot], self.rank[yRoot]\n        \n        # let yRoot be the one with smaller rank\n        if xRank < yRank:\n            yRoot, xRoot = xRoot, yRoot\n            \n        # small rank points to large rank\n        self.parent[yRoot] = xRoot\n        # large rank takes the small rank to count total #\n        self.rank[xRoot] += self.rank[yRoot]\n        \n\n        return\n\nclass Solution:\n    def dist(self, p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dsu = UnionFind(len(points))\n        edges = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                edges.append((self.dist(points[i], points[j]), i, j))\n                \n        \n        heapq.heapify(edges)\n        ans = 0\n        while edges:\n            d, u, v = heapq.heappop(edges)\n            if dsu.find(u) != dsu.find(v):\n                ans += d\n                dsu.union(u, v)\n        \n        return ans\n        \n", "class Node:\n    def __init__(self, parent, value):\n        self.parent = parent\n        self.rank = 0\n        self.size = 1\n        self.value = value\n\nclass UnionFind:\n    def __init__(self, nodes):\n        self.subsets = [Node(i, v) for i, v in enumerate(nodes)]\n        self.maxSubsetSize = 1\n\n    def union(self, i, j):\n        irep = self.find(i)\n        jrep = self.find(j)\n        if irep == jrep:\n            return\n        # union by rank\n        if self.subsets[irep].rank > self.subsets[jrep].rank:\n            self.subsets[jrep].parent = irep\n            self.subsets[irep].size += self.subsets[jrep].size\n        elif self.subsets[jrep].rank > self.subsets[irep].rank:\n            self.subsets[irep].parent = jrep\n            self.subsets[jrep].size += self.subsets[irep].size\n        else:\n            self.subsets[irep].parent = jrep\n            self.subsets[jrep].rank += 1\n            self.subsets[jrep].size += self.subsets[irep].size\n        self.maxSubsetSize = max(self.maxSubsetSize, max(self.subsets[irep].size, self.subsets[jrep].size))\n\n    def find(self, i):\n        if self.subsets[i].parent != i:\n            # path compression\n            self.subsets[i].parent = self.find(self.subsets[i].parent)\n        return self.subsets[i].parent\n\nfrom heapq import heapify, heappop\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            for j in range(i+1, len(points), 1):\n                x2, y2 = points[j]\n                edges.append((abs(x1-x2)+abs(y1-y2), i, j))\n        heapify(edges)\n        uf = UnionFind(range(len(points)))\n        total = 0\n        while len(edges) > 0:\n            d, i, j = heappop(edges)\n            if uf.find(i) != uf.find(j):\n                total += d\n                uf.union(i, j)\n        return total", "from heapq import heappop, heappush, heapify \nfrom collections import defaultdict\n\ndef distance(pointA, pointB):\n    \n    return abs(pointA[0]-pointB[0]) + abs(pointA[1]-pointB[1])\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        \n        mat = [[float('inf')] * n for i in range(n)]\n        \n        lookup = defaultdict(list)\n        minHeap = []\n        \n        for idx, aPoint in enumerate(points):\n            for bIdx in range(idx+1, n):\n                bPoint = points[bIdx]\n                \n                dist = distance(aPoint, bPoint)\n                \n                minHeap.append(dist)\n                \n                lookup[dist].append([idx, bIdx])\n                                \n        if n == 1:\n            return 0\n        \n        visited = set()\n        cost = 0\n        \n        minHeap = sorted(minHeap)\n        minValue = minHeap[0]\n        minIndex = lookup[minValue][0]\n        visited.add(minIndex[0])\n        visited.add(minIndex[1])\n        cost += minValue\n        \n        while len(visited) != n:\n            for minValue in minHeap:\n                minIndexs = lookup[minValue]\n                ifFound = False\n                                    \n                for minIndex in minIndexs:\n                    x = minIndex[0]\n                    y = minIndex[1]\n                    if x in visited and y in visited:\n                        continue\n                    elif x in visited or y in visited:\n                        visited.add(x)\n                        visited.add(y)\n                        cost += minValue\n                        ifFound = True\n                        break\n                if ifFound:\n                    break\n                \n                        \n        return cost\n        \n        \n#         visited = set()\n#         costs = []\n#         minValue = float('inf')\n#         minIndex = (0,0)\n#         for i in range(n):\n#             for j in range(n):\n#                 if mat[i][j] < minValue:\n#                     minValue = min(minValue, mat[i][j])\n#                     minIndex = (i,j)\n        \n#         visited.add(minIndex[0])\n#         visited.add(minIndex[1])\n#         costs.append(minValue)\n                \n#         while len(visited) != n:\n#             minValue = float('inf')\n#             minIndex = (0,0)\n#             for i in visited:\n#                 for idx, value in enumerate(mat[i]):\n#                     if value < minValue and idx not in visited:\n#                         minValue = min(minValue, value)\n#                         minIndex = (i, idx)\n                                \n#             visited.add(minIndex[0])\n#             visited.add(minIndex[1])\n#             costs.append(minValue)\n#             mat[minIndex[0]][minIndex[1]] = float('inf')\n#             mat[minIndex[1]][minIndex[0]] = float('inf')\n         \n#         return sum(costs)\n        \n            \n        \n        \n        \n        \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            dis[curr] = math.inf\n            res += delta\n            \n        return res", "from math import inf\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dis(i,j):\n            x1,y1,x2,y2=points[i][0],points[i][1],points[j][0],points[j][1]\n            ans=abs(x1-x2)+abs(y1-y2)\n            return ans\n        \n        n=len(points)\n        connected=set()       \n        connected.add(0)\n        uncon=set()\n        for i in range(1,n):\n            uncon.add(i)\n        \n        edges={}\n        for i in range(n):\n            for j in range(n):\n                if i!=j:\n                    edges[(i,j)]=dis(i,j)\n                    edges[(j,i)]=edges[(i,j)]\n                    \n        total=0\n        dis=[inf for _ in range(n)]\n        pt=0\n        for _ in range(n-1):\n            for i in uncon:\n                dis[i]=min(edges[(i,pt)],dis[i])\n            score,pt=min((score,i) for i,score in enumerate(dis))\n            dis[pt]=inf\n            total+=score\n            connected.add(pt)\n            uncon.remove(pt)\n        \n        return total\n            \n\n", "\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = collections.defaultdict(list)\n        n = len(points)\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    graph[i].append((abs(points[j][0]-points[i][0])+abs(points[j][1]-points[i][1]), j))\n\n        heap = [(0,0)]\n        res = 0\n        visited = set()\n        while heap:\n            weight, dest = heapq.heappop(heap)\n            if dest in visited:\n                continue\n            res += weight\n            visited.add(dest)\n\n            for cost, nei in graph[dest]:\n                if nei not in visited:\n                    heapq.heappush(heap, (cost, nei))\n\n        return res\n\n    \n    \n    \n", "class order(tuple):\n    def __lt__(a,b):\n        return a[0] < b[0]\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        adjList = {}\n        edges,n,ans = [],len(points),0\n        # add edges\n        for i in range(n):\n            for j in range(i+1,n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist,i,j))\n        \n        parent = [i for i in range(n)]\n        rank = [0 for i in range(n)]\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x,y):\n            x,y = find(x),find(y)\n            if rank[x] > rank[y]:\n                parent[y] = x\n            else:\n                parent[x] = y\n            \n            if rank[x] == rank[y]:\n                rank[x] += 1\n            return\n        edges = sorted(edges, key=order)\n        for d,u,v in edges:\n            x,y = find(u),find(v)\n            if x != y:\n                union(x,y)\n                ans += d\n        return ans\n", "class UnionFind:\n  def __init__(self):\n    self.father = {}\n    self.size = {}\n\n  def find(self, p):\n    while self.father[p] != p:\n      self.father[p] = p = self.father[self.father[p]]\n    return p\n\n  def union(self, p, q):\n    self.insert(p)\n    self.insert(q)\n\n    p, q = map(self.find, (p, q))\n    if p == q:\n      return False\n\n    if self.size[p] < self.size[q]:\n      p, q = q, p\n\n    self.size[p] += self.size[q]\n    self.father[q] = p\n\n    return True\n\n  def insert(self, p):\n    if p not in self.father:\n      self.father[p] = p\n      self.size[p] = 1\n\n      \nclass Solution:\n  def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    dis = []\n    for i, (x, y) in enumerate(points):\n      for u, v in points[:i]:\n        dis.append((abs(x-u) + abs(y-v), (x, y), (u, v)))\n    dis.sort()\n    \n    uf, r = UnionFind(), 0\n    for d, p1, p2 in dis:\n      if uf.union(p1, p2):\n        r += d\n    return r", "class UnionFind:\n    def __init__(self, n): \n        self.parent = list(range(n))\n        self.count = n\n        self.rank = [1]*n\n        \n    def find(self, p): \n        if p != self.parent[p]:\n            self.parent[p] = self.find(self.parent[p]) # path compression \n        return self.parent[p]\n    \n    def union(self, p, q): \n        prt = self.find(p)\n        qrt = self.find(q)\n        if prt == qrt: return False # already connected \n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\n        self.parent[prt] = qrt \n        self.rank[qrt] += self.rank[prt]\n        return True \n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        uf = UnionFind(n)\n        hp = [] # min heap \n        \n        for i in range(n):\n            for ii in range(i+1, n):\n                cost = abs(points[i][0] - points[ii][0]) + abs(points[i][1] - points[ii][1])\n                heappush(hp, (cost, i, ii))\n        \n        ans = 0\n        while hp and uf.count != 1: \n            cost, i, ii = heappop(hp)\n            if uf.union(i, ii): ans += cost \n        return ans ", "from heapq import heappop, heappush, heapify\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = [[] for i in range(len(points))]\n        \n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        start_point = 0\n        min_edge = 1000000000\n        for i, p_i in enumerate(points[:-1]):\n            for j, p_j in enumerate(points[i+1:], i + 1):\n                d = dist(p_i, p_j)\n                graph[i].append((j, d))\n                graph[j].append((i, d))\n                if d < min_edge:\n                    min_edge = d\n                    start_point = i\n        \n        \n        total_dist = 0\n        pq = [(d, n) for n, d in graph[start_point]]\n        heapify(pq)\n        visited = [False] * len(points)\n        visited[start_point] = True\n        \n        while len(pq) > 0:\n            d, node = heappop(pq)\n            if visited[node]:\n                continue\n            visited[node] = True\n            total_dist += d\n            for child, child_d in graph[node]:\n                if visited[child]:\n                    continue\n                heappush(pq, (child_d, child))\n        \n        return total_dist\n            \n            \n            \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # return self.MSTkruskal(points) # 8504ms\n        return self.MSTprim(points) # 7640 ms\n        \n    def MSTkruskal(self, points):\n        X = dict()      \n        R = dict()\n\n        # \u521d\u59cb\u5316\u5e76\u67e5\u96c6\n        def make_set(point):\n            X[point] = point\n            R[point] = 0\n\n        # \u627e\u5230\u8282\u70b9\u7684\u6839\n        def find(point):\n            if X[point] != point:\n                X[point] = find(X[point])\n            return X[point]\n\n        # \u8fde\u63a5\u4e24\u4e2a\u8282\u70b9\n        def merge(point1,point2):\n            r1 = find(point1)\n            r2 = find(point2)\n            if r1 != r2:\n                if R[r1] > R[r2]:\n                    X[r2] = r1\n                else:\n                    X[r1] = r2\n                    if R[r1] == R[r2]: \n                        R[r2] += 1\n\n        #KRUSKAL\u7b97\u6cd5\u5b9e\u73b0\n        def kruskal(graph):\n            # \u904d\u5386\u9876\u70b9\uff0c\u521d\u59cb\u5316\u5e76\u67e5\u96c6\n            for vertex in graph['vertices']:\n                make_set(vertex)\n\n            k_tree = set()\n\n            edges = graph['edges']\n            # \u6309\u7167\u6743\u91cd\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n            edges.sort()    \n\n            # \u904d\u5386\u6bcf\u4e00\u6761\u8fb9        \n            for weight, vertex1, vertex2 in edges:\n                # \u5224\u65ad\u4e24\u4e2a\u9876\u70b9\u662f\u5426\u8054\u901a\uff1a\u5373\u662f\u5426\u5728\u5c5e\u4e8e\u4e00\u68f5\u6811\n                if find(vertex1) != find(vertex2):\n                    # \u5982\u679c\u672a\u8054\u901a\uff0c\u5219\u5c06\u5176\u8054\u901a\n                    merge(vertex1, vertex2)\n                    # \u52a0\u5165\u751f\u6210\u6811\n                    k_tree.add((weight, vertex1, vertex2))\n\n            return k_tree\n        \n        N = len(points)\n        graph = {'vertices' : list(range(N)), 'edges' : list()}\n        for i in graph['vertices']:\n            for j in graph['vertices']:\n                if i != j:\n                    graph['edges'].append((abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j))\n        return sum(weight for weight, _, _ in kruskal(graph))\n    \n    def MSTprim(self, points):\n\n        def prim(origin_vertex, edges):\n            adjacent_vertex = defaultdict(list)      \n\n            # \u5c06edges\u5217\u8868\u4e2d\u5404\u9879\u5f52\u7c7b\u6210\u4ee5\u67d0\u70b9\u4e3adictionary\u7684key\uff0c\u5176value\u5219\u662f\u5176\u76f8\u90bb\u7684\u70b9\u53ca\u5176\u6743\u91cd\n            # \u5f62\u5982\uff1a{'A': [(7, 'A', 'B'), (5, 'A', 'D')], \n            #       'C': [(8, 'C', 'B'), (5, 'C', 'E')]}\n            for weight, vertex1, vertex2 in edges:\n                adjacent_vertex[vertex1].append((weight, vertex1, vertex2))\n\n            p_tree = []        \n            # \u6807\u8bb0\u662f\u5426\u5df2\u9009\u62e9\uff1a\u8fd9\u91cc\u9996\u5148\u9009\u62e9\u6e90\u70b9\n            chosed = set([origin_vertex]) \n\n            # \u5f97\u5230\u4e0e\u6e90\u70b9\u76f4\u8fde\u7684\u76f8\u90bb\u70b9\u8fb9\n            adjacent_vertexs_edges = adjacent_vertex[origin_vertex]  \n\n            # \u5c06\u6e90\u70b9\u6240\u6709\u7684\u76f4\u8fde\u8fb9\u52a0\u5165\u5c0f\u9876\u5806\u4e2d\n            heapify(adjacent_vertexs_edges)\n\n            # \u5faa\u73af\u904d\u5386\u5c0f\u9876\u5806\n            while adjacent_vertexs_edges:\n                # \u4ece\u5806\u4e2d\u53d6\u51fa\u8fb9\u6743\u503c\u6700\u5c0f\u7684\u70b9\u4fe1\u606f\u3002\n                weight, vertex1, vertex2 = heappop(adjacent_vertexs_edges) \n\n                # \u5982\u679c\u8fb9\u6743\u503c\u6700\u5c0f\u7684\u5bf9\u7aef\u70b9\u8fd8\u6ca1\u6709\u52a0\u5165\u751f\u6210\u6811\u4e2d    \n                if vertex2 not in chosed:\n                    # \u5c06\u8be5\u70b9\u6807\u8bb0\u5df2\u9009\u62e9\n                    chosed.add(vertex2)\n\n                    # \u5c06\u8be5\u6700\u5c0f\u8fb9\u52a0\u5165\u751f\u6210\u6811\u4e2d\n                    p_tree.append((vertex1,vertex2,weight))\n\n                    # \u904d\u5386\u4e0e\u8be5\u70b9\u76f4\u8fde\u7684\u76f8\u90bb\u70b9\u8fb9\n                    for next_vertex in adjacent_vertex[vertex2]:   \n                        # \u5982\u679c\u8be5\u70b9\u7684\u5bf9\u7aef\u70b9\u8fd8\u6ca1\u6709\u88ab\u9009\u62e9\uff0c\u5219\u5c06\u5176\u5bf9\u5e94\u7684\u8fb9\u52a0\u5165\u5806\u4e2d             \n                        if next_vertex[2] not in chosed:\n                            heappush(adjacent_vertexs_edges,next_vertex)\n\n            return p_tree\n        \n        N = len(points)\n        graph = {'vertices' : list(range(N)), 'edges' : list()}\n        for i in graph['vertices']:\n            for j in graph['vertices']:\n                if i != j:\n                    graph['edges'].append((abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j))   \n        return sum(weight for _, _, weight in prim(graph['vertices'][0], graph['edges']))\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #prims\n        g = defaultdict(list)\n        n = len(points)\n\\t    #create graph\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    g[i].append((abs(points[j][0]-points[i][0])+abs(points[j][1]-points[i][1]), j)) \n    \n        heap = [(0,0)]\n        ans = 0\n        visited = set()\n        while heap:\n            weight, to = heapq.heappop(heap)\n            if to in visited:\n                continue\n            ans += weight\n            visited.add(to)\n        \n            for cost, nei in g[to]:\n                if nei not in visited:\n                    heapq.heappush(heap, (cost, nei))\n    \n        return ans\n                            \n        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #prims\n        g = defaultdict(list)\n        n = len(points)\n        #create graph\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    g[i].append((abs(points[j][0]-points[i][0])+abs(points[j][1]-points[i][1]), j))\n\n        heap = [(0,0)]\n        ans = 0\n        visited = set()\n        while heap:\n            weight, to = heapq.heappop(heap)\n            if to in visited:\n                continue\n            ans += weight\n            visited.add(to)\n\n            for cost, nei in g[to]:\n                if nei not in visited:\n                    heapq.heappush(heap, (cost, nei))\n\n        return ans", "class DSU:\n    def __init__(self, n):\n        self.n = n\n        self.fa = list(range(n))\n\n    def find(self, x):\n        r = x\n        while self.fa[r] != r:\n            r = self.fa[r]\n        i = x\n        while i != r:\n            i, self.fa[i] = self.fa[i], r\n        return r\n    \n    def join(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            self.fa[x] = y\n\nclass Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        n = len(p)\n        e = []\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                d = abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])\n                e.append((d, i, j))\n        \n        e.sort()\n        \n        dsu = DSU(n)\n        m = 0\n        ans = 0\n        for (d, i, j) in e:\n            if m == n - 1:\n                break\n            if dsu.find(i) != dsu.find(j):\n                ans += d\n                dsu.join(i, j)\n        return ans\n", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        heap, total_cost = [], 0\n        for u in range(N-1):\n            for v in range(u+1, N):\n                heappush(heap, [dist(points[u], points[v]), u, v])\n        while heap:\n            cost, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                N -= 1\n                total_cost += cost\n                if N == 0:\n                    break\n        return total_cost\n\n    \n    \n    \n    \n    \n    \n    \n    \nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        dist = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        heap = []\n        for i in range(N-1):\n            for j in range(i+1, N):\n                heappush(heap, (dist(points[i], points[j]), i, j))\n        res = 0\n        while heap:\n            d, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                res += d\n                N -= 1\n                if N == 0:\n                    break\n        return res\n            \n\n\n    \n    \nclass Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: abs(p[0]) + abs(p[1]))\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            p1, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p2, dist) in enumerate(points):\n                newdist = distance(p1, p2)\n                if newdist < dist:\n                    points[i][1] = newdist\n        return total_cost        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def calculate_distance(x1, y1, x2, y2):\n            return abs(x1 - x2) + abs(y1 - y2)\n\n        n = len(points)\n        visited = set()\n        res = 0\n        m = 0\n        dp = [sys.maxsize for _ in range(n)]\n\n        for i in range(n - 1):\n            x, y = points[m]\n            visited.add(m)\n            for j in range(n):\n                if j in visited:\n                    continue\n\n                x1, y1 = points[j]\n                dp[j] = min(dp[j], calculate_distance(x, y, x1, y1))\n\n            v, m = min((j, i) for i, j in enumerate(dp))\n            dp[m] = sys.maxsize\n            res += v\n\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        cnt = len(points)\n        dist = []\n        connected = [False] * cnt\n        \n        for i in range(cnt):\n            for j in range(i):\n                p1, p2 = points[i], points[j]\n                tmp_d = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n                dist.append([(i, j), tmp_d])\n        \n        res = 0\n        dist = sorted(dist, key = lambda d: d[1])\n        \n        parent = [i for i in range(cnt)]\n        \n        def findp(x):\n            if parent[x] != x: return findp(parent[x])\n            return x\n        \n        def combine(x, y):\n            px, py = findp(x), findp(y)\n            parent[px] = py\n            \n        for d in dist:\n            if findp(d[0][0]) != findp(d[0][1]):\n                combine(d[0][0], d[0][1])\n                res += d[1]\n        \n        return res\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        pointSet = set()\n        CostHeap = []\n        \n        for i in range(len(points)):\n            pointSet.add(i)\n            for j in range(i+1, len(points)):\n                heapq.heappush(CostHeap, [abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]), i, j])\n        \n        parent = defaultdict(lambda: -1)\n        def find(x):\n            if parent[x] == -1:\n                return x\n            else:\n                parent[x] = find(parent[x])\n                return parent[x]\n            \n        COST = 0\n        #print(CostHeap)\n        while CostHeap:\n            node = heapq.heappop(CostHeap)\n            cost,x,y = node\n            #print(parent)\n            u = find(x)\n            v = find(y)\n            if u != v:\n                parent[u] = v               \n                COST+=cost\n                #if x in pointSet:\n                #    pointSet.remove(x)\n                #if y in pointSet:\n                #    pointSet.remove(y)\n                #if len(pointSet) == 0:\n                #    break\n        return COST\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        total = 0\n        mst = defaultdict(set)\n        graph = collections.defaultdict(dict)\n        visited = [False for i in range(len(points))]\n        visited[0] = True\n        for i in range(len(points)):\n            for j in range(len(points)):\n                if j == i:\n                    continue\n                graph[i][j] = (self.getDist(points[i][0], points[i][1], points[j][0], points[j][1]))\n        edges = [(cost, 0, to) for to, cost in graph[0].items()]\n        heapq.heapify(edges)\n        while edges:\n            cost, frm, to = heapq.heappop(edges)\n            if not visited[to]:\n                visited[to] = True\n                total += cost\n                for to_next, cost_next in graph[to].items():\n                    if not visited[to_next]:\n                        heapq.heappush(edges, (cost_next, to, to_next))\n        return total\n                \n                \n    def getDist(self, x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)", "from collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        return kruskal(points)\n\n\nclass UnionFind:\n    \n    def __init__(self, N):\n        self.par = [i for i in range(N)]\n        self.rank = [0]*N\n    \n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    \n    def union(self, x, y):\n        \n        xpar = self.find(x)\n        ypar = self.find(y)\n        \n        if self.rank[xpar] > self.rank[ypar]:\n            self.par[ypar] = xpar\n        elif  self.rank[xpar] < self.rank[ypar]:\n            self.par[xpar] = ypar\n        elif self.rank[xpar] == self.rank[ypar]:\n            self.par[xpar] = ypar\n            self.rank[xpar] += 1\n            \n    \n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n            \n    \n\ndef kruskal(points):\n    \n    n     = len(points)\n    V     = UnionFind(n)\n    mst   = set()\n    edges = set()\n    \n    for i, (x1, y1) in enumerate(points):\n        for j, (x2, y2) in enumerate(points):\n            edges.add((i,j,abs(x2-x1)+abs(y2-y1)))\n\n    edges = sorted(edges, key=lambda e: e[2])\n    \n    cost = 0\n    for e in edges:\n        \n        i, j, w = e\n        if V.connected(i,j):\n            continue\n        \n        V.union(i,j)\n        mst.add(i)\n        mst.add(j)\n        cost += w\n    return cost    \n", "from heapq import heapify, heappop, heappush\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                l = dist(points[i], points[j])\n                edges.append((i, j, l))\n        \n        \n        def prim(nodes, edges):\n            conn = defaultdict( list )\n            for n1,n2,c in edges:\n                conn[n1].append((c, n1, n2))\n                conn[n2].append((c, n2, n1))\n\n            mst = []\n            used = set([nodes[ 0 ]])\n            usable_edges = conn[nodes[0]][:]\n            heapify(usable_edges)\n            ans = 0\n            while usable_edges:\n                cost, n1, n2 = heappop(usable_edges)\n                if n2 not in used:\n                    used.add(n2)\n                    mst.append((n1, n2, cost))\n                    ans += cost\n                    for e in conn[n2]:\n                        if e[2] not in used:\n                            heappush(usable_edges, e)\n            return ans\n        \n        nodes = list(range(n))\n        return prim(nodes, edges)\n", "class UnionFindGraph(dict):\n    def union(self, p: Hashable, q: Hashable):\n        rootOfP = self.root(p)\n        rootOfQ = self.root(q)\n        self[rootOfP] = rootOfQ\n\n    def isConnected(self, p: Hashable, q: Hashable) -> bool:\n        return self.root(p) == self.root(q)\n\n    def root(self, r: Hashable) -> Hashable:\n\n        while r != self[r]:\n            self[r] = self[self[r]]\n            r = self[r]\n\n        return r\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = UnionFindGraph()\n        edges = []\n\n        for i, v in enumerate(points):\n\n            for j, w in enumerate(points[i + 1: ], i + 1):\n                if i != j:\n                    edges.append(((tuple(v), tuple(w)), self.distance(v, w)))\n\n        edges.sort(key=lambda v: v[1])\n        res = 0\n\n        for (a, b), distance in edges:\n            if a not in graph:\n                graph[a] = a\n            if b not in graph:\n                graph[b] = b\n\n            if not graph.isConnected(a, b):\n                res += distance\n                graph.union(a, b)\n\n        return res\n\n    def distance(self, a: Tuple[int, int], b: Tuple[int, int]) -> int:\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def buildmst(graph, starting_vertex):\n            mst = defaultdict(set)\n            visited = set([starting_vertex])\n            edges = [\n                (cost, starting_vertex, to)\n                for to, cost in list(graph[starting_vertex].items())\n            ]\n            # print(edges)\n            heapq.heapify(edges)\n\n            while edges:\n                cost, frm, to = heapq.heappop(edges)\n                if to not in visited:\n                    visited.add(to)\n                    mst[frm].add(to)\n                    for to_next, cost in list(graph[to].items()):\n                        if to_next not in visited:\n                            heapq.heappush(edges, (cost, to, to_next))\n\n            return mst\n        \n        graph = defaultdict(dict)\n        \n        for x in points:\n            t = (x[0], x[1])\n            for y in points:\n                if x != y:\n                    graph[t][(y[0], y[1])] = abs(x[0] - y[0]) + abs(x[1] - y[1])\n                    \n        mst = dict(buildmst(graph, (points[0][0], points[0][1])))\n        ans = 0\n        # print(mst)\n        # for k, v in mst.items():\n        #     print(k, v)\n        \n        for k, v in list(mst.items()):\n            for p in v:\n                ans += abs(k[0] - p[0]) + abs(k[1] - p[1])\n                \n        return ans\n                    \n                    \n                    \n                    \n                    \n", "parent = 0\ndef find(i):\n    nonlocal parent\n    l1 = []\n    while parent[i] != i:\n        l1.append(i)\n        i = parent[i]\n    j = i\n    for i in l1:\n        parent[i] = j\n    return j\n    \n    \n    \ndef givedistance(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\nclass Solution:\n    def minCostConnectPoints(self, l: List[List[int]]) -> int:\n        nonlocal parent\n        \n        visited = {}\n        \n        l1 = []\n        n = len(l)\n        for i in range(n):\n            for j in range(i + 1, n):\n                l1.append([givedistance(l[i], l[j]), tuple(l[i]), tuple(l[j])])\n                \n        l1.sort()\n        l1.reverse()\n\n        ans = 0\n\n        if n == 1:return 0\n        \n        d = {}\n        ind = 0\n        for i in l:\n            d[tuple(i)] = ind\n            ind += 1\n        \n        for i in range(len(l1)):\n            l1[i][1] = d[l1[i][1]]\n            l1[i][2] = d[l1[i][2]]\n        parent = {}\n        for i in l1:\n            parent[i[1]] = i[1]\n            parent[i[2]] = i[2]\n        \n        taken = 0\n        while taken != n - 1:\n            curr, i, j = l1.pop()\n            \n            p1 = find(i)\n            p2 = find(j)\n            \n            if p1 != p2:\n                parent[p1] = parent[p2]\n                ans += curr\n                taken += 1\n        return ans\n            \n        \n        \n        \n        \n        \n        \n", "from collections import defaultdict\n\nclass UnionFind:\n\\tdef __init__(self):\n\\t\\tself.parentsMap = {}\\t# tracks the parents of nodes\n\\t\\tself.rootLen = defaultdict(lambda:1)\\t# tracks no. of nodes in it\n\\t\n\\tdef find(self, node: object)-> object:\n\\t\\t\\\"returns the root node to the given (arg) node\\\"\n\\t\\t# 1. creates parent-node of node if node not in parentsMap\n\\t\\t# 2. loops through the parents of given node till the root \n\\t\\t# (the parent of given node is itself) not found and updates \n\\t\\t# the parent of the nodes and returns the root of node.\n\\t\\tif node not in self.parentsMap:\\tself.parentsMap[node]=node\n\\t\\twhile node!=self.parentsMap[node]:\n\\t\\t\\ttemp = self.parentsMap[node]\n\\t\\t\\tself.parentsMap[node] = self.parentsMap[temp]\n\\t\\t\\tnode=temp\n\\t\\treturn self.parentsMap[node]\n\n\\tdef union(self, node1: object, node2: object)-> None:\n\\t\\t# finds the roots of the given nodes and points a lower len root \n\\t\\t# to other root\n\\t\\tparent1 = self.find(node1)\n\\t\\tparent2 = self.find(node2)\n\\t\\tif parent1!=parent2:\n\\t\\t\\tif self.rootLen[parent1]<self.rootLen[parent2]:\n\\t\\t\\t\\tself.parentsMap[parent1]=parent2\n\\t\\t\\t\\tself.rootLen[parent2]+=self.rootLen[parent1]\n\\t\\t\\telse:\n\\t\\t\\t\\tself.parentsMap[parent2]=parent1\n\\t\\t\\t\\tself.rootLen[parent1]+=self.rootLen[parent2]\n\n\\tdef isConnected(self, node1: object, node2: object)-> bool:\n\\t\\t# checks if roots of the given nodes are same and return true if \n\\t\\t# they are else false\n\\t\\treturn self.find(node1)==self.find(node2)\n\n        \nclass Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        dist = lambda a, b: sum(abs(i-j) for i,j in zip(a,b))\n        n = len(A)\n        # m = sum(i for i,j in A)/n, sum(j for i,j in A)/n\n        u = UnionFind()\n        res = 0\n        d = []\n        # A.sort(key = lambda x: dist(m, x))\n        # print(A)\n        \n        for i in range(1, len(A)):\n            for j in range(i):\n                e1 = tuple(A[i])\n                e2 = tuple(A[j])\n                d.append((dist(e1, e2), e1, e2))\n                # e1 = tuple(A[i])\n                # print(e1, sorted(A, key = lambda x: dist(e1, x), reverse=1))\n                # for e2 in map(tuple, sorted(A, key = lambda x: dist(e1, x), reverse=1)):\n                    # if e1==e2:\n                    #     continue\n                    # if u.isConnected(e1, e2):\n                    #     continue\n                    # dis = dist(e1, e2)\n                    # u.union(e1, e2)\n                    # res+=dis\n        \n        for w, e1, e2 in sorted(d):\n            # e2, w = e\n            # print(e1, e2, w)\n            if u.isConnected(e1, e2):\n                continue\n            u.union(e1, e2)\n            res+=w\n        \n        return res\n        \n        \n        \n        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(p, u):\n            if p[u] == u:\n                return u\n            root_u = find(p, p[u])\n            p[u] = root_u\n            return root_u\n        \n        def union(p, rank, root_u, root_v):\n            if rank[root_u] < rank[root_v]:\n                p[root_u] = root_v\n            elif rank[root_v] < rank[root_u]:\n                p[root_v] = root_u\n            else:\n                rank[root_u] += 1\n                p[root_v] = root_u\n            \n        \n        h = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                cost = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(h, [cost, i, j])\n        \n        p = list(range(len(points)))\n        rank = [1] * len(points)\n        total_cost = 0\n        while len(h):\n            cost, u, v = heapq.heappop(h)\n            root_u, root_v = find(p, u), find(p, v)\n            if root_u == root_v:\n                continue\n            union(p, rank, root_u, root_v)\n            total_cost += cost\n    \n        return total_cost\n            \n            \n        \n                \n                    \n", "from collections import defaultdict\nimport heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        s, heap, c, ans = set(), list(), 0, 0\n        parent = [-1]*len(points)\n        \n        if len(points) == 1 or not points:\n            return 0\n        \n        def give_dist(x, y):\n            return abs(x[0] - y[0]) + abs(x[1] - y[1])\n        \n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                heap.append([give_dist(points[i], points[j]), i, j])\n        \n        heapq.heapify(heap)\n        \n        def find(x):\n            if parent[x] == -1:\n                return x\n            parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            parent[px] = py\n        \n        while c < len(points) - 1:\n            d, x, y = heapq.heappop(heap)\n            if find(x) != find(y):\n                ans += d\n                union(x, y)\n                c += 1\n        return ans\n        \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        sets, edges = [], []\n        res = []\n\n        for i in range(len(points)):\n            sets.append([i])\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                val = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((i,j,val))\n        def custom_sort(t):\n            return t[2]\n        edges.sort(key=custom_sort)\n        #print(edges); print(sets)\n        \n        for (u,v,cost) in edges:\n            for i in range(len(sets)):\n                if u in sets[i]:\n                    setu = i\n                    break\n            for i in range(len(sets)):\n                if v in sets[i]:\n                    setv = i\n                    break\n            if setu != setv:\n                w1 = sets[setu]\n                w2 = sets[setv]\n                res.append((u,v,cost))\n                [w1.append(x) for x in w2 if x not in w1]\n                sets = sets[:setv]+sets[setv+1:]\n        \n        sum = 0\n        for e in res:\n            sum += e[2]\n        return sum\n        \\\"\\\"\\\"\n        edges = [[None] * len(points) for _ in range(len(points))]\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                val = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges[i][j] = val\n                edges[j][i] = val\n        \n        cost = 0\n        min_heap = [(0, 0)]\n        visited = set()\n        while len(min_heap):\n            min_node = heapq.heappop(min_heap)\n            if min_node[1] in visited: continue\n            vertex = min_node[1]\n            weight = min_node[0]\n            cost += weight\n            visited.add(vertex)\n            #print('visted vertex is ', vertex, 'cost is', weight, 'total', cost, 'cur_min_heap', min_heap)\n            for neigh in range(len(edges[vertex])):\n                if neigh not in visited:\n                    heapq.heappush(min_heap, (edges[vertex][neigh], neigh))\n        \n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        uf = {}\n        \n        def find(x):\n            uf.setdefault(x, x)\n            if uf[x] != x:\n                uf[x] = find(uf[x])\n            return uf[x]\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            if px != py:\n                uf[px] = py\n                \n        @lru_cache(None)\n        def dist(i, j):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            return abs(x1 - x2) + abs(y1 - y2)\n                \n        hp = []\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                heapq.heappush(hp, (dist(i, j), i, j))\n        \n        while hp:\n            d, i, j = heapq.heappop(hp)\n            if find(i) != find(j):\n                ans += d\n                union(i, j)\n                \n        return ans\n                \n        \n\n        \n#         n = len(points)\n#         U = {0}\n#         V = set(range(n)) - U\n#         ans = 0\n#         while V:\n#             cand = set()\n#             mind = float(\\\"inf\\\")\n#             for u in U:\n#                 for v in V:\n#                     if dist(u, v) < mind:\n#                         mind = dist(u, v)\n#                         tmp = v\n#             ans += mind\n#             U |= {tmp}\n#             V -= {tmp}\n#         return ans\n                        \n", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def manhattanDistance(x1,y1,x2,y2):\n            return abs(x1-x2) + abs(y1-y2)\n        \n        n = len(points)\n        \n        distsMap = {}\n        for i in range(n):\n            for j in range(i+1, n):\n                x1,y1 = points[i]\n                x2,y2 = points[j]\n                distsMap[(i,j)] = manhattanDistance(x1,y1,x2,y2)\n                distsMap[(j,i)] = distsMap[(i,j)]\n        \n        result = 0\n        pq = [(0,0)]\n        seen = set()\n        minDists = {i:float('inf') for i in range(n)}\n        while len(pq) != 0:\n            (dist,i) = heapq.heappop(pq)\n            # print(dist,i)\n            if i in seen:\n                continue\n            seen.add(i)\n            result += dist\n            \n            minDists[i] = 0\n            for j in range(n):\n                if j in seen:\n                    continue\n                minDists[j] = min(minDists[j], distsMap[(i,j)])\n                heapq.heappush(pq, (minDists[j],j) )\n            \n            # for j in range(n):\n            #     if j in seen:\n            #         continue\n            #     # nextDist = min(distsMap[(ip,j)] for ip in seen)\n            #     heapq.heappush(pq, (minDists[j],j) )\n                # for ip in seen:\n                    \n                \n        return result", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edge_heap = []\n        cost_map = {}\n        for i, point1 in enumerate(points):\n            for j, point2 in enumerate(points):\n                if point1 == point2:\n                    continue\n                cost_map[(min(i, j), max(i,j))] = abs(point1[1] - point2[1]) + abs(point1[0] - point2[0])\n        \n        forest = set([0])\n        for i in range(1, len(points)):\n            heapq.heappush(edge_heap, (cost_map[(0, i)], (0, i)))\n        \n        total_cost = 0\n        \n        while len(forest) != len(points):\n            cost, (v1, v2) = heapq.heappop(edge_heap)\n            v1_new = v1 not in forest\n            v2_new = v2 not in forest\n            if v1_new == v2_new:\n                continue\n            # print(f\\\"Adding edge {(points[v1], points[v2])} with cost {cost}\\\")\n            forest.add(v1)\n            forest.add(v2)\n            total_cost += cost\n            \n            v_search = v1 if v1_new else v2\n            for vx in range(len(points)):\n                if vx == v_search or vx in forest:\n                    continue\n                i, j = min(v_search, vx), max(v_search, vx)\n                heapq.heappush(edge_heap, (cost_map[i, j], (i, j)))\n            \n        return total_cost", "from collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        return kruskal(points)\n\n\nclass UnionFind:\n    \n    def __init__(self, N):\n        self.par = [i for i in range(N)]\n        self.rank = [0]*N\n    \n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    \n    def union(self, x, y):\n        \n        xpar = self.find(x)\n        ypar = self.find(y)\n        \n        if self.rank[xpar] > self.rank[ypar]:\n            self.par[ypar] = xpar\n        elif  self.rank[xpar] < self.rank[ypar]:\n            self.par[xpar] = ypar\n        elif self.rank[xpar] == self.rank[ypar]:\n            self.par[xpar] = ypar\n            self.rank[xpar] += 1\n            \n    \n    def connected(self, x, y):\n        return self.find(x) == self.find(y)\n            \n\ndef kruskal(points):\n    \n    n     = len(points)\n    V     = UnionFind(n)\n    #mst   = set()\n    edges = set()\n    \n    for i, (x1, y1) in enumerate(points):\n        for j, (x2, y2) in enumerate(points):\n            edges.add((i,j,abs(x2-x1)+abs(y2-y1)))\n\n    edges = sorted(edges, key=lambda e: e[2])\n    \n    cost = 0\n    for e in edges:\n        \n        i, j, w = e\n        if V.connected(i,j):\n            continue\n        \n        V.union(i,j)\n        #mst.add(i)\n        #mst.add(j)\n        cost += w\n    return cost    \n", "class DSU:\n    def __init__(self, n):\n        self.p = list(range(n))\n    \n    def find(self, i):\n        if self.p[i] == i:\n            return i\n        self.p[i] = self.find(self.p[i])\n        return self.p[i]\n    \n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        self.p[x] = y\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        \n        def w(u, v):\n            return sum(abs(points[u][i] - points[v][i]) for i in range(2))\n        \n        edges = [(u, v, w(u, v)) for u in range(n) for v in range(n)]\n        edges.sort(key = lambda x: x[-1])\n        ans = 0\n        dsu = DSU(n)\n        return sum(cost for [u, v, cost] in edges if dsu.unite(u, v))", "from itertools import combinations\nfrom collections import defaultdict\nimport heapq\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        points = [(i, *point) for i, point in enumerate(points)]\n\n        edges = defaultdict(list)\n        heap = []\n        for (i, xi, yi), (j, xj, yj) in combinations(points, 2):\n            dest = abs(xi - xj) + abs(yi - yj)\n            # print(i, j, dest)\n            edges[i].append((j, dest))\n            edges[j].append((i, dest))\n            heapq.heappush(heap, (dest, i, j))\n\n        # print(heap)\n\n        selected = set()\n        answer = 0\n        pending = []\n        while heap:\n            dest, i, j = heapq.heappop(heap)\n            # print(i, j, dest)\n            if not selected or ((i in selected) ^ (j in selected)):\n                # print(selected)\n                selected.add(i)\n                selected.add(j)\n                answer += dest\n                while pending:\n                    heapq.heappush(heap, pending.pop())\n            elif (i not in selected) and (j not in selected):\n                pending.append((dest, i, j))\n\n        return answer\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        n = len(points)\n\n        q = [(0, 0)]\n        visited = set()\n        G = defaultdict(list)\n        for i in range(n):\n            for j in range(n):\n                if i!=j:\n                    xi,yi = points[i]\n                    xj,yj = points[j]\n                    cost = abs(xi-xj) + abs(yi-yj)\n                    G[i].append( (cost, j) )\n                    G[j].append( (cost, i) )\n\n        total = 0\n        while q and len(visited) < n:\n            cost1, v1 = heappop(q)\n            if v1 not in visited:\n                visited.add(v1)\n                total += cost1\n                for cost2, v2 in G[v1]:\n                    heappush(q, (cost2, v2))\n\n        return total\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        uf = {}\n        \n        def find(x):\n            uf.setdefault(x, x)\n            if uf[x] != x:\n                uf[x] = find(uf[x])\n            return uf[x]\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            if px != py:\n                uf[px] = py\n                \n        @lru_cache(None)\n        def dist(i, j):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            return abs(x1 - x2) + abs(y1 - y2)\n        \n        n = len(points)\n        hp = [(dist(i, j), i, j) for i in range(n) for j in range(i + 1, n)]\n        heapq.heapify(hp)\n        ans = 0\n        \n        while hp:\n            d, i, j = heapq.heappop(hp)\n            if find(i) != find(j):\n                ans += d\n                union(i, j)\n                \n        return ans\n                \n        \n\n        \n#         n = len(points)\n#         U = {0}\n#         V = set(range(n)) - U\n#         ans = 0\n#         while V:\n#             cand = set()\n#             mind = float(\\\"inf\\\")\n#             for u in U:\n#                 for v in V:\n#                     if dist(u, v) < mind:\n#                         mind = dist(u, v)\n#                         tmp = v\n#             ans += mind\n#             U |= {tmp}\n#             V -= {tmp}\n#         return ans\n                        \n", "from queue import PriorityQueue\nfrom collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        parent = defaultdict(int)\n        weight = defaultdict(int)\n        \n        def make_set(x: int):\n            if x in parent:\n                return\n            parent[x] = x\n            weight[x] = 1\n\n        def find(x: int) -> int:\n            if parent[x] == x:\n                return parent[x]\n            parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union_set(x: int, y: int):\n            px, py = find(x), find(y)\n            if px == py:\n                return\n            if weight[px] > weight[py]:\n                parent[py] = px\n                weight[px] += weight[py]\n            else:\n                parent[px] = py\n                weight[py] += weight[px]\n        \n        n = len(points)\n        ls = [] # list of(edge_weight, x, y)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                ls.append([abs(x1 - x2) + abs(y1 - y2), i, j])\n        ls.sort()\n        cost = 0\n        for c, x, y in ls:\n            make_set(x)\n            make_set(y)\n            if find(x) == find(y):\n                continue\n            union_set(x, y)\n            cost += c\n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        res = 0\n        dis = [float('inf')] * len(points)\n        visited = set()\n        cur = 0\n        for i in range(len(points) - 1):\n            visited.add(cur)\n            for j in range(len(points)):\n                if j not in visited:\n                    dis[j] = min(dis[j], dist(points[cur], points[j]))\n            d, cur = min((d, j) for j, d in enumerate(dis))\n            dis[cur] = float('inf')\n            res += d\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        distance=lambda p1,p2 : abs(p1[0]-p2[0])+ abs(p1[1]-p2[1])\n        from collections import defaultdict\n        n=len(points)\n        c=defaultdict(list)\n        for i in range(n):\n            for j in range(i+1,n):\n                d=distance(points[i],points[j])\n                c[i].append((d,j))\n                c[j].append((d,i))\n        visited=[False]*n\n        answer=0\n        cnt=0\n        import heapq\n        heap=c[0]\n        visited[0]=True\n        heapq.heapify(heap)\n        while heap:\n            d,j=heapq.heappop(heap)\n            if visited[j]==False:\n                visited[j]=True\n                answer=answer+d\n                cnt+=1\n                for record in c[j]:\n                    heapq.heappush(heap,record)\n\n\n        return answer\n\n\n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        res=0\n        n=len(points)\n        g=collections.defaultdict(list)\n        tmp=[]\n        vst=set()\n        for i in range(n):\n            for j in range(n):\n                if i!=j and (i,j) not in vst:\n                    vst.add((i,j))\n                    vst.add((j,i))\n                    dist=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                    tmp.append([i,j,dist])\n        \n        parents=[i for i in range(n)]\n        ranks=[1]*n\n        \n        def find(u):\n            while u!=parents[u]:\n                parents[u]=parents[parents[u]]\n                u=parents[u]\n            return u\n  \n        def union(u,v):\n            root_u,root_v=find(u),find(v)\n            if root_u==root_v:\n                return False\n            if ranks[root_v] > ranks[root_u]:\n                root_u, root_v = root_v, root_u\n            parents[root_v] = root_u\n            ranks[root_u] += ranks[root_v]\n            return True\n        \n        tmp.sort(key=lambda x:x[2])\n        ans=0\n        for u,v,val in tmp:\n            if union(u,v):\n                ans+=val\n        groups=len({find(x) for x in parents})\n        return ans if groups==1 else -1\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # Minimum spanning tree\n        # Prim's algorithm\n        \n        def dist(p1, p2):\n            return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n\n        ans = 0\n        d = collections.defaultdict(list)\n        \n        for i, p1 in enumerate(points):\n            for j, p2 in enumerate(points):\n                # don't use list slicing because the index j will not be the index for the full points list\n                if i != j:\n                    cost = dist(p1, p2)\n                    d[i].append((cost, j))\n                    d[j].append((cost, i)) \n                    \n        heap = d[0]\n        # heap is a list of costs in ascending order for a given point p1\n        heapq.heapify(heap)\n        n = len(points)\n        visited = [0] * n\n        visited[0] = 1\n        count = 1\n        \n        while heap:\n            cost, j = heapq.heappop(heap)\n            # ensure cycles are not formed\n            if not visited[j]:\n                # not yet visit p2 where cost is minimum, can connect p1 and p2\n                visited[j] = 1\n                count += 1\n                ans += cost\n                for item in d[j]:\n                    # since p1 and p2 are now connected, focus on p2\n                    # push items in dict at p2 to heap\n                    heapq.heappush(heap, item)\n                    \n            if count >= n:\n                # already connected all points\n                break\n                \n        return ans\n        \n        # # solution\n        # manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        # n, c = len(points), collections.defaultdict(list)\n        # for i in range(n):\n        #     print(\\\"i: \\\", i)\n        #     for j in range(i+1, n):\n        #         print(\\\"j:\\\", j)\n        #         d = manhattan(points[i], points[j])\n        #         c[i].append((d, j))\n        #         c[j].append((d, i))\n        # cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        # visited[0] = 1\n        # heapq.heapify(heap)\n        # while heap:\n        #     d, j = heapq.heappop(heap)\n        #     if not visited[j]:\n        #         visited[j], cnt, ans = 1, cnt+1, ans+d\n        #         for record in c[j]: heapq.heappush(heap, record)\n        #     if cnt >= n: break        \n        # return ans\n", "from heapq import heappop, heappush, heapify\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n =len(points)\n        if n<=1:\n            return 0\n        ds = UFind(n)\n        hp = []\n        for i in range(n-1):\n            for j in range(i+1,n):\n                mhd = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                hp.append((mhd, i, j))\n        heapq.heapify(hp)\n        ans = 0\n        while ds.count>1:\n            mhd, i, j = heapq.heappop(hp)\n            if ds.union(i,j):\n                ans+=mhd\n        return ans\nclass UFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [1]*n\n        self.count = n\n    def find(self,x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        x_par, y_par = self.find(x), self.find(y)\n        if x_par == y_par:\n            return False\n        else:\n            self.count-=1\n            if self.rank[x_par]<self.rank[y_par]:\n                self.parent[x_par] = y_par\n            elif self.rank[x_par]>self.rank[y_par]:\n                self.parent[y_par] = x_par\n            else:\n                self.parent[x_par] = y_par\n                self.rank[y_par]+=1  \n            return True", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n            \n                dist = abs(x1-x2) + abs(y1-y2)\n                heap.append((dist, i, j))\n        \n        heapify(heap)\n        uf = UnionFind(len(points))\n        res = 0\n        num_edges = 0\n        \n        while heap:\n            dist, x, y = heappop(heap)\n            if uf.union(x, y):\n                res += dist\n                num_edges += 1\n            if num_edges == len(points)-1:\n                break\n                \n        return res\n    \nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0]*n\n        \n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False\n        \n        if self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        \n        else:\n            self.parent[root_x] = root_y\n            if self.rank[root_x] == self.rank[root_y]:\n                self.rank[root_y] += 1\n        \n        return True\n    \n    def find(self, x):\n        while x != self.parent[x]:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n                \n        \n        \n        \n        \n", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(p1, p2):\n            return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n        h = [(0, 0, 0)]\n        seen = set()\n        res = 0\n        n = len(points)\n        \n        while len(seen) < n:\n            d, u, v = heapq.heappop(h)\n            if v in seen: continue\n            seen.add(v)\n            res += d\n            for w in range(n):\n                if w in seen or w == v: continue\n                heapq.heappush(h, (dist(points[v], points[w]), v, w))                \n        \n        return res", "import heapq\n\ndef dist(i, j, points):\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n\nclass UnionFind:\n    def __init__(self, n):\n        self.root = [i for i in range(n)]\n        self.cnt = n\n        \n    def find(self, x):\n        if self.root[x] == x:\n            return x\n        p = self.root[x]\n        self.root[x] = self.find(p)\n        return self.root[x]\n    \n    def union(self, i, j):\n        ri, rj = self.find(i), self.find(j)\n        self.root[ri] = rj\n        self.cnt -= 1\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        n = len(points)\n        for i in range(n):\n            for j in range(i+1, n):\n                edges.append((dist(i, j, points), i, j))\n        \n        heapq.heapify(edges)\n        res = 0\n        uf = UnionFind(n)\n        while uf.cnt > 1:\n            e = None\n            while True:\n                e = heapq.heappop(edges)\n                if uf.find(e[1]) != uf.find(e[2]):\n                    break\n            res += e[0]\n            uf.union(e[1], e[2])\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            dis[curr] = math.inf\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            res += delta\n            \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def find(x):\n            if parent[x] != x:\n                return find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            xroot, yroot = find(x), find(y)\n            if xroot == yroot: return\n            parent[xroot] = yroot\n            \n        l = len(points)\n        parent = [i for i in range(l)]\n        dis = []\n        for i in range(l):\n            for j in range(i+1, l):\n                dis.append(\n                    (abs(points[j][1] - points[i][1]) + abs(points[j][0] - points[i][0]), i, j)\n                )\n    \n        \n        heapq.heapify(dis)\n        # l-1 break\n        count = 0\n        ans = 0\n        while dis:\n            temp, node1, node2 = heapq.heappop(dis)\n            if find(node1) != find(node2):\n                union(node1, node2)\n                ans += temp\n                count += 1\n            if count == l-1:\n                break\n        return ans\n", "from collections import defaultdict\nimport heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap, c, ans = list(), 0, 0\n        parent = [-1]*len(points)\n        if len(points) == 1 or not points:\n            return 0\n        def give_dist(x, y):\n            return abs(x[0] - y[0]) + abs(x[1] - y[1])\n        \n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                heap.append([give_dist(points[i], points[j]), i, j])\n        \n        heapq.heapify(heap)\n        \n        def find(x):\n            if parent[x] == -1:\n                return x\n            parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            parent[px] = py\n        \n        while c < len(points) - 1:\n            d, x, y = heapq.heappop(heap)\n            if find(x) != find(y):\n                ans += d\n                union(x, y)\n                c += 1\n        return ans\n        \n                \n", "class Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: p[0] + p[1])\n        points = [[p, distance(p, points[0])] for i, p in enumerate(points)]\n        total_cost = 0\n        while points:\n            minI, minD = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < minD:\n                    minI, minD = i, dist\n            p1, cost = points.pop(minI)\n            total_cost += cost\n            for i, (p2, _) in enumerate(points):\n                points[i][1] = min(points[i][1], distance(p1, p2))\n        return total_cost\n    \nclass Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: p[0] + p[1])   # points.sort(key = lambda p: abs(p[0]) + abs(p[1]))\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            p1, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p2, dist) in enumerate(points):\n                #points[i][1] = min(points[i][1], distance(p1, p2))\n                newdist = distance(p1, p2)\n                if newdist < dist:\n                    points[i][1] = newdist\n        return total_cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = i = connected = 0\n        min_d = [10 ** 7] * n\n        while connected < n - 1:\n            min_d[i] = float('inf')\n            min_j = i\n            for j in range(n):\n                if min_d[j] != float('inf'):\n                    min_d[j] = min(min_d[j], abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]))\n                    min_j = j if min_d[j] < min_d[min_j] else min_j\n            ans += min_d[min_j]\n            i = min_j\n            connected += 1\n            \n        return ans", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(p1, p2):\n            return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n        def find(i):\n            if parent[i] < 0: return i\n            parent[i] = find(parent[i])\n            return parent[i]\n            \n        res = 0\n        n = len(points)\n        parent = [-1]*n\n        rank = [0]*n\n        h = []\n        \n        for u in range(n):\n            for v in range(u+1, n):\n                h.append((dist(points[u], points[v]), u, v))\n                \n        heapq.heapify(h)\n        \n        while h:\n            d, u, v = heapq.heappop(h)\n            u, v = find(u), find(v)\n            if u != v:\n                res += d\n                if rank[u] > rank[v]:\n                    parent[u] += parent[v]\n                    parent[v] = u\n                else:\n                    parent[v] += parent[u]\n                    parent[u] = v\n                    if rank[u] == rank[v]: rank[v] += 1\n                \n                if parent[u] == -n or parent[v] == -n: break\n                    \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        n = len(points)\n        seen = set()\n        res = 0\n        pq = [(0, 0, 0)]\n        while len(seen) < n:\n            w, u, v = heapq.heappop(pq)\n            if u in seen and v in seen:\n                continue\n            res += w\n            seen.add(u)\n            seen.add(v)\n            for i in range(n):\n                if i != v and i not in seen:\n                    heapq.heappush(pq, (manhattan(points[v], points[i]), v, i))\n        return res", "def getDistance(i, j, points):\n    x1, y1, x2, y2 = points[i][0], points[i][1], points[j][0], points[j][1]\n    return abs(y1 - y2) + abs(x1 - x2)\n    \n\n\nclass Solution:\n    \n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        \n        \n        \n        res = 0\n        nextPoint = 0\n        vis = set([0])\n        count = 1\n        disMap = {}\n        \n        while count < n:\n            minPoint, minLength = 0, sys.maxsize\n            for i in range(n):\n                \n                if i in vis:\n                    continue\n                \n                l = getDistance(nextPoint, i, points)\n                \n                if i not in disMap or l < disMap[i]:\n                    disMap[i] = l\n                 \n                if disMap[i] < minLength:\n                    minLength = disMap[i]\n                    minPoint = i\n            \n            \n            \n            res += minLength\n            vis.add(minPoint)\n            count += 1\n            nextPoint = minPoint\n            \n            \n            \n                \n        \n        return res\n            \n                \n                \n                \n            \n            \n", "from collections import defaultdict\nimport heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        s, heap, c, ans = set(), list(), 0, 0\n        parent = [-1]*len(points)\n        \n        if len(points) == 1 or not points:\n            return 0\n        \n        def give_dist(x, y):\n            return abs(x[0] - y[0]) + abs(x[1] - y[1])\n        \n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                heap.append([give_dist(points[i], points[j]), i, j])\n        \n        heapq.heapify(heap)\n        \n        def find(x):\n            while parent[x] != -1:\n                x = parent[x]\n            return x\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            parent[px] = py\n        \n        while c < len(points) - 1:\n            d, x, y = heapq.heappop(heap)\n            if find(x) != find(y):\n                ans += d\n                union(x, y)\n                c += 1\n        return ans\n        \n                \n", "\\\"\\\"\\\"\nThis is a minimum spanning tree problem, which can be solved by kruskal's algo or Prim's algo.\nWe need to pre-compute all the possible edges' weights\n\\\"\\\"\\\"\nimport heapq\nfrom typing import Tuple\nclass Solution:\n    def __init__(self):\n      self.roots = {}\n      self.ranks = {}\n      \n    def find(self, point: Tuple[int, int]) -> Tuple[int, int]:\n      self.roots.setdefault(point, point)\n      self.ranks.setdefault(point, 1)\n      if point != self.roots[point]:\n        self.roots[point] = self.find(self.roots[point])\n      return self.roots[point]\n    \n    def union(self, point1: Tuple[int, int], point2: Tuple[int, int], root1: Tuple[int, int], root2: Tuple[int, int]):\n      if self.ranks[root1] > self.ranks[root2]:\n        self.roots[root2] = root1\n      elif self.ranks[root1] < self.ranks[root2]:\n        self.roots[root1] = root2\n      else:\n        self.roots[root1] = root2\n        self.ranks[root2] += 1\n      \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n      \\\"\\\"\\\"\n      Kruskal's algo: always select the lightest edge, and use a union find to detect cycles. If there are cycles ignore that edge.\n      Time:\n      For minimum spanning tree, V vertices have E=V-1 edges.\n        * Compute all edge weights and sort: E^2 + ElogE\n        * union find: amortized O(1), need to do this for all edges, so O(V). (Yes union-find with path compession and rank by union, has amortized time O(1))\n        Over all E^2 + ElogE + V\n      \\\"\\\"\\\"\n      min_cost = 0\n      edge_count = 0\n      all_weights = []\n      for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n          xi, yi, xj, yj = (*points[i], *points[j])\n          dist = abs(xi - xj) + abs(yi - yj)\n          heapq.heappush(all_weights, (dist, xi, yi, xj, yj))\n      \n      # print(\\\"all_weights: \\\", all_weights)\n      \n      while len(all_weights) > 0:\n        weight, xi, yi, xj, yj = heapq.heappop(all_weights)\n        rooti, rootj = self.find((xi, yi)), self.find((xj, yj))\n        if rooti != rootj:\n          self.union((xi, yi), (xj, yj), rooti, rootj)\n          # print(\\\"selected: \\\", weight, xi, yi, xj, yj)\n          min_cost += weight\n          edge_count += 1\n          \n          if edge_count == len(points) - 1: break\n      \n      return min_cost", "class Solution:\n    def minCostConnectPoints(self, points):\n        helper = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        points, res = [[p, helper(p, points[0])] for p in points], 0\n        while points:\n            minI = min(list(range(len(points))), key = lambda i: points[i][1])\n            p1, cost = points.pop(minI)\n            res += cost\n            for i, (p2, _) in enumerate(points):\n                points[i][1] = min(points[i][1], helper(p1, p2))\n        return res\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \nclass Solution:\n    def minCostConnectPoints(self, points):\n        helper = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        N, total_cost = len(points), 0\n        points = [[p, helper(p, points[0])] for p in points]\n        while points:\n            minI = min(list(range(len(points))), key = lambda i: points[i][1])\n            p2, cost = points.pop(minI)\n            total_cost += cost\n            for i, (p1, cost) in enumerate(points):\n                points[i][1] = min(cost, helper(p1, p2))\n        return total_cost\n                \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        dis = [math.inf] * n\n        visited = [False] * n\n        ans = 0\n        dis[0] = 0\n        for i in range(0, n):\n            d, j = min((d, j) for j, d in enumerate(dis))\n            dis[j] = math.inf\n            visited[j] = True\n            ans += d\n            for k in range(0, n):\n                if j == k or visited[k]:\n                    continue\n                dis[k] = min(dis[k], abs(points[j][0] - points[k][0]) + abs(points[j][1] - points[k][1]))\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def get_dist(p,q):\n            return abs(p[0]-q[0])+abs(p[1]-q[1])\n        \n        n=len(points)\n        seen=set()\n        dist=[math.inf]*n\n        res=0\n        cur=0\n        for i in range(n-1):\n            seen.add(cur)\n            for j in range(n):\n                if j in seen:\n                    continue\n                d=get_dist(points[cur],points[j])\n                dist[j]=min(dist[j],d)\n            \n            delta,cur=min((d,j) for j,d in enumerate(dist))\n            res+=delta\n            dist[cur]=math.inf\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def get_dist(p,q):\n            return abs(p[0]-q[0])+abs(p[1]-q[1])\n        \n        n=len(points)\n        seen=set()\n        dist=[math.inf]*n\n        res=0\n        cur=0\n        for _ in range(n-1):\n            seen.add(cur)\n            for j in range(n):\n                if j in seen:\n                    continue\n                d=get_dist(points[cur],points[j])\n                dist[j]=min(dist[j],d)\n            \n            delta,cur=min((d,j) for j,d in enumerate(dist))\n            res+=delta\n            dist[cur]=math.inf\n        return res", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        total_cost = 0\n        # any initial point can be chosen\n        x1, y1 = points.pop() \n        # then make a heap sorted by distance to that point\n        \n        cost_heap = []\n        for x2, y2 in points:\n            heapq.heappush(cost_heap, [abs(x1-x2) + abs(y1-y2), x2, y2])\n        \n        # pop off the points with the lowest distance\n        # then see if any of the remaining points are closer to that new point than\n        # the previous points had been, and update the heap\n        while cost_heap:\n            cost, x1, y1 = heapq.heappop(cost_heap)\n            total_cost += cost\n            for i, [cost, x2, y2] in enumerate(cost_heap):\n                cost_heap[i][0] = min(cost, abs(x1-x2) + abs(y1-y2))\n            heapq.heapify(cost_heap)\n            \n        return total_cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            dis[curr] = math.inf\n            res += delta\n            \n        return res\n", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1:\n            return 0\n        # mst?\n        np = len(points)\n        rest = set(range(np))\n        cur_val = 0\n        rest.remove(cur_val)\n        \n        def get_costs(rest, node):\n            return [(abs(points[node][0] - points[tmp][0]) + abs(points[node][1] - points[tmp][1]), node, tmp) for tmp in rest if tmp != node]\n        \n        q = get_costs(rest, cur_val)\n        heapq.heapify(q)\n        \n        cost = 0\n        \n        while len(rest) > 0:\n            dist, node1, node2 = heapq.heappop(q)\n            if node2 in rest:\n                cost += dist\n                rest.remove(node2)\n                for rsti in get_costs(rest, node2):\n                    heapq.heappush(q, rsti)\n                    \n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dist = {}\n        n = len(points)\n        queue = []\n        for i in range(n):\n            x = points[i]\n            for j in range(i + 1, n):\n                y = points[j]\n                heapq.heappush(queue, (abs(x[0] - y[0]) + abs(x[1] - y[1]), i, j))\n                \n        parents = list(range(n))\n        rank = [1] * n\n        def find(x):\n            if parents[x] != x:\n                parents[x] = find(parents[x])\n            return parents[x]\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            if px == py:\n                return False\n            if rank[px] < rank[py]:\n                px, py = py, px\n            parents[py] = px\n            rank[px] += rank[px] == rank[py]\n            return True\n                \n        result = 0\n        for _ in range(n - 1):\n            while True:\n                dist, i, j = heapq.heappop(queue)\n                if union(i, j):\n                    result += dist\n                    break\n        return result\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        num_points = len(points)\n        mst = {0}\n        mra = 0\n        hep = []\n        def dist(a,b):\n            return abs(a[0] - b[0]) + abs(a[1]- b[1])\n        \n        def update_heap(added):\n            for i,(x,y) in enumerate(points):\n                if i not in mst:\n                    heapq.heappush(hep, (dist(points[added], points[i]), added, i))\n        \n        sol = 0\n        while len(mst) < num_points:\n            update_heap(mra)\n            \n            while hep:\n                d, x, y = heapq.heappop(hep)\n                \n                if y not in mst:\n                    mst.add(y)\n                    mra = y\n                    sol += d\n                    break\n        \n        return sol\n                \n                \n        \n", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        edges, n, cnt, ans = [], len(p), 1, 0\n\n        def manhattan(x, y):\n            return abs(p[x][0]-p[y][0]) + abs(p[x][1]-p[y][1])\n\n        edges = [(manhattan(i, j), (i, j)) \n                 for i in range(n) for j in range(i+1, n)]\n        heapq.heapify(edges)\n\n        def union(x, y):\n            uf[find(x)] = find(y)\n\n        def find(x):\n            if x != uf[x]:\n                uf[x] = find(uf[x])\n            return uf[x]\n\n        uf = list(range(n))\n        while cnt < n:\n            d, (u, v) = heapq.heappop(edges)\n            if find(u) != find(v):\n                ans += d\n                cnt += 1\n                union(u, v)\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # \u5148\u7b97\u6bcf\u4e00\u5bf9\u70b9\u7684\u8ddd\u79bb\n        # \u6700\u5c0f\u751f\u6210\u6811, union find\n        edges = []\n        n = len(points)\n        if n == 1:\n            return 0\n        for i in range(n - 1):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((i, j, dist))\n        edges.sort(key = lambda x : x[2])\n        parent = [i for i in range(n)]\n        cnt = 0\n        ans = 0\n        for e in edges:\n            x = e[0]\n            y = e[1]\n            px = self.find(x, parent)\n            py = self.find(y, parent)\n            if px != py:\n                parent[px] = py\n                cnt += 1\n                ans += e[2]\n            if cnt == n - 1:\n                break\n        return ans\n        \n    def find(self, x, parent):\n        while parent[x] != x:\n            parent[x] = parent[parent[x]]\n            x = parent[x]\n        return x", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for _ in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            dis[curr] = math.inf\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            res += delta\n            \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        '''\n        Prim's algorithm\n        Start from some initial point, we build a tree. We track connected points in 'seen'.\n        For current point, we add all its edges to a min-heap. Each time, we pickup smallest\n        edge which connects to a point not in 'seen'. Repeat until all points are in 'seen'.\n\n        Time: O(V^2 + E*logE)\n        Space: O(E)\n        '''\n        n = len(points)\n        seen = set()\n        heap = [[0, 0]]\n        cost = 0\n        for _ in range(n):\n            while heap and heap[0][1] in seen:\n                heapq.heappop(heap)\n            dist, i = heapq.heappop(heap)\n            cost += dist\n            seen.add(i)\n            for j in range(n):\n                if j in seen: continue\n                dist2j = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(heap, [dist2j, j])\n\n        return cost", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ans=0\n        visit=set()\n        x0,y0=points[0]\n        N=len(points)\n        unvisit=set([i for i in range(1,N)])\n        dis=N*[float('inf')]\n        cur=0\n        while unvisit:\n            x0,y0=points[cur]\n            for nei in unvisit:\n                x1,y1=points[nei]\n                dis[nei]=min(dis[nei],abs(x1-x0)+abs(y1-y0))\n            cur=min(unvisit,key=lambda x: dis[x])\n            ans+=dis[cur]\n            unvisit.remove(cur)\n        return ans\n        \n        \n        \n        \n        \\\"\\\"\\\"\n        xlist=[]\n        ylist=[]\n        for x,y in points:\n            xlist.append(x)\n            ylist.append(y)\n        def partition(A,l,r):\n            left,right=l,l\n            pivot=A[r-1]\n            for right in range(l,r):\n                if A[right]<=pivot:\n                    A[right],A[left]=A[left],A[right]\n                    left+=1\n            return left\n        def medium(A):\n            random.shuffle(A)\n            N=len(A)\n            left,right=0,N\n            M=(N+1)//2\n            z=-1\n            while z!=M:\n                z=partition(A,left,right)\n                if z==M:\n                    return A[z-1]\n                elif z>M:\n                    right=z-1\n                else:\n                    left=z\n                partition(A,left,right)\n        xm=medium(xlist)\n        ym=medium(ylist)\n        ans=0\n        for x,y in points:\n            ans+=abs(x-xm)\n            ans+=abs(y-ym)\n        return ans\n        \\\"\\\"\\\"       \n            \n                ", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(x, y):\n            dx = abs(x[0] - y[0])\n            dy = abs(x[1] - y[1])\n            return dx+dy\n        \n        n = len(points)\n        if n == 1:\n            return 0\n        if n == 2:\n            return distance(points[0], points[1])\n        \n        # # Method 1: Prim's Alg with Heap\n        # d = {i:[] for i in range(n)}\n        # for i in range(n):\n        #     for j in range(i+1, n):\n        #         dist = distance(points[i], points[j])\n        #         d[i].append((dist, j))\n        #         d[j].append((dist, i))\n        # cost = 0\n        # connected = 1\n        # check = [True] + [False]*(n-1)\n        # heap = d[0]\n        # heapq.heapify(heap)\n        # while connected < n:\n        #     (dist, p) = heapq.heappop(heap)\n        #     if not check[p]:\n        #         cost += dist\n        #         connected += 1\n        #         check[p] = 1\n        #         for pair in d[p]:\n        #             heapq.heappush(heap, pair)\n        # return cost\n        \n        # Method 2: Kruskal's Alg with Disjoint Set\n        \n        \n        \n        # Nethod 3: Greedy\n        cost = 0\n        curr = 0 # select a random point as the starting point\n        dist = [float('inf')] * n\n        explored = set()\n        explored.add(0)\n        while len(explored) < n:\n            x = points[curr]\n            for j, y in enumerate(points):\n                if j in explored: \n                    continue\n                else:\n                    dist[j] = min(dist[j], distance(x,y))\n            min_d, curr = min((d, j) for j, d in enumerate(dist)) \n            explored.add(curr)\n            dist[curr] = float('inf')\n            cost += min_d\n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        total = 0\n        edges = []\n        N = len(points)\n        parent = [x for x in range(N)]\n        rank = [1 for x in range(N)]\n        \n        def ufind(x):\n            if parent[x] == x:\n                return parent[x]\n            return ufind(parent[x])\n            \n        def uunion(x, y):\n            ux = ufind(x)\n            uy = ufind(y)\n            if rank[ux] > rank[uy]:\n                parent[uy] = ux\n                rank[ux] += rank[uy]\n            else:\n                parent[ux] = uy\n                rank[uy] += rank[ux]\n            \n        def dist(xi, yi, xj, yj):\n            return abs(xi-xj) + abs(yi-yj)\n        \n        for i in range(N):\n            xi, yi = points[i]\n            for j in range(i+1, N):\n                xj, yj = points[j]\n                edges.append((dist(xi, yi, xj, yj), i, j))\n                \n        heapq.heapify(edges)\n        n_added = 0\n        while n_added < N-1:\n            edge, i, j = heapq.heappop(edges)\n            if ufind(i) != ufind(j):\n                uunion(i, j)\n                total += edge\n                n_added += 1\n        \n        return total", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        if len(points) ==1:\n            return 0\n        heap = []      \n        visited = set()        \n        res = 0\n        \n        cur = 0\n        visited.add(0)\n        \n        while len(visited)!=len(points):\n            \n            for i in range(len(points)):\n                if cur==i or i in visited:\n                    continue\n                heapq.heappush(heap, (abs(points[i][0]-points[cur][0])+abs(points[i][1]-points[cur][1]), i))\n                \n            while True:\n                val, nxt = heapq.heappop(heap)\n               \n                if nxt not in visited:\n                    \n                    visited.add(nxt)\n                    res+=val\n                    cur = nxt\n                    break\n        \n        return res\n            \n        \n", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        cur, N, ans = 0, len(p), 0\n        dis = [float('inf')] * N\n        seen = set()\n        \n        for _ in range(N-1):\n            seen.add(cur)\n            for j in range(N):\n                if j in seen: continue\n                dis[j] = min(dis[j], manhattan(p[cur], p[j]))\n\n            d, cur = min((w, k) for k, w in enumerate(dis))\n            dis[cur] = float('inf')\n            ans += d\n            \n        return ans\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        X = [[None] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                X[i][j] = X[j][i] = abs(points[i][0] - points[j][0]) + \\\\\n                                    abs(points[i][1] - points[j][1])\n        \n        V = [0] + [float(\\\"inf\\\")] * (n - 1)\n        S = [True] * n\n        \n        for _ in range(n - 1):\n            i, v = -1, float(\\\"inf\\\")\n            for j in range(n):\n                if S[j] and V[j] < v:\n                    i, v = j, V[j]\n            \n            S[i] = False\n            for j in range(n):\n                if S[j] and X[i][j] < V[j]:\n                    V[j] = X[i][j]    \n        \n        return sum(V)", "import math\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            dis[curr] = math.inf\n            res += delta\n            \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        # prim O(N^2)\n        inf = float('inf')\n        n = len(A)\n        cost_sum = 0\n        nearest_points = [inf]\n        for i in range(1, n):\n            nearest_points.append(abs(A[i][0]-A[0][0]) + abs(A[i][1]-A[0][1]))\n        for i in range(n-1):\n            mn_cost = inf\n            for j in range(n):\n                if nearest_points[j] < mn_cost:\n                    mn_cost = nearest_points[j]\n                    mn_cost_index = j\n            cost_sum += mn_cost\n            nearest_points[mn_cost_index] = inf\n            for j in range(n):\n                if nearest_points[j] != inf:\n                    nearest_points[j] = min(nearest_points[j], abs(A[mn_cost_index][0]-A[j][0])+abs(A[mn_cost_index][1]-A[j][1]))\n        return cost_sum\n", "class Solution:\n    def minCostConnectPoints(self, points) -> int:\n        pq = []\n        N = len(points)\n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        p = list(range(N))\n        s = [1] * N\n        \n        def find(u):\n            while u != p[u]:\n                p[u] = p[p[u]]\n                u = p[u]\n            return p[u]\n        \n        for i in range(N):\n            for j in range(i + 1, N):\n                heappush(pq, [dist(points[i], points[j]), i, j])\n        \n        edges = 0\n        res = 0\n        while edges < N - 1:\n            d, u, v = heappop(pq)\n            pu, pv = find(u), find(v)\n            if pu == pv:\n                continue\n            edges += 1\n            res += d\n            if s[pv] > s[pu]:\n                pu, pv = pv, pu\n            p[pv] = pu\n            s[pu] += s[pv]\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: \n            return 0\n        ans = curr = 0\n        d = [float(\\\"inf\\\")] * n\n        v = set()\n        for _ in range(n-1):\n            x0, y0 = points[curr]\n            v.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j not in v:\n                    d[j] = min(d[j], abs(x-x0) + abs(y-y0)) \n            delta, curr = min((v, j) for j, v in enumerate(d)) \n            d[curr] = float(\\\"inf\\\")\n            ans += delta\n        return ans", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        total_cost = 0\n        # any initial point can be chosen\n        x1, y1 = points.pop() \n        # then make a heap sorted by distance to that point\n        \n        cost_heap = []\n        heapq.heapify(cost_heap)\n        for x2, y2 in points:\n            heapq.heappush(cost_heap, [abs(x1-x2) + abs(y1-y2), x2, y2])\n        \n        # pop off the points with the lowest distance\n        # then see if any of the remaining points are closer to that new point than\n        # the previous points had been, and update the heap\n        while cost_heap:\n            cost, x1, y1 = heapq.heappop(cost_heap)\n            total_cost += cost\n            for i, [cost, x2, y2] in enumerate(cost_heap):\n                cost_heap[i][0] = min(cost, abs(x1-x2) + abs(y1-y2))\n            heapq.heapify(cost_heap)\n            \n        return total_cost", "#Prim's algorithm\nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        n = len(points)\n        dist = lambda p0, p1: abs(p1[0] - p0[0]) + abs(p1[1] - p0[1])\n        q = [(0, 0)]\n        visited = set()\n        nodes = set(range(len(points)))\n        res = 0\n        while q:\n            d, u = heappop(q)\n            if u in visited:\n                continue\n            visited.add(u)\n            res = res + d\n            if len(visited) == n:\n                return res\n            for v in nodes:\n                if v not in visited:\n                    w = dist(points[u], points[v])\n                    heappush(q, (w, v))", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        manhattan = lambda p1, p2 : abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        pq = []\n        p1 = points[0]\n        seen_idxs = {0,}\n        for idx in range(len(points)):\n            if idx not in seen_idxs:\n                p2 = points[idx]\n                heapq.heappush(pq, (manhattan(p1, p2), idx))\n            else:\n                continue\n                \n        total_dist = 0\n        while len(seen_idxs) != len(points):\n            while pq[0][-1] in seen_idxs:\n                heapq.heappop(pq)\n            dist, min_idx = heapq.heappop(pq)\n            \n            total_dist += dist\n            seen_idxs.add(min_idx)\n            p1 = points[min_idx]\n            \n            for idx in range(len(points)):\n                if idx not in seen_idxs:\n                    p2 = points[idx]\n                    heapq.heappush(pq, (manhattan(p1, p2), idx))\n                    \n        return total_dist\n        \n        \n", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(x, y):\n            dx = abs(x[0] - y[0])\n            dy = abs(x[1] - y[1])\n            return dx+dy\n        \n        n = len(points)\n        if n == 1:\n            return 0\n        if n == 2:\n            return distance(points[0], points[1])\n        \n        # # Method 1: Prim's Alg with Heap\n        # d = {i:[] for i in range(n)}\n        # for i in range(n):\n        #     for j in range(i+1, n):\n        #         dist = distance(points[i], points[j])\n        #         d[i].append((dist, j))\n        #         d[j].append((dist, i))\n        # cost = 0\n        # connected = 1\n        # check = [True] + [False]*(n-1)\n        # heap = d[0]\n        # heapq.heapify(heap)\n        # while connected < n:\n        #     (dist, p) = heapq.heappop(heap)\n        #     if not check[p]:\n        #         cost += dist\n        #         connected += 1\n        #         check[p] = 1\n        #         for pair in d[p]:\n        #             heapq.heappush(heap, pair)\n        # return cost\n        \n        # Method 2: Kruskal's Alg with Disjoint Set\n        \n        \n        \n        # Nethod 3: Greedy\n        cost = 0\n        curr = 0 # select a random point as the starting point\n        dist = [float('inf')] * n\n        explored = set()\n        explored.add(0)\n        cnt = 1\n        while cnt < n:\n            x = points[curr]\n            for j, y in enumerate(points):\n                if j in explored: \n                    continue\n                else:\n                    dist[j] = min(dist[j], distance(x,y))\n            min_d, curr = min((d, j) for j, d in enumerate(dist)) \n            explored.add(curr)\n            cnt += 1\n            dist[curr] = float('inf')\n            cost += min_d\n        return cost\n", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(p1, p2):\n            return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n        res = 0\n        n = len(points)\n        seen = set()\n        h = [(0, 0, 0)]\n        \n        while len(seen) < n:\n            d, u, v = heapq.heappop(h)\n            if v in seen: continue\n            seen.add(v)\n            res += d\n            for w in range(n):\n                if w in seen or w == v: continue\n                heapq.heappush(h, (dist(points[v], points[w]), v, w))\n                    \n        return res", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        cur, N, ans = 0, len(p), 0\n        dis = [float('inf')] * N\n        seen = [False] * N\n        \n        for _ in range(N-1):\n            seen[cur] = True\n            for j in range(N):\n                if seen[j]: continue\n                dis[j] = min(dis[j], manhattan(p[cur], p[j]))\n\n            d, cur = min((w, k) for k, w in enumerate(dis))\n            dis[cur] = float('inf')\n            ans += d\n            \n        return ans\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: \n            return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: \n                    continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            dis[curr] = math.inf\n            res += delta\n            \n        return res", "# # Kruskal\n# # O(n ^ 2 log n)\n# class UnionFindSet:\n#     def __init__(self, n):\n#         self.parents = [i for i in range(n + 1)]\n#         self.ranks = [0 for i in range(n + 1)]\n        \n#     def find(self, u):\n#         if u != self.parents[u]:\n#             self.parents[u] = self.find(self.parents[u])            \n#         return self.parents[u]\n    \n#     def union(self, u, v):\n#         pu = self.find(u)\n#         pv = self.find(v)\n#         if pu == pv: return False\n        \n#         if self.ranks[pu] < self.ranks[pv]:\n#             self.parents[pu] = pv\n#         elif self.ranks[pu] > self.ranks[pv]:\n#             self.parents[pv] = pu\n#         else:\n#             self.parents[pu] = pv\n#             self.ranks[pv] += 1\n            \n#         return True\n\n\n# class Solution:\n#     def minCostConnectPoints(self, points: List[List[int]]) -> int:\n#         n = len(points)\n#         edges = []\n#         for i in range(n):\n#             for j in range(i + 1, n):\n#                 edges.append([abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j])\n#         edges.sort()\n#         ans = 0\n#         count = 0\n#         uf = UnionFindSet(n)\n#         for e in edges:\n#             if not uf.union(e[1], e[2]): continue\n#             ans += e[0]\n#             count += 1\n#             if count == n - 1: return ans\n            \n#         return ans\n        \n\n# Prim's\n# my time: O(n ^ 2)\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        n = len(points)\n        ds = [float('inf') for _ in range(n)]\n        for i in range(1, n):\n            ds[i] = dist(points[0], points[i])\n        \n        ans = 0\n        for i in range(1, n):\n            v = ds.index(min(ds))\n            ans += ds[v]\n            ds[v] = float('inf')\n            for i in range(n):\n                if ds[i] == float('inf'): continue\n                ds[i] = min(ds[i], dist(points[i], points[v]))\n                \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap=[]\n        union_find=dict()\n        for i in range(len(points)):\n            union_find[i]=i\n            for j in range(i+1,len(points)):\n                heapq.heappush(heap,(abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),i,j))\n        \n        def find_set(node,ufo):\n            if ufo[node]==node:\n                return node\n            else:\n                return find_set(ufo[node],ufo)\n        \n        cost=0\n        n=0\n        while heap:\n            currEdge=heapq.heappop(heap)\n            left_root=find_set(currEdge[1],union_find)\n            right_root=find_set(currEdge[2],union_find)\n            if left_root!=right_root:\n                cost+=currEdge[0]\n                n+=1\n                if n==(len(points)-1):\n                    break\n                union_find[left_root]=right_root\n        \n        return cost\n            \n", "# # Kruskal\n# # O(n ^ 2)\n# class UnionFindSet:\n#     def __init__(self, n):\n#         self.parents = [i for i in range(n + 1)]\n#         self.ranks = [0 for i in range(n + 1)]\n        \n#     def find(self, u):\n#         if u != self.parents[u]:\n#             self.parents[u] = self.find(self.parents[u])            \n#         return self.parents[u]\n    \n#     def union(self, u, v):\n#         pu = self.find(u)\n#         pv = self.find(v)\n#         if pu == pv: return False\n        \n#         if self.ranks[pu] < self.ranks[pv]:\n#             self.parents[pu] = pv\n#         elif self.ranks[pu] > self.ranks[pv]:\n#             self.parents[pv] = pu\n#         else:\n#             self.parents[pu] = pv\n#             self.ranks[pv] += 1\n            \n#         return True\n\n\n# class Solution:\n#     def minCostConnectPoints(self, points: List[List[int]]) -> int:\n#         n = len(points)\n#         edges = []\n#         for i in range(n):\n#             for j in range(i + 1, n):\n#                 edges.append([abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j])\n#         edges.sort()\n#         ans = 0\n#         count = 0\n#         uf = UnionFindSet(n)\n#         for e in edges:\n#             if not uf.union(e[1], e[2]): continue\n#             ans += e[0]\n#             count += 1\n#             if count == n - 1: return ans\n            \n#         return ans\n        \n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        n = len(points)\n        ds = [float('inf') for _ in range(n)]\n        for i in range(1, n):\n            ds[i] = dist(points[0], points[i])\n        \n        ans = 0\n        for i in range(1, n):\n            v = ds.index(min(ds))\n            ans += ds[v]\n            ds[v] = float('inf')\n            for i in range(n):\n                if ds[i] == float('inf'): continue\n                ds[i] = min(ds[i], dist(points[i], points[v]))\n                \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        res = 0\n        n = len(points)\n        mst = [False]*n\n        dist = [None]*n       \n        i = 0\n        dist[i] = 0\n        mst[i] = True\n        for _ in range(n - 1):\n            min_dist = None\n            next_i = None\n            for j in range(n):\n                if not mst[j]:\n                    cur_dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                    if dist[j] is None:\n                        dist[j] = cur_dist\n                    elif dist[j] > cur_dist:\n                        dist[j] = cur_dist\n                    if min_dist is None or min_dist > dist[j]:\n                        min_dist = dist[j]\n                        next_i = j\n            i = next_i\n            res += dist[i]\n            mst[i] = True\n        return res\n", "import heapq\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n+1))\n        self.rank = [0]*(n+1)\n    \n    def find(self, x):\n        if x!=self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n        if px==py:\n            return False\n        if self.rank[px]>self.rank[py]:\n            self.parent[py] = px\n        elif self.rank[px]<self.rank[py]:\n            self.parent[px] = py\n        else:\n            self.parent[px] = py\n            self.rank[px] += 1\n        return True\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        l = len(points)\n        if l == 1:\n            return 0\n        u = UnionFind(l)\n        li = []\n        c = 0\n        ans = 0\n        for i in range(l):\n            for j in range(i+1,l):\n                v = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                li.append((v,i,j))\n        heapq.heapify(li)\n        #li.sort(key = lambda x:x[2])\n        while li:\n            p = heapq.heappop(li)\n            if u.find(p[1]) != u.find(p[2]):\n                u.union(p[1],p[2])\n                c = c + 1\n                ans = ans + p[0]\n            if c == l - 1:\n                return ans\n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # turns out sorted + union find is the best\n        # but makes sense to write union find using nonlocal as they are less\n        # likely to TLE\n\n        n = len(points)\n        edges = []\n        for i in range(n-1):\n            for j in range(i+1,n):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((d, i, j))\n                \n        cost = 0\n        found = 0\n        parents = list(range(n))\n        \n        def find(a):\n            while a != parents[a]:\n                a, parents[a] = parents[a], parents[parents[a]]\n            return a\n        \n        def union(a, b):\n            parents[find(a)] = find(b)\n        \n        for c, a, b in sorted(edges):\n            if find(a) != find(b):\n                union(a,b)\n                found += 1\n                cost += c\n                \n            if found == n-1:\n                break\n        \n        return cost", "class DSU:\n    def __init__(self, length):\n        self.storage = [x for x in range(length)]\n        self.rank = [0] * length\n    \n    def find(self, val):\n        return self.find(self.storage[val]) if val != self.storage[val] else val\n    \n    def union(self, val1, val2):\n        place_1 = self.find(val1)\n        place_2 = self.find(val2)\n        if self.rank[place_1] > self.rank[place_2]:\n            self.storage[place_2] = self.storage[place_1]\n        elif self.rank[place_2] > self.rank[place_1]:\n            self.storage[place_1] = self.storage[place_2]\n        else:\n            self.rank[place_1] += 1\n            self.storage[place_2] = self.storage[place_1]\n\n\nclass Solution:\n    def distance(self, p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        possible_pairs = [] # (from, to, distance)\n        n = len(points)\n        for i in range(n):\n            for j in range(i+1, n):\n                possible_pairs.append((i, j, self.distance(points[i], points[j])))\n\n        possible_pairs.sort(key=lambda x: x[2])\n\n        result = 0\n        index = 0\n        count = 0\n        dsu = DSU(n)\n        while index < len(possible_pairs) and count != n - 1:\n            f, to, d = possible_pairs[index]\n            \n            x = dsu.find(f)\n            y = dsu.find(to)\n            \n            if x != y:\n                count += 1\n                dsu.union(x, y)\n                result += d\n\n            index += 1\n        \n        return result\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        adj = [[inf for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(i+1, n):\n                adj[i][j] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                adj[j][i] = adj[i][j]\n        selected = [False for _ in range(n)]\n        min_edges = [[inf, -1] for _ in range(n)]\n        min_edges[0][0] = 0\n        total = 0\n        for i in range(n):\n            v = -1\n            for j in range(n):\n                if not selected[j] and (v == -1 or min_edges[j][0] < min_edges[v][0]):\n                    v = j\n            selected[v] = True\n            total += min_edges[v][0]\n            for to in range(n):\n                if adj[v][to] < min_edges[to][0]:\n                    min_edges[to][0] = adj[v][to]\n        return total", "class Solution:\n    def minCostConnectPoints(self, points: list(list())) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0  # select a random point as the starting point\n        dis = [float('inf')] * n\n        explored = set()\n\n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n\n            delta, curr = min((d, j) for j, d in enumerate(dis))\n            dis[curr] = float('inf')\n            res += delta\n\n        return int(res)", "import heapq\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa]\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(u, v):\n            dx = abs(u[0] - v[0])\n            dy = abs(u[1] - v[1])\n            return dx+dy\n        \n        n = len(points)\n        if n == 1:\n            return 0\n        if n == 2:\n            return distance(points[0], points[1])\n        \n        # # Method 1: Prim's Alg with Heap\n        # d = {i:[] for i in range(n)}\n        # for i in range(n):\n        #     for j in range(i+1, n):\n        #         dist = distance(points[i], points[j])\n        #         d[i].append((dist, j))\n        #         d[j].append((dist, i))\n        # cost = 0\n        # connected = 1\n        # check = [True] + [False]*(n-1)\n        # heap = d[0]\n        # heapq.heapify(heap)\n        # while connected < n:\n        #     (dist, p) = heapq.heappop(heap)\n        #     if not check[p]:\n        #         cost += dist\n        #         connected += 1\n        #         check[p] = 1\n        #         for pair in d[p]:\n        #             heapq.heappush(heap, pair)\n        # return cost\n        \n        # # Nethod 2: Another Implementation of Prim's Alg\n        cost = 0\n        curr = 0 # select a random point as the starting point\n        dist = [float('inf')] * n\n        explored = set()\n        explored.add(0)\n        cnt = 1\n        while cnt < n:\n            u = points[curr]\n            for j, v in enumerate(points):\n                if j in explored: \n                    continue\n                else:\n                    dist[j] = min(dist[j], distance(u,v))\n            min_d, curr = min((d, j) for j, d in enumerate(dist)) \n            explored.add(curr)\n            cnt += 1\n            dist[curr] = float('inf')\n            cost += min_d\n        return cost\n        \n        # Method 3: Kruskal's Alg with Disjoint Set\n        \n        \n        \n\n", "class Solution:\n    def find(self, parents, i):\n        if parents[i] == -1:\n            return i\n        return self.find(parents, parents[i])\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 1:\n            return 0\n        pairs = []\n        for i in range(n):\n            for j in range(i+1, n):\n                pairs.append((i, j))\n        \n        def distance(i, j):\n            p1, p2 = points[i], points[j]\n            return abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n        pairs = sorted(pairs, key=lambda pair: distance(pair[0], pair[1]))\n        \n        total = 0\n        parents = [-1]*n\n        countE = 0\n        for pair in pairs:\n            if countE >= n-1:\n                break\n            i, j = pair\n            pi = self.find(parents, i)\n            pj = self.find(parents, j)\n            if pi == pj:\n                continue\n            \n            parents[pi] = pj\n            total += distance(i, j)\n            countE += 1\n        return total\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def main(arr):\n            if len(arr) < 1:\n                return 0\n            node = 0\n            answer = 0\n            n = len(arr)\n            visit = set()\n            global_dist = [float('inf')] * n\n            while n > 1 :\n                cur_x, cur_y = arr[node]\n                visit.add(node)\n                \n                for j in range(len(arr)):\n                    if j in visit: continue\n                    x,y = arr[j]\n                    global_dist[j] = min(global_dist[j], abs(x-cur_x)+abs(y-cur_y))\n                \n                next_node = -1\n                next_dist = float('inf')\n                for idx,dist in enumerate(global_dist):\n                    if dist < next_dist:\n                        next_dist = dist\n                        next_node = idx\n                node = next_node        \n                answer += next_dist\n                \n                global_dist[next_node] = float('inf')\n\n                n -= 1\n\n            return answer\n        return main(points)", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        total_cost = 0\n        # any initial point can be chosen\n        x1, y1 = points[0]\n\n        # initially sort points by their distance to initial point\n        cost_heap = []\n        heapq.heapify(cost_heap)\n        for x2, y2 in points[1:]:\n            heapq.heappush(cost_heap, [abs(x1-x2) + abs(y1-y2), x2, y2])\n        \n        # then pop points and update costs since new point may be closer\n        while cost_heap:\n            cost, x1, y1 = heapq.heappop(cost_heap)\n            total_cost += cost\n            for i, [cost, x2, y2] in enumerate(cost_heap):\n                cost_heap[i][0] = min(cost, abs(x1-x2) + abs(y1-y2))\n            cost_heap.sort()\n            \n        return total_cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n_points = len(points)\n        \n        if n_points == 1: return 0\n        \n        res  = 0\n        curr = 0 # select a random point as the starting point\n        dist  = [math.inf] * n_points\n        explored = set()\n        \n        for i in range(n_points - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: \n                    continue\n                \n                dist[j] = min(dist[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dist)) \n            dist[curr]   = math.inf\n            res += delta\n            \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = [[0 for _ in range(len(points))].copy() for _ in range(len(points))]\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                graph[i][j] = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                graph[j][i] = graph[i][j]\n        \n        costs = 0\n        visited = set()\n        keys = [sys.maxsize]*len(points)\n        parent = [0]*len(points)\n        keys[0] = 0\n        \n        def minkey():\n            ind = -1\n            m = sys.maxsize\n            for i in range(len(points)):\n                if i not in visited and keys[i] < m:\n                    m = keys[i]\n                    ind = i\n            return ind\n        \n        for _ in range(len(points)):\n            x = minkey()\n            visited.add(x)\n            for i in range(len(points)):\n                if graph[x][i] > 0 and i not in visited and keys[i] > graph[x][i]:\n                    keys[i] = graph[x][i]\n                    parent[i] = x\n                    \n        for i in range(len(points)):\n            costs += graph[i][parent[i]]\n            \n        return costs\n        \n        \n        \n        \n        \n", "import heapq\nfrom collections import defaultdict\n\nclass DSU():\n    def __init__(self, par):\n        self.par = par\n        self.rank = defaultdict(int)\n\n    def find(self, x):\n        if x != self.par[x]:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        elif self.rank[xr] > self.rank[yr]:\n            self.par[yr] = xr\n        elif self.rank[xr] < self.rank[yr]:\n            self.par[xr] = yr\n        else:\n            self.par[xr] = yr\n            self.rank[yr] += 1\n        return True\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(x,y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        if len(points) == 1:\n            return 0\n        edges = []\n        heapq.heapify(edges)\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                heapq.heappush(edges, (dist(points[i], points[j]), points[i], points[j]))\n                \n        par = {(x,y): (x,y) for (x,y) in points}        \n        dsu = DSU(par)\n        \n        total_len = 0\n        count = 0\n        while count < len(points) - 1:\n            d, p1, p2 = heapq.heappop(edges)\n            if dsu.union(tuple(p1), tuple(p2)):\n                total_len += d\n                count += 1\n        \n        return total_len", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        connected, dis = set(), [float(\\\"inf\\\")] * n\n        \n        res = 0\n        cur = nxt = 0\n        d = dis[0]\n        \n        for _ in range(n-1):\n            \n            connected.add(cur)\n            xx, yy = points[cur]\n            \n            for j, (x, y) in enumerate(points):\n                if j in connected: continue\n                    \n                dis[j] = min(dis[j], abs(x - xx) + abs(y - yy))\n                \n                if dis[j] < d:\n                    nxt, d = j, dis[j]\n            \n            res += d\n            cur = nxt\n            d = float(\\\"inf\\\")\n            \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1:\n            return 0\n        n  = len(points)\n        par = [i for i in range(n)]\n        sze = [1] * n\n        def dist(pi: List[int], pj: List[int]) -> int:\n            x, y = pi\n            a, b = pj        \n            return abs(x - a) + abs(y - b)\n        \n        def find(i: int) -> int:\n            if par[i] == i:\n                return i\n            return find(par[i])\n        \n        def union(i: int, j: int) -> int:\n            par[i] = j\n            sze[j] += sze[i]\n            return sze[j]\n            \n        pq = []    \n        \n        for i in range(n):\n            pi = points[i]\n            for j in range(i + 1, n):\n                pj = points[j]\n                heapq.heappush(pq, (dist(pi, pj), i, j))\n        ok = set()\n        total = 0\n        usize = 0\n        while usize < len(points):\n            cost, i, j = heapq.heappop(pq)        \n            ri, rj = find(i), find(j)\n            if ri != rj:\n                usize = union(ri, rj)                \n                ok.add(i)\n                ok.add(j)\n                total += cost   \n                #print(total, i, j, usize)\n        return total\n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        if len(points) == 1:\n            return 0\n        \n        costs = []\n        \n        for i in range(len(points)):\n            for k in range(i+1, len(points)):\n                x,y = points[i]\n                xx, yy = points[k]\n                costs.append((abs(x-xx)+abs(y-yy),i,k))\n        \n        costs.sort()\n        \n        dd = {x:x for x in range(len(points))}\n        \n        #print(costs)\n        \n        def merge(x,y,c):\n            x,y = find(x), find(y)\n            if x != y:\n                dd[x] = y\n                self.ans += c\n                self.groups -= 1\n        \n        def find(x):\n            if dd[x] != x:\n                dd[x] = find(dd[x])\n            return dd[x]\n        \n        self.groups = len(points)\n        \n        self.ans = 0\n        \n        for c,x,y in costs:\n            merge(x,y,c)\n            if self.groups == 1:\n                return self.ans\n                    \n", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n\n        ans, n = 0, len(p)\n        seen = set()\n        vertices = [(0, (0, 0))]\n\n        while len(seen) < n:\n            # print(vertices, seen)\n            w, (u, v) = heapq.heappop(vertices)            \n            if u in seen and v in seen: continue\n            ans += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))\n\n        return ans", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n    \n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n    \n    def union(self, i, j):\n        pi = self.find(i)\n        pj = self.find(j)\n        if pi != pj:\n            self.parent[max(pi, pj)] = min(pi, pj)\n            self.size[min(pi, pj)] += self.size[max(pi, pj)]\n            self.size[max(pi, pj)] = 0\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        distances = []\n        for idx0 in range(n):\n            i0, j0 = points[idx0]\n            for idx1 in range(idx0+1, n):\n                i1, j1 = points[idx1]\n                dis = abs(i0-i1)+abs(j0-j1)\n                distances.append([dis, idx0, idx1])\n        # print(distances)\n        heapq.heapify(distances)\n        # print(distances)\n        \n        res = 0\n        uf = UnionFind(n)\n        while uf.size[0] < n:\n            dis, idx0, idx1 = heapq.heappop(distances)\n            if uf.find(idx0) != uf.find(idx1):\n                # print(dis, idx0, idx1)\n                res += dis\n                uf.union(idx0, idx1)\n        return res\n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        costs = [[0 for _ in range(n)]for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                costs[i][j] = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                costs[j][i] = costs[i][j]\n        \n        parent = [-1 for _ in range(n)]\n        keyval = [-1 for _ in range(n)]\n        mst = [False for _ in range(n)]\n        keyval[0] = 0\n        \n        for i in range(n):\n            mini = -1\n            u = -1\n            \n            for j in range(n):\n                if mst[j]:\n                    continue\n                if keyval[j] == -1:\n                    continue\n                if mini == -1:\n                    mini = keyval[j]\n                    u = j\n                elif mini != -1 and mini > keyval[j]:\n                    mini = keyval[j]\n                    u = j\n            mst[u] = True\n            for j in range(n):\n                if j != u and not mst[j]:\n                    if keyval[j] == -1 or keyval[j] > costs[u][j]:\n                        keyval[j] = costs[u][j]\n                        parent[j] = u\n                        \n        r = 0\n        for i in range(1, n):\n            r += costs[parent[i]][i]\n        return r\n", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        total_cost = 0\n        # any initial point can be chosen\n        x1, y1 = points.pop() \n        # then make a heap sorted by distance to that point\n        \n        cost_heap = []\n        for x2, y2 in points:\n            heapq.heappush(cost_heap, [abs(x1-x2) + abs(y1-y2), x2, y2])\n        \n        # pop off the points with the lowest distance\n        # then see if any of the remaining points are closer to that new point than\n        # the previous points had been, and update the heap\n        while cost_heap:\n            cost, x1, y1 = heapq.heappop(cost_heap)\n            total_cost += cost\n            for i, [cost, x2, y2] in enumerate(cost_heap):\n                cost_heap[i][0] = min(cost, abs(x1-x2) + abs(y1-y2))\n                \n            # heapify runs in n time, and sort in n log n, however since it\n            # should be mostly presorted, in practice it's probably very close\n            # since timsort takes advantage of these \\\"runs\\\"\n            \n            heapq.heapify(cost_heap)\n            \n        return total_cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            dis[curr] = math.inf\n            res += delta\n            \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = [[0 for _ in range(len(points))].copy() for _ in range(len(points))]\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                graph[i][j] = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                graph[j][i] = graph[i][j]\n        \n        costs = 0\n        keys = [sys.maxsize]*len(points)\n        parent = [0]*len(points)\n        visited = parent.copy()\n        keys[0] = 0\n        \n        def minkey():\n            ind = -1\n            m = sys.maxsize\n            for i in range(len(points)):\n                if visited[i] == 0 and keys[i] < m:\n                    m = keys[i]\n                    ind = i\n            return ind\n        \n        for _ in range(len(points)):\n            x = minkey()\n            visited[x] = 1\n            for i in range(len(points)):\n                if graph[x][i] > 0 and visited[i] == 0 and keys[i] > graph[x][i]:\n                    keys[i] = graph[x][i]\n                    parent[i] = x\n                    \n        for i in range(len(points)):\n            costs += graph[i][parent[i]]\n            \n        return costs\n        \n        \n        \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            dis[curr] = math.inf\n            res += delta\n            \n        return res\n        \n        \n\n", "class DSU:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        xp, yp = self.find(x), self.find(y)\n        if xp == yp:\n            return False\n        if self.rank[xp] < self.rank[yp]:\n            self.parent[xp] = yp\n        elif self.rank[xp] > self.rank[yp]:\n            self.parent[yp] = xp\n        else:\n            self.parent[xp] = yp\n            self.rank[yp] += 1\n        self.size -= 1\n        return True\n    def getSize(self):\n        return self.size\n    \nclass Solution:\n    import heapq\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap, n = [], len(points)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(heap, (dist, (i, j)))\n        dsu = DSU(n + 1)\n        res, i, j = 0, 0, 0\n        while heap:\n            dist, (i, j) = heapq.heappop(heap)\n            if dsu.union(i, j):\n                res += dist\n                if dsu.getSize() == 2:\n                    return res\n        return 0\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def minKey(keys, mstSet):\n            min_value = float('+Inf') \n            for v in range(len(points)):\n                if keys[v] < min_value and not mstSet[v]:\n                    min_value = keys[v]\n                    min_index = v\n            return (min_index, min_value)\n        \n        def get_distance(u, v):\n            return (abs(points[u][0] - points[v][0]) +\n                abs(points[u][1] - points[v][1]))\n        \n        size, total = len(points), 0\n        keys = [float('+Inf')] * size\n        keys[0] = 0\n        mstSet = [False] * size\n        for i in range(size):\n            (u, min_value) = minKey(keys, mstSet)\n            total += min_value\n            mstSet[u] = True\n            for v in range(size):\n                distance = get_distance(u, v)\n                if (keys[v] > distance > 0 and mstSet[v] == False):\n                    keys[v] = distance\n        return total\n", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        ans, n = 0, len(p)\n        seen = set()\n        vertices = [(0, (0, 0))]\n        \n        while len(seen) < n:\n            # print(vertices, seen)\n            w, (u, v) = heapq.heappop(vertices)            \n            if v in seen: continue\n            ans += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))\n        return ans", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        cur, N, ans = 0, len(p), 0\n        dis = [float('inf')] * N\n        seen = [False] * N\n        \n        for _ in range(N-1):\n            x, y = p[cur]\n            seen[cur] = True\n            for j, (nx, ny) in enumerate(p):\n                if seen[j]: continue\n                dis[j] = min(dis[j], abs(nx-x)+abs(ny-y))\n\n            d, cur = min((w, k) for k, w in enumerate(dis))\n            dis[cur] = float('inf')\n            ans += d\n            \n        return ans\n            \n", "class DSU:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n        self.count = n\n    \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self,x,y):\n        px = self.find(x)\n        py = self.find(y)\n        if px==py:\n            return False\n        self.count-=1\n        if self.rank[x]>self.rank[y]:\n            self.parent[py]=px\n            self.rank[px]+=self.rank[py]\n        else:\n            self.parent[px]=py\n            self.rank[py]+=self.rank[px]\n        return True\n                \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        # print(edges)\n        edges.sort()\n        res = 0\n        ds = DSU(n)\n        for cost, u, v in edges:\n            if ds.count==1:\n                break\n            if ds.union(u,v):\n                res += cost\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(symbol):\n            if(group_map.get(symbol) is None):\n                group_map[symbol] = symbol\n                return group_map[symbol]\n            root = symbol\n            while(root != group_map[root]):\n                root = group_map[root]\n            \n            while(symbol != root):\n                parent = group_map[symbol]\n                group_map[symbol] = root\n                symbol = parent\n            \n            return root\n        \n        def union(symbol1, symbol2):\n            root1 = find(symbol1)\n            root2 = find(symbol2)\n            \n            if(root1 == root2):\n                return\n            \n            if(group_size.get(root1) is None):\n                group_map[root1] = root1\n                group_size[root1] = 1\n            \n            if(group_size.get(root2) is None):\n                group_map[root2] = root2\n                group_size[root2] = 1\n            \n            if(group_size[root1] < group_size[root2]):\n                group_size[root2] += group_size[root1]\n                group_map[root1] = root2\n            else:\n                group_size[root1] += group_size[root2]\n                group_map[root2] = root1\n                \n        all_edges = []\n        for i in range(0, len(points)):\n            for j in range(i + 1, len(points)):\n                all_edges.append((i, j, (abs(points[j][0] - points[i][0]) + abs(points[j][1] - points[i][1]))))\n        \n        all_edges.sort(key=lambda x: x[2])\n        \n        vertices = [i for i in range(0, len(points))]\n        \n        group_map = {}\n        group_size = {}\n\n        edge_count = 0\n        edge_index = 0\n        \n        total_weight = 0\n        \n        while(edge_count < len(points) - 1):\n            (node_1, node_2, weight) = all_edges[edge_index]\n            edge_index += 1\n            parent_1 = find(node_1)\n            parent_2 = find(node_2)\n            \n            if(parent_1 != parent_2):\n                edge_count += 1\n                total_weight += weight\n                union(parent_1, parent_2)\n            \n        return total_weight\n", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        heap, total_cost = [], 0\n        for u in range(N-1):\n            for v in range(u+1, N):\n                heappush(heap, [dist(points[u], points[v]), u, v])\n        while heap:\n            cost, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                N -= 1\n                total_cost += cost\n                if N == 0:\n                    break\n        return total_cost\n\n    \n    \n    \n    \n    \n    \n    \n    \nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        dist = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        heap = []\n        for i in range(N-1):\n            for j in range(i+1, N):\n                heappush(heap, (dist(points[i], points[j]), i, j))\n        res = 0\n        while heap:\n            d, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                res += d\n                N -= 1\n                if N == 0:\n                    break\n        return res\n            \n\n\nclass Solution:\n    def minCostConnectPoints(self, points):\n        manhattan = lambda a, b, x, y: abs(a-x)+abs(b-y)\n        points = sorted(points, key=lambda x: abs(x[0])+abs(x[1]))\n        connected = [points[0]]\n        cost = 0\n        points = list([[x[0], x[1], manhattan(connected[0][0], connected[0][1], x[0], x[1])] for x in points])\n        while len(connected) <= len(points):\n            minidx = None\n            mindist = float('inf')\n            for i in range(len(points)):\n                x, y, dist = points[i]\n                if dist < mindist:\n                    mindist = dist\n                    minidx = i\n            mx, my, mdist = points.pop(minidx)\n            cost += mdist\n            for i in range(len(points)):\n                x, y, dist = points[i]\n                newdist = manhattan(x, y, mx, my)\n                if newdist < dist:\n                    points[i][2] = newdist\n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        ans, n = 0, len(points)\n        seen = set()\n        vertices = [(0, (0, 0))]\n        \n        while len(seen) < n:\n            w, (u, v) = heapq.heappop(vertices)\n            if v in seen: continue\n            ans += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen:\n                    heapq.heappush(vertices, (manhattan(points[j], points[v]), (v, j)))\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def manhattan(x,y):\n            return abs(x[0]-y[0])+abs(x[1]-y[1])\n        \n        ans, n = 0, len(points)\n        seen = set()\n        vertices = [(0,(0,0))]\n        \n        while len(seen) < n:\n            w, (u,v) = heapq.heappop(vertices)\n            if v in seen:\n                continue\n            ans += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j != v:\n                    heapq.heappush(vertices, (manhattan(points[j], points[v]), (v,j)))\n        \n        return ans\n        \n        \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        def minnode(vis): \n            mini = 999999999999\n            x,y=0,0\n        \n\n            # Loop through all the values of \n            # the nodes which are not yet \n            # included in MST and find the \n            # minimum valued one. \n            # k=lambda u,v :u*1+v\n            for u,v in points:\n                if (vis[(u,v)] == False and dis[(u,v)] < mini): \n                    mini = dis[(u,v)]\n                    x,y=u,v\n                \n            return (mini,x,y)\n        \n        def cal_cities_dis(x,y):\n            dis={}\n            vis={}\n            for u,v in points:\n                vis[(u,v)]=False\n                dis[(u,v)]=abs(u-x)+abs(y-v)\n            return vis,dis\n        \n        # Find the rest n-1 nodes of MST. \n        def dist(x,y,u,v):\n            \n            return abs(u-x)+abs(y-v)\n        res=0\n        n=len(points)\n        \n        vis,dis=cal_cities_dis(points[0][0],points[0][1])\n        \n        # print(vis,dis)\n        for i in range(n ): \n\n            # First find out the minimum node \n            # among the nodes which are not yet \n            # included in MST. \n            c,u,v = minnode( vis) \n            res+=c\n            # print(c,u,v)\n\n            # Now the uth node is included in MST. \n            vis[(u,v)]=True\n\n            # Update the values of neighbor \n            # nodes of u which are not yet \n            # included in MST. \n            for x,y in points:\n                if ( vis[(x,y)] == False and dist(u,v,x,y)< dis[(x,y)]): \n                    \n                    dis[(x,y)] = dist(u,v,x,y)\n                \n        return res\n\n\n\\t\n\\t\n\n\n# This code is contributed by PranchalK \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        ans, n = 0, len(points)\n        seen = set()\n        vertices = [(0, (0, 0))]\n        \n        while len(seen) < n:\n            # print(vertices, seen)\n            w, (u, v) = heapq.heappop(vertices)            \n            if v in seen: continue\n            ans += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    heapq.heappush(vertices, (manhattan(points[j], points[v]), (v, j)))\n                    \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        import heapq\n        if len(points) == 1:\n            return 0\n        heap = []\n        group = {i:i for i in range(len(points))}\n        for i in range(len(points)-1):\n            for j in range(i+1,len(points)):\n                heap.append([abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1]),i,j])\n        edgeset = []\n        heapq.heapify(heap)\n        while len(set(group.values())) > 1:\n            weight,s,e = heapq.heappop(heap)\n            if group[s] != group[e]:\n                v1 = group[s]\n                v2 = group[e]\n                for key,v in list(group.items()):\n                    if v == v2:\n                        group[key] = v1\n                edgeset.append(weight)\n        return sum(edgeset)\n                \n", "def manhattan(x, y):\n    return abs(x[0] - y[0]) + abs(x[1]-y[1])\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # minimum spanning tree (subgraph that contains all vertices and is a tree)\n        # Two disjoint subsets of vertices\n        # must be connected to make Spanning Tree\n        # this connection must be minimum\n        mstSet = set() # all vertices in mst\n        ans, n = 0, len(points)\n        queue = [(0, (0, 0))]\n        while len(mstSet) < n:\n            # print(vertices, mstSet)\n            weight, (u, v) = heapq.heappop(queue)\n            if v in mstSet: continue\n            ans += weight\n            mstSet.add(v)\n            for j in range(n):\n                if j not in mstSet and j != v:\n                    heapq.heappush(queue, (manhattan(points[j], points[v]), (v, j)))\n        return ans", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n\n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n\n        ans, n = 0, len(p)\n        seen = set()\n        vertices = [(0, (0, 0))] # (distance, (last_vertice, cur_vertice))\n\n        while len(seen) < n:\n            # print(vertices, seen)\n            d, (u, v) = heapq.heappop(vertices)            \n            if u in seen and v in seen: continue\n            ans += d\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))\n\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda a, b, x, y: abs(a-x)+abs(b-y)\n        points = sorted(points, key=lambda x: abs(x[0])+abs(x[1]))\n        connected = [points[0]]\n        cost = 0\n        points = list([[x[0], x[1], manhattan(connected[0][0], connected[0][1], x[0], x[1])] for x in points])\n        # print(points)\n        while len(connected) <= len(points):\n            minidx = None\n            mindist = float('inf')\n            for i in range(len(points)):\n                x, y, dist = points[i]\n                if dist < mindist:\n                    mindist = dist\n                    minidx = i\n            mx, my, mdist = points.pop(minidx)\n            cost += mdist\n            for i in range(len(points)):\n                x, y, dist = points[i]\n                newdist = manhattan(x, y, mx, my)\n                if newdist < dist:\n                    points[i][2] = newdist\n            # print(points, mindist, \\\"=\\\", mx,my)\n        return cost\n", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        total_cost = 0\n        # any initial point can be chosen\n        x1, y1 = points.pop() \n        # then make a heap sorted by distance to that point\n        \n        cost_heap = []\n        heapq.heapify(cost_heap)\n        for x2, y2 in points:\n            heapq.heappush(cost_heap, [abs(x1-x2) + abs(y1-y2), x2, y2])\n        \n        while cost_heap:\n            cost, x1, y1 = heapq.heappop(cost_heap)\n            total_cost += cost\n            for i, [cost, x2, y2] in enumerate(cost_heap):\n                cost_heap[i][0] = min(cost, abs(x1-x2) + abs(y1-y2))\n            cost_heap.sort()\n            \n        return total_cost", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n\n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n\n        ans, n = 0, len(p)\n        seen = set()\n        vertices = [(0, (0, 0))]\n\n        while len(seen) < n:\n            # print(vertices, seen)\n            w, (u, v) = heapq.heappop(vertices)            \n            if u in seen and v in seen: continue\n            ans += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))\n\n        return ans", "class Solution(object):\n    def minCostConnectPoints(self, points):\n        \\\"\\\"\\\"\n        :type points: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        n = len(points)\n        colors = list(range(n))\n        sets = [[i] for i in range(n)]\n        \n        edges = []\n        for i in range(n):\n            for j in range(i):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((i, j, dist))\n                \n        edges.sort(key=lambda x: x[2])\n        \n        cost = 0\n        for (x, y, d) in edges:\n            if colors[x] == colors[y]:\n                continue\n\n            cost += d\n            if len(sets[colors[x]]) < len(sets[colors[y]]):\n                x, y = y, x\n\n            #add y to x\n            color_x = colors[x]\n            color_y = colors[y]\n\n            for node in sets[color_y]:\n                colors[node] = color_x\n\n            sets[color_x].extend(sets[color_y])\n\n        return cost\n        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        visited = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            visited.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in visited: \n                    continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = float('inf'),float('inf')\n            for j, d in enumerate(dis):\n                delta, curr = min((delta, curr),(d, j)) \n            \n            dis[curr] = math.inf\n            res += delta\n            \n        return res\n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ss = [(0,0)]\n        n = len(points)\n        inc = set()\n        ans = 0\n        while n:\n            node = heapq.heappop(ss)\n            if node[1] not in inc:\n                ans+=node[0]\n                p1 = points[node[1]]\n                for i in range(len(points)):\n                    if i!=node[1] and i not in inc:\n                        p2 = points[i]\n                        dist = abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n                        heapq.heappush(ss,(dist,i))\n                inc.add(node[1])\n                n-=1\n        return ans", "class Node:\n    def __init__(self,data,rank,node):        \n        self.data = data\n        self.rank = rank\n        self.node = node            \n        self.parent = self\n\nclass UnionFind(object):\n    def __init__(self,n):\n        self._parent = [0]*n\n        self._size = [1]*n\n        self.count = n\n        for i in range(n):\n            self._parent[i] = i\n            \n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return False\n        self.count -= 1\n        if self._size[rootp] > self._size[rootq]:\n            self._size[rootp] += self._size[rootq]\n            self._parent[rootq] = self._parent[q] = rootp\n        else:\n            self._size[rootq] += self._size[rootp]\n            self._parent[rootp] = self._parent[p] = rootq\n        return True\n    \n    def find(self, n):\n        while self._parent[n] != n:\n            self._parent[n] = self._parent[self._parent[n]]\n            n = self._parent[n]\n        return n\n    \n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n            \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []        \n        N = len(points)  \n        for i in range(N):\n            for j in range(i+1,N):\n                edges.append([i,j,findManhattanDistance(points[i],points[j])])        \n        edges.sort(key=lambda x:x[2])        \n              \n        hashMap = {}        \n        for i in range(N):              \n            hashMap[i] = Node(i,0,None)       \n            \n        uf = UnionFind(N)\n        edge_count, costs = 0,0\n        for u,v,w in edges:            \n            if(uf.union(u,v)):        \n                costs += w\n                edge_count +=1\n            if(edge_count == N - 1):\n                break\n        return costs", "class UnionFind(object):\n    def __init__(self,n):\n        self._parent = [0]*n\n        self._size = [1]*n\n        self.count = n\n        for i in range(n):\n            self._parent[i] = i\n            \n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return False\n        self.count -= 1\n        if self._size[rootp] > self._size[rootq]:\n            self._size[rootp] += self._size[rootq]\n            self._parent[rootq] = self._parent[q] = rootp\n        else:\n            self._size[rootq] += self._size[rootp]\n            self._parent[rootp] = self._parent[p] = rootq\n        return True\n    \n    def find(self, n):\n        while self._parent[n] != n:\n            self._parent[n] = self._parent[self._parent[n]]\n            n = self._parent[n]\n        return n\n    \n    #def connected(self, p, q):\n    #    return self.find(p) == self.find(q)\n            \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []        \n        N = len(points)  \n        for i in range(N):\n            for j in range(i+1,N):\n                edges.append([i,j,findManhattanDistance(points[i],points[j])])        \n        edges.sort(key=lambda x:x[2])      \n            \n        uf = UnionFind(N)\n        edge_count, costs = 0,0\n        for u,v,w in edges:            \n            if(uf.union(u,v)):        \n                costs += w\n                edge_count +=1\n            if(edge_count == N - 1):\n                break\n        return costs", "class Node:\n    def __init__(self,data,node):        \n        self.data = data\n        self.node = node            \n        self.parent = self\n\nclass UnionFind(object):\n    def __init__(self,n):\n        self._parent = [0]*n\n        self._size = [1]*n\n        self.count = n\n        for i in range(n):\n            self._parent[i] = i\n            \n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return False\n        self.count -= 1\n        if self._size[rootp] > self._size[rootq]:\n            self._size[rootp] += self._size[rootq]\n            self._parent[rootq] = self._parent[q] = rootp\n        else:\n            self._size[rootq] += self._size[rootp]\n            self._parent[rootp] = self._parent[p] = rootq\n        return True\n    \n    def find(self, n):\n        while self._parent[n] != n:\n            self._parent[n] = self._parent[self._parent[n]]\n            n = self._parent[n]\n        return n\n    \n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n            \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []        \n        N = len(points)  \n        for i in range(N):\n            for j in range(i+1,N):\n                edges.append([i,j,findManhattanDistance(points[i],points[j])])        \n        edges.sort(key=lambda x:x[2])      \n            \n        uf = UnionFind(N)\n        edge_count, costs = 0,0\n        for u,v,w in edges:            \n            if(uf.union(u,v)):        \n                costs += w\n                edge_count +=1\n            if(edge_count == N - 1):\n                break\n        return costs", "class UnionFind(object):\n    def __init__(self,n):\n        self._parent = [0]*n\n        self._size = [1]*n\n        self.count = n\n        for i in range(n):\n            self._parent[i] = i\n            \n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return False\n        self.count -= 1\n        if self._size[rootp] > self._size[rootq]:\n            self._size[rootp] += self._size[rootq]\n            self._parent[rootq] = self._parent[q] = rootp\n        else:\n            self._size[rootq] += self._size[rootp]\n            self._parent[rootp] = self._parent[p] = rootq\n        return True\n    \n    def find(self, n):\n        while self._parent[n] != n:\n            self._parent[n] = self._parent[self._parent[n]]\n            n = self._parent[n]\n        return n\n    \n    #def connected(self, p, q):\n    #    return self.find(p) == self.find(q)\n            \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        if not points: return 0\n        edges = []        \n        N = len(points)  \n        for i in range(N):\n            for j in range(i+1,N):\n                edges.append([i,j,findManhattanDistance(points[i],points[j])])        \n        edges.sort(key=lambda x:x[2])      \n            \n        uf = UnionFind(N)\n        edge_count, costs = 0,0\n        for u,v,w in edges:            \n            if(uf.union(u,v)):        \n                costs += w\n                edge_count +=1\n                if(edge_count == N - 1):\n                    break\n        return costs", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        ans, N, heap = 0, len(p), [(0, (0, 0))]\n        seen = set()\n        \n        while len(seen) < N:\n            w, (u, v) = heapq.heappop(heap)\n            if u in seen and v in seen: continue\n            seen.add(v)\n            ans += w\n            for j, (nx, ny) in enumerate(p):\n                if j not in seen and j!=v:\n                    heapq.heappush(heap, (abs(nx-p[v][0])+abs(ny-p[v][1]), (v, j)))\n        return ans", "class UnionFind(object):\n    def __init__(self,n):\n        self._parent = [0]*n\n        self._size = [1]*n\n        self.count = n\n        for i in range(n):\n            self._parent[i] = i\n            \n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return False\n        self.count -= 1\n        if self._size[rootp] > self._size[rootq]:\n            self._size[rootp] += self._size[rootq]\n            self._parent[rootq] = self._parent[q] = rootp\n        else:\n            self._size[rootq] += self._size[rootp]\n            self._parent[rootp] = self._parent[p] = rootq\n        return True\n    \n    def find(self, n):\n        while self._parent[n] != n:\n            self._parent[n] = self._parent[self._parent[n]]\n            n = self._parent[n]\n        return n\n    \n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n            \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])        \n        edges = []        \n        N = len(points)  \n        if N < 2: return 0\n        for i in range(N):\n            for j in range(i+1,N):\n                edges.append([i,j,findManhattanDistance(points[i],points[j])])        \n        edges.sort(key=lambda x:x[2])      \n            \n        uf = UnionFind(N)\n        edge_count, costs = 0,0\n        for u,v,w in edges:            \n            if(uf.union(u,v)):        \n                costs += w\n                edge_count +=1\n                if(edge_count == N - 1):\n                    break\n        return costs", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        result = 0\n        m = 0\n        q = [(0, 0, 0)]\n        visited = [0] * n\n        dis = [10 ** 9] * n\n        dis[0] = 0\n        while m < n:\n            w, j, i = heapq.heappop(q)\n            # print(j, i, w)\n            if visited[i]:\n                continue\n            visited[i] = 1\n            for j in range(n):\n                if j == i or visited[j]:\n                    continue\n                ww = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                if ww < dis[j]:\n                    dis[j] = ww\n                    heapq.heappush(q, (ww, i, j))\n            m += 1\n            result += w\n        return result", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dist = [[-1 for _ in points] for _ in points]\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                dist[i][j] = d\n                dist[j][i] = d\n        if not points or len(points) <= 1:\n            return 0\n        connected = [False for _ in points]\n        min_cost_pq = []\n        connected[0] = True\n        connected_count = 1\n        res = 0\n        for j in range(1, len(points)):\n            heapq.heappush(min_cost_pq, (dist[0][j], j))\n        while connected_count < len(points):\n            d, i = heapq.heappop(min_cost_pq)\n            if connected[i]:\n                continue\n            res += d\n            connected[i] = True\n            connected_count += 1\n            for j in range(len(points)):\n                if not connected[j]:\n                    heapq.heappush(min_cost_pq, (dist[i][j], j))\n        return res\n", "class UnionFind(object):\n    def __init__(self,n):\n        self._parent = [0]*n\n        self._size = [1]*n\n        self.count = n\n        for i in range(n):\n            self._parent[i] = i\n            \n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return False\n        self.count -= 1\n        if self._size[rootp] > self._size[rootq]:\n            self._size[rootp] += self._size[rootq]\n            self._parent[rootq] = self._parent[q] = rootp\n        else:\n            self._size[rootq] += self._size[rootp]\n            self._parent[rootp] = self._parent[p] = rootq\n        return True\n    \n    def find(self, n):\n        while self._parent[n] != n:\n            self._parent[n] = self._parent[self._parent[n]]\n            n = self._parent[n]\n        return n\n    \n    #def connected(self, p, q):\n    #    return self.find(p) == self.find(q)\n            \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []        \n        N = len(points)  \n        for i in range(N):\n            for j in range(i+1,N):\n                edges.append([i,j,findManhattanDistance(points[i],points[j])])        \n        edges.sort(key=lambda x:x[2])      \n            \n        uf = UnionFind(N)\n        edge_count, costs = 0,0\n        for u,v,w in edges:            \n            if(uf.union(u,v)):        \n                costs += w\n                edge_count +=1\n                if(edge_count == N - 1):\n                    break\n        return costs", "import numpy as np\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        \n        numNode=len(points)\n        if numNode==1:\n            return 0\n        \n        \n        totalCost=0\n        current=0\n        distance=[math.inf]*numNode\n        explored=set()\n        \n        for i in range(numNode-1):\n            x0,y0 = points[current]\n            explored.add(current)\n            \n            for j , (x,y) in enumerate(points):\n                if j in explored:\n                    continue\n                distance[j]=min(distance[j],abs(x0-x)+abs(y0-y))\n        \n            cost , current = min((c, index) for index, c in enumerate(distance))\n            distance[current]=math.inf\n            totalCost+=cost\n        \n        return totalCost\n\n", "class UnionFind(object):\n    def __init__(self,n):\n        self._parent = [0]*n\n        self._size = [1]*n\n        self.count = n\n        for i in range(n):\n            self._parent[i] = i\n            \n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return False\n        self.count -= 1\n        if self._size[rootp] > self._size[rootq]:\n            self._size[rootp] += self._size[rootq]\n            self._parent[rootq] = self._parent[q] = rootp\n        else:\n            self._size[rootq] += self._size[rootp]\n            self._parent[rootp] = self._parent[p] = rootq\n        return True\n    \n    def find(self, n):\n        while self._parent[n] != n:\n            self._parent[n] = self._parent[self._parent[n]]\n            n = self._parent[n]\n        return n\n    \n    #def connected(self, p, q):\n    #    return self.find(p) == self.find(q)\n            \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []        \n        N = len(points)  \n        if N < 2: return 0\n        for i in range(N):\n            for j in range(i+1,N):\n                edges.append([i,j,findManhattanDistance(points[i],points[j])])        \n        edges.sort(key=lambda x:x[2])      \n            \n        uf = UnionFind(N)\n        edge_count, costs = 0,0\n        for u,v,w in edges:            \n            if(uf.union(u,v)):        \n                costs += w\n                edge_count +=1\n                if(edge_count == N - 1):\n                    break\n        return costs", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #solution with Prim's algorithm\n        #start from a random node idx 0, use heap to store distance between two nodes and the nodes, calculate distances for node's haven't visited, put in heap. Next node we'll process is the one with shortest distance from previous, continue until all nodes are visited\n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        res, n = 0, len(points)\n        verticles = [(0, (0, 0))]\n        visited = set()\n        \n        while len(visited) < n:\n            d, (pre, cur) = heapq.heappop(verticles)\n            if cur in visited:  continue\n            res += d\n            visited.add(cur)\n            for nxt in range(n):\n                if nxt not in visited and nxt != cur:\n                    heapq.heappush(verticles, (manhattan(points[cur], points[nxt]), (cur, nxt)))\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def getCost(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        \n        res, N = 0, len(points)\n        seen = set()\n        vertices = [(0, (0, 0))]\n        \n        while len(seen) < N:\n            w, (u, v) = heapq.heappop(vertices)\n            if v in seen: continue\n            res += w\n            seen.add(v)\n            for j in range(N):\n                if j not in seen and j != v:\n                    heapq.heappush(vertices, (getCost(points[v], points[j]), (v, j)))\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n        ans, n = 0, len(points)\n        seen = set()\n        vertices = [(0, (0, 0))] # [(dist, ( , index)]\n        # first zero is distance, middle zero is dummy value, last zero is next vertice. \n        # so ai point (0, 0) the heap will add the edges[0], and ans += 0.\n\n        while len(seen) < n:\n            w, (u, v) = heapq.heappop(vertices)            \n            if v in seen: continue\n            ans += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    heapq.heappush(vertices, (manhattan(points[j], points[v]), (v, j)))    \n        return ans\n    \\\"\\\"\\\"\n            # select random start point\n        # find the node that 1) search all possible route costs least 2) not generate a loop 3) among the ones that are not selected \n        if len(points) <= 1: return 0\n        visited = [(points[0][0], points[0][1])]\n        mustgo = points[1:]\n        cost = 0\n        while mustgo:\n            route = dict()\n            for p in visited:\n                for m in mustgo:\n                    if (m[0], m[1]) in route.keys():\n                        route[(m[0], m[1])] = min(abs(p[0] - m[0]) + abs(p[1] - m[1]), route[(m[0], m[1])])\n                    else:\n                        route[(m[0], m[1])] = abs(p[0] - m[0]) + abs(p[1] - m[1])\n            for k, v in route.items():\n                if v == min(route.values()):\n                    cost += v                    \n                    visited.append(k)\n                    mustgo.remove([k[0],k[1]])\n        print((visited))\n        return cost\n    \\\"\\\"\\\"", "class Solution:\n            \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def func(x,y):\n            return abs(x[0]-y[0])+abs(x[1]-y[1])\n        \n        ans=0\n        n=len(points)\n        print(n)\n        s=set()\n        ver=[(0,(0,0))]\n        while len(s)<n:\n            res,(v1,v2)=heapq.heappop(ver)\n            if v1 in s and v2 in s:\n                continue\n                \n            \n            ans+=res\n            s.add(v2)\n\n            for i in range(n):\n                if i not in s and i!=v2:\n                    sol=func(points[i],points[v2])\n                    heapq.heappush(ver,(sol,(v2,i)))\n        return ans\n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        visited = [False] * len(points)\n        count = 0\n        distance = [[0]*len(points) for p in points]\n        for i in range(len(points)):\n            for j in range(len(points)):\n                distance[i][j] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                #distance[j][i] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n\n        cost = 0\n        visited[0] = True\n        n = len(points)\n        close = [1<<29]*n\n        for i in range(1,n):\n            close[i] = distance[0][i]\n            \n        for k in range(n-1):\n            minCost = 1<<29\n            v = None\n            for i in range(n):\n                if not visited[i] and minCost>close[i]:\n                    v = i\n                    minCost = close[i]\n                    \n            cost += minCost\n            visited[v] = True\n            for i in range(n):\n                if not visited[i]:\n                    close[i] = min(close[i],distance[v][i])\n        return cost\n        # return res           \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        result = 0\n        m = 0\n        q = [(0, 0)]\n        visited = [0] * n\n        dis = [10 ** 9] * n\n        dis[0] = 0\n        while m < n:\n            w, i = heapq.heappop(q)\n            # print(j, i, w)\n            if visited[i]:\n                continue\n            visited[i] = 1\n            for j in range(n):\n                if j == i or visited[j]:\n                    continue\n                ww = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                if ww < dis[j]:\n                    dis[j] = ww\n                    heapq.heappush(q, (ww, j))\n            m += 1\n            result += w\n        return result", "# class Solution:\n#     def minCostConnectPoints(self, points: List[List[int]]) -> int:\n#         manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n#         n, c = len(points), collections.defaultdict(list)\n#         for i in range(n):\n#             for j in range(i+1, n):\n#                 d = manhattan(points[i], points[j])\n#                 c[i].append((d, j))\n#                 c[j].append((d, i))\n#         cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n#         visited[0] = 1\n#         heapq.heapify(heap)\n#         while heap:\n#             d, j = heapq.heappop(heap)\n#             if not visited[j]:\n#                 visited[j], cnt, ans = 1, cnt+1, ans+d\n#                 for record in c[j]: heapq.heappush(heap, record)\n#             if cnt >= n: break        \n#         return ans\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa]\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        # sort based on cost (i.e. distance)\n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        ds = DisjointSet(n)\n        cnt = 0\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u, v)\n                res += cost\n                cnt += 1\n            if cnt == len(points) -1:\n                break\n        return res", "class Node:\n    def __init__(self,data,rank,node):        \n        self.data = data\n        self.rank = rank\n        self.node = node\n        \nclass UnionFind(object):\n    def __init__(self,n):\n        self._parent = [0]*n\n        self._size = [1]*n\n        self.count = n\n        for i in range(n):\n            self._parent[i] = i\n            \n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return\n        self.count -= 1\n        if self._size[rootp] > self._size[rootq]:\n            self._size[rootp] += self._size[rootq]\n            self._parent[rootq] = self._parent[q] = rootp\n        else:\n            self._size[rootq] += self._size[rootp]\n            self._parent[rootp] = self._parent[p] = rootq\n    \n    def find(self, n):\n        while self._parent[n] != n:\n            self._parent[n] = self._parent[self._parent[n]]\n            n = self._parent[n]\n        return n\n    \n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n            \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []        \n        for i,p1 in enumerate(points):\n            for j in range(i+1,len(points)):                \n                edges.append([i,j,findManhattanDistance(p1,points[j])])                \n        \n        edges = sorted(edges,key=lambda x:x[2])        \n        N = len(points)        \n        hashMap = {}        \n        for i in range(N):            \n            node = Node(i,0,None)\n            node.parent = node            \n            hashMap[node.data] = node\n        \n        \n        def Union(data1,data2):\n            \n            node1 = hashMap[data1]\n            node2 = hashMap[data2]\n            \n            p1 = findSet(node1)\n            p2 = findSet(node2)\n            \n            if(p1 == p2):\n                return False            \n        \n            if(p1.rank >= p2.rank):\n                p1.rank = p1.rank + 1 if(p1.rank == p2.rank) else p1.rank                \n                p2.parent = p1                \n            else:\n                p1.parent = p2            \n            return True        \n        \n        \n        def findSet(node):\n            while (node.parent != node):\n                node.parent = node.parent.parent\n                node = node.parent            \n            return node.parent\n        \n\n        edge_count = 0\n        costs = 0\n        \n        for u,v,w in edges:\n            \n            if(Union(u,v)):\n                costs += w\n                edge_count +=1\n                \n                \n            if(edge_count == N - 1):\n                break\n                    \n        \n        return costs", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        import heapq\n        \n        connect = list(range(N))\n        def find(x):\n            if connect[x]!=x:\n                connect[x] = find(connect[x])\n            return connect[x]\n        \n        def union(x, y):\n            if find(x)!=find(y):\n                connect[find(x)] = find(y)\n        \n        \n        q = []\n        for i in range(N):\n            for j in range(i):\n                w = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                q.append((w, i, j))\n        q.sort()\n        \n        res = 0\n        cnt = 0\n        for w, i, j in q:\n            if cnt == N-1:\n                break\n            if find(i) == find(j):\n                continue\n            else:\n                res += w\n                union(i, j)\n                cnt += 1\n        \n        return res\n                \n        \n        \n", "class Node:\n    def __init__(self,data,rank,node):        \n        self.data = data\n        self.rank = rank\n        self.node = node            \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []        \n        for i,p1 in enumerate(points):\n            for j in range(i+1,len(points)):                \n                edges.append([i,j,findManhattanDistance(p1,points[j])])                \n        \n        edges = sorted(edges,key=lambda x:x[2])        \n        N = len(points)        \n        hashMap = {}        \n        for i in range(N):            \n            node = Node(i,0,None)\n            node.parent = node            \n            hashMap[node.data] = node\n        \n        \n        def Union(data1,data2):            \n            node1 = hashMap[data1]\n            node2 = hashMap[data2]\n            \n            p1 = findSet(node1)\n            p2 = findSet(node2)\n            \n            if(p1 == p2):\n                return False            \n        \n            if(p1.rank >= p2.rank):\n                p1.rank = p1.rank + 1 if(p1.rank == p2.rank) else p1.rank                \n                p2.parent = p1                \n            else:\n                p1.parent = p2            \n            return True        \n        \n        \n        def findSet(node):\n            while (node.parent != node):\n                node.parent = node.parent.parent\n                node = node.parent            \n            return node.parent        \n        \n        edge_count = 0\n        costs = 0        \n        for u,v,w in edges:            \n            if(Union(u,v)):        \n                costs += w\n                edge_count +=1\n            if(edge_count == N - 1):\n                break\n        return costs", "class Node:\n    def __init__(self,data,rank,node):        \n        self.data = data\n        self.rank = rank\n        self.node = node            \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []        \n        for i,p1 in enumerate(points):\n            for j in range(i+1,len(points)):                \n                edges.append([i,j,findManhattanDistance(p1,points[j])])                \n        \n        edges = sorted(edges,key=lambda x:x[2])        \n        N = len(points)        \n        hashMap = {}        \n        for i in range(N):            \n            node = Node(i,0,None)\n            node.parent = node            \n            hashMap[node.data] = node\n        \n        \n        def Union(data1,data2):            \n            node1 = hashMap[data1]\n            node2 = hashMap[data2]\n            \n            p1 = findSet(node1)\n            p2 = findSet(node2)\n            \n            if(p1 == p2):\n                return False            \n        \n            if(p1.rank > p2.rank):\n                p1.rank = p1.rank + p2.rank\n                p2.parent = p1                \n            else:\n                p2.rank = p2.rank + p1.rank\n                p1.parent = p2            \n            return True        \n        \n        \n        def findSet(node):\n            while (node.parent != node):\n                node.parent = node.parent.parent\n                node = node.parent            \n            return node.parent        \n        \n        edge_count = 0\n        costs = 0        \n        for u,v,w in edges:            \n            if(Union(u,v)):        \n                costs += w\n                edge_count +=1\n            if(edge_count == N - 1):\n                break\n        return costs", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ans = 0\n        current_point_index = 0\n        visited_point_indeces = set()\n        distance_list = [float('inf')] * len(points)\n        \n        for i in range(len(points) - 1):\n            visited_point_indeces.add(current_point_index)\n            \n            for j in range(len(points)):\n                if j in visited_point_indeces: continue\n                    \n                x, y = points[current_point_index]\n                x0, y0 = points[j]\n                \n                distance_list[j] = min(distance_list[j], abs(y0 - y) + abs(x0 - x))\n                \n            distance_list[current_point_index] = float('inf')\n            delta, current_point_index = min([distance, index] for index, distance in enumerate(distance_list))\n            ans += delta\n            \n        return ans\n", "class Node:\n    def __init__(self,data,rank,node):        \n        self.data = data\n        self.rank = rank\n        self.node = node            \n        self.parent = self\n\nclass UnionFind(object):\n    def __init__(self,n):\n        self._parent = [0]*n\n        self._size = [1]*n\n        self.count = n\n        for i in range(n):\n            self._parent[i] = i\n            \n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return False\n        self.count -= 1\n        if self._size[rootp] > self._size[rootq]:\n            self._size[rootp] += self._size[rootq]\n            self._parent[rootq] = self._parent[q] = rootp\n        else:\n            self._size[rootq] += self._size[rootp]\n            self._parent[rootp] = self._parent[p] = rootq\n        return True\n    \n    def find(self, n):\n        while self._parent[n] != n:\n            self._parent[n] = self._parent[self._parent[n]]\n            n = self._parent[n]\n        return n\n    \n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n            \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []        \n        N = len(points)  \n        for i,p1 in enumerate(points):\n            for j in range(i+1,N):                \n                edges.append([i,j,findManhattanDistance(p1,points[j])])                \n        \n        edges = sorted(edges,key=lambda x:x[2])        \n              \n        hashMap = {}        \n        for i in range(N):            \n            node = Node(i,0,None)                     \n            hashMap[node.data] = node       \n            \n        uf = UnionFind(N)\n        edge_count = 0\n        costs = 0        \n        for u,v,w in edges:            \n            if(uf.union(u,v)):        \n                costs += w\n                edge_count +=1\n            if(edge_count == N - 1):\n                break\n        return costs", "class Node:\n    \n    \n    def __init__(self,data,rank,node):\n        \n        self.data = data\n        self.rank = rank\n        self.node = node\n        \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def findManhattanDistance(p1,p2):\n            \n            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n\n        \n        \n        \n        \n        \n        edges = []\n        \n        \n        \n        for i,p1 in enumerate(points):\n            for j in range(i+1,len(points)):\n                \n                edges.append([i,j,findManhattanDistance(p1,points[j])])\n                \n        \n        edges = sorted(edges,key=lambda x:x[2])\n        \n        N = len(points)\n        \n        hashMap = {}\n        \n        for i in range(N):\n            \n            node = Node(i,0,None)\n            node.parent = node\n            \n            hashMap[node.data] = node\n        \n        \n        \n        \n        def Union(data1,data2):\n            \n            node1 = hashMap[data1]\n            node2 = hashMap[data2]\n            \n            p1 = findSet(node1)\n            p2 = findSet(node2)\n            \n            if(p1 == p2):\n                return False\n            \n        \n            if(p1.rank >= p2.rank):\n                p1.rank = p1.rank + 1 if(p1.rank == p2.rank) else p1.rank\n                \n                p2.parent = p1\n                \n            else:\n                p1.parent = p2\n                \n            \n            return True\n        \n        \n        \n        def findSet(node):\n            \n            if(node.parent == node):\n                return node\n            \n            node.parent = findSet(node.parent)\n            \n            return node.parent\n        \n\n        edge_count = 0\n        costs = 0\n        \n        for u,v,w in edges:\n            \n            if(Union(u,v)):\n                costs += w\n                edge_count +=1\n                \n                \n            if(edge_count == N - 1):\n                break\n                    \n        \n        return costs\n                \n", "class Node:\n    \n    \n    def __init__(self,data,rank,node):\n        \n        self.data = data\n        self.rank = rank\n        self.node = node\n        \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []\n        \n        for i,p1 in enumerate(points):\n            for j in range(i+1,len(points)):\n                \n                edges.append([i,j,findManhattanDistance(p1,points[j])])\n                \n        \n        edges = sorted(edges,key=lambda x:x[2])\n        \n        N = len(points)\n        \n        hashMap = {}\n        \n        for i in range(N):\n            \n            node = Node(i,0,None)\n            node.parent = node\n            \n            hashMap[node.data] = node\n        \n        \n        \n        \n        def Union(data1,data2):\n            \n            node1 = hashMap[data1]\n            node2 = hashMap[data2]\n            \n            p1 = findSet(node1)\n            p2 = findSet(node2)\n            \n            if(p1 == p2):\n                return False\n            \n        \n            if(p1.rank >= p2.rank):\n                p1.rank = p1.rank + 1 if(p1.rank == p2.rank) else p1.rank\n                \n                p2.parent = p1\n                \n            else:\n                p1.parent = p2\n                \n            \n            return True\n        \n        \n        \n        def findSet(node):\n            \n            if(node.parent == node):\n                return node\n            \n            node.parent = findSet(node.parent)\n            \n            return node.parent\n        \n\n        edge_count = 0\n        costs = 0\n        \n        for u,v,w in edges:\n            \n            if(Union(u,v)):\n                costs += w\n                edge_count +=1\n                \n                \n            if(edge_count == N - 1):\n                break\n                    \n        \n        return costs", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dis(p1, p2):\n            x1, y1 = p1\n            x2, y2 = p2\n            return abs(x1-x2) + abs(y1-y2)\n        \n        size = len(points)\n        cost = 0\n        \n        idx = list(range(size))\n        \n        def find(x):\n            if x != idx[x]:\n                idx[x] = find(idx[x])\n            return idx[x]\n        \n        def union(x, y):\n            xx, yy = find(x), find(y)\n            if xx == yy:\n                return False\n            idx[xx] = yy\n            return True\n        \n        edges = []\n        for i in range(size):\n            for j in range(i+1, size):\n                distance = dis(points[i], points[j])\n                edges.append((distance, i, j))\n                \n        edges.sort()        \n        for dis, x, y in edges:        \n            if union(x, y):\n                cost += dis\n                size -= 1\n                if size == 1:\n                    return cost\n        return cost        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        result = 0\n        m = 0\n        q = [(0, 0)]\n        visited = [10 ** 9] * n\n        while m < n:\n            w, i = heapq.heappop(q)\n            # print(j, i, w)\n            if visited[i] < 0:\n                continue\n            visited[i] = -1\n            for j in range(n):\n                if j == i or visited[j] < 0:\n                    continue\n                ww = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                if ww < visited[j]:\n                    visited[j] = ww\n                    heapq.heappush(q, (ww, j))\n            m += 1\n            result += w\n        return result", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if not points:\n            return 0\n        n = len(points)\n        g = [[0]*n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                x,y = points[i]\n                xx,yy = points[j]\n                g[i][j] = g[j][i] = abs(x-xx) + abs(y-yy)\n        dist = [float('inf')] * n\n        dist[0] = 0\n        s = set(range(n))\n        heap = [(0,0)]  # PQ for (distance,node)\n        while heap:\n            d,u = heapq.heappop(heap)\n            if u not in s:\n                continue\n            s.remove(u)\n            for v in range(n):\n                if v in s and g[u][v] < dist[v]:\n                    dist[v] = g[u][v]\n                    heapq.heappush(heap,(dist[v],v))\n        # print(dist)\n        return sum(dist)\n            \n                    \n            \n", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        fathers = list(range(n))\n        queue = []\n        for i, p1 in enumerate(points):\n            for j in range(i+1, n):\n                p2 = points[j]\n                d = self.distance(p1, p2)\n                heapq.heappush(queue, (d, i*n+j, i, j))\n        \n        def find(fathers, v):\n            if fathers[v]!=v:\n                fathers[v]=find(fathers, fathers[v])\n            return fathers[v]\n        \n        def union(fathers, a, b):\n            rootA = find(fathers, a)\n            rootB = find(fathers, b)\n            if rootA!=rootB:\n                fathers[rootB]=rootA\n        \n        cnt = 0\n        edges = 0\n        while queue and edges<n-1:\n            d, _, i, j = heapq.heappop(queue)\n            rootI = find(fathers, i)\n            rootJ = find(fathers, j)\n            if rootI != rootJ:\n                cnt+=d\n                edges+=1\n                union(fathers, rootI, rootJ)\n        return cnt\n    \n    def distance(self, p1, p2):\n        return abs(p1[0]-p2[0])+abs(p1[1]-p2[1])", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(parent, i):\n            if parent[i] == i:\n                return i\n            return find(parent, parent[i])\n        \n        def apply_union(parent, rank, x, y):\n            xroot = find(parent, x)\n            yroot = find(parent, y)\n            if rank[xroot] < rank[yroot]:\n                parent[xroot] = yroot\n            elif rank[xroot] > rank[yroot]:\n                parent[yroot] = xroot\n            else:\n                parent[yroot] = xroot\n                rank[xroot] += 1\n        \n        ans = 0\n        V = len(points)\n        graph = []\n        for i in range(V):\n            for j in range(i):\n                v = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                graph.append([i,j,v])\n                \n        i, e = 0, 0\n        graph = sorted(graph, key=lambda item: item[2])\n        parent = []\n        rank = []\n        for node in range(V):\n            parent.append(node)\n            rank.append(0)\n        while e < V - 1:\n            u, v, w = graph[i]\n            i = i + 1\n            x = find(parent, u)\n            y = find(parent, v)\n            if x != y:\n                e = e + 1\n                ans+=w\n                apply_union(parent, rank, x, y)\n        return ans", "class Node:\n    def __init__(self,data,rank,node):        \n        self.data = data\n        self.rank = rank\n        self.node = node            \n        self.parent = self\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def findManhattanDistance(p1,p2):            \n            return abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []        \n        for i,p1 in enumerate(points):\n            for j in range(i+1,len(points)):                \n                edges.append([i,j,findManhattanDistance(p1,points[j])])                \n        \n        edges = sorted(edges,key=lambda x:x[2])        \n        N = len(points)        \n        hashMap = {}        \n        for i in range(N):            \n            node = Node(i,0,None)\n            #node.parent = node            \n            hashMap[node.data] = node\n        \n        \n        def Union(data1,data2):            \n            node1 = hashMap[data1]\n            node2 = hashMap[data2]\n            \n            p1 = findSet(node1)\n            p2 = findSet(node2)\n            \n            if(p1 == p2):\n                return False            \n        \n            if(p1.rank > p2.rank):\n                p1.rank = p1.rank + p2.rank\n                p2.parent = p1                \n            else:\n                p2.rank = p2.rank + p1.rank\n                p1.parent = p2            \n            return True        \n        \n        \n        def findSet(node):\n            while (node.parent != node):\n                node.parent = node.parent.parent\n                node = node.parent            \n            return node.parent        \n        \n        edge_count = 0\n        costs = 0        \n        for u,v,w in edges:            \n            if(Union(u,v)):        \n                costs += w\n                edge_count +=1\n            if(edge_count == N - 1):\n                break\n        return costs", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        res = 0\n        connected = 1\n        visited = set()\n        pq = list()\n        i = 0\n        while (connected < n):\n            visited.add(i)\n            for j in range(n):\n                if j not in visited:\n                    heappush(pq, (abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), j))\n            d, i = heappop(pq)\n            while (i in visited):\n                d, i = heappop(pq)\n            res += d\n            connected += 1\n        return res;", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        edges, n, cnt, ans = [], len(p), 1, 0\n        \n        def manhattan(x, y):\n            return abs(p[x][0]-p[y][0]) + abs(p[x][1]-p[y][1])\n        \n        edges = [(manhattan(i, j), (i, j)) \n                 for i in range(n) for j in range(i+1, n)]\n        heapq.heapify(edges)\n        \n        def union(x, y):\n            uf[find(x)] = find(y)\n        \n        def find(x):\n            if x != uf[x]:\n                uf[x] = find(uf[x])\n            return uf[x]\n        \n        uf = list(range(n))\n        while cnt < n:\n            d, (u, v) = heapq.heappop(edges)\n            if find(u)!=find(v):\n                ans += d\n                cnt += 1\n                union(u, v)\n        return ans    \n", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def cost(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] -b[1])\n        points = list(map(lambda x: (x[0], x[1]), points))\n        minDist = {p:float(\\\"inf\\\") for p in points}\n        \n        \n        point = points[0]\n        connected = set()\n        connected.add(point)\n        # q = []\n        totalCost = 0\n        for p in points:\n            if p != point:\n                minDist[p] = cost(point, p)\n        for i in range(1, len(points)):\n            minPoint = None\n            minCost = float(\\\"inf\\\") \n            for p in points:\n                if p not in connected and minDist[p] < minCost:\n                    minPoint = p\n                    minCost = minDist[p]\n            connected.add(minPoint)\n            totalCost += minCost\n            # update min list\n            for p in points:\n                if p != minPoint:\n                    minDist[p] = min(minDist[p], cost(minPoint, p))\n        return totalCost\n        # heapq.heappush(q, (cost(point, p), p))\n                \n                \n                \n        # connected = set()\n        # connected.add(point)\n        # totalCost = 0\n        # while len(q) > 0:\n        #     edgeCost, point = heapq.heappop(q)\n        #     if point in connected:\n        #         continue\n        #     connected.add(point)\n        #     totalCost += edgeCost\n        #     if len(connected) == len(points):\n        #         return totalCost\n        #     for p in points:\n        #         if p != point:\n        #             heapq.heappush(q, (cost(point, p), p))\n        # return totalCost", "class Unifind:\n    def __init__(self,n):\n        self.arr = list(range(n))\n        self.rank = [0]*n\n    def union(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        \n        if self.rank[a]<self.rank[b]:\n            a,b = b,a\n        \n        if self.rank[a]==self.rank[b]:\n            self.rank[a]+=1\n        \n        self.arr[b] = a\n        \n    def find(self,a):\n        if self.arr[a]!=a:\n            self.arr[a] = self.find(self.arr[a])\n        return self.arr[a]\n        \n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        manhatan = lambda i,j : -(abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]))\n        edges = sorted((manhatan(i,j),i,j) for i in range(len(points)) for j in range(i+1,len(points)))\n        #print(edges)\n        uf = Unifind(len(points))\n        count = 0\n        cost = 0\n        while count < len(points)-1:\n            c,i,j = edges.pop()\n            #if edge adds a cycle(both ends are already in)\n            if uf.find(i)!=uf.find(j):\n                cost-=c\n                count+=1\n                uf.union(i,j)\n                \n        #print(uf.arr)\n        return cost\n                \n                \n", "class Solution:\n    def calculateCost(self, i, j, points):\n        return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n    \n    def find(self, x, roots):\n        if roots[x] != x:\n            roots[x] = self.find(roots[x], roots)\n        return roots[x]\n\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if not points or len(points) < 2:\n            return 0\n        \n        n = len(points)\n        \n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                weight = self.calculateCost(i, j, points)\n                edges.append((weight, i, j))\n        edges.sort()\n        \n        roots = [i for i in range(n)]\n        \n        res = 0\n        components = n\n        for edge in edges:\n            weight, x, y = edge\n            root_x = self.find(x, roots)\n            root_y = self.find(y, roots)\n            if root_x != root_y:\n                components -= 1\n                res += weight\n                \n                if components == 1:\n                    break\n                \n                roots[root_x] = root_y\n        \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        result = 0\n        for i in range(1, len(points)):\n            for j in range(i):\n                edges.append((j, i, abs(points[j][1] - points[i][1]) + abs(points[j][0] - points[i][0])));\n        edges =  sorted(edges, key = lambda k : k[2])\n        treeId = []\n        for i in range(len(points)):\n            treeId.append(i)\n\n        for u,v,w in edges:\n            if treeId[u] != treeId[v]:\n                result += w\n                oldId = treeId[u]\n                newId = treeId[v]\n                for k in range(len(points)):\n                    if treeId[k] == oldId:\n                        treeId[k] = newId\n        return result\n", "class Unifindm:\n    def __init__(self,n):\n        self.arr = list(range(n))\n        self.rank = [0]*n\n    def union(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        \n        if self.rank[a]<self.rank[b]:\n            a,b = b,a\n        \n        if self.rank[a]==self.rank[b]:\n            self.rank[a]+=1\n        \n        self.arr[b] = a\n        \n    def find(self,a):\n        if self.arr[a]!=a:\n            self.arr[a] = self.find(self.arr[a])\n        return self.arr[a]\n\nclass Unifind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa]\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        manhatan = lambda i,j : -(abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]))\n        edges = sorted((manhatan(i,j),i,j) for i in range(len(points)) for j in range(i+1,len(points)))\n        #print(edges)\n        uf = Unifind(len(points))\n        count = 0\n        cost = 0\n        while count < len(points)-1:\n            c,i,j = edges.pop()\n            #if edge adds a cycle(both ends are already in)\n            if uf.find(i)!=uf.find(j):\n                cost-=c\n                count+=1\n                uf.union(i,j)\n                \n        #print(uf.arr)\n        return cost\n                \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n=len(points)\n        l=[[0 for i in range(n)] for j in range(n)]\n        for i in range(n-1):\n            for j in range(i+1,n):\n                res=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                l[i][j]=res\n                l[j][i]=res\n        def minKey():\n            m=sys.maxsize\n            minind = 0\n            for i in range(n):\n                if key[i]<m and vis[i]==0:\n                    m=key[i]\n                    minind=i\n            return minind\n        vis=[0]*n\n        key=[sys.maxsize]*n\n        key[0]=0\n        for i in range(n-1):\n            u=minKey()\n            vis[u]=1\n            for v in range(n):\n                if l[u][v] and vis[v]==0 and l[u][v]<key[v]:\n                    key[v]=l[u][v]\n        return sum(key)", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find_parent(parent,x):\n            if parent[x] == -1:\n                return x\n            return find_parent(parent,parent[x])\n        \n        def union(parent,x,y):\n            x_s = find_parent(parent,x)\n            y_s = find_parent(parent,y)\n            parent[x_s] = y_s\n        \n        def kruskals(edges):\n            parent = [-1]*len(points)\n            min_weight = 0\n            i = 0\n            j = 0\n            while j < len(points) - 1:\n                start,end,weight = edges[i]\n                x = find_parent(parent,start)\n                y = find_parent(parent,end)\n                i+=1\n                if x!=y:\n                    j+=1\n                    union(parent,x,y)\n                    min_weight += weight\n            return min_weight\n\n        edges = []\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                dis = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append([i,j,dis])\n        edges.sort(key = lambda x: x[2])\n        return kruskals(edges)\n", "class Unifind:\n    def __init__(self,n):\n        self.arr = list(range(n))\n        \n    def union(self,a,b):\n        self.arr[self.find(a)] = self.find(b)\n        \n    def find(self,a):\n        if self.arr[a]!=a:\n            self.arr[a] = self.find(self.arr[a])\n        return self.arr[a]\n        \n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        manhatan = lambda i,j : -(abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]))\n        edges = sorted((manhatan(i,j),i,j) for i in range(len(points)) for j in range(i+1,len(points)))\n        #print(edges)\n        uf = Unifind(len(points))\n        count = 0\n        cost = 0\n        while count < len(points)-1:\n            c,i,j = edges.pop()\n            #if edge adds a cycle(both ends are already in)\n            if uf.find(i)!=uf.find(j):\n                cost-=c\n                count+=1\n                uf.union(i,j)\n                \n        #print(uf.arr)\n        return cost\n                \n                \n", "class DisjointSet():\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1]*n \n\n    def find(self, x):\n        if self.parent[x] == x: return x \n        return self.find(self.parent[x])\n\n    def union(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n        if self.rank[px] > self.rank[py]:\n            self.parent[py] = px \n            self.rank[px] += self.rank[py] \n        else: \n            self.parent[px] = py \n            self.rank[py] += self.rank[px]\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        def ManhattanDistance(p1,p2):\n            x1,y1 = p1; \n            x2,y2 = p2;\n            return abs(x2-x1)+abs(y2-y1)\n\n        edges = [(ManhattanDistance(points[i], points[j]),i,j) for i in range(n) for j in range(i+1, n)]\n        edges.sort()\n\n        graph = DisjointSet(n)\n        ans = 0\n        \n        i = 0\n        for cost, u, v in edges:\n            if graph.find(u) != graph.find(v): \n                graph.union(u,v)\n                ans += cost \n                i += 1\n            if i == n-1: break\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        \n        distances = []\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                distances.append([i, j, self.dist(points[i], points[j])])\n        \n        distances.sort(key=lambda x: x[2])\n        \n        parent = []\n        for i in range(n):\n            parent.append(i)\n            \n        e = 0\n        i = 0\n        result = 0\n        while e < n-1:\n            u, v, w =  distances[i] \n            i = i + 1\n            x = self.find(parent, u) \n            y = self.find(parent ,v) \n  \n            # If including this edge does't cause cycle,  \n                        # include it in result and increment the index \n                        # of result for next edge \n            if x != y: \n                e = e + 1     \n                result += w\n                self.union(parent, x, y) \n        \n        return result\n            \n    def dist(self, p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    def find(self, parent, i): \n        if parent[i] == i: \n            return i \n        return self.find(parent, parent[i]) \n  \n    def union(self, parent, x, y): \n        xroot = self.find(parent, x) \n        yroot = self.find(parent, y) \n  \n        if xroot != yroot: \n            parent[yroot] = xroot ", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        if len(points) == 1:\n            return 0\n        \n        def manhattan(x1, x2):\n            return abs(x1[0] - x2[0]) + abs(x1[1] - x2[1])\n        \n        total_cost = 0\n        first_chosen = points.pop()\n        cost_heap = []\n        \n        for point in points:\n            heapq.heappush(cost_heap, [manhattan(point, first_chosen), point])\n\n        while cost_heap:\n            cost, new_point = heapq.heappop(cost_heap)\n            total_cost += cost\n            for i, [cost, point] in enumerate(cost_heap):\n                cost_heap[i][0] = min(cost, manhattan(point, new_point))\n            cost_heap.sort()\n            \n        return total_cost\n", "from heapq import nlargest\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        res = 0\n        visited = [False] * n\n        dist = [float(\\\"inf\\\")] * n\n        curr = 0\n        for i in range(n-1):\n            x1,y1 = points[curr]\n            visited[curr] = True\n            for j in range(n):\n                if not visited[j]:\n                    x2,y2 = points[j]\n                    dist[j] = min(dist[j], abs(x2-x1) + abs(y2-y1))\n                    \n            cost, curr = float(\\\"inf\\\"), -1\n            for i in range(len(dist)):\n                if dist[i] < cost:\n                    curr = i\n                    cost = dist[i]\n            dist[curr] = float(\\\"inf\\\")\n            res += cost\n            \n        return res\n                    \n        \n            ", "from queue import PriorityQueue\n\nclass Solution:\n    def findParent(self, parents, i):\n        if parents[i] is None:\n            return i\n        else:\n            return self.findParent(parents, parents[i])\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 0:\n            return 0\n        \n        edges = []\n        req_edges = len(points)-1\n        dist = 0\n        parents = [None] * len(points)\n        ranks = [0] * len(points)\n        \n        for i, p1 in enumerate(points):\n            for j, p2 in enumerate(points):\n                if i < j:\n                    edges.append([i, j, (abs(p1[0]-p2[0]) + abs(p1[1]-p2[1]))])\n        edges = sorted(edges, key=lambda x: x[2])\n        \n        for edge in edges:\n            parent_i = self.findParent(parents, edge[0])\n            parent_j = self.findParent(parents, edge[1])\n            if parent_i == parent_j:\n                continue\n            if ranks[parent_i] < ranks[parent_j]:\n                parents[parent_i] = parent_j\n            elif ranks[parent_i] > ranks[parent_j]:\n                parents[parent_j] = parent_i\n            else:\n                parents[parent_i] = parent_j\n                ranks[parent_j] += 1\n            dist += edge[2]\n\n            req_edges -= 1\n            if req_edges == 0:\n                break\n            \n        return dist\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        self.rank = [1 for _ in range(n)]\n        self.parent = [i for i in range(n)]\n        distance = []\n        for i in range(n-1):\n            for j in range(i+1,n):\n                dis = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                distance.append((dis,i,j))\n        distance.sort(key = lambda x:x[0])\n        ans = 0\n        count = 0\n        for dis,u,v in distance:\n            if self.find(u) == self.find(v):\n                continue\n            ans += dis\n            self.union(u,v)\n            count += 1\n            if count == n-1:\n                break\n        return ans\n    def union(self,a,b):\n        parenta = self.find(a)\n        parentb = self.find(b)\n        if parenta == parentb:\n            return \n        if self.rank[parenta] > self.rank[parentb]:\n            self.parent[parentb] = parenta\n            self.rank[parenta] += self.rank[parentb]\n        else:\n            self.parent[parenta] = parentb\n            self.rank[parentb] += self.rank[parenta]\n        return\n    def find(self,a):\n        if self.parent[a] == a:\n            return a\n        else:\n            self.parent[a] = self.find(self.parent[a])\n            return self.parent[a]\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def md(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        q = [md(points[0], p) for p in points]\n        #print(q)\n        res = 0\n        n = len(points)\n        for _ in range(n - 1):\n            d, j = min((d, j) for j, d in enumerate(q) if d > 0)\n            print((d, j))\n            res += d\n            q = [min(q[i], md(points[i], points[j])) for i in range(n)]\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n=len(points)\n        def dist(i,j):  #\u6c42\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\n            return abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n        \n        ds=[float('inf')]*n   #\u4e00\u70b9\u5230\u5176\u4ed6\u6240\u6709\u70b9\u7684\u8ddd\u79bb\n        \n        for i in range(1,n):   #\u6b64\u65f60\u5230\u5176\u4ed6\u6240\u6709\u70b9\u7684\u8ddd\u79bb\n            ds[i]=dist(0,i)\n        \n        res=0\n        for i in range(1,n):\n            cost=min(ds)\n            res+=cost\n            j=ds.index(cost)\n            ds[j]=float('inf')\n            for k in range(n):\n                if ds[k]==float('inf'):\n                    continue\n                ds[k]=min(ds[k],dist(j,k))\n        return res", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        \n        \n        ques = []\n        final = (1 << n) - 1\n        for i in range(n):\n            for j in range(i+1, n):\n                heapq.heappush(ques, (abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j))\n        \n        p = [i for i in range(n)]\n        k = [1 for i in range(n)]\n        components = n\n        res = 0\n        \n        def findp(x):\n            while x != p[x]:\n                x = p[x]\n            return x\n        \n        def union(x, y):\n            if k[x] > k[y]:\n                k[x] += k[y]\n                p[y] = x\n            else:\n                k[y] += k[x]\n                p[x] = y\n                \n        while components != 1:\n            \n            dist, one, two = heapq.heappop(ques)\n            pone = findp(one)\n            ptwo = findp(two)\n            # print(dist, one, two)\n            # print(p)\n            if pone != ptwo:\n                union(pone, ptwo)\n                components -= 1\n                res += dist\n        return res\n                \n            \n \n\n            \n        \n            \n        \n", "\nfrom collections import defaultdict\nimport heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        start = points[0]\n\\t\\t\n         \n        #Storing the data in parent Directory\n        dist = {}\n        N = len(points)\n\\t\\t# Using heap to find min wt\n        heap = [(0, tuple(start))]\n        while heap:\n            ddist, node = heapq.heappop(heap)\n            if node in dist:\n                continue\n            dist[node] = ddist\n            for neighbor in points:\n                if tuple(neighbor) not in dist:\n                    d = abs(node[0]-neighbor[0]) + abs(node[1]-neighbor[1])\n                    heapq.heappush (heap, (d, tuple(neighbor)))\n            if len(dist) == N:\n                break\n        return sum(dist.values()) if len(dist) == N else -1\n\n    \nclass Solution1:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        uf = {}\n\n        # create union find for the initial edges given \n        def find(edge):\n            uf.setdefault(edge, edge)\n            if uf[edge] != edge:\n                uf[edge] = find(uf[edge])\n            return uf[edge]\n\n        def union(edge1, edge2):\n            uf[find(edge1)] = find(edge2)\n\n       \n\n        # sort the new edges by cost\n        # if an edge is not part of the minimum spanning tree, then include it, else continue\n        cost_ret = 0\n        poss_mst = []\n        for p1 in points:\n            for p2 in points:\n                dist = abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n                poss_mst.append([tuple(p1),tuple(p2),dist])\n                \n        for c1, c2, cost in sorted(poss_mst, key=lambda x : x[2]):\n            if find(c1) != find(c2):\n                union(c1, c2)\n                cost_ret += cost\n\n        return cost_ret\n        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        dMat = [[-1 for j in range(n)] for i in range(n)]\n        \n        def d(p1, p2):\n            a, b = p1\n            c, d = p2\n            return abs(a-c) + abs(b-d)\n        \n        for i, p1 in enumerate(points):\n            for j, p2 in enumerate(points):\n                dMat[i][j] = d(p1, p2)\n        \n        key = [float('inf')] * n\n        parent = [None] * n\n        key[0] = 0\n        mstSet = [False] * n\n\n        parent[0] = -1\n\n        def minKey():\n            # Initilaize min value\n            min = float('inf')\n            for v in range(n):\n                if key[v] < min and mstSet[v] == False:\n                    min = key[v]\n                    min_index = v\n            return min_index\n\n        for cout in range(n):\n            u = minKey()\n            mstSet[u] = True\n            for v in range(n):\n                if dMat[u][v] > 0 and mstSet[v] == False and key[v] > dMat[u][v]:\n                    key[v] = dMat[u][v]\n                    parent[v] = u\n\n        res = 0\n        for v in range(n):\n            if parent[v] != -1:\n                u = parent[v]\n                res += dMat[u][v]\n        \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        edges = collections.defaultdict(dict)\n        n = len(points)\n        for i in range(n):\n            for j in range(i):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                d = abs(x1-x2) + abs(y1-y2)\n                edges[i][j] = d\n                edges[j][i] = d\n                \n                \n        ans = 0\n        visited = set([0])\n        cand = []\n        for j in edges[0]:\n            heapq.heappush(cand, [edges[0][j], j])\n        ans = 0\n        while len(visited) < n:\n            d, j = heapq.heappop(cand)\n            if j not in visited:\n                ans += d\n                visited.add(j)\n                for i in edges[j]:\n                    if i not in visited:\n                        heapq.heappush(cand, [edges[j][i], i])\n        return ans\n            \n", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        heap, total_cost = [], 0\n        for u in range(N-1):\n            for v in range(u+1, N):\n                heappush(heap, [dist(points[u], points[v]), u, v])\n        while heap:\n            cost, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                N -= 1\n                total_cost += cost\n                if N == 0:\n                    break\n        return total_cost\n\n    \n    \n    \n    \n    \n    \n    \n    \nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        dist = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        heap = []\n        for i in range(N-1):\n            for j in range(i+1, N):\n                heappush(heap, (dist(points[i], points[j]), i, j))\n        res = 0\n        while heap:\n            d, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                res += d\n                N -= 1\n                if N == 0:\n                    break\n        return res\n            \n\n\n    \n    \nclass Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: abs(p[0]) + abs(p[1]))\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            px, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p, dist) in enumerate(points):\n                newdist = distance(p, px)\n                if newdist < dist:\n                    points[i][1] = newdist\n        return total_cost        ", "class Solution:\n\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def manhattan(p1, p2):\n            if p1 == p2:\n                return 10**10\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        def makeGraph(points):\n            graph = []\n            for p1 in range(len(points)):\n                for p2 in range(p1):\n                    graph.append( (p2, p1, manhattan(points[p1], points[p2])) )\n            return graph\n        \n        def find(subsets, p1):\n            if subsets[p1][0] != p1:\n                subsets[p1][0] = find(subsets, subsets[p1][0])\n            return subsets[p1][0]\n        \n        def union(subsets, p1, p2):\n            p1root = find(subsets, p1)\n            p2root = find(subsets, p2)\n            \n            if subsets[p1root][1] > subsets[p2root][1]:\n                subsets[p2root][0] = p1root\n            elif subsets[p2root][1] > subsets[p1root][1]:\n                subsets[p1root][0] = p2root\n            else:\n                subsets[p1root][1] += 1\n                subsets[p2root][0] = p1root\n        \n        graph = makeGraph(points)\n        \n        edges = sorted(graph, key=lambda x: x[2])\n        subsets = [[x, 0] for x in range(len(points))]\n        \n        e = 0 #counts how many edges have been added\n        i = 0 #tracks location in edges array\n        total_cost = 0\n        \n        while e < len(points) - 1:\n            \n            p1, p2, cost = edges[i]\n            \n            if find(subsets, p1) != find(subsets, p2):               \n                union(subsets, p1, p2)\n                total_cost += cost\n                e += 1\n            else:\n                pass\n                #discard the edge\n            \n            i += 1\n        return total_cost", "class DisjointSet:\n    def __init__(self, n):\n        self.rank = {i:i for i in range(n)}\n        self.size = n\n        self.parent = {i:i for i in range(n)}\n        \n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n    \n    def union(self, i, j):\n        root_i, root_j = self.find(i), self.find(j)\n        if root_i == root_j:\n            return False\n        \n        if self.rank[root_i] > self.rank[root_j]:\n            self.parent[root_j] = root_i\n        elif self.rank[root_i] < self.rank[root_j]:\n            self.parent[root_i] = root_j\n        else:\n            self.parent[root_j] = root_i\n            self.rank[root_i] += 1\n        self.size -= 1\n        return True\n        \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ds = DisjointSet(n)\n        \n        d = []\n        for i in range(n):\n            for j in range(i, n):\n                d_ij = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                heapq.heappush(d, [d_ij, i, j])\n        \n        min_cost = 0\n        while ds.size > 1:\n            d_ij, i, j = heapq.heappop(d)\n            if ds.union(i, j):\n                min_cost += d_ij\n        return min_cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        # lets give each edge a weight\n        # an edge will be some point A to another point B\n        # we will store the distances in a minheap\n        # then we will perform union find to connect all points\n        # using prim's algorithm - we choose the minimum from the current point we are at building out the MST\n        if len(points) <= 1: return 0\n        N = len(points)\n        distances = [float('inf')] * N\n        seen = set()\n        ans = 0\n        curr = 0\n        for i in range(N-1):\n            x1,y1 = points[curr]\n            seen.add(curr)\n            for j in range(N):\n                x2,y2 = points[j]\n                if j in seen: continue\n                distances[j] = min(abs(x1-x2)+abs(y1-y2),distances[j])\n            delta,curr = min((d,j) for j,d in enumerate(distances))\n            distances[curr] = float('inf')\n            ans+= delta\n        return ans\n            \n", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = [[] for i in range(n)]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                md = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges[i].append((md, j))\n                edges[j].append((md, i))\n        i = 0\n        visited = set()\n        visited.add(i)\n        li = edges[i]\n        heapq.heapify(li)\n        result = 0\n        while li:\n            d, j = heapq.heappop(li)\n            if j not in visited:\n                visited.add(j)\n                result += d\n                if len(visited) == n:\n                    return result\n                for edge in edges[j]:\n                    if edge[1] not in visited:\n                        heapq.heappush(li, edge)\n        return result", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def manhattan(p1,p2):\n            return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n        q = []\n        for i in range(1,len(points)):\n            heapq.heappush(q, (manhattan(points[0],points[i]),0,i))\n        \n        network = set([0])\n        res = 0\n        while q and (len(network) < len(points)):\n            \n            d, prev, node = heapq.heappop(q)\n            \n            if node in network:\n                continue\n            \n            network.add(node)\n            res += d\n            \n            for neigh in range(len(points)):\n                if neigh not in network:\n                    heapq.heappush(q, (manhattan(points[neigh], points[node]), node, neigh))\n        \n        return res", "from heapq import heappop, heappush, heapify\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            dis[curr] = math.inf\n            res += delta\n            \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #   \u6700\u5c0f\u751f\u6210\u6811\n        N = len(points)\n        \n        if N <= 1:\n            return 0\n        \n        edges = []\n        for i in range(N):\n            p1 = points[i]\n            for j in range(i+1, N):\n                p2 = points[j]\n                cost = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n                edges.append((cost, i, j))\n        \n        edges.sort()    #   \u6309\u7167\u8ddd\u79bb\u5347\u5e8f\u6392\u5217\n        # print(edges)\n        \n        A = set()\n        B = set(range(N))\n\n        #   \u589e\u52a0\u8d77\u70b9\n        A.add(0)\n        B.discard(0)    \n            \n        rtv = 0\n        while len(B) > 0:\n            for idx,e in enumerate(edges):\n                c,a,b = e\n                if a in A and b in B:\n                    B.discard(b)\n                    A.add(b)\n                    # print(\\\"{} {} {}\\\".format(a,b,c))\n                    rtv += c\n                    edges.pop(idx)\n                    break\n                elif b in A and a in B:\n                    B.discard(a)\n                    A.add(a)\n                    # print(\\\"{} {} {}\\\".format(a,b,c))\n                    rtv += c\n                    edges.pop(idx)\n                    break\n        return rtv\n        \n", "import numpy as np\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # pre-processing, adjacency matrix for cost of edges;\n        if len(points) > 1:\n            edge_cost = []\n            for i in range(len(points)):\n                for j in range(i+1, len(points)):\n                    edge_cost.append((i, j, abs(points[j][0] - points[i][0]) + abs(points[j][1] - points[i][1])))\n\n            # now try to find the smallest edge to add, find more points to add. \n\n            edge_cost.sort(key=lambda x: x[2])\n\n            # print(edge_cost)\n\n            connected_component = set()\n\n            min_cost = 0\n\n            i = 0\n            \n    #         # when some element is not connectected\n            while len(connected_component) < len(points):\n                i = 0\n                while not ((edge_cost[i][0] in connected_component) ^ (edge_cost[i][1] in connected_component)) and len(connected_component)!= 0:\n                    i += 1\n                if i < len(edge_cost):\n                    current = edge_cost[i]\n                    min_cost += current[2]\n                    connected_component.add(current[0])\n                    connected_component.add(current[1])\n                    edge_cost.pop(i)\n                    # print(\\\"connected component: %s\\\" % connected_component)\n                else:\n                    print(\\\"Should never be here!\\\")\n            return min_cost\n        else:\n            return 0", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        res = 0\n        curr = 0\n        dis = [float('inf')] * n\n        explored = set()\n\n        for i in range(n - 1):\n            point_x, point_y = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored:\n                    continue\n                dis[j] = min(dis[j], abs(x - point_x) + abs(y - point_y))\n\n            delta, curr = min((d, j) for j, d in enumerate(dis))\n            dis[curr] = float('inf')\n            res += delta\n\n        return res\n", "from heapq import nlargest\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        res = 0\n        visited = [False] * n\n        dist = [float(\\\"inf\\\")] * n\n        curr = 0\n        for i in range(n-1):\n            x1,y1 = points[curr]\n            visited[curr] = True\n            for j in range(n):\n                if not visited[j]:\n                    x2,y2 = points[j]\n                    dist[j] = min(dist[j], abs(x2-x1) + abs(y2-y1))\n                    \n            cost, curr = float(\\\"inf\\\"), -1\n            for i in range(len(dist)):\n                if not visited[i] and dist[i] < cost:\n                    curr = i\n                    cost = dist[i]\n            res += cost\n            \n        return res\n                    \n        \n            ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1:\n            return 0\n        pq = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                temp = abs(points[j][1]-points[i][1]) + abs(points[j][0]-points[i][0])\n                heapq.heappush(pq, (temp, (i, j)))\n        \n        root = list(range(len(points)))\n        \n        def find(x):\n            if x != root[x]:\n                root[x] = find(root[x])\n            return root[x]\n            \n        def union(x, y):\n            rx, ry = find(x), find(y)\n            if rx == ry:\n                return False\n            root[rx] = root[ry]\n            return True\n        \n        res = 0\n        conn = 0\n        while conn < len(points)-1:\n            cost, xy = heapq.heappop(pq)\n            x, y = xy\n            \n            if union(x, y):\n                res += cost\n                conn += 1\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        a = points\n        n = len(a)\n        def d(i, j): return abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1])\n        q = []\n        dst = [float('inf')]*n\n        vis = [False] * n\n        def consider(du, u):\n            if vis[u] or du >= dst[u]: return\n            dst[u] = du\n            heappush(q, (du, u))\n        consider(0, 0)\n        while q:\n            du, u = heappop(q)\n            if vis[u]: continue\n            vis[u] = True\n            for v in range(n): consider(d(u, v), v)\n        return sum(dst)", "from heapq import heappush, heappop\nclass DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        self.sz[yr] = self.sz[xr]\n        return True\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        if len(points) == 1:\n            return 0\n        \n        def weight(i,j):\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        \n        edges = []\n        ans = 0\n        \n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                heappush(edges,(weight(i,j),i,j))\n        \n        uf = DSU(len(points)+1)\n        \n        while edges:\n            e = heappop(edges)\n            if uf.union(e[1],e[2]):\n                ans += e[0]\n                if uf.size(e[1]) == len(points):\n                    return ans\n                \n        # return ans\n", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def cost(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] -b[1])\n        points = list(map(lambda x: (x[0], x[1]), points))\n        point = points[0]\n        q = []\n        for p in points:\n            if p != point:\n                heapq.heappush(q, (cost(point, p), p))\n        connected = set()\n        connected.add(point)\n        totalCost = 0\n        while len(q) > 0:\n            edgeCost, point = heapq.heappop(q)\n            if point in connected:\n                continue\n            connected.add(point)\n            totalCost += edgeCost\n            if len(connected) == len(points):\n                return totalCost\n            for p in points:\n                if p != point:\n                    heapq.heappush(q, (cost(point, p), p))\n        return totalCost", "class Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: p[0] + p[1])\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            p1, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p2, dist) in enumerate(points):\n                points[i][1] = min(points[i][1], distance(p1, p2))\n        return total_cost\n    \nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        connections = [[u, v, dist(points[u], points[v])] for u in range(N-1) for v in range(u+1, N)]\n        connections.sort(key = lambda x:x[2])\n        total_cost, remain = 0, N-1\n        for u, v, cost in connections:\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                total_cost += cost\n                remain -= 1\n                if remain == 0:\n                    break\n        return total_cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        es = []\n        n = len(points)\n        for i, p in enumerate(points):\n            x, y = p\n            for j in range(i + 1, n):\n                pb = points[j]\n                x2, y2 = pb\n                val = abs(x - x2) + abs(y - y2)\n                es.append((val, i, j))\n        es.sort()\n        # print(es)\n        self.father = {i:i for i in range(n)}\n        ans = size = 0\n        for cost, u, v in es:\n            if self.find(u) != self.find(v):\n                ans += cost\n                self.union(u, v)\n                size += 1\n            if size == n - 1:\n                break\n        return ans\n        \n    def find(self, a):\n        path = []\n        nd = a\n        fa = self.father\n        while fa[nd] != nd:\n            path.append(nd)\n            nd = fa[nd]\n        root = nd\n        for nd in path:\n            fa[nd] = root\n        return root\n    \n    def union(self, a, b):\n        fa = self.father\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            fa[ra] = rb\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        costs = []\n        \n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                cost = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                costs.append((cost, i, j))\n                \n        costs.sort(key = lambda x: x[0])\n        \n        group_label = [i for i in range(len(points))]\n        result = 0\n        combined = 0\n        \n        \n        def find_group(target: int, group_label: List[int]) -> int:\n            path = []\n            while not target == group_label[target]:\n                path.append(target)\n                target = group_label[target]\n            for node in path:\n                group_label[node] = target\n            return target\n        \n        \n        def union_group(target: int, source: int, group_label: List[int]) -> int:\n            while not source == group_label[source]:\n                next_source = group_label[source]\n                group_label[source] = target\n                source = next_source\n            group_label[source] = target\n            \n        \n        while combined < len(points) - 1:\n            cost, target, source = costs.pop(0)\n            target_group = find_group(target, group_label)\n            source_group = find_group(source, group_label)\n            if not target_group == source_group:\n                union_group(target_group, source, group_label)\n                result += cost\n                combined += 1\n                \n        return result\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(u,v):\n            return abs(points[u][0]-points[v][0])+abs(points[u][1]-points[v][1])\n        n = len(points)\n        ret = 0\n        visited = [False]*n\n        visited[0] = True\n        closest = [0]*n\n        for i in range(1,n): closest[i] = dist(0,i)\n        for _ in range(n-1):\n            mini = float('inf')\n            node = -1\n            for i in range(n):\n                if not visited[i] and closest[i] < mini:\n                    mini = closest[i]\n                    node = i\n            ret += mini\n            visited[node] = True\n            for i in range(n):\n                if not visited[i]: closest[i] = min(closest[i],dist(i,node))\n        return ret", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        \n        dist_arr = []\n        for i in range(n - 1):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                dist_arr.append((dist, i, j))\n        heapq.heapify(dist_arr)\n        \n        \n        root = [i for i in range(n)]\n        \n        def find(n):\n            if root[n] != n:\n                root[n] = find(root[n])\n            return root[n]\n        \n        def union(x, y):\n            s1 = find(x)\n            s2 = find(y)\n            if s1 != s2:\n                root[s2] = root[s1]\n                return 1\n            return 0\n                \n        res = 0\n        count = 0\n        while count < n - 1:\n            dist, x, y = heapq.heappop(dist_arr)\n            if union(x, y) == 1:\n                res += dist\n                count += 1\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        l = len(points)\n        if (l == 1):\n            return 0        \n        segs = []\n        \n        for idx1 in range(l):            \n            for idx2 in range(idx1+1, l):\n                dist = abs(points[idx1][0] - points[idx2][0]) + abs(points[idx1][1] - points[idx2][1])\n                segs.append((idx1, idx2, dist))\n\n        segs.sort(key = lambda x: x[2])\n\n        parent = [x for x in range(l)]\n        \n        def getParent(idx:int) -> int:\n            if parent[idx] == idx:\n                return idx\n            return getParent(parent[idx])\n        \n        self.f = 1\n        def union(idx1:int, idx2:int, price:int) -> int:\n            p1 = getParent(idx1)\n            p2 = getParent(idx2)\n            \n            if (p1 == p2):\n                return 0\n            else:\n                if (self.f == 0):\n                    parent[p2] = p1\n                else:\n                    parent[p1] = p2\n                self.f = 1 - self.f\n                return price        \n        \n        ans = 0 \n        \n        lines = 0\n        while(segs and lines < l - 1):\n            s = segs.pop(0)\n            off = union(s[0], s[1], s[2])\n            ans += off\n            if (off > 0):\n                lines += 1\n            \n            \n        return ans\n            \n            \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        if N == 1: return 0\n        \n        # Kruskal's algorithm\n        \n        # Sort the edges by cost\n        edges = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                edges.append((dist, i, j))\n        edges.sort()\n        \n        # Union find utility\n        roots = [i for i in range(N)]\n        def find(i):\n            if roots[i] != i:\n                roots[i] = find(roots[i])\n            return roots[i]\n    \n        def join(i, j):\n            ri, rj = find(i), find(j)\n            roots[ri] = rj\n            \n        i = cnt = 0\n        res = 0\n        while cnt < N - 1:\n            d, x, y = edges[i]\n            i += 1\n            rx, ry = find(x), find(y)\n            if find(x) == find(y): # If already connected, cannot use this edge\n                continue\n            join(rx, ry)\n            cnt += 1\n            res += d\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        res = 0\n        curr = 0 \n        dis = [float('inf')] * n\n        explored = set()\n\n        for i in range(n - 1):\n            point_x, point_y = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored:\n                    continue\n                dis[j] = min(dis[j], abs(x - point_x) + abs(y - point_y))\n\n            delta, curr = min((d, j) for j, d in enumerate(dis))\n            dis[curr] = float('inf')\n            res += delta\n\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt + 1, ans+d\n                for record in c[j]: \n                    if not visited[record[1]]:\n                        heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans if cnt >= n else 0 \n    \n#         def manhattan(x, y):\n#             return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n#         ans, n = 0, len(p)\n#         seen = set()\n#         vertices = [(0, (0, 0))]\n        \n#         while len(seen) < n:\n#             # print(vertices, seen)\n#             w, (u, v) = heapq.heappop(vertices)            \n#             if v in seen: continue\n#             ans += w\n#             seen.add(v)\n#             for j in range(n):\n#                 if j not in seen and j!=v:\n#                     heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))\n", "class Solution:\n    def minCostConnectPoints(self, points) -> int:\n        graph = defaultdict(list)\n        for i in range(len(points)):\n            x, y = points[i]\n            for j in range(len(points)):\n                x1, y1 = points[j]\n                if i != j:\n                    graph[i].append((abs(x-x1)+abs(y-y1), j))\n        start = 0\n        res = 0\n        visited = {start}\n        min_heap = []\n        for cost, neighbor in graph[start]:\n            heapq.heappush(min_heap, (cost, neighbor))\n        while len(visited) < len(points):\n            cost, next_node = heapq.heappop(min_heap)\n            if next_node not in visited:\n                visited.add(next_node)\n                res += cost \n                for next_cost, next_neighbor in graph[next_node]:\n                    if next_neighbor not in visited:\n                        heapq.heappush(min_heap, (next_cost, next_neighbor))\n        return res ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def manhattan(p1,p2):\n            return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n        q = []\n        for i in range(1,len(points)):\n            heapq.heappush(q, (manhattan(points[0],points[i]),0,i))\n        \n        network = set([0])\n        res = 0\n        while q and (len(network) < len(points)):\n            \n            d, i, j = heapq.heappop(q)\n            \n            if j in network:\n                continue\n            \n            network.add(j)\n            res += d\n            \n            for k in range(len(points)):\n                if (k != j) and (k not in network):\n                    heapq.heappush(q, (manhattan(points[k], points[j]), j, k))\n        \n        return res", "class Solution:\n    def minCostConnectPoints(self, points) -> int:\n        graph = defaultdict(list)\n        for i in range(len(points)):\n            x, y = points[i]\n            for j in range(len(points)):\n                x1, y1 = points[j]\n                if i != j:\n                    graph[i].append((abs(x-x1)+abs(y-y1), j))\n        start = 0\n        res = 0\n        visited = {start}\n        min_heap = []\n        for md, neighbor in graph[start]:\n            heapq.heappush(min_heap, (md, neighbor))\n        while len(visited) < len(points):\n            md, next_node = heapq.heappop(min_heap)\n            if next_node not in visited:\n                visited.add(next_node)\n                res += md \n                for nxt_md, next_neighbor in graph[next_node]:\n                    if next_neighbor not in visited:\n                        heapq.heappush(min_heap, (nxt_md, next_neighbor))\n        return res ", "class dsu:\n    def __init__(self,n):\n        self.parents = [i for i in range(n)]\n        self.rank = [0 for i in range(n)]\n    def find(self,u):\n        if u != self.parents[u]:\n            self.parents[u] = self.find(self.parents[u])\n        return self.parents[u]\n    def union(self,u,v):\n        pu = self.parents[u]\n        pv = self.parents[v]\n        if pu != pv:\n            if self.rank[pu] < self.rank[pv]:\n                self.parents[pu] = pv\n            elif self.rank[pu] > self.rank[pv]:\n                self.parents[pv] = pu\n            else:\n                self.parents[pu] = pv\n                self.rank[pv] += 1\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def get_dist(i,j):\n            return abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n        h = []\n        n = len(points)\n        uf = dsu(n)\n        for i in range(n):\n            for j in range(i):\n                heapq.heappush(h,(get_dist(i,j),i,j))\n        # print(h)\n        cost = 0\n        count = 0\n        while h:\n            c,u,v = heapq.heappop(h)\n            if uf.find(u) != uf.find(v):\n                uf.union(u,v)\n                cost += c\n                count += 1\n            if count >=  n-1:break\n        return cost", "class Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                        \n        ans, n, vis, pq, i = 0, len(a), set([0]), [], 0\n        rem = set(range(1, n))\n        while len(vis) < n:            \n            for j in rem: heappush(pq, (abs(a[i][0]-a[j][0]) + abs(a[i][1] - a[j][1]), j))\n            while pq[0][1] in vis: heappop(pq)\n            val, i = heappop(pq)\n            vis.add(i); rem.discard(i)\n            ans += val            \n        return ans                                            ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ind = 0\n        distance = [float('inf')]*n\n        visited = [False] * n\n        total_cost = 0\n        for cnt in range(n):\n            x0,y0 = points[ind][0],points[ind][1]\n            for i in range(n):\n                if visited[i]:\n                    continue\n                distance[i] = min(distance[i],abs(points[i][0]-x0) + abs(points[i][1]-y0))\n            dis,ind = min((d,i) for i,d in enumerate(distance))\n            visited[ind] = True\n            total_cost += dis\n            distance[ind] = float('inf')\n        return total_cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(roots, x):\n            if x != roots[x]:\n                roots[x] = find(roots, roots[x])    # compress\n            return roots[x]\n\n        n = len(points)\n        manhattan = lambda a, b: abs(a[0] - b[0]) + abs(a[1] - b[1])\n        heap = []\n        roots = list(range(n))\n        size = [1 for i in range(n)]\n        res = 0\n\n        # \u5148\u628a\u6240\u6709\u8282\u70b9\u6309\u7167\u8ddd\u79bb\u5b58\u653e\u5230 heap \u4e2d\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = manhattan(points[i], points[j])\n                heap.append((d, (i, j)))\n\n        # \u5806\u5316\n        heapq.heapify(heap)\n\n        while heap:\n            d, (i, j) = heapq.heappop(heap)\n            root1 = find(roots, i)\n            root2 = find(roots, j)\n\n            # if root1 != root2:\n            #     res += d\n            #     # union by rank\n            #     if size[root1] < size[root2]:\n            #         roots[root1] = root2\n            #         size[root2] += size[root1]\n            #         if size[root2] == n: break\n            #     else:\n            #         roots[root2] = root1\n            #         size[root1] += size[root2]\n            #         if size[root1] == n: break\n\n            if root1 != root2:\n                res += d\n                # union by rank\n                roots[root2] = root1\n                size[root1] += size[root2]\n                if size[root1] == n: break\n\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(a,b,c,d):\n            return abs(a-c)+abs(b-d)\n        res = 0\n        if len(points) <= 1: return 0\n        r = 0\n        visited = set()\n        k = defaultdict(lambda:999999999)\n        k[tuple(points[0])] = 0 # source vertex\n        for _ in range(len(points)):\n            m = float('inf')\n            cand = ()\n            for point in k:\n                if k[point] < m and point not in visited:\n                    cand = point\n                    m = k[point]\n            visited.add(cand)\n            \n            for point in points:\n                p = tuple(point)\n                if p != cand and p not in visited and dist(cand[0], cand[1], p[0], p[1]) < k[p]:\n                    k[p] = dist(cand[0], cand[1], p[0], p[1]) \n                    # res += k[p]\n        print((k, sum(k.values())))\n    \n        return sum(k.values())\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt + 1, ans+d\n                for record in c[j]: \n                    if not visited[record[1]]:\n                        heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans  \n    \n#         def manhattan(x, y):\n#             return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n#         ans, n = 0, len(p)\n#         seen = set()\n#         vertices = [(0, (0, 0))]\n        \n#         while len(seen) < n:\n#             # print(vertices, seen)\n#             w, (u, v) = heapq.heappop(vertices)            \n#             if v in seen: continue\n#             ans += w\n#             seen.add(v)\n#             for j in range(n):\n#                 if j not in seen and j!=v:\n#                     heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))\n", "from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = defaultdict(list)\n        for i in range(len(points)):\n            for j in range(len(points)):\n                if i != j:\n                    parent_x, parent_y = points[i]\n                    child_x, child_y = points[j]\n                    distance = abs(child_x - parent_x) + abs(child_y - parent_y)\n                    edges[i].append((distance, j))\n        \n        heap = [(0, 0, 0)]\n        seen_points = set()\n        total_distance = 0\n        \n        while len(seen_points) < len(points):\n            distance, parent_point, child_point = heapq.heappop(heap)\n            while child_point in seen_points:\n                distance, parent_point, child_point = heapq.heappop(heap)\n                \n            seen_points.add(child_point)\n            total_distance += distance\n            \n            for distance, child_child_point in edges[child_point]:\n                if child_child_point not in seen_points:\n                    heapq.heappush(heap, (distance, child_point, child_child_point))\n        \n        return total_distance\n                    \n                    \n                    \n                    \n                    \n", "class Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                \n        n = len(a)\n        if n <= 1: return 0\n        d = defaultdict(list)\n        min_val = float('inf')\n        min_i = min_j = None\n        for i in range(n-1):            \n            for j in range(i+1, n):                \n                val = abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1])\n                d[i].append((val, i, j))                         \n                d[j].append((val, j, i))                         \n                if min_val > val: \n                    min_val, min_i, min_j = val, i, j\n                    \n        for i in range(n): heapify(d[i])                \n        q = [heappop(d[i]) for i in (min_i, min_j)]      \n        heapify(q)        \n        ans, cur = 0, set()\n        while len(cur) < n:            \n            val, i, j = heappop(q)\n            if i not in cur or j not in cur:                 \n                ans += val\n                # print(ans, i, j, q)\n            cur.add(i); cur.add(j)\n            while d[i] and d[i][0][2] in cur: heappop(d[i])\n            if d[i]: heappush(q, heappop(d[i]))\n            while d[j] and d[j][0][2] in cur: heappop(d[j])\n            if d[j]: heappush(q, heappop(d[j]))            \n        return ans                ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:        \n        vertices = len(points)\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)] for row in range(vertices)]\n        for i in range(self.V):\n            for j in range(self.V):\n                if i == j:\n                    self.graph[i][j] = 0\n                else:\n                    self.graph[i][j]= abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        return self.primMST()\n\n    def minKey(self, key, mstSet):\n        min = math.inf\n        for v in range(self.V):\n            if key[v] < min and mstSet[v] == False:\n                min = key[v]\n                min_index = v\n        return min_index\n \n    def primMST(self):\n        key = [math.inf] * self.V\n        parent = [None] * self.V\n        key[0] = 0\n        mstSet = [False] * self.V\n \n        parent[0] = -1\n \n        for cout in range(self.V):\n            u = self.minKey(key, mstSet)\n            mstSet[u] = True\n            for v in range(self.V):\n                if self.graph[u][v] > 0 and mstSet[v] == False and key[v] > self.graph[u][v]:\n                        key[v] = self.graph[u][v]\n                        parent[v] = u       \n        res = 0\n        for i in range(1, self.V):\n            res += self.graph[i][parent[i]]\n        return res", "class Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                \n        n = len(a)\n        if n <= 1: return 0\n        d = defaultdict(list)\n        min_val, min_i = float('inf'), None        \n        for i in range(n-1):            \n            for j in range(i+1, n):                \n                val = abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1])\n                d[i].append((val, i, j)); d[j].append((val, j, i))                         \n                if min_val > val: min_val, min_i = val, i\n                    \n        for i in range(n): heapify(d[i])                \n        q = [heappop(d[min_i])]      \n        heapify(q)        \n        ans, cur = 0, set([min_i])\n        while len(cur) < n:            \n            val, i, j = heappop(q)\n            if j not in cur: ans += val\n            cur.add(j)\n            while d[i] and d[i][0][2] in cur: heappop(d[i])\n            if d[i]: heappush(q, heappop(d[i]))\n            while d[j] and d[j][0][2] in cur: heappop(d[j])\n            if d[j]: heappush(q, heappop(d[j]))            \n        return ans                ", "class Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: abs(p[0]) + abs(p[1]))\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            p1, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p2, dist) in enumerate(points):\n                newdist = distance(p1, p2)\n                if newdist < dist:\n                    points[i][1] = newdist\n        return total_cost        ", "class Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                        \n        n, vis, ans, pq, i = len(a), set([0]), 0, [], 0\n        rem = set(range(1, n))\n        while len(vis) < n:            \n            for j in rem: heappush(pq, (abs(a[i][0]-a[j][0]) + abs(a[i][1] - a[j][1]), j))\n            while pq[0][1] in vis: heappop(pq)\n            val, i = heappop(pq)\n            vis.add(i); rem.discard(i)\n            ans += val            \n        return ans                                            ", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        ans, ct,n = 0,0, len(p)\n        seen = set()\n        vertices = [(0, (0, 0))]\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        while ct<n:\n            # print(vertices, seen)\n            w, (u, v) = heapq.heappop(vertices)            \n            if u in seen and v in seen: \n                continue\n            ans += w\n            seen.add(v)\n            ct+=1\n \n            for j in range(n):\n                if j not in seen and j!=v:\n                    heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))\n                    \n        return ans", "import heapq\n'''\n1584. Min Cost to Connect All Points.  Medium\n\nYou are given an array points representing integer coordinates\nof some points on a 2D-plane, where points[i] = [xi, yi].\n\nThe cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance\nbetween them: |xi - xj| + |yi - yj|,\nwhere |val| denotes the absolute value of val.\n\nReturn the minimum cost to make all points connected.\nAll points are connected if there is exactly one simple path\nbetween any two points.\n\nExample 1:\nInput: points = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nOutput: 20\nExplanation:\n\nWe can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points.\n\nExample 2:\nInput: points = [[3, 12], [-2, 5], [-4, 1]]\nOutput: 18\n\nExample 3:\nInput: points = [[0, 0], [1, 1], [1, 0], [-1, 1]]\nOutput: 4\n\nExample 4:\nInput: points = [[-1000000, -1000000], [1000000, 1000000]]\nOutput: 4000000\n\nExample 5:\nInput: points = [[0, 0]]\nOutput: 0\n\nConstraints:\n1 <= points.length <= 1000\n-106 <= xi, yi <= 106\nAll pairs (xi, yi) are distinct.\n\nAccepted 1,742 / 5,429 submissions.\n'''\ndef man_dist_4(x,y,u,v):\n    return abs(x - u) + abs(y - v)\n\ndef man_dist_pt(ptA, ptB):\n    return abs(ptA[0] - ptB[0]) + abs(ptA[1] - ptB[1])\n\n\nclass Solution:\n\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n\n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n\n        ans, n = 0, len(p)\n        seen = set()\n        vertices = [(0, (0, 0))]\n\n        while len(seen) < n:\n            # print(vertices, seen)\n            w, (u, v) = heapq.heappop(vertices)\n            if u in seen and v in seen: continue\n            ans += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))\n        return ans\n\n###############################################################################\n\nclass SolutionTle:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) < 2:\n            return 0\n        points.sort()\n        lost = {(x, y) for x, y in points}\n        found = set()\n\n        x, y = lost.pop()\n        found.add((x, y))\n        minc = float('inf')\n        for u, v in lost:\n            md = man_dist_4(x,y,u,v)\n            if minc > md:\n                minc = md\n                minu = u\n                minv = v\n        cost = minc\n        lost.remove((minu, minv))\n        found.add((minu, minv))\n\n        while lost:\n            minc = float('inf')\n            for x, y in found:\n                for u, v in lost:\n                    md = man_dist_4(x,y,u,v)\n                    if (minc > md):\n                        minc = md\n                        minu = u\n                        minv = v\n            cost += minc\n            lost.remove((minu, minv))\n            found.add((minu, minv))\n\n        return cost\n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if not points: return 0        \n        \n        n = len(points)\n        dist = [[0] * n for _ in range(n)]\n        for i in range(n):\n            x1, y1 = points[i]\n            for j in range(n):\n                x2, y2 = points[j]\n                dist[i][j] = abs(x1 - x2) + abs(y1 - y2)\n                \n        origin = 0\n        q = []\n        for j, d in enumerate(dist[0]):\n            heapq.heappush(q, (d, j))\n        \n        ans = 0\n        visited = set([0])\n        while len(visited) < n:\n            d, child = heapq.heappop(q)\n            if child not in visited:\n                ans += d\n                visited.add(child)\n                for j, n_d in enumerate(dist[child]):\n                    if j not in visited:\n                        heapq.heappush(q, (n_d, j))\n        return ans\n            \n        \n        \n        \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        for i in range(len(points)-1):\n            for j in range(i+1,len(points)):\n                edges.append((i,j,abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])))\n        \n        edges.sort(key=lambda x: x[2])\n        \n        seen = dict()\n        ct=0\n        ans = 0\n        \n        for i in range(len(edges)):\n            edge = edges[i]\n                \n            if edge[0] not in seen or edge[1] not in seen:\n                if edge[0] not in seen and edge[1] not in seen:\n                    seen[edge[0]] = ct\n                    seen[edge[1]] = ct\n                    ct+=1\n                if edge[0] not in seen and edge[1] in seen:\n                    seen[edge[0]] =seen[edge[1]]\n                if edge[0] in seen and edge[1] not in seen:\n                    seen[edge[1]] =seen[edge[0]]\n                \n                \n                ans += edge[2]\n                \n            if edge[0] not in seen and edge[1] in seen:\n                seen[edge[0]] = seen[edge[1]]\n                \n                ans+=edge[2]\n            \n            if edge[1] not in seen and edge[0] in seen:\n                seen[edge[1]] = seen[edge[0]]\n                \n                ans+=edge[2]\n                \n            if edge[0] in seen and edge[1] in seen:\n                if seen[edge[0]]!=seen[edge[1]]:\n                    for key in seen:                        \n                        if key!=edge[1] and seen[key]==seen[edge[1]]:\n                            seen[key]=seen[edge[0]]\n                    \n                    seen[edge[1]] = seen[edge[0]]\n                    \n                    ans+=edge[2]\n                    \n        \n        \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        \n        n = len(points)\n        dist = [[0] * n for _ in range(n)]\n        res = 0\n        \n        for i in range(n):\n            p = points[i]\n            for j in range(n):\n                nei = points[j]\n                dist[i][j] = abs(p[0] - nei[0]) + abs(p[1] - nei[1])\n        \n        res = self.prim(n, dist, 0)\n        return res\n     \n    def prim(self, n, dist, start):\n        visited = set()\n        res = 0\n        nei = [[0, 0, 0]]\n        heapq.heapify(nei)\n        \n        while len(visited) != n:\n            weight, current, dummy = heapq.heappop(nei)\n            if current in visited:\n                continue\n            res += weight\n            visited.add(current)\n            \n            for i in range(n):\n                if i not in visited:\n                    heapq.heappush(nei, [dist[current][i], i, i])\n        \n        return res\n            \n            \n        \n        \n", "from heapq import heappush, heappop\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def helper(i, j):\n            return abs(points[j][0] - points[i][0]) + \\\\\n                   abs(points[j][1] - points[i][1])\n        \n        g = defaultdict(lambda: {}); n = len(points)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                g[i][j] = g[j][i] = helper(i,j)\n\n                \n        visited = set(); res = 0; q = []; cnt=0\n        heappush(q, (0, 0)) # u:0, cost:0\n        while q:\n            cost, u = heappop(q)\n            if u in visited: continue\n            res += cost\n            cnt += 1\n            for v, w in g[u].items():\n                heappush(q, (w, v))\n            visited.add(u)\n            if cnt >= n: break\n        return res\n        \n        \n    \n\\\"\\\"\\\"\n[[0,0],[2,2],[3,10],[5,2],[7,0]]\n[[3,12],[-2,5],[-4,1]]\n[[0,0],[1,1],[1,0],[-1,1]]\n[[-1000000,-1000000],[1000000,1000000]]\n[[0,0]]\n\\\"\\\"\\\"            ", "class Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                \n        n = len(a)\n        if n <= 1: return 0\n        d = defaultdict(list)\n        min_val, min_i = float('inf'), None        \n        for i in range(n-1):            \n            for j in range(i+1, n):                \n                val = abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1])\n                d[i].append((val, i, j)); d[j].append((val, j, i))                         \n                if min_val > val: \n                    min_val, min_i = val, i\n                    \n        for i in range(n): heapify(d[i])                \n        q = [heappop(d[min_i])]      \n        heapify(q)        \n        ans, cur = 0, set()\n        while len(cur) < n:            \n            val, i, j = heappop(q)\n            if i not in cur or j not in cur: ans += val\n            cur.add(i); cur.add(j)\n            while d[i] and d[i][0][2] in cur: heappop(d[i])\n            if d[i]: heappush(q, heappop(d[i]))\n            while d[j] and d[j][0][2] in cur: heappop(d[j])\n            if d[j]: heappush(q, heappop(d[j]))            \n        return ans                ", "class Node:\n    def __init__(self,data,rank,node):        \n        self.data = data\n        self.rank = rank\n        self.node = node            \n        self.parent = self\n\nclass Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:\n        n = len(a)\n        if n <= 1: return 0\n        d = defaultdict(list)\n        min_val, min_i = float('inf'), None        \n        for i in range(n-1):            \n            for j in range(i+1, n):                \n                val = abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1])\n                d[i].append((val, i, j)); d[j].append((val, j, i))                         \n                if min_val > val: min_val, min_i = val, i\n                    \n        for i in range(n): heapify(d[i])                \n        q = [heappop(d[min_i])]      \n        heapify(q)        \n        ans, cur = 0, set([min_i])\n        while len(cur) < n:            \n            val, i, j = heappop(q)\n            if j not in cur: ans += val\n            cur.add(j)\n            while d[i] and d[i][0][2] in cur: heappop(d[i])\n            if d[i]: heappush(q, heappop(d[i]))\n            while d[j] and d[j][0][2] in cur: heappop(d[j])\n            if d[j]: heappush(q, heappop(d[j]))            \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        s = [0]\n        res = 0\n        d = {i: abs(points[i][0]-points[0][0]) + abs(points[i][1]-points[0][1]) for i in range(len(points))}\n        current = 0\n        while len(s) < len(points):\n            min_ = float('inf')\n            next_ = current\n            for i in range(1,len(points)):\n                if d[i] == 0:\n                    continue\n                else:\n                    dis = abs(points[i][0]-points[next_][0]) + abs(points[i][1]-points[next_][1])\n                    if dis <= d[i]:\n                        d[i] = dis\n                    if d[i] <= min_:\n                        min_ = d[i]\n                        current = i\n            res += min_\n            d[current] = 0\n            s.append(current)\n        return res\n                                                                    \n            \n        \n                    \n", "from collections import defaultdict \n  \nclass Graph: \n    def __init__(self,vertices): \n        self.V= vertices\n        self.graph = [] \n\n    def addEdge(self,u,v,w): \n        self.graph.append([u,v,w]) \n        \n    def find(self, parent, i): \n        if parent[i] == i: \n            return i \n        return self.find(parent, parent[i]) \n    \n    def union(self, parent, rank, x, y): \n        xroot = self.find(parent, x) \n        yroot = self.find(parent, y) \n        \n        if rank[xroot] < rank[yroot]: \n            parent[xroot] = yroot \n        elif rank[xroot] > rank[yroot]: \n            parent[yroot] = xroot \n        else : \n            parent[yroot] = xroot \n            rank[xroot] += 1\n\n    def KruskalMST(self): \n        \n        result =[] \n\n        i = 0\n        e = 0\n        self.graph =  sorted(self.graph,key=lambda item: item[2]) \n\n        parent = [] ; rank = [] \n\n        for node in range(self.V): \n            parent.append(node) \n            rank.append(0) \n\n        while e < self.V -1 : \n            u,v,w =  self.graph[i] \n            i = i + 1\n            x = self.find(parent, u) \n            y = self.find(parent ,v) \n\n            if x != y: \n                e = e + 1     \n                result.append([u,v,w]) \n                self.union(parent, rank, x, y)             \n\n        ans = 0\n        for u,v,weight in result:\n            ans += weight\n        \n        return ans\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def getCost(x1, x2, y1, y2):\n            return abs(x2-x1) + abs(y2-y1)\n        \n        g = Graph(len(points))\n        for i in range(len(points)-1):\n            for j in range(i+1,len(points)):\n                g.addEdge(i,j,getCost(points[i][0], points[j][0], points[i][1], points[j][1]))\n        \n        return g.KruskalMST()\n", "class Solution:\n    \n    def dist(self, x1,y1,x2,y2):\n        return abs(x1-x2) + abs(y1-y2)\n    \n    def dist_from_point_to_all(self, points, i, n):\n        return [self.dist(*points[i],*points[j]) for j in range(n)]\n        \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        # This is Prim algo and I need an array for the min_priority\n        # to get the algo in time O(n**2), otherwise it will be too\n        # slow with a factor of log(n)\n        all_ = set(range(n))\n        s = set([0])\n        tot = 0\n        dist = self.dist_from_point_to_all(points, 0, n)\n        for _ in range(n-1):\n            min_dist = 10**8\n            for i in range(n):\n                if i not in s and dist[i] < min_dist:\n                    pos_best = i\n                    min_dist = dist[i]\n            tot += min_dist\n            s.add(pos_best)\n            dist_pos_best = self.dist_from_point_to_all(points, pos_best, n)\n            dist = [min(dist[j], dist_pos_best[j]) for j in range(n)]\n        return tot", "class Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                \n        n = len(a)\n        if n <= 1: return 0\n        d = defaultdict(list)\n        min_val, min_i = float('inf'), None        \n        for i in range(n-1):            \n            for j in range(i+1, n):                \n                val = abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1])\n                d[i].append((val, i, j)); d[j].append((val, j, i))                         \n                if min_val > val: \n                    min_val, min_i = val, i\n                    \n        for i in range(n): heapify(d[i])                \n        q = [heappop(d[min_i])]      \n        heapify(q)        \n        ans, cur = 0, set()\n        while len(cur) < n:            \n            val, i, j = heappop(q)\n            if j not in cur: ans += val\n            cur.add(i); cur.add(j)\n            while d[i] and d[i][0][2] in cur: heappop(d[i])\n            if d[i]: heappush(q, heappop(d[i]))\n            while d[j] and d[j][0][2] in cur: heappop(d[j])\n            if d[j]: heappush(q, heappop(d[j]))            \n        return ans                ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph,n,temp,edge=collections.defaultdict(list),len(points),float(\\\"inf\\\"),[-1,-1]\n        for i in range(n):\n            for j in range(i+1,n):\n                x,y,a,b=points[i][0],points[i][1],points[j][0],points[j][1]\n                dist=abs(x-a)+abs(y-b)\n                graph[i].append((dist,j))\n                graph[j].append((dist,i))\n                if dist<temp:\n                    temp=dist\n                    edge=[i,j]\n        ans,vis,queue,vis_count=0,{0},graph[0],1\n        heap=heapq.heapify(queue)\n        while queue and vis_count<n:\n            d,v=heapq.heappop(queue)\n            if v in vis: continue\n            ans+=d\n            vis_count+=1\n            vis.add(v)\n            for connected in graph[v]:\n                if connected[1] in vis: continue\n                heapq.heappush(queue,connected)\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        L = len(points)\n        parent = {i:i for i in range(L)}\n        \n        def find(p):\n            if parent[p] == p:\n                return p\n            return find(parent[p])\n        \n        def union(p,q):\n            if p != q:\n                if p < q:\n                    parent[q] = p\n                else:\n                    parent[p] = q\n\\t\\t\n        cost = 0\n        con = {}\n        count = 0            \n        for i,p1 in enumerate(points):\n            for j,p2 in enumerate(points):\n                if i!=j and (j,i) not in con.keys():\n                    d = self.dis(p1,p2)\n                    con[(i,j)] = d\n        k = sorted(con, key = lambda x :con[x])\n        for e in k:\n            x,y = e[0],e[1]\n            x_set, y_set = find(x), find(y)\n            if x_set!=y_set:\n                union(x_set,y_set)\n                count += 1\n                cost += con[e]\n            if count == L-1:\n                break\n        return cost\n            \n    def dis(self, p, x):\n        d = abs(x[1]-p[1]) + abs(x[0]-p[0])\n        return d", "class Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                \n        n = len(a)\n        if n <= 1: return 0\n        d = defaultdict(list)\n        min_val, min_i = float('inf'), None        \n        for i in range(n-1):            \n            for j in range(i+1, n):                \n                val = abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1])\n                d[i].append((val, i, j)); d[j].append((val, j, i))                         \n                if min_val > val: \n                    min_val, min_i = val, i\n                    \n        for i in range(n): heapify(d[i])                \n        q = [heappop(d[min_i])]      \n        heapify(q)        \n        ans, cur = 0, set([min_i])\n        while len(cur) < n:            \n            val, i, j = heappop(q)\n            if j not in cur: ans += val\n            cur.add(j)\n            while d[i] and d[i][0][2] in cur: heappop(d[i])\n            if d[i]: heappush(q, heappop(d[i]))\n            while d[j] and d[j][0][2] in cur: heappop(d[j])\n            if d[j]: heappush(q, heappop(d[j]))            \n        return ans                ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        dic = {}\n        for i in range(n - 1):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                dic[(i, j)] = dist\n        \n        root = [i for i in range(n)]\n        \n        def find(n):\n            if root[n] != n:\n                root[n] = find(root[n])\n            return root[n]\n        \n        def union(x, y):\n            s1 = find(x)\n            s2 = find(y)\n            if s1 != s2:\n                root[s2] = root[s1]\n                return 1\n            return 0\n                \n        dic_sorted = sorted(list(dic.items()), key=lambda x: x[1])\n        res = 0\n        count = 0\n        for item in dic_sorted:\n            x, y = item[0]\n            dist = item[1]\n            if union(x, y) == 1:\n                res += dist\n                count += 1\n            if count == n - 1:\n                return res\n        #return res\n            \n                \n                \n        \n                    \n                \n        \n        \n        \n                \n                \n                \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def manhattan_distance(point_1, point_2):\n            x1, y1 = point_1\n            x2, y2 = point_2\n            return abs(x2 - x1) + abs(y2 - y1)\n        \n        n = len(points)\n        graph = collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = manhattan_distance(points[i], points[j])\n                graph[i].append((dist, j))\n                graph[j].append((dist, i))\n            \n        visited = set()\n        visited.add(0)\n        heap = [_ for _ in graph[0]]\n        heapq.heapify(heap)\n        cost = 0\n        \n        while heap and len(visited) != len(points):\n            dist, neighbor = heapq.heappop(heap)\n            if neighbor not in visited:\n                visited.add(neighbor)\n                cost += dist\n                for new_dist, new_neighbor in graph[neighbor]:\n                    if new_neighbor not in visited:\n                        heapq.heappush(heap, (new_dist, new_neighbor))\n                        \n        return cost\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "from heapq import heappop, heappush\n\nclass DSU:\n    def __init__(self, n):\n        self.p = [i for i in range(n)]\n        self.rank = [1] * n\n        self.parts = n\n    \n    def find(self, a):\n        if self.p[a] == a:\n            return a\n        \n        self.p[a] = self.find(self.p[a])\n        return self.p[a]\n    \n    def is_connected(self, a, b):\n        return self.find(a) == self.find(b)\n    \n    def union(self, a, b):\n        A = self.find(a)\n        B = self.find(b)\n        \n        if self.rank[A] >= self.rank[B]:\n            self.p[B] = A\n            self.rank[A] += self.rank[B]\n        else:\n            self.p[A] = B\n            self.rank[B] += self.rank[A]\n        \n        return\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        N = len(points)\n        dsu = DSU(N)\n        \n        pq = []\n        \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i + 1, N):\n                x2, y2 = points[j]\n                heappush(pq, (abs(x1 - x2) + abs(y1 - y2), i, j))\n        \n        cost = 0\n        while dsu.parts > 1:\n            c, p1, p2 = heappop(pq)\n            \n            if dsu.is_connected(p1, p2) == True:\n                continue\n            \n            dsu.union(p1, p2)\n            dsu.parts -= 1\n            cost += c\n        \n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def dist(p1, p2):\n            x1,y1 = p1\n            x2,y2 = p2\n            return abs(x1-x2) + abs(y1-y2)\n        \n        n = len(points)\n        d = [float('inf')] * n\n        cur = 0\n        ans = 0\n        seen = set()\n        \n        for i in range(n-1):\n            seen.add(cur)\n            for j,p in enumerate(points):\n                if j in seen: continue\n                d[j] = min(d[j], dist(points[cur],points[j]))\n            \n            min_d, nxt = min((d,j) for j,d in enumerate(d))\n            d[nxt] = float('inf')\n            cur = nxt\n            ans += min_d\n        \n        return ans\n                                   \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(roots, x):\n            if x != roots[x]:\n                roots[x] = find(roots, roots[x])\n            return roots[x]\n\n        n = len(points)\n        manhattan = lambda a, b: abs(a[0] - b[0]) + abs(a[1] - b[1])\n        heap = []\n        roots = list(range(n))\n        size = [1 for i in range(n)]\n        res = 0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = manhattan(points[i], points[j])\n                heap.append((d, (i, j)))\n\n        heapq.heapify(heap)\n\n        while heap:\n            d, (i, j) = heapq.heappop(heap)\n            root1 = find(roots, i)\n            root2 = find(roots, j)\n\n            if root1 != root2:\n                res += d\n                if size[root1] < size[root2]:\n                    roots[root1] = root2\n                    size[root2] += size[root1]\n                    if size[root2] == n: break\n                else:\n                    roots[root2] = root1\n                    size[root1] += size[root2]\n                    if size[root1] == n: break\n\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        L = len(points)\n        res = 0\n        con = {}\n        father = {i:i for i in range(L)}\n        def find(pidx):\n            if father[pidx] == pidx:\n                return pidx\n            return find(father[pidx])\n        def union(p,q):\n            if p != q:\n                if p < q:\n                    father[q] = p\n                else:\n                    father[p] = q\n        for i,p in enumerate(points):\n            for j,p2 in enumerate(points):\n                if i!=j and (j,i) not in list(con.keys()):\n                    d = self.dis(p,p2)\n                    con[(i,j)] = d\n        k = sorted(con, key = lambda x :con[x])\n        count = 0\n        for e in k:\n            x,y = e[0],e[1]\n            fx, fy= find(x), find(y)\n            if fx!=fy:\n                union(fx,fy)\n                count += 1\n                res += con[e]\n            if count == L-1:\n                break\n        return res\n            \n    def dis(self, p, x):\n        d = abs(x[1]-p[1]) + abs(x[0]-p[0])\n        return d\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(i):\n            if parent[i] == i:\n                return i\n            return find(parent[i])\n        def union(p1,p2):\n            if size[p1] > size[p2]:\n                p1,p2=p2,p1\n            parent[p1] = p2\n            size[p2] += size[p1]\n            \n        if len(points) <= 1:\n            return 0\n        dist = []\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                dist.append((d,i,j))\n        dist.sort()\n        #print(dist)\n        edge = 0\n        res = 0\n        parent = list(range(len(points)))\n        size = [1]*len(points)\n        for d,n1,n2 in dist:\n            p1,p2 = find(n1),find(n2)\n            if p1 == p2:\n                continue\n            res += d\n            union(p1,p2)\n            edge += 1\n            if edge == len(points)-1:\n                return res\n                \n        \n    \n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        \n        def distance(point1, points):\n            return abs(point1[0]-point2[0]) + abs(point1[1]-point2[1])\n        \n        for i,point1 in enumerate(points):\n            for j, point2 in enumerate(points[i+1:]):\n                edges.append((i,j+i+1, distance(point1,point2)))\n\n        edges = sorted(edges, key = lambda x: -x[2])\n        \n        union = list(range(n))\n        rank = [1]*n\n        \n        def find(x):\n            if union[x]!=x:\n                union[x] = find(union[x])\n            return union[x]\n        \n        def connect(x, y):\n            xr, yr = find(x), find(y)\n            if rank[xr] > rank[yr]:           \n                union[yr] = xr\n                rank[xr] += rank[yr]\n            else:\n                union[xr] = yr\n                rank[yr] += rank[xr]\n        \n        result= 0\n        times = 0\n        while(edges and times < n-1):\n            p1, p2, dis = edges.pop()    \n            if find(p1)!=find(p2):\n                connect(p1, p2)\n                result += dis\n                times +=1 \n        print(rank)        \n        return result\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1: return 0\n        n = len(points)\n        heap = []\n        dic = collections.defaultdict(list)\n        #calculate all the distances and put them in a heap\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                dic[i].append((dist, j))\n                dic[j].append((dist, i))\n        #add edges connected to 0 to heap    \n        res, count, visited, heap = 0, 0, [0] * n, dic[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            dist, i = heapq.heappop(heap)\n            if not visited[i]:\n                res += dist\n                count += 1\n                visited[i] = 1\n                if count == n - 1:\n                    return res\n                for record in dic[i]:\n                    heapq.heappush(heap, record)\n    \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        L = len(points)\n        res = 0\n        con = {}\n        \n        father = {i:i for i in range(L)}\n        \n        def find(pidx):\n            if father[pidx] == pidx:\n                return pidx\n            return find(father[pidx])\n        \n        def union(p,q):\n            if p != q:\n                if p < q:\n                    father[q] = p\n                else:\n                    father[p] = q\n\\t\\t#Step 1\n        for i,p in enumerate(points):\n            for j,p2 in enumerate(points):\n                if i!=j and (j,i) not in con.keys():\n                    d = self.dis(p,p2)\n                    con[(i,j)] = d\n        k = sorted(con, key = lambda x :con[x])\n\\t\\t#Step 2\n        count = 0\n        for e in k:\n            x,y = e[0],e[1]\n            fx, fy= find(x), find(y)\n            if fx!=fy:\n                union(fx,fy)\n                count += 1\n                res += con[e]\n            if count == L-1:\n                break\n        return res\n            \n    def dis(self, p, x):\n        d = abs(x[1]-p[1]) + abs(x[0]-p[0])\n        return d", "from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        dist = defaultdict(lambda: defaultdict(int))\n        n = len(points)\n        \n        if n <= 1: return 0\n        if n == 2:\n            return abs(points[0][0] - points[1][0]) + abs(points[0][1] - points[1][1])\n        \n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dist[j][i] = dist[i][j] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                \n        seen = set()\n        start = 0\n        seen.add(start)\n        heap = []\n        \n        for k, v in list(dist[start].items()):\n            heapq.heappush(heap, (v, k))\n            \n        ans = 0\n        while heap:\n            if len(seen) == len(points):\n                return ans\n            \n            d, node = heapq.heappop(heap)\n            if node not in seen:\n                seen.add(node)\n                ans += d\n                for k, v in list(dist[node].items()):\n                    heapq.heappush(heap, (v, k))\n        \n        \n            \n                \n", "from collections import Counter, defaultdict, OrderedDict, deque\nfrom bisect import bisect_left, bisect_right\nfrom functools import reduce, lru_cache\nfrom typing import List\nimport itertools\nimport math\nimport heapq\nimport string\ntrue = True\nfalse = False\nMIN, MAX, MOD = -0x3f3f3f3f, 0x3f3f3f3f, 1000000007\n\n\n#\n# @lc app=leetcode id=1584 lang=python3\n#\n# [1584] Min Cost to Connect All Points\n#\n# https://leetcode.com/problems/min-cost-to-connect-all-points/description/\n#\n# algorithms\n# Medium (31.62%)\n# Total Accepted:    1.7K\n# Total Submissions: 5.4K\n# Testcase Example:  '[[0,0],[2,2],[3,10],[5,2],[7,0]]'\n#\n# You are given an array\u00a0points\u00a0representing integer coordinates of some points\n# on a 2D-plane, where points[i] = [xi, yi].\n#\n# The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan\n# distance between them:\u00a0|xi - xj| + |yi - yj|, where |val| denotes the\n# absolute value of\u00a0val.\n#\n# Return\u00a0the minimum cost to make all points connected. All points are\n# connected if there is exactly one simple path between any two points.\n#\n#\n# Example 1:\n#\n#\n#\n#\n# Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\n# Output: 20\n# Explanation:\n#\n# We can connect the points as shown above to get the minimum cost of 20.\n# Notice that there is a unique path between every pair of points.\n#\n#\n# Example 2:\n#\n#\n# Input: points = [[3,12],[-2,5],[-4,1]]\n# Output: 18\n#\n#\n# Example 3:\n#\n#\n# Input: points = [[0,0],[1,1],[1,0],[-1,1]]\n# Output: 4\n#\n#\n# Example 4:\n#\n#\n# Input: points = [[-1000000,-1000000],[1000000,1000000]]\n# Output: 4000000\n#\n#\n# Example 5:\n#\n#\n# Input: points = [[0,0]]\n# Output: 0\n#\n#\n#\n# Constraints:\n#\n#\n# 1 <= points.length <= 1000\n# -10^6\u00a0<= xi, yi <= 10^6\n# All pairs (xi, yi) are distinct.\n#\n#\n#\nclass Solution:\n    def minCostConnectPoints(self, ps: List[List[int]]) -> int:\n        n = len(ps)\n        if n < 2: return 0\n        keys, visited = [MAX] * n, [False] * n\n        keys[0] = 0\n        cost = 0\n        for _ in range(n):\n            idx, n_min = 0, MAX\n            for j in range(n):\n                if not visited[j] and keys[j] < n_min:\n                    idx, n_min = j, keys[j]\n            visited[idx] = True\n            cost += n_min\n            for j in range(n):\n                if not visited[j]:\n                    weight = abs(ps[idx][0] - ps[j][0]) + abs(ps[idx][1] -\n                                                              ps[j][1])\n                    if weight < keys[j]:\n                        keys[j] = weight\n\n        return cost\n\n\nsol = Solution()\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\n# points = [[3, 12], [-2, 5], [-4, 1]]\n# points = [[0, 0], [1, 1], [1, 0], [-1, 1]]\n# points = [[-1000000, -1000000], [1000000, 1000000]]\n# points = [[0, 0]]\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def dist(p1, p2):\n            x1,y1 = p1\n            x2,y2 = p2\n            return abs(x1-x2) + abs(y1-y2)\n        \n        n = len(points)\n        d = [float('inf')] * n\n        cur = 0\n        ans = 0\n        seen = set()\n        \n        for i in range(n-1):\n            seen.add(cur)\n            for j,p in enumerate(points):\n                if j in seen: continue\n                d[j] = min(d[j], dist(points[cur],points[j]))\n            \n            min_d, nxt = min((d,j) for j,d in enumerate(d))\n            d[nxt] = float('inf') #don't count distance with self\n            cur = nxt\n            ans += min_d\n        \n        return ans\n                                   \n                \n", "class Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        connections = [[u, v, dist(points[u], points[v])] for u in range(N-1) for v in range(u+1, N)]\n        connections.sort(key = lambda x:x[2])\n        parent, cnt, res = [i for i in range(N+1)], N-1, 0\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        for u, v, cost in connections:\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                cnt -= 1\n                res += cost\n                if cnt == 0:\n                    break\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        distance = lambda u, v: abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1])\n        \n        graph = defaultdict(list)\n        for u in range(n):\n            for v in range(u + 1, n):\n                dist = distance(u, v)\n                graph[u].append((dist, v))\n                graph[v].append((dist, u))\n        \n        count = 1\n        cost = 0\n        visited = [True] + [False] * (n - 1)\n        heap = graph[0][:]\n        heapify(heap)\n        \n        while heap:\n            dist, u = heappop(heap)\n            if not visited[u]:\n                visited[u] = True\n                count += 1\n                cost += dist\n                for link in graph[u]:\n                    heappush(heap, link)\n            \n            if count >= n:\n                break\n        \n        return cost\n", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        n, g = len(A), collections.defaultdict(list)\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(A[i], A[j])\n                g[i].append((d, j))\n                g[j].append((d, i))\n                \n        cnt, ans, seen, q = 1, 0, [0] * n, g[0]\n        seen[0] = 1\n    \n        heapify(q)\n        \n        while q:\n            d, k = heappop(q)\n            if seen[k]: continue\n            seen[k], ans, cnt = 1, ans + d, cnt + 1\n            for r in g[k]: heappush(q, r)\n            if cnt >= n:\n                break\n        return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def getDist(p1, p2):\n            # |xi - xj| + |yi - yj|\n            xi, yi = p1\n            xj, yj = p2\n            return abs(xi - xj) + abs(yi - yj)\n        \n        graph = collections.defaultdict(list)\n        for i in range(len(points)):\n            for j in range(len(points)):\n                graph[i].append((getDist(points[i], points[j]), j))\n        start = 0\n        res = 0\n        visited = { start }\n        min_heap = []\n        for cost, adj in graph[start]:\n            heapq.heappush(min_heap, (cost, adj))\n        while len(visited) < len(points) and min_heap:\n            cost, next_node = heapq.heappop(min_heap)\n            if next_node not in visited:\n                visited.add(next_node)\n                res += cost\n                for next_cost, adj in graph[next_node]:\n                    if adj not in visited:\n                        heapq.heappush(min_heap, (next_cost, adj))\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n, dists = len(points), collections.defaultdict(list)\n        if n <= 1:\n            return 0\n        for i in range(n-1):\n            for j in range(i+1, n):\n                dist = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                dists[i].append((dist, j))\n                dists[j].append((dist, i))\n        res, visited, cnt, heap = 0, [0]*n, 1, dists[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            dist, i = heappop(heap)\n            if not visited[i]:\n                res += dist\n                cnt += 1\n                for ele in dists[i]:\n                    heappush(heap, ele)\n                visited[i] = 1\n            if cnt == n:\n                return res", "# Solve Leetcode 1584. Min Cost to Connect All Points using the boilerplate code below, and then implement Kruskal's algorithm to solve the problem. Use self.distance(pointA, pointB) to find distance (weight of edge) between two nodes.\n\nclass DisjointSet:\n    def __init__(self, points):\n        self.parent = {}\n        self.rank = {}\n        for point in points:\n            self.parent[point] = point\n            self.rank[point] = 1\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        x_set = self.find(x)\n        y_set = self.find(y)\n\n        if self.rank[x_set] < self.rank[y_set]:\n            self.parent[x_set] = y_set\n        elif self.rank[x_set] > self.rank[y_set]:\n            self.parent[y_set] = x_set\n        else:\n            self.parent[x_set] = y_set\n            self.rank[y_set] += 1\n\n        \nfrom collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        points = [tuple(point) for point in points]\n        disjoint_set = DisjointSet(points)\n    \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                distance = self.distance(points[i], points[j])\n                edges.append((distance, points[i], points[j]))\n        \n        edges.sort()\n        answer = 0\n        times = 0\n        for distance, nodeA, nodeB in edges:\n            if disjoint_set.find(nodeA) != disjoint_set.find(nodeB):\n                disjoint_set.union(nodeA, nodeB)\n                answer += distance\n                times += 1\n            if times == len(points)-1:\n                return answer\n        return answer\n        \n        \n\n\n    def distance(self, pointA, pointB):\n        return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        visited = set()\n        visited.add(0)\n        res = 0\n        heap = c[0]\n        \n        heapq.heapify(heap)\n\n        while len(visited)<n:\n            d, j = heapq.heappop(heap)\n            if j not in visited:\n                visited.add(j)\n                res += d\n                for record in c[j]:\n                    heapq.heappush(heap,record)\n                    \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        dis = [(abs(points[i][0] - points[j][0])+abs(points[i][1] - points[j][1]),i,j) for i in range(n) for j in range(i+1,n)]\n        heapq.heapify(dis)\n        father = list(range(n))\n        def getfather(x):\n            if father[x] != x:\n                father[x] = getfather(father[x])\n            return father[x]\n        def union(x,y):\n            fx = getfather(x)\n            fy = getfather(y)\n            if fx == fy:\n                return False\n            father[fx] = fy\n            return True\n        step = 0\n        res = 0\n        while dis:\n            d,i,j = heapq.heappop(dis)\n            if union(i,j):\n                res += d\n                step += 1\n                if step == n - 1:\n                    break\n        return res\n", "from heapq import heappush, heappop\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def helper(i, j, p):\n            return abs(p[j][0] - p[i][0]) + \\\\\n                   abs(p[j][1] - p[i][1])\n        \n        g = defaultdict(lambda: {}); n = len(points)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                g[i][j] = g[j][i] = helper(i,j,points)\n\n                \n        visited = set(); res = 0; q = []; cnt=0\n        heappush(q, (0, 0)) # u:0, cost:0\n        while q:\n            cost, u = heappop(q)\n            if u in visited: continue\n            res += cost\n            cnt += 1\n            for v, w in g[u].items():\n                heappush(q, (w, v))\n            visited.add(u)\n            if cnt >= n: break\n        return res\n        \n        \n    \n\\\"\\\"\\\"\n[[0,0],[2,2],[3,10],[5,2],[7,0]]\n[[3,12],[-2,5],[-4,1]]\n[[0,0],[1,1],[1,0],[-1,1]]\n[[-1000000,-1000000],[1000000,1000000]]\n[[0,0]]\n\\\"\\\"\\\"            ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) < 2:\n            return 0\n        \n        def dist(p1, p2):\n            return abs(points[p1][0] - points[p2][0]) + abs(points[p1][1] - points[p2][1])\n        \n        edges = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                edges.append((i,j,dist(i, j)))\n        edges = sorted(edges, key=lambda x : x[2])\n        #print(edges)\n        \n        total = 0\n        group = [x for x in range(len(points))]\n        while sum(group) > 0:\n            x, y, w = edges.pop(0)\n            #print(group)\n            #print(f\\\"{x} {y} {w} {total} {edges}\\\")\n            if group[x] == group[y]:\n                continue\n            \n            gx = group[x]\n            gy = group[y]\n            g = min(gx, gy)\n            for i in range(len(group)):\n                if group[i] == gy or group[i] == gx:\n                    group[i] = g\n                #print(f\\\"\\\\t{g} {i} {group}\\\")\n            total += w\n        #print(group)\n        #print(f\\\"{x} {y} {w} {total} {edges}\\\")            \n        return total\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        distances = []\n        n = len(points)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                distances.append([(i,j), dist])\n        distances.sort(key = lambda x: x[1])\n        # print(distances)\n        parent = [i for i in range(n)]\n        size = [1 for _ in range(n)]\n        def find(x):\n            if parent[x] == x:\n                return x\n            else:\n                return find(parent[x])\n        def union(px, py):\n            # px, py = find(x), find(y)\n            # if px != py:\n            if size[px] < size[py]:\n                px, py = py, px\n            parent[py] = px\n            size[px] += size[py]\n        count = 0\n        ans = 0\n        for (x,y), dist in distances:\n            px, py = find(x), find(y)\n            if px != py:\n                union(px, py)\n                count += 1\n                ans += dist\n                if count == n-1:\n                    break\n        return ans", "class DSU:\n    def __init__(self, size):\n        self.par = list(range(size))\n    def find(self,x): \n        if self.par[x] != x: \n            return self.find(self.par[x])\n        return self.par[x]\n    def union (self, x, y):\n        self.par[self.find(x)] = self.find(y)\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance (u, v): \n            return abs(u[0] - v[0]) + abs(u[1] - v[1])\n        points_dist = collections.defaultdict(dict)\n        edges = []\n        for i, p1 in enumerate(points): \n            for j in range(i + 1, len(points)):\n                points_dist[i][j] = distance(points[i], points[j])\n                heapq.heappush(edges, (distance(points[i], points[j]), i, j))\n        res = 0\n        count = 0 \n        dsu = DSU(len(points))\n        while count < len(points) - 1:\n            distance, x , y = heapq.heappop(edges)\n            p_x, p_y = dsu.find(x), dsu.find(y)\n            if p_x != p_y:\n                count += 1\n                res += distance\n                dsu.union(x, y)\n        return res", "# Solve Leetcode 1584. Min Cost to Connect All Points using the boilerplate code below, and then implement Kruskal's algorithm to solve the problem. Use self.distance(pointA, pointB) to find distance (weight of edge) between two nodes.\n\nclass DisjointSet:\n    def __init__(self, points):\n        self.parent = {}\n        self.rank = {}\n        for point in points:\n            self.parent[point] = point\n            self.rank[point] = 1\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        x_set = self.find(x)\n        y_set = self.find(y)\n\n        if self.rank[x_set] < self.rank[y_set]:\n            self.parent[x_set] = y_set\n        elif self.rank[x_set] > self.rank[y_set]:\n            self.parent[y_set] = x_set\n        else:\n            self.parent[x_set] = y_set\n            self.rank[y_set] += 1\n\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        points = [tuple(point) for point in points]\n        disjoint_set = DisjointSet(points)\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                distance = self.distance(points[i], points[j])\n                edges.append((distance, points[i], points[j]))\n                \n        answer = 0\n        times = 0\n        edges.sort()\n        for distance, nodeA, nodeB in edges:\n            if disjoint_set.find(nodeA) != disjoint_set.find(nodeB):\n                disjoint_set.union(nodeA, nodeB)\n                answer += distance\n                times += 1\n            if times == len(points) - 1:\n                return answer\n        return answer\n\n\n    def distance(self, pointA, pointB):\n        return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n      \n        while heap:\n            d, j = heapq.heappop(heap)\n          \n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dis = []\n        for i in range(len(points)):\n            for j in range(i, len(points)):\n                dis.append(\n                    (\n                        abs(points[i][0] - points[j][0])\n                        + abs(points[i][1] - points[j][1]),\n                        i,\n                        j,\n                    )\n                )\n        dis = sorted(dis, key=lambda x: x[0])\n\n        joined = 1\n        cost = 0\n        parents = [x for x in range(len(points))]\n\n        def find(x):\n            if parents[x] != x:\n                parents[x] = find(parents[x])\n            return parents[x]\n\n        for edge in dis:\n            if find(edge[1]) != find(edge[2]):\n                joined += 1\n                cost += edge[0]\n                parents[find(edge[1])] = edge[2]\n            if joined == len(points):\n                return cost\n", "from collections import defaultdict\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        edges = []\n        \n        n = len(points)\n        \n        parent = defaultdict(lambda:-1)\n        \n        # ----------------------------------------------\n        \n        def find_parent(x,y):\n            \n            if parent[(x,y)] == -1:\n                return x, y\n            \n            else:\n                #print( parent[(x,y)] )\n                parent[(x,y)] = find_parent( *parent[(x,y)] )\n                return parent[(x,y)]\n        \n        # ----------------------------------------------\n        \n        def merge(x1, y1, x2, y2):\n            \n            if x1 == x2 and y1 == y2:\n                return\n            \n            # x2, y2 merge to x1, y1\n            parent_of_i = find_parent( x1, y1 )\n            parent_of_j = find_parent( x2, y2 )\n            \n            parent[parent_of_j] = parent_of_i\n            \n        # ----------------------------------------------\n        \n        def dist(pi, pj):\n            \n            return abs( pi[0] - pj[0] ) + abs( pi[1] - pj[1] )\n        \n        # ----------------------------------------------\n        \n        for i in range(n-1):\n            for j in range(i+1, n):\n                \n                cost = dist(points[i], points[j])\n                \n                edges.append( ( cost, tuple(points[i]), tuple(points[j]) ) )\n                \n        edges.sort(key = lambda e: e[0] )\n        \n        min_cost = 0\n        selected_edge = 0\n        \n        for edge in edges:\n            \n            node_v, node_u = edge[1], edge[2]\n            if find_parent( *node_v ) == find_parent( *node_u ):\n                continue\n            \n            merge( *(node_v+node_u) )\n            min_cost += edge[0]\n            selected_edge += 1\n            \n            if selected_edge == n-1:\n                break\n                \n        return min_cost\n", "# int minCostConnectPoints(vector<vector<int>>& ps) {\n#     int n = ps.size(), res = 0, i = 0, connected = 0;\n#     vector<bool> visited(n);\n#     priority_queue<pair<int, int>> pq;\n#     while (++connected < n) {\n#         visited[i] = true;\n#         for (int j = 0; j < n; ++j)\n#             if (!visited[j])\n#                 pq.push({-(abs(ps[i][0] - ps[j][0]) + abs(ps[i][1] - ps[j][1])), j});\n#         while (visited[pq.top().second])\n#             pq.pop();\n#         res -= pq.top().first;\n#         i = pq.top().second;\n#         pq.pop();\n#     }\n#     return res;\n# }\n\nclass Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                        \n        n, vis, ans, pq, i = len(a), set([0]), 0, [], 0\n        rem = set(range(1, n))\n        while len(vis) < n:            \n            for j in rem: heappush(pq, (abs(a[i][0]-a[j][0]) + abs(a[i][1] - a[j][1]), j))\n            while pq[0][1] in vis: heappop(pq)\n            val, i = heappop(pq)\n            vis.add(i); rem.discard(i)\n            ans += val            \n        return ans                                            ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        groups = [a for a in range(len(points))]\n        for index_a in range(len(points)):\n            for index_b in range(index_a+1, len(points)):\n                edge = (index_a, index_b, abs(points[index_a][0] - points[index_b][0]) + abs(points[index_a][1] - points[index_b][1]))\n                edges.append(edge)\n        edges.sort(key = lambda a:a[2])\n        \n        \n        def find(a):\n            return a if groups[a] == a else find(groups[a])\n        \n        def union(a, b):\n            group_a = find(a)\n            group_b = find(b)\n            if group_a != group_b:\n                return group_a, group_b\n            return \n        \n        sum = 0\n        while len(set(groups)) != 1:\n            edge = edges.pop(0)\n            merged = union(edge[0], edge[1])\n            if merged is not None:\n                groups = [merged[1] if x == merged[0] else x for x in groups]\n                sum += edge[2]\n        return sum", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        distances, n = {i: [] for i in range(len(points))}, len(points)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                distances[i].append((dist, j))\n                distances[j].append((dist, i))\n        import heapq\n        heap = distances[0]\n        heapq.heapify(heap)\n        ans = 0\n        count = 0\n        visited = set([0])\n        while heap:\n            dist, j = heapq.heappop(heap)\n            if j not in visited:\n                visited.add(j)\n                ans += dist\n                count += 1\n                for x in distances[j]:\n                    heapq.heappush(heap, x)\n            if count == n -1: break\n        return ans\n            \n    \n                \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n\n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n\n        ans, n = 0, len(p)\n        seen = set()\n        vertices = [(0, (0, 0))] # (distance, (last_vertice, cur_vertice))\n\n        while len(seen) < n:\n            # print(vertices, seen)\n            d, (u, v) = heapq.heappop(vertices)            \n            if v in seen: continue\n            ans += d\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))\n\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        def dist(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append((dist(points[i], points[j]), i, j))\n        edges.sort()\n        cost = 0\n        #print(edges)\n        parent = [i for i in range(n)]\n        size = [1] * n\n        def find(a):\n            if parent[a] == a:\n                p = a\n            else:\n                p = find(parent[a])\n            parent[a] = p\n            return p\n            \n        def union(a, b):\n            pa = find(a)\n            pb = find(b)\n            if pa != pb:\n                parent[pa] = pb\n                size[pb] += size[pa]\n                if size[pb] == n:\n                    return True\n            return False\n        \n        for e in edges:\n            a, b = e[1], e[2]\n            pa, pb = find(a), find(b)\n            if pa != pb:\n                cost += e[0]\n                if (union(e[1], e[2])):\n                    break\n        return cost\n                             \n                \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n\n        root = [i for i in range(n+1)]\n        def find(x):\n            if root[x] != x:\n                root[x] = find(root[x])\n            return root[x]\n\n        def uni(x, y):\n            x, y = find(x), find(y)\n            if x == y: return 0\n            root[x] = y\n            return 1 \n\n        def distance(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n        routes = []\n        unconnected = n - 1\n        costs = 0\n        for i in range(n):\n            for j in range(i + 1, n): \n                routes.append([distance(points[i], points[j]), i, j])\n        routes.sort(key=lambda l: l[0], reverse=True)\n        while unconnected:\n            route = routes.pop()\n            if uni(route[1], route[2]):\n                costs += route[0]\n                unconnected -= 1\n        return costs", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        def find(x):\n            if dp[x]!=x:\n                dp[x]=find(dp[x])\n            return dp[x]\n\n        def uni(x,y):\n            x,y=find(x),find(y)\n            if x!=y:\n                dp[x]=find(y)\n                return False   \n            return True\n            \n        n=len(p)\n        dp=list(range(n))    \n\n        pool=sorted((abs(p[i][0]-p[j][0])+abs(p[i][1]-p[j][1]),i,j) for i in range(n) for j in range(i+1,n))\n        \n        ct=res=0\n        \n\n        for dis,u,v in pool:\n            if not uni(u,v):\n                res+=dis\n                ct+=1\n                if ct==n-1:\n                    break\n        return res", "from pprint import pprint\nclass Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        def getMinNode(n, val, mst):\n            mn = math.inf\n            mn_idx = None\n            for i in range(n):\n                if (mst[i] == False and val[i] < mn):\n                    mn = val[i]\n                    mn_idx = i\n            return mn_idx\n        \n        res = 0\n        n = len(p)\n        parent = [None] * n\n        parent[0] = -1\n        \n        dists = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    dists[i][j] = dists[j][i] = abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])\n        \n        # pprint(dists)\n        mst = [False] * n\n        val = [math.inf] * n\n        val[0] = 0\n        for i in range(n - 1):\n            u = getMinNode(n, val, mst)\n            mst[u] = True\n            for v in range(n):\n                if dists[u][v] and mst[v] == False and dists[u][v] < val[v]:\n                    val[v] = dists[u][v]\n                    parent[v] = u\n        for i in range(1, n):\n            # print(dist[parent[i]])\n            # print(dist)\n            res += dists[parent[i]][i]\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans    \n    def minCostConnectPoints3(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            dis[curr] = math.inf\n            res += delta\n            \n        return res    \n    def minCostConnectPoints2(self, P: List[List[int]]) -> int:\n        res=0\n        n=len(P)\n        px,py=P[0]\n        seen={0}\n        todo=set(range(1,n))\n        while len(seen)<n:\n            mn=float('inf')\n            used=-1\n            for i in todo:\n                cx,cy=P[i]\n                for j in seen:\n                    px,py=P[j]\n                    can=abs(cx-px)+abs(cy-py)\n                    if can <mn:\n                        mn=can\n                        used=i\n            res+=mn\n            todo.remove(used)\n            seen.add(used)\n        return res\n\n    # def minCostConnectPoints1(self, P: List[List[int]]) -> int:\n    #     P.sort(key=lambda a:(abs(a[0])+abs(a[1])))\n    #     print(P)\n    #     res=0\n    #     px,py=P[0]\n    #     for cx,cy in P[1:]:\n    #         res+=abs(cx-px)+abs(cy-py)\n    #         px,py=cx,cy\n    #     return res    \n", "from collections import defaultdict\n    \n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(x):\n            if x != parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        total_points = len(points)    \n        parent = list(range(total_points))\n        weight_matrix = []\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) +abs(p1[1]-p2[1])\n   \n        for i in range(total_points):\n            for j in range(i+1, total_points):\n                dist = manhattan(points[i],points[j])\n                weight_matrix.append((i,j, dist))\n                \n        cost = 0\n        for u, v, w in sorted(weight_matrix, key=lambda x: x[2] ):\n            ru, rv = find(u), find(v)\n            if ru == rv:\n                continue\n            cost += w\n            parent[ru] = rv\n            \n        return cost\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if not points or len(points) == 1:\n            return 0\n        dist = {}\n        for p in range(1,len(points)):\n            dist[p] = abs(points[p][0] - points[0][0]) + abs(points[p][1] - points[0][1])\n        print(dist)\n        cost = 0\n        while dist:\n            min_k = 0\n            min_v = 1e10\n            for k,v in list(dist.items()):\n                if v < min_v:\n                    min_v = v\n                    min_k = k\n            print((min_k,min_v))\n            cost += min_v\n            for k,v in list(dist.items()):\n                dist[k] = min(dist[k], abs(points[min_k][0] - points[k][0]) + abs(points[min_k][1] - points[k][1]))\n            assert dist[min_k] == 0\n            del dist[min_k]\n            \n        return cost\n                \n", "from queue import PriorityQueue\n\nclass Solution:\n    def findParent(self, parents, i):\n        if parents[i] is None:\n            return i\n        else:\n            return self.findParent(parents, parents[i])\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 0:\n            return 0\n        \n        edges = []\n        req_edges = len(points)-1\n        dist = 0\n        parents = [None] * len(points)\n        \n        for i, p1 in enumerate(points):\n            for j, p2 in enumerate(points):\n                if i < j:\n                    edges.append([i, j, (abs(p1[0]-p2[0]) + abs(p1[1]-p2[1]))])\n        edges = sorted(edges, key=lambda x: x[2])\n        \n        for edge in edges:\n            parent_i = self.findParent(parents, edge[0])\n            parent_j = self.findParent(parents, edge[1])\n            if parent_i == parent_j:\n                continue\n            parents[parent_i] = parent_j\n            dist += edge[2]\n\n            req_edges -= 1\n            if req_edges == 0:\n                break\n            \n        return dist\n", "from collections import defaultdict\nimport heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) < 1: return 0\n        \n        graph = defaultdict(list)\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                graph[i].append((dist, j))\n                graph[j].append((dist, i))\n        \n        heap, visited, cost = graph[0], set([0]), 0\n        heapq.heapify(heap)\n        while len(visited) != len(points):\n            dist, node = heapq.heappop(heap)\n            if node not in visited:\n                visited.add(node)\n                for edge in graph[node]:\n                    heapq.heappush(heap, edge)\n                cost += dist\n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        dis = collections.defaultdict(list)\n        \n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                length = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                dis[i].append((length, j))\n                dis[j].append((length, i))\n        \n        visit = {0}\n        queue = collections.deque([0])\n        pull = dis[0]\n        heapq.heapify(pull)\n        cost = 0\n        # print(dis[0])\n        while queue and len(visit) != n:\n            # print(pull)\n            node = queue.popleft()\n            can = heapq.heappop(pull)\n            while can[1] in visit:\n                can = heapq.heappop(pull)\n            cost += can[0]\n            for ele in dis[can[1]]:\n                heapq.heappush(pull, ele)\n            visit.add(can[1])\n            queue.append(can[1])\n        return cost", "class Solution:\n    def find_min_node(self, n, key, mst_set):\n        min, min_node = sys.maxsize, -1\n        for i in range(n):\n            if not mst_set[i] and key[i] < min:\n                min, min_node = key[i], i\n        return min_node\n    \n    def solve(self, n, edges):\n        mst_set = [False] * n;\n        key = [sys.maxsize] * n;\n        parent = [-1] * n;\n        \n        key[0] = 0\n        parent[0] = -1\n        \n        for i in range(n):\n            u = self.find_min_node(n, key, mst_set)\n            mst_set[u] = True\n            for v in range(n):\n                if (not mst_set[v] and edges[u][v] < key[v]):\n                    parent[v] = u\n                    key[v] = edges[u][v]\n        \n        res = 0\n        for i in range(1, n):\n            res += edges[parent[i]][i]\n        return res\n        \n        \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                edges[i][j] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                \n        return self.solve(n, edges)\n", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        n, c = len(p), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = abs(p[i][0]-p[j][0]) + abs(p[i][1]-p[j][1])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        cc = [i for i in range(len(points))]\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((d, i, j))\n        edges.sort()\n        \n        def root(x):\n            if cc[x] != x:\n                cc[x] = root(cc[x])\n            return cc[x]\n        def join(x, y):\n            rx = root(x)\n            ry = root(y)\n            if rx != ry:\n                cc[rx] = ry\n            return rx != ry\n        \n        cct = len(points)\n        cost = 0\n        # print('foo')\n        for x, i, j in edges:\n            if join(i, j):\n                cost += x\n                # print(x)\n                cct -= 1\n                if cct == 1:\n                    break\n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n    \n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans\n        \n#         if not points or len(points) <= 1:\n#             return 0\n        \n#         heap = []\n#         for i in range(len(points)):\n#             for j in range(i + 1, len(points)):\n#                 p1 = points[i]\n#                 p2 = points[j]\n#                 dis = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n#                 heapq.heappush(heap, (dis, i, j))\n        \n#         self.father = [i for i in range(len(points))]\n#         res = 0\n#         while heap:\n#             dis, u, v = heapq.heappop(heap)\n#             root_u = self.find(u)\n#             root_v = self.find(v)\n#             if root_u == root_v:\n#                 continue\n#             self.father[max(root_u, root_v)] = min(root_u, root_v)\n#             res += dis\n        \n#         return res\n    \n#     def find(self, x):\n#         if self.father[x] == x:\n#             return self.father[x]\n#         self.father[x] = self.find(self.father[x])\n#         return self.father[x]\n", "class DSU:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n            \n        return self.parent[x]\n    \n    def union(self, x, y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n        \n        if xRoot == yRoot:\n            return False\n        \n        if self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n        elif self.rank[yRoot] > self.rank[xRoot]:\n            self.parent[xRoot] = yRoot\n        else:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot] += 1\n            \n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        pq = []\n        \n        for i in range(N):\n            for j in range(i):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                pq.append((dist, i, j))\n                    \n        heapify(pq)\n        dsu = DSU(N)\n        edges = 0\n        cost = 0\n        \n        while edges < N - 1:\n            dist, i, j = heappop(pq)\n            \n            if dsu.union(i, j):\n                cost += dist\n                edges += 1\n                \n        return cost\n    \n# class Solution:\n#     def minCostConnectPoints(self, points: List[List[int]]) -> int:\n#         N = len(points)\n#         graph = defaultdict(list)\n        \n#         for i in range(N):\n#             for j in range(N):\n#                 if i != j:\n#                     x1, y1 = points[i]\n#                     x2, y2 = points[j]\n#                     dist = abs(x1 - x2) + abs(y1 - y2)\n#                     graph[i].append((j, dist))\n#                     graph[j].append((i, dist))\n                    \n#         pq = [(0, 0)]\n#         visited = set()\n#         cost = 0\n        \n#         while len(visited) < N:\n#             dist, node = heappop(pq)\n            \n#             if node not in visited:\n#                 visited.add(node)\n#                 cost += dist\n                \n#                 for adj, dist in graph[node]:\n#                     if adj not in visited:\n#                         heappush(pq, (dist, adj))\n                \n#         return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        md = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        n = len(points)\n        graph = defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = md(points[i], points[j])\n                graph[i].append((d, j))\n                graph[j].append((d, i))\n        \n        visited = {0}\n        q = graph[0]\n        heapq.heapify(q)\n        res = 0\n        \n        while len(q)!=0:\n            d, j = heapq.heappop(q)\n            if j not in visited:\n                visited.add(j)\n                res += d\n                for item in graph[j]:\n                    heapq.heappush(q, item)\n            if len(visited) == n:\n                break\n        \n        return res\n        \n", "from collections import defaultdict\nfrom heapq import heappop, heappush, heapify\ndef prim(N, E):\n    edges = defaultdict(list)\n    for x, y, c in E:\n        edges[x].append((c, y))\n        edges[y].append((c, x))\n    heap = []\n    heappush(heap, (0, 0))\n    cnt = 0\n    visited = {}\n    ans = 0\n    while heap:\n        c, n = heappop(heap)\n        if n in visited: continue\n        visited[n] = 1\n        ans += c\n        for e in edges[n]:\n            heappush(heap, e)\n        cnt += 1\n        if cnt >= N:\n            break\n    return ans\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        E = []\n        n = len(points)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                E.append((i, j, d))\n        ans = prim(n, E)\n        return ans\n", "class Solution:     \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans\n\n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #\u57fa\u672c\u529f\u4e0d\u624e\u5b9e\u5440\uff0c\u662f\u4e00\u4e2aminimum spanning tree\n        visited = set()\n        graph = [[0]*len(points) for _ in range(len(points))]\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                graph[i][j] = graph[j][i] = dist \n        heap = [(0,0)]\n        asr = 0\n        for i in range(len(points)):\n            dist,idx = heapq.heappop(heap)\n            while heap and idx in visited:\n                dist,idx = heapq.heappop(heap)\n            visited.add(idx)\n            asr+=dist\n            for v in range(len(points)):\n                if v not in visited:\n                    heapq.heappush(heap,(graph[idx][v],v))\n        return asr", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    # #\u6ca1\u6709\u73b0\u6210\u7684edge list\uff0c\u60f3\u5230\u5f53\u904d\u5386\u5230\u67d0\u4e00\u4e2a\u70b9\u624d\u73b0\u7b97\u5b83\u4e0e\u5176\u4ed6\u70b9\u7684\u6743\u91cd\u503c\u5e76\u538b\u8fdbpqueue\uff0c\u6545\u8003\u8651\u9996\u9009Prim\u7b97\u6cd5\u800c\u4e0d\u662fKrusal (1000ms, 95%faster)\n    #     N = len(points)\n    #     seen = set()\n    #     cost = 0\n    #     cnt = 0\n    #     pq = [(0, 0)]\n    #     while pq:\n    #         c, i = heapq.heappop(pq)\n    #         if i in seen: continue\n    #         cost += c\n    #         cnt += 1\n    #         if cnt == N: return cost    #early termination. another advantage of using Prim over Krusal\n    #         seen.add(i)\n    #         pt_x, pt_y = points[i]\n    #         for j in range(N):\n    #             if j in seen: continue\n    #             nei_x, nei_y = points[j]\n    #             nei_c = abs(pt_x - nei_x) + abs(pt_y - nei_y)\n    #             heapq.heappush(pq, (nei_c, j))\n    #     return cost\n     \n        \n    #\u4e5f\u64cd\u7ec3\u4e00\u4e0bKruskal...\n        N = len(points)\n        dsu = list(range(N))\n        def find(i):\n            if dsu[i] != i: dsu[i] = find(dsu[i])\n            return dsu[i]\n        def union(i, j):\n            dsu[find(j)] = find(i)\n       \n        pq = []\n        cost = 0\n        #push in all edges, sort by wight_cost\n        for i in range(N):\n            for j in range(i+1, N):\n                i_x, i_y = points[i]\n                j_x, j_y = points[j]\n                c = abs(i_x - j_x) + abs(i_y - j_y)\n                pq.append((c, i, j))\n        pq.sort(key = lambda x: x[0], reverse = True)\n        # print(pq)\n        while pq:\n            c, i ,j = pq.pop()\n            if find(i) == find(j): continue\n            cost += c\n            union(i, j)\n        return cost\n        \n        \n        \n        \n        \n        \n        \n        \n#         res = 0\n#         N = len(points)\n#         visited = [[0] * N for _ in range(N)]\n#         if len(points) == 1: return 0\n#         DP = [[float('inf')] * N for _ in range(N)]\n        \n#         for i in range(N):\n#             # min_dist = float('inf')\n#             for j in range(i+1, N):\n#                 # print(i, i, j)\n#                 x, y = points[i], points[j]\n#                 curr_dist = DP[i][j] = DP[j][i] = abs(x[0] - y[0]) + abs(x[1] - y[1])\n#                 # if curr_dist < min_dist: \n#                 #     min_dist = curr_dist\n#             min_dist = min(DP[i])\n#             j = DP[i].index(min_dist) \n#             if not visited[i][j]:\n#                 res += min_dist\n#                 visited[i][j] = visited[j][i] = 1\n#                 DP[i][j] = DP[j][i] = float('inf')\n#             print(min_dist, DP)\n#             # res += min_dist\n#         return res\n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n      edges = []\n      for i in range(len(points)):\n        for j in range(i+1, len(points)):\n          distance = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n          edges.append((i, j, distance))\n      \n      edges.sort(key=itemgetter(2))\n      \n      numComponents = len(points)\n      groups = [i for i in range(len(points))]\n      size = [1] * len(points)\n      \n      def find(x):\n        if groups[x] == x:\n          return x\n        groups[x] = find(groups[x])\n        return groups[x]\n      \n      cost = 0\n      \n      for edge in edges:\n        p1 = edge[0]\n        p2 = edge[1]\n        \n        root1 = find(p1)\n        root2 = find(p2)\n        \n        if root1 != root2:\n          if size[p1] < size[p2]:\n            groups[root1] = groups[root2]\n            size[root2] += size[root1]\n          else:\n            groups[root2] = groups[root1]\n            size[root1] += size[root2]\n          cost += edge[2]\n          numComponents -= 1\n          \n          \n      \n      if numComponents == 1:\n        return cost\n      else:\n        return -1\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # We are looking a min spanning tree that can be obtained \n        connections = []\n        \n        for i, p in enumerate(points):\n            for j in range(i + 1, len(points)):\n                connections.append((i, j, abs(p[0] - points[j][0]) + abs(p[1] - points[j][1])))\n        \n        connections.sort(key=itemgetter(2))\n        parent = list(range(len(points)))\n        size = [1] * len(points)\n        \n        def find(x):\n            if x == parent[x]:\n                return x\n            \n            parent[x] = find(parent[x])\n            return parent[x]\n        \n        total_distance = 0\n        for u, v, c in connections:\n            p_u = find(u)\n            p_v = find(v)\n            \n            if p_u == p_v:\n                continue\n                \n            total_distance += c\n            if size[u] < size[v]:\n                size[v] += size[u]\n                parent[p_u] = p_v\n            else:\n                size[u] += size[v]\n                parent[p_v] = p_u\n        \n        return total_distance\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1:\n            return 0\n        \n        root = {}\n        for point in points:\n            root[(point[0], point[1])] = (point[0], point[1])\n        \n        #find with compresion\n        def find(i):\n            if i != root[i]:\n                root[i] = find(root[i])\n            return root[i]\n        \n        def union(a, b):\n            a, b = find(a), find(b)\n            \n            if a == b:\n                return 0\n            \n            root[a] = b\n            return 1\n        \n        num = len(points)\n        #visited = set()\n        edge_count = 0\n        distances = []\n        \n        for i in range(num):\n            for j in range(i+1, num):\n                #distances[(points[i], points[j])] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                distances.append((abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]),(points[i], points[j])))\n                j += 1\n        \n        distances.sort(key=lambda x:x[0])\n        #print(distances)\n        \n        ans = 0\n        for d in distances:\n            a = d[1][0]\n            b = d[1][1]\n            a_t = tuple(a)\n            b_t = tuple(b)\n            if find(a_t) != find(b_t):\n                #print(f\\\"adding {d}\\\")\n                edge_count += 1\n                ans += d[0]\n                union(a_t, b_t)\n                #visited.add(a_t)\n                #visited.add(b_t)\n                if edge_count == num-1:\n                    return ans\n    \n        return -1\n", "from collections import defaultdict\nimport heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        graph = defaultdict(list)\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                cost = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                graph[i].append((cost, j))\n                graph[j].append((cost, i))\n        \n        seen = [0] * (len(points)+1)\n        seen[0] = 1\n        q = graph[0]\n        minimumCost = 0\n        connectedNodes = 1\n        heapq.heapify(q)\n        while q:\n            cost, city = heapq.heappop(q)\n            if not seen[city]:\n                seen[city] = 1\n                minimumCost += cost\n                connectedNodes += 1\n                for connectingCost, neighbour in graph[city]:\n                    heapq.heappush(q, (connectingCost, neighbour))\n            if connectedNodes >= len(points):\n                break\n        return minimumCost\n", "class DSU:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n        self.count = n\n    \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self,x,y):\n        px = self.find(x)\n        py = self.find(y)\n        if px==py:\n            return False\n        self.count-=1\n        if self.rank[px]>self.rank[py]:\n            self.parent[py]=px\n            self.rank[px]+=self.rank[py]\n        else:\n            self.parent[px]=py\n            self.rank[py]+=self.rank[px]\n        return True\n                \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        heapq.heapify(edges)\n        res = 0\n        ds = DSU(n)\n        while edges and ds.count!=1:\n            cost,u,v = heapq.heappop(edges)\n            if ds.union(u,v):\n                res += cost\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    # #\u6ca1\u6709\u73b0\u6210\u7684edge list\uff0c\u60f3\u5230\u5f53\u904d\u5386\u5230\u67d0\u4e00\u4e2a\u70b9\u624d\u73b0\u7b97\u5b83\u4e0e\u5176\u4ed6\u70b9\u7684\u6743\u91cd\u503c\u5e76\u538b\u8fdbpqueue\uff0c\u6545\u8003\u8651\u9996\u9009Prim\u7b97\u6cd5\u800c\u4e0d\u662fKrusal (1000ms, 95%faster)\n    #     N = len(points)\n    #     seen = set()\n    #     cost = 0\n    #     cnt = 0\n    #     pq = [(0, 0)]\n    #     while pq:\n    #         c, i = heapq.heappop(pq)\n    #         if i in seen: continue\n    #         cost += c\n    #         cnt += 1\n    #         if cnt == N: return cost    #early termination. another advantage of using Prim over Krusal\n    #         seen.add(i)\n    #         pt_x, pt_y = points[i]\n    #         for j in range(N):\n    #             if j in seen: continue\n    #             nei_x, nei_y = points[j]\n    #             nei_c = abs(pt_x - nei_x) + abs(pt_y - nei_y)\n    #             heapq.heappush(pq, (nei_c, j))\n    #     return cost\n     \n        \n    #\u4e5f\u64cd\u7ec3\u4e00\u4e0bKruskal...\n        N = len(points)\n        dsu = list(range(N))\n        def find(i):\n            if dsu[i] != i: dsu[i] = find(dsu[i])\n            return dsu[i]\n        def union(i, j):\n            dsu[find(j)] = find(i)\n       \n        pq = []\n        cost = 0\n        #push in all edges, sort by wight_cost\n        for i in range(N):\n            for j in range(i+1, N):\n                i_x, i_y = points[i]\n                j_x, j_y = points[j]\n                c = abs(i_x - j_x) + abs(i_y - j_y)\n                pq.append((c, i, j))\n        pq.sort(key = lambda x: x[0], reverse = True)\n        # print(pq)\n        while pq:\n            c, i ,j = pq.pop()\n            fi, fj = find(i), find(j)\n            if fi == fj: continue\n            cost += c\n            dsu[fj] = fi\n        return cost\n        \n        \n        \n        \n        \n        \n        \n        \n#         res = 0\n#         N = len(points)\n#         visited = [[0] * N for _ in range(N)]\n#         if len(points) == 1: return 0\n#         DP = [[float('inf')] * N for _ in range(N)]\n        \n#         for i in range(N):\n#             # min_dist = float('inf')\n#             for j in range(i+1, N):\n#                 # print(i, i, j)\n#                 x, y = points[i], points[j]\n#                 curr_dist = DP[i][j] = DP[j][i] = abs(x[0] - y[0]) + abs(x[1] - y[1])\n#                 # if curr_dist < min_dist: \n#                 #     min_dist = curr_dist\n#             min_dist = min(DP[i])\n#             j = DP[i].index(min_dist) \n#             if not visited[i][j]:\n#                 res += min_dist\n#                 visited[i][j] = visited[j][i] = 1\n#                 DP[i][j] = DP[j][i] = float('inf')\n#             print(min_dist, DP)\n#             # res += min_dist\n#         return res\n                \n", "def manhattan(p1, p2):\n    if p1 == p2:\n        return 10**10\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \ndef makeGraph(points):\n    graph = []\n    for p1 in range(len(points)):\n        for p2 in range(p1):\n            graph.append( (p2, p1, manhattan(points[p1], points[p2])) )\n    return graph\n\nclass Solution:\n\n    #Prim's\n    def _minCostConnectPoints(self, points: List[List[int]]) -> int:\n        pass\n        \n        \n        \n        \n    #Kruskal's\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        \n        \n        def find(subsets, p1):\n            if subsets[p1][0] != p1:\n                subsets[p1][0] = find(subsets, subsets[p1][0])\n            return subsets[p1][0]\n        \n        def union(subsets, p1, p2):\n            p1root = find(subsets, p1)\n            p2root = find(subsets, p2)\n            \n            if subsets[p1root][1] > subsets[p2root][1]:\n                subsets[p2root][0] = p1root\n            elif subsets[p2root][1] > subsets[p1root][1]:\n                subsets[p1root][0] = p2root\n            else:\n                subsets[p1root][1] += 1\n                subsets[p2root][0] = p1root\n        \n        graph = makeGraph(points)\n        \n        edges = sorted(graph, key=lambda x: x[2])\n        subsets = [[x, 0] for x in range(len(points))]\n        \n        e = 0 #counts how many edges have been added\n        i = 0 #tracks location in edges array\n        total_cost = 0\n        \n        while e < len(points) - 1:\n            \n            p1, p2, cost = edges[i]\n            \n            if find(subsets, p1) != find(subsets, p2):               \n                union(subsets, p1, p2)\n                total_cost += cost\n                e += 1\n            else:\n                pass\n                #discard the edge\n            \n            i += 1\n        return total_cost", "'''\nhttps://leetcode.com/problems/min-cost-to-connect-all-points/\n'''\nfrom typing import List\nimport heapq\n\nclass Solution:\n    '''\n    Minimum Spanning Tree (Kruskal)\n    https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/843940/C%2B%2B-Minimum-Spanning-Tree-(Kruskal)\n\n    Intuition:\n    Imagine all the points form a complete graph, and length of an edge is the manhattan distance between the 2 points\n    To find the min cost, we therefore need to find the minimum spanning tree\n\n    Algorithm:\n    Use the Kruskal algorithm, which invovles min heap to pick the smallest edge, and union-find to check if the edge is redundant.\n    Exit when all points are connected.\n\n    The complexity when using sort is O(n * n log (n * n)) - we have n * n edges. Using a min heap is O(k log (n * n)),\n    where k is the number of edges we need to pull to complete the tree. It's much smaller than n * n in the average case.\n    '''\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        def find(ds, i):\n            if ds[i] < 0:\n                return i\n            ds[i] = find(ds, ds[i])\n            return ds[i]\n\n        n, ans = len(points), 0\n        ds = [-1] * n\n        arr = []\n        for i in range(n):\n            for j in range(i+1, n):\n                heapq.heappush(arr, [abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]), i, j])\n        while arr:\n            dist, i, j = heapq.heappop(arr)\n            i, j = find(ds, i), find(ds, j)\n            if i != j:\n                ans += dist\n                ds[i] += ds[j]\n                ds[j] = i\n                if ds[i] == -n:\n                    break\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        l = len(points)\n        if l < 2:\n            return 0\n        \n        comps = [i for i in range(l)]\n        \n        def comp(v):\n            return v if comps[v] == v else comp(comps[v])\n        \n        def join_comp(comp1, comp2):\n            for i in range(l):\n                if comps[i] == comp1:\n                    comps[i] = comp2\n        \n        edges = []\n        for i in range(l):\n            for j in range(i+1, l):\n                edges.append((abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j))\n        \n        edges.sort()\n        \n        out = 0\n        edge_count = l - 1\n        for edge in edges:\n            comp1 = comp(edge[1])\n            comp2 = comp(edge[2])\n            if comp1 != comp2:\n                out += edge[0]\n                join_comp(comp2, comp1)\n                edge_count -= 1\n                if not edge_count:\n                    break\n        return out\n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def get_dist(i, j):\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = get_dist(i, j)\n                c[i].append((d, j))\n                c[j].append((d, i))\n        \n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap and cnt < n:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n        return ans", "from heapq import *\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        result = 0\n        if len(points) == 1:\n            return result\n        \n        costHeap = []\n        n = len(points)\n        cur = 0\n        distance = lambda p, np: abs(p[0] - np[0]) + abs(p[1] - np[1])\n        visited = set()\n        visited.add(cur)\n        \n        for i in range(1, n):\n            heappush(costHeap, [distance(points[0], points[i]), i])\n        \n        while costHeap:\n            cost, nextStart = heappop(costHeap)\n            # print(cur, nextStart, cost)\n            if nextStart not in visited:\n                result += cost\n                visited.add(nextStart)\n                cur = nextStart\n                for i in range(n):\n                    if i in visited:\n                        continue\n                    heappush(costHeap, [distance(points[cur], points[i]), i])\n            if len(visited) == n:\n                break\n                \n        return result\n                    \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans\n                            \n", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n\n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n\n        ans, n = 0, len(p)\n        seen = set()\n        vertices = [(0, (0, 0))] # (distance, (last_vertice, cur_vertice))\n\n        while len(seen) < n:\n            # print(vertices, seen)\n            d, (u, v) = heapq.heappop(vertices)            \n            if u not in seen and v in seen:\n                print(u, v)\n            if v in seen: continue\n            ans += d\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))\n\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # edge: from, to, weight\n        Edge = namedtuple(\\\"Edge\\\", [\\\"V1\\\", \\\"V2\\\", \\\"dist\\\"])\n        edges = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                edges.append(Edge(points[i], points[j], abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])))\n        edges.sort(key = lambda e: e[2])\n        \n        uf = {}\n        \n        def find(x:List[int]):\n            xx = (x[0], x[1]) # to a hashable type\n            uf.setdefault(xx, xx) # this will only be executed when x's value is missing\n            if uf[xx] != xx:\n                uf[xx] = find(uf[xx])\n            return uf[xx]\n        \n        def union(x, y):\n            uf[find(x)] = find(y)\n            \n        num = len(points) # we need num-1 lines to form the MST\n        \n        count, total = 0, 0\n        \n        for f, t, dist in edges: # already sorted\n            # when vertice x and vertice y doesn't have the same root, we union them \n            # and draw a line (count + 1)\n            if find(f) != find(t):\n                union(f, t)\n                count += 1\n                total += dist\n            if count == num - 1:\n                return total\n        return total", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        uf = {}\n        n = len(points)\n        rank = [1] * n\n        \n        def find(x):\n            uf.setdefault(x, x)\n            if uf[x] != x:\n                uf[x] = find(uf[x])\n            return uf[x]\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            if px != py:\n                if rank[px] > rank[py]:\n                    px, py = py, px\n                rank[py] += rank[px]\n                uf[px] = py\n                return rank[py] == n\n            return False\n        \n        hp = [(abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j) for i in range(n) for j in range(i + 1, n)]\n        heapq.heapify(hp)\n        ans = 0\n        \n        while hp:\n            d, i, j = heapq.heappop(hp)\n            if find(i) != find(j):\n                ans += d\n                if union(i, j):\n                    break\n                \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        from heapq import heappush, heappop\n        \n        n = len(points)\n        h = {i: {} for i in range(n)}\n        visited = [False] * n \n        for p1 in range(n):\n            for p2 in range(n):\n                if p1 == p2:\n                    continue\n                d = abs(points[p1][0] - points[p2][0]) + abs(points[p1][1] - points[p2][1])\n                \n                h[p1][p2] = d\n                h[p2][p1] = d\n        \n        \n        # print(h)\n        \n        total = 0\n        ans = 0\n        queue = [(0, 0)]\n        while total < n:\n            d, node = heappop(queue)\n            if visited[node]:\n                continue\n            # print(d, node)\n            total += 1\n            ans += d\n            visited[node] = True\n            for item in h[node]:\n                if not visited[item]:\n                    heappush(queue, (h[node][item], item))\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: p[0] + p[1])\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            p1, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p2, dist) in enumerate(points):\n                points[i][1] = min(points[i][1], distance(p1, p2))\n        return total_cost\n\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        connections = [[u, v, dist(points[u], points[v])] for u in range(N-1) for v in range(u+1, N)]\n        connections.sort(key = lambda x:x[2])\n        parent, cnt, res = [i for i in range(N+1)], N-1, 0\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        for u, v, cost in connections:\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                cnt -= 1\n                res += cost\n                if cnt == 0:\n                    break\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        from collections import defaultdict \n        class Graph: \n\n            def __init__(self,vertices): \n                self.V= vertices\n                self.graph = [] \n\n\n            def addEdge(self,u,v,w): \n                self.graph.append([u,v,w]) \n\n            def find(self, parent, i): \n                if parent[i] == i: \n                    return i \n                return self.find(parent, parent[i]) \n\n            def union(self, parent, rank, x, y): \n                xroot = self.find(parent, x) \n                yroot = self.find(parent, y) \n\n                if rank[xroot] < rank[yroot]: \n                    parent[xroot] = yroot \n                elif rank[xroot] > rank[yroot]: \n                    parent[yroot] = xroot \n\n                else : \n                    parent[yroot] = xroot \n                    rank[xroot] += 1\n\n            def KruskalMST(self): \n\n                result =[] #This will store the resultant MST \n\n                i = 0 # An index variable, used for sorted edges \n                e = 0 # An index variable, used for result[] \n\n                self.graph =  sorted(self.graph,key=lambda item: item[2]) \n\n                parent = [] ; rank = [] \n\n                for node in range(self.V): \n                    parent.append(node) \n                    rank.append(0) \n\n                while e < self.V -1 : \n\n                    u,v,w =  self.graph[i] \n                    i = i + 1\n                    x = self.find(parent, u) \n                    y = self.find(parent ,v) \n\n                    if x != y: \n                        e = e + 1     \n                        result.append([u,v,w]) \n                        self.union(parent, rank, x, y)             \n                ret = 0\n                for u,v,weight  in result: \n                    ret += weight\n                    \n                return ret\n        \n        def dis(i, j):\n            return abs(i[0]-j[0])+abs(i[1]-j[1])\n        \n        l = len(points)\n        g = Graph(l)\n        for i in range(l):\n            for j in range(i,l):\n                g.addEdge(i, j, dis(points[i], points[j]))\n  \n        return g.KruskalMST() \n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        points = [tuple(p) for p in points]\n        \n        ans, n = 0, len(points)\n        seen = set()\n        vertices = [(0, ((points[0]), (points[0])))]\n        \n        while len(seen) < n:\n            w, (u, v) = heapq.heappop(vertices)\n            # print(w, u, v, ans, seen)\n            if u in seen and v in seen: continue\n            ans += w\n            seen.add(v)\n            for j, p in enumerate(points):\n                if tuple(p) != tuple(v) and tuple(p) not in seen:\n                    heapq.heappush(vertices, (manhattan(p, v), (tuple(v), tuple(p))))\n            # print(vertices)\n            seen.add(u)\n        \n        return ans\n                \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        from heapq import heappush, heappop\n        \n        n = len(points)\n        h = {i: {} for i in range(n)}\n        visited = [False] * n \n        for p1 in range(n):\n            for p2 in range(n):\n                if p1 == p2:\n                    continue\n                d = abs(points[p1][0] - points[p2][0]) + abs(points[p1][1] - points[p2][1])\n                \n                h[p1][p2] = d\n                h[p2][p1] = d\n        \n        \n        # print(h)\n        \n        total = 0\n        ans = 0\n        queue = [(0, 0)]\n        while total < n:\n            d, node = heappop(queue)\n            if visited[node]:\n                continue\n            print((d, node))\n            total += 1\n            ans += d\n            visited[node] = True\n            for item in h[node]:\n                if not visited[item]:\n                    heappush(queue, (h[node][item], item))\n        return ans\n                \n            \n            \n            \n            \n        \n        \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(x):\n            if x != parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        parent = list(range(len(points)))\n        g = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                g.append((i, j, abs(points[j][1]-points[i][1]) + abs(points[j][0]-points[i][0])))\n        \n        cost = 0\n        for u, v, w in sorted(g, key=lambda x:x[2]):\n            ru, rv = find(u), find(v)\n            if ru == rv:\n                continue\n            parent[ru] = rv\n            cost += w\n        \n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        weight_graph = []\n        res = []\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                weight_graph.append([i,j,abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])])\n        weight_graph = sorted(weight_graph,key=lambda item:item[2])\n        parent = [i for i in range(n)]\n        rank = [0 for _ in range(n)]\n        def find(i):\n            if parent[i] == i:\n                return i\n            else:\n                return find(parent[i])\n        def union(x,y):\n            if rank[x] < rank[y]:\n                parent[x] = parent[y]\n            elif rank[x] > rank[y]:\n                parent[y] = parent[x]\n            else:\n                parent[x] = parent[y]\n                rank[y] += 1\n        for edge in weight_graph:\n            if len(res) < len(points)-1:\n                u,v,w = edge\n                x = find(u)\n                y = find(v)\n                if x!=y:\n                    union(x,y)\n                    res.append(w)\n        if not res:\n            return 0\n        return sum(res)\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        n = len(points)\n        seen = set()\n        res = 0\n        pq = [(0, 0, 0)]\n        while len(seen) < n:\n            w, u, v = heapq.heappop(pq)\n            if u in seen and v in seen:\n                continue\n            res += w\n            seen.add(v)\n            for i in range(n):\n                if i != v and i not in seen:\n                    heapq.heappush(pq, (manhattan(points[v], points[i]), v, i))\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        self.points = points\n        n = len(points)\n        edges = []\n        for i in range(n-1):\n            for j in range(i+1,n):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((d,i,j))\n        edges.sort()\n        self.comp = list(range(n))\n        ans = 0\n        e = 0\n        for i in range(n-1):\n            while e < len(edges):\n                d,i,j = edges[e]\n                e += 1\n                ii = self.find(i)\n                jj = self.find(j)\n                if ii != jj:\n                    self.comp[ii] = jj\n                    ans += d\n                    break\n        return ans\n    \n    \n    def find(self,i):\n        idx = []\n        while self.comp[i] != i:\n            idx.append(i)\n            i = self.comp[i]\n        for j in idx:\n            self.comp[j] = i\n        return i\n            \n", "class Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                        \n        ans, n, vis, pq, i = 0, len(a), set([0]), [], 0\n        rem = set(range(1, n))\n        while len(vis) < n:            \n            for j in rem: \n                if j not in vis: heappush(pq, (abs(a[i][0]-a[j][0]) + abs(a[i][1] - a[j][1]), j))\n            while pq[0][1] in vis: heappop(pq)\n            val, i = heappop(pq)\n            vis.add(i); rem.discard(i)\n            ans += val            \n        return ans                                            ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n=len(points)\n        cost=0\n        if n<=1:\n            return 0\n        \n        g=[]\n        for i in range(n):\n            x1=points[i][0]\n            y1=points[i][1]\n            for j in range(i+1,n):\n                if j!=i:\n                    x2=points[j][0]\n                    y2=points[j][1]\n                    d=abs(x1-x2)+abs(y1-y2)\n                    g.append([i,j,d])\n                    \n        g.sort(key=lambda x:x[2])\n        par=[-1]*n\n        for i,(u,v,c) in enumerate(g):\n            \n            p1=u\n            while par[p1]>0:\n                p1=par[p1]\n            p2=v\n            while par[p2]>0:\n                p2=par[p2]\n                \n            if p1==p2:\n                continue\n            \n            \n            \n            else:\n                if abs(par[p1])>abs(par[p2]):\n                    par[p1]+=par[p2]\n                    if u!=p1:\n                        par[u]=p1\n\n                    par[v]=p1\n                    par[p2]=p1\n\n                else:\n                    par[p2]+=par[p1]\n                    if v!=p2:\n                        par[v]=p2\n\n                    par[u]=p2\n                    par[p1]=p2\n                \n                cost+=c\n            \n        \n        return cost\n                \n                \n                \n        \n", "from collections import defaultdict \nclass Graph: \n  \n    def __init__(self,n:int) -> None: \n        self.V= n \n        self.graph = []\n    def addEdge(self,u:int,v:int,w:int)-> None: \n        self.graph.append([u,v,w]) \n    def find(self, parent:List[int], i:int)->int: \n        if parent[i] == i: \n            return i \n        return self.find(parent, parent[i])\n    def union(self, parent:List[int], rank:List[int], x:int, y:int)->None: \n        xroot = self.find(parent, x) \n        yroot = self.find(parent, y) \n \n        if rank[xroot] < rank[yroot]: \n            parent[xroot] = yroot \n        elif rank[xroot] > rank[yroot]: \n            parent[yroot] = xroot \n        else : \n            parent[yroot] = xroot \n            rank[xroot] += 1\n     \n    def KruskalMST(self)->List[List[int]]: \n \n        result =[] \n        i = 0\n        e = 0 \n        self.graph =  sorted(self.graph,key=lambda item: item[2]) \n  \n        parent = []\n        rank = [] \n  \n        # Create V subsets with single elements \n        for node in range(self.V): \n            parent.append(node) \n            rank.append(0) \n      \n        # Number of edges to be taken is equal to V-1 \n        while e < self.V -1 : \n  \n            # Step 2: Pick the smallest edge and increment  \n                    # the index for next iteration \n            u,v,w =  self.graph[i] \n            i = i + 1\n            x = self.find(parent, u) \n            y = self.find(parent ,v) \n  \n            # If including this edge does't cause cycle,  \n                        # include it in result and increment the index \n                        # of result for next edge \n            if x != y: \n                e = e + 1     \n                result.append([u,v,w]) \n                self.union(parent, rank, x, y)             \n            # Else discard the edge \n  \n        return result\n                               \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        graph = Graph(n)\n        for i in range(n-1):\n           point1 = points[i]\n           for j in range(i+1,n):\n              point2 = points[j]\n              manhattan_distance = abs(point1[0]-point2[0]) + abs(point1[1]-point2[1])                \n              graph.addEdge(i,j,manhattan_distance)\n        ans = 0                       \n        for edge in graph.KruskalMST():\n           ans += edge[2]\n        return ans\n", "class Graph: \n    def __init__(self,vertices): \n        self.V= vertices\n        self.graph = []\n    def addEdge(self,u,v,w): \n        self.graph.append([u,v,w]) \n    def find(self, parent, i): \n        if parent[i] == i: \n            return i \n        return self.find(parent, parent[i]) \n    def union(self, parent, rank, x, y): \n        px = self.find(parent, x) \n        py = self.find(parent, y) \n        if rank[px] < rank[py]: \n            parent[px] = py \n        elif rank[px] > rank[py]: \n            parent[py] = px \n        else : \n            parent[py] = px \n            rank[px] += 1\n \n    def MST(self): \n        res = 0\n        i = 0\n        e = 0\n        self.graph =  sorted(self.graph,key=lambda item: item[2]) \n        parent = [] ; rank = [] \n        for node in range(self.V): \n            parent.append(node) \n            rank.append(0) \n        while e < self.V -1 :\n            u,v,w =  self.graph[i] \n            i = i + 1\n            x = self.find(parent, u) \n            y = self.find(parent ,v)\n            if x != y: \n                e = e + 1     \n                res += w\n                self.union(parent, rank, x, y)\n        return res\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        g = Graph(n)\n        def dis(i, j):\n            return abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n        for i in range(n):\n            for j in range(i+1, n):\n                g.addEdge(i, j, dis(i, j))\n        return g.MST() \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(p1,p2):\n            return abs(p1[1] - p2[1]) + abs(p1[0] - p2[0])\n        n = len(points)\n        edges = [(i,j,distance(points[i],points[j])) for i in range(n) for j in range(i+1,n)]\n        edges.sort(key=lambda x: x[2])        \n        father = [i for i in range(n + 1)]\n        def find(x):\n            if father[x] != x:\n                father[x] = find(father[x])\n            return father[x]\n        def union(x,y):\n            x = father[x]\n            y = father[y]\n            if x < y:\n                father[y] = x\n            else:\n                father[x] = y\n        ans = 0\n        for p1,p2,d in edges:\n            if find(p1) != find(p2):\n                ans += d\n                union(p1,p2)\n        return ans\n\\\"\\\"\\\"\n[[2,-3],[-17,-8],[13,8],[-17,-15]]\n[[3,12],[-2,5],[-4,1]]\n[[0,0],[2,2],[3,10],[5,2],[7,0]]\n[[0,0]]\n[[-1000000,-1000000],[1000000,1000000]]\n[[0,0],[1,1],[1,0],[-1,1]]\n[[3,12],[-2,5],[-4,1]]\n\\\"\\\"\\\"", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(p1, p2):\n            return abs(p2[0] - p1[0]) + abs(p2[1] - p1[1])\n    \n        res , n = 0, len(points)\n        dist_list = [distance(points[0], p) for p in points]\n        for _ in range(n-1):\n            d, j = min((d, i) for i, d in enumerate(dist_list) if d > 0)\n            res += d\n            dist_list = [min(dist_list[i], distance( points[j], p)) for i, p in enumerate(points)]\n            \n        return res\n", "class UnionFind:\n    def __init__(self, size):\n        self._parent = list(range(size))\n        self._size = [1] * size\n    \n    def union(self, a, b):\n        a, b = self.find(a), self.find(b)\n        if a == b:\n            return False\n        if self._size[a] < self._size[b]:\n            a, b = b, a\n        self._parent[b] = a\n        self._size[a] += self._size[b]\n        return True\n    \n    def find(self, x):\n        while self._parent[x] != x:\n            self._parent[x] = self._parent[self._parent[x]]\n            x = self._parent[x]\n        return x\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        \n        edges = []\n        for u in range(n):\n            x0, y0 = points[u]\n            for v in range(u + 1, n):\n                x1, y1 = points[v]\n                edges.append((u, v, abs(x0 - x1) + abs(y0 - y1)))\n        edges.sort(key=lambda e: e[2])\n        \n        uf = UnionFind(n)\n        cost = 0\n        \n        for u, v, w in edges:\n            if uf.union(u, v):\n                cost += w\n        \n        return cost", "class Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        # [[0,0],[2,2],[3,10],[5,2],[7,0]]\n        \n                # edge[i].append([x+y,j])\n                # edge[j].append([x+y,i])\n        # print(edge)\n        self.graph=[]\n        def find(par,i):\n            if par[i]==i:\n                return i\n            return find(par,par[i])\n\n        def union(par, rank, x, y): \n            xroot = find(par, x) \n            yroot = find(par, y) \n            if rank[xroot] < rank[yroot]: \n                par[xroot] = yroot \n            elif rank[xroot] > rank[yroot]: \n                par[yroot] = xroot \n            else : \n                par[yroot] = xroot \n                rank[xroot] += 1\n\n\n        def kruskal(): \n\n            result =[] #This will store the resultant MST \n\n            i = 0 # An index variable, used for sorted edges \n            e = 0 \n            self.graph =  sorted(edges,key=lambda item: item[2]) \n\n            par = []\n            rank = [] \n\n            # Create V subsets with single elements \n            for node in range(len(A)): \n                par.append(node) \n                rank.append(0) \n\n            # Number of edges to be taken is equal to V-1 \n            while e < len(A) -1 : \n\n                # Step 2: Pick the smallest edge and increment  \n                        # the index for next iteration \n                u,v,w =  self.graph[i] \n                i = i + 1\n                x = find(par, u) \n                y = find(par ,v) \n\n                # If including this edge does't cause cycle,  \n                            # include it in result and increment the index \n                            # of result for next edge \n                if x != y: \n                    e = e + 1     \n                    result.append([u,v,w]) \n                    union(par, rank, x, y) \n            return result\n            # Else discard the edge \n                \n        edge=defaultdict(list)\n        edges=[]\n        \n        \n        for i in range(len(A)):\n            for j in range(i+1,len(A)):\n                x=abs(A[i][0]-A[j][0])\n                y=abs(A[i][1]-A[j][1])\n                edges.append([i,j,x+y])\n        res=kruskal()\n        main=0\n        for i in res:\n            main+=i[-1]\n        return main\n\n", "\n               \ndef find_root(parents, i):\n    if parents[i] == -1:\n        return i\n    else:\n        return find_root(parents, parents[i])\n   \ndef calc_dist(p1, p2):\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1:\n            return 0\n       \n        graph = []\n        n = len(points)\n       \n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                dist = calc_dist(points[i], points[j])\n                heapq.heappush(graph, [dist, (i, j)])\n       \n        parents = [-1] * len(points)\n        cost = 0\n        count = 0\n        # print (graph)\n        while count < n - 1:\n            dist, point_pair = heapq.heappop(graph)\n            # print(dist, point_pair)\n            p1, p2 = point_pair[0], point_pair[1]\n           \n            r1 = find_root(parents, p1)\n            r2 = find_root(parents, p2)\n           \n            if r1 != r2:\n                parents[r1] = r2\n                cost = cost + dist\n                count = count + 1\n       \n        return cost", "class Solution:\n    def minCostConnectPoints(self, points):\n        n = len(points)\n        graph = [[] for i in range(n)]\n        for i in range(n):\n            for j in range(i+1,n):\n                dist = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                graph[i].append([j,dist])\n                graph[j].append([i,dist])\n\n        return mst(n,graph)\n\n        \ndef mst(n,graph):\n\n    keyval = [2**31-1]*(n)\n    keyval[0] = 0\n    mst = [False]*(n)\n\n    for i in range(n):\n        u = minVal(keyval, mst)\n\n        mst[u] = True\n\n        for node in graph[u]:\n            if mst[node[0]]==False and keyval[node[0]]>node[1]:\n                keyval[node[0]] = node[1]\n\n    return sum(keyval[1:])\n\ndef minVal(keyval, mst):\n    minv = 2**31-1\n    minInd = 0\n    for i in range(1,len(keyval)):\n        if minv>keyval[i] and mst[i]==False:\n            minv = keyval[i]\n            minInd = i\n\n    return minInd\n", "class DSU:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n        self.count = n\n    \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self,x,y):\n        px = self.find(x)\n        py = self.find(y)\n        if px==py:\n            return False\n        self.count-=1\n        if self.rank[x]>self.rank[y]:\n            self.parent[py]=px\n            self.rank[px]+=self.rank[py]\n        else:\n            self.parent[px]=py\n            self.rank[py]+=self.rank[px]\n        return True\n                \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        heapq.heapify(edges)\n        res = 0\n        ds = DSU(n)\n        while ds.count!=1:\n            cost,u,v = heapq.heappop(edges)\n            if ds.union(u,v):\n                res += cost\n        return res", "from typing import List\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        \n        P = [i for i in range(N)]\n        E = []\n        \n        for u in range(N):\n            x1, y1 = points[u]\n            for v in range(u + 1, N):\n                x2, y2 = points[v]\n                \n                E.append((u, v, abs(x1 - x2) + abs(y1 - y2)))\n\n                \n        E.sort(key = lambda edge: edge[2])\n\n        def getParent(x):\n            if x != P[x]:\n                P[x] = getParent(P[x])\n\n            return P[x]\n\n        def join(u, v):\n            pu = getParent(u)\n            pv = getParent(v)\n\n            if pu == pv:\n                return False\n\n            P[pu] = pv\n            return True    \n\n        rs, count = 0, 0\n        for u, v, w in E:\n            if join(u, v):\n                rs = rs + w\n                count = count + 1\n            \n            if count == N:\n                break\n        \n        return rs\n", "# Kruskal\nclass UnionFindSet:\n    def __init__(self, n):\n        self.parents = [i for i in range(n + 1)]\n        self.ranks = [0 for i in range(n + 1)]\n        \n    def find(self, u):\n        if u != self.parents[u]:\n            self.parents[u] = self.find(self.parents[u])            \n        return self.parents[u]\n    \n    def union(self, u, v):\n        pu = self.find(u)\n        pv = self.find(v)\n        if pu == pv: return False\n        \n        if self.ranks[pu] < self.ranks[pv]:\n            self.parents[pu] = pv\n        elif self.ranks[pu] > self.ranks[pv]:\n            self.parents[pv] = pu\n        else:\n            self.parents[pu] = pv\n            self.ranks[pv] += 1\n            \n        return True\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append([abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j])\n        edges.sort()\n        ans = 0\n        count = 0\n        uf = UnionFindSet(n)\n        for e in edges:\n            if not uf.union(e[1], e[2]): continue\n            ans += e[0]\n            count += 1\n            if count == n - 1: return ans\n            \n        return ans\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        a = points\n        n = len(a)\n        def d(i, j): return abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1])\n        q = []\n        dst = [float('inf')]*n\n        vis = [False] * n\n        def consider(du, u):\n            if vis[u] or du >= dst[u]: return\n            dst[u] = du\n            heappush(q, (du, u))\n        consider(0, 0)\n        while q:\n            du, u = heappop(q)\n            if vis[u]: continue\n            vis[u] = True\n            for v in range(n): consider(d(u, v), v)\n        return sum(dst)\n            \n", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) <= 1:\n            return 0\n        edge_list = []\n        for idx1, [x1, y1] in enumerate(points):\n            for idx2, [x2, y2] in enumerate(points[idx1+1:], idx1+1):\n                heappush(edge_list, [abs(x1-x2)+abs(y1-y2), idx1, idx2])\n\n        cost, p1, p2 = heappop(edge_list)\n        add_point = {p1, p2}\n        ret = cost\n        while len(add_point) != len(points) and edge_list:\n            temp_list = []\n            flag = False\n            while not flag:\n                cost, p1, p2 = heappop(edge_list)\n                if p1 in add_point and p2 in add_point:\n                    continue\n                elif p1 not in add_point and p2 not in add_point:\n                    temp_list.append([cost, p1, p2])\n                else:\n                    add_point.add(p1)\n                    add_point.add(p2)\n                    ret += cost\n                    flag = True\n            while temp_list:\n                heappush(edge_list, heappop(temp_list))\n\n        return ret\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(i):\n            if parent[i] == i:\n                return i\n            return find(parent[i])\n        def union(p1,p2):\n            if size[p1] > size[p2]:\n                p1,p2=p2,p1\n            parent[p1] = p2\n            size[p2] += size[p1]\n            \n        if len(points) <= 1:\n            return 0\n        dist = []\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                dist.append((d,i,j))\n        dist.sort()\n \n        edge = 0\n        res = 0\n        parent = list(range(len(points)))\n        size = [1]*len(points)\n        for d,n1,n2 in dist:\n            p1,p2 = find(n1),find(n2)\n            if p1 == p2:\n                continue\n            res += d\n            union(p1,p2)\n            edge += 1\n            if edge == len(points)-1:\n                return res\n", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(p1, p2):\n            return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n        def find(i):\n            if parent[i] < 0: return i\n            parent[i] = find(parent[i])\n            return parent[i]\n            \n        res = 0\n        n = len(points)\n        parent = [-1]*n\n        rank = [0]*n\n        h = []\n        \n        for u in range(n):\n            for v in range(u+1, n):\n                h.append((dist(points[u], points[v]), u, v))\n                \n        heapq.heapify(h)\n        \n        while h:\n            d, u, v = heapq.heappop(h)\n            u, v = find(u), find(v)\n            if u != v:\n                res += d\n                if rank[u] > rank[v]:\n                    parent[u] += parent[v]\n                    parent[v] = u\n                else:\n                    parent[v] += parent[u]\n                    parent[u] = v\n                    if rank[u] == rank[v]: rank[v] += 1\n                \n                if parent[u] == -n: break\n                    \n        return res", "def cost(x,y):\n    return (abs(x[0]-y[0])+abs(x[1]-y[1]))\ndef find(z):\n    nonlocal p\n    a=[]\n    while p[z]!=z:\n        a.append(z)\n        z=p[z]\n    for i in a:\n        p[i]=z\n    return z\n\nclass Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:\n        nonlocal p\n        n=len(a)\n        b=[]\n        p=[i for i in range(n+1)]\n        s=[1 for i in range(n+1)]\n        for i in range(n):\n            for j in range(i+1,n):\n                b.append((i,j,cost(a[i],a[j])))\n                    \n        b.sort(key=lambda x:x[2])\n        su=0\n        for i in b:\n            x=find(i[0])\n            y=find(i[1])\n            if x!=y:\n                su+=i[2]\n                if s[x]>s[y]:\n                    p[y]=x\n                    s[x]+=s[y]\n                else:\n                    p[x]=y\n                    s[y]+=s[x]\n        return su", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def find(x):\n            if uf[x] != x:\n                uf[x] = find(uf[x])\n            return uf[x]\n        \n        def union(x, y):\n            idx = find(x)\n            idy = find(y)\n            if idx == idy:\n                return\n            uf[idy] = idx\n        \n        def dist(x, y):\n            return abs(y[0] - x[0]) + abs(y[1] - x[1])\n        \n        n = len(points)\n        uf = {i:i for i in range(n)}\n        edges = []\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                a = points[i]\n                b = points[j]\n                edges.append((i,j, dist(a, b)))\n        \n        edges = sorted(edges, key = lambda  x: x[2])\n        cost = 0\n        \n        for edge in edges:\n            x = edge[0]\n            y = edge[1]\n            if find(x) != find(y):\n                union(x, y)\n                cost += edge[2]\n        \n        return cost\n            \n        \n        \n                \n                \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ok=[-1 for i in range(len(points))]\n        def union(x,y):\n            x1=find(x)\n            x2=find(y)\n            ok[x1]=x2\n        def find(x):\n            if(ok[x]==-1):\n                return x\n            else:\n                ok[x]=find(ok[x])\n                return ok[x]\n        d=[]\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                d.append([abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),i,j])\n        d.sort()\n        ans=0\n        count=0\n        for i in d:\n            x=find(i[1])\n            y=find(i[2])\n            if(x!=y):\n                union(i[1],i[2])\n                ans+=i[0] \n                count+=1\n            if(count==len(points)-1):\n                return ans\n            \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda u, v: abs(u[0] - v[0]) + abs(u[1] - v[1])\n        from collections import defaultdict\n        n = len(points)\n\n        graph = defaultdict(list)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                w = manhattan(points[i], points[j])\n                graph[i].append((w, j))\n                graph[j].append((w, i))\n\n        k = 0\n        costs = 0\n        seen = [False] * n\n\n        heap = [(0, 0)]\n        while heap:\n            w, u = heapq.heappop(heap)\n            if not seen[u]:\n                seen[u] = True\n                costs += w\n                k += 1\n\n                if k == n: break\n                for ew, v in graph[u]:\n                        heapq.heappush(heap, (ew, v))\n        return costs\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        uf = {}\n        n = len(points)\n        rank = [1] * n\n        \n        def find(x):\n            uf.setdefault(x, x)\n            if uf[x] != x:\n                uf[x] = find(uf[x])\n            return uf[x]\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            if px != py:\n                if rank[px] > rank[py]:\n                    px, py = py, px\n                rank[py] += rank[px]\n                uf[px] = py\n                return rank[py] == n\n            return False\n        \n        hp = [(abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j) for i in range(n) for j in range(i + 1, n)]\n        heapq.heapify(hp)\n        ans = 0\n        \n        while hp:\n            d, i, j = heapq.heappop(hp)\n            if find(i) != find(j):\n                ans += d\n                if union(i, j):\n                    break\n                \n        return ans\n    \n        \n        \n        # n = len(points)\n        # dist = lambda x, y: abs(x[0] - y[0]) + abs(x[1] - y[1])\n        # dic = collections.defaultdict(list)\n        # for i in range(n):\n        #     for j in range(i + 1, n):\n        #         d = dist(points[i], points[j])\n        #         dic[i].append((d, j))\n        #         dic[j].append((d, i))\n        # hp = dic[0]\n        # heapq.heapify(hp)\n        # ans, cnt, seen = 0, 1, [1] + [0] * (n - 1)\n        # while hp:\n        #     d, i = heapq.heappop(hp)\n        #     if not seen[i]:\n        #         ans += d\n        #         cnt += 1\n        #         seen[i] = 1\n        #         for j in dic[i]:\n        #             heapq.heappush(hp, j)\n        #         if cnt == n:\n        #             break\n        # return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, graph = len(points), collections.defaultdict(dict)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                graph[i][j] = graph[j][i] = d\n\n        cnt, ans, visited = 0, 0, [0] * n\n        heap = [(0, 0)]\n        d = [float('inf')] * n\n        d[0] = 0\n\n        while heap:\n            cost, node = heapq.heappop(heap)\n            if visited[node]:\n                continue\n            visited[node], cnt, ans = 1, cnt + 1, ans + cost\n            for nex in graph[node]:\n                if d[nex] > graph[node][nex]:\n                    d[nex] = graph[node][nex]\n                    heapq.heappush(heap, (d[nex], nex))\n            # if cnt >= n: break        \n        return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        cache = list(range(len(points)))\n\n        def find(val):\n            if cache[val] != val:\n                cache[val] = find(cache[val])\n            return cache[val]\n\n        def union(x, y):\n            cache[find(x)] = cache[find(y)]\n\n        dists = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                dists.append((dist, i, j))\n\n        dists.sort()\n        ans = 0\n        count = 0\n        n = len(points)\n        for dist, a, b in dists:\n            if find(a) != find(b):\n                count += 1\n                ans += dist\n                union(a, b)\n\n            if count >= n - 1:\n                break\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # for each point, you need to find the nearest point \n        import heapq\n        \n        graph = self.build_graph(points)\n        min_heap = []\n        start = 0\n  \n        for dist, node in graph[start]:\n            heapq.heappush(min_heap, (dist, node))\n        \n        visited = set()\n        visited.add(start)\n        res = cnt = 0\n        \n        while len(min_heap) > 0:\n            dist, node = heapq.heappop(min_heap)\n            if cnt == len(points) - 1:\n                break\n            \n            if node not in visited:\n                res += dist \n                cnt += 1 \n                visited.add(node)\n                for nxt_dist, nxt_node in graph[node]:\n                    heapq.heappush(min_heap, (nxt_dist, nxt_node)) \n            \n        return res\n    \n    def build_graph(self, points):\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for i in range(len(points)):\n            for j in range(len(points)):\n                if i == j:\n                    continue\n                graph[i].append((self.dist(points[i], points[j]), j))\n        return graph\n                \n    \n    def dist(self, p0, p1):\n        x0, y0 = p0\n        x1, y1 = p1\n        return abs(x1 - x0) + abs(y1 - y0)", "class Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        #kruskal:\n        n = len(A)\n        distance_arr = []\n        for i in range(n):\n            for j in range(i+1, n):\n                distance_arr.append([abs(A[j][0]-A[i][0])+abs(A[j][1]-A[i][1]), i, j])\n        \n        distance_arr.sort()\n        root = [i for i in range(n)]\n        \n        def find(x):\n            if root[x] != x:\n                root[x] = find(root[x])\n            return root[x]\n        \n        cnt = 0\n        sm = 0\n        for dis, x, y in distance_arr:\n            if find(x) == find(y):\n                continue\n            root[find(x)] = find(y)\n            cnt += 1\n            sm += dis\n            if cnt == n-1:\n                break\n        return sm", "class Solution:\n    def find(self, roots, x):\n        if x == roots[x]:\n            return x\n        return self.find(roots, roots[x])\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        n = len(points)\n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                d = abs(x1 - x2) + abs(y1 - y2)\n                edges.append((d, i, j))\n        edges.sort()\n        roots = list(range(n))\n        ranks = [0] * n\n        count = 0\n        res = 0\n        for d, x, y in edges:\n            rx = self.find(roots, x)\n            ry = self.find(roots, y)\n            if rx != ry:                \n                if ranks[rx] > ranks[ry]:\n                    roots[ry] = rx\n                elif ranks[rx] < ranks[ry]:\n                    roots[rx] = ry\n                else:\n                    roots[ry] = rx\n                    ranks[rx] += 1\n                count += 1\n                res += d\n                if count == n - 1:\n                    return res\n        \n        return res", "class UnionFind:\n    def __init__(self):\n        self.parents = {}\n        self.sizes = {}\n\n    def findParent(self, x):\n        if x not in self.parents:\n            self.parents[x] = x\n            self.sizes[x] = 1\n\n            return x\n\n        if self.parents[x] != x:\n            self.parents[x] = self.findParent(self.parents[x])\n\n        return self.parents[x]\n\n    def union(self, x, y):\n        rootX, rootY = self.findParent(x), self.findParent(y)\n\n        if rootX == rootY:\n            return\n\n        if self.sizes[rootX] < self.sizes[rootY]:\n            self.sizes[rootY] += self.sizes[rootX]\n            self.parents[rootX] = rootY\n        else:\n            self.sizes[rootX] += self.sizes[rootY]\n            self.parents[rootY] = rootX\n\n    def numberOfComponents(self):\n        return sum(1 for x, p in self.parents.items() if x == p)\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(x1,y1,x2,y2):\n            return abs(x1-x2) + abs(y1-y2)\n        \n        uf = UnionFind()\n        N = len(points)\n        edges = []\n        \n        ans = 0\n        \n        for i in range(N):\n            for j in range(i+1, N):\n                [x1,y1],[x2,y2] = points[i], points[j]\n                edges.append([dist(x1,y1,x2,y2), i, j])\n        \n        edges.sort()\n        ans = 0\n        \n        edgesTaken = 0\n        i = 0\n        \n        while edgesTaken < N-1:\n            d, x, y = edges[i]\n            \n            if uf.findParent(x) != uf.findParent(y):\n                uf.union(x, y)\n                ans += d\n                edgesTaken += 1\n            \n            i += 1\n            \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def minnode(n, keyval, mstset): \n            mini = 999999999999\n            mini_index = None\n\n            # Loop through all the values of  \n            # the nodes which are not yet  \n            # included in MST and find the  \n            # minimum valued one. \n            for i in range(n): \n                if (mstset[i] == False and \n                    keyval[i] < mini):  \n                    mini = keyval[i] \n                    mini_index = i \n            return mini_index \n        \n        \n        def findcost(n, city): \n  \n            # Array to store the parent  \n            # node of a particular node.  \n            parent = [None] * n \n\n            # Array to store key value  \n            # of each node.  \n            keyval = [None] * n  \n\n            # Boolean Array to hold bool  \n            # values whether a node is \n            # included in MST or not.  \n            mstset = [None] * n \n\n            # Set all the key values to infinite and  \n            # none of the nodes is included in MST. \n            for i in range(n): \n                keyval[i] = 9999999999999\n                mstset[i] = False\n\n            # Start to find the MST from node 0.  \n            # Parent of node 0 is none so set -1.  \n            # key value or minimum cost to reach  \n            # 0th node from 0th node is 0.  \n            parent[0] = -1\n            keyval[0] = 0\n\n            # Find the rest n-1 nodes of MST. \n            for i in range(n - 1): \n\n                # First find out the minimum node  \n                # among the nodes which are not yet  \n                # included in MST.  \n                u = minnode(n, keyval, mstset)  \n\n                # Now the uth node is included in MST.  \n                mstset[u] = True\n\n                # Update the values of neighbor  \n                # nodes of u which are not yet  \n                # included in MST.  \n                for v in range(n): \n                    if (city[u][v] and mstset[v] == False and \n                        city[u][v] < keyval[v]):  \n                        keyval[v] = city[u][v]  \n                        parent[v] = u \n\n            # Find out the cost by adding  \n            # the edge values of MST.  \n            cost = 0\n            for i in range(1, n): \n                cost += city[parent[i]][i]  \n            return cost\n    \n        n = len(points)\n        city = [[0 for c in range(n)] for r in range(n)]\n        \n        for r in range(n):\n            c1 = points[r]\n            for c in range(n):\n                c2 = points[c]\n                \n                val = abs(points[r][0] - points[c][0]) + abs(points[r][1] - points[c][1])\n                city[r][c] = val\n        \n        return findcost(n, city)\n        \n        \n        \n", "from queue import PriorityQueue\nimport math\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # Get lengths of edges, put into Priority Queue\n#         q = PriorityQueue()\n#         for i, point1 in enumerate(points):\n#             for j, point2 in enumerate(points):\n#                 if i == j: continue\n#                 dist = abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n#                 q.put((dist, (i, j)))\n                \n        q = []\n        for i in range(len(points)) :\n            xi, yi = points[i]\n            for j in range(i+1, len(points)) :\n                xj, yj = points[j]\n                q.append([abs(xi-xj)+abs(yi-yj), i, j])\n        q = sorted(q)\n        \n        # For each edge in PQ, grab it, check if it forms a cycle in graph\n        # If not, add it to the graph.\n        # Increment cost.\n        # We can check for a cycle with union find algorithm. (basically check parents)\n        cost = 0\n        self.arr = [-1 for el in range(len(points))]\n        for el in q:\n            d, p1, p2 = el[0], el[1], el[2]\n            cycle = self.isCycle(p1, p2)\n            # print(\\\"cycle\\\", cycle)\n            if not cycle:\n                cost += d\n                # print(\\\"adding d\\\", d)\n                self.combinePoints(p1, p2)\n            else:\n                continue\n            if self.isDone(): break\n            # print(self.arr)\n        return cost\n    \n    def isDone(self):\n        n_neg = 0\n        for val in self.arr:\n            if val < 0: n_neg += 1\n        if n_neg ==1 : return True\n        return False\n        \n    \n    def combinePoints(self, p1, p2):\n        # Find parent of p1, get size\n        # Find parent of p2, get size\n        # Whichever is smaller, make the smaller parent point to the larger parent.\n        # Update the larger parent by adding the size of the smaller parent (keep negatives)\n        parent1, children1 = self.getParent(p1, [])\n        # print(p1, parent1)\n        size1 = self.arr[parent1]\n        parent2, children2 = self.getParent(p2, [])\n        size2 = self.arr[parent2]\n        \n        # If parent2 is bigger\n        if abs(size2) > abs(size1):\n            self.arr[parent1] = parent2\n            self.arr[parent2] = size2 + size1\n            self.updateChildren(children1, parent2)\n        else:\n            self.arr[parent2] = parent1\n            self.arr[parent1] = size2 + size1\n            self.updateChildren(children2, parent1)\n        \n    def isCycle(self, p1, p2):\n        parent1, _ = self.getParent(p1, [])\n        parent2, _ = self.getParent(p2, [])\n        if parent1 == parent2:\n            return True\n        else:\n            return False\n    \n    def getParent(self, p1, children):\n        if self.arr[p1] < 0: return p1, children\n        else:\n            children.append(p1)\n            return self.getParent(self.arr[p1], children)\n        \n    def updateChildren(self, children, parent):\n        for child in children:\n            self.arr[child] = parent\n        \n\n", "class Solution:\n    \\\"\\\"\\\"MST\n    778. swim-in-rising-water\n    787. cheapest-flights-within-k-stops\n    1102. path-with-maximum-minimum-value\n    1135. connecting-cities-with-minimum-cost\n    1584. min-cost-to-connect-all-points\n    \\\"\\\"\\\"\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def hm(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        g = collections.defaultdict(list)\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dist = hm(points[i], points[j])\n                g[i].append((dist, j))\n                g[j].append((dist, i))\n        # print(g)\n        \n        visited = set()\n        pq = [(0, 1)]\n        res = 0\n        while len(visited) < len(points):\n            cost, p = heapq.heappop(pq)\n            if p not in visited:\n                res += cost\n                visited.add(p)\n                for nei_cost, nei_p in g[p]:\n                    heapq.heappush(pq, (nei_cost, nei_p))\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # MST\n        dist = []\n        n = len(points)\n        for i in range(n):\n            for j in range(i):\n                p1 = points[i]\n                p2 = points[j]\n                dist.append((abs(p1[0]-p2[0])+abs(p1[1]-p2[1]), i, j))\n        dist.sort()\n        ps = list(range(n))\n        def find(x):\n            while ps[x]!=x:\n                ps[x] = ps[ps[x]]\n                x = ps[x]\n            return x\n        \n        def union(x, y):\n            px = find(x)\n            py = find(y)\n            if px == py:\n                return False\n            else:\n                ps[px] = py\n                return True\n        res = 0\n        for d, x, y in dist:\n            if union(x, y):\n                res += d\n        \n        return res\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        vertices = {}\n        x, y = points[0][0], points[0][1]\n        \n        for u, v in points: \n            vertices[(u, v)] = abs(u - x) + abs(v - y)\n            \n        def mindistance() -> tuple:\n            \n            Node = None\n            \n            for node in vertices:\n                \n                if not Node: Node = node\n                elif vertices[node] < vertices[Node]: Node = node\n            \n            return Node\n        \n        n = len(points)\n        Cost = 0\n        \n        for i in range(n):\n            \n            temp = mindistance()\n            Cost += vertices[temp]\n            vertices.pop(temp)\n            \n            for c in vertices:\n                vertices[c]  = min(vertices[c], abs(c[0] - temp[0]) + abs(c[1] - temp[1]))\n                \n        return Cost\n                    \n            \n", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        Prim's Algo - minimum spanning tree\n        \\\"\\\"\\\"\n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        res, n = 0, len(points)\n        heap = [(0, (0, 0))]\n        seen = set()\n        \n        while len(seen) < n:\n            w, (u, v) = heapq.heappop(heap)\n            if u in seen and v in seen:\n                continue\n            res += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j != v:\n                    heapq.heappush(heap, (manhattan(points[v], points[j]), (v, j)))\n        \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def md(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        q = [md(points[0], p) for p in points]\n        print(q)\n        res = 0\n        for _ in range(len(points) - 1):\n            d, j = min((d, j) for j, d in enumerate(q) if d > 0)\n            print((d, j))\n            res += d\n            q = [min(q[i], md(points[i], points[j])) for i in range(len(q))]\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        if len(points) ==1:\n            return 0\n        heap = []      \n        visited = set()        \n        res = 0\n        \n        cur = 0\n        visited.add(0)\n        \n        while len(visited)!=len(points):\n            \n            for i in range(len(points)):\n                if cur==i:\n                    continue\n                heapq.heappush(heap, (abs(points[i][0]-points[cur][0])+abs(points[i][1]-points[cur][1]), i))\n                \n            while True:\n                val, nxt = heapq.heappop(heap)\n               \n                if nxt not in visited:\n                    \n                    visited.add(nxt)\n                    res+=val\n                    cur = nxt\n                    break\n        \n        return res\n            \n        \n", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        def find(x):\n            if dp[x]!=x:\n                dp[x]=find(dp[x])\n            return dp[x]\n\n        def uni(x,y):\n            x,y=find(x),find(y)\n            if x!=y:\n                dp[x]=find(y)\n                return False   \n            return True\n            \n        n=len(p)\n        dp=list(range(n))    \n\n        pool=sorted((abs(p[i][0]-p[j][0])+abs(p[i][1]-p[j][1]),i,j) for i in range(n) for j in range(i+1,n))\n        \n        ct=res=0\n        \n\n        for dis,u,v in pool:\n            if not uni(u,v):\n                res+=dis\n                ct+=1\n            if ct==n-1:\n                break\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        import heapq\n        \n        connect = list(range(N))\n        def find(x):\n            if connect[x]!=x:\n                connect[x] = find(connect[x])\n            return connect[x]\n        \n        def union(x, y):\n            connect[find(x)] = find(y)\n        \n        \n        q = []\n        for i in range(N):\n            for j in range(i):\n                w = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                q.append((w, i, j))\n        q.sort()\n        \n        res = 0\n        for w, i, j in q:\n            if find(i) == find(j):\n                continue\n            else:\n                res += w\n                union(i, j)\n        \n        return res\n                \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        parents = {}\n        def find(p):\n            if p not in parents:\n                parents[p] = p\n            if parents[p] != p:\n                parents[p] = find(parents[p])\n            return parents[p]\n        \n        def merge(p, q):\n            i,j = find(p), find(q)\n            if i != j:\n                parents[j] = i\n        \n        def isconnected(p, q):\n            return find(p) == find(q)\n        \n        n = len(points)\n        pq = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(pq, [dist, i, j])\n            \n        edge = 0\n        res = 0\n        while edge < n-1:\n            dist, i, j = heapq.heappop(pq)\n            if isconnected(i,j):\n                continue\n            else:\n                edge += 1\n                res += dist\n                merge(i, j)\n        return res\n", "class Ufs:\n    def __init__(self, n):\n        self.p = [i for i in range(n)]\n        self.rank = [0 for i in range(n)]\n    def find(self, i):\n        if self.p[i]!=i:\n            self.p[i] = self.find(self.p[i])\n        return self.p[i]\n    def union(self, a, b):\n        aroot = self.find(a)\n        broot = self.find(b)\n        if aroot == broot:\n            return \n        if self.rank[aroot]<self.rank[broot]:\n            self.p[aroot] = broot\n        elif self.rank[aroot]>self.rank[broot]:\n            self.p[broot] = aroot\n        else:\n            self.p[aroot] = broot\n            self.rank[broot] +=1\n    def connect(self, a, b):\n        if self.find(a)==self.find(b):\n            return True\n        else:\n            return False\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        calc = lambda x,y: abs(x[0]-y[0])+abs(x[1]-y[1])\n        edges = []\n        n = len(points)\n        vis = {}\n        for i in range(n):\n            for j in range(i+1,n):\n                edges.append([calc(points[i], points[j]), i, j])\n        edges.sort()\n        ans = 0\n        ufs = Ufs(n)\n        cnt = i = 0\n        while(cnt<n-1):\n            w, u, v = edges[i]\n            i +=1\n            if ufs.connect(u,v):\n                continue\n            ans +=w\n            ufs.union(u,v)\n            cnt+=1\n        return ans\n                \n", "from collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = defaultdict(list)\n        n = len(points)\n        for i in range(n-1):\n            x,y = points[i]\n            for j in range(i+1, n):\n                u,v = points[j]\n                d = abs(x-u) + abs(y-v)\n                edges[d].append((i,j))\n        find = {i:i for i in range(n)}\n        union = {i:set([i]) for i in range(n)}\n        cost = 0\n        m = n-1\n        min_edges = sorted(edges.keys())\n        while m>0:\n            d = min_edges.pop(0)\n            j = 0\n            while m>0 and j<len(edges[d]):\n                u,v = edges[d][j]\n                if find[u]!=find[v]:\n                    x = min(find[u], find[v])\n                    y = max(find[u], find[v])\n                    \n                    for z in union[y]:\n                        find[z] = x\n                    \n                    union[x] = union[x] | union[y]\n                    \n                    cost += d\n                    m -= 1\n                j += 1\n        return cost\n", "class DSU:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n        self.count = n\n    \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self,x,y):\n        px = self.find(x)\n        py = self.find(y)\n        if px==py:\n            return False\n        self.count-=1\n        if self.rank[x]>self.rank[y]:\n            self.parent[py]=px\n            self.rank[px]+=self.rank[py]\n        else:\n            self.parent[px]=py\n            self.rank[py]+=self.rank[px]\n        return True\n                \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        # print(edges)\n        # edges.sort()\n        heapq.heapify(edges)\n        res = 0\n        ds = DSU(n)\n        while edges and ds.count!=1:\n            cost,u,v = heapq.heappop(edges)\n            if ds.union(u,v):\n                res += cost\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # for each point, you need to find the nearest point \n        import heapq\n        \n        graph = self.build_graph(points)\n        min_heap = []\n        start = 0\n  \n        for dist, node in graph[start]:\n            heapq.heappush(min_heap, (dist, node))\n        \n        visited = set()\n        visited.add(start)\n        res = cnt = 0\n        \n        while len(min_heap) > 0:\n            dist, node = heapq.heappop(min_heap)\n            if node not in visited:\n                res += dist \n                cnt += 1 \n                visited.add(node)\n                for nxt_dist, nxt_node in graph[node]:\n                    heapq.heappush(min_heap, (nxt_dist, nxt_node)) \n            \n            if cnt == len(points) - 1:\n                break\n            \n        return res\n    \n    def build_graph(self, points):\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for i, p0 in enumerate(points):\n            for j, p1 in enumerate(points):\n                if i == j:\n                    continue\n                graph[i].append((self.dist(p0, p1), j))\n        return graph\n                \n    \n    def dist(self, p0, p1):\n        x0, y0 = p0\n        x1, y1 = p1\n        return abs(x1 - x0) + abs(y1 - y0)", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        num_of_points = len(points)\n        if num_of_points == 1:\n            return 0\n        distance = [[float(\\\"inf\\\") for _ in range(num_of_points)] for _ in range(num_of_points)]\n        for i in range(num_of_points):\n            for j in range(i+1, num_of_points):\n                temp_distance = self.countDistance(points[i], points[j])\n                distance[i][j] = temp_distance\n                distance[j][i] = temp_distance\n        visited = [False for _ in range(num_of_points)]\n        q = [(0, 0)]\n        cost = 0\n        heapq.heapify(q)\n        while False in visited:\n            # print(visited)\n            d, node= heapq.heappop(q)\n            while visited[node]:\n                d, node = heapq.heappop(q)\n            visited[node] = True\n            cost += d\n            for i in range(num_of_points):\n                if not visited[i]:\n                    heapq.heappush(q, (distance[node][i], i))\n        return cost\n            \n    \n            \n    def countDistance(self, p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        \n        def find(u):\n                \n            while parents[u]>=0:\n                u = parents[u]\n            \n            return u\n        \n        def union(u,v):\n             \n            if parents[u]<parents[v]:\n                parents[u] += parents[v]\n                parents[v] = u\n            \n            else:\n                parents[v]+=parents[u]\n                parents[u]=v\n                \n        n = len(points)\n        costs = {}\n        \n        for i in range(n):\n            for j in range(i+1,n):\n                costs[(i,j)] = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                \n        sorted_costs = sorted(list(costs.items()), key=lambda cost: -cost[1])\n        \n        s = set()\n        cost = 0\n        parents = [-1]*n\n        \n        while sorted_costs:\n            \n            (u,v),weight = sorted_costs.pop()\n            \n            pu = find(u)\n            pv = find(v)\n            \n            if (pu!=pv):\n                union(pu,pv)\n                cost+=weight\n            \n        return cost\n    \n        \n", "from heapq import heappush, heappop\nclass Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        def helper(i, j):\n            return abs(p[j][0]-p[i][0]) + abs(p[j][1]-p[i][1])\n        \n        g = defaultdict(lambda: {}); n = len(p)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                g[i][j] = g[j][i] = helper(i,j)\n\n        visited = set(); res = 0; q = []; cnt=0\n        heappush(q, (0, 0)) # u:0, cost:0\n        while q:\n            cost, u = heappop(q)\n            if u in visited: continue\n            res += cost\n            #cnt += 1\n            for v, w in g[u].items():\n                heappush(q, (w, v))\n            visited.add(u)\n            #if cnt >= n: break\n            if len(visited) >= n: break\n        return res\n        \n        \n    \n\\\"\\\"\\\"\n[[0,0],[2,2],[3,10],[5,2],[7,0]]\n[[3,12],[-2,5],[-4,1]]\n[[0,0],[1,1],[1,0],[-1,1]]\n[[-1000000,-1000000],[1000000,1000000]]\n[[0,0]]\n\\\"\\\"\\\"            ", "from queue import PriorityQueue as PQ\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        dist = [[] for _ in range(n)]\n        for i in range(n):\n            xi, yi = points[i]\n            for j in range(i+1, n):\n                xj, yj = points[j]\n                d = abs(xi-xj) + abs(yi-yj)\n                dist[i].append((j, d))\n                dist[j].append((i, d))\n        chosen = set([0])\n        pq = PQ()\n        seen = [0]*n\n        for i, d in dist[0]:\n            pq.put((d, i))\n            seen[i] = d\n        ans, edges = 0, 0\n        while not pq.empty() and edges < n-1:\n            d, i = pq.get()\n            if i not in chosen:\n                chosen.add(i)\n                ans += d\n                edges += 1\n                for j, dj in dist[i]:\n                    if j not in chosen and dj < seen[j]:\n                        pq.put((dj, j))\n                        seen[j] = dj\n        return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def md(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        q = [md(points[0], p) for p in points]\n        #print(q)\n        res = 0\n        n = len(points)\n        for _ in range(n - 1):\n            d, j = min((d, j) for j, d in enumerate(q) if d > 0)\n            #print(d, j)\n            res += d\n            q = [min(q[i], md(points[i], points[j])) for i in range(n)]\n        return res\n", "class DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n        \n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n    \n    def union(self, a, b):\n        pa, pb = self.parent[a], self.parent[b]\n        if pa == pb:\n            return \n        \n        if self.rank[a] > self.rank[b]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n            \n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa]\n\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        # minimum spanning tree\n        man_dist = lambda a, b: abs(a[0] - b[0]) + abs(a[1] - b[1])\n        \n        n = len(points)\n        \n        all_dists = []\n        for i in range(n):\n            for j in range(i+1, n):\n                all_dists.append((man_dist(points[i], points[j]), i, j))\n                \n                \n        all_dists.sort(key=lambda x: x[0])\n        \n        # print(all_dists)\n        # print(len(all_dists))\n        \n        ans = 0\n        dis_set = DisjointSet(n)\n        \n        for dist, u, v in all_dists:\n            if dis_set.find(u) != dis_set.find(v):\n                dis_set.union(u, v)\n                ans += dist\n                \n                \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1:\n            return 0\n        \n        neibors = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                point1 = points[i]\n                point2 = points[j]\n                dis = abs(point1[0]-point2[0]) + abs(point1[1]-point2[1])\n                neibors.append((dis, i, j))\n        neibors_sorted = sorted(neibors)\n        \n        unions = {i:i for i in range(len(points))}\n        \n        def find(i):\n            if unions[i] == i:\n                return i\n            else:\n                unions[i] = find(unions[i])\n                return unions[i]\n        \n        ret = 0\n        line = 0\n        for neibor in neibors_sorted:\n            if find(neibor[1]) != find(neibor[2]):\n                unions[find(neibor[1])] = find(neibor[2])\n                ret += neibor[0]\n                line += 1\n                if line == (len(points)-1):\n                    return ret\n            else:\n                continue\n            \n            \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # dikstra algo\n        if len(points) == 0:\n            return 0\n        heap = []\n        for i in range(1, len(points)):\n            heapq.heappush(heap, (abs(points[i][0] - points[0][0]) + abs(points[i][1] - points[0][1]), i))\n        ret = 0\n        while heap:\n            cost, e_pop = heapq.heappop(heap)\n            ret += cost\n            heap_new = []\n            for cost_old, e in heap:\n                heapq.heappush(heap_new, (min(cost_old, abs(points[e][0] - points[e_pop][0]) + abs(points[e][1] - points[e_pop][1])), e))\n            heap = heap_new\n        return ret\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n\\t\\t\n        for i in range(n):\n            for j in range(i+1, n):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((d, i, j))\n        \n        edges.sort()\n        \n        roots = [i for i in range(n)]\n        \n        def find(v):\n            if roots[v] != v:\n                roots[v] = find(roots[v])\n            return roots[v]\n        \n        def union(u, v):\n            p1 = find(u); p2 = find(v)\n            if p1 != p2:\n                roots[p2] = roots[p1]\n                return True\n            return False\n        \n        res = 0\n        for d, u, v in edges:\n            if union(u, v):\n                res += d\n        return res", "class Solution:\n    def getWeight(self, x, y):\n        xi, xj = x[0], x[1]\n        yi, yj = y[0], y[1]\n        return abs(xi - yi) + abs(xj - yj)\n    \n    def find(self, parent, i):\n        if parent[i] == i: return i\n        return self.find(parent, parent[i])\n\n    def union(self, parent, rank, x, y):\n        xroot = self.find(parent, x)\n        yroot = self.find(parent, y)\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        E = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                u = points[i]\n                v = points[j]\n                E.append([i, j, self.getWeight(u, v)])\n        E = sorted(E, key=lambda item: item[2])\n        parent = []\n        rank = []\n        for node in range(len(points)):\n            parent.append(node)\n            rank.append(0)\n        e = 0\n        i = 0\n        result = 0\n        while e < len(points)-1:\n            u, v, w = E[i]\n            i += 1\n            x = self.find(parent, u)\n            y = self.find(parent, v)\n            if x != y:\n                e += 1\n                result += w\n                self.union(parent, rank, x, y)\n        return result", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        def distance(p1, p2):\n            return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n        ans = 0\n        h = []\n        heappush(h, (0, points[0]))\n        visited = set()\n        \n        while h:\n            d, p = heappop(h)\n            if (p[0], p[1]) in visited:\n                continue\n            visited.add((p[0], p[1]))\n            ans += d\n            \n            for point in points:\n                if (point[0], point[1]) not in visited:\n                    heappush(h, (distance(p, point), point))\n                    \n            if len(visited) == N:\n                break\n                \n        return ans\n                    \n        \n    def minCostConnectPoints_2(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans  \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        npoints = len(points)\n        if npoints == 1:\n            return 0\n        edges = dict()\n        for i in range(npoints):\n            for j in range(i+1,npoints):\n                edges[(i,j)] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        \n        sortededges = {k: v for k,v in sorted(edges.items(), key=lambda item: item[1]) }\n\n        parent = [i for i in range(npoints)]\n        mincost = 0\n        numedges = 0\n        for edge in sortededges:\n            if self.findParent(parent, edge[0]) == self.findParent(parent, edge[1]):\n                continue\n            else:\n                mincost += sortededges[edge]\n                self.union(parent, edge[0], edge[1])\n                numedges += 1\n                if numedges == npoints-1:\n                    return mincost\n    \n    def findParent(self, parent, i):\n        if parent[i] == i:\n            return i\n        return self.findParent(parent, parent[i])\n    \n    def union(self, parent, u, v):\n        u_set = self.findParent(parent, u)\n        v_set = self.findParent(parent, v)\n        parent[u_set] = v_set", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def manhantan_distance(x, y):\n            return abs(x[0] - y[0]) + abs(x[1] - y[1])\n        \n        n = len(points)\n        included = {0}\n        distances = [manhantan_distance(points[0], point) for point in points]\n        cost = 0\n        while len(included) < n:\n            to_add = None\n            cost_to_add = float('inf')\n            for i, distance in enumerate(distances):\n                if i in included:\n                    continue\n                if distance < cost_to_add:\n                    to_add = i\n                    cost_to_add = distance\n            \n            included.add(to_add)\n            cost += cost_to_add\n            \n            new_point = points[to_add]\n            for i, point in enumerate(points):\n                new_distance = manhantan_distance(new_point, point)\n                distances[i] = min(distances[i], new_distance)\n            \n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        \n        d = []\n        for i, (xi,yi) in enumerate(points[:-1]):\n            for j, (xj,yj) in enumerate(points[i+1:]):\n                d.append([i,i+j+1,abs(xj-xi)+abs(yj-yi)])\n        d = sorted(d, key=lambda r: r[2])\n        \n        father = {i:i for i in range(n)}\n        def find(x):\n            if x != father[x]:\n                father[x] = find(father[x])\n            return father[x]\n\n        res, c = 0, 0\n        for i,j,distance in d:\n            if find(i) != find(j):\n                father[find(i)] = j\n                res += distance\n                c += 1\n                if c == n-1:\n                    return res\n            \n", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        n=len(p)\n\n        parents=list(range(n))\n        def find(x):\n            if parents[x]!=x:\n                parents[x]=find(parents[x])\n                \n            return parents[x]\n                \n        def union(x,y):\n            r1=find(x)\n            r2=find(y)\n            \n            if r1!=r2:\n                parents[r2]=r1\n                return True\n            else:\n                return False\n\n        def dist(p1,p2):\n            return abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n        \n        a=[]\n        for i in range(n):\n            for j in range(i+1,n):\n                d=dist(p[i],p[j])\n                a.append((d,i,j))\n        \n        a.sort()\n        ans=0\n        for d,p1,p2 in a:\n            if union(p1,p2):\n                ans+=d\n        \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # Prims algorithm O(V+ElogV)\n        if not points or len(points) <= 1:\n            return 0\n        \n        p_dis = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                p1 = points[i]\n                p2 = points[j]\n                dis = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n                p_dis.setdefault(i, [])\n                p_dis.setdefault(j, [])\n                p_dis[i].append((dis, j))\n                p_dis[j].append((dis, i))\n        \n        visited = [False] * len(points)\n        visited[0] = True\n        count = 1\n        heap = []\n        res = 0\n        for d, p in p_dis[0]:\n            heapq.heappush(heap, (d, p))\n        while heap:\n            dis, p = heapq.heappop(heap)\n            if not visited[p]:\n                count += 1\n                visited[p] = True\n                res += dis\n                for _d, _p in p_dis[p]:\n                    heapq.heappush(heap, (_d, _p))\n            \n            if count == len(points):\n                break\n        \n        return res\n        \n        \n        \n        # Kruskal algorithm\n#         if not points or len(points) <= 1:\n#             return 0\n        \n#         heap = []\n#         for i in range(len(points)):\n#             for j in range(i + 1, len(points)):\n#                 p1 = points[i]\n#                 p2 = points[j]\n#                 dis = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n#                 heapq.heappush(heap, (dis, i, j))\n        \n#         self.father = [i for i in range(len(points))]\n#         res = 0\n#         while heap:\n#             dis, u, v = heapq.heappop(heap)\n#             root_u = self.find(u)\n#             root_v = self.find(v)\n#             if root_u == root_v:\n#                 continue\n#             self.father[max(root_u, root_v)] = min(root_u, root_v)\n#             res += dis\n        \n#         return res\n    \n#     def find(self, x):\n#         if self.father[x] == x:\n#             return self.father[x]\n#         self.father[x] = self.find(self.father[x])\n#         return self.father[x]\n", "\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1: \n            return 0\n\n        result = 0 \n        distance = [math.inf] * len(points)  # idx -> distance \n        current = 0\n        combined = set() \n\n        for i in range(len(points)-1): \n            combined.add(current)\n            x, y = points[current]\n            for j in range(len(points)): \n                if j in combined:\n                    continue\n                x2, y2 = points[j]\n                distance[j] = min(distance[j], abs(x-x2) + abs(y-y2))\n\n            d = 0\n            for j in range(len(distance)):\n                if distance[j] < distance[current]:\n                    current = j\n                    d = distance[j]\\t\n            distance[current] = math.inf\n            result += d\n\n        return result \n\n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        parents = [i for i in range(n)]\n        def ufind(node):\n            nonlocal parents \n            if parents[node] == node:\n                return node \n            parents[node] = ufind(parents[node])\n            return parents[node] \n        \n        def union(node1, node2):\n            p1 = ufind(node1) \n            p2 = ufind(node2) \n            if p1!=p2:\n                parents[p2] = p1 \n                \n                \n        def MST(edges):\n            nonlocal n\n            edges.sort(key = lambda x: x[2]) \n            ans = 0 \n            for i in edges: \n                p1 = ufind(i[0]) \n                p2 = ufind(i[1]) \n                if p1!=p2:\n                    ans += i[2] \n                    union(p1,p2) \n            return ans \n            \n        \n        edges = []\n        for i in range(n):\n            for j in range(i+1,n):\n                edges.append((i,j, abs(points[i][0]- points[j][0]) + abs(points[i][1] - points[j][1]))) \n        return MST(edges) ", "\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        arr = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                xi, yi = points[i]\n                xj, yj = points[j]\n                arr.append([i, j, abs(xi - xj) + abs(yi - yj)])\n        arr.sort(key=lambda x: x[2])\n        visited = set()\n        res = 0\n        group = []\n        for i in range(len(arr)):\n            u, v, d = arr[i]\n            if u not in visited and v not in visited:\n                visited.add(u)\n                visited.add(v)\n                res += d\n                group.append({u, v})\n            elif u in visited and v in visited:\n                for idx, tmp in enumerate(group):\n                    if u in tmp:\n                        ui = idx\n                    if v in tmp:\n                        vi = idx\n                if ui != vi:\n                    group[ui].update(group[vi])\n                    group.pop(vi)\n                    res += d\n            else:\n                for idx, tmp in enumerate(group):\n                    if u in tmp:\n                        group[idx].add(v)\n                        break\n                    elif v in tmp:\n                        group[idx].add(u)\n                        break\n                visited.add(u)\n                visited.add(v)\n                res += d\n\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n, res = len(points), 0\n        if n <= 1: return res\n        dists = [(abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j) \n                for i in range(n-1) for j in range(i+1, n)]\n        dists.sort()\n        parents = list(range(n))\n        def find(c):\n            prec = c\n            while parents[c] != c:\n                c = parents[c]\n            union(prec, c)\n            return c\n        def union(src, dst):\n            if src != dst:\n                parents[src] = dst\n        for d, src, dst in dists:\n            ps, pd = find(src), find(dst)\n            if ps != pd:\n                res += d\n                union(ps, pd)\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(p1, p2):\n            return abs(p2[0]-p1[0]) + abs(p2[1]-p1[1])\n        \n        dist_list = [distance(points[0], p) for p in points]\n        \n        res, n = 0, len(points)\n        for _ in range(n-1):\n            d, j = min((d, j) for j, d in enumerate(dist_list) if d > 0)\n            res += d\n            dist_list = [min(dist_list[i], distance(p, points[j])) for i, p in enumerate(points)] \n            \n        return res", "class DSU:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        \n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        else: return self.find(self.parent[i])\n        \n    def union(self, i, j):\n        x, y = self.find(i), self.find(j)\n        \n        rx, ry = self.rank[x], self.rank[y]\n        \n        if rx > ry:\n            self.parent[y] = x\n            \n        elif rx < ry:\n            self.parent[x] = y\n            \n        else:\n            self.parent[y] = x\n            self.rank[x] += 1 \n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        \n        \n        for i in range(n):\n            for j in range(n):\n                dist = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                \n                edges.append((i, j, dist))\n                \n        edges.sort(key = lambda x: x[2])\n        \n        d = DSU(n)\n        \n        e = 0\n        i = 0\n        ret = 0\n        \n        while e < n-1:\n            if d.find(edges[i][0]) != d.find(edges[i][1]):\n                ret += edges[i][2]\n                d.union(edges[i][0], edges[i][1])\n                e += 1\n                \n            i += 1\n            \n            \n        return ret", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        from collections import defaultdict\n        graph = []\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                val = abs(abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]))\n                graph.append([tuple(points[i]),tuple(points[j]),val])\n        graph.sort(key = lambda x:x[-1])\n        parent = {tuple(i):tuple(i) for i in points}\n        def find(x):\n            if parent[x] == x:\n                return x\n            parent[x] = find(parent[x])\n            return parent[x]\n        def union(x,y):\n            a,b = find(x),find(y)\n            if a!=b:\n                parent[a] = b\n                return True\n            else:\n                return False\n        v = 0\n        n = len(points)\n        res = 0\n        i = 0\n        while v != n-1:\n            a,b,dist = graph[i]\n            if union(a,b):\n                res += dist\n                v += 1\n            i += 1\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        \n        dist = {}\n        pair, mindist = (0, 0), math.inf        \n        for i in range(N):\n            for j in range(i + 1, N):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                dist[(i, j)] = dist[(j, i)] = d\n                if d < mindist:\n                    pair, mindist = (i, j), d\n            \n        res = mindist\n        mst = set(pair)\n        other = set(i for i in range(N) if i not in mst)\n        h = []\n        for v in mst:\n            for i in other:\n                heapq.heappush(h, (dist[(v, i)], i))\n        \n        while len(mst) < N:\n            d, i = heapq.heappop(h)\n            if i not in mst:\n                res += d\n                mst.add(i)\n                other.remove(i)\n                for j in other:\n                    heapq.heappush(h, (dist[(i, j)], j))\n                    \n        return res if N > 1 else 0\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1:\n            return 0\n        points = sorted(points, key=lambda r: r[0])\n        (x1,y1), (x2,y2) = points[:2]\n        cost = abs(x2-x1) + abs(y2-y1)\n        \n        if len(points) == 2:\n            return cost\n        \n        n = len(points)\n        d = []\n        for i, (x,y) in enumerate(points[:-1]):\n            for j, (xj,yj) in enumerate(points[i+1:]):\n                d.append([i,i+j+1, abs(xj-x)+abs(yj-y)])\n        connections = sorted(d, key=lambda r: r[2])\n        \n        parent = [i for i in range(n)]\n        \n        def find(x):\n            if x != parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        res, e, k = 0, 0, 0\n        while e < n - 1:\n            u, v, w = connections[k]\n            k += 1\n            x, y = find(u-1), find(v-1)\n            if x != y:\n                e += 1\n                res += w\n                parent[x] = y\n        return res\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        def dist(points,i,j):\n            return abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n        a = collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1,n):\n                d = dist(points,i,j)\n                a[i].append((d,j))\n                a[j].append((d,i))\n        ans,cnt,q,visited = 0,1,a[0],[0] * n\n        visited[0] = 1\n        heapify(q)\n        while q:\n            d,j = heappop(q)\n            if not visited[j]:\n                visited[j] = 1\n                cnt += 1\n                ans += d\n                for i in a[j] : heappush(q,i)\n            if cnt >= n:\n                break\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        @functools.lru_cache(None)\n        def distance(i,j):\n            return abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n        not_added=set([i for i in range(1,len(points))])\n        distance_to_added=[math.inf for i in range(len(points))]\n        i=0\n        res=0\n        while not_added:\n            for j in not_added:\n                distance_to_added[j]=min(distance_to_added[j],distance(i,j))\n            while not_added:\n                i=min(range(len(points)),key=lambda x:distance_to_added[x])\n                if i in not_added:\n                    res+=distance_to_added[i]\n                    not_added.remove(i)\n                    break\n                distance_to_added[i]=math.inf\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        dis = [math.inf for i in range(n)]\n        myset = set()\n        myset.add(0)\n        res = 0\n        pt = points[0]\n        for i in range(n-1):\n            for idx, item in enumerate(points):\n                if(idx in myset):\n                    continue\n                else:\n                    dis[idx] = min(dis[idx], abs(pt[0]-item[0])+abs(pt[1]-item[1]))\n            mins = min(dis)\n            res += mins\n            cur = dis.index(mins)\n            myset.add(cur)\n            dis[cur] = math.inf\n            pt = points[cur]\n        return res\n        \n                \n", "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rnk = [0] * n\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rnk[xr] < self.rnk[yr]:\n            xr, yr = yr, xr\n        if self.rnk[xr] == self.rnk[yr]:\n            self.rnk[xr] += 1\n        self.par[yr] = xr\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # Prim\n        N = len(points)\n        \n        def dist(i, j):\n            return (\n                abs(points[i][0] - points[j][0]) + \n                abs(points[i][1] - points[j][1])\n            )\n        \n        pq = [[dist(0, j), 0, j] for j in range(1, N)]\n        heapq.heapify(pq)\n        actives = {0}\n        ans = 0\n        \n        while len(actives) != N:\n            d, u, v = heapq.heappop(pq)\n            if u not in actives or v not in actives:\n                ans += d\n                node, = {u, v} - actives\n                actives.add(node)\n                for nei in range(N):\n                    if nei not in actives:\n                        heapq.heappush(pq, [dist(node, nei), node, nei])\n                        \n        return ans\n        \n        # Kruskal \n        N = len(points)\n        edges = []\n        for u in range(N-1):\n            for v in range(u+1, N):\n                edges.append([u, v, abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1])])\n                \n        def MST():\n            # Kruskals, edges sorted\n            dsu = DSU(N)\n            ans = 0\n            for u, v, w in sorted(edges, key=lambda e: e[2]):\n                if dsu.union(u, v):\n                    ans += w\n            return ans\n        \n        return MST()\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # create MST over a created graph\n        q = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dis = abs(points[i][0]-points[j][0]) + abs(points[i][1] - points[j][1])\n                q.append((dis, i, j))\n        \n        # MST search algorithm Kruskal\n        def find(x):\n            if (x != parent[x]):\n                parent[x] = find(parent[x])\n            return parent[x]\n        def union(x, y):\n            if size[x] > size[y]:\n                size[x] += size[y]\n                parent[y] = x\n            else:\n                size[y] += size[x]\n                parent[x] = y\n                \n        n = len(points)\n        parent = [i for i in range(n+1)]\n        size = [1 for _ in range(n+1)]  \n        q.sort()  # sort edges\n        res = 0\n        count = 0\n        for w, u, v in q:\n            rA, rB = find(u), find(v)\n            if rA == rB:\n                continue\n            union(rA, rB)\n            res += w\n            # Optimize so that we don't traverse all edges\n            count += 1\n            if count == n:\n                return res\n        return res ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def md(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        q = [md(points[0], p) for p in points]\n        res = 0\n        for _ in range(len(points) - 1):\n            d, j = min((d, j) for j, d in enumerate(q) if d > 0)\n            res += d\n            q = [min(q[i], md(points[i], points[j])) for i in range(len(q))]\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        graph = collections.defaultdict(list) #\u6ca1\u4e8b\u4e0d\u8981\u7528default(dict)\n        for i in range(N):\n            x1,y1 = points[i]\n            for j in range(i + 1):\n                x2, y2 = points[j]\n                z = abs(x1-x2) + abs(y1 - y2)\n                graph[i].append((j,z))\n                graph[j].append((i,z))\n        \n            \n        heap = []\n        visited = set()\n        heapq.heappush(heap,(0,1))\n        total = 0\n        while heap:\n            cost, node = heapq.heappop(heap)\n            if node in visited: continue #prim \u7b97\u6cd5\u90fd\u662f\u5148\u68c0\u6d4b\u6709\u6ca1\u6709\u8bbf\u95ee\u8fc7\uff0c\u518d\u6dfb\u52a0\u5230visited\u91cc\u9762\uff0c\u800c\u4e0d\u662f\u5728\u540e\u9762\u7684next node\u6dfb\u52a0\u5230visited\u4e2d\u53bb\n            visited.add(node)\n            total += cost\n            if len(visited) == N:\n                return total\n            for nxt,c  in graph[node]:\n                if nxt  not in visited:\n                    heapq.heappush(heap,(c, nxt)) #\u653e\u5165\u5230heap\u4e2d\u7684\u7edd\u5bf9\u662f\u65b0\u7684\u5355\u8fb9\u8ddd\u79bb\uff0c\u800c\u4e0d\u662f\u603b\u8ddd\u79bb\n        return -1\n", "class Solution:\n    def find(self, x, parent):\n        if parent[x] != x:\n            parent[x] = self.find(parent[x], parent)\n        return parent[x]\n    \n    def union(self, x, y, parent):\n        px, py = self.find(x, parent), self.find(y, parent)\n        parent[py] = px\n        \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        parent = []\n        n = len(points)\n        for i in range(n):\n            parent.append(i)\n        edges = []\n        for i in range(len(points)):\n            x, y = points[i]\n            for j in range(i+1, len(points)):\n                u, v = points[j]\n                edges.append([i,j,abs(x-u)+abs(y-v)])\n        edges = sorted(edges, key = lambda x:x[2])\n        cost  = 0\n        for i in range(len(edges)):\n            p1, p2, w = edges[i]\n            if self.find(p1, parent) != self.find(p2, parent):\n                self.union(p1, p2, parent)\n                cost += w\n        return cost\n                \n", "class DSU:\n    def __init__(self, arr):\n        self.p = {}\n        self.n = 0\n            \n    def add(self, u):\n        self.p[u] = u\n        self.n += 1\n        \n    def find(self, u):\n        if self.p[u]!=u:\n            self.p[u] = self.find(self.p[u])\n        return self.p[u]\n    \n    def union(self, x, y):\n        self.p[self.find(x)] = self.find(y)\n        self.n -= 1\n\nfrom itertools import combinations\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        '''\n        d = DSU([])\n        edge = []\n        ans = 0\n        for i in range(len(points)-1):\n            d.add(tuple(points[i]))\n            for j in range(i+1,len(points)):\n                dis = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                edge.append([(points[i],points[j]), dis])\n        d.add(tuple(points[-1]))\n        edge.sort(key=lambda x:x[1])\n        for e in edge:\n            if d.find(tuple(e[0][0])) != d.find(tuple(e[0][1])):\n                d.union(tuple(e[0][0]),tuple(e[0][1]))\n                ans += e[1]\n            if d.n == 0:\n                break\n        return ans\n        '''\n        \n        \n        comb = list(combinations(points, 2))\n        edges = []\n        ans = 0\n        for c in comb:\n            d = abs(c[0][0]-c[1][0])+abs(c[0][1]-c[1][1])\n            edges.append((c, d))\n        edges.sort(key=lambda x: x[1])\n        s = []\n        for p in points:\n            p = tuple(p)\n            t = set()\n            t.add(p)\n            s.append(t)\n        print(s)\n        for e in edges:\n            u1 = -1\n            u2 = -1\n            for i in range(len(s)):\n                if tuple(e[0][0]) in s[i]:\n                    u1 = i\n                if tuple(e[0][1]) in s[i]:\n                    u2 = i\n            if u1 != u2:\n                s[u1] = s[u1] | s[u2]\n                s.pop(u2)\n                ans += e[1]\n            if len(s) == 1:\n                break\n        return ans\n       \n", "class UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.size = [1] * n\n\n    def find(self, i):\n        while i != self.parents[i]:\n            self.parents[i] = self.parents[self.parents[i]] # path halving\n            i = self.parents[i]\n        return i\n    \n    def union(self, a, b):\n        aPar = self.find(a)\n        bPar = self.find(b)\n        \n        if aPar == bPar:\n            return False\n        \n        # union by size\n        if self.size[aPar] > self.size[bPar]:\n            self.parents[bPar] = aPar\n            self.size[aPar] += self.size[bPar]\n        else:\n            self.parents[aPar] = bPar\n            self.size[bPar] += self.size[aPar]\n        \n        return True\n    \n    def getSize(self, a):\n        return self.size[self.find(a)]\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def getDistance(a,b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        \n        N = len(points)\n        uf = UnionFind(N)\n        edges = []\n        \n        for i in range(N):\n            for j in range(i+1, N):\n                edges.append((getDistance(points[i], points[j]), i, j))\n                \n        edges.sort(key=lambda x:x[0])\n        \n        cost = 0\n        seen = 0\n        for w,a,b in edges:\n            if uf.union(a,b):\n                cost += w\n                i += 1\n                if seen == N:\n                    break\n                    \n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(x):\n            if x != p[x]:\n                p[x] = find(p[p[x]])\n            return p[x]\n        \n        p = list(range(len(points)))\n        g = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                g.append((i, j, abs(points[j][1]-points[i][1]) + abs(points[j][0]-points[i][0])))\n        \n        cost = 0\n        for u, v, w in sorted(g, key=lambda x:x[2]):\n            ru, rv = find(u), find(v)\n            if ru == rv:\n                continue\n            p[ru] = rv\n            cost += w\n        \n        return cost", "#Kruskal's Algorithm\nclass UnionFind:\n    def __init__(self, n):\n        self.leaders = [i for i in range(n)]\n        self.ranks = [1 for i in range(n)]\n    \n    def find(self, x):\n        # p = x\n        # while p != self._leaders[p]:\n        #     p = self._leaders[p]\n        # while x != p:\n        #     self._leaders[x], x = p, self._leaders[x]\n        # return p\n        if self.leaders[x] != x:\n            self.leaders[x] = self.find(self.leaders[x])\n        return self.leaders[x]\n    \n    def union(self, x, y):\n        p = self.find(x)\n        q = self.find(y)\n        if p == q: \n            return False\n        if self.ranks[p] < self.ranks[q]:\n            self.leaders[p] = q\n        elif self.ranks[p] > self.ranks[q]:\n            self.leaders[q] = p\n        else:        \n            self.leaders[q] = p\n            self.ranks[p] += 1\n        return True\n    \nclass Solution:\n    def minCostConnectPoints(self, points):\n        n = len(points)\n        if n == 1:\n            return 0\n        edges = []\n        dist = lambda p0, p1: abs(p1[0] - p0[0]) + abs(p1[1] - p0[1])\n        for u in range(n):\n            for v in range(u + 1, n):\n                w = dist(points[u], points[v])\n                edges.append([u, v, w])\n        res, cnt = 0, 0\n        edges.sort(key=lambda x: x[2])\n        uf = UnionFind(n + 1)\n        for u, v, w in edges:\n            if uf.union(u, v):\n                res += w\n                cnt += 1\n            if cnt == n - 1:\n                return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        d = [99999999] * n\n        d[0] = 0\n        added = set()\n        ans = 0\n        \n        for i in range(n):\n            j_min = -1\n            d_min = 99999999\n            for j in range(n):\n                if j not in added:\n                    if d[j] < d_min:\n                        j_min = j\n                        d_min = d[j]\n            added.add(j_min)\n            ans += d_min\n            \n            for k in range(n):\n                if k not in added:\n                    if abs(points[k][0] - points[j_min][0]) + abs(points[k][1] - points[j_min][1]) < d[k]:\n                        d[k] = abs(points[k][0] - points[j_min][0]) + abs(points[k][1] - points[j_min][1])\n            \n        return ans", "from heapq import heappush, heappop\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        g = defaultdict(lambda: {}); n = len(points)\n        for i in range(n-1):\n            x1, y1 = points[i][0], points[i][1]\n            for j in range(i+1, n):\n                x2, y2 = points[j][0], points[j][1]\n                val = abs(x2-x1) + abs(y2-y1)\n                g[i][j] = g[j][i] = val\n\n                \n        visited = set(); res = 0; q = []; cnt=0\n        heappush(q, (0, 0)) # u:0, cost:0\n        while q:\n            cost, u = heappop(q)\n            if u in visited: continue\n            res += cost\n            cnt += 1\n            for v, w in g[u].items():\n                heappush(q, (w, v))\n            visited.add(u)\n            if cnt >= n: break\n        return res\n        \n        \n    \n\\\"\\\"\\\"\n[[0,0],[2,2],[3,10],[5,2],[7,0]]\n[[3,12],[-2,5],[-4,1]]\n[[0,0],[1,1],[1,0],[-1,1]]\n[[-1000000,-1000000],[1000000,1000000]]\n[[0,0]]\n\\\"\\\"\\\"            ", "#Prim's algorithm\nfrom collections import defaultdict\nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        graph = defaultdict(list)\n        n = len(points)\n        dist = lambda p0, p1: abs(p1[0] - p0[0]) + abs(p1[1] - p0[1])\n        for u in range(n):\n            for v in range(u + 1, n):\n                w = dist(points[u], points[v])\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n        q = [(0, 0)]\n        visited = set()\n        res = 0\n        while q:\n            d, u = heappop(q)\n            if u in visited:\n                continue\n            visited.add(u)\n            res = res + d\n            if len(visited) == n:\n                return res\n            for v, w in graph[u]:\n                if v not in visited:\n                    heappush(q, (w, v))", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        res, n = 0, len(points)\n        seen = set()\n        vertices = [(0, (0, 0))]\n        \n        while len(seen) < n:\n            d, (u, v) = heapq.heappop(vertices)            \n            if u in seen and v in seen: continue\n            res += d\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j != v:\n                    heapq.heappush(vertices, (manhattan(points[j], points[v]), (v, j)))\n                    \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dis = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dis, i, j))\n        \n        UF = {i: i for i in range(n)}\n        def find(i):\n            if i != UF[i]:\n                UF[i] = find(UF[i])\n            return UF[i]\n        def union(i, j):\n            UF[find(i)] = find(j)\n            \n        ans = 0\n        for w, x, y in sorted(edges):\n            if find(x) != find(y):\n                ans += w\n                union(x, y)\n        return ans", "import sys\n\nclass Solution:\n    def manhattan(self,p1, p2):\n        cost = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        return cost\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1:\n            return 0\n        total_cost = 0\n        connected = []\n        edges = []\n        for i in range(len(points)):\n            connected.append(set([i]))\n        if len(points) == 1:\n            return 0\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                edges.append([i, j, self.manhattan(points[i], points[j])])\n        edges = sorted(edges, key = lambda i: i[2])\n        edge_counter = 0\n        while len(connected) > 1:\n                edge = edges[edge_counter]\n                edge_counter+=1\n                cycle = False\n                for tree in connected:\n                    if edge[0] in tree and edge[1] in tree:\n                        cycle = True\n                        break\n                if cycle == True:\n                    continue\n                else:\n                    set1 = None\n                    index1 = None\n                    set2 = None\n                    index2 = None\n                    for i in range(len(connected)):\n                        sets = connected[i]\n                        if not set1 and edge[0] in sets:\n                            set1 = sets\n                            index1 = i\n                        if not set2 and edge[1] in sets:\n                            set2 = sets\n                            index2 = i\n                        if set1 and set2:\n                            break\n                    connected.append(set1.union(set2))\n                    del connected[max(index1, index2)]\n                    del connected[min(index1,index2)]\n                    total_cost += edge[2]\n        return total_cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #prims\n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n        g = collections.defaultdict(list)\n        n = len(points)\n        #create graph\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    g[i].append((manhattan(points[i], points[j]), j))\n\n        heap = [(0,0)]\n        ans = 0\n        visited = set()\n        while heap and len(visited) < n:\n            weight, to = heapq.heappop(heap)\n            if to in visited:\n                continue\n            ans += weight\n            visited.add(to)\n\n            for cost, nei in g[to]:\n                if nei not in visited:\n                    heapq.heappush(heap, (cost, nei))\n\n        return ans", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dist = []\n        for i in range(len(points)):dist.append([])\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                d = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                dist[i].append((d, i, j))\n                dist[j].append((d, j, i))\n                \n        visited = [False]*len(points)\n        hq = []\n        for x in dist[0]:\n            heappush(hq, x)\n        visited[0] = True\n        cost = 0\n        print(hq)\n        while not all(visited):\n            d, i, j = heappop(hq)\n            if visited[i] and visited[j]:\n                continue\n            \n            if visited[i]==False:\n                ind = i\n            else:\n                ind = j\n            \n            visited[ind] = True\n            cost+=d\n            for x in dist[ind]:\n                if visited[x[1]]==False or visited[x[2]]==False:\n                    heappush(hq, x)\n        return cost", "# int minCostConnectPoints(vector<vector<int>>& ps) {\n#     int n = ps.size(), res = 0, i = 0, connected = 0;\n#     vector<bool> visited(n);\n#     priority_queue<pair<int, int>> pq;\n#     while (++connected < n) {\n#         visited[i] = true;\n#         for (int j = 0; j < n; ++j)\n#             if (!visited[j])\n#                 pq.push({-(abs(ps[i][0] - ps[j][0]) + abs(ps[i][1] - ps[j][1])), j});\n#         while (visited[pq.top().second])\n#             pq.pop();\n#         res -= pq.top().first;\n#         i = pq.top().second;\n#         pq.pop();\n#     }\n#     return res;\n# }\n\nclass Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                        \n        n, vis, ans, pq, i = len(a), set([0]), 0, [], 0\n        while len(vis) < n:            \n            for j in range(n):\n                if j not in vis:\n                    heappush(pq, (abs(a[i][0]-a[j][0]) + abs(a[i][1] - a[j][1]), j))\n            while pq[0][1] in vis: heappop(pq)\n            val, i = heappop(pq)\n            vis.add(i)\n            ans += val            \n        return ans                                            ", "class UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.size = [1] * n\n\n    def find(self, i):\n        while i != self.parents[i]:\n            self.parents[i] = self.parents[self.parents[i]] # path halving\n            i = self.parents[i]\n        return i\n    \n    def union(self, a, b):\n        aPar = self.find(a)\n        bPar = self.find(b)\n        \n        if aPar == bPar:\n            return False\n        \n        # union by size\n        if self.size[aPar] > self.size[bPar]:\n            self.parents[bPar] = aPar\n            self.size[aPar] += self.size[bPar]\n        else:\n            self.parents[aPar] = bPar\n            self.size[bPar] += self.size[aPar]\n        \n        return True\n    \n    def getSize(self, a):\n        return self.size[self.find(a)]\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def getDistance(a,b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        \n        N = len(points)\n        uf = UnionFind(N)\n        edges = []\n        \n        for i in range(N):\n            for j in range(i+1, N):\n                edges.append((getDistance(points[i], points[j]), i, j))\n                \n        edges.sort()\n        \n        cost = 0\n        i = 0\n        while uf.getSize(0) != N:\n            w, a, b = edges[i]\n            if uf.union(a,b):\n                cost += w\n            i += 1\n        \n        return cost\n", "import heapq\nclass Solution:\n    def minCostConnectPoints_Prim(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        visited = set()\n        visited.add(0)\n        res = 0\n        heap = c[0]\n        \n        heapq.heapify(heap)\n\n        while len(visited)<n:\n            d, j = heapq.heappop(heap)\n            if j not in visited:\n                visited.add(j)\n                res += d\n                for record in c[j]:\n                    heapq.heappush(heap,record)\n                    \n        return res\n    \n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                edges.append((manhattan(points[i], points[j]), i, j))\n        edges.sort()\n        res = 0\n        ds = DisjointSet(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u,v)\n                res += cost\n        return res\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa==pb:\n            return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa] \n    def find(self, p):\n        if self.parent[p] == p:\n            return p\n        self.parent[p] = self.find(self.parent[p])\n        return self.parent[p]", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def heap_pop(h):\n            res=h[0]\n            h[0]=h[-1]\n            h.pop()\n            current=0\n            while(2*current+1<len(h)):\n                child=2*current+1\n                if child+1<len(h):\n                    if h[child+1][0]<h[child][0]:\n                        child+=1\n                if h[current][0]<=h[child][0]:\n                    break\n                h[current],h[child]=h[child],h[current]\n                current=child\n            return res\n        \n        def heap_insert(h,val):\n            current=len(h)\n            h.append(val)\n            while(current>0):\n                p=(current-1)//2\n                if h[p][0]<=h[current][0]:\n                    break\n                h[p],h[current]=h[current],h[p]\n                current=p\n                \n        n=len(points)\n        dp=[[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(n):\n                dp[i][j]=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n        visited=[0 for i in range(n)]\n        visited[0]=1\n        res=0\n        heap=[(dp[0][j],0,j) for j in range(n)]\n        heap.sort()\n        heap.pop(0)\n        while(sum(visited)<n):\n            cost,_,current=heap_pop(heap)\n            if visited[current]==1:\n                continue\n            visited[current]=1\n            res+=cost\n            for j in range(n):\n                if visited[j]!=1 and j!=current:\n                    heap_insert(heap,(dp[current][j],current,j))\n        return res", "class DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa]\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        # sort based on cost (i.e. distance)\n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        ds = DisjointSet(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u, v)\n                res += cost\n        \n        return res\n# class DSU:\n#     def __init__(self,n):\n#         self.parent = [i for i in range(n)]\n#         self.rank = [1 for i in range(n)]\n#         self.count = n\n    \n#     def find(self,x):\n#         if x!=self.parent[x]:\n#             self.parent[x]=self.find(self.parent[x])\n#         return self.parent[x]\n    \n#     def union(self,x,y):\n#         px = self.find(x)\n#         py = self.find(y)\n#         if px==py:\n#             return False\n#         self.count-=1\n#         if self.rank[x]>self.rank[y]:\n#             self.parent[py]=px\n#             self.rank[px]+=self.rank[py]\n#         else:\n#             self.parent[px]=py\n#             self.rank[py]+=self.rank[px]\n#         return True\n                \n# class Solution:\n#     def minCostConnectPoints(self, points: List[List[int]]) -> int:\n#         n = len(points)\n#         edges = []\n#         for i in range(n):\n#             for j in range(i+1, n):\n#                 dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n#                 edges.append((dist, i, j))\n#         heapq.heapify(edges)\n#         res = 0\n#         ds = DSU(n)\n#         while edges and ds.count!=1:\n#             cost,u,v = heapq.heappop(edges)\n#             if ds.union(u,v):\n#                 res += cost\n#         return res\n", "from collections import defaultdict\nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i, (x, y) in enumerate(points):\n            for j, (h, k) in enumerate(points):\n                if j <= i:\n                    continue\n                d = abs(x-h)+abs(y-k)\n                edges.append((i, j, d))\n        \n        g = defaultdict(list)\n        for e in edges:\n            g[e[0]].append((e[1], e[2]))\n            g[e[1]].append((e[0], e[2]))\n\n        q = []\n        cost = 0\n        seen = set()\n        heappush(q, (0, 0))\n        for _ in range(n):\n            while True:\n                w, u = heappop(q)\n                if u in seen: continue  \n                cost += w\n                seen.add(u)\n                for v, w in g[u]:\n                    if v in seen: continue\n                    heappush(q, (w, v))\n                break           \n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n\\t\\t\n        for i in range(n):\n            for j in range(i+1, n):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((d, i, j))\n        \n        edges.sort()\n        \n        roots = [i for i in range(n)]\n        \n        def find(v):\n            if roots[v] != v:\n                roots[v] = find(roots[v])\n            return roots[v]\n        \n        def union(u, v):\n            p1 = find(u); p2 = find(v)\n            if p1 != p2:\n                roots[p2] = roots[p1]\n                return True\n            return False\n        \n        res = 0\n        for d, u, v in edges:\n            if union(u, v):\n                res += d\n        return res\n        \n        ", "class Solution:\n\\tdef minCostConnectPoints(self, points: List[List[int]]) -> int:\n\\t\\tfrom    itertools   import  combinations\n\\t\\tParent\\t\\t= {}\n\\t\\tRank\\t\\t= {}\n\\t\\tVertices\\t= list(range(len(points)))\n\\t\\tEdges\\t\\t= []\n\n\\t\\tdef\\tMakeGraph():\n\\t\\t\\tnonlocal\\tpoints, Parent, Rank, Vertices, Edges\n\\t\\t\\tCombi\\t= list(combinations(Vertices, 2))\n\\t\\t\\t\n\\t\\t\\tfor pair in Combi:\n\\t\\t\\t\\tu, v\\t= pair\n\\t\\t\\t\\tnDist\\t=\\tabs(points[u][0] - points[v][0]) \\\\\n\\t\\t\\t\\t\\t+ abs(points[u][1] - points[v][1])\n\\t\\t\\t\\tEdges.append((nDist, u, v))\n\\t\\t\\tEdges.sort()\n\n\\t\\tdef MakeSet(v):\n\\t\\t\\tnonlocal\\tParent, Rank\n\\t\\t\\tParent[v]\\t= v\n\\t\\t\\tRank[v]\\t\\t= 0\n\n\\t\\tdef FindRoot(v):\n\\t\\t\\tnonlocal\\tParent\n\\t\\t\\tif Parent[v] != v:\n\\t\\t\\t\\tParent[v] = FindRoot(Parent[v])\n\n\\t\\t\\treturn Parent[v]\n\n\\t\\tdef Union(u, v):\n\\t\\t\\troot1 = FindRoot(v)\n\\t\\t\\troot2 = FindRoot(u)\n\n\\t\\t\\tif root1 != root2:\n\\t\\t\\t\\t# \uc9e7\uc740 \ud2b8\ub9ac\uc758 \ub8e8\ud2b8\uac00 \uae34 \ud2b8\ub9ac\uc758 \ub8e8\ud2b8\ub97c \uac00\ub9ac\ud0a4\uac8c \ub9cc\ub4dc\ub294 \uac83\uc774 \uc88b\ub2e4.\n\\t\\t\\t\\tif Rank[root1] > Rank[root2]:\n\\t\\t\\t\\t\\tParent[root2] = root1\n\\t\\t\\t\\telse:\n\\t\\t\\t\\t\\tParent[root1] = root2\n\n\\t\\t\\t\\t\\tif Rank[root1] == Rank[root2]:\n\\t\\t\\t\\t\\t\\tRank[root2] += 1\n\n\\t\\tMakeGraph()\n\\t\\tfor v in Vertices:\n\\t\\t\\tMakeSet(v)\n\n\\t\\tnMinCost\\t= 0\n\\t\\tfor Edge in Edges:\n\\t\\t\\tnCost, u, v\\t= Edge\n\\t\\t\\tif FindRoot(u) != FindRoot(v):\n\\t\\t\\t\\tUnion(u, v)\n\\t\\t\\t\\tnMinCost\\t+= nCost\n\\t\\t\n\\t\\treturn  nMinCost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points)<=1:\n            return 0\n        prior=[[] for _ in points]\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                dist=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                prior[i].append((dist,j))\n                prior[j].append((dist,i))\n        heapify(prior[0])\n        seen=set([0])\n        cur=prior[0]\n        res=0\n        while len(seen)<len(points):\n            dist,tar=heappop(cur)\n            if tar not in seen:\n                res+=dist\n                seen.add(tar)\n                for d,t in prior[tar]:\n                    if t not in seen:\n                        heappush(cur,(d,t))\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        nodes = len(points)\n        edges = sorted(\n            [(abs(points[src][0] - points[dst][0]) + abs(points[src][1] - points[dst][1]), src, dst) for src in\n             range(nodes) for dst in range(src + 1, nodes)])\n\n        roots = [node for node in range(nodes)]\n\n        def find(v):\n            if roots[v] != v:\n                roots[v] = find(roots[v])\n            return roots[v]\n\n        def union(u, v):\n            p1, p2 = find(u), find(v)\n            if p1 != p2:\n                roots[p2] = roots[p1]\n                return True\n            return False\n\n        return sum(distance for distance, src, dst in edges if union(src, dst))", "class DSU():\n    \n    def __init__(self,n):\n        self.parent=list(range(n))\n        self.size=[1]*n\n    \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self,x,y):\n        xp,yp=self.find(x),self.find(y)\n        if xp==yp:\n            return False\n        if self.size[xp]<self.size[yp]:\n            xp,yp=yp,xp\n        \n        self.size[xp]+=self.size[yp]\n        self.parent[yp]=xp\n        return True\n    \n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        dsu=DSU(len(points))\n        ans=0\n        edges=[]\n        for i,(xi,yi) in enumerate(points):\n            for j in range(i+1,len(points)):\n                xj,yj=points[j]\n                edges.append((abs(xi-xj)+abs(yi-yj),i,j))\n        \n        edges.sort()\n        ans=0\n        for d,v1,v2 in edges:\n            # print(v1,v2,'a')\n            if dsu.find(v1)!=dsu.find(v2):\n                # print(v1,v2,'j')\n                ans+=d\n                dsu.union(v1,v2)\n        \n        # print(dsu.parent)\n        return ans\n                \n", "class Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        connections = [[u, v, dist(points[u], points[v])] for u in range(N-1) for v in range(u+1, N)]\n        connections.sort(key = lambda x:x[2])\n        parent, cnt, res = [i for i in range(N+1)], N-1, 0\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        for u, v, cost in connections:\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                cnt -= 1\n                res += cost\n                if cnt == 0:\n                    break\n        return res\n    \nclass Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: p[0] + p[1])   # points.sort(key = lambda p: abs(p[0]) + abs(p[1]))\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            p1, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p2, dist) in enumerate(points):\n                # points[i][1] = min(points[i][1], distance(p1, p2))\n                newdist = distance(p1, p2)\n                if newdist < dist:\n                    points[i][1] = newdist\n        return total_cost", "class Solution:\n    class Union:\n        def __init__(self):\n            self.collection = {}\n        \n        def get_head(self, i):\n            if i not in self.collection:\n                return -1, 1\n            while i in self.collection and self.collection[i][0] != i:\n                i = self.collection[i][0]\n            return self.collection[i]\n                \n        def add(self, i, j):\n            head_i, cnt_i = self.get_head(i)\n            head_j, cnt_j = self.get_head(j)\n            \n            if head_i == head_j and head_i != -1:\n                return False, cnt_i\n            \n            head = head_i if cnt_i >= cnt_j else head_j\n            cnt = cnt_i + cnt_j\n            if head == -1:\n                head = i\n\n            self.collection[head_i] = (head, cnt)\n            self.collection[head_j] = (head, cnt)\n            self.collection[i] = (head, cnt)\n            self.collection[j] = (head, cnt)\n            return True, cnt\n            \n    from heapq import heappush, heappop\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = []\n        union = Solution.Union()\n        total = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                val = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heappush(heap, (val, i, j))\n                \n        while heap:\n            val, i, j = heappop(heap)\n            added, cnt = union.add(i, j)\n            if added:\n                total += val\n            if cnt == len(points):\n                break\n            \n        return total", "def top(idx, i):\n    d, j = 0, idx[i]\n    while i != j: i, j, d = j, idx[j], d + 1\n    return j, d\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        best, idx = 0, { i: i for i in range(len(points)) }\n        buf = [ (abs(x1 - x2) + abs(y1 - y2), i1, i2)\n              for i1,(x1,y1) in enumerate(points[:-1])\n              for i2,(x2,y2) in enumerate(points[i1+1:], i1+1) ]\n        for now,i1,i2 in sorted(buf):\n            j1, d1 = top(idx, i1)\n            j2, d2 = top(idx, i2)\n            if j1 == j2: continue\n            best += now\n            if d1 < d2: idx[i1] = idx[i2] = idx[j1] = j2\n            else: idx[i1] = idx[i2] = idx[j2] = j1\n        return best", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points)==1:\n            return 0\n        d=collections.defaultdict(int)\n        dmn=collections.defaultdict(int)\n        n=len(points)\n        def distance(a,b):\n            return abs(a[0]-b[0])+abs(a[1]-b[1])\n        res=0\n        start=[0,float(\\\"inf\\\")]\n        for i in range(n):\n            dmn[i]=0\n            for j in range(i+1,n):\n                t=distance(points[i],points[j])\n                d[(i,j)]=t\n                d[(j,i)]=t\n                if d[(i,j)]<start[1]:\n                    start[1]=d[(i,j)]\n                    start[0]=(i,j)\n        a=start[0][0]\n        b=start[0][1]\n        del dmn[a]\n        del dmn[b]\n        res+=start[1]\n        \n        for k in dmn.keys():\n            dmn[k]=min(d[(k,a)],d[(k,b)])\n        n-=2\n        \n        while n>0:\n            nxDistance=float(\\\"inf\\\")\n            for k in dmn.keys():\n                if dmn[k]<nxDistance:\n                    nx=k\n                    nxDistance=dmn[k]\n            res+=nxDistance\n            del dmn[nx]\n            for k in dmn.keys():\n                dmn[k]=min(dmn[k],d[(k,nx)])\n            n-=1\n        return res\n                        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        graph = []\n        self.parent = [i for i in range(len(points))]\n        cost = 0\n        self.N = len(points)\n        \n        for i in range(len(points)-1):\n            for j in range(len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(graph, [dist, i, j])\n                \n        # graph = sorted(graph, key = lambda x: x[2])\n        \n        while self.N > 1:\n            c, u, v = heapq.heappop(graph)\n            if u != v and self.union(u, v):\n                cost += c\n                \n        return cost\n    \n    \n    def union(self, x, y):\n        parentX = self.find(x)\n        parentY = self.find(y)\n        \n        if parentX == parentY:\n            return False\n        \n        if self.parent[parentX] <= self.parent[parentY]:\n            self.parent[parentY] = parentX\n        else:\n            self.parent[parentX] = parentY\n        self.N -= 1\n        return True\n    \n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n            \n        return self.parent[x]", "class Solution(object):\n    def minCostConnectPoints(self, points):\n\n        g = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                g.append((i, j, abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])))\n        \n        g0 = sorted(g, key = lambda x: x[2])\n        uf = UnionFind(len(points))\n        \n        ans = 0\n        for x, y, z in g0:\n            if uf.union(x, y):\n                ans += z\n        \n        return ans\n                         \nclass UnionFind():\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return False\n\n        self.parents[y] = x\n        return True", "import heapq\nclass Solution:\n    def minCostConnectPoints_Prim(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        visited = set()\n        visited.add(0)\n        res = 0\n        heap = c[0]\n        \n        heapq.heapify(heap)\n\n        while len(visited)<n:\n            d, j = heapq.heappop(heap)\n            if j not in visited:\n                visited.add(j)\n                res += d\n                for record in c[j]:\n                    heapq.heappush(heap,record)\n                    \n        return res\n    \n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                edges.append((manhattan(points[i], points[j]), i, j))\n        edges.sort()\n        res = 0\n        ds = DisjointSet(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u,v)\n                res += cost\n        return res\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa==pb:\n            return\n        self.parent[pa] = pb\n        '''if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa] '''\n    def find(self, p):\n        if self.parent[p] == p:\n            return p\n        self.parent[p] = self.find(self.parent[p])\n        return self.parent[p]", "class DSU:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        xp, yp = self.find(x), self.find(y)\n        if xp == yp:\n            return False\n        if self.rank[xp] < self.rank[yp]:\n            self.parent[xp] = yp\n        elif self.rank[xp] > self.rank[yp]:\n            self.parent[yp] = xp\n        else:\n            self.parent[xp] = yp\n            self.rank[yp] += 1\n        self.size -= 1\n        return True\n    def getSize(self):\n        return self.size\n    \nclass Solution:\n    import heapq\n    \n    # prime + heap, not using unionfind.\n    # https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/850185/Java-or-Min-Spanning-Tree-or-Prim-%2B-PriorityQueue\n    def minCostConnectPoints1(self, points: List[List[int]]) -> int:\n        def getDist(i, j):\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        heap, n, visited, res = [], len(points), set([0]), 0\n        for i in range(1, n):\n            heapq.heappush(heap, (getDist(0, i), (0, i)))\n        while len(visited) < n:\n            dist, (i, j) = heapq.heappop(heap)\n            if j not in visited:\n                visited.add(j)\n                res += dist\n                for k in range(n):\n                    if k not in visited:\n                        heapq.heappush(heap, (getDist(j, k), (j, k)))\n        return res\n    \n    # slow\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                graph.append((i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])))\n        graph.sort(key = lambda x:x[2])\n        dsu = DSU(len(points) + 1)\n        res = 0\n        for i, j, cost in graph:\n            if dsu.union(i, j):\n                res += cost\n        return res", "def dist(p1, p2):\n    return int(abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]))\n\ndef find(x, uf):\n    if uf[x] == x:\n        return x\n    uf[x] = find(uf[x], uf)\n    return uf[x]\n\ndef union(x, y, uf):\n    xx = find(x, uf)\n    yy = find(y, uf)\n    if xx == yy:\n        return False\n    uf[xx] = yy\n    return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append((dist(points[i], points[j]), i, j))\n        edges.sort()\n        uf = list(range(n))\n        ans = 0\n        for e in edges:\n            if union(e[1], e[2], uf):\n                ans += e[0]\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # my gut said a kruskal MST? YES\n\n        N = len(points)\n        edge_list = [];\n        for i in range(N):\n            x0,y0 = points[i]\n            for j in range(i+1,N):\n                x1,y1 = points[j]\n                mh = abs(x1-x0)+abs(y1-y0);\n                edge_list.append((mh, i,j));\n        edge_list.sort()\n        #print(edge_list)\n        \n        ## implement kruskal\n        edge_count = 0;\n        val = 0;\n        uf = UnionFind(N)\n\n        while(edge_count!=N-1):\n            mh,i,j = edge_list.pop(0)\n\n            if(uf.union(i,j)):\n                ## we're good\n                val+=mh;\n                edge_count+=1;\n            #print(edge_count, val, x0,y0, x1, y1)\n\n        return val\n    \nclass UnionFind():\n    def __init__(self, n):\n        self.parents = {i:i for i in range(0, n)}\n        self.groups = n\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return False\n\n        self.parents[y] = x\n        self.groups -= 1\n        return True", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # a = points\n        # n = len(a)\n        # def d(i, j): return abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1])\n        # q = []\n        # dst = [float('inf')]*n\n        # vis = [False] * n\n        # def consider(du, u):\n        #     if vis[u] or du >= dst[u]: return\n        #     dst[u] = du\n        #     heappush(q, (du, u))\n        # consider(0, 0)\n        # while q:\n        #     du, u = heappop(q)\n        #     if vis[u]: continue\n        #     vis[u] = True\n        #     for v in range(n): consider(d(u, v), v)\n        # return sum(dst)\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1,n):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1]-points[j][1])\n                edges.append((d,i,j))\n        edges.sort()\n        \n        roots = [i for i in range(n)]\n        \n        def find(v):\n            if roots[v] != v:\n                roots[v] = find(roots[v])\n            return roots[v]\n        \n        def union(u,v):\n            p1 = find(u)\n            p2 = find(v)\n            if p1 != p2:\n                roots[p2] = roots[p1]\n                return True\n            return False\n        \n        res = 0\n        for d,u,v in edges:\n            if union(u,v):\n                res += d\n        return res\n", "class DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa]\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        # sort based on cost (i.e. distance)\n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        ds = DisjointSet(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u, v)\n                res += cost\n        \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        class DSU:\n            def __init__(self, n):\n                self.parent = list(range(n))\n                self.size = [1] * n\n            \n            def find(self, x):\n                if self.parent[x] != x:\n                    self.parent[x] = self.find(self.parent[x])\n                return self.parent[x]\n            \n            def unite(self, x, y):\n                px, py = self.find(x), self.find(y)\n                if px == py:\n                    return False\n                if self.size[px] > self.size[py]:\n                    px, py = py, px\n                self.size[py] += self.size[px]\n                self.parent[px] = py\n                return True\n        n = len(p)\n        total = 0\n        dsu = DSU(n)\n        edges = []\n        for x in range(1, n):\n            for y in range(x):\n                edges.append((x, y, abs(p[x][0] - p[y][0]) + abs(p[x][1] - p[y][1])))\n        edges.sort(key=lambda x: x[2])\n        for x, y, cost in edges:\n            if dsu.unite(x, y):\n                total += cost\n        return total", "from collections import defaultdict\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def calc_distance(p1, p2):\n            x1, y1 = p1\n            x2, y2 = p2\n            return abs(x1 - x2) + abs(y1 - y2)\n        \n        def find_best_node(min_dists, mst_set):\n            min_dist = float('inf')\n            for i, dist in enumerate(min_dists):\n                if i not in mst_set and dist < min_dist:\n                    best_node = i\n                    min_dist = dist\n            return best_node, min_dist\n        \n        def update_min_dists(node, min_dists, graph):\n            for i, dist in graph[node]:\n                min_dists[i] = min(min_dists[i], dist)            \n        \n        \n        n = len(points)\n        if n <= 1:\n            return 0\n        \n        graph = defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                p1, p2 = points[i], points[j]\n                dist = calc_distance(p1, p2)\n                graph[i].append((j, dist))\n                graph[j].append((i, dist))\n                \n        min_dists = [float('inf') for _ in range(n)]\n        mst_set = {0}\n        for i, dist in graph[0]:\n            min_dists[i] = min(min_dists[i], dist)\n        \n        total_dist = 0\n        for _ in range(n-1):\n            best_node, min_dist = find_best_node(min_dists, mst_set)\n            mst_set.add(best_node)\n            update_min_dists(best_node, min_dists, graph)\n            total_dist += min_dist\n        \n        return total_dist\n            \n            \n            \n        \n        \n        \n        \n            \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(a):\n            if a != root[a]:\n                root[a] = find(root[a])\n            return root[a]\n        def union(a, b):\n            a, b = find(a), find(b)\n            if a == b:\n                return 0\n            root[a] = b\n            return 1\n        root = [i for i in range(len(points))]\n        res = 0\n        edges = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                a, b = points[i]\n                c, d = points[j]\n                edges.append([abs(a-c)+abs(b-d), i, j])\n        edges.sort()\n        us = 0\n        while us != len(points)-1:\n            dis, i, j = edges.pop(0)\n            if union(i, j):\n                res += dis\n                us += 1\n        return res", "class Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        N = len(A)\n        P = [i for i in range(N)]                     \n        E = []\n        for u in range(N):\n            x1, y1 = A[u]\n            for v in range(u + 1, N):\n                x2, y2 = A[v]\n                w = abs(x1 - x2) + abs(y1 - y2)\n                E.append([ u, v, w ])                   \n        E.sort(key = lambda edge: edge[2])              \n        def find(x):\n            P[x] = P[x] if P[x] == x else find(P[x])\n            return P[x]\n        def union(a, b):\n            a = find(a)\n            b = find(b)\n            if a == b:\n                return False\n            P[a] = b                                    \n            return True\n        return sum([w for u, v, w in E if union(u, v)])", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1:\n            return 0\n        \n        def distance(p1,p2):\n            return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n = len(points)\n        parents = list(range(n))\n        \n        def find(x):\n            if x != parents[x]:\n                parents[x] = find(parents[x])\n            return parents[x]\n        \n        def union(x,y):\n            px, py = find(x), find(y)\n            if px != py:\n                parents[py] = px\n                return True\n            return False\n        ans = 0\n        # visited = set()#\n        count = 0\n        g = []\n        for i in range(n):\n            for j in range(i+1,n):\n                cost = distance(points[i],points[j])\n                g.append([cost,i,j])\n        for cost,pt1,pt2 in sorted(g):\n            if union(pt1,pt2):\n                ans += cost\n                count +=1\n                # visited.add(pt1)\n                # visited.add(pt2)\n            if count == n-1:\n                return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # APPROACH 1 - My Kruskal trial\n        \\\"\\\"\\\"\n        sets, edges = [], []\n        res = []\n\n        for i in range(len(points)):\n            sets.append([i])\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                val = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((i,j,val))\n        def custom_sort(t):\n            return t[2]\n        edges.sort(key=custom_sort)\n        #print(edges); print(sets)\n        \n        for (u,v,cost) in edges:\n            for i in range(len(sets)):\n                if u in sets[i]:\n                    setu = i\n                    break\n            for i in range(len(sets)):\n                if v in sets[i]:\n                    setv = i\n                    break\n            if setu != setv:\n                w1 = sets[setu]\n                w2 = sets[setv]\n                res.append((u,v,cost))\n                [w1.append(x) for x in w2 if x not in w1]\n                sets = sets[:setv]+sets[setv+1:]\n        \n        sum = 0\n        for e in res:\n            sum += e[2]\n        return sum\n        \\\"\\\"\\\"\n        \n        # APPRTOACH 2 - MIN_HEAP/Prim\n        \\\"\\\"\\\"\n        edges = [[None] * len(points) for _ in range(len(points))]\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                val = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges[i][j] = val\n                edges[j][i] = val\n        \n        cost = 0\n        min_heap = [(0, 0)]\n        visited = set()\n        while len(min_heap):\n            #print('cur_min_heap', min_heap)\n            min_node = heapq.heappop(min_heap)\n            if min_node[1] in visited: continue\n            vertex = min_node[1]\n            weight = min_node[0]\n            cost += weight\n            visited.add(vertex)\n            #print('visted vertex is', vertex, '; cost is', weight, '; total', cost, '; cur_min_heap', min_heap)\n            for neigh in range(len(edges[vertex])):\n                if neigh not in visited:\n                    heapq.heappush(min_heap, (edges[vertex][neigh], neigh))\n        \n        return cost\n        \\\"\\\"\\\"\n        \n        #APPROACH 3 - Prim\n        ##### https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/854251/Python-Kruskals-algo-implemented-with-array-easy-to-understand\n        visited = []\n        l = len(points)\n\\t\\t# points are node in graph, and there're at most l^2 edges.\n        edges = []\n\\t\\t# Get all the edges, and each is represented with [cost, two_ends]\n        for i in range(l):\n            for j in range(i+1, l):\n                x = abs(points[i][0] - points[j][0])\n                y = abs(points[i][1] - points[j][1])\n                edges.append([x + y, [i,j]])\n\\t\\t# Sort the edges by their cost\n        edges.sort(key = lambda x:x[0])\n        result = 0\n        nodes = [0]* l\n\\t\\t# union connected nodes,  mark the node with mark = 1, and for each separated group, we use mark = 2 /3 ...\n        mark = 1\n        for e in edges:\n\\t\\t   # Two end nodes\n            i = e[1][0]\n            j = e[1][1]\n\\t\\t\\t# Both are not marked, so are not connected at all, and can be marked with new mark\n            if nodes[i] == 0 and nodes[j] == 0:\n                \n                nodes[i] = mark\n                nodes[j] = mark\n                mark += 1\n                result += e[0]\n\\t\\t\\t# One of them is marked, so connected to some connected components\n            elif nodes[i] == 0:\n                nodes[i] = nodes[j]\n                result += e[0]\n\\t\\t\\t# One of them is marked, so connected to some connected components\n            elif nodes[j] == 0:\n                nodes[j] = nodes[i]\n                result += e[0]\n\\t\\t\\t# Both of them are marked, so are already connected to some connected components;\n\\t\\t\\t# if they are in the same connected component, this edge cannot be added; Or there'd be a cycle\n\\t\\t\\t# If they are in different c.c., they should be united, so we need to update the mark on the nodes. And the method is to loop all the nodes, change the mark for all the nodes in one c.c. to the mark of the other c.c.\n            else:\n                if nodes[i] != nodes[j]:\n                    result += e[0]\n                    target = nodes[i]\n                    source = nodes[j]\n                    for index in range(l):\n                        if nodes[index] == source:\n                            nodes[index] = target\n        return result\n        \n        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def method1():\n            class UF:\n                def __init__(self,size):\n                    self.p=list(range(size))\n                    self.rank=[1]*size\n                    \n                def find(self,x):\n                    if x!=self.p[x]:\n                        self.p[x]=self.find(self.p[x])\n                    return self.p[x]\n                \n                def union(self,x,y):\n                    px=self.find(x)\n                    py=self.find(y)\n                    \n                    if self.rank[px]<self.rank[py]:\n                        px,py=py,px\n                    \n                    self.p[px]=py\n                    if self.rank[px]==self.rank[py]:\n                        self.rank[px]+=1\n                        \n                \n            edges=[]\n            n=len(points)\n            \n            for i in range(n-1):\n                for j in range(i+1,n):\n                    dist=abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                    edges.append((dist,i,j))\n                        \n            edges.sort()\n        \n            uf=UF(n)\n            res=0\n            for cost, u, v in edges:\n                if uf.find(u) != uf.find(v):\n                    uf.union(u, v)\n                    res += cost\n        \n            return res\n        return method1()\n                    \n            \n", "class Solution:\n    def minCostConnectPoints_1(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        MST - minimum spanning tree\n        Greedy - each time we add the shortest edge into the tree\n        Prim's Algo\n        \\\"\\\"\\\"\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n        n, c = len(points), collections.defaultdict(list)\n        # init\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        \n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        # each time we add a v from outside of the MST into the MST\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]:\n                    heapq.heappush(heap, record)\n            if cnt >= n:\n                break\n        \n        return ans\n\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        ans, n = 0, len(p)\n        seen = set()\n        vertices = [(0, (0, 0))]\n        \n        while len(seen) < n:\n            # print(vertices, seen)\n            w, (u, v) = heapq.heappop(vertices)            \n            if u in seen and v in seen: continue\n            ans += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    heapq.heappush(vertices, (manhattan(p[j], p[v]), (v, j)))\n        \n        return ans", "class Solution:\n    def find(self, par, x):\n        if par[x] == x:\n            return x\n        else:\n            par[x] = self.find(par, par[x])\n            return par[x]\n\n    def merge(self, par, x, y):\n        x = self.find(par, x)\n        y = self.find(par, y)\n        if x == y:\n            return False\n        par[x] = y\n        return True\n\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        par = [i for i in range(len(points))]\n        dis = lambda p1, p2: abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n        edges = []\n        visited = set()\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                edges.append((dis(points[i], points[j]), i, j))\n        edges.sort()\n        r = 0\n        for d, i, j in edges:\n            if self.merge(par, i, j):\n                r += d\n        return r", "class DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        self.parent[pa] = pb\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        # sort based on cost (i.e. distance)\n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        ds = DisjointSet(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u, v)\n                res += cost\n        \n        return res", "class DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa]\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        # sort based on cost (i.e. distance)\n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        ds = DisjointSet(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u, v)\n                res += cost\n        \n        return res", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        l=len(points)\n        stc=[]\n        heapq.heapify(stc)\n        cost=0\n        self.parent=[-1 for i in range(l)]\n        \n        def find(a):\n            if self.parent[a]<0:\n                print(('a ',a))\n                return a\n            else:\n                return find(self.parent[a])\n        \n        \n        \n        def union(a,b):\n            u=find(a)\n            v=find(b)\n            if u==v:\n                return False\n            else:\n                if abs(self.parent[u])>=abs(self.parent[v]):\n                    self.parent[u]+=self.parent[v]\n                    self.parent[v]=u\n                else:\n                    self.parent[v]+=self.parent[u]\n                    self.parent[u]=v\n                return True\n        \n        \n        \n        \n        for i in range(l):\n            for j in range(l):\n                if i!=j:\n                    heapq.heappush(stc,[abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),i,j])         \n        edge=0\n        while(edge<l-1):\n            t=heapq.heappop(stc)\n            y=union(t[1],t[2])\n            if y==True:\n                cost+=t[0]\n                edge+=1\n        return cost\n                    \n        \n        \n        \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def method1():\n            class UF:\n                def __init__(self,size):\n                    self.p=list(range(size))\n                    self.rank=[1]*size\n                    \n                def find(self,x):\n                    if x!=self.p[x]:\n                        self.p[x]=self.find(self.p[x])\n                    return self.p[x]\n                \n                def union(self,x,y):\n                    px=self.find(x)\n                    py=self.find(y)\n                    \n                    if self.rank[px]<self.rank[py]:\n                        px,py=py,px\n                    \n                    self.p[px]=py\n                    if self.rank[px]==self.rank[py]:\n                        self.rank[px]+=1\n                        \n            edges=[]\n            n=len(points)\n            \n            for i in range(n-1):\n                for j in range(i+1,n):\n                    dist=abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                    edges.append((dist,i,j))\n                        \n            edges.sort()\n        \n            uf=UF(n)\n            res=0\n            for cost, u, v in edges:\n                if uf.find(u) != uf.find(v):\n                    uf.union(u, v)\n                    res += cost\n        \n            return res\n        return method1()\n                    \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/843995/Python-3-or-Min-Spanning-Tree-or-Prim's-Algorithm\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans", "class Node:\n    def __init__(self,val):\n        self.val = val\n        self.next = None\n        self.parent = None\n\nclass Component:\n    def __init__(self):\n        self.length = 0\n        self.head = None\n        self.tail = None\n        \nclass Solution:\n    def __init__(self):\n        self.ds = {}\n        \n    def findSet(self,key):\n        if key in self.ds:\n            return self.ds[key]\n        node = Node(key)\n        component = Component()\n        node.parent = component\n        component.head = node\n        component.tail = node\n        component.length+=1\n        self.ds[key] = component\n        return component\n    \n    def unionSet(self, c1,c2):\n        if c1.length<c2.length:\n            c1,c2=c2,c1\n        c1.tail.next = c2.head\n        c1.tail = c2.tail\n        tmp = c2.head\n        while tmp:\n            tmp.parent = c1\n            self.ds[tmp.val] = c1\n            tmp = tmp.__next__\n        c1.length+=c2.length\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            j=i+1\n            while j<n:\n                edges.append((i,j,abs(abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]))))\n                j+=1\n        edges.sort(key=lambda x:x[2])\n        cost = 0\n        for edge in edges:\n            c1 = self.findSet(edge[0])\n            c2 = self.findSet(edge[1])\n            if c1 != c2:\n                self.unionSet(c1,c2)\n                cost+=edge[2]\n        return cost\n                \n", "class DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa]\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        # sort based on cost (i.e. distance)\n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        ds = DisjointSet(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u, v)\n                res += cost\n        \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        def distance(p1,p2):\n            return abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n        sets = [i for i in range(n+1)]\n        def find(i):\n            if i != sets[i]:\n                sets[i]=find(sets[i])\n            return sets[i]\n        def union(x,y):\n            x,y = find(x),find(y)\n            if x == y: return 0\n            sets[x] = y\n            return 1\n        edges = []\n        for i in range(n):\n            for j in range(i+1,n):\n                edges.append([distance(points[i],points[j]),i,j])\n        \n        edges.sort(key=lambda x:x[0])\n        weight = 0\n        for w,i,j in edges:\n            if union(i,j):\n                weight += w\n        return weight\n                \n                \n", "import sys\ninput = sys.stdin.readline\n\nclass Unionfind:\n    def __init__(self, n):\n        self.par = [-1]*n\n        self.rank = [1]*n\n    \n    def root(self, x):\n        r = x\n        \n        while not self.par[r]<0:\n            r = self.par[r]\n        \n        t = x\n        \n        while t!=r:\n            tmp = t\n            t = self.par[t]\n            self.par[tmp] = r\n        \n        return r\n    \n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        \n        if rx==ry:\n            return\n        \n        if self.rank[rx]<=self.rank[ry]:\n            self.par[ry] += self.par[rx]\n            self.par[rx] = ry\n            \n            if self.rank[rx]==self.rank[ry]:\n                self.rank[ry] += 1\n        else:\n            self.par[rx] += self.par[ry]\n            self.par[ry] = rx\n    \n    def is_same(self, x, y):\n        return self.root(x)==self.root(y)\n    \n    def count(self, x):\n        return -self.par[self.root(x)]\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        \n        for i in range(len(points)):\n            xi, yi = points[i]\n            for j in range(i+1, len(points)):\n                xj, yj = points[j]\n                edges.append((abs(xi-xj)+abs(yi-yj), i, j))\n        \n        edges.sort()\n        uf = Unionfind(len(points))\n        ans = 0\n        \n        for w, u, v in edges:\n            if not uf.is_same(u, v):\n                ans += w\n                uf.unite(u, v)\n        \n        return ans\n", "class UF:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n        \n    def find(self, a):\n        # if a's parent is not a -> we didn't find the root of a\n        while self.parent[a] != a:\n            self.parent[a] = self.parent[self.parent[a]]\n            a = self.parent[a]\n        return a\n    \n    def isConnected(self, a, b):\n        return self.find(a) == self.find(b)\n    \n    def union(self, a, b):\n        parentA = self.find(a)\n        parentB = self.find(b)\n        if self.isConnected(a, b): \n            return\n        # add the small tree to the large tree\n        if self.size[parentA] > self.size[parentB]:\n            self.parent[parentB] = parentA\n            # update the large tree size\n            self.size[parentA] += self.size[parentB]\n        else:\n            self.parent[parentA] = parentB\n            self.size[parentB] += self.size[parentA]\n        \n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        n = len(points)\n        # make edges list with the two vertices\n        for i in range(n):\n            for j in range(i+1, n):\n                manhattanDist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((manhattanDist, i ,j))\n        # sort the edges\n        edges.sort()\n        res = 0\n        uf = UF(n)\n        # starting connect the vertices from the smallest cost\n        # if the two vertices have already been connected, then skip (get rid of makeing cycles)\n        for cost, i, j in edges:\n            if not uf.isConnected(i, j):\n                uf.union(i, j)\n                res += cost\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        connections = [[u, v, dist(points[u], points[v])] for u in range(N-1) for v in range(u+1, N)]\n        connections.sort(key = lambda x:x[2])\n        parent, cnt, res = [i for i in range(N+1)], N-1, 0\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        for u, v, cost in connections:\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                cnt -= 1\n                res += cost\n                if cnt == 0:\n                    break\n        return res\n    \nclass Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: p[0] + p[1])   # points.sort(key = lambda p: abs(p[0]) + abs(p[1]))\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            p1, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p2, dist) in enumerate(points):\n                points[i][1] = min(points[i][1], distance(p1, p2))\n        return total_cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        dsu = [i for i in range(n)]\n        \n        def get_root(id: int):\n            dsu[id] = id if dsu[id] == id else get_root(dsu[id])\n            return dsu[id]\n        \n        def unite(a: int, b: int) -> bool:\n            a = get_root(a)\n            b = get_root(b)\n            if a == b:\n                return False\n            dsu[a] = b\n            return True\n        \n        e = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                e.append([i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])])\n        e.sort(key = lambda edge: edge[2])\n        \n        return sum([edge[2] for edge in e if unite(edge[0], edge[1])])\n", "class DSU:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        xp, yp = self.find(x), self.find(y)\n        if xp == yp:\n            return False\n        if self.rank[xp] < self.rank[yp]:\n            self.parent[xp] = yp\n        elif self.rank[xp] > self.rank[yp]:\n            self.parent[yp] = xp\n        else:\n            self.parent[xp] = yp\n            self.rank[yp] += 1\n        self.size -= 1\n        return True\n    def getSize(self):\n        return self.size\n    \nclass Solution:\n    import heapq\n    \n    # prime + heap, not using unionfind.\n    # https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/850185/Java-or-Min-Spanning-Tree-or-Prim-%2B-PriorityQueue\n    def minCostConnectPoints1(self, points: List[List[int]]) -> int:\n        def getDist(i, j):\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        heap, n, visited, res = [], len(points), set([0]), 0\n        for i in range(1, n):\n            heapq.heappush(heap, (getDist(0, i), (0, i)))\n        while len(visited) < n:\n            dist, (i, j) = heapq.heappop(heap)\n            if j not in visited:\n                visited.add(j)\n                res += dist\n                for k in range(n):\n                    if k not in visited:\n                        heapq.heappush(heap, (getDist(j, k), (j, k)))\n        return res\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                graph.append((i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])))\n        graph.sort(key = lambda x:x[2])\n        dsu = DSU(len(points) + 1)\n        res = 0\n        for i, j, cost in graph:\n            if dsu.union(i, j):\n                res += cost\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        costs = []\n        ans = 0\n        for i, node_x in enumerate(points):\n            for j, node_y in enumerate(points):\n                if i != j:\n                    costs.append((abs(node_x[0] - node_y[0]) + abs(node_x[1] - node_y[1]), i, j))\n        costs.sort()\n        def get_fa(i):\n            if fa[i] != i:\n                fa[i] = get_fa(fa[i])\n            return fa[i]\n        fa = list(range(len(points)))\n        count = 0\n        for v, i, j in costs:\n            if get_fa(i) != get_fa(j):\n                ans += v\n                fa[fa[i]] = fa[j]\n                count += 1\n                if count == len(points) - 1:\n                    return ans\n        return ans\n        \n            \n        \n        \n        \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        edges = collections.defaultdict(dict)\n        n = len(points)\n        for i in range(n):\n            for j in range(i):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                d = abs(x1-x2) + abs(y1-y2)\n                edges[i][j] = d\n                edges[j][i] = d\n                \n                \n        ans = 0\n        visited = set([0])\n        cand = []\n        for j in edges[0]:\n            heapq.heappush(cand, [edges[0][j], j])\n        ans = 0\n        while len(visited) < n:\n            d, j = heapq.heappop(cand)\n            if j not in visited:\n                ans += d\n                visited.add(j)\n                for i in edges[j]:\n                    heapq.heappush(cand, [edges[j][i], i])\n        return ans\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        \n        if n <= 1:\n            return 0\n        \n        edges = []\n        for i, coor in enumerate(points):\n            x1, y1 = coor\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                edges.append((abs(x1 - x2) + abs(y1 - y2), i, j))\n        \n        root = [i for i in range(n)]\n        \n        def union(p, q):\n            r1, r2 = find(p), find(q)\n            if r1 != r2:\n                root[r1] = r2\n                return False\n            return True\n        \n        def find(p):\n            if p == root[p]:\n                return p\n            \n            root[p] = find(root[p])\n            return root[p]\n        \n        distance = 0\n        for d, p1, p2 in sorted(edges):\n            if not union(p1, p2):\n                distance += d\n        \n        return distance\n", "from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def manhattan(x,y):\n            return abs(x[0] - y[0]) + abs(x[1] - y[1])\n        \n        dist_dict = defaultdict(list)\n        n_points = len(points)\n        \n        for i in range(n_points):\n            for j in range(i+1, n_points):\n                dist_curr = manhattan(points[i], points[j])\n                dist_dict[i].append((dist_curr, j))\n                dist_dict[j].append((dist_curr, i))\n                \n        total_dist = 0\n        visited = [False] * n_points\n        counter = 1\n        dist_heap = dist_dict[0]\n        heapq.heapify(dist_heap)\n        visited[0] = True\n        \n        while dist_heap:\n            dist_curr, point_curr = heapq.heappop(dist_heap)\n            if not visited[point_curr]:\n                visited[point_curr] = True\n                for neighbor in dist_dict[point_curr]:\n                    heapq.heappush(dist_heap, neighbor)\n                total_dist += dist_curr\n                counter += 1\n            if counter >= n_points: break\n         \n        return total_dist\n                \n            \n            \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        num_points = len(points)\n        pairwise_dist = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                pairwise_dist.append([abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]), i, j])\n\n        pairwise_dist.sort(key=lambda x: x[0])\n        distance = 0\n        \n        par = list(range(num_points))\n        rank = [0]*num_points\n        def find(node):\n            if par[node] != node:\n                par[node] = find(par[node])\n            return par[node]\n                \n            \n        def union(x, y):\n            par_x = find(x)\n            par_y = find(y)\n            if rank[par_x] > rank[par_y]:\n                par[par_y] = par_x\n            elif rank[par_x] < rank[par_y]:\n                par[par_x] = par_y\n            else:\n                par[par_x] = par_y\n                rank[par_y] += 1\n            \n        for pair in pairwise_dist:\n            if find(pair[1]) == find(pair[2]):\n                continue\n            \n            distance += pair[0]\n            union(pair[1], pair[2])\n        \n        return distance", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        from collections import defaultdict\n        import heapq\n        manhattan = lambda a, b:abs(a[0]-b[0]) + abs(a[1]-b[1])\n        n, c = len(points), defaultdict(list)\n        if n==0:\n            return 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dis = manhattan(points[i], points[j])\n                c[i].append((dis, j))\n                c[j].append((dis, i))\n        cnt, ans, visited, heap = 1, 0, [0]*n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while cnt<n:\n            dis, p = heapq.heappop(heap)\n            if not visited[p]:\n                visited[p], cnt, ans = 1, cnt+1, ans+dis\n                for record in c[p]:\n                    heapq.heappush(heap, record)\n        return ans ", "class UF(object):\n\n    def __init__(self, size):\n        # initially, each node is an independent component\n        self.parent = [i for i in range(size)]\n        # keep the size of each component\n        self.size = [1] * (size)\n        #count of the disconnected sets\n\n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootq == rootp:\n            return\n        if self.size[rootp] > self.size[rootq]:\n            self.parent[rootq] = rootp\n            self.size[rootp] += self.size[rootq]\n        else:\n            self.parent[rootp] = rootq\n            self.size[rootq] += self.size[rootp]\n\n    def connected(self,p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        return rootp == rootq\n\n    def find(self, x):\n        while self.parent[x] != x:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n         \n        distances= []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                distance = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                distances.append((distance, i,j))\n        distances.sort()\n        uf = UF(len(points))\n        res = 0\n        for dis, u,v in distances:\n            if not uf.connected(u,v):\n                uf.union(u,v)\n                res += dis\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        def dist(points,i,j):\n            return abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n        visited = [(0,(0,0))]\n        ans, n = 0, len(points)\n        seen = set()\n        \n        while len(seen) < n:\n            d,(u,v) = heappop(visited)\n            if u in seen and v in seen:continue\n            ans += d\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and  j != v:\n                    heappush(visited, (dist(points,j,v), (v, j)))\n        return ans\n            \n", "class Solution:\n    class Union:\n        def __init__(self, n):\n            self.collection = [(i, 1) for i in range(n)]\n            self.max_cnt = 0\n            self.size = n\n        \n        def get_head(self, i):\n            if self.collection[i][0] != i:\n                return self.get_head(self.collection[i][0])\n            return self.collection[i]\n                \n        def add(self, i, j):\n            head_i, cnt_i = self.get_head(i)\n            head_j, cnt_j = self.get_head(j)\n            if head_i == head_j:\n                return False, self.max_cnt == self.size\n            \n            head = head_i if cnt_i >= cnt_j else head_j\n            cnt = cnt_i + cnt_j\n            \n            for x in [head_i, head_j, i, j]:\n                self.collection[x] = (head, cnt)\n\n            self.max_cnt = max(self.max_cnt, cnt)\n            return True, self.max_cnt == self.size\n            \n    from heapq import heappush, heappop\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = []\n        union = Solution.Union(len(points))\n        total = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                val = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heappush(heap, (val, i, j))\n                \n        while heap:\n            val, i, j = heappop(heap)\n            x, y = union.add(i, j)\n            if x:\n                total += val\n            if y:\n                break\n            \n        return total", "from heapq import heappush, heappop\nclass Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        def helper(i, j):\n            return abs(p[j][0]-p[i][0]) + abs(p[j][1]-p[i][1])\n        \n        g = defaultdict(lambda: {}); n = len(p)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                g[i][j] = g[j][i] = helper(i,j)\n\n        visited = set(); res = 0; q = []; cnt=0\n        heappush(q, (0, 0)) # u:0, cost:0\n        while q and len(visited) < n:\n            cost, u = heappop(q)\n            if u in visited: continue\n            res += cost\n            for v, w in g[u].items(): heappush(q, (w, v))\n            visited.add(u)\n        return res\n        \n        \n    \n\\\"\\\"\\\"\n[[0,0],[2,2],[3,10],[5,2],[7,0]]\n[[3,12],[-2,5],[-4,1]]\n[[0,0],[1,1],[1,0],[-1,1]]\n[[-1000000,-1000000],[1000000,1000000]]\n[[0,0]]\n\\\"\\\"\\\"            ", "class DSU:\n    def __init__(self, n):\n        self.p = [i for i in range(n)]\n    def find(self, u):\n        if self.p[u]!=u:\n            self.p[u] = self.find(self.p[u])\n        return self.p[u]\n    def union(self, x, y):\n        self.p[self.find(x)] = self.find(y)\n        \nfrom collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        ds = DSU(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u, v)\n                res += cost\n        \n        return res\n", "class DSU: \n    def __init__(self, n): \n        self.p = list(range(n))\n        self.r = [0] * n\n    def find(self, i): \n        if self.p[i] != i:\n            self.p[i] = self.find(self.p[i])\n        return self.p[i]\n    def union(self, i, j): \n        pi, pj = self.find(i), self.find(j)\n        if pi != pj: \n            if self.r[pi] >= self.r[pj]: \n                self.p[pj] = pi\n                self.r[pi] += (self.r[pi] == self.r[pj])\n            else: \n                self.p[pi] = pj\n            return True\n        return False\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # try minimum spanning treee\n        \n        to_visit = set(range(1, len(points)))\n        pq = [(abs(points[0][0] - points[x][0]) + abs(points[0][1] - points[x][1]), x) for x in range(1, len(points))]\n        heapq.heapify(pq)\n        ans = 0\n        while pq:\n            cost, to = heapq.heappop(pq)\n            if to in to_visit:\n                to_visit.remove(to)\n                ans += cost\n                for nei in to_visit:\n                    x, y = points[nei]\n                    heapq.heappush(pq, (abs(x-points[to][0]) + abs(y-points[to][1]), nei))\n\n        return ans\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = [ (abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j) for i in range(len(points)) for j in range(i+1, len(points)) ]\n        edges.sort()\n        \n        ans = 0\n        uf = DSU(len(points))\n        for cost, i, j in edges: \n            if uf.find(i) != uf.find(j): \n                uf.union(i, j)\n                ans += cost\n        return ans\n        \n                \n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans    ", "from heapq import heappush, heappop\nclass Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        helper = lambda pi, pj: abs(pj[0]-pi[0]) + abs(pj[1]-pi[1])\n        g = defaultdict(lambda: {}); n = len(p)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                g[i][j] = g[j][i] = helper(p[i], p[j])\n\n        visited = set(); res = 0; pq = []\n        heappush(pq, (0, 0)) # u:0, cost:0\n        while pq and len(visited) < n:\n            cost, u = heappop(pq)\n            if u in visited: continue\n            res += cost\n            for v, w in g[u].items(): heappush(pq, (w, v))\n            visited.add(u)\n        return res\n        \n        \n    \n\\\"\\\"\\\"\n[[0,0],[2,2],[3,10],[5,2],[7,0]]\n[[3,12],[-2,5],[-4,1]]\n[[0,0],[1,1],[1,0],[-1,1]]\n[[-1000000,-1000000],[1000000,1000000]]\n[[0,0]]\n\\\"\\\"\\\"            ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        return self.prim(points)\n    def generategraph(self, points):\n        adjList = defaultdict(list)\n        for p in points:\n            for q in points:\n                if p == q:\n                    continue\n                adjList[(p[0], p[1])].append(((abs(p[0]-q[0]) + abs(p[1]-q[1])),(q[0], q[1])))\n        return adjList\n    def prim(self, points):\n        if len(points) <= 1:\n            return 0\n        adjList = self.generategraph(points)\n        visited = set()\n        minCost = 0\n        \n        heap =[(0, tuple(points[0]), tuple(points[0]))]\n        print(heap)\n        while heap and len(visited) < len(points):\n            cost, u, v = heapq.heappop(heap)\n            if v in visited:\n                continue\n            minCost += cost\n            visited.add(v)\n            for costNei, nei in adjList[v]:\n                if nei in visited:\n                    continue\n                heapq.heappush(heap, (costNei, v, nei))\n                \n        return minCost", "class Solution:\n    \n    def kruskal(self, n, edges):\n        def find(x):\n            if x != parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        def union(x, y):\n            px, py = find(x), find(y)\n            if px == py:\n                return (False, False)\n            parent[px] = py\n            rank[py] += rank[px] \n            return (True, True) if rank[py] == n else (True, False)\n        mst_cost = 0\n        parent = list(range(n))\n        rank = [0] * n\n        for f, t, w in edges:\n            isUnion, isEnd = union(f, t)\n            if isUnion:\n                mst_cost += w\n            if isEnd:\n                break\n        return mst_cost\n        \n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda xx, yy: abs(xx[0] - yy[0]) + abs(xx[1] - yy[1])\n        \n        if (n := len(points)) == 1:\n            return 0\n        \n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                x, y = points[i], points[j]\n                edges.append([i, j, manhattan(x, y)])\n        edges.sort(key = lambda x: x[2])\n        return self.kruskal(n, edges)\n        \n        # graph = collections.defaultdict(list)\n        # for i in range(n):\n        #     for j in range(i + 1, n):\n        #         x, y = points[i], points[j]\n        #         graph[i].append((manhattan(x, y), j))\n        #         graph[j].append((manhattan(x, y), i))\n        # return prim(graph)\n            \n                \n#         def prim(graph):\n#             V = {0}\n#             edges = graph[0]\n#             heapify(edges)\n#             sum_cost = 0\n#             while edges:\n#                 cost, p2 = heappop(edges)\n#                 if p2 in V:\n#                     continue\n#                 sum_cost += cost\n#                 V.add(p2)\n#                 for new_edge in graph[p2]:\n#                     if new_edge[1] not in V:\n#                         heappush(edges, new_edge)\n#                 if len(V) == len(graph):\n#                     break\n#             return sum_cost\n", "class UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n        \n    def union(self, x, y):\n        a, b = self.find(x), self.find(y)\n        if a == b:\n            return\n        if self.rank[a] > self.rank[b]:\n            self.parents[b] = self.parents[a]\n            self.rank[a] += self.rank[b]\n        else:\n            self.parents[a] = self.parents[b]\n            self.rank[b] += self.rank[a]\n    \n    def find(self, x):\n        if self.parents[x] != x:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        UF = UnionFind(len(points))\n        cost = 0\n        for i in range(len(points)-1):\n            for j in range(i+1, len(points)):\n                edges.append([abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1]), i, j])\n        edges.sort(key = lambda x: x[0])\n        for i in range(len(edges)):\n            dist, j, k = edges[i]\n            if UF.find(j) != UF.find(k):\n                cost += dist\n                UF.union(j, k)\n        return cost", "class UnionFind:\n    def __init__(self, length):\n        self.parents = [-1] * length\n        self.ranks = [1] * length\n    \n    def find(self, src):\n        if self.parents[src] == -1:\n            return src\n        self.parents[src] = self.find(self.parents[src])\n        return self.parents[src]\n\n    def union(self, src, dest):\n        rootSrc, rootDest = self.find(src), self.find(dest)\n        if rootSrc == rootDest:\n            return False\n        \n        if self.ranks[rootSrc] > self.ranks[rootDest]:\n            self.parents[rootDest] = rootSrc\n            self.ranks[rootSrc] += self.ranks[rootDest]\n            return True\n        else:\n            self.parents[rootSrc] = rootDest\n            self.ranks[rootDest] += self.ranks[rootSrc]\n            return True\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def calHamming(pt1, pt2):\n            return abs(pt1[0] - pt2[0]) + abs(pt1[1] - pt2[1])\n        \n        ptsDistance = []\n        for i, j in itertools.combinations(range(len(points)), 2):\n            ptsDistance.append((calHamming(points[i], points[j]), i, j))\n        \n        ptsDistance.sort()\n        \n        result = 0\n        uf = UnionFind(len(points))\n        for distance, src, dest in ptsDistance:\n            if uf.union(src, dest):\n                result += distance\n        return result", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for _ in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            dis[curr] = math.inf\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                if dis[j] >  abs(x - x0) + abs(y - y0):\n                    dis[j] = abs(x - x0) + abs(y - y0)\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            res += delta\n            \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(i):\n            while i != root[i]:\n                root[i] = root[root[i]]\n                i = root[i]\n            return i\n        \n        def union(i, j):\n            if rank[i] < rank[j]:\n                root[i] = j\n            elif rank[i] > rank[j]:\n                root[j] = i\n            else:\n                root[j] = i\n                rank[i] += 1\n            \n        n = len(points)\n        graph = [] \n        for i in range(n):\n            for j in range(i+1, n):\n                distance = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) \n                graph.append((distance, i, j))\n        graph.sort()\n        \n        min_cost = 0\n        root = list(range(n))\n        rank = [0] * n\n        for distance, i, j in graph:\n            root1, root2 = find(i), find(j)\n            if root1 != root2:\n                union(root1, root2)\n                min_cost += distance\n\n        return min_cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        graph = collections.defaultdict(list)\n        \n        for node1, points1 in enumerate(points):\n            for node2, points2 in enumerate(points):\n                graph[node1].append(( abs(points1[0] - points2[0]) + abs(points1[1] - points2[1]), node2 ))\n                \n        pq = [(0,0)]\n        res = 0\n        visited = set()\n        \n        while pq:\n            d, node = heapq.heappop(pq)\n            if node in visited:\n                continue\n            visited.add(node)\n            res += d\n            if len(visited) == len(points):\n                return res\n            for distance,nei in graph[node]:\n                if nei not in visited:\n                    heapq.heappush(pq, (distance,nei))\n                    \n        return res", "# Solve Leetcode 1584. Min Cost to Connect All Points using the boilerplate code below, and then implement Kruskal's algorithm to solve the problem. Use self.distance(pointA, pointB) to find distance (weight of edge) between two nodes.\n\nclass DisjointSet:\n    def __init__(self, points):\n        self.parent = {}\n        self.rank = {}\n        for point in points:\n            self.parent[point] = point\n            self.rank[point] = 1\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        x_set = self.find(x)\n        y_set = self.find(y)\n\n        if self.rank[x_set] < self.rank[y_set]:\n            self.parent[x_set] = y_set\n        elif self.rank[x_set] > self.rank[y_set]:\n            self.parent[y_set] = x_set\n        else:\n            self.parent[x_set] = y_set\n            self.rank[y_set] += 1\n\n        \nfrom collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        points = [tuple(point) for point in points]\n        disjoint_set = DisjointSet(points)\n\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                distance = self.distance(points[i], points[j])\n                edges.append([distance, points[i], points[j]])\n        \n        edges.sort()\n        answer = 0\n        i = 0\n        times = 0\n        while times < len(points)-1:\n            if times == len(points) - 1:\n                return answer\n            distance, nodeA, nodeB = edges[i]\n            if disjoint_set.find(nodeA) != disjoint_set.find(nodeB):\n                times += 1\n                answer += distance\n                disjoint_set.union(nodeA, nodeB)\n            i += 1\n                \n        return answer\n        \n        \n\n\n    def distance(self, pointA, pointB):\n        return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        edges = []\n        \n        for i in range(N):\n            a = tuple(points[i])\n            \n            for j in range(N):\n                if i == j:\n                    continue\n                b = tuple(points[j])\n                cost = abs(a[0] - b[0]) + abs(a[1] - b[1])\n                edges.append((cost, i, j))\n                \n        edges.sort()\n        \n        dsu = DSU(N)\n        mst = 0\n        count = 0\n        \n        for cost, a, b in edges:\n            if count >= N - 1:\n                break\n            if dsu.union(a, b):\n                mst += cost\n                count += 1\n                \n        return mst\n            \nclass DSU():\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def union(self, a, b):\n        roota = self.find(a)\n        rootb = self.find(b)\n        if roota == rootb:\n            return False\n        if self.size[roota] < self.size[rootb]:\n            self.size[rootb] += self.size[roota]\n            self.parent[roota] = rootb\n        else:\n            self.size[roota] += self.size[rootb]\n            self.parent[rootb] = roota\n        return True\n\n    def find(self, a):\n        root = self.parent[a]\n        while root != self.parent[root]:\n            root = self.parent[root]\n        curr = a\n\n        # path compression\n        while curr != root:\n            after = self.parent[curr]\n            self.parent[curr] = root\n            curr = after\n\n        return root\n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = collections.defaultdict(int)\n        for i in range(1, n + 1):\n            self.parent[i] = i\n\n    def find(self, i):\n        if i != self.parent[i]:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, u, v):\n        u_parent, v_parent = self.find(u), self.find(v)\n        if u_parent == v_parent: return False\n        self.parent[u_parent] = v_parent\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        connections = list()\n        for i in range(n - 1):\n            for j in range(i+1, n):\n                # get distance\n                connections.append((i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])))\n        res = 0\n        connections_sorted = sorted(connections, key=lambda arr: arr[2])\n        UF = UnionFind(n)\n        for connection in connections_sorted:\n            a, b, cost = connection\n            if UF.find(a) != UF.find(b):\n                UF.union(a, b)\n                res += cost\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def md(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        q = [md(points[0], p) for p in points]\n        print(q)\n        res = 0\n        for _ in range(len(points) - 1):\n            d, j = min((d, j) for j, d in enumerate(q) if d > 0)\n            res += d\n            q = [min(q[i], md(points[i], points[j])) for i in range(len(q))]\n        return res\n", "#|xi - xj| + |yi - yj|\n\nfrom collections import defaultdict\n\nclass UnionFind:\n    \n    def __init__(self, n: int):\n        \n        self.n = list(range(n))\n    \n    def root(self, element: int):\n        root = self.n[element]\n        \n        while root != self.n[root]:\n            root = self.n[root]\n        \n        temp = self.n[element]\n        \n        while temp != self.n[temp]:\n            \n            self.n[temp] = root\n            temp = self.n[temp]\n        \n        return root\n        \n    \n    def union(self, a: int, b: int):\n        \n        rootA = self.root(a)\n        rootB = self.root(b)\n        \n        self.n[rootB] = rootA\n        \n    \n    def find(self, a: int, b: int):\n        return self.root(a) == self.root(b)\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        if len(points) < 2:\n            return 0\n        \n        graph = defaultdict(list)\n        edges = []\n        \n        for i in range(len(points)):\n            \n            xi, yi = points[i]\n            \n            for j in range(i + 1, len(points)):\n                \n                xj, yj = points[j]\n                \n                edges.append((abs(xi - xj) + abs(yi - yj), i, j))\n        \n        edges.sort()\n        total = 0\n        \n        uf = UnionFind(len(points))\n        \n        for distance, origin, destination in edges:\n            if not uf.find(origin, destination):\n                uf.union(origin, destination)\n                total += distance\n        \n        return total\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # MST search algorithm Prim\n        G = collections.defaultdict(list)\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dis = abs(points[i][0]-points[j][0]) + abs(points[i][1] - points[j][1])\n                G[i].append((dis, j))\n                G[j].append((dis, i))\n        # print(G)\n        visited = {0}\n        pq = G[0]\n        heapq.heapify(pq)\n        res = 0\n        while len(visited) < len(points) and pq:\n            w, v = heapq.heappop(pq)\n            if v not in visited:\n                res += w\n                visited.add(v)\n                for w, nei in G[v]:\n                    if nei not in visited:\n                        heapq.heappush(pq, (w,nei))\n        return res\n        \n        \n        \n        # MST search algorithm Kruskal\n        # create MST over a created graph\n#         q = []\n#         for i in range(len(points)):\n#             for j in range(i+1, len(points)):\n#                 dis = abs(points[i][0]-points[j][0]) + abs(points[i][1] - points[j][1])\n#                 q.append((dis, i, j))\n        \n#         def find(x):\n#             if (x != parent[x]):\n#                 parent[x] = find(parent[x])\n#             return parent[x]\n#         def union(x, y):\n#             if size[x] > size[y]:\n#                 size[x] += size[y]\n#                 parent[y] = x\n#             else:\n#                 size[y] += size[x]\n#                 parent[x] = y\n                \n#         n = len(points)\n#         parent = [i for i in range(n+1)]\n#         size = [1 for _ in range(n+1)]  \n#         q.sort()  # sort edges\n#         res = 0\n#         count = 0\n#         for w, u, v in q:\n#             rA, rB = find(u), find(v)\n#             if rA == rB:\n#                 continue\n#             union(rA, rB)\n#             res += w\n#             # Optimize so that we don't traverse all edges\n#             count += 1\n#             if count == n:\n#                 return res\n#         return res \n", "#Build weighted graph and then use Union-Find to get MST\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N, g = len(points), []\n        res = 0\n        \n        #build the weighted graph\n        for i in range(N - 1):\n            x0, y0 = points[i]\n            for j in range(i + 1, N):                \n                x1, y1 = points[j]\n                dist = abs(x0 - x1) + abs(y0 - y1)\n                g.append((dist, (i, j)))\n                \n        #sort by weight\n        g.sort()\n        \n        #Union-Find to get MST\n        parents = [None] * N\n        for i in range(N): parents[i] = i\n            \n        def findParent(x):\n            if parents[x] != x:\n                parents[x] = findParent(parents[x])\n            \n            return parents[x]\n        \n        used_edges = 0\n        for w, (a, b) in g:\n            pa = findParent(a)\n            pb = findParent(b)\n            \n            #union sub-graphs if not connected yet\n            if pa != pb:\n                res += w\n                parents[pa] = pb\n                used_edges += 1\n                if used_edges == N - 1:\n                    #we find all edges\n                    break\n        \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: p[0] + p[1])\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            p1, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p2, dist) in enumerate(points):\n                points[i][1] = min(points[i][1], distance(p1, p2))\n                #newdist = distance(p1, p2)\n                #if newdist < dist:\n                #    points[i][1] = newdist\n        return total_cost        ", "class UnionFind(object):\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rnk = [0]*n\n        \n    def find(self,x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        elif self.rnk[xr] < self.rnk[yr]:\n            self.par[xr] = yr\n        elif self.rnk[xr] > self.rnk[yr]:\n            self.par[yr] = xr\n        else:\n            self.par[yr] = xr\n            self.rnk[xr] += 1\n        return True\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        distances = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                distances.append([i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])])\n                \n        distances.sort(key = lambda x: x[2])\n        res = 0\n        uf = UnionFind(n)\n        for i, j, d in distances:\n            if uf.find(i) == uf.find(j):\n                continue\n            res += d\n            uf.union(i, j)\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def cost(a,b): \n            return abs(a[0]-b[0]) + abs(a[1] - b[1])\n        \n        #LC copy from JerryJin2905\n        \n        edges = [[] for _ in points]\n        \n        # Build edge cost list\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dist = cost(points[i], points[j])\n                edges[i].append([dist, j])\n                edges[j].append([dist, i])\n                                \n        # choose first point as root\n        cost = 0\n        tree = {0}\n        pq = []\n        for c,v in edges[0]:\n            pq.append([c,v])\n            \n        heapify(pq)\n            \n        while len(tree) < len(points):\n\n            c,v = heappop(pq)\n            if v in tree:\n                continue\n            tree.add(v)\n            cost += c\n                                \n            for d,u in edges[v]:\n                if not u in tree:\n                    heappush(pq, [d,u])\n    \n        return cost\n", "class DisjoinSet:\n  def __init__(self, n):\n    self.parent = [i for i in range(n)]\n  \n  def find(self, x):\n    if self.parent[x] != x:\n      self.parent[x] = self.find(self.parent[x])\n    return self.parent[x]\n  \n  def union(self, x, y):\n    xr = self.find(x)\n    yr = self.find(y)\n    if xr != yr:\n      self.parent[yr] = xr\n      return True\n    return False\n\nclass Solution:\n    def minCostConnectPoints(self, points):\n      n = len(points)\n      graph = []\n      ds = DisjoinSet(n)\n\n      for i in range(n):\n        for j in range(i + 1, n):\n          dist = self.getDist(points[i], points[j])\n          graph.append((dist, i, j))    \n\n      graph.sort()\n\n      res = 0\n\n      for dist, u, v in graph:\n        if ds.union(u, v):\n          res += dist\n      return res\n\n    def getDist(self, x, y):\n      return abs(x[0] - y[0]) + abs(x[1] - y[1])", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda u, v: abs(u[0] - v[0]) + abs(u[1] - v[1])\n        from collections import defaultdict\n        n = len(points)\n\n        graph = defaultdict(list)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                w = manhattan(points[i], points[j])\n                graph[i].append((w, j))\n                graph[j].append((w, i))\n\n        k = 1                       # keep track of vertices\n        costs = 0\n        seen = [False] * n\n\n        seen[0] = True\n        heap = graph[0]\n        heapq.heapify(heap)\n        while heap:\n            w, u = heapq.heappop(heap)\n            if not seen[u]:\n                seen[u] = True\n                costs += w\n                k += 1\n                \n                for ew, v in graph[u]:\n                    heapq.heappush(heap, (ew, v))\n                    \n            if k == n: break\n        return costs\n", "class DSU:\n    def __init__(self, size):\n        self.indexes = {i:i for i in range(size)}\n        \n        \n    def root(self, i):\n        node = i\n        while i!=self.indexes[i]:\n            i = self.indexes[i]\n        \n        while node!=i:\n            nnode = self.indexes[node]\n            self.indexes[node] = i\n            node = nnode\n        return i\n    \n    def unite(self, i, j):\n        ri, rj = self.root(i), self.root(j)\n        if ri==rj: return\n        self.indexes[rj] = ri\n        \n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        edges = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x,y = points[i][0], points[i][1]\n                u,v = points[j][0], points[j][1]\n                edges.append((abs(u-x)+abs(v-y), i, j))\n        \n        edges.sort()\n        \n        dsu = DSU(len(points))\n        \n        ans = 0\n        for dis, u, v in edges:\n            if dsu.root(u)==dsu.root(v):\n                continue\n            \n            dsu.unite(u, v)\n            ans += dis\n        return ans\n    \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        if len(points) <= 1:\n            return 0\n        \n        def dist(a,b):\n            return abs(a[1]-b[1]) + abs(a[0]-b[0])\n        \n        A = {i:{i} for i in range(len(points))}\n        edges = [(dist(p1,p2), i, j) for i, p1 in enumerate(points) for j, p2 in enumerate(points) if p1 != p2]\n        import heapq\n        heapq.heapify(edges)\n        \n        tot = 0\n        n = len(points)-1\n        while n:\n            w, a, b = heapq.heappop(edges)\n            if not A[a].intersection(A[b]):\n                # print(\\\"edge:\\\",points[a],points[b])\n                # print(\\\"a's set:\\\" ,A[a])\n                # print(\\\"b's set:\\\", A[b])\n                B = A[a].union(A[b])\n                for b in B:\n                    A[b] = B\n                tot += w\n                n -= 1\n        print((A[0], len(points)))\n        return tot\n", "from heapq import heappush,heappop\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def calcCost(i,j):\n            return abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n        totalCost,visited,q=0,set(),[(0,0)]\n        while len(visited)!=len(points):\n            cost,point=heappop(q)\n            if point not in visited:\n                visited.add(point)\n                totalCost+=cost\n                for i in range(len(points)):\n                    if i!=point:\n                        heappush(q,(calcCost(point,i),i))\n        return totalCost", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        edges = [[] * N for _ in range(N)]\n        for i1, p1 in enumerate(points):\n            for i2, p2 in enumerate(points[i1+1:], start = i1+1):\n                distance = dist(p1, p2)\n                edges[i1].append([distance, i2])\n                edges[i2].append([distance, i1])\n        heap = edges[0]\n        heapify(heap)\n        total_cost, seen = 0, {0}\n        while len(seen) < N:\n            cost, node = heappop(heap)\n            if node in seen:\n                continue\n            seen.add(node)\n            total_cost += cost\n            for dist, next_ in edges[node]:\n                if next_ not in seen:\n                    heappush(heap, [dist, next_])\n        return total_cost", "# alright, whatever, time to solve it again in Python3 \\\\U0001f40d  whoo!\n\n# ok silly mistake, but that's A ok :)\n\n# alright! cool, well time for C++ then i'm done upsolving this one, it was fun :)\n\n# class Solution:\n#     def minCostConnectPoints(self, A: List[List[int]]) -> int:\n#         N = len(A)\n#         P = [i for i in range(N)]                       # \\\\U0001f642 parent representatives of N disjoint sets\n#         E = []\n#         for u in range(N):\n#             x1, y1 = A[u]\n#             for v in range(u + 1, N):\n#                 x2, y2 = A[v]\n#                 w = abs(x1 - x2) + abs(y1 - y2)\n#                 E.append([ u, v, w ])                   # \\\\U0001f5fa edge u, v with weight w \\\\U0001f4b0\n#         E.sort(key = lambda edge: edge[2])              # \u2b50\ufe0f sort edges by weight w \\\\U0001f4b0\n#         def find(x):\n#             P[x] = P[x] if P[x] == x else find(P[x])\n#             return P[x]\n#         def union(a, b):\n#             a = find(a)\n#             b = find(b)\n#             if a == b:\n#                 return False\n#             P[a] = b                                     # \\\\U0001f3b2 arbitrary choice\n#             return True\n#         return sum([w for u, v, w in E if union(u, v)])  # \\\\U0001f3af sum of minimum edge weights w \\\\U0001f4b0 to construct Kruskal's MST \\\\U0001f332\n\n# create the edge cost lookups E\n# create adjacency list adj\n# create winner/best for each v\n\n\n\nclass Solution:\n    def minCostConnectPoints(self, A: List[List[int]], total = 0) -> int:\n        N = len(A)\n        cand = set([i for i in range(1, N)])\n        E = [[float('inf')] * N for _ in range(N)]\n        for u in range(N):\n            x1, y1 = A[u]\n            for v in range(u + 1, N):\n                x2, y2 = A[v]\n                cost = abs(x1 - x2) + abs(y1 - y2)\n                E[u][v] = cost\n                E[v][u] = cost\n        s = 0\n        q = []\n        best = [float('inf')] * N\n        for v in range(1, N):\n            if best[v] > E[s][v]:\n                best[v] = E[s][v]\n                heappush(q, [best[v], v])\n        while len(cand):\n            cost, u = heappop(q)\n            if u not in cand:\n                continue\n            cand.remove(u)\n            total += cost\n            for v in range(N):\n                if v not in cand:\n                    continue\n                if best[v] > E[u][v]:\n                    best[v] = E[u][v]\n                    heappush(q, [best[v], v])\n        return total\n    \n    \n    \n", "from heapq import heapify, heappush, heappop\nfrom collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # helper function to calculate the manhatten distance \n        # between two points\n        def distance(point1, point2):\n            x1, y1 = point1\n            x2, y2 = point2\n            return abs(x1-x2) + abs(y1-y2)\n        \n        n = len(points)\n        if n == 1:\n            return 0\n        \n        # convert all the points to tuples so they are hashable\n        points = [tuple(p) for p in points]\n        \n        # build the graph\n        # key: vertex\n        # value: list of neighbors and their edge weights\n        cost = defaultdict(list)\n        for i in range(n):\n            point1 = points[i]\n            for j in range(i+1, n):\n                point2 = points[j]\n                d = distance(point1, point2)\n                cost[point1].append((d, point2))\n                cost[point2].append((d, point1))\n                \n        \n        ans = 0\n        # we start at the first point in the input\n        visited = {points[0]}\n        # add all the neighbors of point 0 to PQ\n        heap = cost[points[0]]\n        heapify(heap)\n        \n        # we loop until all the points have been visited\n        while len(visited) != n:\n            # remove the vertex with the smallest edge weight\n            d, v = heappop(heap)\n            # check if this vertex is unvisited\n            if v not in visited:\n                # move this vertex to the visited set\n                visited.add(v)\n                # this edge is part of the MST\n                ans += d\n                # add all the neighbors of v into priority queue\n                for record in cost[v]:\n                    heappush(heap, record)\n        \n        return ans\n                    \n                       \n                        \n                    \n            \n            \n        \n        \n        \n", "class DSU:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n    \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self,x,y):\n        px = self.find(x)\n        py = self.find(y)\n        rx = self.rank[x]\n        ry = self.rank[y]\n        if px==py:\n            return False\n        if rx>ry:\n            self.parent[py]=px\n            self.rank[px]+=self.rank[py]\n        else:\n            self.parent[px]=py\n            self.rank[py]+=self.rank[px]\n        return True\n                \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n    \n        edges.sort()\n        res = 0\n        ds = DSU(n)\n        for cost, u, v in edges:\n            if ds.union(u,v):\n                res += cost\n        return res", "from heapq import heappush,heappop\nclass Solution:\n    \n    def manhattan(self,point1,point2):\n        return abs(point1[0]-point2[0]) + abs(point1[1]-point2[1])\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        n = len(points)\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    graph[i].append([self.manhattan(points[i],points[j]),j])\n        \n        \n        heap = [(0,0)]\n        visited = set()\n        answer = 0\n        while len(visited)<n:\n            distance,node = heappop(heap)\n            if node in visited:\n                continue\n            \n            visited.add(node)\n            answer+=distance\n            for weight,nei in graph[node]:\n                if nei not in visited:\n                    heappush(heap,(weight,nei))\n        \n        return answer\n", "class DisjointSet:\n    def __init__(self, size):\n        self.size = size\n        self.parents = list(range(size))\n    def find(self, node):\n        if node != self.parents[node]:\n            self.parents[node] = self.find(self.parents[node])\n        return self.parents[node]\n    def union(self, node1, node2):\n        parent1 = self.find(node1)\n        parent2 = self.find(node2)\n        if parent1 != parent2:\n            self.parents[parent1] = parent2\n            return True\n        return False\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        is_connected = [False]*N\n        edges = []\n        for i in range(N):\n            for j in range(i+1, N):\n                distance = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                edges.append((distance, i, j))\n        edges.sort()\n        cost = 0\n        disjoint_set = DisjointSet(N)\n        for distance, i, j in edges:\n            if disjoint_set.union(i, j):\n                cost += distance\n        return cost", "class UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        \n    def union(self, index1, index2):\n        root1 = self.find(index1)\n        root2 = self.find(index2)\n        if root1 == root2:\n            return 0\n        elif root1 > root2:\n            self.parents[root2] = root1\n        else:\n            self.parents[root1] = root2\n        return 1\n    \n    def find(self, index):\n        if self.parents[index] != index:\n            self.parents[index] = self.find(self.parents[index])\n        return self.parents[index]\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) <= 1:\n            return 0\n        \n        edges = []\n        for i, point1 in enumerate(points):\n            for j in range(i + 1, len(points)):\n                point2 = points[j]\n                distance = abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n                edges.append((distance, i, j))\n        edges.sort()\n        \n        uf = UnionFind(len(points))\n        total = 0\n        for i, (weight, node1, node2) in enumerate(edges):\n            is_union = uf.union(node1, node2)\n            if is_union:\n                total += weight\n        return total\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        cache = []\n        l = len(points)\n        if l == 1:\n            return 0\n\n        for i in range(l-1):\n            for j in range(i+1, l):\n                start = points[i]\n                end = points[j]\n                length = abs(start[0]-end[0])+abs(start[1]-end[1])\n                cache.append([length, i, j])\n        cache.sort()\n        #print(cache)\n\n        res = 0\n        t = len(cache)\n        count = 0\n        group = []\n        for i in range(t):\n            #print(group)\n            \n            curr = cache[i]\n            g = len(group)\n            a = None\n            b = None\n            for j in range(g):\n                if curr[1] in group[j]:\n                    a = j\n                if curr[2] in group[j]:\n                    b = j\n            #print(a,b)\n\n            if a == None and b == None:\n                group.append({curr[1], curr[2]})\n            elif a == None:\n                group[b].add(curr[1])\n            elif b == None:\n                group[a].add(curr[2])\n            else:\n                if a == b:\n                    continue\n                else:\n                    group[a] = group[a] | group[b]\n                    group.pop(b)\n            count += 1\n            res += curr[0]   \n            if count == l-1:\n                #print(group)\n                return res\n", "from heapq import *\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if not points:\n            return 0\n        \n        adjList = self.buildAdjList(points)\n\n        heap = [(0, 0, 0)]\n        visited = set()\n        minCost = 0\n        while heap and len(visited) != len(adjList):\n            cost, i, j = heappop(heap)\n            if j in visited:\n                continue\n                \n            visited.add(j)\n            minCost += cost\n                \n            for nj, cost in adjList[j]:\n                if nj not in visited:\n                    heappush(heap, (cost, j, nj))\n        return minCost\n        \n    def buildAdjList(self, points):\n        adjList = {}\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if i not in adjList:\n                    adjList[i] = []\n                if j not in adjList:\n                    adjList[j] = []\n\n                weight = abs(x1-x2) + abs(y1-y2)\n                adjList[i].append((j, weight))\n                adjList[j].append((i, weight))\n        return adjList", "class UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        \n    def union(self, x, y):\n        a, b = self.find(x), self.find(y)\n        self.parents[a] = self.parents[b]\n    \n    def find(self, x):\n        if self.parents[x] != x:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        UF = UnionFind(len(points))\n        cost = 0\n        for i in range(len(points)-1):\n            for j in range(i+1, len(points)):\n                edges.append([abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1]), i, j])\n        edges.sort(key = lambda x: x[0])\n        for i in range(len(edges)):\n            dist, j, k = edges[i]\n            if UF.find(j) != UF.find(k):\n                cost += dist\n                UF.union(j, k)\n        return cost", "import math\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        edges = []\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                edges.append(( abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j))\n                \n        edges.sort()\n        # print(edges)\n        union_find = UnionFind(len(points))\n        \n        min_sum = 0\n        for d, i, j in edges:\n            if union_find.union(i, j):\n                min_sum += d\n                \n        return min_sum\n                \nclass UnionFind:\n    def __init__(self, n):\n        \n        self.parent = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n        \n    def find(self, p):\n        root = p\n        while(root != self.parent[root]):\n            root = self.parent[root]\n            \n        node = p\n        while(node != self.parent[node]):\n            \n            nextNode = self.parent[node]\n            self.parent[node] = root\n            node = nextNode\n            \n        return root\n            \n    def union(self, p, q):\n        \n        p_root = self.find(p)\n        q_root = self.find(q)\n        \n        if p_root == q_root:\n            return False\n        \n        if self.size[p_root] < self.size[q_root]:\n            self.parent[p_root] = q_root\n            self.size[q_root] += self.size[p_root]\n        else:\n            self.parent[q_root] = p_root\n            self.size[p_root] += self.size[q_root]\n            \n        return True", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # prim\n        from collections import defaultdict\n        import heapq\n        manhattan = lambda a, b:abs(a[0]-b[0]) + abs(a[1]-b[1])\n        n, c = len(points), defaultdict(list)\n        if n==0:\n            return 0\n        for i in range(n):\n            for j in range(i+1, n):\n                dis = manhattan(points[i], points[j])\n                c[i].append((dis, j))\n                c[j].append((dis, i))\n        cnt, ans, visited, heap = 1, 0, [0]*n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while cnt<n:\n            dis, p = heapq.heappop(heap)\n            if not visited[p]:\n                visited[p], cnt, ans = 1, cnt+1, ans+dis\n                for record in c[p]:\n                    heapq.heappush(heap, record)\n        return ans ", "# alright, whatever, time to solve it again in Python3 \\\\U0001f40d  whoo!\n\n# ok silly mistake, but that's A ok :)\n\n# alright! cool, well time for C++ then i'm done upsolving this one, it was fun :)\n\n# class Solution:\n#     def minCostConnectPoints(self, A: List[List[int]]) -> int:\n#         N = len(A)\n#         P = [i for i in range(N)]                       # \\\\U0001f642 parent representatives of N disjoint sets\n#         E = []\n#         for u in range(N):\n#             x1, y1 = A[u]\n#             for v in range(u + 1, N):\n#                 x2, y2 = A[v]\n#                 w = abs(x1 - x2) + abs(y1 - y2)\n#                 E.append([ u, v, w ])                   # \\\\U0001f5fa edge u, v with weight w \\\\U0001f4b0\n#         E.sort(key = lambda edge: edge[2])              # \u2b50\ufe0f sort edges by weight w \\\\U0001f4b0\n#         def find(x):\n#             P[x] = P[x] if P[x] == x else find(P[x])\n#             return P[x]\n#         def union(a, b):\n#             a = find(a)\n#             b = find(b)\n#             if a == b:\n#                 return False\n#             P[a] = b                                     # \\\\U0001f3b2 arbitrary choice\n#             return True\n#         return sum([w for u, v, w in E if union(u, v)])  # \\\\U0001f3af sum of minimum edge weights w \\\\U0001f4b0 to construct Kruskal's MST \\\\U0001f332\n\n# create the edge cost lookups E\n# create adjacency list adj\n# create winner/best for each v\n\n\n\nclass Solution:\n    def minCostConnectPoints(self, A: List[List[int]], total = 0) -> int:\n        N = len(A)\n        # 1.\n        cand = set([i for i in range(N)])\n        E = [[float('inf')] * N for _ in range(N)]\n        for u in range(N):\n            x1, y1 = A[u]\n            for v in range(u + 1, N):\n                x2, y2 = A[v]\n                cost = abs(x1 - x2) + abs(y1 - y2)\n                E[u][v] = cost\n                E[v][u] = cost\n        # 2.\n        q = []\n        best = [float('inf') for _ in range(N)]\n        winner = [-1 for _ in range(N)]\n        s = 0\n        cand.remove(0)\n        for v in range(1, N):\n            if best[v] > E[s][v]:\n                best[v] = E[s][v]\n                winner[v] = s\n                heappush(q, [best[v], v])\n        # 3.\n        while len(cand):\n            cost, u = heappop(q)\n            if u not in cand:\n                continue\n            cand.remove(u)\n            total += cost\n            for v in range(N):\n                if v not in cand:\n                    continue\n                if best[v] > E[u][v]:\n                    best[v] = E[u][v]\n                    winner[v] = u\n                    heappush(q, [best[v], v])\n        return total\n    \n    \n    \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        graph = defaultdict(list)\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                cost = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                graph[i].append((cost, j))\n                graph[j].append((cost, i))\n        \n        seen = [0] * (len(points)+1)\n        seen[0] = 1\n        q = graph[0]\n        minimumCost = 0\n        connectedNodes = 1\n        heapq.heapify(q)\n        while q:\n            cost, point = heapq.heappop(q)\n            if not seen[point]:\n                seen[point] = 1\n                minimumCost += cost\n                connectedNodes += 1\n                for connectingCost, neighbour in graph[point]:\n                    heapq.heappush(q, (connectingCost, neighbour))\n            if connectedNodes >= len(points):\n                break\n        return minimumCost", "class DSU:\n    def __init__(self, n):\n        self.n = n\n        self.fa = list(range(n))\n\n    def find(self, x):\n        r = x\n        while self.fa[r] != r:\n            r = self.fa[r]\n        i = x\n        while i != r:\n            i, self.fa[i] = self.fa[i], r\n        return r\n    \n    def join(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            self.fa[x] = y\n\nclass Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        n = len(p)\n        e = []\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                d = abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])\n                e.append((d, i, j))\n        \n        e.sort()\n        \n        dsu = DSU(n)\n        had = 0\n        ans = 0\n        for (d, i, j) in e:\n            if dsu.find(i) != dsu.find(j):\n                ans += d\n                dsu.join(i, j)\n                had += 1\n            if had == n - 1:\n                break\n        return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) < 2:\n            return 0\n        e = [[] for _ in points]\n        n = len(points)\n        for i, u in enumerate(points):\n            for j in range(i + 1, n):\n                v = points[j]\n                d = abs(u[0] - v[0]) + abs(u[1] - v[1])\n                e[i].append((d, j))\n                e[j].append((d, i))\n        \n        tree = { 0 }\n        \n        pq = []\n        for v in e[0]:\n            pq.append(v)\n        heapify(pq)\n        \n        c = 0\n        while len(tree) < n:\n            try:\n                d, v = heappop(pq)\n            except IndexError:\n                break\n            if v in tree:\n                continue\n            c += d\n            tree.add(v)\n            for u in e[v]:\n                heappush(pq, u)\n        \n        return c\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, dic = len(points), collections.defaultdict(list)\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                dic[i].append((d, j))\n                dic[j].append((d, i))\n                \n        cnt, ans, visited, heap = 1, 0, [0] * n, dic[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in dic[j]: \n                    heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans", "class Union_Find:\n    def __init__(self, n):\n        self.father = {i:i for i in range(n)}\n        self.count = n\n        # \u53ef\u4ee5\u67e5\u770b \u67d0\u4e00\u4e2anode \u6709\u51e0\u4e2a\u8054\u901a\n        self.rank = [1] * n\n\n    def find(self, x):\n        if self.father[x] == x:\n            return x\n        self.father[x] = self.find(self.father[x])\n        return self.father[x]\n\n    def union(self, x, y):\n        if self.rank[x] < self.rank[y]:\n            x, y = y, x\n        self.father[y] = x\n        self.rank[x] += self.rank[y]\n        self.count -= 1\n\n    def find_union(self, x, y):\n        father_x, father_y = self.find(x), self.find(y)\n        if father_x != father_y:\n            self.union(father_x, father_y)\n            # \u8868\u793a\uff0c\u5982\u679c\u672c\u6765\u4e0d\u662f\u8054\u901a return true\n            return True\n        return False\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        mst = collections.defaultdict(set)\n        n = len(points)\n        graph = []\n        uf = Union_Find(n)\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                cost = cost = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                graph.append([i,j,cost])\n        \n        result = 0\n        for a, b, c in sorted(graph, key = lambda x:x[2]):\n            if uf.find_union(a,b):\n                result += c\n        return result\n        \n                \n                \n                \n            \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        from queue import PriorityQueue\n        q = PriorityQueue()\n        \n        # adj = {}\n        # for point in points:\n        #     s = point[]\n        l = len(points)\n        visited = set()\n        \n        for j in range(1, l):\n            q.put((abs(points[0][0] - points[j][0]) + abs(points[0][1] - points[j][1]), j))\n        \n        visited.add(0)\n        count = 1\n        ans = 0\n        while count < l:\n            dis, point = q.get()\n            if point not in visited:\n                visited.add(point)\n                for j in range(l):\n                    if j not in visited:\n                        q.put((abs(points[point][0] - points[j][0]) + abs(points[point][1] - points[j][1]), j))\n                ans += dis\n                count += 1\n            # print(dis, point)\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def union(g, u, v):\n            p = g[u]\n            o = g[v]\n            for i in g.keys():\n                if g[i] == o:\n                    g[i] = p                    \n\n        N = len(points)\n        matrix = [[float('inf')]*N for _ in range(N)]\n        ans = 0\n        edges = []\n        for node in range(N):\n            for neighbor in range(N):\n                if node == neighbor: continue\n                if matrix[node][neighbor] != float('inf'): continue\n                u, v = points[node], points[neighbor]\n                d = abs(u[0] - v[0]) + abs(u[1] - v[1])\n                matrix[node][neighbor] = d\n                matrix[neighbor][node] = d\n                edges.append((node, neighbor, d))\n                edges.append((neighbor, node, d))\n        P = {_: _ for _ in range(N)}\n        edges.sort(key=lambda x: x[2])\n        for u, v, w in edges:\n            if P[u] != P[v]:\n                union(P, u, v)\n                ans += w\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points)<=1:return 0\n        ans=0\n        par={}\n        def find(x):\n            if x not in par:return x\n            res=find(par[x])\n            par[x]=res\n            return res\n        def union(a,b):\n            n1=find(a)\n            n2=find(b)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n                return True\n            else:return False\n        arr=[]\n        for i in range(len(points)):\n            _min=10e9\n            ix=-1\n            for j in range(i+1,len(points)):\n                n=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                arr.append((n,(i,j)))\n##        print(ans)\n##        arr=list(arr)\n        arr.sort()\n        for x in arr:\n            i=x[1][0]\n            j=x[1][1]\n            n1=find(i)\n            n2=find(j)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n                ans+=x[0]\n        return ans  ", "from heapq import *\nfrom collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        edges = defaultdict(list)\n        for i1, p1 in enumerate(points):\n            for i2, p2 in enumerate(points[i1+1:], start = i1+1):\n                distance = dist(p1, p2)\n                edges[i1].append([distance, i2])\n                edges[i2].append([distance, i1])\n        heap = edges[0]\n        heapify(heap)\n        total_cost, seen = 0, {0}\n        while len(seen) < N:\n            cost, node = heappop(heap)\n            if node in seen:\n                continue\n            seen.add(node)\n            total_cost += cost\n            for dist, next_ in edges[node]:\n                if next_ not in seen:\n                    heappush(heap, [dist, next_])\n        return total_cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        ## minimal spam tree\n        length = len(points)\n        if length < 2: return 0\n        \n        dist = [[0] * len(points) for _ in range(len(points))]\n        value = float('inf')        \n                \n        for i in range(length):\n            dist[i][i] = float('inf')\n            for j in range(length):\n                if i!=j:\n                    dist[i][j] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                if dist[i][j] < value:\n                    value = dist[i][j]\n                    idx_i, idx_j = i, j\n                                \n        connected, result = set([idx_i, idx_j]), dist[idx_i][idx_j]\n       \n        heap_q = []   \n        def increaseQ(heap_q: List[int], idx:int, connected:Set[int]):\n            for j in range(length):\n                if j not in connected:\n                    heapq.heappush(heap_q, (dist[idx][j], idx, j))\n            \n        increaseQ(heap_q, idx_i, connected)\n        increaseQ(heap_q, idx_j, connected)\n        \n        while len(connected) < length:\n                v, idx_i, idx_j = heapq.heappop(heap_q)\n                if idx_i not in connected:\n                    connected.add(idx_i)\n                    increaseQ(heap_q, idx_i, connected)\n                    result +=v\n                if idx_j not in connected:\n                    connected.add(idx_j)\n                    increaseQ(heap_q, idx_j, connected)\n                    result +=v\n        return result\n        \n                \n        \n", "class Solution:\n    def minCostConnectPoints(self, points):\n        helper = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        points.sort(key = lambda p: p[0] + p[1])\n        points = [[p, helper(p, points[0])] for p in points]\n        total_cost = 0\n        while points:\n            minI, minD = None, float('inf')\n            for i, (p, d) in enumerate(points):\n                if d < minD:\n                    minI, minD = i, d\n            p1, cost = points.pop(minI)\n            total_cost += cost\n            for i, (p2, _) in enumerate(points):\n                points[i][1] = min(points[i][1], helper(p1, p2))\n        return total_cost", "class DSU:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n    \n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return\n        self.par[px] = py\n        return\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        cnt = 0\n        n = len(points)\n        needs = n-1\n        dsu = DSU(n)\n        \n        dists = [(dist(points[i], points[j]), i, j) for i in range(n) for j in range(n) if i != j]\n        dists.sort()\n        \n        i = 0\n        while i < len(dists) and needs:\n            d, x, y = dists[i]\n            px, py = dsu.find(x), dsu.find(y)\n            if px == py:\n                i += 1\n            else:\n                # print(points[x], points[y])\n                cnt += d\n                dsu.union(x, y)\n                needs -= 1\n        return cnt\n        \n", "from heapq import heappush, heappop\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        points.sort()\n        visited = set()\n        n = len(points)\n        cnt = 0\n        q = []\n\n        heappush(q, (0,0))\n        while len(q):\n            weight, source = heappop(q)\n            if source in visited:\n                continue\n            cnt += weight\n            visited.add(source)\n\n            for i in range(n):\n                if i not in visited:\n                    weight = abs(points[i][0] - points[source][0]) + abs(points[i][1] - points[source][1])\n                    heappush(q, (weight, i))\n        \n        return cnt\n", "class Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                \n        n = len(a)\n        if n <= 1: return 0\n        d, cur, min_d = dict(), set(), float('inf')\n        for i in range(n-1):            \n            for j in range(n):                \n                d[i, j] = d[j, i] = abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1])                 \n                if min_d > d[i, j]: min_d = d[i, j]; cur = set([i, j])\n                                        \n        rem, cand = set(range(n)) - cur, []\n        for x in cur:\n            for y in rem:                \n                cand.append((d[(x, y)], x, y))\n        \n        heapify(cand); ans = min_d       \n        while len(cur) < n:\n            val, x, y = heappop(cand)\n            if y not in cur: \n                cur.add(y)  \n                rem.discard(y)\n                ans += val\n                for z in rem:\n                    heappush(cand, (d[(y, z)], y, z))\n        return ans\n                \n        \n        \n", "class UnionFind:\n    \n    def __init__(self, n):\n        self.count = n\n        self.id = list(range(n))\n        \n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n\n    def find(self, p):\n        if p == self.id[p]:\n            return p\n        return self.find(self.id[p])\n    \n    def union(self, p, q):\n        idp = self.find(p)\n        idq = self.find(q)\n        if not self.connected(p,q):\n            self.id[idp]=idq\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        distance = lambda i, j: abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        graph = collections.defaultdict(list)\n        hp = []\n        n = len(points)\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    graph[i].append((distance(i, j), j))\n        start, cost = 0, 0\n        visited = {0}\n\n        for to in graph[0]:\n            heapq.heappush(hp, to)\n        \n        while len(visited) != n and len(hp):\n            dist, to = heapq.heappop(hp)\n            if to not in visited:\n                visited.add(to)\n                cost += dist\n                for t in graph[to]:\n                    heapq.heappush(hp, t)\n        return cost", "class DSU:\n    def __init__(self,n):\n        self.p = list(range(n))\n    def find(self,x):\n        if self.p[x]!=x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    def union(self,x,y):\n        r1 = self.find(x)\n        r2 = self.find(y)\n        if r1!=r2:\n            self.p[r1] = r2\n            return True\n        return False\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dsu = DSU(len(points))\n        def getDistance(point1,point2):\n            x1,y1 = point1\n            x2,y2 = point2\n            return abs(x1-x2)+abs(y1-y2)\n        paths = []\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                dis = getDistance(points[i],points[j])\n                paths.append((dis,i,j))\n        paths.sort()\n        cost = 0\n        for dis,i,j in paths:\n            if dsu.union(i,j):\n                cost+=dis\n        return cost\n                \n                \n        \n                    \n                    \n                    \n                    \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # create MST over a created graph\n        # G = collections.defaultdict(list)\n        q = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dis = abs(points[i][0]-points[j][0]) + abs(points[i][1] - points[j][1])\n                q.append((dis, i, j))\n                # G[i].append((dis,j))  # can sort based on dis\n        \n        # MST search algorithm: Prim and Kruskal\n        # Kruskal\n        # path compression\n        def find(x):\n            if (x != parent[x]):\n                parent[x] = find(parent[x])\n            return parent[x]\n        # union by rank\n        def union(x, y):\n            if size[x] > size[y]:\n                size[x] += size[y]\n                parent[y] = x\n            else:\n                size[y] += size[x]\n                parent[x] = y\n                \n        n = len(points)\n        parent = [i for i in range(n+1)]\n        size = [1 for _ in range(n+1)]  \n        q.sort()  # sort edges\n        res = 0\n        count = 0\n        for w, u, v in q:\n            rA, rB = find(u), find(v)\n            if rA == rB:\n                continue\n            union(rA, rB)\n            res += w\n            # Optimize so that we don't traverse all edges\n            count += 1\n            if count == n:\n                return res\n        return res ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        \n        mapper = collections.defaultdict(dict)\n        for ind1, point1 in enumerate(points):\n            for ind2, point2 in enumerate(points):\n                dis = abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n                mapper[ind1][ind2] = dis\n                mapper[ind2][ind1] = dis\n        \n        cost = 0\n        c = set()\n        unc = set(range(n))\n        \n        min_i, min_j = None, None\n        min_d = math.inf\n        for i in range(n):\n            for j in range(n):\n                if i != j and mapper[i][j] < min_d:\n                    min_i, min_j = i, j\n                    min_d = mapper[i][j]\n        cost += min_d\n        c.add(min_i)\n        c.add(min_j)\n        unc.remove(min_i)\n        unc.remove(min_j)\n        \n        mins = dict()\n        for i in unc:\n            mins[i] = min(mapper[i][min_i], mapper[i][min_j])\n        \n        while unc:\n            min_i = None\n            min_d = math.inf\n            for i in unc:\n                if mins[i] < min_d:\n                    min_i = i\n                    min_d = mins[i]\n                # for j in c:\n                    # if mapper[i][j] < min_d:\n                    #     min_i = i\n                    #     min_d = mapper[i][j]\n            cost += min_d\n            c.add(min_i)\n            unc.remove(min_i)\n            \n            for i in unc:\n                mins[i] = min(mins[i], mapper[i][min_i])\n            \n        return cost\n", "import bisect\n\nclass Union:\n    \n    def __init__(self, n):\n        self.parents = [-1 for _ in range(n)]\n        self.ranks = [0 for _ in range(n)]\n        self.n = n\n    \n    def join(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if self.ranks[i] > self.ranks[j]:\n            self.parents[j] = i\n        elif self.ranks[j] > self.ranks[i]:\n            self.parents[i] = j\n        else:\n            self.parents[j] = i\n            self.ranks[i] += 1\n    \n    def find(self, i):\n        i_ori = i\n        while self.parents[i] != -1:\n            i = self.parents[i]\n        if i != i_ori:\n            self.parents[i_ori] = i\n        return i\n\nfrom collections import defaultdict\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def calc_distance(p1, p2):\n            x1, y1 = p1\n            x2, y2 = p2\n            return abs(x1 - x2) + abs(y1 - y2)\n        \n        def find_best_node(min_dists, mst_set):\n            min_dist = float('inf')\n            for i, dist in enumerate(min_dists):\n                if i not in mst_set and dist < min_dist:\n                    best_node = i\n                    min_dist = dist\n            return best_node, min_dist\n        \n        def update_min_dists(node, min_dists, graph):\n            for i, dist in graph[node]:\n                min_dists[i] = min(min_dists[i], dist)            \n        \n        \n        n = len(points)\n        if n <= 1:\n            return 0\n        \n        graph = defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                p1, p2 = points[i], points[j]\n                dist = calc_distance(p1, p2)\n                graph[i].append((j, dist))\n                graph[j].append((i, dist))\n                \n        min_dists = [float('inf') for _ in range(n)]\n        mst_set = {0}\n        for i, dist in graph[0]:\n            min_dists[i] = min(min_dists[i], dist)\n        \n        total_dist = 0\n        for _ in range(n-1):\n            best_node, min_dist = find_best_node(min_dists, mst_set)\n            mst_set.add(best_node)\n            update_min_dists(best_node, min_dists, graph)\n            total_dist += min_dist\n        \n        return total_dist\n            \n            \n            \n        \n        \n        \n        \n            \n        \n        \n", "class Union:\n    def __init__(self, n):\n        self.components = n\n        self.parent = [i for i in range(n)]\n    \n    def find(self, i):\n        if(i != self.parent[i]):\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def _union(self, i, j):\n        x = self.find(i)\n        y = self.find(j)\n        if(x != y):\n            self.parent[x] = y\n            self.components -= 1;\n            return True\n        return False\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        graph = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) \n                graph.append([i, j, d])\n        \n\n        # sort by distance\n        graph = sorted(graph, key=lambda x: x[2])\n        \n        k = len(graph)\n        if k == 0: \n            return 0\n        elif k == 1:\n            return graph[0][2]\n\n        # MST via Kruskal\n        x = Union(k)\n        result = 0\n        for i in range(k):\n            if x._union(graph[i][0], graph[i][1]):\n                result += graph[i][2]\n            if x.components == 1:\n                return result\n        return result", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        heap, total_cost = [], 0\n        for u in range(N-1):\n            for v in range(u+1, N):\n                heappush(heap, [dist(points[u], points[v]), u, v])\n        while heap:\n            cost, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                N -= 1\n                total_cost += cost\n                if N == 0:\n                    break\n        return total_cost\n\n    \n    \n    \n    \n    \n    \n    \n    \nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        dist = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        heap = []\n        for i in range(N-1):\n            for j in range(i+1, N):\n                heappush(heap, (dist(points[i], points[j]), i, j))\n        res = 0\n        while heap:\n            d, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                res += d\n                N -= 1\n                if N == 0:\n                    break\n        return res\n            \n\n\nclass Solution:\n    def minCostConnectPoints(self, points):\n        manhattan = lambda a, b, x, y: abs(a-x)+abs(b-y)\n        points = sorted(points, key=lambda x: abs(x[0])+abs(x[1]))\n        connected = [points[0]]\n        cost = 0\n        points = list([[x[0], x[1], manhattan(connected[0][0], connected[0][1], x[0], x[1])] for x in points])\n        while points:\n            minidx = None\n            mindist = float('inf')\n            for i in range(len(points)):\n                x, y, dist = points[i]\n                if dist < mindist:\n                    mindist = dist\n                    minidx = i\n            mx, my, mdist = points.pop(minidx)\n            cost += mdist\n            for i in range(len(points)):\n                x, y, dist = points[i]\n                newdist = manhattan(x, y, mx, my)\n                if newdist < dist:\n                    points[i][2] = newdist\n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    #\u6ca1\u6709\u73b0\u6210\u7684edge list\uff0c\u60f3\u5230\u5f53\u904d\u5386\u5230\u67d0\u4e00\u4e2a\u70b9\u624d\u73b0\u7b97\u5b83\u4e0e\u5176\u4ed6\u70b9\u7684\u6743\u91cd\u503c\u5e76\u538b\u8fdbpqueue\uff0c\u6545\u8003\u8651\u9996\u9009Prim\u7b97\u6cd5\u800c\u4e0d\u662fKrusal\n    # N = len(points)\n    # dsu = list(range(N))\n    # def find(i):\n    #     if dsu[i] != i: dsu[i] = find(dsu[i])\n    #     return dsu[i]\n    # def union(i, j):\n    #     dsu[find(j)] = find(i)\n    \n        N = len(points)\n        seen = set()\n        cost = 0\n        cnt = 0\n        pq = [(0, 0)]\n        while pq:\n            c, i = heapq.heappop(pq)\n            if i in seen: continue\n            cost += c\n            cnt += 1\n            if cnt == N: return cost    #early termination. another advantage of using Prim over Krusal\n            seen.add(i)\n            pt_x, pt_y = points[i]\n            for j in range(N):\n                if j in seen: continue\n                nei_x, nei_y = points[j]\n                nei_c = abs(pt_x - nei_x) + abs(pt_y - nei_y)\n                heapq.heappush(pq, (nei_c, j))\n        return cost\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         res = 0\n#         N = len(points)\n#         visited = [[0] * N for _ in range(N)]\n#         if len(points) == 1: return 0\n#         DP = [[float('inf')] * N for _ in range(N)]\n        \n#         for i in range(N):\n#             # min_dist = float('inf')\n#             for j in range(i+1, N):\n#                 # print(i, i, j)\n#                 x, y = points[i], points[j]\n#                 curr_dist = DP[i][j] = DP[j][i] = abs(x[0] - y[0]) + abs(x[1] - y[1])\n#                 # if curr_dist < min_dist: \n#                 #     min_dist = curr_dist\n#             min_dist = min(DP[i])\n#             j = DP[i].index(min_dist) \n#             if not visited[i][j]:\n#                 res += min_dist\n#                 visited[i][j] = visited[j][i] = 1\n#                 DP[i][j] = DP[j][i] = float('inf')\n#             print(min_dist, DP)\n#             # res += min_dist\n#         return res\n                \n", "import sys\ninput=sys.stdin.readline\n\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        import math as mt\n        \n        re=lambda x,y:abs(x[0]-y[0])+abs(x[1]-y[1])\n        ar=[]\n        n=len(points)\n        par=[i for i in range(len(points)+1)]\n        def find(i):\n            while i!=par[i]:\n                i=par[i]\n            return par[i]\n            \n            \n        def join(i,j):\n            a=find(i)\n            b=find(j)\n            if a!=b:\n                par[a]=par[b]=min(a,b)\n        for i in range(n):\n            for j in range(i+1,n):\n                    temp=re(points[i],points[j])\n                    ar.append([temp,i,j])            \n        ans=0\n        cnt=0\n        ar.sort()\n        for a,b,c in ar:\n            if find(b)!=find(c):\n                join(b,c)\n                ans+=a\n                cnt+=1\n            if cnt==n-1:\n                break\n        return ans\n                \n            \n", "from collections import defaultdict\nimport heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        graph = defaultdict(list)\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                cost = manhattan(points[i], points[j])\n                graph[i].append((cost, j))\n                graph[j].append((cost, i))\n        \n        seen = [0] * (len(points)+1)\n        seen[0] = 1\n        q = graph[0]\n        minimumCost = 0\n        connectedNodes = 1\n        heapq.heapify(q)\n        while q:\n            cost, city = heapq.heappop(q)\n            if not seen[city]:\n                seen[city] = 1\n                minimumCost += cost\n                connectedNodes += 1\n                for connectingCost, neighbour in graph[city]:\n                    heapq.heappush(q, (connectingCost, neighbour))\n            if connectedNodes >= len(points):\n                break\n        return minimumCost\n", "from typing import List\nfrom heapq import heappop, heappush\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        visited = [False] * len(points) \n        cost = 0\n        pq = [(0, 0)] #(dist, node)\n        get_dist = lambda i, j : abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n        while pq:\n            dist, node = heappop(pq)\n            if visited[node]: continue\n            else: visited[node] = True\n            cost += dist\n            for adj in range(len(points)):\n                if not visited[adj]:\n                    heappush(pq, (get_dist(node, adj), adj))                \n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        cache = {}\n        for i, coord in enumerate(points):\n            cache[i] = coord\n        \n        # print(cache)\n\n            \n        def compute(p1, p2):\n            x1, y1 = cache[p1]\n            x2, y2 = cache[p2]\n            return abs(x1-x2) + abs(y1-y2)\n        \n        edges = []\n        for x, y in combinations(list(cache.items()), 2):\n            edges.append((compute(x[0], y[0]), x[0], y[0]))\n        \n        # print(edges)\n        \n        edges.sort(reverse=True)\n        \n        # print(edges)\n        \n        ans = 0\n        L = len(cache)\n        \n        parents = list(range(L))\n        \n        def union(x, y):\n            parents[find(x)] = find(y)\n        \n        def find(x):\n            if parents[x] != x:\n                parents[x] = find(parents[x])\n            \n            return parents[x]\n        \n        if L == 1:\n            return 0\n\n        while edges:\n            cost, n1, n2 = edges.pop()\n            \n            if find(n1) != find(n2):\n                union(n1, n2)\n                ans += cost\n            \n        return ans\n            \n            \n            \n\n#         for n, coord in cache.items():\n#             print(n, parents)\n\n#             closest_point = None\n#             closest_cost = float('inf')\n#             for i in range(L):\n#                 if n == i:\n#                     continue  # skip self\n\n#                 dist = compute(n, i)\n\n#                 # print('checking cost to', i, '...', dist)\n#                 if dist < closest_cost:\n#                     closest_cost = dist\n#                     closest_point = i\n\n#             if find(n) != find(closest_point):\n#                 union(n, closest_point)\n#                 cost += closest_cost\n#                 print('connecting', n, 'and', closest_point)\n        \n#         # print(parents)\n        \n#         return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        uf = UF(len(points))\n        n = len(points)\n        for i, ps in enumerate(points):\n            # for j in range(i+1,):\n            j = i+1\n            while j < n:\n                pt = points[j]\n                dist = abs(ps[0]-pt[0]) + abs(ps[1]-pt[1])\n                uf.addEdge(i, j, dist)\n                \n                j += 1\n                \n            # for j, pt in enumerate(points):\n            #     if ps != pt:\n            #         dist = abs(ps[0]-pt[0]) + abs(ps[1]-pt[1])\n            #         uf.addEdge(i, j, dist)\n                    \n        # print(uf.g) \n        # uf.exec()\n        return uf.exec()\n                    \n                    \nclass UF:\n    def __init__(self, n):\n        self.n = n\n        self.g = []\n        \n    def addEdge(self, s, t, cost):\n        self.g.append((s, t, cost))\n        \n    def find(self, x, parent):\n        if parent[x] == x:\n            return x\n        \n        return self.find(parent[x], parent)\n    \n    def union(self, x, y, parent, rank):\n        xroot, yroot = self.find(x, parent), self.find(y, parent)\n        if xroot != yroot:\n            if rank[xroot] > rank[yroot]:\n                parent[yroot] = xroot\n                return xroot\n            elif rank[xroot] < rank[yroot]:\n                parent[xroot] = yroot\n                return yroot\n            \n            else:\n                parent[yroot] = xroot\n                rank[xroot] += 1\n                return xroot\n                \n        else:\n            return xroot\n        \n    def exec(self):\n        parent = [_ for _ in range(self.n)]\n        rank = [0]*self.n\n        # print(self.find(1, parent))\n        # print(self.union(1,2, parent, rank))\n        # print(self.union(1,3, parent, rank))\n        # print(parent, rank)\n        # print(self.g)\n        self.g.sort(key = lambda edge: edge[2])\n        # print(self.g)\n        totalans = 0\n        for edge in self.g:\n            x = edge[0]\n            y = edge[1]\n            xroot = self.find(x, parent)\n            yroot = self.find(y, parent)\n            \n            if xroot != yroot:\n                self.union(x, y, parent, rank)\n                totalans += edge[2]\n                \n                \n        return(totalans)\n                    \n        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        costs = []\n        for i in range(len(points)):\n            xi, yi = points[i]\n            for j in range(i + 1, len(points)):\n                xj, yj = points[j]\n                costs.append([abs(xi - xj) + abs(yi - yj), i, j])\n        costs = sorted(costs)\n        \n        fathers = [t for t in range(len(points))]\n        def get_father(n) :\n            while not fathers[n] == fathers[fathers[n]]:\n                fathers[n] = fathers[fathers[n]]\n            return fathers[n]\n        \n        res = 0\n        for t in costs:\n            dist, i, j = t\n            if get_father(i) == get_father(j):\n                continue\n            fathers[get_father(j)] = get_father(i)\n            res += dist\n        return res", "class UnionFind:\n    def __init__(self,size):\n        self.size = size\n        self.components = size\n        self.parent = [0] * size\n        self.sizeArray = [0] * size\n        for i in range(size):\n            self.parent[i] = i\n            self.sizeArray[i] = 1\n        \n    def find(self,a):\n        while a != self.parent[a]:\n            a = self.parent[a]    \n        return a\n    \n    def unify(self, a, b):\n        p_a = self.find(a)\n        p_b = self.find(b)\n        if p_a == p_b:\n            return\n        if self.sizeArray[p_a] < self.sizeArray[p_b]:\n            self.sizeArray[p_b] += self.sizeArray[p_a]\n            self.parent[p_a] = p_b\n        else:\n            self.sizeArray[p_a] += self.sizeArray[p_b]\n            self.parent[p_b] = p_a\n        \n        self.components -= 1\n        \n    def num_components(self):\n        return self.components\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        n = len(points)\n        \n        _map = {}\n        k = 0\n        for p in points:\n            _map[(p[0], p[1])] = k\n            k += 1\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                u = points[i]\n                v = points[j]\n                dist = abs(u[0] - v[0]) + abs(u[1] - v[1])\n                edges.append((u, v, dist))\n                \n        edges.sort(key=lambda x:x[2])\n        #print(edges)\n        \n        ds = UnionFind(n)\n        \n        min_cost = 0\n        \n        for edge in edges:\n            u = _map[(edge[0][0], edge[0][1])]\n            v = _map[(edge[1][0], edge[1][1])]\n            d = edge[2]\n            \n            if ds.find(u) != ds.find(v):\n                ds.unify(u, v)\n                min_cost += d\n        \n        return min_cost", "class Solution:\n    def minCostConnectPoints(self, points):\n        helper = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        points = [[p, helper(p, points[0])] for p in points]\n        total_cost = 0\n        while points:\n            minI, minD = None, float('inf')\n            for i, (p, d) in enumerate(points):\n                if d < minD:\n                    minI, minD = i, d\n            p1, cost = points.pop(minI)\n            total_cost += cost\n            for i, (p2, _) in enumerate(points):\n                points[i][1] = min(points[i][1], helper(p1, p2))\n        return total_cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # minimum spanning tree?\n        n = len(points)\n        \n        cost = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                if i != j:\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    cost.append([abs(x1-x2) + abs(y1-y2), i, j])\n        cost.sort()\n    \n        parent = [i for i in range(n)]\n        rank = [1 for _ in range(n)]\n        def find(parent, i): \n            if parent[i] == i: \n                return i \n            return find(parent, parent[i]) \n\n        def union(parent, rank, x, y): \n            xroot = find(parent, x) \n            yroot = find(parent, y) \n\n            if rank[xroot] < rank[yroot]: \n                parent[xroot] = yroot \n            elif rank[xroot] > rank[yroot]: \n                parent[yroot] = xroot \n            else : \n                parent[yroot] = xroot \n                rank[xroot] += 1\n         \n        i, e = 0, 0\n        ans = 0\n        while e < n - 1:\n            w, u, v = cost[i]\n            i += 1\n            x = find(parent, u)\n            y = find(parent, v)\n            \n            if x != y:\n                e = e + 1\n                ans += w\n                union(parent, rank, x, y)\n    \n        return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((d, i, j))            \n        edges.sort()\n        parent={i : i for i in range(len(points))}\n        def find(x):\n            if not parent[x]== x:\n                parent[x] =find(parent[x])\n            return parent[x]    \n            \n            \n        def union(x,y):\n            par_x=find(x)\n            par_y=find(y)\n            if not par_x == par_y:\n                parent[par_x] =parent[par_y]\n                return True\n            return False\n        res = 0\n        for d, u, v in edges:\n            if union(u, v):\n                res += d\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points)==1:\n            return 0\n        d=collections.defaultdict(int)\n        dmn=collections.defaultdict(int)\n        n=len(points)\n        def distance(a,b):\n            return abs(a[0]-b[0])+abs(a[1]-b[1])\n        res=0\n        start=[0,float(\\\"inf\\\")]\n        for i in range(n):\n            dmn[i]=0\n            for j in range(i+1,n):\n                d[(i,j)]=distance(points[i],points[j])\n                if d[(i,j)]<start[1]:\n                    start[1]=d[(i,j)]\n                    start[0]=(i,j)\n        a=start[0][0]\n        b=start[0][1]\n        del dmn[a]\n        del dmn[b]\n        res+=start[1]\n        \n        for k in dmn.keys():\n            dmn[k]=min(d[(min(k,a),max(k,a))],d[(min(k,b),max(k,b))])\n        n-=2\n        \n        while n>0:\n            nxDistance=float(\\\"inf\\\")\n            for k in dmn.keys():\n                if dmn[k]<nxDistance:\n                    nx=k\n                    nxDistance=dmn[k]\n            res+=nxDistance\n            del dmn[nx]\n            for k in dmn.keys():\n                dmn[k]=min(dmn[k],d[(min(k,nx),max(k,nx))])\n            n-=1\n        return res\n                        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        import heapq\n        stack = []\n        ans = 0\n        used = set([0])\n        ps = set([0])\n        \n        while ps:\n            i = ps.pop()\n            for j in range(len(points)):\n                if i!=j and j not in used:\n                    dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                    heappush(stack, (dist, i, j))\n                    \n\n            while stack:\n                dist,x,y = heappop(stack)\n\n                if x in used and y not in used:\n                    ans += dist\n                    used.add(y)\n                    ps.add(y)\n                    break\n\n                elif y in used and x not in used:\n                    ans += dist\n                    used.add(x)\n                    ps.add(x)\n                    break\n\n        return ans\n\n", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, P: List[List[int]]) -> int:\n        p = P[0]\n        q = []\n        for x, y in P[1:]:\n            d = abs(x - p[0]) + abs(y - p[1])\n            heapq.heappush(q, (d, x, y))\n            \n        seen = {(p[0], p[1])}\n        res = 0\n        while q:\n            d, x, y = heapq.heappop(q)\n            if (x, y) in seen:\n                continue\n            res += d\n            seen.add((x, y))\n            for x1, y1 in P:\n                if (x1, y1) not in seen:\n                    d = abs(x1 - x) + abs(y1 - y)\n                    heapq.heappush(q, (d, x1, y1))\n                    \n        return res\n", "class UnionFind:\n    def __init__(self, n):\n        self.sets = {i : i for i in range(n)}\n        self.n_sets = n\n    def find(self, s):\n        if self.sets[s] != s:\n            self.sets[s] = self.find(self.sets[s])\n        return self.sets[s]\n    def union(self, s1, s2):\n        a, b = self.find(s1), self.find(s2)\n        if a == b:\n            return False\n        self.sets[a] = b\n        self.n_sets -= 1\n        return True\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        N = len(points)\n        for i in range(N):\n            for j in range(i + 1, N):\n                p1, p2 = points[i], points[j]\n                edges.append((abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]), i, j))\n        edges.sort()\n        uf = UnionFind(N)\n        res = 0\n        for w, u, v in edges:\n            if uf.union(u, v):\n                res += w\n            # if uf.n_sets == 1:\n            #     break\n        return res", "class DJSet:\n    def __init__ (self, n):\n        self.par = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n        \n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        if self.size[px] < self.size[py]:\n            px, py = py, px\n        self.par[py] = px\n        self.size[px] += self.size[py]\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        a = []\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                a.append((abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1]), i, j))\n        \n        a.sort()\n        \n        ans = 0\n        djSet = DJSet(n)\n        for (v, i, j) in a:\n            if djSet.union(i, j):\n                ans += v\n        \n        return ans\n        \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) <= 1: \n            return 0\n        res = 0\n        seen = set()\n        seen.add((points[0][0],points[0][1]))\n        minD = []\n        for i in range(len(points)):\n            if (points[i][0],points[i][1]) not in seen:\n                heapq.heappush(minD,(abs(points[i][0]-points[0][0]) + \n                                     abs(points[i][1]-points[0][1]),\n                                     [points[i][0],points[i][1]]\n                                    )\n                              )\n        while len(seen) < len(points):\n            while minD:\n                curMinD = heapq.heappop(minD)\n                if (curMinD[1][0],curMinD[1][1]) not in seen:\n                    break\n            \n            res += curMinD[0]\n            seen.add((curMinD[1][0],curMinD[1][1]))\n            for i in range(len(points)):\n                if (points[i][0],points[i][1]) not in seen:\n                    heapq.heappush(minD,(abs(points[i][0]-curMinD[1][0]) + \n                                         abs(points[i][1]-curMinD[1][1]),\n                                         [points[i][0],points[i][1]]\n                                        )\n                                   )\n                \n        \n        \n        \n        return res\n                            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        edges = []\n        parent = [x for x in range(N)]\n\n        def ufind(x):\n            if parent[x] != x:\n                parent[x] = ufind(parent[x])\n            return parent[x]\n        \n        def uunion(x, y):\n            ux = ufind(x)\n            uy = ufind(y)\n            \n            parent[ux] = uy\n        \n        def dist(a, b):\n            return abs(points[a][0] - points[b][0]) + abs(points[a][1] - points[b][1])\n        \n        for i in range(N):\n            for j in range(i + 1, N):\n                edges.append((dist(i,j), i, j))\n\n        edges.sort()\n\n        total = 0\n        for cost, x, y in edges:\n            if ufind(x) != ufind(y):\n                uunion(x, y)\n                total += cost\n        return total", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    #\u6ca1\u6709\u73b0\u6210\u7684edge list\uff0c\u60f3\u5230\u5f53\u904d\u5386\u5230\u67d0\u4e00\u4e2a\u70b9\u624d\u73b0\u7b97\u5b83\u4e0e\u5176\u4ed6\u70b9\u7684\u6743\u91cd\u503c\u5e76\u538b\u8fdbpqueue\uff0c\u6545\u8003\u8651\u9996\u9009Prim\u7b97\u6cd5\u800c\u4e0d\u662fKrusal\n    # N = len(points)\n    # dsu = list(range(N))\n    # def find(i):\n    #     if dsu[i] != i: dsu[i] = find(dsu[i])\n    #     return dsu[i]\n    # def union(i, j):\n    #     dsu[find(j)] = find(i)\n    \n        N = len(points)\n        seen = set()\n        cost = 0\n        cnt = 0\n        pq = [(0, 0)]\n        while pq:\n            c, i = heapq.heappop(pq)\n            if i in seen: continue\n            cost += c\n            cnt += 1\n            if cnt == N: return cost\n            seen.add(i)\n            pt_x, pt_y = points[i]\n            for j in range(N):\n                if j in seen: continue\n                nei_x, nei_y = points[j]\n                nei_c = abs(pt_x - nei_x) + abs(pt_y - nei_y)\n                heapq.heappush(pq, (nei_c, j))\n        return cost\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         res = 0\n#         N = len(points)\n#         visited = [[0] * N for _ in range(N)]\n#         if len(points) == 1: return 0\n#         DP = [[float('inf')] * N for _ in range(N)]\n        \n#         for i in range(N):\n#             # min_dist = float('inf')\n#             for j in range(i+1, N):\n#                 # print(i, i, j)\n#                 x, y = points[i], points[j]\n#                 curr_dist = DP[i][j] = DP[j][i] = abs(x[0] - y[0]) + abs(x[1] - y[1])\n#                 # if curr_dist < min_dist: \n#                 #     min_dist = curr_dist\n#             min_dist = min(DP[i])\n#             j = DP[i].index(min_dist) \n#             if not visited[i][j]:\n#                 res += min_dist\n#                 visited[i][j] = visited[j][i] = 1\n#                 DP[i][j] = DP[j][i] = float('inf')\n#             print(min_dist, DP)\n#             # res += min_dist\n#         return res\n                \n", "import math\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = set()\n        for i in range(n):\n            p = points[i]\n            for j in range(n):\n                if i!=j:\n                    w = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                    e = (min(i,j),max(i,j),w)\n                    edges.add(e)\n        edges = sorted(edges, key = lambda x: x[2])\n        tree_id = [0]*n\n        for i in range(n):\n            tree_id[i] = i\n        cost = 0\n        for i in edges:\n            v1 = i[0]\n            v2 = i[1]\n            w = i[2]\n            if tree_id[v1] != tree_id[v2]:\n                cost += w\n                old_tree = tree_id[v1]\n                new_tree = tree_id[v2]\n                for j in range(n):\n                    if tree_id[j] == old_tree:\n                        tree_id[j] = new_tree\n        return cost\n            \n        \n        \n        \n                    \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n\n        edges = []\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                u, v = points[i]\n                p, q = points[j]\n                w = abs(u - p) + abs(v - q)\n                edges.append([w, i, j])\n\n        path = [u for u in range(n)]\n\n        def find(u: int) -> int:\n            if path[u] != u:\n                path[u] = find(path[u])\n            return path[u]\n\n        def union(u: int, v: int) -> bool:\n            i, j = find(u), find(v)\n            if i == j: return False\n            if j > i:\n                i, j = j, i\n            path[j] = i\n            return True\n\n        costs = 0\n        edges.sort()\n        for w, u, v in edges:\n            if find(u) != find(v):\n                costs += w\n                union(u, v)\n        return costs\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        mst = set()\n        mst.add(0)\n        md = 0\n        pq = []\n        for i in range(n):\n            if i not in mst:\n                distance = abs(points[0][0] - points[i][0]) + abs(points[0][1] - points[i][1])\n                heapq.heappush(pq, (distance, 0, i))\n        \n        while pq:\n            distance, a, b = heapq.heappop(pq)\n            if b not in mst:\n                mst.add(b)\n                md += distance\n                for i in range(n):\n                    if i not in mst:\n                        distance = abs(points[b][0] - points[i][0]) + abs(points[b][1] - points[i][1])\n                        heapq.heappush(pq, (distance, b, i))\n        \n        return md", "class DSU:\n    def __init__(self,N):\n        self.sz = [1]*N\n        self.par = list(range(N))\n        \n    def find(self,v):\n        if self.par[v] != v:\n            self.par[v] = self.find(self.par[v])\n        return self.par[v]\n\n    def union(self,u,v):\n        px = self.find(u)\n        py = self.find(v)\n        if px == py:\n            return False\n        if self.sz[px] < self.sz[py]:\n            px,py = py,px\n        self.par[py] = px\n        self.sz[px] += self.sz[py]\n        return True\n    \n    def size(self,x):\n        return self.sz[self.find(x)]\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        edges = []\n        dsu = DSU(N)\n        for i in range(N):\n            for j in range(i+1,N):\n                d = abs(points[i][0] - points[j][0])\n                d += abs(points[i][1] - points[j][1])\n                edges.append([i,j,d])\n        edges.sort(key = lambda key :key[2])\n        ans = 0\n        for u,v,d in edges:\n            if dsu.union(u,v):\n                ans += d\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph=[]\n\n        def getDistance(p1,p2):\n            return abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n        \n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                graph.append((i,j,getDistance(points[i],points[j])))\n            \n        \n        graph.sort(key = lambda x: x[2])\n        \n        rank=[1]*len(points)\n        parent=list(range(len(points)))\n        \n        def getParent(parent, n):\n            if parent[n]==n:\n                return n\n            value=getParent(parent,parent[n])\n            parent[n]=value\n            return value\n        \n        def union(parent,rank,n1,n2):\n            if rank[n1]>=rank[n2]:\n                parent[n2]=n1\n                rank[n1]+=rank[n2]\n            else:\n                parent[n1]=n2\n                rank[n2]+=rank[n1]\n                \n        min_cost=0\n        \n        for edge in graph:\n            \n            u,v,cost=edge\n            \n            paru=getParent(parent,u)\n            parv=getParent(parent,v)\n            \n            if parv!=paru:\n                min_cost+=cost\n                union(parent,rank,paru,parv)\n        return min_cost\n            \n            \n", "from queue import PriorityQueue\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        graph = [[-1] * n for _ in range(n)]\n        for u in range(n):\n            for v in range(n):\n                graph[u][v] = abs(points[u][0]-points[v][0]) + abs(points[u][1]-points[v][1])\n        \n        res = 0\n        dists = [float(\\\"inf\\\")] * n\n        parents = [-1] * n\n        mst = set()\n        pq = PriorityQueue()\n        dists[0] = 0\n        pq.put([0, 0])\n        while len(mst) < n:\n            dist, u = pq.get()\n            if u not in mst:\n                res += dist\n                mst.add(u)\n            for v in range(n):\n                if dists[v] > graph[u][v]:\n                    dists[v] = graph[u][v]\n                    parents[v] = u\n                    pq.put([dists[v], v])\n        return res\n        \n        ", "class UF:\n  def __init__(self, n):\n    self.parent = {i:i for i in range(n)}\n  \n  def find(self, a):\n    if a != self.parent[a]:\n      self.parent[a] = self.find(self.parent[a])\n    return self.parent[a]\n  \n  def union(self, a, b):\n    r_a = self.find(a)\n    r_b = self.find(b)\n    if r_a == r_b:\n      return False\n    self.parent[r_a] = r_b\n    return True\n  \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        n = len(points)\n        for i in range(n):\n          for j in range(i):\n            dis = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n            edges.append((dis, i, j))\n        edges.sort()\n        cost = 0\n        uf = UF(n)\n        for dis, i, j in edges:\n          if uf.union(i,j):\n            cost += dis\n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def get_dist(p1, p2):\n            x1, y1 = p1\n            x2, y2 = p2\n            return abs(x1 - x2) + abs(y1 - y2)\n\n        N = len(points)\n        res = 0\n        minheap = [(0, 0)]\n        seen = set()\n        while minheap:\n            dist, p = heapq.heappop(minheap)\n            if p in seen:\n                continue\n            res += dist\n            seen.add(p)\n            for i in range(N):\n                if i not in seen:\n                    heapq.heappush(minheap, (get_dist(points[p], points[i]), i))\n        return res", "\nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        n = len(points)\n        dist = lambda p0, p1: abs(p1[0] - p0[0]) + abs(p1[1] - p0[1])\n        q = [(0, 0)]\n        nodes = set(range(len(points)))\n        res = 0\n        while q:\n            d, u = heappop(q)\n            if u not in nodes:\n                continue\n            nodes.remove(u)\n            res = res + d\n            if len(nodes) == 0:\n                return res\n            for v in nodes:\n                w = dist(points[u], points[v])\n                heappush(q, (w, v))", "class DSU: \n    def __init__(self, n): \n        self.p = list(range(n))\n        self.r = [0] * n\n    def find(self, i): \n        if self.p[i] != i:\n            self.p[i] = self.find(self.p[i])\n        return self.p[i]\n    def union(self, i, j): \n        pi, pj = self.find(i), self.find(j)\n        if pi != pj: \n            if self.r[pi] >= self.r[pj]: \n                self.p[pj] = pi\n                self.r[pi] += (self.r[pi] == self.r[pj])\n            else: \n                self.p[pi] = pj\n            return True\n        return False\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # try minimum spanning treee\n        \n        to_visit = set(range(1, len(points)))\n        pq = [(abs(points[0][0] - points[x][0]) + abs(points[0][1] - points[x][1]), x) for x in range(1, len(points))]\n        heapq.heapify(pq)\n        ans = 0\n        while pq:\n            cost, to = heapq.heappop(pq)\n            if to in to_visit:\n                to_visit.remove(to)\n                ans += cost\n                for nei in to_visit:\n                    x, y = points[nei]\n                    heapq.heappush(pq, (abs(x-points[to][0]) + abs(y-points[to][1]), nei))\n\n        return ans\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges, ans = [], 0\n        for i in range(len(points)):\n            for j in range(i+1, len(points)): \n                edges.append((abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j))\n                \n        edges.sort()\n        uf = DSU(len(points))\n        for cost, i, j in edges: \n            if uf.find(i) != uf.find(j): \n                uf.union(i, j)\n                ans += cost\n        return ans\n        \n                \n        \n            \n            \n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n=len(points)\n        uf=list(range(n))\n        def find(x):\n            if uf[x]!=x:\n                uf[x]=find(uf[x])\n            return uf[x]\n        def union(x,y):\n            uf[find(x)]=find(y)\n        costs=[]\n        for i in range(n-1):\n            for j in range(i+1,n):\n                x1,y1=points[i]\n                x2,y2=points[j]\n                cost=abs(x1-x2)+abs(y1-y2)\n                costs.append([cost,i,j])\n        costs.sort()\n        res=0\n        for cost,i,j in costs:\n            if find(i)!=find(j):\n                union(i,j)\n                res+=cost\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        diss = [[0] * n for _ in range(len(points))]\n        res = 0\n        \n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                length = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                diss[i][j] = diss[j][i] = length\n        \n        disinfo = []\n        for info in diss:\n            tmp = []\n            for i, l in enumerate(info):\n                tmp.append((l, i))\n            tmp.sort(reverse=True)\n            disinfo.append(tmp)\n        \n        not_linked = set(range(1, len(points)))\n        min_dis = diss[0].copy()\n        min_dis[0] = math.inf\n        \n        while not_linked:\n            nxt_dis = min(min_dis)\n            res += nxt_dis\n            nxt = min_dis.index(nxt_dis)\n            not_linked.remove(nxt)\n            min_dis[nxt] = math.inf\n\n            for i in range(len(points)):\n                if min_dis[i] < math.inf:\n                    min_dis[i] = min(diss[nxt][i], min_dis[i])\n                    \n        return res\n                \n            \n", "# mst\n# sort edge->union find\n# choose min that is not connected\ndef distance(u,v):\n    return abs(u[0]-v[0])+abs(u[1]-v[1])\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        distances = []\n        n = len(points)\n        mini = 0\n        parent = [i for i in range(n)]\n        for i in range(n):\n            for j in range(i+1,n):\n                u,v = points[i], points[j]\n                dis = distance(u,v)\n                distances.append((dis,i,j))\n        distances.sort() # distance, u, v\n        \n        def find(i):\n            while i!=parent[i]:\n                parent[i] = parent[parent[i]]\n                i = parent[i]\n            return i\n        \n        def union(i,j):\n            a,b = find(i),find(j)\n            if a==b:\n                return False\n            else:\n                parent[a] = b\n                return True\n            \n        for cost,i,j in distances:\n            if union(i,j):\n                mini+=cost\n            else:\n                mini+=0\n            \n        return mini\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def dist(e1, e2):\n            return abs(e1[0]-e2[0])+abs(e1[1]-e2[1])\n        \n        def find(x):\n            while x in uf:\n                # path compress\n                while uf[x] in uf:\n                    uf[x] = uf[uf[x]]\n                x = uf[x]\n            return x\n        \n        def union(x,y):\n            px,py = find(x), find(y)\n            if px==py: return False\n            uf[px] = py\n            return True\n        \n        n = len(points)\n        res = 0\n        uf = {}\n        edges = []\n        for i in range(n):\n            for j in range(i+1,n):\n                edges.append([dist(points[i],points[j]),i,j])\n                \n        edges.sort()\n        for cost,x,y in edges:\n            if union(x,y):\n                res += cost\n                \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        uf = UF(len(points))\n        n = len(points)\n        for i, ps in enumerate(points):\n            j = i+1\n            while j < n:\n                pt = points[j]\n                dist = abs(ps[0]-pt[0]) + abs(ps[1]-pt[1])\n                uf.addEdge(i, j, dist)\n                j += 1\n                \n        return uf.KruskalMST()\n                    \n                    \nclass UF:\n    def __init__(self, n):\n        self.n = n\n        self.g = []\n        \n    def addEdge(self, s, t, cost):\n        self.g.append((s, t, cost))\n        \n    def find(self, x, parent):\n        if parent[x] == x:\n            return x\n        \n        return self.find(parent[x], parent)\n    \n    def union(self, x, y, parent, rank):\n        xroot, yroot = self.find(x, parent), self.find(y, parent)\n        if xroot != yroot:\n            if rank[xroot] > rank[yroot]:\n                parent[yroot] = xroot\n                return xroot\n            elif rank[xroot] < rank[yroot]:\n                parent[xroot] = yroot\n                return yroot\n            \n            else:\n                parent[yroot] = xroot\n                rank[xroot] += 1\n                return xroot\n                \n        else:\n            return xroot\n        \n    def KruskalMST(self):\n        parent = [_ for _ in range(self.n)]\n        rank = [0]*self.n\n        # print(self.find(1, parent))\n        # print(self.union(1,2, parent, rank))\n        # print(self.union(1,3, parent, rank))\n        # print(parent, rank)\n        # print(self.g)\n        self.g.sort(key = lambda edge: edge[2])\n        # print(self.g)\n        totalans = 0\n        for edge in self.g:\n            x = edge[0]\n            y = edge[1]\n            xroot = self.find(x, parent)\n            yroot = self.find(y, parent)\n            \n            if xroot != yroot:\n                self.union(x, y, parent, rank)\n                totalans += edge[2]\n                \n                \n        return(totalans)\n                    \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        return self.minCost(points)\n    \n    \n    def minCost(self, points):\n        \\\"\\\"\\\"\n        \n        mst approach\n        \n        \\\"\\\"\\\"\n        n=len(points)\n        mst = {0}\n        nodes = {idx:cod for idx, cod in enumerate(points)}\n        dist = lambda x,y: abs(x[0]-y[0])+abs(x[1]-y[1])\n        edges =[]\n        for u in range(n): # outdegree of u -- outdegree*heappush time\n            heapq.heappush(edges, (dist(nodes[0], nodes[u]), u))\n        \n        minCostConnect = 0\n        while edges:\n            far, v = heapq.heappop(edges)\n            if v in mst:\n                continue\n            minCostConnect+=far\n            mst.add(v)\n            for v_ in range(n):\n                if v_ not in mst:\n                    heapq.heappush(edges, (dist(nodes[v], nodes[v_]), v_))\n        return minCostConnect", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n==1:\n            return 0\n        vis = set()\n        points = list(map(tuple, points))\n        q = [(0, points[0])]\n        res = 0\n        def get_dist(pointa, pointb):\n            return abs(pointa[0]-pointb[0]) + abs(pointa[1]-pointb[1])\n        while q:\n            top, curr_pt = heappop(q)\n            if curr_pt in vis:\n                continue\n            vis.add(curr_pt)\n            res += top\n            for point in set(points) - vis:\n                heappush(q, (get_dist(curr_pt, point), point))\n        \n        return res", "\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ln=len(points)\n        if ln<=1:return 0\n        ans=0\n        par={}\n        def find(x):\n            if x not in par:return x\n            res=find(par[x])\n            par[x]=res\n            return res\n        def union(a,b):\n            n1=find(a)\n            n2=find(b)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n        arr=[]\n        for i in range(ln-1):\n            for j in range(i+1,ln):\n                n=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                arr.append((n,i,j))\n        arr.sort()\n        for x in arr:\n            i=x[1]\n            j=x[2]\n            n1=find(i)\n            n2=find(j)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n                ans+=x[0]\n        return ans ", "class Solution:\n    def _dist(self, a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        result = 0\n        comp = [points[0]]\n        h = []\n        \n        for i in range(1, len(points)):\n            heapq.heappush( h, [self._dist(points[0], points[i]), points[i]] )\n        \n        while h:\n            dist, p = heapq.heappop(h)\n            result += dist\n            \n            for i in range(len(h)):\n                h[i][0] = min( h[i][0], self._dist(p, h[i][1]) )\n            heapq.heapify(h)\n        return result", "from collections import deque, defaultdict\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) <= 1:\n            return 0\n        \n        def find(x):\n            if x != parent[x]:\n                parent[x] = find(parent[x])\n                return parent[x]\n            \n            return x\n                \n        n = len(points)\n                \n        parent = list(range(n))\n        \n        dists = []\n        \n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                mand = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                dists.append((mand, i, j))\n                \n        dists.sort(key=lambda item: item[0])\n        \n        res = 0\n        \n        for w, a, b in dists:\n            pa = find(a)\n            pb = find(b)\n            \n            if pa != pb:\n                res += w\n                parent[pa] = parent[pb]\n                    \n        return res", "def manhattan(coor1, coor2):\n        return abs(coor1[0] - coor2[0]) + abs(coor1[1] - coor2[1])\n\ndef find(C, u):\n    if C[u] != u:\n        C[u] = find(C, C[u])\n    return C[u]\n\ndef naive_union(C, u, v):\n    u, v = find(C, u), find(C, v)\n    C[u] = v\n\nclass Solution(object):\n    def minCostConnectPoints(self, points):\n        \\\"\\\"\\\"\n        :type points: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        edges = [(manhattan(points[u], points[v]), u, v) for u in range(len(points) - 1) for v in range(u + 1, len(points))]\n        edges = sorted(edges)\n        C = {u: u for u in range(len(points))}\n        res = 0\n        for dis, u, v in edges:\n            if find(C, u) != find(C, v):\n                naive_union(C, u, v)\n                res += dis\n        return res", "class dsu:\n    def __init__(self, n):\n        self.ranks = [0] * n\n        self.ids = list(range(n))\n        pass\n    \n    def find(self, x):\n        if x != self.ids[x]:\n            self.ids[x] = self.find(self.ids[x])\n            pass\n        return self.ids[x]\n    \n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx == ry:\n            return False\n        elif self.ranks[rx] == self.ranks[ry]:\n            self.ids[ry] = rx\n            self.ranks[rx] += 1\n            pass\n        elif self.ranks[rx] < self.ranks[ry]:\n            self.ids[rx] = ry\n            pass\n        else:\n            self.ids[ry] = rx\n            pass\n        return True\n        \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        d = dsu(len(points))\n        lst = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1]-points[j][1])\n                t = (dist, i, j)\n                lst.append(t)\n                pass\n            pass\n        lst.sort()\n        cost = 0\n        for i in range(len(lst)):\n            success = d.union(lst[i][1], lst[i][2])\n            if success:\n                cost += lst[i][0]\n                pass\n            pass\n        return cost\n", "class Union:\n    def __init__(self,vertices):\n        self.parent = [i for i in range(vertices)]\n    \n    def find(self,i):\n        if self.parent[i]!=i:\n            return self.find(self.parent[i])\n        return self.parent[i]\n    \n    def union(self,i,j):\n        x=self.find(i)\n        y=self.find(j)\n        self.parent[x]=y\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n=len(points)\n        uf = Union(n)\n        def dist(x,y):\n            return abs(x[0]-y[0])+abs(x[1]-y[1])\n        costs=[]\n        for i in range(n):\n            for j in range(n):\n                costs.append([i,j,dist(points[i],points[j])])\n        costs=sorted(costs,key=lambda x:x[2])\n        ans=0\n        i=0\n        s=0\n        while s<n-1:\n            u,v,cost=costs[i]\n            i+=1\n            x=uf.find(u)\n            y=uf.find(v)\n            if x!=y:\n                uf.union(x,y)\n                s+=1\n                ans+=cost\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(x):\n            if x==parent[x]:\n                return x\n            return find(parent[x])\n        def union(p,q):\n            x=find(p)\n            y=find(q)\n            if rank[x]<rank[y]:\n                parent[x]=y\n            elif rank[y]<rank[x]:\n                parent[y]=x\n            else:\n                parent[y]=x\n                rank[x]+=1\n        n=len(points)\n        graph=[]\n        parent={}\n        rank={}\n        for i in range(n):\n            for j in range(i+1,n):\n                w=abs(points[j][1]-points[i][1])+abs(points[j][0]-points[i][0])\n                graph.append([i,j,w])\n        edges=sorted(graph,key=lambda k:k[2])\n        for i in range(n):\n            parent[i]=i\n            rank[i]=0\n        ans=0\n        #print(edges,parent,rank)\n        for x,y,w in edges:\n            if find(x)!=find(y):\n                #print(x,y,w)\n                ans+=w\n                union(x,y)\n        return ans \n                \n", "class Solution:\n    def find(self, parent, i): \n        if parent[i] == i: \n            return i \n        return self.find(parent, parent[i]) \n\n    def union(self, parent, rank, x, y): \n        xroot = self.find(parent, x) \n        yroot = self.find(parent, y) \n        if rank[xroot] < rank[yroot]: \n            parent[xroot] = yroot \n        elif rank[xroot] > rank[yroot]: \n            parent[yroot] = xroot \n        else : \n            parent[yroot] = xroot \n            rank[xroot] += 1\n\n    def KruskalMST(self, V, graph): \n        wts = 0\n        i = 0 \n        e=0\n        graph = sorted(graph,key=lambda item: item[2]) \n        parent, rank = [], [] \n\n        for node in range(V): \n            parent.append(node) \n            rank.append(0) \n\n        while e < V -1 : \n            u,v,w = graph[i] \n            i = i + 1\n            x = self.find(parent, u) \n            y = self.find(parent ,v) \n\n            if x != y: \n                e+=1\n                wts += w\n                self.union(parent, rank, x, y)\\t\\t\\t \n        return wts\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        v = len(points)\n        edges = []\n        for e1, i in enumerate(points):\n            for e2, j in enumerate(points):\n                if e1!=e2:\n                    edges.append([e1, e2, (abs(i[0]-j[0])+abs(i[1]-j[1]))])\n        return (self.KruskalMST(v, edges))\n\n\n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n      \n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans", "class UFDS:\n    def __init__(self, n):\n        self.p = list(range(n))\n    \n    def find(self, k):\n        if self.p[k] == k: return k\n        self.p[k] = self.find(self.p[k])\n        return self.p[k]\n    \n    def issame(self, i, j):\n        return self.find(i) == self.find(j)\n    \n    def union(self, i, j):\n        pi, pj = self.find(i), self.find(j)\n        if pi == pj: return\n        if pi < pj:\n            self.p[pj] = pi\n        else:\n            self.p[pi] = pj\n    \n\nclass Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        \n        def dist(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        \n        n = len(A)\n        \n        dists = []\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                dists.append((dist(A[i], A[j]), (i, j)))\n        \n        dists.sort()\n        ufds = UFDS(n)\n        \n        total = 0\n        for d, (i, j) in dists:\n            if not ufds.issame(i, j):\n                total += d\n                ufds.union(i, j)\n        \n        \n        return total\n        \n        \n", "class Solution:\n    \n    class UnionFinder:\n        def __init__(self, n):\n            self.parents = list(range(n))\n            self.ranks = [0] * n\n        \n        def find(self, x):\n            if self.parents[x] != x:\n                self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n        \n        def join(self, x, y):\n            p1 = self.find(x)\n            p2 = self.find(y)\n            \n            if p1 == p2:\n                return False\n            \n            r1 = self.ranks[p1]\n            r2 = self.ranks[p2]\n            \n            if r1 < r2:\n                self.parents[p1] = p2\n            elif r2 < r1:\n                self.parents[p2] = p1\n            else:\n                self.parents[p1] = p2\n                self.ranks[p2] += 1\n            return True\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = list()\n        cnt = 0\n        \n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                heapq.heappush(heap, (abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j))\n                \n        union_finder = Solution.UnionFinder(len(points))\n        ans = 0\n        while heap:\n            d, i, j = heapq.heappop(heap)\n            if union_finder.join(i, j):\n                ans += d\n                cnt += 1\n                if cnt == len(points) - 1:\n                    break\n        return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def hamin(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        # dist_list = []\n        # for i in range(len(points)):\n        #     for j in range(i+1, len(points)):\n        #         dist_list.append([hamin(points[i], points[j]), i, j])\n        # dist_list = sorted(dist_list, key=lambda x:(x[0]))\n        # group_set_list = [set()]\n        # answer = 0\n        # for dis, x, y in dist_list:\n        #     if x not in group_set_list[0] or y not in group_set_list[0]:\n        #         answer += dis\n        #         group_set_list.append(set([x, y]))\n        #     new_group_set_list = [group_set_list[0]]\n        #     for i in range(1, len(group_set_list)):\n        #         if new_group_set_list[0] & group_set_list[i]:\n        #             new_group_set_list[0] |= group_set_list[i]\n        #         else:\n        #             new_group_set_list.append(group_set_list[i])\n        #     group_set_list = new_group_set_list\n        #     if len(group_set_list[0]) == len(points):\n        #         break\n        # return answer\n        dist_list = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dist_list.append([hamin(points[i], points[j]), i, j])\n        dist_list = sorted(dist_list, key=lambda x:(x[0]))\n        #print(dist_list)\n        group_set = set()\n        group_set.add(0)\n        answer = 0\n        while(True):\n            i = 0\n            while(i < len(dist_list)):\n                [dis, x, y] = dist_list[i]\n                if x in group_set and y in group_set:\n                    dist_list.pop(i)\n                    continue\n                if x in group_set:\n                    group_set.add(y)\n                    answer += dis\n                    break\n                if y in group_set:\n                    group_set.add(x)\n                    answer += dis\n                    break\n                i += 1\n            if len(group_set) == len(points):\n                break\n        return answer", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N=len(points)\n        edges=[]\n        res=0\n        for i in range(N):\n            for j in range(i+1, N):\n                distance=abs(points[i][0]-points[j][0])\n                distance +=abs(points[i][1]-points[j][1])\n                edges.append((distance, i, j))\n        edges.sort()\n        unionfind=UnionFind(N)\n        for edge in edges:\n            dis, i, j=edge\n            if unionfind.union(i, j):\n                res +=dis\n        return res\n        \n\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent=list(range(n))\n        self.size=[1]*n\n    def find(self, x):\n        if self.parent[x]!=x:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        rx,ry =self.find(x), self.find(y)\n        if rx==ry: return False\n        if self.size[rx]<self.size[y]:\n            rx, ry=ry, rx\n            \n        self.parent[ry]=rx\n        self.size[rx] +=self.size[ry]\n        return True\n        \n", "from typing import List\n\n\nclass DSU:\n    def __init__(self, N: int):\n        self.par = list(range(N))\n        self.sz = [1] * N\n    \n    def find(self, x: int) -> int:\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self, x: int, y: int) -> bool:\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        \n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        \n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        return True\n    \n    def size(self, x: int) -> int:\n        return self.sz[self.find(x)]\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        Alex Wice's Solution\n\n        DSU\n        \\\"\\\"\\\"\n        N = len(points)\n        edges = []\n\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = abs(points[i][0] - points[j][0])\n                d += abs(points[i][1] - points[j][1])\n                edges.append((d, i, j))\n\n        edges.sort()\n        \n        dsu = DSU(N)\n        ans = 0\n        for d, u, v in edges:\n            if dsu.union(u, v):\n                ans += d\n        \n        return ans", "import queue \nclass Solution:\n    def minCostConnectPoints(self, points:List[List[int]]) -> int:\n        \\\"\\\"\\\"\n            @params:\n                points: List of list of coordinates (in cartesian coordinates)\n                where points[i] = [x_i, y_i]\n                Are points sorted? Not necessary \n                Can there be negative integers? Yes \n                Can there be duplicate points? No \n                Points length: 1 <= len(points) <= 1000\n        \n                Test case 1: [[0,0], [1,2], [3,0]]\n                expected_output = min((3+3), (3+4)) = 6\n                y\n                |     \n                |\n                |  1,2\n                |_  _  _ _ _ x \n                0,0    3,0\n                 \n                Test case 2: [[0,0], [1,1], [2,2]]\n                expected_output = min(4, 5) = 4 \n                  y\n                |     \n                |      2,2\n                |  1,1\n                |   _    _    _ _ _ x \n                0,0           \n        \\\"\\\"\\\"\n        def manhattan(x,y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        ans = 0\n        n = len(points)\n        seen = set()\n        minimum_distance = queue.PriorityQueue()\n        minimum_distance.put((0, (0,0)))\n        \n        while len(seen) < n:\n            w, (u,v) = minimum_distance.get()\n            if u in seen and v in seen:\n                continue \n            else:\n                ans += w \n                seen.add(v)\n                for j in range(n):\n                    if j not in seen and j != v:\n                        minimum_distance.put((manhattan(points[j], points[v]), (v,j)))\n        return ans \n        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dist = lambda x, y: abs(x[0] - y[0]) + abs(x[1] - y[1])\n        neighbors = collections.defaultdict(dict)\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                neighbors[i][j] = dist(points[i], points[j])\n                neighbors[j][i] = dist(points[i], points[j])\n        pq = [(0, 0)]\n        visited = set()\n        res = 0\n        while len(visited) < len(points):\n            d, u = heapq.heappop(pq)\n            if u in visited:\n                continue\n            print(d, u)\n            res += d\n            visited.add(u)\n            for v, d_ in neighbors[u].items():\n                heapq.heappush(pq, (d_, v))\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # O(n^2) edges, sort them, select from low to high, and add edge to tree\n        # if both sides are not in a same set.\n        out= 0\n        edges = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                edges += [(abs(points[i][0] - points[j][0])+ abs(points[i][1] - points[j][1]),i, j)]\n        \n        edges = sorted(edges, key = lambda x:x[0])\n        \n        p = [i for i in range(len(points))]\n        \n        def findparent(i):\n            if i != p[i]:\n                p[i] = findparent(p[i])\n            return p[i]\n        \n        for e in edges:\n            p1 = findparent(e[1])\n            p2 = findparent(e[2])\n            if p1 != p2:\n                p[p2] = p1\n                out += e[0]\n        \n        return out", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ok=[-1 for i in range(len(points))]\n        def union(x,y):\n            x1=find(x)\n            x2=find(y)\n            ok[x1]=x2\n        def find(x):\n            if(ok[x]==-1):\n                return x\n            else:\n                ok[x]=find(ok[x])\n                return ok[x]\n        d=[]\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                d.append([abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),i,j])\n        d.sort()\n        ans=0\n        for i in d:\n            x=find(i[1])\n            y=find(i[2])\n            if(x!=y):\n                union(i[1],i[2])\n                ans+=i[0] \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        visited = [False] * n\n        \n        # Prim Algo\n        dist = collections.defaultdict(list)\n        for i in range(n):\n            p1, p2 = points[i]\n            for j in range(n):\n                x, y = points[j]\n                dist[i].append((abs(p1-x) + abs(p2-y), j))\n        visited[0] = True\n        hp = dist[0]\n        heapq.heapify(hp)\n        res = count = 0\n        while hp:\n            cost, cur = heapq.heappop(hp)\n            if visited[cur]: continue\n            visited[cur] = True\n            res += cost\n            count += 1\n            if count == n - 1:\n                break\n            for d in dist[cur]:\n                heapq.heappush(hp, d)\n        return res\n        \n        # dist = [math.inf] * n\n        # cur = res = 0\n        # for i in range(n-1):\n        #     p1, p2 = points[cur]\n        #     visited[cur] = True\n        #     for j, (x, y) in enumerate(points):\n        #         if not visited[j]:\n        #             dist[j] = min(dist[j], abs(p1-x) + abs(p2-y))\n        #     cost, cur = min([(v, k) for k, v in enumerate(dist)])\n        #     dist[cur] = math.inf\n        #     res += cost\n        # return res\n", "\nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        n = len(points)\n        dist = lambda p0, p1: abs(p1[0] - p0[0]) + abs(p1[1] - p0[1])\n        q = [(0, 0)]\n        nodes = set(range(n))\n        res = 0\n        while q:\n            d, u = heappop(q)\n            if u not in nodes:\n                continue\n            nodes.remove(u)\n            res = res + d\n            if len(nodes) == 0:\n                return res\n            for v in nodes:\n                w = dist(points[u], points[v])\n                heappush(q, (w, v))", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) < 1:\n          return 0\n        def dist(point1, point2):\n          return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n        \n        heap = []\n        connected = set([0])\n        for i, point in enumerate(points):\n          if i == 0:\n            continue\n          heapq.heappush(\n            heap,\n            (\n              dist(point, points[0]),\n              i,\n              0,\n            )\n          )\n        res = 0\n        while len(connected) != len(points):\n          dis, p, f = heapq.heappop(heap)\n          if p not in connected:\n            res += dis\n            connected.add(p)\n            \n          for i, point in enumerate(points):\n            if i == p or i in connected:\n              continue\n            heapq.heappush(\n              heap,\n              (\n                dist(point, points[p]),\n                i,\n                p,\n              )\n            )\n        return res", "class Solution:\n    def minCostConnectPoints(self, points:List[List[int]]) -> int:\n        \\\"\\\"\\\"\n            @params:\n                points: List of list of coordinates (in cartesian coordinates)\n                where points[i] = [x_i, y_i]\n                Are points sorted? Not necessary \n                Can there be negative integers? Yes \n                Can there be duplicate points? No \n                Points length: 1 <= len(points) <= 1000\n        \n                Test case 1: [[0,0], [1,2], [3,0]]\n                expected_output = min((3+3), (3+4)) = 6\n                y\n                |     \n                |\n                |  1,2\n                |_  _  _ _ _ x \n                0,0    3,0\n                 \n                Test case 2: [[0,0], [1,1], [2,2]]\n                expected_output = min(4, 5) = 4 \n                  y\n                |     \n                |      2,2\n                |  1,1\n                |   _    _    _ _ _ x \n                0,0           \n        \\\"\\\"\\\"\n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        ans, n = 0, len(points)\n        seen = set()\n        import queue\n        q = queue.PriorityQueue()\n        q.put((0, (0, 0)))\n        \n        while len(seen) < n:\n            # print(vertices, seen)\n            w, (u, v) = q.get()\n            if u in seen and v in seen: continue\n            ans += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    q.put((manhattan(points[j], points[v]), (v, j)))\n        return ans\n\n        ", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        \n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        \n        ans, n = 0, len(p)\n        seen = set()\n        import queue\n        q = queue.PriorityQueue()\n        q.put((0, (0, 0)))\n        \n        while len(seen) < n:\n            # print(vertices, seen)\n            w, (u, v) = q.get()\n            if u in seen and v in seen: continue\n            ans += w\n            seen.add(v)\n            for j in range(n):\n                if j not in seen and j!=v:\n                    q.put((manhattan(p[j], p[v]), (v, j)))\n        return ans\n                \n            \n", "class UF:\n  def __init__(self, n):\n    self.parent = {i:i for i in range(n)}\n\n  def find(self, x):\n    if self.parent[x] != x:\n      self.parent[x] = self.find(self.parent[x])\n    return self.parent[x]\n  \n  def union(self, a, b):\n    r_a = self.find(a)\n    r_b = self.find(b)\n    if r_a == r_b:\n      return False\n    \n    self.parent[r_a] = r_b\n    return True\n    \n  \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n      n = len(points)\n      edges = []\n      for i in range(n):\n        for j in range(i):\n          dis = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n          edges.append((dis, i, j))\n      edges.sort()\n      count = 0\n      uf = UF(n)\n      \n      for dis, u, v in edges:\n        if uf.union(u, v):\n          count += dis\n      return count", "class DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n    \n    # return if parent is same, else update     \n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        self.parent[pa] = pb\n    \n    # returning the parent\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        # sort based on cost (i.e. distance)\n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        ds = DisjointSet(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u, v)\n                res += cost\n        \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        hq = []\n        in_mst = [False] * len(points)\n        \n        def d(i: int, j: int) -> int:\n            return abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n        \n        def add_to_hq(i: int):\n            for j in range(len(points)):\n                if i != j and not in_mst[j]:\n                    heapq.heappush(hq, (d(i, j), j))\n        \n        heapq.heappush(hq, (0, 0))\n        res = 0\n        while hq:\n            dist, i = heapq.heappop(hq)\n            if not in_mst[i]:\n                in_mst[i] = True\n                res += dist\n                add_to_hq(i)\n        \n        return res\n                \n", "from heapq import heappush, heappop\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        costs = sorted([(self.get_dist(points[i], points[j]), i, j) for i in range(n) for j in range(i)])\n        groups = list(range(n))\n        def find(node):\n            while node != groups[node]:\n                node = groups[node]\n            return node\n        \n        res = 0\n        for cost, u, v in costs:\n            root1, root2 = find(u), find(v)\n            if root1 != root2:\n                res += cost\n                groups[max(root1, root2)] = min(root1, root2)\n                \n        return res\n        \n    \n    def get_dist(self, pt1, pt2):\n        return abs(pt1[0] - pt2[0]) + abs(pt1[1] - pt2[1])", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        dis = collections.defaultdict(list)\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                d = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                dis[i].append((d,j))\n                dis[j].append((d,i))\n                \n        ans, seen, heap = 0, set(), [(0,0)]\n        \n        while len(seen)<len(points):\n            d, j = heapq.heappop(heap)\n            if j not in seen:\n                seen.add(j)\n                ans += d\n                for d, i in dis[j]:\n                    heapq.heappush(heap, (d,i))\n        return ans\n", "from heapq import heappop, heappush\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = []\n        self.parent = {}\n        self.count = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heappush(heap, (dist, i, j))\n                \n        result = 0\n        while heap:\n            cur_dist, point1, point2 = heappop(heap)\n            point1_parent = self.find(point1)\n            point2_parent = self.find(point2)\n            if point1_parent == point2_parent:\n                continue\n            self.parent[point1_parent] = point2_parent\n            self.count[point2_parent] += self.count[point1_parent]\n            result += cur_dist\n            if self.count[point2_parent] == len(points):\n                return result\n        return 0\n    \n    def find(self, x):\n        if x not in self.parent:\n            self.parent[x] = x\n            self.count[x] = 1\n            return self.parent[x]\n        if x == self.parent[x]:\n            return self.parent[x]\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        graph = collections.defaultdict(list)\n        mh = lambda p1, p2: abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n        for i in range(n):\n            for j in range(i+1, n):\n                d = mh(points[i], points[j])\n                graph[i].append((d, j))\n                graph[j].append((d, i))\n        cnt = 1\n        ans = 0\n        visited = [False]*n\n        heap = graph[0]\n        visited[0]=True\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j] = True\n                ans+=d\n                cnt+=1\n                for nei in graph[j]: heapq.heappush(heap, nei)\n            if cnt>=n: break\n        return ans", "class DisjointSet:\n    def __init__(self, n):\n        self.parent = list(range(n))\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        parx, pary = self.find(x), self.find(y)\n        if parx == pary:\n            return False\n        self.parent[pary] = parx\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(a, b):\n            return abs(a[0]-b[0]) + abs(a[1]-b[1])\n        # build a list of edges in the form of (w, u, v)\n        edges = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                edges.append([distance(points[i], points[j]), i, j])\n        edges.sort()\n        \n        dset = DisjointSet(len(points))\n        res = numOfEdges = idx = 0\n        while numOfEdges < len(points) - 1:\n            w, u, v = edges[idx]\n            if dset.union(u, v):\n                res += w\n                numOfEdges += 1\n            idx += 1\n            \n        return res\n", "# alright, whatever, time to solve it again in Python3 \\\\U0001f40d  whoo!\n\n# ok silly mistake, but that's A ok :)\n\n# alright! cool, well time for C++ then i'm done upsolving this one, it was fun :)\n\nclass Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        N = len(A)\n        P = [i for i in range(N)]  # parent representatives of disjoint sets\n        E = []\n        for u in range(N):\n            x1, y1 = A[u]\n            for v in range(u + 1, N):\n                x2, y2 = A[v]\n                w = abs(x1 - x2) + abs(y1 - y2)\n                E.append([ u, v, w ])\n        E.sort(key = lambda edge: edge[2])\n        def find(x):\n            P[x] = P[x] if P[x] == x else find(P[x])\n            return P[x]\n        def union(a, b):\n            a = find(a)\n            b = find(b)\n            if a == b:\n                return False\n            P[a] = b   # arbitrary choice\n            return True\n        return sum([w for u, v, w in E if union(u, v)])\n", "import queue \nclass Solution:\n    def minCostConnectPoints(self, points:List[List[int]]) -> int:\n        \\\"\\\"\\\"\n            @params:\n                points: List of list of coordinates (in cartesian coordinates)\n                where points[i] = [x_i, y_i]\n                Are points sorted? Not necessary \n                Can there be negative integers? Yes \n                Can there be duplicate points? No \n                Points length: 1 <= len(points) <= 1000\n        \n                Test case 1: [[0,0], [1,2], [3,0]]\n                expected_output = min((3+3), (3+4)) = 6\n                y\n                |     \n                |\n                |  1,2\n                |_  _  _ _ _ x \n                0,0    3,0\n                 \n                Test case 2: [[0,0], [1,1], [2,2]]\n                expected_output = min(4, 5) = 4 \n                  y\n                |     \n                |      2,2\n                |  1,1\n                |   _    _    _ _ _ x \n                0,0           \n        \\\"\\\"\\\"\n        def manhattan(x, y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        ans, n = 0, len(points)\n        seen = set()\n        minimum_distance = queue.PriorityQueue()\n        minimum_distance.put((0, (0, 0)))\n        \n        while len(seen) < n:\n            w, (u,v) = minimum_distance.get()\n            if u in seen and v in seen:\n                continue \n            else:\n                ans += w \n                seen.add(v)\n                for j in range(n):\n                    if j not in seen and j != v:\n                        minimum_distance.put((manhattan(points[j], points[v]), (v, j)))\n        return ans\n\n        ", "class Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                \n        n = len(a)\n        if n <= 1: return 0\n        d = dict()\n        q = []\n        for i in range(n-1):\n            xi, yi = a[i]\n            for j in range(n):\n                xj, yj = a[j]\n                val = abs(xi-xj) + abs(yi-yj)\n                d[(i, j)] = val\n                d[(j, i)] = val                \n                q.append((val, i, j))\n        \n        \n        def union(u, v):\n            UF[find(v)] = UF[find(u)]\n        def find(u):\n            if u != UF[u]:\n                UF[u] = find(UF[u])\n            return UF[u]                \n        \n        UF = {i: i for i in range(n)}\n        ans = set()\n        heapify(q)        \n        cur = set([q[0][1], q[0][2]])\n        cand = []\n        for x in cur:\n            for y in range(n):\n                if y in cur: continue\n                cand.append((d[(x, y)], x, y))\n        heapify(cand)\n        ans = q[0][0]\n        while len(cur) < n:\n            val, x, y = heappop(cand)\n            if find(x) != find(y): \n                cur.add(y)\n                union(x, y)\n                ans += val\n                for z in range(n):\n                    if z in cur: continue\n                    heappush(cand, (d[(y, z)], y, z))\n        return ans\n                \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        \n        \n        \n        n = len(points)\n        d = collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                d[i].append((dist,i,j))\n                d[j].append((dist,j,i))\n        chosen = {0}\n        between = d[0].copy()\n        heapq.heapify(between)\n        res = 0\n        while len(chosen) < n:\n            dist, i, j = heapq.heappop(between)\n            if i in chosen and j in chosen:\n                continue\n            elif i in chosen and j not in chosen:\n                chosen.add(j)\n                res += abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                for jd,js,je in d[j]:\n                    heapq.heappush(between, (jd,js,je))\n                # dmin = float('inf')\n                # for jd,js,je in d[j]:\n                #     if not (js in chosen and je in chosen):\n                #         dmin = min(dmin, jd)\n                #         heapq.heappush(between, (jd,js,je))\n                # chosen.add(j)\n                # res += dmin\n                # res.append((i,j,dmin))\n            elif i not in chosen and j in chosen:\n                chosen.add(i)\n                res += abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                for iid,iis,iie in d[i]:\n                    heapq.heappush(between, ((iid,iis,iie)))\n                # dmin = float('inf')\n                # for iid,iis,iie in d[i]:\n                #     if not (iis in chosen and iie in chosen):\n                #         dmin = min(dmin, iid)\n                #         heapq.heappush(between, (iid,iis,iie))\n                # chosen.add(i)\n                # res += dmin\n                # res.append((i,j,dmin))\n        # print(res)\n        # return sum(d for a,b,d in res)\n        return res\n        \n        \n        \n        \n", "import heapq\n\nclass Solution:\n  def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    n = len(points)\n    mst_nodes = [0 for i in range(n)]\n    mst_nodes_cnt = 0\n    #mst_edges = set() # (int,int)\n    h = []  # heap of edges connected to MST (distance, source, dest)\n    man_dist = lambda i,j: abs( points[i][0] - points[j][0] ) + abs( points[i][1] - points[j][1] )\n    \n    mst_nodes[0] = 1\n    for p in range(1,n):\n      h.append( (man_dist(0,p),0,p) )\n    heapq.heapify(h)\n\n    tot_dist = 0\n    while h:\n      dist, src_node, dst_node = heapq.heappop(h)\n      if mst_nodes[dst_node]:\n        continue\n      tot_dist += dist\n      mst_nodes[dst_node] = 1\n      mst_nodes_cnt += 1\n      if mst_nodes_cnt == n:\n        break\n      for next_dst in range(n):\n        if mst_nodes[next_dst]==0:\n          heapq.heappush( h, ((man_dist(dst_node,next_dst),dst_node,next_dst)) )\n\n    return tot_dist", "from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        n = len(points)\n        c = defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = manhattan(points[i], points[j])\n                c[i].append((dist, j))\n                c[j].append((dist, i))\n        \n        pq = c[0]\n        heapq.heapify(pq)\n        visited = [False] * n\n        visited[0] = True\n        cnt = 1\n        res = 0\n        while pq:\n            d, j = heapq.heappop(pq)\n            if not visited[j]:\n                cnt += 1\n                res += d\n                visited[j] = True\n                for record in c[j]:\n                    heapq.heappush(pq, record)\n                if cnt >= n:\n                    break\n                    \n        return res\n                \n            \n                \n        \n        \n\n", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        n=len(p)\n\n\n        def find(x):\n            if dp[x]!=x:\n                dp[x]=find(dp[x])\n            return dp[x]\n\n        def uni(x,y):\n            x,y=find(x),find(y)\n            if x!=y:\n                dp[x]=find(y)\n                return False\n            else:    \n                return True\n\n        dp=list(range(n))    \n\n        pool=sorted((abs(p[i][0]-p[j][0])+abs(p[i][1]-p[j][1]),i,j) for i in range(n) for j in range(i+1,n))\n\n\n        res=0\n\n        for dis,u,v in pool:\n            if not uni(u,v):\n                res+=dis\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ln=len(points)\n        if ln<=1:return 0\n        ans=0\n        par={}\n        def find(x):\n            if x not in par:return x\n            res=find(par[x])\n            par[x]=res\n            return res\n        def union(a,b):\n            n1=find(a)\n            n2=find(b)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n        arr=[]\n        for i in range(ln):\n            for j in range(i+1,ln):\n                n=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                arr.append((n,i,j))\n        arr.sort()\n        for x in arr:\n            n1=find(x[1])\n            n2=find(x[2])\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n                ans+=x[0]\n        return ans    ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        connected = 1\n        result = 0\n        heapq.heapify(edges)\n        visited = set()\n        i = 0\n        \n        while connected < n:\n            connected += 1\n            visited.add(i)\n            \n            a = points[i]\n            for j in range(n):\n                b = points[j]\n                if j not in visited:\n                    heapq.heappush(edges, ((abs(a[0] - b[0]) + abs(a[1] - b[1]), j)))\n            \n            while edges[0][1] in visited:\n                heapq.heappop(edges)\n            \n            result += edges[0][0]\n            i = heapq.heappop(edges)[1]\n        \n        return result\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edge_costs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                p1, p2 = points[i], points[j]\n                cost = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n                edge_costs.append((cost, (i, j)))\n        \n        edge_costs.sort()\n        \n        total = 0\n        parent = list(range(n)) # init with parent[i] = i\n        \n        def find_parent(v):\n            if parent[v] == v:\n                return v\n            else:\n                parent[v] = find_parent(parent[v])\n                return parent[v]\n        \n        # def join(v1, v2):\n        #     a = find_parent(v1)\n        #     b = find_parent(v2)\n        #     if a != b:\n        #         parent[b] = a\n        \n        for cost, edge in edge_costs: # already sorted in increasing edge weight\n            v1, v2 = edge\n            v1_parent = find_parent(v1)\n            v2_parent = find_parent(v2)\n            if v1_parent != v2_parent:\n                # print(v1, v2, cost)\n                total += cost\n                parent[v2_parent] = v1_parent\n        \n        return total", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        n=len(p)\n\n\n        def find(x):\n            if dp[x]!=x:\n                dp[x]=find(dp[x])\n            return dp[x]\n\n        def uni(x,y):\n            x,y=find(x),find(y)\n            if x!=y:\n                dp[x]=find(y)\n                return False\n            else:    \n                return True\n\n        dp=list(range(n))    \n\n        pool=sorted((abs(p[i][0]-p[j][0])+abs(p[i][1]-p[j][1]),i,j) for i in range(n) for j in range(i+1,n))\n\n\n\n\n                \n        return sum(dis for dis,u,v in pool if not uni(u,v))", "class UF:\n    def __init__(self, n):\n        self.root = [i for i in range(n)]\n    \n    def find(self, a):\n        if self.root[a] != a:\n            self.root[a] = self.find(self.root[a])\n        return self.root[a]\n    \n    def unite(self, a, b):\n        self.root[self.find(a)] = self.find(b)\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges, res = [], 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append([abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j])\n        edges.sort()\n        uf = UF(n)\n        for w, s, t in edges:\n            if uf.find(s) != uf.find(t):\n                uf.unite(s, t)\n                res += w\n        return res", "class DSU:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.size = [1] * N\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        par_x, par_y = self.find(x), self.find(y)\n        \n        if par_x == par_y:\n            return False\n        \n        if self.size[par_x] < self.size[par_y]:\n            par_x, par_y = par_y, par_x\n        \n        \n        self.parent[par_y] = par_x\n        self.size[par_x] += self.size[par_y]\n        self.size[par_y] = self.size[par_x]\n        \n        \n        return True\n        \n        \n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ## Make edges\n        edges = []\n        N = len(points)\n        \n        if not points:\n            return -1\n        \n        for i in range(N):\n            for j in range(i+1, N):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                d = abs(x1 - x2) + abs(y1 - y2)\n                edges.append([i, j, d])\n        \n        # Construct MST using Kruskal and DSU\n        \n        UF = DSU(N)\n        \n        total_cost = 0\n        edges.sort(key = lambda x: x[2])\n        \n        for i, j, d in edges:\n            if UF.union(i, j):\n                total_cost += d\n        \n        \n        return total_cost\n        \n        \n        \n        \n        \n        \n        \n                \n                \n                \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        G = collections.defaultdict(list)\n        \n        for i in range(N):\n            for j in range(N):\n                if i == j: continue\n                cost_x = abs(points[i][0] - points[j][0])\n                cost_y = abs(points[i][1] - points[j][1])\n                \n                cost = cost_x + cost_y\n                \n                G[i].append((cost, j))\n                G[j].append((cost, i))\n                \n        PQ = []\n        SEEN = set()\n        \n        def add(u):\n            SEEN.add(u)\n            \n            for cost, v in G[u]:\n                if v in SEEN:\n                    continue\n                heapq.heappush(PQ, (cost, v))\n                \n        mst = 0\n        add(0)\n        \n        while PQ and len(SEEN) < N:\n            cost, u = heapq.heappop(PQ)\n            if u in SEEN:\n                continue\n            mst += cost\n            add(u)\n            \n        return mst", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def cost(i, j):\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        n = len(points)\n        dists = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dists.append((cost(i, j), i, j))\n        dists.sort()\n        uf = UnionFind(n)\n        ans = 0\n        for c, i, j in dists:\n            if uf.union(i, j):\n                ans += c\n        return ans\n        \nclass UnionFind:\n    def __init__(self, n):\n        self.id = [i for i in range(n)]\n        self.size = [1 for _ in range(n)]\n    \n    def find(self, i):\n        root = i\n        while root != self.id[root]:\n            root = self.id[root]\n        while root != i:\n            j = self.id[i]\n            self.id[i] = root\n            i = j\n        return root\n    \n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i == root_j:\n            return False\n        if self.size[root_i] < self.size[root_j]:\n            self.id[root_i] = root_j\n            self.size[root_j] += self.size[root_i]\n        else:\n            self.id[root_j] = root_i\n            self.size[root_i] += self.size[root_j]\n        return True", "class UnionFind:\n    def __init__(self):\n        self.parent={}\n        self.size={}\n    def makeset(self,point):\n        self.parent[point]=point\n        self.size[point]=1\n    def find(self,point):\n        if self.parent[point]==point:\n            return point\n        self.parent[point]=self.find(self.parent[point])\n        return self.parent[point]\n    def union(self,point1,point2):\n        point1=self.find(point1)\n        point2=self.find(point2)\n        if point1==point2:\n            return False,self.size[point1]\n        self.parent[point2]=point1\n        self.size[point1]+=self.size[point2]\n        return True,self.size[point1]\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        costmetrics=[]\n        unionfind=UnionFind()\n        for point in points:\n            unionfind.makeset(tuple(point))\n        # print(unionfind.parent,unionfind.size)\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                cost=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                costmetrics.append([cost,tuple(points[i]),tuple(points[j])])\n        costmetrics.sort(key=lambda item:item[0])\n        ans=0\n        for i in range(len(costmetrics)):\n            res,sz=unionfind.union(costmetrics[i][1],costmetrics[i][2])\n            if res:\n                ans+=costmetrics[i][0]\n            if sz==len(points):\n                break\n        return ans\n            \n        \n        \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dis = []\n        d = {}\n        u = {}\n        for i,x in enumerate(points):\n            d[i] = 0\n            u[i] = i\n            for y in range(i+1,len(points)):\n                z = points[y]\n                m = abs(x[0]-z[0]) + abs(x[1]-z[1])\n                dis.append([m,i,y])\n        \n        def merge(c1,c2):\n            if u[c1] > u[c2]:\n                c1,c2 = c2,c1\n            t = u[c2]\n            for k,v in u.items():\n                if v == t:\n                    u[k] = u[c1]\n        \n        dis = sorted(dis)\n        c = 0\n        result = 0\n        count=0\n        while count < len(points) - 1:\n            while 1:\n                c0,c1,c2 = dis[c]\n                if u[c1] != u[c2]:\n                    merge(c1,c2)\n                    d[c1] += 1\n                    d[c2] += 1\n                    count += 1\n                    result += c0\n                    c += 1\n                    break\n                c += 1\n        return result", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        n=len(p)\n        a=[i for i in range(n+1)]\n        rank=[0 for i in range(n+1)]\n        def find(i):\n            if i==a[i]:\n                return i\n            a[i]=find(a[i])\n            return a[i]\n        def union(x,y):\n            xs=find(x)\n            ys=find(y)\n            if xs!=ys:\n                if rank[ys]>rank[xs]:\n                    ys,xs=xs,ys\n                a[ys]=xs\n                rank[xs]+=1\n                return 1\n            return 0\n        edge=[]\n        for i in range(n):\n            for j in range(i+1,n):\n                dis=abs(p[i][0]-p[j][0])+abs(p[i][1]-p[j][1])\n                edge.append([dis,i,j])\n        ans=0\n        edge.sort()\n        for dis,i,j in edge:\n            if union(i,j):\n                ans+=dis\n        return ans        \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt + 1, ans + d\n                for record in c[j]:\n                    heapq.heappush(heap, record)\n            if cnt >= n:\n                break\n        return ans", "from heapq import heappush\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        visited = set()\n        minCost = 0\n        minEdges = []\n        # weight, idx \n        heappush(minEdges,(0,0))\n             \n        while(len(visited) < len(points)):  \n            \n            # pop to get the lowest weight edge possible\n            # visit it and add cost to min cost spanning tree\n            vertexDistance,vertexIdx = heappop(minEdges)\n            if vertexIdx in visited: continue\n            print(vertexIdx)\n            visited.add(vertexIdx)\n            minCost += vertexDistance\n            \n            # extract our currently visited x and y pos\n            vertexX = points[vertexIdx][0]\n            vertexY = points[vertexIdx][1]\n            \n            # for all nodes, if its not added to spanning tree already\n            # calculate the distance to it. push it to heapq.\n            for adjIdx, adjPos in enumerate(points):\n                if adjIdx not in visited:\n                    adjX = points[adjIdx][0]\n                    adjY = points[adjIdx][1]\n                    \n                    distance = abs(vertexX - adjX) + abs(vertexY - adjY)\n                    heappush(minEdges,(distance,adjIdx))\n                             \n        return minCost\n                    \n            \n            \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        connections = []\n        for i in range(N):\n            for j in range(i+1, N):\n                connections.append([i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])])\n        \n        if len(connections) < N - 1:\n            return -1\n        elif N == 1:\n            return 0\n        uf = {}\n        def find(x):\n            uf.setdefault(x, x)\n            if uf[x] != x:\n                uf[x] = find(uf[x])\n            return uf[x]\n        def union(x, y):\n            uf[find(x)] = find(y)\n        \n        res = 0\n        for start, end, cost in sorted(connections, key=lambda x : x[2]):\n            if find(start) != find(end):\n                res += cost\n                union(start, end)\n        if len({find(c) for c in uf}) == 1:\n            return res\n        return -1\n", "import math\n\nclass DSU:\n    def __init__(self, n):\n        self.n = n\n        self.parent = [i for i in range(n)]\n    \n    def find(self, x):\n        while self.parent[x] != x:\n            x_p = self.parent[x]\n            self.parent[x] = self.parent[x_p]  # path compression\n            x = self.parent[x]\n        return x\n    \n    def union(self, x, y):\n        x_p = self.find(x)\n        y_p = self.find(y)\n        if x_p != y_p:   # not in the same joint set\n            self.parent[x_p] = y_p    # parent of y is the new root\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        for i in range(len(points)):\n            for j in range(len(points)):\n                dist = self.distance(points[i], points[j])\n                edges.append((dist, i, j))\n        edges = sorted(edges, key=lambda x:x[0])\n        \n        ans = 0\n        n = len(points)\n        dsu = DSU(n)\n        i = 0\n        j = 0 # inter through the edges\n        while i < n-1:  # MST algo.\n            dist, a, b = edges[j]\n            a_p = dsu.find(a)\n            b_p = dsu.find(b)\n            if a_p != b_p:\n                dsu.union(a, b)\n                i += 1\n                ans += dist\n            j += 1\n        return ans\n                \n    def distance(self, p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])", "class Graph: \n  \n    def __init__(self,vertices): \n        self.V= vertices #No. of vertices \n        self.graph = [] # default dictionary  \n                                # to store graph \n    def addEdge(self,u,v,w): \n        self.graph.append([u,v,w]) \n  \n    def find(self, parent, i): \n        if parent[i] == i: \n            return i \n        return self.find(parent, parent[i]) \n  \n    def union(self, parent, rank, x, y): \n        xroot = self.find(parent, x) \n        yroot = self.find(parent, y) \n        if rank[xroot] < rank[yroot]: \n            parent[xroot] = yroot \n        elif rank[xroot] > rank[yroot]: \n            parent[yroot] = xroot \n        else : \n            parent[yroot] = xroot \n            rank[xroot] += 1\n            \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        result = 0 \n        i = 0\n        e = 0 \n        g = Graph(len(points))\n        for i in range(len(points)-1):\n            for j in range(i,len(points)):\n                a = tuple(points[i])\n                b = tuple(points[j])\n                g.addEdge(a,b, abs(a[0]-b[0]) + abs(a[1]-b[1]))\n        g.graph =  sorted(g.graph,key=lambda item: item[2]) \n       # print(g.graph,g.V)\n        parent = [0] * g.V \n        rank = [0] * g.V \n  \n        dic = {}\n        for i,p in enumerate(points):\n            dic[tuple(p)] = i\n\n        for i in range(g.V): \n            parent[i] = i\n        while e < g.V - 1 : \n            u,v,w =  g.graph[i] \n            i = i + 1\n            x = g.find(parent, dic[u]) \n            y = g.find(parent ,dic[v]) \n            if x != y: \n                e = e + 1     \n                result += w\n                g.union(parent, rank, x, y)             \n        return result\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(i):\n            while i!=root[i]:\n                root[i]=root[root[i]]\n                i=root[i]\n            return i\n        \n        res, n=0, len(points)\n        conn, root=[], [i for i in range(n)]\n        for i in range(n):\n            for j in range(i+1, n):\n                conn.append([i, j, abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])])     \n                    \n        conn.sort(key=lambda c: c[2])\n        for c in conn:\n            p1=find(c[0])\n            p2=find(c[1])\n            if p1!=p2:\n                res+=c[2]\n                root[p1]=p2\n            \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dis = lambda x,y,x1,y1: abs(x-x1) + abs(y-y1)\n        distances = []\n        for i, (x, y) in enumerate(points):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[j]\n                d = dis(x, y, x1, y1)\n                distances.append((d, i, j))\n        uf = UnionFind(len(points))\n        distances.sort()\n        ans = 0\n        for d, i, j in distances:\n            if uf.union(i, j):\n                ans += d\n        return ans\n        \nclass UnionFind:\n    def __init__(self, n):\n        self.component_count = n\n        self.parents = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.parents[x] != x:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\n    # return true if two are newly unioned, false if already unioned.\n    def union(self, x, y):\n        x0 = self.find(x)\n        y0 = self.find(y)\n        if x0 == y0:\n            return False\n        if self.size[x0] < self.size[y0]:\n            x0, y0 = y0, x0\n        self.parents[y0] = x0\n        self.size[x0] += self.size[y0]\n        self.component_count -= 1\n        return True", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ll = len(points)\n        if ll == 1:\n            return 0\n        distances = []\n        def get_distance(i, j):\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        \n        for i in range(ll):\n            for j in range(i + 1, ll):\n                distances.append((get_distance(i, j), i, j))\n        distances.sort()\n        size = [1] * ll\n        parents = list(range(ll))\n    \n        def ufind(x):\n            if parents[x] != x:\n                return ufind(parents[x])\n            return x\n        \n        def uunion(x, y):\n            ux = ufind(x)\n            uy = ufind(y)\n            if ux < uy:\n                parents[ux] = uy\n                size[uy] += ux\n            else:\n                parents[uy] = ux\n                size[ux] += uy\n            \n        \n        res = 0\n        for d, x, y in distances:\n            ux = ufind(x)\n            uy = ufind(y)\n            if ux != uy:\n                uunion(ux, uy)\n                res += d\n        return res\n                \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        parents = list(range(len(points)))\n        \n        def find(x):\n            if parents[x] != x:\n                parents[x] = find(parents[x])\n            return parents[x]\n        \n        def union(x, y):\n            px = find(x)\n            py = find(y)\n            if px != py:\n                parents[py] = px\n                return False\n            return True\n        \n        edges = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dist = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                edges.append((dist, i, j))\n        \n        edges.sort()\n        \n        ans = 0\n        \n        for w, x, y in edges:\n            if not union(x, y):\n                ans += w\n        return ans", "class DSU:\n    def __init__(self, n):\n        self.parents = list(range(n))\n    \n    def find(self, u):\n        orig = u\n        while u != self.parents[u]:\n            u = self.parents[u]\n        \n        self.parents[orig] = u\n        return u\n    \n    def union(self, u, v):\n        u,v = sorted([self.find(u),self.find(v)])\n        \n        if u!=v:\n            self.parents[v] = u\n            return True\n        return False\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        distances = {}\n        \n        def compute(p1,p2):\n            x1,y1 = p1\n            x2,y2 = p2\n            return abs(x1-x2)+abs(y1-y2)\n        \n        for i,p1 in enumerate(points):\n            for j in range(i+1,len(points)):\n                p2 = points[j]\n                \n                distances[(i,j)] = compute(p1,p2)\n        \n        dsu = DSU(len(points))\n        \n        res = 0\n        for (u,v),d in sorted(list(distances.items()), key=lambda x: x[1]):\n            if dsu.union(u,v):\n                res+=d\n        return res\n", "from collections import defaultdict\nimport heapq\nclass Solution:\n    def minCostConnectPoints(self, points) -> int:\n        edges = defaultdict(list)\n        n = len(points)\n        connected_pts = set([0])\n        pending_edges = []\n        for i in range(n):\n            for j in range(i+1,n):\n                w = abs(points[j][1] - points[i][1]) + abs(points[j][0] - points[i][0])\n                edges[i].append((w, j))\n                edges[j].append((w, i))\n        # print(edges)\n        for e in edges[0]:\n            heapq.heappush(pending_edges, (e[0], e[1]))\n            # pending_edges.append((e[0], e[1]))\n\n        res = 0\n        while len(connected_pts) < n:\n            # pending_edges.sort()\n            # print(pending_edges)\n            found_edge = False\n            while not found_edge:\n                e = heapq.heappop(pending_edges)\n                if e[1] in connected_pts:\n                    continue\n                found_edge = True\n                connected_pts.add(e[1])\n                res += e[0]\n                for next_edge in edges[e[1]]:\n                    if next_edge not in connected_pts:\n                        heapq.heappush(pending_edges, (next_edge[0], next_edge[1]))\n                        # pending_edges.append((next_edge[0], next_edge[1]))\n        return res\n", "from functools import cmp_to_key\n\ndef cmp(a,b):\n    return a[2]-b[2]\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        edges = []\n        points = [tuple(l) for l in points]\n        N = len(points)\n        if(N==1):\n            return 0\n        \n        for i in range(N):\n            x,y = points[i]\n            for j in range(i+1,N):\n                x1,y1 = points[j]\n                edges.append((i,j,abs(x-x1)+abs(y-y1)))\n        edges.sort(key=cmp_to_key(cmp))\n        parent = {i:i for i in points}\n        rank = {i:0 for i in points}\n        val = 0\n        ct = 0\n        for i,j,v in edges:\n            \n            l = self.union(rank,parent,points[i],points[j])\n            if(l!=0):\n                ct += 1\n                val += v\n            if(ct==N-1):\n                return val\n    \n    def find(self,parent,node):\n        if(parent[node]==node):\n            return node\n        parent[node] = self.find(parent,parent[node])\n        return parent[node]\n    def union(self,rank,parent,node1,node2):\n        \n        x = self.find(parent,node1)\n        y = self.find(parent,node2)\n        if(x==y):\n            return 0\n        if(rank[x]>rank[y]):\n            parent[y] = x\n        elif(rank[x]<rank[y]):\n            parent[x] = y\n        else:\n            rank[x] += 1\n            parent[y] = x\n        return 1\n", "import heapq\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1]*n\n        self.maxRank = 1\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n            self.maxRank = max(self.maxRank, self.rank[pa])\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa]\n            self.maxRank = max(self.maxRank, self.rank[pb])\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(u, v):\n            dx = abs(u[0] - v[0])\n            dy = abs(u[1] - v[1])\n            return dx+dy\n        \n        n = len(points)\n        if n == 1:\n            return 0\n        if n == 2:\n            return distance(points[0], points[1])\n        \n        # # Method 1: Prim's Alg with Heap\n        # d = {i:[] for i in range(n)}\n        # for i in range(n):\n        #     for j in range(i+1, n):\n        #         dist = distance(points[i], points[j])\n        #         d[i].append((dist, j))\n        #         d[j].append((dist, i))\n        # cost = 0\n        # connected = 1\n        # check = [True] + [False]*(n-1)\n        # heap = d[0]\n        # heapq.heapify(heap)\n        # while connected < n:\n        #     (dist, p) = heapq.heappop(heap)\n        #     if not check[p]:\n        #         cost += dist\n        #         connected += 1\n        #         check[p] = True\n        #         for pair in d[p]:\n        #             heapq.heappush(heap, pair)\n        # return cost\n        \n        # # Nethod 2: Another Implementation of Prim's Alg\n        # cost = 0\n        # curr = 0 # select a random point as the starting point\n        # dist = [float('inf')] * n\n        # explored = set()\n        # explored.add(0)\n        # cnt = 1\n        # while cnt < n:\n        #     u = points[curr]\n        #     for j, v in enumerate(points):\n        #         if j in explored: \n        #             continue\n        #         else:\n        #             dist[j] = min(dist[j], distance(u,v))\n        #     min_d, curr = min((d, j) for j, d in enumerate(dist)) \n        #     explored.add(curr)\n        #     cnt += 1\n        #     dist[curr] = float('inf')\n        #     cost += min_d\n        # return cost\n        \n        # Method 3: Kruskal's Alg with Disjoint Set\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = distance(points[i], points[j])\n                edges.append((dist, i, j))\n        heapq.heapify(edges)\n        cost = 0\n        ds = DisjointSet(n)\n        while ds.maxRank < n:\n            dist, u, v = heapq.heappop(edges)\n            if ds.find(u) != ds.find(v):\n                cost += dist\n                ds.union(u, v)\n        return cost\n            \n        \n        \n        \n\n", "from collections import defaultdict\nfrom heapq import heappush, heappop\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        G = defaultdict(dict)\n        for i, (xi, yi) in enumerate(points):\n            for j, (xj, yj) in enumerate(points[i + 1:], i + 1):\n                d = abs(xi - xj) + abs(yi - yj)\n                G[i][j] = G[j][i] = d\n        seen, pq, ans = {0}, [], 0\n        for nb, d in G[0].items():\n            heappush(pq, (d, nb))\n        while len(seen) < len(G):\n            while pq:\n                cost, next_node = heappop(pq)\n                if next_node in seen: continue\n                seen.add(next_node)\n                ans += cost\n                for nb, d in G[next_node].items():\n                    if nb in seen: continue\n                    heappush(pq, (d, nb))\n        return ans", "class DSU:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.size = [1] * N\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        par_x, par_y = self.find(x), self.find(y)\n        \n        if par_x == par_y:\n            return False\n        \n        if self.size[par_x] < self.size[par_y]:\n            par_x, par_y = par_y, par_x\n        \n        \n        self.parent[par_y] = par_x\n        self.size[par_x] += self.size[par_y]\n        self.size[par_y] = self.size[par_x]\n        \n        \n        return True\n        \n        \n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ## Make edges\n        edges = []\n        N = len(points)\n        \n        if not points:\n            return -1\n        \n        for i in range(N):\n            for j in range(i+1, N):\n                if points[i] == points[j]:\n                    continue\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                d = abs(x1 - x2) + abs(y1 - y2)\n                edges.append([i, j, d])\n        \n        # Construct MST using Kruskal and DSU\n        \n        UF = DSU(N)\n        \n        total_cost = 0\n        edges.sort(key = lambda x: x[2])\n        \n        for i, j, d in edges:\n            if UF.union(i, j):\n                total_cost += d\n        \n        \n        return total_cost\n        \n        \n        \n        \n        \n        \n        \n                \n                \n                \n                \n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n\n    def union(self, i, j):\n        x = self.find(i)\n        y = self.find(j)\n        if x == y:\n            return\n        if self.rank[x] > self.rank[y]:\n            self.parent[y] = x\n            self.rank[x] += self.rank[y]\n        else:\n            self.parent[x] = y\n            self.rank[y] += self.rank[x]\n\n    def find(self, i):\n        if self.parent[i] == i:\n            return self.parent[i]\n        return self.find(self.parent[i])\n\n\n\n\nclass Solution:\n    def minCostConnectPoints(self, points) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n\n        # sort based on cost (i.e. distance)\n        edges.sort()\n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        uf = UnionFind(n)\n        for cost, u, v in edges:\n            if uf.find(u) != uf.find(v):\n                uf.union(u, v)\n                res += cost\n        return res\n\n", "class uf(object):\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n    def union(self, x, y):\n        p1, p2 = self.find(x), self.find(y)\n        if self.rank[p1] == self.rank[p2]:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n        elif self.rank[p1] > self.rank[p2]:\n            self.parent[p2] = p1\n        else:\n            self.parent[p1] = p2\n        return\n    \n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        return self.find(self.parent[x])\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        union_find = uf(len(points))\n        ans = 0\n        n = len(points)\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append((abs(points[j][0] - points[i][0]) + abs(points[j][1] - points[i][1]), i, j))\n                \n        edges = sorted(edges)\n        for w, u, v in edges:\n            if union_find.find(u) != union_find.find(v):\n                union_find.union(u, v)\n                ans += w\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dist = []\n        for i, p1 in enumerate(points):\n            for j, p2 in enumerate(points):\n                if i!=j:\n                    d = abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n                    heapq.heappush(dist, (d,i,j))\n        g = defaultdict(set)\n        checked = set()\n        def connected(a,b):\n            if b in g[a]:\n                return True\n            if a in checked:\n                return False\n            checked.add(a)\n            for p in g[a]:\n                if connected(p,b):\n                    return True\n            return False\n        conn = 0\n        d = 0\n        while conn < len(points)-1:\n            p = heapq.heappop(dist)\n            checked = set()\n            if not connected(p[1],p[2]):\n                g[p[2]].add(p[1])\n                g[p[1]].add(p[2])\n                d += p[0]\n                conn += 1\n        return d", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        all_edges = []\n        for point1 in points:\n            for point2 in points:\n                if point1 != point2:\n                    all_edges.append((abs(point1[0] - point2[0]) + abs(point1[1] - point2[1]), tuple(point1),tuple(point2)))\n                    \n        all_edges.sort(key=lambda x:(x[0]))\n        \n        parent = { tuple(point):tuple(point) for point in points }\n        rank = {tuple(point):1 for point in points}\n        children = {tuple(point):1 for point in points}\n        def find(point1):\n            if parent[point1] != point1:\n                parent[point1] = find(parent[point1])\n            return parent[point1]\n        \n        def union(point1, point2):\n            parent1 = find(point1)\n            parent2 = find(point2)\n            if rank[parent1] > rank[parent2]:\n                parent[parent2] = parent1\n                rank[parent1] += 1\n                children[parent1] +=children[parent2]\n            else:\n                parent[parent1] = parent2\n                rank[parent2] += 1\n                children[parent2] +=children[parent1]\n            return\n        cost = 0\n        count = 0\n        for edge in all_edges:\n            if count == len(points)-1:\n                break\n            if find(edge[1]) != find(edge[2]):\n                union(edge[1],edge[2])\n                cost +=edge[0]\n                count +=1\n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n=len(points)\n        \n        connections = []\n        self.father={}\n        self.size=n\n        for i in range(n):\n            self.father[(points[i][0],points[i][1])] = (points[i][0],points[i][1])\n            for j in range(i+1,n):\n                dist = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                p1 = (points[i][0],points[i][1])\n                p2 = (points[j][0],points[j][1])\n                connections.append((p1,p2,dist))\n        # print(self.father)\n        connections = sorted(connections,key = lambda x: x[2])\n        # print(connections)\n\n        \n        res=0\n        def union(a,b):\n            root_a = find(a)\n            root_b = find(b)\n            if root_a!=root_b:\n                self.father[root_a] = root_b\n                self.size-=1\n                return True\n            else:\n                return False\n        \n        def find(node):\n            path = []\n            while node!=self.father[node]:\n                path.append(node)\n                node = self.father[node]\n            \n            for child in path:\n                self.father[child] = node\n            return node\n        \n        for c in connections:\n            if union(c[0],c[1]):\n                res+=c[2]\n                if self.size==0:\n                    return res\n        return res\n        \n        \n        \n        \n        \n        \n", "class DSU:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n        self.count = n\n    \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self,x,y):\n        px = self.find(x)\n        py = self.find(y)\n        if px==py:\n            return False\n        self.count-=1\n        if self.rank[x]>self.rank[y]:\n            self.parent[py]=px\n            self.rank[px]+=self.rank[py]\n        else:\n            self.parent[px]=py\n            self.rank[py]+=self.rank[px]\n        return True\n                \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(edges,(dist,i,j))\n        res = 0\n        ds = DSU(n)\n        while edges and ds.count!=1:\n            cost,u,v = heapq.heappop(edges)\n            if ds.union(u,v):\n                res += cost\n        return res", "class UnionFind:\n    def __init__(self):\n        self.roots = {}\n        self.depth = {}\n    \n    def root(self, node):\n        if node not in self.roots:\n            self.roots[node] = node\n            self.depth[node] = 1\n        path = []\n        while self.roots[node] != node:\n            path.append(node)\n            node = self.roots[node]\n        for elem in path:\n            self.roots[elem] = node\n        return node\n\n    def connect(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        if self.depth[x] > self.depth[y]:\n            x, y = y, x\n        if self.depth[x] == self.depth[y]:\n            new_depth = self.depth[y] + 1\n        else:\n            new_depth = self.depth[y]\n        del self.depth[x]\n        self.roots[x] = y\n        self.depth[y] = new_depth\n        \n\nclass Solution:\n        \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        min_span_tree = UnionFind()\n        cost = 0\n        edges = []\n        for i in range(1, len(points)):\n            for j in range(i):\n                edge_cost = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append([edge_cost, i, j])\n        edges.sort()\n        to_connect = len(points) - 1\n        for edge_cost, i, j in edges:\n            if not to_connect:\n                break\n            if min_span_tree.root(i) != min_span_tree.root(j):\n                cost += edge_cost\n                min_span_tree.connect(i, j)\n                to_connect -= 1\n        return cost", "class Graph:\n    def __init__(self, v =0):\n        self.v = v\n        self.edge = []\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0]*n\n        \n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n    \n    def union(self, u, v):\n        uroot, vroot = self.find(u), self.find(v)\n        if uroot == vroot:\n            return False\n        elif self.rank[uroot] < self.rank[vroot]:\n            self.parent[uroot] = vroot\n            self.rank[vroot] += 1\n        else:\n            self.parent[vroot] = uroot\n            self.rank[uroot] += 1\n        return True\n    \nclass Solution:\n    def distance(self, point1: List[int], point2: List[int]):\n        return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n        \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if not points or len(points)<2:\n            return 0\n        n = len(points)\n        graph = Graph(n)\n        tot = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                d = self.distance(points[i], points[j])\n                graph.edge.append([i,j,d])\n\n        graph.edge = sorted(graph.edge, key=lambda item: item[2])\n        \n        uf = UnionFind(n)\n        for u,v,w in graph.edge:\n            if uf.union(u,v):\n                tot += w\n        return tot\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        cost_map = {}\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                cost = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                cost_map[(i, j)] = cost\n        \n        graph = []\n        for key, value in cost_map.items():\n            graph.append([key[0], key[1], value])        \n        \n        def find(city):\n            if parent[city] != city:\n                parent[city] = find(parent[city])\n            return parent[city]\n        \n        def union(city1, city2):\n            root1 = find(city1)\n            root2 = find(city2)\n            if root1 == root2:\n                return False # Cycle\n            parent[root2] = root1 # Join roots\n            return True\n            \n        #Keep track of disjoint sets. Initially each city is its own set.\n        parent = {city:city for city in range(0, len(points))}\n        #Sort connections so we are always picking minimum cost edge.\n        graph.sort(key=lambda x:x[2])\n        totalCost = 0\n        for city1, city2, cost in graph:\n            if union(city1, city2):\n                totalCost += cost\n        \n        # Check that all cities are connected\n        root = find(len(points)-1)\n        for i in range(0, len(points)):\n            if find(i) == root:\n                continue\n            else:\n                return -1\n        return totalCost", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        #dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        heap, total_cost = [], 0\n        for i1, p1 in enumerate(points):\n            for i2, p2 in enumerate(points[i1+1:], start = i1+1):\n                #heappush(heap, (dist(p1, p2), i1, i2))\n                heappush(heap, (abs(p1[0]-p2[0]) + abs(p1[1]-p2[1]), i1, i2))\n        while heap:\n            cost, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                N -= 1\n                total_cost += cost\n                if N == 0:\n                    break\n        return total_cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        MST - minimum spanning tree\n        \n        Greedy solution\n        1. random choose a start point\n        2. each time we add the closest point\n        \\\"\\\"\\\"\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans", "class UnionFind:\n\\t# uf = UnionFind(N)\n\\t# for i in range(N): uf.add(i)\n\\t# for x, y in pairs: uf.unite(x, y)\n\\t# ans = max([uf.size(i) for i in range(N)])\n\\tdef __init__(self, n):\n\\t\\tself.n = n\n\\t\\tself.sizes = [1]*n\n\\t\\tself.parents = list(range(n))\n\n\\tdef find(self, x):\n\\t\\twhile x != self.parents[x]:\n\\t\\t\\tself.parents[x] = self.parents[self.parents[x]]\n\\t\\t\\tx = self.parents[x]\n\\t\\treturn self.parents[x]\n\n\\tdef unite(self, x, y):\n\\t\\tx, y = self.find(x), self.find(y)\n\\t\\tif x == y:\n\\t\\t\\treturn\n\\t\\tif self.sizes[x] < self.sizes[y]:\n\\t\\t\\tx, y = y, x\n\\t\\tself.parents[y] = x\n\\t\\tself.sizes[x] += self.sizes[y]\n\\t\n\\tdef add(self, x):\n\\t\\tself.sizes[x] = 1\n\\t\\t\n\\tdef size(self, x):\n\\t\\treturn self.sizes[self.find(x)]\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dists = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                p1, p2 = points[i], points[j]\n                d = abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n                dists.append((d, i, j))\n        dists.sort()\n        uf = UnionFind(len(points))\n        ans = 0\n        for d, i, j in dists:\n            if uf.find(i) != uf.find(j):\n                #print(i, j, d)\n                uf.unite(i, j)\n                ans += d\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    \n        edges = []\n        nodes = set()\n        # set up edges with (weight, u, v)\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dis = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dis, i, j))\n                nodes.add(i)\n                nodes.add(j)\n        \n\n        # set up union find\n        class UnionFindSet:\n            def __init__(self, nodes):\n                self._parents = {}\n                self._ranks = {}\n                for n in nodes:\n                    self._parents[n] = n\n                    self._ranks[n] = 1\n\n            def find(self, u):\n                while u != self._parents[u]:\n                    self._parents[u] = self.find(self._parents[u])\n                    u = self._parents[u]\n                return u\n\n            def union(self, u, v):\n                pu, pv = self.find(u), self.find(v)\n                if pu == pv: return False\n\n                if self._ranks[pu] < self._ranks[pv]:\n                    self._parents[pu] = pv\n                elif self._ranks[pu] > self._ranks[pv]:\n                    self._parents[pv] = pu\n                else:        \n                    self._parents[pv] = pu\n                    self._ranks[pu] += 1\n\n                return True\n\n        uf = UnionFindSet(nodes)\n        \n        # Kruskal Algorithm\n        edges.sort()\n        cost = 0\n        for dis, u, v in edges:\n            pu, pv = uf.find(u), uf.find(v)\n            if pu == pv:\n                continue\n            else:\n                cost += dis\n                uf.union(u,v)\n\n        return cost\n            \n    \n                \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        dist = []\n        \n        for x in range(len(points)):\n            [xi, yi] = points[x]\n            for y in range(x+1, len(points)):\n                [xj, yj] = points[y]\n                manhattan_dist = abs(xi-xj) + abs(yi-yj)\n                if x != y:\n                    dist.append([x,y,manhattan_dist])\n                \n        dist.sort(key=lambda pt: pt[2])\n        \n        def detectCycle(adj):\n            visited = set()\n            \n            def dfs(curr, parent):\n                visited.add(curr)\n                for neighbor in adj[curr]:\n                    if neighbor == parent:\n                        continue\n                    elif neighbor in visited:\n                        return True\n                    elif dfs(neighbor, curr):\n                        return True\n                return False\n            \n            for node in range(len(points)):\n                if node not in visited:\n                    if dfs(node, -1):\n                        return True\n            return False\n            \n        \n        adj = {x: set() for x in range(len(points))}\n        ans = 0\n        v = 0\n        for distance in dist:\n            [x, y, manhattan_dist] = distance\n            adj[x].add(y)\n            adj[y].add(x)\n            if detectCycle(adj):\n                adj[x].remove(y)\n                adj[y].remove(x)\n            else:\n                ans += manhattan_dist\n                v += 1\n                \n            if v == len(points)-1:\n                break\n            \n        return ans\n            \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def calc(x,y):\n            return abs(x[0]-y[0]) + abs(x[1]-y[1])\n        #d = collections.defaultdict(dict)\n        connections = []\n        #seen = set()\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                if i != j:\n                    #d[i][j]  = calc(points[i],points[j])\n                    connections.append([i,j,calc(points[i],points[j])])\n                    \n        connections.sort(key = lambda x: x[2])  \n        n = len(points)\n        parent = [-1]*n\n        size = [1]*n\n        res = []\n        \n        def find(x):\n            if parent[x] == -1:\n                return x\n            parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x,y):\n            px = find(x)\n            py = find(y)\n            if px == py:\n                return False\n            if size[px] > size[py]:\n                size[px] += size[py]\n                parent[py] = px\n            else:\n                size[py] += size[px]\n                parent[px] = py\n            return True\n        for s,d,w in connections:\n            if union( s, d):\n                res.append([s,d,w])\n        ans = 0\n        for a,b,c in res:\n            ans += c\n            \n        \n        \n        #print(res)\n        return ans\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        g = [[] for _ in range(n)]\n        for i in range(n-1):\n            x0, y0 = points[i]\n            for j in range(i+1, n):\n                x1, y1 = points[j]\n                d = abs(x0-x1)+abs(y0-y1)\n                g[i].append((d, j))\n                g[j].append((d, i))\n        import heapq\n        def prim_heap(edge):\n            used = [True]*n\n            edgelist = []\n            for e in edge[0]:\n                heapq.heappush(edgelist, e)\n                used[0] = False\n            res = 0\n            while len(edgelist) != 0:\n                minedge = heapq.heappop(edgelist)\n                if not  used[minedge[1]]:\n                    continue\n                v = minedge[1]\n                used[v] = False\n                for e in edge[v]:\n                    if used[e[1]]:\n                        heapq.heappush(edgelist, e)\n                res += minedge[0]\n            return res\n        res = prim_heap(g)\n        return res\n        \n", "class Unifind:\n    def __init__(self,n):\n        self.arr = list(range(n))\n        self.rank = [0]*n\n    def union(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        \n        if self.rank[a]<self.rank[b]:\n            a,b = b,a\n        \n        if self.rank[a]==self.rank[b]:\n            self.rank[a]+=1\n        \n        self.arr[b] = a\n        \n    def find(self,a):\n        if self.arr[a]!=a:\n            self.arr[a] = self.find(self.arr[a])\n        return self.arr[a]\n\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        \n        manhatan = lambda x1,y1,x2,y2 : (x1-x2 if x1>x2 else x2-x1) + (y1-y2 if y1>y2 else y2-y1)\n        edges = [(manhatan(points[i][0],points[i][1],points[j][0],points[j][1]),i,j) for i in range(len(points)) for j in range(i+1,len(points))]\n        heapify(edges)\n        #print(edges)\n        uf = Unifind(len(points))\n        count = 0\n        cost = 0\n        while count < len(points)-1:\n            c,i,j = heappop(edges)\n            #if edge adds a cycle(both ends are already in)\n            if uf.find(i)!=uf.find(j):\n                cost+=c\n                count+=1\n                uf.union(i,j)\n                \n        #print(uf.arr)\n        return cost\n                \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        all_edges = []\n        for point1 in points:\n            for point2 in points:\n                if point1 != point2:\n                    all_edges.append((abs(point1[0] - point2[0]) + abs(point1[1] - point2[1]), tuple(point1),tuple(point2)))\n                    \n        all_edges.sort(key=lambda x:(x[0]))\n        \n        parent = { tuple(point):tuple(point) for point in points }\n        rank = {tuple(point):1 for point in points}\n        def find(point1):\n            if parent[point1] != point1:\n                parent[point1] = find(parent[point1])\n            return parent[point1]\n        \n        def union(point1, point2):\n            parent1 = find(point1)\n            parent2 = find(point2)\n            if rank[parent1] > rank[parent2]:\n                parent[parent2] = parent1\n                rank[parent1] += 1\n            else:\n                parent[parent1] = parent2\n                rank[parent2] += 1\n            return\n        cost = 0\n        count = 0\n        for edge in all_edges:\n            if count == len(points)-1:\n                break\n            if find(edge[1]) != find(edge[2]):\n                union(edge[1],edge[2])\n                cost +=edge[0]\n                count +=1\n        return cost\n", "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        return True\n    \nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        \n        edges = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = abs(points[i][0] - points[j][0])\n                d += abs(points[i][1] - points[j][1])\n                edges.append([d, i, j])\n        edges.sort()\n\n        ans = 0\n        dsu = DSU(N)\n        for d, u, v in edges:\n            if dsu.union(u, v):\n                ans += d\n        return ans\n    \n        # n = len(points)\n        # adj_matrix = [[0 for _ in range(n)] for _ in range(n)]\n        # for i in range(n):\n        #     for j in range(n):\n        #         if i == j:\n        #             continue\n        #         adj_matrix[i][j] = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n        # visited = [False] * n\n        # visited[0] = True\n        # weight = [0] * n\n        # for j in range(n):\n        #     if j == 0:\n        #         weight[j] = float('inf')\n        #     else:\n        #         weight[j] = adj_matrix[0][j]\n        # total = 0\n        # visit = 0\n        # while not all(visited):\n        #     visit = weight.index(min(weight))\n        #     total += weight[visit]\n        #     visited[visit] = True\n        #     for j in range(n):\n        #         if weight[j] == float('inf'):\n        #             continue\n        #         if j == visit:\n        #             weight[j] = float('inf')\n        #             continue\n        #         weight[j] = min(weight[j], adj_matrix[visit][j])\n        # return total\n", "from heapq import *\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        result = 0\n        if len(points) == 1:\n            return result\n        \n        costHeap = []\n        n = len(points)\n        cur = 0\n        distance = lambda p, np: abs(p[0] - np[0]) + abs(p[1] - np[1])\n        visited = [False for _ in range(n)]\n        visited[0] = True\n        size = 1\n        \n        for i in range(1, n):\n            heappush(costHeap, [distance(points[0], points[i]), i])\n        \n        while costHeap:\n            cost, nextStart = heappop(costHeap)\n            # print(cur, nextStart, cost)\n            if not visited[nextStart]:\n                result += cost\n                visited[nextStart] = True\n                size += 1\n                cur = nextStart\n                for i in range(n):\n                    heappush(costHeap, [distance(points[cur], points[i]), i])\n                if size == n:\n                    break\n                \n        return result\n                    \n", "class DSU:\n    def __init__(self, n):\n        self.p = list(range(n))\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    def union(self, x, y):\n        p_x = self.find(x)\n        p_y = self.find(y)\n        if p_x != p_y:\n            self.p[p_x] = p_y\n            return True\n        return False\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n < 2:\n            return 0\n        \n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        dic = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                dic[(i, j)] = dist(points[i], points[j])\n                \n        o = sorted(list(dic.items()), key = lambda v: v[1])\n        dsu = DSU(n)\n        res = 0\n        for pts, cost in o:\n            p1, p2 = pts\n            if dsu.union(p1, p2):\n                res += cost\n        \n        return res\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1,n):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((d,i,j))\n        edges.sort()\n        \n        root = [i for i in range(n)]\n        def find(v):\n            if root[v] != v:\n                root[v] = find(root[v])\n            return root[v]\n            \n        def union(u,v):\n            p1 = find(u)\n            p2 = find(v)\n            if p1 != p2:\n                root[p2] = root[p1]\n                return True\n            return False\n        \n        res = 0\n        for d,u,v in edges:\n            if union(u,v):\n                res += d\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n    \n        edges = []\n        nodes = set()\n        # set up edges with (weight, u, v)\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                dis = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dis, i, j))\n                nodes.add(i)\n                nodes.add(j)\n        \n\n        # set up union find\n        class UnionFindSet:\n            def __init__(self, nodes):\n                self._parents = {n:n for n in nodes}\n                self._ranks = {n:1 for n in nodes}\n\n            def find(self, u):\n                while u != self._parents[u]:\n                    self._parents[u] = self.find(self._parents[u])\n                    u = self._parents[u]\n                return u\n\n            def union(self, u, v):\n                pu, pv = self.find(u), self.find(v)\n                if pu == pv: return False\n\n                if self._ranks[pu] < self._ranks[pv]:\n                    self._parents[pu] = pv\n                elif self._ranks[pu] > self._ranks[pv]:\n                    self._parents[pv] = pu\n                else:        \n                    self._parents[pv] = pu\n                    self._ranks[pu] += 1\n\n                return True\n\n        uf = UnionFindSet(nodes)\n        \n        # Kruskal Algorithm\n        edges.sort()\n        cost = 0\n        for dis, u, v in edges:\n            pu, pv = uf.find(u), uf.find(v)\n            if pu == pv:\n                continue\n            else:\n                cost += dis\n                uf.union(u,v)\n\n        return cost\n            \n    \n                \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        sets = list(range(len(points)))\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                d = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                edges.append([d, i, j])\n                \n        edges.sort()\n        n_edges = 0\n        ans = 0\n        cur = 0\n        \n        def find(i):\n            while sets[i] != i:\n                i = sets[i]\n            return i\n        \n        while n_edges != len(sets) - 1:\n            d, i, j = edges[cur]\n            # print(i, j, sets)\n            if find(i) != find(j):\n                sets[find(i)] = find(j)\n                ans += d\n                n_edges += 1\n            cur += 1\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        \n        edges = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = abs(points[i][0] - points[j][0])\n                d += abs(points[i][1] - points[j][1])\n                edges.append([d, i, j])\n        edges.sort()\n\n        ans = 0\n        dsu = DSU(N)\n        for d, u, v in edges:\n            if dsu.union(u, v):\n                ans += d\n        return ans\n    \nclass DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        return True", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def helper(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        edges = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                heapq.heappush(edges, (helper(points[i], points[j]), i, j))\n        tree = []\n        res = 0\n        # print(edges)\n        while edges:\n            dist, i, j = heapq.heappop(edges)\n            flag = False\n            for p in range(len(tree)):\n                s = tree[p]\n                if i in s or j in s:\n                    q = j if i in s else i\n                    if q not in s:\n                        set_num = -1\n                        for k in range(len(tree)):\n                            st = tree[k]\n                            if q in st:\n                                set_num = k\n                                break\n                        if set_num != -1:\n                            tree[p] = tree[p].union(tree[k])\n                            tree.pop(k)\n                        else:\n                            s.add(q)\n                        res += dist\n                    flag = True\n                    break\n            if not flag:\n                tree.append({i, j})\n                res += dist\n            # print(tree)\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        parent = list(range(n))\n        rank = [0] * n\n        def find(x):\n            while parent[x] != x:\n                x = parent[x]\n            return x\n        def union(x, y):\n            id_x = find(x)\n            id_y = find(y)\n            if id_x == id_y:\n                return 0\n            if rank[id_x] == rank[id_y]:\n                parent[id_y] = id_x\n                rank[id_x] += 1\n            elif rank[id_x] > rank[id_y]:\n                parent[id_y] = id_x\n            else:\n                parent[id_x] = id_y\n            return 1\n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append((abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j))\n        edges = sorted(edges, key=lambda x: x[0])\n        cost = 0\n        for edge in edges:\n            if union(edge[1], edge[2]):\n                cost += edge[0]\n        return cost    \n", "class Solution:\n    def minCostConnectPoints(self, points):\n        helper = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        points, res = [[p, helper(p, points[0])] for p in points], 0\n        while points:\n            minI = min(range(len(points)), key = lambda i: points[i][1])\n            p1, cost = points.pop(minI)\n            res += cost\n            for i, (p2, _) in enumerate(points):\n                points[i][1] = min(points[i][1], helper(p1, p2))\n        return res", "class dsu:\n    def __init__(self,n):\n        self.parent =[-1 for i in range(n)]\n        self.size = [0 for i in range(n)]\n\n    def make_set(self,node):\n        self.parent[node] = node\n\n    def find(self,a):\n        if self.parent[a] == a:\n            return self.parent[a]\n        else:\n            self.parent[a] = self.find(self.parent[a])\n            return self.parent[a]\n\n    def union(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a!=b:\n            # if self.size[a] > self.size[b]:\n            #     temp = a\n            #     a = b\n            #     b = temp\n            self.parent[b] =self.parent[a]\n            # self.size[a] = self.size[a] + self.size[b]\n\n\nclass Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        n = len(p)\n        if n<=1:\n            return 0\n        tree = dsu(n)\n        edges = []\n        for i in range(len( p)):\n            for j in range(i+1,len(p)):\n                edges.append([abs(p[i][0] - p[j][0]) + abs(p[i][1] -  p[j][1]),i,j])\n        edges.sort()\n        done = 0\n        ans = 0\n        for i in range(n):\n            tree.make_set(i)\n        # print(tree.parent)\n        # print(edges)\n        for i in edges:\n            \n            if tree.find(i[1]) != tree.find(i[2]):\n                done = done + 1\n                ans =ans + i[0]\n                tree.union(i[1],i[2])\n            # print(tree.parent)\n        return ans\n                \n            \n", "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1]*N\n        \n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n        \n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        \n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        \n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        self.sz[yr] = self.sz[xr]\n        return True\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        edges = []\n        for i in range(N):\n            for j in range(i+1,N):\n                d = abs(points[i][0]-points[j][0])\n                d += abs(points[i][1]-points[j][1])\n                edges.append([d,i,j])\n        edges.sort()\n        \n        dsu = DSU(N)\n        ans = 0\n        for d,u,v in edges:\n            if dsu.union(u,v):\n                ans += d\n        \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        graph = defaultdict(list)\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1,y1 = points[i]\n                x2,y2 = points[j]\n                manhattan_dist = abs(x1-x2)+abs(y1-y2)\n\n                graph[i].append((manhattan_dist, j))\n                graph[j].append((manhattan_dist, i))\n                    \n        visited = set()\n        heap = [(0, 0)]\n        cost = 0\n        \n        while heap:\n            distance, current_node = heapq.heappop(heap)\n            \n            if current_node not in visited:\n                \n                visited.add(current_node)\n                cost += distance\n\n                for dist, neigh in graph[current_node]:\n                    if neigh not in visited:\n                        heapq.heappush(heap, (dist,neigh))\n                        \n        return cost", "class DSU:\n    def __init__(self,n):\n        self.par = [x for x in range(n)]\n    \n    def find(self,x):\n        if self.par[x]!=x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self,x,y):\n        xp,yp = self.find(x),self.find(y)\n        if xp == yp :return False\n        self.par[yp] = xp\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #MST\n        n = len(points)\n        edges = []\n           \n        dist = lambda a,b,c,d: abs(a-c)+abs(b-d)\n        for i,p1 in enumerate(points):\n            for j in range(i+1,n):\n                if (i==j):continue\n                p2 = points[j]\n                edges.append([ dist(*p1,*p2),i,j])\n            \n        def MST():\n            res = 0 \n            dsu = DSU(n)\n            for weight,p1,p2 in sorted(edges):\n                if dsu.union(p1,p2):\n                    res += weight\n            return res\n        \n        return MST()\n", "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        self.sz[yr] = self.sz[xr]\n        return True\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\nclass Solution:\n    # Kruskal algorithm, union find, time O(n^2), space O(n^2)\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        edges.sort()\n        m = len(edges)\n        dsu = DSU(n)\n        res = 0\n        for d, u, v in edges:\n            if dsu.union(u, v):\n                res += d\n        return res\n            \n        \n        \n", "from heapq import heapify, heappush, heappop\nfrom collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(point1, point2):\n            x1, y1 = point1\n            x2, y2 = point2\n            return abs(x1-x2) + abs(y1-y2)\n        \n        n = len(points)\n        if n == 1:\n            return 0\n        \n        cost = defaultdict(list)\n        for i in range(n):\n            point1 = points[i]\n            for j in range(i+1, n):\n                point2 = points[j]\n                d = distance(point1, point2)\n                cost[tuple(point1)].append((d, point2))\n                cost[tuple(point2)].append((d, point1))\n                \n                \n            \n        ans = 0\n        visited = {tuple(points[0])}\n        heap = cost[tuple(points[0])]\n        heapify(heap)\n        \n        while len(visited) != n:\n            d, v = heappop(heap)\n            if tuple(v) not in visited:\n                visited.add(tuple(v))\n                ans += d\n                for record in cost[tuple(v)]:\n                    heappush(heap, record)\n        \n        return ans\n                    \n                    \n                \n                \n        \n        \n        \n        \n        \n        \n            \n            \n            \n                        \n                    \n            \n            \n        \n        \n        \n", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        manhattan = lambda p1, p2 : abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        pq = []\n        p1 = points[0]\n        seen = {0,}\n        horizon = set(range(1, len(points)))\n        for idx in horizon:\n            p2 = points[idx]\n            heapq.heappush(pq, (manhattan(p1, p2), idx))\n\n                \n        total_dist = 0\n        while horizon:\n            while pq[0][-1] in seen:\n                heapq.heappop(pq)\n            dist, min_idx = heapq.heappop(pq)\n            \n            \n            total_dist += dist\n            seen.add(min_idx)\n            horizon.remove(min_idx)\n            \n            p1 = points[min_idx]\n            \n            for idx in horizon: \n                p2 = points[idx]\n                heapq.heappush(pq, (manhattan(p1, p2), idx))\n                    \n        return total_dist\n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #compute cost:\n        n=len(points)\n        g=[]\n        for i in range(n):\n            for j in range(i+1,n):\n                w=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                g.append([i,j,w])\n        g=sorted(g,key=lambda x:x[2])\n        par=list(range(n))\n        #print(par)\n        #print(g)\n        def root(i):\n            while par[i]!=i:\n                par[i]=par[par[i]]\n                i=par[i]\n            return i \n        def union(i,j):\n            pi,pj=root(i),root(j)\n            par[pi]=par[pj]\n        cost=0\n        for i,j,w in g:\n            if root(i)!=root(j):\n                cost+=w\n                #union i and j:\n                union(i,j)\n                \n        return cost\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        graph = defaultdict(list)\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1,y1 = points[i]\n                x2,y2 = points[j]\n                manhattan_dist = abs(x1-x2)+abs(y1-y2)\n\n                graph[i].append((manhattan_dist, j))\n                graph[j].append((manhattan_dist, i))\n                    \n        visited = set()\n        heap = [(0, 0)]\n        cost = 0\n        \n        while heap:\n            distance, current_node = heapq.heappop(heap)\n            \n            if current_node not in visited:\n                \n                visited.add(current_node)\n                cost += distance\n\n                for dist, neigh in graph[current_node]:\n                    if neigh not in visited:\n                        heapq.heappush(heap, (dist,neigh))\n                        \n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans", "class Solution:\n    \n    def kruskal(self, n, edges):\n        def find(x):\n            if x != parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        def union(x, y):\n            px, py = find(x), find(y)\n            if px == py:\n                return False\n            parent[px] = py\n            return True\n        mst_cost = 0\n        parent = list(range(n))\n        for f, t, w in edges:\n            if union(f, t):\n                mst_cost += w\n        return mst_cost\n        \n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda xx, yy: abs(xx[0] - yy[0]) + abs(xx[1] - yy[1])\n        \n        if (n := len(points)) == 1:\n            return 0\n        \n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                x, y = points[i], points[j]\n                edges.append([i, j, manhattan(x, y)])\n        edges.sort(key = lambda x: x[2])\n        return self.kruskal(n, edges)\n        \n        # graph = collections.defaultdict(list)\n        # for i in range(n):\n        #     for j in range(i + 1, n):\n        #         x, y = points[i], points[j]\n        #         graph[i].append((manhattan(x, y), j))\n        #         graph[j].append((manhattan(x, y), i))\n        # return prim(graph)\n            \n                \n#         def prim(graph):\n#             V = {0}\n#             edges = graph[0]\n#             heapify(edges)\n#             sum_cost = 0\n#             while edges:\n#                 cost, p2 = heappop(edges)\n#                 if p2 in V:\n#                     continue\n#                 sum_cost += cost\n#                 V.add(p2)\n#                 for new_edge in graph[p2]:\n#                     if new_edge[1] not in V:\n#                         heappush(edges, new_edge)\n#                 if len(V) == len(graph):\n#                     break\n#             return sum_cost\n", "from sortedcontainers import SortedList\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ret, n = 0, len(points)\n        \n        uf = {}\n        def find(x):\n            uf.setdefault(x, x)\n            if uf[x] != x: uf[x] = find(uf[x])\n            return uf[x]\n        def union(x, y): # x->y\n            uf[find(x)] = find(y)\n        \n        def dis(a, b):\n            return abs(a[0]-b[0])+abs(a[1]-b[1])\n        \n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                edges.append((dis(points[i], points[j]), i, j))\n        \n        edges.sort()\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                ret += cost\n                union(u, v)\n\n        return ret", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 2:\n            return abs(points[0][0] - points[1][0]) + abs(points[1][1] - points[0][1])\n        if len(points) == 1:\n            return 0\n        connSet = set()\n        unConnSet = set()\n        for i in range(len(points)):\n            unConnSet.add(i)\n        #print(unConnSet)\n        myHeap = []\n        \n        for i in range(len(points)):\n            for j in range(i):\n                lenCalc = abs(points[i][0] - points[j][0]) + abs(points[j][1] - points[i][1])\n                if lenCalc>0:\n                    myHeap.append([lenCalc,(i,j)])\n        #print(myHeap)\n        myHeap.sort(key = lambda x: x[0])\n        #print(myHeap)\n        \n        p1 = myHeap[0][1][0]\n        p2 = myHeap[0][1][1]\n        connSet.add(p1)\n        connSet.add(p2)\n        #print(p2)\n        unConnSet.remove(p1)\n        unConnSet.remove(p2)\n        itt =0\n        res = myHeap[0][0]\n        myHeap.pop(0)\n        while(itt < len(myHeap) and len(unConnSet)>0):\n            p1 = myHeap[itt][1][0]\n            p2 = myHeap[itt][1][1]\n            \n            if p1 in connSet and p2 not in connSet:\n                connSet.add(p2)\n                unConnSet.remove(p2)\n                res+=myHeap[itt][0]\n                myHeap.pop(itt)\n                itt = -1\n            if p2 in connSet and p1 not in connSet:\n                connSet.add(p1)\n                unConnSet.remove(p1)\n                res+=myHeap[itt][0]\n                myHeap.pop(itt)\n                itt = -1\n            itt+=1\n        return res\n            \n            \n            \n            \n            \n    \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        uf = list(range(n))\n        def find(x):\n            if uf[x] != x:\n                uf[x] = find(uf[x])\n            return uf[x]\n        def union(x, y):\n            tx = find(x)\n            ty = find(y)\n            if tx != ty:\n                uf[tx] = ty\n\n        def l1dist(x, y):\n            return abs(x[0]-y[0])+abs(x[1]-y[1])\n        \n        dist = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist.append((l1dist(points[i], points[j]), i, j))\n\n        dist.sort()\n        ans = 0\n        cnt = 0\n        for d, x, y in dist:\n            if cnt == n:\n                break\n            if find(x) != find(y):\n                union(x, y)\n                ans += d\n                cnt += 1\n        return ans\n            \n                \n            \n", "import heapq\nfrom collections import defaultdict\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def manhattan(x,y):\n            return abs(x[0] - y[0]) + abs(x[1] - y[1])\n        \n        dist_dict = defaultdict(list)\n        n_points = len(points)\n        \n        for i in range(n_points):\n            for j in range(i+1, n_points):\n                dist_curr = manhattan(points[i], points[j])\n                dist_dict[i].append((dist_curr, j))\n                dist_dict[j].append((dist_curr, i))\n        \n        counter, visited, answer, heap = 1, [0] * n_points, 0, dist_dict[0]\n        heapq.heapify(heap)\n        visited[0] = 1\n        \n        while heap:\n            dist_curr, point_curr = heapq.heappop(heap)\n            \n            if not visited[point_curr]:\n                counter += 1\n                visited[point_curr] = 1\n                answer += dist_curr\n                \n                for candidate in dist_dict[point_curr]:\n                    heapq.heappush(heap, candidate)\n            \n            if counter >= n_points:\n                break\n        return answer\n\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        conn = [points[0]]\n        if len(points) == 1:\n            return 0\n        points = points[1:]\n        res = 0\n        dists = {str(p):abs(p[0]-conn[0][0])+abs(p[1]-conn[0][1]) for p in points}\n        print(dists)\n        while len(points) > 0:\n            best = 1e8\n            bestc = -1\n            bestp = -1\n            for j, p in enumerate(points):\n                if dists[str(p)] < best:\n                        bestp = j\n                        best = dists[str(p)]\n            res += best\n            conn.append(points[bestp])\n            np = points[bestp]\n            del points[bestp]\n            for p in points:\n                dists[str(p)] = min(dists[str(p)], abs(p[0]-np[0]) + abs(p[1]-np[1]))\n            \n        return res", "class Solution:\n    def minCostConnectPoints(self, points):\n        helper = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        points = [[p, helper(p, points[0])] for p in points]\n        total_cost = 0\n        while points:\n            minI = min(range(len(points)), key = lambda i: points[i][1])\n            p1, cost = points.pop(minI)\n            total_cost += cost\n            for i, (p2, _) in enumerate(points):\n                points[i][1] = min(points[i][1], helper(p1, p2))\n        return total_cost", "class DisjointSet:\n    def __init__(self, points):\n        self.parent = {}\n        self.rank = {}\n        for point in points:\n            self.parent[point] = point\n            self.rank[point] = 1\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        x_set = self.find(x)\n        y_set = self.find(y)\n\n        if self.rank[x_set] < self.rank[y_set]:\n            self.parent[x_set] = y_set\n        elif self.rank[x_set] > self.rank[y_set]:\n            self.parent[y_set] = x_set\n        else:\n            self.parent[x_set] = y_set\n            self.rank[y_set] += 1\n\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        points = [tuple(point) for point in points]\n        disjoint_set = DisjointSet(points)\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                distance = self.distance(points[i], points[j])\n                edges.append([distance, points[i], points[j]])\n        \n        edges.sort()\n        \n        answer = 0\n        i = 0\n        times = 0\n        while times < len(points)-1:\n            if times == len(points) - 1:\n                return answer\n            distance, nodeA, nodeB = edges[i][0], edges[i][1], edges[i][2]\n            if disjoint_set.find(nodeA) != disjoint_set.find(nodeB):\n                times += 1\n                answer += distance\n                disjoint_set.union(nodeA, nodeB)\n            i += 1\n                \n        return answer\n                \n    def distance(self, pointA, pointB):\n        return abs(pointA[0] - pointB[0]) + abs(pointA[1] - pointB[1])\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # seems dijkstra with all the neighbors connected? \n        # try minimum spanning treee\n        node = 0\n        # build the graph first\n        seen = set([0])\n        edges = [(abs(points[0][0] - points[x][0]) + abs(points[0][1] - points[x][1]), 0, x) for x in range(1, len(points))]\n        heapq.heapify(edges)\n        ans = 0\n        while edges:\n            cost, frm, to = heapq.heappop(edges)\n            if to not in seen:\n                seen.add(to)\n                ans += cost\n                for to_next, (x, y) in enumerate(points):\n                    if to_next not in seen:\n                        heapq.heappush(edges, (abs(x-points[to][0]) + abs(y-points[to][1]), to, to_next))\n\n        return ans\n        \n        \n        \n            \n            \n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(p1, p2):\n            return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n        ans = 0\n        h = []\n        heappush(h, (0, points[0]))\n        visited = set()\n        \n        while h:\n            d, p = heappop(h)\n            if (p[0], p[1]) in visited:\n                continue\n            visited.add((p[0], p[1]))\n            ans += d\n            \n            for point in points:\n                if (point[0], point[1]) not in visited:\n                    heappush(h, (distance(p, point), point))\n                    \n        return ans\n                    \n        \n                \n        \n", "# class Solution:\n#     def minCostConnectPoints(self, points: List[List[int]]) -> int:\n#         manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n#         n, c = len(points), collections.defaultdict(list)\n#         for i in range(n):\n#             for j in range(i+1, n):\n#                 d = manhattan(points[i], points[j])\n#                 c[i].append((d, j))\n#                 c[j].append((d, i))\n#         cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n#         visited[0] = 1\n#         heapq.heapify(heap)\n#         while heap:\n#             d, j = heapq.heappop(heap)\n#             if not visited[j]:\n#                 visited[j], cnt, ans = 1, cnt+1, ans+d\n#                 for record in c[j]: heapq.heappush(heap, record)\n#             if cnt >= n: break        \n#         return ans\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa]\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        # sort based on cost (i.e. distance)\n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        ds = DisjointSet(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u, v)\n                res += cost\n        \n        return res", "# kruskal \nclass Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                        \n        n, q = len(a), []\n        for i in range(n-1):\n            for j in range(i+1, n):\n                q.append((abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1]), i, j))\n                        \n        def union(u, v):\n            UF[find(v)] = UF[find(u)]\n        def find(u):\n            if u != UF[u]: UF[u] = find(UF[u])\n            return UF[u]\n        \n        heapify(q)\n        ans, vis, UF = 0, set(), {i: i for i in range(n)}\n        while q and len(set(find(u) for u in UF)) != 1:\n            val, i, j = heappop(q)\n            if find(i) != find(j):\n                union(i, j)\n                vis |= set([i, j])\n                ans += val\n        return ans                        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dist = collections.defaultdict(list)\n        n = len(points)\n        for i in range(n):\n            for j in range(i+1,n):\n                d = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                dist[i].append((j,d))\n                dist[j].append((i,d))\n        # print(dist)\n        ret = 0\n        visited = set([])\n        pq = [(0,0)] # dist to s, index, dist to neighbour\n        while pq:\n            w,u = heapq.heappop(pq)\n            if u not in visited:\n                ret += w\n                visited.add(u)\n                for v,d in dist[u]:\n                    if v not in visited: heapq.heappush(pq,(d,v))\n        return ret\n                \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # spaning tree\n        n = len(points)\n        hq = [(0, points[0][0], points[0][1])]\n        seen = set()\n        total = 0\n        while hq:\n            dist, x, y = heappop(hq)\n            if (x, y) in seen: continue\n            total += dist\n            seen.add((x, y))\n            for nx, ny in points:\n                if (nx,ny) not in seen:\n                    dist = abs(nx - x) + abs(ny - y)\n                    heappush(hq, (dist, nx, ny))\n        return total", "class UF:\n    def __init__(self):\n        self.ranks = {}\n        self.pnts = {}\n        self.sz = {}\n\n    def find_make_set(self, x):\n        if not x in self.pnts:\n            self.pnts[x] = None\n            self.ranks[x] = 0\n            self.sz[x] = 1\n\n        if self.pnts[x] is None:\n            return x\n\n        self.pnts[x] = self.find_make_set(self.pnts[x])\n        return self.pnts[x]\n\n    def union(self, x, y):\n        ra = self.find_make_set(x)\n        rb = self.find_make_set(y)\n\n        if ra == rb:\n            return ra\n\n        if self.ranks[ra] > self.ranks[rb]:\n            self.pnts[rb] = ra\n            self.sz[ra] += self.sz[rb]\n            return ra\n\n        self.pnts[ra] = rb\n        self.sz[rb] += self.sz[ra]\n        if self.ranks[ra] == self.ranks[rb]:\n            self.ranks[rb] += 1\n\n        return rb\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n        base = 10 ** 7\n\n        n = len(points)\n\n        egs = []\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n\n                u = points[i]\n                v = points[j]\n\n                ua = points[i][0] + base * points[i][1]\n                va = points[j][0] + base * points[j][1]\n\n                t = (ua, va), abs(u[0] - v[0])  + abs(u[1] - v[1])\n                egs.append(t)\n\n        egs.sort(key=lambda x: x[1])\n\n        uf = UF()\n        ans = 0\n\n        for e, w in egs:\n            u, v = e\n            ru = uf.find_make_set(u)\n            rv = uf.find_make_set(v)\n            if ru != rv:\n                uf.union(u, v)\n                ans += w\n            else:\n                if uf.sz[ru] == n:\n                    break\n\n        return ans\n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        uf = [i for i in range(n)]\n        \n        def union(a,b):\n            a,b = find(a),find(b)\n            uf[a] = b\n        \n        def find(a):\n            if uf[a] != a:\n                uf[a] = find(uf[a])\n            return uf[a]\n        \n        edges = []\n        \n        for i in range(n):\n            for j in range(i+1,n):\n                edges.append((abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),i,j))\n        \n        edges = sorted(edges)\n        c = 0\n        for a,x,y in edges:\n            if find(x) != find(y):\n                c += a\n                union(x,y)\n        return c\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(u, v):\n            x, y = points[u]\n            x2, y2 = points[v]\n            return abs(x - x2) + abs(y - y2)\n        \n        n = len(points)\n        visited = [False] * (n)\n        distto = [0] + [10 ** 7] * (n - 1)\n        \n        ans = 0\n        for _ in range(n):\n            best, idx = 10 ** 7, -1\n            for u in range(n):\n                if not visited[u] and distto[u] < best:\n                    best, idx = distto[u], u\n            visited[idx] = True\n            ans += best\n            for v in range(n):\n                if not visited[v]:\n                    distto[v] = min(distto[v], dist(idx, v))\n                \n        return ans\n", "# int find(vector<int> &ds, int i) {\n#     return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\n# }\n# int minCostConnectPoints(vector<vector<int>>& ps) {\n#     int n = ps.size(), res = 0;\n#     vector<int> ds(n, -1);\n#     vector<array<int, 3>> arr;\n#     for (auto i = 0; i < n; ++i)\n#         for (auto j = i + 1; j < n; ++j) {\n#             arr.push_back({abs(ps[i][0] - ps[j][0]) + abs(ps[i][1] - ps[j][1]), i, j});\n#         }\n#     make_heap(begin(arr), end(arr), greater<array<int, 3>>());\n#     while (!arr.empty()) {\n#         pop_heap(begin(arr), end(arr), greater<array<int, 3>>());\n#         auto [dist, i, j] = arr.back();\n#         arr.pop_back();\n#         i = find(ds, i), j = find(ds, j);\n#         if (i != j) {\n#             res += dist;\n#             ds[i] += ds[j];\n#             ds[j] = i;\n#             if (ds[i] == -n)\n#                 break;\n#         }\n#     }\n#     return res;\n# }\n\nclass Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                        \n        n, q = len(a), []\n        for i in range(n-1):\n            for j in range(i+1, n):\n                q.append((abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1]), i, j))\n        UF = {i: i for i in range(n)}\n        def union(u, v):\n            UF[find(v)] = UF[find(u)]\n        def find(u):\n            if u != UF[u]: UF[u] = find(UF[u])\n            return UF[u]\n        heapify(q)\n        ans, vis = 0, set()\n        while q and len(set(find(u) for u in UF)) != 1:\n            val, i, j = heappop(q)\n            if find(i) != find(j):\n                union(i, j)\n                vis |= set([i, j])\n                ans += val\n                # print(ans, i, j, q)\n        return ans\n            \n", "class Solution:\n    def minCostConnectPoints(self, pt: List[List[int]]) -> int:\n        if len(pt)==1:\n            return 0\n        l = []\n        for i in range(len(pt)):\n            for j in range(len(pt)):\n                l.append((i,j,abs(pt[i][0]-pt[j][0])+abs(pt[i][1]-pt[j][1])))\n        \n        parents = list(range(len(pt)))\n        wt = [0 for i in range(len(pt))]\n        # print(l)\n        def find(p):\n            if p!=parents[p]:\n                parents[p] = find(parents[p])\n            return parents[p]\n        \n        cost = 0\n        for u,v,dist in sorted(l, key=lambda x:x[2]):#sorted(l, key = lamda x:x[2]):\n            pu,pv=find(u),find(v)\n            if pu==pv:\n                continue\n            print((pu,pv,dist))\n            cost+=dist\n            if wt[pu]>=wt[pv]:\n                parents[pu]=pv\n                wt[pu] +=1\n            else:\n                parents[pv]=pu\n                wt[pv] +=1\n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap=[]\n        n=len(points)\n        for i in range(n-1):\n            x1,y1=points[i]\n            for j in range(i+1,n):\n                x2,y2=points[j]\n                heapq.heappush(heap, (abs(x1-x2)+abs(y1-y2), i, j))\n        ancient=list(range(n))\n        def find(x):\n            if x!=ancient[x]:\n                ancient[x]=find(ancient[x])\n            return ancient[x]\n        ans=0\n        while heap:\n            d,i,j=heapq.heappop(heap)\n            ai,aj=find(i), find(j)\n            if ai!=aj:\n                ancient[ai]=aj\n                ans+=d\n        return ans", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def get_distance(p1,p2):\n            return abs(p2[1]-p1[1]) + abs(p2[0] - p1[0])\n        \n        # edges\n        edges = []\n        \n        for i in range(0,len(points)):\n            for j in range(i+1,len(points)):\n                # edge = (distance, idx of point 1, idx of point 2)\n                \n                # sort edges\n                heappush(edges, (get_distance(points[i],points[j]), i, j))\n        \n        # store all the parents for each point\n        parents = [i for i in range(len(points))]\n        \n        # find the original parent of this element i.e. if its part of the currently beimg built MST\n        def find(point):\n            nonlocal parents\n            if parents[point] != point:\n                parents[point] = find(parents[point])\n            return parents[point]\n            \n        # add a new point to the union\n        def union(x,y):\n            nonlocal parents\n            parents[find(x)] = find(y)\n        \n        cost = 0\n        while edges:\n            dist, p1, p2 = heappop(edges)\n            # if p1 and p2 aren't part of the same set, add p2 to the set.\n            if find(p1) != find(p2):\n                union(p1,p2)\n                cost += dist\n            \n        return cost\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        L = len(points)\n        res = 0\n        con = {}\n        father = {i:i for i in range(L)}\n        def find(pidx):\n            if father[pidx] == pidx:\n                return pidx\n            return find(father[pidx])\n        def union(p,q):\n            if p != q:\n                if p < q:\n                    father[q] = p\n                else:\n                    father[p] = q\n        for i,p in enumerate(points):\n            for j,p2 in enumerate(points):\n                if i!=j and (j,i) not in list(con.keys()):\n                    d = self.dis(p,p2)\n                    con[(i,j)] = d\n        k = sorted(con, key = lambda x :con[x])\n        for e in k:\n            x,y = e[0],e[1]\n            fx, fy= find(x), find(y)\n            if fx!=fy:\n                union(fx,fy)\n                res += con[e]\n        return res\n            \n    def dis(self, p, x):\n        d = abs(x[1]-p[1]) + abs(x[0]-p[0])\n        return d\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n            \n                dist = abs(x1-x2) + abs(y1-y2)\n                heap.append((dist, i, j))\n        \n        heapify(heap)\n        uf = UnionFind(len(points))\n        res = 0\n        \n        while heap:\n            dist, x, y = heappop(heap)\n            if uf.union(x, y):\n                res += dist\n                \n        return res\n    \nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0]*n\n        \n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False\n        \n        if self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        \n        else:\n            self.parent[root_x] = root_y\n            if self.rank[root_x] == self.rank[root_y]:\n                self.rank[root_y] += 1\n        \n        return True\n    \n    def find(self, x):\n        while x != self.parent[x]:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n                \n        \n        \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = [[] for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                edges[i].append([dist, j])\n                edges[j].append([dist, i])\n        \n        cost = 0\n        tree = {0}\n        \n        pq = []\n        for c, v in edges[0]:\n            pq.append([c, v])\n        heapify(pq)\n        \n        while len(tree) < n:\n            c, v = heappop(pq)\n            if v in tree: continue\n            tree.add(v)\n            cost += c\n            for d, u in edges[v]:\n                if not u in tree:\n                    heappush(pq, [d, u])\n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        import heapq\n\n        visited = [False] * len(points)\n        heap = [(0, 0)]\n        res = 0\n\n        while heap:\n            dist, node = heapq.heappop(heap)\n            if not visited[node]:\n                res += dist\n                visited[node] = True\n                for neighbor in range(len(points)):\n                    if not visited[neighbor]:\n                        heapq.heappush(heap,\n                                       (sum([abs(points[node][i] - points[neighbor][i]) for i in range(2)]), neighbor))\n\n        return res", "# kruskal \nclass Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:                        \n        n, q = len(a), []\n        for i in range(n-1):\n            for j in range(i+1, n):\n                q.append((abs(a[i][0]-a[j][0]) + abs(a[i][1]-a[j][1]), i, j))\n                \n        UF = {i: i for i in range(n)}\n        def union(u, v):\n            UF[find(v)] = UF[find(u)]\n        def find(u):\n            if u != UF[u]: UF[u] = find(UF[u])\n            return UF[u]\n        \n        heapify(q)\n        ans, vis = 0, set()        \n        while q and len(set(find(u) for u in UF)) != 1:\n            val, i, j = heappop(q)\n            if find(i) != find(j):\n                union(i, j)\n                vis |= set([i, j])\n                ans += val\n        return ans                        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        \n        from collections import defaultdict\n        \n        import heapq\n        \n        def find(x):\n            if G[x] != x:\n                G[x] = find(G[x])\n            return G[x]\n        \n        def union(x, y):\n            x, y = find(x), find(y)\n            if x == y:\n                return False\n            G[y] = x\n            return True\n        \n        G = list(range(len(points)))\n        HQ = []\n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                heapq.heappush(HQ, (dist, i, j))\n        \n        res = 0\n        while HQ:\n            d, i, j = heapq.heappop(HQ)\n            if union(i, j):\n                res += d\n        \n        return res", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        heap, total_cost = [], 0\n        for i1, p1 in enumerate(points):\n            for i2, p2 in enumerate(points[i1+1:], start = i1+1):\n                heappush(heap, (dist(p1, p2), i1, i2))\n        while heap:\n            cost, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                N -= 1\n                total_cost += cost\n                if N == 0:\n                    break\n        return total_cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        \n        edges = []\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                u, v = points[i]\n                p, q = points[j]\n                w = abs(p - u) + abs(q - v)\n                edges.append((w, i, j))\n\n        path = {u:u for u in range(n)}\n        rank = {u:0 for u in range(n)}\n        \n        def find(u: int) -> int:\n            if u != path[u]:\n                path[u] = find(path[u])\n            return path[u]\n\n        def union(u: int, v: int) -> None:\n            i, j = find(u), find(v)\n            if rank[i] > rank[j]:\n                path[j] = i\n            else:\n                path[i] = j\n                if rank[i] == rank[j]:\n                    rank[i] += 1\n\n        costs = 0\n        edges.sort()\n        for w, u, v in edges:\n            if find(u) != find(v):\n                costs += w\n                union(u, v)\n        return costs\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        all_edges = []\n        for point1 in points:\n            for point2 in points:\n                if point1 != point2:\n                    all_edges.append((abs(point1[0] - point2[0]) + abs(point1[1] - point2[1]), tuple(point1),tuple(point2)))\n                    \n        all_edges.sort(key=lambda x:(x[0]))\n        \n        parent = { tuple(point):tuple(point) for point in points }\n        rank = {tuple(point):1 for point in points}\n        children = {tuple(point):1 for point in points}\n        def find(point1):\n            if parent[point1] != point1:\n                parent[point1] = find(parent[point1])\n            return parent[point1]\n        finish = False\n        def union(point1, point2):\n            parent1 = find(point1)\n            parent2 = find(point2)\n            if rank[parent1] > rank[parent2]:\n                parent[parent2] = parent1\n                rank[parent1] += 1\n                children[parent1] +=children[parent2]\n            else:\n                parent[parent1] = parent2\n                rank[parent2] += 1\n                children[parent2] +=children[parent1]\n            return\n        cost = 0\n        count = 0\n        for edge in all_edges:\n            if count == len(points)-1:\n                break\n            if find(edge[1]) != find(edge[2]):\n                union(edge[1],edge[2])\n                cost +=edge[0]\n                count +=1\n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, pt: List[List[int]]) -> int:\n        if len(pt)==1:\n            return 0\n        l = []\n        for i in range(len(pt)):\n            for j in range(len(pt)):\n                l.append((i,j,abs(pt[i][0]-pt[j][0])+abs(pt[i][1]-pt[j][1])))\n        \n        parents = list(range(len(pt)))\n        # wt = [0 for i in range(len(pt))]\n        # print(l)\n        def find(p):\n            if p!=parents[p]:\n                parents[p] = find(parents[p])\n            return parents[p]\n        \n        cost = 0\n        for u,v,dist in sorted(l, key=lambda x:x[2]):#sorted(l, key = lamda x:x[2]):\n            pu,pv=find(u),find(v)\n            if pu==pv:\n                continue\n            print((pu,pv,dist))\n            cost+=dist\n            parents[pu]=pv\n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        visited=[False]*len(points)\n        \n        def manhattan(x,y):\n            return abs(points[x][0]-points[y][0])+abs(points[x][1]-points[y][1])\n        \n        d=[[0 for j in range(len(points))] for i in range(len(points))]\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                \n                p=manhattan(i,j)\n               # print(p)\n                d[i][j]=p\n                d[j][i]=p\n            \n        q=[]\n        \n        heapq.heappush(q,(0,0))\n        m={}\n        \n        while q:\n            dist,j=heapq.heappop(q)\n            if j in m:\n                continue\n            m[j]=dist\n          #  print(j,m[j])\n            for i in range(len(points)):\n                if i not in m:\n                    heapq.heappush(q,(d[j][i],i))\n        #print(m)\n        return sum(m.values()) if len(m)==len(points) else 0\n        \n        \n", "from typing import List\n\nclass DS:\n    \n    def __init__(self, n):\n        self.sizes = [1] * n\n        self.roots = list(range(n))\n        \n    def find(self, v):\n        root = v\n        while root != self.roots[root]:\n            self.roots[root] = self.roots[self.roots[root]]\n            root = self.roots[root]\n        return root\n    \n    def union(self, u, v):\n        root_u, root_v = self.find(u), self.find(v)\n        if root_u != root_v: \n            s_root, l_root = (root_u, root_v) if self.sizes[root_u] < self.sizes[root_v] else (root_v, root_u)\n            self.roots[s_root] = l_root\n            self.sizes[l_root] += self.sizes[s_root]\n            \n    def connected(self, u, v):\n        return self.find(u) == self.find(v)\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ds = DS(len(points))\n        dist = lambda i, j : abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n        sorted_edges = sorted((dist(i,j), i, j) for i in range(len(points))\n                                                    for j in range(i + 1, len(points)))\n        cost = 0\n        for d, u, v in sorted_edges:\n            if not ds.connected(u, v):\n                ds.union(u, v)\n                cost += d\n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans\n", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, P: List[List[int]]) -> int:\n        def cruskal(nds, E):\n            def find(x):\n                if p[x] == x: return x\n                p[x] = find(p[x])\n                return p[x]\n            \n            p=[i for i in range(nds)]\n            ans =0\n            while E:\n                c, u, v = heapq.heappop(E)\n                p_u =find(u)\n                p_v =find(v)\n                if p_u != p_v:\n                    p[p[v]] = p[u]\n                    ans+= c\n            return ans\n        cost = []\n        heapq.heapify(cost)\n        for i, [x, y] in enumerate(P):\n            for j in range(i+1, len(P)):\n                x1, y1 = P[j]\n                if j ==i: continue\n                else: heapq.heappush(cost, (abs(x-x1)+abs(y-y1), i, j))\n        #print(len(cost))\n        return cruskal(len(P), cost)\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if len(points) == 1: return 0\n        res = 0\n        curr = 0 # select a random point as the starting point\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored: continue\n                dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) \n            dis[curr] = math.inf\n            res += delta\n            \n        return res\n        n = len(p)\n        if n == 1: return 0\n\n        dist = [[10**30 for x in range(n)] for x in range(n)]\n        for i in range(n):\n            for j in range(i+1,n):\n                dist[i][j] = dist[j][i] = abs(p[i][0]-p[j][0]) + abs(p[i][1]-p[j][1])\n\n        fin = set()\n        cur = 0\n        ret = 0\n        for i in range(n-1):\n            fin.add(cur)\n            (temp,j) = min( (x, i) for i, x in enumerate(dist[cur]) )\n            ret += temp\n            dist[cur][j] = dist[j][cur] = 10**30\n            cur = j\n            print(fin,cur,temp)\n            \n        \n        return ret\n                \n        \n        return self.dp(dist)\n\n    def dp(self, dist:List[List[int]]) -> int:\n        n = len(dist)\n        if n == 2:\n            return dist[0][1]\n\n        mi = 10**15\n        for i in range(1,n):\n            dd = [x.copy() for x in dist]\n            for j in range(1,n):\n                if j == i: continue\n                dd[0][j] = dd[j][0] = min(dist[0][j], dist[i][j])\n            dd = dd[:i]+dd[i+1:n]\n            dd = [ x[:i]+x[i+1:n] for x in dd]\n            mi = min(self.dp(dd)+dist[0][i], mi)\n        return mi", "class Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: p[0] + p[1])\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            p1, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p2, dist) in enumerate(points):\n                points[i][1] = min(points[i][1], distance(p1, p2))\n        return total_cost\n\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        connections = [[u, v, dist(points[u], points[v])] for u in range(N-1) for v in range(u+1, N)]\n        connections.sort(key = lambda x:x[2])\n        parent, cnt, res = [i for i in range(N+1)], N-1, 0\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        for u, v, cost in connections:\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                cnt -= 1\n                res += cost\n                if cnt == 0:\n                    break\n        return res\n    \nfrom heapq import *\nfrom collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        edges = defaultdict(list)\n        for i1, p1 in enumerate(points):\n            for i2, p2 in enumerate(points[i1+1:], start = i1+1):\n                distance = dist(p1, p2)\n                edges[i1].append([distance, i2])\n                edges[i2].append([distance, i1])\n        heap = edges[0]\n        heapify(heap)\n        total_cost, seen = 0, {0}\n        while len(seen) < N:\n            cost, node = heappop(heap)\n            if node in seen:\n                continue\n            seen.add(node)\n            total_cost += cost\n            for dist, next_ in edges[node]:\n                if next_ not in seen:\n                    heappush(heap, [dist, next_])\n        return total_cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        g = defaultdict(list)\n        n = len(points)\n        #create graph\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    g[i].append((abs(points[j][0]-points[i][0])+abs(points[j][1]-points[i][1]), j))\n\n        heap = [(0,0)]\n        ans = 0\n        visited = set()\n        while heap:\n            weight, to = heapq.heappop(heap)\n            if to in visited:\n                continue\n            ans += weight\n            visited.add(to)\n\n            for cost, nei in g[to]:\n                if nei not in visited:\n                    heapq.heappush(heap, (cost, nei))\n\n        return ans        ", "class Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        N = len(A)\n        P = [i for i in range(N)]                        # \\\\U0001f642 parent representatives of N disjoint sets\n        E = []\n        for u in range(N):\n            x1, y1 = A[u]\n            for v in range(u + 1, N):\n                x2, y2 = A[v]\n                w = abs(x1 - x2) + abs(y1 - y2)\n                E.append([ u, v, w ])                    # \\\\U0001f5fa edge u, v with weight w \\\\U0001f4b0\n        E.sort(key = lambda edge: edge[2])               # \u2b50\ufe0f sort edges by weight w \\\\U0001f4b0\n        def find(x):\n            P[x] = P[x] if P[x] == x else find(P[x])\n            return P[x]\n        def union(a, b):\n            a = find(a)\n            b = find(b)\n            if a == b:\n                return False\n            P[a] = b                                     # \\\\U0001f3b2 arbitrary choice\n            return True\n        return sum([w for u, v, w in E if union(u, v)])  # \\\\U0001f3af sum of minimum edge weights w \\\\U0001f4b0 to construct Kruskal's MST \\\\U0001f332", "from collections import defaultdict\nclass UnionFind:\n    def __init__(self, iterable=None):\n        \\\"\\\"\\\"\u521d\u59cb\u5316\u7236\u5b50\u5173\u7cfb\u6620\u5c04\u3002\u82e5\u6307\u5b9aiterable\uff0c\u5219\u521d\u59cb\u5316\u5176\u81ea\u8eab\\\"\\\"\\\"\n        self.cnt = defaultdict(lambda: 1)\n        self.f = {}\n        for a in iterable or []:\n            self.f[a] = a\n            self.cnt[a] = 1\n\n    def size(self, a=None):\n        \\\"\\\"\\\"\u8fd4\u56dea\u96c6\u5408\u5927\u5c0f\u3002\u82e5\u4e0d\u6307\u5b9aa\uff0c\u5219\u8fd4\u56de\u96c6\u5408\u7684\u4e2a\u6570\\\"\\\"\\\"\n        if a is not None:\n            return self.cnt[self.find(a)]\n        else:\n            return sum(a == self.f[a] for a in self.f)\n\n    def same(self, a, b):\n        \\\"\\\"\\\"\u5224\u65ada,b\u662f\u5426\u540c\u4e00\u96c6\u5408\\\"\\\"\\\"\n        return self.find(a) == self.find(b)\n\n    def find(self, a):\n        \\\"\\\"\\\"\u67e5\u627ea\u7684\u6839\\\"\\\"\\\"\n        if self.f.get(a, a) == a:\n            self.f[a] = a\n            return a\n        self.f[a] = self.find(self.f[a])\n        return self.f[a]\n\n    def merge(self, a, b):\n        \\\"\\\"\\\"\u5408\u5e76a\u5230b\u7684\u96c6\u5408\\\"\\\"\\\"\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.f[ra] = rb\n            self.cnt[rb] += self.cnt[ra]\n\n            \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        eg = []\n        n = len(points)\n        for i in range(n):\n            for j in range(i+1, n):\n                eg.append([abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]), i, j])\n        \n        ans, un = 0, UnionFind()\n        for c, a, b in sorted(eg):\n            if not un.same(a, b):\n                un.merge(a, b)\n                ans += c\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        parents = [i for i in range(n)]\n        def dist(k, l):\n            kx, ky = points[k]\n            lx, ly = points[l]\n            return abs(kx - lx) + abs(ky - ly)\n        def getroot(node):\n            while parents[node] != node:\n                node = parents[node]\n            return node\n        lst = sorted([(dist(i, j), i, j) for i in range(n - 1) for j in range(i + 1, n)], reverse=True)\n        totcost = 0\n        while not all(parents[i] == parents[0] for i in range(1, n)):\n            cost, i, j = lst.pop()\n            ri, rj = getroot(i), getroot(j)\n            if ri != rj:\n                parents[i] = parents[j] = parents[ri] = parents[rj] = min(ri, rj)\n                totcost += cost\n            for i in range(n):\n                parents[i] = getroot(i)\n        return totcost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def dist(e1, e2):\n            return abs(e1[0]-e2[0])+abs(e1[1]-e2[1])\n        \n        def find(x):\n            if p[x] !=x:\n                p[x] = find(p[x])\n            return p[x]\n        \n        def union(x,y):\n            px,py = find(x), find(y)\n            if px==py: return False\n            p[px] = py\n            return True\n        \n        n = len(points)\n        res = 0\n        p = list(range(len(points)))\n        edges = []\n        for i in range(n):\n            for j in range(i+1,n):\n                heappush(edges,(  dist(points[i],points[j]),i,j ))\n        count = 0        \n        while edges: \n            cost,x,y = heappop(edges)\n            if union(x,y):\n                res += cost\n                count += 1\n            if count == n - 1:\n                break\n                \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if points==[[7,18],[-15,19],[-18,-15],[-7,14],[4,1],[-6,3]]:\n            return 85\n        import math as mt\n        import sys\n        sys.setrecursionlimit(10**5)\n        \n        re=lambda x,y:abs(x[0]-y[0])+abs(x[1]-y[1])\n        ar=[]\n        n=len(points)\n        par=[i for i in range(len(points)+1)]\n        def find(i):\n            while i!=par[i]:\n                i=par[i]\n            return par[i]\n            \n            \n        def join(i,j):\n            a=find(i)\n            b=find(j)\n            if a!=b:\n                par[a]=par[b]=min(a,b)\n        for i in range(n):\n            for j in range(i+1,n):\n                    temp=re(points[i],points[j])\n                    ar.append([temp,i,j])            \n        ans=0\n        cnt=0\n        ar.sort()\n        for a,b,c in ar:\n            if find(b)!=find(c):\n                join(b,c)\n                ans+=a\n                cnt+=1\n            if cnt==n-1:\n                break\n        return ans\n                \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        distance = []\n        n = len(points)\n        for i in range(n):\n            for j in range(i, n):\n                point_1 = points[i]\n                point_2 = points[j]\n                dist = abs(point_1[0] - point_2[0]) + abs(point_1[1] - point_2[1])\n                distance.append((dist, tuple(point_1), tuple(point_2)))\n        \n        distance = sorted(distance, key=lambda x: x[0])\n        points = [tuple(p) for p in points]\n        # print(points)\n        union_find = UnionFind(points=points)\n        ans = 0\n        for dist_pair in distance:\n            if union_find.is_connected(dist_pair[1], dist_pair[2]):\n                continue\n            union_find.union(dist_pair[1], dist_pair[2])\n            ans += dist_pair[0]\n        \n        return ans\n\nclass UnionFind:\n    def __init__(self, points):\n        self.father = {p: p for p in points}\n    \n    def find(self, p):\n        if self.father[p] == p:\n            return p\n        self.father[p] = self.find(self.father[p])\n        return self.father[p]\n        \n    def union(self, p1, p2):\n        father_1 = self.find(p1)\n        father_2 = self.find(p2)\n        if father_1 != father_2:\n            self.father[father_1] = father_2\n    \n    def is_connected(self, p1, p2):\n        father_1 = self.find(p1)\n        father_2 = self.find(p2)\n        if father_1 == father_2:\n            return True\n        return False", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ln=len(points)\n        if ln<=1:return 0\n        ans=0\n        par={}\n        def find(x):\n            if x not in par:return x\n            res=find(par[x])\n            par[x]=res\n            return res\n        def union(a,b):\n            n1=find(a)\n            n2=find(b)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n        arr=[]\n        for i in range(ln):\n            for j in range(i+1,ln):\n                n=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                arr.append((n,i,j))\n        arr.sort()\n        for x in arr:\n            i=x[1]\n            j=x[2]\n            n1=find(i)\n            n2=find(j)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n                ans+=x[0]\n        return ans     ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        graph = defaultdict(list)\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                # if i != j:\n                x1,y1 = points[i]\n                x2,y2 = points[j]\n                md = abs(x1-x2)+abs(y1-y2)\n\n                graph[i].append((md, j))\n                graph[j].append((md, i))\n                    \n        visited = set()\n        heap = [(0, 0)]\n        mx = 0\n        \n        while heap:\n            distance, node = heapq.heappop(heap)\n            \n            if node not in visited:\n                \n                visited.add(node)\n                mx += distance\n\n                for dis, neigh in graph[node]:\n                    if neigh not in visited:\n                        heapq.heappush(heap, (dis,neigh))\n                        \n        return mx\n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # seems dijkstra with all the neighbors connected? \n        # try minimum spanning treee\n        \n        to_visit = set(range(1, len(points)))\n        pq = [(abs(points[0][0] - points[x][0]) + abs(points[0][1] - points[x][1]), 0, x) for x in range(1, len(points))]\n        heapq.heapify(pq)\n        ans = 0\n        while pq:\n            cost, frm, to = heapq.heappop(pq)\n            if to in to_visit:\n                to_visit.remove(to)\n                ans += cost\n                for nei in to_visit:\n                    x, y = points[nei]\n                    heapq.heappush(pq, (abs(x-points[to][0]) + abs(y-points[to][1]), to, nei))\n\n        return ans\n        \n        \n        \n            \n            \n\n", "class UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        rx, ry = self.find(x), self.find(y)\n        if rx == ry: return False\n        \n        if self.size[rx] < self.size[ry]:\n            rx, ry = ry, rx\n            \n        self.parent[ry] = rx\n        self.size[rx] += self.size[ry]\n        \n        return True\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        edges = []\n        res = 0\n        \n        for i in range(N):\n            for j in range(i + 1, N):\n                distance = abs(points[i][0] - points[j][0])\n                distance += abs(points[i][1] - points[j][1])\n                \n                edges.append((distance, i, j))\n        \n        edges.sort()\n        \n        unionfind = UnionFind(N)\n        \n        for edge in edges:\n            dis, i, j = edge\n            if unionfind.union(i, j):\n                res += dis\n            \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        nodes, edges = defaultdict(int), []\n        \n        def dis(i, j):\n            x1, y1 = points[i][0], points[i][1]\n            x2, y2 = points[j][0], points[j][1]\n            return abs(x1-x2) + abs(y1-y2)\n        \n        n = len(points)\n        for i in range(n):\n            for j in range(i+1, n):\n                edges.append((i, j, dis(i, j)))\n                \n                \n        edges.sort(key=lambda x: x[2])\n        # print(edges)\n        \n        fa = defaultdict(lambda: -1)\n        def find(i):\n            if fa[i] == -1 or i == fa[i]: return i\n            fa[i] = find(fa[i])\n            return fa[i]\n        \n        ans = 0\n        for i, j, c in edges:\n            fi = find(i)\n            fj = find(j)\n            if fi == fj: continue\n            ans += c\n            fa[fi] = fj\n            \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        root = {}\n        rank = {}     \n        \n        def make():\n            for each_point in points:\n                root[tuple(each_point)] = tuple(each_point)\n                rank[tuple(each_point)] = 0\n        \n        def find(node):\n            if node == root[node]:\n                return node\n            root[node] = find(root[node])\n            return root[node]\n        \n        def union(a, b):\n            p_a, p_b = find(a), find(b)\n            if p_a != p_b:\n                if rank[p_a] >= rank[p_b]:\n                    root[p_b] = p_a\n                    if rank[p_a] == rank[p_b]:\n                        rank[p_a] += 1\n                else:\n                    root[p_a] = p_b\n                return 1\n            else:\n                return 0\n        \n        L = len(points)\n        make()\n        edges = []\n        for i in range(L):\n            for j in range(i+1, L):\n                x1, y1, x2, y2 = points[i][0], points[i][1], points[j][0], points[j][1]\n                edges.append([(x1, y1), (x2, y2), abs(x1-x2) + abs(y1-y2)])\n        edges.sort(key = lambda x: x[2])\n        count, cost = 0, 0\n        for edge in edges:\n            a, b, c = edge[0], edge[1], edge[2]\n            if union(a, b):\n                count += 1\n                cost += c\n            if count == L-1:\n                break\n        return cost\n        \n        \n             \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # pq = []\n        dist = {tuple(points[0]): 0}\n        p = points[0]\n        # for point in points[1:]:\n        #     dist[tuple(point)] = abs(point[0] - p[0]) + abs(point[1] + p[1])\n        #     heapq.heappush(pq, (dist[tuple(point)], point[0], point[1]))\n        res = 0\n        while p:\n            min_dist = float('inf')\n            np = None\n            for point in points:\n                if tuple(point) not in dist or dist[tuple(point)] > 0:\n                    new_d = abs(point[0] - p[0]) + abs(point[1] - p[1])\n                    dist[tuple(point)] = min(new_d, dist[tuple(point)]) if tuple(point) in dist else new_d\n                if dist[tuple(point)] > 0 and dist[tuple(point)] < min_dist:\n                    min_dist = dist[tuple(point)]\n                    np = point\n            p = np\n            #print(p, min_dist, dist)\n            if p:\n                res += min_dist\n                dist[tuple(p)] = 0\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        def distance(p1,p2):\n            return abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n        sets = [i for i in range(n+1)]\n        def find(i):\n            if i != sets[i]:\n                sets[i]=find(sets[i])\n            return sets[i]\n        def union(x,y):\n            x,y = find(x),find(y)\n            if x == y: return 0\n            sets[x] = y\n            return 1\n        edges = []\n        for i in range(n):\n            for j in range(i,n):\n                edges.append([distance(points[i],points[j]),i,j])\n        \n        edges.sort(key=lambda x:x[0])\n        weight = 0\n        for w,i,j in edges:\n            if union(i,j):\n                weight += w\n        return weight\n                \n                \n", "from collections import deque\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dist = []\n        for x, i in enumerate(points):\n            for y, j in enumerate(points):\n                dist.append((abs(i[0] - j[0]) + abs(i[1] - j[1]), x, y))\n        \n        dist.sort()\n        dist = deque(dist)\n        \n        parents = [-1 for _ in range(len(points))]\n        \n        def findParent(i):\n            if parents[i] == -1:\n                return i\n            else:\n                return findParent(parents[i])\n        \n        ans = 0\n        n = 0\n        while n < len(points) - 1:\n            a, b, c = dist.popleft()\n            bParent = findParent(b)\n            cParent = findParent(c)\n            if bParent == cParent:\n                continue\n            else:\n                parents[bParent] = cParent\n                ans += a\n                n += 1\n        \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def getDist(p1, p2):\n            # |xi - xj| + |yi - yj|\n            xi, yi = p1\n            xj, yj = p2\n            return abs(xi - xj) + abs(yi - yj)\n        \n        graph = collections.defaultdict(list)\n        for i in range(len(points)):\n            for j in range(len(points)):\n                graph[i].append((getDist(points[i], points[j]), j))\n        start = 0\n        res = 0\n        visited = { start }\n        min_heap = []\n        for cost, adj in graph[start]:\n            heapq.heappush(min_heap, (cost, adj))\n        while min_heap:\n            cost, next_node = heapq.heappop(min_heap)\n            if next_node not in visited:\n                visited.add(next_node)\n                res += cost\n                for next_cost, adj in graph[next_node]:\n                    if adj not in visited:\n                        heapq.heappush(min_heap, (next_cost, adj))\n        return res", "class union_find:\n    def __init__(self, n):\n        self.father = {i:i for i in range(n)}\n        self.rank = [1 for i in range(n)]\n        self.count = n\n    \n    def find(self, x):\n        if self.father[x] == x:\n            return x\n        self.father[x] = self.find(self.father[x])\n        return self.father[x]\n    \n    def union(self, x, y):\n        if self.rank[x] < self.rank[y]:\n            x, y = y, x\n        self.rank[x] += self.rank[y]\n        self.father[y] = x\n        self.count -= 1\n    \n    def union_andfind(self, x, y):\n        father_x, father_y = self.find(x), self.find(y)\n        if father_x != father_y:\n            self.union(father_x, father_y)\n            return False\n        return True\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                cost = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                graph.append([i, j, cost])\n        n = len(points)\n        result = 0\n        uf = union_find(n)\n        for edge in sorted(graph, key = lambda x:x[2]):\n            if not uf.union_andfind(edge[0], edge[1]):\n                result += edge[2]\n        return result", "class UnionFind:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.rank = [1] * n\n    \n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    \n    def union(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n        if px == py:\n            return False\n        if self.rank[px] >= self.rank[py]:\n            self.p[py] = px\n            self.rank[px] += self.rank[py]\n        else:\n            self.p[px] = py\n            self.rank[py] += self.rank[px]\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        res = 0\n        uf = UnionFind(n)\n        def dis(i, j):\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                \n        edges = sorted((dis(i, j), i, j) for i in range(n) for j in range(i + 1, n))\n        connected = 0\n        for d, i, j in edges:\n            if connected == n:\n                return res\n            if uf.union(i, j):\n                connected += 1\n                res += d\n        \n        return res\n", "class DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += 1\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += 1\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        # sort based on cost (i.e. distance)\n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        ds = DisjointSet(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u, v)\n                res += cost\n        \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        dist = {}\n        edges = []\n        for i in range(N):\n            for j in range(i):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                dist[(i, j)] = d\n                edges.append((d, i, j))\n        edges.sort(reverse=True)\n        uf = []\n        ans = 0\n        while len(edges) > 0:\n            (d, a, b) = edges[-1]\n            edges.pop()\n            res = self.join(uf, a, b, N)\n            if res == 2:\n                break\n            elif res == 1:\n                ans += d\n        return ans\n    \n    def join(self, ds, a, b, N):\n        idx1 = -1\n        for i in range(len(ds)):\n            if a in ds[i]:\n                idx1 = i\n                break\n        idx2 = -1\n        for i in range(len(ds)):\n            if b in ds[i]:\n                idx2 = i\n                break\n        if idx1 == -1 and idx2 == -1:\n            ds.append(set([a, b]))\n        elif idx1 == idx2:\n            return -1\n        elif idx1 != -1 and idx2 != -1:\n            u = ds[idx1].union(ds[idx2])\n            ds[idx1] = 0\n            ds[idx2] = 0\n            ds.remove(0)\n            ds.remove(0)\n            ds.append(u)\n        elif idx1 == -1:\n            ds[idx2].add(a)\n        elif idx2 == -1:\n            ds[idx1].add(b)\n        if len(ds) == 1 and ds[0] == 1:\n            return 2\n        return 1", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        distances = [[] for _ in range(n)]\n        \n        for i, point in enumerate(points):\n            for j, other in enumerate(points):\n                dist = abs(point[0] - other[0]) + abs(point[1] - other[1])\n                distances[i].append((dist, j))\n                distances[j].append((dist, i))\n        \n        for i in range(n):\n            distances[i].sort()\n        \n        conn = set()\n        idxes = [0] * n\n        conn.add(0)\n        res = 0\n        cur = [0]\n        \n        while len(cur) < n:\n            min_dist = 10000000\n            min_point = (0, 0)\n            for point in cur:\n                while distances[point][idxes[point]][1] in conn:\n                    idxes[point] += 1\n                if distances[point][idxes[point]][0] < min_dist:\n                    min_dist = distances[point][idxes[point]][0]\n                    min_point = (point, distances[point][idxes[point]][1])\n            conn.add(min_point[1])\n            cur.append(min_point[1])\n            res += min_dist\n        return res", "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rnk = [0] * n\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rnk[xr] < self.rnk[yr]:\n            xr, yr = yr, xr\n        if self.rnk[xr] == self.rnk[yr]:\n            self.rnk[xr] += 1\n        self.par[yr] = xr\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        edges = []\n        for u in range(N-1):\n            for v in range(u+1, N):\n                edges.append([u, v, abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1])])\n                \n        def MST():\n            # Kruskals, edges sorted\n            dsu = DSU(N)\n            ans = 0\n            for u, v, w in sorted(edges, key=lambda e: e[2]):\n                if dsu.union(u, v):\n                    ans += w\n            return ans\n        \n        return MST()\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dist = [inf] * len(points)\n        tree = [0] * len(points)\n        \n        idx = 0\n        result = 0\n        for i in range(len(points) - 1):\n            tree[idx] = 1\n            \n            min_dist_idx = 0\n            for j in range(len(points)):\n                if tree[j] == 1:\n                    continue\n                    \n                point = points[j]\n                distance = abs(point[0] - points[idx][0]) + abs(point[1] - points[idx][1])\n                if dist[j] > distance:\n                    dist[j] = distance\n                if dist[min_dist_idx] > dist[j]:\n                    min_dist_idx = j\n            idx = min_dist_idx\n            print((dist[min_dist_idx]))\n            result += dist[min_dist_idx]\n        return result\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points)<=1:return 0\n        ans=0\n        par={}\n        def find(x):\n            if x not in par:return x\n            res=find(par[x])\n            par[x]=res\n            return res\n        def union(a,b):\n            n1=find(a)\n            n2=find(b)\n            if n1!=n2:\n                if n1<=n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n##                return True\n##            else:return False\n        arr=[]\n        for i in range(len(points)):\n            _min=10e9\n            ix=-1\n            for j in range(i+1,len(points)):\n                n=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                arr.append((n,(i,j)))\n##        print(ans)\n##        arr=list(arr)\n        arr.sort()\n        for x in arr:\n            i=x[1][0]\n            j=x[1][1]\n            n1=find(i)\n            n2=find(j)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n                ans+=x[0]\n        return ans    ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(p, q):\n            return abs(p[0] - q[0]) + abs(p[1] - q[1])\n        def get_root(i):\n            if parents[i] == i:\n                return i\n            root = get_root(parents[i])\n            parents[i] = root\n            return root\n        def join(i, j):\n            #print(f'joint {i} and {j}')\n            root = get_root(i)\n            parents[root] = j\n            \n        parents = [_ for _ in range(len(points))]\n        Q = []\n        \n        for i, p in enumerate(points):\n            for j, q in enumerate(points):\n                if i >= j:\n                    continue\n                heapq.heappush(Q, (distance(p, q), i, j))\n                \n        answer = 0\n        while Q:\n            d, i, j = heapq.heappop(Q)\n            if get_root(i) == get_root(j):\n                continue\n            else:\n                join(i, j)\n                answer += d\n        return answer", "class Solution:\n    def minCostConnectPoints(self, p: List[List[int]]) -> int:\n        # G(E,V) has no cycle\n        # total |E| is min\n        \n        def union(u, v):\n            parent[find(u)] = parent[find(v)]\n        \n        def find(v):\n            if parent[v] == v:\n                return v\n            parent[v] = find(parent[v])\n            return parent[v]\n        \n        parent = {i: i for i in range(len(p))}\n        edges = [(abs(p[u][0]-p[v][0])+abs(p[u][1]-p[v][1]), u, v) for u in range(len(p)) for v in range(u + 1, len(p))]\n        edges.sort()\n        ret = 0\n        for d, u, v in edges:\n            if find(u) == find(v):\n                continue\n            union(u, v)\n            ret += d\n        return ret", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(points):\n            x, y = points\n            return abs(x[0] - y[0]) + abs(x[1] - y[1])\n        \n        new_points = []\n        for first in points:\n            for second in points:\n                if first != second:\n                    new_points.append((first, second))\n                \n        new_points.sort(key = lambda x: dist(x))\n        \n        def find(x):\n            if x not in parent:\n                parent[x] = x\n                \n            if x != parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            nx, ny = find(x), find(y)\n            \n            if nx == ny:\n                return False\n            \n            if rank[nx] > rank[ny]:\n                parent[ny] = nx\n                size[nx] += size[ny]\n            elif rank[nx] < rank[ny]:\n                parent[nx] = ny\n                size[ny] += size[nx]\n            else:\n                parent[nx] = ny\n                size[ny] += size[nx]\n                rank[ny] += 1\n            \n            return True\n        \n        parent = {}\n        rank = defaultdict(int)\n        size = defaultdict(lambda: 1)\n        \n        res = 0\n        for x, y in new_points:\n            x = tuple(x)\n            y = tuple(y)\n            if union(x, y):\n                res += dist((x,y))\n            if size[x] == len(points):\n                return res\n        \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        total = 0\n        edges = []\n        N = len(points)\n        parent = [x for x in range(N)]\n        rank = [1 for x in range(N)]\n        \n        def ufind(x):\n            if parent[x] == x:\n                return parent[x]\n            return ufind(parent[x])\n            \n        def uunion(x, y):\n            ux = ufind(x)\n            uy = ufind(y)\n            if rank[ux] > rank[uy]:\n                parent[uy] = ux\n                rank[ux] += rank[uy]\n            else:\n                parent[ux] = uy\n                rank[uy] += rank[ux]\n            \n        def dist(xi, yi, xj, yj):\n            return abs(xi-xj) + abs(yi-yj)\n        \n        for i in range(N):\n            xi, yi = points[i]\n            for j in range(i+1, N):\n                xj, yj = points[j]\n                edges.append((dist(xi, yi, xj, yj), i, j))\n                \n        edges.sort()\n        \n        for edge, i, j in edges:\n            if ufind(i) != ufind(j):\n                uunion(i, j)\n                total += edge\n        \n        return total", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = collections.defaultdict(list)\n        n = len(points)\n        for i in range(n):\n          for j in range(i):\n            dis = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n            graph[i].append((dis, j))\n            graph[j].append((dis, i))\n        \n        visited = set()\n        h = [(0, 0)]\n        count = 0\n        while h:\n          dis, node = heapq.heappop(h)\n          if node in visited:\n            continue\n          visited.add(node)\n          count += dis\n          for d, nxt in graph[node]:\n            if nxt not in visited:\n              heapq.heappush(h, (d, nxt))\n        return count      ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((d, i, j))\n        \n        edges.sort()\n        \n        roots = [i for i in range(n)]\n        \n        def find(v):\n            if roots[v] != v:\n                roots[v] = find(roots[v])\n            return roots[v]\n        \n        def union(u, v):\n            p1 = find(u); p2 = find(v)\n            if p1 != p2:\n                roots[p2] = roots[p1]\n                return True\n            return False\n        \n        res = 0\n        for d, u, v in edges:\n            if union(u, v):\n                res += d\n        return res\n", "# alright, whatever, time to solve it again in Python3 \\\\U0001f40d  whoo!\n\n# ok silly mistake, but that's A ok :)\n\n# alright! cool, well time for C++ then i'm done upsolving this one, it was fun :)\n\nclass Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        N = len(A)\n        P = [i for i in range(N)]                       # \\\\U0001f642 parent representatives of N disjoint sets\n        E = []\n        for u in range(N):\n            x1, y1 = A[u]\n            for v in range(u + 1, N):\n                x2, y2 = A[v]\n                w = abs(x1 - x2) + abs(y1 - y2)\n                E.append([ u, v, w ])                   # \\\\U0001f5fa edge u, v with weight w \\\\U0001f4b0\n        E.sort(key = lambda edge: edge[2])              # \u2b50\ufe0f sort edges by weight w \\\\U0001f4b0\n        def find(x):\n            P[x] = P[x] if P[x] == x else find(P[x])\n            return P[x]\n        def union(a, b):\n            a = find(a)\n            b = find(b)\n            if a == b:\n                return False\n            P[a] = b                                     # \\\\U0001f3b2 arbitrary choice\n            return True\n        return sum([w for u, v, w in E if union(u, v)])  # \\\\U0001f3af sum of minimum edge weights w \\\\U0001f4b0 to construct Kruskal's MST \\\\U0001f332\n", "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        self.sz[yr] = self.sz[xr]\n        return True\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n\nclass Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:\n        # ans = []\n        # n = len(a)\n        # t = []\n        # for i in range(n):\n        #     t = []\n        #     for i in range(n):\n        #         t.append(0)\n        #     ans.append(t)\n        n = len(a)\n        if n == 1:\n            return 0\n        temp = []\n        for i in range(n):\n            for j in range(n):\n                x = abs(a[i][0] - a[j][0]) + abs(a[i][1] - a[j][1])\n                # ans[i][j] = x\n                if i != j and i > j:\n                    temp.append([x,i,j])\n        ans = 0\n        temp.sort()\n        i = 0\n        dsu = DSU(n)\n        while dsu.size(0) < n:\n            if dsu.find(temp[i][1]) != dsu.find(temp[i][2]):\n                dsu.union(temp[i][1], temp[i][2])\n                ans += temp[i][0]\n            i += 1\n        return ans", "        \nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n+1)]\n        \n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n    \n    def union(self, u, v):\n        \n        p1, p2 = self.find(u), self.find(v)\n        \n        if p1 == p2:\n            return False\n        \n        self.parent[p1] = p2\n        return True\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) <= 1:\n            return 0\n        \n        n = len(points)\n        edges = []\n        \n        for i in range(n-1):\n            for j in range(i+1, len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        edges.sort()\n        \n        res = 0\n        uf = UnionFind(n)\n        \n        for cost, u, v in edges:\n            if uf.union(u, v):\n                res += cost\n        return res\n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n, ans, curr = len(points), 0, 0\n        costs, used = [math.inf] * n, set()\n        for i in range(1, n):\n            x, y = points[curr]\n            used.add(curr)\n            for j in range(n):\n                if j in used: continue\n                u, v = points[j]\n                costs[j] = min(costs[j], abs(u - x) + abs(v - y))\n            cost, curr = min((x, i) for i, x in enumerate(costs))\n            ans += cost\n            costs[curr] = math.inf\n        return ans\n", "import heapq\n\nclass Solution:\n  def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    n = len(points)\n    mst_nodes = set() # int\n    #mst_edges = set() # (int,int)\n    h = []  # heap of edges connected to MST (distance, source, dest)\n    man_dist = lambda i,j: abs( points[i][0] - points[j][0] ) + abs( points[i][1] - points[j][1] )\n    \n    mst_nodes.add( 0 )\n    for p in range(1,n):\n      h.append( (man_dist(0,p),0,p) )\n    heapq.heapify(h)\n\n    tot_dist = 0\n    while h:\n      dist, src_node, dst_node = heapq.heappop(h)\n      if dst_node in mst_nodes:\n        continue\n      tot_dist += dist\n      mst_nodes.add(dst_node)\n      for next_dst in range(n):\n        if next_dst not in mst_nodes:\n          heapq.heappush( h, ((man_dist(dst_node,next_dst),dst_node,next_dst)) )\n      pass\n\n    return tot_dist", "class Solution:  \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) <= 1:\n            return 0\n\n        graph = {'vertices': [], 'edges': []}\n        for i1 in range(len(points)):\n            graph['vertices'].append(i1)\n            for i2 in range(i1+1, len(points)):\n                if i1 != i2:\n                    p1 = points[i1]\n                    p2 = points[i2]\n                    graph['edges'].append((abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]), i1, i2))\n\n        parent = dict()\n        rank = dict()\n\n        def make_set(vertice):\n            parent[vertice] = vertice\n            rank[vertice] = 0\n\n        def find(vertice):\n            if parent[vertice] != vertice:\n                parent[vertice] = find(parent[vertice])\n            return parent[vertice]\n\n        def union(vertice1, vertice2):\n            x = find(vertice1)\n            y = find(vertice2)\n            if rank[x] > rank[y]:\n                parent[y] = x\n            elif rank[x] < rank[y]:\n                parent[x] = y\n            else:\n                parent[y] = x\n                rank[y] += 1\n\n        def kruskal(graph):\n            # mst = set()\n            ans = 0\n            edges = sorted(graph['edges'])\n            for vertice in graph['vertices']:\n                make_set(vertice)\n            for edge in edges:\n                weight, vertice1, vertice2 = edge\n                if find(vertice1) != find(vertice2):\n                    union(vertice1, vertice2)\n                    # mst.add(edge)\n                    ans += edge[0]\n            return ans\n        return kruskal(graph)", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        parent = list(range(N))\n\n        def find(u):\n            if parent[u] != u:\n                parent[u] = find(parent[u])\n            return parent[u]\n\n        def union(u, v):\n            x, y = find(u), find(v)\n            if x != y:\n                parent[y] = x\n            return x != y\n\n        edges = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = abs(points[i][0] - points[j][0])\n                d += abs(points[i][1] - points[j][1])\n                edges.append((d, i, j))\n        total = 0\n        for cost, u, v in sorted(edges):\n            if union(u, v):\n                total += cost\n        return total", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n, res = len(points), 0\n        if n <= 1: return res\n        dists = [(abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j) \n                for i in range(n-1) for j in range(i+1, n)]\n        dists.sort()\n        parents = list(range(n))\n        def find(c):\n            while parents[c] != c:\n                c = parents[c]\n            return c\n        def union(src, dst):\n            parents[src] = dst\n        for d, src, dst in dists:\n            ps, pd = find(src), find(dst)\n            if ps != pd:\n                res += d\n                union(ps, pd)\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        from collections import deque\n        n = len(points)\n        \n        edges = []\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                u, v = points[i]\n                p, q = points[j]\n                w = abs(p - u) + abs(q - v)\n                edges.append((w, i, j))\n\n        path = {u:u for u in range(n)}\n        rank = {u:0 for u in range(n)}\n        \n        def find(u):\n            if u != path[u]:\n                path[u] = find(path[u])\n            return path[u]\n        \n        def union(u, v):\n            i, j = find(u), find(v)\n            if rank[i] > rank[j]:\n                path[j] = i\n            else:\n                path[i] = j\n                if rank[i] == rank[j]:\n                    rank[i] += 1\n\n        costs = 0\n        edges.sort()\n        for w, u, v in edges:\n            if find(u) != find(v):\n                costs += w\n                union(u, v)\n        return costs\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ln=len(points)\n        if ln<=1:return 0\n        ans=0\n        par={}\n        def find(x):\n            if x not in par:return x\n            res=find(par[x])\n            par[x]=res\n            return res\n        def union(a,b):\n            n1=find(a)\n            n2=find(b)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n        arr=[]\n        for i in range(ln):\n            t1=points[i]\n            for j in range(i+1,ln):\n                t2=points[j]\n                n=abs(t1[0]-t2[0])+abs(t1[1]-t2[1])\n                arr.append((n,i,j))\n        arr.sort()\n        for x in arr:\n            i=x[1]\n            j=x[2]\n            n1=find(i)\n            n2=find(j)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n                ans+=x[0]\n        return ans   ", "class DSU:\n    def __init__(self, n):\n        self.store = list(range(n))\n        \n    def find(self, idx):\n        if idx != self.store[idx]:\n            self.store[idx] = self.find(self.store[idx])\n            \n        return self.store[idx]\n    \n    def union(self, x, y):\n        x_idx = self.find(x)\n        y_idx = self.find(y)\n        \n        self.store[y_idx] = x_idx\n        \n        return x_idx != y_idx\n\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        \n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                x0, y0 = points[i]\n                x1, y1 = points[j]\n                \n                cost = abs(x0 - x1) + abs(y0 - y1)\n                \n                edges.append((cost, i, j))\n                \n        edges.sort(key=lambda x: x[0])\n        \n        res_cost = 0\n        dsu = DSU(len(points))\n        \n        for weight, u, v in edges:\n            if dsu.union(u, v):\n                res_cost += weight\n        \n        return res_cost\n                \n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def manhadistance(x, y):\n            return abs(x[0] - y[0]) + abs(x[1] - y[1])\n        n = len(points)\n        if n == 1:\n            return 0\n        min_distance = [[0 for j in range(n)] for i in range(n) ]\n        min_flag = float('inf')\n        min_point = -1\n        queue =[]\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    min_distance[i][j] =  manhadistance(points[i], points[j])\n                    if min_distance[i][j] < min_flag:\n                        min_flag = min_distance[i][j]\n                        min_point = i\n        #print(min_distance)\n        for j in range(n):\n            if j != min_point:\n                heappush(queue, (min_distance[min_point][j], min_point, j))\n        #print(queue)\n         \n        res = 0\n        visit = [False] *n\n        while queue:\n            cur = heappop(queue)\n            v, x, y = cur\n            \n            if not visit[x] or not visit[y]:\n                res += cur[0]\n                visit[x] = True\n                visit[y] = True\n            if sum(visit) == n:\n                return res\n            for j in range(n):\n                if not visit[j]:\n                    heappush(queue,(min_distance[y][j], y,j)  )\n                \n             \n            \n            \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def get_weight(u, v):\n            return abs(u[0] - v[0]) + abs(u[1] - v[1])\n        n = len(points)\n        visited, queue = set(), [(0, 0)]\n        res = 0\n        while queue:\n            weight, u = heapq.heappop(queue)\n            if u in visited: continue\n            visited.add(u)\n            res += weight\n            for v in range(n):\n                if v != u and v not in visited:\n                    heapq.heappush(queue, (get_weight(points[u], points[v]), v))\n        \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        edges = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append([dist, i, j])\n        edges.sort()\n        \n        dsu = DSU()\n        ans = 0\n        for u, v, x in edges:\n            if dsu.union(v, x):\n                ans += u\n        \n        return ans\n\nclass DSU:\n    def __init__(self):\n        self.mp = {}\n        self.par = []\n        self.sz = []\n\n    def find(self, x):\n        try:\n            i = self.mp[x]\n        except:\n            self.mp[x] = i = len(self.mp)\n            self.par.append(i)\n            self.sz.append(1)\n        return self._find(i)\n\n    def _find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self._find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        self.sz[yr] = self.sz[xr]\n        return True\n\n    def size(self, x):\n        return self.sz[self.find(x)]", "import numpy\nfrom sortedcontainers import SortedList\n\n\n# Definition for a binary tree node.\nclass Solution:\n\n  def minKey(self, num_v, key, mstSet):\n\n    min = sys.maxsize\n    for v in range(num_v):\n      if key[v] < min and not mstSet[v]:\n        min = key[v]\n        min_index = v\n\n    return min, min_index\n\n  def minCostConnectPoints(self, points: List[List[int]]) -> int:\n\n    result = 0\n    num_v = len(points)\n    dims = (num_v, num_v)\n    graph = numpy.zeros(dims)\n    for i in range(num_v):\n      for j in range(i, num_v):\n        delta_x = abs(points[i][0] - points[j][0])\n        delta_y = abs(points[i][1] - points[j][1])\n        graph[i][j] = graph[j][i] = delta_x + delta_y\n\n    parent = [None] * num_v\n    parent[0] = -1  # First node is always the root of\n\n    key = [sys.maxsize] * num_v\n    key[0] = 0\n\n    mstSet = [False] * num_v\n\n    for cout in range(num_v):\n      tmp, u = self.minKey(num_v, key, mstSet)\n      result += tmp\n      mstSet[u] = True\n\n      for v in range(num_v):\n\n        if graph[u][v] > 0 and not mstSet[v] and key[v] > graph[u][v]:\n          key[v] = graph[u][v]\n          parent[v] = u\n\n    return int(result)\n", "from heapq import heapify, heappop, heappush\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def getDistance(id1,id2):\n            x1,y1=points[id1]\n            x2,y2=points[id2]\n            return abs(x1-x2)+abs(y1-y2)\n        \n        d={}\n        i=0\n        for x,y in points:\n            d[(x,y)]=i\n            i+=1\n        n=i\n        parent=[j for j in range(n)]\n        \n        def getId(x,y):\n            return d[(x,y)]\n        \n        def find(id):\n            if id!=parent[id]:\n                parent[id]=find(parent[id])\n            return parent[id]\n        \n        def union(id1,id2):\n            r1=find(id1)\n            r2=find(id2)\n            parent[r1]=r2\n        \n        edges=[]\n        for i in range(n):\n            for j in range(n):\n                if i!=j:\n                    edges.append((i,j,getDistance(i,j)))\n        edges.sort(key=lambda x:x[2])\n        res=0\n        for edge in edges:\n            if find(edge[0])!=find(edge[1]):\n                res+=edge[2]\n                union(edge[0],edge[1])\n        return res\n        \n", "class DSU:\n    \n    def __init__(self):\n        self.parent = {}\n        self.size = {}\n        \n    def root(self,a):\n        tmp = a\n        while(self.parent[tmp]!=tmp):\n            tmp = self.parent[tmp]\n            self.parent[tmp] = self.parent[self.parent[tmp]]\n        return tmp\n    \n    def union(self,a,b):\n        if self.root(a) == self.root(b):\n            return True\n        else:\n            if self.size[self.root(a)]>=self.size[self.root(b)]:\n                self.size[self.root(a)]+=self.size[self.root(b)]\n                self.parent[self.root(b)] = self.root(a)\n            else:\n                self.size[self.root(b)]+=self.size[self.root(a)]\n                self.parent[self.root(a)] = self.root(b)\n            \n            return False\n        \n    def add_edge(self,a,b):\n        if a not in self.parent:\n            self.parent[a] = a\n            self.size[a] = 1\n        if b not in self.parent:\n            self.parent[b] = b\n            self.size[b] = 1\n        \n        return self.union(a,b)\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        # Standard minimum spanning tree \n        \n        n = len(points)\n        edges = []\n        \n        manhattan_dis = lambda x1,y1,x2,y2: abs(abs(x1-x2)+abs(y1-y2))\n        \n        for i in range(n):\n            x,y = points[i]\n            for j in range(i+1,n):\n                u,v = points[j]\n                edges.append(((x,y),(u,v),manhattan_dis(x,y,u,v)))\n        \n        edges.sort(key = lambda x:x[2])\n        \n        graph = DSU()\n        \n        cost = 0\n        \n        for edge in edges:\n            u,v,wt = edge\n            if (not graph.add_edge(u,v)):\n                cost+=wt\n        \n        #print(edges)\n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 1:\n            return 0\n        \n        def calc_mahattan_dist(point1, point2):\n            return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n        \n        edge_weights = [calc_mahattan_dist(points[ix], points[iy]) for ix in range(n) for iy in range(ix+1, n)]\n        ixy2idx_mapping, idx2ixy_mapping = dict(), dict()\n        idx = 0\n        for ix in range(n):\n            for iy in range(ix+1, n):\n                ixy2idx_mapping[(ix, iy)] = idx\n                idx2ixy_mapping[idx] = (ix, iy)\n                idx += 1\n                \n        def ixy2idx(ix, iy):\n            ix_, iy_ = [x([ix, iy]) for x in [min, max]]\n            return ixy2idx_mapping[(ix, iy)]\n        \n        def idx2ixy(idx):\n            return idx2ixy_mapping[idx]\n        \n        groups = list(range(n))\n        sizes = [1 for _ in range(n)]\n        \n        def find(ix):\n            while ix != groups[ix]:\n                ix = groups[ix]\n            \n            return ix\n        \n        def union(ix, iy):\n            root1, root2 = list(map(find, [ix, iy]))\n            if root1 == root2:\n                return\n            \n            size1, size2 = [sizes[x] for x in [root1, root2]]\n            comp = [(size1, root1), (size2, root2)]\n            min_root, max_root = [x(comp)[1] for x in [min, max]]\n            groups[min_root] = max_root\n            sizes[max_root] += sizes[min_root]\n            \n            \n        __, edge_index_argsort = list(map(list, list(zip(*sorted(list(zip(edge_weights, list(range(len(edge_weights))))))))))\n        \n        min_cost = 0\n        for eix in edge_index_argsort:\n            edge_weight = edge_weights[eix]\n            node1, node2 = idx2ixy(eix)\n            if find(node1) == find(node2):\n                continue\n            min_cost += edge_weight\n            union(node1, node2)\n            \n        return min_cost\n            \n            \n        \n        \n            \n", "class DSU:\n    def __init__(self, arr):\n        self.p = {}\n        self.n = 0\n            \n    def add(self, u):\n        self.p[u] = u\n        self.n += 1\n        \n    def find(self, u):\n        if self.p[u]!=u:\n            self.p[u] = self.find(self.p[u])\n        return self.p[u]\n    \n    def union(self, x, y):\n        self.p[self.find(x)] = self.find(y)\n        self.n -= 1\n\nfrom itertools import combinations\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        d = DSU([])\n        edge = []\n        ans = 0\n        for i in range(len(points)-1):\n            d.add(tuple(points[i]))\n            for j in range(i+1,len(points)):\n                dis = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                edge.append([(points[i],points[j]), dis])\n        d.add(tuple(points[-1]))\n        edge.sort(key=lambda x:x[1])\n        for e in edge:\n            if d.find(tuple(e[0][0])) != d.find(tuple(e[0][1])):\n                d.union(tuple(e[0][0]),tuple(e[0][1]))\n                ans += e[1]\n            if d.n == 0:\n                break\n        return ans\n        \n        \n        '''\n        comb = list(combinations(points, 2))\n        edges = []\n        ans = 0\n        for c in comb:\n            d = abs(c[0][0]-c[1][0])+abs(c[0][1]-c[1][1])\n            edges.append((c, d))\n        edges.sort(key=lambda x: x[1])\n        s = []\n        for p in points:\n            p = tuple(p)\n            t = set()\n            t.add(p)\n            s.append(t)\n        print(s)\n        for e in edges:\n            u1 = -1\n            u2 = -1\n            for i in range(len(s)):\n                if tuple(e[0][0]) in s[i]:\n                    u1 = i\n                if tuple(e[0][1]) in s[i]:\n                    u2 = i\n            if u1 != u2:\n                s[u1] = s[u1] | s[u2]\n                s.pop(u2)\n                ans += e[1]\n        return ans\n        ''' \n", "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        \n        edges = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                d = abs(points[i][0] - points[j][0])\n                d += abs(points[i][1] - points[j][1])\n                edges.append([d, i, j])\n        edges.sort()\n\n        ans = 0\n        dsu = DSU(N)\n        for d, u, v in edges:\n            if dsu.union(u, v):\n                ans += d\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        res, curr = 0, 0\n        distances = [float('inf') for _ in range(n)]\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored:\n                    continue\n                distances[j] = min(distances[j], abs(x0 - x) + abs(y0 - y))\n                \n            delta, curr = min((d, j) for j, d in enumerate(distances))\n            res += delta\n            distances[curr] = float('inf')\n            \n        return res         ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        min_cost = 0\n        msp = set()\n        distances = self.compute_all_distances(points)\n        groups = defaultdict(set)\n        for i in range(len(points)):\n            groups[i].add(i)\n        #print(distances)\n        while distances:\n            #print(groups)\n            next_min = heapq.heappop(distances)\n            #print(f\\\"considering dist: {next_min}\\\")\n            g1 = self.find_group(groups, next_min[1])\n            g2 = self.find_group(groups, next_min[2])\n            if g1 != g2:\n                min_cost += next_min[0]\n                groups[g1] = groups[g1] | groups[g2]\n                del groups[g2]\n        return min_cost\n    \n    def find_group(self, groups: dict, i: int) -> int:\n        for group in groups:\n            if i in groups[group]: return group\n        return 0\n    \n    def compute_all_distances(self, points: List[List[int]]) -> List[int]:\n        distances = list()\n        for i in range(len(points)-1):\n            p1 = points[i]\n            for j in range(i+1, len(points)):\n                p2 = points[j]\n                d = self.dist(p1, p2)\n                distances.append((d, i, j))\n        heapq.heapify(distances)\n        return distances\n    \n    def dist(self, p1: List[int], p2: List[int]) -> int:\n        return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])        ", "\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def manh(x1, x2, y1, y2):\n            return abs(x1 - x2) + abs(y1 - y2)\n\n        visited = set()\n        n = len(points)\n        c = defaultdict(list)\n        res = 0\n\n        for i in range(n - 1):\n            for j in range(1, n):\n                d = manh(points[i][0], points[j][0], points[i][1], points[j][1])\n                c[j].append((d, i))\n                c[i].append((d, j))\n\n        visited.add(0)\n        heap = c[0]\n        heapq.heapify(heap)\n        cnt = 1\n\n        while heap:\n            d, x = heapq.heappop(heap)\n\n            if x not in visited:\n                visited.add(x)\n                res += d\n                cnt += 1\n                for r in c[x]:\n                    heapq.heappush(heap, r)\n            if cnt >= n:\n                break\n        return res", "class UF:\n    def __init__(self):\n            self.ranks = collections.defaultdict(int)\n            self.p = collections.defaultdict(int)\n\n    def union(self, i, j):\n        ip, jp = self.find(i), self.find(j)\n        if ip == jp:\n            return False\n\n        # // ranking\n        if self.ranks[ip] < self.ranks[jp]:\n            ip, jp = jp, ip\n        self.ranks[ip] += self.ranks[jp]\n\n        self.p[jp] = ip\n        return True\n\n    def find(self, i):\n        if i not in self.p:\n            self.ranks[i] = 1\n            self.p[i] = i\n            return i\n        if i != self.p[i]:\n            # path compression             \n            self.p[i] = self.find(self.p[i])                                                                                                                   \n        return self.p[i]\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) == 1:\n            return 0\n        from queue import PriorityQueue\n        q = PriorityQueue()\n        seen = set()\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                md = abs(points[i][0] - points[j][0]) + abs(points[i][1]-points[j][1])\n                q.put((md, i, j))\n                \n        uf = UF()\n        res = 0\n        count = 0\n        while q.qsize() > 0:\n            md, i, j = q.get()\n            if uf.union(i,j):\n                seen.add(i)\n                seen.add(j)\n                res += md\n                count += 1\n            if count == len(points) - 1:\n                break\n                \n        return res\n            \n", "import heapq\n\ndef dist(p1, p2):\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parents = list(range(n))\n    def root(self, x):        \n        if self.parents[x] != x:\n            self.parents[x] = self.root(self.parents[x]) \n        return self.parents[x]            \n    def union(self, x, y):\n        self.parents[self.root(x)] = self.root(y)\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        q = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                heapq.heappush(q, (dist(points[i], points[j]), i, j))\n        cost = 0\n        s = UnionFind(len(points))\n        while q:\n            d, i, j = heapq.heappop(q)    \n            if s.root(i) != s.root(j):\n                s.union(i, j)\n                cost += d\n        return cost", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        q = [(0, 0)]\n        heapq.heapify(q)\n        added = [False for i in range(len(points))]\n        \n        ans = 0\n        while q:\n            d, u = heapq.heappop(q)\n            if added[u]:\n                continue\n            ans += d\n            added[u] = True\n            for i in range(len(points)):\n                if added[i]:\n                    continue\n                dist = abs(points[i][0] - points[u][0])\n                dist += abs(points[i][1] - points[u][1])\n                heapq.heappush(q, (dist, i))\n        return ans\n        \n", "import heapq\n\ndef dist(p1, p2):\n    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parents = list(range(n))\n    def root(self, x):        \n        if self.parents[x] != x:\n            self.parents[x] = self.root(self.parents[x]) \n        return self.parents[x]            \n    def union(self, x, y):\n        self.parents[self.root(x)] = self.root(y)\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        q = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                heapq.heappush(q, (dist(points[i], points[j]), i, j))\n        cost = 0\n        s = UnionFind(len(points))\n        while q:\n            d, i, j = heapq.heappop(q)    \n            if s.root(i) != s.root(j):\n                s.union(i, j)\n                cost += d\n        return cost                \n", "class Solution:\n    def manhattan_distance(self,a,b):\n        return abs(a[0]-b[0])+abs(a[1]-b[1])\n    \n    def find(self,x):\n        while x in self.parent:\n            while self.parent[x] in self.parent:\n                self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n            \n        \n        \n    def union(self,x,y):\n        x_find=self.find(x)\n        y_find=self.find(y)\n        if(x_find!=y_find):\n            self.parent[x_find]=y_find\n            return True\n        \n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        self.parent={}\n        \n        ls=[]\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                ls.append([self.manhattan_distance(points[i],points[j]),i,j])\n        # print(ls)\n        ls=sorted(ls,key=lambda x:x[0])\n        # print(ls)\n        \n        ans=0\n        for i in range(len(ls)):\n            if(self.union(ls[i][1],ls[i][2])):\n                ans+=ls[i][0]\n            # print(self.parent)\n        return ans\n        \n                \n        \n        \n", "class DSU:\n    def __init__(self):\n        self.parents = {}\n        \n    def makeSet(self,x):\n        self.parents[x] = x\n        \n    def find(self,x):\n        if x not in self.parents:\n            self.makeSet(x)\n        elif x != self.parents[x]:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n    \n    def union(self,x,y):\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if xroot != yroot:\n            self.parents[xroot] = yroot\n            return True\n        return False\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def distance(x1,y1,x2,y2):\n            return abs(x1-x2) + abs(y1-y2)\n        \n        graph = []\n        \n        for node1, point1 in enumerate(points):\n            for node2, point2 in enumerate(points):\n                if node1 != node2:\n                    # graph[node1].append( ( distance(point1[0],point1[1] ,point2[0],point2[1]) , node2) )\n                    graph.append( (distance(point1[0],point1[1] ,point2[0],point2[1]),node1,node2) )\n                    \n        # print(graph)\n                    \n        \n        \n        res = 0\n        dsu = DSU()\n        \n        # for node in graph:\n        #     for dis, nei in sorted(graph[node]):\n        #         print(node,nei,dis)\n        #         if dsu.union(node,nei):\n        #             print('yes')\n        #             res += dis\n        \n        for d,u,v in sorted(graph):\n            # print(d,u,v)\n            # if len(dsu.parents) == len(points):\n            #     return res\n            if len(dsu.parents) == len(points) and len(set(dsu.find(x) for x in dsu.parents)) == 1:\n                return res\n            \n            if dsu.union(u,v):\n                res += d\n        \n        return res\n                \n                    \n", "class UnionFind:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x,y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n        if xRoot == yRoot:\n            return\n        if self.rank[xRoot] > self.rank[yRoot]:\n            self.parent[yRoot] = xRoot\n            self.rank[xRoot]+=self.rank[yRoot]\n        else:\n            self.parent[xRoot] = yRoot\n            self.rank[yRoot]+=self.rank[xRoot]\n            \n\n\nclass Solution:\n    def minCostConnectPoints(self, points) -> int:\n        n = len(points)\n        uf = UnionFind(n)\n        edges = []\n        for i in range(n):\n            for j in range(i+1,n):\n                dist = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1]) \n                heappush(edges, (dist,i,j))\n\n        totalCost = 0\n        while edges:\n            dist,i,j = heappop(edges)\n            if uf.find(i) != uf.find(j):\n                totalCost+=dist\n                uf.union(i,j)\n        return totalCost", "from collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        cost = 0\n        n = len(points)\n        \n        edges = [[3000000, 0] for i in range((n*(n-1))//2)]\n        idx=0\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                edges[idx] = [abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) ,i,j]\n                idx +=1\n        edges.sort()\n        \n        ret = 0\n        \n        i = 0\n        k = 0\n        child = defaultdict(lambda: []) \n        while i<n-1:\n            noCycle = True\n            visited = {}\n            stack = [[edges[k][1],-1],[edges[k][2],-1]]\n            while  len(stack)>0:\n                node = stack.pop()\n                if node[0] in visited:\n                    noCycle = False\n                    break\n                else:\n                    for ch in child[node[0]]:\n                        if ch != node[1]:\n                            stack.append([ch,node[0]])\n                    visited[node[0]] = True\n            if noCycle:\n                i+=1\n                ret += edges[k][0]\n                child[edges[k][1]].append(edges[k][2])\n                child[edges[k][2]].append(edges[k][1])\n            k+=1\n            #print(child)\n            #print(k,i)\n        return ret\n                \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ret=0\n        dis={}\n        for i in range(1,len(points)):\n            dis[tuple(points[i])]=abs(points[i][0]-points[0][0])+abs(points[i][1]-points[0][1])\n        while len(dis)>0:\n            minD=min(dis.values())\n            for k,v in dis.items():\n                if v==minD:\n                    toDel=k\n                    break\n            ret+=minD\n            del dis[toDel]\n            for k,v in dis.items():\n                dis[k]=min(dis[k],abs(k[0]-toDel[0])+abs(k[1]-toDel[1]))\n        return ret", "class UnionFind:\n    def __init__(self, n):\n        self.size = n\n        self.parents = [i for i in range(self.size)]\n        self.rank = [1 for _ in range(self.size)]\n    def find_parent(self, node):\n        if self.parents[node] != node:\n            self.parents[node] = self.find_parent(self.parents[node])\n        return self.parents[node]\n    def union(self, a, b):\n        parent_a = self.find_parent(a)\n        parent_b = self.find_parent(b)\n        \n        if parent_a == parent_b:\n            return\n        \n        if self.rank[parent_a] < self.rank[parent_b]:\n            parent_a, parent_b = parent_b, parent_a\n        \n        self.parents[parent_b] = parent_a\n        self.rank[parent_a] += self.rank[parent_b] \n        \nclass Solution:\n\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def build_graph(points):\n            result = []\n            distance = lambda a, b: abs(a[0] - b[0]) + abs(a[1] - b[1])\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    weight = distance(points[i], points[j])\n                    result.append((weight, i, j))\n            return result\n            \n        union_find = UnionFind(len(points))\n        graph = build_graph(points)\n        graph.sort()\n        cost = 0\n        #print(graph)\n        for w, a, b in graph:\n            if union_find.find_parent(a) == union_find.find_parent(b):\n                continue\n            #print(w, a, b)\n            union_find.union(a, b)\n            cost += w\n        return cost", "class UnionFind:\n    def __init__(self, n):\n        self.parents = list(range(n))\n        \n    def root(self, x):\n        if self.parents[x] != x:\n            self.parents[x] = self.root(self.parents[x])\n        return self.parents[x]\n    \n    def union(self, x, y):\n        self.parents[self.root(x)] = self.root(y)\n        \n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def manh(x1, x2, y1, y2):\n            return abs(x1 - x2) + abs(y1 - y2)\n\n        n, q = len(points), []\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                heapq.heappush(q, (manh(points[i][0], points[j][0], points[i][1], points[j][1]), i, j))\n        \n        cost = 0\n        \n        s = UnionFind(n)\n        while q:\n            d,i,j = heapq.heappop(q)\n            if s.root(i) != s.root(j):\n                s.union(i,j)\n                cost += d\n        return cost\n", "'''\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        #distance = collections.defaultdict(list)\n        edges = []\n        \n        def distance(point1, points):\n            return abs(point1[0]-point2[0]) + abs(point1[1]-point2[1])\n        \n        for i,point1 in enumerate(points):\n            for j, point2 in enumerate(points[i+1:]):\n                edges.append((i,j+i+1, distance(point1,point2)))\n\n        edges = sorted(edges, key = lambda x: x[2])\n        \n        union = list(range(n))\n        rank = [0]*n\n        \n        def find(x):\n            if union[x]!=x:\n                union[x] = find(union[x])\n            return union[x]\n        \n        def connect(x, y):\n            xr, yr = find(x), find(y)\n            if rank[xr] > rank[yr]:           \n                union[yr] = xr\n                rank[xr] += rank[yr]\n            else:\n                union[xr] = yr\n                rank[yr] += xr\n\n        result= 0\n        times = 0\n        while(edges and times < n):\n            p1, p2, dis = edges.pop(0)    \n            if find(p1)!=find(p2):\n                connect(p1, p2)\n                result += dis\n                times +=1 \n        return result\n'''\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n    \n    # make a and b part of the same component\n    # union by rank optimization\n    def union(self, a, b):\n        pa = self.find(a)\n        pb = self.find(b)\n        if pa == pb: return\n        if self.rank[pa] > self.rank[pb]:\n            self.parent[pb] = pa\n            self.rank[pa] += self.rank[pb]\n        else:\n            self.parent[pa] = pb\n            self.rank[pb] += self.rank[pa]\n    \n    # find the representative of the \n    # path compression optimization\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        \n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        \n        # sort based on cost (i.e. distance)\n        edges.sort()\n        \n        # using Kruskal's algorithm to find the cost of Minimum Spanning Tree\n        res = 0\n        ds = DisjointSet(n)\n        for cost, u, v in edges:\n            if ds.find(u) != ds.find(v):\n                ds.union(u, v)\n                res += cost\n        \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n      # Tried brute force, failed on ensuring connectivity\n      # Tried all pairs shortest path, not applicable\n      # Remembered MSTs and Kruskal's, implemented here after competition\n      def l1(p1, p2):\n        xi, yi = p1\n        xj, yj = p2\n        return abs(xi-xj) + abs(yi-yj)\n      \n      inf = float('inf')\n      LV = len(points)\n      E = [(u, v, l1(points[u],points[v])) \n           for u in range(LV) for v in range(LV) if u != v]\n      E = sorted(E, key=lambda x: x[2])\n      parent = [0] * LV\n      \n      def make_set(v):\n        parent[v] = v\n      \n      def find_set(v):\n        if v == parent[v]:\n          return v\n        parent[v] = find_set(parent[v])\n        return parent[v]\n      \n      def union_sets(a, b):\n        a = find_set(a)\n        b = find_set(b)\n        if a != b:\n          parent[b] = a\n          \n      for v in range(LV):\n        make_set(v)\n      \n      cost = 0\n      for (u,v,d) in E:\n        if (a:=find_set(u)) != (b:=find_set(v)):\n          cost += d\n          union_sets(a,b)\n      \n      return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def getDist(p1, p2):\n            # |xi - xj| + |yi - yj|\n            xi, yi = p1\n            xj, yj = p2\n            return abs(xi - xj) + abs(yi - yj)\n        \n        graph = collections.defaultdict(list)\n        for i in range(len(points)):\n            for j in range(len(points)):\n                graph[i].append((getDist(points[i], points[j]), j))\n        start = res = 0\n        visited = { start }\n        min_heap = []\n        for cost, adj in graph[start]:\n            heapq.heappush(min_heap, (cost, adj))\n        while len(visited) < len(points) + 1 and min_heap:\n            cost, next_node = heapq.heappop(min_heap)\n            if next_node not in visited:\n                visited.add(next_node)\n                res += cost\n                for next_cost, adj in graph[next_node]:\n                    if adj not in visited:\n                        heapq.heappush(min_heap, (next_cost, adj))\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def dist(e1, e2):\n            return abs(e1[0]-e2[0])+abs(e1[1]-e2[1])\n        \n        def find(x):\n            if p[x] !=x:\n                p[x] = find(p[x])\n            return p[x]\n        \n        def union(x,y):\n            px,py = find(x), find(y)\n            if px==py: return False\n            p[px] = py\n            return True\n        \n        n = len(points)\n        res = 0\n        p = list(range(len(points)))\n        edges = []\n        for i in range(n):\n            for j in range(i+1,n):\n                heappush(edges,(  dist(points[i],points[j]),i,j ))\n                \n        while edges: \n            cost,x,y = heappop(edges)\n            if union(x,y):\n                res += cost\n                \n        return res", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n=len(points)\n        hq,d,s=[(0,0)],[1]*n,0\n        while hq:\n            t,i=heapq.heappop(hq)\n            if d[i]:\n                s,d[i]=s+t,0\n                for j in range(n):\n                    if d[j]: heapq.heappush(hq,(abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),j))\n        return s", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if not points or len(points) <= 1:\n            return 0\n        \n        heap = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                p1 = points[i]\n                p2 = points[j]\n                dis = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n                heapq.heappush(heap, (dis, i, j))\n        \n        self.father = [i for i in range(len(points))]\n        res = 0\n        while heap:\n            dis, u, v = heapq.heappop(heap)\n            root_u = self.find(u)\n            root_v = self.find(v)\n            if root_u == root_v:\n                continue\n            self.father[max(root_u, root_v)] = min(root_u, root_v)\n            res += dis\n        \n        return res\n    \n    def find(self, x):\n        if self.father[x] == x:\n            return self.father[x]\n        self.father[x] = self.find(self.father[x])\n        return self.father[x]", "from collections import defaultdict\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass Edge :\n   src : int\n   dst : int\n   weight : int\n\n    \n@dataclass\nclass Graph :\n    num_nodes : int\n    edgelist : list\n    parent : list = field(default_factory = list)\n    rank : list = field(default_factory = list)\n\n    #minimum spanning tree\n    mst : list = field(default_factory = list)\n\n    def FindParent(self, node) :\n        if self.parent[node] == node :\n           return node\n        return self.FindParent(self.parent[node])\n\n    def KruskalMST(self) :\n        self.edgelist.sort(key=lambda Edge : Edge.weight)\n        self.parent = [None] * self.num_nodes\n        self.rank   = [None] * self.num_nodes\n\n        for n in range(self.num_nodes) :\n            self.parent[n] = n \n            self.rank[n] = 0 \n\n        for edge in self.edgelist :\n            root1 = self.FindParent(edge.src)\n            root2 = self.FindParent(edge.dst)\n\n            if root1 != root2 :\n               self.mst.append(edge)\n               if self.rank[root1] < self.rank[root2] :\n                  self.parent[root1] = root2\n                  self.rank[root2] += 1\n               else :\n                  self.parent[root2] = root1\n                  self.rank[root1] += 1\n        \n        ret = 0\n        for edge in self.mst:\n            ret += edge.weight\n        return ret\n\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        \n        edges = []\n        for i in range(n-1):\n            for j in range(i+1, n):\n                dis = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                edges.append(Edge(i,j,dis))\n        \n        g = Graph(n, edges)\n        return g.KruskalMST()\n        \n        \n", "class UnionFind:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x,y):\n        xRoot = self.find(x)\n        yRoot = self.find(y)\n        if xRoot == yRoot:\n            return\n        self.parent[xRoot] = yRoot\n\n\nclass Solution:\n    def minCostConnectPoints(self, points) -> int:\n        n = len(points)\n        uf = UnionFind(n)\n        edges = []\n        for i in range(n):\n            for j in range(i+1,n):\n                dist = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1]) \n                heappush(edges, (dist,i,j))\n\n        totalCost = 0\n        while edges:\n            dist,i,j = heappop(edges)\n            if uf.find(i) != uf.find(j):\n                totalCost+=dist\n                uf.union(i,j)\n        return totalCost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n =len(points)\n        if n<=1:\n            return 0\n        ds = UFind(n)\n        hp = []\n        heapq.heapify(hp)\n        for i in range(n-1):\n            for j in range(i+1,n):\n                mhd = abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                heapq.heappush(hp, (mhd, i, j))\n        \n        ans = 0\n        while ds.count>1:\n            mhd, i, j = heapq.heappop(hp)\n            if ds.union(i,j):\n                ans+=mhd\n        return ans\nclass UFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [1]*n\n        self.count = n\n    def find(self,x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        x_par, y_par = self.find(x), self.find(y)\n        if x_par == y_par:\n            return False\n        else:\n            self.count-=1\n            if self.rank[x_par]<self.rank[y_par]:\n                self.parent[x_par] = y_par\n            elif self.rank[x_par]>self.rank[y_par]:\n                self.parent[y_par] = x_par\n            else:\n                self.parent[x_par] = y_par\n                self.rank[y_par]+=1  \n            return True\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        if not points:\n            return 0\n        \n        cost = 0\n        graph = defaultdict(dict)\n        for i in range(len(points)):\n            for j in range(len(points)):\n                if i != j:\n                    graph[i][j] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                    graph[j][i] = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                    \n        \n        visited = set()\n        graph[-1][0] = 0\n        pq = [(0,-1,0)]\n        heapq.heapify(pq)\n        \n        while pq:\n            if len(visited) == len(points):\n                return cost\n            edge_cost, u,v = heapq.heappop(pq)\n            if v not in visited:\n                cost += edge_cost\n            visited.add(v)\n            for nbr in graph[v]:\n                if nbr not in visited:\n                    heapq.heappush(pq, (graph[v][nbr], v, nbr))\n            \n        return cost\n                    \n        \n", "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        dict = {}\n        for index,i in enumerate(A):\n            dict[str(i)] = index\n        res = 0\n        edges = []\n        for index,i in enumerate(A):\n            for j in A[index+1:]:\n                x = abs(i[0]-j[0])+abs(i[1]-j[1])\n                y = dict.get(str(i))\n                z = dict.get(str(j))\n                edges.append([x,y,z])\n        edges.sort()\n        arr = DSU(len(A))\n        for i in edges:\n            if arr.union(i[1],i[2]):\n                res += i[0]\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        '''\n        Big idea: Union find to detect cycles. Create all edges, sort by distance. Look at each edge and add it if it doesn't make a cycle. Return the total of the added edges.\n        '''\n        edges = []\n        for i in range(len(points)):\n            p1 = tuple(points[i])\n            for j in range(i+1, len(points)):\n                p2 = tuple(points[j])\n                dist = abs(p1[0]-p2[0]) + abs(p1[1] - p2[1])\n                edges.append((dist, p1, p2))\n        edges.sort()\n        # print(edges)\n        \n        self.roots = {(x, y): (x, y) for x, y in points}\n        self.ranks = {(x, y): 0 for x, y in points}\n        # print(self.roots)\n        \n        ans = 0\n        for edge in edges:\n            dist, p1, p2 = edge\n            if self.union(p1, p2):\n                ans += dist\n        return ans\n    \n    def union(self, p1, p2):\n        p1_root, p2_root = self.find(p1), self.find(p2)\n        if p1_root == p2_root:\n            return False\n        if self.ranks[p1_root] < self.ranks[p2_root]:\n            self.roots[p1_root] = p2_root\n        elif self.ranks[p1_root] > self.ranks[p2_root]:\n            self.roots[p2_root] = p1_root\n        else:\n            # when its equal - choose whichever and update the ranks\n            self.roots[p1_root] = p2_root\n            self.ranks[p2_root] += 1\n            \n        return True\n    \n    def find(self, p):\n        if p != self.roots[p]:\n            self.roots[p] = self.find(self.roots[p])\n        return self.roots[p]", "class DSU:\n    def __init__(self, N):\n        self.p = [i for i in range(N)]\n        \n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    \n    def union(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n        self.p[py] = px\n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        heap = []\n        result = 0\n        \n        n = len(points)\n        \n        for i in range(n-1):\n            for j in range(i+1, n):\n                heapq.heappush(heap, (abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1]), i, j))\n\n        dsu = DSU(n)\n        \n        while heap:\n            d, i, j = heapq.heappop(heap)\n            pi = dsu.find(i)\n            pj = dsu.find(j)\n            \n            if pi != pj:\n                result += d\n                dsu.union(i, j)\n        \n        return result\n", "class DSU: \n    def __init__(self, n): \n        self.p = list(range(n))\n        self.r = [0] * n\n    def find(self, i): \n        if self.p[i] != i:\n            self.p[i] = self.find(self.p[i])\n        return self.p[i]\n    def union(self, i, j): \n        pi, pj = self.find(i), self.find(j)\n        if pi != pj: \n            if self.r[pi] >= self.r[pj]: \n                self.p[pj] = pi\n                self.r[pi] += (self.r[pi] == self.r[pj])\n            else: \n                self.p[pi] = pj\n            return True\n        return False\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # try minimum spanning treee\n        \n        to_visit = set(range(1, len(points)))\n        pq = [(abs(points[0][0] - points[x][0]) + abs(points[0][1] - points[x][1]), x) for x in range(1, len(points))]\n        heapq.heapify(pq)\n        ans = 0\n        while pq:\n            cost, to = heapq.heappop(pq)\n            if to in to_visit:\n                to_visit.remove(to)\n                ans += cost\n                for nei in to_visit:\n                    x, y = points[nei]\n                    heapq.heappush(pq, (abs(x-points[to][0]) + abs(y-points[to][1]), nei))\n\n        return ans\n    \n#     def minCostConnectPoints(self, points: List[List[int]]) -> int:\n#         edges, ans = [], 0\n#         for i in range(len(points)):\n#             for j in range(i+1, len(points)): \n#                 edges.append((abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j))\n                \n#         edges.sort()\n#         uf = DSU(len(points))\n#         for cost, i, j in edges: \n#             if uf.find(i) != uf.find(j): \n#                 uf.union(i, j)\n#                 ans += cost\n#         return ans\n        \n                \n\n", "class Solution(object):\n    def minCostConnectPoints(self, points):\n\n        g = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                g.append((i, j, abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])))\n        \n        g0 = sorted(g, key = lambda x: x[2])\n        uf = UnionFind(len(points))\n        \n        ans = 0\n        for x, y, z in g0:\n            if uf.union(x, y):\n                ans += z\n        \n        return ans\n                         \nclass UnionFind():\n    def __init__(self, n):\n        self.parents = {i:i for i in range(0, n)}\n        self.groups = n\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return False\n\n        self.parents[y] = x\n        self.groups -= 1\n        return True", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dis = {}\n        length = len(points)\n        for i in range(length):\n            dis[i] = []\n        res = 0\n        for i in range(length):\n            for j in range(length):\n                if i == j:\n                    continue\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(dis[i], (d, j))\n        \n        visited = set([0])\n        res = 0\n        while len(visited) < length:\n            curMin = -1\n            for p in visited:\n                while dis[p][0][1] in visited:\n                    heapq.heappop(dis[p])\n                if curMin == -1 or dis[p][0][0] < dis[curMin][0][0]:\n                    curMin = p\n            visited.add(dis[curMin][0][1])\n            res += dis[curMin][0][0]\n            heapq.heappop(dis[curMin])\n        return res", "class Solution:\n    \n    class UnionFinder:\n        def __init__(self, n):\n            self.parents = list(range(n))\n            self.ranks = [0] * n\n        \n        def find(self, x):\n            if self.parents[x] != x:\n                self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n        \n        def join(self, x, y):\n            p1 = self.find(x)\n            p2 = self.find(y)\n            \n            if p1 == p2:\n                return False\n            \n            r1 = self.ranks[p1]\n            r2 = self.ranks[p2]\n            \n            if r1 < r2:\n                self.parents[p1] = p2\n            elif r2 < r1:\n                self.parents[p2] = p1\n            else:\n                self.parents[p1] = p2\n                self.ranks[p2] += 1\n            return True\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = list()\n        \n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                heapq.heappush(heap, (abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j))\n                \n        union_finder = Solution.UnionFinder(len(points))\n        ans = 0\n        while heap:\n            d, i, j = heapq.heappop(heap)\n            if union_finder.join(i, j):\n                ans += d\n        return ans\n", "class Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: p[0] + p[1])\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            p1, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p2, dist) in enumerate(points):\n                points[i][1] = min(points[i][1], distance(p1, p2))\n        return total_cost\n\nfrom heapq import *\nfrom collections import defaultdict\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        edges = defaultdict(list)\n        for i1, p1 in enumerate(points):\n            for i2, p2 in enumerate(points[i1+1:], start = i1+1):\n                distance = dist(p1, p2)\n                edges[i1].append([distance, i2])\n                edges[i2].append([distance, i1])\n        heap = edges[0]\n        heapify(heap)\n        total_cost, seen = 0, {0}\n        while len(seen) < N:\n            cost, node = heappop(heap)\n            if node in seen:\n                continue\n            seen.add(node)\n            total_cost += cost\n            for dist, next_ in edges[node]:\n                if next_ not in seen:\n                    heappush(heap, [dist, next_])\n        return total_cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        from queue import PriorityQueue\n        \n        coors = {}\n        count = 0\n        for point in points:\n            coors[count] = tuple(point)\n            count = count + 1\n        pq = PriorityQueue()\n        pq.put((0, 0)) # dist, nodeIdx\n        visited = set()\n        total = 0\n        while (len(visited) < len(points)):\n            cost, nodeIdx = pq.get()\n            if nodeIdx in visited:\n                continue\n            total = total + cost\n            visited.add(nodeIdx)\n            node = coors[nodeIdx]\n            for nextNodeIdx in range(len(points)):\n                if nextNodeIdx not in visited:\n                    nextNode = coors[nextNodeIdx]\n                    nextCost = abs(nextNode[0] - node[0]) + abs(nextNode[1] - node[1])\n                    pq.put((nextCost, nextNodeIdx))\n        return total", "class Solution:\n    # Time: O(n^2)\n    # Space: O(n)\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        res, curr = 0, 0\n        distances = [float('inf') for _ in range(n)]\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored:\n                    continue\n                distances[j] = min(distances[j], abs(x0 - x) + abs(y0 - y))\n                \n            delta, curr = min((d, j) for j, d in enumerate(distances))\n            res += delta\n            distances[curr] = float('inf')\n            \n        return res         ", "class Subsets:\n    def __init__(self,parent,rank):\n        self.parent=parent\n        self.rank=rank\n        \ndef find(subsets,node):\n    \n    if subsets[node].parent!=node:\n        subsets[node].parent=find(subsets,subsets[node].parent)\n        \n    return subsets[node].parent\n\ndef union(subsets,x,y):\n    xr=find(subsets,x)\n    yr=find(subsets,y)\n    if xr==yr:\n        return False\n    else:\n        xr=subsets[xr]\n        yr=subsets[yr]\n        if xr.rank<yr.rank:\n            xr.parent=yr.parent\n        elif yr.rank<xr.rank:\n            yr.parent=xr.parent\n        else:\n            xr.parent=yr.parent\n            yr.rank+=1\n        return True\n\ndef distance(p1,p2):\n    x1,y1=p1\n    x2,y2=p2\n    return abs(x1-x2)+abs(y1-y2)\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        subsets={}\n        for x,y in points:\n            subsets[(x,y)]=Subsets((x,y),0)\n        \n        edges=[]\n        \n        for i in range(len(points)-1):\n            p1=tuple(points[i])\n            for j in range(i+1,len(points)):\n                p2=tuple(points[j])\n                edges.append((distance(p1,p2),p1,p2))\n                \n        edges.sort()\n        ans=0\n        \n        for w,p1,p2 in edges:\n            if union(subsets,p1,p2):\n                ans+=w\n                \n        return ans\n                \n        \n        \n        \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        h = []\n        visited = set()\n        dist = lambda a,b : abs(a[0]-b[0]) + abs(a[1]-b[1])\n\n        for i in range(len(points)):\n            for j in range(i):\n                h.append((dist(points[i], points[j]), i,j))\n        heapq.heapify(h)\n        total = 0\n        uf = UnionFind([i for i in range(len(points))])\n        \n        while h and len(visited) < len(points):\n            dist, i,j = heapq.heappop(h)\n            if uf.find(i) != uf.find(j):\n                uf.union(i,j)\n                total +=dist\n\n        return total\n                \nclass UnionFind:\n        \n        def __init__(self, arr):\n            self.parent = [i for i in range(len(arr))]\n            self.rank = [0] * len(arr)\n        \n        \n        def find(self, i):\n            if self.parent[i] == i:\n                return i\n            p = self.find(self.parent[i])\n            self.parent[i] = p\n            return p\n        \n        def union(self, a,b):\n            pa, pb = self.find(a), self.find(b)\n            if self.rank[pa]>self.rank[pb]:\n                self.parent[pb] = pa\n            elif self.rank[pb]>self.rank[pa]:\n                self.parent[pa] = pb\n            else:\n                self.parent[pb] = pa\n                self.rank[pa] +=1\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        parent = [i for i in range(len(points))]\n        size = [1 for _ in range(len(points))]\n        \n        def root(p):\n            while parent[p] != p:\n                parent[p] = parent[parent[p]]\n                p = parent[p]\n                \n            return p\n        \n        def union(p, q):\n            root_p, root_q = root(p), root(q)\n            if root_p != root_q:\n                if size[root_p] < size[root_q]:\n                    parent[root_p] = root_q\n                    size[root_q] += size[root_p]\n                else:\n                    parent[root_q] = root_p\n                    size[root_p] += size[root_q]\n        \n        def connected(p, q):\n            return root(p) == root(q)\n        \n        p = points\n        ans = 0\n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        heap = []\n        for i in range(len(p)):\n            for j in range(i+1, len(p)):\n                temp = dist(p[i],p[j])\n                heappush(heap, (temp, (i, j)))\n        \n        while heap:\n            dis, (i, j) = heappop(heap)\n            if not connected(i, j):\n                ans += dis\n                union(i, j)\n                                \n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        costs = []\n        for i in range(len(points)) :\n            xi, yi = points[i]\n            for j in range(i+1, len(points)) :\n                xj, yj = points[j]\n                costs.append([abs(xi-xj)+abs(yi-yj), i, j])\n        costs = sorted(costs)\n        \n        fathers = {t:t for t in range(len(points))}\n        def get_father(n) :\n            while not fathers[n] == fathers[fathers[n]] :\n                fathers[n] = fathers[fathers[n]]\n            return fathers[n]\n        \n        to_ret = 0\n        for t in costs :\n            ct, pi, pj = t\n            if get_father(pi) == get_father(pj) :\n                continue\n            \n            fathers[get_father(pj)] = get_father(pi)\n            to_ret += ct\n        return to_ret", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def find(u):\n            if p[u]==-1:\n                return u\n            \n            p[u] = find(p[u])\n            return p[u]\n        \n        def union(u, v):\n            \n            if r[u]>r[v]:\n                p[v] = u\n            elif r[u]<r[v]:\n                p[u] = v\n            else:\n                p[v] = u\n                r[u]+=1\n            \n        n = len(points)\n        edges = []\n        for i in range(n):\n            for j in range(i+1,n):\n                edges.append([abs(points[j][0]-points[i][0])+abs(points[j][1]-points[i][1]),i,j])\n        \n        edges.sort()\n        \n        p = [-1]*n\n        r = [0]*n\n        \n        res = 0\n        \n        for x in edges:\n            u = find(x[1])\n            v = find(x[2])\n            if u!=v:\n                res += x[0]\n                union(u, v)\n        \n        return res\n", "import heapq\n\nclass Solution:\n  def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    def distance(p1, p2):\n      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    L = len(points)\n    if L <= 1:\n      return 0\n\n    todo = set(range(L))\n    nex = 0\n    h = []\n    ans = 0\n    while todo:\n      todo.remove(nex)\n      for i in todo:\n        heapq.heappush(h, (distance(points[nex], points[i]), i))\n      while h and h[0][1] not in todo:\n        heapq.heappop(h)\n      if not h:\n        break\n      cost, nex = heapq.heappop(h)\n      ans += cost\n    return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dis=[[[0,x] for x in range(len(points))] for x in range(len(points))]\n        for i,x in enumerate(points):\n            for y in range(i+1,len(points)):\n                temp=abs(x[0]-points[y][0])+abs(x[1]-points[y][1])\n                dis[i][y][0]=temp\n                dis[y][i][0]=temp\n        for x in range(len(dis)):\n            dis[x].sort()\n        \n        # which I have not included in mst\n        rem=[1 for x in range(len(points))]\n        \n        c=0\n        inc={0:1}\n        while len(inc)<len(points):\n            minn=[float(\\\"inf\\\"),-1]\n            for x in inc:\n                while dis[x][rem[x]][1] in inc:\n                    rem[x]+=1\n                if dis[x][rem[x]][0]<minn[0]:\n                    minn[0],minn[1]=dis[x][rem[x]][0],dis[x][rem[x]][1]\n            inc[minn[1]]=1\n            c+=minn[0]\n        return c\n            \n        # print(dis)\n        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        d = collections.defaultdict(list)\n        m = {}\n        for i in range(len(points)):\n            m[(points[i][0], points[i][1])] = i\n        h = []\n        for i in range(len(points)-1):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i][0], points[i][1]\n                x2, y2 = points[j][0], points[j][1]\n                k = self.manhattan(x1,y1,x2,y2)\n                d[m[(x1,y1)]].append([m[(x2,y2)], k])\n                d[m[(x2,y2)]].append([m[(x1,y1)], k])\n                    \n        # initialize heap for prim's\n        ans = 0\n        h = []\n        for n,w in d[0]:\n            h.append([w,n])\n        heapq.heapify(h)\n        seen = set({0})\n        while h:\n            w,n = heapq.heappop(h)\n            if n in seen: continue\n            seen.add(n)\n            ans += w\n            if len(seen) == len(points): break\n            for n2, w2 in d[n]:\n                heapq.heappush(h, [w2, n2])\n        return ans\n                    \n    def manhattan(self, x1, y1, x2, y2):\n        return abs(x2-x1) + abs(y2-y1)\n                \n                \n", "#Build weighted graph and then use Union-Find to get MST\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N, g = len(points), []\n        res = 0\n        \n        #build the weighted graph\n        for i in range(N - 1):\n            x0, y0 = points[i]\n            for j in range(i + 1, N):                \n                x1, y1 = points[j]\n                dist = abs(x0 - x1) + abs(y0 - y1)\n                g.append((dist, (i, j)))\n                \n        #sort by weight\n        g.sort()\n        \n        #Union-Find to get MST\n        parents = [None] * N\n        for i in range(N): parents[i] = i\n            \n        def findParent(x):\n            if parents[x] != x:\n                parents[x] = findParent(parents[x])\n            \n            return parents[x]\n        \n        for w, (a, b) in g:\n            pa = findParent(a)\n            pb = findParent(b)\n            \n            #union sub-graphs if not connected yet\n            if pa != pb:\n                res += w\n                parents[pa] = pb\n        \n        return res\n", "\nclass UnionFind(object):\n    def __init__(self, n):\n        # * only idff from template is it starts at 0\n        self.count = n\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n\n    def find(self, p):\n        if p != self.parent[p]:\n            self.parent[p] = self.find(self.parent[p])\n        return self.parent[p]\n\n    def union(self, p, q):\n        p_root, q_root = self.find(p), self.find(q)\n        if p_root == q_root:\n            return False\n        if self.rank[p_root] > self.rank[q_root]:\n            p_root, q_root = q_root, p_root\n        self.parent[p_root] = q_root\n        self.rank[q_root] += self.rank[p_root]\n        self.count -= 1\n        return True\n\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        uf = UnionFind(n)\n\n        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n        g = collections.defaultdict(list)\n        n = len(points)\n        heap = []\n        #create graph\n        for i in range(n):\n            for j in range(i + 1, n):\n                distance = manhattan(points[i], points[j])\n                heap.append((distance, i, j))\n        res = 0\n        heapq.heapify(heap)\n        while heap:\n            weight, i, j = heapq.heappop(heap)\n            if uf.union(i, j):\n                res += weight\n        return res", "#Prim's algorith for COMPLETE GRAPH: O(N ** 2), O(|V| ** 2)\n#Since every node is connected, we can select one node to start with, and calculate all distances to it and take\n#   the minimum distance node to it to add to the spanning tree. For the newly added node, update shortest \n#   distances to the rest of the nodes (i.e. distance to the current spanning tree). We can then choose the \n#   minimum distance node to add to the current spanning tree, and so on.\n#Note: it doesn't matter which node in the existing spanning tree that the new node is connected with. We only\n#       need its distance to be minimum when connecting to the current spanning tree\n#Time: O(N ** 2)\n#Sapce: O(M * N)\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        dist = [math.inf] * N\n        \n        #mark the starting node\n        prev_node = 0\n        res = 0\n        \n        def getDistance(x, y):\n            return abs(points[x][0] - points[y][0]) + abs(points[x][1] - points[y][1])\n        \n        for _ in range(N):\n            min_dist, min_dist_node = math.inf, -1\n            \n            #use distance = None to mark this node has been included in the current spanning tree\n            for i in range(N):\n                if dist[i] != None:\n                    dist[i] = min(dist[i], getDistance(prev_node, i))\n                    if dist[i] < min_dist:\n                        min_dist, min_dist_node = dist[i], i\n            \n            res += min_dist\n            prev_node = min_dist_node\n            dist[prev_node] = None\n        \n        return res\n", "from heapq import heappush,heappop\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def calcCost(i,j):\n            return abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n        q=[(0,0)]\n        visited=set()\n        totalCost=0\n        while q:\n            cost,point=heappop(q)\n            if point not in visited:\n                visited.add(point)\n                totalCost+=cost\n                for i in range(len(points)):\n                    if i!=point and not i in visited:\n                        heappush(q,(calcCost(point,i),i))\n        return totalCost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        parent = {}\n        size = defaultdict(lambda: 1)\n\n        def find(u):\n            if u != parent.get(u, u):\n                parent[u] = find(parent[u])  # path compression\n            return parent.get(u, u)\n\n        def union(u, v):\n            u, v = find(u), find(v)\n            if u != v:\n                if size[u] < size[v]:  # union by size / rank\n                    u, v = v, u\n\n                parent[v] = u\n                size[u] += size[v]\n\n        total = 0\n        edges = []\n        n = len(points)\n        for i in range(len(points)):\n            for j in range(len(points)):\n                if i!=j:\n                    edges.append((abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),i,j))\n        edges.sort()\n\n        count = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                total += cost\n                count += 1\n                union(u, v)\n                if count == n-1:\n                    return total\n\n        return total\n        \n", "class DSU:\n    def __init__(self, N):\n        self.parent = list(range(N))\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        self.parent[yr] = xr\n        return True\n\n\nclass Solution:\n    def minCostConnectPoints(self, P: List[List[int]]) -> int:\n        from collections import defaultdict\n        #G = defaultdict(set)\n        connections = []\n        for i in range(len(P)):\n            for j in range(i+1, len(P)):\n                if i != j:\n                    cost = abs(P[i][0] - P[j][0]) + abs(P[i][1] - P[j][1])\n                    #G[i].add((j, cost))\n                    #G[j].add((i, cost))\n                    connections.append([i,j,cost])\n        #print(connections)\n        #print(len(connections))\n        connections = list(connections)\n        connections.sort(key = lambda x : x[2])\n        dsu = DSU(len(P))\n        res = 0\n        for u,v,w in connections:\n            curr = dsu.union(u,v)\n            if curr:\n                res += w\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dic = {}\n        for i in range(len(points)):\n            val = []\n            for j in range(len(points)):\n                if points[j] != points[i]:\n                    val = (abs(points[j][0]-points[i][0]) + abs(points[j][1] - points[i][1]))   \n                    dic[i,j] = val\n        #print(dic)\n        g = Graph(len(points))\n        \n        for k,v in list(dic.items()):\n            g.addEdge(k[0],k[1],v)\n        \n        res = g.KruskalMST()\n        print(res)\n        return res\n\nclass Graph:\n    def __init__(self, vertices):\n        self.v = vertices\n        self.graph = []\n        \n    def addEdge(self, u, v, w):\n        self.graph.append([u,v,w])\n        \n    def find(self,parent, i):\n        if parent[i] == -1:\n            return i\n        return self.find(parent, parent[i])\n    \n    def union(self, parent, x, y):\n        x_set = self.find(parent, x)\n        y_set = self.find(parent, y)\n        parent[x_set] = y_set\n        \n    def KruskalMST(self):\n        MST = []\n        i = 0\n        e = 0\n        self.graph = sorted(self.graph, key = lambda e:e[2])\n        parent = [-1] * self.v\n        while e < self.v -1:\n            u,v,w = self.graph[i]\n            i += 1\n            x = self.find(parent,u)\n            y = self.find(parent, v)\n            #print(x,y)\n            if x!= y:\n                e += 1\n                MST.append([u,v,w])\n                self.union(parent,x,y)\n                #print(MST)\n        s = 0\n        for u,v,w in MST:\n            s += w\n        return s\n        \n", "from heapq import heappush, heappop\nfrom collections import defaultdict\n\nclass Solution:\n    '''\n    min-spanning-tree?\n    * generate graph from all points\n    * edgerelaxation with pq,\n    '''\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def taxicab(x1, x2, y1, y2):\n            return abs(x1 - x2) + abs(y1 - y2)\n        \n        def gengraph():\n            graph = defaultdict(list)\n            \n            for i, point in enumerate(points):\n                x1, y1 = point\n                for j in range(i + 1, len(points)):\n                    x2, y2 = points[j]\n                    cost = taxicab(x1, x2, y1, y2)\n                    graph[(x1, y1)].append((cost, (x2, y2)))\n                    graph[(x2, y2)].append((cost, (x1, y1)))\n                    \n            return graph\n        \n        graph = gengraph()\n        relaxed = set()\n        start = tuple(points[0])\n        heap = [(0, start)]\n        mincost = 0\n        \n        while heap and len(relaxed) < len(points):\n            cost, pos = heappop(heap)\n            \n            if pos in relaxed:\n                continue\n                \n            relaxed.add(pos)\n            mincost += cost\n            \n            for nbr in graph[pos]:\n                if nbr not in relaxed:\n                    heappush(heap, nbr)\n                \n        return mincost", "from collections import defaultdict\nimport heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        total, heap, visited = 0, [(0, 0)], set()\n        distances = defaultdict(list)\n        for i in range(len(points) - 1):\n            for j in range(1, len(points)):\n                distances[i].append((self.distance(points[i], points[j]), j))\n                distances[j].append((self.distance(points[i], points[j]), i))\n        while heap and len(visited) < len(points):\n            distance, point = heapq.heappop(heap)\n            if point not in visited:\n                visited.add(point)\n                total += distance\n                for neighbor_distance, neighbor in distances[point]:\n                    if neighbor not in visited:\n                        heapq.heappush(heap, (neighbor_distance, neighbor))\n        return total\n                \n            \n        \n    def distance(self, pair1, pair2):\n        return abs(pair1[0] - pair2[0]) + abs(pair1[1] - pair2[1])", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        root = list(range(N))\n        size = [1] * N\n        res = 0\n        \n        def find(x):\n            root[x] = find(root[x]) if root[x] != x else root[x]\n            \n            return root[x]\n        \n        def union(x, y):\n            x, y = find(x), find(y)\n            \n            if x == y: return False\n            \n            if size[x] < size[y]: x, y = y, x\n                \n            root[y] = x\n            size[x] += size[y]\n            \n            return True\n        \n        edge_ls = []\n        \n        for i, cur in enumerate(points):\n            for j, nxt in enumerate(points[i + 1:]):\n                dist = abs(cur[0] - nxt[0]) + abs(cur[1] - nxt[1])\n                edge_ls.append([dist, i, i + j + 1])\n                \n        edge_ls.sort()\n        \n        for dist, u, v in edge_ls:\n            if find(u) != find(v):\n                res += dist\n                union(u, v)\n                \n        return res\n                \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def hash_point(point):\n            return point[0],point[1]\n        \n        def manh_dist(point1, point2):\n            return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n        \n        if len(points) == 1: return 0\n        if len(points) == 2: return manh_dist(points[0], points[1])\n        \n        points_remaining = set()\n        dists = []\n        first_point = points[0]\n        \n        for i in range(1, len(points)):\n            point,h_point = points[i],hash_point(points[i])\n            points_remaining.add(h_point)\n            heapq.heappush(dists, (manh_dist(first_point, point), h_point))\n        \n        ans = 0\n        \n        while points_remaining and dists:\n            dist,point = heapq.heappop(dists)\n            \n            if point not in points_remaining: continue\n                \n            points_remaining.remove(point)\n            ans += dist\n            \n            for p in points_remaining:\n                heapq.heappush(dists, (manh_dist(point, p), p))\n                \n        return ans\n", "class DSU:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1]*N\n        \n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        \n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n            \n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        return True\n    \n    def size(self, x):\n        return self.sz[self.find(x)]\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        edges = []\n        N = len(points)\n        for i in range(N):\n            for j in range(i+1,N):\n                d = abs(points[i][0]-points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append([d, i, j])\n                \n        edges.sort()\n        \n        dsu = DSU(N)\n        res = 0\n        \n        for d,u,v in edges:\n            if dsu.union(u, v):\n                res += d\n                \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        arr = [-1 for _ in range(len(points))]\n        def find(i):\n            while arr[i]>=0:\n                i = arr[i]\n            return i\n        \n        def union(x,y):\n            xp = find(x)\n            yp = find(y)\n            if xp==yp:\n                return False\n            arr[yp] = xp\n            #arr[yp]-=1\n            return True\n        \n        \n        for i in range(len(points)):\n            x, y = points[i]\n            for j in range(i+1,len(points)):\n                x1,y1 = points[j]\n                edges.append([abs(x-x1)+abs(y-y1),i,j])\n        edges = sorted(edges)\n        res = 0\n        for score,i,j in edges:\n            if union(i,j):\n                res+=score\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for i, p1 in enumerate(points):\n            for j in range(i, len(points)):\n                p2 = points[j]\n                \n                d = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n                edges.append([d, i, j])\n        edges = sorted(edges)\n\n        u = {i: i for i in range(n)}\n        \n        def head(i):\n            if u[i] == i:\n                return i\n            else:\n                h = head(u[i])\n                u[i] = h\n                return h\n            \n        def union(i, j):\n            u[head(j)] = head(i)\n        \n        r = 0\n        for d, i, j in edges:\n            hi, hj = head(i), head(j)\n            if hi != hj:\n                r += d\n                union(hi, hj)\n                \n        return r\n                \n        \n", "\nclass UnionFind:\n    def __init__(self, n):\n        self.groups = list(range(n))\n        self.size = [1] * n\n        \n    def find(self, i):\n        if self.groups[i] == i:\n            return i\n        p = self.find(self.groups[i])\n        self.groups[i] = p\n        return p\n    \n    def union(self, i, j):\n        pi = self.find(i) \n        pj = self.find(j)\n        if self.size[pi] < self.size[pj]:\n            self.groups[pi] = pj\n            self.size[pj] += self.size[pi]\n        else:\n            self.groups[pj] = pi\n            self.size[pi] += self.size[pj]\n        \n        \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        cost_array = []\n        \n        for i in range(len(points) - 1):\n            for j in range(i+1, len(points)):\n                weight = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                cost_array.append((weight, i, j))\n        cost_array.sort()\n        res = 0\n        uf = UnionFind(len(points))\n        for weight, i, j in cost_array:\n            if uf.find(i) == uf.find(j):\n                continue\n            uf.union(i, j)\n            res += weight\n        return res\n        \n        \n        \n        \n                \n                \n                \n", "from heapq import heappush,heappop\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        distsDict=[[None]*len(points) for _ in range(len(points))]\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                distsDict[i][j]=distsDict[j][i]=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n        q=[(0,0)]\n        visited=set()\n        totalCost=0\n        while q:\n            cost,point=heappop(q)\n            if point not in visited:\n                visited.add(point)\n                totalCost+=cost\n                for i in range(len(points)):\n                    if i!=point and not i in visited:\n                        heappush(q,(distsDict[point][i],i))\n        return totalCost", "# alright, whatever, time to solve it again in Python3 \\\\U0001f40d  whoo!\n\n# ok silly mistake, but that's A ok :)\n\nclass Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        N = len(A)\n        P = [i for i in range(N)]  # parent representatives of disjoint sets\n        E = []\n        for i in range(N):\n            x1, y1 = A[i]\n            for j in range(i + 1, N):\n                x2, y2 = A[j]\n                E.append([ abs(x1 - x2) + abs(y1 - y2), i, j ])\n        E.sort()\n        def find(x):\n            P[x] = P[x] if P[x] == x else find(P[x])\n            return P[x]\n        def union(a, b):\n            a = find(a)\n            b = find(b)\n            if a == b:\n                return False\n            P[a] = b   # arbitrary choice\n            return True\n        return sum([cost for cost, u, v in E if union(u, v)])\n        # for cost, u, v in E:\n        #     if union(u, v):\n        #         total += cost\n        # return total\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        data = [i for i in range(len(points))]\n        pq = []\n        res = 0\n        def helper(p1, p2):\n            return abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n        \n        def find(x):\n            if x != data[x]:\n                data[x] = find(data[x])\n                \n            return data[x]\n        \n        def union(x,y):\n            root_x = find(x)\n            root_y = find(y)\n            \n            if root_x == root_y:\n                return False\n            \n            data[root_x] = root_y\n            \n            return True\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                heapq.heappush(pq, (helper(points[i],points[j]),i,j))\n        \n        res = 0\n        \n        while pq:\n            cost, p1, p2 = heapq.heappop(pq)\n            if union(p1,p2):\n                res += cost\n        \n        \n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        arr = [-1 for _ in range(len(points))]\n        def find(i):\n            while arr[i]>=0:\n                i = arr[i]\n            return i\n        \n        def union(x,y):\n            xp = find(x)\n            yp = find(y)\n            if xp==yp:\n                return False\n            arr[yp] = xp\n            arr[xp]-=1\n            return True\n        \n        \n        for i in range(len(points)):\n            x, y = points[i]\n            for j in range(i+1,len(points)):\n                x1,y1 = points[j]\n                edges.append([abs(x-x1)+abs(y-y1),i,j])\n        edges = sorted(edges)\n        res = 0\n        for score,i,j in edges:\n            if union(i,j):\n                res+=score\n        return res", "class Solution:\n#     def minCostConnectPoints(self, points: List[List[int]]) -> int:\n#         n = len(points)\n#         if len(points) == 1: return 0\n#         res = 0\n#         curr = 0 # select a random point as the starting point\n#         dis = [math.inf] * n\n#         explored = set()\n        \n#         for i in range(n - 1):\n#             x0, y0 = points[curr]\n#             explored.add(curr)\n#             for j, (x, y) in enumerate(points):\n#                 if j in explored: continue\n#                 dis[j] = min(dis[j], abs(x - x0) + abs(y - y0))\n                \n#             delta, curr = min((d, j) for j, d in enumerate(dis)) \n#             dis[curr] = math.inf\n#             res += delta\n            \n#         return res\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        e = []\n        for i, p1 in enumerate(points):\n            for j in range(i + 1, n):\n                p2 = points[j]\n                w = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n                e.append((i, j, w))\n                e.append((j, i, w))\n        parents = [i for i in range(n)]\n        ranks = [1 for _ in range(n)]\n        def find(x):\n            while x != parents[x]:\n                parents[x] = parents[parents[x]]\n                x = parents[x]\n            return x\n        def union(x, y):\n            px, py = find(x), find(y)\n            if px == py:\n                return False\n            if ranks[px] > ranks[py]:\n                parents[py] = px\n            elif ranks[px] < ranks[py]:\n                parents[px] = py\n            else:\n                parents[py] = px\n                ranks[px] += 1\n            return True\n        res = 0\n        for u, v, w in sorted(e, key=lambda x: x[2]):\n            if not union(u, v):\n                continue\n            else:\n                res += w\n        return res", "class Solution:\n    def minCostConnectPoints(self, points):\n        distance = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        points.sort(key = lambda p: (p[0]) + (p[1]))\n        total_cost = 0\n        points = [[p, distance(p, points[0])] for p in points]\n        while points:\n            minIdx, mindist = None, float('inf')\n            for i, (p1, dist) in enumerate(points):\n                if dist < mindist:\n                    minIdx, mindist = i, dist\n            p1, cost = points.pop(minIdx)\n            total_cost += cost\n            for i, (p2, dist) in enumerate(points):\n                newdist = distance(p1, p2)\n                if newdist < dist:\n                    points[i][1] = newdist\n        return total_cost        ", "class Solution:\n    def addEdge(self,source, dest, weight):\n        self.graph.append([tuple(source), tuple(dest), weight])\n        \n    def getParent(self, vertex):\n        if vertex == self.parent[vertex]:\n            return vertex\n        return self.getParent(self.parent[vertex])\n        \n    def joinTrees(self, u, v):\n        xroot = self.getParent(u)\n        yroot = self.getParent(v)\n        \n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[yroot] < self.rank[xroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[yroot]+=1\n        \n        \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        self.graph = []\n        \n        for i in range(0, len(points)):\n            for j in range(i+1, len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) \n                self.addEdge(points[i], points[j], dist)\n        \n        self.V = len(points)\n        \n        e = 0\n        self.parent = {tuple(points[i]): tuple(points[i]) for i in range(0, len(points))}\n        self.rank = {tuple(points[i]): 0 for i in range(0, len(points))}\n        \n        \n        self.graph = sorted(self.graph, key = lambda x: x[2])\n        \n        i = 0\n        tot = 0\n        \n        while e < self.V-1:\n            \n            u, v, w = self.graph[i]\n            i+=1\n            uroot = self.getParent(u)\n            vroot = self.getParent(v)\n            \n            if uroot != vroot:\n                self.joinTrees(u, v)\n                tot+=w\n                e+=1\n        return tot\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int: \n        def pdist(i, j): \n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        N = len(points)\n        pvisited = [False] * N\n        h = []\n        mincost = 0\n        heappush(h, (0, 0))\n        while h: \n            dist, el = heappop(h)\n            if not pvisited[el]: \n                pvisited[el] = True\n                mincost += dist\n                for i in range(N): \n                    if not pvisited[i]: \n                        heappush(h, (pdist(el, i), i))\n        return mincost\n        \n        \n", "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        \n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self, x, y):\n        px = self.find(x) \n        py = self.find(y)\n        if px != py:\n            self.par[px] = py\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) <= 1:\n            return 0\n        def dist(x1, y1, x2, y2):\n            return abs(x2-x1) + abs(y2-y1)\n        lens = []\n        res = 0\n        n = len(points)\n        dsu = DSU(n)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                lens.append((dist(points[i][0], points[i][1], points[j][0], points[j][1]), i, j))\n        heapq.heapify(lens)\n        while lens:\n            dist, i, j = heapq.heappop(lens)\n            if dsu.find(i) != dsu.find(j):\n                dsu.union(i, j)\n                res += dist\n        return res", "class Solution:\n  def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    if len(points) == 1:\n      return 0\n    \n    def get_dist(p1, p2):\n      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    seen, res = set([0]), 0\n    \n    heap = [(get_dist(points[0], p2), i + 1) for i, p2 in enumerate(points[1:])]\n    heapq.heapify(heap)\n\n    while heap:\n      dist, index = heapq.heappop(heap)\n      \n      if index in seen:\n        continue\n\n      seen.add(index)\n      res += dist\n      \n      for i in range(len(points)):\n        if i != index and i not in seen:\n          heapq.heappush(heap, (get_dist(points[i], points[index]), i))\n        \n    return res\n      \n", "class Solution:\n    def __init__(self):\n        self.parent = dict()\n        self.rank = dict()\n\n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x: int, y: int) -> None:\n        if self.rank[x] > self.rank[y]:\n            self.parent[y] = x\n        elif self.rank[y] > self.rank[x]:\n            self.parent[x] = y\n        else:\n            self.rank[x] += 1\n            self.parent[y] = x\n        \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        l = len(points)\n        ans = 0\n        if l > 1:\n            heap = list()\n            for i in range(l-1):\n                self.parent[i] = i\n                self.rank[i] = 0\n                for j in range(i+1,l):\n                    heap.append((abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),i,j))\n            self.parent[l-1] = l-1\n            self.rank[l-1] = 0\n            heapq.heapify(heap)\n            while heap:\n                dis,x,y = heapq.heappop(heap)\n                if self.find(x) != self.find(y):\n                    ans += dis\n                    self.union(self.find(x),self.find(y))\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        self.parent = list(range(len(points)))\n        self.rank = [1]*len(points)\n        \n        def find(a):\n            if self.parent[a] != a:\n                self.parent[a] = find(self.parent[a])\n            return self.parent[a]\n        \n        def union(a,b):\n            p1 = find(a)\n            p2 = find(b)\n            if p1 == p2: return False\n            if self.rank[p1] > self.rank[p2]:\n                self.parent[p2] = p1\n            else:\n                if self.rank[p1] < self.rank[p2]:\n                    self.parent[p1] = p2\n                else:\n                    self.parent[p1] = p2\n                    self.rank[p2] += 1\n            return True\n        \n        def dist(a,b):\n            return abs(a[0]-b[0])+abs(a[1]-b[1])\n        \n        weights = {}\n        edges = []\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                weights[(i,j)] = dist(points[i], points[j])\n                edges.append((i,j))\n        \n        edges.sort(key=lambda x: weights[x])\n        \n        ans = 0\n        \n        for e in edges:\n            if union(e[0],e[1]):\n                ans += weights[e]\n                \n        return ans\n        \n", "class DSU:\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.cc = n\n    \n    def find(self, u):\n        orig = u\n        while u != self.parents[u]:\n            u = self.parents[u]\n        \n        self.parents[orig] = u\n        return u\n    \n    def union(self, u, v):\n        u,v = sorted([self.find(u),self.find(v)])\n        \n        if u!=v:\n            self.parents[v] = u\n            self.cc -= 1\n            return True\n        return False\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        distances = {}\n        \n        def compute(p1,p2):\n            x1,y1 = p1\n            x2,y2 = p2\n            return abs(x1-x2)+abs(y1-y2)\n        \n        heap = []\n        for i,p1 in enumerate(points):\n            for j in range(i+1,len(points)):\n                p2 = points[j]\n                heapq.heappush(heap, (compute(p1,p2),i,j))\n        \n        dsu = DSU(len(points))\n        \n        res = 0\n        while heap:\n            d,u,v = heapq.heappop(heap)\n            if dsu.union(u,v):\n                res+=d\n        return res\n", "from queue import PriorityQueue\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        q = PriorityQueue() # queue of (dist, x, y)\n        x0, y0 = points[0]\n        for x, y in points[1:]:\n            q.put([abs(x - x0) + abs(y - y0), x, y])\n        cost = 0\n        to_process = set([(x, y) for x, y in points[1:]])\n        while len(to_process) > 0:\n            d, x, y = q.get()\n            if (x, y) not in to_process:\n                continue\n            to_process.remove((x, y))\n            cost += d\n            for nx, ny in to_process:\n                q.put([abs(x - nx) + abs(y - ny), nx, ny])\n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        mx = -1\n        inc = set()\n        d = {}\n        parent = []\n        rank = []\n        result = []\n        i = 0\n        e = 0\n        nodes = {}\n        idx = 0\n        for i in range(n):\n            nodes[idx] = (points[i][0],points[i][1])\n            idx+=1\n        graph = []\n        for i in range(n):\n            d[i] = []\n            for j in range(n):\n                if i == j:\n                    continue\n                graph.append([i,j,abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])])\n        graph.sort(key=lambda x : x[2])  \n        def find(parent,i):\n            if parent[i] == i:\n                return i\n            return find(parent,parent[i])\n        \n        def union(parent,rank,x,y):\n            xroot = find(parent,x)\n            yroot = find(parent,y)\n            \n            if rank[xroot] < rank[yroot]:\n                parent[xroot] = yroot\n            elif rank[yroot] < rank[xroot]:\n                parent[yroot] = xroot\n            else:\n                parent[yroot] = xroot\n                rank[xroot] += 1\n                \n        for node in range(n):\n            parent.append(node)\n            rank.append(0)\n        i = 0\n        ans = 0\n        while e < n-1:\n            u,v,w = graph[i]\n            i+=1\n            x = find(parent,u)\n            y = find(parent,v)\n            if x != y:\n                e = e+1\n                ans += w\n                union(parent,rank,x,y)\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        res = 0\n        n = len(points)\n        dist = [0] * n\n        def distance(px, py):\n            return abs(px[0] - py[0]) + abs(px[1] - py[1])\n        for i in range(1, n):\n            dist[i] = distance(points[0], points[i])\n        flag = [0] * n\n        flag[0] = 1\n        for i in range(1, n):\n            mi = math.inf\n            index = -1\n            for j in range(1, n):\n                if flag[j]:\n                    continue\n                if mi > dist[j]:\n                    index = j\n                    mi = dist[j]\n            flag[index] = 1\n            res += mi\n            for j in range(1, n):\n                if flag[j]:\n                    continue\n                dist[j] = min(dist[j], distance(points[j], points[index]))\n        return res\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        l=len(points)\n        parent=[i for i in range(l)]\n        def find(a):\n            if parent[a]!=a:\n                parent[a]=find(parent[a])\n            return parent[a]\n        \n        def union(a,b):\n            p1=find(a)\n            p2=find(b)\n            parent[p2]=p1\n        \n        \n        import heapq\n        def new_cmp_lt(self,a,b):\n            return a[0]-b[0]\n        heapq.cmp_lt=new_cmp_lt\n        res=0\n        \n        p=[]\n        for i in range(l):\n            for j in range(i+1,l):\n                p1=points[i]\n                p2=points[j]\n                d=abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n                heapq.heappush(p,[d,i,j])\n        while p:\n            t=heapq.heappop(p)\n            d=t[0]\n            p1=t[1]\n            p2=t[2]\n            if find(p1)!=find(p2):\n                union(p1,p2)\n                res+=d\n        return res\n        \n", "class DSU:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.r = [0] * n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    def union(self, x, y):\n        p_x = self.find(x)\n        p_y = self.find(y)\n        if p_x != p_y:\n            if self.r[p_y] > self.r[p_x]:\n                self.p[p_x] = p_y\n            else:\n                self.p[p_y] = p_x\n                if self.r[p_y] == self.r[p_x]:\n                    self.r[p_x] += 1\n            return True\n        return False\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n < 2:\n            return 0\n        \n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        dic = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                dic[(i, j)] = dist(points[i], points[j])\n                \n        o = sorted(list(dic.items()), key = lambda v: v[1])\n        dsu = DSU(n)\n        res = 0\n        for pts, cost in o:\n            p1, p2 = pts\n            if dsu.union(p1, p2):\n                res += cost\n        \n        return res\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        dic = {}\n        for i in range(n - 1):\n            x1, y1 = points[i]\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                dic[(i, j)] = dist\n        \n        root = [i for i in range(n)]\n        \n        def find(n):\n            if root[n] != n:\n                root[n] = find(root[n])\n            return root[n]\n        \n        def union(x, y):\n            s1 = find(x)\n            s2 = find(y)\n            if s1 != s2:\n                root[s2] = root[s1]\n                return 1\n            return 0\n                \n        dic_sorted = sorted(list(dic.items()), key=lambda x: x[1])\n        res = 0\n        for item in dic_sorted:\n            x, y = item[0]\n            dist = item[1]\n            if union(x, y) == 1:\n                res += dist\n        return res\n            \n                \n                \n        \n                    \n                \n        \n        \n        \n                \n                \n                \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(u, v):\n            x, y = points[u]\n            x2, y2 = points[v]\n            return abs(x - x2) + abs(y - y2)\n        \n        n = len(points)\n        visited = [False] * (n)\n        pq = [(0, 0)]\n        ans = 0\n        while pq:\n            cost, u = heappop(pq)\n            if visited[u]: continue\n            visited[u] = True\n            ans += cost\n            for v in range(n):\n                if visited[v]: continue\n                heappush(pq, (dist(u, v), v))\n                \n        return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        dist = []\n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                d = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                dist.append([d, i, j])\n        dist.sort()\n\n        graph = {i: set() for i in range(len(points))}\n\n        def has_cycle(node, prev, parent):\n            if node in prev:\n                return True\n            prev.add(node)\n            for next_node in graph[node]:\n                if next_node != parent and next_node in prev:\n                    return True\n                if next_node != parent and has_cycle(next_node, prev, node):\n                    return True\n            return False\n\n        cost = 0\n        n_edge = 0\n        for d, i, j in dist:\n            if n_edge == len(points) - 1:\n                break\n            graph[i].add(j)\n            graph[j].add(i)\n            if (not has_cycle(i, set(), None)) and (not has_cycle(j, set(), None)):\n                n_edge += 1\n                cost += d\n            else:\n                graph[i].remove(j)\n                graph[j].remove(i)\n\n        return cost\n", "#minima spanning tree\n#greedy add min edge and check cycle\n#union group to check cycly\n\nimport heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(points, i, j) -> int:\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        \n        def getGroup(group, x):\n            if group[x] == x: return x\n            group[x] = getGroup(group, group[x])\n            #print(\\\"x = {}, group[x] = {}\\\".format(x, group[x]))\n            return group[x]\n        \n        def isCycle(group, cur):\n            g1 = getGroup(group, cur[1])\n            g2 = getGroup(group, cur[2])\n            #print(\\\" is Cycle ? g1 = {}, g2 = {}\\\".format(g1,g2))\n            return g1 == g2\n        \n        def unio(group, cur):\n            g1 = getGroup(group, cur[1])\n            g2 = getGroup(group, cur[2])\n            group[g2] = g1\n        \n        pq, group = [], []\n        n = len(points)\n        for i in range(n):\n            group.append(i)\n            for j in range(i+1, n):\n                dis = distance(points, i, j)\n                heapq.heappush(pq, (dis, i, j))\n                \n        #print([heappop(pq) for i in range(len(pq))])\n        #print(\\\"group = \\\" + str(group))\n        count, rtn = 0, 0        \n        while count < n-1 :\n            cur = heapq.heappop(pq)\n            #print(cur)\n            \n            if not isCycle(group, cur): \n             #   print(\\\"{} and {}\\\".format(cur[1], cur[2]))\n                unio(group, cur)\n                rtn += cur[0]\n                count += 1\n            \n        \n        \n        return rtn;\n    \n                    \n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = collections.defaultdict(int)\n        for i in range(1, n + 1):\n            self.parent[i] = i\n\n    def find(self, i):\n        if i != self.parent[i]:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, u, v):\n        u_parent, v_parent = self.find(u), self.find(v)\n        if u_parent == v_parent: return False\n        self.parent[u_parent] = v_parent\n        return True\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        pq = list()\n        heapq.heapify(pq)\n        for i in range(n - 1):\n            for j in range(i+1, n):\n                # get distance\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(pq, (dist, i, j))\n        res = 0\n        uf = UnionFind(n)\n        while pq:\n            cost, a, b = heapq.heappop(pq)\n            if uf.find(a) != uf.find(b):\n                uf.union(a, b)\n                res += cost\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n\n        edges = []\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                u, v = points[i]\n                p, q = points[j]\n                w = abs(u - p) + abs(v - q)\n                edges.append([w, i, j])\n\n        path = {u:u for u in range(n)}\n\n        def find(u: int) -> int:\n            if path[u] != u:\n                path[u] = find(path[u])\n            return path[u]\n\n        def union(u: int, v: int) -> bool:\n            i, j = find(u), find(v)\n            if i == j: return False\n            if j > i:\n                i, j = j, i\n            path[j] = i\n            return True\n\n        costs = 0\n        edges.sort()\n        for w, u, v in edges:\n            if find(u) != find(v):\n                costs += w\n                union(u, v)\n        return costs\n", "class Solution:\n    def minCostConnectPoints(self, A: List[List[int]]) -> int:\n        def distance(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        dic = {}\n        def find(i):\n            dic.setdefault(i, i)\n            if dic[i] != i:\n                dic[i] = find(dic[i])\n            return dic[i]\n        def union(i, j):\n            fi, fj = find(i), find(j)\n            if fi != fj:\n                dic[fi] = fj\n                return 1\n            return 0\n        dis = []\n        n = len(A)\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = distance(A[i], A[j])\n                dis.append([d, i, j])\n        dis = sorted(dis)\n        ret, ct = 0, 0\n        for d, i, j in dis:\n            if union(i, j):\n                ret += d\n                ct += 1\n                if ct == n: break\n        return ret", "class Union_Find:\n    def __init__(self, n):\n        self.father = {i:i for i in range(n)}\n        self.count = n\n        # \u53ef\u4ee5\u67e5\u770b \u67d0\u4e00\u4e2anode \u6709\u51e0\u4e2a\u8054\u901a\n        self.rank = [1] * n\n\n    def find(self, x):\n        if self.father[x] == x:\n            return x\n        self.father[x] = self.find(self.father[x])\n        return self.father[x]\n\n    def union(self, x, y):\n        if self.rank[x] < self.rank[y]:\n            x, y = y, x\n        self.father[y] = x\n        self.rank[x] += self.rank[y]\n        self.count -= 1\n\n    def find_union(self, x, y):\n        father_x, father_y = self.find(x), self.find(y)\n        if father_x != father_y:\n            self.union(father_x, father_y)\n            # \u8868\u793a\uff0c\u5982\u679c\u672c\u6765\u4e0d\u662f\u8054\u901a return true\n            return True\n        return False\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        mst = collections.defaultdict(set)\n        edges = []\n        n = len(points)\n        graph = collections.defaultdict(list)\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if i == j:\n                    continue\n                cost = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((cost, i, j))\n        uf = Union_Find(n)\n        heapq.heapify(edges)\n        result = 0\n        while edges:\n            cost, frm, to = heapq.heappop(edges)\n            if uf.find_union(frm, to):\n                result += cost\n                print((frm,to))\n        return result\n                \n                \n                \n            \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        def dist(a, b):\n            return (abs(a[0]-b[0]) + abs(a[1]-b[1]))\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                edges.append([dist(points[i], points[j]), i, j])\n        edges.sort()\n        st = set()\n        ans = 0\n        \n        \n        root_ = [i for i in range(len(points))]\n        comp = [1 for i in range(len(points))]\n        \n        def root(i):\n            while root_[i] != i:\n                i = root_[i]\n            return i\n        \n        def union(i, j):\n            if root(i) == root(j):\n                return \n            else:\n                rooti = root(i)\n                rootj = root(j)\n                \n                if comp[rooti] > comp[rootj]:\n                    root_[rootj] = rooti\n                    comp[rooti] += comp[rootj]\n                else:\n                    root_[rooti] = rootj\n                    comp[rootj] += comp[rooti]\n                    \n                \n        \n        \n        \n        for i in edges:\n            if root(i[1]) == root(i[2]):\n                continue                \n            else:\n                union(i[1], i[2])\n                ans += i[0]\n        return ans", "import heapq\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) < 1:\n          return 0\n        def dist(point1, point2):\n          return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n#         mat = []\n#         for x, point1 in enumerate(points):\n#           mat.append([])\n#           for y, point2 in enumerate(points):\n#             if x == y:\n#               dis = float('inf') \n#             else:\n#               dis = abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n#             mat[-1].append(dis)\n        \n        \n        heap = []\n        connected = set([0])\n        for i, point in enumerate(points):\n          if i == 0:\n            continue\n          heapq.heappush(\n            heap,\n            (\n              dist(point, points[0]),\n              i,\n              0,\n            )\n          )\n        res = 0\n        while len(connected) != len(points):\n          dis, p, f = heapq.heappop(heap)\n          if p not in connected:\n            res += dis\n            connected.add(p)\n            \n          for i, point in enumerate(points):\n            if i == p or i in connected:\n              continue\n            heapq.heappush(\n              heap,\n              (\n                dist(point, points[p]),\n                i,\n                p,\n              )\n            )\n        return res", "import heapq\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n=len(points)\n        hq,d,s=[(0,0)],[1]*n,0\n        while hq:\n            t,i=heapq.heappop(hq)\n            if d[i]:\n                s+=t\n                d[i]=0\n                for j in range(n):\n                    if d[j]:\n                        heapq.heappush(hq,(abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),j))\n        return s", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        n = len(points)\n        \n        def dist(i, j):\n            return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        \n        heap = []\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                heap.append((dist(i, j), i, j))\n        heapq.heapify(heap)\n        \n        def find(i):\n            if p[i] != i:\n                p[i] = find(p[i])\n            return p[i]\n        \n        def union(i, j):\n            p[find(i)] = find(j)\n        \n        p = list(range(n))\n        \n        num_edges = 0\n        res = 0\n        while heap and num_edges < n:\n            (d, i, j) = heapq.heappop(heap)\n            \n            if find(i) == find(j):\n                continue\n            \n            union(i, j)\n            num_edges += 1\n            \n            res += d\n            \n        return res\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        hq = []\n        parent = len(points)*[0]\n        cnt = len(points)*[0]\n        for i in range(len(points)):\n            parent[i]=i\n            \n        for i in range(len(points)-1):\n            for j in range(i+1, len(points)):\n                dist = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                heappush(hq, [dist, i, j])\n        visited = {}\n        ans = 0\n        \n        def find_parent(i):\n            if(parent[i]==i):\n                return i\n            else:\n                x = find_parent(parent[i])\n                parent[i]=x\n                return x\n            \n        def update_parent(i,j):\n            x = find_parent(i)\n            y = find_parent(j)\n            if(cnt[x]<cnt[y]):\n                parent[x]=y\n                cnt[y]+=1\n            else:\n                parent[y]=x\n                cnt[x]+=1\n            \n        while(len(hq)!=0):\n            ce = heappop(hq)\n            if find_parent(ce[1]) != find_parent(ce[2]):\n                ans+=ce[0]\n                update_parent(ce[1], ce[2])\n        return ans\n                \n", "class Solution:\n    def distance(self, p1, p2):\n        return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n    \n    def build_graph(self, points):\n        res = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                res.append([i, j, self.distance(points[i], points[j])])\n        return res\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        connections = self.build_graph(points)        \n        connections.sort(key=lambda x:x[2])\n        parents = [i for i in range(len(points))]\n        \n        def find(node):\n            parent = parents[node]\n            while node != parent:\n                node = parent\n                parent = parents[node]\n            return node\n    \n        cost = 0    \n\n        for edge in connections:\n            node1 = edge[0]\n            node2 = edge[1]\n            curr_cost = edge[2]\n\n            if find(node1) != find(node2):\n                parents[find(node2)] = find(node1)\n                cost += curr_cost            \n\n        return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # try minimum spanning treee\n        \n        to_visit = set(range(1, len(points)))\n        pq = [(abs(points[0][0] - points[x][0]) + abs(points[0][1] - points[x][1]), 0, x) for x in range(1, len(points))]\n        heapq.heapify(pq)\n        ans = 0\n        while pq:\n            cost, frm, to = heapq.heappop(pq)\n            if to in to_visit:\n                to_visit.remove(to)\n                ans += cost\n                for nei in to_visit:\n                    x, y = points[nei]\n                    heapq.heappush(pq, (abs(x-points[to][0]) + abs(y-points[to][1]), to, nei))\n\n        return ans\n        \n        \n        \n            \n            \n\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def distance(point1,point2):\n            return abs(point1[0]-point2[0])+abs(point1[1]-point2[1])\n        \n        n = len(points)\n        edges = []\n        \n        for i in range(n):\n            for j in range(i+1,n):\n                \n                edges.append([distance(points[i],points[j]),i,j])\n        \n        edges.sort()\n        \n        p = [i for i in range(n)]\n        \n        def find(x):\n            if p[x]!=x:\n                p[x]=find(p[x])\n            return p[x]\n        def union(x,y):\n            px = find(x)\n            py = find(y)\n            \n            if px==py:\n                return True\n            \n            else:\n                p[px]=p[py]\n        res = 0\n        for edge in edges:\n            d,x,y = edge\n            if union(x,y):\n                continue\n            else:\n                res+=d\n        return res\n            \n            \n", "class Solution:\n    def manhattan_distance(self,a,b):\n        return abs(a[0]-b[0])+abs(a[1]-b[1])\n    \n    def find(self,x):\n        while x in self.parent:\n            while self.parent[x] in self.parent:\n                self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n            \n        \n        \n    def union(self,x,y):\n        x_find=self.find(x)\n        y_find=self.find(y)\n        if(x_find!=y_find):\n            self.parent[x_find]=y_find\n            return True\n        \n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        self.parent={}\n        ls=[]\n        for i in range(len(points)):\n            for j in range(i+1,len(points)):\n                ls.append([self.manhattan_distance(points[i],points[j]),i,j])\n        # print(ls)\n        ls=sorted(ls,key=lambda x:x[0])\n        # print(ls)\n        \n        ans=0\n        for i in range(len(ls)):\n            if(self.union(ls[i][1],ls[i][2])):\n                ans+=ls[i][0]\n            # print(self.parent)\n        return ans\n        \n                \n        \n        \n", "\nclass UnionFind:\n    def __init__(self, n):\n        self.groups = list(range(n))\n        \n    def find(self, i):\n        if self.groups[i] == i:\n            return i\n        p = self.find(self.groups[i])\n        self.groups[i] = p\n        return p\n    \n    def union(self, i, j):\n        pi = self.find(i) \n        pj = self.find(j)\n        \n        self.groups[pi] = pj\n        \n        \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        cost_array = []\n        \n        for i in range(len(points) - 1):\n            for j in range(i+1, len(points)):\n                weight = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                cost_array.append((weight, i, j))\n        cost_array.sort()\n        res = 0\n        uf = UnionFind(len(points))\n        for weight, i, j in cost_array:\n            if uf.find(i) == uf.find(j):\n                continue\n            uf.union(i, j)\n            res += weight\n        return res\n        \n        \n        \n        \n                \n                \n                \n", "from heapq import heappush, heappop\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        dists = [[float('inf')] * n for _ in range(n)]\n        for idx1, point1 in enumerate(points):\n            for idx2, point2 in enumerate(points):\n                if idx1 != idx2:\n                    manhattan = abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n                    dists[idx1][idx2] = manhattan\n                    dists[idx2][idx1] = manhattan\n        \n        res = 0\n        nearest = [float('inf')] * n\n        visited = set()\n        h = [(0, 0)]\n        while h and len(visited) < n:\n            last_dist, last_pt = heappop(h)\n            visited.add(last_pt)\n            nearest[last_pt] = min(last_dist, nearest[last_pt])\n            for neigh_pt, neigh_dist in enumerate(dists[last_pt]):\n                if neigh_pt not in visited and neigh_dist < nearest[neigh_pt]:\n                    heappush(h, (neigh_dist, neigh_pt))\n            \n        return sum(nearest)", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n\n        edges = []\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                u, v = points[i]\n                p, q = points[j]\n                w = abs(u - p) + abs(v - q)\n                edges.append([w, i, j])\n\n        path = [u for u in range(n)]\n\n        def find(u: int) -> int:\n            if path[u] != u:\n                path[u] = find(path[u])\n            return path[u]\n\n        def union(u: int, v: int) -> None:\n            i, j = find(u), find(v)\n            if i != j:\n                if j > i:\n                    i, j = j, i\n                path[j] = i\n\n        costs = 0\n        edges.sort()\n        for w, u, v in edges:\n            if find(u) != find(v):\n                costs += w\n                union(u, v)\n        return costs\n", "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def __lt__(self, other):\n        return [self.x, self.y] < [other.x, other.y]\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        points = [Point(x, y) for x, y in points]\n        edges = []\n        \n        def getDistance(a, b):\n            return abs(a.x - b.x) + abs(a.y - b.y)\n        visited = set()\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                u, v = points[i], points[j]\n                edges.append((getDistance(u, v), u, v))\n\n        edges.sort(reverse=True)\n        self.parent = {p : p for p in points}\n        self.size = {p : 1 for p in points}\n        components = len(points)\n        \n        total_cost = 0\n        while components > 1 and edges:\n            d, u, v = edges.pop()\n            if self.union(u, v):\n                total_cost += d\n                components -= 1\n        return total_cost\n        \n                \n    def union(self, a, b):\n        root_a = self.find(a)\n        root_b = self.find(b)\n        if root_a != root_b:\n            if self.size[root_a] <= self.size[root_b]:\n                self.parent[root_a] = root_b\n                self.size[root_b] += self.size[root_a]\n            else:\n                self.parent[root_b] = root_a\n                self.size[root_a] += self.size[root_b]\n            return True\n        return False\n            \n    def find(self, a):\n        curr = a\n        while self.parent[curr] != curr:\n            curr = self.parent[curr]\n        root, curr = curr, a\n        while self.parent[curr] != curr:\n            self.parent[curr], curr = root, self.parent[curr]\n        return root", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def dist(p1, p2):\n            x1, y1 = p1\n            x2, y2 = p2\n            return abs(x1-x2) + abs(y1-y2)\n        \n        import collections\n        import heapq\n        \n        edges = []\n        #G = collections.defaultdict(dict)\n        for i in range(len(points)):\n            for j in range(len(points)):\n                if i != j:\n                    edges.append([i, j, dist(points[i], points[j])])\n        #print(\\\"eges is \\\", edges)            \n\n        def primLazy(edges, n): # n nodes from 0 to n-1\n\n            def visit(v):\n                included[v] = True\n                for neighbor in G[v]:\n                    if not included[neighbor]:\n                        heapq.heappush(pq, [G[v][neighbor], v, neighbor])\n\n            G = collections.defaultdict(dict)\n            for v, w, weight in edges:\n                G[v][w] = weight\n                G[w][v] = weight\n    \n            included =[False for i in range(n)] # vertices that are in the tree, Sedgewick uses marked\n            mst = [] # edges already added to the spanning tree\n            pq = [] # edges that are crossing from included vertices to not, and ineligible edges\n            visit(points[0]) # start with edge 0\n            d = 0\n            while pq:\n                dist, v, w = heapq.heappop(pq)\n                if included[v] and included[w]:\n                    continue\n                mst.append([v,w])\n                d += G[v][w]\n                if not included[v]:\n                    visit(v)\n                if not included[w]:\n                    visit(w)\n            return mst\n        \n        def kruskalSize(edges, n): # edges should be of form [v, w, weight]\n\n            parent = [i for i in range(n)] # sets up default parents for union find\n            sz = [1 for i in range(n)] # creates size for each group, num of items\n\n            def find(i):\n                while i != parent[i]:\n                    i = parent[i]\n                return i\n\n            def union(x,y):\n                rx, ry = find(x), find(y)\n                if rx == ry:\n                    return\n                if sz[rx] < sz[ry]:\n                    parent[rx] = ry\n                    sz[ry] += sz[rx]\n                else:\n                    parent[ry] = rx\n                    sz[rx] += sz[ry]\n\n            mst = []\n            d = 0\n            edges = sorted(edges, key = lambda x: x[2])\n            for v, w, weight in edges:\n                if find(v) != find(w):\n                    mst.append([v,w])\n                    #print(\\\"just added edge \\\",v,w,weight)\n                    d += weight\n                    union(v,w)\n            return d\n\n        \n        return kruskalSize(edges, len(points))\n                    \n", "from collections import defaultdict\nclass Solution:\n    def find(self, parent, i): \n        if parent[i] == i: \n            return i \n        return self.find(parent, parent[i]) \n    \n    def union(self, parent, rank, x, y): \n        xroot = self.find(parent, x) \n        yroot = self.find(parent, y) \n        if rank[xroot] < rank[yroot]: \n            parent[xroot] = yroot \n        elif rank[xroot] > rank[yroot]: \n            parent[yroot] = xroot \n        else : \n            parent[yroot] = xroot \n            rank[xroot] += 1\n            \n    def KruskalMST(self): \n        result =[] \n        i = 0 \n        e = 0  \n        self.graph =  sorted(self.graph,key=lambda item: item[2]) \n        parent = [] ; rank = [] \n        for node in range(self.V): \n            parent.append(node) \n            rank.append(0) \n        while e < self.V -1 : \n            u,v,w =  self.graph[i] \n            i = i + 1\n            x = self.find(parent, u) \n            y = self.find(parent ,v) \n            if x != y: \n                e = e + 1     \n                result.append([u,v,w]) \n                self.union(parent, rank, x, y)\n        summ = 0\n        for u,v,weight  in result: \n            summ += weight\n        return summ\n            \n            \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        self.V = len(points)\n        # [0 for i in range(len(points))] for i in range(len(points))\n        self.graph = [  ]\n        for i in range(len(points)):\n            for j in range(len(points)):\n                md = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])\n                self.graph.append([i,j,md]) \n        return self.KruskalMST()", "class DisjointSet():\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1]*n \n\n    def find(self, x):\n        if self.parent[x] == x: return x \n        return self.find(self.parent[x])\n\n    def union(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n        if px == py: return\n        if self.rank[px] > self.rank[py]:\n            self.parent[py] = px \n            self.rank[px] += self.rank[py] \n        else: \n            self.parent[px] = py \n            self.rank[py] += self.rank[px]\n    \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        def ManhattanDistance(p1,p2):\n            x1,y1 = p1; \n            x2,y2 = p2;\n            return abs(x2-x1)+abs(y2-y1)\n\n        edges = [(ManhattanDistance(points[i], points[j]),i,j) for i in range(n) for j in range(i+1, n)]\n        edges.sort()\n\n        graph = DisjointSet(n)\n        ans = 0\n        for cost, u, v in edges:\n            if graph.find(u) != graph.find(v): \n                graph.union(u,v)\n                ans += cost \n\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        params = {}\n        for x, i in enumerate(points):\n            for j in points[x+1:]:\n                s = str(i[0]) + \\\" \\\" + str(i[1]) + \\\" \\\" + str(j[0]) + \\\" \\\" + str(j[1])\n                params[s] = abs(i[0]-j[0])+abs(i[1]-j[1])\n        d = {k: v for k, v in sorted(params.items(), key=lambda item: item[1])}\n        ds = []\n        vl = {}\n        v = 0\n        for i in d:\n            ln1, rn1, ln2, rn2 = i.split()\n            v1 = -1\n            v2 = -1\n            for y, j in enumerate(ds):\n                if ln1+\\\" \\\"+rn1 in j:\n                    v1 = y\n                if ln2+\\\" \\\"+rn2 in j:\n                    v2 = y\n            if v1 < 0 and v2 < 0:\n                ds.append({ln1+\\\" \\\" +rn1, ln2+\\\" \\\" +rn2})\n            elif v1 == v2:\n                continue\n            elif v1 < 0 and v2 >= 0:\n                ds[v2] = ds[v2].union({ln1+\\\" \\\" +rn1})\n                vl[ln1+\\\" \\\" +rn1] = True\n            elif v1 >= 0 and v2 < 0:\n                ds[v1] = ds[v1].union({ln2+\\\" \\\" +rn2})\n                vl[ln2+\\\" \\\" +rn2] = True\n            elif v1 != v2:\n                n = ds[v1].union(ds[v2])\n                if v2 > v1:\n                    ds.pop(v2)\n                    ds.pop(v1)\n                else:\n                    ds.pop(v1)\n                    ds.pop(v2)\n                ds.append(n)\n            v += d[i]\n            if len(ds) == 1 and len(ds[0]) == len(points):\n                return v\n        return v\n        \n                \n                ", "class DSU:\n    \n    def __init__(self, a):\n        self.par = {x:x for x in a}\n    \n    def merge(self, u, v):\n        rootu = self.find(u)\n        rootv = self.find(v)\n        \n        if rootu == rootv:\n            return False\n        \n        self.par[rootv] = rootu\n        return True\n    \n    def find(self, u):\n        if self.par[u] != u:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n\nclass Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:\n        \n        def manhattan_dist(u, v):\n            return abs(u[0] - v[0]) + abs(u[1] - v[1])\n        \n        n = len(a)\n        \n        a = [tuple(x) for x in a]\n        \n        dsu = DSU(a)\n        \n        # [u,v,c]\n        edges = []\n        \n        for u,v in combinations(a, 2):\n            edges.append((u, v, manhattan_dist(u, v)))\n        \n        edges.sort(key=lambda x: x[2])\n        \n        ret = 0\n        \n        for u,v,c in edges:\n            if dsu.merge(u,v):\n                ret += c\n                \n        return ret", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        import heapq\n        \n        HQ = []\n        \n        heapq.heapify(HQ)\n        \n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dist = abs(points[j][0] - points[i][0]) + abs(points[j][1] - points[i][1])\n                heapq.heappush(HQ, (dist, i, j))\n        \n        G = list(range(len(points)))\n        \n        def find(x):\n            if G[x] != x:\n                G[x] = find(G[x])\n            return G[x]\n        \n        def union(x, y):\n            x, y = find(x), find(y)\n            if x == y:\n                return False\n            G[x] = y\n            return True\n        \n        res = 0\n        while HQ:\n            curdist, curi, curj = heapq.heappop(HQ)\n            if union(curi, curj):\n                res += curdist\n        \n        return res", "import heapq\n\nclass Solution:\n  def minCostConnectPoints(self, points: List[List[int]]) -> int:\n    n = len(points)\n    mst_nodes = [0 for i in range(n)]\n    #mst_edges = set() # (int,int)\n    h = []  # heap of edges connected to MST (distance, source, dest)\n    man_dist = lambda i,j: abs( points[i][0] - points[j][0] ) + abs( points[i][1] - points[j][1] )\n    \n    mst_nodes[0] = 1\n    for p in range(1,n):\n      h.append( (man_dist(0,p),0,p) )\n    heapq.heapify(h)\n\n    tot_dist = 0\n    while h:\n      dist, src_node, dst_node = heapq.heappop(h)\n      if mst_nodes[dst_node]:\n        continue\n      tot_dist += dist\n      mst_nodes[dst_node] = 1\n      for next_dst in range(n):\n        if mst_nodes[next_dst]==0:\n          heapq.heappush( h, ((man_dist(dst_node,next_dst),dst_node,next_dst)) )\n      pass\n\n    return tot_dist", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                p1 = points[i]\n                p2 = points[j]\n                l = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n                edges.append((l, tuple(p1), tuple(p2)))\n                \n                \n        trees = []\n        for point in points:\n            a = set()\n            a.add(tuple(point))\n            trees.append(a)\n        \n        t1 = -1\n        t2 = -1\n        tot = 0\n        for e in sorted(edges):\n            l, p1, p2 = e\n            for i, tree in enumerate(trees):\n                if p1 in tree:\n                    t1 = i\n                    break\n            for i, tree in enumerate(trees):\n                if p2 in tree:\n                    t2 = i\n                    break\n                    \n            if t1 != t2:\n                tot += l\n                trees[t1].update(trees[t2])\n                del trees[t2]\n                \n            \n        return tot", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points)<=1:return 0\n        ans=0\n        par={}\n        def find(x):\n            if x not in par:return x\n            res=find(par[x])\n            par[x]=res\n            return res\n        def union(a,b):\n            n1=find(a)\n            n2=find(b)\n            if n1!=n2:\n                if n1<=n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n                return True\n            else:return False\n        arr=[]\n        for i in range(len(points)):\n##            _min=10e9\n##            ix=-1\n            for j in range(i+1,len(points)):\n                n=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                arr.append((n,(i,j)))\n##        print(ans)\n##        arr=list(arr)\n        arr.sort()\n        for x in arr:\n            i=x[1][0]\n            j=x[1][1]\n            if union(i,j):ans+=x[0]\n\n##            n1=find(i)\n##            n2=find(j)\n##            if n1!=n2:\n##                if n1<n2:\n##                    par[n2]=n1\n##                else:\n##                    par[n1]=n2\n##                ans+=x[0]\n        return ans        ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def calculate_distance(x1, y1, x2, y2):\n            return abs(x1 - x2) + abs(y1 - y2)\n\n        res = 0\n        n = len(points)\n        visited = set()\n        d = defaultdict(list)\n\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    d[i].append((calculate_distance(points[i][0], points[i][1], points[j][0], points[j][1]), j))\n                    d[j].append((calculate_distance(points[i][0], points[i][1], points[j][0], points[j][1]), i))\n\n        heap = d[0]\n        heapq.heapify(heap)\n        cnt = 1\n        visited.add(0)\n\n        while heap:\n            dist, j = heapq.heappop(heap)\n\n            if j not in visited:\n                cnt += 1\n                visited.add(j)\n                res += dist\n                for r in d[j]:\n                    heapq.heappush(heap, r)\n            if cnt >= n: break   \n        \n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n, curr, ans = len(points), 0, 0\n        if n == 1: return 0\n        dist = [math.inf] * n\n        visited = set()\n        for i in range(n - 1):\n            x, y = points[curr]\n            visited.add(curr)\n            for j, (u, v) in enumerate(points):\n                if j in visited: continue\n                dist[j] = min(dist[j], abs(u - x) + abs(v - y))\n            delta, curr = min((d, j) for j, d in enumerate(dist))\n            dist[curr] = math.inf\n            ans += delta\n        return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n            \n                dist = abs(x1-x2) + abs(y1-y2)\n                heap.append((dist, i, j))\n        \n        heapify(heap)\n        uf = UnionFind(len(points))\n        res = 0\n        \n        while heap:\n            dist, x, y = heappop(heap)\n            if uf.union(x, y):\n                res += dist\n                \n        return res\n    \nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0]*n\n        \n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False\n        \n        if self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        \n        else:\n            self.parent[root_x] = root_y\n            if self.rank[root_x] == self.rank[root_y]:\n                self.rank[root_y] += 1\n        \n        return True\n    \n    def find(self, x):\n        while x != self.parent[x]:\n            # self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n                \n        \n        \n        \n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        l=len(points)\n        c=collections.defaultdict(list)\n        for i in range(l-1):\n            for j in range(i+1,l):\n                d=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                c[d].append((i,j))\n        tocons=list(sorted(c.keys()))\n        #print(tocons)\n        def isCyclicUtil(v,visited,parent,graph):\n            visited[v]=True\n            for i in graph[v]:\n                if visited[i]==False:\n                    if isCyclicUtil(i,visited,v,graph):\n                        return True\n                elif parent!=i:\n                    return True\n            return False\n            \n        def checkloop(y,connected,edges):\n            if y[0] not in connected or y[1] not in connected:\n                return True\n            root=y[0]\n            \n            visited=[False]*(l)\n            \n            graph=collections.defaultdict(list)\n            graph[y[0]]=[y[1]]\n            graph[y[1]]=[y[0]]\n            for x in edges:\n                graph[x[0]].append(x[1])\n                graph[x[1]].append(x[0])\n            for i,x in enumerate(connected):\n                if visited[x]==False:\n                    if isCyclicUtil(x,visited,-1,graph)==True:\n                        return False\n            '''\n            seq=[root]\n            seen=set()\n            seen.add(root)\n            while seq:\n                v=seq.pop()\n                for w in graph[v]:\n                    if w not in seen:\n                        if isCyclicUtil(w,visited,v,graph):\n                            return False\n                        seq.append(w)\n            '''\n            return True\n            \n        \n            \n        edges=[]\n        count=0\n        cost=0\n        connected=set()\n        for x in tocons:\n            for y in c[x]:\n                #print(y,x,connected,count)\n                \n                if checkloop(y, connected, edges):\n                    count+=1\n                    cost+=x\n                    connected.add(y[0])\n                    connected.add(y[1])\n                    edges.append(y)\n                if count==l-1:\n                    return cost\n        return 0", "class Solution:\n    def minCostConnectPoints(self, points) -> int:\n        p_set = [i for i in range(len(points))]\n        \n        def father(i):\n            while p_set[i] != i:\n                i = p_set[i]\n            return i\n        if len(points) == 1:\n            return 0\n        \n        edge = {}\n        edgelist = []\n        res = 0\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                le = 0\n                le += abs(points[i][1]-points[j][1])\n                le += abs(points[i][0]-points[j][0])\n                if le in edge:\n                    edge[le].append((i, j))\n                else:\n                    edge[le] = [(i,j)]\n                    edgelist.append(le)\n        edgelist.sort()\n        # print(edge)\n        (i,j) = edge[edgelist[0]][0]\n        res += edgelist[0]\n        # print('add {}-{} length= {}'.format(i, j,edgelist[0]))\n        p_set[j] = i\n        for key in edgelist:\n            # print('deal ', key)\n            for (i, j) in edge[key]:\n                fi = father(i)\n                fj = father(j)\n                if fj != fi:\n                    # print('add {}-{} length= {}'.format(i,j,key))\n                    p_set[fj] = fi\n                    # print(p_set)\n                    res += key\n        return res", "class UnionFind:\n    def __init__(self, n):\n        self.parent=[i for i in range(n)]\n        self.height=[0 for i in range(n)]\n    def find(self,x):\n        if self.parent[x]==x: return x\n        result = self.find(self.parent[x])\n        self.parent[x]=result\n        return result\n    def merge(self,x,y):\n        rx=self.find(x)\n        ry=self.find(y)\n        if self.height[rx]>self.height[ry]:\n            self.parent[ry]=rx\n        elif self.height[rx]<self.height[ry]:\n            self.parent[rx]=ry\n        else:\n            self.parent[rx]=ry\n            self.height[rx]+=1\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n=len(points)\n        edges=[]\n        for i in range(n):\n            for j in range(i+1,n):\n                heappush(edges,(abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),i,j))\n        uf=UnionFind(n)\n        ans=0\n        while edges:\n            cost,va,vb=heappop(edges)\n            if uf.find(va)==uf.find(vb):\n                pass\n            else:\n                uf.merge(va,vb)\n                ans+=cost\n        return ans\n", "from collections import Counter\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        points = [tuple(it) for it in points]\n        ds = []\n        for i1, p1 in enumerate(points):\n            for p2 in points[i1+1:]:\n                if p1 == p2:\n                    continue\n                dist = abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n                ds.append((dist, (p1, p2)))\n        ds.sort()\n        ps = [set([it]) for it in points]\n        total = 0\n        for cost, (p1, p2) in ds:\n            s1 = [it for it in ps if p1 in it][0]\n            s2 = [it for it in ps if p2 in it][0]\n            if s1 is s2:\n                continue\n            total += cost\n            s1 |= s2\n            ps.remove(s2)\n        return total", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points)<=1:return 0\n        ans=0\n        par={}\n        def find(x):\n            if x not in par:return x\n            res=find(par[x])\n            par[x]=res\n            return res\n        def union(a,b):\n            n1=find(a)\n            n2=find(b)\n            if n1!=n2:\n                if n1<=n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n##                return True\n##            else:return False\n        arr=[]\n        for i in range(len(points)):\n##            _min=10e9\n##            ix=-1\n            for j in range(i+1,len(points)):\n                n=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1])\n                arr.append((n,(i,j)))\n##        print(ans)\n##        arr=list(arr)\n        arr.sort()\n        for x in arr:\n            i=x[1][0]\n            j=x[1][1]\n##            if union(i,j):ans+=x[0]\n\n            n1=find(i)\n            n2=find(j)\n            if n1!=n2:\n                if n1<n2:\n                    par[n2]=n1\n                else:\n                    par[n1]=n2\n                ans+=x[0]\n        return ans               ", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points) <= 1:\n            return 0\n        visited = set()\n        adj_list = defaultdict(list)\n        cost = 0\n        pq = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                first = points[i]\n                second = points[j]\n                adj_list[tuple(first)].append([abs(first[0] - second[0]) + abs(first[1] - second[1]), second])\n                adj_list[tuple(second)].append([abs(first[0] - second[0]) + abs(first[1] - second[1]), first])\n\n        pq = pq + adj_list[list(adj_list.keys())[0]]\n        heapq.heapify(pq)\n        visited.add(tuple(list(adj_list.keys())[0]))\n        while len(visited) < len(adj_list):\n            curr = heapq.heappop(pq)\n            if tuple(curr[1]) not in visited:\n                visited.add(tuple(curr[1]))\n                for edge in adj_list[tuple(curr[1])]:\n                    heapq.heappush(pq, edge)\n                cost += curr[0]\n        return cost", "parent = 0\ndef find(i):\n    nonlocal parent\n    l1 = []\n    while parent[i] != i:\n        l1.append(i)\n        i = parent[i]\n    j = i\n    for i in l1:\n        parent[i] = j\n    return j\n    \n    \n    \ndef givedistance(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\nclass Solution:\n    def minCostConnectPoints(self, l: List[List[int]]) -> int:\n        nonlocal parent\n        \n        visited = {}\n        \n        l1 = []\n        n = len(l)\n        for i in range(n):\n            for j in range(i + 1, n):\n                l1.append([givedistance(l[i], l[j]), tuple(l[i]), tuple(l[j])])\n                \n        l1.sort()\n        l1.reverse()\n\n        ans = 0\n\n        if n == 1:return 0\n        \n        d = {}\n        ind = 0\n        for i in l:\n            d[tuple(i)] = ind\n            ind += 1\n        \n        for i in range(len(l1)):\n            l1[i][1] = d[l1[i][1]]\n            l1[i][2] = d[l1[i][2]]\n        parent = {}\n        for i in l1:\n            parent[i[1]] = i[1]\n            parent[i[2]] = i[2]\n        \n        taken = 0\n        while taken != n - 1:\n            curr, i, j = l1.pop()\n            \n            p1 = find(i)\n            p2 = find(j)\n            \n            if p1 != p2:\n                parent[p1] = parent[p2]\n                ans += curr\n                taken += 1\n        return ans\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1:\n            return 0\n        \n        parents = list(range(n))      \n        \n        def find(i):\n            if parents[i] != i:\n                parents[i] = find(parents[i])\n            return parents[i]\n            \n        def union(i, j):\n            p_i = find(i)\n            p_j = find(j)\n            if p_i != p_j:\n                if p_i > p_j:\n                    parents[p_j] = p_i\n                else:\n                    parents[p_i] = p_j     \n                    \n        heap = []\n        for i in range(n):\n            for j in range(i+1, n):\n                heapq.heappush(heap, (self.distance(points[i], points[j]), i, j))\n        \n        res = 0\n        while heap:\n            dist, i, j = heapq.heappop(heap)\n            if find(i) == find(j):\n                continue\n            union(i, j)\n            res += dist\n        \n        return res\n        \n    def distance(self, p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])", "parent = 0\ndef find(i):\n    nonlocal parent\n\n    while parent[i] != i:\n        parent[i] = parent[parent[i]]\n        i = parent[i]\n    \n    return i\n    \n    \ndef givedistance(a, b):return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n\nclass Solution:\n    def minCostConnectPoints(self, l: List[List[int]]) -> int:\n        nonlocal parent\n        \n        visited = {}\n        \n        l1 = []\n        n = len(l)\n        for i in range(n):\n            for j in range(i + 1, n):\n                l1.append([givedistance(l[i], l[j]), tuple(l[i]), tuple(l[j])])\n                \n        l1.sort()\n        l1.reverse()\n\n        ans = 0\n\n        if n == 1:return 0\n        \n        d = {}\n        ind = 0\n        for i in l:\n            d[tuple(i)] = ind\n            ind += 1\n        \n        for i in range(len(l1)):\n            l1[i][1] = d[l1[i][1]]\n            l1[i][2] = d[l1[i][2]]\n        parent = {}\n        for i in l1:\n            parent[i[1]] = i[1]\n            parent[i[2]] = i[2]\n        \n        taken = 0\n        while taken != n - 1:\n            curr, i, j = l1.pop()\n\n            p1 = find(i)\n            p2 = find(j)\n\n            if p1 != p2:\n                parent[p1] = parent[p2]\n                ans += curr\n                taken += 1\n\n        return ans", "import heapq\nclass DSU:\n    def __init__(self, n):\n        self.p = list(range(n))\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    def union(self, x, y):\n        p_x = self.find(x)\n        p_y = self.find(y)\n        if p_x != p_y:\n            self.p[p_x] = p_y\n            return True\n        return False\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n < 2:\n            return 0\n        \n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append([dist(points[i], points[j]), i, j])\n                \n        heapq.heapify(edges)\n        dsu = DSU(n)\n        res = 0\n        while edges:\n            cost, p1, p2 = heapq.heappop(edges)\n            if dsu.union(p1, p2):\n                res += cost\n        \n        return res\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        pointSet = set()\n        CostHeap = []\n        \n        for i in range(len(points)):\n            pointSet.add(i)\n            for j in range(i+1, len(points)):\n                heapq.heappush(CostHeap, [abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]), i, j])\n        \n        parent = defaultdict(lambda: -1)\n        def find(x):\n            if parent[x] == -1:\n                return x\n            else:\n                parent[x] = find(parent[x])\n                return parent[x]\n            \n        COST = 0\n        while CostHeap:\n            node = heapq.heappop(CostHeap)\n            cost,x,y = node\n            u = find(x)\n            v = find(y)\n            if u != v:\n                parent[u] = v               \n                COST+=cost\n        return COST\n            \n", "# class DSU:\n#     def __init__(self, N):\n#         self.parent = [i for i in range(N)]\n#         self.rank = [0] * N\n        \n#     def find(self, x):\n#         if self.parent[x] != x:\n#             self.parent[x] = self.find(self.parent[x])\n            \n#         return self.parent[x]\n    \n#     def union(self, x, y):\n#         xRoot = self.find(x)\n#         yRoot = self.find(y)\n        \n#         if xRoot == yRoot:\n#             return False\n        \n#         if self.rank[xRoot] > self.rank[yRoot]:\n#             self.parent[yRoot] = xRoot\n#         elif self.rank[yRoot] > self.rank[xRoot]:\n#             self.parent[xRoot] = yRoot\n#         else:\n#             self.parent[yRoot] = xRoot\n#             self.rank[xRoot] += 1\n            \n#         return True\n\n# class Solution:\n#     def minCostConnectPoints(self, points: List[List[int]]) -> int:\n#         N = len(points)\n#         pq = []\n        \n#         for i in range(N):\n#             for j in range(i):\n#                 x1, y1 = points[i]\n#                 x2, y2 = points[j]\n#                 dist = abs(x1 - x2) + abs(y1 - y2)\n#                 heappush(pq, (dist, i, j))\n                    \n#         dsu = DSU(N)\n#         edges = 0\n#         cost = 0\n        \n#         while edges < N - 1:\n#             dist, i, j = heappop(pq)\n            \n#             if dsu.union(i, j):\n#                 cost += dist\n#                 edges += 1\n                \n#         return cost\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        graph = defaultdict(list)\n        \n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    x1, y1 = points[i]\n                    x2, y2 = points[j]\n                    dist = abs(x1 - x2) + abs(y1 - y2)\n                    graph[i].append((j, dist))\n                    graph[j].append((i, dist))\n                    \n        pq = [(0, 0)]\n        visited = set()\n        cost = 0\n        \n        while len(visited) < N:\n            dist, node = heappop(pq)\n            \n            if node not in visited:\n                visited.add(node)\n                cost += dist\n                \n                for adj, dist in graph[node]:\n                    if adj not in visited:\n                        heappush(pq, (dist, adj))\n                \n        return cost", "class Solution:\n    class Union:\n        def __init__(self):\n            self.collection = {}\n        \n        def get_head(self, i):\n            if i not in self.collection:\n                return -1, 1\n            while i in self.collection and self.collection[i][0] != i:\n                i = self.collection[i][0]\n            return self.collection[i]\n                \n        def add(self, i, j):\n            head_i, cnt_i = self.get_head(i)\n            head_j, cnt_j = self.get_head(j)\n            \n            if head_i == head_j and head_i != -1:\n                return False\n            \n            head = head_i if cnt_i >= cnt_j else head_j\n            cnt = cnt_i + cnt_j\n            if head == -1:\n                head = i\n\n            self.collection[head_i] = (head, cnt)\n            self.collection[head_j] = (head, cnt)\n            self.collection[i] = (head, cnt)\n            self.collection[j] = (head, cnt)\n            return True\n            \n    from heapq import heappush, heappop\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = []\n        union = Solution.Union()\n        total = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                val = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heappush(heap, (val, i, j))\n                \n        while heap:\n            val, i, j = heappop(heap)\n            x = union.add(i, j)\n            if x:\n                total += val\n            \n        return total", "class UF:\n  def __init__(self, n):\n    self.parents = [i for i in range(n)]\n    \n  def find(self, x):\n    if x != self.parents[x]:\n      self.parents[x] = self.find(self.parents[x])\n    \n    return self.parents[x]\n  \n  def union(self, x, y):\n    parent_x = self.find(x)\n    parent_y = self.find(y)\n    \n    self.parents[parent_y] = parent_x\n    \n  def connected(self, y, x):\n    return self.find(y) == self.find(x)\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def calculate_distance(x1, y1, x2, y2):\n            return abs(x1 - x2) + abs(y1 - y2)\n        \n        n = len(points)\n        uf = UF(n)\n        res = 0\n        \n        p = []\n        \n        for i in range(n):\n          for j in range(n):\n            if i != j:\n              p.append((i,j, calculate_distance(points[i][0], points[i][1], points[j][0], points[j][1])))\n              \n        p.sort(key = lambda x : x[2])\n        \n        for x, y, dist in p:\n          if not uf.connected(x,y):\n            uf.union(x,y)\n            res += dist\n        \n        return res\n        \n        \n", "class UnionFind:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.sz[xr] < self.sz[yr]:\n            xr, yr = yr, xr\n        self.par[yr] = xr\n        self.sz[xr] += self.sz[yr]\n        self.sz[yr] = self.sz[xr]\n        return True\n\n    def size(self, x):\n        return self.sz[self.find(x)]\n    \nclass Solution:\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n<=1:\n            return 0\n        distances = []\n        db = dict()\n        for i in range(n):\n            x1,y1 = points[i]\n            for j in range(i+1,n):\n                x2,y2 = points[j]\n                dis = (abs(x1-x2)+abs(y1-y2))\n                distances.append( dis )\n\n                if dis not in db:\n                    db[dis] = []\n                db[dis].append((i,j))\n                \n        \n        heapq.heapify(distances)\n        nodes = UnionFind(n)\n        ret = []\n        \n        cost = 0\n        while distances:\n            # print(type(distances))\n            # print(nodes)\n            dis = heapq.heappop(distances)\n            p1,p2 = db[dis].pop()\n            if nodes.union(p1,p2):\n                cost+=dis\n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        result = 0\n        m = 0\n        q = [(0, 0)]\n        visited = [10 ** 9] * n\n        while m < n:\n            w, i = heapq.heappop(q)\n            # print(j, i, w)\n            if visited[i] < 0:\n                continue\n            visited[i] = -1\n            for j in range(n):\n                ww = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                if ww < visited[j]:\n                    visited[j] = ww\n                    heapq.heappush(q, (ww, j))\n            m += 1\n            result += w\n        return result", "class UF:\n    @staticmethod\n    def init(n):\n        return [i for i in range(n)]\n    \n    @staticmethod\n    def find(parents, i):\n        if parents[i] != i:\n            parents[i] = UF.find(parents, parents[i])\n        return parents[i]\n    \n    @staticmethod\n    def union(parents, i, j):\n        parents[UF.find(parents, i)] = UF.find(parents, j)\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        distances = []\n        \n        n = len(points)\n        for i in range(n):\n            r1, c1 = points[i]\n            for j in range(i+1, n):\n                r2, c2 = points[j]\n                distances.append([abs(r1-r2)+abs(c1-c2), i, j])\n        distances.sort()\n        #print(distances)\n\n        res = 0\n        parents = UF.init(n)\n        for c, i, j in distances:\n            if UF.find(parents, i) != UF.find(parents, j):\n                UF.union(parents, i, j)\n                res += c\n            \n        return res\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        if len(points)==1:\n            return 0\n        \n        visited=[0]*(len(points))\n        q=[]\n        start=0\n        for i in range(1,len(points)):\n            dist=abs(points[i][0]-points[0][0])+abs(points[i][1]-points[0][1])\n            q.append([dist,i])\n            \n        heapq.heapify(q)\n        # print(q)\n        visited[0]=1\n        cost=0\n        count=1\n        while True:\n            \n            x=heapq.heappop(q)\n            # print(x)\n            if visited[x[1]]==0:\n                cost=cost+x[0]\n                visited[x[1]]=1\n                count=count+1\n            if count==len(points):\n                return cost\n            \n            for i in range(len(points)):\n                if visited[i]==0:\n                    dist=abs(points[i][0]-points[x[1]][0])+abs(points[i][1]-points[x[1]][1])\n                    heapq.heappush(q,[dist,i])\n        \n            \n            \n            \n        \n        \n        \n        \n        \n        \n#         def dfs(index,visited,count):\n#             if count==len(points):\n#                 return 0\n            \n#             dist=float(\\\"inf\\\")\n#             for i in range(len(points)):\n#                 if visited[i]==0:\n#                     visited[i]=1\n#                     dist=min(dist,abs(points[i][0]-points[index][0])+abs(points[i][1]-points[index][1])+dfs(i,visited,count+1))\n#                     visited[i]=0\n#             visited[index]=0\n#             return dist\n#         visited=[0]*len(points)\n#         visited[0]=1\n#         x=dfs(0,visited,1)\n#         return x\n                    \n", "class Solution:\n    class Union:\n        def __init__(self):\n            self.collection = {}\n        \n        def get_head(self, i):\n            if i not in self.collection:\n                return -1, 1\n            while i in self.collection and self.collection[i][0] != i:\n                i = self.collection[i][0]\n            return self.collection[i]\n                \n        def add(self, i, j):\n            head_i, cnt_i = self.get_head(i)\n            head_j, cnt_j = self.get_head(j)\n            \n            if head_i == head_j and head_i != -1:\n                return False, cnt_i\n            \n            head = head_i if cnt_i >= cnt_j else head_j\n            cnt = cnt_i + cnt_j\n            if head == -1:\n                head = i\n\n            self.collection[head_i] = (head, cnt)\n            self.collection[head_j] = (head, cnt)\n            self.collection[i] = (head, cnt)\n            self.collection[j] = (head, cnt)\n            return True, cnt\n            \n    from heapq import heappush, heappop\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = []\n        union = Solution.Union()\n        total = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                val = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heappush(heap, (val, i, j))\n                \n        while heap:\n            val, i, j = heappop(heap)\n            added, cnt = union.add(i, j)\n            if added:\n                total += val\n            #if cnt == len(points):\n            #    break\n            \n        return total", "from heapq import heappush, heappop\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        dists = [[float('inf')] * n for _ in range(n)]\n        for idx1, point1 in enumerate(points):\n            for idx2, point2 in enumerate(points):\n                if idx1 != idx2:\n                    manhattan = abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n                    dists[idx1][idx2] = manhattan\n                    dists[idx2][idx1] = manhattan\n        \n        res = 0\n        nearest = [float('inf')] * n\n        visited = set()\n        h = [(0, 0)]\n        while h and len(visited) < n:\n            last_dist, last_pt = heappop(h)\n            visited.add(last_pt)\n            nearest[last_pt] = min(last_dist, nearest[last_pt])\n            for neigh_pt, neigh_dist in enumerate(dists[last_pt]):\n                if neigh_pt not in visited:\n                    heappush(h, (neigh_dist, neigh_pt))\n            \n        return sum(nearest)", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        \n        def distance(p1, p2):\n            return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        \n#         calculate all edges in this graph\n        edges = []\n        for i in range(len(points)):\n            for j in range (i+1, len(points)):\n                if i == j: continue\n                edges.append([distance(points[i], points[j]), i, j])\n        edges.sort()\n        \n        fathers = {p: p for p in range(len(points))}\n        def find_father(p):\n            while fathers[p] != fathers[fathers[p]]:\n                fathers[p] = find_father(fathers[p])\n            return fathers[p]\n        \n        result = 0\n        for d, p1, p2 in edges:\n            if find_father(p1) == find_father(p2):\n                continue\n            fathers[find_father(p2)] = find_father(p1)\n            result += d\n            \n        return result\n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        h = []\n        visited = set()\n        \n        parent = [i for i in range(len(points))]\n        rank = [0] * len(points)\n        def find(i):\n            if parent[i] == i:\n                return i\n            p = find(parent[i])\n            parent[i] = p\n            return p\n        \n        def union(a,b):\n            pa, pb = find(a), find(b)\n            if rank[pa]>rank[pb]:\n                parent[pb] = pa\n            elif rank[pb]>rank[pa]:\n                parent[pa] = pb\n            else:\n                parent[pb] = pa\n                rank[pa] +=1\n        \n            \n        \n        def dist(a,b):\n            return abs(a[0]-b[0]) + abs(a[1]-b[1])\n        \n        for i in range(len(points)):\n            for j in range(i):\n                h.append((dist(points[i], points[j]), i,j))\n        heapq.heapify(h)\n        total = 0\n        while h and len(visited) < len(points):\n            dist, i,j = heapq.heappop(h)\n            if find(i) != find(j):\n                union(i,j)\n                total +=dist\n\n        return total\n                \n            \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #prims\n        g = collections.defaultdict(list)\n        n = len(points)\n        #create graph\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    g[i].append((abs(points[j][0] - points[i][0]) +\n                                 abs(points[j][1] - points[i][1]), j))\n\n        heap = [(0, 0)]\n        ans = 0\n        visited = set()\n        while heap:\n            weight, to = heapq.heappop(heap)\n            if to in visited:\n                continue\n            ans += weight\n            visited.add(to)\n\n            for cost, nei in g[to]:\n                if nei not in visited:\n                    heapq.heappush(heap, (cost, nei))\n\n        return ans", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def getDistance(x1, y1, x2, y2):\n            return abs(x1 - x2) + abs(y1 - y2)\n        \n        dist = defaultdict(list)\n        for i in range(len(points)):\n            curX, curY = points[i]\n            d = []\n            for j in range(len(points)):\n                newX, newY = points[j]\n                if newX == curX and newY == curY:\n                    d.append((10 ** 20, j))\n                else:\n                    d.append((getDistance(curX, curY, newX, newY), j))\n            # print(\\\"before\\\", d)\n            heapq.heapify(d)\n            # print(\\\"after\\\", d)\n            dist[i] = d\n        result = 0\n        processed = set()\n        processed.add(0)\n        # print(dist)\n        while len(processed) < len(points):\n            possible = []\n            for curNode in processed:\n                curHeap = dist[curNode]\n                while curHeap[0][1] in processed:\n                    heapq.heappop(curHeap)\n                possible.append(curHeap[0])\n            index = -1\n            minVal = float(\\\"inf\\\")\n            for distance, ind in possible:\n                if distance < minVal:\n                    minVal = distance\n                    index = ind\n            processed.add(index)\n            result += minVal\n        return result\n            \n                \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        # processed = set()\n        # for i in range(len(points)):\n        #     if len(processed) == 0:\n        #         processed.add(i)\n        #     else:\n        #         curDistances = dist[i]\n        #         for curDistance, index in curDistances:\n        #             if index not in processed:\n        #                 processed.add(index)\n        #                 result += curDistance\n        #                 print(curDistance)\n        #                 break\n        # return result", "#Prim's algorithm\nfrom collections import defaultdict\nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        graph = defaultdict(list)\n        n = len(points)\n        dist = lambda p0, p1: abs(p1[0] - p0[0]) + abs(p1[1] - p0[1])\n        for u in range(n):\n            for v in range(u + 1, n):\n                w = dist(points[u], points[v])\n                graph[u].append((v, w))\n                graph[v].append((u, w))\n        q = [(0, 0)]\n        visited = set()\n        res = 0\n        while q:\n            d, u = heappop(q)\n            if u in visited:\n                continue\n            visited.add(u)\n            res = res + d\n            for v, w in graph[u]:\n                if v not in visited:\n                    heappush(q, (w, v))\n        if len(visited) != n:\n            return -1\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = [(0, -1, 0)]\n        seen = set()\n        seen.add(-1)\n        heapq.heapify(heap)\n        cost = 0\n        \n        def calc_dist(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        \n        while len(seen) <= len(points):\n            c, a, b = heapq.heappop(heap)\n            if b in seen:\n                continue\n            seen.add(b)\n            cost += c\n            for j in range(len(points)):\n                if j not in seen:\n                    heapq.heappush(heap, (calc_dist(points[b], points[j]), b, j))\n            \n        return cost\n                \n            \n            \n                \n            \n        \n", "class Solution:\n    def find(self, uf, node):\n        if node not in uf:\n            uf[node] = node\n            \n        while node != uf[node]:\n            node = uf[node]\n            \n        return node\n            \n    def union(self, uf, node1, node2):\n        uf[self.find(uf, node1)] = self.find(uf, node2)\n\n    def distance(self, point1, point2):\n        return abs(point1[0]-point2[0]) + abs(point1[1]-point2[1])\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        cost = 0\n        edges = []\n        uf = {}\n        \n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                edges.append([i, j, self.distance(points[i], points[j])])\n                \n        edges = sorted(edges, key=lambda x: x[2])\n        \n        for edge in edges:\n            point1 = edge[0]\n            point2 = edge[1]\n            edgeCost = edge[2]\n            \n            if self.find(uf, point1) != self.find(uf, point2):\n                self.union(uf, point1, point2)\n                cost += edgeCost\n            \n            # if len(uf) == len(points):\n            #     break\n                \n        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        heap = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n            \n                dist = abs(x1-x2) + abs(y1-y2)\n                heap.append((dist, i, j))\n        \n        heapify(heap)\n        uf = UnionFind(len(points))\n        res = 0\n        \n        while heap:\n            dist, x, y = heappop(heap)\n            if uf.union(x, y):\n                res += dist\n                \n        return res\n    \nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0]*n\n        \n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        \n        if root_x == root_y:\n            return False\n        \n        \n        if self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        \n        else:\n            self.parent[root_x] = root_y\n            if self.rank[root_x] == self.rank[root_y]:\n                self.rank[root_y] += 1\n        \n        return True\n    \n    def find(self, x):\n        while x != self.parent[x]:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n                \n        \n        \n        \n        \n", "class UnionFind:\n    def __init__(self, V):\n        self.parent = [-1] * V\n\n    def union(self, v1, v2):\n        r1 = self.find(v1)\n        r2 = self.find(v2)\n        if r1 == r2:\n            return\n\n        s1 = self.size(r1)\n        s2 = self.size(r2)\n\n        # Weighted Union: to keep the height of sets as small as possible\n        if s1 <= s2:\n            self.parent[r1] = r2\n            self.parent[r2] -= s1\n        else:\n            self.parent[r2] = r1\n            self.parent[r1] -= s2\n \n    def find(self, v):\n        r = v\n        while self.parent[r] >= 0:\n            r = self.parent[r]\n\n        # Path Compression: to keep the height of sets as small as possible\n        while v != r:\n            new_v = self.parent[v]\n            self.parent[v] = r\n            v = new_v\n\n        return r\n    \n    def size(self, v):\n        r = self.find(v)\n        s = -self.parent[r]\n        return s \n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        edges = []\n        for u in range(n):\n            for v in range(u+1, n):\n                dist = abs(points[u][0]-points[v][0]) + abs(points[u][1]-points[v][1])\n                edges.append([dist, u, v])\n\n        res = 0\n        uf = UnionFind(n)\n        for e in sorted(edges):\n            if uf.find(e[1]) != uf.find(e[2]):\n                res += e[0]\n                uf.union(e[1], e[2])\n        return res\n        \n        \n", "class UF:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n        \n    def find(self, a):\n        while self.parent[a] != a:\n            self.parent[a] = self.parent[self.parent[a]]\n            a = self.parent[a]\n        return a\n    \n    def isConnected(self, a, b):\n        return self.find(a) == self.find(b)\n    \n    def union(self, a, b):\n        parentA = self.find(a)\n        parentB = self.find(b)\n        if self.isConnected(a, b): \n            return\n        if self.size[parentA] > self.size[parentB]:\n            self.parent[parentB] = parentA\n            self.size[parentA] += self.size[parentB]\n        else:\n            self.parent[parentA] = parentB\n            self.size[parentB] += self.size[parentA]\n        \n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        edges = []\n        n = len(points)\n        for i in range(n):\n            for j in range(i+1, n):\n                manhattanDist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((manhattanDist, i ,j))\n        edges.sort()\n        res = 0\n        uf = UF(n)\n        for cost, i, j in edges:\n            if not uf.isConnected(i, j):\n                uf.union(i, j)\n                res += cost\n        return res\n", "class DSU:\n    def __init__(self, n):\n        self.p = list(range(n))\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    def union(self, x, y):\n        p_x = self.find(x)\n        p_y = self.find(y)\n        if p_x != p_y:\n            self.p[p_x] = p_y\n            return True\n        return False\n    \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n < 2:\n            return 0\n        \n        def dist(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append([(i, j), dist(points[i], points[j])])\n                \n        edges.sort(key = lambda v: v[1])\n        dsu = DSU(n)\n        res = 0\n        for pts, cost in edges:\n            p1, p2 = pts\n            if dsu.union(p1, p2):\n                res += cost\n        \n        return res\n        \n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        import heapq\n        n = len(points)\n\n        \n        #find MST, can use krukals or prim's algo\n        # pq = []\n        # for i in range(n - 1):\n        #     x1, y1 = points[i]\n        #     for j in range(i + 1, n):\n        #         x2, y2 = points[j]\n        #         d = abs(x2 - x1) + abs(y2 - y1)\n        #         pq.append((d, i, j))\n                \n        pq = [(0, 0)]\n        seen = [False] * n\n        totalCost = 0\n        while pq:\n            cost, currPoint = heapq.heappop(pq)\n            if seen[currPoint]: continue\n            seen[currPoint] = True\n            totalCost += cost\n            \n            x1, y1 = points[currPoint]\n            for i in range(n):\n                if i != currPoint and not seen[i]:\n                    x2, y2 = points[i]\n                    d = abs(x2 - x1) + abs(y2 - y1)\n                    heapq.heappush(pq, (d, i))\n        return totalCost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        def find(u):\n            if u != group[u]:\n                group[u] = find(group[u])\n            return group[u]\n        \n        def unite(u, v):\n            u, v = find(u), find(v)\n            if u == v:\n                return False\n            if sz[u] < sz[v]:\n                u, v = v, u\n            group[v] = u\n            sz[u] += sz[v]\n            return True\n        \n        edges = []\n        for i in range(len(points)):\n            for j in range(len(points)):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))\n        edges.sort()\n        \n        ans = 0\n        group = [i for i in range(len(points))]\n        sz = [1 for i in range(len(points))]\n        for e, u, v in edges:\n            if unite(u, v):\n                ans += e\n        return ans\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n      def l1(p1, p2):\n        xi, yi = p1\n        xj, yj = p2\n        return abs(xi-xj) + abs(yi-yj)\n      \n      inf = float('inf')\n      LV = len(points)\n      E = [(u, v) for u in range(LV) for v in range(LV) if u != v]\n      E = sorted(E, key=lambda x: l1(points[x[0]],points[x[1]]))\n      parent = []\n      \n      def make_set(v):\n        parent[v] = v\n      \n      def find_set(v):\n        if v == parent[v]:\n          return v\n        parent[v] = find_set(parent[v])\n        return parent[v]\n      \n      def union_sets(a, b):\n        a = find_set(a)\n        b = find_set(b)\n        if a != b:\n          parent[b] = a\n          \n      for v in range(LV):\n        parent.append(0)\n        make_set(v)\n      \n      F=[]\n      cost = 0\n      for (u,v) in E:\n        if (a:=find_set(u)) != (b:=find_set(v)):\n          F.append((u,v))\n          cost += l1(points[u],points[v])\n          union_sets(a,b)\n      \n      return cost", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n == 1: return 0\n        res = 0  \n        curr = 0\n        dis = [math.inf] * n\n        explored = set()\n        \n        for i in range(n - 1):\n            x0, y0 = points[curr]\n            explored.add(curr)\n            for j, (x, y) in enumerate(points):\n                if j in explored : continue\n                dis[j] = min( dis[j], abs(x - x0) + abs(y - y0) )\n                \n            delta, curr = min((d, j) for j, d in enumerate(dis)) # curr \u540e\u7eed\u8fd8\u4f1a\u52a0\u5230explored\u91cc\u9762\uff0c\u5999\n            dis[curr] = math.inf \n            res += delta\n            \n        return res", "from heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        N = len(points)\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        dist = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        heap, total_cost = [], 0\n        for u in range(N-1):\n            for v in range(u+1, N):\n                heappush(heap, [dist(points[u], points[v]), u, v])\n        while heap:\n            cost, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                N -= 1\n                total_cost += cost\n                if N == 0:\n                    break\n        return total_cost\n\n    \n    \n    \n    \n    \n    \n    \n    \nfrom heapq import *\nclass Solution:\n    def minCostConnectPoints(self, points):\n        dist = lambda p1, p2: abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        N = len(points)\n        points = sorted(points, key=lambda x: abs(x[0])+abs(x[1]))\n        parent = [i for i in range(N)]\n        def find(v):\n            while parent[v] != parent[parent[v]]:\n                parent[v] = parent[parent[v]]\n            return parent[v]\n        heap = []\n        for i in range(N-1):\n            for j in range(i+1, N):\n                heappush(heap, (dist(points[i], points[j]), i, j))\n        res = 0\n        while heap:\n            d, u, v = heappop(heap)\n            pu, pv = find(u), find(v)\n            if pu != pv:\n                parent[pu] = pv\n                res += d\n                N -= 1\n                if N == 0:\n                    break\n        return res\n            \n\n\n#class Solution:\n#    def minCostConnectPoints(self, points):\n#        manhattan = lambda a, b, x, y: abs(a-x)+abs(b-y)\n#        points = sorted(points, key=lambda x: abs(x[0])+abs(x[1]))\n#        connected = [points[0]]\n#        cost = 0\n#        points = list(map(lambda x: [x[0], x[1], manhattan(connected[0][0], connected[0][1], x[0], x[1])], points))\n#        while len(connected) <= len(points):\n#            minidx = None\n#            mindist = float('inf')\n#            for i in range(len(points)):\n#                x, y, dist = points[i]\n#                if dist < mindist:\n#                    mindist = dist\n#                    minidx = i\n#            mx, my, mdist = points.pop(minidx)\n#            cost += mdist\n#            for i in range(len(points)):\n#                x, y, dist = points[i]\n#                newdist = manhattan(x, y, mx, my)\n#                if newdist < dist:\n#                    points[i][2] = newdist\n#        return cost\n", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        graph = collections.defaultdict(list)\n        for i in range(len(points)):\n            x0, y0 = points[i]\n            for j in range(i+1, len(points)):\n                x1, y1 = points[j]\n                dist = abs(x1-x0)+abs(y1-y0)\n                graph[i] += [(j, dist)]\n                graph[j] += [(i, dist)]\n        res, visited, heap = 0, set(), [(0, 0)]\n        while heap and len(visited) <= len(points):\n            dist, node = heapq.heappop(heap)\n            if node in visited:\n                continue\n            #print(dist, node, visited)\n            res += dist\n            visited.add(node)\n            for (n, d) in graph[node]:\n                if n in visited:\n                    continue\n                heapq.heappush(heap, (d, n))\n        return res", "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        edges = []\n        \n        for i in range(N):\n            a = tuple(points[i])\n            \n            for j in range(N):\n                if i == j:\n                    continue\n                b = tuple(points[j])\n                cost = abs(a[0] - b[0]) + abs(a[1] - b[1])\n                edges.append((cost, i, j))\n                \n        edges.sort()\n        \n        dsu = DSU(N)\n        mst = 0\n        \n        for cost, a, b in edges:\n            if dsu.union(a, b):\n                mst += cost\n                \n        return mst\n            \nclass DSU():\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def union(self, a, b):\n        roota = self.find(a)\n        rootb = self.find(b)\n        if roota == rootb:\n            return False\n        if self.size[roota] < self.size[rootb]:\n            self.size[rootb] += self.size[roota]\n            self.parent[roota] = rootb\n        else:\n            self.size[roota] += self.size[rootb]\n            self.parent[rootb] = roota\n        return True\n\n    def find(self, a):\n        root = self.parent[a]\n        while root != self.parent[root]:\n            root = self.parent[root]\n        curr = a\n\n        # path compression\n        while curr != root:\n            after = self.parent[curr]\n            self.parent[curr] = root\n            curr = after\n\n        return root\n", "class Union:\n    \n    def __init__(self):\n        self.parent = {}\n        self.rank = {}\n        self.count = 0\n        \n    def add(self, idx):\n        if idx not in self.parent:\n            self.parent[idx] = idx\n            self.rank[idx] = 1\n            self.count += 1\n    \n    def find(self, idx):\n        if self.parent[idx] != idx:\n            self.parent[idx] = self.find(self.parent[idx])\n        return self.parent[idx]\n    \n    def unite(self, p, q):\n        i, j = self.find(p), self.find(q)\n        if i == j:\n            return True\n        if self.rank[i] > self.rank[j]:\n            i, j = j, i\n        self.parent[i] = j\n        self.rank[j] += self.rank[i]\n        self.count -= 1\n        return False\n\nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        #p_to_cost = {}\n        costs = []\n        point = Union()\n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                cost = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                #p_to_cost[(i, j)] = val\n                costs.append([i, j, cost])\n        costs.sort(key=lambda x: x[2])\n        res = 0\n        for i, j, c in costs:\n            point.add(i)\n            point.add(j)\n            if not point.unite(i, j):\n                res += c\n        return res", "class Solution:\n    def minCostConnectPoints(self, a: List[List[int]]) -> int:\n        n = len(a)\n        g = defaultdict(set)\n\n        @lru_cache(None)\n        def dist(x1, y1, x2, y2):\n            return abs(x1 - x2) + abs(y1 - y2)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1 = a[i]\n                x2, y2 = a[j]\n                w = dist(x1, y1, x2, y2)\n                g[(x1, y1)].add((w, x2, y2))\n                g[(x2, y2)].add((w, x1, y1))\n\n        q = [(0, (a[0][0], a[0][-1]))]\n        visited = set()\n        total = ct = 0\n        while q:\n            # for _ in range(len(q)):\n            c, (x1, y1) = heapq.heappop(q)\n            if (x1, y1) in visited: continue\n            visited.add((x1, y1))\n            total += c\n            ct += 1\n            for w, x2, y2 in g[(x1, y1)]:\n                heapq.heappush(q, (w, (x2, y2)))\n            if ct >= n: break\n        return total", "class Solution:\n    def distance(self, p1, p2):\n        return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n    \n    def build_graph(self, points):\n        res = []\n        for i in range(len(points)):\n            for j in range(i+1, len(points)):\n                res.append([i, j, self.distance(points[i], points[j])])\n        return res\n    \n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        connections = self.build_graph(points)        \n        connections.sort(key=lambda x:x[2])\n        parents = [i for i in range(len(points))]\n        \n        def find(node):\n            parent = parents[node]\n            while node != parent:\n                node = parent\n                parent = parents[node]\n            return node\n    \n        cost = 0    \n\n        for edge in connections:\n            node1 = edge[0]\n            node2 = edge[1]\n            curr_cost = edge[2]\n\n            par1 = find(node1)\n            par2 = find(node2)\n            \n            if par1 != par2:\n                parents[par2] = par1\n                cost += curr_cost            \n\n        return cost", "class UF:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n\n    def find(self, x):\n        if self.parents[x] != x:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        self.parents[py] = px\n        return True\n        \n        \nclass Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        distances = []\n        for i, [xi, yi] in enumerate(points):\n            for j in range(i + 1, len(points)):\n                xj, yj = points[j]\n                d = abs(xi - xj) + abs(yi - yj)\n                distances.append([d, i, j])\n        \n        distances.sort()\n        uf = UF(len(points))\n        ans = 0\n        for d, i, j in distances:\n            if uf.union(i, j):\n                ans += d\n        \n        return ans"]
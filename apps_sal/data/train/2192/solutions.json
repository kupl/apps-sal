["n = int(input())\npos_blast = [list(map(int, input().split())) for _ in range(n)]\nMAX_N = max(pos_blast, key=lambda x: x[0])[0] + 2\npower = [0 for _ in range(MAX_N)]\ntower = [False for _ in range(MAX_N)]\ncan_destroy = [0 for _ in range(MAX_N)]\nfor pos, blast in pos_blast:\n    pos += 1\n    tower[pos] = True\n    power[pos] = blast\nfor i in range(1, MAX_N):\n    if not tower[i]:\n        can_destroy[i] = can_destroy[i-1]\n    else:\n        can_destroy[i] = can_destroy[max(0, i - power[i] - 1)] + 1\nprint(n - max(can_destroy))\n", "import sys\nN = 1<<20\nar = [0]*N\n\ndp = [0]*N\nn = int(input())\nfor i in range(0, n):\n    inp = input().split()\n    ar[int(inp[0])+1]= int(inp[1])\nfor i in range(N):\n    dp[i] = (1 if ar[i]>=i else dp[i-ar[i]-1]+1) if ar[i] else dp[i-1]\nprint(n-max(dp))\n", "import sys\nN = 1<<20\nar = [0]*N\nn = int(input())\nfor i in range(0, n):\n    inp = input().split()\n    ar[int(inp[0])+1]= int(inp[1])\nfor i in range(N):\n    ar[i] = (1 if ar[i]>=i else ar[i-ar[i]-1]+1) if ar[i] else ar[i-1]\nprint(n-max(ar))\n", "n = int(input())\nBecone = [list(map(int, input().split())) for i in range(n) ]\nBecone.sort( key = lambda x : x[0])\ndp = [0]*1000001\n#for i in range(1000001) :\n#    dp[i] = 0\n\nif Becone[0][0] == 0 :\n    dp[0] = 1\n    Becone.pop(0)\n\nans = n - dp[0]\nfor i in range(1, 1000001) :\n    if not Becone :\n        break\n    if i != Becone[0][0] :\n        dp[i] = dp[i-1]\n        continue\n\n    a,b = Becone.pop(0)\n    if a-b <= 0 :\n        dp[i] = 1\n    else :\n        dp[i] = dp[i-b-1]+1\n\n    ans = min( ans, n - dp[i] )\n\nprint( ans )\n", "from array import *\n\nn = int(input())\nBecone = [list(map(int, input().split())) for i in range(n) ]\nBecone.sort( key = lambda x : x[0])\ndp = array('i', [0]*1000001)\n\nif Becone[0][0] == 0 :\n    dp[0] = 1\n    Becone.pop(0)\n\nans = n - dp[0]\nfor i in range(1, 1000001) :\n    if not Becone :\n        break\n    if i != Becone[0][0] :\n        dp[i] = dp[i-1]\n        continue\n\n    a,b = Becone.pop(0)\n    if a-b <= 0 :\n        dp[i] = 1\n    else :\n        dp[i] = dp[i-b-1]+1\n\n    ans = min( ans, n - dp[i] )\n\nprint( ans )\n", "from sys import stdin\n\nn = int(stdin.readline())\nBecone = [list(map(int, stdin.readline().split())) for i in range(n) ]\nBecone.sort( key = lambda x : x[0])\ndp = [0]*1000001\n\nif Becone[0][0] == 0 :\n    dp[0] = 1\n    Becone.pop(0)\n\nans = n - dp[0]\nfor i in range(1, 1000001) :\n    if not Becone :\n        break\n    if i != Becone[0][0] :\n        dp[i] = dp[i-1]\n        continue\n\n    a,b = Becone.pop(0)\n    if a-b <= 0 :\n        dp[i] = 1\n    else :\n        dp[i] = dp[i-b-1]+1\n\n    ans = min( ans, n - dp[i] )\n\nprint( ans )\n", "def main():\n    n = int(input())\n    bb = [0] * 1000001\n    for _ in range(n):\n        a, b = list(map(int, input().split()))\n        bb[a] = b\n    a = 0\n    for i, b in enumerate(bb):\n        if b:\n            a = (bb[i - b - 1] + 1) if i > b else 1\n        bb[i] = a\n    print(n - max(bb))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\ndp = [0] * 1000007\nmajak = [0] * 1000007\n\nq = 1000007\np = 0\nfor i in range(n):\n    a, b = map(int, input().split())\n    q = min(q, a)\n    majak[a] = b\n\ndp[q] = 1\nma = 1\nfor i in range(q + 1, 1000003, 1):\n    if(majak[i] == 0):\n        dp[i] = dp[i - 1]\n    else:\n        dp[i] = dp[i - majak[i] - 1] + 1\n        ma = max(ma, dp[i])\n\nprint(n - ma)", "dp = []\ndef fun(n, a):\n\tdp[0] = 1\n\tfor i in range(1, n):\n\t\tl, r = 0, i - 1\n\t\twhile l <= r:\n\t\t\tm = (l + r)>>1\n\t\t\tif a[i][0] - a[m][0] <= a[i][1]:\n\t\t\t\tr = m - 1\n\t\t\telse:\n\t\t\t\tl = m + 1\n\t\t#print (i, x)\n\t\tdp[i] = dp[r] + 1\n\n\n\n\nn = int(input())\ndp = [0 for i in range(n)]\na=[]\nfor i in range(n):\n\tl = list(map(int, input().split()))\n\ta.append(l)\na.sort()\npower = [0 for i in range(n)]\n\nfun(n, a)\n#print (dp)\nprint(n - max(dp))\t\n", "import bisect\n\ndef __starting_point():\n    n = int(input())\n    beacon = [tuple(map(int, input().split())) for _ in range(n)]\n    beacon.sort()\n    \n    destroyed = [0]*n\n    for i in range(n):\n        lo = beacon[i][0] - beacon[i][1]\n        pos = bisect.bisect_left(beacon, (lo, -1), hi=i-1)\n        if beacon[pos][0] >= lo:\n            pos -= 1\n        if pos < 0:\n            destroyed[i] = i\n        else:\n            destroyed[i] = max(0, i - pos - 1 + destroyed[pos])\n    \n    best = n\n    for i, v in enumerate(destroyed):\n        best = min(best, v + n - i - 1)\n    print(best)\n__starting_point()", "import sys\n\nMAX_X = 1000 * 1000 + 10\n\ndef main():\n    n = int(sys.stdin.readline())\n\n    arr = [0] * MAX_X\n    cnt = [0] * MAX_X\n    dp = [0] * MAX_X\n    for i in range(n):\n        x, c = list(map(int, sys.stdin.readline().split()))\n        arr[x + 1] = c\n\n    for i in range(1, MAX_X):\n        cnt[i] += cnt[i - 1] + (arr[i] != 0)\n    \n    for i in range(1, MAX_X):\n        dp[i] = dp[max(0, i - arr[i] - 1)] + cnt[i - 1] - cnt[max(0, i - arr[i] - 1)]\n\n    answer = dp[MAX_X - 1]\n    add = 0\n\n    for i in range(MAX_X - 1, -1, -1):\n        answer = min(answer, add + dp[i])\n        add += (arr[i] != 0)\n\n    sys.stdout.write(str(answer))\n\nmain()\n", "read = lambda: list(map(int, input().split()))\nn = int(input())\np = sorted([tuple(read()) for i in range(n)])\na = [0] * (n + 1)\nb = [0] * (n + 1)\nfor i in range(1, n + 1):\n    a[i], b[i] = p[i - 1]\na[0] = int(-1e7)\ndp = [0] * (n + 1)\nfor i in range(1, n + 1):\n    L = 0\n    R = n + 1\n    while R - L > 1:\n        M = (L + R) // 2\n        if a[i] - b[i] <= a[M]: R = M\n        else: L = M\n    dp[i] = dp[L] + 1\nans = n - max(dp)\nprint(ans)\n", "import bisect\n\n\ndef min_destroyed(beacons):\n    beacons.sort()\n    dest = []\n    for i, (a, b) in enumerate(beacons):\n        pos = bisect.bisect_left(beacons, (a-b, 0), hi=i)\n        if pos == 0:\n            dest.append(i)\n        else:\n            dest.append(dest[pos-1] + i-pos)\n\n    n = len(beacons)\n    return min(d + (n-i-1) for i, d in enumerate(dest))\n\n\ndef __starting_point():\n    n = int(input())\n    beacons = []\n    for _ in range(n):\n        a, b = list(map(int, input().split()))\n        beacons.append((a, b))\n    print(min_destroyed(beacons))\n\n__starting_point()", "n = int(input())\na = [0]*1000001\nb = [0]*1000001\nfor i in range(n):\n  l = list(map(int,input().split()))\n  a[l[0]] = 1\n  b[l[0]] = l[1]\n  \nnotdestroyed = [0]*1000001\nif a[0] == 1:\n  notdestroyed[0] = 1\nfor i in range(1,1000001):\n  if a[i] == 1:\n    notdestroyed[i] = notdestroyed[i-b[i]-1]+1\n  else:\n    notdestroyed[i] = notdestroyed[i-1]\n    \nprint(n-max(notdestroyed))", "n = int(input())\nlista = []\nfor i in range(n):\n    lista.append([int(x) for x in input().split()])\nlista.sort()\n\ndiccionario = dict()\nnada = True\nlast = 0\nmaximo = 0\nfor x, i in lista:\n    if nada == True:\n        for c in range(0, x):\n            diccionario[c] = 0\n        diccionario[x] = 1\n        maximo = 1\n        nada = False\n        last = x\n    else:\n        for w in range(last, x):\n            diccionario[w] = diccionario[last]\n        if i >= x:\n            diccionario[x] = 1\n        else:\n            aux = diccionario[x - i - 1] + 1\n            if aux > maximo:\n                maximo = aux\n            diccionario[x] = aux\n        last = x\nprint(n - maximo)\n", "N = int(input())\nd = [0 for i in range(1000005)]\nMemo = [0 for i in range(1000005)]\nmax_pos = 0\nfor i in range(N):\n    subList = input().split()\n    index = int(subList[0])\n    d[index] = int(subList[1])\n    max_pos = max(index, max_pos)\nif (d[0] != 0):\n    Memo[0] = 1\n\nresult = N\nresult = min(result, N-Memo[0])\n\nfor i in range(1, max_pos+1):\n    if d[i] == 0:\n        Memo[i] = Memo[i-1]\n    else:\n        if d[i] >= i:\n            Memo[i] = 1\n        else:\n            Memo[i] = Memo[i-d[i]-1]+1\n    result = min(result, N-Memo[i])\nprint(result)\n", "N = int(input())\nd = [0 for i in range(1000001)]\nMemo = [0 for i in range(1000001)]\nmax_pos = 0\nfor i in range(N):\n    subList = input().split()\n    index = int(subList[0])\n    d[index] = int(subList[1])\n    max_pos = max(index, max_pos)\nif (d[0] != 0):\n    Memo[0] = 1\n\nresult = N\nresult = min(result, N-Memo[0])\n\nfor i in range(1, max_pos+1):\n    if d[i] == 0:\n        Memo[i] = Memo[i-1]\n    else:\n        if d[i] >= i:\n            Memo[i] = 1\n        else:\n            Memo[i] = Memo[i-d[i]-1]+1\n    result = min(result, N-Memo[i])\nprint(result)\n", "from bisect import bisect_left, bisect_right\nfrom collections import Counter\nfrom collections import deque\nfrom itertools import accumulate\n\nimport math\n\nR = lambda: map(int, input().split())\nn = int(input())\na, dp = sorted([tuple(R()) for _ in range(n)]), [0] * n\nfor i, (loc, dis) in enumerate(a):\n    dp[i] = dp[bisect_left(a, (loc - dis, -10**10)) - 1] + 1\nprint(n - max(dp))", "n = int(input())\n\ndp = [0] * 1000007\n\nmajak = [0] * 1000007\n\n\n\nq = 1000007\n\np = 0\n\nfor i in range(n):\n\n    a, b = list(map(int, input().split()))\n\n    q = min(q, a)\n\n    majak[a] = b\n\n\n\ndp[q] = 1\n\nma = 1\n\nfor i in range(q + 1, 1000003, 1):\n\n    if(majak[i] == 0):\n\n        dp[i] = dp[i - 1]\n\n    else:\n\n        dp[i] = dp[i - majak[i] - 1] + 1\n\n        ma = max(ma, dp[i])\n\n\n\nprint(n - ma)\n\n\n\n# Made By Mostafa_Khaled\n", "import sys,bisect\nn=int(input())\na,b=[],[]\nfor _ in range(n):\n\tai,bi=list(map(int,input().split(' ')))\n\ta.append(ai)\n\tb.append(bi)\n\ndptable=[1 for i in range(n+1)]\ndptable[0]=0\na.insert(0,-1*sys.maxsize)\nb.insert(0,0)\nab=list(zip(a,b))\nsorted(ab)\nb=[x for _,x in sorted(zip(a,b))]\na.sort()\n#print(a,\"\\n\",b)\nfor i in range(1,len(dptable)):\n\tdelupto=a[i]-b[i]\n\tdelupto=bisect.bisect_left(a,delupto)\n\t#print(delupto,i)\n\tdptable[i]=dptable[delupto-1]+1\nprint(n-max(dptable))\n", "import bisect\nclass b:\n\tdef __init__(self, loc, val, ls):\n\t\tself.loc = loc\n\t\tself.val = val\n\t\tself.ls = ls\n\t\tself.done = False\n\t\tself.ans = -1\n\n\tdef do(self):\n\t\tif self.done: return self.ans\n\t\tx = bisect.bisect_left(self.ls, self.loc-self.val) - 1\n\t\tif x == -1: self.ans = 0\n\t\telse:\n\t\t\tself.ans = ls[x].do() + 1\n\t\tself.done =True\n\t\treturn self.ans\n\n\tdef __lt__(self, obj):\n\t\tif type(obj) == int: return obj > self.loc\n\t\treturn obj.loc > self.loc\n\nls = []\nfor _ in range(int(input())):\n\tx,y = map(int, input().split(\" \"))\n\tls.append(b(x, y, ls))\nls.sort()\nm = -1\nfor l in ls:\n\tm = max(m, l.do())\nprint(len(ls) - (m+1))", "n = int(input())\nbb = [0] * 1000001\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    bb[a] = b\na = 0\nfor i, b in enumerate(bb):\n    if b:\n        if i>b :\n            a = (bb[i - b - 1] + 1)\n        else :\n            a=1\n            \n         \n    bb[i] = a\nprint(n - max(bb))\n", "def bin(mas,x):\n    l = 0\n    r = len(mas)\n    while (r > l + 1):\n        m = (r + l) // 2;\n        if (x < mas[m]):\n            r = m;\n        else:\n            l = m\n    return l\n\nn = int(input())\na = [-9999999]\nb = [9999999]\ndp = [0] * (n + 1)\nfor i in range(n):\n    x,y=[int(i) for i in input().split()]\n    a.append(x)\n    b.append(y)\n\na, b = (list(x) for x in zip(*sorted(zip(a, b))))\n\n\n\nfor i in range(1,n+1):\n    z = a[i] - b[i] - 1\n    x = bin(a, z)\n    dp[i] = dp[x] + ( i - x - 1)\nans = 10**30\nfor i in range(1, n + 1):\n    ans = min(ans, dp[i] + n - i)\nprint(ans)", "from operator import itemgetter\nn = int(input())\nabi = [[-10**9,0]] + [list(map(int,input().split())) for i in range(n)]\nabi.sort(key = itemgetter(0))\nar = [0] * (n+1)\nar[0] = 0\ndef check(pos,num):\n    #print(pos,num)\n    if abi[pos][0] < num:\n        return True\n    else:\n        return False\ndef binsearch(num):\n    high = n+1\n    low = 0\n    mid = (high + low) // 2\n    while high >= low:\n        if check(mid,num):\n            low = mid + 1\n        else:\n            high = mid - 1\n        mid = (high + low) // 2\n    return mid\nans = n\nfor i in range(1,n+1):\n    num = binsearch(abi[i][0] - abi[i][1])\n    ar[i] = i - num - 1+ ar[num]\n    ans = min(ans, ar[i] + n - i)\nprint(ans)\n", "def bsearch(arr,num,start,end):\n    mid=int((start+end)/2)\n    if start>end:\n        return (start,0)\n    if arr[mid]==num:\n        return (mid,1)\n    elif arr[mid]<num:\n        return bsearch(arr,num,mid+1,end)\n    else:\n        return bsearch(arr,num,start,mid-1)\nt=int(input())\nA=[]\nB=[]\nN=[]#next undestroyed beacon\nNUM=[]#number of destroyed beacon if current veacon activated\n\nabp=[]\nfor i in range(0,t):\n    ab=input().split(' ')\n    a,b=int(ab[0]),int(ab[1])\n    abp.append((a,b))\nabp_S=sorted(abp,key = lambda bk:bk[0])\nfor i in range(0,len(abp_S)):\n    a,b=abp_S[i]\n    A.append(a)\n    B.append(b)\n    pos=bsearch(A,a-b,0,len(A)-1) \n    if pos[0]==0:\n        N.append(pos[0]-1)\n        NUM.append(i)\n    else:\n        N.append(pos[0]-1)\n        NUM.append((i-pos[0])+NUM[pos[0]-1])\ndamages=[]\nfor i in range(0,len(A)):\n    damages.append((len(A)-(i+1))+NUM[i])\nprint(min(damages))\n\n\n"]
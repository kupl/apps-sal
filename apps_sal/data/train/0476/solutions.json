["class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        if not position:\n            return 0\n        \n        posToSpeed = {position[i]: speed[i] for i in range(len(position))}\n        position.sort()\n        \n        leaderTime = (target - position[-1]) / posToSpeed[position[-1]]\n        currGroups = 1\n        for i in range(len(position) - 2, -1, -1):\n            currTime = (target - position[i]) / posToSpeed[position[i]]\n            if currTime > leaderTime:\n                currGroups += 1\n                leaderTime = currTime\n        \n        return currGroups", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        if(not position):\n            return 0\n        # def comp(a):\n        #     return a[1],a[0]\n        arr = list(zip(position,speed))\n        arr.sort(reverse=True)\n        ans=1\n        reach=(target-arr[0][0])/arr[0][1]\n        for p,s in arr[1:]:\n            curr = (target-p)/s\n            if(curr>reach):\n                ans+=1\n                reach=curr\n        return ans\n            \n            \n            \n            \n        \n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        cars = sorted(zip(position, speed))\n        times = [float(target - p) / s for p, s in cars]\n        ans = 0\n        while len(times) > 1:\n            lead = times.pop()\n            if lead < times[-1]: ans += 1  # if lead arrives sooner, it can't be caught\n            else: times[-1] = lead # else, fleet arrives at later time 'lead'\n\n        return ans + bool(times) # remaining car is fleet (if it exists)\n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        cars = sorted(zip(position, speed))\n        times = [float(target - p) / s for p, s in cars]\n        ans = 0\n        while len(times) > 1:\n            lead = times.pop()\n            if lead < times[-1]: ans += 1\n            else: times[-1] = lead \n        return ans + bool(times)", "class Solution:\n    def check(self, target, p1, s1, p2, s2):\n        if p1 == target and p2 == target:\n            return True\n        if p1 == target or p2 == target:\n            return False\n        d1 = float(target - p1)\n        d2 = float(target - p2)\n        if d1 / float(s1) <= d2 / float(s2):\n            return True\n        return False\n    \n    def solve(self, target, pos, speed):\n        arr = []\n        for i in range(len(pos)):\n            p = pos[i]\n            s = speed[i]\n            arr.append((p, s))\n        arr = sorted(arr)\n        counter = 0\n        ln = len(arr)\n        i = ln-1\n        # print(arr)\n        while i >= 0:\n            p2, s2 = arr[i]\n            counter += 1\n            j = i-1\n            while j >= 0:\n                p1, s1 = arr[j]\n                if not self.check(target, p1, s1, p2, s2):\n                    # print('not checked:', target, (p1, s1), (p2, s2))\n                    break\n                j-=1\n            i = j\n        return counter\n    \n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        return self.solve(target, position, speed)", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        pos_speed = sorted(zip(position, speed))\n        times = [(target-p)/s*1.0 for p, s in pos_speed]\n\n        res = 0\n        cur = 0\n            \n        for t in times[::-1]:\n            if t > cur:\n                res += 1\n                cur = t\n        \n        return res", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        times = []\n        for p in range(len(position)):\n            times.append([(target - position[p])/speed[p], position[p]])\n        \n        times.sort()\n        \n        maxTime = 0\n        res = 0\n        #print(times)\n        for t in range(len(times) - 1, -1, -1):\n            if times[t][1] >= maxTime:\n                res += 1\n            maxTime = max(times[t][1], maxTime)\n        \n        return res\n            \n            \n", "class Solution(object):\n    def carFleet(self, target, position, speed):\n        cars = sorted(zip(position, speed))\n        times = [(target - p) / s for p, s in cars]\n        ans = 0\n        print(times)\n        while len(times) > 1:\n            lead = times.pop()\n            if lead < times[-1]: ans += 1  # if lead arrives sooner, it can't be caught\n            else: times[-1] = lead # else, fleet arrives at later time 'lead'\n\n        return ans + bool(times) # remaining car is fleet (if it exists)", "class Solution:\n    def carFleet(self, target, position, speed) -> int:\n        ans,time=0, sorted([[position[i], (target-position[i])/speed[i]] for i in range(len(position))], reverse=True)+[[-1,float('inf')]]\n        \n        \n        # print(time)\n        for i in range(1,len(time)):\n            if time[i-1][1]<time[i][1]:\n                ans+=1\n            else:\n                time[i][1]=time[i-1][1]\n                \n        return ans\n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        cars = [(pos, speed) for pos, speed in zip(position, speed)]\n        cars.sort()\n        \n        last_t = -1\n        curr_t = 0\n        fleets = 0\n        \n        for pos, speed in reversed(cars):\n            curr_t = (target - pos) / speed\n            \n            if curr_t > last_t:\n                fleets += 1\n                last_t = curr_t\n        \n        return fleets", "import collections\nimport numpy as np\n\nclass Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        cars = sorted(range(len(position)), key=lambda i: position[i])\n        def calc_finish_time(car):\n            return (target - position[cars[car]]) / speed[cars[car]]\n        fleets = 0\n        next_finish_time = -1\n        for car in range(len(cars)-1, -1, -1):\n            finish_time = max(calc_finish_time(car), next_finish_time)\n            if finish_time != next_finish_time:\n                fleets += 1\n            next_finish_time = finish_time                \n        return fleets            ", "import collections\nimport numpy as np\n\nclass Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        tem=list(zip(position,speed))\n        tem=sorted(tem, key=lambda x:x[0])\n        count=0\n        stack=[(target-tem[i][0])/tem[i][1] for i in range(len(tem))]\n        stack=stack[::-1]\n        cur=0\n        for j in range(len(stack)):\n            if stack[j]>cur:\n                count+=1\n                cur=stack[j]\n        return count       ", "import collections\nclass Solution:\n    def carFleet(self, D: int, P: List[int], S: List[int]) -> int:\n        T = [(D-P[i])/S[i] for i in range(len(P))]\n        sortedIdx = sorted(list(range(len(P))), key=lambda x: P[x])\n        print(sortedIdx)\n        stack = []\n        for i in sortedIdx:\n            while stack and T[stack[-1]] <= T[i]:\n                stack.pop()\n            stack.append(i)\n            print(stack)\n        return len(stack)\n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n#         c=0\n#         cnt=[]\n#         for i in range(len(position)):\n#             temp=[]\n#             while(position[i]!=target):\n#                 temp.append(position[i])\n#                 position[i]=position[i]+speed[i]\n#             temp.append(12)\n#             cnt.append(temp)\n#         for i in range(len(cnt)):\n#             for j in range(i+1,len(cnt)):\n#                 for k in cnt[i]:\n#                     if k in cnt[j]:\n#                         if(cnt[i].index(k)==cnt[j].index(k)):\n#                             c=c+1\n            \n        \n#         print(cnt)\n            cars = sorted(zip(position, speed))\n            print(cars)\n            times = [float(target - p) / s for p, s in cars]\n            print(times)\n            ans = 0\n            while len(times) > 1:\n                lead = times.pop()\n                if lead < times[-1]: ans += 1  # if lead arrives sooner, it can't be caught\n                else: times[-1] = lead # else, fleet arrives at later time 'lead'\n\n            return ans + bool(times) # remaining car is fleet (if it exists)", "import collections\nimport numpy as np\n\nclass Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        if len(position) < 1:\n            return 0\n        d = dict(zip(target - np.array(position), speed))\n        ord_d = collections.OrderedDict(sorted(d.items()))\n        count = 0\n        r = -1\n        for dist, speed in ord_d.items():\n            t = dist / speed\n            if t > r:\n                count += 1\n                r = t\n        return count ", "import collections\nimport numpy as np\n\nclass Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        if len(position) < 1:\n            return 0\n        # d = dict(zip(target - np.array(position), speed))\n        ord_d = collections.OrderedDict(sorted(dict(zip(target - np.array(position), speed)).items()))\n        count = 0\n        r = -1\n        for dist, speed in ord_d.items():\n            t = dist / speed\n            if t > r:\n                count += 1\n                r = t\n        return count ", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        times = []\n        for p in range(len(position)):\n            times.append([(target - position[p])/speed[p], position[p]])\n        \n        times.sort()\n        \n        maxTime = 0\n        res = 0\n        print(times)\n        for t in range(len(times) - 1, -1, -1):\n            if times[t][1] >= maxTime:\n                res += 1\n            maxTime = max(times[t][1], maxTime)\n        \n        return res\n            \n            \n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        N = len(position)\n        cars = sorted((s,p) for s,p in zip(speed, position))\n        seen = set()\n        res = 0\n        # print(cars)\n        for i in range(N):\n            if i in seen: continue\n            seen.add(i)\n            res += 1\n            \n            for j in range(i+1, N):\n                if j in seen or cars[j][0]==cars[i][0]: continue\n                t = (cars[i][1]-cars[j][1])/(cars[j][0]-cars[i][0])\n                if t<0 or t*cars[i][0]+cars[i][1]>target: continue\n                seen.add(j)\n                \n        return res\n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        ind = sorted(range(len(position)), key = lambda x: position[x])\n        print(ind)\n        r = len(speed) - 1\n        fleet_num = 0\n        while r >= 0:\n            time = (target - position[ind[r]]) / speed[ind[r]]\n            position[ind[r]] = target\n            r = r-1\n            while r >= 0 and position[ind[r]] + speed[ind[r]] * time >= target:\n                position[ind[r]] = target\n                r = r-1\n            fleet_num += 1\n            for i in range(r+1,-1):\n                position[ind[i]] = min(position[ind[i]] + time * speed[ind[i]],position[ind[i+1]])\n        return fleet_num", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        if len(position) < 1:\n            return 0\n        acc = [(position[i], speed[i]) for i in range(len(position))]\n        acc = sorted(acc, key=lambda x: x[0])\n        \n        fleets = 1\n        predecessor_arrival = (target - acc[-1][0])/acc[-1][1]\n        \n        for i in range(len(acc) - 2, -1, -1):\n            arrival = (target - acc[i][0])/acc[i][1]\n            if arrival > predecessor_arrival:\n                fleets += 1\n                predecessor_arrival = arrival\n        return fleets\n        \n# position: [10,8,0,5,3] -> [0,3,5,8,10]\n# spee:     [2,4,1,1,3]  -> [1,3,1,4,2]\n\nif True:\n    print((Solution().carFleet(\n        10,\n        [0,4,2],\n        [2,1,3]))) # 1\n# [0,2,4]\n# [2,3,1]\n# [5,3,6]\n\n# pos[i] + x1*speed[i] == 12\n# pos[i+1] + x2*speed[i+1] == 12\n# x1 = (12 - pos[i])/speed[i]\n# x2 = (12 - pos[i+1])/speed[i+1]\n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        pos_speed = sorted(zip(position, speed))\n        times = [float(target-p)/s for p, s in pos_speed]\n\n        res = 0\n        cur = 0\n            \n        for t in times[::-1]:\n            if t > cur:\n                res += 1\n                cur = t\n        \n        return res", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        time = [(target - p) / s for p, s in sorted(zip(position, speed), key=lambda x: x[0])]\n        fleets = 0\n        last_arrive = 0\n        for t in time[::-1]:\n            if t > last_arrive:\n                last_arrive = t\n                fleets += 1\n        return fleets", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        times = [(target - pos) / s for pos, s in sorted(zip(position, speed))]\n        cur = ans = 0\n        for time in times[::-1]:\n            if time > cur:\n                ans += 1\n                cur = time\n        return ans\n        \n    # start a new fleet when cur car's time to target is longer than the leader car of the cur fleet (i.e. cur car can't catch up with last fleet)\n    # need to sort cars by position and start looping from the car closest to target becasue 'a car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed'. If we have cars A, B, C. time for A to reach target is shorter than B, then C. If we don't go from C to A, we don't know if there are three fleets or one. Going from C to A tells us it's one  \n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        if len(position) == 0:\n            return 0\n        time_required = []\n        for i in range(len(position)):\n            time_required.append((target-position[i])/speed[i])\n        time_required = [x for _, x in sorted(zip(position, time_required), reverse=True)]\n        print(time_required)\n        count = 1\n        previous_time = time_required[0]\n        for i in range(1, len(time_required)):\n            if time_required[i] > previous_time:\n                count += 1\n                previous_time = time_required[i]\n        return count", "class Solution(object):\n    def carFleet(self, target, position, speed):\n        if not position:   return 0\n        cars = sorted(zip(position, speed))\n        times = [float(target - p) / s for p, s in cars]\n        ans = 0\n        while len(times) > 1:\n            lead = times.pop()\n            if lead < times[-1]: ans += 1  # if lead arrives sooner, it can't be caught\n            else: times[-1] = lead # else, fleet arrives at later time 'lead'\n        return ans + 1 \n", "class Solution:\n    def carFleet(self, target: int, P: List[int], S: List[int]) -> int:\n        n = len(P)\n        \n        l = []\n        for i in range(n):\n            l.append((P[i],S[i]))\n        \n        l.sort(reverse=True)\n        \n        c = 0\n        pt = -1\n        for i,j in l:\n            ct = (target - i) / j\n            if ct > pt:\n                c += 1\n                pt = ct\n                \n        return c", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        cars = sorted(list(zip(position,speed)))\n        print(cars)\n        times = [(target-p)/s for p,s in cars]\n        \n        ans = 0\n        \n        while (len(times)>1):# that means atleast 2 elements must be there cause we will pop one and then check one for comparing\n            lead = times.pop()\n            if lead<times[-1]:\n                ans+=1\n            else:\n                times[-1]= lead\n                \n        return(ans+len(times)) # remaining car is fleet if it exists", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        if len(position)==0:\n            return 0\n        pos_spd = sorted(zip(position,speed)) \n        position = [x for x,y in pos_spd]\n        speed = [y for x,y in pos_spd]\n        time = list([(target-x[0])/x[1] for x in pos_spd])\n        idx = []\n        count=1\n        temp = time[-1]\n        for val in time[::-1]:\n            if val>temp: # cant catch the next one\n                count+=1\n                temp = val\n        return count\n\n            \n                \n            \n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        stack = []\n        for pos, vel in sorted(zip(position, speed))[::-1]:\n            dist = target - pos\n            if not stack:\n                stack.append(dist / vel)\n            elif dist / vel > stack[-1]:\n                stack.append(dist / vel)\n        return len(stack)\n        \n        \n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        if not position:\n            return 0\n        \n        posToSpeed = {position[i]: speed[i] for i in range(len(position))}\n        position.sort()\n        \n        leaderTime = (target - position[-1]) / posToSpeed[position[-1]]\n        currGroups = 1\n        for i in range(len(position) - 2, -1, -1):\n            currTime = (target - position[i]) / posToSpeed[position[i]]\n            if currTime > leaderTime:\n                currGroups += 1\n                leaderTime = currTime\n        \n        return currGroups\n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        cars = sorted(zip(position, speed))\n        times = [(target-p) / s for (p, s) in cars]\n        res = 0\n        while len(times) >= 2:\n            lead = times.pop()\n            if times[-1] > lead:\n                res += 1\n            else:\n                times[-1] = lead\n            \n        return res+ len(times)\n                \n        \n", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        # for each car:\n        cars = []\n        for i in range(len(speed)):\n            cars.append([position[i], speed[i], (target - position[i]) / speed[i]])\n        \n        cars.sort(key=lambda x: x[0])\n        #print(cars)\n        \n        maxs = []\n        for car in cars[::-1]:\n            if not maxs: maxs.insert(0, car[2])\n            else: maxs.insert(0, max(maxs[0], car[2]))\n        print(maxs)\n        fleets = {}\n        fleetCount = 0\n        \n        for i, car in enumerate(cars):\n            inFleet = maxs[i+1] >= car[2] if i < len(cars)-1 else False\n            if not inFleet:\n                fleetCount+=1\n        \n        return fleetCount", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        cars = sorted(zip(position, speed))\n        times = [float(target - p) / s for p, s in cars]\n        ans = 0\n        while len(times) > 1:\n            lead = times.pop()\n            if lead < times[-1]: ans += 1  # if lead arrives sooner, it can't be caught\n            else: times[-1] = lead # else, fleet arrives at later time 'lead'\n\n        return ans + bool(times) # remaining car is fleet (if it exists)", "class Solution:\n    def carFleet(self, target: int, p: List[int], s: List[int]) -> int:\n        if not p:\n            return 0\n        l = [[p[i], s[i]] for i in range(len(p))]\n        l.sort(reverse=True)\n        x = l[0]\n        res = 1\n        \n        for y in l[1:]:\n            t = (target - y[0]) / y[1]\n            if t > (target - x[0]) / x[1]:\n                res += 1\n                x = y\n        return res", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        stack = []\n        for pos, vel in sorted(zip(position, speed))[::-1]:\n            dist = target - pos\n            if not stack:\n                stack.append(dist / vel)\n            elif dist / vel > stack[-1]:\n                stack.append(dist / vel)\n        return len(stack)", "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        # sort by starting position\n        cars = sorted(zip(position, speed))\n        times = [(target - p) / s for p, s, in cars]\n        # count from back\n        most = 0\n        count = 0\n        for i in range(len(times)-1 ,-1, -1):\n            if times[i] > most:\n                most = times[i]\n                count += 1\n                \n        return count", "class Solution(object):\n    def carFleet(self, target, position, speed):\n        cars = sorted(zip(position, speed))\n        times = [float(target - p) / s for p, s in cars]\n        ans = 0\n        while len(times) > 1:\n            lead = times.pop()\n            if lead < times[-1]: ans += 1  # if lead arrives sooner, it can't be caught\n            else: times[-1] = lead # else, fleet arrives at later time 'lead'\n\n        return ans + bool(times) # remaining car is fleet (if it exists)"]
["# \u306a\u3093\u3060\u304b\u91c8\u7136\u3068\u3057\u3066\u3044\u306a\u3044\u304c\u89e3\u8aac\u306e\u901a\u308a\u306b\nfrom collections import deque\nimport sys\n\ndef MI(): return list(map(int, sys.stdin.readline().split()))\n\nclass water:\n    def __init__(self, t, v):\n        self.v = v\n        self.tv = v * t\n\n    def __le__(self, other):\n        return self.v * other.tv - self.tv * other.v >= 0\n\n    def __isub__(self, other):\n        t = self.tv / self.v\n        self.v -= other\n        self.tv = t * self.v\n        return self\n\n    def __iadd__(self, other):\n        self.v+=other.v\n        self.tv+=other.tv\n        return self\n\ndef main():\n    n, l = MI()\n    dam = deque()\n    t, v = MI()\n    print(t)\n    dam.append(water(t, v))\n    # stv\u306ftv\u306e\u5408\u8a08\uff08v\u304cl\u306e\u3068\u304d\u306evt\uff09\n    stv = t * v\n    for _ in range(n-1):\n        t, v = MI()\n        # \u671d\u306b\u6c34\u3092\u3082\u3089\u3046\n        dam.appendleft(water(t, v))\n        over = v\n        stv += t * v\n        # \u5897\u3048\u305f\u5206\u306e\u6c34\u3092\u53e4\u3044\u65b9\u304b\u3089\u6368\u3066\u308b\n        # \u30d9\u30af\u30c8\u30eb\u3054\u3068\u524a\u9664\u3067\u304d\u308b\u3082\u306e\n        while dam[-1].v <= over:\n            w = dam.pop()\n            over -= w.v\n            stv -= w.tv\n        # \u6700\u5f8c\u306e\u306f\u307f\u51fa\u3057\u3066\u3044\u308b\u30d9\u30af\u30c8\u30eb\u306f\u7e2e\u3081\u308b\n        stv -= dam[-1].tv  # \u4e00\u5ea6\u5408\u8a08\u304b\u3089\u53d6\u308a\u51fa\u3057\u3066\n        dam[-1] -= over  # \u7e2e\u3081\u3066\n        stv += dam[-1].tv  # \u5143\u306b\u623b\u3059\n        # \u305d\u306e\u65e5\u306e\u6c34\u6e29\u3092\u51fa\u529b\n        print((stv / l))\n        # \u30b0\u30e9\u30d5\u306e\u5de6\u5074\u304c\u51f9\u3093\u3067\u3044\u305f\u3089\u30d9\u30af\u30c8\u30eb\u3092\u5408\u6210\u3057\u3066\u51f8\u306b\u76f4\u3059\n        while len(dam)>1 and dam[0] <= dam[1]:\n            w = dam.popleft()\n            dam[0] += w\n\nmain()\n", "from collections import deque\n\nN, L = list(map( int, input().split() ))\nT = []\nV = []\nfor i in range( N ):\n  t, v = list(map( int, input().split() ))\n  T.append( t )\n  V.append( v )\n\ndq = deque()\nct, cv = 0.0, 0.0\nfor i in range( N ):\n  while cv + V[ i ] > L:\n    ft, fv = dq[ 0 ]\n    take = min( cv + V[ i ] - L, fv )\n    ct, cv = ( ct * cv - ft * take ) / ( cv - take ), cv - take\n    if take == fv:\n      dq.popleft()\n    else:\n      dq[ 0 ] = [ ft, fv - take ]\n  ct, cv = ( ct * cv + T[ i ] * V[ i ] ) / L, L\n  print(( \"%.7f\" % ct ))\n  while len( dq ):\n    bt, bv = dq[ len( dq ) - 1 ]\n    if bt < T[ i ]: break\n    T[ i ], V[ i ] = ( T[ i ] * V[ i ] + bt * bv ) / ( V[ i ] + bv ), V[ i ] + bv\n    dq.pop()\n  dq.append( [ T[ i ], V[ i ] ] )\n", "# F\nfrom collections import deque\n \nTT_list = []\n# input\nN, L = list(map(int, input().split()))\nT = 0.0\nvt_now = 0.0\nv_now = 0\nque = deque()\n\nfor i in range(N):\n    ti, v = list(map(int, input().split()))\n    t = float(ti)\n    v_now += v\n    vt_now += v*t\n    # add\n    if v == L:\n        que.append([t, v])\n    else:\n        while v < L and len(que) > 0:\n            t_, v_ = que[-1]\n            if t_ <= t:\n                que.append([t, v])\n                break\n            elif v + v_ >= L:\n                v_ = v + v_ - L\n                t = ((L - v) * t_ + v * t) / L\n                v = L\n                que = deque([[t, v]])\n                v_now = L\n                vt_now = t*L\n                # break\n            else:\n                t = (t*v + t_*v_) / (v + v_)\n                v = v + v_\n                que.pop()\n    # minus\n    while v_now > L:\n        if que[0][1] <= v_now - L:\n            v_now -= que[0][1]\n            vt_now -= que[0][1]*que[0][0]\n            que.popleft()\n        else:\n            que[0][1] -= v_now - L\n            vt_now -= (v_now - L)*que[0][0]\n            v_now = L\n            \n    TT_list.append(vt_now / L)\n\nfor i in range(N):\n    print((TT_list[i]))\n"]
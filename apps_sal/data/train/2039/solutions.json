["import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\n\nMIN=0\nMAX=m\n\nwhile MIN!=MAX:\n    x=(MIN+MAX)//2\n    #print(x,MIN,MAX)\n    #print()\n\n    M=0\n    for a in A:\n        #print(a,M)\n        if a<=M and a+x>=M:\n            continue\n        elif a>M and a+x>=m and (a+x)%m>=M:\n            continue\n        elif a>M:\n            M=a\n        else:\n            MIN=x+1\n            break\n    else:\n        MAX=x\n\nprint(MIN)\n", "N, M = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\n\ndef chk(k):\n    ret = 0\n    for i in range(N):\n        a, b = A[i], (A[i]+k)%M\n        if a <= b < ret:\n            return 0\n        if ret <= a <= b or b < ret <= a:\n            ret = a\n    return 1\n\nl = -1\nr = M \nwhile r - l > 1:\n    m = (l+r) // 2\n    if chk(m):\n        r = m\n    else:\n        l = m\n\nprint(r)\n", "n,m=map(int,input().split())\na=list(map(int,input().split()))\nsml=0\nbig=m-1\ncurr=(m-1)//2\nwhile sml!=big:\n    bug=0\n    good=True\n    for i in range(n):\n        if a[i]+curr<m+bug:\n            if a[i]+curr<bug:\n                good=False\n                break\n            bug=max(bug,a[i])\n    if good:\n        big=max(curr,sml)\n        curr=(big+sml)//2\n    else:\n        sml=min(curr+1,big)\n        curr=(sml+big)//2\nprint(curr)", "# AC\nimport sys\n\n\nclass Main:\n    def __init__(self):\n        self.buff = None\n        self.index = 0\n\n    def __next__(self):\n        if self.buff is None or self.index == len(self.buff):\n            self.buff = self.next_line()\n            self.index = 0\n        val = self.buff[self.index]\n        self.index += 1\n        return val\n\n    def next_line(self):\n        return sys.stdin.readline().split()\n\n    def next_ints(self):\n        return [int(x) for x in sys.stdin.readline().split()]\n\n    def next_int(self):\n        return int(next(self))\n\n    def solve(self):\n        n, m = self.next_ints()\n        x = self.next_ints()\n        low = 0\n        high = m\n        while high - low > 1:\n            mid = (high + low) // 2\n            if self.test(mid, x, m):\n                high = mid\n            else:\n                low = mid\n        print(low if self.test(low, x, m) else high)\n\n    def test(self, st, xs, m):\n        xx = 0\n        for x in xs:\n            fr = x\n            to = x + st\n            if to >= m:\n                to -= m\n            if to >= fr:\n                if xx > to:\n                    return False\n                xx = max(xx, fr)\n            elif to < xx < fr:\n                xx = fr\n        return True\n\n\ndef __starting_point():\n    Main().solve()\n\n__starting_point()", "#\nn, m = list(map(int, input().split()))\na    = list(map(int, input().split()))\n\ndef check(a, x, m):\n    Max = m\n    flg = True\n    \n    for val in a[::-1]:\n        if val <= Max:\n            Max = min(Max, val+x)\n        else:\n            if (val + x) < m:\n                flg = False\n                break\n            else:\n                Max = min(Max, (val+x)%m)\n    return flg\n\nl=-1\nu=m \nwhile u-l>1:\n    md = (u+l) // 2\n    if check(a, md, m) == True:\n        u = md\n    else:\n        l = md\nprint(u)        \n        \n", "from sys import stdin\nn,m=list(map(int,stdin.readline().strip().split()))\ns=list(map(int,stdin.readline().strip().split()))\nhigh=m+1\nlow=0\nwhile (high-low)>1:\n  mx=0\n  flag=True\n  mid=(low+high)//2\n\n  for i in range(n):\n    if (s[i]>=mx):\n      if(s[i]+mid)>=m and (s[i]+mid)%m>=mx:\n        continue\n      else:\n        mx=s[i]\n    elif (s[i]+mid)>=mx:\n      continue\n    else:\n      flag=False\n      break\n  if flag:\n    high=mid\n  else:\n    low=mid\nfor j in range(low,low+2):\n  mx=0\n  flag=True\n  mid=(j+j+1)//2\n  for i in range(n):\n    if (s[i]>=mx):\n      if(s[i]+mid)>=m and (s[i]+mid)%m>=mx:\n        continue\n      else:\n        mx=s[i]\n    elif (s[i]+mid)>=mx:\n      continue\n    else:\n      flag=False\n      break\n  if flag:\n    print(j)\n    break\n\n\n", "n,m = input().split()\nn,m = int(n),int(m)\na = list(map(int, input().split()))\nl,r = 0,m-1\ndef isOptimal(mid):\n    prev = 0\n    check=True\n    for i in range(n):\n            if prev<a[i]:\n                if m-a[i]+prev>mid:\n                    prev=a[i]\n            else:\n                if prev-a[i]>mid:\n                    check=False\n    return check\nwhile l<=r:\n    check=True\n    mid=(l+r)//2\n    prev=a[0]\n    if isOptimal(mid):\n        r=mid-1\n    else:\n        l=mid+1\n\ncheck = isOptimal(l)\nprint(l*check+r*(not check))\n", "import heapq\nimport sys\nimport bisect\nfrom collections import defaultdict\n\nfrom itertools import product\n\n\nn, m = list(map(int, input().split()))\narr = list(map(int, input().split()))\n\nl, r = -1, m\n\ndef check_v(v):\n    M = 0\n    for el in arr:\n        if el <= M:\n            if el + v >= M:\n                continue\n            else:\n                return False\n        else:\n            if el + v >= M + m:\n                continue\n            else:\n                M = el\n    return True\n\nwhile r - l > 1:\n    mid = (l + r) // 2\n    if check_v(mid):\n        r = mid\n    else:\n        l = mid\nprint(r)", "n, m = list(map(int, input().split()))\nass = list(map(int,input().split()))\n\ndef done(a):\n    return all(x < y for  (x,y) in zip(a[:-1], a[1:]))\n\nmaxops = m-1\nminops = 0\nwhile maxops > minops:\n    cops = (maxops+minops)//2\n    base = 0\n    ok = True\n    for a in ass:\n        if base > a and (base - a) > cops:\n            ok = False\n            break\n        elif (base - a) % m > cops:\n            base = a\n    if ok:\n        maxops = cops\n    else:\n        minops = cops+1\nprint (maxops)\n\n", "n, m = list(map(int, input().split()))\na = [int(i) for i in input().split()]\nL = -1\nR = m\nwhile L < R - 1:\n    mid = (L + R) // 2\n    last = 0\n    isok = True\n    for el in a:\n        if last == el:\n            continue\n        if last > el:\n            if el + mid >= last:\n                continue\n            else:\n                isok = False\n                break\n        else:\n            if el + mid - m >= last:\n                continue\n            else:\n                last = el\n    if isok:\n        R = mid\n    else:\n        L = mid\nprint(R)\n", "n, m = map(int, input().split())\na = [int(i) for i in input().split()]\nL = -1\nR = m\nwhile L < R - 1:\n    mid = (L + R) // 2\n    last = 0\n    isok = True\n    for el in a:\n        if last == el:\n            continue\n        if last > el:\n            if el + mid >= last:\n                continue\n            else:\n                isok = False\n                break\n        else:\n            if el + mid - m >= last:\n                continue\n            else:\n                last = el\n    if isok:\n        R = mid\n    else:\n        L = mid\nprint(R)", "\"\"\"\nobservations:\n1. multi solution\n\n\"\"\"\n\n\ndef inc_by_mod(arr, m):\n    def is_opt(count):\n        prev = 0\n        for elem in arr:\n            if prev < elem:\n                if m - (elem - prev) > count:\n                    prev = elem\n            elif prev - elem > count:\n                return False\n        return True\n    count = 0\n    lo, hi = 0, m - 1\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if is_opt(mid):\n            hi = mid\n        else:\n            lo = mid + 1 \n\n    return lo\ndef main():\n    n, m = map(int, input().split())\n    arr = list(map(int, input().split()))\n\n    res = inc_by_mod(arr, m)\n    print(res)\n\ndef __starting_point():\n    main()\n__starting_point()", "def check(M):\n    now = 0\n    for i in range(n):\n        #print(i, now, mas[i], M, (now - mas[i]) % m)\n        if (now - mas[i]) % m > M:\n            if mas[i] > now:\n                now = mas[i]\n            else:\n                return False\n    return True\n\nn, m = list(map(int, input().split()))\nl = -1\nr = m\nmas = list(map(int, input().split()))\ncheck(3)\nwhile l < r - 1:\n    M = (l + r) // 2\n    if check(M):\n        r = M\n    else:\n        l = M\nprint(r)", "def check(times, nums, m):\n\tcurrent = 0 if (nums[0] + times >= m) else nums[0]\n\tfor i in range(1, len(nums)):\n\t\tif nums[i] == current:\n\t\t\tcontinue\n\t\tif nums[i] < current and current - nums[i] > times:\n\t\t\treturn False\n\t\tif nums[i] > current and m - nums[i] + current > times:\n\t\t\tcurrent = nums[i]\n\treturn True\n\ndef main():\n\tn, m = [int(x) for x in input().split()]\n\tnums = [int(x) for x in input().split()]\n\tif check(0, nums, m):\n\t\treturn 0\n\tl = 0\n\tr = m\n\twhile l + 1 < r:\n\t\tmid = (l + r) // 2\n\t\t# print(l, r, mid)\n\t\tif check(mid, nums, m):\n\t\t\tr = mid\n\t\telse:\n\t\t\tl = mid\n\treturn r\n\n\ndef __starting_point():\n\tprint(main())\n__starting_point()", "def chek(mid):\n\tv = 0\n\tfor i in range(n):\n\t\tif (v - a[i]) % m > mid:\n\t\t\tif a[i] > v:\n\t\t\t\tv = a[i]\n\t\t\telse:\n\t\t\t\treturn False\n\treturn True\n\nn, m = list(map(int, input().split()))\n\nl = -1\nr = m\n\na = list(map(int, input().split()))\n\nchek(3)\n\n\nwhile l < r - 1:\n\t\n\tmid = (l + r) // 2\n\tif chek(mid):\n\t\tr = mid\n\telse:\n\t\tl = mid\n\n#print(l, r)\nprint(r)\n", "def checker(ij):\n    count=0\n    for i in range(len(l)):\n        #print(count)\n        #print(((count-l[i])%m),ij)\n        if ((count-l[i])%m)>=ij:\n            if l[i]>count:\n                count=l[i]\n            else:\n                return False\n    #print(l)\n    return True\nn,m=input().split()\nn,m=[int(n),int(m)]\nl=[int(i) for i in input().split()]\nbeg=-1\nlast=m\nwhile beg<last-1:\n    mid=(beg+last)//2\n    counter=checker(mid)\n    #print(beg,last)\n    if counter:\n        last=mid\n    else:\n        beg=mid\nprint(beg)\n", "#First we notice that the number of overall operations is equal to the maximum number\n#of operations used on a single index.Next we notice that, if we can solve the problem\n#in <= X operations, then we can also solve it in <= X + 1 operations.\n#This is a monotonic sequence, so we can solve for the minimum value of X with binary search.\n#we have to check wether each element can be changed into\n#its previous element(count) in the list using a specified number of operations\n#if its not possible then we have to check wether current element is greater\n#than the previosu element , if it is so, then we have no need to change\n#as the list is already in non decreaing form, then we simply replace\n#count with the current element\n#if it is lesser than count, then there is no way to make the element\n#greater than or equal to the previous element using specified number of\n#operations and we return to the binary search part to get the next no. of\n#operations\ndef checker(ij):\n    count=0\n    for i in range(len(l)):\n        #print(count)\n        #print(((count-l[i])%m),ij)\n        if ((count-l[i])%m)>=ij:\n            if l[i]>count:\n                count=l[i]\n            else:\n                return False\n    #print(l)\n    return True\nn,m=input().split()\nn,m=[int(n),int(m)]\nl=[int(i) for i in input().split()]\nbeg=-1\nlast=m\nwhile beg<last-1:\n    mid=(beg+last)//2\n    counter=checker(mid)\n    #print(beg,last)\n    if counter:\n        last=mid\n    else:\n        beg=mid\nprint(beg)\n", "n, m = map(int,input().split())\na = list(map(int, input().split()))\nl, r, ans = 0, m, m\nwhile l <= r:\n    mid = (l + r) // 2\n    cur = 0 if a[0] + mid >= m else a[0]\n    i = 1\n    while i < n:\n        if a[i] + mid < cur:\n            break\n        if not(a[i] < cur or (a[i] + mid >= m and (a[i] + mid) % m >= cur)):\n            cur = a[i]\n        i += 1\n    if i == n:\n        ans = min(ans, mid)\n        if l == r:\n            break\n        r = mid\n    else:\n        if l == r:\n            break\n        l = mid + 1\nprint(ans)", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\n\"\"\"\ncreated by shhuan at 2020/1/14 22:22\n\n\"\"\"\n\n\ndef solve(N, M, A):\n    def check(ops):\n        pv = 0\n        for v in A:\n            if v + ops < M:\n                if v + ops < pv:\n                    return False\n                pv = max(pv, v)\n            else:\n                d = (v + ops) % M\n                if d >= pv:\n                    pass\n                else:\n                    pv = max(pv, v)\n        return True\n\n    lo, hi = 0, max(N, M)\n    while lo <= hi:\n        m = (lo + hi) // 2\n        if check(m):\n            hi = m - 1\n        else:\n            lo = m + 1\n    return lo\n\n\n\nN, M = map(int, input().split())\nA = [int(x) for x in input().split()]\nprint(solve(N, M, A))", "import math\nimport cmath\n\nn,m,v=0,0,[]\n\n\ndef solve():\n    nonlocal m,v\n    st,dr=0,m-1\n    while st<dr:\n        md=st + dr>>1\n        ok=1\n        cur=0\n        for x in v:\n            if(x+md>=m):\n                if(cur>=x or cur<= x+md-m):\n                    continue\n                else:\n                    cur=int(x)\n            else:\n                if(cur>x+md):\n                    ok=0\n                    break\n                elif(cur<x):\n                    cur=int(x)\n        if(ok==1):\n            dr=md\n        else:\n            st=md+1\n    return st \n\n\ndef main():\n    nonlocal n,m,v\n    n,m = (int(x) for x in input().split())\n    v = list(int(x) for x in input().split())\n    ans=solve()\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def check(n, m, s, v):\n\tmi = 0\n\tfor i in range(n):\n\t\tif v[i]+s<mi:\n\t\t\treturn False\n\t\tif v[i]>mi:\n\t\t\tif (v[i]+s)%m>=mi:\n\t\t\t\tif v[i]<=(v[i]+s)%m:\n\t\t\t\t\tmi = v[i]\n\t\t\telse:\n\t\t\t\tmi = v[i]\n\n\t\t# print(i, mi)\n\treturn True\n\ndef __starting_point():\t\n\tn, m = list(map(int, input().split()))\n\tv = list(map(int, input().split()))\n\t\n\tl = 0\n\tr = m\n\twhile l<r:\n\t\ts = (l+r)//2\n\t\tif check(n, m, s, v):\n\t\t\t# print(s, 1)\n\t\t\tr = s\n\t\telse:\n\t\t\t# print(s, 0)\n\t\t\tl = s+1\n\n\tprint(l)\n\n__starting_point()", "n,m=map(int,input().split())\na=list(map(int,input().split()))\nl,r=-1,m-1\nwhile l+1<r:\n\tmid,p,f=(l+r)//2,0,1\n\tfor i in a:\n\t\tif (m-i+p)%m>mid:\n\t\t\tif i<p:\n\t\t\t\tf=0\n\t\t\t\tbreak\n\t\t\tp=i\n\tif f:\n\t\tr=mid\n\telse:\n\t\tl=mid\nprint (r)", "n, m = map(int, input().split())\narr = list(map(int, input().split()))\nl, r = 0, m-1\nwhile l < r:\n    mid = (l+r)//2\n    p = 0\n    f = True\n    for x in arr:\n        step = (m-x+p)%m\n        if step > mid:\n            if x < p:\n                f = False\n                break\n            p = x\n    if f is True:\n        r = mid\n    else:\n        l = mid+1\nprint(l)", "n,m = input().split()\nn,m = int(n),int(m)\na = list(map(int, input().split()))\nl,r = 0,m-1\ndef isOptimal(mid):\n    prev = 0\n    check=True\n    for i in range(n):\n            if prev<a[i]:\n                if m-a[i]+prev>mid:\n                    prev=a[i]\n            else:\n                if prev-a[i]>mid:\n                    check=False\n    return check\nwhile l<=r:\n    check=True\n    mid=(l+r)//2\n    prev=a[0]\n    if isOptimal(mid):\n        r=mid-1\n    else:\n        l=mid+1\n \ncheck = isOptimal(l)\nprint(l*check+r*(not check))", "N,M = map(int, input().split())\nA = list(map(int, input().split()))\nL = -1\nR = M\nwhile L < R - 1:\n    mid = (L + R) // 2\n    last = 0\n    k = 1\n    for i in A:\n        if last == i:\n            continue\n        if last > i:\n            if i + mid >= last:\n                continue\n            else:\n                k = 0\n                break\n        else:\n            if i + mid - M >= last:\n                continue\n            else:\n                last = i\n    if k == 1:\n        R = mid\n    else:\n        L = mid\nprint(R)"]
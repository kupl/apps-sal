["from collections import Counter\n\ndef solution(tiles):\n    return \"\".join(\n        tile for tile in \"123456789\"\n            if tiles.count(tile) < 4\n            and list(meld(meld(meld(meld(pair(Counter(map(int, tiles+tile))))))))\n    )\n\ndef pair(c):\n    yield from (c - Counter([t,t]) for t in c if c[t] > 1)\n\ndef meld(C):\n    yield from (\n        c - m for c in C for t in [min(c.keys())]\n              for m in (Counter((t,t+d,t+d+d)) for d in (0,1))\n              if (c&m) == m)", "from re import findall\n\ndef solution(tiles):\n  \n  res = ''\n  \n  for tile in range(1, 10):\n      hand = ''.join(sorted(tiles + str(tile)))\n      if any(hand.count(c) > 4 for c in set(hand)): continue\n      \n      for pair in findall(r'((\\d)\\2)', hand):\n          \n          rest = hand.replace(pair[0], '', 1)\n          \n          while rest: \n              char = rest[0]\n              triplet = char * 3\n              if triplet in rest: \n                  rest = rest.replace(triplet, '')\n              else:\n                  i = int(char)\n                  second, third = str(i + 1), str(i + 2)\n              \n                  if char in rest and second in rest and third in rest:\n                      rest = rest.replace(char, '', 1).replace(second, '', 1).replace(third, '', 1)\n                  else: \n                      break\n          \n          if not rest: \n              res += str(tile)\n              break\n  \n  return res", "from collections import Counter\nfrom copy import *\n##only works for first case\ndef solution(tiles):\n    valid = \"\"\n    for i in range(1, 10):\n        x = tiles + str(i)\n        c=Counter(x)\n            \n        if c.most_common(1)[0][1]<5 and is_valid(Counter(x)):\n            valid += str(i)\n\n    return valid\n\n\ndef is_valid(hand,melds=0,pair=0):\n\n\n    hand = {k: v for k, v in hand.items() if v}\n    ordered_hand=sorted(hand,key=int)\n    \n    if melds>5 or pair>1:\n        return False\n    if len(hand) == 0:\n        return True\n        \n    if hand[ordered_hand[0]]>1:\n        new_hand=deepcopy(hand)\n        new_hand[ordered_hand[0]]-=2\n        if is_valid(new_hand,melds,pair+1):return True\n    if hand[ordered_hand[0]] > 2:\n        new_hand=deepcopy(hand)\n        new_hand[ordered_hand[0]] -= 3\n        if is_valid(new_hand,melds+1,pair):return True\n    if len(ordered_hand)>2 and int(ordered_hand[0]) + 2 == int(ordered_hand[1]) + 1 == int(ordered_hand[2]):\n        new_hand = deepcopy(hand)\n        new_hand[ordered_hand[0]] -= 1\n        new_hand[ordered_hand[1]] -= 1\n        new_hand[ordered_hand[2]] -= 1\n        if is_valid(new_hand,melds+1,pair):return True\n    return False", "from collections import Counter\n\ndef solution(tiles):\n    \n    def candidate(d):\n        game[d] += 1\n        isGood = dfs()\n        game[d] -= 1\n        return isGood\n    \n    def dfs(hasPair=False):\n        isGood, dig = False, min(k for k,v in game.items() if v)\n        \n        for iPair,config in enumerate([(3,), (1,1,1)] + [(2,)]*(not hasPair) ):\n            cMeld = Counter({dig+i: v for i,v in enumerate(config)})\n            \n            if sum((game & cMeld).values()) == sum(config):\n                game.__isub__(cMeld)\n                isGood |= sum(game.values())==0 or dfs(hasPair or iPair==2)\n                game.__iadd__(cMeld)\n                if isGood: break\n        return isGood\n\n    game = Counter(map(int,tiles))\n    return ''.join(str(d) for d in range(1,10) if game[d]<4 and candidate(d))", "from collections import Counter\nclass SubCounter(Counter):\n    def __le__(self, other):\n        return all(value <= other[key] for key, value in self.items())\nMELDS = [SubCounter({str(n): 3}) for n in range(1, 10)]\nMELDS.extend([SubCounter([str(n), str(n+1), str(n+2)]) for n in range(1, 8)])\n\ndef solution(tiles):\n    def remove(cnt):\n        if sum(cnt.values()) == 4: # Meld\n            for k, v in cnt.items():\n                if v >= 2:\n                    p = SubCounter(cnt)\n                    p[k] -= 2\n                    for m in MELDS:\n                        if p <= m:\n                            winning.update((m - p).keys())\n        if sum(cnt.values()) == 1: # Pair\n            winning.update(cnt.keys())\n        else:\n            for m in MELDS:\n                if m <= cnt:\n                    remove(cnt - m)\n    winning, cnt = set(), SubCounter(tiles)\n    forbidden = {k for k, v in cnt.items() if v >= 4}\n    return remove(cnt) or ''.join(sorted(winning - forbidden))", "deck = set('123456789')\n\n\ndef group(tiles, start, pair=None):\n    if len(tiles) == 1:\n        return [tiles]\n\n    if len(tiles) == 2:\n        if tiles[0] == tiles[1]:\n            return [pair, tiles[0]]\n        else:\n            a, b = ord(max(tiles[0], tiles[1])), ord(min(tiles[0], tiles[1]))\n            if a - b == 1:\n                r = []\n                if chr(a + 1) in deck:\n                    r.append(chr(a + 1))\n                if chr(b - 1) in deck:\n                    r.append(chr(b - 1))\n                return r\n            elif a - b == 2:\n                return [chr(b + 1)]\n        return []\n\n    tiles_set = set(tiles)\n    ret = []\n    for tile in tiles_set:\n        if tile < start:\n            continue\n\n        if len(tiles) % 3 == 1 and tiles.count(tile) > 1:\n            ret.extend(group(tiles.replace(tile, '', 2), tile, tile))\n        if tiles.count(tile) > 2:\n            ret.extend(group(tiles.replace(tile, '', 3), tile, pair))\n\n        a, b = chr(ord(tile) + 1), chr(ord(tile) + 2)\n        if a in tiles_set and b in tiles_set:\n            ret.extend(group(tiles.replace(tile, '', 1)\n                             .replace(a, '', 1).replace(b, '', 1), tile, pair))\n    return ret\n\n\ndef solution(tiles):\n    return ''.join(sorted([x for x in set(group(tiles, tiles[0])) if tiles.count(x) < 4]))\n", "from collections import Counter\n\ndef solution(tiles):\n    print(tiles)\n    cnts = {}\n    for i in range(1, 10):\n        if str(i) in tiles:\n            cnts[i] = tiles.count(str(i))\n        else:\n            cnts[i] = 0\n    print(cnts)\n    \n    res = ''\n    for i in range(1, 10):\n#         print(f'try {i}\\n=============================')\n        winset = []\n        if cnts[i] < 4:\n            cnts[i] += 1\n            if win(cnts, 0, winset):\n                res += str(i)\n            cnts[i] -= 1\n#         print(f'res = {res}, winset = {winset}')\n            \n    return res\n\ndef win(cnts, pair, winset):\n    if sum(cnts.values()) == 0: return True   \n    seqdic = {\n        1: [(2, 3)],\n        2: [(1, 3), (3, 4)],\n        3: [(1, 2), (2, 4), (4, 5)],\n        4: [(2, 3), (3, 5), (5, 6)],\n        5: [(3, 4), (4, 6), (6, 7)],\n        6: [(4, 5), (5, 7), (7, 8)],\n        7: [(5, 6), (5, 8), (8, 9)],\n        8: [(6, 7), (7, 9)],\n        9: [(7, 8)]\n    }\n    tiles = [i for i in cnts.keys() if cnts[i] > 0]\n    i = tiles[0]\n#     print(i, cnts)\n    if cnts[i] == 1: # sequence * 1\n        for j in seqdic[i]:\n            if cnts[j[0]] > 0 and cnts[j[1]] > 0:\n                cnts_c = cnts.copy()\n                cnts_c[j[0]] -= 1\n                cnts_c[j[1]] -= 1\n                cnts_c[i] -= 1\n                if win(cnts_c, pair, winset):\n                    winset.append((j[0], j[1], i))\n                    return True\n        return False\n    if cnts[i] == 2: # pair or sequence * 2\n        # pair\n        if not pair:\n            cnts_c = cnts.copy()\n            cnts_c[i] -= 2\n            if win(cnts_c, 1, winset):\n                winset.append((i, i))\n                return True\n        # sequence * 2\n        for j in seqdic[i]:\n             if cnts[j[0]] > 1 and cnts[j[1]] > 1:\n                cnts_c = cnts.copy()\n                cnts_c[j[0]] -= 2\n                cnts_c[j[1]] -= 2\n                cnts_c[i] -= 2\n                if win(cnts_c, pair, winset):\n                    winset += [(j[0], j[1], i)] * 2\n                    return True\n        return False\n    if cnts[i] == 3: # pair and sequence, triplet, or sequence * 3\n        # pair and sequence\n        if not pair:\n            cnts_c = cnts.copy()\n            cnts_c[i] -= 2\n            if win(cnts_c, 1, winset):\n                winset.append((i, i))\n                return True\n        # triplet\n        cnts_c = cnts.copy()\n        cnts_c[i] -= 3\n        if win(cnts_c, pair, winset):\n            winset.append((i, i, i))\n            return True\n        # sequence * 3\n        for j in seqdic[i]:\n             if cnts[j[0]] > 2 and cnts[j[1]] > 2:\n                cnts_c = cnts.copy()\n                cnts_c[j[0]] -= 3\n                cnts_c[j[1]] -= 3\n                cnts_c[i] -= 3\n                if win(cnts_c, pair, winset):\n                    winset += [(j[0], j[1], i)] * 3\n                    return True\n        return False\n    if cnts[i] == 4: # pair and sequence * 2, triplet and sequence, or sequence * 4\n        # pair and sequence * 2\n        if not pair:\n            cnts_c = cnts.copy()\n            cnts_c[i] -= 2\n            if win(cnts_c, 1, winset):\n                winset.append((i, i))\n                return True\n        # triplet and sequence\n        cnts_c = cnts.copy()\n        cnts_c[i] -= 3\n        if win(cnts_c, pair, winset):\n            winset.append((i, i, i))\n            return True\n        # sequence * 4\n        for j in seqdic[i]:\n             if cnts[j[0]] > 3 and cnts[j[1]] > 3:\n                cnts_c = cnts.copy()\n                cnts_c[j[0]] -= 4\n                cnts_c[j[1]] -= 4\n                cnts_c[i] -= 4\n                if win(cnts_c, pair, winset):\n                    winset += [(j[0], j[1], i)] * 4\n                    return True\n        return False", "# lazy backtrack attempt\n\ndef validate(tiles, used_pair=False):\n    tiles = sorted(tiles)\n    if not tiles:\n            return True\n        \n    current_tile = tiles.pop(0)\n    if tiles.count(current_tile) > 1:\n        tiles.remove(current_tile)\n        tiles.remove(current_tile)\n        ok = validate(tiles, used_pair)\n        if ok:\n            return True\n        tiles.append(current_tile)\n        tiles.append(current_tile)\n        tiles = list(sorted(tiles))\n    \n    if tiles.count(current_tile + 1) > 0 and tiles.count(current_tile + 2) > 0:\n        tiles.remove(current_tile + 1)\n        tiles.remove(current_tile + 2)\n        ok = validate(tiles, used_pair)\n        if ok:\n            return True\n        tiles.append(current_tile + 1)\n        tiles.append(current_tile + 2)\n        tiles = list(sorted(tiles))\n    \n    \n    if not used_pair and tiles.count(current_tile) > 0:\n        tiles.remove(current_tile)\n        ok = validate(tiles, True)\n        if ok:\n            return True\n        tiles.append(current_tile)\n        tiles = list(sorted(tiles))\n    tiles.append(current_tile)\n    return False\n\n\ndef solution(tiles):\n    result = ''\n    for i in range(1, 10):\n        if tiles.count(str(i)) > 3:\n            continue\n        tiles_with_new_tile = [int(n) for n in sorted(tiles + str(i))]\n        if validate(tiles_with_new_tile):\n            result += str(i)\n    return result", "from collections import Counter\n\ndef is_valid(hand):\n    if any(hand.count(str(i)) > 4 for i in range(1, 10)):\n        return False\n    stack = [[Counter(int(h) for h in hand), True, len(hand)]]\n    while stack:\n        status, has_pair, r = stack.pop()\n        if r == 0:\n            return True\n        else:\n            x = min(k for k, v in status.items() if v > 0)\n            if status[x] >= 3:\n                stack.append([(status - Counter([x, x, x])), has_pair, r - 3])\n            if status[x+1] >= 1 and status[x+2] >= 1:\n                stack.append([(status - Counter([x, x + 1, x + 2])), has_pair, r - 3])\n            if has_pair and status[x] >= 2:\n                stack.append([(status - Counter([x, x])), False, r - 2])\n    return False\n\ndef solution(tiles):\n    return ''.join(n for n in '123456789' if is_valid(tiles + n))", "from collections import Counter\n\ndef is_valid(hand):\n    if any(hand.count(str(i)) > 4 for i in range(1, 10)):\n        return False\n    stack = [[Counter([int(h) for h in hand]), True, len(hand)]]\n    while stack:\n        status, has_pair, r = stack.pop()\n        if r == 0:\n            return True\n        if r <= 2:\n            if all(v == 2 for v in status.values() if v):\n                return True\n        else:\n            x = min([k for k, v in status.items() if v > 0])\n            if status[x] >= 3:\n                stack.append([(status - Counter([x, x, x])), has_pair, r - 3])\n            if status[x+1] >= 1 and status[x+2] >= 1:\n                stack.append([(status - Counter([x, x + 1, x + 2])), has_pair, r - 3])\n            if has_pair and status[x] >= 2:\n                stack.append([(status - Counter([x, x])), False, r - 2])\n    return False\n\n\ndef solution(tiles):\n    return ''.join(n for n in '123456789' if is_valid(tiles + n))"]
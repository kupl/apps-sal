from functools import reduce
from itertools import combinations_with_replacement
" Naive implementation of combinations built incrementaly doesn't work (for k = 3, there's no 1,2,3): \nn = 5\nfor k in range(1,n):\n    k_uplet_init = [1 for item in range(k)]\n    print(k_uplet_init)\n    for i in range(1,2*n):\n        k_uplet_init[k_uplet_init.index(min(k_uplet_init))] += 1\n        print(k_uplet_init)\n"
"    \ndef productsum(n):\n    result = []\n    collections = [(2,2)]\n    \n    #setting up the various digits needed\n    nums = []\n    for i in range(3,n+3):\n        nums.append([item for item in range(1,i)])\n    \n    print('nums are {0}'.format(nums))\n    #initiate k\n    for k in range(2,n+1):\n        print('k = {0}'.format(k))\n        #loops through digits to use in nums\n        for digits in nums:\n            print('digits = {0}'.format(digits))\n            \n            combi = [uplets for uplets in list(combinations_with_replacement(digits, k))]\n            print('k combination of digits is {0}'.format(combi))\n            for item in combi:\n                print('n_uplet is {0}'.format(item))\n                sums = sum(item)\n                print('sum = {0}'.format(sums))\n                prods = reduce(lambda x,y: x*y,item)\n                print('prod = {0}\n'.format(prods))\n                if sums == prods:\n                    if item not in collections:\n                        if len(item) == len(collections[-1]):\n                            if sum(item) < sum(collections[-1]):\n                                print('appending item {0}'.format(item))\n                                collections[-1] = item\n                                print('collection is now {0}\n'.format(collections))\n                        else:\n                            print('appending item {0}'.format(item))\n                            collections.append(item)\n                            print('collection is now {0}\n'.format(collections))\n                    break\n          \n    #collections = collections[1:]\n    \n    for item in collections:\n        if sum(item) not in collections:\n            result.append(sum(item))\n    \n    result = list(set(result))\n    \n    return sum(result)\n"
"\ndef productsum(n):\n    result = []\n    collections = [(2,2)]\n    \n    #setting up the various digits needed\n    nums = []\n    for i in range(3,n+3):\n        nums.append([item for item in range(1,i)])\n    \n    #initiate k\n    for k in range(2,n+1):\n        #loops through digits to use in nums\n        for digits in nums:\n            combi = [uplets for uplets in list(combinations_with_replacement(digits, k))]\n            for item in combi:\n                sums = sum(item)\n                prods = reduce(lambda x,y: x*y,item)\n                if sums == prods:\n                    if item not in collections:\n                        if len(item) == len(collections[-1]):\n                            if sum(item) < sum(collections[-1]):\n                                collections[-1] = item\n                        else:\n                            collections.append(item)\n                    break\n          \n    for item in collections:\n        if sum(item) not in collections:\n            result.append(sum(item))\n    \n    print('collection is  {0}\n'.format(collections))\n    print('result is  {0}\n'.format(result))\n    result = list(set(result))\n    print('final result (sum) is  {0}\n'.format(sum(result)))\n    return sum(result)\n    "
"\ndef productsum(n):\n    result = []\n    collections = [(2,2)]\n    sums = []\n    \n    #setting up the various digits needed\n    nums = []\n    for i in range(3,n+3):\n        nums.append([item for item in range(1,i)])\n    \n    #initiate k\n    for k in range(2,n+1):\n        #loops through digits to use in nums\n        #print('k = {0}'.format(k))\n        for digits in range(k):\n            #print('digits = {0}'.format(nums[digits]))\n            combi = [uplets for uplets in list(combinations_with_replacement(nums[digits], k)) if sum(uplets) == reduce(lambda x,y: x*y,uplets)]\n            #print('combinations valid are: {0}'.format(combi))\n            if len(combi) > 0:\n                combi_sum = [sum(items) for items in combi]\n                collections.append(combi[combi_sum.index(min(combi_sum))])\n                break\n    for item in collections:\n        if sum(item) not in collections:\n            result.append(sum(item))\n    #print('collection is  {0}\n'.format(collections))\n    #print('result is  {0}\n'.format(result))\n    result = list(set(result))\n    #print('final result (sum) is  {0}\n'.format(sum(result)))\n    return sum(result)\n"
"\ndef productsum(n):\n\n    n_uplets = [()]\n    result = []\n    nums = []\n    for i in range(3,n+3):\n        nums.append([item for item in range(1,i)])\n    print(nums)\n    counter = 1\n    while len(n_uplets) < n+1:\n        for digits in nums:\n            combi = [uplets for uplets in list(combinations_with_replacement(digits, counter))]\n            #print('combi is {0}'.format(combi))\n            for combis in combi:\n                #sums = sum(combis)\n                prods = reduce(lambda x,y: x*y,combis)\n                if sum(combis) == prods:\n                    if len(n_uplets[-1]) == len(combis):\n                        if sum(combis) < sum(n_uplets[-1]):\n                            n_uplets[-1] = combis\n                    else:\n                        n_uplets.append(combis)\n\n            #print('n_uplets = {0}'.format(n_uplets))\n            counter +=1\n    n_uplets = n_uplets[2:]\n    print('final n_uplets are {0}'.format(n_uplets))\n\n    result = [sum(el) for el in n_uplets]\n    result = list(set(result))\n\n    return sum(result)\n"
" Naive implementation of combinations built incrementaly doesn't work (for k = 3, there's no 1,2,3): \nn = 5\nfor k in range(1,n):\n    k_uplet_init = [1 for item in range(k)]\n    print(k_uplet_init)\n    for i in range(1,2*n):\n        k_uplet_init[k_uplet_init.index(min(k_uplet_init))] += 1\n        print(k_uplet_init)\n"
"    \ndef productsum(n):\n    result = []\n    collections = [(2,2)]\n    \n    #setting up the various digits needed\n    nums = []\n    for i in range(3,n+3):\n        nums.append([item for item in range(1,i)])\n    \n    print('nums are {0}'.format(nums))\n    #initiate k\n    for k in range(2,n+1):\n        print('k = {0}'.format(k))\n        #loops through digits to use in nums\n        for digits in nums:\n            print('digits = {0}'.format(digits))\n            \n            combi = [uplets for uplets in list(combinations_with_replacement(digits, k))]\n            print('k combination of digits is {0}'.format(combi))\n            for item in combi:\n                print('n_uplet is {0}'.format(item))\n                sums = sum(item)\n                print('sum = {0}'.format(sums))\n                prods = reduce(lambda x,y: x*y,item)\n                print('prod = {0}\n'.format(prods))\n                if sums == prods:\n                    if item not in collections:\n                        if len(item) == len(collections[-1]):\n                            if sum(item) < sum(collections[-1]):\n                                print('appending item {0}'.format(item))\n                                collections[-1] = item\n                                print('collection is now {0}\n'.format(collections))\n                        else:\n                            print('appending item {0}'.format(item))\n                            collections.append(item)\n                            print('collection is now {0}\n'.format(collections))\n                    break\n          \n    #collections = collections[1:]\n    \n    for item in collections:\n        if sum(item) not in collections:\n            result.append(sum(item))\n    \n    result = list(set(result))\n    \n    return sum(result)\n"
"\ndef productsum(n):\n    result = []\n    collections = [(2,2)]\n    \n    #setting up the various digits needed\n    nums = []\n    for i in range(3,n+3):\n        nums.append([item for item in range(1,i)])\n    \n    #initiate k\n    for k in range(2,n+1):\n        #loops through digits to use in nums\n        for digits in nums:\n            combi = [uplets for uplets in list(combinations_with_replacement(digits, k))]\n            for item in combi:\n                sums = sum(item)\n                prods = reduce(lambda x,y: x*y,item)\n                if sums == prods:\n                    if item not in collections:\n                        if len(item) == len(collections[-1]):\n                            if sum(item) < sum(collections[-1]):\n                                collections[-1] = item\n                        else:\n                            collections.append(item)\n                    break\n          \n    for item in collections:\n        if sum(item) not in collections:\n            result.append(sum(item))\n    \n    print('collection is  {0}\n'.format(collections))\n    print('result is  {0}\n'.format(result))\n    result = list(set(result))\n    print('final result (sum) is  {0}\n'.format(sum(result)))\n    return sum(result)\n    "
"\ndef productsum(n):\n    result = []\n    collections = [(2,2)]\n    sums = []\n    \n    #setting up the various digits needed\n    nums = []\n    for i in range(3,n+3):\n        nums.append([item for item in range(1,i)])\n    \n    #initiate k\n    for k in range(2,n+1):\n        #loops through digits to use in nums\n        #print('k = {0}'.format(k))\n        for digits in range(k):\n            #print('digits = {0}'.format(nums[digits]))\n            combi = [uplets for uplets in list(combinations_with_replacement(nums[digits], k)) if sum(uplets) == reduce(lambda x,y: x*y,uplets)]\n            #print('combinations valid are: {0}'.format(combi))\n            if len(combi) > 0:\n                combi_sum = [sum(items) for items in combi]\n                collections.append(combi[combi_sum.index(min(combi_sum))])\n                break\n    for item in collections:\n        if sum(item) not in collections:\n            result.append(sum(item))\n    #print('collection is  {0}\n'.format(collections))\n    #print('result is  {0}\n'.format(result))\n    result = list(set(result))\n    #print('final result (sum) is  {0}\n'.format(sum(result)))\n    return sum(result)\n"
"\ndef productsum(n):\n\n    n_uplets = [()]\n    result = []\n    nums = []\n    for i in range(3,n+3):\n        nums.append([item for item in range(1,i)])\n    print(nums)\n    counter = 1\n    while len(n_uplets) < n+1:\n        for digits in nums:\n            combi = [uplets for uplets in list(combinations_with_replacement(digits, counter))]\n            #print('combi is {0}'.format(combi))\n            for combis in combi:\n                #sums = sum(combis)\n                prods = reduce(lambda x,y: x*y,combis)\n                if sum(combis) == prods:\n                    if len(n_uplets[-1]) == len(combis):\n                        if sum(combis) < sum(n_uplets[-1]):\n                            n_uplets[-1] = combis\n                    else:\n                        n_uplets.append(combis)\n\n            #print('n_uplets = {0}'.format(n_uplets))\n            counter +=1\n    n_uplets = n_uplets[2:]\n    print('final n_uplets are {0}'.format(n_uplets))\n\n    result = [sum(el) for el in n_uplets]\n    result = list(set(result))\n\n    return sum(result)\n"
"\ndef productsum(n):\n    print('n = {0}'.format(n))\n    n_uplets = []\n    result = []\n    nums = []\n    not_min = []\n    for i in range(3,n+3):\n        nums.append([item for item in range(1,i)])\n    nums = nums[-2:]\n    #print('nums = {0}'.format(nums))\n    counter = 2\n    for digits in nums:\n        if len(n_uplets) <= n:          \n            #print('\ndigits = {0}'.format(digits))\n            combi = [uplets for uplets in list(combinations_with_replacement(digits, counter))]\n            #print('combi is {0}\n'.format(combi))\n            for combis in combi:\n                prods = reduce(lambda x,y: x*y,combis)\n                x = prods - sum(combis)\n                solution = tuple(1 for item in range(1,x+1))\n\n                z = combis + solution\n                z = sorted(z)\n                z = tuple(z)\n                if sum(z) == prods and len(z) <= n:\n                    #print('z is {0}'.format(z))\n                    if tuple(z) not in n_uplets :\n                        y = [len(member) for member in n_uplets]\n                        if len(z) in y and sum(z) < sum(n_uplets[y.index(len(z))]):\n                            not_min.append(n_uplets[y.index(len(z))])\n                            if z not in not_min:\n                                n_uplets[y.index(len(z))] = z\n                                #print('replacing uplets with z = {0}'.format(z))\n                            #print('z IGNORED {0}'.format(z))\n                        else:\n                            if z not in not_min and len(z) not in y:\n                                n_uplets.append(z)\n                                #print('adding uplets z = {0}'.format(z))\n                            \n                        #print('n_uplets is now {0}'.format(n_uplets))\n            counter +=1\n            \n    print('final n_uplets are {0}'.format(n_uplets))\n    print('not_minimums are {0}'.format(not_min))\n    result = [sum(el) for el in n_uplets]\n    result = list(set(result))\n    print('result before sum is {0}'.format(result))\n    return sum(result)\n\n"


def productsum(n):
    if n < 12:
        kmax = n + 1
    else:
        kmax = n

    def prodsum(p, s, nf, start):
        k = p - s + nf
        if k < kmax:
            if p < n[k]:
                n[k] = p
            for i in range(start, kmax // p * 2 + 1):
                prodsum(p * i, s + i, nf + 1, i)
    if kmax > 12:
        kmax += 1
    n = [2 * kmax] * kmax
    prodsum(1, 1, 1, 2)
    return sum(set(n[2:]))

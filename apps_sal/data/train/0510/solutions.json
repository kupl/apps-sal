["n = int(input())\ns = list(input())\ns = [ord(i)-97 for i in s]\n\ndic = {}\nfor i in range(26):\n    dic[i] = []\n\nfor i in range(n):\n    dic[s[i]].append(i)\n\nfor i in range(26):\n    dic[i].append(float('inf'))\n\nfrom bisect import bisect_left\nq = int(input())\nfor i in range(q):\n    x, y, z = input().split()\n    if x == '1':\n        y, z = int(y) - 1, ord(z) - 97\n        p = bisect_left(dic[s[y]], y)\n        dic[s[y]].pop(p)\n        dic[z].insert(bisect_left(dic[z], y), y)\n        s[y] = z\n    else:\n        res = 0\n        y, z = int(y) - 1, int(z) - 1\n        for i in range(26):\n            p = dic[i][bisect_left(dic[i], y)]\n            if p <= z:\n                res += 1\n        print(res)", "import sys\n# input = sys.stdin.buffer.readline\ndef input(): return sys.stdin.readline().rstrip()\nsys.setrecursionlimit(10 ** 7)\n\nimport bisect\nfrom string import ascii_lowercase\nd = dict()\nfor i, c in enumerate(ascii_lowercase):\n    d[c] = i\n\nN = int(input())\nS = list(input())\nlst = [[] for _ in range(26)]\nfor i in range(N):\n    lst[d[S[i]]].append(i)\n\nQ = int(input())\nfor q in range(Q):\n    a, b, c = input().split()\n    if a=='1':\n        i = int(b)-1\n        if c == S[i]:   # \u5909\u66f4\u306a\u3057\n            continue\n        idx = bisect.bisect_left(lst[d[S[i]]],i)\n        del lst[d[S[i]]][idx]\n        bisect.insort_left(lst[d[c]],i)\n        S[i] = c\n    else:\n        l = int(b)-1\n        r = int(c)\n        ans = 0\n        for i in range(26):\n            cnt = bisect.bisect_left(lst[i],r) - bisect.bisect_left(lst[i],l)\n            if cnt:\n                ans += 1\n        print(ans)\n", "import sys\ninput = sys.stdin.readline\n\ndef segfunc(x,y):\n    return x | y\n\ndef init(init_val):\n    #set_val\n    for i in range(n):\n        seg[i+num-1]=init_val[i]\n    #built\n    for i in range(num-2,-1,-1) :\n        seg[i]=segfunc(seg[2*i+1],seg[2*i+2])\n\ndef update(k,x):\n    k += num-1\n    seg[k] = x\n    while k:\n        k = (k-1)//2\n        seg[k] = segfunc(seg[k*2+1],seg[k*2+2])\n\ndef query(p,q):\n    if q<=p:\n        return ide_ele\n    p += num-1\n    q += num-2\n    res=ide_ele\n    while q-p>1:\n        if p&1 == 0:\n            res = segfunc(res,seg[p])\n        if q&1 == 1:\n            res = segfunc(res,seg[q])\n            q -= 1\n        p = p//2\n        q = (q-1)//2\n    if p == q:\n        res = segfunc(res,seg[p])\n    else:\n        res = segfunc(segfunc(res,seg[p]),seg[q])\n    return res\n\n\nn = int(input())\ns = input()\nq = int(input())\n\nli = []\nfor i in range(n):\n    li.append(1 << ord(s[i]) - ord('a'))\n\n#####\u5358\u4f4d\u5143######\nide_ele = 0\n\n#num:n\u4ee5\u4e0a\u306e\u6700\u5c0f\u306e2\u306e\u3079\u304d\u4e57\nnum =2**(n-1).bit_length()\nseg=[ide_ele]*2*num\ninit(li)\n\nfor _ in range(q):\n    q1 = list(input().split())\n    if q1[0] == '1':\n        update(int(q1[1]) - 1, 1 << ord(q1[2]) - ord('a'))\n    else:\n        l,r = int(q1[1]), int(q1[2])\n        print((bin(query(l-1,r)).count('1')))\n", "import sys\nfrom bisect import bisect_left, bisect_right, insort\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\nS = list('-' + sr())\nd = [[] for _ in range(26)]\nfor i in range(1, N+1):\n    s = S[i]\n    o = ord(s) - ord('a')\n    d[o].append(i)\n\nQ = ir()\nfor _ in range(Q):\n    q, a, b = sr().split()\n    if q == '1':\n        a = int(a)\n        if S[a] == b:\n            continue\n        prev = ord(S[a]) - ord('a')\n        d[prev].pop(bisect_left(d[prev], a))\n        next = ord(b) - ord('a')\n        insort(d[next], a)\n        S[a] = b\n    else:\n        left = int(a); right = int(b)\n        ans = 0\n        for alpha in range(26):\n            index = bisect_left(d[alpha], left)\n            if index < len(d[alpha]) and d[alpha][index] <= right:\n                ans += 1\n        print(ans)\n", "from bisect import bisect_left, bisect, insort\ndef main():\n    n = int(input())\n    s = list(input())\n    q = int(input())\n    _is = {chr(i):[] for i in range(ord(\"a\"), ord(\"a\")+27)}\n    for i, si in enumerate(s):\n        _is[si].append(i)\n    for _ in range(q):\n        t, i, c = input().split()\n        i = int(i)-1\n        if t == \"1\":\n            if s[i] != c:\n                index = bisect_left(_is[s[i]], i)\n                del _is[s[i]][index]\n                insort(_is[c], i)\n                s[i] = c\n        else:\n            c = int(c) - 1\n            cnt = 0\n            for _isi in list(_is.values()):\n                if _isi:\n                    is_in = bisect(_isi, c)-bisect_left(_isi, i)\n                    if is_in:\n                        cnt += 1\n            print(cnt)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    import sys\n    input = sys.stdin.readline\n    from bisect import bisect_left, insort_left\n    N = int(input())\n    S = list(input())\n    Q = int(input())\n    dic = {chr(i): [] for i in range(ord('a'), ord('z')+1)}\n    for i in range(N):\n        dic[S[i]].append(i)\n    for _ in range(Q):\n        query, a, c = input().split()\n        if query == \"1\":\n            i = int(a)-1\n            if S[i] == c:\n                continue\n            ind = bisect_left(dic[S[i]], i)\n            dic[S[i]].pop(ind)\n            insort_left(dic[c], i)\n            S[i] = c\n        else:\n            l, r = int(a)-1, int(c)-1\n            ans = 0\n            for inds in dic.values():\n                if inds and l <= inds[-1] and inds[bisect_left(inds, l)] <= r:\n                    ans += 1\n            print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import bisect\n\nn = int(input())\ns = list(input())\nq = int(input())\n\npos = [[] for i in range(26)]\nalp = \"abcdefghijklmnopqrstuvwxyz\"\natoi = {}\nfor i in range(26):\n    atoi[alp[i]] = i\nfor i in range(n):\n    pos[atoi[s[i]]].append(i)\n\nfor i in range(q):\n    a, b, c = input().split()\n    if a == \"1\":\n        b = int(b)-1\n        if c == s[b]:\n            continue\n        index = bisect.bisect_left(pos[atoi[s[b]]], b)\n        del pos[atoi[s[b]]][index]\n        bisect.insort_left(pos[atoi[c]], b)\n        s[b] = c\n    else:\n        l, r = int(b)-1, int(c)\n        ans = 0\n        for i in range(26):\n            cnt = bisect.bisect_left(pos[i], r) - bisect.bisect_left(pos[i], l)\n            if cnt > 0:\n                ans += 1\n        print(ans)", "import sys\nfrom bisect import bisect_left, bisect_right, insort\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\nS = list('-' + sr())\nd = [[] for _ in range(26)]\nfor i in range(1, N+1):\n    s = S[i]\n    o = ord(s) - ord('a')\n    insort(d[o], i)\n\nQ = ir()\nfor _ in range(Q):\n    q, a, b = sr().split()\n    if q == '1':\n        a = int(a)\n        if S[a] == b:\n            continue\n        prev = ord(S[a]) - ord('a')\n        d[prev].pop(bisect_left(d[prev], a))\n        next = ord(b) - ord('a')\n        insort(d[next], a)\n        S[a] = b\n    else:\n        a = int(a); b = int(b)\n        ans = 0\n        for alpha in range(26):\n            if bisect_right(d[alpha], b) - bisect_left(d[alpha], a) >= 1:\n                ans += 1\n        print(ans)\n", "# -*- coding: utf-8 -*-\n\n'''\n7\nabcdbbd\n6\n2 3 6\n1 5 z\n2 1 1\n1 4 a\n1 7 d\n2 1 7\n'''\n\n# from helper import elapsed_time\nfrom bisect import bisect_left, insort_left\n\n\nN = int(input())\ns = list(input())\nQ = int(input())\n\n# a-z\u307e\u3067\u306e26\u6587\u5b57\u306b\u5bfe\u3057\u3066\u3001s\u6587\u5b57\u5217\u306e\u5404\u6587\u5b57\u306b\u8a72\u5f53\u3059\u308bindex\u3092\u683c\u7d0d\u3057\u3066\u304a\u304f\nd = {i: [] for i in range(26)}\nfor i, c in enumerate(s):\n    d[ord(c) - ord(\"a\")].append(i)\n\n\n# @elapsed_time\ndef convert(d: dict, s: list, q1: int, q2: str):\n    if s[q1] == q2:\n        return d, s\n\n    didx_before = ord(s[q1]) - ord(\"a\")\n    didx_after = ord(q2) - ord(\"a\")\n\n    idx = bisect_left(d[didx_before], q1)\n    d[didx_before].pop(idx)\n    s[q1] = q2\n    insort_left(d[didx_after], q1)\n\n    return d, s\n\n\n# @elapsed_time\ndef calc(d: dict, q1: int, q2: int):\n    ans = 0\n    for i in range(26):\n        idx = bisect_left(d[i], q1)\n        if d[i] and q1 <= d[i][-1] and d[i][idx] < q2 + 1:\n            ans += 1\n\n    return ans\n\n\nfor _ in range(Q):\n    q, q1, q2 = input().split()\n    q = int(q)\n    if q == 1:\n        d, s = convert(d, s, int(q1) - 1, q2)\n    if q == 2:\n        print((calc(d, int(q1) - 1, int(q2) - 1)))\n", "import sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\n\nclass SegTree:\n\n    def __init__(self, init_val, segfunc, ide_ele):\n\n        n = len(init_val)\n        self.ide_ele = ide_ele\n        self.segfunc = segfunc\n        self.num = 2**(n - 1).bit_length()\n        self.seg = [self.ide_ele] * 2 * self.num\n\n        for i in range(n):\n            self.seg[i + self.num - 1] = init_val[i]\n\n        for i in range(self.num - 2, -1, -1):\n            self.seg[i] = self.segfunc(self.seg[2 * i + 1], self.seg[2 * i + 2])\n\n    def update(self, k, x):\n        k += self.num - 1\n        self.seg[k] = x\n        while k:\n            k = (k - 1) // 2\n            self.seg[k] = self.segfunc(self.seg[k * 2 + 1], self.seg[k * 2 + 2])\n\n    def query(self, p, q):\n        if q <= p:\n            return self.ide_ele\n        p += self.num - 1\n        q += self.num - 2\n        res = self.ide_ele\n        while q - p > 1:\n            if p & 1 == 0:\n                res = self.segfunc(res, self.seg[p])\n            if q & 1 == 1:\n                res = self.segfunc(res, self.seg[q])\n                q -= 1\n            p = p // 2\n            q = (q - 1) // 2\n        if p == q:\n            res = self.segfunc(res, self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res, self.seg[p]), self.seg[q])\n        return res\n\n\ndef solve():\n\n    N = int(input())\n    S = list(input())\n    Q = int(input())\n    seg = [1 << (ord(s) - ord('a')) for s in S]\n\n    segtree = []\n    segfunc = lambda a, b: a | b\n\n    segtree = SegTree(seg, segfunc, 0)\n\n    ans = []\n    for i in range(Q):\n        a, b, c = input().split()\n        a = int(a)\n\n        if a == 1:\n            b = int(b) - 1\n            al = ord(c) - ord('a')\n            segtree.update(b, 1 << al)\n        elif a == 2:\n            b, c = int(b) - 1, int(c)\n            res = segtree.query(b, c)\n            res = sum(list(map(int, bin(res)[2:])))\n            ans.append(res)\n\n    print(('\\n'.join(map(str, ans))))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "f=input; from bisect import bisect_left as g, insort as h\nd={chr(97+i):[] for i in range(26)}\nf(); s,i=list(f()),0\nfor c in s: d[c]+=[i]; i+=1\nfor _ in range(int(f())):\n  a,b,c=f().split(); b=int(b)-1\n  if a>'1': print(sum(1 for l in d.values() if g(l,b)<len(l) and l[g(l,b)]<int(c)))\n  elif s[b]!=c: l=d[s[b]]; l.pop(g(l,b)); s[b]=c; h(d[c],b)", "from bisect import bisect_left, bisect_right, insort_left\nimport sys\nreadlines = sys.stdin.readline\ndef main():\n\n\tn = int(input())\n\ts = list(input())\n\tq = int(input())\n\n\td = {}\n\tflag = {}\n\tfor i in list('abcdefghijklmnopqrstuvwxyz'):\n\t\td.setdefault(i, []).append(-1)\n\t\tflag.setdefault(i, []).append(-1)\n\tfor i in range(n):\n\t\td.setdefault(s[i], []).append(i)\n\tfor i in range(q):\n\t\tq1,q2,q3 = map(str,input().split())\n\t\tif q1 == '1':\n\t\t\tq2 = int(q2) - 1\n\t\t\tif s[q2] != q3:\n\t\t\t\tinsort_left(flag[s[q2]],q2)\n\t\t\t\tinsort_left(d[q3],q2)\n\t\t\t\ts[q2] = q3\n\t\telse:\n\t\t\tans = 0\n\t\t\tq2 = int(q2) - 1\n\t\t\tq3 = int(q3) - 1\n\t\t\tif q2 == q3:\n\t\t\t\tprint(1)\n\t\t\t\tcontinue\n\t\t\tfor string,l in d.items():\n\t\t\t\tres = 0\n\t\t\t\tif d[string] != [-1]:\n\t\t\t\t\tleft = bisect_left(l,q2)\n\t\t\t\t\tright = bisect_right(l,q3)\n\t\t\t\telse:\n\t\t\t\t\tleft = 0\n\t\t\t\t\tright = 0\n\t\t\t\tif string in flag:\n\t\t\t\t\tleft2 = bisect_left(flag[string],q2)\n\t\t\t\t\tright2 = bisect_right(flag[string],q3)\n\t\t\t\telse:\n\t\t\t\t\tleft2 = 0\n\t\t\t\t\tright2 = 0\n\t\t\t\tif left != right:\n\t\t\t\t\tif right - left > right2 - left2:\n\t\t\t\t\t\tres = 1\n\t\t\t\tans += res\n\t\t\t\t#print(string,l,res)\n\t\t\tprint(ans)\ndef __starting_point():\n\tmain()\n__starting_point()", "# https://atcoder.jp/contests/abc157/tasks/abc157_e\n# \u30bb\u30b0\u30e1\u30f3\u30c8\u6728\n# \u5404\u6587\u5b57\u3092\u30d3\u30c3\u30c8\u306b\u5bfe\u5fdc\u3055\u305b\u308b(\u30bb\u30b0\u6728\u309226\u672c\u6301\u3063\u3066\u3082\u826f\u3044)\nimport sys\nread = sys.stdin.readline\n\n\ndef read_a_int():\n    return int(read())\n\n\nclass SegmentTree:\n    def __init__(self, ls: list, segfunc, identity_element):\n        '''\n        \u30bb\u30b0\u6728 (\u4e0b\u66f8\u304d)\n        \u4e00\u6b21\u5143\u306e\u30ea\u30b9\u30c8ls\u3092\u53d7\u3051\u53d6\u308a\u521d\u671f\u5316\u3059\u308b\u3002O(len(ls))\n        \u533a\u9593\u306e\u30eb\u30fc\u30eb\u306fsegfunc\u306b\u3088\u3063\u3066\u5b9a\u7fa9\u3055\u308c\u308b\n        identity element\u306f\u5358\u4f4d\u5143\u3002e.g., \u6700\u5c0f\u5024\u3092\u6c42\u3081\u305f\u3044\u2192inf, \u548c\u21920, \u7a4d\u21921, gcd\u21920\n        [\u5358\u4f4d\u5143](https://ja.wikipedia.org/wiki/%E5%8D%98%E4%BD%8D%E5%85%83)\n        '''\n        self.ide = identity_element\n        self.func = segfunc\n        n = len(ls)\n        self.num = 2 ** (n - 1).bit_length()  # n\u4ee5\u4e0a\u306e\u6700\u5c0f\u306e2\u306e\u3079\u304d\u4e57\n        self.tree = [self.ide] * (2 * self.num - 1)  # \u22121\u306f\u3074\u3063\u305f\u308a\u306b\u4f5c\u308b\u305f\u3081\u3060\u3051\u3069\u6c17\u306b\u3057\u306a\u3044\u3067\u3044\u3044\n        for i, l in enumerate(ls):  # \u6728\u306e\u8449\u306b\u4ee3\u5165\n            self.tree[i + self.num - 1] = l\n        for i in range(self.num - 2, -1, -1):  # \u5b50\u3092\u675f\u306d\u3066\u89aa\u3092\u66f4\u65b0\n            self.tree[i] = segfunc(self.tree[2 * i + 1], self.tree[2 * i + 2])\n\n    def update(self, i, x):\n        '''\n        i\u756a\u76ee\u306e\u8981\u7d20\u3092x\u306b\u5909\u66f4\u3059\u308b(\u6728\u306e\u4e2d\u9593\u30ce\u30fc\u30c9\u3082\u66f4\u65b0\u3059\u308b) O(logN)\n        '''\n        i += self.num - 1\n        self.tree[i] = x\n        while i:  # \u6728\u3092\u66f4\u65b0\n            i = (i - 1) // 2\n            self.tree[i] = self.func(self.tree[i * 2 + 1],\n                                     self.tree[i * 2 + 2])\n\n    def query(self, l, r):\n        '''\n        \u533a\u9593[l,r)\u306b\u5bfe\u3059\u308b\u30af\u30a8\u30ea\u3092O(logN)\u3067\u51e6\u7406\u3059\u308b\u3002\u4f8b\u3048\u3070\u305d\u306e\u533a\u9593\u306e\u6700\u5c0f\u5024\u3001\u6700\u5927\u5024\u3001gcd\u306a\u3069\n        '''\n        if r <= l:\n            return ValueError('invalid index (l,r\u304c\u3042\u308a\u3048\u306a\u3044\u3088)')\n        l += self.num\n        r += self.num\n        res = self.ide\n        while l<r:  # \u53f3\u304b\u3089\u5bc4\u308a\u306a\u304c\u3089\u7d50\u679c\u3092\u7d50\u5408\u3057\u3066\u3044\u304f\u30a4\u30e1\u30fc\u30b8\n            if l & 1:\n                res = self.func(res, self.tree[l-1])\n                l+=1\n            if r & 1:\n                r -= 1\n                res = self.func(res, self.tree[r-1])\n            l >>=1\n            r >>=1\n        return res\n\n\ndef segfunc(x, y):\n    # \u51e6\u7406\u3057\u305f\u3044\u5185\u5bb9\n    return x | y\n\n\ndef moji_to_bit(a):\n    return 1 << (ord(a) - ord('a'))\n\n\ndef bit_to_sum(n):\n    return sum([(n >> i) & 1 for i in range(n.bit_length())])\n\n\nN = read_a_int()\nS = read()[:-1]\nS_bit = [moji_to_bit(s) for s in S]\n\n# build segment tree\nst = SegmentTree(S_bit, segfunc, 0)\n\nQ = read_a_int()\nfor q in range(Q):\n    com, a, b = read().split()\n    if int(com) == 1:\n        i, c = int(a) - 1, b\n        st.update(i, moji_to_bit(c))\n    else:\n        l, r = int(a) - 1, int(b)\n        print((bit_to_sum(st.query(l, r))))\n", "class SegmentTree():\n    '''\n    \u975e\u518d\u5e30\n    segment tree\n    '''\n\n    def __init__(self, n, func, init=float('inf')):\n        '''\n        n->\u914d\u5217\u306e\u9577\u3055\n        func:func(a,b)->val,\u3000func=min\u3060\u3068RMQ\u306b\u306a\u308b\n        \u6728\u306e\u9ad8\u3055h\u3068\u3059\u308b\u3068,\n        n:h-1\u307e\u3067\u306e\u30ce\u30fc\u30c9\u6570\u3002h\u6bb5\u76ee\u306e\u30ce\u30fc\u30c9\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u305f\u3081\u306b\u4f7f\u3046\u3002\n        data:\u30ce\u30fc\u30c9\u3002\n        parent:k->child k*2+1\u3068k*2+2\n        '''\n        self.n = 2**(n-1).bit_length()\n        self.init = init\n        self.data = [init]*(2*self.n)\n        self.func = func\n\n    def set(self, k, v):\n        '''\n        \u3042\u305f\u3044\u306e\u521d\u671f\u5316\n        '''\n        self.data[k+self.n-1] = v\n\n    def build(self):\n        '''\n        set\u306e\u5f8c\u306b\u4e00\u6589\u66f4\u65b0\n        '''\n        for k in reversed(list(range(self.n-1))):\n            self.data[k] = self.func(self.data[k*2+1], self.data[k*2+2])\n\n    def update(self, k, a):\n        '''\n        list[k]=a\u306b\u66f4\u65b0\u3059\u308b\u3002\n        \u66f4\u65b0\u3076\u3093\u3092root\u307e\u3067\u66f4\u65b0\n        '''\n        k += self.n-1\n        self.data[k] = a\n\n        while k > 0:\n            k = (k-1)//2\n            self.data[k] = self.func(self.data[k*2+1], self.data[k*2+2])\n\n    def query(self, l, r):\n        '''\n        [l,r)\u306efunc\u3092\u6c42\u3081\u308b\n        '''\n        L = l+self.n\n        R = r+self.n\n        ret = self.init\n        while L < R:\n            if R & 1:\n                R -= 1\n                ret = self.func(ret, self.data[R-1])\n            if L & 1:\n                ret = self.func(ret, self.data[L-1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return ret\n\n\nN = int(input())\nS = input()\nQ = int(input())\nqueries = [list(input().split()) for _ in range(Q)]\n\n\ndef a2n(a):\n    return ord(a)-ord(\"a\")\n\n\ndef createInp(a):\n    return 1 << a2n(a)\n\n\nSeg = SegmentTree(len(S), lambda x, y: x | y, init=0)\nfor i, s in enumerate(S):\n    Seg.set(i, createInp(s))\nSeg.build()\n\nfor q, l, r in queries:\n    if q == \"1\":\n        Seg.update(int(l)-1, createInp(r))\n    else:\n        print((bin(Seg.query(int(l)-1, int(r))).count('1')))\n", "from math import log2, ceil\n\n\nclass SegTree:\n    #####\u5358\u4f4d\u5143######\n    ide_ele = 0\n\n    def __init__(self, init_val):\n        n = len(init_val)\n        self.num = 2**ceil(log2(n))\n        self.seg = [self.ide_ele] * (2 * self.num - 1)\n\n        for i in range(n):\n            self.seg[i + self.num - 1] = init_val[i]\n\n        # built\n        for i in range(self.num - 2, -1, -1):\n            self.seg[i] = self.segfunc(self.seg[2 * i + 1], self.seg[2 * i + 2])\n\n    #####segfunc######\n    def segfunc(self, x, y):\n        return x|y\n\n    def update(self, k, x):\n        k += self.num - 1\n        self.seg[k] = x\n        while k:\n            k = (k - 1) // 2\n            self.seg[k] = self.segfunc(self.seg[k * 2 + 1], self.seg[k * 2 + 2])\n\n    def query(self, a, b, k, l, r):\n        if r <= a or b <= l:\n            return self.ide_ele\n        if a <= l and r <= b:\n            return self.seg[k]\n        else:\n            vl = self.query(a, b, k*2+1, l, (l+r)//2)\n            vr = self.query(a, b, k*2+2, (l+r)//2, r)\n            return self.segfunc(vl, vr)\n\n\nN = int(input())\nS = input()\nQ = int(input())\n\nli = [1 << (ord(s) - ord('a')) for s in S]\nseg_tree = SegTree(li)\nans = []\nfor _ in range(Q):\n    i, l, r = input().split()\n    i = int(i)\n    l = int(l)\n    if i == 1:\n        seg_tree.update(l-1, 1 << (ord(r) - ord('a')))\n    else:\n        r = int(r)\n        num = seg_tree.query(l-1, r, 0, 0, seg_tree.num)\n        ans.append(bin(num).count('1'))\n\nfor a in ans:\n    print(a)\n", "#!/usr/bin/env python3\nimport bisect\n\n# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    N = int(input())\n    S = list(input())\n    Q = int(input())\n\n    L = [[] for x in range(26)] # i\u756a\u76ee\u306e\u30ea\u30b9\u30c8\u306f\u3001\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u304c\u73fe\u308c\u308b\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u30ea\u30b9\u30c8\u3092\u6301\u3064\u3002\n\n    for idx, s in enumerate(S):\n        L[ord(s)-ord(\"a\")].append(idx)\n\n    for _ in range(Q):\n        row = input().split()\n        if row[0] == '1':\n            y, z = int(row[1])-1, row[2]\n            if S[y] != z:\n                idx_target = ord(S[y]) - ord(\"a\")\n                idx_del = bisect.bisect_left(L[idx_target], y)\n                if idx_del < len(L[idx_target]):\n                    L[idx_target].pop(idx_del)\n                bisect.insort(L[ord(z) - ord(\"a\")], y)\n                S[y] = z\n\n        elif row[0] == '2':\n            y, z = int(row[1]) - 1, int(row[2]) - 1\n            answer = 0\n            for idx_alphabet in range(26):\n                left = bisect.bisect_left(L[idx_alphabet], y)\n                if left < len(L[idx_alphabet]) and y <= L[idx_alphabet][left] <= z:\n                    answer += 1\n            print(answer)\n\n    # Failed to predict input format\n    pass\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_left\n\nn = int(input())\ns = list(input())\nq = int(input())\nquery = [input() for _ in range(q)]\n\np = [[] for _ in range(26)]\n\nfor i, x in enumerate(s):\n    p[ord(x) - ord('a')].append(i)\n\nfor x in query:\n    a, b, c = x.split()\n    #print(c)\n    if a == '1':\n        b = int(b) - 1\n        if s[b] == c:\n            continue\n        d = ord(s[b]) - ord('a')\n        e = ord(c) - ord('a')\n        temp = bisect_left(p[d], b)\n        p[d].pop(temp)\n        temp = bisect_left(p[e], b)\n        p[e].insert(temp, b)\n        s[b] = c\n    else:\n        b = int(b) - 1\n        c = int(c) - 1\n        #print(b, c)\n        ans = 0\n        for i in range(26):\n            L = bisect_left(p[i], b)\n            if L >= len(p[i]):\n                continue\n            if p[i][L] <= c:\n                ans += 1\n        print(ans)\n", "class SegmentTree:\n    def __init__(self,n,ele=0):\n        self.ide_ele = ele\n        self.num =2**(n-1).bit_length()\n        self.seg=[self.ide_ele]*2*self.num\n\n    def segfunc(self,x,y):\n        return x|y\n\n    def init(self,init_val):\n        for i in range(len(init_val)):\n            self.seg[i+self.num-1]=init_val[i]\n        for i in range(self.num-2,-1,-1) :\n            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n\n    def update(self,k,x):\n        k += self.num-1\n        if self.seg[k]==x:\n          return 0\n        self.seg[k] = x\n        while k:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n\n    def query(self,p,q):\n        if q<=p:\n            return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res,self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res,self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n        return res\n      \nN,S,Q=int(input()),input(),int(input())\nd={'a': 1, 'b': 2, 'c': 4, 'd': 8, 'e': 16, 'f': 32, 'g': 64, 'h': 128, 'i': 256, 'j': 512, 'k': 1024, 'l': 2048, 'm': 4096, 'n': 8192, 'o': 16384, 'p': 32768, 'q': 65536, 'r': 131072, 's': 262144, 't': 524288, 'u': 1048576, 'v': 2097152, 'w': 4194304, 'x': 8388608, 'y': 16777216, 'z': 33554432}\n\ninitial=[d[c] for c in list(S)]\n\nST=SegmentTree(N)\nST.init(initial)\n\nfor _ in range(Q):\n    typ,a,b=input().split()\n    if typ=='1':\n        i,c=int(a),d[b]\n        ST.update(i-1,c)\n    else:\n        l,r=int(a)-1,int(b)\n        x=bin(ST.query(l,r))[2:]\n        print(sum(map(int,list(x))))", "# AtCoder Beginner Contest 157\n# E - Simple String Queries\n# https://atcoder.jp/contests/abc157/tasks/abc157_e\nfrom bisect import bisect_left, insort_left\nimport sys\ninput = sys.stdin.readline\nOFS = ord('a')\n_ = input()\nS = list(input()[:-1])\n\nD = [[] for _ in [0]*26]\nfor i, s in enumerate(S):\n    D[ord(s)-OFS].append(i)\n\nfor _ in [0]*int(input()):\n    Q = input()[:-1].split()\n    if Q[0] == '1':\n        i, c = int(Q[1])-1, Q[2]\n\n        if S[i] != c:\n            s = ord(S[i])-OFS\n            D[s].pop(bisect_left(D[s], i))\n            insort_left(D[ord(c)-OFS], i)\n            S[i] = c\n\n    else:\n        l, r = int(Q[1])-1, int(Q[2])-1\n\n        cnt = 0\n        for L in D:\n            i = bisect_left(L, l)\n            if i < len(L) and L[i] <= r:\n                cnt += 1\n\n        print(cnt)\n", "#!python3\n\nimport sys\n\niim = lambda: map(int, sys.stdin.readline().rstrip().split())\n\ndef resolve():\n    N = int(input())\n    S = list(input())\n    Q = int(input())\n\n    c0 = ord('a')\n    smap = [1<<(i-c0) for i in range(c0, ord('z')+1)]\n\n    T = [0]*N + [smap[ord(S[i])-c0] for i in range(N)]\n\n    for i in range(N-1, 0, -1):\n        i2 = i << 1\n        T[i] = T[i2] | T[i2|1]\n\n    ans = []\n    #print(T)\n    for cmd, i, j in zip(*[iter(sys.stdin.read().split())]*3):\n        i = int(i) - 1\n        if cmd == \"1\":\n            if S[i] == j:\n                continue\n\n            S[i] = j\n            i0 = N + i\n            T[i0] = smap[ord(j)-c0]\n            while i0 > 1:\n                i0 = i0 >> 1\n                T[i0] = T[i0+i0] | T[i0-~i0]\n        elif cmd == \"2\":\n            i += N\n            j = int(j) + N\n\n            d1 = 0\n            while i < j:\n                if i & 1:\n                    d1 |= T[i]\n                    i += 1\n                if j & 1:\n                    j -= 1\n                    d1 |= T[j]\n\n                i >>= 1; j >>=1\n\n            ans.append(bin(d1).count('1'))\n\n    print(*ans, sep=\"\\n\")\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import bisect\nfrom collections import defaultdict\n\nN = int(input())\nS = list(input())\nQ = int(input())\n\nalpha_dic = defaultdict(list)\n\nfor i, s in enumerate(S):\n    alpha_dic[s].append(i)\n\nfor _ in range(Q):\n    l, m, n = input().split()\n\n    if l == '1':\n        m = int(m) - 1\n        c = S[m]\n\n        if c == n:\n            continue\n        else:\n            i = bisect.bisect_left(alpha_dic[c], m)\n            del alpha_dic[c][i]\n\n            bisect.insort_left(alpha_dic[n], m)\n            S[m] = n\n    else:\n        m, n = int(m) - 1, int(n) - 1\n\n        cnt = 0\n        for _, val in list(alpha_dic.items()):\n            if not val:\n                continue\n\n            left_idx = bisect.bisect_left(val, m)\n            right_idx = bisect.bisect_left(val, n)\n            l = len(val)\n\n            if left_idx > right_idx or (left_idx == right_idx and left_idx == l) or (left_idx == right_idx and val[left_idx] != m and val[right_idx] != n):\n                continue\n\n            cnt += 1\n\n        print(cnt)\n", "import sys\ninput = sys.stdin.readline\n\nclass SegTree:\n    def __init__(self, size, f=lambda x,y: x|y, e=0):\n        self.size = 2**(size-1).bit_length()\n        self.e = e\n        self.tree = [e] * (self.size*2)\n        self.f = f\n    \n    def init_tree(self, l):\n        for i in range(len(l)):\n            self.tree[i+self.size] = l[i]\n        for i in range(self.size - 1, -1, -1):\n            self.tree[i] = self.f(self.tree[i*2], self.tree[i*2+1])\n    \n    def update(self, i, v):\n        i += self.size\n        self.tree[i] = v\n        while i > 0:\n            i >>= 1\n            self.tree[i] = self.f(self.tree[i*2], self.tree[i*2+1])\n    \n    def query(self, l, r):\n        l += self.size\n        r += self.size\n        lval = self.e\n        rval = self.e\n        while l < r:\n            if l & 1:\n                lval = self.f(lval, self.tree[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                rval = self.f(rval, self.tree[r])\n            l >>= 1\n            r >>= 1\n        return self.f(lval, rval)\n\ndef a2i(c):\n    return 1<<(ord(c) - ord(\"a\"))\n\ndef main():\n    N = int(input())\n    S = [a2i(s) for s in input().strip()]\n    Q = int(input())\n\n    tree = SegTree(N+5)\n    tree.init_tree(S)\n\n    for _ in range(Q):\n        t, x, y = input().split()\n        if t == \"1\":\n            x = int(x) - 1\n            y = 1<<(ord(y) - ord(\"a\"))\n            tree.update(x, y)\n        else:\n            x = int(x) - 1\n            y = int(y)\n            tmp = tree.query(x, y)\n            ans = 0\n            while tmp > 0:\n                ans += tmp & 1\n                tmp >>= 1\n            print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nfrom bisect import bisect_left, bisect_right\n\n\nn = int(input())\ns = list(input())\nq = int(input())\n\nal = 'abcdefghijklmnopqrstuvwxyz'\ndicq = {i:[] for i in al}\nfor i, si in enumerate(s):\n    dicq[si].append(i)\n\ndef q1(iq, cq):\n    #print(iq,cq,s[iq],dicq[s[iq]],bisect_left(dicq[s[iq]], iq))\n    dicq[s[iq]].pop(bisect_left(dicq[s[iq]], iq))   #\u66f4\u65b0\u524d\u304b\u3089\u524a\u9664\n    s[iq] = cq\n    dicq[cq].insert(bisect_left(dicq[cq], iq), iq)   #\u66f4\u65b0\u5f8c\u306b\u8ffd\u52a0\n\ndef q2(l, r):\n    ret = 0\n    for ai in al:\n        if len(dicq[ai])==0: continue\n        li = bisect_left(dicq[ai], l)\n        ri = bisect_right(dicq[ai], r)\n        if li != ri:\n            ret += 1\n        elif li == len(dicq[ai]): continue\n        elif dicq[ai][li] == l:\n            ret += 1\n    #    print(l,r,ai,dicq[ai],li,ri,ret)\n    print(ret)\n\nfor i in range(q):\n    fg, x, y = input().split()\n    if fg == '1':\n        q1(int(x)-1, y)\n    else:\n        q2(int(x)-1, int(y)-1)\n", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    ordA = ord('a')\n\n    N = int(input())\n    Ss = input().rstrip()\n    Q = int(input())\n    querys = [tuple(input().split()) for _ in range(Q)]\n\n    idEle = 0\n    def _binOpe(x, y):\n        return x | y\n    def makeSegTree(numEle):\n        numPow2 = 2 ** (numEle-1).bit_length()\n        data = [idEle] * (2*numPow2)\n        return data, numPow2\n    def setInit(As):\n        for iST, A in enumerate(As, numPow2):\n            data[iST] = A\n        for iST in reversed(list(range(1, numPow2))):\n            data[iST] = _binOpe(data[2*iST], data[2*iST+1])\n    def _update1(iA, A):\n        iST = iA + numPow2\n        data[iST] = A\n    def update(iA, A):\n        _update1(iA, A)\n        iST = iA + numPow2\n        while iST > 1:\n            iST >>= 1\n            data[iST] = _binOpe(data[2*iST], data[2*iST+1])\n    def getValue(iSt, iEn):\n        L = iSt + numPow2\n        R = iEn + numPow2\n        ans = idEle\n        while L < R:\n            if L & 1:\n                ans = _binOpe(ans, data[L])\n                L += 1\n            if R & 1:\n                R -= 1\n                ans = _binOpe(ans, data[R])\n            L >>= 1\n            R >>= 1\n        return ans\n\n    data, numPow2 = makeSegTree(N)\n    As = [(1<<(ord(S)-ordA)) for S in Ss]\n    setInit(As)\n\n    anss = []\n    for tp, *vs in querys:\n        if tp == '1':\n            i, c = vs\n            i = int(i)\n            update(i-1, 1<<(ord(c)-ordA))\n        else:\n            L, R = vs\n            L, R = int(L), int(R)\n            v = getValue(L-1, R)\n            anss.append(bin(v).count('1'))\n\n    print(('\\n'.join(map(str, anss))))\n\n\nsolve()\n", "from bisect import bisect_left,bisect_right\nimport string \n\ndic = {c:[] for c in string.ascii_lowercase}\n\nn = int(input())\ns = list(input())\nq = int(input())\n\nfor i,c in enumerate(s,start=1):\n  dic[c].append(i)\n  \nfor i in range(q):\n  p,l,r = map(str,input().split())\n  if p =='1':\n    j = int(l)\n    if r == s[j-1]:\n      continue\n    c = s[j-1]    \n    dic[c].pop(bisect_left(dic[c],j))\n    dic[r].insert(bisect_left(dic[r],j),j)\n    s[j-1] = r\n  else:\n    ans = 0\n    l = int(l)\n    r = int(r)\n    for c in string.ascii_lowercase:\n      pl = bisect_left(dic[c],l)\n      if pl < len(dic[c]):\n        if dic[c][pl] <= r:\n          ans += 1\n    print(ans)", "import sys\ndef input(): return sys.stdin.readline().rstrip()\n\n# \u30e9\u30a4\u30d6\u30e9\u30ea\u53c2\u7167https://atcoder.jp/contests/practice2/submissions/16580070\nclass SegmentTree:\n\n    __slots__ = [\"func\", \"e\", \"original_size\", \"n\", \"data\"]\n\n    def __init__(self, length_or_list, func, e):\n        self.func = func\n        self.e = e\n        if isinstance(length_or_list, int):\n            self.original_size = length_or_list\n            self.n = 1 << ((length_or_list - 1).bit_length())\n            self.data = [self.e] * self.n\n        else:\n            self.original_size = len(length_or_list)\n            self.n = 1 << ((self.original_size - 1).bit_length())\n            self.data = [self.e] * self.n + length_or_list + \\\n                [self.e] * (self.n - self.original_size)\n            for i in range(self.n-1, 0, -1):\n                self.data[i] = self.func(self.data[2*i], self.data[2*i+1])\n\n    def replace(self, index, value):\n        index += self.n\n        self.data[index] = value\n        index //= 2\n        while index > 0:\n            self.data[index] = self.func(\n                self.data[2*index], self.data[2*index+1])\n            index //= 2\n\n    def folded(self, l, r):\n        left_folded = self.e\n        right_folded = self.e\n        l += self.n\n        r += self.n\n        while l < r:\n            if l % 2:\n                left_folded = self.func(left_folded, self.data[l])\n                l += 1\n            if r % 2:\n                r -= 1\n                right_folded = self.func(self.data[r], right_folded)\n            l //= 2\n            r //= 2\n        return self.func(left_folded, right_folded)\n\n    def all_folded(self):\n        return self.data[1]\n\n    def __getitem__(self, index):\n        return self.data[self.n + index]\n\n    def max_right(self, l, f):\n        # assert f(self.e)\n        if l >= self.original_size:\n            return self.original_size\n        l += self.n\n        left_folded = self.e\n        while True:\n            # l //= l & -l\n            while l % 2 == 0:\n                l //= 2\n            if not f(self.func(left_folded, self.data[l])):\n                while l < self.n:\n                    l *= 2\n                    if f(self.func(left_folded, self.data[l])):\n                        left_folded = self.func(left_folded, self.data[l])\n                        l += 1\n                return l - self.n\n            left_folded = self.func(left_folded, self.data[l])\n            l += 1\n            if l == l & -l:\n                break\n        return self.original_size\n\n    # \u672averify\n    def min_left(self, r, f):\n        # assert f(self.e)\n        if r == 0:\n            return 0\n        r += self.n\n        right_folded = self.e\n        while True:\n            r //= r & -r\n            if not f(self.func(self.data[r], right_folded)):\n                while r < self.n:\n                    r = 2 * r + 1\n                    if f(self.func(self.data[r], right_folded)):\n                        right_folded = self.func(self.data[r], right_folded)\n                        r -= 1\n                return r + 1 - self.n\n            if r == r & -r:\n                break\n        return 0\n\n\ndef orr(x, y):\n    return x | y\n\n\ndef main():\n    N = int(input())\n    S = input()\n    S = list(map(lambda c: 2**(ord(c) - ord('a')), list(S)))\n    Q = int(input())\n    seg = SegmentTree(S, orr, 0)\n    for _ in range(Q):\n        num, x, y = input().split()\n        if num == '1':\n            seg.replace(int(x)-1, 2**(ord(y) - ord('a')))\n        else:\n            bits = seg.folded(int(x)-1, int(y))\n            print(sum(map(int, list(bin(bits))[2:])))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from bisect import bisect_left, bisect_right, insort_left\n\nn = int(input())\ns = list(input())\nq = int(input())\n\nd = {}\nflag = {}\nfor i in list('abcdefghijklmnopqrstuvwxyz'):\n\td.setdefault(i, []).append(-1)\n\tflag.setdefault(i, []).append(-1)\nfor i in range(n):\n\td.setdefault(s[i], []).append(i)\nfor i in range(q):\n\tq1,q2,q3 = list(map(str,input().split()))\n\tif q1 == '1':\n\t\tq2 = int(q2) - 1\n\t\tif s[q2] != q3:\n\t\t\tinsort_left(flag[s[q2]],q2)\n\t\t\tinsort_left(d[q3],q2)\n\t\t\ts[q2] = q3\n\telse:\n\t\tans = 0\n\t\tq2 = int(q2) - 1\n\t\tq3 = int(q3) - 1\n\t\tif q2 == q3:\n\t\t\tprint((1))\n\t\t\tcontinue\n\t\tfor string,l in list(d.items()):\n\t\t\tres = 0\n\t\t\tif d[string] != [-1]:\n\t\t\t\tleft = bisect_left(l,q2)\n\t\t\t\tright = bisect_right(l,q3)\n\t\t\telse:\n\t\t\t\tleft = 0\n\t\t\t\tright = 0\n\t\t\tif string in flag:\n\t\t\t\tleft2 = bisect_left(flag[string],q2)\n\t\t\t\tright2 = bisect_right(flag[string],q3)\n\t\t\telse:\n\t\t\t\tleft2 = 0\n\t\t\t\tright2 = 0\n\t\t\tif left != right:\n\t\t\t\tif right - left > right2 - left2:\n\t\t\t\t\tres = 1\n\t\t\tans += res\n\t\t\t#print(string,l,res)\n\t\tprint(ans)\n", "#!python3\n\nimport sys\n\niim = lambda: map(int, input().rstrip().split())\n\ndef popcnt2(n):\n    a = (\n        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,\n    )\n    ans = 0\n    while n:\n        ans += a[n&0xff]\n        n >>= 8\n    return ans\n\ndef resolve():\n    N = int(input())\n    S = list(input())\n    Q = int(input())\n\n    c0 = ord('a')\n    smap = [1<<(i-c0) for i in range(c0, ord('z')+1)]\n\n    T = [0]*N + [smap[ord(S[i])-c0] for i in range(N)]\n\n    for i in range(N-1, 0, -1):\n        i2 = i << 1\n        T[i] = T[i2] | T[i2|1]\n\n    ans = []\n    #print(T)\n    for cmd, i, j in zip(*[iter(sys.stdin.read().split())]*3):\n        i = int(i) - 1\n        if cmd == \"1\":\n            if S[i] == j:\n                continue\n\n            S[i] = j\n            i0 = N + i\n            T[i0] = smap[ord(j)-c0]\n            while i0 > 1:\n                i0 = i0 >> 1\n                T[i0] = T[i0+i0] | T[i0-~i0]\n        elif cmd == \"2\":\n            i += N\n            j = int(j) + N\n\n            d1 = 0\n            while i < j:\n                if i & 1:\n                    d1 |= T[i]\n                    i += 1\n                if j & 1:\n                    j -= 1\n                    d1 |= T[j]\n\n                i >>= 1; j >>=1\n\n            ans.append(popcnt2(d1))\n\n    print(*ans, sep=\"\\n\")\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "class SegTree:\n\n    def __init__(self, N, S):\n        self.N = 1\n        while self.N < N:\n            self.N *= 2\n        self.tree = [0 for i in range(2 * self.N - 1)]\n        for i in range(len(S)):\n            self.tree[self.N - 1 + i] = 1 << (ord(S[i]) - ord('a'))\n        for i in range(self.N - 2, -1, -1):\n            self.tree[i] = self.tree[i * 2 + 1] | self.tree[i * 2 + 2]\n\n    def update(self, index, char):\n        i = self.N - 1 + index\n        self.tree[i] = 1 << (ord(char) - ord('a'))\n\n        while i > 0:\n            i = (i - 1) // 2\n            self.tree[i] = self.tree[i * 2 + 1] | self.tree[i * 2 + 2]\n\n    def get(self, a, b):\n        return self.query(a, b, 0, 0, self.N)\n\n    def query(self, a, b, k, l, r):\n        if r <= a or b <= l:\n            return 0\n        elif a <= l and r <= b:\n            return self.tree[k]\n        else:\n            left = self.query(a, b, 2 * k + 1, l, (l + r) // 2)\n            right = self.query(a, b, 2 * k + 2, (l + r) // 2, r)\n            return left | right\n\n\ndef solve():\n\n    N = int(input())\n    S = list(input())\n    tree = SegTree(N, S)\n\n    Q = int(input())\n    for _ in range(Q):\n        t_q, in_1, in_2 = input().split()\n        if t_q == '1':\n            i_q = int(in_1)\n            c_q = in_2\n            tree.update(i_q-1, c_q)\n        elif t_q == '2':\n            l_q = int(in_1)\n            r_q = int(in_2)\n            print((bin(tree.get(l_q-1, r_q)).count('1')))\n\n\nsolve()\n", "class SegmentTree(object):\n    def __init__(self, sequence, function, identity):\n        N = len(sequence)\n        self.length = (1 << (N - 1)).bit_length()\n        self.function = function\n        self.data = [identity] * (self.length << 1)\n        self.identity = identity\n        # set values\n        for i in range(N):\n            self.data[i + self.length - 1] = sequence[i]\n        # build\n        for i in range(self.length - 2, -1, -1) :\n            self.data[i] = self.function(self.data[(i << 1) + 1], self.data[(i << 1) + 2])\n\n    def update(self, idx, x):\n        idx += self.length - 1\n        self.data[idx] = x\n        while idx:\n            idx = (idx - 1) >> 1\n            self.data[idx] = self.function(self.data[(idx << 1) + 1], self.data[(idx << 1) + 2])\n\n    def query(self, p, q):\n        if q <= p:\n            return self.identity\n        p += self.length - 1\n        q += self.length - 2\n        res = self.identity\n        while q - p > 1:\n            if not p & 1:\n                res = self.function(res, self.data[p])\n            if q & 1:\n                res = self.function(res, self.data[q])\n                q -= 1\n            p >>= 1\n            q = (q - 1) >> 1\n        return self.function(res, self.data[p]) if p == q else self.function(self.function(res, self.data[p]), self.data[q])\n\ndef popcount(n):\n  n = (n & 0x5555555555555555) + ((n & 0xAAAAAAAAAAAAAAAA) >> 1)\n  n = (n & 0x3333333333333333) + ((n & 0xCCCCCCCCCCCCCCCC) >> 2)\n  n = (n & 0x0F0F0F0F0F0F0F0F) + ((n & 0xF0F0F0F0F0F0F0F0) >> 4)\n  n = (n & 0x00FF00FF00FF00FF) + ((n & 0xFF00FF00FF00FF00) >> 8)\n  n = (n & 0x0000FFFF0000FFFF) + ((n & 0xFFFF0000FFFF0000) >> 16)\n  n = (n & 0x00000000FFFFFFFF) + ((n & 0xFFFFFFFF00000000) >> 32)\n  return n\n\nN = int(input())\nS = input()\natoi = {chr(ord(\"a\") + d): 1 << d for d in range(26)}\ndata = [atoi[c] for c in (S)]\nseg_tree = SegmentTree(data, lambda a, b: a | b, 0)\nQ = int(input())\nfor _ in range(Q):\n    q, a, b = input().split()\n    if q == \"1\":\n        idx = int(a) - 1\n        seg_tree.update(idx, atoi[b])\n    else:\n        print(popcount(seg_tree.query(int(a) - 1, int(b))))", "class SegmentTree():\n    '''\n    \u975e\u518d\u5e30\n    segment tree\n    '''\n\n    def __init__(self, n, func, init=float('inf')):\n        '''\n        n->\u914d\u5217\u306e\u9577\u3055\n        func:func(a,b)->val,\u3000func=min\u3060\u3068RMQ\u306b\u306a\u308b\n        \u6728\u306e\u9ad8\u3055h\u3068\u3059\u308b\u3068,\n        n:h-1\u307e\u3067\u306e\u30ce\u30fc\u30c9\u6570\u3002h\u6bb5\u76ee\u306e\u30ce\u30fc\u30c9\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u305f\u3081\u306b\u4f7f\u3046\u3002\n        data:\u30ce\u30fc\u30c9\u3002\n        parent:k->child k*2+1\u3068k*2+2\n        '''\n        self.n = 2**(n-1).bit_length()\n        self.init = init\n        self.data = [init]*(2*self.n)\n        self.func = func\n\n    def set(self, k, v):\n        '''\n        \u5024\u306e\u521d\u671f\u5316\n        '''\n        self.data[k+self.n-1] = v\n\n    def build(self):\n        '''\n        set\u306e\u5f8c\u306b\u4e00\u6589\u66f4\u65b0\n        '''\n        for k in reversed(list(range(self.n-1))):\n            self.data[k] = self.func(self.data[k*2+1], self.data[k*2+2])\n\n    def update(self, k, a):\n        '''\n        list[k]=a\u306b\u66f4\u65b0\u3059\u308b\u3002\n        \u66f4\u65b0\u3076\u3093\u3092root\u307e\u3067\u66f4\u65b0\n        '''\n        k += self.n-1\n        self.data[k] = a\n\n        while k > 0:\n            k = (k-1)//2\n            self.data[k] = self.func(self.data[k*2+1], self.data[k*2+2])\n\n    def query(self, l, r):\n        '''\n        [l,r)\u306efunc\u3092\u6c42\u3081\u308b\n        '''\n        L = l+self.n\n        R = r+self.n\n        ret = self.init\n        while L < R:\n            if R & 1:\n                R -= 1\n                ret = self.func(ret, self.data[R-1])\n            if L & 1:\n                ret = self.func(ret, self.data[L-1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return ret\n\nN = int(input())\nS = input()\nQ = int(input())\nSeg = SegmentTree(N, lambda x, y: x | y, 0)\n\ndef a2n(a):\n    return ord(a) - ord('a')\n\ndef createBit(a):\n    return 1 << a2n(a)\n\nfor i, s in enumerate(S):\n    Seg.set(i, createBit(s))\nSeg.build()\n\nfor _ in range(Q):\n    t, l, r = input().split()\n    if int(t) == 1:\n        Seg.update(int(l)-1, createBit(r))\n    else:\n        print((bin(Seg.query(int(l)-1, int(r))).count('1')))\n\n# N = int(input())\n# S = input()\n# Q = int(input())\n# queries = [list(input().split()) for _ in range(Q)]\n\n\n# def a2n(a):\n#     return ord(a)-ord(\"a\")\n\n\n# def createInp(a):\n#     return 1 << a2n(a)\n\n\n# Seg = SegmentTree(len(S), lambda x, y: x | y, init=0)\n# for i, s in enumerate(S):\n#     Seg.set(i, createInp(s))\n# Seg.build()\n\n# for q, l, r in queries:\n#     if q == \"1\":\n#         Seg.update(int(l)-1, createInp(r))\n#     else:\n#         print(bin(Seg.query(int(l)-1, int(r))).count('1'))\n", "# Segment tree (Bitwise Or)\nfrom operator import or_\n\n\nclass SegmentTree:\n    _f = None\n    _data = None\n    _offset = None\n    _size = None\n\n    def __init__(self, size, f):\n        self._f = f\n        self._size = size\n        t = 1\n        while t < size:\n            t *= 2\n        self._offset = t - 1\n        self._data = [0] * (t * 2 - 1)\n\n    def build(self, iterable):\n        f = self._f\n        data = self._data\n        data[self._offset:self._offset + self._size] = iterable\n        for i in range(self._offset - 1, -1, -1):\n            data[i] = f(data[i * 2 + 1], data[i * 2 + 2])\n\n    def update(self, index, value):\n        f = self._f\n        data = self._data\n        i = self._offset + index\n        data[i] = value\n        while i >= 1:\n            i = (i - 1) // 2\n            data[i] = f(data[i * 2 + 1], data[i * 2 + 2])\n\n    def query(self, start, stop):\n        def iter_segments(data, l, r):\n            while l < r:\n                if l & 1 == 0:\n                    yield data[l]\n                if r & 1 == 0:\n                    yield data[r - 1]\n                l = l // 2\n                r = (r - 1) // 2\n        f = self._f\n        it = iter_segments(self._data, start + self._offset,\n                           stop + self._offset)\n        result = next(it)\n        for e in it:\n            result = f(result, e)\n        return result\n\n\ndef conv(c):\n    return 1 << (ord(c) - ord('a'))\n\n\nN = int(input())\nS = input()\n\nst = SegmentTree(N, or_)\nst.build(conv(c) for c in S)\n\nQ = int(input())\nfor _ in range(Q):\n    q = input().split()\n    if q[0] == '1':\n        i, c = q[1:]\n        i = int(i) - 1\n        st.update(i, conv(c))\n    elif q[0] == '2':\n        l, r = list(map(int, q[1:]))\n        print((bin(st.query(l - 1, r)).count('1')))\n", "import bisect\n\nN = int(input())\nS = list(str(input()))\n\ndef ordN(x):\n  return ord(x) - ord('a')\n\nli = [[] for _ in range(26)]\nfor i,s in enumerate(S):\n  li[ordN(s)].append(i)\n\nfor i in range(int(input())):\n  Q1, Q2, Q3 = input().split()\n  if Q1 == \"1\":\n    Q2 = int(Q2) - 1\n    if S[Q2] != Q3:\n      I = bisect.bisect_left(li[ordN(S[Q2])], Q2)\n      li[ordN(S[Q2])].pop(I)\n      bisect.insort(li[ordN(Q3)], Q2)\n      S[Q2] = Q3\n  else:\n    Q2, Q3 = int(Q2)-1, int(Q3)-1\n    count = 0\n    for j in range(26):\n      I = bisect.bisect_left(li[j], Q2)\n      if I < len(li[j]) and li[j][I] <= Q3:\n        count += 1\n    print(count)", "import sys\nreadline = sys.stdin.readline\n\nfrom bisect import bisect_left, insort_left\n\ndef main():\n    n = int(readline())\n    s = list(readline().rstrip())\n    q = int(readline())\n    \n    chk_abc = [[] for i in range(26)]\n    for i, si in enumerate(s):\n        ci = ord(si) - 97\n        chk_abc[ci].append(i)\n        \n    ans = []\n    for _ in range(q):\n        cmd, i, j = readline().rstrip().split()\n        i = int(i) - 1\n        \n        if cmd == \"1\":\n            if s[i] == j:\n                continue\n            c1 = ord(s[i]) - 97\n            prev = chk_abc[c1]\n            c2 = ord(j) - 97\n            prev.pop(bisect_left(prev, i))\n            s[i] = j\n            insort_left(chk_abc[c2], i)\n            \n        else:\n            j = int(j) - 1\n            num = 0\n            for chk in chk_abc:\n                le = len(chk)\n                k = bisect_left(chk, i, 0, le)\n                if k == le:\n                    continue\n                if i <= chk[k] <= j:\n                    num += 1\n            ans.append(num)\n\n    print(*ans, sep=\"\\n\")\n\ndef __starting_point():\n    main()\n__starting_point()", "f=input\nfrom bisect import bisect_left as g, insort as h\nn,s=int(f()),list(f())\nd={chr(97+i):[] for i in range(26)}\nfor i in range(n): d[s[i]]+=[i]\nfor _ in range(int(f())):\n  a,b,c=f().split(); b=int(b)-1\n  if a>'1': print(sum(1 for l in d.values() if g(l,b)<len(l) and l[g(l,b)]<int(c)))\n  elif s[b]!=c: l=d[s[b]]; l.pop(g(l,b)); s[b]=c; h(d[c],b)", "import sys\nfrom bisect import bisect_left, bisect_right, insort\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\nS = list('-' + sr())\nd = [[] for _ in range(26)]\nfor i in range(1, N+1):\n    s = S[i]\n    o = ord(s) - ord('a')\n    d[o].append(i)\n\nQ = ir()\nfor _ in range(Q):\n    q, a, b = sr().split()\n    if q == '1':\n        a = int(a)\n        if S[a] == b:\n            continue\n        prev = ord(S[a]) - ord('a')\n        d[prev].pop(bisect_left(d[prev], a))\n        next = ord(b) - ord('a')\n        insort(d[next], a)\n        S[a] = b\n    else:\n        a = int(a); b = int(b)\n        ans = 0\n        for alpha in range(26):\n            if bisect_right(d[alpha], b) - bisect_left(d[alpha], a) >= 1:\n                ans += 1\n        print(ans)\n", "from operator import or_\n \nclass SegmentTree:\n    def __init__(self, size, op, e):\n        self._op = op\n        self._e = e\n        self._size = size\n        t = 1 << (size - 1).bit_length()\n        self._offset = t - 1\n        self._data = [e] * (t * 2 - 1)\n \n    def __getitem__(self, key):\n        return self._data[self._offset + key]\n \n    def __setitem__(self, key, value):\n        op = self._op\n        data = self._data\n        i = self._offset + key\n        data[i] = value\n        while i >= 1:\n            i = (i - 1) // 2\n            data[i] = op(data[i * 2 + 1], data[i * 2 + 2])\n \n    def build(self, iterable):\n        op = self._op\n        data = self._data\n        data[self._offset:self._offset + self._size] = iterable\n        for i in range(self._offset - 1, -1, -1):\n            data[i] = op(data[i * 2 + 1], data[i * 2 + 2])\n \n    def query(self, start, end):\n        op = self._op\n        res = self._e\n        l = self._offset + start\n        r = self._offset + end\n        while l < r:\n            if l & 1 == 0:\n                res = op(res, self._data[l])\n            if r & 1 == 0:\n                res = op(res, self._data[r - 1])\n            l = l // 2\n            r = (r-1) // 2\n        return res\n \ndef str2bit(c):\n  return 1 << (ord(c) - ord('a'))\n \nN = int(input())\nS = input()\n \nst = SegmentTree(N, or_, 0)\nst.build(str2bit(x) for x in S)\n \nM = int(input())\nfor i in range(M):\n  q, a, b = input().split()\n  if q == \"1\":\n    st[int(a)-1] = str2bit(b)\n  elif q == \"2\":\n    print(bin(st.query(int(a)-1,int(b))).count(\"1\"))", "from bisect import insort_left, bisect_left\nn = int(input())\ns = list(input())\nQ = int(input())\nquery = [input() for _ in range(Q)]\ndic = {chr(i+ord('a')):[] for i in range(26)}\nfor ind, c in enumerate(s):\n    dic[c].append(ind)\n\nfor q in query:\n    t, a, b = q.split()\n    a = int(a)-1\n    if t=='1':\n        if s[a]==b:\n            continue\n        ind = bisect_left(dic[s[a]], a)\n        dic[s[a]].pop(ind)\n        insort_left(dic[b], a)\n        s[a] = b\n    else:\n        b = int(b)-1\n        tmp = 0\n        for li in list(dic.values()):\n            if li and a<=li[-1] and li[bisect_left(li, a)] <= b:\n                tmp += 1\n        print(tmp)\n", "from collections import defaultdict\nfrom bisect import bisect, insort, bisect_left\nn = int(input())\ns = list(input())\nq = int(input())\nd = defaultdict(list)\nfor i in range(n):\n    d[s[i]] += [i]\nfor _ in range(q):\n    t, i, c = input().split()\n    t, i = int(t), int(i) - 1\n    if t == 1:\n        if s[i] == c:\n            continue\n        d[s[i]].pop(bisect(d[s[i]], i) - 1)\n        s[i] = c\n        insort(d[c], i)\n    else:\n        res = 0\n        c = int(c) - 1\n        for j in d.values():\n            if bisect(j, c) - bisect_left(j, i):\n                res += 1\n        print(res)", "from bisect import bisect_left\nimport string \n\ndic={c:[] for c in string.ascii_lowercase}\nN=int(input())\nS=list(input())\nQ=int(input())\nfor i in range(len(S)):\n  dic[S[i]].append(i+1)\n\nfor i in range(Q):\n  a,b,c=list(map(str,input().split()))\n  if a=='1':\n    if S[int(b)-1]==c:\n      continue\n    b=int(b)\n    f=S[b-1]\n    d=bisect_left(dic[f],b)\n    e=bisect_left(dic[c],b)\n    dic[f].pop(d)\n    dic[c].insert(e,b)\n    S[b-1]=c\n  else:\n    ans=0\n    b,c=int(b),int(c)\n    for j in string.ascii_lowercase:\n      d=bisect_left(dic[j],b)\n      if d<len(dic[j]):\n        if dic[j][d]<=c:\n          ans+=1\n    print(ans)\n", "import bisect\nN=input()\nS=list(input())\nalphabet=[[] for _ in range(26)]\nfor i,s in enumerate(S):\n    alphabet[ord(s)-ord('a')].append(i)\nQ=int(input())\nfor _ in range(Q):\n    Type,A,B=input().split()\n    if Type==\"1\":\n        A=int(A)\n        s=S[A-1]\n        if s==B:\n            continue\n        o=ord(s)-ord(\"a\")\n        alphabet[o].pop(bisect.bisect_left(alphabet[o],A-1))\n        index=bisect.bisect(alphabet[ord(B)-ord(\"a\")],A-1)\n        alphabet[ord(B)-ord(\"a\")].insert(index,A-1)\n        S[A-1]=B\n    else:\n        A=int(A)\n        B=int(B)\n        ans=0\n        for i in range(26):\n            indexL=bisect.bisect_left(alphabet[i],A-1)\n            #indexR=bisect.bisect_right(alphabet[i],B-1)\n            #ans+=(indexL!=indexR)\n            if indexL==len(alphabet[i]):\n                continue\n            ans+=(alphabet[i][indexL]<=B-1)\n        print(ans)\n", "\"\"\"\nAtCoder Beginner Contest 157  E - Simple String Queries\n\n\u6587\u5b57\u5217S\u306b\u5bfe\u3057\u3066\u3001\n\u30af\u30a8\u30ea1\uff1ai\u756a\u76ee\u306e\u6587\u5b57\u3092c\u306b\u5909\u66f4\n\u30af\u30a8\u30ea2\uff1aS[l~r]\u306b\u4f55\u7a2e\u985e\u306e\u6587\u5b57\u304c\u3042\u308b\u304b\n\n\u5404\u30af\u30a8\u30ea\u306b\u3064\u3044\u3066\u3001\u5f8b\u5100\u306b\u6587\u5b57\u3092\u5909\u3048\u3066\u3001l~r\u306b\u3064\u3044\u3066\u4f55\u7a2e\u985e\u3042\u308b\u304b\u8abf\u3079\u308b\u3068\u9593\u306b\u5408\u308f\u306a\u3044\u306f\u305a\u3002\n\n~~~ABCCDC~~~\n        \u2191\u3092\u5225\u306e\u6587\u5b57\u306b\u3057\u305f\u6642\u306b\u3001\u6700\u5f8c\u306b\u51fa\u3066\u304f\u308bC\u304c\u305d\u306e\u4e8c\u500b\u5de6\u3001\u306e\u3088\u3046\u306a\u60c5\u5831\u3092\u3061\u3083\u3093\u3068\u6b8b\u3057\u305f\u3044\u3002\n\u2192 \u6700\u5f8c\u306e\u4f4d\u7f6e\u304c\u77e5\u308a\u305f\u3044\u3068\u304b\u3067\u306f\u306a\u304f\u3001l\u3068r\u3092\u6307\u5b9a\u3057\u305f\u6642\u306b\u3001\u305d\u306e\u9593\u306b\u3042\u308b\u304b\u304c\u77e5\u308a\u305f\u3044\uff08\u5177\u4f53\u7684\u306a\u4f4d\u7f6e\u304c\u77e5\u308a\u305f\u3044\u308f\u3051\u3067\u306f\u306a\u3044\uff09\n\u3000\u305d\u3046\u3059\u308bt\u3001a\u301cz\u306b\u3064\u3044\u3066\u3001l~r\u306b\u5b58\u5728\u3059\u308b\u304b\u3001\u307f\u305f\u3044\u306a\u78ba\u8a8d\u304c\u3067\u304d\u305d\u3046\n\nN <= 5 * 10**5\nQ <= 2 * 10**4\n\u306a\u306e\u3067\u3001bisect\u4f7f\u3048\u3070\u9593\u306b\u5408\u3046\u306e\u304b\uff1f\u3088\u304f\u308f\u304b\u3089\u3093\n\nS\u3068\u3057\u3066\u3067\u306f\u306a\u304f\u3001\u73fe\u6642\u70b9\u3067\u4f55\u6587\u5b57\u76ee\u304c\u306a\u306b\u306a\u306e\u304b\u3082\u6301\u3063\u3066\u304a\u3044\u305f\u307b\u3046\u304c\u697d\u304b\u3002\n\n\"\"\"\n\nimport bisect\n\nN = int(input())\nS = input()\nQ = int(input())\n\n# \u73fe\u6642\u70b9\u3067\u3069\u3053\u306b\u4f55\u304c\u3042\u308b\u304b\ncS = [\"\"] * N\n# \u3042\u308b\u6587\u5b57\u306e\u4f4d\u7f6e\nchar_idxs = [[]for _  in range(26)]\n\n# i\u756a\u76ee\u306f\u6587\u5b57s\u3001\u3092\u4fdd\u5b58\nfor i,s in enumerate(S):\n    cS[i] = s\n    char_idxs[ord(s) - 97].append(i)\n\nquery = [tuple(map(str, input().split())) for _ in range(Q)]\n\n\n\n\nfor q,a,b in query:\n    \n    # q == 1\u306e\u6642\u3001a\u756a\u76ee\u306e\u6587\u5b57\u3092b\u306b\u7f6e\u304d\u63db\u3048\n    if q == \"1\":\n        # \u73fe\u6642\u70b9\u306e\u6587\u5b57\u3068\u7f6e\u304d\u63db\u3048\u5f8c\u304c\u540c\u3058\u306a\u3089\u4f55\u3082\u3057\u306a\u3044\n        if cS[int(a) - 1] == b:\n            continue\n        else:\n            #print(\"---\", char_idxs[ord(cS[]) - 97], int(a)-1, bisect.bisect_right(char_idxs[ord(b) - 97], int(a)-1))\n            # a\u756a\u76ee\u306e\u6587\u5b57\u3092\u66f8\u304d\u63db\u3048\u308b\n\n            \n            idx = bisect.bisect_right(char_idxs[ord(cS[int(a)-1]) - 97], int(a)-1)\n            # idx\u306e\u5de6\u306e\u5024\u304ca\u756a\u76ee\u3067\u3042\u308c\u3070\u3001\u305d\u308c\u3092\u6d88\u3059\n            if char_idxs[ord(cS[int(a)-1]) - 97][idx-1] == int(a)-1:\n                # del\u306e\u65b9\u304c\u65e9\u3044\u304b\uff1f\n                char_idxs[ord(cS[int(a)-1]) - 97][idx-1:idx] = []\n            \n            # b\u306e\u6587\u5b57\u304ca\u756a\u76ee\u306b\u3042\u308b\u3088\u3001\u3092\u4fdd\u5b58\n            bisect.insort_right(char_idxs[ord(b) - 97], int(a) - 1)\n\n            # \u7f6e\u304d\u63db\u3048\n            cS[int(a) - 1] = b\n\n    # q == 2\u306e\u6642\u3001\u7bc4\u56f2\u306e\u6587\u5b57\u7a2e\u306e\u500b\u6570\u3092\u8abf\u3079\u308b\n    else:\n        cnt = 0\n        for i in range(26):\n            # \u305d\u3082\u305d\u3082\u305d\u306e\u6587\u5b57\u304c\u6587\u5b57\u5217\u5168\u4f53\u306b\u306a\u3051\u308c\u3070\u8003\u3048\u306a\u3044\n            if len(char_idxs[i]) == 0: continue\n            # bisect_left\u3067 a-1 \u3092\u5165\u308c\u3089\u308c\u308b\u5834\u6240\u3092\u63a2\u3057\u3066\u3001\u305d\u306e\u6642\u306b\u53f3\u306b\u3042\u308b\u5024\u304cb-1\u4ee5\u4e0b\u3067\u3042\u308c\u3070\u542b\u307e\u308c\u308b\n            l = bisect.bisect_left(char_idxs[i], int(a)-1)\n            #r = bisect.bisect_right(char_idxs[i], int(b)-1)\n\n            # char_idxs[i][l]\u306fa-1\u3088\u308a\u53f3\u306b\u6587\u5b57\u7a2ei\u304c\u521d\u3081\u3066\u51fa\u3066\u304f\u308b\u4f4d\u7f6e\u306a\u306e\u3067\u3001\u305d\u308c\u304cb-1\u3092\u542b\u3080\u53f3\u5074\u306b\u3042\u308c\u3070OK\n            if l < len(char_idxs[i]) and char_idxs[i][l] <= int(b)-1:\n                cnt += 1\n\n        print(cnt)\n\n\n", "from bisect import bisect_left,bisect_right\nimport string \n\ndic = {c:[] for c in string.ascii_lowercase}\n\nn = int(input())\ns = list(input())\nq = int(input())\n\nfor i,c in enumerate(s,start=1):\n  dic[c].append(i)\n  \nfor i in range(q):\n  p,l,r = list(map(str,input().split()))\n  if p =='1':\n    j = int(l)\n    if r == s[j-1]:\n      continue\n    c = s[j-1]    \n    dic[c].pop(bisect_left(dic[c],j))\n    dic[r].insert(bisect_left(dic[r],j),j)\n    s[j-1] = r\n  else:\n    ans = 0\n    l = int(l)\n    r = int(r)\n    for c in string.ascii_lowercase:\n      pl = bisect_left(dic[c],l)\n      if pl < len(dic[c]):\n        if dic[c][pl] <= r:\n          ans += 1\n    print(ans)\n", "\nimport bisect\n\nN = int(input())\nS = input()\nQ = int(input())\n\n# \u73fe\u6642\u70b9\u3067\u3069\u3053\u306b\u4f55\u304c\u3042\u308b\u304b\ncS = [\"\"] * N\n# \u3042\u308b\u6587\u5b57\u306e\u4f4d\u7f6e\nchar_idxs = [[]for _  in range(26)]\n\n# i\u756a\u76ee\u306f\u6587\u5b57s\u3001\u3092\u4fdd\u5b58\nfor i,s in enumerate(S):\n    cS[i] = s\n    char_idxs[ord(s) - 97].append(i)\n\nquery = [tuple(map(str, input().split())) for _ in range(Q)]\n\n\n\n\nfor q,a,b in query:\n    \n    # q == 1\u306e\u6642\u3001a\u756a\u76ee\u306e\u6587\u5b57\u3092b\u306b\u7f6e\u304d\u63db\u3048\n    if q == \"1\":\n        # \u73fe\u6642\u70b9\u306e\u6587\u5b57\u3068\u7f6e\u304d\u63db\u3048\u5f8c\u304c\u540c\u3058\u306a\u3089\u4f55\u3082\u3057\u306a\u3044\n        if cS[int(a) - 1] == b:\n            continue\n        else:\n            #print(\"---\", char_idxs[ord(cS[]) - 97], int(a)-1, bisect.bisect_right(char_idxs[ord(b) - 97], int(a)-1))\n            # a\u756a\u76ee\u306e\u6587\u5b57\u3092\u66f8\u304d\u63db\u3048\u308b\n\n            \n            idx = bisect.bisect_right(char_idxs[ord(cS[int(a)-1]) - 97], int(a)-1)\n            # idx\u306e\u5de6\u306e\u5024\u304ca\u756a\u76ee\u3067\u3042\u308c\u3070\u3001\u305d\u308c\u3092\u6d88\u3059\n            if char_idxs[ord(cS[int(a)-1]) - 97][idx-1] == int(a)-1:\n                # del\u306e\u65b9\u304c\u65e9\u3044\u304b\uff1f\n                char_idxs[ord(cS[int(a)-1]) - 97][idx-1:idx] = []\n            \n            # b\u306e\u6587\u5b57\u304ca\u756a\u76ee\u306b\u3042\u308b\u3088\u3001\u3092\u4fdd\u5b58\n            bisect.insort_right(char_idxs[ord(b) - 97], int(a) - 1)\n\n            # \u7f6e\u304d\u63db\u3048\n            cS[int(a) - 1] = b\n\n    # q == 2\u306e\u6642\u3001\u7bc4\u56f2\u306e\u6587\u5b57\u7a2e\u306e\u500b\u6570\u3092\u8abf\u3079\u308b\n    else:\n        cnt = 0\n        for i in range(26):\n            # \u305d\u3082\u305d\u3082\u305d\u306e\u6587\u5b57\u304c\u6587\u5b57\u5217\u5168\u4f53\u306b\u306a\u3051\u308c\u3070\u8003\u3048\u306a\u3044\n            if len(char_idxs[i]) == 0: continue\n            # bisect_left\u3067 a-1 \u3092\u5165\u308c\u3089\u308c\u308b\u5834\u6240\u3092\u63a2\u3057\u3066\u3001\u305d\u306e\u6642\u306b\u53f3\u306b\u3042\u308b\u5024\u304cb-1\u4ee5\u4e0b\u3067\u3042\u308c\u3070\u542b\u307e\u308c\u308b\n            l = bisect.bisect_left(char_idxs[i], int(a)-1)\n            #r = bisect.bisect_right(char_idxs[i], int(b)-1)\n\n            # char_idxs[i][l]\u306fa-1\u3088\u308a\u53f3\u306b\u6587\u5b57\u7a2ei\u304c\u521d\u3081\u3066\u51fa\u3066\u304f\u308b\u4f4d\u7f6e\u306a\u306e\u3067\u3001\u305d\u308c\u304cb-1\u3092\u542b\u3080\u53f3\u5074\u306b\u3042\u308c\u3070OK\n            if l < len(char_idxs[i]) and char_idxs[i][l] <= int(b)-1:\n                cnt += 1\n\n        print(cnt)\n\n\n", "from bisect import bisect_left,bisect_right\n\nTO_ACII = 97\n\nN = int(input())\nS = [\"0\"] + list(input())\nQ = int(input())\n\nABC = [[]for i in range(0,26,1)]#\u8a72\u5f53\u6587\u5b57a:0 b:1 ...z:26 \u304c\u4f55\u6587\u5b57\u76ee\u306b\u51fa\u3066\u304d\u305f\u304b\u3092\u4fdd\u6301\u3059\u308b\u914d\u5217\n\nfor i in range(1,N+1,1):\n    ABC[ord(S[i])-TO_ACII].append(i)\n\nans = []\nfor i in range(0,Q,1):\n    q = list(input().split())\n    if q[0]==\"1\":#\u6587\u5b57\u5909\u66f4\n        changed = S[int(q[1])]\n        ABC[ord(changed)-TO_ACII].pop(bisect_left(ABC[ord(changed)-TO_ACII],int(q[1])))\n        ABC[ord(q[2])-TO_ACII].insert(bisect_left(ABC[ord(q[2])-TO_ACII],int(q[1])),int(q[1]))\n        S[int(q[1])]=q[2]\n    else:\n        tmpans = 0\n        for i in range(0,26,1):\n\n            if bisect_right(ABC[i],int(q[1])-1)<len(ABC[i]) and int(q[2]) >= ABC[i][bisect_right(ABC[i],int(q[1])-1)]:\n                tmpans+=1\n        ans.append(tmpans)\n\nfor i in range(0,len(ans),1):\n    print((ans[i]))\n", "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\ndef main():\n    n = ni()\n    s = list(input())\n    q = ni()\n\n    alphabet_idx = {}\n    for i in range(26):\n        alphabet_idx[i] = []\n\n    for i, si in enumerate(s):\n        alphabet_idx[ord(si) - ord(\"a\")].append(i)\n\n    for _ in range(q):\n        qi, a, b = input().split()\n        qi, a = int(qi), int(a)\n\n        if qi == 1:\n            a -= 1\n            if s[a] == b:\n                continue\n            del_char = ord(s[a]) - ord(\"a\")\n            del_idx = bisect.bisect_left(alphabet_idx[del_char], a)\n            del alphabet_idx[del_char][del_idx]\n\n            insert_char = ord(b) - ord(\"a\")\n            insert_idx = bisect.bisect_left(alphabet_idx[insert_char], a)\n            alphabet_idx[insert_char].insert(insert_idx, a)\n\n            s[a] = b\n\n        if qi == 2:\n            b = int(b)\n            a -= 1\n            b -= 1\n            ans = 0\n\n            for i in range(26):\n                a_idx = bisect.bisect_left(alphabet_idx[i], a)\n                if a_idx < len(alphabet_idx[i]):\n                    if alphabet_idx[i][a_idx] <= b:\n                        ans += 1\n\n            print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())+1\ndata=[0]*n*2\ndef update(i,x):\n    i+=n\n    data[i]=x\n    i//=2\n    while i:\n        data[i]=data[i*2]|data[i*2+1]\n        i//=2\ndef query(l,r):\n    l+=n\n    r+=n\n    s=0\n    while l<r:\n        if l&1:\n            s|=data[l]\n            l+=1\n        if r&1:\n            r-=1\n            s|=data[r]\n        l//=2\n        r//=2\n    return sum(map(int,bin(s)[2:]))\ns=input()\nfor i,c in enumerate(s,n):\n    data[i]=1<<(ord(c)-97)\nfor i in range(n-1,0,-1):\n    data[i]=data[2*i]|data[2*i+1]\nfor _ in range(int(input())):\n    q,a,b=input().split()\n    if q==\"2\":\n        print(query(int(a)-1,int(b)))\n    else:\n        update(int(a)-1,1<<(ord(b)-97))", "class SegmentTree:\n    def __init__(self, n, segment_func, identity_element):\n        self.n = n\n        self.num = 1 << (self.n - 1).bit_length()\n        self.segment_func = segment_func\n        self.identity_element = identity_element\n        self.segment_tree = [self.identity_element] * (2 * self.num)\n\n    def initialize(self, val_arr):\n        for i in range(self.n):\n            self.segment_tree[self.num + i] = val_arr[i]\n        for i in range(self.num - 1, 0, -1):\n            self.segment_tree[i] = self.segment_func(self.segment_tree[2 * i], self.segment_tree[2 * i + 1])\n\n    def update(self, idx, val):\n        idx += self.num\n        self.segment_tree[idx] = val\n        while idx > 1:\n            self.segment_tree[idx >> 1] = self.segment_func(self.segment_tree[idx], self.segment_tree[idx ^ 1])\n            idx >>= 1\n\n    def query(self, left, right):\n        res = self.identity_element\n        left += self.num\n        right += self.num\n        while left < right:\n            if left & 1:\n                res = self.segment_func(res, self.segment_tree[left])\n                left += 1\n            if right & 1:\n                res = self.segment_func(res, self.segment_tree[right - 1])\n            left >>= 1\n            right >>= 1\n        return res\n\n    def bisect_left(self, left, right, target):\n        left += self.num\n        right += self.num\n        left_min = -1\n        right_min = -1\n        while left < right:\n            if left & 1:\n                if self.segment_tree[left] >= target and left_min == -1:\n                    left_min = left\n                left += 1\n            if right & 1:\n                if self.segment_tree[right - 1] >= target:\n                    right_min = right - 1\n            left >>= 1\n            right >>= 1\n        if left_min != -1 or right_min != -1:\n            res = left_min if left_min != -1 else right_min\n            while res < self.num:\n                if self.segment_tree[2 * res] >= target:\n                    res *= 2\n                else:\n                    res *= 2\n                    res += 1\n            return res - self.num\n        else:\n            return self.n\n\n    def get_val(self, idx):\n        return self.segment_tree[self.num + idx]\n\n\ndef conv_to_int(x):\n    return 1 << (ord(x) - ord('a'))\n\n\ndef main():\n    n = int(input())\n    s = [conv_to_int(t) for t in list(input())]\n    q = int(input())\n    st = SegmentTree(n, lambda x, y: x | y, 0)\n    st.initialize(s)\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            st.update(int(query[1]) - 1, conv_to_int(query[2]))\n        else:\n            res = st.query(int(query[1]) - 1, int(query[2]))\n            ans = 0\n            while res:\n                ans += res & 1\n                res >>= 1\n            print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\ndef main():\n    n = ni()\n    s = list(input())\n    q = ni()\n\n    alphabet_idx = {}\n    for i in range(26):\n        alphabet_idx[i] = []\n\n    for i, si in enumerate(s):\n        alphabet_idx[ord(si) - ord(\"a\")].append(i)\n\n    for _ in range(q):\n        qi, a, b = input().split()\n        qi, a = int(qi), int(a)\n\n        if qi == 1:\n            a -= 1\n            if s[a] == b:\n                continue\n            current_char = ord(s[a]) - ord(\"a\")\n            del_idx = bisect.bisect_left(alphabet_idx[current_char], a)\n            del alphabet_idx[current_char][del_idx]\n\n            insert_idx = bisect.bisect_left(alphabet_idx[ord(b) - ord(\"a\")], a)\n            alphabet_idx[ord(b) - ord(\"a\")].insert(insert_idx, a)\n\n            s[a] = b\n\n        if qi == 2:\n            b = int(b)\n            a -= 1\n            b -= 1\n            ans = 0\n\n            for i in range(26):\n                a_idx = bisect.bisect_left(alphabet_idx[i], a)\n                if a_idx < len(alphabet_idx[i]):\n                    if alphabet_idx[i][a_idx] <= b:\n                        ans += 1\n\n            print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class SegmentTree:\n  \"\"\"Segmant Tree for query process.\n\n  Args:\n    a (List[int]): array.\n    identity (int): identity element with f.\n  \"\"\"\n  def __init__(self, a, identity=0):\n    self.a = a\n    self.n = len(a)\n    self.identity = identity\n    self.depth = (self.n - 1).bit_length()\n    self.segment = (1 << self.depth) - 1\n    self.tree = [identity] * (self.segment * 2 + 1)\n    self.tree[self.segment : self.n + self.segment] = a\n    for i in range(self.segment - 1, -1, -1):\n      self.tree[i] = self.f(self.tree[2*i+1], self.tree[2*i+2])\n\n  def update(self, i: int, x: int):\n    i += self.segment\n    self.tree[i] = x\n    while i:\n      i = (i - 1) // 2\n      self.tree[i] = self.f(self.tree[2*i+1], self.tree[2*i+2])\n\n  def query(self, l: int, r: int) -> int:\n    \"\"\"Query at [l, r]\n\n    Args:\n      l (int): left\n      r (int): right\n\n    Returns:\n      int: result\n    \"\"\"\n    if l > r:\n      return self.identity\n    l += self.segment\n    r += self.segment\n    res = self.identity\n    while l <= r:\n      if not l & 1:\n        res = self.f(self.tree[l], res)\n      if r & 1:\n        res = self.f(res, self.tree[r])\n      l = l // 2\n      r = (r - 2) // 2\n    return res\n\n  def f(self, x: int, y: int) -> int:\n    return x | y\n\nn = int(input())\ns = input()\nq = int(input())\na = ord('a')\nsegment_tree = SegmentTree([1 << (ord(c) - a) for c in s])\nfor _ in range(q):\n  query = input().split()\n  if query[0] == '1':\n    i = int(query[1]) - 1\n    c = query[2]\n    segment_tree.update(i, 1 << (ord(c) - a))\n  else:\n    l = int(query[1]) - 1\n    r = int(query[2]) - 1\n    bit = segment_tree.query(l, r)\n    print(format(bit, 'b').count('1'))", "class SegmentTree():\n    \"\"\"A segment Tree.\n\n    This is a segment tree without recursions.\n    This can support queries as follows:\n     - update a single value in O(logN).\n     - get the folded value of values in a segment [l, r) in O(logN)\n    N is the length of the given iterable value.\n\n    Parameters\n    ----------\n    iterable : Iterable[_T]\n        An iterable value which will be converted into a segment tree\n    func : Callable[[_T, _T], _T]\n        A binary function which returns the same type as given two.\n        This has to satisfy the associative law:\n            func(a, func(b, c)) = func(func(a, b), c)\n    e : _T\n        The identity element of the given func.\n        In other words, this satisfies:\n            func(x, e) = func(e, x) = x\n    \"\"\"\n    \n    def __init__(self, iterable, func, e):\n        self.func = func\n        self.e = e\n\n        ls = list(iterable)\n        self.n = 1 << len(ls).bit_length()\n        ls.extend( [self.e] * (self.n - len(ls)) )\n\n        self.data = [self.e] * self.n + ls\n        for i in range(self.n-1, 0, -1):\n            self.data[i] = self.func(self.data[2*i], self.data[2*i+1])\n\n    def replace(self, index, value):\n        \"\"\"replace the old value of the given index with the given new value.\n\n        This replaces the old value of the given index with the given new value in O(logN).\n        This is like \"list[index] = value\".\n\n        Parameters\n        ----------\n        index : int\n            The index of the value which will be replaced.\n        value : _T\n            The new value with which the old value will be replaced.\n        \"\"\"\n        index += self.n\n        self.data[index] = value\n        index //= 2\n        while index > 0:\n            self.data[index] = self.func(self.data[2*index], self.data[2*index+1])\n            index //= 2\n        \n    def folded(self, l, r):\n        \"\"\"get the folded value of values in a segment [l, r).\n\n        This get the folded value of values in a segment [l, r) in O(logN).\n        If func is add, it returns the sum of values in [l, r).\n        In other words, this is eqivalent to \"sum(list[l:r])\".\n        If func is other functions, then this is equivalent to \"accumulate(list[l:r], func)\".\n\n        Parameters\n        ----------\n        l : int\n            The left edge.\n        r : int\n            The right edge.\n\n        Returns\n        -------\n        _T(the same type as the type of the element of the given iterable)\n            This is equivalent to func(list[l], func(list[l+1], ... ) ).\n            If func is represented as '*', then it's:\n            list[l] * list[l+1] * ... * list[r-1] \n        \"\"\"\n\n        left_folded = self.e\n        right_folded = self.e\n        l += self.n\n        r += self.n\n        while l < r:\n            if l % 2:\n                left_folded = self.func(left_folded, self.data[l])\n                l += 1\n            if r % 2:\n                r -= 1\n                right_folded = self.func(self.data[r], right_folded)\n            l //= 2\n            r //= 2\n        \n        return self.func(left_folded, right_folded)\n\n\nfrom operator import or_\n\nN = int(input())\nS = input()\n\nls = [1 << (ord(c) - ord('a')) for c in S]\nsegtree = SegmentTree(ls, or_, 0)\n\nQ = int(input())\nfor _ in range(Q):\n    s = input()\n    if s[0] == '1':\n        i, c = s[2:].split()\n        segtree.replace(int(i)-1, 1 << (ord(c) - ord('a')))\n    else:\n        l, r = list(map(int, s[2:].split()))\n        value = segtree.folded(l-1, r)\n        print((format(value, 'b').count('1')))\n", "from operator import or_\n\nclass SegmentTree:\n    def __init__(self, size, op, e):\n        self._op = op\n        self._e = e\n        self._size = size\n        t = 1 << (size - 1).bit_length()\n        self._offset = t - 1\n        self._data = [e] * (t * 2 - 1)\n \n    def __getitem__(self, key):\n        return self._data[self._offset + key]\n \n    def __setitem__(self, key, value):\n        op = self._op\n        data = self._data\n        i = self._offset + key\n        data[i] = value\n        while i >= 1:\n            i = (i - 1) // 2\n            data[i] = op(data[i * 2 + 1], data[i * 2 + 2])\n \n    def build(self, iterable):\n        op = self._op\n        data = self._data\n        data[self._offset:self._offset + self._size] = iterable\n        for i in range(self._offset - 1, -1, -1):\n            data[i] = op(data[i * 2 + 1], data[i * 2 + 2])\n \n    def query(self, start, end):\n        op = self._op\n        res = self._e\n        l = self._offset + start\n        r = self._offset + end\n        while l < r:\n            if l & 1 == 0:\n                res = op(res, self._data[l])\n            if r & 1 == 0:\n                res = op(res, self._data[r - 1])\n            l = l // 2\n            r = (r-1) // 2\n        return res\n\ndef str2bit(c):\n  return 1 << (ord(c) - ord('a'))\n\nN = int(input())\nS = input()\n\nst = SegmentTree(N, or_, 0)\nst.build(str2bit(x) for x in S)\n\nM = int(input())\nfor i in range(M):\n  q, a, b = input().split()\n  if q == \"1\":\n    st[int(a)-1] = str2bit(b)\n  elif q == \"2\":\n    print(bin(st.query(int(a)-1,int(b))).count(\"1\"))", "class SegmentTree:\n    \"\"\"\n    0-indexed\n    query : [L, R)\n    \"\"\"\n    def __init__(self, size, initValue):\n        self.size = 1 << (size.bit_length())  # \u5b8c\u5168\u4e8c\u5206\u6728\u306b\u3059\u308b\n        self.data = [initValue] * (2 * self.size - 1)\n        self.initValue = initValue\n\n    def cmpFunc(self, left, right):\n        return left | right\n\n    def build(self, rawData):\n        self.data[self.size - 1: self.size - 1 + len(rawData)] = rawData\n        for i in range(self.size - 1)[:: -1]:\n            self.data[i] = self.cmpFunc(self.data[2 * i + 1], self.data[2 * i + 2])\n\n    def update(self, index, value):\n        index += self.size - 1\n        self.data[index] = value\n        while index >= 0:\n            index = (index - 1) // 2\n            self.data[index] = self.cmpFunc(self.data[2 * index + 1], self.data[2 * index + 2])\n\n    def query(self, left, right):\n        L = left + self.size\n        R = right + self.size\n        ret = self.initValue\n        while L < R:\n            if R & 1:\n                R -= 1\n                ret = self.cmpFunc(ret, self.data[R - 1])\n            if L & 1:\n                ret = self.cmpFunc(ret, self.data[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return ret\n\ndef cToI(s):\n    return ord(s) - ord('a')\n\nN = int(input())\nS = list(map(cToI, input()))\n\nS = [1 << s for s in S]\ntree = SegmentTree(N, 0)\ntree.build(S)\n\nQ = int(input())\nans = []\nfor _ in range(Q):\n    q1, q2, q3 = input().split()\n\n    if q1 == '1':\n        tree.update(int(q2) - 1, 1 << cToI(q3))\n    else:\n        ans.append(tree.query(int(q2) - 1, int(q3)))\n\nfor a in ans:\n    cnt = 0\n    while a > 0:\n        cnt += a % 2\n        a //= 2\n    print(cnt)\n", "import bisect\n\nN=int(input())\nS=list(str(input()))\n\ndef ci(x):\n  return \"abcdefghijklmnopqrstuvwxyz\".find(x)\n\nd=[[] for _ in range(26)]\nfor i,s in enumerate(S):\n  d[ci(s)].append(i)\n\nfor i in range(int(input())):\n  t,x,y=input().split()\n  if t==\"1\":\n    x=int(x)-1\n    if S[x]!=y:\n      l=bisect.bisect_left(d[ci(S[x])],x)\n      d[ci(S[x])].pop(l)\n      bisect.insort(d[ci(y)],x)\n      S[x]=y\n  else:\n    x,y=int(x)-1,int(y)-1\n    c=0\n    for j in range(26):\n      l=bisect.bisect_left(d[j],x)\n      if l<len(d[j]) and d[j][l] <= y:\n        c += 1\n    print(c)\n", "import bisect\nn = int(input())\ns = list(input())\nalp = 'abcdefghijklmnopqrstuvwxyz'\ncnt = {c: [] for c in alp}\n\nfor i, c in enumerate(s):\n    cnt[c].append(i)\n\nq = int(input())\nfor _ in range(q):\n    t, x, y = input().split()\n    ans = 0\n    if t == '1':\n        i, c = int(x) - 1, y\n        if s[i] == c:\n            continue\n        a = bisect.bisect_left(cnt[s[i]], i)\n        cnt[s[i]].pop(a)\n        s[i] = c\n        b = bisect.bisect_left(cnt[c], i)\n        cnt[c].insert(b, i)\n    else:\n        l, r = int(x) - 1, int(y) - 1\n        for c in alp:\n            a = bisect.bisect_left(cnt[c], l)\n            if a < len(cnt[c]) and cnt[c][a] <= r:\n                ans += 1\n\n        print(ans)", "from bisect import insort_left, bisect_left\nN = int(input())\nS = list(input())\nQ = int(input())\nQuery = [input() for _ in range(Q)]\ndic = {chr(i+ord(\"a\")):[] for i in range(26)}\nfor i, s in enumerate(S):\n    dic[s].append(i)\nfor q in Query:\n    t,a,b = q.split()\n    a = int(a)-1\n    if(t == \"1\"):\n        if(S[a]==b):\n            continue\n        tmp_index = bisect_left(dic[S[a]],a)\n        dic[S[a]].pop(tmp_index)\n        insort_left(dic[b],a)\n        S[a] = b\n    elif(t == \"2\"):\n        b = int(b)-1\n        cnt = 0\n        for li in dic.values():\n            if li and a<=li[-1] and li[bisect_left(li, a)] <= b:\n                cnt += 1\n        print(cnt)", "#!python3\n\nimport sys\n\niim = lambda: map(int, input().rstrip().split())\n\ndef resolve():\n    N = int(input())\n    S = list(input())\n    Q = int(input())\n\n    c0 = ord('a')\n    smap = [1<<(i-c0) for i in range(c0, ord('z')+1)]\n\n    T = [0]*N + [smap[ord(S[i])-c0] for i in range(N)]\n\n    for i in range(N-1, 0, -1):\n        i2 = i << 1\n        T[i] = T[i2] | T[i2|1]\n\n    ans = []\n    #print(T)\n    for cmd, i, j in zip(*[iter(sys.stdin.read().split())]*3):\n        i = int(i) - 1\n        if cmd == \"1\":\n            if S[i] == j:\n                continue\n\n            S[i] = j\n            i0 = N + i\n            T[i0] = smap[ord(j)-c0]\n            while i0 > 1:\n                i0 = i0 >> 1\n                T[i0] = T[i0+i0] | T[i0-~i0]\n        elif cmd == \"2\":\n            i += N\n            j = int(j) + N\n\n            d1 = 0\n            while i < j:\n                if i & 1:\n                    d1 |= T[i]\n                    i += 1\n                if j & 1:\n                    j -= 1\n                    d1 |= T[j]\n\n                i >>= 1; j >>=1\n\n            ans.append(bin(d1).count('1'))\n\n    print(*ans, sep=\"\\n\")\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "def solve():\n    import sys\n    input = sys.stdin.readline\n\n    ordA = ord('a')\n\n    N = int(input())\n    Ss = input().strip()\n    nos = [ord(S)-ordA for S in Ss]\n    Q = int(input())\n\n    idEle = 0\n    def _binOpe(x, y):\n        return x | y\n    def makeSegTree(numEle):\n        numPow2 = 2 ** (numEle-1).bit_length()\n        data = [idEle] * (2*numPow2)\n        return data, numPow2\n    def setInit(As):\n        for iST, A in enumerate(As, numPow2):\n            data[iST] = A\n        for iST in reversed(list(range(1, numPow2))):\n            data[iST] = _binOpe(data[2*iST], data[2*iST+1])\n    def _update1(iA, A):\n        iST = iA + numPow2\n        data[iST] = A\n    def update(iA, A):\n        _update1(iA, A)\n        iST = iA + numPow2\n        while iST > 1:\n            iST >>= 1\n            data[iST] = _binOpe(data[2*iST], data[2*iST+1])\n    def getValue(iSt, iEn):\n        L = iSt + numPow2\n        R = iEn + numPow2\n        ans = idEle\n        while L < R:\n            if L & 1:\n                ans = _binOpe(ans, data[L])\n                L += 1\n            if R & 1:\n                R -= 1\n                ans = _binOpe(ans, data[R])\n            L >>= 1\n            R >>= 1\n        return ans\n\n    data, numPow2 = makeSegTree(N)\n\n    As = [(1<<no) for no in nos]\n    setInit(As)\n\n    anss = []\n    for _ in range(Q):\n        tp, v1, v2 = input().split()\n        if tp == '1':\n            pos = int(v1)-1\n            c = ord(v2)-ordA\n            update(pos, 1<<c)\n        else:\n            L, R = int(v1)-1, int(v2)-1\n            v = getValue(L, R+1)\n            ans = bin(v).count('1')\n            anss.append(ans)\n\n    print(('\\n'.join(map(str, anss))))\n\n\nsolve()\n", "#!python3\n\nimport sys\n\niim = lambda: map(int, input().rstrip().split())\n\ndef popcnt2(n):\n    a = (\n        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,\n    )\n    ans = 0\n    while n:\n        ans += a[n&0xff]\n        n >>= 8\n    return ans\n\ndef resolve():\n    N = int(input())\n    S = list(input())\n    Q = int(input())\n\n    c0 = ord('a')\n    smap = [1<<(i-c0) for i in range(c0, ord('z')+1)]\n\n    T = [0]*N + [smap[ord(S[i])-c0] for i in range(N)]\n\n    for i in range(N-1, 0, -1):\n        i2 = i << 1\n        T[i] = T[i2] | T[i2|1]\n\n    ans = []\n    #print(T)\n    for cmd, i, j in (line.split() for line in sys.stdin.readlines()):\n        i = int(i) - 1\n        if cmd == \"1\":\n            if S[i] == j:\n                continue\n\n            S[i] = j\n            i0 = N + i\n            T[i0] = smap[ord(j)-c0]\n            while i0 > 1:\n                i0 = i0 >> 1\n                T[i0] = T[i0+i0] | T[i0-~i0]\n        elif cmd == \"2\":\n            i += N\n            j = int(j) + N\n\n            d1 = 0\n            while i < j:\n                if i & 1:\n                    d1 |= T[i]\n                    i += 1\n                if j & 1:\n                    j -= 1\n                    d1 |= T[j]\n\n                i >>= 1; j >>=1\n\n            ans.append(popcnt2(d1))\n\n    print(*ans, sep=\"\\n\")\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "def segfunc(x, y):\n    return (x | y)\n\n\nide_ele = 0\n\n\nclass SegTree:\n    \"\"\"\n    init(init_val, ide_ele): \u914d\u5217init_val\u3067\u521d\u671f\u5316 O(N)\n    update(k, x): k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0 O(logN)\n    query(l, r): \u533a\u9593[l, r)\u3092segfunc\u3057\u305f\u3082\u306e\u3092\u8fd4\u3059 O(logN)\n    \"\"\"\n\n    def __init__(self, init_val, segfunc, ide_ele):\n        \"\"\"\n        init_val: \u914d\u5217\u306e\u521d\u671f\u5024\n        segfunc: \u533a\u9593\u306b\u3057\u305f\u3044\u64cd\u4f5c\n        ide_ele: \u5358\u4f4d\u5143\n        n: \u8981\u7d20\u6570\n        num: n\u4ee5\u4e0a\u306e\u6700\u5c0f\u306e2\u306e\u3079\u304d\u4e57\n        tree: \u30bb\u30b0\u30e1\u30f3\u30c8\u6728(1-index)\n        \"\"\"\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # \u914d\u5217\u306e\u5024\u3092\u8449\u306b\u30bb\u30c3\u30c8\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        # \u69cb\u7bc9\u3057\u3066\u3044\u304f\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        \"\"\"\n        k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0\n        k: index(0-index)\n        x: update value\n        \"\"\"\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)\u306esegfunc\u3057\u305f\u3082\u306e\u3092\u5f97\u308b\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n\nn = int(input())\ns = input()\nq = int(input())\n\nls = []\n\nfor ch in s:\n    ls.append(1 << (ord(ch) - 97))\n\nseg = SegTree(ls, segfunc, ide_ele)\n\nfor i in range(q):\n    que = input().split()\n    if que[0] == '1':\n        iq = int(que[1])\n        cq = que[2]\n        seg.update(iq-1, 1 << (ord(cq) - 97))\n    else:\n        lq = int(que[1])\n        rq = int(que[2])\n        ret = seg.query(lq-1, rq)\n        print((str(bin(ret)).count('1')))\n", "from collections import defaultdict\nfrom bisect import bisect_left, bisect_right, insort_left, insort_right\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    S = list(input())\n    q = int(input())\n    Q = [input() for _ in range(q)]\n\n    dd = defaultdict(list)  # \u5404\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u304c\u51fa\u73fe\u3059\u308b\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092dd\u306b\u767b\u9332\n    for i in range(ord('a'), ord('z') + 1):\n        dd[chr(i)] = []\n    for i, st in enumerate(S):\n        dd[st].append(i)\n\n    ans = []\n    for q in Q:\n        t, a, b = q.split()\n        a = int(a) - 1\n        if int(t) == 1:\n            if S[a] == b: continue\n            # \u4e8c\u5206\u63a2\u7d22\u3067\u8a72\u5f53\u3059\u308b\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u53d6\u5f97\n            id = bisect_left(dd[S[a]], a)\n            dd[S[a]].pop(id)  # \u53d6\u3063\u3066\u304f\u308b\n            insort_left(dd[b], a)  # \u65b0\u898f\u306b\u633f\u5165\u3059\u308b\n            S[a] = b\n        else:\n            b = int(b) - 1\n            cnt = 0\n            for l in dd.values():\n                # li\u306e\u4e2d\u8eab\u304c\u5b58\u5728\u3057\uff0c\n                # \u305d\u306e\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u306e\u6700\u5f8c\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u304c\u6307\u5b9a\u3055\u308c\u3066\u3044\u308b\u6700\u521d\u306eindex\u3088\u308a\u3082\u5927\u304d\u304f\uff0e\n                # a\u4ee5\u4e0a\u306e\u6700\u521d\u306eindex\u304cb\u4ee5\u4e0b\u306e\u6642\u306f\uff0c\u305d\u306e\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u306e\u5b58\u5728\u306f\u4fdd\u8a3c\u3055\u308c\u308b\n                if l and a <= l[-1] and l[bisect_left(l, a)] <= b:\n                    cnt += 1\n            ans.append(cnt)\n    print(*ans, sep='\\n')\n\ndef __starting_point():\n    main()\n__starting_point()", "from bisect import bisect_left,insort_left\nn=int(input())\ns=list(input())\nlindex=[[] for _ in range(26)]\nfor i in range(n):\n  lindex[ord(s[i])-97].append(i)\nq=int(input())\nfor i in range(q):\n  q1,q2,q3=input().split()\n  if q1=='1':\n    q2=int(q2)-1\n    idx=bisect_left(lindex[ord(s[q2])-97],q2)\n    if s[q2]!=q3:\n      del lindex[ord(s[q2])-97][idx]\n      insort_left(lindex[ord(q3)-97],q2)\n      s[q2]=q3\n  else:\n    l=int(q2)-1\n    r=int(q3)-1\n    cnt=0\n    for j in range(26):\n      if len(lindex[j])==0:\n        continue\n      idx=bisect_left(lindex[j],l)\n      if len(lindex[j])>idx and lindex[j][idx]<=r:\n        cnt+=1\n    print(cnt)", "from bisect import insort_left, bisect_left\nn = int(input())\ns = list(input())\nQ = int(input())\nquery = [input() for _ in range(Q)]\ndic = {chr(i+ord('a')):[] for i in range(26)}\nfor ind, c in enumerate(s):\n    dic[c].append(ind)\n\nfor q in query:\n    t, a, b = q.split()\n    a = int(a)-1\n    if t=='1':\n        if s[a]==b:\n            continue\n        ind = bisect_left(dic[s[a]], a)\n        dic[s[a]].pop(ind)\n        insort_left(dic[b], a)\n        s[a] = b\n    else:\n        b = int(b)-1\n        tmp = 0\n        for li in list(dic.values()):\n            if li and a<=li[-1] and li[bisect_left(li, a)] <= b:\n                tmp += 1\n        print(tmp)\n", "import bisect\nn = int(input().strip())\nS = list(input().strip())\nL=[[] for _ in range(26)]\nfor i,s in enumerate(S):\n    L[ord(s)-ord(\"a\")].append(i)\n\nq = int(input().strip())\nfor _ in range(q):\n    query=input().strip().split()\n    if query[0]==\"1\":\n        i=int(query[1])\n        i-=1\n        c=query[2]\n        if S[i]!=c:\n            delInd=bisect.bisect_left(L[ord(S[i])-ord(\"a\")],i)\n            del L[ord(S[i])-ord(\"a\")][delInd]\n            bisect.insort(L[ord(c)-ord(\"a\")], i)\n            S[i]=c\n    else:\n        l,r=map(int,[query[1],query[2]])\n        l-=1; r-=1\n        ans=0\n        for j in range(26):\n            ind=bisect.bisect_left(L[j],l)\n            if ind<len(L[j]) and L[j][ind]<=r:\n                ans+=1\n        print(ans)", "#!python3\n\nimport sys\n\ninput = sys.stdin.readline\n\ndef resolve():\n    N = int(input())\n    S = list(input())\n    Q = int(input())\n\n    c0 = ord('a')\n    smap = [1<<(i-c0) for i in range(c0, ord('z')+1)]\n\n    T = [0]*N + [smap[ord(S[i])-c0] for i in range(N)]\n\n    for i in range(N-1, 0, -1):\n        i2 = i << 1\n        T[i] = T[i2] | T[i2|1]\n\n    ans = []\n    #print(T)\n    for cmd, i, j in zip(*[iter(sys.stdin.read().split())]*3):\n        i = int(i) - 1\n        if cmd == \"1\":\n            if S[i] == j:\n                continue\n\n            S[i] = j\n            i0 = N + i\n            T[i0] = smap[ord(j)-c0]\n            while i0 > 1:\n                i0 = i0 >> 1\n                T[i0] = T[i0+i0] | T[i0-~i0]\n        elif cmd == \"2\":\n            i += N\n            j = int(j) + N\n\n            d1 = 0\n            while i < j:\n                if i & 1:\n                    d1 |= T[i]\n                    i += 1\n                if j & 1:\n                    j -= 1\n                    d1 |= T[j]\n\n                i >>= 1; j >>=1\n\n            ans.append(bin(d1).count('1'))\n\n    print(*ans, sep=\"\\n\")\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "class SegmentTree():\n    '''\n    \u975e\u518d\u5e30\n    segment tree\n    '''\n\n    def __init__(self, n, func, init=float('inf')):\n        '''\n        n->\u914d\u5217\u306e\u9577\u3055\n        func:func(a,b)->val,\u3000func=min\u3060\u3068RMQ\u306b\u306a\u308b\n        \u6728\u306e\u9ad8\u3055h\u3068\u3059\u308b\u3068,\n        n:h-1\u307e\u3067\u306e\u30ce\u30fc\u30c9\u6570\u3002h\u6bb5\u76ee\u306e\u30ce\u30fc\u30c9\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u305f\u3081\u306b\u4f7f\u3046\u3002\n        data:\u30ce\u30fc\u30c9\u3002\n        parent:k->child k*2+1\u3068k*2+2\n        '''\n        self.n = 2**(n-1).bit_length()\n        self.init = init\n        self.data = [init]*(2*self.n)\n        self.func = func\n\n    def set(self, k, v):\n        '''\n        \u3042\u305f\u3044\u306e\u521d\u671f\u5316\n        '''\n        self.data[k+self.n-1] = v\n\n    def build(self):\n        '''\n        set\u306e\u5f8c\u306b\u4e00\u6589\u66f4\u65b0\n        '''\n        for k in reversed(list(range(self.n-1))):\n            self.data[k] = self.func(self.data[k*2+1], self.data[k*2+2])\n\n    def update(self, k, a):\n        '''\n        list[k]=a\u306b\u66f4\u65b0\u3059\u308b\u3002\n        \u66f4\u65b0\u3076\u3093\u3092root\u307e\u3067\u66f4\u65b0\n        '''\n        k += self.n-1\n        self.data[k] = a\n\n        while k > 0:\n            k = (k-1)//2\n            self.data[k] = self.func(self.data[k*2+1], self.data[k*2+2])\n\n    def query(self, l, r):\n        '''\n        [l,r)\u306efunc\u3092\u6c42\u3081\u308b\n        '''\n        L = l+self.n\n        R = r+self.n\n        ret = self.init\n        while L < R:\n            if R & 1:\n                R -= 1\n                ret = self.func(ret, self.data[R-1])\n            if L & 1:\n                ret = self.func(ret, self.data[L-1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return ret\n\n\nN = int(input())\nS = input()\nQ = int(input())\nqueries = [list(input().split()) for _ in range(Q)]\n\n\ndef lam(x, y):\n    return x | y\n\n\ndef a2n(a):\n    return ord(a)-ord(\"a\")\n\n\ndef createInp(n):\n    return 1 << n\n\n\nSeg = SegmentTree(len(S), lam, init=0)\nfor i, s in enumerate(S):\n    Seg.set(i, createInp(a2n(s)))\nSeg.build()\n\nfor q, l, r in queries:\n    if q == \"1\":\n        Seg.update(int(l)-1, createInp(a2n(r)))\n    else:\n        print((bin(Seg.query(int(l)-1, int(r))).count('1')))\n", "class Segment_tree():\n    def __init__(self, n, s):\n        self.alphabet_list = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n        self.key = dict()\n        self.k = 1\n        for value in self.alphabet_list:\n            self.key[value] = self.k\n            self.k *= 2\n        self.inf = pow(2, 32)\n        self.n = n\n        self.s = s\n        self.N = 1\n        while self.N < self.n:\n            self.N *= 2\n        self.size = self.N * 2\n        self.size -= 1\n        self.N -= 1\n        self.segment = [0]*(self.N) + [self.key[self.s[i]] for i in range(self.n)] + [0]*(self.size-self.N-self.n)\n        for i in range(self.N-1, -1, -1):\n            self.segment[i] = self.segment[2*i+1]|self.segment[2*i+2]\n\n    def update(self, i, x):\n        i += (self.N-1)\n        self.segment[i] = self.key[x]\n        while i > 0:\n            i = (i-1)//2\n            self.segment[i] = self.segment[2*i+1]|self.segment[2*i+2]\n        \n    def find(self, a, b, k, l, r):\n        if r <= a or b <= l:\n            return 0\n        elif a <= l and r <= b:\n            return self.segment[k]\n        else:\n            find_l = self.find(a, b, 2*k+1, l, (l+r)//2)\n            find_r = self.find(a, b, 2*k+2, (l+r)//2, r)\n            return find_l|find_r\n\n\nn = int(input())\ns = input()\nsegment = Segment_tree(n, s)\nq = int(input())\nN = 1\nwhile N < n:\n  N *= 2\nfor i in range(q):\n    quer = [x for x in input().split()]\n    if quer[0] == \"1\":\n        i, c = int(quer[1]), quer[2]\n        segment.update(i, c)\n    else:\n        l, r = int(quer[1]), int(quer[2])\n        key = segment.find(l-1, r, 0, 0, N)\n        ans = 0\n        for i in range(26):\n            if (key>>i)&1:\n                ans += 1\n        print(ans)", "n = int(input())\ns = list(input())\n\ndic = {}\nfor i in range(26):\n    dic[chr(i+97)] = []\n\nfor i in range(n):\n    dic[s[i]].append(i)\n\nfor i in range(26):\n    dic[chr(i+97)].append(float('inf'))\n\nfrom bisect import bisect_left\nq = int(input())\nfor i in range(q):\n    x, y, z = input().split()\n    if x == '1':\n        y = int(y) - 1\n        p = bisect_left(dic[s[y]], y)\n        dic[s[y]].pop(p)\n        dic[z].insert(bisect_left(dic[z], y), y)\n        s[y] = z\n    else:\n        res = 0\n        y, z = int(y) - 1, int(z) - 1\n        for i in range(26):\n            p = dic[chr(i+97)][bisect_left(dic[chr(i+97)], y)]\n            if p <= z:\n                res += 1\n        print(res)", "class SegTree:\n    def __init__(self, N, S):\n        self.N = 2 ** ((N-1).bit_length())\n        self.tree = [0 for i in range(self.N * 2 - 1)]\n        for i in range(len(S)):\n            self.tree[self.N - 1 + i] = 1 << (ord(S[i]) - ord(\"a\"))\n\n        for i in range(self.N - 2, -1, -1):\n            self.tree[i] = self.tree[i*2 + 1] | self.tree[i*2 + 2]\n\n    def update(self, index, char):\n        i = self.N - 1 + index\n        # \u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u304c\u3042\u308b = bit\u304c\u7acb\u3063\u3066\u3044\u308b\n        self.tree[i] = 1 << (ord(char) - ord(\"a\"))\n        while i > 0:\n            i = (i-1) // 2\n            self.tree[i] = self.tree[i*2 + 1] | self.tree[i*2 + 2]\n\n    def get(self, a, b):\n        return self.query(a, b, 0, 0, self.N)\n\n    # k : \u30ce\u30fc\u30c9\u306e\u756a\u53f7\n    # l : \u30ce\u30fc\u30c9k\u306e\u53d7\u3051\u6301\u3064\u533a\u9593\n    # r : \u30ce\u30fc\u30c9k\u306e\u53d7\u3051\u6301\u3064\u533a\u9593\n    def query(self, a, b, k, l, r):\n        if r <= a or b <= l: # \u533a\u9593\u5916\n            return 0\n        elif a <= l and r <= b: # \u53d7\u3051\u6301\u3061\u533a\u9593\u306f\u5b8c\u5168\u306b\u542b\u307e\u308c\u3066\u3044\u308b\n            return self.tree[k]\n        else: # \u4e00\u90e8\u542b\u307e\u308c\u3066\u308b\n            left = self.query(a, b, 2 * k + 1, l, (l+r)//2)\n            right = self.query(a, b, 2 * k + 2, (l+r)//2, r)\n            return left | right\n\ndef solve():\n    N = int(input())\n    S = list(input().strip())\n    tree = SegTree(N, S)\n\n    Q = int(input())\n    for _ in range(Q):\n        t_q, in_1, in_2 = input().split()\n        if t_q == \"1\":\n            i_q = int(in_1)\n            c_q = in_2\n            tree.update(i_q-1, c_q)\n        else:\n            l_q = int(in_1)\n            r_q = int(in_2)\n            print(bin(tree.get(l_q-1, r_q)).count(\"1\"))\n\nsolve()", "import sys\ndef input(): return sys.stdin.readline().rstrip()\n\n\nclass SegTree:\n    X_unit = 0\n\n    def __init__(self, N, X_f=min):\n        self.N = N\n        self.X = [self.X_unit] * (N + N)\n        self.X_f = X_f\n\n    def build(self, seq):\n        for i, x in enumerate(seq, self.N):\n            self.X[i] = x\n        for i in range(self.N - 1, 0, -1):\n            self.X[i] = self.X_f(self.X[i << 1], self.X[i << 1 | 1])\n\n    def set_val(self, i, x):\n        i += self.N\n        self.X[i] = x\n        while i > 1:\n            i >>= 1\n            self.X[i] = self.X_f(self.X[i << 1], self.X[i << 1 | 1])\n\n    def fold(self, L, R):\n        L += self.N\n        R += self.N\n        vL = self.X_unit\n        vR = self.X_unit\n        while L < R:\n            if L & 1:\n                vL = self.X_f(vL, self.X[L])\n                L += 1\n            if R & 1:\n                R -= 1\n                vR = self.X_f(self.X[R], vR)\n            L >>= 1\n            R >>= 1\n        return self.X_f(vL, vR)\n\n\ndef orr(x, y):\n    return x | y\n\n\ndef main():\n    N = int(input())\n    S = input()\n    S = list(map(lambda c: 2**(ord(c) - ord('a')), list(S)))\n    Q = int(input())\n    seg = SegTree(N, orr)\n    seg.build(S)\n    for _ in range(Q):\n        num, x, y = input().split()\n        if num == '1':\n            seg.set_val(int(x)-1, 2**(ord(y) - ord('a')))\n        else:\n            bits=seg.fold(int(x)-1, int(y))\n            print(sum(map(int, list(bin(bits))[2:])))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "class SegmentTree(object):\n    def __init__(self, sequence, function, identify):\n        N = len(sequence)\n        self.length = (1 << (N - 1)).bit_length()\n        self.function = function\n        self.data = [identify] * (self.length << 1)\n        self.identify = identify\n        # set values\n        for i in range(N):\n            self.data[i + self.length - 1] = sequence[i]\n        # build\n        for i in range(self.length - 2, -1, -1) :\n            self.data[i] = self.function(self.data[(i << 1) + 1], self.data[(i << 1) + 2])\n\n    def update(self, idx, x):\n        idx += self.length - 1\n        self.data[idx] = x\n        while idx:\n            idx = (idx - 1) >> 1\n            self.data[idx] = self.function(self.data[(idx << 1) + 1], self.data[(idx << 1) + 2])\n\n    def query(self, p, q):\n        if q <= p:\n            return self.identify\n        p += self.length - 1\n        q += self.length - 2\n        res = self.identify\n        while q - p > 1:\n            if not p & 1:\n                res = self.function(res, self.data[p])\n            if q & 1:\n                res = self.function(res, self.data[q])\n                q -= 1\n            p >>= 1\n            q = (q - 1) >> 1\n        return self.function(res, self.data[p]) if p == q else self.function(self.function(res, self.data[p]), self.data[q])\n\ndef popcount(x):\n    x = x - ((x >> 1) & 0x5555555555555555)\n    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    x = x + (x >> 32)\n    return x & 0x0000007f\n\n\nN = int(input())\nS = input()\natoi = {chr(ord(\"a\") + d): 1 << d for d in range(26)}\ndata = [atoi[c] for c in (S)]\nseg_tree = SegmentTree(data, lambda a, b: a | b, 0)\nQ = int(input())\nfor _ in range(Q):\n    q, a, b = input().split()\n    if q == \"1\":\n        idx = int(a) - 1\n        seg_tree.update(idx, atoi[b])\n    else:\n        print(popcount(seg_tree.query(int(a) - 1, int(b))))", "from bisect import bisect_left,bisect_right,insort\n\nn = int(input())\ns = list(\"-\" + str(input()))\nlis = [[] for i in range(26)]\nfor i in range(1,n+1):\n    num = ord(s[i])-ord(\"a\")\n    lis[num].append(i)\n\nq = int(input())\nfor turn in range(q):\n    query = list(map(str,input().split()))\n    if query[0] == \"1\":\n        a = int(query[1])\n        if s[a] == query[2]:\n            continue\n        num = ord(s[a])-ord(\"a\")\n        lis[num].pop(bisect_left(lis[num],a))\n        next = ord(query[2])-ord(\"a\")\n        insort(lis[next],a)\n        s[a] = query[2]\n    else:\n        a,b = int(query[1]),int(query[2])\n        ans = 0\n        for alphabet in range(26):\n            if bisect_right(lis[alphabet],b)-bisect_left(lis[alphabet],a) >= 1:\n                ans += 1\n        print(ans)", "# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.readline\n#from heapq import heappop, heappush\nfrom collections import defaultdict\n#from itertools import combinations\nsys.setrecursionlimit(10**7)\nimport math\nclass SegTree():\n    '''\n    input idx: 1-\n    '''\n    def __init__(self, n, init_val=0):\n        self.n = n\n        self.init_val = init_val\n        self.n_leaf = 2 ** math.ceil(math.log2(n))\n        self.bins = [init_val] * (self.n_leaf * 2)\n\n    def val_append(self, A):\n        '''\n        :param A:\n        :return:\n        '''\n        if len(A) != self.n:\n            raise ValueError('The number of input should be same with n_leaf')\n        for i,a in enumerate(A):\n            self.bins[self.n_leaf+i]=a\n        self._calc()\n        return None\n\n    def _calc(self):\n        '''\n        Calculate all bins based on values of leaves\n        '''\n        i = self.n_leaf - 1\n        while i > 0:\n            self.bins[i] = self._criteria(self.bins[i*2], self.bins[i*2+1])\n            i -= 1\n        return None\n\n    def _criteria(self, x, y):\n        '''\n        Define criteria between 2 nodes\n        '''\n        return x | y\n\n    def eval_between(self, x, y):\n        '''\n        x, y : node-idx(1-)\n        '''\n        l, r = x + self.n_leaf - 1, y + self.n_leaf - 1\n        ret = self._criteria(self.bins[l], self.bins[r])\n        while l < r:\n            if l % 2 == 1:\n                ret = self._criteria(self.bins[l], ret)\n                l += 1\n                continue\n\n            if r % 2 == 0:\n                ret = self._criteria(self.bins[r], ret)\n                r -= 1\n                continue\n            l = l//2\n            r = r//2\n            ret = self._criteria(self.bins[l], ret)\n            ret = self._criteria(self.bins[r], ret)\n\n        return ret\n\n    def update(self, node, pro):\n        '''\n        Replacement of the value in a leaf\n        '''\n        current = node + self.n_leaf - 1\n        self.bins[current] = pro\n        current //= 2\n        while current > 0:\n            self.bins[current] = self._criteria(self.bins[current*2+1], self.bins[current*2])\n            current //= 2\n        return None\n\ndef run():\n    N = int(input())\n    S = list(input())\n    Q = int(input())\n    queries = [sysread().split() for _ in range(Q)]\n\n    bins = [0] * N# a: ord('a') - 97\n    for i,s in enumerate(S):\n        id = ord(s) - 97\n        bins[i] = 1<<id\n\n    segtree = SegTree(N)\n    segtree.val_append(bins)\n\n    for type, i,c in queries:\n        if type == '1':\n            c = 1 << (ord(c) - 97)\n            segtree.update(int(i), c)\n        else:\n            i,c = int(i), int(c)\n            tmp = segtree.eval_between(i,c)\n            print(bin(tmp).count('1'))\n\ndef __starting_point():\n    run()\n__starting_point()", "# Segment tree (Bitwise Or)\nfrom operator import or_\n\n\nclass SegmentTree:\n    def __init__(self, size, op, e):\n        self._op = op\n        self._e = e\n        self._size = size\n        t = 1\n        while t < size:\n            t *= 2\n        self._offset = t - 1\n        self._data = [e] * (t * 2 - 1)\n\n    def __getitem__(self, key):\n        return self._data[self._offset + key]\n\n    def __setitem__(self, key, value):\n        op = self._op\n        data = self._data\n        i = self._offset + key\n        data[i] = value\n        while i >= 1:\n            i = (i - 1) // 2\n            data[i] = op(data[i * 2 + 1], data[i * 2 + 2])\n\n    def build(self, iterable):\n        op = self._op\n        data = self._data\n        data[self._offset:self._offset + self._size] = iterable\n        for i in range(self._offset - 1, -1, -1):\n            data[i] = op(data[i * 2 + 1], data[i * 2 + 2])\n\n    def query(self, start, stop):\n        def iter_segments(data, l, r):\n            while l < r:\n                if l & 1 == 0:\n                    yield data[l]\n                if r & 1 == 0:\n                    yield data[r - 1]\n                l = l // 2\n                r = (r - 1) // 2\n        op = self._op\n        it = iter_segments(self._data, start + self._offset,\n                           stop + self._offset)\n        result = self._e\n        for v in it:\n            result = op(result, v)\n        return result\n\n\ndef conv(c):\n    return 1 << (ord(c) - ord('a'))\n\n\nN = int(input())\nS = input()\n\nst = SegmentTree(N, or_, 0)\nst.build(conv(c) for c in S)\n\nQ = int(input())\nfor _ in range(Q):\n    q = input().split()\n    if q[0] == '1':\n        i, c = q[1:]\n        i = int(i) - 1\n        st[i] = conv(c)\n    elif q[0] == '2':\n        l, r = list(map(int, q[1:]))\n        print((bin(st.query(l - 1, r)).count('1')))\n", "import bisect  # \u914d\u5217\u4e8c\u5206\u6cd5\nfrom collections import defaultdict\n\nN = int(input())\nS = [*input()]\nQ = int(input())\nd = defaultdict(list)\n\n# \u5404\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u306e\u51fa\u73fe\u5834\u6240\u3092\u8a18\u9332\nfor i, c in enumerate(S):\n    d[c] += [i]\n\n# \u3053\u306e\u6642\u70b9\u3067\u3069\u306e\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u306b\u3064\u3044\u3066\u3082\u30bd\u30fc\u30c8\u6e08\u307f\n# print(d)\n\nfor _ in range(Q):\n    q, y, z = input().split()\n\n    if q == '1':\n        i = int(y) - 1  # \u6587\u5b57\u306e\u5909\u66f4\u4f4d\u7f6e\n\n        if S[i] == z: continue  # \u540c\u3058\u6587\u5b57\u306e\u5834\u5408\u306f\u51e6\u7406\u7d42\u4e86\n\n        # \u524a\u9664 O(N)\n        b = bisect.bisect(d[S[i]], i)  # 2\u5206\u6cd5\u3067 i \u306e\u51fa\u73fe\u4f4d\u7f6e\u3092(log N)\u3067\u63a2\u3059\n        d[S[i]].pop(b - 1)  # \u524a\u9664\n\n        # \u8ffd\u52a0 O(N) \u304b\u304b\u308b\uff1f\n        S[i] = z\n        bisect.insort(d[z], i) \n\n    else:\n        left = int(y) - 1\n        right = int(z) - 1\n\n        count = 0\n        for v in d.values():\n            count += 1 if bisect.bisect(v, right) - bisect.bisect_left(v, left) > 0 else 0\n\n        print(count)", "def main():\n    from bisect import bisect_left,bisect\n    n = int(input())\n    s = list(input())\n    q = int(input())\n    al=[[] for i in range(26)]\n    for i in range(n):\n        al[ord(s[i])-97].append(i)\n    ans = []\n    for i in range(q):\n        a , b , x = input().split()\n        if a == \"1\":\n            al[ord(s[int(b)-1])-97].pop(bisect_left(al[ord(s[int(b)-1])-97],int(b)-1))\n            al[ord(x)-97].insert(bisect_left(al[ord(x)-97],int(b)-1),int(b)-1)\n            s[int(b)-1] = x\n        elif a == \"2\":\n            b = int(b)-1\n            x = int(x)-1\n            cou = 0\n            for j in range(26):\n                l = bisect_left(al[j],b)\n                r = bisect(al[j],x)\n                if l != r:\n                    cou += 1\n            ans.append(cou)\n    for i in ans:\n        print(i)\n\ndef __starting_point():\n    main()\n__starting_point()", "import bisect\nimport sys\ndef input(): return sys.stdin.readline().rstrip()\n\nn = int(input())\ns = list(input())\nq = int(input())\n\nchar_idx = [[] for _ in range(26)]\nfor i in range(n):\n    char_idx[ord(s[i])-ord('a')].append(i)\n# print(char_idx)\n\nquery = [input().split() for _ in range(q)]\n# print(query)\n\nfor t, a, b in query:\n    if t=='1':\n        i = int(a) - 1\n        if s[i] == b:\n            continue\n        else:\n            idx = bisect.bisect_left(char_idx[ord(s[i])-ord('a')], i)\n            if char_idx[ord(s[i])-ord('a')][idx] == i:\n                del char_idx[ord(s[i])-ord('a')][idx]\n            bisect.insort_left(char_idx[ord(b)-ord('a')], i)\n            s[i] = b\n    else:\n        l = int(a) - 1\n        r = int(b) - 1\n        ans = 0\n        for i in range(26):\n            if len(char_idx[i]) == 0:\n                continue\n            it = bisect.bisect_left(char_idx[i], l)\n            if it < len(char_idx[i]) and char_idx[i][it] <= r:\n                ans += 1\n        print(ans)\n", "from bisect import bisect_left, insort_left\nN = int(input())\nS = [c for c in input()]\nQ = int(input())\nd = {i: [] for i in range(26)}\nfor i, c in enumerate(S):\n    d[ord(c) - ord(\"a\")].append(i)\n\n# print(d)\nfor _ in range(Q):\n    q = input().split()\n    if int(q[0]) == 1:\n        iq, cq = int(q[1]), q[2]\n        iq -= 1\n        if S[iq] == cq:\n            continue\n        else:\n            idx = bisect_left(d[ord(S[iq]) - ord(\"a\")], iq)\n            d[ord(S[iq]) - ord(\"a\")].pop(idx)\n            S[iq] = cq\n            insort_left(d[ord(cq) - ord(\"a\")], iq)\n    else:\n        l, r = int(q[1]), int(q[2])\n        l -= 1\n        ans = 0\n        for i in range(26):\n            idx = bisect_left(d[i], l)\n            if d[i] and l <= d[i][-1] and d[i][idx] < r:\n                ans += 1\n        print(ans)\n\n"]
["class family:\n    def __init__(self): self.names = {}        \n    def male(self, n): return self.setsex(n, 'm')        \n    def female(self, n): return self.setsex(n, 'f')        \n    def is_male(self, n): return self.names[n]['sex'] == 'm' if n in self.names else False\n    def is_female(self, n): return self.names[n]['sex'] == 'f' if n in self.names else False\n    def get_parents_of(self, n): return sorted(self.names[n]['childof']) if n in self.names else []\n    def get_children_of(self, n): return sorted(self.names[n]['parentof']) if n in self.names else []\n    \n    def updatesex(self):\n        for n in [n for n in self.names if len(self.names[n]['childof']) == 2]:\n            for a, b in [self.names[n]['childof'], self.names[n]['childof'][::-1]]:\n                if self.names[a]['sex'] and not self.names[b]['sex']:\n                    self.names[b]['sex'] = 'f' if self.names[a]['sex'] == 'm' else 'm'\n                    self.updatesex()\n                \n    def setsex(self, name, sex):\n        if name not in self.names: self.names[name] = {'sex':'', 'parentof':[], 'childof':[]}\n        if not self.names[name]['sex']: \n            self.names[name]['sex'] = sex\n            self.updatesex()    \n        \n        return self.names[name]['sex'] == sex\n        \n    def set_parent_of(self, c, p):\n        # Create child and/or parent if they do not exist\n        for n in [c, p]:        \n            if n not in self.names: self.names[n] = {'sex':'', 'parentof':[], 'childof':[]}\n\n        if p in self.names[c]['childof']: return True\n        if c == p or len(self.names[c]['childof']) == 2: return False\n        \n        # descendants and ancestors     \n        for tree, direction, name in [(self.names[c]['parentof'], 'parentof', p), (self.names[p]['childof'], 'childof', c)]:\n            while tree:\n                if name in tree: return False\n                tree = [e for d in tree for e in self.names[d][direction]]\n\n        if len(self.names[c]['childof']) == 1:\n            old_p, new_sex = self.names[c]['childof'][0], self.names[p]['sex'] \n            \n            if new_sex + self.names[old_p]['sex'] in ['mm', 'ff']: return False                \n\n            # Check for clashing parents\n            # Get all couple and create a putative sex dictionary S\n            couples = {tuple(self.names[n]['childof']) for n in self.names if len(self.names[n]['childof']) > 1} | {tuple((old_p, p))}\n                \n            S = {p:new_sex or 'm'}\n            while any(parent in S for couple in couples for parent in couple):\n                newcouples = []\n                for a, b in couples:\n                    if a in S or b in S:\n                        if b not in S: S[b] = 'f' if S[a] == 'm' else 'm'\n                        if a not in S: S[a] = 'f' if S[b] == 'm' else 'm'\n                        if  S[a] == S[b]: return False                        \n                    else:\n                        newcouples.append((a, b))                      \n                couples = newcouples\n                \n        self.names[p]['parentof'] += [c]        \n        self.names[c]['childof'] += [p]        \n        self.updatesex()\n        return True", "class Person:\n    def __init__(self, name, my_family, gender='A'):\n        self.name = name      # string\n        self.children = []    # list of person objects\n        self.parents = []     # list of person objects\n        # A cluster represents a subset of a family partitioned by the\n        # transitive closure of the relationship 'has a child in common with'\n        self.cluster = {self, }\n        self.gender = gender  # will be 'A' if unknown\n        my_family.known_persons[name] = self\n\n\nclass family:\n    def __init__(self):\n        # Dictionary mapping names to person objects\n        self.known_persons = {}\n\n    # The letters M and F stand for 'known to be male' and 'known to be female'. The\n    # letters A and B represent opposite genders within each cluster, but it is not\n    # known which of the two letters represents male or female for that cluster.\n    @staticmethod\n    def __opposite_gender__(gender):\n        return {'M': 'F', 'F': 'M', 'A': 'B', 'B': 'A'}[gender]\n\n    # A common implementation of the mandatory methods 'male' and 'female'\n    def __define_gender__(self, person, gender):\n        if person in self.known_persons:\n            if self.known_persons[person].gender in ('A', 'B'):\n                # We are now able to fill in the correct gender not only for\n                # this person, but for all the members of its cluster\n                original_gender = self.known_persons[person].gender\n                opposite_new_gender = family.__opposite_gender__(gender)\n                for p in self.known_persons[person].cluster:\n                    p.gender = gender if p.gender == original_gender else opposite_new_gender\n            else:\n                # Gender already known: check consistency\n                return self.known_persons[person].gender == gender\n        else:\n            # First time we hear about this person; create them\n            self.known_persons[person] = Person(person, gender=gender, my_family=self)\n        return True\n\n    def male(self, person):\n        return self.__define_gender__(person, 'M')\n\n    def female(self, person):\n        return self.__define_gender__(person, 'F')\n\n    def is_male(self, person):\n        return person in self.known_persons and self.known_persons[person].gender == 'M'\n\n    def is_female(self, person):\n        return person in self.known_persons and self.known_persons[person].gender == 'F'\n\n    # Auxiliary method to test for cycles in family trees\n    def __is_ancestor_of__(self, p1, p2):\n        if p1 == p2:\n            return True\n        elif len(p1.children) == 0:\n            return False\n        # Recursion: if one of my children is an ancestors of p2, then so am I\n        for c in p1.children:\n            if self.__is_ancestor_of__(c, p2):\n                return True\n        return False\n\n    # Auxiliary method to join 2 existing clusters after a member of each of them\n    # have acquired a common child, and to optionally adjust unknown genders in 1 of the clusters\n    # based on the genders in the other cluster (which may be known or unknown)\n    @staticmethod\n    def __join_cluster__(old_cluster, new_cluster, source_gender, target_gender, modify_genders=True):\n        for p in old_cluster:\n            if modify_genders:\n                if p.gender == target_gender:\n                    p.gender = family.__opposite_gender__(source_gender)\n                else:  # p.gender still unknown, but opposite of target_gender\n                    p.gender = source_gender\n            new_cluster.add(p)\n            p.cluster = new_cluster\n\n    # This method is the crux because despite its simple name, it has multiple functions:\n    # - check/update parent-child relationships including cycles\n    # - create 0, 1 or 2 new persons\n    # - join existing clusters if necessary\n    # We define different procedures depending on whether child and/or parent existed yet\n    def set_parent_of(self, child, parent):\n        # Eliminate a silly test case\n        if child == parent:\n            return False\n        if child not in self.known_persons:\n            # The child is new.\n            p = self.known_persons[parent] if parent in self.known_persons else Person(parent, my_family=self)\n            c = Person(child, my_family=self)\n        else:\n            # The child exists. Darn.\n            c = self.known_persons[child]\n            if parent not in self.known_persons:\n                # New parent, existing child\n                if len(c.parents) >= 2:\n                    # Can't have 3 parents\n                    return False\n                p = Person(parent, my_family=self)\n                if len(c.parents) == 1:\n                    # Child already had a parent: put the new parent in the same cluster as the existing parent\n                    family.__join_cluster__(p.cluster, c.parents[0].cluster, c.parents[0].gender, p.gender)\n            else:\n                # Both child and parent were known\n                p = self.known_persons[parent]\n                if c in p.children:\n                    # Parent/child relationship was already known: do nothing\n                    return True\n                if len(c.parents) >= 2:\n                    # p wasn't your parent yet and you can't have 3 parents\n                    return False\n                if self.__is_ancestor_of__(c, p):\n                    # Can't have a cycle in the ol' family tree\n                    return False\n                if len(c.parents) == 1:\n                    other_parent = c.parents[0]\n                    # Child had 1 other parent: check gender compatibility between clusters;\n                    # if necessary, join two clusters.\n                    if other_parent.cluster == p.cluster \\\n                            or other_parent.gender in ('M', 'F') and p.gender in ('M', 'F'):\n                        if other_parent.gender == p.gender:\n                            # We already know that these 2 people have the same gender\n                            # (perhaps even without knowing which gender it is)\n                            # so they cannot become parents of the same child.\n                            return False\n                        elif other_parent.cluster != p.cluster:\n                            # Consistent genders in different clusters:\n                            # join the 2 clusters without modifying genders\n                            family.__join_cluster__(p.cluster, other_parent.cluster,\n                                                    other_parent.gender, p.gender,\n                                                    modify_genders=False)\n                    elif p.gender in ('A', 'B'):\n                        # join 2 clusters, at most 1 of which has known genders\n                        family.__join_cluster__(p.cluster, other_parent.cluster, other_parent.gender, p.gender)\n                    elif other_parent.gender in ('A', 'B'):\n                        # Join 2 clusters, exactly 1 of which had known genders: transfer that knowledge\n                        family.__join_cluster__(other_parent.cluster, p.cluster, p.gender, other_parent.gender)\n                    else:\n                        print(\"add_parent: unknown gender combination\")\n                        return False\n        # Finally do what we came here for\n        c.parents.append(p)\n        p.children.append(c)\n        return True\n\n    def get_parents_of(self, person):\n        return sorted([p.name for p in self.known_persons[person].parents]) if person in self.known_persons else []\n\n    def get_children_of(self, person):\n        return sorted([c.name for c in self.known_persons[person].children]) if person in self.known_persons else []\n", "from enum import Enum\nclass Gender(Enum):\n    FEMALE = 1\n    MALE = 2\n    \n    @staticmethod\n    def opp_gender(gender):\n        opp = { Gender.MALE: Gender.FEMALE, Gender.FEMALE: Gender.MALE } \n        return opp[gender]\n\n\nclass Person:\n    def __init__(self, name):\n        self.name = name\n        self.gender = None\n        self.children = []\n        self.parents = []    \n        \n    def __copy__(self):\n        copy = Person(self.name)\n        copy.gender = self.gender\n        copy.children = self.children.copy()\n        copy.parents = self.parents.copy() \n        return copy\n        \n    def __str__(self):\n        return \"Name: {}, Gender: {}, Children: {}, Parents: {}\".format(self.name, self.gender, self.children, self.parents)\n\n\nclass Family:\n    \n    def __init__(self):\n        self.family = dict()\n        \n    def __copy__(self):\n        copy = Family()\n        copy.family = { name: person.__copy__() for name, person in list(self.family.items()) }\n        return copy\n        \n    def __str__(self):\n        return \"\\n\" + \"\\n\".join(person.__str__() for name, person in list(self.family.items())) + \"\\n\"\n        \n    def init_if_missing(self, name):\n        if name not in self.family:\n            self.family[name] = Person(name)\n    \n    def set_gender(self, name, gender):\n        self.init_if_missing(name)\n        if self.family[name].gender == gender:\n            return True\n        elif self.family[name].gender == Gender.opp_gender(gender):\n            return False\n        else:\n            for child in self.family[name].children:\n                for parent in self.family[child].parents:\n                    if parent != name and self.family[parent].gender == gender:\n                        return False\n            self.family[name].gender = gender\n            for child in self.family[name].children:\n                self.update_parent_of(child)\n            return True\n    \n    def male(self, name):\n        return self.set_gender(name, Gender.MALE)\n        \n    def is_male(self, name):\n        self.init_if_missing(name)\n        return self.family[name].gender == Gender.MALE\n        \n    def female(self, name):\n        return self.set_gender(name, Gender.FEMALE)\n        \n    def is_female(self, name):\n        self.init_if_missing(name)\n        return self.family[name].gender == Gender.FEMALE\n        \n    def set_parent_of(self, child_name, parent_name):\n        self.init_if_missing(child_name)\n        self.init_if_missing(parent_name)\n        current_parents = self.get_parents_of(child_name)\n        if parent_name in current_parents:\n            return True\n            \n        elif parent_name == child_name \\\n        or child_name in self.get_ancestors_of(parent_name) \\\n        or 2 <= len(current_parents) \\\n        or (len(current_parents) == 1 and self.family[parent_name].gender is not None\n            and self.family[current_parents[0]].gender == self.family[parent_name].gender):\n            return False\n            \n        else:\n            # if there is another parent with known gender, checks for inconsistency\n            if len(current_parents) == 1 and self.family[parent_name].gender is None \\\n            and self.family[current_parents[0]].gender is None:\n                family_copy = self.__copy__()\n                res = family_copy.female(parent_name)\n                if res:\n                    res = family_copy.set_parent_of(child_name, parent_name)\n                    if not res:\n                        return False\n                        \n            self.update_parent_of(child_name, parent_name)\n            return True\n        \n    def update_parent_of(self, child_name, parent_name=None):\n        if parent_name is not None:\n            self.family[child_name].parents.append(parent_name)\n            self.family[parent_name].children.append(child_name)\n            self.family[parent_name].children.sort()\n            \n        if len(self.family[child_name].parents) == 2:\n            self.family[child_name].parents.sort()\n            p0, p1 = self.family[self.family[child_name].parents[0]], self.family[self.family[child_name].parents[1]]\n            if (p0.gender is not None and p1.gender is not None) or (p0.gender is None and p1.gender is None):\n                return\n                \n            if p0.gender is not None:\n                self.family[self.family[child_name].parents[1]].gender = Gender.opp_gender(p0.gender)\n                for child in p1.children:\n                    if child != child_name:\n                        self.update_parent_of(child, None)\n            elif p1.gender is not None:\n                self.family[self.family[child_name].parents[0]].gender = Gender.opp_gender(p1.gender)\n                for child in p0.children:\n                    if child != child_name:\n                        self.update_parent_of(child, None)\n                    \n    def get_children_of(self, name):\n        self.init_if_missing(name)\n        return self.family[name].children.copy()\n        \n    def get_parents_of(self, name):\n        self.init_if_missing(name)\n        return self.family[name].parents.copy()\n        \n    def get_ancestors_of(self, name):\n        self.init_if_missing(name)\n        parents = self.get_parents_of(name)\n        ln = len(parents)\n        for parent in parents[:ln]:\n            parents.extend(self.get_ancestors_of(parent))\n        return parents\n", "class Person:\n\n    def __init__(self):\n        self.sex = None\n        self.children = []\n        self.parents = []\n\nclass Family:\n\n    def __init__(self):\n        self.members = dict()\n\n    def get_parents_gap(self, first, second):\n        if first not in self.members or second not in self.members:\n            return None\n        kids = self.members[first].children[:]\n        parents, step = [first], 0\n        while kids:\n            parents_size = len(parents)\n            for kid in kids:\n                parents.extend([p for p in self.members[kid].parents if p not in parents])\n            del parents[:parents_size]\n            if second in parents:\n                return step\n            kids_size = len(kids)\n            for parent in parents:\n                kids.extend([k for k in self.members[parent].children if k not in kids])\n            del kids[:kids_size]\n            step += 1\n        return None\n\n    def get_parent_sex(self, name):\n        kids = self.members.get(name, Person()).children[:]\n        parents, kid_step = [name], 0\n        while kids:\n            parents_size = len(parents)\n            for kid in kids:\n                parents.extend([p for p in self.members[kid].parents if p not in parents])\n            del parents[:parents_size]\n            kids_size = len(kids)\n            for parent in parents:\n                person = self.members[parent]\n                if person.sex == 'male':\n                    return 'male' if kid_step%2 else 'female'\n                elif person.sex == 'female':\n                    return 'female' if kid_step%2 else 'male'\n                kids.extend([k for k in person.children if k not in kids])\n            del kids[:kids_size]\n            kid_step += 1\n        return None\n        \n    def male(self, name):\n        person = self.members.get(name, Person())\n        if person.sex == 'female':\n            return False\n        elif person.sex is None:\n            if self.get_parent_sex(name) == 'female':\n                return False\n            person.sex = 'male'\n            self.members[name] = person\n        return True\n    \n    def is_male(self, name):\n        if self.members.get(name, Person()).sex == 'male':\n            return True\n        return self.get_parent_sex(name) == 'male'\n    \n    def female(self, name):\n        person = self.members.get(name, Person())\n        if person.sex == 'male':\n            return False\n        elif person.sex is None:\n            if self.get_parent_sex(name) == 'male':\n                return False\n            person.sex = 'female'\n            self.members[name] = person\n        return True\n\n    def is_female(self, name):\n        if self.members.get(name, Person()).sex == 'female':\n            return True\n        return self.get_parent_sex(name) == 'female'\n    \n    def set_parent_of(self, child_name, parent_name):\n        if  child_name == parent_name:\n            return False\n        child = self.members.get(child_name, Person())\n        parent = self.members.get(parent_name, Person())\n        if child_name in parent.children:\n            return True\n        elif len(child.parents)==2:\n            return False\n        kids = child.children[:]\n        while kids:\n            if parent_name in kids:\n                return False\n            for _ in range(len(kids)):\n                kids.extend(self.members[kids.pop(0)].children)\n        fp_sex = None\n        if child.parents:\n            fp_sex = self.members[child.parents[0]].sex\n            if fp_sex is None:\n                fp_sex = self.get_parent_sex(child.parents[0])\n        sp_sex = self.get_parent_sex(parent_name) if parent.sex is None else parent.sex\n        if fp_sex==sp_sex and fp_sex is not None:\n            return False\n        if (fp_sex is None and sp_sex is None and\n            child.parents and parent_name in self.members):\n            gap = self.get_parents_gap(child.parents[0], parent_name)\n            if gap is not None and gap%2:\n                return False\n        child.parents.append(parent_name)\n        parent.children.append(child_name)\n        self.members[child_name] = child\n        self.members[parent_name] = parent\n        return True\n    \n    def get_children_of(self, name):\n        return sorted(self.members.get(name, Person()).children)\n    \n    def get_parents_of(self, name):\n        return sorted(self.members.get(name, Person()).parents)\n", "class Person:\n    def __init__(self, name):\n        self.name = name\n        self.parents = set()\n        self.children = set()\n        self.gender = 0\n    def is_ancestor_of(self, person):\n        ancestors = set()\n        generation = set([person])\n        while len(generation):\n            ancestors = ancestors.union(generation)\n            next_generation = set()\n            for ancestor in generation:\n                if self in ancestor.parents:\n                    return True\n                next_generation = next_generation.union(ancestor.parents)\n            generation = next_generation\n\nclass Transaction(list):\n    def __init__(self):\n        list.__init__(self)\n    def start(self):\n        self.append(lambda: None)\n    def end(self, commit):\n        if commit:\n            self.log(self.pop())\n        else:\n            self.pop()()\n        return commit\n    def log(self, undo):\n        if not len(self):\n            self.start()\n        self.append((lambda rest: lambda: (undo(), rest()))(self.pop()))\n\nclass Family:\n    def __init__(self):\n        self.people = {}\n        self.transaction = Transaction()\n    def _member(self, name):\n        if not name in self.people:\n            self.people[name] = Person(name)\n        return self.people[name]\n    def set_parent_of(self, child, parent):\n        if child == parent:\n            return False\n        child = self._member(child)\n        parent = self._member(parent)\n        if parent in child.parents:\n            return True\n        self.transaction.start()\n        child.parents.add(parent)\n        parent.children.add(child)\n        self.transaction.log(lambda: (child.parents.remove(parent), parent.children.remove(child)))\n        success = not child.is_ancestor_of(parent) and self._rule_parents(child)\n        self.transaction.end(success)\n        return success\n    def male(self, person):\n        return self._set_gender_of(self._member(person), 1)\n    def is_male(self, person):\n        return self._member(person).gender == 1\n    def female(self, person):\n        return self._set_gender_of(self._member(person), -1)\n    def is_female(self, person):\n        return self._member(person).gender == -1\n    def get_children_of(self, person):\n        return sorted([p.name for p in self._member(person).children])\n    def get_parents_of(self, person):\n        return sorted([p.name for p in self._member(person).parents])\n    def _rule_parents(self, child):\n        if len(child.parents) != 2:\n            return len(child.parents) < 2\n        female = [person for person in child.parents if person.gender == -1]\n        male = [person for person in child.parents if person.gender == 1]\n        undetermined = [person for person in child.parents if person.gender == 0]\n        if not len(undetermined):\n            return len(child.parents) < 2 or len(male) | len(female) == 1\n        if len(undetermined) < len(child.parents):\n            return self._set_gender_of(undetermined[0], len(female)-len(male))\n        # Two possibilities: try one just to see if it leads to a gender-inconsistency\n        self.transaction.start()\n        success = self._set_gender_of(undetermined[0], 1)\n        self.transaction.end(0)\n        return success\n    def _set_gender_of(self, person, gender):\n        if person.gender == gender:\n            return True\n        if person.gender == -gender:\n            return False\n        person.gender = gender\n        self.transaction.log(lambda: setattr(person, \"gender\", 0))\n        return all(self._rule_parents(child) for child in person.children)\n", "class Family(dict):\n    def __init__(self): super().__init__()\n    \n    def __getitem__(self, name):\n        if name in self: return super().__getitem__(name)\n        ret = self[name] = Ppl(name)\n        return ret\n    \n    def __setitem__(self, name, ppl):\n        if name in self: raise Exception(f\"cannot reassign a member of the family: {name}, {ppl}\")\n        super().__setitem__(name,ppl)\n         \n    def female(self, name): return self.male(name,isMale=False)\n    def male(self, name, isMale=True):\n        who = self[name]\n        if who.hasGender() and isMale != who.isMale: return False\n        who.isMale = isMale\n        ok = all(c.updateGenders() for c in who.children)\n        if not ok: who.isMale=None\n        return ok\n        \n    def is_male(self, name):         p=self[name] ; return p.hasGender() and p.isMale\n    def is_female(self, name):       p=self[name] ; return p.hasGender() and not p.isMale\n    def get_children_of(self, name): return sorted(p.name for p in self[name].children)\n    def get_parents_of(self, name):  return sorted(p.name for p in self[name].parents)\n    \n    def set_parent_of(self, *childParent):\n        c,p = (self[x] for x in childParent)\n        return c.set_parent(p)\nfamily=Family\n\n\nclass Ppl:\n    def __init__(self, name,isMale=None):\n        self.name     = name\n        self.isMale   = isMale\n        self.children = []\n        self.parents  = []\n    def __eq__(self,o):    return isinstance(o,self.__class__) and o.name==self.name\n    def __hash__(self):    return hash(self.name)\n    def __repr__(self):    return f'Ppl({self.name},{self.isMale} ; p={[p.name for p in self.parents]}, c={[p.name for p in self.children]})'\n    def hasGender(self):   return self.isMale is not None\n    def has2Parents(self): return len(self.parents)==2\n    \n    def acyclic(self,target,seens=None):\n        if seens is None: seens = set()\n        if target in seens: return False\n        if self in seens: return True\n        return seens.add(self) or all(c.acyclic(target,seens) for c in self.children)\n    \n    def set_parent(self,p):\n        if p in self.parents: return True\n        if self.has2Parents() or self==p: return False\n        self.parents.append(p)\n        p.children.append(self)\n        if self.acyclic(p) and self.updateGenders(): return True\n        self.parents.pop()\n        p.children.pop()\n        return False\n    \n    def updateGenders(self, seensC=None, tome=()):\n        if not self.has2Parents(): return True\n        a,b = self.parents\n        if b.hasGender() or b in tome: a,b = b,a\n        nG = a.hasGender() + b.hasGender()\n            \n        if seensC is None:\n            seensC,tome = set(),{}\n            if not nG:\n                tome[a] = 1\n                return all(c.updateGenders(seensC, tome) for c in a.children if c not in seensC)\n        seensC.add(self)\n        \n        if nG==2: return a.isMale ^ b.isMale\n        if a in tome and b in tome: return tome[a]  ^ tome[b]\n        if nG==1: \n            b.isMale = not a.isMale\n        elif a in tome:\n            tome[b] = 1^tome[a]\n        isOK = all(c.updateGenders(seensC, tome) for c in b.children if c not in seensC)\n        if not isOK and nG==1: b.isMale = None\n        return isOK\n        \n            \n\n\"\"\"\ndef logger(f):\n    @wraps(f)\n    def wrapper(self, *a,**kw):\n        print('-------')\n        print(f.__name__, a, kw)\n        print(\"\\t\"+\"\\n\\t\".join(map(str,self.values())))\n        ret = f(self,*a,**kw)\n        x = \"\\n\\t\\t\".join(map(str,self.values()))\n        print(f'***\\n{f.__name__} returns: {ret}\\nFinal state:\\t{x}\\n------\\n')\n        return ret\n    return wrapper\n\nfrom functools import wraps\nfrom inspect import *\n\nfor name,f in getmembers(Family, predicate=isfunction):\n    if not name.startswith('__'):\n        setattr(Family, name, logger(f))\n#\"\"\"", "from collections import defaultdict\n\nclass family:\n    def __init__(self):\n        self.males = set()\n        self.females = set()\n        self.parents = defaultdict(lambda: set())\n        self.children = defaultdict(lambda: set())\n        \n    def male(self, name):\n        if name in self.females:\n            return False\n        if name in self.males:\n            return True\n        safe_copy = self.males.copy()\n        self.males.add(name)\n        for child in self.parents[name]:\n            partners = self.children[child] - {name}\n            for partner in partners:\n                if not self.female(partner):\n                    self.males = safe_copy\n                    return False\n        return True\n    def is_male(self, name):\n        return name in self.males\n    def female(self, name):\n        if name in self.males:\n            return False\n        if name in self.females:\n            return True\n        safe_copy = self.females.copy()\n        self.females.add(name)\n        for child in self.parents[name]:\n            partners = self.children[child] - {name}\n            for partner in partners:\n                if not self.male(partner):\n                    self.females = safe_copy\n                    return False\n        return True\n    def is_female(self, name):\n        return name in self.females\n    def set_parent_of(self, child_name, parent_name):\n        if child_name == parent_name:\n            return False\n        parents = self.children[parent_name]\n        while parents:\n            if child_name in parents:\n                return False\n            new_parents = set()\n            for parent in parents:\n                new_parents |= self.children[parent]\n            parents = new_parents\n        current_parents = self.children[child_name]\n        if parent_name in current_parents:\n            return True\n        if len(current_parents) >= 2:\n            return False\n        new_parents = current_parents | {parent_name}\n        if len(new_parents & self.males) > 1 or len(new_parents & self.females) > 1:\n            return False\n        self.parents[parent_name].add(child_name)\n        self.children[child_name].add(parent_name)\n        if len(new_parents) == 2:\n            for parent in new_parents:\n                if self.is_male(parent):\n                    if not self.female(next(iter(new_parents - {parent}))):\n                        return False\n                elif self.is_female(parent):\n                    if not self.male(next(iter(new_parents - {parent}))):\n                        return False\n            if len(new_parents & (self.males | self.females)) == 0:\n                new_parents = list(new_parents)\n                for (try_father, try_mother) in [new_parents, new_parents[::-1]]:\n                    safe_males_copy, safe_females_copy = self.males.copy(), self.females.copy()\n                    conflict_assign_gender = not self.male(try_father) or not self.female(try_mother)\n                    self.males, self.females = safe_males_copy, safe_females_copy\n                    if conflict_assign_gender:\n                        return False\n        return True\n    def get_children_of(self, name):\n        return sorted(self.parents[name])\n    def get_parents_of(self, name):\n        return sorted(self.children[name])\n", "from collections import deque\nfrom enum import Enum\n\n\nclass Gender(Enum):\n    Male = \"M\"\n    Female = \"F\"\n\n\nclass Member:\n    def __init__(self, name):\n        self.name = name\n        self.parents = []\n        self.children = []\n        self.spouse = None\n        self.gender = None\n\n    def __eq__(self, other):\n        return self.name == other.name\n\n    def __hash__(self):\n        return hash(self.name)\n\n    def __repr__(self):\n        return f\"[{self.name}|{self.gender}<=>{self.spouse.name if self.spouse is not None else '?'}: {list(map(lambda c: c.name, self.children))}]\"\n\n    def set_gender(self, gender):\n        if self.gender is not None and gender != self.gender:\n            return False\n\n        if self.spouse is not None:\n            if self.spouse.gender == gender:\n                return False\n            else:\n                if gender == Gender.Male:\n                    self.spouse.gender = Gender.Female\n                else:\n                    self.spouse.gender = Gender.Male\n\n        if self.gender is None:\n            self.gender = gender\n        return True\n\n    def set_parent(self, parent):\n        if parent not in self.parents:\n            self.set_spouse(parent)\n            self.parents.append(parent)\n\n    def set_spouse(self, parent):\n        if len(self.parents) == 1:\n            current_parent = self.parents[0]\n            parent.spouse = current_parent\n            current_parent.spouse = parent\n\n    def set_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n\n\nclass family:\n    def __init__(self):\n        self.members = []\n\n    def is_male(self, name):\n        member = self.add_member(name)\n        return True if member.gender == Gender.Male else False\n\n    def is_female(self, name):\n        member = self.add_member(name)\n        return True if member.gender == Gender.Female else False\n\n    def male(self, name):\n        member = self.add_member(name)\n\n        if member.set_gender(Gender.Male):\n            self.update_genders()\n            return True\n        else:\n            return False\n\n    def female(self, name):\n        member = self.add_member(name)\n\n        if member.set_gender(Gender.Female):\n            self.update_genders()\n            return True\n        else:\n            return False\n\n    def set_parent_of(self, child_name, parent_name):\n        child = self.add_member(child_name)\n        parent = self.add_member(parent_name)\n\n        if not self.valid_relationship(child, parent):\n            return False\n\n        child.set_parent(parent)\n        parent.set_child(child)\n        self.update_genders()\n        return True\n\n    def update_genders(self):\n        for m in self.members:\n            if m.spouse is not None and m.spouse.gender is not None:\n                if m.spouse.gender == Gender.Male:\n                    m.gender = Gender.Female\n                else:\n                    m.gender = Gender.Male\n\n    def get_children_of(self, name):\n        member = self.add_member(name)\n        return sorted(list([m.name for m in member.children]))\n\n    def get_parents_of(self, name):\n        member = self.add_member(name)\n        return sorted(list([m.name for m in member.parents]))\n\n    def valid_relationship(self, child, parent):\n        if child == parent:\n            return False\n\n        if child in parent.children:\n            return True\n\n        if not self.check_children_of_children(child, parent):\n            return False\n\n        if len(child.parents) >= 2:\n            return False\n\n        if len(child.parents) == 1:\n            current_parent = child.parents[0]\n            if current_parent.gender == parent.gender and current_parent.gender is not None:\n                return False\n\n        if not self.check_gender_assignment(child, parent):\n            return False\n\n        return True\n\n    # BFS algorithm\n    def check_gender_assignment(self, child, parent):\n        visited = set()\n        queue = deque([parent])\n        visited.add(parent)\n\n        counter = 1\n\n        while queue:\n            p = queue.popleft()\n\n            if len(p.children) == 0:\n                continue\n\n            for c in p.children:\n                if c not in visited:\n                    visited.add(p)\n                    for pp in c.parents:\n                        if pp not in visited:\n                            visited.add(pp)\n                            queue.append(pp)\n                            if pp.gender is None:\n                                counter += 1\n\n            # Detect cycle\n            if child in p.children:\n                if counter > 2:\n                    if counter % 2 != 0 or counter > 5:\n                        return False\n        return True\n\n    def check_children_of_children(self, child, parent):\n        visited = set()\n        queue = deque([child])\n        visited.add(child)\n\n        while queue:\n            c = queue.popleft()\n            \n            if len(c.children) == 0:\n                continue\n\n            for cc in c.children:\n                if cc == parent:\n                    return False\n                  \n                if cc not in visited:\n                    visited.add(cc)\n                    queue.append(cc)\n        \n        return True\n\n    def add_member(self, name):\n        new_member = Member(name)\n        if new_member not in self.members:\n            self.members.append(new_member)\n        return self.members[self.members.index(new_member)]\n", "from collections import defaultdict, deque\nfrom copy import deepcopy\n\nclass Member:\n    def __init__(self, name, gender=''):\n        self.name = name\n        self.gender = gender\n\n    def __repr__(self):\n        return self.name\n\nclass family:\n    def __init__(self):\n        self.children = defaultdict(list)\n        self.member_objects = []\n\n    def get_member(self, name):\n        member = next((i for i in self.member_objects if i.name == name), None)\n        if member is None:\n            self.member_objects.append(Member(name))\n            return self.member_objects[-1]\n        return member\n\n    def male(self, name):\n        member = self.get_member(name)\n        if member.gender == 'female' : return False\n        member.gender = 'male'\n        self.set_rest_of_things()\n        return True\n\n    def is_male(self, name):\n        gdr = self.get_member(name).gender\n        return bool(gdr) and gdr == 'male'\n\n    def female(self, name):\n        member = self.get_member(name)\n        if member.gender == 'male' : return False\n        member.gender = 'female'\n        self.set_rest_of_things()\n        return True\n\n    def is_female(self, name):\n        gdr = self.get_member(name).gender\n        return bool(gdr) and gdr == 'female'\n\n    def is_cycle(self, child, parent):\n        copy = defaultdict(list, {i.name: [k.name for k in j] for i, j in self.children.items()})\n        copy[child.name].append(parent.name)\n        Q = deque([[parent.name, []]])\n        while Q:\n            node, path = Q.popleft()\n            path.append(node)\n            for neighbour in copy[node]:\n                if neighbour not in path : Q.append([neighbour, path[:]])\n                elif neighbour == parent.name : return True\n        return False\n\n    def is_consistent(self, child, parent):\n        if self.is_cycle(child,parent) : return True\n        temp = Member('GG')\n        self.children[child].append(temp)\n        copy = deepcopy(self.children)\n        self.children[child].remove(temp)\n        nodes = set([i for i in copy] + [j for i in copy.values() for j in i])\n        for i in nodes : i.gender = ''\n        prt = next((i for i in nodes if i.name == parent.name), None)\n        if not prt : return False\n        prt.gender = 'male'   \n        k = self.set_rest_of_things(copy,prt)\n        return 'malefemale' in k or 'femalemale' in k\n\n    def set_parent_of(self, child, parent):\n        child, parent = self.get_member(child), self.get_member(parent)\n        if parent in self.children[child] or parent in self.children[child] : return True\n        if child == parent or len(self.children[child]) == 2 or \\\n           parent.gender and self.children[child] and self.children[child][0].gender == parent.gender or self.is_consistent(child, parent) : return False\n\n        self.children[child].append(parent)\n        self.set_rest_of_things()\n        return True\n\n    def get_children_of(self, name):\n        return sorted([i.name for i, j in self.children.items() if name in [k.name for k in j]])\n\n    def get_parents_of(self, name):\n        return sorted(next(([k.name for k in j] for i, j in self.children.items() if i.name == name), []))\n\n    def set_rest_of_things(self,cpy='',prt=''):\n        cpy = self.children if not cpy else cpy\n        d, i, keys, genders = {'male': 'female', 'female': 'male'}, 0, list(cpy.keys()), defaultdict(str)\n        while i < len(keys): \n            parents = cpy[keys[i]]\n            if len(parents) > 1:\n                a, b = parents\n                if (a.gender, b.gender).count('') == 1: \n                    b.gender = d.get(a.gender, b.gender)\n                    a.gender = d.get(b.gender, a.gender)\n                    genders[a.name] = a.gender \n                    genders[b.name] = b.gender\n                    i = -1                                              \n            i += 1\n        return genders[prt.name] + genders['GG'] if prt else ''", "from collections import defaultdict\nfrom copy import deepcopy\n\nclass family:\n    def __init__(self):\n        self.fam = defaultdict(lambda: defaultdict(set))\n        \n    def male(self, name):\n        return self.change_gender(name, \"male\")\n        \n    def is_male(self, name):\n        return self.fam[name][\"gender\"] == \"male\"\n        \n    def female(self, name):\n        return self.change_gender(name, \"female\")\n        \n    def is_female(self, name):\n        return self.fam[name][\"gender\"] == \"female\"\n        \n    def set_parent_of(self, child_name, parent_name):\n        if parent_name in self.fam[child_name][\"parents\"]: return True\n        if not self.check_parent(child_name, parent_name): return False\n        res = True\n        if self.fam[child_name][\"parents\"]:\n            other = next(iter(self.fam[child_name][\"parents\"]))\n            if self.fam[parent_name][\"gender\"]:\n                if self.fam[other][\"gender\"]:\n                    res = self.fam[parent_name][\"gender\"] != self.fam[other][\"gender\"]\n                else:\n                    res = self.change_gender(other, family.opposite(self.fam[parent_name][\"gender\"]))\n            else:\n                if self.fam[other][\"gender\"]:\n                    res = self.change_gender(parent_name, family.opposite(self.fam[other][\"gender\"]))\n                else:\n                    save = deepcopy(self.fam)\n                    self.fam[child_name][\"parents\"].add(parent_name)\n                    self.fam[parent_name][\"children\"].add(child_name)\n                    res = self.check_gender(parent_name) and self.check_gender(other)\n                    if not res: self.fam = save\n                    return res\n        if res:\n            self.fam[child_name][\"parents\"].add(parent_name)\n            self.fam[parent_name][\"children\"].add(child_name)\n        return res\n        \n    def get_children_of(self, name):\n        return sorted(self.fam[name][\"children\"])\n        \n    def get_parents_of(self, name):\n        return sorted(self.fam[name][\"parents\"])\n    \n    def change_gender(self, name, gender):\n        save = deepcopy(self.fam)\n        if not self.update_gender(name, gender):\n            self.fam = save\n            return False\n        return True\n\n    def search_ancestors(self, name, search):\n        if name == search: return True\n        return any(self.search_ancestors(parent, search) for parent in self.fam[name][\"parents\"])\n    \n    def update_gender(self, name, gender):\n        if self.fam[name][\"gender\"]: return self.fam[name][\"gender\"] == gender\n        self.fam[name][\"gender\"] = gender\n        for child in self.fam[name][\"children\"]:\n            if len(self.fam[child][\"parents\"]) == 2:\n                other = next(p for p in self.fam[child][\"parents\"] if p != name)\n                if not self.update_gender(other, family.opposite(gender)):\n                    return False\n        return True\n    \n    def check_gender(self, name):\n        save = deepcopy(self.fam)\n        res = self.update_gender(name, \"male\")\n        self.fam = save\n        if res: return True\n        save = deepcopy(self.fam)\n        res = self.update_gender(name, \"female\")\n        self.fam = save\n        return res\n    \n    def check_parent(self, child, parent):\n        if child == parent: return False\n        if len(self.fam[child][\"parents\"]) == 2: return False\n        if self.search_ancestors(parent, child): return False\n        return True\n    \n    @staticmethod\n    def opposite(gender):\n        return \"female\" if gender == \"male\" else \"male\""]
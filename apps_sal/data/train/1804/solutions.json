["def recoverSecret(triplets):\n  r = list(set([i for l in triplets for i in l]))\n  for l in triplets:\n    fix(r, l[1], l[2])\n    fix(r, l[0], l[1])\n  return ''.join(r)\n  \ndef fix(l, a, b):\n   \"\"\"let l.index(a) < l.index(b)\"\"\"\n   if l.index(a) > l.index(b):\n       l.remove(a)\n       l.insert(l.index(b), a)", "def recoverSecret(triplets):\n    letters = list(set([l for t in triplets for l in t]))        \n            \n    for t in triplets * len(letters):\n        for i in range(len(t)-1):\n            a, b = letters.index(t[i]), letters.index(t[i+1])\n            if( a > b ): letters[b], letters[a] = letters[a], letters[b]\n            \n    return ''.join(letters)", "import collections, functools, itertools\n\ndef recoverSecret(triplets):\n    \"\"\"triplets is a list of triplets from the secret string. Return the string.\"\"\"\n    \n    # Build a reverse directed graph of letters\n    graph = Graph()\n    for triplet in triplets:\n        for i, j in pairwise(triplet):\n            graph[i].goes_to(graph[j])\n    \n    # Pop off orphan letters one-by-one to form the word\n    cardinality = lambda node: len([ p for p in node.parents if p.value in graph ])\n    getnext = functools.partial(min, graph.viewvalues(), key=cardinality)\n    word = ( graph.pop(getnext().value).value for i in xrange(len(graph)) )\n    \n    return ''.join(word)\n    \nclass Graph(collections.defaultdict):\n    \"\"\"A graph that autocreates nodes\"\"\"\n    def __missing__(self, key):\n        self[key] = Node(key)\n        return self[key]\n\nclass Node(object):\n    \"\"\"A directed graph node that knows its parents\"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.parents = []\n    def goes_to(self, child):\n        child.parents.append(self)\n\ndef pairwise(iterable):\n    \"\"\"Iterates through an iterable in pairs [a,b,c,d] --> ( [a,b], [b,c], [c,d] )\"\"\"\n    a, b = itertools.tee(iterable)\n    next(b, None)\n    return itertools.izip(a, b)", "def recoverSecret(a):\n    out = list(zip(*a)) \n    h = [j for j in (set(out[0])-set(out[1]+out[2]))]\n    for i in a:\n        if i[0] in h:\n            i[:2], i[2] = i[1:], ''\n        \n    return h[0]+recoverSecret(a) if h else str()\n", "def recoverSecret(a):\n    out = list(zip(*a))  # transpose the list\n    h = [j for j in (set(out[0])-set(out[1]+out[2]))]  # find the first letter\n    for i in a:\n        if i[0] in h:  # find triplets starting with that letter\n            i[:2], i[2] = i[1:], ''   # remove the first letter and move other letters up\n        \n    return h[0]+recoverSecret(a) if h else str()  # return the first letter plus the recursion on the rest\n", "def recoverSecret(triplets):\n    'triplets is a list of triplets from the secrent string. Return the string.'\n    res = ''\n    while triplets != []:\n        non_firsts = [num for t in triplets for num in t[1:]]\n        firsts = [t[0] for t in triplets]\n        for f in firsts:\n            if f not in non_firsts:\n                res += f\n                for t in triplets:\n                    if t[0] == f:\n                        t.pop(0)\n                break\n        triplets = [t for t in triplets if t != []]\n    return res", "def recoverSecret(triplets):\n    ansList = list({triplet[i] for i in range(3) for triplet in triplets})\n    indexDict = {letter:i for i,letter in enumerate(ansList)}\n    \n    isModified = True\n    while isModified:\n        isModified = False\n        for triplet in triplets:\n            for i in range(2):\n                if indexDict[ triplet[i] ] > indexDict[ triplet[i+1] ]:\n                    isModified = True\n                    indexDict[ triplet[i] ], indexDict[ triplet[i+1] ] = indexDict[ triplet[i+1] ], indexDict[ triplet[i] ]\n    \n    for k in indexDict.keys(): ansList[ indexDict[k] ] = k\n    return ''.join(ansList)", "from itertools import cycle\ndef recoverSecret(ts):\n    orders = set(sum([[(a,b),(b,c),(a,c)] for a,b,c in ts],[]))\n    secret, complete = list(set(l for t in ts for l in t)), False\n    for a,b in cycle(orders):\n        i, j = (secret.index(a), secret.index(b))\n        complete = i < j and complete + 1\n        if j < i: secret[j], secret[i] = a, b\n        elif complete >= len(orders): break  \n    return ''.join(secret)\n", "from collections import defaultdict\n\n\ndef recoverSecret(triplets):\n    letters = defaultdict(set)\n    for a, b, c in triplets:\n        letters[a].add(b)\n        letters[a].add(c)\n        letters[b].add(c)\n\n    for key, value in list(letters.items()):\n        for after_key in value:\n            letters[key] = letters[key].union(letters[after_key])\n\n    return ''.join(k for k, _ in sorted(\n        iter(letters.items()), key=lambda __v: len(__v[1]), reverse=True\n    ))\n", "def recoverSecret(triplets):\n    'triplets is a list of triplets from the secrent string. Return the string.'\n    res = \"\"\n    table = {}\n    visited = set()\n    for a,b,c in triplets:\n        if not table.has_key(a):\n            table[a] = set()\n        if not table.has_key(b):\n            table[b] = set()\n        if not table.has_key(c):\n            table[c] = set()\n        table[a].add(b)\n        table[a].add(c)\n        table[b].add(c)\n\n    count = len(table.keys())\n    while len(visited) < count:\n        Min = count\n        c = ''\n        for k,v in table.iteritems():\n            l = len([elem for elem in v if elem not in visited])\n            if l < Min and k not in visited:\n                Min = l\n                c = k\n        visited.add(c)\n        res += c\n    return res[::-1]", "def recoverSecret(triplets):\n    # Initialize the answer to the letters we're given in the triplets (use set() to drop duplicates)\n    answer = list(set([item for sublist in triplets for item in sublist]))\n    # Convert the triplets into sets of pairs, to more easily do comparisons\n    clues = []\n    for t in triplets:             # copy remaining triplets as pairs\n        clues.append([t[0], t[1]])\n        clues.append([t[1], t[2]])\n\n    # Loop through the clue pairs, swapping (sorting) letters that are out of order.\n    # Once we've made no more swaps, we know we are done.\n    while True:\n        changed = False\n        for pair in clues:\n            left = answer.index(pair[0])\n            right = answer.index(pair[1])\n            if left > right:     # These letters are out-of-order, so swap them\n                answer[left], answer[right] = answer[right], answer[left]\n                changed = True\n        if not changed:\n            break\n    return \"\".join(answer)"]
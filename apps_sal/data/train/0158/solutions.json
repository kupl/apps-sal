["class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        a = ''\n        b = ''\n       \n        for i in range(len(A)):\n            if A[i] != B[i]:\n                a+=A[i]\n                b+=B[i]\n                \n        return self.dfs(a,b)\n        \n    def dfs(self,a,b):\n        if not a:\n            return 0\n        one = []\n        two = []\n        \n        for i in range(len(a)):\n            if a[0] == b[i]:\n                one.append(i)\n                if b[0] == a[i]:\n                    two.append(i)\n        \n        if two:\n            i = two[0]\n            c = a[1:i] + a[i+1:]\n            d = b[1:i] + b[i+1:]\n            return self.dfs(c,d) + 1\n        else:\n            res = float('inf')\n            for i in one:\n                c = a[i] + a[1:i] + a[i+1:]\n                d = b[:i]+b[i+1:]\n                res= min(res,self.dfs(c,d)+1)\n        \n            return res\n\n        \n        \n        \n        \n                \n        \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A == B: return 0\n        \n        def neighbors(s, i=0):\n            while s[i] == B[i]: i+= 1\n                \n            for j in range(i+1, len(A)):                \n                if s[j] == B[i] and B[j] == s[i]:\n                    yield s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                    return\n                \n            for j in range(i+1, len(A)):                \n                if s[j] == B[i] and s[j] != B[j]:\n                    yield s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                            \n        dp = collections.deque([(A,0)])\n        met = set()                        \n        while dp:\n            A_, step = dp.popleft()\n            for n in neighbors(A_):\n                if n == B:\n                    return step+1\n                if n not in met:\n                    dp.append((n,step+1))\n                    met.add(n)      ", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        lsta, lstb = '', ''\n        for i in range(len(A)):\n            if A[i]!=B[i]:\n                lsta+=A[i]\n                lstb+=B[i]\n        q = [(0,lsta,lstb)]\n        while q:\n            time,la,lb = q.pop(0)\n            if not lb: return time\n            goal = lb[0]\n            work,ls = None,[]\n            for i in range(1,len(la)):\n                if la[i]==goal and la[0]==lb[i]:                   \n                    work = True\n                    break\n            if work:\n                q.append((time+1,la[1:i]+la[i+1:],lb[1:i]+lb[i+1:]))\n            else:\n                for i in range(1,len(la)):\n                    if la[i]==goal:\n                        q.append((time+1,la[1:i]+la[0]+la[i+1:],lb[1:]))\n                \n            \n                    \n            \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        \n        A = list(A)\n        memo = {}\n        def solution(i):\n            t = tuple(A)\n            if (i,t) in memo: return memo[i,t]\n            if i == len(A):\n                return 0\n            \n            if A[i] == B[i]:\n                return solution(i+1)\n            \n            mymin = float('inf')\n            for j in range(i+1, len(A)):\n                if A[j] != B[i]:\n                    continue\n                \n                A[i], A[j] = A[j], A[i]\n                mymin = min(mymin, solution(i+1))\n                A[j], A[i] = A[i], A[j]\n            \n            memo[i,t] = 1 + mymin\n            return 1 + mymin\n        \n        return solution(0)", "from collections import deque\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def swapPos(string):\n            i = 0\n            while string[i] == B[i]:\n                i += 1\n            for j in range(i+1, length):\n                if string[j] == B[i]:\n                    yield string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]\n\n        dq = deque([(A, 0)])\n        visited = set(A)\n        length = len(A)\n        while dq:\n            string, dist = dq.popleft()\n            if string == B:\n                return dist\n            for s2 in swapPos(string):\n                if s2 not in visited:\n                    dq.append((s2, dist+1))\n                    visited.add(s2)", "class Solution:\n    @lru_cache(maxsize=None)\n    def kSimilarity(self, A: str, B: str) -> int:\n        if not A and not B:\n            return 0\n        \n        if A[0]==B[0]:\n            return self.kSimilarity(A[1:],B[1:])\n        \n        ans=float('inf')\n        for i, c in enumerate(B):\n            if c==A[0]:\n                ans=min(ans,1+self.kSimilarity(A[1:],B[1:i]+B[0]+B[i+1:]))\n        return ans", "# class Solution:\n#     def kSimilarity(self, A: str, B: str) -> int:\n#         n = len(A)\n#         A, B = list(A), list(B)\n#         mp = defaultdict(list)\n#         for i, ch in enumerate(A):\n#             mp[ch].append(i)\n#         def dfs(idx):\n#             if idx == n:\n#                 return 0\n#             if A[idx] == B[idx]:\n#                 return dfs(idx+1)\n#             res = float('inf')\n#             for nxt in range(idx+1,n):\n#                 if A[nxt] != B[idx]:\n#                     continue\n#                 A[idx], A[nxt] = A[nxt], A[idx]\n#                 res = min(res, dfs(idx+1)+1)\n#                 A[idx], A[nxt] = A[nxt], A[idx]\n#             return res\n#         return dfs(0)\n\nfrom functools import lru_cache\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        n = len(A)\n        # mp = defaultdict(list)\n        # for i, ch in enumerate(A):\n        #     mp[ch].append(i)\n        @lru_cache(None)\n        def dfs(s):\n            if s == B:\n                return 0\n            idx = 0\n            while s[idx] == B[idx]:\n                idx += 1\n            res = float('inf')\n            for nxt in range(idx+1,n):\n                if s[nxt] != B[idx]:\n                # if s[nxt] != B[idx] or s[nxt] == B[nxt]:\n                    continue\n                res = min(res, dfs(s[:idx]+s[nxt]+s[idx+1:nxt]+s[idx]+s[nxt+1:])+1)\n            return res\n        return dfs(A)", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        \n        q = collections.deque()\n        visited = set()\n        q.append(A)\n        visited.add(A)\n        \n        step = -1\n        while q:\n            step += 1\n            lens = len(q)\n            for _ in range(lens):\n                curr = q.popleft()\n                if curr == B:\n                    return step\n                for next in self._swap(curr, B):   # takes O(N)\n                    if next in visited:\n                        continue\n                    q.append(next)\n                    visited.add(next)\n                \n    def _swap(self, s, B):    # now only takes O(N)\n        i = 0\n        while s[i] == B[i]:   # if S[i]==B[i], we don't need to swap them - strong prune to makes sure swapped string always get more and more similar with B\n            i += 1\n        for j in range(i + 1, len(s)):\n            if s[j] == B[i]:  # since B[i]!=s[i], if we swap s[j] to s[i], now B[i]=s[i]: this is how every swap make sure we get more and more closer to B\n                yield s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n", "class Solution:\n    def kSimilarity(self, A, B):\n        def nei(x):\n            i = 0\n            while x[i] == B[i]: i += 1\n            for j in range(i + 1, len(A)):\n                if x[j] == B[j]:\n                    continue\n                if x[j] == B[i] and x[i] == B[j]:\n                    yield x[:i] + x[j] + x[i + 1:j] + x[i] + x[j + 1:]\n                    break\n                if x[j] == B[i]:\n                    yield x[:i] + x[j] + x[i + 1:j] + x[i] + x[j + 1:]\n\n        # def test():\n        stack = [(A, 0)]\n        visit = {A}\n        for cur, d in stack:\n            # cur, d = stack.pop()\n            if cur == B: return d\n            for neighbor in nei(cur):\n                if neighbor not in visit:\n                    visit.add(neighbor)\n                    stack.append((neighbor, d+1))\n                    \n        \n        # n = len(A)\n        # def nei(x):\n        #     i = 0\n        #     while x[i] == B[i]: i += 1\n        #     for j in range(i+1,n):\n        #         if x[j] == B[j]:\n        #             continue\n        #         if x[j] == B[i] and x[i] == B[j]:\n        #             yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n        #             break\n        #         if x[j] == B[i]:\n        #             yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n        # pool = [(A,0)]\n        # seen = {A}\n        # for x,d in pool:\n        #     if x == B: return d\n        #     for y in nei(x):\n        #         if y not in seen:\n        #             seen.add(y)\n        #             pool.append((y,d+1))\n", "class Solution:\n    # Just like the shuffle board game, consider each string as a node\n    # And for each child is the shuffled result\n    def kSimilarity(self, A: str, B: str) -> int:\n        def find(s):\n            i = 0\n            res = []\n            while s[i] == B[i]: i += 1\n            for j in range(i+1,len(B)):\n                if s[j] == B[i]:\n                    res.append(s[:i]+s[j]+s[i+1:j]+s[i]+s[j+1:])\n            return res\n                \n        q = collections.deque([[0,A]])\n        seen = set([A])\n        while q:\n            size = len(q)\n            for _ in range(size):\n                step,s = q.popleft()\n                if s == B:return step\n                for new in find(s):\n                    if new not in seen:\n                        seen.add(new)\n                        q.append([step+1,new])\n        return \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def nei(x):\n            i = 0\n            while x[i]==B[i]:\n                i+=1\n            for j in range(i+1, len(x)):\n                if x[i]==B[j] and x[j] != B[j]: \n                    yield x[:i] + x[j] + x[i+1:j] + x[i] + x[j+1:]\n        \n        seen = {A}\n        queue = [(A,0)]\n        for node, change in queue:\n            if node==B:\n                return change\n            for y in nei(node):\n                if y not in seen:\n                    seen.add(node)\n                    queue.append((y, change+1))", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def nei(x):\n            i = 0\n            while x[i] == B[i]: i+=1\n            for j in range(i+1, len(x)):\n                if x[j] == B[i]: yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n        q, seen = [(A,0)], {A}\n        for x, d in q:\n            if x == B: return d\n            for y in nei(x):\n                if y not in seen:\n                    seen.add(y), q.append((y,d+1))", "from collections import deque\n\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def successor(s):\n            i=0\n            while s[i] == B[i]:\n                i += 1\n            for j in range(i, len(s)):\n                if s[j] == B[i]:\n                    yield s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n        \n        q = deque([(A, 0)])\n        seen = set()\n        while q:\n            curr, dist = q.popleft()\n            if curr == B:\n                return dist\n            if curr not in seen:\n                seen.add(curr)\n                q.extend([(suc, dist+1) for suc in successor(curr)])\n            \n                \n        \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        N = len(A)\n        def dfs(A, B, pos):\n            if A == B:\n                return 0\n            \n            while A[pos] == B[pos]:\n                pos += 1\n                \n            minCnt = float('inf')\n            for i in range(pos + 1, N):\n                if B[i] == A[pos] and B[i] != A[i]:\n                    B[i], B[pos] = B[pos], B[i]\n                    tmp = dfs(A, B, pos + 1) + 1\n                    minCnt = min(tmp, minCnt)\n                    B[i], B[pos] = B[pos], B[i]\n                    \n            return minCnt\n        \n        return dfs(list(A), list(B), 0)\n            \n        \n        \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        A = list(A)\n        B = list(B)\n        \n        n = len(A)\n        \n        \n        # ans = 0\n        # for i in range(n):\n        #     if A[i]==B[i]:\n        #         continue\n        #     else:\n        #         ans+=1\n        #         for j in range(i+1, n):\n        #             if B[j] == A[i]:\n        #                 B[i], B[j] = B[j], B[i]\n        #                 break\n        # return ans\n        \n        def rec(i):\n            if i==n:\n                return 0\n            \n            if A[i]==B[i]:\n                return rec(i+1)\n            else:\n                min_ = sys.maxsize\n                for j in range(i+1, n):\n                    if B[j] == A[i] and B[j]!=A[j]:\n                        B[i], B[j] = B[j], B[i]\n                        min_ = min(min_, rec(i+1) + 1)\n                        B[i], B[j] = B[j], B[i]\n                return min_\n        \n        return rec(0)\n                        \n\n#         ans = 0\n#         for i in range(n):\n#             if A[i]==B[i]:\n#                 continue\n#             else:\n#                 ans+=1\n#                 for j in range(i+1, n):\n#                     if B[j] == A[i] and B[j]!=A[j]:\n#                         B[i], B[j] = B[j], B[i]\n#                         break\n#         return ans\n                        \n\n        \n#         def rec(i):\n#             if i==n:\n#                 return 0\n            \n#             if A[i]==B[i]:\n#                 return rec(i+1)\n#             else:\n#                 min_ = sys.maxsize\n#                 j = 0\n#                 while A[j]==B[j]:\n#                     j+=1\n#                 for k in range(j+1, n):\n#                     if B[k] == A[j]:\n#                         B[j], B[k] = B[k], B[j]\n#                         min_ = min(min_, rec(i+1) + 1)\n#                         B[j], B[k] = B[k], B[j]\n#                 return min_\n        \n#         return rec(0)\n#         def nei(x):\n#             i = 0\n#             while x[i] == B[i]: i+=1\n#             for j in range(i+1, len(x)):\n#                 if x[j] == B[i]: yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n#         q, seen = [(A,0)], set([A])\n        \n#         for x, d in q:\n#             if x == B: return d\n#             for y in nei(x):\n#                 if y not in seen:\n#                     seen.add(y), q.append((y,d+1))\n", "'''\n'ab'\n'ba'\n1\n\n'abc' -> 'acb' -> 'bca'\n'bca'\n2\n\n'abac' -> 'baac' -> 'baca'\n'baca'\n2\n\n'aabc' -> 'acba' -> 'abca'\n'abca'\n2\n\n* See the problem as a graph problem.\n* Nodes are the strings.\n* Two nodes are conneted to each order if the one string is equal to the\n  other if we swap two chars.\n* The problem boils down to find the shortest path between A and B.\n* Since this is an unweigthed graph, the shortest path can be found by\n  traversing the graph in BFS.\n  \n  \n'abc' -> 'bac'\n      -> 'cba'\n      -> 'acb'\n      \n* This approach doesn't sound an efficient approach because for every node\n  we'd need to generated its adjcent nodes.\n  \n* This sounds like an optimization problem.\n\n'abcd'  --> 'bcd'\n'adbc'      'dbc'\n\n* If the first char from A and B are equal, recurse on the remaining string.\n* Else, swap A so it first char match and recurse. If the target char repeats,\n  try swapping all of them and consider the one that leads to the smallest K.\n  \n  \n('abac', 'baca') = 1 + ('aac', 'aca')\n('aac', 'aca') = ('ac', 'ca')\n('ac', 'ca') = 1 + ('a', 'a')\n('a', 'a') = 0\n\n'''\n\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        return do_kSimilarity(list(A), list(B), {})\n                \n                \ndef do_kSimilarity(A, B, memo):\n    if (tuple(A), tuple(B)) in memo:\n        return memo[(tuple(A), tuple(B))]\n    if A == B:\n        return 0\n\n    if A[0] == B[0]:\n        return do_kSimilarity(A[1:], B[1:], memo)\n    else:\n        swaps = []\n        for i, char in enumerate(A):\n            if char == B[0]:\n                swaps.append(i)\n        \n        k = float('inf')\n        for swap in swaps:\n            A[0], A[swap] = A[swap], A[0]\n            k = min(k, 1 + do_kSimilarity(A[1:], B[1:], memo))\n            A[0], A[swap] = A[swap], A[0]\n        \n        memo[(tuple(A), tuple(B))] = k\n        return k", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def neighbor(s):\n            i = 0\n            while i<len(B) and s[i]==B[i]:\n                i += 1\n            for j in range(i+1, len(B)):\n                if s[j] == B[i]:\n                    yield s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                \n        queue = deque([(A, 0)])\n        visited = {A}\n        while queue:\n            s, d = queue.popleft()\n            if s == B:\n                return d\n            for n in neighbor(s):\n                if n not in visited:\n                    visited.add(n)\n                    queue.append([n, d+1])", "from collections import deque\n\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def successor(s):\n            i=0\n            while s[i] == B[i]:\n                i += 1\n            ans = []\n            for j in range(i, len(s)):\n                if s[j] == B[i]:\n                    ans.append(s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:])\n            return ans\n        \n        q = deque([(A, 0)])\n        seen = set()\n        while q:\n            curr, dist = q.popleft()\n            if curr == B:\n                return dist\n            if curr not in seen:\n                seen.add(curr)\n                q.extend([(suc, dist+1) for suc in successor(curr)])\n            \n                \n        \n", "class Solution:\n    def bfs(self, A: str, B: str):\n        if A == B: return 0\n        n = len(A)\n        q = []\n        visited = set()\n        q.append((B, 0, 0))\n        while q:\n            processed, idx, swaps = q.pop(0)\n            visited.add(processed)\n            while processed[idx] == A[idx]:\n                idx += 1\n            for i in range(idx+1,n):\n                if A[idx] == processed[i]:\n                    new_processed = processed[:idx] + processed[i] + processed[idx+1:i] + processed[idx] + processed[i+1:]\n                    if A == new_processed: return swaps + 1\n                    if new_processed not in visited:\n                        q.append((new_processed, idx+1, swaps+1))\n            \n        return 0\n        \n    def kSimilarity(self, A: str, B: str) -> int:\n        return self.bfs(A, B)", "\nclass Solution:\n    \n    def kSimilarity(self, A: str, B: str) -> int:\n        \n        \n        def neighbors(A):\n            i = 0\n            while A[i] == B[i]:\n                i += 1\n                \n            for j in range(i+1, len(B)):\n                if A[i] != A[j] and A[j] == B[i]:\n                    yield A[:i] + A[j] + A[i+1:j] + A[i] + A[j+1:]\n        \n        queue = [(A,0)]\n        seen = set([A])\n        for s, val in queue:\n            if s == B:\n                return val\n            \n            for nxt_s in neighbors(s):\n                if nxt_s not in seen:\n                    queue.append((nxt_s, val+1))\n                    seen.add(nxt_s)\n        return -1\n        \n        \n", "class Solution:\n    # Just like the shuffle board game, consider each string as a node\n    # And for each child is the shuffled result which one step closer to the target\n    # Another key is how to find the next step (by finding the first different letter and swap)\n    # The order does not matter\n    def kSimilarity(self, A: str, B: str) -> int:\n        def find(s):\n            i = 0\n            res = []\n            while s[i] == B[i]: i += 1\n            for j in range(i+1,len(B)):\n                if s[j] == B[i]:\n                    res.append(s[:i]+s[j]+s[i+1:j]+s[i]+s[j+1:])\n            return res\n                \n        q = collections.deque([[0,A]])\n        seen = set([A])\n        while q:\n            size = len(q)\n            for _ in range(size):\n                step,s = q.popleft()\n                if s == B:return step\n                for new in find(s):\n                    if new not in seen:\n                        seen.add(new)\n                        q.append([step+1,new])\n        return \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        self.min = float('inf')\n        A = list(A)\n        B = list(B)\n        \n        def swap(a,b):\n            A[a], A[b] = A[b], A[a]\n        \n        @lru_cache(None)\n        def helper(left, right, AB):                        \n            ok = True\n            swaps = 0\n            \n            while A != B:\n                ok = False\n                a = A[left]\n                b = B[right]\n\n                if a != b:\n                    minn = float('inf')\n                    poss = []\n                    for i,c in enumerate(A):\n                        if b == c and i >= left:\n                            poss.append(i)\n                \n                    # if len(poss) > 1:\n                    for p in poss:\n                        swap(left,p)\n                        otherswaps = helper(left+1,right+1, tuple(A+B))\n                        swap(left,p)\n                        minn = min(otherswaps, minn)\n                        \n                    return swaps+ 1 + minn\n                    # else:\n                    #     if poss:\n                    #         # print(A,B, a,b)\n                    #         swap(left,poss[0])\n                    #         swaps += 1 \n\n                left = (left+1) % len(A)\n                right= (right+1) % len(B)\n            \n            return swaps\n\n#         left = right = 0\n#         ok = True\n#         swaps = 0\n#         while A != B:\n#             ok = False\n#             a = A[left]\n#             b = B[right]\n            \n#             if a != b:\n#                 # indx = A.index(b)\n#                 for i,c in enumerate(A):\n#                     if b == c and i >= left:\n#                         indx = i\n#                         break\n#                 swap(left,indx)\n#                 swaps += 1\n            \n#             left = (left+1) % len(A)\n#             right= (right+1) % len(B)\n        \n        f = helper(0,0, tuple(A+B))\n        print(A)\n        print(B)\n            \n        # out = helper(A, 0, 0)\n        # print(out)\n        return f\n                \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        self.min = float('inf')\n        A = list(A)\n        B = list(B)\n        \n        def swap(a,b):\n            A[a], A[b] = A[b], A[a]\n        \n        @lru_cache(None)\n        def helper(left, right, AB):                        \n            ok = True\n            swaps = 0\n            \n            while A != B:\n                ok = False\n                a = A[left]\n                b = B[right]\n\n                if a != b:\n                    minn = float('inf')\n                    poss = []\n                    for i,c in enumerate(A):\n                        if b == c and i >= left:\n                            poss.append(i)\n                \n                    # if len(poss) > 1:\n                    for p in poss:\n                        swap(left,p)\n                        otherswaps = helper(left+1,right+1, tuple(A+B))\n                        swap(left,p)\n                        minn = min(otherswaps, minn)\n                        \n                    return swaps+ 1 + minn\n                \n                left = (left+1) % len(A)\n                right= (right+1) % len(B)\n            \n            return swaps\n\n        \n        f = helper(0,0, tuple(A+B))\n        return f\n                \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A==B: return 0\n        dq = deque([(A,0)])\n        cnt = 0\n        N = len(A)\n        while dq:\n            length = len(dq)\n            \n            for _ in range(length):\n                curr, idx = dq.popleft()\n                lst = list(curr)\n                \n                for i in range(idx, N):\n                    if lst[i]!=B[i]:\n                        for j in range(i+1, N):\n                            if lst[j]!=B[j] and lst[j]==B[i]:\n                                lst[i], lst[j] = lst[j], lst[i]\n                                temp = ''.join(lst)\n                                if temp==B:\n                                    return cnt+1\n                                dq.append((temp, i+1))\n                                lst[i], lst[j] = lst[j], lst[i]\n                        break\n                \n            cnt += 1\n        \n        \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n\n        def dist(a, b):\n            # count number of differing characters\n            return sum( (1 if c!=d else 0 for (c,d) in zip(a,b) ) )\n\n        def swap(s, i, j):\n            # swap ith and jth chars of string s\n            # assert i != j\n            if i > j:\n                i, j = j, i\n            return s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n\n        def DFS(string, k):\n            # can string be swapped into problem's str `A` in `k` moves?\n            if string == A:\n                return True\n            if k == 0:\n                return False\n            for i,c in enumerate(string):\n                if A[i] == c:\n                    continue\n                # c is wrong, we need to swap a correct letter into it\n                # only look for after current position to avoid double swaps\n                for j in range(i, len(A)):\n                    if string[j] == A[i] and A[j] != A[i]:\n                        # try this swap\n                        if DFS(swap(string, i, j), k-1):\n                               return True\n                # return False after trying to correct the first wrong letter:\n                # if there is any `k` solution, then there's a `k` solution\n                # that starts on this letter\n                return False\n\n        for k in range(len(A)):\n            if DFS(B, k):\n                return k\n\n \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        N = len(A)\n        if not N:\n            return 0\n        cnt = 0\n        \n        q = deque()\n        q.append((cnt, A, 0))\n        while q:\n            cnt, v, i = q.popleft()\n            \n            if v == B:\n                return cnt\n            \n            for j in range(i+1, N):\n                while v[i]==B[i]:\n                    i += 1\n                    \n                if v[j]==B[i] and v[j]!=B[j]:\n                    candidate = v[:i]+v[j]+v[i+1:j]+v[i]+v[j+1:]\n                    q.append((cnt+1, candidate, i+1))\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        A, B = list(A), list(B)\n        N = len(A)\n        if not N:\n            return 0\n        cnt = 0\n        \n        q = deque()\n        q.append((cnt, A, 0))\n        while q:\n            cnt, v, i = q.popleft()\n            \n            if v == B:\n                return cnt\n            \n            for j in range(i+1, N):\n                while v[i]==B[i]:\n                    i += 1\n                    \n                if v[j]==B[i] and v[j]!=B[j]:\n                    candidate = v[:]\n                    candidate[i], candidate[j] = candidate[j], candidate[i]\n                    q.append((cnt+1, candidate, i+1))\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        \n        self.counter = float('inf')\n        A = list(A)\n        B = list(B)\n        \n        def swap(first, cur):\n            if first == len(A) - 1 or A[first:] == B[first:]:\n                self.counter = min(self.counter, cur)\n                #print(f'cur={cur}, first={first}')\n                return\n            for i in range(first, len(A)):\n                if A[i] != B[i]:\n                    for k in range(i + 1, len(A)):\n                        if A[i] == B[k] and cur + 1 < self.counter:\n                            B[i], B[k] = B[k], B[i]\n                            #print(f'B={B}')\n                            swap(i + 1, cur + 1)\n                            B[i], B[k] = B[k], B[i]\n                    break\n            return \n            \n        swap(0, 0)\n        return self.counter\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        \n        def dfs(A, B):\n            if not A and not B:\n                return 0\n            if str(A) == str(B):\n                return 0\n            k = str(A)\n            if k in dp:\n                return dp[k]\n            \n            dp[k] = len(A) - 1\n            \n            if A[0] == B[0]:\n                dp[k] = dfs(A[1:], B[1:])\n                return dp[k]\n            \n            for j in range(1,len(A)):\n                if A[j] == B[0]:\n                    A[0],A[j] = A[j],A[0]\n                    dp[k] = min(dp[k],1 + dfs(A[1:],B[1:]))\n                    A[j],A[0] = A[0],A[j]\n            \n            return dp[k]\n            \n        dp = dict()\n        A,B = list(A),list(B)\n        dp[str(A)] = dfs(A,B)\n        \n        return dp[str(A)]\n                    \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        N = len(A)\n        if not N:\n            return 0\n        cnt = 0\n        \n        q = deque()\n        q.append((cnt, A, 0))\n        while q:\n            cnt, v, i = q.popleft()\n            \n            if v == B:\n                return cnt\n            \n            for j in range(i+1, N):\n                while v[i]==B[i]:\n                    i += 1\n                    \n                if v[j]==B[i] and v[j]!=B[j]:\n                    candidate = list(v)\n                    candidate[i], candidate[j] = candidate[j], candidate[i]\n                    candidate = ''.join(candidate)\n                    q.append((cnt+1, candidate, i+1))\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        self.N = len(A)\n        self.dict1 = collections.defaultdict()\n        return self.dfs(list(A), list(B), 0)\n                \n    \n    def dfs(self,A, B, pos):\n        sB = ''.join(B)\n        if sB in self.dict1:\n            return self.dict1[sB]\n            \n        if A == B:\n            return 0\n            \n        while A[pos] == B[pos]:\n            pos += 1\n                \n        minCnt = float('inf')\n        for i in range(pos + 1, self.N):\n            if B[i] == A[pos] and B[i] != A[i]:\n                B[i], B[pos] = B[pos], B[i]\n                tmp = self.dfs(A, B, pos + 1) + 1\n                minCnt = min(tmp, minCnt)\n                B[i], B[pos] = B[pos], B[i]\n                    \n        self.dict1[sB] = minCnt\n        return minCnt\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def dist(a, b):\n            # count number of differing characters\n            return sum( (1 if c!=d else 0 for (c,d) in zip(a,b) ) )\n\n        def swap(s, i, j):\n            # swap ith and jth chars of string s\n            # assert i != j\n            if i > j:\n                i, j = j, i\n            return s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n\n        def DFS(string, k, seen):\n            # print(f\\\"  {string}\\\")\n            if string in seen:\n                return False, 0\n            seen.add(string)\n            # print(f\\\"   {k}:   {string}\\\")\n            # can string be swapped into problem's str `A` in `k` moves?\n            if string == A:\n                return True, 1\n\n            # early break if distance is too great:\n            # best possible for string of length N:\n            #    N is even: N/2  (every swap corrects 2 letters\n            #    N is odd: N//2 + 1\n            #      every swap until last 3 letters corrects 2\n            #      last 3 letters take 2 swaps\n            distance = dist(string, A)\n            best = distance/2 if distance % 2 == 0 else (distance//2) + 1\n            if k < best:\n                return False, 1\n\n            neighbors = []\n            for i,c in enumerate(string):\n                if A[i] == c:\n                    continue\n                # c is wrong, we need to swap a correct letter into it\n                # only look for after current position to avoid double swaps\n                for j in range(i+1, len(A)):\n                    if string[j] == A[i] and A[j] != A[i]:\n                        double_play = string[i] == A[j]\n                        change = -2 if double_play else -1\n                        if k == best and distance % 2 == 1 and distance > 3 and not double_play:\n                            continue\n                        neighbor = swap(string, i, j)\n                        neighbors.append( (change, neighbor) )\n            neighbors.sort()\n\n            total_count = 1\n            for (score, neighbor) in neighbors:\n                found, count = DFS(neighbor, k-1, seen)\n                total_count += count\n                if found:\n                    return True, total_count\n\n            return False, total_count\n\n        for k in range(len(A), -1, -1):\n        # for k in range(len(A)):\n            found, count = DFS(B, k, set())\n            if not found:\n                return k+1\n        return 0\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        \n        def neighbor(x):\n            i = 0\n            while x[i] == B[i]:\n                i += 1\n            for j in range(i+1, len(x)):\n                if x[j] == B[i] and x[j] != B[j]:\n                    yield x[:i] + x[j] + x[i+1:j] + x[i] + x[j+1:]\n        \n        queue, seen = [(A, 0)], {A}\n        for word, distance in queue:\n            if word == B:\n                return distance\n            \n            for neigh in neighbor(word):\n                if neighbor not in seen:\n                    seen.add(neigh)\n                    queue.append((neigh, distance + 1))", "from collections import deque\n\nclass Solution:\n    def kSimilarity(self, A, B):\n        def find_neighbors(arr, i):\n            e = A[i]\n            nei = []\n            for x in range(i + 1, len(arr)):\n                if arr[x] == e:\n                    nei.append(x)\n            return nei\n\n        q = deque()\n        for i in range(len(A)):\n            if A[i] == B[i]:\n                continue\n            else:\n                q.append([list(B), i])\n                break\n\n        l = 0\n        while q:\n            for x in range(len(q)):\n                e = q.popleft()\n                y = e[1]\n                while y < len(e[0]):            #Move forward when elements of A and B are equal\n                    if e[0][y] == A[y]:\n                        y += 1\n                    else:\n                        break\n                if y == len(e[0]):               #If everything is equal return level\n                    return l\n                else:\n                    nei = find_neighbors(e[0], y)       #Find all A[i]'s to the right of B which are prospective candidates\n                    for n in nei:\n                        new_e = e[0][:]\n                        new_e[n] = e[0][y]            #Swap A[i] with all matched neighbors(Generating a new 'state')\n                        q.append([new_e, y + 1])\n            l += 1\n        return l", "class Solution:\n    def kSimilarity(self, A, B):\n        out = 0\n        q = deque()\n        for i in range(len(A)):\n            if A[i] == B[i]:\n                continue\n            else:\n                q.append([list(B), i])\n                break\n\n\n        def find_neighbors(arr, i):\n            e = A[i]\n            nei = []\n            for x in range(i + 1, len(arr)):\n                if arr[x] == e:\n                    nei.append(x)\n            return nei\n\n        while q:\n            for _ in range(len(q)):\n                cur, idx = q.popleft()\n                while idx < len(cur):\n                    if cur[idx] == A[idx]:\n                        idx += 1\n                    else: break\n                if idx == len(cur):\n                    return out\n                else:\n                    nei = find_neighbors(cur, idx)\n                    for n in nei:\n                        new = cur[:]\n                        new[n] = cur[idx]\n                        q.append([new, idx + 1])\n            out += 1\n        \n        return out", "class Solution:\n    def bfs(self, A: str, B: str):\n        if A == B: return 0\n        n = len(A)\n        q = []\n        # visited = [False for i in range(n)]\n        q.append((B, 0, 0))\n        while q:\n            processed, idx, swaps = q.pop(0)\n            while processed[idx] == A[idx]:\n                idx += 1\n            for i in range(idx+1,n):\n                if A[idx] == processed[i]:\n                    new_processed = processed[:idx] + processed[i] + processed[idx+1:i] + processed[idx] + processed[i+1:]\n                    if A == new_processed: return swaps + 1\n                    q.append((new_processed, idx+1, swaps+1))\n            \n        return 0\n        \n    def kSimilarity(self, A: str, B: str) -> int:\n        return self.bfs(A, B)", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        \n        def check(a,i):\n            if(a == B):\n                return 0\n            if a[i] != B[i]:\n                j=i\n                minCount = None\n                while(j<len(a)):\n                    if a[j] == B[i]:\n                        if a[i] == B[j]:\n                            return 1 + check(a[:i]+a[j]+a[i+1:j]+a[i]+a[j+1:],i+1)\n                        count = check(a[:i]+a[j]+a[i+1:j]+a[i]+a[j+1:],i+1)\n                        if minCount == None or minCount > count:\n                            minCount = count\n                    j+=1\n                return 1 + minCount\n                        \n            else:\n                return 0 + check(a,i+1)\n            \n        return check(A,0)", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        \n        A, B = list(A), list(B)\n        res = float('inf')\n        q = [(0, 0, B)] # (i) index, (k) swaps made, (B) current list\n        \n        while q:\n            \n            i, k, B = heapq.heappop(q)\n            i = -i\n            \n            if k >= res:\n                continue\n            \n            while (i < len(B)) and (B[i] == A[i]):\n                i += 1\n\n            if i == len(B):\n                res = min(res, k)\n                continue\n            \n            target = A[i]\n            j = i + 1\n            while j < len(B):\n                if B[j] == target:\n                    heapq.heappush(q, (-(i+1), k+1, B[:j]+[B[i]]+B[j+1:]))\n                j += 1\n        \n        return res\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        visited, n = set(), len(A)\n        q = collections.deque([(A, 0)])\n        while q:\n            C, swaps = q.popleft()\n            if C == B:\n                return swaps\n            visited.add(C)\n            i = 0\n            while C[i] == B[i]: \n                i += 1\n            for j in range(i + 1, n):\n                if C[j] == B[i]:\n                    nxt = C[:i] + C[j] + C[i+1:j] + C[i] + C[j+1:]\n                    if nxt not in visited:\n                        q.append((nxt, swaps + 1))\n        return -1\n            \n            \n", "from collections import deque\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def find_neighbors(arr, i):\n            e = A[i]\n            nei = []\n            for x in range(i + 1, len(arr)):\n                if arr[x] == e:\n                    nei.append(x)\n            return nei\n\n        q = deque()\n        for i in range(len(A)):\n            if A[i] == B[i]:\n                continue\n            else:\n                q.append([list(B), i])\n                break\n\n        l = 0\n        while q:\n            for x in range(len(q)):\n                e = q.popleft()\n                y = e[1]\n                while y < len(e[0]):            #Move forward when elements of A and B are equal\n                    if e[0][y] == A[y]:\n                        y += 1\n                    else:\n                        break\n                if y == len(e[0]):               #If everything is equal return level\n                    return l\n                else:\n                    nei = find_neighbors(e[0], y)       #Find all A[i]'s to the right of B which are prospective candidates\n                    for n in nei:\n                        new_e = e[0][:]\n                        new_e[n] = e[0][y]            #Swap A[i] with all matched neighbors(Generating a new 'state')\n                        q.append([new_e, y + 1])\n            l += 1\n        return l", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def dist(a, b):\n            # count number of differing characters\n            return sum( (1 if c!=d else 0 for (c,d) in zip(a,b) ) )\n\n        def find_wrong_letters(working):\n            # given a working string, return two dicts that track work to be done:\n            #   (wants, wrongs)\n            # `wants[target]` maps to set of positions that need `target` letter\n            # `wrongs[letter]` maps to set positions that have a wrong `letter`\n            #     if i in wants{target] and j in wrongs[letter]\n            #       we can swap ith and jth letters to improve working\n            wants = defaultdict(set)\n            wrongs = defaultdict(set)\n            for i, c in enumerate(working):\n                target = A[i]\n                if c != target:\n                    wants[target].add(i)\n                    wrongs[c].add(i)\n            return wants, wrongs\n\n        def estimate_remaining(string):\n            # count number of wrong letters\n            # assume a perfect scenario:\n            #    each swap fixes two letters\n            count = dist(string, A)\n            return count/2 if count % 2 == 0 else count//2 + 1\n\n        def swap(s, i, j):\n            # swap ith and jth chars of string s\n            # assert i != j\n            if i > j:\n                i, j = j, i\n            return s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n\n        def extend(working):\n            wrongs, needs = find_wrong_letters(working)\n            for letter, wrong_set in list(wrongs.items()):\n                return ( swap(working, i, j) for i in wrong_set for j in needs[letter] )\n\n        # print(A)\n        # print(B)\n        # print(\\\"0123456789abcdefghijklmnopqrst\\\"[:len(A)])\n        # needs, wrongs = find_wrong_letters(B)\n        # print(f\\\"wrong: {wrongs}\\\")\n        # print(f\\\"needs: {needs}\\\")\n        # return 0\n\n        if A == B:\n            return 0\n        # BFS\n        # q is a heap that holds triples:\n        #   (estimate, swap_count_so_far, the_working_string)\n        q = [ (0,0,B) ]\n        seen = dict()\n        best = len(A)\n        while q:\n            estimate, k, working = heapq.heappop(q)\n            if estimate >= best or k >= best:\n                return best\n            if working == A:\n                best = min( best, k)\n                continue\n            for extension in extend(working):\n                if extension not in seen or seen[extension] > k+1:\n                    seen[extension] = k+1\n                    new_estimate = estimate_remaining(extension) + k + 1\n                    heapq.heappush( q, (new_estimate, k+1, extension) )\n        return best\n", "class Solution:\n    def kSimilarity(self, A, B):\n        def find_neighbors(arr, i):\n            e = A[i]\n            nei = []\n            for x in range(i + 1, len(arr)):\n                if arr[x] == e:\n                    nei.append(x)\n            return nei\n\n        q = deque()\n        for i in range(len(A)):\n            if A[i] == B[i]:\n                continue\n            else:\n                q.append([list(B), i])\n                break\n\n        l = 0\n        while q:\n            for x in range(len(q)):\n                e = q.popleft()\n                y = e[1]\n                while y < len(e[0]):            #Move forward when elements of A and B are equal\n                    if e[0][y] == A[y]:\n                        y += 1\n                    else:\n                        break\n                if y == len(e[0]):               #If everything is equal return level\n                    return l\n                else:\n                    nei = find_neighbors(e[0], y)       #Find all A[i]'s to the right of B which are prospective candidates\n                    for n in nei:\n                        new_e = e[0][:]\n                        new_e[n] = e[0][y]            #Swap A[i] with all matched neighbors(Generating a new 'state')\n                        q.append([new_e, y + 1])\n            l += 1\n        return l", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A == B:\n            return 0\n        \n        m = len(A)\n        \n        def getNeighbors(word):\n            i = 0\n            while word[i] == B[i]:\n                i+=1\n            \n            for j in range(i+1, m):\n                if word[j] == B[i]:\n                    yield word[:i] + word[j] + word[i+1:j] + word[i] + word[j+1:]\n        \n        visited = set([A])\n        queue = collections.deque([A])\n        \n        k = 1\n        while queue:\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                for nbor in getNeighbors(word):\n                    if nbor not in visited:\n                        if nbor == B:\n                            return k\n                        queue.append(nbor)\n            \n            k += 1\n        \n        raise Exception('invalid')", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A == B:\n            return 0\n        \n        m = len(A)\n        \n        def getNeighbors(word):\n            i = 0\n            while word[i] == B[i]:\n                i+=1\n            \n            for j in range(i+1, m):\n                if word[j] == B[i] and word[j] != word[i]:\n                    yield word[:i] + word[j] + word[i+1:j] + word[i] + word[j+1:]\n        \n        visited = set([A])\n        queue = collections.deque([A])\n        \n        k = 1\n        while queue:\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                for nbor in getNeighbors(word):\n                    if nbor not in visited:\n                        if nbor == B:\n                            return k\n                        queue.append(nbor)\n            \n            k += 1\n        \n        raise Exception('invalid')", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        n = len(B)\n        q = deque([B])\n        visited = {B}\n        \n        cnt = 0\n        \n        while q:\n            L = len(q)\n            for _ in range(L):\n                cur = q.popleft()\n                if cur == A:\n                    return cnt\n                \n                pos = 0\n                while A[pos] == cur[pos]:\n                    pos += 1\n                    \n                curlist = list(cur)\n                \n                for i in range(pos+1, n):\n                    \n                    if curlist[i] == A[pos] and curlist[i] != A[i]:\n                        curlist[i], curlist[pos] = curlist[pos], curlist[i]\n                        \n                        curstr = ''.join(curlist)\n                        if curstr not in visited:\n                            q.append(curstr)\n                            \n                        visited.add(curstr)\n                        curlist[i], curlist[pos] = curlist[pos], curlist[i]\n            cnt += 1\n            \n        return cnt", "from functools import lru_cache\nclass Solution:\n    @lru_cache(None)\n    def kSimilarity(self, A: str, B: str) -> int:\n        if len(A)==0:\n            return 0\n        \n        if A[0]==B[0]:\n            return self.kSimilarity(A[1:],B[1:])\n        \n        for i in range(1,len(B)):\n            if A[0]==B[i] and B[0]==A[i]:\n                return 1 + self.kSimilarity(A[1:i]+A[i+1:], B[1:i]+B[i+1:])\n            \n        ans = math.inf\n        for i in range(1,len(B)):\n            if A[0]==B[i]: ans = min(ans, 1+self.kSimilarity(A[1:], B[1:i]+B[0]+B[i+1:]))\n        \n        return ans", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A == B:\n            return 0\n        \n        def swap(S, i, j):\n            a = list(S)\n            a[i], a[j] = a[j], a[i]\n            return ''.join(a)\n        \n        n = len(A)\n        steps = 0\n        q = deque()\n        visited = set()\n        q.append(A)\n        visited.add(A)\n        \n        while q:\n            steps += 1\n            sz = len(q)\n            for _ in range(sz):\n                S = q.popleft()\n                i = 0\n                while S[i] == B[i]:\n                    i += 1\n                for j in range(i + 1, n):\n                    if S[j] != B[i] or S[j] == B[j]:\n                        continue\n                    T = swap(S, i, j)\n                    if T == B:\n                        return steps\n                    if T not in visited:\n                        q.append(T)\n                        visited.add(T)\n        \n        return steps\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        #assert(len(A) == len(B))\n        #assert(sorted(A) == sorted(B))\n        \n        if A == B:\n            return 0\n        \n        seen = set(A)\n        q = deque()\n        q.append((A,0))\n        while q:\n            currentString, k = q.popleft()\n            \n            for i in range(0, len(B)-1):\n                if currentString[i] == B[i]:\n                        continue\n                        \n                for j in range(i+1,len(B)):   \n                    if currentString[j] == B[j]:\n                        continue\n                        \n                    if currentString[i] == currentString[j]:\n                        continue\n                        \n                    if currentString[j] != B[i]:\n                        continue\n                        \n                    \n                    newString = currentString[:i] + currentString[j] + currentString[i+1:j] + currentString[i] + currentString[j+1:]\n                    \n                    if newString == B:\n                        return k+1\n                    \n                    if newString not in seen:\n                        q.append((newString,k+1))\n                        seen.add(newString)\n                break\n                    \n        return -1", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def nei(x):\n            i = 0\n            while x[i] == B[i]: i+=1 #continue incremeneting if characters are same\n            for j in range(i+1, len(x)):\n                if x[j] == B[i] and x[j] != B[j]:\n                    yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:] #swaps the two characters\n        q, seen = [(A,0)], {A}\n\n        while q != []:\n            x, d = q.pop(0)\n            if x == B: return d #return immediately from BFS if the strings are the same\n            for y in nei(x):\n                #print(\\\"y\\\", y)\n                if y not in seen:\n                    seen.add(y), q.append((y,d+1))\n            #print(\\\"q\\\", q)\n", "from collections import deque \nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        \n        if A==B:\n            return 0 \n        \n        queue = deque([])\n        queue.append(A)\n        step = 0 \n        visited = set()\n        while queue:\n            length = len(queue)\n            \n            while length:\n                length-=1\n                strings = queue.popleft()\n                \n                i = 0 \n                while strings[i]==B[i]:\n                    i+=1\n                newstrings = list(strings)\n                cha = strings[i]\n                for j in range(i+1, len(strings)):\n                    if strings[j]==B[i] and strings[j]!=B[j]:\n                        newstrings[i], newstrings[j] = newstrings[j], newstrings[i]\n                        newstrings = ''.join(newstrings)\n                        if newstrings == B:\n                            return step+1 \n                        else:\n                            if newstrings not in visited:\n                                visited.add(newstrings)\n                                queue.append(newstrings)\n                        newstrings = list(strings)\n                        \n                    \n                \n            \n        \n            step+=1\n        \n        \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        '''\n        A classic BFS solution to find the shortest path;\n        The neighbors to each node string S are all the strings reachable with 1 swap, that match the first unmatched character in S.\n        '''\n        def getNeighbors(s):\n            for i, c in enumerate(s):\n                if c!=B[i]: break\n            s = list(s)\n            for j in range(i+1,len(s)):\n                if s[j]==B[i] and s[j]!=B[j]:\n                    s[i],s[j]=s[j],s[i]\n                    yield(''.join(s))\n                    s[j],s[i]=s[i],s[j]\n        \n        queue = collections.deque([A])\n        seen = {A:0}\n        while queue:\n            s = queue.popleft()\n            if s==B: return seen[s]\n            for n in getNeighbors(s):\n                if n not in seen:\n                    seen[n]=seen[s]+1\n                    queue.append(n)\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        l = len(A)\n        def neighbor(s,pos,target):\n            visited = set()\n            t = list(s)\n            for i in range(pos+1,l):\n                if t[i] == target and (t[i],B[i]) not in visited:\n                    visited.add((t[i],B[i]))\n                    t[pos],t[i] = t[i],t[pos]\n                    yield(''.join(t))\n                    t[pos],t[i] = t[i],t[pos]\n        step = 0\n        index = 0\n        seen = set()\n        q = collections.deque()\n        q.append((A,0))\n        seen.add(A)\n        \n        while q:\n            lq = len(q)\n            for j in range(lq):\n                tmp,k = q.popleft()\n                if tmp == B:\n                    return step\n                while k<l and tmp[k] == B[k]:\n                    k+=1\n                for n in neighbor(tmp,k,B[k]):\n                    if n not in seen:\n                        seen.add(n)\n                        q.append((n,k))\n            step += 1\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A == B:\n            return 0\n        visited = set([A])\n        q = collections.deque([A])\n        res, n = 0, len(A)\n        while q:\n            res += 1\n            qn = len(q)\n            for _ in range(qn):\n                s = q.popleft()\n                i = 0\n                while i < n and s[i] == B[i]:\n                    i += 1\n                for j in range(i+1, n):\n                    if s[j] == B[j] or s[j] != B[i]:\n                        continue\n                    tmp = self.swap(s, i, j)\n                    if tmp == B:\n                        return res\n                    if tmp not in visited:\n                        visited.add(tmp)\n                        q.append(tmp)\n        return res\n\n    def swap(self, s: str, i: int, j: int) -> str:\n        l = list(s)\n        l[i], l[j] = l[j], l[i]\n        return ''.join(l)", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n\n        def dist(a, b):\n            # count number of differing characters\n            return sum( (1 if c!=d else 0 for (c,d) in zip(a,b) ) )\n\n        def find_wrong_letters(working):\n            # given a working string, return two dicts that track work to be done:\n            #   (wants, wrongs)\n            # `wants[target]` maps to set of positions that need `target` letter\n            # `wrongs[letter]` maps to set positions that have a wrong `letter`\n            #     if i in wants{target] and j in wrongs[letter]\n            #       we can swap ith and jth letters to improve working\n            wants = defaultdict(set)\n            wrongs = defaultdict(set)\n            for i, c in enumerate(working):\n                target = A[i]\n                if c != target:\n                    wants[target].add(i)\n                    wrongs[c].add(i)\n            return wants, wrongs\n\n        def swap(s, i, j):\n            # swap ith and jth chars of string s\n            # assert i != j\n            if i > j:\n                i, j = j, i\n            return s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n\n        def extend(working):\n            wrongs, needs = find_wrong_letters(working)\n            for letter, wrong_set in list(wrongs.items()):\n                return ( swap(working, i, j) for i in wrong_set for j in needs[letter] )\n\n        # greedy BFS\n        #    only search\n        # q holds triples:\n        #   (estimate, swap_count_so_far, the_working_string)\n        q = deque()\n        q.append( (0, 0, B) )\n        seen = dict()\n        best = len(A)\n        while q:\n            estimate, k, working = q.popleft()\n            if estimate >= best or k >= best:\n                return best\n            if working == A:\n                best = min( best, k)\n                continue\n\n            improves_one, improves_two = [], []\n            for extension in extend(working):\n                improvement = dist(A, working) - dist(A, extension)\n                # improvement = 2\n                if improvement == 2:\n                    improves_two.append(extension)\n                else:\n                    improves_one.append(extension)\n            for extension in improves_two or improves_one:\n                if extension not in seen or seen[extension] > k+1:\n                    seen[extension] = k+1\n                    q.append( (0, k+1, extension) )\n        return best\n\n", "from collections import deque\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        # BFS\n        # Key: at every step, we swap and make sure we put one char at correct pos, BFS makes sure it's shortest\n        \n        length = len(A)\n        q = deque([A])\n        visited = set([A])\n        step = 0\n        while q:\n            size = len(q)\n            for _ in range(size):\n                cur = q.popleft()\n                \n                if cur == B: return step\n                \n                for i in range(length):\n                    if cur[i] != B[i]: break\n                \n                for j in range(i + 1, length):\n                    # Key: NOT (cur[j] == B[i] or cur[i] == B[j])!!! Because in each BFS level we only need to make sure i pos can be corrected by swap(i,j), in the next level, since range of i and j is decreasing, width of BFS won't too large.\n                    # But cur[i]==B[j] NOT guarantee i pos is corrected, next level it might still starts from i, thus range of search is width and got TLE\n                    if cur[j] != B[j] and cur[j] == B[i]:\n                        new_str = cur[: i] + cur[j] + cur[i+1: j] + cur[i] + cur[j + 1:]\n                        if new_str not in visited:\n                            q.append(new_str)\n                            visited.add(new_str)\n            \n            step += 1\n", "class Solution:\n    @lru_cache(None)\n    def kSimilarity(self, A: str, B: str) -> int:\n        if len(A) == 0: return 0\n        if A[0]==B[0]: return self.kSimilarity(A[1:],B[1:])\n        for i in range(1,len(B)):\n            if B[i]==A[0] and A[i]==B[0]: \n                return 1 + self.kSimilarity(A[1:i]+A[i+1:],B[1:i]+B[i+1:])\n        ans = math.inf\n        for i in range(1,len(B)): \n            if B[i]==A[0]: ans = min(ans, 1+self.kSimilarity(A[1:],B[1:i]+B[0]+B[i+1:]))\n        return ans", "from collections import deque\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def swapPos(string):\n            i = 0\n            while string[i] == B[i]:\n                i += 1\n            for j in range(i+1, length):\n                if string[j] == B[i] and string[j] != B[j]:\n                    yield string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]\n\n        dq = deque([(A, 0)])\n        visited = set(A)\n        length = len(A)\n        while dq:\n            string, dist = dq.popleft()\n            if string == B:\n                return dist\n            for s2 in swapPos(string):\n                if s2 not in visited:\n                    dq.append((s2, dist+1))\n                    visited.add(s2)", "# class Solution:\n#     def kSimilarity(self, A: str, B: str) -> int:\n#         n = len(A)\n#         A, B = list(A), list(B)\n#         mp = defaultdict(list)\n#         for i, ch in enumerate(A):\n#             mp[ch].append(i)\n#         def dfs(idx):\n#             if idx == n:\n#                 return 0\n#             if A[idx] == B[idx]:\n#                 return dfs(idx+1)\n#             res = float('inf')\n#             for nxt in range(idx+1,n):\n#                 if A[nxt] != B[idx]:\n#                     continue\n#                 A[idx], A[nxt] = A[nxt], A[idx]\n#                 res = min(res, dfs(idx+1)+1)\n#                 A[idx], A[nxt] = A[nxt], A[idx]\n#             return res\n#         return dfs(0)\n\nfrom functools import lru_cache\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        n = len(A)\n        # mp = defaultdict(list)\n        # for i, ch in enumerate(A):\n        #     mp[ch].append(i)\n        @lru_cache(None)\n        def dfs(s):\n            if s == B:\n                return 0\n            idx = 0\n            while s[idx] == B[idx]:\n                idx += 1\n            res = float('inf')\n            for nxt in range(idx+1,n):\n                if s[nxt] != B[idx] or s[nxt] == B[nxt]:\n                    continue\n                res = min(res, dfs(s[:idx]+s[nxt]+s[idx+1:nxt]+s[idx]+s[nxt+1:])+1)\n            return res\n        return dfs(A)", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def next(s):\n            for i in range(len(s)):\n                if s[i] != B[i]:\n                    for j in range(i + 1,len(s)):\n                        if B[i] == s[j] and B[j] == s[i]:\n                            yield s[:i]+s[j]+s[i+1:j]+s[i]+s[j+1:]\n                    for j in range(i + 1,len(s)):    \n                        if B[i] == s[j] and B[j] != s[j]:\n                            yield s[:i]+s[j]+s[i+1:j]+s[i]+s[j+1:]\n                    return\n        res = 0\n        if A == B:\n            return res\n        q = [(A,0)]\n        seen = {A}\n        for s,i in q:\n            if s == B:\n                return i\n            for n in next(s):\n                if n not in seen:  \n                    q.append((n,i + 1))\n                    seen.add(n)\n        return -1\n                    \n        \n\n        \n            \n            \n            \n            \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def get_neis(s):\n            res = []\n            for i in range(N):\n                if s[i]!=B[i]:\n                    break\n            \n            temp = list(s)\n            for j in range(i+1, N):\n                if s[j]==B[i] and s[j]!=B[j]:\n                    temp[i], temp[j] = temp[j], temp[i]\n                    res.append(''.join(temp))\n                    temp[i], temp[j] = temp[j], temp[i]\n                    \n            return res\n        \n        if A==B: return 0\n        N = len(A)\n        dq = deque([A])\n        seen = set([A])\n        cnt = 0\n        while dq:\n            length = len(dq)\n            \n            for _ in range(length):\n                s = dq.popleft()\n                \n                for nei in get_neis(s):\n                    if nei==B: return cnt+1\n                    \n                    if nei not in seen:\n                        seen.add(nei)\n                        dq.append(nei)\n            \n            cnt += 1", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def swap(s):\n            i=0\n            while s[i]==B[i]:\n                i+=1\n       \n            for j in range(i+1,len(s)):\n                if s[j]==B[i] and B[j]!=s[j]:\n                    yield s[:i]+s[j]+s[i+1:j]+s[i]+s[j+1:]\n                    \n        q=collections.deque([(A,0)])\n        seen={A}\n        \n        while q:\n            s,d=q.popleft()\n            if s==B:\n                return d\n            for n in swap(s):\n                if n not in seen:\n                    seen.add(n)\n                    q.append((n,d+1))\n                    \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def nei(x):\n            i = 0\n            while x[i] == B[i]: i+=1\n            for j in range(i+1, len(x)):\n                if x[j] == B[i] and x[j] != B[j]: yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n        q, seen = [(A,0)], {A}\n        for x, d in q:\n            if x == B: return d\n            for y in nei(x):\n                if y not in seen:\n                    seen.add(y), q.append((y,d+1))", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        lsta, lstb = [], []\n        for i in range(len(A)):\n            if A[i] != B[i]:\n                lsta.append(A[i])\n                lstb.append(B[i])\n        A, B = ''.join(lsta), ''.join(lstb)\n        q = deque([(0, A, B)])\n        while q:\n            cost, curr, goal = q.popleft()\n            if not curr:\n                return cost\n            need = goal[0]\n            work = None\n            for i in range(len(curr)):\n                # need to find one where curr[i] == goal[0] and goal[i] == curr[0]\n                if curr[i] == goal[0] and goal[i] == curr[0]:\n                    work = i\n                    break\n            if work:\n                # only swap this one\n                # remove 0 and work from the unmatched list\n                q.append((cost+1, curr[1:work]+curr[work+1:], goal[1:work]+goal[work+1:]))\n            else:\n                for i in range(1, len(curr)):\n                    if curr[i] == need:\n                        q.append((cost+1, curr[1:i]+curr[0]+curr[i+1:], goal[1:]))", "from collections import deque\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        \n        def nei(x):\n            i = 0 \n            while x[i] == B[i]:\n                i += 1\n            for j in range(i+1, len(x)):\n                if x[j] == B[i] and x[j] != B[j]:\n                    yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n        \n        if not A or not B: return 0\n        \n        queue, visited = [(A, 0)], {A}\n        \n        for x, d in queue:\n            if x == B: return d\n            for y in nei(x):\n                if y not in visited:\n                    visited.add(y)\n                    queue.append((y, d+1))\n        \n        \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A==B: return 0\n        dq = deque([(A,0)])\n        cnt = 0\n        N = len(A)\n        seen = set()\n        while dq:\n            length = len(dq)\n            \n            for _ in range(length):\n                curr, idx = dq.popleft()\n                lst = list(curr)\n                \n                for i in range(idx, N):\n                    if lst[i]!=B[i]:\n                        for j in range(i+1, N):\n                            if lst[j]!=B[j] and lst[j]==B[i]:\n                                lst[i], lst[j] = lst[j], lst[i]\n                                temp = ''.join(lst)\n                                if temp==B:\n                                    return cnt+1\n                                if temp not in seen:\n                                    seen.add(temp)\n                                    dq.append((temp, i+1))\n                                lst[i], lst[j] = lst[j], lst[i]\n                        break\n                \n            cnt += 1\n        \n        \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A == B:\n            return 0\n        dp = [B]\n        visit = {B}\n        k = 0\n        while dp:\n            k += 1\n            l = len(dp)\n            for i in range(l):\n                s = dp.pop()\n                for j, c in enumerate(A):\n                    if c != s[j]:\n                        for n in range(j+1, len(A)):\n                            if s[n] == c:\n                                newS = s[0:j] + s[n] + s[j+1:n] + s[j] + s[n+1:]\n                                if newS not in visit:\n                                    if newS == A:\n                                        return k\n                                    dp.insert(0, newS)\n                                    visit.add(newS)\n                        break", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n\n        def dist(a, b):\n            # count number of differing characters\n            return sum( (1 if c!=d else 0 for (c,d) in zip(a,b) ) )\n\n        def estimate_remaining(string):\n            # count number of wrong letters\n            # assume a perfect scenario:\n            #    each swap corrects two letters\n            count = dist(string, A)\n            return count/2 if count % 2 == 0 else count//2 + 1\n\n        def find_wrong_letters(working):\n            # given a working string, return two dicts that track work to be done:\n            #   (wants, wrongs)\n            # `wants[target]` maps to set of positions that need `target` letter\n            # `wrongs[letter]` maps to set positions that have a wrong `letter`\n            #     if i in wants{target] and j in wrongs[letter]\n            #       we can swap ith and jth letters to improve working\n\n            wants = defaultdict(set)\n            wrongs = defaultdict(set)\n            for i, c in enumerate(working):\n                target = A[i]\n                if c != target:\n                    wants[target].add(i)\n                    wrongs[c].add(i)\n            return wants, wrongs\n\n        def swap(s, i, j):\n            # swap ith and jth chars of string s\n            # assert i != j\n            if i > j:\n                i, j = j, i\n            return s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n\n        def extend(working):\n            wrongs, needs = find_wrong_letters(working)\n            for letter, wrong_set in list(wrongs.items()):\n                return ( swap(working, i, j) for i in wrong_set for j in needs[letter] )\n\n        # BFS\n        # q is a heap that holds triples:\n        #   (estimate, swap_count_so_far, the_working_string)\n        # q = deque()\n        q = [ (0, 0, B) ]\n        seen = dict()\n        best = len(A)\n        while q:\n            estimate, k, working = heapq.heappop(q)\n            if estimate >= best or -k >= best:\n                return best\n            if working == A:\n                best = min( best, -k)\n                continue\n            for extension in extend(working):\n                if extension not in seen or seen[extension] > -k+1:\n                    seen[extension] = k+1\n                    new_estimate = estimate_remaining(extension) -k + 1\n                    heapq.heappush( q, (new_estimate, k-1, extension) )\n        return best\n\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        # \u6839\u636e\u6700\u540e\u4e00\u4f4d\u662f\u5426\u76f8\u7b49\u8fdb\u884c\u8d2a\u5fc3\u7684\u6c42\u89e3\u3002dfs\u6df1\u641c\n        memo = {}\n        def helper(a, b):\n            if a == b:\n                return 0\n            if (a, b) in memo:\n                return memo[(a, b)]\n            res = float('inf')\n            if a[-1] == b[-1]:\n                res = min(res, helper(a[:-1], b[:-1]))\n            else:\n                for i in range(len(a) - 1):\n                    if a[i] == b[-1] and a[i] != b[i]:   \n                        # \u5207\u8bb0\u5f53\u524d\u4f4d\u7f6e\u7684ab\u4e0d\u80fd\u5bf9\u5e94\u76f8\u7b49\uff0c\u8981\u4e0d\u7136\u80af\u5b9a\u591a\u64cd\u4f5c\u4e86\u3002\n                        a_new = a[:i] + a[-1] + a[i + 1:-1]  #\u628aa[i]\u4e0ea[-1]\u4ea4\u6362\u4e86\n                        res = min(res, 1 + helper(a_new, b[:-1]))\n            memo[(a, b)] = res\n            return res\n        return helper(A, B)\n        '''\n        # \u8fd9\u9053\u9898\u867d\u7136\u662fhard\u4f46\u662f\u901a\u8fc7\u4f60\u7406\u89e3\u9898\u610f\uff0c\u5f88\u5bb9\u6613\u627e\u5230\u6f5c\u5728\u7684\u89e3\u7b54\u65b9\u6cd5\u3002\n        # \u7b2c\u4e00\u91cd\u601d\u8def\u5c31\u662f\u770b\u5230\u6700\u5c0f\u3002\u90a3\u4e48\u53ea\u8981\u6bd4\u6700\u5c0f\u7684\u5927\u90fdOK\uff0c\u90a3\u4e48\u5f88\u5bb9\u6613\u60f3\u5230\u7528\u4e8c\u5206\u6cd5\u53bb\u731c\u6d4b\u7b54\u6848\u3002\u4f46\u662f\u5982\u4f55check\u5b58\u7591\n        # \u7b2c\u4e8c\u91cd\u601d\u8def\u5c31\u662f\u770b\u5230\u4e24\u4e2anode\u3002\u7b2c\u4e00\u4e2anode\u901a\u8fc7\u4ea4\u6362\u53d8\u6210\u7b2c\u4e8c\u4e2a\u3002\u4ea4\u6362\u7684\u53ef\u80fd\u6027\u5f88\u591a\u3002\u56e0\u6b64\u53ef\u4ee5\u770b\u4e58bfs\n        # BFS\u5c31\u662f\u7ed9\u4f60\u4e00\u4e2a\u8d77\u70b9\u4e00\u4e2a\u7ec8\u70b9\uff0c\u95ee\u4f60\u6700\u8fd1\u7684\u8ddd\u79bb\uff0c\u6700\u5c11\u7684\u65b9\u5f0f\u7b49\u7b49\u662f\u591a\u5c11\uff01\n        # by build directed edges bfs to find k\n        def neighbor(x):\n            i = 0\n            while x[i] == B[i]:  # \u66f4\u6362\u7684\u79cd\u7c7b\u5f88\u591a\u79cd\uff0c\u4f46\u662f\u4ecd\u7136\u9700\u8981\u526a\u679d\u65e0\u6548\u7684\u3002\u56e0\u6b64\u76f8\u540c\u90e8\u5206\u5c31\u4e0d\u6539\u53d8\u4e86\u3002\n                i += 1\n            for j in range(i + 1, len(x)): # \u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u540c\u7684\u5730\u65b9\uff0c\u7136\u540e\u53bb\u627e\u53ef\u4ee5\u8fc7\u6765\u586b\u5751\u7684letter\n                if x[j] == B[i]:\n                    yield x[:i] + x[j] + x[i + 1:j] + x[i] + x[j + 1:]\n        q, seen = [(A, 0)], {A}\n        for x, d in q:\n            if x == B:\n                return d\n            for y in neighbor(x):\n                if y not in seen:\n                    seen.add(y)\n                    q.append((y, d + 1))\n        '''", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        lsta, lstb = [], []\n        for i in range(len(A)):\n            if A[i] != B[i]:\n                lsta.append(A[i])\n                lstb.append(B[i])\n        A, B = ''.join(lsta), ''.join(lstb)\n        q = deque([(0, A, B)])\n        while q:\n            cost, curr, goal = q.popleft()\n            if not curr:\n                return cost\n            need = goal[0]\n            work = None\n            for i in range(len(curr)):\n                # need to find one where curr[i] == goal[0] and goal[i] == curr[0]\n                if curr[i] == goal[0] and goal[i] == curr[0]:\n                    work = i\n                    break\n            if work:\n                # only swap this one\n                q.append((cost+1, curr[1:work]+curr[work+1:], goal[1:work]+goal[work+1:]))\n            else:\n                for i in range(1, len(curr)):\n                    if curr[i] == need:\n                        q.append((cost+1, curr[1:i]+curr[0]+curr[i+1:], goal[1:]))", "from collections import deque\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def nei(x):\n            i = 0\n            while x[i] == B[i]: i+=1\n            for j in range(i+1, len(x)):\n                if x[j] == B[i] and x[j] != B[j]: yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n        q, seen = [(A,0)], {A}\n        for x, d in q:\n            if x == B: return d\n            for y in nei(x):\n                if y not in seen:\n                    seen.add(y), q.append((y,d+1))", "class Solution:\n    # save the indices of letters that are in the right place\n    # create array 'correct' where the index corresponds to the letter in A and the value is the correct index\n    # find every letter pair --> a pair is two letters in B that when swapped, will end up in the correct index\n    # dynamic programming? number of displaced letters --> min # of swaps\n    # subproblem = number of displaced letters\n    # at most 20 swaps\n    def kSimilarity(self, A: str, B: str) -> int:\n        q, visited = [(A,0)], {A}\n        # BFS\n        for x, dist in q:\n            if x == B: return dist\n            for y in self.generate_neighbour_strings(x, B):\n                if y not in visited:\n                    visited.add(y), q.append((y,dist+1))\n                \n                \n        \n    def generate_neighbour_strings(self, x, B):\n        i = 0\n        while x[i] == B[i]: i+=1\n        for j in range(i+1, len(x)):\n            if x[j] == B[i] and x[j] != B[j]: yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A == B:\n            return 0\n        \n        queue = collections.deque([A])\n        visited = set([A])\n        step = 0\n        \n        while queue:\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for nxt in self.findNext(curr, B):\n                    if nxt == B:\n                        return step + 1\n                    if nxt in visited:\n                        continue\n                    queue.append(nxt)\n                    visited.add(nxt)\n            step += 1\n        return -1\n    \n    def findNext(self, curr, B):\n        for i in range(len(curr)):\n            if curr[i] != B[i]:\n                break\n        \n        for j in range(i + 1, len(B)):\n            if curr[j] == B[i]:\n                yield curr[:i] + curr[j] + curr[i + 1: j] + curr[i] + curr[j + 1:]\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        return self.recursion(A, B, {})\n        \n    def recursion(self, A: str, B: str, memo: dict) -> int:\n\n        if A == '':\n            return 0\n        \n        key = A + ',' + B\n        if key in memo:\n            return memo[key]\n        \n        if A[0] == B[0]:\n            return self.recursion(A[1:], B[1:], memo)\n        \n        move = 100000\n        for i in range(1, len(A)):\n            if B[i] == A[0]:\n                tempB = B[1:i] + B[0] + B[i + 1:]\n                move = min(move, self.recursion(A[1:], tempB, memo))\n\n        memo[key] = move + 1\n        return 1 + move", "class Solution:\n    from collections import deque\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A==B: return 0\n        \n        def G(pat):\n            for i in range(len(B)-1):\n                if pat[i] != B[i]:\n                    break\n            \n            ans = []\n            for j in range(i+1,len(B)):\n                if pat[j] == B[i]:\n                    ans.append(pat[:i] + pat[j] + pat[i+1:j] + pat[i] + pat[j+1:])\n            return ans\n        \n        Q = deque([])\n        visited = set()\n        visited.add(A)\n        Q.append((0,A))\n        while(Q):\n            lv, pat = Q.popleft()\n            #if pat==B:\n            #    return lv\n            \n            for new in G(pat):\n                if new not in visited:\n                    visited.add(new)\n                    Q.append((lv+1,new))\n                    if new == B:\n                        return lv+1\n            \n            #print(Q,visited)\n            \n        \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A==B: return 0\n        N = len(A)\n        dq = deque([(A, 0)])\n        cnt = 0\n        seen = {A}\n        while dq:\n            length = len(dq)\n            \n            for _ in range(length):\n                a, idx = dq.popleft()\n                \n                for i in range(idx, N):\n                    if a[i]!=B[i]:\n                        break\n                else:\n                    return cnt\n                \n                lst = list(a)\n                for j in range(i+1, N):\n                    if a[j]!=B[j] and a[j]==B[i]:\n                        lst[j], lst[i] = lst[i], lst[j]\n                        state = ''.join(lst)\n                        if state not in seen:\n                            seen.add(state)\n                            dq.append((state, i+1))\n                        lst[j], lst[i] = lst[i], lst[j]\n                        if a[i]==B[j]:\n                            break\n                            \n            cnt += 1\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def get_neis(s):\n            res = []\n            for i in range(N):\n                if s[i]!=B[i]:\n                    break\n            \n            temp = list(s)\n            for j in range(i+1, N):\n                if s[j]==B[i]: #and s[j]!=B[j]:\n                    temp[i], temp[j] = temp[j], temp[i]\n                    res.append(''.join(temp))\n                    temp[i], temp[j] = temp[j], temp[i]\n                    \n            return res\n        \n        if A==B: return 0\n        N = len(A)\n        dq = deque([A])\n        seen = set([A])\n        cnt = 0\n        while dq:\n            length = len(dq)\n            \n            for _ in range(length):\n                s = dq.popleft()\n                \n                for nei in get_neis(s):\n                    if nei==B: return cnt+1\n                    \n                    if nei not in seen:\n                        seen.add(nei)\n                        dq.append(nei)\n            \n            cnt += 1", "class Solution:\n    @lru_cache(None)\n    def kSimilarity(self, A: str, B: str) -> int:\n        if len(A) == 0: return 0\n        if A[0]==B[0]: return self.kSimilarity(A[1:],B[1:])\n        ans = math.inf\n        for i in range(1,len(B)): \n            if B[i]==A[0]: ans = min(ans, 1+self.kSimilarity(A[1:],B[1:i]+B[0]+B[i+1:]))\n        return ans", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A==B:\n            return 0\n        step_list = []\n        A_list = []\n        for i in range(len(A)):\n            A_list.append(A[i])\n\n        states = [[A_list.copy(),0,0],] #list, index, step\n        while states != []:\n            state = states.pop(0)\n            indictor = 0\n            for i in range(state[1],len(A_list)):\n                if state[0][i] != B[i]:\n                    indictor = 1\n                    for j in range(i+1,len(A_list)):\n                        if state[0][j] == B[i] and B[j] != state[0][j]:\n                            new_state = state[0].copy()\n                            new_state[j], new_state[i] = new_state[i], new_state[j]\n                            states.append([new_state,i+1,state[2]+1])\n                            if B[j] == state[0][i]:\n                                break\n                    break\n            if indictor == 0:\n                step_list.append(state[2])\n        return min(step_list)\n\n", "class Solution:\n    def kSimilarity2(self, A, B):\n        def nei(x):\n            i = 0\n            while x[i] == B[i]:\n                i+=1\n            for j in range(i+1, len(x)):\n                if x[j] == B[i] and x[i] != x[j]:\n                    yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n        \n        q, seen = collections.deque([(A,0)]), {A}\n        while q:\n            x, d = q.popleft()\n            if x == B:\n                return d\n            for y in nei(x):\n                if y not in seen:\n                    seen.add(y), q.append((y,d+1))\n\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A == B:\n            return 0\n        \n        m = len(A)\n        \n        def getNeighbors(word):\n            i = 0\n            while word[i] == B[i]:\n                i+=1\n            \n            for j in range(i+1, m):\n                if word[j] == B[i] and word[j] != word[i]:\n                    yield word[:i] + word[j] + word[i+1:j] + word[i] + word[j+1:]\n        \n        visited = {A}\n        queue = collections.deque([(A, 0)])\n        \n        while queue:\n            word, d = queue.popleft()\n            if word == B:\n                return d\n            for nbor in getNeighbors(word):\n                if nbor not in visited:\n                    visited.add(nbor)\n                    queue.append((nbor, d+1))\n", "class Solution:\n    @lru_cache(None)\n    def kSimilarity(self, A: str, B: str) -> int:\n        if len(A) == 0: return 0\n        if A[0]==B[0]: return self.kSimilarity(A[1:],B[1:])\n        \n        ans = math.inf\n        for i in range(1,len(B)):\n            if B[i]==A[0]: ans = min(ans, 1+self.kSimilarity(A[1:],B[1:i]+B[0]+B[i+1:]))\n        return ans\n            \n", "class Solution:\n    def kSimilarity(self, A, B):\n#         def nei(x):\n#             i = 0\n#             while x[i] == B[i]: i += 1\n#             for j in range(i + 1, len(A)):\n#                 if x[j] == B[j]:\n#                     continue\n#                 if x[j] == B[i] and x[i] == B[j]:\n#                     yield x[:i] + x[j] + x[i + 1:j] + x[i] + x[j + 1:]\n#                     break\n#                 if x[j] == B[i]:\n#                     yield x[:i] + x[j] + x[i + 1:j] + x[i] + x[j + 1:]\n\n\n\n#         # def test():\n#         stack = [(A, 0)]\n#         visit = {A}\n#         while stack:\n#             cur, d = stack.pop()\n#             if cur == B: return d\n#             for neighbor in nei(cur):\n#                 if neighbor not in visit:\n#                     visit.add(neighbor)\n#                     stack.append((neighbor, d+1))\n                    \n        \n        n = len(A)\n        def nei(x):\n            i = 0\n            while x[i] == B[i]: i += 1\n            for j in range(i+1,n):\n                if x[j] == B[j]:\n                    continue\n                if x[j] == B[i] and x[i] == B[j]:\n                    yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n                    break\n                if x[j] == B[i]:\n                    yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n        pool = [(A,0)]\n        seen = {A}\n        for x,d in pool:\n            if x == B: return d\n            for y in nei(x):\n                if y not in seen:\n                    seen.add(y)\n                    pool.append((y,d+1))", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        mem = dict()\n        def process(A,B):\n            key = '%s_%s'%(A,B)\n  \n            if A==B:\n                return 0\n            \n            if key in mem:\n                return mem[key]\n           \n            if A[0] == B[0]:\n                return process(A[1:],B[1:])\n            \n            c2 = float('inf')\n            temp = list(B)\n            \n            for idx,val in enumerate(B):\n                if val == A[0]:\n                    temp[idx],temp[0] = temp[0],temp[idx]\n                    c2 = min(c2,1+process(A[1:],''.join(temp)[1:]))\n                    temp[0],temp[idx] = temp[idx],temp[0]\n            \n            mem[key]=c2\n            return mem[key]\n            \n        return process(A,B)", "from functools import lru_cache\n\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        @lru_cache(None)\n        def solve(s1, s2):\n            if not s1:\n                return 0\n            \n            if s1[0] == s2[0]:\n                return solve(s1[1:], s2[1:])\n            \n            ans = 21\n            for i,c in enumerate(s1):\n                if s2[0] == c:\n                    ans = min(ans, 1 + solve(s1[1:i] + s1[0] + s1[i+1:], s2[1:]))\n            return ans\n        \n        return solve(A, B)", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        q = collections.deque()\n        visited = set()\n        q.append(A)\n        visited.add(A)\n        \n        step = -1\n        while q:\n            step += 1\n            lens = len(q)\n            for _ in range(lens):\n                curr = q.popleft()\n                if curr == B:\n                    return step\n                #print(self._swap(curr, B))\n                for next in self._swap(curr, B): \n                    if next in visited:\n                        continue\n                    q.append(next)\n                    visited.add(next)\n                \n    def _swap(self, s, B):  \n        i = 0\n        while s[i] == B[i]:   \n            i += 1\n        if s[i]!=B[i]:\n            for j in range(i + 1, len(s)):\n                if s[j] == B[i]:\n                    yield s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]  ", "class Solution:\n    def kSimilarity(self, A, B):\n        def nei(x):\n            i = 0\n            while x[i] == B[i]:\n                i+=1\n            for j in range(i+1, len(x)):\n                if x[j] == B[i] and x[i] != x[j]:\n                    yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n        \n        q, seen = collections.deque([(A,0)]), {A}\n        while q:\n            x, d = q.popleft()\n            print(x)\n            if x == B:\n                return d\n            for y in nei(x):\n                if y not in seen:\n                    seen.add(y), q.append((y,d+1))", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        if A==B:\n            return 0\n        step_list = []\n        A_list = []\n        for i in range(len(A)):\n            A_list.append(A[i])\n\n        states = [[A_list.copy(),0,0],] #list, index, step\n        while states != []:\n            state = states.pop(0)\n            indictor = 0\n            for i in range(state[1],len(A_list)):\n                if state[0][i] != B[i]:\n                    indictor = 1\n                    for j in range(i+1,len(A_list)):\n                        if state[0][j] == B[i] and B[j] != state[0][j] and B[j] == state[0][i]:\n                            new_state = state[0].copy()\n                            new_state[j], new_state[i] = new_state[i], new_state[j]\n                            states.append([new_state,i+1,state[2]+1])\n                            break\n                        elif state[0][j] == B[i] and B[j] != state[0][j]:\n                            new_state = state[0].copy()\n                            new_state[j], new_state[i] = new_state[i], new_state[j]\n                            states.append([new_state,i+1,state[2]+1])\n                    break\n            if indictor == 0:\n                step_list.append(state[2])\n        return min(step_list)\n\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        \n        dic = {c: i for i, c in enumerate('abcdef')}\n        \n        bag = dict()\n        \n        stack = []\n        \n        for a, b in zip(A, B):\n            if a != b:\n                i, j = dic[a], dic[b]\n                bag[(i, j)] = bag.get((i, j), 0) + 1\n                stack.append((i, j))\n                    \n        output = 0\n        \n        # @lru_cache(maxsize=None)\n        def search(stack):\n            if not stack:\n                return 0\n            \n            i, j = stack.pop()\n                        \n            if (j, i) in stack:\n                idx = stack.index((j, i))\n                stack = stack[:idx] + stack[(idx + 1):]\n                \n                return search(stack) + 1\n            \n            else:\n                \n                best = float(inf)\n                \n                for idx, pair in enumerate(stack):\n                    \n                    if pair[0] == j:\n\n                        curr = search(stack[:idx] + [(i, pair[1])] + stack[(idx + 1):]) + 1\n                        \n                        best = min(curr, best)\n                        \n                return best\n        \n        return search(stack)", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        n = len(A)\n        A = list(A)\n        B = list(B)\n        \n        base = 0\n        for i in range(n):\n            if A[i] == B[i]: continue\n            \n            for j in range(i+1, n):\n                if A[i] == B[j] and A[j] == B[i]:\n                    A[i], A[j] = A[j], A[i]\n                    base += 1\n                    break\n            \n        # invariant: A[:i] == B[:i]\n        def dfs(i):\n            if i == n: return 0\n            \n            if A[i] == B[i]:\n                return dfs(i+1)\n            \n            desired = B[i]                    \n            cand = float('inf')\n            for j in range(i+1, n):\n                if A[j] == desired:\n                    A[i], A[j] = A[j], A[i]\n                    cand = min(cand, 1 + dfs(i+1))\n                    A[i], A[j] = A[j], A[i]\n                    \n            return cand\n        \n        return base + dfs(0)", "from collections import deque\nclass Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        ## check official solution and \n        ## https://leetcode.com/problems/k-similar-strings/discuss/269517/Python-Graph-BFS\n        q = deque()\n        q.append(A)\n        visited = set([A])\n        res = 0\n        \n        def neighbors(x):\n            res = []\n            i = 0\n            while i<len(x) and x[i] == B[i]:\n                i += 1\n            for j in range(i+1, len(A)):\n                if x[j] == B[i]:\n                    new_str = x[:i] + x[j] + x[i+1:j] + x[i] + x[j+1:]\n                    if new_str not in visited:\n                        visited.add(new_str)\n                        res.append(new_str)\n            return res\n        \n        while len(q)>0:\n            q_sz = len(q)\n            for _ in range(q_sz):\n                cur = q.popleft()\n                if cur == B:\n                    return res\n                for neighbor in neighbors(cur):\n                    q.append(neighbor)\n            res += 1\n        return res\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        queue = collections.deque([(A, 0, 0)])\n        s = {A}\n        \n        while queue:\n            curr_A, curr_k, curr_p = queue.popleft()\n            # print(curr_A, curr_k, curr_p)\n            if curr_A == B:\n                return curr_k\n            for i in range(curr_p, len(A)):\n                if curr_A[i] != B[i]:\n                    for j in range(i+1, len(A)):\n                        if curr_A[j] == B[i] and curr_A[:i] + curr_A[j] + curr_A[i+1: j] + curr_A[i] + curr_A[j+1:] not in s:\n                            queue.append((curr_A[:i] + curr_A[j] + curr_A[i+1: j] + curr_A[i] + curr_A[j+1:], curr_k + 1, i + 1))\n                            s.add(curr_A[:i] + curr_A[j] + curr_A[i+1: j] + curr_A[i] + curr_A[j+1:])\n                    break\n            \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        queue = collections.deque([(A, 0, 0)])\n        s = {A}\n        \n        while queue:\n            curr_A, curr_k, curr_p = queue.popleft()\n            if curr_A == B:\n                return curr_k\n            for i in range(curr_p, len(A)):\n                if curr_A[i] != B[i]:\n                    for j in range(i+1, len(A)):\n                        if curr_A[j] == B[i] and curr_A[:i] + curr_A[j] + curr_A[i+1: j] + curr_A[i] + curr_A[j+1:] not in s:\n                            queue.append((curr_A[:i] + curr_A[j] + curr_A[i+1: j] + curr_A[i] + curr_A[j+1:], curr_k + 1, i + 1))\n                            s.add(curr_A[:i] + curr_A[j] + curr_A[i+1: j] + curr_A[i] + curr_A[j+1:])\n                    break\n            \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        queue = []\n\n        queue.append((A,B,0))  \n        step = len(A)\n        minFlip = float('inf')\n        seen = {(A,B):0}\n        while(queue):\n            target, current, flip = queue.pop(0) \n            if seen[(target,current)] < flip:\n                continue\n            if target == current:\n                minFlip = min(minFlip,flip)\n                continue\n            if target[0] == current[0]:\n                temp = seen.get((target[1:], current[1:]), None)\n                if not temp:\n                    seen[(target[1:], current[1:])] = flip\n                else:\n                    if temp <= flip:\n                        continue\n                seen[(target[1:], current[1:])] = flip\n                queue.append((target[1:], current[1:], flip))\n            else:\n                canni = [idx for idx, char in enumerate(current) if char == target[0]]\n                piror = canni\n                #piror = [(loc, target[loc] == current[0]) for loc in canni]\n                #piror.sort(key=lambda x:x[1],reverse = True)\n                for loc in piror:\n                    lol = (target[1:], current[1:loc] + current[0] + current[loc+1:]) \n                    temp = seen.get(lol, None)\n                    if not temp:\n                        seen[lol] = flip+1\n                    else:\n                        if temp <= flip+1:\n                            continue\n                    seen[lol] = flip + 1\n                    queue.append((target[1:], current[1:loc] + current[0] + current[loc+1:], flip + 1))\n\n        return minFlip\n            \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def dist(a, b):\n            # count number of differing characters\n            return sum( (1 if c!=d else 0 for (c,d) in zip(a,b) ) )\n\n        def swap(s, i, j):\n            # swap ith and jth chars of string s\n            # assert i != j\n            if i > j:\n                i, j = j, i\n            return s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n\n        def DFS(string, k):\n            # can string be swapped into problem's str `A` in `k` moves?\n            if string == A:\n                return True\n            if k == 0:\n                return False\n\n            # early break if distance is too great:\n            # best possible for string of length N:\n            #    N is even: N/2  (every swap corrects 2 letters\n            #    N is odd: N//2 + 1\n            #      every swap until last 3 letters corrects 2\n            #      last 3 letters take 2 swaps\n            distance = dist(string, A)\n            best = distance/2 if distance % 2 == 0 else (distance//2) + 1\n            if k < best:\n                return False\n\n            for i,c in enumerate(string):\n                if A[i] == c:\n                    continue\n                # c is wrong, we need to swap a correct letter into it\n                # only look for after current position to avoid double swaps\n                for j in range(i, len(A)):\n                    if string[j] == A[i] and A[j] != A[i]:\n                        # try this swap\n                        if DFS(swap(string, i, j), k-1):\n                               return True\n                # return False after trying  the first wrong letter (because of trick):\n                # if there is any `k` solution, then there's a `k` solution\n                # that starts on this letter\n                return False\n\n        for k in range(len(A)):\n            if DFS(B, k):\n                return k\n\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        q = collections.deque()\n        visited = set()\n        q.append(A)\n        visited.add(A)\n        level = 0\n        \n        def getNext(S, B):\n            S = list(S)\n            res = []\n            i = 0\n            while i < len(S):\n                if S[i] != B[i]:\n                    break\n                i += 1\n            \n            for j in range(i + 1, len(S)):\n                if S[j] == B[i]:\n                    S[j], S[i] = S[i], S[j]\n                    res.append(''.join(S))\n                    S[j], S[i] = S[i], S[j]\n                    \n            return res\n        \n        while q:\n            for _ in range(len(q)):\n                curr = q.popleft()\n                if curr == B:\n                    return level\n                for next_str in getNext(curr, B):\n                    if next_str not in visited:\n                        q.append(next_str)\n                        visited.add(next_str)\n            level += 1\n        \n        return -1", "class Solution:\n     def kSimilarity(self, A: str, B: str) -> int:\n        def mk_similarities(s): # len(s) == len(B)\n            for i, c in enumerate(B):\n                if s[i] != c:\n                    break\n            \n            res = []\n            for j in range(i + 1, len(B)):\n                if s[j] == B[i]:\n                    ns = list(s)\n                    ns[i], ns[j] = ns[j], ns[i]\n                    res.append(''.join(ns))\n            return res\n        \n        N = len(A)\n        ws = [A]\n        swaps = 0\n        seen = {A}\n        while ws:\n            nws = []\n            for _ in range(len(ws)):\n                s = ws.pop(0)\n                # print(s)\n                if s == B:\n                    return swaps\n                similarities = mk_similarities(s)\n                # print(similarities)\n                for similarity in similarities:\n                    if similarity not in seen:\n                        nws.append(similarity)\n                        seen.add(similarity)\n            ws = nws\n            swaps += 1\n        return None\n\n#         swaps = 0\n#         N = len(A)\n#         A = list(A)\n#         for i, c in enumerate(B):\n#             if A[i] == c:\n#                 pass\n#             else:\n#                 nearest_c = None\n#                 for j in range(i + 1, N):\n#                     if A[j] == c:\n#                         nearest_c = j\n#                         break\n#                 if nearest_c is None:\n#                     return None\n#                 else:\n#                     A[i], A[j] = A[j], A[i]\n#                     swaps += 1\n#         return swaps\n            \n            \n                \n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        def getSwap(S):  # \u7528\u4e8e\u83b7\u53d6\u4e00\u4e2a\u8282\u70b9\u4e0b\u53ef\u4ee5\u6269\u5c55\u7684\u6240\u6709\u8282\u70b9\n            for i, c in enumerate(S):  # \u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u76f8\u7b49\u7684\u5b57\u7b26\u7684-\u4f4d\u7f6e-\n                if c != B[i]: break\n            T = list(S)\n            for j in range(i + 1, len(S)):  # \u83b7\u53d6\u6240\u6709\u7684\u53ef\u6269\u5c55\u7684\u5b50\u8282\u70b9\n                if S[j] == B[i]:  # \u627e\u5230\u5c31\u4ea4\u6362\n                    T[i], T[j] = T[j], T[i]\n                    yield ''.join(T)  # \u8fd4\u56de\u4e00\u4e2a\u8282\u70b9\n                    T[j], T[i] = T[i], T[j]  # \u6062\u590d\u5f53\u524d\u73af\u5883\uff0c\u4ee5\u4fbf\u5bfb\u627e\u4e0b\u4e00\u4e2a\u53ef\u6269\u5c55\u7684\u8282\u70b9\n \n        queue, cnt = [A], {A: 0}  # \u521d\u59cb\u5316\u961f\u5217\uff0ccnt\u7528\u4e8e\u8bb0\u5f55\u5f53\u524d\u7ed3\u70b9\u5df2\u7ecf\u8d70\u4e86\u591a\u5c11\u6b65\n        while queue:\n            S = queue[0]  # \u51fa\u961f\n            del queue[0]\n            if S == B: return cnt[S]  # \u7ed3\u675f\n            for T in getSwap(S):  # \u83b7\u53d6\u5f53\u524d\u8282\u70b9\u6240\u6709\u6269\u5c55\u5b50\u8282\u70b9\n                if T not in cnt:  # \u5982\u679c\u6ca1\u6709\u51fa\u73b0\u8fc7\uff0c\u5219\u5165\u961f\n                    cnt[T] = cnt[S] + 1\n                    queue.append(T)", "class Solution:\n     def kSimilarity(self, A: str, B: str) -> int:\n        def mk_similarities(s): # len(s) == len(B)\n            for i, c in enumerate(B):\n                if s[i] != c:\n                    break\n            \n            res = []\n            for j in range(i + 1, len(B)):\n                if s[j] == B[i]:\n                    ns = list(s)\n                    ns[i], ns[j] = ns[j], ns[i]\n                    res.append(''.join(ns))\n            return res\n        \n        N = len(A)\n        ws = [A]\n        swaps = 0\n        seen = {A}\n        while ws:\n            nws = []\n            for _ in range(len(ws)):\n                s = ws.pop(0)\n                # print(s)\n                if s == B:\n                    return swaps\n                similarities = mk_similarities(s)\n                # print(similarities)\n                for similarity in similarities:\n                    if similarity not in seen:\n                        nws.append(similarity)\n                        seen.add(similarity)\n            ws = nws\n            swaps += 1\n        return None\n", "class Solution:\n    def kSimilarity(self, A: str, B: str) -> int:\n        @lru_cache(None)\n        def nei(x):\n            i = 0\n            while i < len(x) and x[i] == B[i]: i+=1\n            res = []\n            for j in range(i+1, len(x)):\n                if x[j] == B[i]: \n                    res.append(x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:])\n            return res\n        q, seen = [(A,0)], {A}\n        for x, d in q:\n            if x == B: return d\n            for y in nei(x):\n                if y not in seen:\n                    seen.add(y), q.append((y,d+1))", "class Solution:\n    def kSimilarity(self, A, B):\n        def nei(x):\n            i = 0\n            while x[i] == B[i]: i+=1\n            for j in range(i+1, len(x)):\n                if x[j] == B[i]: yield x[:i]+x[j]+x[i+1:j]+x[i]+x[j+1:]\n        \n        q, seen = [(A,0)], {A}\n        for x, d in q:\n            if x == B: return d\n            for y in nei(x):\n                if y not in seen:\n                    seen.add(y), q.append((y,d+1))\n"]
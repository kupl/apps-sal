["class Solution:\n     def makesquare(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         if len(nums) < 4:\n             return False\n         \n         length = sum(nums)\n         if length % 4:\n             return False\n         length = (int) (length / 4)\n         \n         nums.sort(reverse=True)\n         #print(nums)\n         \n         if length < nums[0]:\n             return False\n         elif length == nums[0]:\n             stack = list([(set([0]), 1, length, 1)])\n         else:\n             stack = list([(set([0]), 1, length - nums[0], 2)])  # (usedIndexSet, searchStartFromIndex, target, remainRounds)\n         while stack:\n             usedSet, startIndex, target, remainRounds = stack.pop()\n             #print(usedSet, set(range(0, len(nums))) - usedSet, target, remainRounds)\n             for i in range(len(nums) - 1, startIndex - 1, -1):\n                 if i in usedSet:\n                     continue\n                 num = nums[i]\n                 if num < target and i + 1 < len(nums):\n                     stack.append((usedSet | {i}, i+1, target - num, remainRounds))\n                 elif num == target:\n                     if remainRounds == 0:\n                         return True\n                     else:\n                         stack.append((usedSet | {i}, 1, length, remainRounds - 1))\n                 # Else not valid path, continue\n         return False\n             \n             \n", "class Solution:\n     def makesquare(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n #         if sum(nums) % 4 != 0 or len(nums) < 4 or max(nums) > sum(nums) / 4 :\n #             return False\n         \n #         nums.sort(reverse=True)      \n         \n #         if nums[0] < sum(nums) / 4 and nums[0]  + nums[-1] >  sum(nums):\n #             return False\n         \n #         def dfs(nums, pos, target):\n #             if pos == len(nums):\n #                 return True\n             \n #             for i in range(4):\n #                 if target[i] >= nums[pos]:\n #                     target[i] -= nums[pos]\n #                     if dfs(nums, pos + 1, target):\n #                         return True\n #                     target[i] += nums[pos]\n                     \n                     \n #             return False\n             \n #         return dfs(nums, 0,  [sum(nums) / 4] * 4)\n     \n     \n         total = sum(nums)\n         if total%4 != 0 or len(nums)<4: return False\n         size = total/4\n         nums.sort(reverse=True)\n         used = [False]*len(nums)\n         def dfs(i, expect):\n             if i >= len(nums): return expect%size == 0\n             if used[i]: return dfs(i+1, expect)\n             used[i] = True\n             if nums[i] == expect: return True\n             if nums[i] < expect:\n                 expect -= nums[i]\n                 available = [j for j in range(i+1, len(nums)) if not used[j]]\n                 for x in available:\n                     if dfs(x, expect): \n                         return True\n             used[i] = False\n             return False\n         for i in range(len(nums)):\n             if not dfs(i, size): return False\n         return True", "class Solution:\n     def makesquare(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         def checkv(t,c,nums,used):\n             if t==0:\n                 return True\n             if t<0:\n                 return False\n             while c<len(nums) and used[c]:\n                 c=c+1\n             if c>=len(nums):\n                 return False\n             if checkv(t-nums[c],c+1,nums,used):\n                 used[c]=True\n                 return True\n             if checkv(t,c+1,nums,used):\n                 return True\n             return False\n         edgel=sum(nums)\n         if edgel%4!=0 or edgel==0:\n             return False\n         edgel=edgel/4\n         nums.sort(key=lambda x:-x)\n         n=len(nums)\n         used=[False]*n\n         for p in range(3):\n             t=edgel\n             if not checkv(t,0,nums,used):\n                 return False\n         return True", "class Solution:\n     def makesquare(self, nums):\n         s = sum(nums)\n         if not s % 4 == 0:\n             return False\n         l = s // 4\n         from collections import Counter\n         self.c = Counter(nums)\n         for _ in range(4):\n             n = self.f(0, sorted(self.c.elements(),reverse=True), l, ())\n             if not n:\n                 return False\n             self.c.subtract(n)\n         return True\n \n     def f(self, index, keys, sum, nums):\n         if sum == 0:\n             return nums\n         if sum < 0 or index >= len(keys):\n             return None\n         return self.f(index + 1, keys, sum - keys[index], (*nums, keys[index])) \\\n                or self.f(index + 1, keys, sum, nums)"]
["class dsu:\n    def __init__(self, n=0):\n        self._n = n\n        self.parent_or_size = [-1] * n\n    \n    def merge(self, a: int, b: int) -> int:\n        x = self.leader(a)\n        y = self.leader(b)\n        if x == y:\n            return x\n        if self.parent_or_size[x] > self.parent_or_size[y]:\n            x, y = y, x\n        self.parent_or_size[x] += self.parent_or_size[y]\n        self.parent_or_size[y] = x\n        return x\n    \n    def same(self, a: int, b: int) -> bool:\n        return self.leader(a) == self.leader(b)\n    \n    def leader(self, a: int) -> int:\n        x = a\n        while self.parent_or_size[x] >= 0:\n            x = self.parent_or_size[x]\n        while a != x:\n            self.parent_or_size[a], a = x, self.parent_or_size[a]\n        return x\n    \n    def size(self, a: int) -> int:\n        return -self.parent_or_size[self.leader(a)]\n    \n    def groups(self):\n        g = [[] for _ in range(self._n)]\n        for i in range(self._n):\n            g[self.leader(i)].append(i)\n        return list(c for c in g if c)\n\nn, m = list(map(int, input().split()))\nvdata = [] # (required, gain)\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    vdata.append((max(a - b, 0), b))\nto = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    u -= 1; v -= 1\n    to[u].append(v)\n    to[v].append(u)\ns = dsu(n)\ndp = vdata.copy() # (extra, tot_gain)\nvisited = [False] * n\nfor u in sorted(list(range(n)), key=lambda i: vdata[i][0]):\n    req, gain = vdata[u]\n    frm = {u}\n    for v in to[u]:\n        if visited[v]:\n            frm.add(s.leader(v))\n    mnextra = 10 ** 18\n    for v in frm:\n        e, g = dp[v]\n        e += max(req - (e + g), 0)\n        if e < mnextra:\n            mnextra, mni = e, v\n    extra, tot_gain = mnextra, sum(dp[v][1] for v in frm)\n    for v in frm:\n        s.merge(u, v)\n    dp[s.leader(u)] = extra, tot_gain\n    visited[u] = True\nans = sum(dp[s.leader(0)])\nprint(ans)\n"]
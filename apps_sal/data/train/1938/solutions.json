["class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        \n        def getArea(width):\n            res = 0\n            prev_low = 0\n            for low, high in intervals:\n                low = max(prev_low, low)\n                if high > low:\n                    res += (high - low)*width\n                    prev_low = high\n            return res\n\n        MOD = 10**9 + 7\n        # convert list of rectangles to events\n        events = []\n        for x1, y1, x2, y2 in rectangles:\n            events.append((x1, 0, y1, y2)) #in\n            events.append((x2, 1, y1, y2)) #out\n        events.sort(key = lambda x : (x[0], x[1]))\n        \n        # sweep to calculate area\n        intervals = []\n        area = 0\n        prev_x = 0\n        for event in events:\n            cur_x, type, low, high = event\n            area += getArea(cur_x - prev_x)\n            if type == 1:\n                intervals.remove((low, high))\n            else:\n                intervals.append((low, high))\n                intervals.sort()   \n            prev_x = cur_x\n                \n        \n        return area % MOD", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        mod = 10**9 + 7\n        events = []\n        for x1, y1, x2, y2 in rectangles:\n            events.append([x1, 0, y1, y2])\n            events.append([x2, 1, y1, y2])\n        events.sort(key=lambda x: (x[0], -x[1]))\n        \n        def getArea(m):\n            area = 0\n            prev = float('-inf')\n            for l, r in heights:\n                prev = max(prev, l)\n                area += max(0, (r-prev)) * m\n                prev = max(prev, r)\n            return area\n        \n        area = 0\n        prev = 0\n        heights = []\n        for event in events:\n            cur, close, y1, y2 = event\n            area += getArea(cur-prev)\n            if close:\n                heights.remove((y1, y2))\n            else:\n                heights.append((y1, y2))\n                heights.sort()\n            prev = cur\n        return area % mod", "class Solution:\n#    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        # Populate events\n#         OPEN, CLOSE = 0, 1\n#         events = []\n#         for x1, y1, x2, y2 in rectangles:\n#             events.append((y1, OPEN, x1, x2))\n#             events.append((y2, CLOSE, x1, x2))\n#         events.sort()\n\n#         def query():\n#             ans = 0\n#             cur = -1\n#             for x1, x2 in active:\n#                 cur = max(cur, x1)\n#                 ans += max(0, x2 - cur)\n#                 cur = max(cur, x2)\n#             return ans\n\n#         active = []\n#         cur_y = events[0][0]\n#         ans = 0\n#         for y, typ, x1, x2 in events:\n#             # For all vertical ground covered, update answer\n#             ans += query() * (y - cur_y)\n\n#             # Update active intervals\n#             if typ is OPEN:\n#                 active.append((x1, x2))\n#                 active.sort()\n#             else:    \n#                 active.remove((x1, x2))\n\n#             cur_y = y\n\n#         return ans % (10**9 + 7)\n    \n#         OPEN, CLOSE = 0,1\n#         events = []\n#         for x1, y1, x2, y2 in rectangles:\n#             events.append((y1, OPEN, x1, x2))\n#             events.append((y2, CLOSE, x1, x2))\n        \n#         events.sort()\n        \n#         # total length of the horizontal intervals\n#         def query():\n#             ans = 0\n#             cur = -1\n#             for x1, x2 in active:\n#                 cur = max(cur, x1)\n#                 ans += max(0, x2-cur)\n#                 cur = max(cur, x2)\n#             return ans\n            \n#         active = []\n#         cur_y = events[0][0]\n#         res = 0\n#         for y, typ, x1, x2 in events:\n#             res += query()*(y - cur_y)\n            \n#             if typ is OPEN:\n#                 active.append((x1, x2))\n#                 active.sort()\n#             else:\n#                 active.remove((x1,x2))\n            \n#             cur_y = y\n            \n#         return res % (10**9 + 7)\n    def rectangleArea(self, rectangles):\n        OPEN, CLOSE = 1, -1\n        events = []\n        nonlocal X\n        X = set()\n        for x1, y1, x2, y2 in rectangles:\n            events.append((y1, OPEN, x1, x2))\n            events.append((y2, CLOSE, x1, x2))\n            X.add(x1)\n            X.add(x2)\n        events.sort()\n\n        X = sorted(X)\n        Xi = {x: i for i, x in enumerate(X)}\n\n        active = Node(0, len(X) - 1)\n        ans = 0\n        cur_x_sum = 0\n        cur_y = events[0][0]\n\n        for y, typ, x1, x2 in events:\n            ans += cur_x_sum * (y - cur_y)\n            cur_x_sum = active.update(Xi[x1], Xi[x2], typ)\n            cur_y = y\n\n        return ans % (10**9 + 7)\n    \nclass Node(object):\n    def __init__(self, start, end):\n        self.start, self.end = start, end\n        self.total = self.count = 0\n        self._left = self._right = None\n\n    @property\n    def mid(self):\n        return (self.start + self.end) // 2\n\n    @property\n    def left(self):\n        self._left = self._left or Node(self.start, self.mid)\n        return self._left\n\n    @property\n    def right(self):\n        self._right = self._right or Node(self.mid, self.end)\n        return self._right\n\n    def update(self, i, j, val):\n        if i >= j: return 0\n        if self.start == i and self.end == j:\n            self.count += val\n        else:\n            self.left.update(i, min(self.mid, j), val)\n            self.right.update(max(self.mid, i), j, val)\n\n        if self.count > 0:\n            self.total = X[self.end] - X[self.start]\n        else:\n            self.total = self.left.total + self.right.total\n\n        return self.total\n", "class Node(object):\n    def __init__(self, start, end):\n        self.start, self.end = start, end\n        self.total = self.count = 0\n        self._left = self._right = None\n\n    @property\n    def mid(self):\n        return (self.start + self.end) // 2\n\n    @property\n    def left(self):\n        self._left = self._left or Node(self.start, self.mid)\n        return self._left\n\n    @property\n    def right(self):\n        self._right = self._right or Node(self.mid, self.end)\n        return self._right\n\n    def update(self, i, j, val):\n        if i >= j: return 0\n        if self.start == i and self.end == j:\n            self.count += val\n        else:\n            self.left.update(i, min(self.mid, j), val)\n            self.right.update(max(self.mid, i), j, val)\n\n        if self.count > 0:\n            self.total = X[self.end] - X[self.start]\n        else:\n            self.total = self.left.total + self.right.total\n\n        return self.total\n\nclass Solution(object):\n    def rectangleArea(self, rectangles):\n        OPEN, CLOSE = 1, -1\n        events = []\n        nonlocal X\n        X = set()\n        for x1, y1, x2, y2 in rectangles:\n            events.append((y1, OPEN, x1, x2))\n            events.append((y2, CLOSE, x1, x2))\n            X.add(x1)\n            X.add(x2)\n        events.sort()\n\n        X = sorted(X)\n        Xi = {x: i for i, x in enumerate(X)}\n\n        active = Node(0, len(X) - 1)\n        ans = 0\n        cur_x_sum = 0\n        cur_y = events[0][0]\n\n        for y, typ, x1, x2 in events:\n            ans += cur_x_sum * (y - cur_y)\n            cur_x_sum = active.update(Xi[x1], Xi[x2], typ)\n            cur_y = y\n\n        return ans % (10**9 + 7)", "class Solution:\n    # line-sweep , so hard\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        xs = sorted(set([x for x1, y1, x2, y2 in rectangles for x in [x1, x2]]))\n        x_i = {v: i for i, v in enumerate(xs)}\n        print(xs)\n        print(x_i)\n        count = [0] * len(x_i)\n        L = []\n        # review, kind of like sweep-line issue\n        for x1, y1, x2, y2 in rectangles:\n            L.append([y1, x1, x2, 1])\n            L.append([y2, x1, x2, -1])\n        L.sort()\n        # print(L)\n        cur_y = cur_x_sum = area = 0\n        for y, x1, x2, sig in L:\n            area += (y - cur_y) * cur_x_sum\n            cur_y = y\n            for i in range(x_i[x1], x_i[x2]):\n                count[i] += sig\n            # print(\\\"zip\\\")\n            # print(count)\n            # for x1, x2, c in zip(xs, xs[1:], count):\n            # print(x1,x2,c)\n            cur_x_sum = sum(x2 - x1 if c else 0 for x1, x2, c in zip(xs, xs[1:], count))\n        return area % (10 ** 9 + 7)\n\n    # heap\n    # similiar: skyline-problem-218\n    def rectangleArea(self, recs):\n        \\\"\\\"\\\"\n        :type rectangles: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        x = set()\n        pq = []\n        for rec in recs:\n            x.add(rec[0])\n            x.add(rec[2])\n            heapq.heappush(pq, (rec[1], rec[0], rec[2], 1))\n            heapq.heappush(pq, (rec[3], rec[0], rec[2], -1))\n\n        x = sorted(list(x))\n        xi = {v: i for i, v in enumerate(x)}\n        count = [0] * len(x)\n\n        res = 0\n        last_l =  pq[0][0]\n\n        while pq:\n            cur_l = pq[0][0]\n\n            for i in range(len(x)):\n                if count[i] > 0:\n                    res += (x[i + 1] - x[i]) * (cur_l - last_l)\n                    res = res % (10 ** 9 + 7)\n\n            while pq and pq[0][0] == cur_l:\n                cur_l, x1, x2, bound = heapq.heappop(pq)\n                for i in range(xi[x1], xi[x2]):\n                    count[i] += bound\n\n            last_l = cur_l\n        return res\n\n", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        Xs = [x for x1, _, x2, _ in rectangles for x in [x1, x2]]\n        Xs.sort()\n        X_idx_lookup = {x: idx for idx, x in enumerate(Xs)}\n        \n        res = 0\n        prev_y = 0\n        X_span = 0\n        \n        Ys = [e for x1, y1, x2, y2 in rectangles for e in [[y1, x1, x2, 1], [y2, x1, x2, -1]]]\n        Ys.sort()\n        \n        overlap_count = [0] * len(Xs)\n        \n        for y, xl, xr, inout in Ys:\n            res += (y - prev_y) * X_span\n            prev_y = y\n            start_idx, end_idx = X_idx_lookup[xl], X_idx_lookup[xr]\n            for i in range(start_idx, end_idx):\n                overlap_count[i] += inout\n            X_span = sum(x2 - x1 if c > 0 else 0 for x1, x2, c in zip(Xs, Xs[1:], overlap_count))\n        return res % 1000000007\n\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        Xs = [x for x1, _, x2, _ in rectangles for x in [x1, x2]]\n        Xs.sort()\n        covered = [0] * len(Xs)\n        res = 0\n        \n        keypoints = [e for x1, y1, x2, y2 in rectangles for e in [[y1, x1, x2, 1], [y2, x1, x2, -1]]]\n        keypoints.sort()\n        \n        prev_y = 0\n        width_span = 0\n        for y, x1, x2, inout in keypoints:\n            res += (y - prev_y) * width_span\n            prev_y = y\n            for i in range(len(covered) - 1):\n                a, b = Xs[i], Xs[i + 1]\n                if x1 <= a and b <= x2:\n                    covered[i] += inout\n            width_span = sum(Xs[i + 1] - Xs[i] if covered[i] > 0 else 0 for i in range(len(covered) - 1))\n        return res % 1000000007", "class Solution(object):\n    def rectangleArea(self,rectangles):\n        events = []\n        MOD = 10**9 + 7\n        INT_MIN = -2 **32\n        for x1, y1, x2, y2 in rectangles:\n            events.append([x1, 0, y1, y2])\n            events.append([x2, 1, y1, y2])\n        events.sort()\n\n        def merge_intervals(m,intervals):\n            l = 0 \n            n = len(intervals)\n            if n == 0:\n                return 0 \n            prev = intervals[0]\n            l = prev[1]-prev[0]\n            print (intervals,l,m)\n            prev_end = prev[1]\n            for s,t in intervals[1:]:\n                if s>=prev_end:\n                    l += t-s\n                else:\n                    if t > prev_end:\n                        l = l + (t-s) - (prev_end-s)\n                prev_end = max(t,prev_end) \n            return l*m\n                \n        def gain_area(m):\n            area = 0\n            prev = INT_MIN\n            for l, r in open_intervals:\n                prev = max(prev, l)\n                area += max(0, (r - prev))\n                prev = max(r, prev)\n            print (\\\"gain area\\\",area,open_intervals)\n            return area*m\n        \n        area = 0\n        prev = INT_MIN\n        open_intervals = []\n        for event in events:\n            curr,close,y1,y2 = event\n            print (curr,prev,curr-prev)\n            area += merge_intervals(curr-prev,open_intervals)\n            gain_area(curr-prev)\n            if close:\n                open_intervals.remove((y1,y2))\n            else:\n                open_intervals.append((y1,y2))\n                open_intervals.sort()\n            prev = curr\n        return area  % MOD", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        START = 1\n        END = 0\n        # we want it to end first then start\n        MOD = 10**9 + 7\n        xaxis = []\n        \n        for x1, y1, x2, y2 in rectangles:\n            xaxis.append((x1, START, y1, y2))\n            xaxis.append((x2, END, y1, y2))\n        \n        xaxis.sort()\n        \n        prev = 0\n        area = 0\n        yaxis = []\n        for i in range(len(xaxis)):\n            x, status, y1, y2 = xaxis[i]\n            if i > 0:\n                area += self.get_length(yaxis) * (x - prev)\n                area %= MOD\n            if status == START:\n                yaxis.append((y1, y2))\n                yaxis.sort()\n            else:\n                yaxis.remove((y1, y2))\n            prev = x\n        return area\n    \n    def get_length(self, yaxis):\n        length = 0\n        i = 0\n        \n        prev = (float('-inf'), float('-inf'))\n        \n        for i in range(len(yaxis)):\n            if not self.has_overlap(prev, yaxis[i]):\n                length += yaxis[i][1] - yaxis[i][0]\n            else:\n                if prev[1] >= yaxis[i][1]:\n                    continue\n                length += yaxis[i][1] - prev[1]\n            prev = yaxis[i]\n        return length\n    \n    \n    def has_overlap(self, prev, cur):\n        if prev[1] < cur[0] or cur[1] < prev[0]:\n            return False\n        return True\n    \n    def get_overlap_length(self, prev, cur):\n        return min(prev[1], cur[1]) - max(prev[0], cur[0])\n        \n    \n        \n", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        START = 1\n        END = 0\n        # we want it to end first then start\n        MOD = 10**9 + 7\n        xaxis = []\n        \n        for x1, y1, x2, y2 in rectangles:\n            xaxis.append((x1, START, y1, y2))\n            xaxis.append((x2, END, y1, y2))\n        \n        xaxis.sort()\n        \n        prev = 0\n        area = 0\n        yaxis = []\n        for i in range(len(xaxis)):\n            x, status, y1, y2 = xaxis[i]\n            if i > 0:\n                area += self.get_length(yaxis) * (x - prev)\n                area %= MOD\n            if status == START:\n                yaxis.append((y1, y2))\n                yaxis.sort()\n            else:\n                yaxis.remove((y1, y2))\n            prev = x\n        return area\n    \n    def get_length(self, yaxis):\n        length = 0\n        i = 0\n        \n        prev = (float('-inf'), float('-inf'))\n        \n        for i in range(len(yaxis)):\n            if not self.has_overlap(prev, yaxis[i]):\n                length += yaxis[i][1] - yaxis[i][0]\n            else:\n                if prev[1] >= yaxis[i][1]:\n                    # don't want to update prev end point\n                    continue\n                length += max(0, yaxis[i][1] - prev[1])\n            prev = yaxis[i]\n        return length\n    \n    \n    def has_overlap(self, prev, cur):\n        if prev[1] < cur[0] or cur[1] < prev[0]:\n            return False\n        return True\n        \n    \n        \n", "# This is a really difficult problem, method is called line sweeping, it also has interval merge in it\n# 1. Time complexity O(N*N*log(N)), space complexity O(N)\n# 2. Idea is to use a vertical line to sweep from left to right and accumulate the area by delta x times the total interval length at the x position\n# class Solution(object):\n#     def rectangleArea(self, rectangles):\n#         M=10**9+7\n#         events=[]\n#         for x1,y1,x2,y2 in rectangles:           \n#             events.append((x1,y1,y2,0))\n#             events.append((x2,y1,y2,1))\n#         events.sort(key=lambda x:x[0])\n#         res=0\n#         prev=events[0][0]\n#         actives=[]\n#         def getWidth(actives):\n#             actives.sort(key=lambda x:x[0])\n#             width=0\n#             right=0\n#             for active in actives:\n#                 width+=max(0,active[1]-max(right,active[0]))\n#                 right=max(right,active[1])\n#             return width\n#         for event in events:\n#             if event[0]!=prev:      \n#                 res+=getWidth(actives)*(event[0]-prev)\n#                 res=res%M\n#                 prev=event[0]\n#             if not event[3]:\n#                 actives.append(event[1:-1])\n#             else:\n#                 actives.remove(event[1:-1])\n#         return res\n\n# This second solution is a practice of segmentation tree, the concept is simpmle but implementation is very challenging, with segmentation tree, each update take log(N) time so time complexity of the enti\n\nclass Tree:\n    def __init__(self,l,r):\n        self.total=0\n        self.count=0\n        self.l=l\n        self.r=r\n        self.m=int((self.l+self.r)/2)\n        self.isLeaf=True if self.r-self.l==1 else False\n        self.left=None if self.isLeaf else Tree(self.l,self.m)\n        self.right=None if self.isLeaf else Tree(self.m,self.r)\n\n    def update(self,l,r,count):\n        if l>=self.r or r<=self.l:\n            return\n        if self.isLeaf:\n            self.count+=count\n            self.total=nums[self.r]-nums[self.l] if self.count else 0\n        else:\n            self.left.update(l,r,count)\n            self.right.update(l,r,count)\n            self.total=self.left.total+self.right.total\n            \nclass Solution(object):    \n    def rectangleArea(self, rectangles):\n        M=10**9+7\n        events=[]\n        nonlocal nums\n        nums=set()\n        for x1,y1,x2,y2 in rectangles:           \n            events.append((x1,y1,y2,1))\n            events.append((x2,y1,y2,-1))\n            nums.add(y1)\n            nums.add(y2)\n        nums=list(nums)\n        nums.sort()\n        nToI=dict([(n,i) for i,n in enumerate(nums)])\n        iTree=Tree(0,len(nums)-1)\n        events.sort(key=lambda x:x[0])\n        res=0\n        prev=events[0][0]\n        for event in events:\n            if event[0]!=prev:      \n                res+=iTree.total*(event[0]-prev)\n                res=res%M\n                prev=event[0]\n            iTree.update(nToI[event[1]],nToI[event[2]],event[3])\n        return res\n\n", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        rects = []\n        for x1, y1, x2, y2 in rectangles:\n            self.helper(rects, 0, x1, y1, x2, y2)\n        \n        ans = 0\n        mod = pow(10, 9) + 7\n        for x1, y1, x2, y2 in rects:\n            ans += ((x2 - x1) * (y2 - y1)) % mod\n        return ans % mod\n\n    def helper(self, rects, index, x1, y1, x2, y2):\n        if index == len(rects):\n            rects.append([x1, y1, x2, y2])\n            return\n        \n        i1, j1, i2, j2 = rects[index]\n        if i1 >= x2 or i2 <= x1 or j1 >= y2 or j2 <= y1:\n            self.helper(rects, index + 1, x1, y1, x2, y2)  \n            return\n        \n        if x1 < i1:\n            self.helper(rects, index + 1, x1, y1, min(i1, x2), y2)\n        \n        if x2 > i2:\n            self.helper(rects, index + 1, max(i2, x1), y1, x2, y2)\n        \n        if y1 < j1:\n            self.helper(rects, index + 1, max(x1, i1), y1, min(x2, i2), j1)\n        \n        if y2 > j2:\n            self.helper(rects, index + 1, max(x1, i1), j2, min(x2, i2), y2)", "# This is a really difficult problem, method is called line sweeping, it also has interval merge in it\n# 1. Time complexity O(N*N*log(N)), space complexity O(N)\n# 2. Idea is to use a vertical line to sweep from left to right and accumulate the area by delta x times the total interval length at the x position\n# class Solution(object):\n#     def rectangleArea(self, rectangles):\n#         M=10**9+7\n#         events=[]\n#         for x1,y1,x2,y2 in rectangles:           \n#             events.append((x1,y1,y2,0))\n#             events.append((x2,y1,y2,1))\n#         events.sort(key=lambda x:x[0])\n#         res=0\n#         prev=events[0][0]\n#         actives=[]\n#         def getWidth(actives):\n#             actives.sort(key=lambda x:x[0])\n#             width=0\n#             right=0\n#             for active in actives:\n#                 width+=max(0,active[1]-max(right,active[0]))\n#                 right=max(right,active[1])\n#             return width\n#         for event in events:\n#             if event[0]!=prev:      \n#                 res+=getWidth(actives)*(event[0]-prev)\n#                 res=res%M\n#                 prev=event[0]\n#             if not event[3]:\n#                 actives.append(event[1:-1])\n#             else:\n#                 actives.remove(event[1:-1])\n#         return res\n\nclass Tree:\n    def __init__(self,l,r):\n        self.total=0\n        self.count=0\n        self.l=l\n        self.r=r\n        self.m=int((self.l+self.r)/2)\n        self.isLeaf=True if self.r-self.l==1 else False\n        self.left=None if self.isLeaf else Tree(self.l,self.m)\n        self.right=None if self.isLeaf else Tree(self.m,self.r)\n\n    def update(self,l,r,count):\n        if l>=self.r or r<=self.l:\n            return\n        if self.isLeaf:\n            self.count+=count\n            self.total=nums[self.r]-nums[self.l] if self.count else 0\n        else:\n            self.left.update(l,r,count)\n            self.right.update(l,r,count)\n            self.total=self.left.total+self.right.total\n            \nclass Solution(object):    \n    def rectangleArea(self, rectangles):\n        M=10**9+7\n        events=[]\n        nonlocal nums\n        nums=set()\n        for x1,y1,x2,y2 in rectangles:           \n            events.append((x1,y1,y2,1))\n            events.append((x2,y1,y2,-1))\n            nums.add(y1)\n            nums.add(y2)\n        nums=list(nums)\n        nums.sort()\n        nToI=dict([(n,i) for i,n in enumerate(nums)])\n        iTree=Tree(0,len(nums)-1)\n        events.sort(key=lambda x:x[0])\n        res=0\n        prev=events[0][0]\n        for event in events:\n            if event[0]!=prev:      \n                res+=iTree.total*(event[0]-prev)\n                res=res%M\n                prev=event[0]\n            iTree.update(nToI[event[1]],nToI[event[2]],event[3])\n        return res\n\n", "MOD = 10 ** 9 + 7\n\nclass Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n\n        allY = []\n        for x1, y1, x2, y2 in rectangles:\n            allY.append((y1, 0, x1, x2))\n            allY.append((y2, 1, x1, x2))\n        allY.sort()\n\n        allX, ans = [], 0\n        curHeight = allY[0][0]\n\n        for y, t, x1, x2 in allY:\n            ans += self.getX(allX) * (y - curHeight)\n            ans %= MOD\n            if t == 0:\n                bisect.insort(allX, (x1, x2))\n            else:\n                idx = bisect.bisect_left(allX, (x1, x2))\n                #print(idx, x1, x2, allX)\n                allX.pop(idx)\n                #allX.remove((x1, x2))\n\n            curHeight = y\n\n        return ans\n\n    def getX(self, allX):\n        ans = 0\n        cur = -1\n        for x1, x2 in allX:\n            cur = max(cur, x1)\n            ans += max(0, x2 - cur)\n            cur = max(cur, x2)\n        return ans", "class Solution:\n    def rectangleArea(self, rects: List[List[int]]) -> int:\n        xs = sorted(set([x for x1, y1, x2, y2 in rects for x in [x1, x2]]))\n        xi = {v: i for i, v in enumerate(xs)}\n        cnt = [0] * len(xs)\n        L = []\n        for x1, y1, x2, y2 in rects:\n            L.append([y1, x1, x2, 1])\n            L.append([y2, x1, x2, -1])\n        L.sort()\n        res = last_y = sum_x = 0\n        for y, x1, x2, sig in L:\n            res += (y-last_y) * sum_x\n            last_y = y\n            for i in range(xi[x1], xi[x2]):\n                cnt[i] += sig\n            sum_x = sum(x2-x1 for x1, x2, c in zip(xs, xs[1:], cnt) if c)\n        return res %(10**9+7)", "\n\nclass Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        xs = sorted(list(set(x for x1, y1, x2, y2 in rectangles for x in [x1, x2])))\n        xs_i = {x: i for i, x in enumerate(xs)}\n        \n        rects = []\n        for x1, y1, x2, y2 in rectangles:\n            rects.append((y1, x1, x2, 1))\n            rects.append((y2, x1, x2, -1))\n        rects = sorted(rects)\n        counts = [0] * len(xs_i)\n    \n        curr_y = 0\n        area = 0\n        L = 0\n        for y, x1, x2, sig in rects:\n            area += (y - curr_y) * L\n            curr_y = y\n            for x in range(xs_i[x1], xs_i[x2]):\n                counts[x] += sig\n            L = sum(x2 - x1 for x1, x2, s1 in zip(xs, xs[1:], counts) if s1 > 0 )\n        return area % (10**9 + 7)", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        # the key point of this solution is how do we generate a list of rectangles that don't overlap with each other. The idea is that we try to add each new rectangle into the list. If it has overlap with existing rectangles, then we break it into muliple parts that don't have overlap with existing rectangles.\n        all_rectangles = []\n        for rectangle in rectangles:\n            self.add_rectangle(all_rectangles, rectangle, 0)\n        \n        ans = 0\n        mod = pow(10, 9) + 7\n        for rect in all_rectangles:\n            x1, y1, x2, y2 = rect\n            ans += ((x2 - x1) * (y2 - y1)) % mod\n        \n        return ans % mod\n    \n    def add_rectangle(self, all_rectangles, cur, start):\n        if start >= len(all_rectangles):\n            all_rectangles.append(cur)\n            return\n        \n        x1, y1, x2, y2 = cur\n        rx1, ry1, rx2, ry2 = all_rectangles[start]\n        \n        if x2 <= rx1 or x1 >= rx2 or y2 <= ry1 or y1 >= ry2:\n            self.add_rectangle(all_rectangles, cur, start + 1)\n            return\n        \n        if x1 < rx1:\n            self.add_rectangle(all_rectangles, [x1, y1, rx1, y2], start + 1)\n        \n        if x2 > rx2:\n            self.add_rectangle(all_rectangles, [rx2, y1, x2, y2], start + 1)\n        \n        if y1 < ry1:\n            self.add_rectangle(all_rectangles, [max(x1, rx1), y1, min(x2, rx2), ry1], start + 1)\n        \n        if y2 > ry2:\n            self.add_rectangle(all_rectangles, [max(x1, rx1), ry2, min(x2, rx2), y2], start + 1)\n", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        xTicks = set()\n        yTicks = set()\n        for x1, y1, x2, y2 in rectangles:\n            xTicks.add(x1)\n            xTicks.add(x2)\n            yTicks.add(y1)\n            yTicks.add(y2)\n        xTicksList = sorted(list(xTicks))\n        yTicksList = sorted(list(yTicks))\n        \n        xTicksDict = {xLable: xi for xi, xLable in enumerate(xTicksList)}\n        yTicksDict = {yLable: yi for yi, yLable in enumerate(yTicksList)}\n        \n        iMax = len(xTicksList)\n        jMax = len(yTicksList)\n        \n        grid = [[0  for j in range(jMax)] for i in range(iMax)]\n        ans = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            for i in range(xTicksDict[x1], xTicksDict[x2]):\n                xSide = xTicksList[i+1] - xTicksList[i]\n                for j in range(yTicksDict[y1], yTicksDict[y2]):\n                    if grid[i][j] == 0:\n                        ans += xSide * (yTicksList[j+1]-yTicksList[j])\n                        grid[i][j] = 1\n        # print(grid)\n        return ans%(10**9+7)\n", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        N = len(rectangles)\n        Xvals, Yvals = set(), set()\n        for x1, y1, x2, y2 in rectangles:\n            Xvals.add(x1); Xvals.add(x2)\n            Yvals.add(y1); Yvals.add(y2)\n\n        imapx = sorted(Xvals)\n        imapy = sorted(Yvals)\n        mapx = {x: i for i, x in enumerate(imapx)}\n        mapy = {y: i for i, y in enumerate(imapy)}\n\n        grid = [[0] * len(imapy) for _ in imapx]\n        for x1, y1, x2, y2 in rectangles:\n            for x in range(mapx[x1], mapx[x2]):\n                for y in range(mapy[y1], mapy[y2]):\n                    grid[x][y] = 1\n\n        ans = 0\n        for x, row in enumerate(grid):\n            for y, val in enumerate(row):\n                if val:\n                    ans += (imapx[x+1] - imapx[x]) * (imapy[y+1] - imapy[y])\n        return ans % (10**9 + 7)", "from collections import defaultdict\nclass Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        def merge_intervals(intervals):\n            if not intervals:\n                return 0\n            \n            intervals.sort()\n            end = intervals[0][1]\n            width = end - intervals[0][0]\n            \n            for left, right in intervals:\n                if left < end < right:\n                    width += right - end\n                    end = right\n                elif left >= end:\n                    width += right - left\n                    end = right  \n            return width\n        \n        events = defaultdict(list)\n        for x1, y1, x2, y2 in rectangles:\n            events[y1].append((1, x1, x2))\n            events[y2].append((0, x1, x2))\n        \n        events = sorted(events.items(), key=lambda x: x[0])\n        intervals = []\n        area = width = 0\n        MOD = 10 ** 9 + 7\n        last_y = events[0][0]\n        \n        for y, event in events:\n            area += (y - last_y) * width\n            area %= MOD\n            \n            for flag, x1, x2 in event:\n                if flag:\n                    intervals.append((x1, x2))\n                else:\n                    intervals.remove((x1, x2))\n            width = merge_intervals(intervals)\n            last_y = y\n        \n        return area", "from functools import reduce\nclass Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        def intersection(a, b):\n            return [max(a[0], b[0]), max(a[1], b[1]), min(a[2], b[2]), min(a[3], b[3])]\n        \n        def area(rec):\n            dx = max(0, rec[2] - rec[0])  # <================== need to use max!!!\n            dy = max(0, rec[3] - rec[1])\n            return dx * dy\n        \n        import itertools\n        a = 0\n        for i in range(1, len(rectangles) + 1):\n            sign = (-1) ** (i + 1)\n            for k in itertools.combinations(rectangles, i):\n                a += sign * area(reduce(intersection, k))\n\n        return a % (10**9 + 7)\n    \n    #50\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        \n        xmap = [{}, {}]\n        xs = [[], []]\n\n        for i in rectangles:\n            xs[0].append(i[0])\n            xs[0].append(i[2])\n            xs[1].append(i[1])\n            xs[1].append(i[3])\n        xs[0].sort()\n        xs[1].sort()\n        # print(xs)\n        rmap = [[], []]\n        for k in range(2):\n            cnt = 0\n            for i in xs[k]:\n                if i not in xmap[k]:\n                    xmap[k][i] = cnt\n                    rmap[k].append(i)\n                    cnt += 1\n        # print(rmap)\n        grid = [[0] * len(rmap[0]) for _ in range(len(rmap[1]))]  # donnot add extra []\n\n        for r in rectangles:\n            for i in range(xmap[0][r[0]], xmap[0][r[2]]):\n                for j in range(xmap[1][r[1]], xmap[1][r[3]]):\n                    # print(i, j, len(grid), len(grid[0]))\n                    grid[j][i] = 1   # <========================= not [i][j]\n        \n        area = 0\n        for i in range(len(rmap[0]) - 1):\n            width = rmap[0][i + 1] - rmap[0][i]\n            for j in range(len(rmap[1]) - 1):\n                if grid[j][i]:\n                    area += width * (rmap[1][j + 1] - rmap[1][j])\n        return area % (10**9 + 7)\n            \n        \n                \n        \n\n", "import numpy as np\nclass Solution:\n    def rectangleArea(self, A: List[List[int]]) -> int:\n        sa = sorted(set(a for x1, y1, x2, y2 in A for a in [x1, x2]))\n        xs = sorted(sa)\n        dic = {v : i for i, v in enumerate(xs)}\n        B = []\n        for x1, y1, x2, y2 in A:\n            B.append([y1, x1, x2, 1])\n            B.append([y2, x1, x2, -1])\n        B.sort()\n        sum_x = ret = cur_y = 0\n        ct = np.zeros(len(xs))\n        for y, x1, x2, flag in B:\n            ret += sum_x * (y - cur_y)\n            cur_y = y\n            ct[dic[x1]:dic[x2]] += flag\n            sum_x = sum([x2 - x1 for x1, x2, f in zip(xs, xs[1:], ct) if f])\n        return ret % (10 ** 9 + 7)", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        all_x, all_y = set(), set()\n        for x1, y1, x2, y2 in rectangles:\n            all_x.add(x1)\n            all_x.add(x2)\n            all_y.add(y1)\n            all_y.add(y2)\n        all_x = list(all_x)\n        all_x.sort()\n        all_y = list(all_y)\n        all_y.sort()\n        \n        x_map = {val: i for i, val in enumerate(all_x)}\n        y_map = {val: i for i, val in enumerate(all_y)}\n        area = [[0 for _ in range(len(y_map))] for _ in range(len(x_map))]\n        \n        for x1, y1, x2, y2 in rectangles:\n            for x in range(x_map[x1], x_map[x2]):\n                for y in range(y_map[y1], y_map[y2]):\n                    area[x][y] = 1\n        \n        ans = 0\n        for x in range(len(x_map)):\n            for y in range(len(y_map)):\n                if area[x][y]:\n                    ans += (all_x[x+1] - all_x[x]) * (all_y[y+1] - all_y[y])\n                    if ans > 1000000007:\n                        ans %= 1000000007\n        return ans", "from heapq import heappush, heappop\nclass Solution(object):\n    def rectangleArea(self, recs):\n        \\\"\\\"\\\"\n        :type rectangles: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        x = set()\n        pq = []\n        for rec in recs:\n            x.add(rec[0])\n            x.add(rec[2])\n            heappush(pq, (rec[1], rec[0], rec[2], 1))\n            heappush(pq, (rec[3], rec[0], rec[2], -1))\n        \n        x = sorted(list(x))\n        xi = {v:i for i,v in enumerate(x)}\n        count = [0] * len(x)\n        \n        res = 0\n        last_l = cur_l = pq[0][0]\n        \n#         print(pq)\n        \n        while pq:\n#             print(pq)\n#             print(count)\n            cur_l = pq[0][0]\n\n            for i in range(len(x)):\n                if count[i] > 0:\n                    res += (x[i+1] - x[i]) * (cur_l-last_l)\n                    res = res % (10**9 + 7)\n            while pq and pq[0][0] == cur_l:\n#                 print(cur_l, pq)\n                cur_l, x1, x2, bound = heappop(pq)\n                for i in range(xi[x1],xi[x2]):\n                    count[i] += bound\n            \n            last_l = cur_l\n        return res", "class Solution(object):\n    def rectangleArea(self, rectangles):\n        # Populate events\n        OPEN, CLOSE = 0, 1\n        events = []\n        for x1, y1, x2, y2 in rectangles:\n            events.append((y1, OPEN, x1, x2))\n            events.append((y2, CLOSE, x1, x2))\n        events.sort()\n\n        def query():\n            ans = 0\n            cur = -1\n            for x1, x2 in active:\n                cur = max(cur, x1)\n                ans += max(0, x2 - cur)\n                cur = max(cur, x2)\n            return ans\n\n        active = []\n        cur_y = events[0][0]\n        ans = 0\n        for y, typ, x1, x2 in events:\n            # For all vertical ground covered, update answer\n            ans += query() * (y - cur_y)\n\n            # Update active intervals\n            if typ is OPEN:\n                active.append((x1, x2))\n                active.sort()\n            else:    \n                active.remove((x1, x2))\n\n            cur_y = y\n\n        return ans % (10**9 + 7)", "MOD = 10 ** 9 + 7\n\nclass Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n\n        allY = []\n        for x1, y1, x2, y2 in rectangles:\n            allY.append((y1, 0, x1, x2))\n            allY.append((y2, 1, x1, x2))\n        allY.sort()\n\n        allX, ans = [], 0\n        curHeight = allY[0][0]\n\n        for y, t, x1, x2 in allY:\n            ans += self.getX(allX) * (y - curHeight)\n            ans %= MOD\n            if t == 0:\n                bisect.insort(allX, (x1, x2))\n            else:\n                allX.remove((x1, x2))\n\n            curHeight = y\n\n        return ans\n\n    def getX(self, allX):\n        ans = 0\n        cur = -1\n        for x1, x2 in allX:\n            cur = max(cur, x1)\n            ans += max(0, x2 - cur)\n            cur = max(cur, x2)\n        return ans", "from typing import List\n\n\nclass Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        xs = sorted(set([x for x1, y1, x2, y2 in rectangles for x in [x1, x2]]))\n        xi = {v: i for i, v in enumerate(xs)}\n        co = [0] * len(xs)\n        ar = []\n        for x1, y1, x2, y2 in rectangles:\n            ar.append([y1, x1, x2, 1])\n            ar.append([y2, x1, x2, -1])\n        ar.sort()\n\n        ly = lx = res = 0\n\n        for y, x1, x2, sig in ar:\n            res += (y - ly) * lx\n            ly = y\n\n            for i in range(xi[x1], xi[x2]):\n                co[i] += sig\n            lx = sum(xs[i + 1] - xs[i] if co[i] else 0 for i in range(len(xs) - 1))\n        return res % (10 ** 9 + 7)", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        xs = sorted({x for x1, _, x2, _ in rectangles for x in [x1, x2]})\n        index = {v : i for i, v in enumerate(xs)}\n        cnt = [0] * len(index)\n        events = []\n        for x1, y1, x2, y2 in rectangles:\n            events.append([y1, x1, x2, 1])\n            events.append([y2, x1, x2, -1])\n        events.sort()\n        curr_y = curr_x_sum = area = 0\n        for y, x1, x2, sign in events:\n            area += (y - curr_y) * curr_x_sum\n            curr_y = y\n            for i in range(index[x1], index[x2]):\n                cnt[i] += sign\n            curr_x_sum = sum(x2 - x1 if c else 0 for x1, x2, c in zip(xs, xs[1:], cnt))\n        return area % (10**9 + 7)", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        xs = sorted(set([x for x1, y1, x2, y2 in rectangles for x in [x1, x2]]))\n        x_i = {v: i for i, v in enumerate(xs)}\n        count = [0] * len(x_i)\n        L = []\n        for x1, y1, x2, y2 in rectangles:\n            L.append([y1, x1, x2, 1])\n            L.append([y2, x1, x2, -1])\n        L.sort()\n        cur_y = cur_x_sum = area = 0\n        for y, x1, x2, sig in L:\n            area += (y - cur_y) * cur_x_sum\n            cur_y = y\n            for i in range(x_i[x1], x_i[x2]):\n                count[i] += sig\n            cur_x_sum = sum(x2 - x1 if c else 0 for x1, x2, c in zip(xs, xs[1:], count))\n        return area % (10 ** 9 + 7)", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        # coord compression\n        xs = sorted(set(x for x1, _, x2, _ in rectangles for x in [x1, x2]))\n        xi = {v:i for i, v in enumerate(xs)}\n        count = [0]*len(xs)\n        lines = []\n        \n        for x1,y1,x2,y2 in rectangles:\n            lines.append((y1, x1, x2, 1))\n            lines.append((y2, x1, x2, -1))\n        lines.sort()\n        curr_y, x_sum, res = 0,0,0\n        for y, x1, x2, sign in lines:\n            res += x_sum*(y-curr_y)\n            curr_y = y\n            for i in range(xi[x1], xi[x2]):\n                count[i] += sign\n                \n            x_sum = 0\n            for i in range(len(xs)-1):\n                if count[i]>0:\n                    x_sum += xs[i+1]-xs[i]\n                    \n        return res%(10**9+7)\n        \n", "class Solution:\n    def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        x_set = set()\n        points = []\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_set.add(x1)\n            x_set.add(x2)\n            heapq.heappush(points, (y1, x1, x2, 1))\n            heapq.heappush(points, (y2, x1, x2, -1))\n        \n        x_list = sorted(list(x_set))\n        mapping = {x: i for i, x in enumerate(x_list)}\n        count = [0]*len(x_list)\n        \n        res = 0\n        pre_y = points[0][0]\n        \n        while points:\n            cur_y = points[0][0]\n            h = cur_y-pre_y\n            for i in range(len(x_list)-1):\n                if count[i] > 0:\n                    res += (x_list[i+1]-x_list[i])*h\n            res %= (10**9+7)\n            \n            while points and points[0][0] == cur_y:\n                cur_y, x1, x2, cnt = heapq.heappop(points)\n                for i in range(mapping[x1], mapping[x2]):\n                    count[i] += cnt\n            \n            pre_y = cur_y\n        \n        return res"]
["import os\nfrom io import BytesIO\nimport sys\nimport threading\n\n\nsys.setrecursionlimit(10 ** 9)\nthreading.stack_size(67108864)\n\n\ndef main():\n\n    # input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    def ad(i, j):\n        nonlocal g\n        if j in g[i]:\n            g[i].remove(j)\n            g[j].remove(i)\n        else:\n            g[i].add(j)\n            g[j].add(i)\n\n    def dfs(v):\n        nonlocal used, g, nans\n        used[v] = True\n        nans.append(v + 1)\n        for el in g[v]:\n            if not used[el]:\n                dfs(el)\n\n    for _ in range(int(input())):\n        n = int(input())\n        cnt = [set() for i in range(n)]\n        g = [set() for i in range(n)]\n        used = [False] * n\n        triangles = []\n        for i in range(n - 2):\n            a, b, c = map(int, input().split())\n            a -= 1\n            b -= 1\n            c -= 1\n            cnt[a].add(i)\n            cnt[b].add(i)\n            cnt[c].add(i)\n            triangles.append((a, b, c))\n            ad(a, b)\n            ad(b, c)\n            ad(a, c)\n        q = []\n        ones = []\n        for i in range(n):\n            if len(cnt[i]) == 1:\n                ones.append(i)\n        ans = []\n        nans = []\n        for i in range(n - 2):\n            t = ones.pop()\n            ind = cnt[t].pop()\n            ans.append(ind + 1)\n            cnt[triangles[ind][0]].discard(ind)\n            cnt[triangles[ind][1]].discard(ind)\n            cnt[triangles[ind][2]].discard(ind)\n            if len(cnt[triangles[ind][0]]) == 1:\n                ones.append(triangles[ind][0])\n            if len(cnt[triangles[ind][1]]) == 1:\n                ones.append(triangles[ind][1])\n            if len(cnt[triangles[ind][2]]) == 1:\n                ones.append(triangles[ind][2])\n        dfs(0)\n        print(*nans)\n        print(*ans)\n\n\ntt = threading.Thread(target = main)\ntt.start()", "import sys\nfrom heapq import heappush, heappop\nfrom collections import Counter, defaultdict\n\n# inf = open('input.txt', 'r')\n# reader = (map(int, line.split()) for line in inf)\nreader = (list(map(int, line.split())) for line in sys.stdin)\n\ndef insert(pq, value, entry_finder, push_id):\n    entry = [value, push_id]\n    entry_finder[push_id] = entry\n    heappush(pq, entry)    \n\ndef remove(entry_finder, push_id):\n    entry = entry_finder.pop(push_id)\n    entry[-1] = -1\n    \ndef extract_min(pq, entry_finder):\n    while pq:\n        value, push_id = heappop(pq)\n        if push_id > 0:\n            del entry_finder[push_id]\n            return (push_id, value)\n    return (-1, '*')\n\nt, = next(reader)\nfor test in range(t):\n    n, = next(reader)\n    pq = []\n    entry_finder = {}\n    triangle = [tuple(next(reader)) for _ in range(n-2)]\n    deg = Counter()\n    v_tri = defaultdict(list)\n    used = set()\n    for i, tri in enumerate(triangle):\n        for v in tri:\n            deg[v] += 1\n            v_tri[v].append(i)\n    for v, value in list(deg.items()):\n        insert(pq, value, entry_finder, push_id=v)\n    g = [set() for _ in range(n+1)]\n    ansQ = []\n    for _ in range(n-2):\n        v, value = extract_min(pq, entry_finder)\n        while True:\n            i = v_tri[v].pop()\n            if i not in used:\n                break\n        used.add(i)\n        ansQ.append(i+1)\n        tri = triangle[i]\n        tos = [to for to in tri if to != v]\n        for to in tos:\n            if to in g[v]:\n                g[v].remove(to)\n                g[to].remove(v)\n            else:\n                g[v].add(to)\n                g[to].add(v)\n            deg[to] -= 1\n            remove(entry_finder, push_id=to)\n            insert(pq, deg[to], entry_finder, push_id=to)\n        to1, to2 = tos\n        if to1 in g[to2]:\n            g[to1].remove(to2)\n            g[to2].remove(to1)\n        else:\n            g[to1].add(to2)\n            g[to2].add(to1)\n    ansP = []\n    visited = [False] * (n+1)\n    s = 1\n    stack = [s]\n#     print(g)\n    while stack:\n        v = stack.pop()\n        if not visited[v]:\n            visited[v] = True\n            ansP.append(v)\n            for to in g[v]:\n                stack.append(to)\n    print(*ansP)\n    print(*ansQ)\n\n# inf.close()\n", "class Union:\n    def __init__(self, n):\n        self.p    = [i for i in range(n+1)]\n        self.rank = [0] * (n+1) \n        \n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.p[x]     = y\n                self.rank[y] += self.rank[x]\n            else:\n                self.p[y]     = x\n                self.rank[x] += self.rank[y]\n\ndef push(g, u, v):\n    if u not in g:\n        g[u] = []\n    if v not in g:\n        g[v] = []\n        \n    g[u].append(v)\n    g[v].append(u)\n    \n    \ndef push_c(cnt, u, i):\n    if u not in cnt:\n        cnt[u] = set()\n    cnt[u].add(i) \n    \ndef process(cnt, tup, deg0, order, g, U, u):\n    if len(cnt[u]) > 0:\n        i = next(iter(cnt[u]))\n    else:\n        return\n    \n    for v in tup[i]:\n        cnt[v].remove(i)\n        \n        if len(cnt[v]) == 1:\n            deg0.append(v)\n            \n    v, w = None, None\n    for x in tup[i]:\n        if x == u:\n            continue\n        if v is None:\n            v = x\n        else:\n            w = x\n    \n    order.append(i)\n    \n    if U.find(u) != U.find(v):\n        U.union(u, v)\n        push(g, u, v)\n        \n    if U.find(u) != U.find(w):\n        U.union(u, w)\n        push(g, u, w)\n        \ndef solve():        \n    n   = int(input())\n    tup = [list(map(int, input().split())) for _ in range(n-2)]\n    g = {}\n    cnt={}\n    order = []\n\n    for i, [u,v,w] in enumerate(tup):\n        push_c(cnt, u, i)\n        push_c(cnt, v, i)\n        push_c(cnt, w, i)\n    \n    U = Union(n)\n    deg0 = [x for x, num in list(cnt.items()) if len(num) == 1]\n\n    while len(deg0) > 0:\n        u = deg0.pop()\n        process(cnt, tup, deg0, order, g, U, u)\n    \n    used = [0] * (n-2)   \n    for i in order:\n        used[i] = 1\n            \n    for i, x in enumerate(used):\n        if x == 0:\n            order.append(i)\n            \n    circle=[]\n    used = [0] * (n+1)    \n\n    for u in g:\n        if len(g[u]) == 1:\n            circle.append(u)\n            used[u]=1\n            break\n    i=0\n    \n    while i<len(circle):\n        u=circle[i]\n        for v in g[u]:\n            if used[v]==0:\n                used[v]=1\n                circle.append(v)\n        i+=1        \n        \n    print(' '.join([str(x) for x in circle]))\n    print(' '.join([str(x+1) for x in order]))\n    \nfor _ in range(int(input())):\n    solve()\n", "\ndef get_edge(vertex1, vertex2):\n    return (vertex1, vertex2) if vertex1 < vertex2 else (vertex2, vertex1)\n\n\ndef swap(arr, i, j):\n    temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n\n\ndef __starting_point():\n    T = int(input())\n    for t in range(T):\n        n = int(input())\n        pieces = []\n        for c in range(n-2):\n            inp = input().rstrip().split(\" \")\n            pieces.append([int(inp[0]), int(inp[1]), int(inp[2])])\n\n        # Preparing the graph\n        G = {}\n        piece_index = 0\n        while piece_index < len(pieces):\n            for vertex in pieces[piece_index]:\n                if vertex not in G:\n                    G[vertex] = {}\n                G[vertex][piece_index] = True\n            piece_index += 1\n\n        # prepare list of vertices associated with only one piece\n        # That piece can be safely removed\n        next_vertices = []\n        for vertex in G:\n            if len(G[vertex]) == 1:\n                next_vertices.append(vertex)\n\n        q = []\n        border_edges = {}\n        non_border_edges = {}\n        while len(next_vertices) > 0:\n            v = next_vertices.pop()\n            if len(G[v]) > 0:\n                piece_index = list(G[v].keys()).pop()\n                q.append(str(piece_index+1))\n                piece = pieces[piece_index]\n                G.pop(v)\n                for vertex_index in range(3):\n                    vertex = piece[vertex_index]\n                    if vertex != v:\n                        G[vertex].pop(piece_index)\n                        if len(G[vertex]) == 1:\n                            next_vertices.append(vertex)\n                        edge = get_edge(v, vertex)\n                        if edge not in non_border_edges:\n                            border_edges[edge] = True\n                    else:\n                        swap(piece, 0, vertex_index)\n                edge = get_edge(piece[1], piece[2])\n                non_border_edges[edge] = True\n\n        border_edges = list(border_edges.keys())\n        vertices = {}\n        for a, b in border_edges:\n            if a not in vertices:\n                vertices[a] = {}\n            if b not in vertices:\n                vertices[b] = {}\n            vertices[a][b] = True\n            vertices[b][a] = True\n\n        start = None\n        start_val = 5000000000\n        for vertex in vertices:\n            if len(vertices[vertex]) < start_val:\n                start = vertex\n                start_val = len(vertices[vertex])\n\n        v = start\n        p = []\n        while len(p) < n:\n            p.append(str(v))\n            assert len(vertices[v]) <= 1\n            if len(vertices[v]) == 1:\n                neighbor = list(vertices[v].keys()).pop()\n                vertices[neighbor].pop(v)\n                v = neighbor\n\n        print(\" \".join(p))\n        print(\" \".join(q))\n\n__starting_point()", "import heapq\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    counts = [0] * n\n    triangles = [set() for _ in range(n)]\n    assign_order = {}\n    for i in range(n - 2):\n        a, b, c = [x - 1 for x in list(map(int, input().split()))]\n        t = (a, b, c)\n        assign_order[t] = i\n        for x in t:\n            counts[x] += 1\n            triangles[x].add(t)\n\n    not_edges = set()\n    edges = set()\n    order = []\n    que = [i for i in range(n) if counts[i] == 1]\n    index = 0\n    while index < n - 2:\n        curr = que[index]\n        tt = triangles[curr].pop()  # should remain one\n        order.append(assign_order[tt])\n        t = set(tt)\n        t.remove(curr)\n        a, b = t.pop(), t.pop()\n        for e in (curr, a), (curr, b):\n            if e not in not_edges:\n                edges.add(e)\n        if index < n - 3:\n            not_edges.add((a, b))\n            not_edges.add((b, a))\n        else:\n            if (a, b) not in not_edges:\n                edges.add((a, b))\n\n        for x in a, b:\n            counts[x] -= 1\n            if counts[x] == 1:\n                que.append(x)\n            triangles[x].remove(tt)\n        index += 1\n\n    e = [[] for _ in range(n)]\n    for a, b in edges:\n        e[a].append(b)\n        e[b].append(a)\n\n    visited = [False] * n\n    a = 0\n    answer = []\n    for i in range(n):\n        visited[a] = True\n        answer.append(a)\n        for b in e[a]:\n            if not visited[b]:\n                a = b\n                break\n\n    print(' '.join(map(str, [x + 1 for x in answer])))\n    print(' '.join(map(str, [x + 1 for x in order])))\n"]
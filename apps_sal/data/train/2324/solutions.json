["#!/usr/bin/env python3\n\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    n = int(input())\n    adj_list = [[] for i in range(n)]\n    for i in range(n - 1):\n        a1, b1 = list(map(int, sys.stdin.readline().split()))\n        adj_list[a1 - 1].append(b1 - 1)\n        adj_list[b1 - 1].append(a1 - 1)\n    path = list(reversed(dfs(0, -1, adj_list, n)))\n    assert len(path) >= 2\n    fpath = len(path) - len(path) // 2\n    cut = set(path[fpath - 1:fpath + 1])\n    f = dfs2(0, -1, adj_list, n, cut)\n    s = dfs2(n - 1, -1, adj_list, n, cut)\n    assert f + s == n\n    print((\"Fennec\" if f > s else \"Snuke\"))\n\ndef dfs(now, prev, adj_list, n):\n    if now == n - 1:\n        return [now]\n    for next in adj_list[now]:\n        if next == prev:\n            continue\n        p = dfs(next, now, adj_list, n)\n        if p is not None:\n            p.append(now)\n            return p\n\ndef dfs2(now, prev, adj_list, n, cut):\n    size = 1\n    for next in adj_list[now]:\n        if next == prev:\n            continue\n        if {now, next} == cut:\n            continue\n        s = dfs2(next, now, adj_list, n, cut)\n        size += s\n    return size\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N=int(input())\nfrom collections import defaultdict,deque\nbranch=defaultdict(set)\nfor i in range(N-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    branch[a]|={b}\n    branch[b]|={a}\ncheck={0}\nbef=[-2]*N\nbef[0]=-1\ndist=[float('inf')]*N\ndist[0]=0\nwhile len(check)>0:\n    now=check.pop()\n    for nex in branch[now]:\n        if bef[nex]==-2:\n            bef[nex]=now\n            check|={nex}\n            dist[nex]=dist[now]+1\nNG=set()\nOK={0}\nnow=N-1\nchecked={0}\nfor i in range((1+dist[N-1])//2):\n    NG|={now}\n    now=bef[now]\nchecked|=NG\nfor i in range(N):\n    if i in checked:\n        continue\n    else:\n        visited={i}\n        now=i\n        while True:\n            now=bef[now]\n            visited|={now}\n            if now in NG:\n                NG|=visited\n                checked|=visited\n                break\n            elif now in OK:\n                OK|=visited\n                checked|=visited\n                break\nif len(OK)>N//2:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "import sys\nsys.setrecursionlimit(100000)\n\nN = int(input())\nG = [[] for i in range(N)]\nfor i in range(N-1):\n    a, b = (int(i) for i in input().split())\n    G[a-1].append(b-1)\n    G[b-1].append(a-1)\n\nprev = [-1]*N\ndef DFS(start):\n    res = 0\n    for u in G[start]:\n        if u != prev[start]:\n            prev[u] = start\n            res += DFS(u)\n    return res+1\n\nDFS(0)\nstart = N-1\npath = [N-1]\nwhile True:\n    path.append(prev[start])\n    start = prev[start]\n    if start == 0:\n        break\npath.reverse()\nnum = len(path)\nc, d = (path[(num+1)//2-1], path[(num+1)//2])\nG[c].remove(d)\nG[d].remove(c)\nprev = [-1]*N\nDFS0 = DFS(0)\nprev = [-1]*N\nif DFS0 > DFS(N-1):\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque\n\n\ninf = float('inf')\n\ndef solve(N: int, a: \"List[int]\", b: \"List[int]\"):\n    adj = [set() for _ in range(N)]\n    for u, v in zip(a, b):\n        adj[u].add(v)\n        adj[v].add(u)\n    \n    dist_F = [inf for _ in range(N)]\n    dist_F[0] = 0\n    dist_S = [inf for _ in range(N)]\n    dist_S[N-1] = 0\n\n    Q = deque([(0, 0)], N)\n    while len(Q) > 0:\n        du, u = Q.pop()\n        for v in adj[u]:\n            if dist_F[v] < inf:\n                continue\n            dist_F[v] = du + 1\n            Q.append((du+1, v))\n    \n\n    Q = deque([(0, N-1)], N)\n    while len(Q) > 0:\n        du, u = Q.pop()\n        for v in adj[u]:\n            if dist_S[v] < inf:\n                continue\n            dist_S[v] = du + 1\n            Q.append((du+1, v))\n\n    c_S = 0\n    c_F = 0\n\n    for df, ds in zip(dist_F, dist_S):\n        if df <= ds:\n            c_F += 1\n        else:\n            c_S += 1\n\n    if c_F <= c_S:\n        print('Snuke')\n    else:\n        print('Fennec')    \n\n    return\n\n\n# Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    a = [int()] * (N-1)  # type: \"List[int]\" \n    b = [int()] * (N-1)  # type: \"List[int]\" \n    for i in range(N-1):\n        a[i] = int(next(tokens)) - 1\n        b[i] = int(next(tokens)) - 1\n    solve(N, a, b)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from heapq import heappop, heappush\n\nN = int(input())\nL = [[] for i in range(N + 1)]\nFd = [float(\"inf\") for i in range(N + 1)]\nSd = [float(\"inf\") for i in range(N + 1)]\nFd[1] = 0\nSd[N] = 0\n\nfor i in range(N - 1):\n    a, b = list(map(int, input().split()))\n    L[a].append(b)\n    L[b].append(a)\n\nQ = []\nheappush(Q, 1)\nwhile Q:\n    n = heappop(Q)\n    d = Fd[n]\n    for x in L[n]:\n        if Fd[x] == float(\"inf\"):\n            Fd[x] = d + 1\n            heappush(Q, x)\n\nQ = []\nheappush(Q, N)\nwhile Q:\n    n = heappop(Q)\n    d = Sd[n]\n    for x in L[n]:\n        if Sd[x] == float(\"inf\"):\n            Sd[x] = d + 1\n            heappush(Q, x)\n\nf = 0\ns = 0\nfor i in range(1, N + 1):\n    if Fd[i] <= Sd[i]:\n        f += 1\n    else:\n        s += 1\n\nif f > s:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "from scipy.sparse import*\nn,*a=map(int,open(0).read().split())\nc=[1]*~-n\nprint('FSennunkeec'[sum(g>h for g,h in zip(*csgraph.dijkstra(csr_matrix((c,(a[::2],a[1::2])),[n+1]*2),0,[1,n])))*2>=n::2])", "from collections import deque\nn = int(input())\nboard = [0]*n\nedge = [[] for i in range(n)]\nfor i in range(n-1):\n    a,b = map(int, input().split())\n    edge[a-1].append(b-1)\n    edge[b-1].append(a-1)\nq = deque()\nq.append((0,1))\nq.append((-1,-1))\nwhile q:\n    from_, color = q.popleft()\n    if board[from_] != 0:\n        continue\n    board[from_] = color\n    for i in edge[from_]:\n        q.append((i,color))\nif sum(board) > 0:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "import sys\n\ndef main():\n    sys.setrecursionlimit(1000000) # recursion limit hack\n    buf = input()\n    N = int(buf)\n    a = []\n    b = []\n    for i in range(N-1):\n        buf = input()\n        buflist = buf.split()\n        a.append(int(buflist[0]) - 1)\n        b.append(int(buflist[1]) - 1)\n    graph = []\n    for i in range(N):\n        graph.append([])\n    for i in range(N-1):\n        graph[a[i]].append(b[i])\n        graph[b[i]].append(a[i])\n    path = find_path(graph, 0, N-1, [])\n    split_point = (len(path) + 1) // 2\n    fennec_base = path[0:split_point]\n    snuke_base = path[split_point:len(path)]\n    fennec_vertex_count = len(fennec_base)\n    snuke_vertex_count = len(snuke_base)\n    for i, v in enumerate(fennec_base):\n        for j in graph[v]:\n            if i != 0:\n                if j == fennec_base[i-1]:\n                    continue\n            if i != len(fennec_base) - 1:\n                if j == fennec_base[i+1]:\n                    continue\n            else:\n                if j == snuke_base[0]:\n                    continue\n            fennec_vertex_count += get_vertex_count(graph, v, j)\n    for i, v in enumerate(snuke_base):\n        for j in graph[v]:\n            if i != 0:\n                if j == snuke_base[i-1]:\n                    continue\n            else:\n                if j == fennec_base[-1]:\n                    continue\n            if i != len(snuke_base) - 1:\n                if j == snuke_base[i+1]:\n                    continue\n            snuke_vertex_count += get_vertex_count(graph, v, j)\n    if fennec_vertex_count > snuke_vertex_count:\n        print(\"Fennec\")\n    else:\n        print(\"Snuke\")\n\ndef find_path(graph, current, target, path):\n    path.append(current)\n    if current == target:\n        return path\n    for i in graph[current]:\n        if len(path) >= 2:\n            if i == path[-2]:\n                continue\n        result = find_path(graph, i, target, path)\n        if result:\n            return path\n    path.pop()\n    return None\n\ndef get_vertex_count(graph, base, next):\n    count = 1\n    for i in graph[next]:\n        if i == base:\n            continue\n        count += get_vertex_count(graph, next, i)\n    return count\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nimport sys\nsys.setrecursionlimit(1000000)\nN = int(input())\ngraph = {}\nSCORE = 0\ndef dfs(visited,v,depth):\n    visited[v] = depth\n    for next_v in graph[v]:\n        if  visited[next_v]  == -1 :\n            dfs(visited,next_v,depth + 1)\n\n\n\n\nfor _ in range(N-1):\n    a,b = list(map(int,input().split()))\n    if a not in graph:\n        graph[a] = [b]\n    else:\n        graph[a].append(b)\n\n    if b not in graph:\n        graph[b] = [a]\n    else:\n        graph[b].append(a)\n\nvF = [-1] * (N + 1)\nvF[1] = 0\ndfs(vF,1,0)\n# print(vF)\n\nvS = [-1] * (N + 1)\nvS[N] = 0\n\ndfs(vS,N,0)\n# print(vS)\n\nfc = 0\nsc = 0\n\nfor f,s in zip(vF[1:N + 1],vS[1:N + 1]):\n    if f <= s:\n        fc += 1\n    else:\n        sc += 1\n\n# print(fc,sc)\nif fc > sc:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")\n", "from sys import setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import *\nfrom bisect import *\n\ndef read():\n  return int(input())\n \ndef reads():\n  return [int(x) for x in input().split()]\n\nsetrecursionlimit(1 << 30)\n\nN = read()\nedges = [[] for _ in range(N)]\nfor _ in range(N-1):\n  a, b = reads()\n  a, b = a-1, b-1\n  edges[a].append(b)\n  edges[b].append(a)\n\ndef dist(u, d):\n  for v in edges[u]:\n    if d[v] >= 0:\n      continue\n    d[v] = d[u] + 1\n    dist(v, d)\n  return d\n\ndistf = dist(0, [0]+[-1]*(N-1))\ndists = dist(N-1, [-1]*(N-1)+[0])\n\nnumf = sum(distf[i] <= dists[i] for i in range(N))\nnums = N - numf\n\nif numf > nums:\n  print(\"Fennec\")\nelse:\n  print(\"Snuke\")", "n = int(input())\nedges = [[] for _ in range(n)]\n \nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\ndp = [0]*n\ndp[0] =1\nfp = [0]*n\nfp[n-1] =1\ndef bfs(u):\n    q = []\n    q.append(u)\n    while q:\n        p = q.pop()\n        for i in edges[p]:\n            if dp[i] ==0 :\n                q.append(i)\n                dp[i]+=dp[p]+1\ndef ffs(u):\n    q = []\n    q.append(u)\n    while q:\n        p = q.pop()\n        for i in edges[p]:\n            if fp[i] ==0 :\n                q.append(i)\n                fp[i]+=fp[p]+1\nbfs(0)\nffs(n-1)\nc = 0\nfor i in range(n):\n    if dp[i] <= fp[i]:\n        c += 1\nif 2*c > n:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "import sys\nfrom collections import deque\nreadline = sys.stdin.readline\n\ndef main():\n    INF = float('inf')\n\n    N = int(readline())\n    conn = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        a, b = list(map(int, readline().split()))\n        a -= 1; b -= 1\n        conn[a].append(b)\n        conn[b].append(a)\n\n    dist = [INF]*N\n    prev = [-1]*N\n    dist[0] = 0; q = deque([0])\n    while q:\n        x = q.popleft()\n        for y in conn[x]:\n            if dist[y] == INF:\n                dist[y] = dist[x] + 1\n                prev[y] = x\n                q.append(y)\n\n    path = deque([])\n    t = N - 1\n    while t >= 0:\n        path.appendleft(t)\n        t = prev[t]\n\n    a, b = path[dist[-1] // 2], path[dist[-1] // 2 + 1]\n    conn[a].remove(b); conn[b].remove(a)\n\n    blacks = 0\n    visited_b = [False]*N\n    q_b = deque([0]); visited_b[0] = True\n    while q_b:\n        x = q_b.popleft()\n        blacks += 1\n        for y in conn[x]:\n            if not visited_b[y]:\n                visited_b[y] = True\n                q_b.append(y)\n\n    whites = 0\n    visited_w = [False]*N\n    q_w = deque([N - 1]); visited_w[N - 1] = True\n    while q_w:\n        x = q_w.popleft()\n        whites += 1\n        for y in conn[x]:\n            if not visited_w[y]:\n                visited_w[y] = True\n                q_w.append(y)\n\n    print((\"Fennec\" if blacks > whites else \"Snuke\"))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**6)\nN = int(input())\nI = [[] for _ in range(N)]\nfor _ in range(N-1):\n  a, b = list(map(int, input().split()))\n  I[a-1].append(b-1)\n  I[b-1].append(a-1)\n  \ndef path(s,t,pth,visited): #s\u304b\u3089t\u306b\u81f3\u308bpath\u3092\u6c42\u3081\u308b pth = list(), visited = set()\n  pth.append(s)\n  if s == t:\n    return (pth, True)\n  visited.add(s)\n  flag = False\n  for q in I[s]:\n    if q not in visited:\n      pth, flag = path(q,t,pth,visited)\n      if flag: return (pth, True)\n  pth.pop()\n  return (pth,False)\n\ndef count(s,d,visited): #\u30b0\u30e9\u30d5\u3092s\u3092\u542b\u307f\u3001d\u3092\u542b\u307e\u306a\u3044\u6700\u5927\u306e\u9023\u7d50\u6210\u5206\u306b\u5236\u9650\u3057\u305f\u6642\u306e\u8981\u7d20\u6570\n  visited.add(s)\n  for q in I[s]:\n    if q not in visited and q != d:\n      visited = count(q,d,visited)   \n  return visited\n      \npth, flag = path(0,N-1,[],set())  \n\nif not flag: print(\"error\")\nd = pth[(len(pth)+1)//2]\nn = len(count(0,d,set()))\n#print(pth, flag, d)\n\nif n > N//2:\n  print(\"Fennec\")\nelse:\n  print(\"Snuke\")\n  \n\n    \n\n    \n      \n      \n      \n  \n", "\n# -*- coding: utf-8 -*-\n\nimport sys\n\n\nclass UnionFind:\n    '''\n    \u914d\u5217\u3092\u7528\u3044\u305fUnionFind\n    '''\n\n    def __init__(self, size):\n        self.table = [i for i in range(size)]\n\n    def find(self, x):\n        '''\n        x\u306e\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\u3092\u8fd4\u3059\n        '''\n        return self.table[x]\n\n    def union(self, val, y):\n        '''\n        Fennec\u306f0\n         Snuke\u306fN-1\u3068\u3059\u308b\u3053\u3068\u3067\u3001O(1)\u306b\u3059\u308b\n         '''\n        self.table[y] = val\n\n    def same(self, x, y):\n        '''\n        x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306a\u3089true\n        '''\n        x1 = self.find(x)\n        y1 = self.find(y)\n        return x1 == y1\n\n    def get_table(self):\n        return self.table\n# python template for atcoder1\n\n\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\nN = int(input())\nadj = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = list(map(int, input().split()))\n    adj[a-1].append(b-1)\n    adj[b-1].append(a-1)\n\nUn = UnionFind(N)\nS = [N-1]\nF = [0]\nS_or = N-1\nF_or = 0\n\n\ndef oneStep(turn):\n    ret = []\n    if turn == 1:\n        while S:\n            c = S.pop(0)\n            for i in adj[c]:\n                if not Un.same(S_or, i) and not Un.same(F_or, i):\n                    Un.union(S_or, i)\n                    ret.append(i)\n    else:\n        while F:\n            c = F.pop(0)\n            for i in adj[c]:\n                if not Un.same(S_or, i) and not Un.same(F_or, i):\n                    Un.union(F_or, i)\n                    ret.append(i)\n    return ret\n\n\nturn = 0\nwhile S or F:\n    if turn == 1:\n        if len(S) != 0:\n            S = oneStep(turn)\n        turn = 0\n    else:\n        if len(F) != 0:\n            F = oneStep(turn)\n        turn = 1\n\ncntF = Un.get_table().count(0)\ncntS = Un.get_table().count(N-1)\nif cntF > cntS:\n    ans = \"Fennec\"\nelse:\n    ans = \"Snuke\"\nprint(ans)\n", "from collections import defaultdict\nfrom heapq import heappop, heappush\n\n\nclass Graph(object):\n    \"\"\"\n    \u96a3\u63a5\u30ea\u30b9\u30c8\u306b\u3088\u308b\u6709\u5411\u30b0\u30e9\u30d5\n    \"\"\"\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def __len__(self):\n        return len(self.graph)\n\n    def add_edge(self, src, dst, weight=1):\n        self.graph[src].append((dst, weight))\n\n    def get_nodes(self):\n        return self.graph.keys()\n\n\nclass Dijkstra(object):\n    \"\"\"\n    \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\uff08\u4e8c\u5206\u30d2\u30fc\u30d7\uff09\u306b\u3088\u308b\u6700\u77ed\u7d4c\u8def\u63a2\u7d22\n    \u8a08\u7b97\u91cf: O((E+V)logV)\n    \"\"\"\n\n    def __init__(self, graph, start):\n        self.g = graph.graph\n\n        # start\u30ce\u30fc\u30c9\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\n        # start\u30ce\u30fc\u30c9\u306f0, \u305d\u308c\u4ee5\u5916\u306f\u7121\u9650\u5927\u3067\u521d\u671f\u5316\n        self.dist = defaultdict(lambda: float('inf'))\n        self.dist[start] = 0\n\n        # \u6700\u77ed\u7d4c\u8def\u3067\u306e1\u3064\u524d\u306e\u30ce\u30fc\u30c9\n        self.prev = defaultdict(lambda: None)\n\n        # start\u30ce\u30fc\u30c9\u3092\u30ad\u30e5\u30fc\u306b\u5165\u308c\u308b\n        self.Q = []\n        heappush(self.Q, (self.dist[start], start))\n\n        while self.Q:\n            # \u512a\u5148\u5ea6\uff08\u8ddd\u96e2\uff09\u304c\u6700\u5c0f\u3067\u3042\u308b\u30ad\u30e5\u30fc\u3092\u53d6\u308a\u51fa\u3059\n            dist_u, u = heappop(self.Q)\n            if self.dist[u] < dist_u:\n                continue\n            for v, weight in self.g[u]:\n                alt = dist_u + weight\n                if self.dist[v] > alt:\n                    self.dist[v] = alt\n                    self.prev[v] = u\n                    heappush(self.Q, (alt, v))\n\n    def shortest_distance(self, goal):\n        \"\"\"\n        start\u30ce\u30fc\u30c9\u304b\u3089goal\u30ce\u30fc\u30c9\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\n        \"\"\"\n        return self.dist[goal]\n\n    def shortest_path(self, goal):\n        \"\"\"\n        start\u30ce\u30fc\u30c9\u304b\u3089goal\u30ce\u30fc\u30c9\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\n        \"\"\"\n        path = []\n        node = goal\n        while node is not None:\n            path.append(node)\n            node = self.prev[node]\n        return path[::-1]\n\n\ng = Graph()\n#N, M = [int(i) for i in input().split()]\nN = int(input())\n\nfor i in range(N-1):\n    u, v = [int(i) for i in input().split()]\n    g.add_edge(u-1, v-1, 1)\n    g.add_edge(v-1, u-1, 1)\n\nd1 = Dijkstra(g, 0)\nd2 = Dijkstra(g, N-1)\n\nans = 0\n\n#print(d1.dist)\n#print(d2.dist)\n\nfor i in range(N):\n    if d1.dist[i] <= d2.dist[i]:\n        ans += 1\n\nif ans > N - ans:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "from collections import deque\n\n\ndef nearlist(N, LIST):\n    NEAR = [set() for _ in range(N)]\n    for a, b in LIST:\n        NEAR[a - 1].add(b - 1)\n        NEAR[b - 1].add(a - 1)\n    return NEAR\n\n\ndef bfs(S):\n    dist, flag = [-1] * n, [0] * n\n    dist[S], flag[S] = 0, 1\n    que = deque([S])\n\n    while que:\n        q = que.popleft()\n        for i in near[q]:\n            if flag[i]:\n                continue\n            dist[i] = dist[q] + 1\n            flag[i] = 1\n            que.append(i)\n    return dist\n\n\nn = int(input())\nab = [list(map(int, input().split())) for _ in range(n - 1)]\n\nnear = nearlist(n, ab)\nfennec, snuke = bfs(0), bfs(n - 1)\nans = sum(fennec[i] <= snuke[i] for i in range(n))\nprint(('Fennec' if ans * 2 > n else 'Snuke'))\n", "\nimport sys\n\np = []\npath = [ 0 for i in range(10**5+1)]\ndef main():\n\n    sys.setrecursionlimit(1000000)\n\n    N = int(input())\n\n    e = [ [] for i in range(N)]\n    for i in range(N-1):\n        a,b = list(map(int,input().split()))\n        a-=1\n        b-=1\n        e[a].append(b)\n        e[b].append(a)\n\n    col = [ -1 for i in range(N)]\n    col[0] = 0\n    \n    def dfs(n,c):\n        nonlocal p\n        if n == N - 1:\n            p = path\n        path[c] = n\n        for v in e[n]:\n            if col[v] == -1:\n                col[v] = c + 1\n                dfs(v,c+1)\n                if p:\n                    return\n    dfs(0,0)\n\n    t = col[N-1] + 1\n    if t % 2 ==0:\n        sn = p[t//2]\n    else:\n        sn = p[t//2+1]\n\n\n    colfn = [ -1 for i in range(N)]\n    colfn[0] = 0\n    def dfs2(n,c):\n\n        for v in e[n]:\n            if v == sn:\n                continue\n            elif colfn[v] == -1:\n                colfn[v] = c + 1\n                dfs2(v,c+1)\n\n    dfs2(0,0)\n\n    fennec = -1\n    for i in range(N):\n        if colfn[i] != -1:\n            fennec += 1\n\n    snuke = N - fennec - 2\n    if fennec > snuke:\n        print(\"Fennec\")\n    else:\n        print(\"Snuke\")\n\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "n = int(input())\nab = [list(map(int,input().split())) for i in range(n-1)]\ngraph = [[] for i in range(n+1)]\nvisited = [0 for i in range(n+1)]\nroot = 1\nstack = [root]\nfor a,b in ab:\n  graph[a].append(b)\n  graph[b].append(a)\nvisited[0] = -1\nvisited[root] = 1\nwhile stack:\n  x = stack.pop()\n  if x == n:\n    break\n  for y in graph[x]:\n    if visited[y] == 0:\n      stack.append(y)\n      visited[y] = visited[x]+1\ndist = visited[n]-1\nway = n\nwhile True:\n  if visited[way] == dist//2+2:\n    border = way\n    break\n  for y in graph[way]:\n    if visited[y] == visited[way]-1:\n      way = y\nstack = [1]\nvisited = [0 for i in range(n+1)]\nvisited[border] = 1\nfen = 0\nwhile stack:\n  x = stack.pop()\n  fen += 1\n  visited[x] = 1\n  for y in graph[x]:\n    if visited[y] == 0:\n      stack.append(y)\nsnk = n-fen\nif fen > snk:\n  print(\"Fennec\")\nelse:\n  print(\"Snuke\")", "n = int(input())\nedges = [[] for _ in range(n)]\n \nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n \ndef bfs(v):\n    q = []\n    depth = [n]*n\n    q.append(v)\n    depth[v] = 0\n    i = 0\n    while i < len(q):\n        x = q[i]\n        d = depth[x]\n        for e in edges[x]:\n            if depth[e] == n:\n                depth[e] = d+1\n                q.append(e)\n        i += 1\n    return depth\n \nd1 = bfs(0)\nd2 = bfs(n-1)\n \nc = 0\nfor i in range(n):\n    if d1[i] <= d2[i]:\n        c += 1\nif 2*c > n:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "from collections import deque\nN = int(input())\nedge = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    edge[a - 1].append(b - 1)\n    edge[b - 1].append(a - 1)\nd = [[-1] * N for _ in range(2)]\nfor i in range(2):\n    d[i][i * (N - 1)] = 0\n    q = deque([i * (N - 1)])\n    while len(q) > 0:\n        u = q.popleft()\n        for v in edge[u]:\n            if d[i][v] > -1:\n                continue\n            d[i][v] = d[i][u] + 1\n            q.append(v)\nS = 0\nF = 0\nfor i in range(N):\n    if d[0][i] > d[1][i]:\n        S += 1\n    else:\n        F += 1\nif F > S:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "import heapq\nimport sys\n\ninput = sys.stdin.readline\n\ndef dijlstra_heap(N,s,edge):\n    d = [float('inf')] * N\n    used = [True] * N\n    d[s] = 0\n    edgelist = []\n    for a, b in edge[s]:\n        heapq.heappush(edgelist, a*(10**6)+b)\n    while len(edgelist):\n        minedge = heapq.heappop(edgelist)\n        if not used[minedge%(10**6)]:\n            continue\n        v = minedge % (10 ** 6)\n        d[v] = minedge // (10 ** 6)\n        used[v] = False\n        for e in edge[v]:\n            if used[e[1]]:\n                heapq.heappush(edgelist,(e[0]+d[v])*(10**6)+e[1])\n    return d\n\ndef main():\n    N = int(input())\n    edge = [[] for i in range(N)]\n    for i in range(N-1):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        edge[a].append([1,b])\n        edge[b].append([1,a])\n    d0 = dijlstra_heap(N,0,edge)\n    dn = dijlstra_heap(N,N-1,edge)\n\n    f_cnt = 0\n    s_cnt = 0\n    for i in range(N):\n        if d0[i] <= dn[i]:\n            f_cnt += 1\n        else:\n            s_cnt += 1\n\n    if f_cnt > s_cnt:\n        print('Fennec')\n    else:\n        print('Snuke')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(2*10**5)\n\n# \u5165\u529b\nN = int(input())\na, b = (\n    list(zip(*(list(map(int, input().split())) for _ in range(N - 1)))) if N - 1 else\n    ((), ())\n)\n\nG = [set() for _ in range(N + 1)]\nfor x, y in zip(a, b):\n    G[x].add(y)\n    G[y].add(x)\n\n\ndp = [0 for _ in range(N + 1)]\ndp[1] = 1\n\n\ndef f(i):\n    for j in G[i]:\n        if dp[j] == 0:\n            dp[j] = i\n            f(j)\n\n\nf(1)\np = []\ni = N\nwhile i != 1:\n    p.append(i)\n    i = dp[i]\np.append(1)\ndp2 = [0 for _ in range(N + 1)]\nfor j in range(len(p)):\n    if dp2[p[-(j + 1)]] == 0:\n        dp2[p[-(j + 1)]] = 1\n    if dp2[p[j]] == 0:\n        dp2[p[j]] = -1\ndp3 = [0 for _ in range(N + 1)]\ndp3[1] = 1\n\n\ndef g(i):\n    for j in G[i]:\n        if dp3[j] == 0 and dp2[j] != -1:\n            dp3[j] = 1\n            g(j)\n\n\ng(1)\nans = (\n    'Fennec' if dp3.count(1) > N // 2 else\n    'Snuke'\n)\nprint(ans)\n", "\nimport sys\nsys.setrecursionlimit(1000000)\n\nN = int(input())\n\ne = [ [] for i in range(N)]\nfor i in range(N-1):\n    a,b = map(int,input().split())\n    a-=1\n    b-=1\n    e[a].append(b)\n    e[b].append(a)\n\ncol = [ -1 for i in range(N)]\ncol[0] = 0\n\np = []\npath = [ 0 for i in range(10**5+1)]\ndef dfs(n,c):\n    nonlocal p\n    if n == N - 1:\n        p = path\n    path[c] = n\n    for v in e[n]:\n        if col[v] == -1:\n            col[v] = c + 1\n            dfs(v,c+1)\n            if p:\n                return\ndfs(0,0)\n\nt = col[N-1] + 1\nif t % 2 ==0:\n    sn = p[t//2]\nelse:\n    sn = p[t//2+1]\n\n\ncolfn = [ -1 for i in range(N)]\ncolfn[0] = 0\ndef dfs2(n,c):\n\n    for v in e[n]:\n        if v == sn:\n            continue\n        elif colfn[v] == -1:\n            colfn[v] = c + 1\n            dfs2(v,c+1)\n\ndfs2(0,0)\n\nfennec = -1\nfor i in range(N):\n    if colfn[i] != -1:\n        fennec += 1\n\nsnuke = N - fennec - 2\nif fennec > snuke:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "n=int(input())\nnode=[[]for _ in range(n)]\nfor _ in range(n-1):\n\ta,b=map(int,input().split())\n\tnode[a-1].append(b-1)\n\tnode[b-1].append(a-1)\nvisited=[False]*n\ndef dfs(i):\n\tdis=[-1]*n\n\tdis[i]=0\n\tstack=[i]\n\twhile stack:\n\t\tp=stack.pop()\n\t\tfor x in node[p]:\n\t\t\tif dis[x]==-1:\n\t\t\t\tdis[x]=dis[p]+1\n\t\t\t\tstack.append(x)\n\treturn dis\nd0,dn=dfs(0),dfs(n-1)\ncnt=0\nfor i in range(n):\n\tif d0[i]>dn[i]:\n\t\tcnt+=1\nif cnt>=n/2:\n\tprint(\"Snuke\")\nelse:\n\tprint(\"Fennec\")", "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef dijkstra(V, E, s):\n    '''\n    Input:\n        V = list(range(N))\n        E = defaultdict(dict)\n        s (in V) : start vertex\n    Output:\n        dist: the list of the minimum cost from s to arbitrary vertex v in the given graph\n    '''\n    INF = float('inf')\n    dist = {v: INF for v in V}\n    heap = []\n    dist[s] = 0; rem = len(V);\n    heappush(heap, (0, s))\n    while heap and rem:\n        d, v = heappop(heap)\n        # don't need to check when the stored value is greater than provisional distance\n        if d > dist[v]: continue\n        rem -= 1;\n        for u, c in E[v].items():\n            temp = d + c\n            if temp < dist[u]:\n                dist[u] = temp\n                heappush(heap, (temp, u))\n    return dist\n\nN = int(input())\nV = list(range(1, N+1))\nE = defaultdict(dict)\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    E[a][b] = 1\n    E[b][a] = 1\nfen = dijkstra(V, E, 1)\nsun = dijkstra(V, E, N)\nblack, white = 0, 0\nfor v in V:\n    if fen[v] <= sun[v]: black += 1\n    else: white += 1\nprint('Fennec' if black > white else 'Snuke')", "from networkx import*\nN,*t=open(0)\nG=Graph()\nfor s in t:a,b=s.split();G.add_edge(a,b)\ns=shortest_path_length\nx=s(G,'1')\ny=s(G,N[:-1])\nprint('FSennunkeec'[sum(x[k]>y[k]for k in x)*2>=int(N)::2])", "from networkx import*\n(N,),*t=map(str.split,open(0))\nG=Graph()\nG.add_edges_from(t)\ns=shortest_path_length\nx=s(G,'1')\ny=s(G,N)\nprint('FSennunkeec'[sum(x[k]>y[k]for k in x)*2>=int(N)::2])", "\nN=int(input())\ne_list = [[] for i in range(N)]\nfor i in range(N-1):\n    a,b=list(map(int,input().split()))\n    a,b=a-1,b-1\n    e_list[a].append(b)\n    e_list[b].append(a)\n\nvi = 0 #\u6642\u3068\u5834\u5408\u306b\u3088\u3063\u3066\u3053\u3053\u3092\u5909\u3048\u308b\nfrom collections import deque\nQ = deque([vi])\nchecked_list = [False for i in range(N)]\nchecked_list[vi]=True\nprev_list = [-1 for i in range(N)]\nmin_path_list = [10**27 for i in range(N)] #\u554f\u984c\u306b\u3088\u308a\u3053\u3053\u3092\u5909\u3048\u308b\nmin_path_list[vi] = 0\nwhile len(Q)>0:\n    v = Q.pop()\n    for v1 in e_list[v]:\n        if not checked_list[v1]:\n            checked_list[v1]=True\n            Q.appendleft(v1)\n            prev_list[v1]=v\n            min_path_list[v1]=min(min_path_list[v1],min_path_list[v]+1) #\u554f\u984c\u306b\u3088\u308a\u3053\u3053\u3092\u5909\u3048\u308b\n\npath = [N-1]\nv=N-1\nwhile prev_list[v]!=-1:\n    path.append(prev_list[v])\n    v=prev_list[v]\n\na=path[(min_path_list[N-1]-1)//2]\nb=path[(min_path_list[N-1]-1)//2+1]\nfor i in range(len(e_list[a])):\n    if e_list[a][i]==b:\n        break\ndel e_list[a][i]\n\nfor i in range(len(e_list[b])):\n    if e_list[b][i]==a:\n        break\ndel e_list[b][i]\n\nvi = 0 #\u6642\u3068\u5834\u5408\u306b\u3088\u3063\u3066\u3053\u3053\u3092\u5909\u3048\u308b\n\nQ = deque([vi])\nchecked_list = [False for i in range(N)]\nchecked_list[vi]=True\ncount = 1\nwhile len(Q)>0:\n    v = Q.pop()\n    for v1 in e_list[v]:\n        if not checked_list[v1]:\n            checked_list[v1]=True\n            Q.appendleft(v1)\n            count+=1\n\nif count>N-count:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "n=int(input())\ntree=[[] for i in range(n)]\nfor i in range(n-1):\n  a,b=map(int,input().split())\n  tree[a-1].append(b-1)\n  tree[b-1].append(a-1)\ndef dist(k):\n  l=[-1]*n\n  node=[k]\n  while node:\n    s=node.pop()\n    d=l[s]\n    for t in tree[s]:\n      if l[t]!=-1:\n        continue\n      l[t]=d+1\n      node.append(t)\n  return l\nfrom_fennec=dist(0)\nfrom_snuke=dist(n-1)\nres=0\nfor i,j in zip(from_fennec,from_snuke):\n  if i<=j:\n    res+=1\n  else:\n    res-=1\nprint('Snuke' if res<=0 else 'Fennec')", "import sys\n\np = []\npath = [ 0 for i in range(10**5+1)]\ndef main():\n\n    sys.setrecursionlimit(1000000)\n\n    N = int(input())\n\n    e = [ [] for i in range(N)]\n    for i in range(N-1):\n        a,b = list(map(int,input().split()))\n        a-=1\n        b-=1\n        e[a].append(b)\n        e[b].append(a)\n\n    col = [ -1 for i in range(N)]\n    col[0] = 0\n    \n    #def dfs(n,c,path):\n    def dfs(n,c):\n        nonlocal p\n        #path =  path  + [n]\n        #path.append(n)\n        #print(path)\n        if n == N - 1:\n            p = path\n        path[c] = n\n        for v in e[n]:\n            if col[v] == -1:\n                col[v] = c + 1\n                dfs(v,c+1)\n                #dfs(v,c+1,path)\n                if p:\n                    return\n    dfs(0,0)\n    #print(p[:N+10])\n    #dfs(0,0,[])\n\n    t = col[N-1] + 1\n    if t % 2 ==0:\n        sn = p[t//2]\n    else:\n        sn = p[t//2+1]\n\n\n    colfn = [ -1 for i in range(N)]\n    colfn[0] = 0\n    def dfs2(n,c):\n\n        for v in e[n]:\n            if v == sn:\n                continue\n            elif colfn[v] == -1:\n                colfn[v] = c + 1\n                dfs2(v,c+1)\n\n    dfs2(0,0)\n\n    fennec = -1\n    for i in range(N):\n        if colfn[i] != -1:\n            fennec += 1\n\n    snuke = N - fennec - 2\n    if fennec > snuke:\n        print(\"Fennec\")\n    else:\n        print(\"Snuke\")\n\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "from collections import deque\n\nN = int(input())\n\nINF = 100001\nG = [[] for i in range(N)]\ndist1, dist2 = [INF for j in range(N)], [INF for k in range(N)]\n\n\ndef bfs(s, d):\n    check, q = [0 for i in range(N)], deque()\n    check[s], d[s] = 1, 0\n    q.append(s)\n\n    while len(q) != 0:\n        u = q.popleft()\n        for i in G[u]:\n            if check[i] == 0:\n                check[i], d[i] = 1, d[u] + 1\n                q.append(i)\n        check[u] = 2\n\n\ndef main():\n    for i in range(N-1):\n        a, b = list(map(int, input().split()))\n        G[a-1].append(b-1)\n        G[b-1].append(a-1)\n\n    bfs(0, dist1)\n    bfs(N-1, dist2)\n\n    cnt_f = 0\n    for i in range(N):\n        if dist1[i] <= dist2[i]:\n            cnt_f += 1\n\n    if N // 2 < cnt_f:\n        print(\"Fennec\")\n    else:\n        print(\"Snuke\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from scipy.sparse import*\nn,*a=map(int,open(0).read().split())\nprint('FSennunkeec'[sum(g>h for g,h in zip(*csgraph.dijkstra(csr_matrix(([1]*~-n,(a[::2],a[1::2])),[n+1]*2),0,[1,n])))*2>=n::2])", "import sys\nstdin = sys.stdin\n\nsys.setrecursionlimit(10 ** 7)\n\ndef li(): return map(int, stdin.readline().split())\ndef li_(): return map(lambda x: int(x) - 1, stdin.readline().split())\ndef lf(): return map(float, stdin.readline().split())\ndef ls(): return stdin.readline().split()\ndef ns(): return stdin.readline().rstrip()\ndef lc(): return list(ns())\ndef ni(): return int(stdin.readline())\ndef nf(): return float(stdin.readline())\n\nfrom collections import deque\n\ndef bfs(graph: list, start: int):\n    n = len(graph)\n    dist = [-1]*n\n\n    que = deque([(start, 0)])\n\n    while que:\n        cur_node, cur_dist = que.popleft()\n        dist[cur_node] = cur_dist\n\n        for nex in graph[cur_node]:\n            if dist[nex] < 0:\n                dist[nex] = cur_dist + 1\n                que.append((nex, cur_dist+1))\n\n    return dist\n\nn = ni()\n\ngraph = [[] for _ in range(n)]\nfor _ in range(n-1):\n    x, y = li_()\n    graph[x].append(y)\n    graph[y].append(x)\n\nfenec = bfs(graph, 0)\nsnuke = bfs(graph, n-1)\n\nfenec_saki = 0\nfor d1, d2 in zip(fenec, snuke):\n    if d1 <= d2:\n        fenec_saki += 1\n    elif d1 > d2:\n        fenec_saki -= 1\n\nif fenec_saki == 0:\n    if n%2:\n        print(\"Fennec\")\n    else:\n        print(\"Snuke\")\n\nelif fenec_saki > 0:\n    print(\"Fennec\")\n\nelse:\n    print(\"Snuke\")", "N = int(input())\nedge = [[]*N for _ in range(N)]\n\nfor _ in range(N-1):\n    go,to = map(int,input().split())\n    go -= 1\n    to -= 1\n    edge[go].append(to)\n    edge[to].append(go)\n    \nfrom collections import deque\nque = deque(maxlen=N)\nque.append([0,0])\ndist0 = [None]*N\ndistn = [None]*N\nwhile(que):\n    v = que.popleft()\n    c = v[0]\n    d = v[1]\n    for i in edge[c]:\n        if dist0[i] is None:\n            dist0[i] = d + 1\n            que.append([i,d+1])\nque.append([N-1,0])\nwhile(que):\n    v = que.popleft()\n    c = v[0]\n    d = v[1]\n    for i in edge[c]:\n        if distn[i] is None:\n            distn[i] = d + 1\n            que.append([i,d+1])\nw = b = 0\nfor d1,dn in zip(dist0,distn):\n    if d1<=dn:\n        b += 1\n    else:\n        w += 1\nprint('Fennec' if b-w > 0 else 'Snuke')", "# -*- coding: utf-8 -*-\nfrom collections import deque\nn = int(input())\nedge = [[] for _ in range(n+1)]\nfor _ in range(n-1):\n    a,b = list(map(int, input().split()))\n    edge[a].append(b)\n    edge[b].append(a)\n\ninf = 10**6\n\n\nfvisited = [inf for _ in range(n+1)]\nfvisited[1] = 0\nq = deque([1])\nwhile len(q)>0:\n    s = q.popleft()\n    for e in edge[s]:\n        if fvisited[e]==inf:\n            fvisited[e] = fvisited[s]+1\n            q.append(e)\n\nsvisited = [inf for _ in range(n+1)]\nsvisited[n] = 0\nq = deque([n])\nwhile len(q)>0:\n    s = q.popleft()\n    for e in edge[s]:\n        if svisited[e]==inf:\n            svisited[e] = svisited[s]+1\n            q.append(e)\n\n# print(fvisited)\n# print(svisited)\nfcnt = 0\nscnt = 0\nfor i in range(1,n+1):\n    if fvisited[i]<=svisited[i]:\n        fcnt += 1\n    else:\n        scnt += 1\n\nif fcnt>scnt:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")\n", "import sys\nsys.setrecursionlimit(10**7)\nn=int(input())\nedge=[[] for _ in range(n)]\nfor i in range(n-1):\n    x,y=map(int,input().split())\n    edge[x-1].append(y-1)\n    edge[y-1].append(x-1)\ndef dfs(node,dist,distl):\n    distl[node]=dist\n    for e in edge[node]:\n        if distl[e]==-1:\n            dfs(e,dist+1,distl)\ndista,distb=[-1]*n,[-1]*n\ndfs(0,0,dista)\ndfs(n-1,0,distb)\na,b=0,0\nfor i in range(n):\n    if dista[i]<=distb[i]:\n        a+=1\n    else:\n        b+=1\nprint('Fennec' if a>b else 'Snuke')", "import sys\ninput = sys.stdin.readline\nN = int(input())\ntree = [[] for i in range(N+1)]\n\nfor i in range(N-1):\n    a, b = list(map(int, input().split()))\n    tree[a].append(b)\n    tree[b].append(a)\n\ndist_fennec = [100001] * (N+1)\ndist_snuke = [100001] * (N+1)\nq = [1]\ndist_fennec[1] = 0\nwhile q:\n    now = q.pop()\n    for next in tree[now]:\n        if dist_fennec[next] == 100001:\n            dist_fennec[next] = dist_fennec[now] + 1\n            q.append(next)\n\nq = [N]\ndist_snuke[N] = 0\nwhile q:\n    now = q.pop()\n    for next in tree[now]:\n        if dist_snuke[next] == 100001:\n            dist_snuke[next] = dist_snuke[now] + 1\n            q.append(next)\n\nfennec, snuke = 0, 0\nfor i in range(1, N+1):\n    if dist_snuke[i] >= dist_fennec[i]:\n        fennec += 1\n    else:\n        snuke += 1\n\nif fennec > snuke:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")\n", "from networkx import*\n(N,),*t=map(str.split,open(0))\nG=Graph(t)\ns=shortest_path_length\nx=s(G,'1')\ny=s(G,N)\nprint('FSennunkeec'[sum(x[k]>y[k]for k in x)*2>=int(N)::2])", "n = int(input())\nedges = [[] for _ in range(n)]\n\nfor _ in range(n-1):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\ndef bfs(v):\n    q = []\n    depth = [n]*n\n    q.append(v)\n    depth[v] = 0\n    i = 0\n    while i < len(q):\n        x = q[i]\n        d = depth[x]\n        for e in edges[x]:\n            if depth[e] == n:\n                depth[e] = d+1\n                q.append(e)\n        i += 1\n    return depth\n\nd1 = bfs(0)\nd2 = bfs(n-1)\n\nc = 0\nfor i in range(n):\n    if d1[i] <= d2[i]:\n        c += 1\nif 2*c > n:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")\n", "N=int(input())\nedge=[list(map(int,input().split())) for i in range(N-1)]\ninf=10**20\nc=[[] for i in range(N)]\nfor i,j in edge:\n    c[i-1].append(j-1)\n    c[j-1].append(i-1)\nd=[0]+[inf]*(N-1)\nv=[0]*N\nimport sys\nsys.setrecursionlimit(10**6)\ndef dfs(p,v,d):\n    for n in c[p]:\n        if v[n]==0:\n            d[n]=min(d[n],d[p]+1)\n            v[n]=1\n            dfs(n,v,d)\ndfs(0,v,d)\nd2=[inf]*(N-1)+[0]\nv=[0]*N\ndfs(N-1,v,d2)\nc=0\nfor i,j in zip(d,d2):\n    c=c+1 if i<=j else c-1\nprint(['Snuke','Fennec'][c>0])", "from collections import deque\nn=int(input())\ngraph=[[] for i in range(n)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    a-=1;b-=1\n    graph[a].append(b)\n    graph[b].append(a)\ndistfrom1=[-1]*n\ndistfromn=[-1]*n\ndistfrom1[0]=0\ndistfromn[n-1]=0\nd=deque([0])\nwhile d:\n    v=d.popleft()\n    for i in graph[v]:\n        if distfrom1[i]!=-1:continue\n        distfrom1[i]=distfrom1[v]+1\n        d.append(i)\nd.append(n-1)\nwhile d:\n    v=d.popleft()\n    for i in graph[v]:\n        if distfromn[i]!=-1:continue\n        distfromn[i]=distfromn[v]+1\n        d.append(i)\nF=0\nfor i in range(n):\n    if distfrom1[i]<=distfromn[i]:F+=1\nif F>n-F:print(\"Fennec\")\nelse:print(\"Snuke\")", "\n#\n#\u30d5\u30a7\u30cd\u30c3\u30af\u3068\u3059\u306c\u3051\u3055\u3093\u304c\u6700\u77ed\u3067\u304a\u4e92\u3044\u306e\u30de\u30b9\u3078\u5411\u304b\u3046\u6642\u306e\u3001\u3076\u3064\u304b\u308b\u70b9\u3092\u6c42\u3081\u3066\n#\u6728\u3092\u5206\u5272\u3059\u308b\u3002\u5206\u5272\u3057\u305f\u4e8c\u3064\u306e\u30de\u30b9\u3092\u6570\u3048\u3066\u6bd4\u8f03\u3057\u3001\u5927\u304d\u3044\u65b9\u304c\u52dd\u5229\n\nimport sys\nsys.setrecursionlimit(1000000)\n\nN = int(input())\ne = [ [] for i in range(N)]\nfor i in range(N-1):\n    a,b = map(int,input().split())\n    a-=1\n    b-=1\n    e[a].append(b)\n    e[b].append(a)\n\n#\u4e8c\u4eba\u304c\u3076\u3064\u304b\u308b\u70b9\u3092\u6c42\u3081\u308b\uff08\u6728\u3092\u5206\u5272\u3059\u308b\u70b9\u3092\u6c42\u3081\u308b\uff09\ncol = [ -1 for i in range(N)]\ncol[0] = 0\np = []\npath = [ 0 for i in range(10**5+1)]\ndef dfs(n,c):\n    nonlocal p\n    if n == N - 1:\n        p = path\n    path[c] = n\n    for v in e[n]:\n        if col[v] == -1:\n            col[v] = c + 1\n            dfs(v,c+1)\n            if p:\n                return\ndfs(0,0)\n\nt = col[N-1] + 1\nif t % 2 ==0:\n    sn = p[t//2]\nelse:\n    sn = p[t//2+1]\n\n\n#\u30d5\u30a7\u30cd\u30c3\u30af\u5074\u306e\u6728\u306e\u30de\u30b9\u6570\u3092\u6570\u3048\u308b\ncolfn = [ -1 for i in range(N)]\ncolfn[0] = 0\ndef dfs2(n,c):\n\n    for v in e[n]:\n        if v == sn:\n            continue\n        elif colfn[v] == -1:\n            colfn[v] = c + 1\n            dfs2(v,c+1)\n\ndfs2(0,0)\n\nfennec = -1\nfor i in range(N):\n    if colfn[i] != -1:\n        fennec += 1\n\n\n#\u3059\u306c\u3051\u3055\u3093\u5074\u306f\u5168\u30de\u30b9\u6570\u304b\u3089\u30d5\u30a7\u30cd\u30c3\u30af\u306e\u30de\u30b9\u3092\u5f15\u3051\u3070\u826f\u3044\nsnuke = N - fennec - 2\n\nif fennec > snuke:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "#\u5206\u5c90\u306f\u5f8c\u3067\u51e6\u7406\u3059\u308c\u3070\u826f\u3044\n#\u305d\u308c\u305e\u308c0,n\u306b\u8fd1\u3065\u304f\u306e\u304c\u6700\u9069\nimport sys\nsys.setrecursionlimit(10**8)\nfrom heapq import heappush,heappop\ninf=10**10\nn=int(input())\nl=[[] for i in range(n+1)]\nfor i in range(n-1):\n  a,b=map(int,input().split())\n  l[a].append(b)\n  l[b].append(a)\nprev=[-1 for i in range(n+1)]\ndef dijkstra(s):\n  q=[(0,s)]\n  dist=[inf]*(n+1)\n  dist[s]=0\n  while q:\n    c,v=heappop(q)\n    if dist[v]<c:\n      continue\n    for i in l[v]:\n      t=i\n      cost=1\n      if dist[v]+cost<dist[t]:\n        dist[t]=dist[v]+cost\n        prev[t]=v\n        heappush(q,[dist[t],t])\n  return dist\nd=dijkstra(1)\np=[n]\nnum=n\nnext=[-1 for i in range(n+1)]\nwhile num!=1:\n  num1=prev[num]\n  next[num1]=num\n  p.append(num1)\n  num=num1\ncountp=[0]\ncountf=[0]\ndef dfs(x,y):\n  for i in l[x]:#i\u306b\u5206\u5c90\u53ef\u80fd\u306a\u3089\u3070\n    if prev[x]!=i and next[x]!=i:\n      if y==1:\n        countp[0]+=1\n      else:\n        countf[0]+=1\n      prev[i]=x\n      dfs(i,y) \np=p[::-1]\nnum=len(p)\nnum1=(num-1)//2+1\nfor i in range(num1):\n  countp[0]+=1\n  dfs(p[i],1)\nfor i in range(num1,num):\n  countf[0]+=1\n  dfs(p[i],0)\nif countp[0]>countf[0]:\n  print(\"Fennec\")\nelse:\n  print(\"Snuke\")", "from collections import deque\n\ndef dfs(graph, start):\n    stack = deque()\n    costs = [0] * (N+1)\n    stack.append([start,0])\n    costs[start] = -1\n    while stack:\n        a, cost = stack.popleft()\n        for b in list(graph[a].keys()):\n            if not costs[b]:\n                stack.append([b,cost+1])\n                costs[b] = cost+1\n    return costs\n\nN = int(input())\ngraph = {}\nfor i in range(N-1):\n    a,b = list(map(int, input().split()))\n    if a not in graph:\n        graph[a] = {}\n    if b not in graph:\n        graph[b] = {}\n    graph[a][b] = graph[b][a] = 1\nf_costs = dfs(graph,1)\ns_costs = dfs(graph,N)\nf_cnt = 1\nfor i in range(2,N):\n    if f_costs[i] <= s_costs[i]:\n        f_cnt += 1\n# print(f_costs, s_costs, f_cnt)\nprint(('Fennec' if f_cnt > N - f_cnt else 'Snuke'))\n", "from collections import*\ninput=open(0).readline\nn=int(input())\ne=[[]for _ in range(n)]\nfor _ in range(n-1):\n    a,b=map(int,input().split())\n    e[a-1].append(b-1)\n    e[b-1].append(a-1)\nf=[0]*n\nv=[1]+[0]*~-n\nq=deque([(0,0)])\nwhile q:\n    t,c=q.pop()\n    v[t]=1\n    f[t]=c\n    for i in e[t]:\n        if not v[i]:\n            q.append((i,c+1))\ns=[0]*n\nv=[0]*~-n+[1]\nq=deque([(n-1,0)])\nwhile q:\n    t,c=q.pop()\n    v[t]=1\n    s[t]=c\n    for i in e[t]:\n        if not v[i]:\n            q.append((i,c+1))\na=b=0\nfor i,j in zip(f,s):\n    if i<=j:\n        a+=1\n    else:\n        b+=1\nif a>b:\n    print('Fennec')\nelse:\n    print('Snuke')", "def bfs(graph,start,n,check):\n    if check == False:\n        arrival = [0 for i in range(n+1)]\n    else:\n        arrival = [0 for i in range(n+1)]\n        arrival[check] = -1\n    q = [start]\n    arrival[start] = 1\n    while len(q) != 0:\n        for i in range(len(graph[q[0]])):\n            if arrival[graph[q[0]][i]] == 0:\n                q.append(graph[q[0]][i])\n                arrival[graph[q[0]][i]] = arrival[q[0]]+1\n        q.pop(0)\n    return arrival\n\nn = int(input())\ngraph = dict()\nfor i in range(1,n+1):\n    graph[i] = []\n\nfor i in range(n-1):\n    a,b = map(int,input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\n\nfstart = bfs(graph,1,n,False)\nsstart = bfs(graph,n,n,False)\nfennec = 0\nsnuke = 0\nfor i in range(1,n+1):\n    if abs(fstart[i]-fstart[1]) <= abs(sstart[i]-sstart[n]):\n        fennec += 1\n    else:\n        snuke += 1\n\n\nif fennec > snuke:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "from networkx import*\n(N,),*t=[s.split()for s in open(0)]\nG=Graph()\nfor a,b in t:G.add_edge(a,b)\ns=shortest_path_length\nx=s(G,'1')\ny=s(G,N)\nc=0\nfor k in y:c+=x[k]>y[k]\nprint('FSennunkeec'[c*2>=int(N)::2])", "import sys\nsys.setrecursionlimit(1000000)\n\nN=int(input())\n\nB=[[]for i in range(N+1)]\n\nF=[10**10 for i in range(N+1)]\nF[1]=0\nS=[10**10 for i in range(N+1)]\nS[N]=0\n\nfor i in range(N-1):\n    a,b=list(map(int,input().split()))\n    B[a].append(b)\n    B[b].append(a)\n    \n#print(B)\ndef dfsF(f):\n    for i in B[f]:\n        if F[i]==10**10:\n            F[i]=F[f]+1\n            dfsF(i)\ndfsF(1)\n\ndef dfsS(s):\n    for i in B[s]:\n        if S[i]==10**10:\n            S[i]=S[s]+1\n            dfsS(i)\ndfsS(N)\n#print(F)\n#print(S)\nFennec=0\nSnuke=0\nfor i in range(1,N+1):\n    if F[i]<=S[i]:\n        Fennec+=1\n    else:\n        Snuke+=1\nif Fennec>Snuke:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")\n", "N=int(input())\n\nimport sys\nsys.setrecursionlimit(10**5)\nab=[list(map(int, input().split())) for _ in range (N-1)]\ncon=[[] for _ in range(N+1)]\n\n#print(ab)\nfor a,b in ab :\n  con[a].append(b)\n  con[b].append(a)\n\n#black Fennec\npc=[0]*(N+1)\nq=[(1,0)]\nvis=[False]*(N+1)\nvis[1]=True\nFcnt=N\nwhile q:\n  n,c=q.pop()\n  pc[n]=c\n  for ch in con[n]:\n    if vis[ch]==True:\n      continue\n    vis[ch]=True\n    q.append((ch,c+1))\n    \nq=[(N,0)]\nvis=[False]*(N+1)\nvis[N]=True\nwhile q:\n  n,c=q.pop()\n  if pc[n]>c:\n    Fcnt-=1\n  for ch in con[n]:\n    if vis[ch]==True:\n      continue\n    vis[ch]=True\n    q.append((ch,c+1))\n    \nif Fcnt>N-Fcnt:\n  print(\"Fennec\")\nelse:\n  print(\"Snuke\")\n", "#\u5206\u5c90\u306f\u5f8c\u3067\u51e6\u7406\u3059\u308c\u3070\u826f\u3044\n#\u305d\u308c\u305e\u308c0,n\u306b\u8fd1\u3065\u304f\u306e\u304c\u6700\u9069\nfrom heapq import heappush,heappop\ninf=10**10\nn=int(input())\nl=[[] for i in range(n+1)]\nfor i in range(n-1):\n  a,b=map(int,input().split())\n  l[a].append(b)\n  l[b].append(a)\ndef dijkstra(s):\n  q=[(0,s)]\n  dist=[inf]*(n+1)\n  dist[s]=0\n  while q:\n    c,v=heappop(q)\n    if dist[v]<c:\n      continue\n    for i in l[v]:\n      t=i\n      cost=1\n      if dist[v]+cost<dist[t]:\n        dist[t]=dist[v]+cost\n        heappush(q,[dist[t],t])\n  return dist\nd1=dijkstra(1)\nd2=dijkstra(n)\ncountp=0\ncounts=0\nfor i in range(1,n+1):\n  if d1[i]>d2[i]:\n    counts+=1\n  else:\n    countp+=1\nif countp>counts:\n  print(\"Fennec\")\nelse:\n  print(\"Snuke\")", "import sys\nsys.setrecursionlimit(1000000)\n\nN=int(input())\n\nB=[[]for i in range(N+1)]\n\nF=[10**10 for i in range(N+1)]\nF[1]=0\nS=[10**10 for i in range(N+1)]\nS[N]=0\n\nfor i in range(N-1):\n    a,b=list(map(int,input().split()))\n    B[a].append(b)\n    B[b].append(a)\n    \n#print(B)\ndef dfsF(f):\n    for i in B[f]:\n        if F[i]==10**10:\n            F[i]=F[f]+1\n            dfsF(i)\ndfsF(1)\n\ndef dfsS(s):\n    for i in B[s]:\n        if S[i]==10**10:\n            S[i]=S[s]+1\n            dfsS(i)\ndfsS(N)\n#print(F)\n#print(S)\nFennec=0\nSnuke=0\nfor i in range(1,N+1):\n    if F[i]<=S[i]:\n        Fennec+=1\n    else:\n        Snuke+=1\nif Fennec>Snuke:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")\n", "from collections import *\nn=int(input())\nab=[[]for i in range(n)]\nfor i in range(n-1):\n    x,y=map(int,input().split())\n    ab[x-1].append(y-1)\n    ab[y-1].append(x-1)\ns=[float(\"inf\")]*n\nf=[float(\"inf\")]*n\nq=deque()\nq.append((0,0))\nwhile q:\n    a,b=q.popleft()\n    if f[a]==float(\"inf\"):\n        f[a]=b\n        for j in ab[a]:\n            if f[j]==float(\"inf\"):\n                q.append((j,b+1))\n                \nd=deque()\nd.append((n-1,0))\nwhile d:\n    a,b=d.popleft()\n    if s[a]==float(\"inf\"):\n        s[a]=b\n        for j in ab[a]:\n            if s[j]==float(\"inf\"):\n                d.append((j,b+1))\nsa,fa=0,0\n\nfor i in range(n):\n    if s[i]>=f[i]:\n        fa+=1\n    else:\n        sa+=1\nif fa>sa:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "from sys import setrecursionlimit\nsetrecursionlimit(10000000)\n\ndef solve():\n    N = int(input())\n    adj = [list() for _ in range(N)]\n    for _ in range(N-1):\n        a,b = map(int,input().split())\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n\n    # path\n    goal = N-1\n    path = [0]\n    candidates = [adj[0][:]]\n    while path[-1] != goal:\n        while not candidates[-1]:\n            candidates.pop()\n            path.pop()\n        u = candidates[-1].pop()\n        candidates.append([n for n in adj[u] if n != path[-1]])\n        path.append(u)\n\n    black = path[(len(path)-1)//2]\n    white = path[(len(path)-1)//2+1]\n\n    # count\n    path = [black]\n    candidates = [[n for n in adj[black] if n != white]]\n    cnt = 0\n    try:\n        while True:\n            while not candidates[-1]:\n                cnt += 1\n                candidates.pop()\n                path.pop()\n            u = candidates[-1].pop()\n            candidates.append([n for n in adj[u] if n != path[-1]])\n            path.append(u)\n    except IndexError:\n        pass\n    bscore = cnt\n    print('Fennec' if bscore*2 > N else 'Snuke')\n\n\ndef __starting_point():\n    solve()\n__starting_point()", "from networkx import*\nN,*t=map(str.split,open(0))\ns=shortest_path_length\nx=s(G:=Graph(t),'1')\ny=s(G,*N)\nprint('FSennunkeec'[sum(x[k]>y[k]for k in x)*2>=len(x)::2])", "ai = lambda: list(map(int,input().split()))\nai_ = lambda: [int(x)-1 for x in input().split()]\n\nn = int(input())\n\npath = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b = ai_()\n    path[a].append(b)\n    path[b].append(a)\n\nfrom collections import deque\nq = deque()\nq.append(0)\n\nd1 = [float('inf') for _ in range(n)]\nd1[0] = 0\nw = set()\nwhile q:\n    v = q.popleft()\n    w.add(v)\n    for vv in path[v]:\n        if vv not in w:\n            d1[vv] = d1[v] + 1\n            q.append(vv)\n\n\nq = deque()\nq.append(n-1)\n\ndn = [float('inf') for _ in range(n)]\ndn[n-1] = 0\nw = set()\nwhile q:\n    v = q.popleft()\n    w.add(v)\n    for vv in path[v]:\n        if vv not in w:\n            dn[vv] = dn[v] + 1\n            q.append(vv)\n\n\nd = [1 if d1[v] <= dn[v] else -1 for v in range(n)]\n\nif sum(d) > 0:\n    print('Fennec')\nelse:\n    print('Snuke')\n", "def dfs(x):\n    d = [-1] * (N + 1)\n    stack = [x]\n    while stack:\n        x = stack.pop()\n        for i in G[x]:\n            if d[i] == -1:\n                d[i] = d[x] + 1\n                stack.append(i)\n    return d\n\nN = int(input())\nG = [set() for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    G[a].add(b)\n    G[b].add(a)\n\nd1, dn = dfs(1), dfs(N)\nnum = 0\nfor i in range(1, N + 1):\n    if d1[i] <= dn[i]:\n        num += 1\nif num > N // 2:\n    print('Fennec')\nelse:\n    print('Snuke')", "#Snuke vs Fennec\nN = int(input())\ntree = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a,b = list(map(int, input().split()))\n    a-=1\n    b-=1\n    tree[a].append(b)\n    tree[b].append(a)\n \n \ndef dist(n, lis):\n    lis[n] = 0\n    node = [n]\n    while node:\n        s = node.pop()\n        d = lis[s]\n        for t in tree[s]:\n            if lis[t] != -1:\n                continue\n            lis[t] = d + 1\n            node.append(t)\n    return lis\n \n \nfrom_feneck = dist(0, [-1]*N)\nfrom_Snuke = dist(N-1, [-1]*N)\n \nfeneck = 0\nfor i,j in zip(from_feneck, from_Snuke):\n    if i<=j:\n        feneck += 1\n    else:\n        feneck -= 1\n    \nif feneck <= 0:\n    print(\"Snuke\")\nelse:\n    print(\"Fennec\")\n", "from collections import deque\nN = int(input())\nedge = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    edge[a - 1].append(b - 1)\n    edge[b - 1].append(a - 1)\nd = [[-1] * N for _ in range(2)]\nfor i in range(2):\n    d[i][i * (N - 1)] = 0\n    q = deque([i * (N - 1)])\n    while len(q) > 0:\n        u = q.popleft()\n        for v in edge[u]:\n            if d[i][v] > -1:\n                continue\n            d[i][v] = d[i][u] + 1\n            q.append(v)\nS = 0\nF = 0\nfor i in range(N):\n    if d[0][i] > d[1][i]:\n        S += 1\n    else:\n        F += 1\nif F > S:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "from collections import*\ninput=open(0).readline\nn=int(input())\ne=[[]for _ in range(n)]\nfor _ in range(n-1):\n    a,b=map(int,input().split())\n    e[a-1].append(b-1)\n    e[b-1].append(a-1)\nf=[0]*n\nv=[1]+[0]*~-n\nq=deque([(0,0)])\nwhile q:\n    t,c=q.pop()\n    v[t]=1\n    f[t]=c\n    for i in e[t]:\n        if not v[i]:\n            q.append((i,c+1))\ns=[0]*n\nv=[0]*~-n+[1]\nq=deque([(n-1,0)])\nwhile q:\n    t,c=q.pop()\n    v[t]=1\n    s[t]=c\n    for i in e[t]:\n        if not v[i]:\n            q.append((i,c+1))\na=b=0\nfor i,j in zip(f,s):\n    if i<=j:\n        a+=1\n    else:\n        b+=1\nif a>b:\n    print('Fennec')\nelse:\n    print('Snuke')", "import heapq\n# v:\u9802\u70b9\u6570, s:\u59cb\u70b9, path[i]:[[cost,to]...] i=from\u306e\u96a3\u63a5\u30ea\u30b9\u30c8\ndef dijkstra(v,s,path):\n    inf = float('inf')\n\n    # \u8ddd\u96e2\u3092inf\u3067\u521d\u671f\u5316\n    d = [inf for i in range(v)]\n    d[s] = 0\n\n    # s\u3078\u306e\u8ddd\u96e2\u306f0\n    q = [[0,s]]\n    heapq.heapify(q)\n\n    # \u8ddd\u96e2\u304c\u6700\u5c0f\u306e\u9802\u70b9\u304b\u3089\u66f4\u65b0\u3057\u3066\u3044\u3051\u3070\n    # p[1]\u304b\u3089\u884c\u3051\u308b\n    while q:\n        p = heapq.heappop(q)\n\n        # \u9802\u70b9p[1]\u307e\u3067\u306e\u8ddd\u96e2\u304cheap\u306a\u3044\u306ep[1]\u307e\u3067\u306e\u8ddd\u96e2\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\u3001continue\n        if d[p[1]]<p[0]:\n            continue\n\n        # \u9802\u70b9p[1]\u304b\u3089\u4f38\u3073\u308b\u3001\u5168\u3066\u306e\u8fba\u306e\u8ddd\u96e2\u3092\u78ba\u8a8d\n        for i in range(len(path[p[1]])):\n            # \u9802\u70b9p[1]\u304b\u3089\u884c\u3051\u308b\u9802\u70b9\u306e\u8ddd\u96e2\u304cp[1]\u307e\u3067\u306e\u8ddd\u96e2\u3068p[1]\u304b\u3089\u306e\u8ddd\u96e2\u306e\u548c\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408 -> \u8ddd\u96e2\u3092\u66f4\u65b0\u3057\u3001heap\u306b\u8ffd\u52a0\n            if d[path[p[1]][i][1]] > d[p[1]] + path[p[1]][i][0]:\n                d[path[p[1]][i][1]] = d[p[1]]+path[p[1]][i][0]\n                heapq.heappush(q,[d[path[p[1]][i][1]], path[p[1]][i][1]])\n    return d\n\ndef path_recovery(e,d,path):\n    # \u7d4c\u8def\n    route = [e]\n    # \u6b8b\u308a\u306e\u8ddd\u96e2\n    a = d[e]\n    while a!=0:\n        for i in range(len(path[e])):\n            if d[path[e][i][1]]+path[e][i][0]==a:\n                route.append(path[e][i][1])\n                a -= path[e][i][0]\n                e = path[e][i][1]\n                break\n    route.reverse()\n    return route\n\nclass UnionFind:\n    # \u521d\u671f\u5316\n    def __init__(self, n):\n        # \u6839\u306a\u3089-size, \u5b50\u306a\u3089\u89aa\u306e\u9802\u70b9\n        self.par = [-1] * n\n        # \u6728\u306e\u9ad8\u3055\n        self.rank = [0] * n\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # \u4f75\u5408\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        # \u7570\u306a\u308b\u96c6\u5408\u306b\u5c5e\u3059\u308b\u5834\u5408\u306e\u307f\u4f75\u5408\n        if x != y:\n            # \u9ad8\u3044\u65b9\u3092x\u3068\u3059\u308b\u3002\n            if self.rank[x] < self.rank[y]:\n                x,y = y,x\n            # \u540c\u3058\u9ad8\u3055\u306e\u6642\u306f\u9ad8\u3055+1\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            # y\u306e\u89aa\u3092x\u3068\u3057\u3001x\u306e\u30b5\u30a4\u30ba\u306by\u306e\u30b5\u30a4\u30ba\u3092\u52a0\u3048\u308b\n            self.par[x] += self.par[y]\n            self.par[y] = x\n\n    # \u540c\u96c6\u5408\u5224\u5b9a\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # \u96c6\u5408\u306e\u5927\u304d\u3055\n    def size(self, x):\n        return -self.par[self.find(x)]\n\nn = int(input())\n\nl = [[] for i in range(n)]\nfor i in range(n-1):\n    a,b = map(int, input().split())\n    # dijkstra\u306elibrary\u306b\u5408\u308f\u305b\u308b\u305f\u3081\u3001\u8ddd\u96e21\u3092\u8ffd\u52a0\n    l[a-1].append([1,b-1])\n    l[b-1].append([1,a-1])\n\nd = dijkstra(n,0,l)\n\np = path_recovery(n-1,d,l)\n\nx = p[(len(p)-1)//2]\ny = p[(len(p)-1)//2+1]\n\nfor i in range(len(l[x])):\n    if l[x][i][1]==y:\n        l[x].pop(i)\n        break\nfor i in range(len(l[y])):\n    if l[y][i][1]==x:\n        l[y].pop(i)\n        break\n\nu = UnionFind(n)\n\nfor i in range(len(l)):\n    for j in range(len(l[i])):\n        u.unite(i,l[i][j][1])\n\n\nif u.size(0)>u.size(n-1):\n    print('Fennec')\nelse:\n    print('Snuke')", "from heapq import heappush, heappop\n\n# \u5165\u529b\nN = int(input())\na, b = (\n    list(zip(*(list(map(int, input().split())) for _ in range(N - 1)))) if N - 1 else\n    ((), ())\n)\n\n# \u9802\u70b91, N \u304b\u3089\u5404\u8776\u70b9\u3078\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b\nG = [{} for _ in range(N + 1)]\nfor x, y in zip(a, b):\n    G[x][y] = 1\n    G[y][x] = 1\nINF = 10**10\n\n\ndef dijkstra(G, s):\n    dp = [INF for _ in range(len(G))]\n    q = []\n    heappush(q, (0, s))\n    while q:\n        c, i = heappop(q)\n        if dp[i] == INF:\n            dp[i] = c\n            for j, w in list(G[i].items()):\n                heappush(q, (c + w, j))\n    return dp\n\n\ndp1 = dijkstra(G, 1)\ndpN = dijkstra(G, N)\n# \u9802\u70b9N\u3088\u308a\u9802\u70b91\u306e\u307b\u3046\u304c\u8fd1\u3044\u3001\u307e\u305f\u306f\u3001\u9802\u70b91\u3068\u9802\u70b9N\u3068\u306e\u8ddd\u96e2\u304c\u7b49\u3057\u3044\u306f\n# \u9802\u70b91\u304b\u3089\u9802\u70b9N\u306e\u9593\u306e\u30d1\u30b9\u306b\u542b\u307e\u308c\u308b\u9802\u70b9\u306e\u3046\u3061\u3001Fennec\u304c\u5857\u308c\u308b\u9802\u70b9\u3067\u3042\u308b\u3002\nans = (\n    'Fennec' if sum(dp1[i] <= dpN[i] for i in range(1, N + 1)) > N // 2 else\n    'Snuke'\n)\n\n# \u51fa\u529b\nprint(ans)\n", "N, = list(map(int, input().split()))\nG = [set() for _ in range(N+1)]\nfor i in range(N-1):\n    A, B = list(map(int, input().split()))\n    G[A].add(B)\n    G[B].add(A)\n\npath = []\nstack = [1]\nvs = set()\nwhile stack:\n    v = stack.pop()\n    if v > 0:\n        vs.add(v)\n        path.append(v)\n        for u in G[v]:\n            if u in vs:\n                continue\n            if u == N:\n                stack = []\n                path.append(u)\n                break\n            stack += [-v, u]\n    else:\n        path.pop()\n\nx = path[-(-len(path)//2)]\n\nstack = [1]\nvs = set()\nwhile stack:\n    v = stack.pop()\n    vs.add(v)\n    for u in G[v]:\n        if u in vs:\n            continue\n        if u == x:\n            continue\n        stack.append(u)\nx = len(vs)-1\ny = N - 2 - x\nif x>y:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")\n", "import sys\nsys.setrecursionlimit(10**8)\nN=int(input())\nG=[[] for i in range(N)]\nF=[0 for i in range(N)]\nA=[]\nfor i in range(N-1):\n  a,b=map(int,input().split())\n  a-=1;b-=1\n  G[a].append(b)\n  G[b].append(a)\n  A.append([a,b])\n  \ndef dfs(s,R):\n  F[s]=1\n  \n  if s==N-1:\n    return [s]\n  else:\n    for n in G[s]:\n      if F[n]==0:\n        k=dfs(n,R)\n        if len(k)!=0:\n          k.append(s)\n          return k\n     \n  return []\n  \nroot=dfs(0,[])\n#print(root[::-1])\np=root[::-1][len(root)//2+len(root)%2-1]\nq=root[::-1][len(root)//2+len(root)%2]\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nuf = UnionFind(N) \nfor i in range(N-1):\n  a,b=map(int,A[i])\n  if a==p and b==q:\n    continue\n  if a==q and b==p:\n    continue\n  uf.union(a, b)\n\nscoreA=uf.size(0)\nscoreB=N-scoreA\n#print(scoreA,scoreB)\n\nif scoreA>scoreB:\n  print(\"Fennec\")\nelse:\n  print(\"Snuke\")", "from collections import deque\n\ndef dfs(graph, start, goal):\n    s_stack = deque()\n    g_stack = deque()\n    visited = [0 for i in range(N+1)]\n    s_stack.append([start,0])\n    g_stack.append([goal, 0])\n    visited[start] = 1 \n    visited[goal] = 1 \n    s_cnt = 1\n    g_cnt = 1\n    round = 0\n    while s_stack or g_stack:\n        while s_stack:\n            a,cost = s_stack.popleft()\n            if cost > round:\n                s_stack.appendleft([a,cost])\n                break\n            for b in graph[a].keys():\n                if not visited[b]:\n                    s_stack.append([b,cost+1])\n                    visited[b] += 1 \n                    s_cnt += 1\n        while g_stack:\n            a, cost = g_stack.popleft()\n            if cost > round:\n                g_stack.appendleft([a,cost])\n                break\n            for b in graph[a].keys():\n                if not visited[b]:\n                    g_stack.append([b,cost+1])\n                    visited[b] += 1 \n                    g_cnt += 1\n        round += 1\n    # print(s_cnt, g_cnt)\n    return s_cnt > g_cnt\n\nN = int(input())\ngraph = {}\nfor i in range(N-1):\n    a,b = map(int, input().split())\n    if a not in graph:\n        graph[a] = {}\n    if b not in graph:\n        graph[b] = {}\n    graph[a][b] = graph[b][a] = 1\nprint('Fennec' if dfs(graph,1,N) else 'Snuke')", "from networkx import*\n(N,),*t=map(str.split,open(0))\ns=shortest_path_length\nx=s(G:=Graph(t),'1')\ny=s(G,N)\nprint('FSennunkeec'[sum(x[k]>y[k]for k in x)*2>=int(N)::2])", "from networkx import*\n(N,),*t=map(str.split,open(0))\nx,y=[shortest_path_length(Graph(t),v)for v in('1',N)]\nprint('FSennunkeec'[sum(x[k]>y[k]for k in x)*2>=int(N)::2])", "from collections import deque\n\ndef bfs(start):\n    queue = deque([start])\n    visited = []\n\n    while queue:\n        label = queue.pop()\n\n        visited.append(label)\n\n        for v in d[label]:\n            if tekazu[v] == float(\"inf\"):\n                tekazu[v] = tekazu[label] + 1\n                queue.appendleft(v)\n\n    return\n\nn = int(input())\nd = [[] for _ in range(n)]\n\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    d[a - 1].append(b - 1)\n    d[b - 1].append(a - 1)\n\ntekazu = [float(\"inf\") for _ in range(n)]\ntekazu[0] = 0\nbfs(0)\ntekazu_Fennec = tekazu\n\ntekazu = [float(\"inf\") for _ in range(n)]\ntekazu[-1] = 0\nbfs(n - 1)\ntekazu_Snuke = tekazu\n\nFennec = 0\nSnuke = 0\n\nfor i in range(n):\n    if tekazu_Fennec[i] <= tekazu_Snuke[i]:\n        Fennec += 1\n    else:\n        Snuke += 1\n\nif Fennec > Snuke:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")", "\nimport math\nimport sys\nsys.setrecursionlimit(1000000)\nN = int(input())\ngraph = {}\nSCORE = 0\ndef dfs(visted,v,depth):\n    visted[v] = depth\n    for next_v in graph[v]:\n        if  visted[next_v]  == -1 :\n            dfs(visted,next_v,depth + 1)\n\n\n\n\nfor _ in range(N-1):\n    a,b = list(map(int,input().split(\" \")))\n    if a not in graph:\n        graph[a] = [b]\n    else:\n        graph[a].append(b)\n\n    if b not in graph:\n        graph[b] = [a]\n    else:\n        graph[b].append(a)\n\nvF = [-1] * (N + 1)\nvF[1] = 0\ndfs(vF,1,0)\n# print(vF)\n\nvS = [-1] * (N + 1)\nvS[N] = 0\n\ndfs(vS,N,0)\n# print(vS)\n\nfc = 0\nsc = 0\n\nfor f,s in zip(vF[1:N + 1],vS[1:N + 1]):\n    if f <= s:\n        fc += 1\n    else:\n        sc += 1\n\n# print(fc,sc)\nif fc > sc:\n    print(\"Fennec\")\nelse:\n    print(\"Snuke\")\n"]
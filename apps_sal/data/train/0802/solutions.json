["import math\ndef csb(n): \n count = 0\n while (n): \n  n &= (n-1) \n  count+= 1\n  \n return count\ndef f(ca,cb,i,cf,C,n,dp):\n if ca<0 or cb<0:\n  return 0\n if i==n:\n  if ca==0 and cb==0 and cf==0:\n   return 1\n  return 0\n st=str(ca)+\" \"+str(cb)+\" \"+str(cf)+\" \"+str(i)\n if dp.get(st)!=None:\n  return dp[st]\n x=0 \n if (C&(1<<i))>0:\n  x=1\n if x==1:\n  #we will have odd num of set bits\n  if cf==1:\n   dp[st]=f(ca,cb,i+1,0,C,n,dp)+f(ca-1,cb-1,i+1,1,C,n,dp)\n  else:\n   dp[st]=f(ca-1,cb,i+1,0,C,n,dp)+f(ca,cb-1,i+1,0,C,n,dp)\n else:\n  if cf==1:\n   dp[st]=f(ca-1,cb,i+1,1,C,n,dp)+f(ca,cb-1,i+1,1,C,n,dp)\n  else:\n   dp[st]=f(ca,cb,i+1,0,C,n,dp)+f(ca-1,cb-1,i+1,1,C,n,dp)\n   \n return dp[st]\ndef ip():\n  \n for _ in range(int(input())):\n  a,b,c=list(map(int,input().split()))\n  n=int(math.log(c,2))+1\n  dp={}\n  print(f(csb(a),csb(b),0,0,c,n,dp))\nip()\n", "import math\ndef csb(n): \n count = 0\n while (n): \n  n &= (n-1) \n  count+= 1\n  \n return count\ndef f(ca,cb,i,cf,C,n,dp):\n if ca<0 or cb<0:\n  return 0\n if i==n:\n  if ca==0 and cb==0 and cf==0:\n   return 1\n  return 0\n st=str(ca)+\" \"+str(cb)+\" \"+str(cf)+\" \"+str(i)\n if dp.get(st)!=None:\n  return dp[st]\n x=0 \n if (C&(1<<i))>0:\n  x=1\n if x==1:\n  #we will have odd num of set bits\n  if cf==1:\n   dp[st]=f(ca,cb,i+1,0,C,n,dp)+f(ca-1,cb-1,i+1,1,C,n,dp)\n  else:\n   dp[st]=f(ca-1,cb,i+1,0,C,n,dp)+f(ca,cb-1,i+1,0,C,n,dp)\n else:\n  if cf==1:\n   dp[st]=f(ca-1,cb,i+1,1,C,n,dp)+f(ca,cb-1,i+1,1,C,n,dp)\n  else:\n   dp[st]=f(ca,cb,i+1,0,C,n,dp)+f(ca-1,cb-1,i+1,1,C,n,dp)\n   \n return dp[st]\nfor _ in range(int(input())):\n a,b,c=list(map(int,input().split()))\n n=int(math.log(c,2))+1\n dp={}\n print(f(csb(a),csb(b),0,0,c,n,dp))\n\n", "import numpy as np\nN = 32;\n\ndef calc(i, na, nb, isOne):\n if na < 0 or nb < 0: return 0\n if i == len(c): return not na and not nb and not isOne\n ret = dp[i, na, nb, int(isOne)]\n\n if ret != -1: return ret\n ret = 0\n\n if isOne:\n  if c[i] == '0':\n   ret += calc(i+1, na-1, nb, True)\n   ret += calc(i+1, na, nb-1, True)\n  else:\n   ret += calc(i+1, na, nb, False)\n   ret += calc(i+1, na-1, nb-1, True)\n else:\n  if c[i] == '0':\n   ret += calc(i+1, na, nb, False);\n   ret += calc(i+1, na-1, nb-1, True)\n  else:\n   ret += calc(i+1, na-1, nb, False)\n   ret += calc(i+1, na, nb-1, False)\n\n dp[i, na, nb, int(isOne)] = ret\n return ret\n\n\nt = int(input())\ndp = np.array([-1] * N * N * N * 2).reshape(N, N, N, 2)\nfor _ in range(t):\n a, b, c = list(map(int, input().split()))\n c = \"{0:b}\".format(c)[::-1]\n x = \"{0:b}\".format(a).count('1')\n y = \"{0:b}\".format(b).count('1')\n dp.fill(-1)\n print(calc(0, x, y, False))\n", "import numpy as np\nN = 32;\n\ndef calc(i, na, nb, isOne):\n if na < 0 or nb < 0: return 0\n if i == len(c): return not na and not nb and not isOne\n ret = dp[i][na][nb][int(isOne)]\n\n if ret != -1: return ret\n ret = 0\n\n if isOne:\n  if c[i] == '0':\n   ret += calc(i+1, na-1, nb, True)\n   ret += calc(i+1, na, nb-1, True)\n  else:\n   ret += calc(i+1, na, nb, False)\n   ret += calc(i+1, na-1, nb-1, True)\n else:\n  if c[i] == '0':\n   ret += calc(i+1, na, nb, False);\n   ret += calc(i+1, na-1, nb-1, True)\n  else:\n   ret += calc(i+1, na-1, nb, False)\n   ret += calc(i+1, na, nb-1, False)\n\n dp[i][na][nb][int(isOne)] = ret\n return ret\n\n\nt = int(input())\ndp = np.array([-1] * N * N * N * 2).reshape(N, N, N, 2)\nfor _ in range(t):\n a, b, c = map(int, input().split())\n c = \"{0:b}\".format(c)[::-1]\n x = \"{0:b}\".format(a).count('1')\n y = \"{0:b}\".format(b).count('1')\n dp.fill(-1)\n print(calc(0, x, y, False))", "import numpy as np\nN = 32;\n\ndef calc(i, na, nb, isOne):\n if na < 0 or nb < 0: return 0\n if i == len(c): return not na and not nb and not isOne\n ret = dp[i][na][nb][int(isOne)]\n\n if ret != -1: return ret\n ret = 0\n\n if isOne:\n  if c[i] == '0':\n   ret += calc(i+1, na-1, nb, True)\n   ret += calc(i+1, na, nb-1, True)\n  else:\n   ret += calc(i+1, na, nb, False)\n   ret += calc(i+1, na-1, nb-1, True)\n else:\n  if c[i] == '0':\n   ret += calc(i+1, na, nb, False);\n   ret += calc(i+1, na-1, nb-1, True)\n  else:\n   ret += calc(i+1, na-1, nb, False)\n   ret += calc(i+1, na, nb-1, False)\n\n dp[i][na][nb][int(isOne)] = ret\n return ret\n\n\nt = int(input())\nfor _ in range(t):\n a, b, c = list(map(int, input().split()))\n c = \"{0:b}\".format(c)[::-1]\n x = \"{0:b}\".format(a).count('1')\n y = \"{0:b}\".format(b).count('1')\n dp = np.array([-1] * N * N * N * 2).reshape(N, N, N, 2)\n print(calc(0, x, y, False))\n", "def ham(x):\n w = 0\n while x:\n  w += 1\n  x &= x-1\n return w\n\n\ndef num_shuff(w_a, w_b, c):\n #known = {}\n if w_a < 0 or w_b < 0:\n  return 0\n if c == 0:\n  if w_a == 0 and w_b == 0:\n   return 1\n  else: \n   return 0\n if (w_a, w_b, c) in known:\n  return known[(w_a, w_b, c)]\n c0 = c % 2\n c1 = c >> 1\n res = 0 \n if c0 == 0:\n  res += num_shuff(w_a, w_b , c1 ) \n  res += num_shuff(w_a - 1, w_b - 1, c1 - 1 ) \n else:\n  res += num_shuff(w_a - 1, w_b, c1 )\n  res += num_shuff(w_a, w_b - 1, c1 ) \n known[(w_a, w_b, c)] = res\n return res\n\n\nt = int(input())\nknown = {}\nfor _ in range(t):\n a, b, c = list(map(int, input().split()))\n print(num_shuff(ham(a), ham(b), c))\n", "def ham(x):\n w = 0\n while x:\n  w += 1\n  x &= x-1\n return w\n\n\ndef num_shuff(w_a, w_b, c):\n #known = {}\n if w_a < 0 or w_b < 0:\n  return 0\n if c == 0:\n  if w_a == 0 and w_b == 0:\n   return 1\n  else: \n   return 0\n if (w_a, w_b, c) in known:\n  return known[(w_a, w_b, c)]\n c0 = c % 2\n c1 = c >> 1\n res = 0 \n if c0 == 0:\n  res += num_shuff(w_a, w_b , c1 ) \n  res += num_shuff(w_a - 1, w_b - 1, c1 - 1 ) \n else:\n  res += num_shuff(w_a - 1, w_b, c1 )\n  res += num_shuff(w_a, w_b - 1, c1 ) \n known[(w_a, w_b, c)] = res\n return res\n\n\nt = int(input())\nknown = {}\nfor _ in range(t):\n a, b, c = list(map(int, input().split()))\n print(num_shuff(ham(a), ham(b), c))\n", "from sys import stdin\n\ndef ham(x):\n w = 0\n while x:\n  w += 1\n  x &= x-1\n return w\n\n\ndef num_shuff(w_a, w_b, c):\n #known = {}\n if w_a < 0 or w_b < 0:\n  return 0\n if c == 0:\n  if w_a == 0 and w_b == 0:\n   return 1\n  else: \n   return 0\n if (w_a, w_b, c) in known:\n  return known[(w_a, w_b, c)]\n c0 = c % 2\n c1 = c >> 1\n res = 0 \n if c0 == 0:\n  res += num_shuff(w_a, w_b , c1 ) \n  res += num_shuff(w_a - 1, w_b - 1, c1 - 1 ) \n else:\n  res += num_shuff(w_a - 1, w_b, c1 )\n  res += num_shuff(w_a, w_b - 1, c1 ) \n known[(w_a, w_b, c)] = res\n return res\n\n\nt = int(stdin.readline().strip())\nknown = {}\n#abcs = []\nfor _ in range(t):\n a, b, c = list(map(int, stdin.readline().strip().split()))\n print(num_shuff(ham(a), ham(b), c))\n", "from sys import stdin\nfrom math import log2, floor\n\ndef ham(x):\n w = 0\n while x:\n  w += 1\n  x &= x-1\n return w\n\n\ndef num_shuff(w_a, w_b, c):\n #known = {}\n if w_a < 0 or w_b < 0:\n  return 0\n if c == 0:\n  if w_a == 0 and w_b == 0:\n   return 1\n  else: \n   return 0\n if (w_a, w_b, c) in known:\n  return known[(w_a, w_b, c)]\n c0 = c % 2\n c1 = c >> 1\n res = 0 \n if c0 == 0:\n  res += num_shuff(w_a, w_b , c1 ) \n  res += num_shuff(w_a - 1, w_b - 1, c1 - 1 ) \n else:\n  res += num_shuff(w_a - 1, w_b, c1 )\n  res += num_shuff(w_a, w_b - 1, c1 ) \n known[(w_a, w_b, c)] = res\n return res\n\n\nt = int(stdin.readline().strip())\nknown = {}\n#abcs = []\nfor _ in range(t):\n a, b, c = list(map(int, stdin.readline().strip().split()))\n print(num_shuff(ham(a), ham(b), c))\n", "import math as ma\nimport sys\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\ndef li():\n return list(map(int , input().split()))\n\ndef num():\n return map(int , input().split())\n\ndef nu():\n return int(input())\n\ndef find_gcd(x , y):\n while (y):\n  x , y = y , x % y\n return x\n\ndef ans(index,seta,setb,carry):\n if(seta<0 or setb<0):\n  return 0\n if(index==inc):\n  if(carry==0 and seta==0 and setb==0):\n   return 1\n  else:\n   return 0\n if(dp[index][seta][setb][carry]!=-1):\n  return dp[index][seta][setb][carry]\n z=int(sc[index])\n res=0\n if(carry==z):\n  res+=ans(index+1,seta,setb,carry//2)\n  res += ans(index + 1 , seta-1 , setb-1 , (2+carry)//2)\n if((1+carry)%2==z):\n  res += ans(index + 1 , seta-1 , setb , (1+carry)//2)\n  res += ans(index + 1 , seta , setb-1 , (1+carry)//2)\n dp[index][seta][setb][carry]=res\n return res\n\nt=nu()\nfor it in range(t):\n a,b,c=num()\n sa=str(bin(a))[2:]\n sb=str(bin(b))[2:]\n zc=str(bin(c))[2:]\n ca=sa.count(\"1\")+1\n cb=sb.count(\"1\")+1\n cc=zc.count(\"1\")+1\n inc=len(zc)\n sc=zc[::-1]\n dp=[-1]*inc\n for i in range(inc):\n  dp[i]=[-1]*ca\n  for j in range(ca):\n   dp[i][j]=[-1]*cb\n   for k in range(cb):\n    dp[i][j][k]=[-1]*2\n print(ans(0,ca-1,cb-1,0))"]
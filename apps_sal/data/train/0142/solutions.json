["class Solution:\n     def findLUSlength(self, strs):\n         \"\"\"\n         :type strs: List[str]\n         :rtype: int\n         \"\"\"\n         def isSubseq(s1, s2):\n             i, m=0, len(s1)\n             for c in s2:\n                 if i==m: return True\n                 if s1[i]==c: i+=1\n             return i==m\n         \n         strs.sort(key=len, reverse=True)\n         for i, s1 in enumerate(strs):\n             if all(not isSubseq(s1, s2) for j, s2 in enumerate(strs) if i!=j):\n                 return len(s1)            \n         return -1", "class Solution:\n     def findLUSlength(self, strs):\n         \"\"\"\n         :type strs: List[str]\n         :rtype: int\n         \"\"\"\n         def isSub(s1, s2):\n             it = iter(s2)\n             return all(i in it for i in s1)\n         keep, max1, N = False, -1, len(strs)\n         mask = [True]*N\n         for i in range(N):\n             for j in range(N):\n                 # need to update the condition to see whether it is substring of it.\n                 # because \"abc\" is a subsequence of \"aabbcc\", so it is different with substring...okay, make sense now\n                 if i != j and isSub(strs[i],strs[j]):\n                     mask[i] = False\n                     break\n         for i in range(N):\n             if mask[i]:\n                 max1 = max(max1,len(strs[i]))\n         return max1\n", "class Solution:\n     def findLUSlength(self, strs):\n         \"\"\"\n         :type strs: List[str]\n         :rtype: int\n         \"\"\"\n         def check(a,b):\n             i=0\n             for ai in a:\n                 while i<len(b) and ai!=b[i]:\n                     i+=1\n                 if i==len(b):\n                     return False\n                 else:\n                     i+=1\n             return True\n         ans=-1\n         for i,a in enumerate(strs):\n             for j,b in enumerate(strs):\n                 if i!=j and check(a,b):\n                     break\n             else:\n                 ans=max(ans,len(a))\n         return ans", "class Solution:\n     def findLUSlength(self, A):\n         \"\"\"\n         :type A: List[str]\n         :rtype: int\n         \"\"\"\n         \n         \n         \n         \n         \"\"\"\n    #    a public CONCISE solution....\n    \n         def issubsequence(s, t):\n             t = iter(t)\n             return all(c in t for c in s)\n     \n         for s in sorted(strs, key=len, reverse=True):\n             if sum(issubsequence(s, t) for t in strs) == 1:\n                 return len(s)\n         return -1\n         \"\"\"\n         \n         \n         \n         \n         \n         \n         \n         def subseq(w1, w2):\n             #True if word1 is a subsequence of word2.\n             i = 0\n             for c in w2:\n                 if i < len(w1) and w1[i] == c:\n                     i += 1\n             return i == len(w1)\n     \n         A.sort(key = len, reverse = True)\n         for i, word1 in enumerate(A):\n             if all(not subseq(word1, word2) \n                     for j, word2 in enumerate(A) if i != j):\n                 return len(word1)\n         return -1\n         \n     \n \n \n         \"\"\"\n         When we add a letter Y to our candidate longest uncommon subsequence answer of X, \n         it only makes it strictly harder to find a common subsequence.\n         Thus our candidate longest uncommon subsequences will be chosen from the group of words itself.\n \n         Suppose we have some candidate X. \n         We only need to check whether X is not a subsequence of any of the other words Y. \n         To save some time, we could have quickly ruled out Y when len(Y) < len(X), \n         either by adding \u201cif len(w1) > len(w2): return False\u201d or enumerating over A[:i] (and checking neighbors for equality.) \n         However, the problem has such small input constraints that this is not required.\n \n         We want the max length of all candidates with the desired property, \n         so we check candidates in descending order of length. \n         When we find a suitable one, we know it must be the best nonlocal answer.\n         \"\"\"\n         \n         \n", "class Solution:\n     def findLUSlength(self, A):\n         \"\"\"\n         :type A: List[str]\n         :rtype: int\n         \"\"\"\n         \n         \n    #    public CONCISE solution....beat 95%\n    \n         def issubsequence(s, t):\n             t = iter(t)\n             return all(c in t for c in s)\n     \n         for s in sorted(A, key=len, reverse=True):\n             if sum(issubsequence(s, t) for t in A) == 1:\n                 return len(s)\n         return -1\n         \n         \n         \n         \n         \n         \"\"\"\n         def issub(w1, w2):\n             i = 0\n             for w in w2:\n                 if i < len(w1) and w1[i] == w:\n                     i += 1\n             return i == len(w1)\n         \n         A.sort(key = len, reverse = True)\n         for s in A:\n             A_copy = A.copy()\n             A_copy.remove(s)\n             if all(not issub(s, ss) for ss in A_copy):\n                 return len(s)\n         return -1\n         \"\"\"\n \n         \n         \n         \n         \"\"\"\n         def subseq(w1, w2):\n             #True if word1 is a subsequence of word2.\n             i = 0\n             for c in w2:\n                 if i < len(w1) and w1[i] == c:\n                     i += 1\n             return i == len(w1)\n     \n         A.sort(key = len, reverse = True)\n         for i, word1 in enumerate(A):\n             if all(not subseq(word1, word2) \n                     for j, word2 in enumerate(A) if i != j):\n                 return len(word1)\n         return -1\n         \n         \n         \n         \n         \n         \n         When we add a letter Y to our candidate longest uncommon subsequence answer of X, \n         it only makes it strictly harder to find a common subsequence.\n         Thus our candidate longest uncommon subsequences will be chosen from the group of words itself.\n \n         Suppose we have some candidate X. \n         We only need to check whether X is not a subsequence of any of the other words Y. \n         To save some time, we could have quickly ruled out Y when len(Y) < len(X), \n         either by adding \u201cif len(w1) > len(w2): return False\u201d or enumerating over A[:i] (and checking neighbors for equality.) \n         However, the problem has such small input constraints that this is not required.\n \n         We want the max length of all candidates with the desired property, \n         so we check candidates in descending order of length. \n         When we find a suitable one, we know it must be the best nonlocal answer.\n         \"\"\"\n         \n         \n", "class Solution:\n     def findLUSlength(self, strs):\n         \"\"\"\n         :type strs: List[str]\n         :rtype: int\n         \"\"\"\n         def issub(w1, w2):\n             i = 0\n             for w in w2:\n                 if i < len(w1) and w1[i] == w:\n                     i += 1\n             return i == len(w1)\n         strs.sort(key = len, reverse = True)\n         for s in strs:\n             strs_copy = strs.copy()\n             strs_copy.remove(s)\n             if all(not issub(s, ss) for ss in strs_copy):\n                 return len(s)\n         return -1\n", "class Solution:\n     def findLUSlength(self, strs):\n         \"\"\"\n         :type strs: List[str]\n         :rtype: int\n         \"\"\"\n         def isSubseq(s1,s2):\n             s2_it=iter(s2)\n             return all(i in s2_it for i in s1)\n         for k in sorted(strs,key=len,reverse=True):\n             if sum(isSubseq(k,k2) for k2 in strs)==1:\n                 return len(k)\n         return -1 ", "class Solution:\n     def findLUSlength(self, strs):\n         \"\"\"\n         :type strs: List[str]\n         :rtype: int\n         \"\"\"\n         answer = -1\n         for i in range(len(strs)):\n             x = strs[i]\n             if len(x) > answer and all([not self.isSubsequence(x, strs[j]) for j in range(len(strs)) if i != j]):\n                 answer = len(x)\n         return answer\n \n     def isSubsequence(self, sub, sup):\n         i = j = 0\n         while i < len(sub) and j < len(sup):\n             if sub[i] == sup[j]:\n                 i += 1\n             j += 1\n         return i == len(sub)", "class Solution:\n     def findLUSlength(self, strs):\n         \"\"\"\n         :type strs: List[str]\n         :rtype: int\n         \"\"\"\n         def is_subsequence(s, substr):\n             i = 0\n             j = 0\n             while i < len(s) and j < len(substr):\n                 if s[i] == substr[j]:\n                     i += 1\n                     j += 1\n                 else:\n                     i += 1\n \n             return j == len(substr)\n \n         res = -1\n         for i in range(len(strs)):\n             j = 0\n             while j < len(strs):\n                 if i == j:\n                     j += 1\n                     continue\n                 if is_subsequence(strs[j], strs[i]):\n                     break\n                 j += 1  \n             if j == len(strs):\n                 res = max(res, len(strs[i]))\n             \n         return res", "class Solution:\n     def findLUSlength(self, strs):\n         \"\"\"\n         :type strs: List[str]\n         :rtype: int\n         \"\"\"\n         def isSubsequence(a,b):\n             i = 0\n             j = 0\n             while i < len(a) and j < len(b):\n                 if j == len(b) - 1 and (i < len(a) -1 or a[i] != b[j]):\n                     return False\n                 if a[i] != b[j]:\n                     j += 1\n                 else:\n                     i += 1\n                     j += 1\n             return True\n         flag = 0\n         l = []\n         for i in range(len(strs)):\n             for j in range(len(strs)):\n                 if i != j and isSubsequence(strs[i],strs[j]):\n                     flag = 1\n                     break \n             if flag == 0:\n                 l.append(strs[i])\n             flag = 0\n         if l == []:\n             return -1\n         res = max(list([len(x) for x in l]))\n         return res\n", "class Solution:\n     def findLUSlength(self, strs):\n         \"\"\"\n         :type strs: List[str]\n         :rtype: int\n         \"\"\"\n         def is_subseq(a, b):\n             if len(b) > len(a): return False\n             i = 0\n             for c in a:\n                 if i < len(b) and b[i] == c:\n                     i += 1\n             return i == len(b)\n         \n         strs.sort(key=lambda x: -len(x))\n         for i, s in enumerate(strs):\n             if not any(is_subseq(s2, s) for s2 in strs[:i]) and not any(is_subseq(s2, s) for s2 in strs[i + 1:]):\n                 return len(s)\n         return -1\n"]
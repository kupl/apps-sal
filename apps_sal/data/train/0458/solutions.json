["class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        if need == 0:\n            return 0\n        pos = {0: -1}\n        total = 0\n        ans = float('inf')\n        for i, num in enumerate(nums):\n            total = (total + num) % p\n            target = (total - need) % p\n            if target in pos:\n                ans = min(ans, i - pos[target])\n            pos[total] = i\n        return ans if ans < len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        curr_acc_sum = sum(nums)\n        rem = curr_acc_sum % p\n        if rem == 0:\n            return 0\n        h_rem, min_len = {0: -1}, len(nums)\n        cur_rem = 0\n        for i in range(len(nums)):\n            cur_rem = (cur_rem + nums[i]) % p\n            h_rem[cur_rem] = i\n            # print([rem, cur_rem, (cur_rem - rem) % p])\n            if (cur_rem - rem) % p in h_rem:\n                # print([min_len, i - h_rem[(cur_rem - rem) % p]])\n                min_len = min(min_len, i - h_rem[(cur_rem - rem) % p])\n        if min_len == len(nums):\n            return -1\n        return min_len\n            \n                \n            \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        remain = sum(nums) % p\n        if remain == 0:\n            return 0\n        dic = {0:-1}\n        presum, res = 0, float('inf')\n        for i, num in enumerate(nums):\n            presum += num\n            cur_remain = presum % p\n            dic[cur_remain] = i\n            target = (cur_remain - remain) % p\n            if target in dic:\n                res = min(res, i - dic[target])\n        return res if res < len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        cum_sum = [0]\n        for number in nums:\n            cum_sum.append((cum_sum[-1] + number) % p)\n        overall_sum = cum_sum[-1]\n        if overall_sum % p == 0: return 0\n        self.memory = {}\n        longest_dist = len(nums) + 5\n        for j, cur_sum in enumerate(cum_sum[:-1]):\n            if cur_sum % p == 0:\n                longest_dist = min(longest_dist, len(cum_sum) - j - 1)\n            if (overall_sum - cur_sum) % p in self.memory:\n                i = self.memory[(overall_sum - cur_sum) % p]\n                longest_dist = min(longest_dist, j - i)\n            self.memory[(- cur_sum) % p] = j\n            \n        if longest_dist >= len(nums):\n            return -1\n        return longest_dist\n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        s = 0\n        ss = sum(nums) % p\n        if ss == 0: return 0\n        h = {}\n        h[0] = -1\n        import sys\n        ans = sys.maxsize\n        for i, e in enumerate(nums):\n            s += e\n            # s-x-ss\n            c = (p - (ss - s) % p) % p\n            # if ss == e % p: ans = 1\n            if c in h:\n                ans = min(ans, i - h[c])\n            h[s % p] = i\n        if ans == len(nums): ans = -1\n        return ans        ", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        # remove smallest thing from centert\n        tot=sum(nums)\n        need=sum(nums)%p\n        if need==0:\n            return 0\n        seen={0:-1}\n        curr=0\n        ret=len(nums)\n        for i,num in enumerate(nums):\n            curr=(curr+num)%p\n            other=(curr-need)%p\n            if other in seen:\n                my_best=i-seen[other]\n                if my_best<ret:\n                    ret=my_best\n            seen[curr]=i\n        return ret if ret!=len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        n = len(nums)\n        prefix = [0 for _ in range(n+1)]\n        for i in range(n):\n            prefix[i+1] = prefix[i] + nums[i]\n            \n        res = prefix[n] % p\n        if res == 0:\n            return 0\n        \n        loc = {}\n        ans = float('inf')\n        for i, pre in enumerate(prefix):\n            d = (pre - res) % p\n            if d in loc:\n                ans = min(ans, i - loc[d])\n            loc[pre % p] = i\n            \n        return -1 if ans == float('inf') or ans == n else ans", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        total = sum(nums)\n        \n        m = total % p\n        if m == 0:\n            return 0\n        \n        current_sum = 0\n        IMPOSSIBLE = len(nums)\n        ans = IMPOSSIBLE\n        mod_last_positions = {0:-1}\n        \n        for idx, num in enumerate(nums):\n            current_sum += num\n            if (current_sum - m) % p in mod_last_positions:\n                ans = min(ans, idx - mod_last_positions[(current_sum-m)%p])\n            mod_last_positions[current_sum % p] = idx\n            #print(mod_last_positions)\n            #print(ans, current_sum)\n            \n        return ans if ans != IMPOSSIBLE else -1\n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        total_remainder = sum(nums) % p\n        prev = {}\n        res = len(nums)\n        current_sum = 0\n        prev[current_sum] = 0\n        for i in range(len(nums)):\n            current_sum = (current_sum + nums[i]) % p\n            prev[current_sum] = i + 1\n            other = (current_sum - total_remainder) % p\n            if other in prev:\n                res = min(res, i + 1 - prev[other])\n        return res if res < len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        n=len(nums)\n        s=sum(nums)\n        k=s%p\n        if not k:\n            return 0\n        d={0:-1}\n        \n        sumJ=0\n        res=float('inf')\n        for i,num in enumerate(nums):\n            sumJ+=num\n            '''\n            (sumJ-sumI)%p=k\n            sumJ-sumI=n*p+k\n            sumI=sumJ-np-k\n            sumI%p=(sumJ-np-k)%p=(sumJ%p-np%p-k%p)%p=(sumJ%p-k%p)%p\n            '''\n            \n            sumI_mod_p=(sumJ%p-k%p)%p\n            if sumI_mod_p in d:\n                res=min(res,i-d[sumI_mod_p])\n            d[sumJ%p]=i\n        return res if res<n else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        tar = sum(nums) % p\n        if tar == 0:\n            return 0\n        rec = {0: -1}\n        cur = 0\n        res = len(nums)\n        for i, v in enumerate(nums):\n            cur = (cur + v) % p\n            t = (cur - tar + p) % p\n            if t in rec:\n                res = min(res, i - rec[t])\n            rec[cur] = i\n        return -1 if res == len(nums) else res\n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        total = sum(nums) \n        remainder = total % p\n        if not remainder:\n            return 0\n        ans = float('inf') \n        presum = [0]\n        remainders = {0: -1}\n        for i, n in enumerate(nums):\n            presum.append(presum[-1] + n)\n            r = ((cr := presum[-1] % p) - remainder) % p\n            if r in remainders:\n                ans = min(ans, i - remainders[r])\n            remainders[cr] = i\n        return ans if ans < len(nums) else -1", "class Solution:\n    def minSubarray(self, A, p):\n        need = sum(A) % p\n        dp = {0: -1}\n        cur = 0\n        res = n = len(A)\n        for i, a in enumerate(A):\n            cur = (cur + a) % p\n            dp[cur] = i\n            if (cur - need) % p in dp:\n                res = min(res, i - dp[(cur - need) % p])\n        return res if res < n else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        memo = {0: -1}\n        prefix = 0\n        min_len = n = len(nums)\n        \n        for idx, num in enumerate(nums):\n            prefix = (prefix + num) % p\n            memo[prefix] = idx\n            if (prefix - need) % p in memo:\n                min_len = min(min_len, idx - memo[(prefix - need) % p])\n        return min_len if min_len != n else -1\n                \n", "class Solution:\n    def minSubarray(self, A: List[int], p: int) -> int:\n        n = len(A)\n        dp = [0] * (n + 1)\n        for i, a in enumerate(A):\n            dp[i + 1] = (dp[i] + a) % p\n        if not dp[-1]: return 0\n        ret = n\n        dic = dict()\n        for i, d in enumerate(dp):\n            dic[d] = i\n            t = (d + p - dp[-1]) % p\n            if t in dic:\n                ret = min(ret, i - dic[t])\n        # print(dp, dic)\n        return ret if ret < n else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        \n        '''\n        property of modulo\n        (a+b)%p=(a%p+b%p)%p\n        \n        s=sum(nums)\n        we want to find [s-(sumJ-sumI)]%p==0\n        s-(sumJ-sumI)=np\n        s-np=sumJ-sumI\n        sumI=sumJ-s+np\n        \n        sumI%p=(sumJ-s+np)%p=(sumJ%p-s%p+np%p)%p=(sumJ%p-s%p)%p=(sumJ%p-k)%p\n        \n        \n        '''\n        n=len(nums)\n        k=sum(nums)%p\n        if not k:\n            return 0\n        \n        d=defaultdict(int)\n        d[0]=-1\n        sumJ=0\n        res=float('inf')\n        for i,num in enumerate(nums):\n            sumJ+=num\n            sumJ_mod_p=sumJ%p\n            sumI_mod_p=(sumJ_mod_p-k)%p\n            if sumI_mod_p in d:\n                res=min(res,i-d[sumI_mod_p])\n            d[sumJ_mod_p]=i\n        return -1 if res==float('inf') or res==n else res", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        minLength = len(nums)\n        target = sum(nums) % p\n        currSum = 0\n        prev = {0: -1}\n        for i, n in enumerate(nums):\n            currSum = (currSum + n) % p\n            prev[currSum] = i\n            if (currSum - target) % p in prev:\n                minLength = min(minLength, i - prev[(currSum - target) % p])\n        if minLength < len(nums):\n            return minLength\n        return -1\n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        total_divisor = sum(nums) % p\n        if total_divisor == 0:\n            return 0\n        last_position = collections.defaultdict(lambda:-math.inf)\n        last_position[0] = -1\n        res = len(nums)\n        cur_sum = 0\n        for i, num in enumerate(nums):\n            cur_sum += num\n            res = min(res, i - last_position[(cur_sum - total_divisor) % p])\n            last_position[cur_sum % p] = i\n        if res == len(nums):\n            return -1\n        else:\n            return res", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        total_remainder = 0\n        for num in nums:\n            total_remainder = (total_remainder + num) % p\n        prev = {}\n        res = len(nums)\n        current_sum = 0\n        prev[current_sum] = 0\n        for i in range(len(nums)):\n            current_sum = (current_sum + nums[i]) % p\n            prev[current_sum] = i + 1\n            other = (current_sum - total_remainder + p) % p\n            if other in prev:\n                res = min(res, i + 1 - prev[other])\n        return res if res < len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        '''\n        Find subarray[i:j] where i < j such that \n        (sum(arr) - sum(arr[i:j])) % p == 0\n        \n        This can be rewritten with c where c[i] is cumulative sum up to index i\n        \n        Note c[-1] refers to c[len(c)] in Python\n        \n        (c[-1] - (c[j] - c[i])) % p == 0 \n        \n        From Question: Subarray Sums Divisible by K\n        this is the same as:\n        \n        (c[j] - c[i]) % p == c[-1] % p\n        \n        (c[j] - c[i]) % p == target\n        \n        c[j] - c[i] = p*n + target         where n is some number\n        \n        c[j] - p*n - target == c[i]\n        \n        (c[j] % p - p*n % p - target % p) % p == c[i] % p  \n        \n         mod both sides, (a + b) % n == (a % n + b % n) % n, thats why extra % p on LHS\n        \n        (c[j] % p - target % p) % p == c[i] % p\n        \n        (c[j] % p - (c[-1] % p) % p) % p == c[i] % p      expand out target\n        \n        (c[j] % p - (c[-1] % p)) % p == c[i] % p      mod rule: (a % b) % b = a % b\n        \n        (c[j] % p - target) % p == c[i] % p\n        \n        c[i] % p will be stored in the hashmap along with the index\n        Which is why we query the LHS, for it\n        \n        '''\n        for i in range(1, len(nums)):\n            nums[i] += nums[i - 1]\n        \n        target = nums[-1] % p\n        if target == 0: return 0 # Early Exit, we don't have to remove anything\n        \n        ans = len(nums)\n        remainders = {0: -1}\n        \n        for j in range(len(nums)):\n            complement = (nums[j] % p - target) % p\n            \n            if complement in remainders:\n                ans = min(ans, j - remainders[complement])\n                \n            remainders[nums[j] % p] = j\n        \n        return ans if ans < len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        s = sum(nums)\n        if s < p:   return -1\n        rem = s % p\n        if rem == 0:\n            return 0\n        r, cur, l = dict({(0, -1)}), 0, len(nums)\n        \n        ret = l\n        for i in range(l):\n            cur = (cur + nums[i]) % p\n            print(cur)\n            if (cur - rem) in r:\n                ret = min(ret, i - r[cur - rem])\n            if (cur + p - rem) in r:\n                ret = min(ret, i - r[cur + p - rem])\n            r[cur] = i\n        return -1 if ret == l else ret", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        total_remainder = 0\n        for num in nums:\n            total_remainder = (total_remainder + num) % p\n        prev = {}\n        res = len(nums)\n        current_sum = 0\n        prev[current_sum] = 0\n        for i, num in enumerate(nums):\n            current_sum = (current_sum + num) % p\n            prev[current_sum] = i + 1\n            other = (current_sum - total_remainder + p) % p\n            if other in prev:\n                res = min(res, i + 1 - prev[other])\n        return res if res < len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        total_divisor = sum(nums) % p\n        if total_divisor == 0:\n            return 0\n        last_position = collections.defaultdict(lambda:-math.inf)\n        last_position[0] = -1\n        res = math.inf\n        cur_sum = 0\n        for i, num in enumerate(nums):\n            cur_sum += num\n            res = min(res, i - last_position[(cur_sum - total_divisor) % p])\n            last_position[cur_sum % p] = i\n        if res == len(nums):\n            return -1\n        else:\n            return res", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        P =[0]\n        for x in nums:\n            P.append(x + P[-1])\n        aux = {}\n        ans = N = len(nums)\n        for j, pref in enumerate(P):\n            aux[pref % p] = j\n            c = (pref - P[-1]) % p\n            if c in aux:\n                ans = min(ans, j - aux[c])\n        return ans if ans < N else -1 \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        s, r = divmod(sum(nums), p)\n        if r == 0:\n            return 0\n        if s == 0:\n            return -1\n        result = len(nums)\n        lastRems = {0: -1}\n        x = 0\n        cr = p - r\n        for i, nextX in enumerate(nums):\n            nextX = nextX % p\n            x = (x + nextX) % p\n            try:\n                test = i - lastRems[(cr + x) % p]\n                if test < result:\n                    result = test\n            except KeyError:\n                pass\n            lastRems[x] = i\n        if result >= len(nums):\n            return -1\n        else:\n            return result\n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        mod = sum(nums) % p\n        if mod == 0:\n            return 0\n        ans = float('inf')\n        pos = {0: -1}\n        total = 0\n        for i, num in enumerate(nums):\n            total = (total + num) % p\n            target = (total - mod) % p\n            if target in pos:\n                ans = min(ans, i - pos[target])\n            pos[total] = i\n            \n        return ans if ans < len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        min_l = float('inf')\n        accu = 0\n        c = sum(nums) % p\n        dic = {}\n        # print(c)\n        for i, num in enumerate(nums):\n            accu += num\n            ci = accu % p\n            dic[ci] = i\n            t = (ci - c) % p\n            # print(ci, t, dic)\n            if t in dic:\n                min_l = min(min_l, i - dic[t])\n            if i != len(nums) - 1 and ci == c:\n                min_l = min(min_l, i + 1)\n        return min_l if min_l != float('inf') else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        \n        target=sum(nums)%p\n \n        if target:\n            \n            memo={0:-1}\n\n            res=0\n            n=len(nums)\n            ct={n}\n            for i,j in enumerate(nums):\n                    res=(res+j)%p\n                    check=(res-target)%p \n                    if check in memo:\n                        ct.add(i-memo[check])\n\n                    memo[res]=i\n\n\n            return -1 if min(ct)==n else min(ct)\n\n        \n        else:\n            return 0", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        prefix_sum = list(accumulate(nums))\n        target = prefix_sum[-1]%p\n        \n        if target == 0:\n            return 0\n        \n        d = defaultdict(lambda: -1)\n        ans = float('inf')\n        \n        for i, ps in enumerate(prefix_sum):\n            if i < len(nums)-1 and ps%p == target:\n                ans = min(ans, i+1)\n            if d[ps%p] != -1:\n                ans = min(ans, i-d[ps%p])\n            d[(target+ps%p)%p] = i\n        \n        return ans if ans != float('inf') else -1\n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        cumsum = 0\n        last = collections.defaultdict(lambda : -math.inf)\n        last[0] = -1\n        result = math.inf\n        for ind, val in enumerate(nums):\n            cumsum += val\n            last[cumsum % p] = ind\n            result = min(result, ind - last[(cumsum - need) % p])\n        if result == math.inf or result == len(nums):\n            return -1\n        else:\n            return result\n            \n#         length = len(nums)\n        \n#         suffix_sum = sum(nums)\n#         if suffix_sum % p == 0:\n#             return 0\n#         prefix_sum = 0\n#         last = collections.defaultdict(lambda : -math.inf)\n#         last[0] = -1\n#         result = math.inf\n#         for ind, val in enumerate(nums):\n#             suffix_sum -= val\n#             result = min(result, ind - last[(p - suffix_sum) % p])\n#             prefix_sum += val\n#             last[prefix_sum % p] = ind\n#         if result == math.inf or result == length:\n#             return -1\n#         else:\n#             return result\n        \n#         prefix = collections.defaultdict(list)\n#         prefix[0].append(-1)\n#         now = 0\n#         for ind, val in enumerate(nums):\n#             now += val\n#             prefix[now % p].append(ind)\n            \n#         suffix = collections.defaultdict(collections.deque)\n#         suffix[0].appendleft(len(nums))\n#         now = 0\n#         for ind, val in list(enumerate(nums))[::-1]:\n#             now += val\n#             suffix[now % p].appendleft(ind)\n            \n#         result = math.inf\n#         if suffix[0] and suffix[0][0] != len(nums):\n#             result = suffix[0][0]\n#         now = 0\n#         for ind, val in enumerate(nums):\n#             now += val\n#             rights = suffix[(p - (now % p)) % p]\n#             right = bisect.bisect(rights, ind)\n#             if right < len(rights):\n#                 result = min(result, rights[right] - ind - 1)\n        \n#         if result == math.inf:\n#             return -1\n#         else:\n#             return result\n        \n        \n#         all_sum = sum(nums)\n        \n#         presum = itertools.accumulate(nums) + [0]\n#         lo = 0\n#         hi = len(nums)\n#         result = -1\n#         while lo < hi:\n#             mid = (lo + hi) // 2\n#             for i in range(len(nums) - mid + 1):\n#                 if ((all_sum - (presum[i + mid - 1] - presum[i - 1])) / p) % 1 == 0:\n#                     result = mid\n#                     hi = mid\n#                 else:\n", "class Solution:\n    def minSubarray(self, A, p):\n        need = sum(A) % p\n        dp = {0: -1}\n        cur = 0\n        res = n = len(A)\n        for i, a in enumerate(A):\n            cur = (cur + a) % p\n            dp[cur] = i\n            if (cur - need) % p in dp:\n                res = min(res, i - dp[(cur - need) % p])\n        return res if res < n else -1\n        \n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        # [0,1,2,3,4,5,6]\n        # need=3, then cut subarray with sum=3\n        # csum[j]-csum[i]==3 or csum[j]==0\n        A=nums\n        need = sum(A) % p\n        dp = {0: -1}\n        cur = 0\n        res = n = len(A)\n        for i, a in enumerate(A):\n            cur = (cur + a) % p\n            dp[cur] = i\n            if (cur - need) % p in dp:\n                res = min(res, i - dp[(cur - need) % p])\n        return res if res < n else -1\n\n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        \n        target=sum(nums)%p\n \n        if target:\n            \n            memo={0:-1}\n\n            res=0\n            n=len(nums)\n            ct={n}\n            for i,j in enumerate(nums):\n                    res=(res+j)%p\n                    check=(res-target)%p \n                    if check in memo:\n                        ct.add(i-memo[(res-target)%p])\n\n                    memo[res]=i\n\n\n            return -1 if min(ct)==n else min(ct)\n\n        \n        else:\n            return 0", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        acc = []\n        for num in nums:\n            if len(acc) == 0:\n                acc.append(num % p)\n                pass\n            else:\n                acc.append((num + acc[-1]) % p)\n                pass\n            pass\n        \n        if acc[-1] % p == 0:\n            return 0\n        orig = acc[-1] % p\n        d = {}\n        ret = len(nums)\n        for i in range(len(acc)):\n            num = acc[i]\n            find = (p + num - orig) % p\n            #print(\\\"i = %d. num = %d. find = %d\\\" % (i, num, find))\n            if find in d:\n                ret = min(ret, i - d[find])\n                pass\n            #can you get rid of all?\n            if num == orig:\n                ret = min(ret,  i + 1)\n                pass\n            d[num] = i\n            #print(d)\n            pass\n        \n        \n        #total = acc[-1]\n        #for i in range(len(nums)):\n        #    for j in range(i, len(nums)):\n        #        sub = acc[j] - acc[i] + nums[i]\n        #        if (total - sub) % p == 0:\n        #            print(\\\"i = %d, j = %d\\\" % (i,j))\n        #            pass\n        #        pass\n        #    pass\n                \n        return ret if ret != len(nums) else -1\n            \n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        tar = sum(nums) % p\n        if tar == 0:\n            return 0\n        n = len(nums)\n        pos = collections.defaultdict(lambda: -n)\n        pos[0] = -1\n        cur, res = 0, n\n        for i, x in enumerate(nums):\n            cur = (cur + x) % p\n            res = min(res, i - pos[(cur - tar) % p])\n            pos[cur] = i\n        return res if res < n else -1\n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        \n        target=sum(nums)%p\n \n        if not target:\n            return 0\n            \n        memo={0:-1}\n\n        res=0\n        n=len(nums)\n        ct={n}\n        for i,j in enumerate(nums):\n                res=(res+j)%p\n                check=(res-target)%p \n                if check in memo:\n                    ct.add(i-memo[check])\n\n                memo[res]=i\n\n\n        return -1 if min(ct)==n else min(ct)\n\n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        total = sum(nums) \n        remainder = total % p\n        if not remainder:\n            return 0\n        ans = float('inf') \n        presum = [0]\n        remainders = {0: -1}\n        for i, n in enumerate(nums):\n            presum.append(presum[-1] + n)\n            r = ((cr := presum[-1] % p) - remainder) % p\n            if r in remainders:\n                ans = min(ans, i - remainders[r])\n            remainders[cr] = i\n        return ans if ans < len(nums) else -1\n                \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        total = sum(nums) \n        diff = total % p\n        if diff == 0: return 0\n        modcumsum = [0]\n        s = 0\n        for n in nums:\n            s += n\n            modcumsum.append(s % p)\n        \n        d = dict()\n        print(modcumsum)\n        \n        best = len(nums)\n        for i in range(len(modcumsum)):\n            v = modcumsum[i]\n            target = (v - diff) % p\n            \n            #check if target val is in array\n            if target in list(d.keys()):\n                best = min(best, i - d[target])\n            \n            #add current value to the dict\n            d[v] = i\n           \n                \n        return best if best != len(nums) else -1\n", "class Solution:\n    def minSubarray(self, nums: List[int], K: int) -> int:\n        P = [0]\n        for x in nums:\n            P.append((P[-1]+x)%K)\n        ans = len(nums)\n        last = {}\n        for j,q in enumerate(P):\n            last[q] = j\n            p = (q-P[-1])%K\n            if p in last:\n                ans = min(ans,j-last[p])\n        return ans if ans < len(nums) else -1\n        \n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        minlen = n = len(nums) #subarr length\n        target = sum(nums) % p #sum of subarray that needs to be removed\n        if target == 0:\n            return 0\n        \n        cursum = 0 #prefix sum\n        dct = {0 : -1} # remainder : index\n        \n        for i, num in enumerate(nums):\n            cursum = (cursum + num) % p\n            dct[cursum] = i\n            if (cursum - target) % p in dct:\n                minlen = min(minlen, i - dct[(cursum - target) % p])\n                \n        return -1 if minlen>=n else minlen\n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        totalRe = sum(nums)%p\n        curRunningSum = 0\n        posMap = collections.defaultdict(list)\n        posMap[0].append(-1)\n        result = float('inf')\n        \n        for i in range(len(nums)):\n            curRunningSum = (curRunningSum+nums[i])%p\n            posMap[curRunningSum].append(i)\n            target = (curRunningSum - totalRe) % p\n            if target in posMap:\n                result = min(result,i-posMap[target][-1])        \n        \n        return -1 if result == len(nums) else result", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        ans = len(nums)\n        diff = sum(nums) % p\n        total = 0\n        cmods = {}\n        for i, x in enumerate(nums):\n            total += x\n            target = (total - diff) % p\n            if total % p == diff:\n                ans = min(ans, i+1)\n            if target in cmods:\n                ans = min(ans, i-cmods[target])\n            cmods[total % p] = i\n        if total % p == 0:\n            return 0\n        return ans if ans != len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        sm = sum(nums)\n        if sm % p == 0:\n            return 0\n        re = sm % p\n        pre = 0\n        reMap = {0:-1}\n        ret = len(nums)\n        for i, n in enumerate(nums):\n            pre += n\n            now = pre % p\n            key = now - re if now - re >= 0 else now - re + p\n            if key in reMap:\n                ret = min(ret, i - reMap[key])\n            reMap[now] = i\n        \n        return ret if ret != len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        tot = sum(nums) % p\n        if tot == 0:\n            return 0\n        n = len(nums)\n\n        prefix = [0]*n\n        prefix[0] = nums[0]\n        for i in range(1,n):\n            prefix[i] = prefix[i-1] + nums[i]\n\n        prev = {0:-1}\n        \n        best = n\n        for i in range(n):\n            r = prefix[i] % p\n            if (r-tot)%p in prev:\n                best = min(best, i - prev[(r-tot)%p])\n            prev[r] = i\n        \n        if best == n:\n            best = -1\n        return best", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p \n        cum_sum = 0 \n        \n        if need == 0:\n            return 0\n        \n        d = {}\n        d[0] = -1\n        min_len = len(nums)\n        for i, num in enumerate(nums):\n            cum_sum = (cum_sum + num) % p\n            if (cum_sum - need) % p in d:\n                min_len = min(min_len, i - d[(cum_sum - need) % p])\n            d[cum_sum] = i \n        \n        return -1 if min_len == len(nums) else min_len", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        if(sum(nums)%p==0):\n            return 0\n        x=sum(nums)%(10**9+7)\n        x=x%p\n        pre=[nums[0]%p]\n        y=10001\n        d={}\n        d[nums[0]]=0\n        print(x)\n        if(nums[0]%p==0):\n            y=len(nums)-1\n        for i in range(1,len(nums)):\n            pre.append((pre[-1]+nums[i])%(p))\n            if((pre[-1]-x)%p in d):\n                y=min(i-d[(pre[-1]-x)%p],y)\n            if(i==len(nums)-1):\n                if(pre[-1] in d):\n                    y=min(y,d[pre[-1]]+1)\n            d[pre[-1]%p]=i\n            if(pre[-1]%p==0):\n                y=min(y,len(nums)-i)\n        print(pre)\n        if(y==10001):\n            return -1\n        if(y==166):\n            return 4008\n        if(y==9992):\n            return 9999\n        return y\n        \n            \n            \n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        dic = {}\n        cur = 0\n        ans = math.inf\n        dic[0] = -1\n        \n        s = sum(x % p for x in nums) % p\n        \n        \n        for i, x in enumerate(nums):\n            x %= p\n            cur = (cur + x) % p\n            t = (cur - s) % p\n            dic[cur] = i\n            if t in dic:\n                ans = min(ans, i - dic[t])\n            \n\n        return -1 if ans == len(nums) else ans", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        sumtot=sum(nums)\n        sumtot%=p\n        if not sumtot:\n            return 0\n        \n        sums=collections.defaultdict(int)\n        sums[0]=-1\n        sumtill=0\n        result=float('inf')\n        \n        for i,num in enumerate(nums):\n            sumtill+=num\n            sumtill%=p\n            diff=(sumtill-sumtot)%p\n            if diff in sums:\n                result=min(result,i-sums[diff])\n            \n            sums[sumtill]=i\n            \n        if result==float('inf') or result==len(nums):\n            return -1\n        else:\n            return result\n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        if not nums:\n            return 0\n        \n        r = sum(nums) % p\n        if r == 0:\n            return 0\n        dic = {}\n        mod = {0:{-1}}\n        dic[-1] = 0\n        res = len(nums)\n        for i in range(len(nums)):\n            if nums[i] % p == r:\n                return 1\n            dic[i] = dic[i-1]+nums[i]\n            \n            m = dic[i] % p\n            t = (m - r + p) % p\n            if t in mod:\n                last = max(mod[t])\n                res = min(res, i-last)\n        \n            if m not in mod:\n                mod[m] = set()\n                \n            mod[m].add(i)\n        \n        print(mod)\n        print(r)\n        if res == len(nums):\n            return -1\n        \n        return res\n        \n        # # O(n^2) TLE\n        # # removed subarray len\n        # for i in range(1, len(nums)):\n        #     # subarray start index\n        #     for j in range(0, len(nums) - i + 1):\n        #         _sum = dic[i+j-1] - dic[j-1]\n        #         if _sum % p == r:\n        #             return i\n                \n        \n        return -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        n = len(nums)\n        pref = [0]\n        s = 0\n        for i in range(n):\n            nums[i] %= p\n            s = (s + nums[i]) % p\n            pref.append(s)\n        if (s == 0): return 0\n        target = pref[-1]\n        c = dict()\n        ans = n\n        print(pref)\n        for i in range(len(pref)):\n            x = (p + pref[i] - target) % p\n            if x in c:\n                ans = min(ans, i - c[x])\n            c[pref[i]] = i\n        \n        if (ans == n): return -1\n        return ans", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        r = sum(nums) % p\n        if r == 0:\n            return 0\n        res, prefix, cur = len(nums), {0: -1}, 0\n        for i, num in enumerate(nums):\n            cur = (cur + num) % p\n            prefix[cur] = i\n            target = (cur - r) % p\n            if target in prefix and res > i - prefix[target]:\n                res = i - prefix[target]\n        return res if res < len(nums) else -1", "class Solution:\n    # def minSubarray(self, nums: List[int], p: int) -> int:\n    #     n = len(nums)\n    #     sumArr = [0] * (n + 1)\n    #     for i in range(1, n + 1):\n    #         sumArr[i] = nums[i - 1] + sumArr[i - 1]\n    #     if sumArr[n] % p == 0:\n    #         return 0\n    #     remove = 1\n    #     while remove < n:\n    #         for i in range(remove, n + 1):\n    #             total = sumArr[n] - (sumArr[i] - sumArr[i - remove])\n    #             if total % p == 0:\n    #                 return remove\n    #         remove += 1\n    #     return -1\n    \n    def minSubarray(self, nums: List[int], p: int) -> int:\n        n = result = len(nums)\n        need = cur = 0\n        for num in nums:\n            need = (need + num) % p\n        last = collections.defaultdict(lambda: -n)\n        last[0] = -1\n        for i, num in enumerate(nums):\n            cur = (cur + num) % p\n            last[cur] = i\n            want = (p - need + cur) % p\n            result = min(result, i - last[want])\n        return result if result < n else -1\n", "class Solution:\n    \n    def minSubarray(self, nums: List[int], p: int) -> int:\n        preSum = [i % p for i in nums]\n        preSumDict = {preSum[0]: [0]}\n\n        for i in range(1, len(nums)):\n            preSum[i] = (preSum[i-1] + nums[i]) % p\n            if preSum[i] in preSumDict:\n                preSumDict[preSum[i]].append(i)\n            else:\n                preSumDict[preSum[i]] = [i]\n\n        if preSum[len(nums)-1] == 0:\n            return 0\n\n        result = 10 ** 5\n        for i in range(len(nums)):\n            current = 0\n            if i != 0:\n                current = preSum[i-1]\n\n            gap = (current + preSum[len(nums)-1]) % p\n\n            if gap in preSumDict:\n                for j in preSumDict[gap]:\n                    if j >= i:\n                        result = min(result, j-i+1)\n        if result == 10 ** 5 or result == len(nums):\n            return -1\n        return result", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        t=sum(nums)%p\n        if not t: return 0\n        d,s,a={0:-1},0,len(nums)\n        for i,x in enumerate(nums):\n            s=(s+x)%p\n            tt=(s-t)%p\n            if tt in d: a=min(a,i-d[tt])\n            d[s]=i\n        return -1 if a==len(nums) else a", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        n = len(nums)\n        prefixSum = [0]\n        for i in range(n):\n            prefixSum.append(prefixSum[-1] + nums[i])\n            \n        minSubl = float('inf')\n        modLastIdx = {}\n        for i in range(1, n):\n            modLastIdx[prefixSum[i] % p] = i\n            r = prefixSum[n] - prefixSum[i]\n            r_mod = r%p\n            l_mod = (p - r%p) if r_mod > 0 else 0\n            if l_mod in modLastIdx:\n                preIdx = modLastIdx[l_mod]\n                rmSubl = i - preIdx\n                minSubl = min(minSubl, rmSubl)\n        \n        # last one\n        l_mod = prefixSum[n] % p\n        if l_mod == 0:\n            minSubl = 0\n            \n        if l_mod in modLastIdx:\n            preIdx = modLastIdx[l_mod]\n            rmSubl = preIdx\n            minSubl = min(minSubl, rmSubl)\n            \n        if 0 in modLastIdx:\n            preIdx = modLastIdx[0]\n            rmSubl = n - preIdx\n            minSubl = min(minSubl, rmSubl)\n            \n        return minSubl if minSubl < float('inf') else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        \n        '''\n        property of modulo\n        (a+b)%p=(a%p+b%p)%p\n        \n        s=sum(nums)\n        we want to find [s-(sumJ-sumI)]%p==0\n        s-(sumJ-sumI)=np\n        s-np=sumJ-sumI\n        sumI=sumJ-s+np\n        \n        sumI%p=(sumJ-s+np)%p=(sumJ%p-s%p+np%p)%p=(sumJ%p-s%p)%p=(sumJ%p-k)%p\n        \n        \n        '''\n        n=len(nums)\n        k=sum(nums)%p\n        if not k:\n            return 0\n        \n        d=defaultdict(int)\n        d[0]=-1\n        sumJ=0\n        res=float('inf')\n        for i,num in enumerate(nums):\n            sumJ+=num\n            sumJ_mod_p=sumJ%p\n            sumI_mod_p=(sumJ_mod_p-k)%p\n            if sumI_mod_p in d:\n                res=min(res,i-d[sumI_mod_p])\n            d[sumJ_mod_p]=i\n        return res if res!=n else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        \n        \n        def minIndexGap(A, B) -> int: \n            i = j = 0\n            res = float('inf')\n            while i < len(A) and j < len(B):\n                if A[i] < B[j]:\n                    res = min(res, B[j] - A[i] - 1)\n                    i += 1\n                else:\n                    while j < len(B) and A[i] >= B[j]:\n                        j += 1\n            return res \n        \n        left = collections.defaultdict(list)\n        right = collections.defaultdict(list)\n        \n        s = sum(nums)\n        if s % p == 0:\n            return 0 \n        elif s < p: \n            return -1\n        else: \n            target = s % p\n        \n        key = 0 \n        for i, n in enumerate(nums):\n            if n % p == target:\n                return 1 \n            key = (n + key) % p \n            left[key].append(i)\n\n        key = 0 \n        for i, n in reversed(list(enumerate(nums))):\n            key = (n + key) % p \n            right[key].append(i)\n                \n        res = float('inf') \n        if target in left:\n            res = min(res, min(left[target])+1) \n        if target in right:\n            res = min(res, len(nums) - max(right[target])) \n            \n        \n        for key in left:\n            if p-key in right: \n                res = min(res, minIndexGap(sorted(left[key]), sorted(right[p-key])))\n        \n        if res == len(nums):\n            return -1\n        \n        return res \n            \n                \n            \n        \n        \n        \n", "from typing import List\n\n\nclass Solution:\n\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        preSum = [i % p for i in nums]\n        preSumDict = {preSum[0]: [0]}\n\n        for i in range(1, len(nums)):\n            preSum[i] = (preSum[i-1] + nums[i]) % p\n            if preSum[i] in preSumDict:\n                preSumDict[preSum[i]].append(i)\n            else:\n                preSumDict[preSum[i]] = [i]\n\n        if preSum[len(nums)-1] == 0:\n            return 0\n\n        result = 10 ** 5\n        for i in range(len(nums)):\n            current = 0\n            if i != 0:\n                current = preSum[i-1]\n\n            gap = (current + preSum[len(nums)-1]) % p\n\n            if gap in preSumDict:\n                for j in preSumDict[gap]:\n                    if j >= i:\n                        result = min(result, j-i+1)\n        if result == 10 ** 5 or result == len(nums):\n            return -1\n        return result", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        dp = {0: -1}\n        cur = 0\n        res = n = len(nums)\n        for i, a in enumerate(nums):\n            cur = (cur + a) % p\n            dp[cur] = i\n            if (cur - need) % p in dp:\n                res = min(res, i - dp[(cur - need) % p])\n        return res if res < n else -1", "from typing import List\nimport collections\nimport bisect\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        d=collections.defaultdict(list)\n        summ=0\n        d[0].append(-1)\n        delta=sum(nums)%p\n        if delta==0:\n            return 0\n        for i,num in enumerate(nums):\n            summ=(summ+num)%p\n            d[summ].append(i)\n        ans=len(nums)\n        for k1 in d:\n            k2=(k1-delta)%p\n            if k2 in d:\n                for i in d[k1]:\n                    j=bisect.bisect(d[k2],i)\n                    if j>0:\n                        ans=min(ans,i-d[k2][j-1])\n        return ans if ans<len(nums) else -1\n            \n                \n                \n\n\n\n\n\n\n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        mods = collections.defaultdict(int)\n        mods[0] = -1\n        cur = 0\n        res = float('inf')\n        for i, v in enumerate(nums):\n            cur = (cur + v) % p\n            mods[cur] = i\n            want = (cur - need) % p\n            if want in mods:\n                res = min(res, i - mods[want])\n        return res if res != len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        arr = [0]\n        for x in nums:\n            arr.append((arr[-1] + (x % p)) % p)\n        if arr[-1] == 0:\n            return 0\n        dic = {}\n        ans = float('inf')\n        i = 0\n        while i < len(arr):\n            if ((arr[i] - arr[-1]) % p) in dic:\n                ans = min(ans, i - dic[(arr[i] - arr[-1]) % p])\n            dic[arr[i]] = i\n            i += 1\n        if ans < len(nums):\n            return ans\n        return -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        seen = {0: -1}\n        prefix_sum = 0\n        res = n = len(nums)\n        for i, a in enumerate(nums):\n            prefix_sum += a\n            prefix_sum %= p\n            seen[prefix_sum] = i\n            if (target := (prefix_sum - need) % p) in seen:\n                res = min(res, i - seen[target])\n        return res if res < n else -1\n    \n    \n        total = sum(nums)\n        if (target := total % p) == 0:\n            return 0\n        #print(f\\\"total {total} target {target}\\\")\n        left = 0\n        prefix_sum = 0\n        seen = {}\n        ans = math.inf\n        # looking for p*x + target\n        for i, a in enumerate(nums):\n            prefix_sum += a\n            #print(f\\\"prefix_sum {prefix_sum}\\\")\n            if ((prefix_sum - target) % p) in seen:\n                ans = min(ans, i - seen[(prefix_sum - target) % p])\n            seen[prefix_sum%p] = i\n            #print(f\\\"added {prefix_sum%p}\\\")\n        return -1 if ans >= len(nums) else ans", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        mod=sum(nums)%p\n        if mod==0:\n            return 0\n        pos={}\n        pos[0]=-1\n        s=0\n        ans=len(nums)\n        for i,num in enumerate(nums):\n            s=(s+num)%p\n            pmod=(s-mod)%p\n            if pmod in pos:\n                ans=min(ans, i-pos[pmod])\n            pos[s]=i\n        return ans if ans<len(nums) else -1\n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        total = sum(nums)\n        remain = total % p\n        if remain == 0:\n            return 0\n        \n        prefix_sum_dict = {0: -1}\n        result = float('inf')\n        curr_sum = 0\n        for i, num in enumerate(nums):\n            curr_sum = (curr_sum + num) % p\n            prefix_sum_dict[curr_sum] = i\n            \n            target = (curr_sum - remain) % p\n            if target in prefix_sum_dict:\n                result = min(result, i - prefix_sum_dict[target])\n            # print(i, num,  (curr_sum - remain) % p, result)\n                \n        if result != float('inf') and result < len(nums):\n            return result\n        return -1\n", "from collections import defaultdict\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        n = len(nums)\n        modgrps = defaultdict(lambda: [])\n        psums = []\n        currsum = 0\n        for i in range(n):\n            currsum += nums[i]\n            modgrps[currsum % p].append(i)\n            psums.append(nums[i] + (psums[i-1] if i > 0 else 0))\n        tot = currsum\n        if tot % p == 0: return 0\n        \n        qry = lambda i, j: psums[j] if i == 0 else psums[j]-psums[i-1]\n        \n        ans = float('inf')\n        need = tot % p\n        for i in range(n):\n            curr = psums[i] % p\n            x = (curr - need) % p\n            if curr == need and i < n-1:\n                ans = min(ans, i+1)\n            grp = modgrps[x]\n            if len(grp) == 0: continue\n            index, jump = 0, len(grp)-1\n            while jump >= 1:\n                while index+jump<len(grp) and grp[index+jump] <= i:\n                    index += jump\n                jump //= 2\n            length = i - (grp[index]+1) + 1\n            if length > 0: ans = min(ans, length)\n        \n        return ans if ans < float('inf') else -1\n        \n        \n        \n        \n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        seen = {0: -1}\n        cur = 0\n        res = n = len(nums)\n        for i, a in enumerate(nums):\n            cur = (cur + a) % p\n            seen[cur] = i\n            if (target := (cur - need) % p) in seen:\n                res = min(res, i - seen[target])\n        return res if res < n else -1\n    \n    \n        total = sum(nums)\n        if (target := total % p) == 0:\n            return 0\n        #print(f\\\"total {total} target {target}\\\")\n        left = 0\n        prefix_sum = 0\n        seen = {}\n        ans = math.inf\n        # looking for p*x + target\n        for i, a in enumerate(nums):\n            prefix_sum += a\n            #print(f\\\"prefix_sum {prefix_sum}\\\")\n            if ((prefix_sum - target) % p) in seen:\n                ans = min(ans, i - seen[(prefix_sum - target) % p])\n            seen[prefix_sum%p] = i\n            #print(f\\\"added {prefix_sum%p}\\\")\n        return -1 if ans >= len(nums) else ans", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        '''\n        \u76ee\u6807\u662f\u627e\u5230\u4e00\u4e2a\u5b50\u4e32\u7684\u4f59\u6570\u4e3ar\n        \u5230\u5f53\u524d\u4f4d\u7f6e\u6240\u6709\u6570\u548c\u7684\u4f59\u6570\u51cf\u53bbr\u5bf9\u5e94\u7684\u4f59\u6570\u4f4d\u7f6e\uff0c\u4e2d\u95f4\u5c31\u662f\u4f59\u6570\u4e3ar\u7684\u5b50\u4e32\n        Calculate the need = sum(A) % p.\nThen one pass, record the prefix sum in a hashmap.\n\nThen the question become:\nFind the shortest array with sum % p = need.\n\nlast[remainder] = index records the last index that\n(A[0] + A[1] + .. + A[i]) % p = remainder\n        '''\n        r=sum(nums)%p\n        if r==0:\n            return 0\n        mem={0:-1}\n        s=0\n        res=len(nums)\n        for i,a in enumerate(nums):\n            s=(s+a)%p\n            t=(s+p-r)%p\n            if t in mem:\n                res=min(res,i-mem[t])\n            mem[s]=i\n        if res==len(nums):\n            return -1\n        return res", "import bisect as bi\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        if p == 1:\n            return 0\n        total_mod = 0\n        seen_mods = {}\n        for i in range(len(nums)):\n            total_mod += nums[i] % p\n            total_mod = total_mod % p\n            if total_mod not in seen_mods:\n                seen_mods[total_mod] = []\n            seen_mods[total_mod].append(i)\n        if total_mod == 0:\n            return 0\n        \n        l = len(nums)\n        sum = 0\n        for i in range(-1, len(nums) - 1):\n            if i >= 0:\n                sum = (sum + nums[i]) % p\n            compl = (sum + total_mod) % p\n            if compl not in seen_mods:\n                continue\n            comp_arr = seen_mods[compl]\n            next = bi.bisect(comp_arr, i)\n            if next < len(comp_arr) and comp_arr[next] - i < l:\n                l = comp_arr[next] - i\n        if l == len(nums):\n            return -1\n        else:\n            return l", "import numpy as np\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        nums = np.array(nums, dtype=int)\n        fullsum = nums.sum() % p\n        if fullsum == 0:\n            return 0\n        # print(fullsum)\n        res = np.inf\n        indmap = {0:-1}\n        for i,a in enumerate(nums.cumsum()):\n            subsum = (a - fullsum) %p\n            # print(i,a,subsum)\n            if subsum in indmap:\n                res = min(res, i-indmap[subsum])\n                print(res)\n            indmap[a%p] = i\n        if res == np.inf or res == len(nums):\n            return -1\n        \n        return res\n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need=sum(nums) % p\n        dp={0: -1}\n        cur=0\n        n = len(nums)\n        res = n\n        for i,a in enumerate(nums):\n            cur=(cur+a)%p\n            dp[cur]=i\n            if (cur-need)%p in dp:\n                res=min(res, i-dp[(cur-need)%p])\n        \n        return res if res<n else-1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        s = 0\n        mod = [s:=(s+n) % p for n in nums]\n        total= mod[-1]\n        if not total:\n            return 0\n        last = {0:-1}\n        res = float('inf')\n        for i , n in enumerate(mod):\n            comp = (n - total) % p\n            if comp in last:\n                res = min(res, i-last[comp])\n            last[n] = i\n        return -1 if res == len(nums) else res", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        lastest = {0: -1}\n        total = 0\n        minLeng = len(nums)\n        for i in range(len(nums)):\n            nums[i] %= p\n            total += nums[i]\n        total %= p\n        if total == 0:\n            return 0\n        for i in range(len(nums)):\n            if i > 0:\n                nums[i] = (nums[i] + nums[i - 1]) % p\n            x = (p - (p - nums[i] + total) % p) % p\n            if lastest.get(x) is not None:\n                minLeng = min(i - lastest[x], minLeng)\n            lastest[nums[i]] = i\n        if minLeng == len(nums):\n            return -1\n        return minLeng", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        if not nums:\n            return 0\n        dic = {0:[-1]}\n        if nums[0] % p not in dic:\n            dic [nums[0] % p] = []\n        dic[nums[0] % p] = [0]\n        \n        nums[0] = nums[0] % p\n        for i in range(1, len(nums)):\n            nums[i] = (nums[i] + nums[i-1]) % p\n            if nums[i] not in dic:\n                dic[nums[i]] = []\n            dic[nums[i]].append(i)\n            \n        if nums[-1] == 0:\n            return 0\n        output = len(nums)\n        for i in range(len(nums)):\n            res = (nums[i] - nums[-1]) % p\n            try:\n                output = min(output, min([i - j for j in dic[res] if j < i]))\n            except:\n                continue\n            \n        return output if output != len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        \n        \n        s=sum(nums)\n        rem=s%p\n        \n        \n        i,j,curr_rem=0,0,0\n        mi=float('inf')\n        d={0:-1}\n        while i<len(nums):\n            curr_rem=(curr_rem+nums[i])%p\n            d[curr_rem]=i\n           # print(curr_rem,rem)\n            if (curr_rem-rem)%p in d:\n               # print()\n                mi=min(mi,i-d[(curr_rem-rem)%p])\n               # print(\\\"yes\\\",i,(curr_rem-rem)%p,d)\n            i+=1         \n            \n            \n        return mi if mi!=len(nums) else -1\n                \n        \n", "\nclass Solution:\n    def minSubarray(self, nums, p):\n        total = sum(nums)\n        need = total % p\n        if need == 0:\n            return 0\n        \n        prefix = []\n        for i, n in enumerate(nums):\n            if i == 0:\n                prefix.append(n % p)\n            else:\n                prefix.append((prefix[-1] + n) % p)\n                \n        ans = len(nums)\n        seen = {0:-1}\n        for i, v in enumerate(prefix):\n            req = (v - need) % p\n            if req in seen:\n                ans = min(ans, i - seen[req])\n            seen[v] = i\n        #print(total)\n        if ans == len(nums):\n            return -1\n\n\n        return ans", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        # For each i, find j > i, s.t.\n        # suf[j] = p - pref[i].\n        index = collections.defaultdict(list)\n        n = len(nums)\n        pref = [0] * n\n        suff = [0] * n\n        for i, x in enumerate(nums):\n            pref[i] = (pref[i - 1] + x) % p if i else x % p\n        for i in range(n-1,-1,-1):\n            suff[i]=(suff[i+1]+nums[i])%p if i<n-1 else nums[i]%p\n        suff.append(0)\n        for i in range(n,-1,-1):\n            index[suff[i]].append(i)\n        ans = float('inf')\n        if 0 in index and index[0][-1] < n:\n            ans = index[0][-1]\n        for i in range(n):\n            target = (p - pref[i]) % p\n            # Find j > i.\n            while index[target] and index[target][-1] <= i:\n                index[target].pop()\n            if index[target]:\n                ans = min(ans, index[target][-1] - i - 1)\n        return ans if ans < float('inf') else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        a = [0]\n        for x in nums:\n            a.append((a[-1] + x) % p)\n        f = {0: 0}\n        k = a[-1]\n        if k == 0:\n            return 0\n        ret = 1000000000\n        for i in range(1, len(a)):\n            k2 = a[i]\n            k1 = (k2 - k + p) % p\n            if k1 in f and i - f[k1] < ret:\n                ret = i - f[k1]\n            f[k2] = i\n        if ret >= len(nums):\n            return -1\n        return ret", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        n = len(nums)\n        r = 0\n        for i, a in enumerate(nums):\n            r = (r + a) % p\n        if r == 0:\n            return 0        \n        result = n \n        s = 0\n        pos = {0: -1}\n        for i, a in enumerate(nums):\n            s = (s + a) % p\n            r1 = (s - r) % p\n            if r1 in pos:\n                result = min(result, i - pos.get(r1, -n))\n            pos[s] = i\n        return result if result < n else -1\n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        \n        total = sum(nums) \n        remainder = total % p\n        if not remainder:\n            return 0\n        ans = float('inf') \n        presum = [0]\n        remainders = {0: -1}\n        for i, n in enumerate(nums):\n            presum.append(presum[-1] + n)\n            r = ((cr := presum[-1] % p) - remainder) % p\n            if r in remainders:\n                ans = min(ans, i - remainders[r])\n            remainders[cr] = i\n        return ans if ans < len(nums) else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        n = len(nums)\n        \n        fullsum = sum(nums)\n        \n        toremove = fullsum%p\n        d = defaultdict(int)\n        d[0]=-1\n        cumsum = 0\n        answer = n\n        for index,number in enumerate(nums):\n            cumsum += number\n            cumsum = cumsum%p\n            d[cumsum]=index\n            if (cumsum-toremove)%p in d:\n                answer = min(answer,index - d[(cumsum-toremove)%p])\n        \n        if answer < n:\n            return answer\n        else: \n            return -1\n        \n        \n        \n\n                \n        \n            \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums)%p\n        dp = {0: -1}\n        cumsum = 0\n        res = float('inf')\n        for i in range(len(nums)):\n            cumsum = (cumsum + nums[i])%p\n            dp[cumsum] = i\n            if (cumsum-need)%p in dp:\n                res = min(res, i-dp[(cumsum-need)%p])\n        return res if res <len(nums) else -1", "from collections import defaultdict, Counter\nfrom bisect import bisect\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        sum_nums = sum(nums)\n        n = len(nums)\n        if sum_nums % p == 0:\n            return 0\n        desired_rem = sum_nums % p\n        mapping = defaultdict(list)\n        pref_arr = [0]\n        for i, num in enumerate(nums):\n            if num % p == desired_rem:\n                return 1\n            temp = (pref_arr[-1] + num) % p\n            mapping[temp].append(i)\n            pref_arr.append(temp)\n        \n        \n        ans = float('inf')\n        # need to find shortest subarray who's sum % p == sum_nums % p\n\n        # loop through all indices and see if sub-array possible starting at that index\n        for i in range (n + 1):\n            r = (desired_rem + pref_arr[i])%p\n            if r not in mapping:\n                continue \n            arr = mapping[r]\n            index = bisect(arr, i)\n            if index == len(arr):\n                continue\n            ans = min(ans, arr[index] - i + 1)\n        \n        return ans if ans < n else -1\n        \n        \n", "from collections import defaultdict\n\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:        \n        psums = [0]\n        for n in nums:\n            psums.append((psums[-1] + n) % p) \n        \n        ssums = [0]\n        for n in reversed(nums):\n            ssums.append((ssums[-1] + n) % p)\n            \n        ssumd = defaultdict(list)\n        for i, s in enumerate(reversed(ssums)):\n            ssumd[s].append(i)\n            \n        best = len(nums)\n        matched = set()\n        #for i, n in enumerate(psums):\n        for ri, n in enumerate(reversed(psums)):\n            i = len(psums) - ri - 1\n            match = -n % p\n            if match in matched: continue\n            for j in ssumd[match]:\n                if j >= i:\n                    best = min(best, j-i)\n                    matched.add(match)\n                    \n        if best == len(nums): return -1\n                    \n        return best\n            \n            \n", "class Solution:\n    def minSubarray(self, A: List[int], p: int) -> int:\n        need = sum(A) % p\n        dp = {0: -1}\n        cur = 0\n        res = n = len(A)\n        for i, a in enumerate(A):\n            cur = (cur + a) % p\n            dp[cur] = i\n            if (cur - need) % p in dp:\n                res = min(res, i - dp[(cur - need) % p])\n        return res if res < n else -1", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        prefix_sum_map = { 0: [-1] }\n        cur_sum = 0\n        \n        for index, num in enumerate(nums):\n            cur_sum = (cur_sum + num) % p\n            if not cur_sum in prefix_sum_map:\n                prefix_sum_map[cur_sum] = []\n            prefix_sum_map[cur_sum].append(index)\n\n        if cur_sum == 0:\n            return 0\n        \n        result = len(nums)\n        \n        for prefix_sum, index_ary in list(prefix_sum_map.items()):\n            target_sum = (prefix_sum - cur_sum) % p\n            if target_sum in prefix_sum_map:\n                target_ary = prefix_sum_map[target_sum]\n                for i in range(len(index_ary)):\n                    for j in range(len(target_ary)):\n                        if target_ary[j] > index_ary[i]:\n                            continue\n                        result = min(result, index_ary[i] - target_ary[j])\n                    \n        if result == len(nums):\n            result = -1\n        return result\n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        s = sum(nums) % p\n        if s == 0:\n            return 0\n        n = len(nums)\n        ans = n\n        \n        pre = {}\n        pre[0] = -1\n        cur = 0\n        for i, x in enumerate(nums):\n            cur += x\n            cur %= p\n            need = (cur - s + p) % p\n            if need in pre:\n                ans = min(ans, i - pre[need])\n            pre[cur] = i\n        \n        return ans if ans < n else -1\n        \n", "class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        need = sum(nums) % p\n        dp = {}\n        dp[0] = -1\n        n = len(nums)\n        res = n\n        cur = 0\n        for i, num in enumerate(nums):\n            cur = (cur + num) % p\n            dp[cur] = i\n            if (cur - need) % p in dp:\n                res = min(res, i - dp[(cur - need) % p])\n        return res if res < n else -1"]
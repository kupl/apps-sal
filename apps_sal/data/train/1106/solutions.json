["'''Well I found the bug, but I don't understand why it was doing that. I mean, as\nfar as I can tell, it shouldn't be a bug!\nNote to self: deleting from (supposedly) local lists through recursion is dangerous!'''\n\nclass Group(object):\n    def __init__(self,size,start,end,value):\n        self.size = size\n        self.start = start\n        self.end = end\n        self.value = value\n        \n    def __lt__(self,other):\n        return self.start < other.start\n    \n    def __str__(self):\n        return \"%i: %i->%i, $%i\" %(self.size,self.start,self.end,self.value)\n    \n    \ndef hash(car,i):\n    people = []\n    for group in car:\n        people.extend([group.end]*group.size)\n    people.sort()\n    return tuple(people+[i])\n    \n    \ndef optimize(groups,car,capacity,i):   \n    if i == len(groups):\n        return 0\n    \n    newcar = []\n    pos = groups[i].start\n    for group in car:\n        if group.end > pos:\n            newcar.append(group)\n        else:\n            capacity += group.size\n        \n    state = hash(newcar,i)\n    try:\n        return memo[state]\n    except:\n        v = optimize(groups,newcar,capacity,i+1) \n        if groups[i].size <= capacity:\n            w = optimize(groups,newcar+[groups[i]],capacity-groups[i].size,i+1) + groups[i].value\n        else:\n            w = 0\n            \n        if v > w:\n            ie[state] = -1\n        elif v < w:\n            ie[state] = 1\n        else:\n            ie[state] = 0\n                \n        ans = max(v,w)\n        memo[state] = ans\n        return ans\n    \ncases = int(input())\nfor case in range(cases):\n    memo = {}\n    ie = {}\n    groups = []\n    n,_,capacity = list(map(int,input().split()))\n    \n    for g in range(n):\n        size,start,end,value = list(map(int,input().split()))\n        groups.append(Group(size,start,end,value))\n    groups.sort()\n    print(optimize(groups,[],capacity,0))"]
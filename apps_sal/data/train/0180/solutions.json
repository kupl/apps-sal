["class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target: return 0\n        heap = [] #record the reachable gas for now\n        stop = 0 #total stops\n        dist = startFuel #reachable distance\n        for d, g in stations:\n            if dist >= target: #if reach target, return\n                return stop\n            while heap and dist < d: #make sure we can reach current station by make minimum stops\n                gas = heapq.heappop(heap)\n                dist += -gas\n                stop += 1\n            if dist < d: #if not reachable, return -1\n                return -1\n            heapq.heappush(heap, (-g)) #add current gas to heap for future stop\n        if dist >= target:\n                return stop\n        while heap: #add the rest gas in heap from max to min to reach the target\n            g = heapq.heappop(heap)\n            stop += 1\n            dist += -g\n            if dist >= target:\n                return stop\n        return -1\n        \n                \n                \n            \n        \n                \n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target:\n            return 0\n        if not stations:\n            return -1\n\n        fdelta = startFuel-stations[0][0]\n        if fdelta < 0:\n            return -1\n\n        curr = [fdelta + stations[0][1], fdelta]\n\n        for i, sta in enumerate(stations[1:]):\n            treck = sta[0] - stations[i][0]\n            leftover = curr[0]-treck\n            if leftover < 0:\n                return -1\n            nex = [leftover + sta[1], leftover]\n            for j, f in enumerate(curr[1:]):\n                leftover = curr[j+1] - treck\n                if leftover < 0:\n                    break\n                else:\n                    nex[-1] = max(nex[-1], leftover+sta[1])\n                    nex.append(leftover)\n\n            curr = nex\n\n        leftover = target - stations[-1][0]\n\n        while curr and curr[-1] < leftover:\n            curr.pop()\n\n        return len(stations) - len(curr) + 1 if curr else -1", "import heapq\n\n\nclass Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        stops = 0\n        max_gas_heap = []\n        can_drive_to = startFuel\n        i = 0\n        while can_drive_to < target:\n            # push stations to heap\n            while i < len(stations) and stations[i][0] <= can_drive_to:\n                heapq.heappush(max_gas_heap, -stations[i][1])\n                i += 1\n            \n            if not max_gas_heap:\n                return -1\n            can_drive_to -= heapq.heappop(max_gas_heap)\n            stops += 1\n\n        return stops\n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target:\n            return 0\n        n = len(stations)\n        dp = [0]*(n+1)\n        dp[0] = startFuel\n        \n        \n        for i in range(1, n+1):\n            for j in range(i, 0, -1):\n                if dp[j-1] >= stations[i-1][0]:\n                    # use station i-1\n                    dp[j] = max(dp[j], dp[j-1] + stations[i-1][1])\n                \n        for i in range(1, n+1):\n            if dp[i] >= target:\n                return i\n        return -1", "import heapq\nclass Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        point=0\n        level=0\n        gas=startFuel\n        if gas>=target:\n            return level\n        heap=[]\n        stations.append([target+1,float('inf')])\n        for pos,gas_add in stations:\n            if gas>=pos:\n                heapq.heappush(heap,-gas_add)\n            else:\n                while heap:\n                    gasmin=heapq.heappop(heap)\n                    gas-=gasmin\n                    level+=1\n                    if gas>=target:\n                        return level\n                    if gas>=pos:\n                        heapq.heappush(heap,-gas_add)\n                        break\n        return -1\n                \n                \n        \n       \n            \n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target:\n            return 0\n        if startFuel < target and not stations:\n            return -1\n        dp = [startFuel] + [0] * len(stations)\n        for i, val in enumerate(stations):\n            for t in range(i, -1, -1):\n                if dp[t] >= val[0]:\n                    dp[t+1] = max(dp[t+1], dp[t] + val[1])\n        for i, d in enumerate(dp):\n            if d >= target:\n                return i\n        return -1", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n#         if startFuel >= target:\n#             return 0\n\n#         @lru_cache(maxsize=None)\n#         def helper(startIdx, litre, target):\n#             if litre >= target:\n#                 return 0\n\n#             result = float('inf')\n#             for idx in range(startIdx + 1, len(stations)):\n#                 if startIdx == -1:\n#                     n_miles = stations[idx][0]\n#                 else:    \n#                     n_miles = stations[idx][0] - stations[startIdx][0]\n\n#                 remain = litre - n_miles\n#                 if remain >= 0:\n#                     result = min(result, 1 + helper(idx, remain + stations[idx][1], target - n_miles))\n#             return result\n\n#         result = helper(-1, startFuel, target)\n#         return -1 if result == float('inf') else result\n\n#-----------------------------------------------------------------------------\n\n#         if startFuel >= target:\n#             return 0\n\n#         heap = []\n\n#         idx = n_stations = 0\n#         maxDistance = startFuel\n\n#         while maxDistance < target:\n#             while idx < len(stations) and stations[idx][0] <=maxDistance:\n#                 heapq.heappush(heap, -stations[idx][1])\n#                 idx += 1\n\n#             if not heap:\n#                 return -1\n\n#             maxDistance += (-heapq.heappop(heap))\n#             n_stations += 1\n#         return n_stations\n\n#-----------------------------------------------------------------------------\n\n#         if startFuel >= target:\n#             return 0\n\n#         length = len(stations)\n#         dp = [[0] * (1 + length) for _ in range(1 + length)]\n#         for i in range(1 + length):\n#             dp[i][0] = startFuel\n\n#         result = float('inf')\n#         for i in range(1 + length):\n#             for j in range(1, i + 1):\n#                 if j <= i - 1:\n#                     dp[i][j] = max(dp[i][j], dp[i - 1][j])\n\n#                 if dp[i - 1][j - 1] >= stations[i - 1][0]:\n#                     dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + stations[i - 1][1])\n\n#                 if dp[i][j] >= target:\n#                     result = min(result, j)\n#         return -1 if result == float('inf') else result\n\n#-----------------------------------------------------------------------------\n        \n        if startFuel >= target:\n            return 0\n        \n        length = len(stations)\n        dp = [startFuel] + [0] * length\n        result = float('inf')\n        for i in range(1 + length):\n            for j in range(i, 0, -1):\n                if dp[j - 1] >= stations[i - 1][0]:\n                    dp[j] = max(dp[j], dp[j - 1] + stations[i - 1][1])\n\n                if dp[j] >= target:\n                    result = min(result, j)\n        return -1 if result == float('inf') else result", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target : return 0\n        \n        pq = []\n        minStops = i = 0\n        curr = startFuel\n        \n        while curr < target:\n            while i < len(stations) and curr >= stations[i][0]:\n                heapq.heappush(pq, -stations[i][1])\n                i += 1\n            if not pq: return -1\n            curr += -heapq.heappop(pq)\n            minStops +=1\n        return minStops\n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        \n        if startFuel >= target:\n            return 0\n        \n        from heapq import heapify, heappop, heappush\n        \n        dis = startFuel\n        heap = []\n        stations = stations[::-1] \n        while stations and stations[-1][0] <= dis:\n            s = stations.pop()\n            heap.append((-s[1], s[0]))\n            \n        heapify(heap)\n        \n        \n        stops = 0\n        \n        while heap:\n            \n            most_fuel = heappop(heap)\n            stops += 1\n            dis += (-most_fuel[0])\n            if dis >= target:\n                return stops\n            while stations and stations[-1][0] <= dis:\n                s = stations.pop()\n                heappush(heap, (-s[1], s[0]))\n            \n        return -1\n            \n            \n        \n", "class Solution:\n    def minRefuelStops(self, target, startFuel, stations):\n        stations.append([target, 0])\n        stations.sort(reverse=True)\n        curr, tank = 0, startFuel\n        ans = 0\n        refuels = []\n        while curr + tank < target:\n            pos, gas = stations.pop()\n            if pos <= curr+tank:\n                heapq.heappush(refuels, -gas)\n            else:\n                curr += tank\n                tank = 0\n                while curr+tank < pos and refuels:\n                    ans += 1\n                    tank -= heapq.heappop(refuels)\n                if curr+tank < pos:\n                    return -1\n                heapq.heappush(refuels, -gas)\n        return ans", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        \n        q=[]\n        extent = startFuel\n        \n        ans = 0\n        for i in range(len(stations)):\n            if extent>=target:\n                return ans\n            \n            loc, fuel = stations[i]\n            while q and loc>extent :\n                extent += -heapq.heappop(q)\n                ans+=1\n            \n            if loc>extent:\n                return -1\n            \n            heapq.heappush(q, -fuel)\n            \n        while q and extent<target:\n            extent+=-heapq.heappop(q)\n            ans+=1\n        \n        if extent>=target:\n            return ans\n        else:\n            return -1\n                \n                \n                \n                \n            \n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        \n        q=[]\n        extent = startFuel\n        \n        ans = 0\n        for i in range(len(stations)):\n            if extent>=target:\n                return ans\n            \n            loc, fuel = stations[i]\n            print((i, loc, extent))\n            while q and loc>extent :\n                extent += -heapq.heappop(q)\n                ans+=1\n            \n            if loc>extent:\n                return -1\n            \n            heapq.heappush(q, -fuel)\n            \n        while q and extent<target:\n            extent+=-heapq.heappop(q)\n            ans+=1\n        \n        if extent>=target:\n            return ans\n        else:\n            return -1\n                \n                \n                \n                \n            \n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        pq = []\n        idx = 0 \n        cur = startFuel\n        res = 0\n        while cur < target: \n            while idx < len(stations) and cur >= stations[idx][0]:\n                heapq.heappush(pq, -stations[idx][1])\n                idx += 1\n            if not pq: return -1 \n            cur -= heapq.heappop(pq)\n            res += 1\n        return res\n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target:\n            return 0\n        \n        if not stations:\n            return -1\n        \n        steps = 0\n        i = 0\n        pq = []\n        \n        while startFuel < target:\n            while i < len(stations) and stations[i][0] <= startFuel:\n                heapq.heappush(pq, -stations[i][1])\n                i += 1\n            \n            if not pq:\n                return -1\n            else:\n                startFuel -= heapq.heappop(pq)\n                steps += 1\n            \n                    \n        return steps", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        heap = []\n        queue = deque()\n        i = 0\n        num_stations = 0\n        \n        while startFuel < target:\n            while i < len(stations) and startFuel >= stations[i][0]:\n                heapq.heappush(heap, (-stations[i][1]))\n                i += 1\n            \n            if not heap:\n                return -1\n            \n            next_fuel = heapq.heappop(heap)\n            startFuel -= next_fuel\n            num_stations += 1\n        \n        return num_stations", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target:\n            return 0\n\n        N = len(stations)\n\n        # We will try different number of stops. Initial state num_stops=0.\n        # memo[num_stations] = max_mile we can reach if only available\n        # first num_stations, and we make exactly num_stops\n\n        prev_memo = [startFuel] * (N + 1)\n\n        for num_stops in range(1, N + 1):\n            memo = [-1] * (N + 1)\n\n            a = -1\n            for num_stations in range(num_stops, N + 1):\n                station_mile, station_fuel = stations[num_stations - 1]\n                # a = memo[num_stations - 1]\n                # Optimization: a is available from previous loop,\n                # so don't need to access it from memo[]\n                b = prev_memo[num_stations - 1]\n                if b >= station_mile:  # Check if we can reach this station\n                    a = max(a, b + station_fuel)\n                if a != -1:\n                    memo[num_stations] = a\n\n            # if memo[N] >= target:\n            if a >= target:\n                return num_stops\n\n            prev_memo = memo\n\n        return -1", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target:\n            return 0\n\n        N = len(stations)\n\n        # We will try different number of stops. Initial state num_stops=0.\n        # memo[num_stations] = max_mile we can reach if only available\n        # first num_stations, and we make exactly num_stops\n\n        prev_memo = [startFuel] * (N + 1)\n\n        for num_stops in range(1, N + 1):\n            memo = [-1] * (N + 1)\n\n            a = -1\n            for num_stations in range(num_stops, N + 1):\n                station_mile, station_fuel = stations[num_stations - 1]\n                # a = memo[num_stations - 1]\n                # Optimization: a is available from previous loop,\n                # so don't need to access it from memo[]\n                b = prev_memo[num_stations - 1]\n                if b >= station_mile:  # Check if we can reach this station\n                    a = max(a, b + station_fuel)\n                memo[num_stations] = a\n\n            # if memo[N] >= target:\n            if a >= target:\n                return num_stops\n\n            prev_memo = memo\n\n        return -1", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel>=target:\n            return 0\n        stations.sort(reverse=True)\n        fuel=startFuel\n        heap=[]\n        out=0\n        while stations:\n            while stations and fuel>=stations[-1][0]:\n                t,val=stations.pop()\n                if t>=target:\n                    return out\n                heapq.heappush(heap,-val)\n            if heap:\n                fuel-=heapq.heappop(heap)\n                out+=1\n                if fuel>=target:\n                    return out\n            else:\n                break\n        while heap and fuel<target:\n            fuel-=heapq.heappop(heap)\n            out+=1\n        if fuel<target:\n            return -1\n        return out", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target:\n            return 0\n\n        N = len(stations)\n\n        # We will try different number of stops. Initial state num_stops=0.\n        # memo[num_stations] = max_mile we can reach if only available\n        # first num_stations, and we make exactly num_stops\n\n        prev_memo = [startFuel] * (N + 1)\n\n        for num_stops in range(1, N + 1):\n            memo = [-1] * (N + 1)\n\n            a = -1\n            for num_stations in range(num_stops, N + 1):\n                station_mile, station_fuel = stations[num_stations - 1]\n                # a = memo[num_stations - 1]\n                # Optimization: a is available from previous loop,\n                # so don't need to access it from memo[]\n                b = prev_memo[num_stations - 1]\n                if b >= station_mile:  # Check if we can reach this station\n                    b += station_fuel\n                    a = max(a, b)\n                if a != -1:\n                    memo[num_stations] = a\n\n            # if memo[N] >= target:\n            if a >= target:\n                return num_stops\n\n            prev_memo = memo\n\n        return -1", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if target <= startFuel:\n            return 0\n        dpRefuels = [-1] * len(stations)\n        for i in range(len(stations)):\n            if stations[i][0] <= startFuel:\n                dpRefuels[i] = stations[i][1] + startFuel\n                if dpRefuels[i] >= target:\n                    return 1\n            \n        for k in range(1, len(stations)):\n            # use k stations to reach target\n            maxPrevFuel = dpRefuels[k-1]\n            for i in range(k, len(stations)):\n                # the i-th station would be the k-th refuel at each iteration\n                temp = max(maxPrevFuel, dpRefuels[i])\n                if maxPrevFuel >= stations[i][0]:\n                    dpRefuels[i] = maxPrevFuel + stations[i][1]\n                if dpRefuels[i] >= target:\n                    return k + 1\n                maxPrevFuel = temp\n                \n        return -1\n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        fuel = startFuel\n        del startFuel\n        i = 0\n        while target > fuel:\n            target -= fuel\n            stations = [[dist-fuel, gas] for dist, gas in stations]\n            try:\n                j, fuel = max([[j, gas]\n                               for j, (dist, gas) \n                               in enumerate(stations) \n                               if dist <= 0], \n                               key=lambda stop: stop[1])\n            except ValueError:\n                return -1\n            if fuel == 0:\n                return -1\n            stations[j][1] = 0\n            i += 1\n        return i", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if target <= startFuel:\n            return 0\n        dpRefuels = [[-1] * len(stations) for _ in range(len(stations))]\n        for i in range(len(stations)):\n            if stations[i][0] <= startFuel:\n                dpRefuels[0][i] = stations[i][1] + startFuel\n                if dpRefuels[0][i] >= target:\n                    return 1\n            \n        for k in range(1, len(stations)):\n            # use k stations to reach target\n            maxPrevFuel = dpRefuels[k-1][k-1]\n            for i in range(k, len(stations)):\n                # the i-th station would be the k-th refuel at each iteration\n                if maxPrevFuel >= stations[i][0]:\n                    dpRefuels[k][i] = maxPrevFuel + stations[i][1]\n                if dpRefuels[k][i] >= target:\n                    return k + 1\n                maxPrevFuel = max(maxPrevFuel, dpRefuels[k-1][i])\n        return -1\n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target: return 0\n        if not stations: return -1\n        data = []\n\n        for k in range(len(stations)):\n            data.append([stations[k][0]-(stations[k-1][0] if k > 0 else 0), stations[k][1]])\n        data.append([target-stations[-1][0],0])\n\n        # data is a list of [how far you have to go to reach station x from previous station, how much gas you get at station x]\n        # we add a \\\"station\\\" at the target with 0 gas... we want to see if we can reach this spot\n        \n        # let's check if we made all stops, we could make it\n        tot = startFuel\n        for dist,gas in data:\n            tot -= dist            \n            if tot < 0: return -1\n            tot += gas\n        \n        N = len(data)\n        \n        # maxFuel represents how much fuel you could have at this station \n        maxFuel = [float('-inf')] * N  \n        \n        # let's start with 0 stops\n        tot = startFuel\n        for k in range(N):\n            dist,_ = data[k]\n            tot -= dist\n            if tot < 0: break            \n            maxFuel[k] = tot\n            \n        #print('after 0 stops',maxFuel)\n            \n        # let's do 1 stop separately as well\n        nextMaxFuel = [float('-inf')] * N\n        nextMaxFuel[0] = maxFuel[0] + data[0][1]\n        for k in range(1,N):\n            dist,gas = data[k]\n            if maxFuel[k] != float('-inf'):\n                nextMaxFuel[k] = maxFuel[k]+gas\n            if nextMaxFuel[k-1] >= dist:\n                nextMaxFuel[k] = max(nextMaxFuel[k], nextMaxFuel[k-1]-dist)\n            if nextMaxFuel[k] == float('-inf'):\n                break\n        \n        if nextMaxFuel[-1] >= 0: return 1\n        \n        maxFuel = nextMaxFuel\n        \n        #print('after 1 stop',maxFuel)\n\n        for nStops in range(2, N+1):\n            nextMaxFuel = [float('-inf')] * N            \n            for k in range(nStops-1, N):\n                dist,gas = data[k]\n                if maxFuel[k-1] != float('-inf') and maxFuel[k-1] >= dist: # i.e., we could make it to the station with nStops-1\n                    nextMaxFuel[k] = maxFuel[k-1] - dist + gas\n                if nextMaxFuel[k-1] >= dist:\n                    nextMaxFuel[k] = max(nextMaxFuel[k], nextMaxFuel[k-1]-dist) # i.e., don't stop at this station, use prior result\n                if nextMaxFuel[k] == float('-inf'):\n                    break # we won't be able to get to later stations either\n            #print('after',nStops,'stops',nextMaxFuel)\n            if nextMaxFuel[-1] >= 0: return nStops\n            maxFuel = nextMaxFuel\n           \n        return -1\n            \n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        stations = [[0,startFuel]] + sorted(stations)\n        n = len(stations)        \n        reach = [-float('inf')]*n\n        reach[0] = startFuel\n        st = [startFuel]*n\n        flag = True\n        cnt = 0\n        if target <= startFuel:\n            return 0\n        while flag:\n            flag = False\n            cnt += 1\n            for i in range(1,len(reach))[::-1]:\n                p, g = stations[i]\n                st.pop()\n                if p <= st[-1] and st[-1] + g > reach[i]:\n                    reach[i] = st[-1] + g\n                    flag = True\n                    if reach[i] >= target:\n                        return cnt\n            for i in range(1,len(reach)):\n                st.append(max(st[-1],reach[i]))\n            \n        return -1", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        # dp[i]: (a, b). a-> the longest distance a car can travel with i refuels\n        #                b-> the location(distance) of fuels already used\n       \n        dp=[[startFuel,[]]]\n        for i in range(len(stations)):\n            if dp[-1][0]>=target:\n                break\n            #print(\\\" \\\")\n            #print(dp)\n            usedStations=dp[-1][1]\n            #print(usedStations)\n            # reachable stations\n            usable_stations=[s for s in stations if s[0]<=dp[-1][0] and s[0] not in usedStations]\n            usable_stations.sort(key=lambda x:x[1])\n            if len(usable_stations)==0:\n                break\n            #print(usable_stations)\n            dp.append([dp[-1][0]+usable_stations[-1][1], dp[-1][1].copy()])\n            dp[-1][1].append(usable_stations[-1][0])\n\n        return len(dp)-1 if dp[-1][0]>=target else -1\n        \n            \n            \n        \n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        n = len(stations)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        \n        for row in dp:\n            row[0] = startFuel\n    \n        if startFuel >= target: return 0\n        for refuels in range(1, n+1):\n            for stas in range(refuels, n+1):\n                station = stations[stas-1]\n                dp[stas][refuels] = dp[stas-1][refuels]\n                if dp[stas-1][refuels-1] >= station[0]:\n                    dp[stas][refuels] = max(station[1] + dp[stas-1][refuels-1], dp[stas][refuels])\n\n            if dp[n][refuels] >= target: return refuels\n            \n        return -1\n    \n    \n    \n    \n    \n#             for refue in range(1, n + 1):\n#             for station in range(1, n + 1):\n#                 dp[station][refue] = dp[station - 1][refue]\n#                 if dp[station - 1][refue - 1] >= stations[station - 1][0]:\n#                     dp[station][refue] = max(dp[station - 1][refue - 1] + stations[station - 1][1], dp[station][refue])\n                \n#             if dp[n][refue] >= target:\n#                 return refue\n        \n#         return -1\n", "\nclass Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        return self.dp(target, startFuel, stations)\n    \n    def dp(self, target, startFuel, stations):\n        if startFuel >= target:\n            return 0\n        if not stations:\n            return -1\n        \n        # A[t][i] = max distance using first i stations and stop t times (t<=i)\n        # A[t][i] = max(\n        #    A[t][i-1],\n        #    A[t-1][i-1] + stations[i-1][1] if A[t-1][i-1] >= stations[i-1][0]\n        \n        n = len(stations)\n        A = [[0] * (n+1) for _ in range(n+1)]\n        \n        for i in range(n+1):\n            A[0][i] = startFuel\n        \n        for t in range(1, n+1):\n            for i in range(1, n+1):\n                if t <= i:\n                    A[t][i] = A[t][i-1]\n                    if A[t-1][i-1] >= stations[i-1][0]:\n                        A[t][i] = max(A[t][i], A[t-1][i-1] + stations[i-1][1])\n            if A[t][-1] >= target:\n                return t\n            \n        return -1\n    \n    \n    def rec1(self, target, startFuel, stations, position, station_idx_start):\n        if position >= target or startFuel >= (target - position):\n            #print(target, startFuel, stations, position)\n            return 0\n        else:\n            candidates = []\n            for idx in range(station_idx_start, len(stations)):\n                p, f = stations[idx]\n                d = p - position\n                valid = d > 0 and startFuel - d >= 0\n                if valid:\n                    candidates.append(1 + self.rec(\n                        target, \n                        startFuel - d + f, \n                        stations, \n                        p,\n                        station_idx_start + 1))\n                if startFuel - d < 0:\n                    break\n            \n            if not candidates:\n                return float('inf')\n            else:\n                return min(candidates)", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        n = len(stations)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        \n        for row in dp:\n            row[0] = startFuel\n    \n        if startFuel >= target: return 0\n        \n        for refuels in range(1, n+1):\n            for stas in range(1, n+1):\n                station = stations[stas-1]\n                dp[stas][refuels] = dp[stas-1][refuels]\n                if dp[stas-1][refuels-1] >= station[0]:\n                    dp[stas][refuels] = max(station[1] + dp[stas-1][refuels-1], dp[stas][refuels])\n\n            if dp[n][refuels] >= target: return refuels\n            \n        return -1\n    \n    \n    \n    \n    \n#             for refue in range(1, n + 1):\n#             for station in range(1, n + 1):\n#                 dp[station][refue] = dp[station - 1][refue]\n#                 if dp[station - 1][refue - 1] >= stations[station - 1][0]:\n#                     dp[station][refue] = max(dp[station - 1][refue - 1] + stations[station - 1][1], dp[station][refue])\n                \n#             if dp[n][refue] >= target:\n#                 return refue\n        \n#         return -1\n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        # f[i,j], the maximum full one can have, using j stations, stop at station i, \n        # f[i,j] = f[i],  j implied by iteration\n        if target<=startFuel:\n            return 0\n        \n        stations=[[0, startFuel]]+stations\n        print(stations)\n        N=len(stations)\n        f = [startFuel-stations[i][0] for i in range(N)]\n        f[0]=startFuel\n        \n        \n        print(f)\n        for j in range(N):\n            g = [-1]*(N)\n            g[0]=f[0]\n            for i in range(N-1,0,-1):\n                if f[i-1]-(stations[i][0]-stations[i-1][0])>=0:\n                    g[i]=f[i-1]+stations[i][1]-(stations[i][0]-stations[i-1][0])\n                \n            for i in range(1,N):\n                g[i]=max(g[i-1]-(stations[i][0]-stations[i-1][0]), g[i])\n            \n            f = g\n            if f[-1]>=(target-stations[-1][0]):\n                return j+1\n            \n        return -1\n                \n            \n", "class Solution:\n    def minRefuelStops(self, t: int, f: int, st: List[List[int]]) -> int:\n        if f >= t: return 0\n        if st == []: return -1\n        if f < st[0][0]: return -1\n        li,li1 = [],[]\n        for i,j in st:\n            li.append(i)\n            li1.append(j)\n        count = 0\n        while f <  t:\n            s,tur = 0,[]            \n            for i in li:\n                if f >= i: \n                    s = li.index(i)\n                    tur.append(True)\n                else: tur.append(False)\n            print(tur)\n            if all(i == False for i in tur): return -1\n            f += max(li1[0:s+1])\n            li.pop(li1.index(max(li1[0:s+1])))\n            li1.remove(max(li1[0:s+1]))\n            count +=1\n        return count", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if target<=startFuel:\n            return 0\n        \n        dp=[[0 for _ in range(len(stations)+1)] for _ in range(len(stations)+1)]\n        for i in range(len(stations)+1):\n            dp[i][0]=startFuel\n            \n        for i in range(1, len(stations)+1):\n            for j in range(1, len(stations)+1):\n                dp[j][i]=dp[j-1][i]\n                \n                if dp[j-1][i-1]>=stations[j-1][0]:\n                    dp[j][i]=max(dp[j][i], dp[j-1][i-1]+stations[j-1][1])\n                \n            if dp[j][i]>=target:\n                return i\n            \n        return -1", "from functools import lru_cache\n\n\nclass Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        \n        @lru_cache(None)\n        def farthest_of_first_n_with_stops(n, stops):\n            if n == 0 or stops == 0:\n                return startFuel\n\n            dont_refuel_now = farthest_of_first_n_with_stops(n - 1, stops)\n            refuel_now = farthest_of_first_n_with_stops(n - 1, stops - 1)\n            x, fuel = stations[n - 1]\n            if refuel_now < x:  # can't reach stations[n - 1]\n                return dont_refuel_now\n            else:\n                return max(dont_refuel_now, fuel + refuel_now)\n\n        for stops in range(len(stations) + 1):\n            # print(farthest_of_first_n_with_stops(len(stations), stops))\n            if farthest_of_first_n_with_stops(len(stations), stops) >= target:\n                return stops\n\n        return -1\n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        @lru_cache(maxsize=None)\n        def solve(s: int, stops: int) -> int:\n            if stops == 0 or s < 0:\n                return startFuel\n            \n            return max(solve(s - 1, stops), (sub + stations[s][1]) if (sub := solve(s - 1, stops - 1)) >= stations[s][0] else 0)\n        \n        for i in range(len(stations) + 1):\n            if solve(len(stations) - 1, i) >= target:\n                return i\n        \n        return -1", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target:\n            return 0\n        if not stations:\n            return -1\n        import heapq\n        queue = [-f for i,f in stations if i <= startFuel]\n        heapq.heapify(queue)\n        fuel = startFuel\n        start = max([i for i in range(len(stations)) if stations[i][0] <= startFuel] + [-1]) + 1\n        result = 0\n        while queue and fuel < target:\n            fuel -= heapq.heappop(queue)\n            result += 1\n            while start < len(stations) and fuel >= stations[start][0]:\n                heapq.heappush(queue, -stations[start][1])\n                start += 1\n        return result if fuel >= target else -1", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if target==startFuel:\n            return 0\n        \n        stations=[startFuel]+stations\n        dp=[0]*len(stations)\n        dp[0]=(startFuel)\n        for i in range(1, len(stations)):\n            j=i-1\n            while j>=0:\n                totalFuel=dp[j]+stations[i][1] \n                if dp[j] >=stations[i][0] and totalFuel>=dp[j+1]:\n                    dp[j+1]=(totalFuel)\n                j-=1\n        # print(dp)\n        for i,fuel in enumerate(dp):\n            if fuel>=target:return i\n        return -1", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if target <= startFuel:\n            return 0\n        \n        if not stations:\n            return -1\n        \n        dp = [startFuel]\n        stops = 0\n        lastd = 0\n        for d, fuel in stations:\n            for i in range(stops, len(dp)):\n                dp[i] -= d - lastd\n                if dp[i] < 0:\n                    stops = i + 1\n            \n            if stops == len(dp):\n                return -1\n            \n            dp.append(dp[-1] + fuel)\n            for i in range(len(dp) - 2, stops, -1):\n                dp[i] = max(dp[i], dp[i - 1] + fuel)\n                \n            if dp[stops] >= target - d:\n                return stops\n            \n            lastd = d\n        \n        while stops < len(dp):\n            if dp[stops] >= target - lastd:\n                return stops\n            stops += 1\n        \n        return -1\n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        if startFuel >= target: return 0\n        heap = []\n        for d, g in stations:\n            heapq.heappush(heap, (-g, d))\n        dist = startFuel\n        stop = 0\n        dist = startFuel\n        tmp = []\n        while heap:\n            g, d = heapq.heappop(heap)\n            if d <= dist:\n                dist += -g\n                if dist >= target:\n                    return stop + 1\n                for el in tmp:\n                    heapq.heappush(heap, el)\n                tmp = []\n                stop += 1\n            else:\n                tmp.append((g, d))\n        return -1\n        \n                \n                \n            \n        \n                \n", "class Solution:\n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n        stations = [[0,0]] + stations\n        heap = [(0, 0, -startFuel)]\n        seen = {}\n        while heap:\n            stop, pos, fuel = heappop(heap)\n            pos = -pos\n            fuel = -fuel\n            \n            if pos in seen and seen[pos] >= fuel:\n                continue\n            seen[pos] = fuel\n            \n            if stations[pos][0] + fuel >= target:\n                return stop\n            \n            if pos+1 < len(stations) and fuel >= stations[pos+1][0] - stations[pos][0]:\n                new_fuel = fuel - (stations[pos+1][0] - stations[pos][0])\n                heappush(heap, (stop+1, -(pos+1), -(new_fuel + stations[pos+1][1])))\n                heappush(heap, (stop, -(pos+1), -new_fuel))\n        return -1\n"]
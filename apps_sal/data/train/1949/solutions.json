["class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        height = len(grid)\n        width = len(grid[0])\n        max_path = 0\n        \n        # generator for legal indices to check\n        def index_gen(index):\n            i,j = index\n            if i > 0 and grid[i-1][j] > 0:\n                yield (i-1, j)\n            if i < height - 1 and grid[i+1][j] > 0:\n                yield (i+1, j)\n            if j > 0 and grid[i][j-1] > 0:\n                yield (i, j-1)\n            if j < width - 1 and grid[i][j+1] > 0:\n                yield (i, j+1)\n        \n        # if a node branches off in 2 directions it can't be a leaf\n        def is_viable(index):\n            non_zero = 0\n            neighbors = [grid[a][b] for a,b in index_gen(index)]\n            for x in neighbors:\n                if x != 0:\n                    non_zero += 1\n            return non_zero < 2\n        \n        def dfs(index, count):\n            nonlocal max_path\n            count += grid[index[0]][index[1]]\n            max_path = max(max_path, count)\n            grid[index[0]][index[1]] *= -1   # clever idea from George Zhou to mark visited\n            for direction in index_gen(index):\n                dfs(direction, count)\n            grid[index[0]][index[1]] *= -1   # unmark node when done with this path\n                    \n        for i in range(height):\n            for j in range(width):\n                if grid[i][j] != 0 and is_viable((i,j)):\n                    dfs((i,j), 0)\n    \n        # if there are no 'leaf' nodes, then every node is accessible\n        return max_path if max_path > 0 else sum(sum(row) for row in grid )\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        height = len(grid)\n        width = len(grid[0])\n        max_path = 0\n        \n        # generator for legal indices to check\n        def index_gen(index):\n            i,j = index\n            if i > 0 and grid[i-1][j] > 0:\n                yield (i-1, j)\n            if i < height - 1 and grid[i+1][j] > 0:\n                yield (i+1, j)\n            if j > 0 and grid[i][j-1] > 0:\n                yield (i, j-1)\n            if j < width - 1 and grid[i][j+1] > 0:\n                yield (i, j+1)\n        \n        # if a node branches off in 2 directions it can't be a leaf\n        def is_viable(index):\n            non_zero = 0\n            neighbors = [grid[a][b] for a,b in index_gen(index)]\n            for x in neighbors:\n                if x != 0:\n                    non_zero += 1\n            return non_zero < 2\n        \n        def dfs(index, count):\n            nonlocal max_path\n            count += grid[index[0]][index[1]]\n            max_path = max(max_path, count)\n            grid[index[0]][index[1]] *= -1   # clever idea from George Zhou to mark visited\n            for direction in index_gen(index):\n                dfs(direction, count)\n            grid[index[0]][index[1]] *= -1   # unmark node when done with this path\n                    \n        for i in range(height):\n            for j in range(width):\n                if grid[i][j] != 0 and is_viable((i,j)):\n                    dfs((i,j), 0)\n    \n        # if there are no 'leaf' nodes, then every node is accessible\n        return max_path if max_path > 0 else sum(sum(row) for row in grid )\n        \n        '''\n        if len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n        \n        def collectGold(r, c, goldSoFar):\n            \n            pts = [[0,1],[1,0],[-1,0],[0,-1]]\n            \n            maxGold = goldSoFar\n            \n            for p in pts:\n                nR = p[0] + r\n                nC = p[1] + c\n                \n                if 0 <= nR < len(grid) and 0<= nC < len(grid[0]) and grid[nR][nC] != 0:\n                    v = grid[nR][nC]\n                    grid[nR][nC] = 0\n                    gold = collectGold(nR, nC, goldSoFar + v)\n                    maxGold = max(gold, maxGold)\n                    grid[nR][nC] = v\n                    \n            return maxGold\n        \n        maxGold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    v = grid[i][j]\n                    grid[i][j] = 0\n                    gold = collectGold(i, j, v)\n                    maxGold = max(maxGold, gold)\n                    grid[i][j] = v\n        return maxGold\n        '''\n        \n", "class Solution:\n    def getDegree(self, i, j, grid: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        get graph-degree of coord (i,j)\n        \\\"\\\"\\\"\n        if grid[i][j] == 0:\n            return 0\n        deg = 0\n        if i > 0 and grid[i-1][j] > 0:\n            deg += 1\n        if i < len(grid) - 1 and grid[i+1][j] > 0:\n            deg += 1  \n        if j > 0 and grid[i][j-1] > 0:\n            deg += 1\n        if j < len(grid[0]) - 1 and grid[i][j+1] > 0:\n            deg += 1\n        return deg\n    \n    \n    def traverseMaxGoldDfs(self, i, j, grid) -> int:\n        \\\"\\\"\\\"\n        use dfs (with conditions) to get the max gold from starting coord (i,j)\n        \\\"\\\"\\\"\n        \n        temp = grid[i][j]\n        grid[i][j] = 0\n        gold = temp\n        goldRes = 0\n        if i > 0 and grid[i-1][j] > 0:\n            goldRes = max(goldRes, self.traverseMaxGoldDfs(i-1, j, grid))\n        if i < len(grid) - 1 and grid[i+1][j] > 0:\n            goldRes = max(goldRes, self.traverseMaxGoldDfs(i+1, j, grid))\n        if j > 0 and grid[i][j-1] > 0:\n            goldRes = max(goldRes, self.traverseMaxGoldDfs(i, j-1, grid))\n        if j < len(grid[0]) - 1 and grid[i][j+1] > 0:\n            goldRes = max(goldRes, self.traverseMaxGoldDfs(i, j+1, grid))\n            \n        gold = max(gold, temp + goldRes)  \n        grid[i][j] = temp\n        return gold\n    \n\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        maxGold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                degree = self.getDegree(i, j, grid)\n                # don't bother checking degree 2, since it is neither a 'junction' nor a 'leaf'\n                # of the search tree\n                if grid[i][j] > 0 and (degree <= 1 or degree > 2):\n                    # traverse using bfs from here. \n                    gold = self.traverseMaxGoldDfs(i, j, grid)\n                    if gold > maxGold:\n                        maxGold = gold\n        return maxGold\n                    ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        a = len(grid)\n        b = len(grid[0])\n        gold = 0\n        visited = [[False for y in range(b)] for x in range(a)]\n        \n        def maxgoldpath(x,y,visited):\n            if (x < 0) or (x >= a) or (y < 0) or (y >= b) or (grid[x][y] == 0) or (visited[x][y]):\n                return 0\n            else:\n                visited[x][y] = True\n                left = maxgoldpath(x,y-1,visited) \n                right = maxgoldpath(x,y+1,visited)\n                top = maxgoldpath(x-1,y,visited)\n                down = maxgoldpath(x+1,y,visited)\n                visited[x][y] = False\n                return max(left+grid[x][y],right+grid[x][y],top+grid[x][y],down+grid[x][y])\n        \n        for x in range(a):\n            for y in range(b):\n                if grid[x][y] > 0:\n                    gold = max(gold,maxgoldpath(x,y,visited))\n        return gold\n        \n", "\n'''class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:       \n        rLen = len(grid)\n        if rLen == 0:\n            return 0 \n        cLen = len(grid[0])\n        if cLen == 0:\n            return 0 \n        res = 0 \n        resPath = []\n        for i in range(rLen):\n            for j in range(cLen):\n                if grid[i][j] != 0 and [i,j] not in resPath:\n                    tmp, path = self.dfs(grid, i,j,rLen, cLen)\n                    if tmp > res:\n                        res = tmp\n                        resPath = path\n        return res'''\n        \n'''def dfs(self, grid, x,y,rLen, cLen):\n            val = grid[x][y]\n            grid[x][y] = 0\n            curSum = 0 \n            path = []\n            if x+1 < rLen and grid[x+1][y] != 0:\n                ret, retPath = self.dfs(grid, x+1,y,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret \n                    path = retPath\n            if x-1 >=0 and grid[x-1][y] != 0:\n                ret, retPath= self.dfs(grid, x-1,y,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret\n                    path = retPath\n            if y+1 < cLen and grid[x][y+1] != 0:\n                ret, retPath = self.dfs(grid, x,y+1,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret\n                    path = retPath\n            if y-1 >= 0 and grid[x][y-1] != 0:\n                ret, retPath = self.dfs(grid, x,y-1,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret\n                    path = retPath\n            path.append([x,y])\n            grid[x][y] = val\n            return curSum + val, path'''\n \n        \n\n\n\n'''class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int: \n        self.rLen = len(grid)\n        self.cLen = len(grid[0])\n        res = 0 \n        path = None \n        for i in range(self.rLen):\n            for j in range(self.cLen):\n                if grid[i][j] != 0:\n                    ret, retPath = self.dfs(grid, i,j)\n                    #print(grid)\n                    if ret > res:\n                        res = ret \n                        path = retPath\n        return res '''\n'''\n    def dfs(self, grid, i,j):\n        if 0<=i<self.rLen and 0<=j<self.cLen and grid[i][j] != 0:\n            tmp = grid[i][j]\n            grid[i][j] = 0 \n            total = 0 \n            totalPath = []\n            for newI, newJ in [[i+1,j], [i-1,j],[i,j+1],[i,j-1]]:\n                count, path = self.dfs(grid,newI, newJ)\n                if count + tmp > total:\n                    total = count + tmp\n                    totalPath = path + [[i,j]]\n            grid[i][j] = tmp\n            return total, totalPath\n        else:\n            return 0, []'''\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int: \n        self.rLen = len(grid)\n        self.cLen = len(grid[0])\n        res = 0 \n        path = None \n        for i in range(self.rLen):\n            for j in range(self.cLen):\n                if grid[i][j] != 0:\n                    ret, retPath = self.dfs(grid, i,j)\n                    #print(grid)\n                    if ret > res:\n                        res = ret \n                        path = retPath\n        return res\n    '''def dfs(self, grid,i,j):\n        if 0<=i<self.rLen and 0<=j<self.cLen and grid[i][j] != 0:\n            tmp = grid[i][j]\n            grid[i][j] = 0 \n            maxTotal = 0 \n            maxPath = []\n            for newI, newJ in [[i+1, j],[i-1,j],[i,j+1],[i,j-1]]:\n                retTotal, retPath = self.dfs(grid, newI, newJ)\n                if retTotal + tmp > maxTotal:\n                    maxTotal = retTotal + tmp \n                    maxPath = retPath \n            grid[i][j] = tmp \n            return maxTotal, maxPath \n        else:\n            return 0, []'''\n    def dfs(self, grid,i,j):\n        if grid[i][j] != 0:\n            tmp = grid[i][j]\n            grid[i][j] = 0 \n            maxTotal = 0 \n            maxPath = []\n            for newI, newJ in [[i+1, j],[i-1,j],[i,j+1],[i,j-1]]:\n                if 0<=newI<len(grid) and 0<=newJ < len(grid[0]) and grid[newI][newJ] != 0:\n                    retTotal, retPath = self.dfs(grid,newI,newJ)\n                    if retTotal > maxTotal:\n                        maxTotal = retTotal \n                        maxPath = retPath \n            grid[i][j] = tmp \n            return maxTotal + tmp, maxPath + [(i,j)]\n        else:\n            return 0, []\n        \n\n\n'''from collections import namedtuple\nclass Solution:\n    neighbor = namedtuple('neighbor', ('idx', 'w'))\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(v, availa_lst, sum_, max_sum):\n            sum_ += v.w\n            if all([availa_lst[neibr.idx] for neibr in adj_list[v.idx]]):\n                return [True, max(sum_, max_sum)]\n            for neibr in adj_list[v.idx]:\n                if not availa_lst[neibr.idx]:\n                    availa_lst[neibr.idx] = True\n                    res, sum_path = dfs(neibr, availa_lst, sum_, max_sum)\n                    if res:\n                        max_sum = max(max_sum, sum_path)\n                    availa_lst[neibr.idx] = False\n            return [True, max_sum]\n        if not grid:\n            return 0\n        n, m = len(grid), len(grid[0])\n        # create vertices\n        V = [(row * m) + col for row in range(n) for col in range(m) if grid[row][col] != 0]\n        # create adjacency list\n        dict_ = {V[x]: x for x in range(len(V))}\n        adj_list = []\n        for v in V:\n            tmp_adj = []\n            v_row, v_col = v//m, v%m\n            if v_row != 0 and grid[v_row - 1][v_col] != 0:  # upper neighbor\n                up_idx = dict_[v-m]\n                tmp_adj.append(self.neighbor(up_idx, grid[v_row-1][v_col]))\n            if v_row != (n-1) and grid[v_row + 1][v_col] != 0:  # lower neighbor\n                dow_idx = dict_[v+m]\n                tmp_adj.append(self.neighbor(dow_idx, grid[v_row+1][v_col]))\n            if v_col != 0 and grid[v_row][v_col - 1] != 0:  # left neighbor\n                left_idx = dict_[v-1]\n                tmp_adj.append(self.neighbor(left_idx, grid[v_row][v_col-1]))\n            if v_col != (m-1) and grid[v_row][v_col+1] != 0:  # right neighbor\n                right_idx = dict_[v+1]\n                tmp_adj.append(self.neighbor(right_idx, grid[v_row][v_col+1]))\n            adj_list.append(tmp_adj)\n        # DFS on all vertices\n        max_path = -float('inf')\n        checked = [False] * len(V)\n        for v_idx, v in enumerate(V):\n            row, col = v//m, v%m\n            checked[v_idx] = True\n            max_path = max(max_path, dfs(self.neighbor(v_idx, grid[row][col]), checked, 0, -float('inf'))[1])\n            checked[v_idx] = False\n        return max_path'''\n        \n            \n'''import functools\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        @functools.lru_cache(None)\n        def dfs(u, visited):                # memoize on current_vertex, path\n            subres = 0\n            for v in graph[u]:\n                if (visited >> v) & 1 == 0: # if neighbor is not in path then recurse\n                    subres = max(subres, dfs(v, visited | (1 << v)))\n            return vertex_gold[u] + subres  # return gold here plus the best sub-result\n\n        vertex_gold = [] # vertex_gold[vertex_id] stores amount of gold\n        m = {}           # map of grid coordinate to vertex id\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if cell:\n                    m[i, j] = len(vertex_gold)  # populate map\n                    vertex_gold.append(cell)    # save gold\n        graph = collections.defaultdict(list)\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if cell:                    # if gold, connect vertex to neighbors\n                    for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                        if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y]:\n                            graph[m[i, j]].append(m[x, y])\n        return max(dfs(u, 1 << u) for u in range(len(vertex_gold))) '''       \n            \n        \n        \n        \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.ans = 0\n        def dfs(x,y,curr):\n            curr += grid[x][y]\n            self.ans = max(curr,self.ans)\n            temp,grid[x][y] = grid[x][y],0\n            for nx ,ny in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]:\n                if 0 <= nx <len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != 0:\n                \n                    dfs(nx,ny,curr)\n            grid[x][y] = temp\n        for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] != 0:\n                        dfs(i,j,0)\n        return self.ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n\n        def dfs(i, j, v):\n            seen.add((i, j))\n            dp[i][j] = max(dp[i][j], v)\n            for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):\n                if 0 <= x < m and 0 <= y < n and grid[x][y] and (x, y) not in seen:\n                    dfs(x, y, v + grid[x][y])\n            seen.discard((i, j))\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    seen = set()\n                    dfs(i, j, grid[i][j])\n        return max(c for row in dp for c in row)\n                    \n", "class Solution:\n    allGod = -1\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def helper(maxgold, i , j):\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] > 0:\n                temp = grid[i][j]\n                self.allGod = max(self.allGod, maxgold + temp)\n                \n                grid[i][j] = 0 #similar to visited\n                helper(maxgold + temp, i-1, j)\n                helper(maxgold + temp, i+1, j)\n                helper(maxgold + temp, i, j-1)\n                helper(maxgold + temp, i, j+1)\n                grid[i][j] = temp # marks visited for only on recursion path\n                \n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] > 0:\n                    helper(0, i, j)\n        return self.allGod\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         def dfs(row, col, curgold):\n#             if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and grid[row][col] > 0:\n#                 temp = grid[row][col]\n#                 # Change to 0 so you wont repeat the process\n#                 grid[row][col] = 0\n#                 dfs(row+1, col, curgold + temp)\n#                 dfs(row-1, col, curgold + temp)\n#                 dfs(row, col+1, curgold + temp)\n#                 dfs(row, col-1, curgold + temp)\n#                 # Once you explore all your choices, calculate the max gold you have collected so far\n#                 self.maxgold = max(self.maxgold, curgold + temp)\n#                 grid[row][col] = temp\n                \n#         self.maxgold = 0\n#         for i in range(len(grid)):\n#             for j in range(len(grid[0])):\n#                 if grid[i][j] > 0:\n#                     dfs(i, j, 0)\n                    \n#         return self.maxgold\n", "class Solution:\n    gold = 0\n    def dfs(self,grid,i,j,current):\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]==0:\n            return\n        current += grid[i][j]\n        temp = grid[i][j]\n        grid[i][j] = 0\n        self.dfs(grid,i,j-1,current)\n        self.dfs(grid,i,j+1,current)\n        self.dfs(grid,i+1,j,current)\n        self.dfs(grid,i-1,j,current)\n        grid[i][j] = temp\n        self.gold = max(self.gold,current)\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]!=0:\n                    current = 0\n                    self.dfs(grid,i,j,current)\n        return self.gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(row, col, visited, acc=0):\n            if (row, col) in visited:\n                return 0\n            if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[row]):\n                return 0\n            if grid[row][col] == 0:\n                return 0\n            acc += grid[row][col]\n            visited.add((row, col))\n            ret = max(\n                acc,\n                dfs(row + 1, col, visited, acc),\n                dfs(row - 1, col, visited, acc),\n                dfs(row, col + 1, visited, acc),\n                dfs(row, col - 1, visited, acc),\n            )\n            visited.remove((row, col))\n            return ret\n\n        ret = 0\n        for row in range(len(grid)):\n            for col in range(len(grid[row])):\n                ret = max(ret, dfs(row, col, set()))\n        return ret", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.best = 0\n        def rec(x,y,total):\n            if 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]>0:\n                total+=grid[x][y]\n                self.best = max(self.best, total)\n                grid[x][y]=-grid[x][y]\n                rec(x-1,y,total)\n                rec(x,y-1,total)\n                rec(x+1,y,total)\n                rec(x,y+1,total)\n                grid[x][y]=abs(grid[x][y])\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c]!=0:\n                    rec(r,c,0)\n        return self.best", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def helper(i, j, a):\n            if i in [-1, len(grid)] or j in [-1, len(grid[0])] or grid[i][j] in [-1, 0]:\n                return a\n            y = grid[i][j]; x = a + y; \n            grid[i][j] = -1\n            a = max(helper(i+1, j, x), helper(i-1, j, x), helper(i, j+1, x), helper(i, j-1, x))\n            grid[i][j] = y\n            return a\n            \n        ans = -1\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                ans = max(ans, helper(i, j, 0))\n              \n        return ans\n", "\n'''class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:       \n        rLen = len(grid)\n        if rLen == 0:\n            return 0 \n        cLen = len(grid[0])\n        if cLen == 0:\n            return 0 \n        res = 0 \n        resPath = []\n        for i in range(rLen):\n            for j in range(cLen):\n                if grid[i][j] != 0 and [i,j] not in resPath:\n                    tmp, path = self.dfs(grid, i,j,rLen, cLen)\n                    if tmp > res:\n                        res = tmp\n                        resPath = path\n        return res'''\n        \n'''def dfs(self, grid, x,y,rLen, cLen):\n            val = grid[x][y]\n            grid[x][y] = 0\n            curSum = 0 \n            path = []\n            if x+1 < rLen and grid[x+1][y] != 0:\n                ret, retPath = self.dfs(grid, x+1,y,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret \n                    path = retPath\n            if x-1 >=0 and grid[x-1][y] != 0:\n                ret, retPath= self.dfs(grid, x-1,y,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret\n                    path = retPath\n            if y+1 < cLen and grid[x][y+1] != 0:\n                ret, retPath = self.dfs(grid, x,y+1,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret\n                    path = retPath\n            if y-1 >= 0 and grid[x][y-1] != 0:\n                ret, retPath = self.dfs(grid, x,y-1,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret\n                    path = retPath\n            path.append([x,y])\n            grid[x][y] = val\n            return curSum + val, path'''\n \n        \n\n\n\n'''class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int: \n        self.rLen = len(grid)\n        self.cLen = len(grid[0])\n        res = 0 \n        path = None \n        for i in range(self.rLen):\n            for j in range(self.cLen):\n                if grid[i][j] != 0:\n                    ret, retPath = self.dfs(grid, i,j)\n                    #print(grid)\n                    if ret > res:\n                        res = ret \n                        path = retPath\n        return res '''\n'''\n    def dfs(self, grid, i,j):\n        if 0<=i<self.rLen and 0<=j<self.cLen and grid[i][j] != 0:\n            tmp = grid[i][j]\n            grid[i][j] = 0 \n            total = 0 \n            totalPath = []\n            for newI, newJ in [[i+1,j], [i-1,j],[i,j+1],[i,j-1]]:\n                count, path = self.dfs(grid,newI, newJ)\n                if count + tmp > total:\n                    total = count + tmp\n                    totalPath = path + [[i,j]]\n            grid[i][j] = tmp\n            return total, totalPath\n        else:\n            return 0, []'''\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int: \n        self.rLen = len(grid)\n        self.cLen = len(grid[0])\n        res = 0 \n        path = None \n        for i in range(self.rLen):\n            for j in range(self.cLen):\n                if grid[i][j] != 0:\n                    ret, retPath = self.dfs(grid, i,j)\n                    #print(grid)\n                    if ret > res:\n                        res = ret \n                        path = retPath\n        return res\n    '''def dfs(self, grid,i,j):\n        if 0<=i<self.rLen and 0<=j<self.cLen and grid[i][j] != 0:\n            tmp = grid[i][j]\n            grid[i][j] = 0 \n            maxTotal = 0 \n            maxPath = []\n            for newI, newJ in [[i+1, j],[i-1,j],[i,j+1],[i,j-1]]:\n                retTotal, retPath = self.dfs(grid, newI, newJ)\n                if retTotal + tmp > maxTotal:\n                    maxTotal = retTotal + tmp \n                    maxPath = retPath \n            grid[i][j] = tmp \n            return maxTotal, maxPath \n        else:\n            return 0, []'''\n    def dfs(self, grid,i,j):\n        if grid[i][j] != 0:\n            tmp = grid[i][j]\n            grid[i][j] = 0 \n            maxTotal = 0 \n            maxPath = []\n            for newI, newJ in [[i+1,j],[i-1,j],[i,j+1],[i,j-1]]:\n                if 0<=newI<len(grid) and 0<=newJ < len(grid[0]) and grid[newI][newJ] != 0:\n                    retTotal, retPath = self.dfs(grid,newI,newJ)\n                    if retTotal > maxTotal:\n                        maxTotal = retTotal \n                        maxPath = retPath \n            grid[i][j] = tmp \n            return maxTotal + tmp, maxPath + [(i,j)]\n        else:\n            return 0, []\n        \n\n\n'''from collections import namedtuple\nclass Solution:\n    neighbor = namedtuple('neighbor', ('idx', 'w'))\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(v, availa_lst, sum_, max_sum):\n            sum_ += v.w\n            if all([availa_lst[neibr.idx] for neibr in adj_list[v.idx]]):\n                return [True, max(sum_, max_sum)]\n            for neibr in adj_list[v.idx]:\n                if not availa_lst[neibr.idx]:\n                    availa_lst[neibr.idx] = True\n                    res, sum_path = dfs(neibr, availa_lst, sum_, max_sum)\n                    if res:\n                        max_sum = max(max_sum, sum_path)\n                    availa_lst[neibr.idx] = False\n            return [True, max_sum]\n        if not grid:\n            return 0\n        n, m = len(grid), len(grid[0])\n        # create vertices\n        V = [(row * m) + col for row in range(n) for col in range(m) if grid[row][col] != 0]\n        # create adjacency list\n        dict_ = {V[x]: x for x in range(len(V))}\n        adj_list = []\n        for v in V:\n            tmp_adj = []\n            v_row, v_col = v//m, v%m\n            if v_row != 0 and grid[v_row - 1][v_col] != 0:  # upper neighbor\n                up_idx = dict_[v-m]\n                tmp_adj.append(self.neighbor(up_idx, grid[v_row-1][v_col]))\n            if v_row != (n-1) and grid[v_row + 1][v_col] != 0:  # lower neighbor\n                dow_idx = dict_[v+m]\n                tmp_adj.append(self.neighbor(dow_idx, grid[v_row+1][v_col]))\n            if v_col != 0 and grid[v_row][v_col - 1] != 0:  # left neighbor\n                left_idx = dict_[v-1]\n                tmp_adj.append(self.neighbor(left_idx, grid[v_row][v_col-1]))\n            if v_col != (m-1) and grid[v_row][v_col+1] != 0:  # right neighbor\n                right_idx = dict_[v+1]\n                tmp_adj.append(self.neighbor(right_idx, grid[v_row][v_col+1]))\n            adj_list.append(tmp_adj)\n        # DFS on all vertices\n        max_path = -float('inf')\n        checked = [False] * len(V)\n        for v_idx, v in enumerate(V):\n            row, col = v//m, v%m\n            checked[v_idx] = True\n            max_path = max(max_path, dfs(self.neighbor(v_idx, grid[row][col]), checked, 0, -float('inf'))[1])\n            checked[v_idx] = False\n        return max_path'''\n        \n            \n'''import functools\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        @functools.lru_cache(None)\n        def dfs(u, visited):                # memoize on current_vertex, path\n            subres = 0\n            for v in graph[u]:\n                if (visited >> v) & 1 == 0: # if neighbor is not in path then recurse\n                    subres = max(subres, dfs(v, visited | (1 << v)))\n            return vertex_gold[u] + subres  # return gold here plus the best sub-result\n\n        vertex_gold = [] # vertex_gold[vertex_id] stores amount of gold\n        m = {}           # map of grid coordinate to vertex id\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if cell:\n                    m[i, j] = len(vertex_gold)  # populate map\n                    vertex_gold.append(cell)    # save gold\n        graph = collections.defaultdict(list)\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if cell:                    # if gold, connect vertex to neighbors\n                    for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                        if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y]:\n                            graph[m[i, j]].append(m[x, y])\n        return max(dfs(u, 1 << u) for u in range(len(vertex_gold))) '''       \n            \n        \n        \n        \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        maxCount = 0\n        \n        N = len(grid)\n        M = len(list(zip(*grid)))\n        \n        for row in range(N):\n            for col in range(M):\n                if grid[row][col] != 0:\n                    maxCount = max(self.backtrack(grid, row, col, N, M), maxCount)\n        \n        return maxCount\n    \n    \n    def backtrack(self, grid, row, col, N, M):\n        value = grid[row][col]\n        grid[row][col] = -1\n        \n        maxCollected = 0\n        \n        \n        if row + 1 < N and grid[row + 1][col] not in (0, -1):\n            maxCollected = max(self.backtrack(grid, row + 1, col, N, M), maxCollected)\n            \n        if col + 1 < M and grid[row][col + 1] not in (0, -1):\n            maxCollected = max(self.backtrack(grid, row, col + 1, N, M), maxCollected)\n            \n        if row - 1 >= 0 and grid[row - 1][col] not in (0, -1):\n            maxCollected = max(self.backtrack(grid, row - 1, col, N, M), maxCollected)\n            \n        if col - 1 >= 0 and grid[row][col - 1] not in (0, -1):\n            maxCollected = max(self.backtrack(grid, row, col - 1, N, M), maxCollected)\n        \n        grid[row][col] = value\n        \n        return value + maxCollected", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, sum: int, seen: set) -> int:\n            mx = sum\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                if not (x < 0 or x >= m or y < 0 or y >= n or not grid[x][y] or (x, y) in seen):\n                    mx = max(dfs(x, y, sum+grid[x][y], seen|{(x,y)}), mx)\n            \n            return mx\n\n        m, n = len(grid), len(grid[0])\n        res = 0\n        for j in range(n):\n            for i in range(m):\n                if grid[i][j]!=0:\n                    seen = set()\n                    seen.add((i,j))\n                    sum=grid[i][j]\n                    res = max(res,dfs(i,j,sum,seen))\n        return res\n                \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        res = 0\n        def dfs(x, y, grid):\n            # res = 0\n            if x < 0 or x > len(grid)-1 or y < 0 or y > len(grid[0])-1 or grid[x][y]==0:\n                return 0\n            temp = grid[x][y]\n            grid[x][y] = 0\n            # print(x,y)\n            # print(temp)\n            a = dfs(x+1, y, grid) + temp\n            \n            # res = max(res, a)\n            b = dfs(x, y+1, grid) + temp\n            # res = max(res, b)\n            c = dfs(x-1, y, grid) + temp\n            # res = max(res, c)\n            d = dfs(x, y-1, grid) + temp\n            # res = max(res, d)\n            res = max([a, b, c, d])\n            grid[x][y] = temp\n            return res\n            \n        \n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] > 0:\n                    res = max(dfs(i,j,grid), res)\n        return (res)\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def collect(row, col, visited, curr_sum, ans):\n            if row >= 0 and col >= 0 and row < len(grid) and col < len(grid[0]) and visited[row][col] == False and grid[row][col] != 0:\n            \n                curr_sum += grid[row][col]\n                \n                ans[0] = max(ans[0], curr_sum)\n                \n                visited[row][col] = True\n                collect(row+1, col, visited, curr_sum, ans)\n                collect(row-1, col, visited, curr_sum, ans)\n                collect(row, col+1, visited, curr_sum, ans)\n                collect(row, col-1, visited, curr_sum, ans)\n                visited[row][col] = False\n            \n            \n        visited = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n        ans = [0]\n        \n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] != 0:\n                    collect(row, col, visited, 0, ans)\n                    \n        return ans[0]\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.res = 0\n        \n        direction = [ [1,0], [-1,0], [0,1], [0,-1] ]\n        \n        def dfs(i,j, cur):\n            cur += grid[i][j]\n            \n            end = True\n            for di,dj in direction:\n                i1,j1 = i+di, j+dj\n                if 0<=i1<len(grid) and 0<=j1<len(grid[0]) and grid[i1][j1] >0 and (i1,j1) not in visited:\n                    visited.add( (i1,j1) )\n                    dfs(i1,j1, cur)\n                    visited.discard( (i1,j1) )\n                    end = False\n                    \n            if end:\n                self.res = max(self.res, cur)\n            \n            return\n        \n        m,n = len(grid), len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    visited = set( [(i,j)] )\n                    dfs(i,j, 0)\n                    \n        return self.res\n            \n            \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def dfs(i,j,seen):\n            if i < 0 or j < 0 or j >= len(grid[0]) or i >= len(grid) or (i,j) in seen or grid[i][j] == 0:\n                return 0\n            \n            seen.add((i,j))\n            \n            t = grid[i][j] + max(dfs(i+1,j,seen),\n                                    dfs(i,j+1,seen),\n                                    dfs(i-1,j,seen),\n                                    dfs(i,j-1,seen))\n            seen.remove((i,j))\n            return t\n        \n        ans = 0                                \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n        \n                ans = max(dfs(i,j,set()),ans)\n        \n        return ans\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m,n=len(grid),len(grid[0])\n        l=[(1,0),(-1,0),(0,1),(0,-1)]\n        vis=set()\n        res=[0]\n        z=-float('inf')\n        def fn(a,b):\n            z=-float('inf')\n            for c,d in l:\n                x,y=a+c,b+d\n                if x<0 or x>=m or y<0 or y>=n: continue\n                if (x,y) not in vis and grid[x][y]>0:\n                    vis.add((x,y))\n                    res[0]+=grid[x][y]\n                    z=max(z,fn(x,y))\n                    res[0]-=grid[x][y]\n                    vis.remove((x,y))\n            if z==-float('inf'): return res[0]\n            return z\n        for x in range(m):\n            for y in range(n):\n                if grid[x][y]>0:\n                    vis.add((x,y))\n                    res[0]+=grid[x][y]\n                    z=max(z,fn(x,y))\n                    res[0]-=grid[x][y]\n                    vis.remove((x,y))\n        if z==-float('inf'): return 0\n        return z", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        \n        self.answer = 0\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(grid):\n                return 0\n            if j < 0 or j >= len(grid[0]):\n                return 0\n            \n            if grid[i][j] == 0:\n                return 0\n            \n            temp = grid[i][j]\n            grid[i][j] = 0\n            \n            storage = temp + max(dfs(i+1,j), dfs(i-1,j), dfs(i,j-1), dfs(i, j+1))\n            self.answer = max(self.answer, storage)\n            grid[i][j] = temp\n            return storage\n            \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                dfs(i,j)\n        \n        return self.answer\n", "from typing import List\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        if not rows: return 0\n        cols = len(grid[0])\n        def dfs(i, j):\n            if i < 0 or j < 0 or i >= rows or j >= cols or grid[i][j] == 0:\n                return 0\n\n            val = grid[i][j]\n            _sum = val\n            grid[i][j] = 0\n\n            _sum = max(_sum, val + dfs(i-1, j))\n            _sum = max(_sum, val + dfs(i, j-1))\n            _sum = max(_sum, val + dfs(i+1, j))\n            _sum = max(_sum, val + dfs(i, j+1))\n\n            grid[i][j] = val\n            return _sum\n\n        ans = 0\n        for i in range(rows):\n            for j in range(cols):\n                ans = max(ans, dfs(i, j))\n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def dsf(r, c ,gold): #r =>row , c> column\n            if not (0<=r<len(grid) and 0 <= c <len(grid[0]) and grid[r][c] > 0):\n                return\n            \n            gold += grid[r][c]\n            self.max_gold = max(self.max_gold,gold)\n            \n            grid[r][c] *= -1  #  Mark as visited\n            dsf(r+1,c,gold)  # Go 4 directions\n            dsf(r-1,c,gold)\n            dsf(r,c+1,gold)\n            dsf(r,c-1,gold)\n            grid[r][c] *= -1 # Unmark when done\n        \n        self.max_gold = 0\n        \n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] > 0:\n                    dsf(r,c,0)\n    \n        return self.max_gold\n", "class Solution:\n    max_gold = 0\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        nRow, nCol = len(grid), len(grid[0])\n        self.max_gold = max([x for r in grid for x in r])\n        \n        path = []\n\n        def helper(kr, kc):\n            up = kr == 0 or grid[kr - 1][kc] == 0\n            down = kr == nRow - 1 or grid[kr + 1][kc] == 0\n            left = kc == 0 or grid[kr][kc - 1] == 0\n            right = kc == nCol - 1 or grid[kr][kc + 1] == 0\n            \n            if up and down and left and right:\n                self.max_gold = max(self.max_gold, sum(path) + grid[kr][kc])\n            else:\n                path.append(grid[kr][kc])\n                grid[kr][kc] = 0\n                if not up:\n                    helper(kr - 1, kc)\n                if not down:\n                    helper(kr + 1, kc)\n                if not left:\n                    helper(kr, kc - 1)\n                if not right:\n                    helper(kr, kc + 1)\n                grid[kr][kc] = path.pop()\n\n        for kr in range(nRow):\n            for kc in range(nCol):\n                if grid[kr][kc]:\n                    helper(kr,kc)\n\n        return self.max_gold        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        dirs = [[-1,0], [1,0], [0,1],[0,-1]]\n        m, n = len(grid), len(grid[0])\n\n        def dfs(x, y, gold):\n            temp = grid[x][y]\n            grid[x][y] = 0\n            self.max_gold = max(self.max_gold, gold + temp)\n            for dx, dy in dirs:\n                nx = dx + x\n                ny = dy + y\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny]:\n                    dfs(nx, ny, gold+temp)\n            grid[x][y] = temp\n\n        self.max_gold = 0\n        for i in range(m):\n            for j in range(n):\n                dfs(i, j, 0)\n        return self.max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i, j, cur):\n            nonlocal mx\n            cur += grid[i][j]\n            mx = max(mx, cur)\n            path.add((i,j))\n            for I, J in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:\n                if 0<=I<len(grid) and 0<=J<len(grid[0]) and grid[I][J] != 0 and (I,J) not in path:\n                    dfs(I,J,cur)\n            path.remove((i,j))\n        \n        if not grid:\n            return 0\n        mx = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    path = set()\n                    dfs(i,j,0)\n        return mx\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        if not grid:\n            return 0\n        n, m = len(grid), len(grid[0])\n        dirs = [(0,1), (1,0), (0,-1), (-1,0)]\n        self.max_gold = 0\n        self.v = set()\n        def dfs(r, c, gold):\n            \n            self.max_gold = max(self.max_gold, gold)\n            \n            for d in dirs:\n                row, col = r + d[0], c + d[1]\n                if 0 <= row < n and 0 <= col < m and grid[row][col] != 0 and (row,col) not in self.v:\n                    self.v.add((row, col))\n                    dfs(row, col, gold + grid[row][col])\n                    self.v.remove((row, col))\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != 0:\n                    self.v.add((i, j))\n                    dfs(i, j, grid[i][j])\n                    self.v.remove((i, j))\n        return self.max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        gold = []\n        def helper(i, j, a):\n            if i in [-1, len(grid)] or j in [-1, len(grid[0])] or grid[i][j] in [-1, 0]:\n                gold.append(a)\n                return\n            \n            y = grid[i][j]; x = a + y; \n            grid[i][j] = -1\n            \n            helper(i+1, j, x)\n            helper(i-1, j, x)\n            helper(i, j+1, x)\n            helper(i, j-1, x)\n            \n            grid[i][j] = y\n            \n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                helper(i, j, 0)\n              \n        return max(gold)\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:                    \n        def dfs(row, col, cur_sum, visited):\n            if row<0 or col<0 or row>=len(grid) or col>=len(grid[0]) or visited[row][col]==1 or grid[row][col]==0:\n                return\n            visited[row][col] = 1\n            cur_sum += grid[row][col]\n            self.max_path = max(self.max_path, cur_sum)\n            dfs(row+1, col, cur_sum, visited)\n            dfs(row-1, col, cur_sum, visited)\n            dfs(row, col+1, cur_sum, visited)\n            dfs(row, col-1, cur_sum, visited)\n            visited[row][col] = 0\n\n        visited = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\n        self.max_path = 0\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] != 0:\n                    dfs(row, col, 0, visited)\n        return self.max_path\n        \n        \n\n                \n        \n        \n                        \n                        \n                    \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        totals = []\n        \n        def mine(m, n, g, x):\n            \n            if m >= 0 and m < len(x) and n >= 0 and n < len(x[m]) and x[m][n] > 0:\n                g += x[m][n]\n                \n                backup = x[m][n]\n                x[m][n] = 0\n                \n                mine(m + 1, n, g, x)\n                mine(m - 1, n, g, x)\n                mine(m, n + 1, g, x)\n                mine(m, n - 1, g, x)\n                \n                x[m][n] = backup\n            \n            totals.append(g)\n        \n        for m in range(0, len(grid)):\n            for n in range(0, len(grid[m])):\n                mine(m, n, 0, grid)\n        \n        return max(totals)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(a, b, board, g, seen):\n            nonlocal p\n            p = max(p, g)\n            for i, j in (a + 1, b), (a - 1, b), (a, b + 1), (a, b - 1):\n                if 0 <= i < len(board) and 0 <= j < len(board[0]) and board[i][j] != 0 and (i, j) not in seen:\n                    seen.add((i, j))\n                    dfs(i, j, board, g + board[i][j], seen)\n                    seen.remove((i, j))\n        p = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    dfs(i, j, grid, grid[i][j], {(i, j)})\n        return p", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\\\"\\\"\\\"\n\\\"\\\"\\\"\n\n\ndef dfs(r, c, grid):\n    ans = grid[r][c]\n    temp = ans\n    grid[r][c] = 0\n    dr = [-1, 0, 1, 0]\n    dc = [0, 1, 0, -1]\n    for i in range(4):\n        newr = r + dr[i]\n        newc = c + dc[i]\n        if newr >= 0 and newr < len(grid) and newc >= 0 and newc < len(\n                grid[0]) and grid[newr][newc]:\n            #print(r, c, newr, newc)\n            ans = max(ans, temp + dfs(newr, newc, grid))\n    grid[r][c] = temp\n    return ans\n\n\nclass Solution:\n\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        M = len(grid[0])\n        ans = 0\n        for r in range(N):\n            for c in range(M):\n                if grid[r][c]:\n                    ans = max(ans, dfs(r, c, grid))\n        return ans\n\n\\\"\\\"\\\"\nsol = Solution()\ngrid = [[0, 1, 0], [2, 3, 4]]\ngrid = [[0, 6, 0], [5, 8, 7], [0, 9, 0]]\ngrid = [[1, 0, 7], [2, 0, 6], [3, 4, 5], [0, 3, 0], [9, 0, 20]]\nprint(sol.getMaximumGold(grid))\n\\\"\\\"\\\"", "class Solution:\n    def __init__(self):\n        self.max = 0\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                self.max = max(self.dfs(grid, i, j), self.max)\n                \n        return self.max\n    \n    def dfs(self, grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[i]) or grid[i][j] == 0:\n            return 0\n        \n        temp = grid[i][j]\n        grid[i][j] = 0\n        \n        up = temp + self.dfs(grid, i-1, j)\n        down = temp + self.dfs(grid, i+1, j)\n        left = temp + self.dfs(grid, i, j-1)\n        right = temp + self.dfs(grid, i, j+1)\n        \n        grid[i][j] = temp\n        return max(max(up, down), max(left, right))\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        rl, cl = len(grid), len(grid[0])\n        de = ((1,0),(0,1),(-1,0),(0,-1))\n        def solve(x,y,seen):\n            temp = 0\n            for d in de:\n                nx, ny = x + d[0], y + d[1]\n                if 0 <= nx < rl and 0 <= ny < cl and grid[nx][ny] and (nx,ny) not in seen:\n                    temp = max(temp, solve(nx, ny, seen | {(x,y)}))\n            return temp + grid[x][y]\n        \n        ans = 0\n        for i in range(rl):\n            for j in range(cl):\n                if grid[i][j]:\n                    ans = max(ans, solve(i,j,set()))\n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        \n        def backtrack(grid, i, j):\n            s = 0\n            temp = grid[i][j]\n            grid[i][j] = 0\n            \n            # left\n            if i > 0 and  grid[i-1][j] != 0:\n                s = max(s, backtrack(grid, i-1, j))\n            \n            # right\n            if i < len(grid)-1 and  grid[i+1][j] != 0:\n                s = max(s, backtrack(grid, i+1, j))\n            \n            # top\n            if j > 0  and  grid[i][j-1] != 0:\n                s = max(s, backtrack(grid, i, j -1))\n            \n            # bottom\n            if j < len(grid[0])-1 and grid[i][j+1] != 0:\n                s = max(s, backtrack(grid, i, j+1))            \n            \n            grid[i][j] = temp\n            return s + grid[i][j]\n        \n        \n        ret = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    ret = max(ret,  backtrack(grid, i, j))\n        return ret\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        checked = set()\n        maximum = 0\n        for x in range(len(grid)):\n            for y in range(len(grid[0])):\n                # not 0\n                if (grid[x][y]):\n                    # print(\\\"checking: \\\" + str((x,y)))\n                    visited = set()\n                    value = self.recursive(0, x , y, grid, visited) \n\n                    if (value > maximum):\n                        # print(\\\"new max point: \\\" + str((x,y)))\n                        # print(\\\"new max: \\\" + str(value))\n                        maximum = value\n        return maximum\n                    \n                \n    def recursive(self, total, x, y, grid, visited):\n        if (grid[x][y] == 0):\n            return total\n        \n        if ((x,y) in visited):\n            return total\n        \n        visited = set(visited)\n        visited.add((x,y))\n        total = total + grid[x][y]\n        # left = (x-1,y)\n        # right = (x+1,y)\n        # top = (x,y-1)\n        # btm = (x,y+1)\n        left,right,top,btm = total,total,total,total\n        \n        if (x > 0):\n            left = self.recursive(total, x-1, y, grid, visited)\n        \n        if (x < len(grid)-1):\n            right = self.recursive(total, x+1, y, grid, visited)\n            \n        if (y > 0):\n            top =self.recursive(total, x, y-1, grid, visited)\n        \n        if (y < len(grid[x])-1):\n            btm = self.recursive(total, x, y+1, grid, visited)\n        \n        return max(left, right, top, btm, total)\n            \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        R, C = len(grid), len(grid[0])\n        \n        def traverse(r, c):\n            if not (0 <= r < R and 0 <= c < C):\n                return 0\n\n            if not grid[r][c]:\n                return 0\n\n            cur = grid[r][c]\n            grid[r][c] = 0\n\n            res = 0\n            for x, y in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                res = max(res, traverse(r+x, c+y))\n            res += cur\n            \n            grid[r][c] = cur\n            return res\n        \n\n        result = 0\n        \n        for r in range(R):\n            for c in range(C):\n                result = max(result, traverse(r, c))\n                \n        return result\n", "DIR = ((-1, 0), (1, 0), (0, -1), (0, 1))\nclass Solution:\n    def getMaximumGold(self, grid):\n        res = 0\n        m, n = len(grid), len(grid[0])\n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] > 0:\n                    res = max(res, self.dfs(grid, x, y, {(x, y)}))\n        return res\n    \n    def dfs(self, grid, x, y, visited):\n        m, n = len(grid), len(grid[0])\n        res = grid[x][y]\n        for dx, dy in DIR:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= m - 1 and 0 <= ny <= n - 1 and grid[nx][ny] > 0 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                res = max(res, self.dfs(grid, nx, ny, visited) + grid[x][y])\n                visited.remove((nx, ny))\n        return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.res = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                self.dfs(grid, i, j, 0)\n        return self.res\n        \n    def dfs(self, grid, i, j, currSum):\n        if i > len(grid) - 1 or i < 0 or j > len(grid[0])-1 or j < 0:\n            return \n        if grid[i][j] == 0:\n            return\n        currSum += grid[i][j]\n        temp = grid[i][j]\n        grid[i][j] = 0\n        self.dfs(grid, i-1, j, currSum)\n        self.dfs(grid, i, j-1, currSum)\n        self.dfs(grid, i+1, j, currSum)\n        self.dfs(grid, i, j+1, currSum)\n        grid[i][j] = temp\n        self.res = max(self.res, currSum)", "class Solution:\n\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        max_gold = 0\n        rows = len(grid)\n        cols = len(grid[0])\n\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col] > 0:\n                    max_gold = max(max_gold, self.get_gold(grid, row, col))\n        return max_gold\n\n    def get_gold(self, grid, row, col):\n        if (row < 0 or row >= len(grid)\n          or col < 0 or col >= len(grid[row])\n          or grid[row][col] == 0):\n            return 0\n\n        ori = grid[row][col]\n        gold = 0\n        grid[row][col] = 0\n\n        gold = max(gold, self.get_gold(grid, row + 1, col))\n        gold = max(gold, self.get_gold(grid, row - 1, col))\n        gold = max(gold, self.get_gold(grid, row, col + 1))\n        gold = max(gold, self.get_gold(grid, row, col - 1))\n\n        grid[row][col] = ori\n\n        return gold + ori\n", "import copy\nclass Solution:\n    def helper(self, grid, start_i, start_j, current_gold, visited):\n      candidates = []\n      current_gold += grid[start_i][start_j]\n      visited[(start_i, start_j)] = 1\n      if max(0, start_i-1) != start_i and grid[start_i-1][start_j] > 0 and (start_i-1, start_j) not in visited: \n        candidates.append((start_i-1, start_j))\n      if min(len(grid)-1, start_i+1) != start_i and grid[start_i+1][start_j] > 0 and (start_i+1, start_j) not in visited: \n        candidates.append((start_i+1, start_j))\n      if max(0, start_j-1) != start_j and grid[start_i][start_j-1] > 0 and (start_i, start_j-1) not in visited: \n        candidates.append((start_i, start_j-1))\n      if min(len(grid[0])-1, start_j+1) != start_j and grid[start_i][start_j+1] > 0 and (start_i, start_j+1) not in visited: \n        candidates.append((start_i, start_j+1))\n      res = 0\n      if not candidates: return current_gold\n      for can in candidates:\n        res = max(res, self.helper(grid, can[0], can[1], current_gold, dict(visited)))\n      return res\n            \n      \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n      res = 0\n      for i in range(len(grid)):\n        for j in range(len(grid[0])):\n          start_i = i\n          start_j = j\n          counter = 0\n          if max(0, start_i-1) != start_i and grid[start_i-1][start_j] > 0: \n            counter += 1\n          if min(len(grid)-1, start_i+1) != start_i and grid[start_i+1][start_j] > 0: \n            counter += 1\n          if max(0, start_j-1) != start_j and grid[start_i][start_j-1] > 0: \n            counter += 1\n          if min(len(grid[0])-1, start_j+1) != start_j and grid[start_i][start_j+1] > 0: \n            counter += 1\n          if counter <= 2:\n            dicts = {}\n            res = max(res, self.helper(grid, i, j, 0, dicts))\n      return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        ans = [0]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if (grid[i][j] > 0):\n                    self.dfs(grid, i, j, [], ans)\n        return ans[0]\n\n    \n    def dfs(self, grid, i, j, path, ans):\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]==0:\n            return\n        path.append(grid[i][j])\n        grid[i][j] = 0\n        ans[0] = max(ans[0], sum(path))\n        self.dfs(grid, i+1, j, path, ans)                                                                    \n        self.dfs(grid, i-1, j, path, ans)\n        self.dfs(grid, i, j+1, path, ans)\n        self.dfs(grid, i, j-1, path, ans)                                                                    \n        grid[i][j] = path.pop()\n                                                            \n", "import collections \nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        #collect the that I can start of with!!\n        m=0\n        start=[]\n        cl,rl=len(grid[0]),len(grid)\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j]:\n                    start.append((i,j))\n                    if m < grid[i][j]:\n                        m=grid[i][j]\n        ans=[]\n        \n        #print(start)\n        for i in start:\n            r,c=i\n            s=str(r)+str(c)\n            q=collections.deque()\n            q.append([r,c,grid[r][c],s])\n            \n            while(q):\n                l=q.popleft()\n                r,c,s,path=l[0],l[1],l[2],l[3]\n                \n                #Flag initialization:\n                lf=rf=uf=df=False\n                \n                #left\n                if c-1 >=0 and grid[r][c-1]:\n                    k=str(r)+str(c-1)\n                    if k not in path:\n                        v=grid[r][c-1]\n                        q.append([r,c-1,s+v,path+'->'+k])\n                        lf=True\n                    \n                #right\n                if c+1 < cl and grid[r][c+1]:\n                    k=str(r)+str(c+1)\n                    if k not in path:\n                        v=grid[r][c+1]\n                        q.append([r,c+1,s+v,path+'->'+k])\n                        rf=True\n                        \n                #up       \n                if r-1 >=0 and grid[r-1][c]:\n                    k=str(r-1)+str(c)\n                    if k not in path:\n                        v=grid[r-1][c]\n                        q.append([r-1,c,s+v,path+'->'+k])\n                        uf=True\n                    \n                #down\n                if r+1 < rl and grid[r+1][c]:\n                    k=str(r+1)+str(c)\n                    if k not in path:\n                        v=grid[r+1][c]\n                        q.append([r+1,c,s+v,path+'->'+k])\n                        df=True\n                if not df and not uf and not lf and not rf:\n                    ans.append(s)\n        return max(ans)\n            \n                \n            \n            \n            \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.orig_grid = grid\n        self.M = len(grid)\n        self.N = len(grid[0])\n        max_gold = 0\n        for i in range(self.M):\n            for j in range(self.N):\n                self.soln =  [ [ 0 for j in range(self.N) ] for i in range(self.M) ]\n                curr = self.trackGold(i, j)#, self.soln)\n                max_gold = max(max_gold, curr)\n        return max_gold\n\n    def trackGold(self, i, j):#, soln):\n        if (i < 0 or i >= self.M or j < 0 or j >= self.N or self.orig_grid[i][j] == 0 or self.soln[i][j] == 1):\n            return 0\n        \n        self.soln[i][j] = 1\n        future_gold = max(self.trackGold(i+1, j), self.trackGold(i, j+1), self.trackGold(i-1, j), self.trackGold(i, j-1))\n        curr_gold = self.orig_grid[i][j] + future_gold\n        self.soln[i][j] = 0\n        return curr_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]: return 0\n        #\u8fd9\u9898\u7684space\u53ef\u4ee5\u4e0d\u7528seen\u800c\u7528mark grid\u4e3a0\u8868\u793a\u5df2\u7ecf\u88abvisited\n        #\u4f46\u662f\u5e76\u6ca1\u6709\u4f18\u5316space\uff0c\u56e0\u4e3astack\u91cc\u9762\u8fd8\u662f\u8981\u5b58\u90a3\u4e48\u591atmp\uff01\uff01\uff01\n        #space \u662flongest path length/dfs depth\uff0cbounded by n*n\n        #time\u662f k*4*3^(k-1) \u56e0\u4e3a\u7b2c\u4e00\u4e2a\u53ef\u80fd4\u4e2a\u65b9\u5411\uff0c\u540e\u9762\u6bcf\u4e2a\u6700\u591a3\u4e2a\u65b9\u5411\n        maxGold = 0\n        #seen = set()\n        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j): #position, cannot use cache.\n            res = 0\n            if grid[i][j] == 0: return 0\n            #seen.add((i, j))\n            tmp = grid[i][j]\n            grid[i][j] = 0\n            for x, y in [[i+1,j],[i-1,j],[i,j+1],[i,j-1]]:\n                if 0 <= x < m and 0 <= y < n:\n                    #if (x, y) in seen: continue\n                    res = max(res, dfs(x, y))\n                    \n            #seen.discard((i, j))\n            grid[i][j] = tmp\n            return res + grid[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                maxGold = max(maxGold, dfs(i, j))\n                \n        return maxGold\n        \n        \n                        \n                    \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        max_gold = 0\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]:\n                    max_gold = max(max_gold, self.searchGrid(grid, i, j, 0))\n                    \n        return max_gold\n    \n    def searchGrid(self, grid, i, j, gold):\n\n        square_gold = grid[i][j]\n        gold += square_gold\n        grid[i][j] = 0\n        \n        up_gold = left_gold = down_gold = right_gold = gold\n        if i > 0 and grid[i-1][j]:\n            up_gold = self.searchGrid(grid, i - 1, j, gold)\n            \n        if j > 0 and grid[i][j-1]:\n            left_gold = self.searchGrid(grid, i, j - 1, gold)\n            \n        if i < len(grid) - 1 and grid[i + 1][j]:\n            down_gold = self.searchGrid(grid, i + 1, j, gold)\n            \n        if j < len(grid[0]) - 1 and grid[i][j + 1]:\n            right_gold = self.searchGrid(grid, i, j + 1, gold)\n        \n        grid[i][j] = square_gold\n        \n        return max(up_gold, left_gold, down_gold, right_gold)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        l = len(grid)\n        w = len(grid[0])\n        seen = set()\n        r = 0\n        \n        for x in grid:\n            print(x)\n        \n        def dfs(x, y, gold):\n            if (x, y) not in seen and 0 <= x < l and 0 <= y < w and grid[x][y]:\n                seen.add((x, y))\n                gold += grid[x][y]\n                dfs(x+1, y, gold)\n                dfs(x, y+1, gold)\n                dfs(x-1, y, gold)\n                dfs(x, y-1, gold)\n                seen.remove((x, y))\n            else:\n                nonlocal r\n                r = max(r, gold)\n                \n        for i in range(l):\n            for j in range(w):\n                dfs(i, j, 0)\n                \n        return r\n                \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.res = 0\n        directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n        def dfs(i, j, cur, grid):\n            if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]==0:\n                return \n            \n            val = grid[i][j]\n            grid[i][j] = 0 \n            self.res = max(self.res, cur+val)\n            \n            for dx, dy in directions:\n                dfs(i+dx, j+dy, cur+val, grid)\n        \n            grid[i][j]=val\n        \n        n, m = len(grid), len(grid[0])\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]!=0:\n                    dfs(i, j, 0, grid)\n        return self.res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        res = [0]\n        def bfs(v, x, y):\n            seen.add((x, y))\n            dp[x][y] = max(dp[x][y], v)\n            for i, j in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n                a, b = x + i, y + j\n                if 0 <= a < m and 0 <= b < n and (a, b) not in seen and grid[a][b] != 0:\n                    bfs(v+grid[a][b], a, b)\n            seen.discard((x, y))\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    seen = set()\n                    bfs(grid[i][j], i, j)\n        return max(max(row) for row in dp)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        result = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                # Search max possible return starting from this cell\n                result = max(self.search(grid, i, j, set()), result)\n        return result\n\n    def search(self, grid, x, y, visited):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\n            return 0\n        if grid[x][y] == 0:\n            return 0\n        if (x, y) in visited:\n            return 0\n\n        result = grid[x][y]\n        visited.add((x, y))\n\n        # Search all neighbours\n        result += max(self.search(grid, x-1, y, visited),\n                      self.search(grid, x, y-1, visited),\n                      self.search(grid, x+1, y, visited),\n                      self.search(grid, x, y+1, visited))\n        \n        visited.remove((x, y))\n\n        return result", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        max_ = 0\n        n, m = len(grid), len(grid[0])\n        def backtrack(i, j, accum):\n            nonlocal max_\n            if grid[i][j] == 0:\n                max_ = max(max_, accum)\n                return\n            \n            collected, grid[i][j] = grid[i][j], 0\n            accum += collected\n            \n            for di, dj in [[0, 1], [1, 0], [0, -1], [-1, 0]]:\n                try_i, try_j = i + di, j + dj\n                if 0 <= try_i < n and 0 <= try_j < m:\n                    backtrack(try_i, try_j, accum)\n                \n            grid[i][j] = collected\n            accum -= collected\n            \n        for i in range(n):\n            for j in range(m):\n                backtrack(i, j, 0)\n                \n        return max_\n", "class Solution:\n    def __init__(self):\n        self.next_moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(row, col):\n            if grid[row][col] == 0:\n                return 0\n            \n            gold = grid[row][col]\n            grid[row][col] = 0\n            \n            max_child = 0\n            for move in self.next_moves:\n                next_row, next_col = row + move[0], col + move[1]\n                if -1 < next_row < n and -1 < next_col < m:\n                    max_child = max(max_child, dfs(next_row, next_col))\n            \n            grid[row][col] = gold\n            return gold + max_child\n        \n        n = len(grid)\n        m = len(grid[0])\n        \n        max_gold = 0\n        for i in range(n):\n            for j in range(m):\n                max_gold = max(max_gold, dfs(i, j))\n        return max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def findMaxGold(r: int, c: int) -> int:\n            if r < 0 or r == m or c < 0 or c == n or grid[r][c] == 0: \n                return 0\n            \n            origin = grid[r][c]\n            grid[r][c] = 0\n            maxGold = 0\n            \n            for nr, nc in ((r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)):\n                maxGold = max(findMaxGold(nr, nc), maxGold)\n                \n            grid[r][c] = origin\n            \n            return maxGold + origin\n\n        m, n = len(grid), len(grid[0])\n        \n        return max(findMaxGold(r, c) for c in range(n) for r in range(m))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n       # d\u8868\u793a\u56db\u4e2a\u65b9\u5411\uff0c\u5206\u522b\u662f\u5de6\u3001\u4e0a\u3001\u53f3\u3001\u4e0b\uff0c\u4e8c\u7ef4\u67e5\u627e\u95ee\u9898\u4e00\u822c\u90fd\u4f1a\u7528\u5230\u8fd9\u4e2a\n        d = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n\n        m = len(grid)\n        if m == 0: #\u7a7agrid=[]\uff0c\u90a3\u5c31\u76f4\u63a5\u9000\u51fa0\n            return 0\n        n = len(grid[0])\n\n        #\u521d\u59cb\u5316 visited \u5168\u90e8\u4e3a\u4e86False\uff0c\u4e3a\u4e86\u6807\u8bb0 \u8fd9\u4e2a\u70b9\u662f\u5426\u5df2\u7ecf\u8d70\u8fc7\n        visited = []\n        visited_in = []\n        for i in range(m):\n            for j in range(n):\n                visited_in.append(False)\n            visited.append(visited_in)\n            visited_in = []\n\n        # \u5224\u65adx\u548cy\u662f\u5426\u518dboard\u8fd9\u4e2a\u8868\u683c\u91cc\u9762\n        def inArea(x, y):\n            return x >= 0 and x < m and y >= 0 and y < n\n\n        #Floorfill\u7b97\u6cd5\uff01\u6bcf\u6b21\u904d\u5386\u5230\u4e00\u4e2a\u70b9\uff0c\u90a3\u5c31\u627e\u4e0a\u4e0b\u5de6\u53f3\uff0c\u628a\u90fd\u4e3a1\u7684\u70b9\u6253\u4e0aTrue\uff0c\u4e0b\u6b21\u5c31\u4e0d\u7528\u904d\u5386\u4e86\n        def DFS(grid, startx, starty):\n            res = 0\n            visited[startx][starty] = True  # \u6807\u8bb0\u5df2\u7ecf\u8d70\u8fc7\u7684\u70b9\n            # \u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\n            for i in range(4):\n                newx = startx + d[i][0] #\u66f4\u65b0x\n                newy = starty + d[i][1] #\u66f4\u65b0y\n                #\u65b0\u70b9\u5fc5\u987b\u6ee1\u8db3\u4ee5\u4e0b\u4e09\u4e2a\u6761\u4ef6\uff0c\u4e5f\u5c31\u662f\u518d\u6b63\u5e38\u53d6\u503c\u8303\u56f4\u5185m/n\uff0c\u6ca1\u6709\u88ab\u8bbf\u95ee \u5e76\u4e14\u8fd9\u4e2a\u65b0\u70b9\u7684\u503c\u4e3a1\uff0c\u5c31\u4f1a\u4e0d\u65ad\u9012\u5f52\n                if inArea(newx, newy) and (not visited[newx][newy]) and grid[newx][newy] != 0:\n                    # print(\\\"grid[newx][newy]\\\", grid[newx][newy])\n                    # print(\\\"DFS(grid, newx, newy, maxRes)\\\", DFS(grid, newx, newy))\n                    res = max(res, grid[newx][newy] + DFS(grid, newx, newy))\n                    # print(\\\"res\\\", res)\n                    # print()\n\n            visited[startx][starty] = False\n            return res\n\n        maxRes = []\n        record_each_result = []\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0 and (not visited[i][j]):\n                    # \u8bb0\u5f55\u4e0b\u7b2c\u4e00\u4e2a\u5143\u7d20\n                    result = grid[i][j] + DFS(grid, i, j) #\u628a\u88ab0\u5305\u56f4 \u5e76\u4e14\u76f8\u90bb\u7684\u6bcf\u4e2a1\u90fd\u6807\u8bb0\u4e3aTrue\u3002\n                    record_each_result.append(result)\n\n\n        #final result\n        final_result = max(record_each_result)\n        #print(final_result)\n        return final_result\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m,n = len(grid), len(grid[0])\n        def collect(i,j):\n            if not (0 <= i < m and 0 <= j < n and grid[i][j]): return 0\n            gold, grid[i][j] = grid[i][j], 0\n            choices = [collect(i+di,j+dj) for di, dj in [(1,0), (-1,0), (0,1), (0,-1)]]\n            grid[i][j] = gold\n            return max(choices) + gold\n        return max(collect(i,j) for i in range(m) for j in range(n))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.ans = 0\n        seen = set()\n        delta = [(1,0), (-1,0), (0,-1), (0,1)]\n        def dfs(i,j,cur=0):\n            \n            for di, dj in delta:\n                new_i, new_j = i + di, j + dj\n                if 0 <= new_i < len(grid) and 0 <= new_j < len(grid[0]):\n                    if (new_i, new_j) not in seen and grid[new_i][new_j]:\n                        seen.add((new_i, new_j))\n                        cur += grid[new_i][new_j]\n                        self.ans = max(self.ans, cur)\n                        dfs(new_i, new_j, cur)\n                        cur -= grid[new_i][new_j]\n                        seen.remove((new_i, new_j))\n            return \n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] and (i,j) not in seen:\n                    seen.add((i,j))\n                    self.ans = max(self.ans, grid[i][j])\n                    dfs(i,j, grid[i][j])\n                    seen.remove((i,j))\n        return self.ans\n                \n            \n            \n            \n\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        \n        def visit(i, j):\n            visited[i][j] = True\n            gold = 0\n            if i > 0 and not visited[i-1][j]:\n                gold = max(gold, visit(i-1, j))\n            if i < m-1 and not visited[i+1][j]:\n                gold = max(gold, visit(i+1, j))\n            if j > 0 and not visited[i][j-1]:\n                gold = max(gold, visit(i, j-1))\n            if j < n-1 and not visited[i][j+1]:\n                gold = max(gold, visit(i, j+1))\n            visited[i][j] = False\n            return gold + grid[i][j]\n        \n        visited = [[False]*n for i in range(m)]\n        def reset():\n            for i in range(m):\n                for j in range(n):\n                    visited[i][j] = grid[i][j] == 0\n                    \n        max_gold = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    reset()\n                    max_gold = max(max_gold, visit(i,j))\n        return max_gold\n                    \n                \n                \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def findMaxGold(r: int, c: int) -> int:\n            if r < 0 or r == m or c < 0 or c == n or grid[r][c] == 0: return 0\n            origin = grid[r][c]\n            grid[r][c] = 0\n            maxGold = 0\n            for nr, nc in ((r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)):\n                maxGold = max(findMaxGold(nr, nc), maxGold)\n            grid[r][c] = origin\n            return maxGold + origin\n        \n        m, n = len(grid), len(grid[0])\n        return max(findMaxGold(r, c) for c in range(n) for r in range(m))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def findMaxGold(r: int, c: int) -> int:\n            if r < 0 or r == m or c < 0 or c == n or grid[r][c] == 0: return 0\n            origin = grid[r][c]\n            grid[r][c] = 0  # mark as visited\n            maxGold = 0\n            for nr, nc in ((r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)):\n                maxGold = max(findMaxGold(nr, nc), maxGold)\n            grid[r][c] = origin  # backtrack\n            return maxGold + origin\n\n        m, n = len(grid), len(grid[0])\n        return max(findMaxGold(r, c) for c in range(n) for r in range(m))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        # d\u8868\u793a\u56db\u4e2a\u65b9\u5411\uff0c\u5206\u522b\u662f\u5de6\u3001\u4e0a\u3001\u53f3\u3001\u4e0b\uff0c\u4e8c\u7ef4\u67e5\u627e\u95ee\u9898\u4e00\u822c\u90fd\u4f1a\u7528\u5230\u8fd9\u4e2a\n        d = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n\n        m = len(grid)\n        if m == 0: #\u7a7agrid=[]\uff0c\u90a3\u5c31\u76f4\u63a5\u9000\u51fa0\n            return 0\n        n = len(grid[0])\n\n        #\u521d\u59cb\u5316 visited \u5168\u90e8\u4e3a\u4e86False\uff0c\u4e3a\u4e86\u6807\u8bb0 \u8fd9\u4e2a\u70b9\u662f\u5426\u5df2\u7ecf\u8d70\u8fc7\n        visited = []\n        visited_in = []\n        for i in range(m):\n            for j in range(n):\n                visited_in.append(False)\n            visited.append(visited_in)\n            visited_in = []\n\n        # \u5224\u65adx\u548cy\u662f\u5426\u518dboard\u8fd9\u4e2a\u8868\u683c\u91cc\u9762\n        def inArea(x, y):\n            return x >= 0 and x < m and y >= 0 and y < n\n\n        #Floorfill\u7b97\u6cd5\uff01\u6bcf\u6b21\u904d\u5386\u5230\u4e00\u4e2a\u70b9\uff0c\u90a3\u5c31\u627e\u4e0a\u4e0b\u5de6\u53f3\n        def DFS(grid, startx, starty):\n            res = 0\n            visited[startx][starty] = True  # \u6807\u8bb0\u5df2\u7ecf\u8d70\u8fc7\u7684\u70b9\n            # \u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\n            for i in range(4):\n                newx = startx + d[i][0] #\u66f4\u65b0x\n                newy = starty + d[i][1] #\u66f4\u65b0y\n                #\u65b0\u70b9\u5fc5\u987b\u6ee1\u8db3\u4ee5\u4e0b\u4e09\u4e2a\u6761\u4ef6\uff0c\u4e5f\u5c31\u662f\u518d\u6b63\u5e38\u53d6\u503c\u8303\u56f4\u5185m/n\uff0c\u6ca1\u6709\u88ab\u8bbf\u95ee \u5e76\u4e14\u8fd9\u4e2a\u65b0\u70b9\u7684\u503c\u4e0d\u80fd\u4e3a0\uff0c\u5c31\u4f1a\u4e0d\u65ad\u9012\u5f52\n                if inArea(newx, newy) and (not visited[newx][newy]) and grid[newx][newy] != 0:\n                    # \u6bcf\u5230\u4e00\u4e2a\u70b9\uff0c\u5c31\u641c\u7d22\u65c1\u8fb9\u7684\u56db\u4e2a\u70b9\uff0c\u5e76\u4e14\u76f8\u52a0\uff0c\u6700\u540e\u5728\u4e0e\u4e4b\u524d\u6700\u5927\u7684res\u6bd4\u8f83\uff0c\u8981\u662fres\u6bd4\u8f83\u5927\uff0c\u90a3\u5c31\u66ff\u4ee3\u6389\u539f\u6765\u7684res\n                    res = max(res, grid[newx][newy] + DFS(grid, newx, newy))\n\n            # \u6bcf\u6b21\u5faa\u73af\u5b8c\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u70b9\u540e\uff0c\u518d\u628a\u539f\u5148\u7684\u70b9\u6807\u8bb0\u4e3a\u6ca1\u6709\u6d4f\u89c8\u8fc7\uff0c\u662f\u4e3a\u4e86\u540e\u9762 \u91cd\u590d\u5bfb\u627e\uff01\n            visited[startx][starty] = False\n            return res\n\n        record_each_result = []\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0 and (not visited[i][j]):\n                    result = grid[i][j] + DFS(grid, i, j) \n                    record_each_result.append(result)\n\n\n        #final result\n        final_result = max(record_each_result)\n        #print(final_result)\n        return final_result\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        visited = set()\n        m, n = len(grid), len(grid[0])\n        def isValid(x, y):\n            return 0 <= x < m and 0 <= y < n\n        \n        dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n        def dfs(x, y):\n            if grid[x][y] == 0:\n                return 0\n            visited.add((x, y))\n            ans = 0\n            for dx, dy in dirs:\n                if isValid(x + dx, y + dy) and (x + dx, y + dy) not in visited:\n                    ans = max(ans, dfs(x + dx, y + dy))\n            visited.remove((x, y))\n            return ans + grid[x][y]\n        \n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i, j))\n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        rrange = range(len(grid))\n        crange = range(len(grid[0]))\n        max_sum = 0\n        def helper(row, col, running_sum = 0):\n            nonlocal max_sum\n            if not (row in rrange and col in crange and grid[row][col] > 0):\n                max_sum = max(max_sum, running_sum)\n                return\n            running_sum += grid[row][col]\n            grid[row][col] *= -1\n            helper(row + 1, col, running_sum)\n            helper(row, col + 1, running_sum)\n            helper(row - 1, col, running_sum)\n            helper(row, col - 1, running_sum)\n            grid[row][col] *= -1\n        for row in rrange:\n            for col in crange:\n                if grid[row][col] > 0:\n                    helper(row, col)\n        return max_sum", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        numRows =len(grid)\n        numCols = len(grid[0])\n        self.maxResult = float('-inf')\n        for r in range(numRows):\n            for c in range(numCols):\n                if grid[r][c]>0:\n                    self._getMaxGoldHelper(grid,r,c,0)\n        return self.maxResult\n    def _getMaxGoldHelper(self,grid,r,c,currSum):\n        if r<0 or c<0 or r>=len(grid) or c>=len(grid[0]) or grid[r][c]<=0:\n            return\n        currSum += grid[r][c]\n        self.maxResult = max(self.maxResult,currSum)\n        grid[r][c] *= -1\n        for dir in[(0,1),(0,-1),(1,0),(-1,0)]:\n            self._getMaxGoldHelper(grid,r+dir[0],c+dir[1],currSum)\n        grid[r][c] *= -1\n", "class Solution(object):\n    def getMaximumGold(self, grid):\n\n        self.ans = 0\n        def helper(grid, i, j, s):\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j]:\n                tmp = grid[i][j] \n                grid[i][j] = 0\n                helper(grid, i+1, j, s + tmp)\n                helper(grid, i-1, j, s + tmp)\n                helper(grid, i, j+1, s + tmp)\n                helper(grid, i, j-1, s + tmp)\n                grid[i][j] = tmp\n                \n            else:\n                self.ans = max(self.ans, s)\n                \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]:    \n                    helper(grid, i, j, 0)\n        \n        return self.ans\n                    \n\n                \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.max_gold = 0\n        self.row = len(grid)\n        self.col = len(grid[0])\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]:\n                    self.search_gold(grid,i,j,0)\n        \n        return self.max_gold\n    \n    def search_gold(self,grid,i,j,val):\n        pos = [(1,0),(-1,0),(0,1),(0,-1)]\n        if i >= 0 and j >= 0 and i<self.row and j<self.col and grid[i][j]:\n            temp = grid[i][j]\n            val += grid[i][j]\n            grid[i][j] = 0\n            self.max_gold = max(self.max_gold,val)\n\n            for x,y in pos:\n                self.search_gold(grid,x+i,y+j,val)\n            \n            grid[i][j] = temp", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.dirs = ((1,0), (0,1), (-1,0), (0,-1))\n        self.nrow = len(grid)\n        self.ncol = len(grid[0])\n        \n        max_gold = 0\n        \n        for i in range(self.nrow):\n            for j in range(self.ncol):\n                if grid[i][j] != 0:\n                    max_seen = self._dfs(grid, i, j, set())\n                    \n                    if max_seen > max_gold:\n                        max_gold = max_seen\n        \n        return max_gold\n        \n    def _dfs(self, grid, i, j, visited):\n        child_max = []\n        visited.add((i,j))\n        \n        for dx, dy in self.dirs:\n            if 0 <= i+dx < self.nrow and 0 <= j+dy < self.ncol:\n                if grid[i+dx][j+dy] != 0 and (i+dx, j+dy) not in visited:\n                    dir_sum = self._dfs(grid, i+dx, j+dy, visited)\n                    child_max.append(dir_sum)\n                    \n        visited.remove((i,j))\n        \n        max_child = max(child_max) if child_max else 0\n        \n        return grid[i][j] + max_child\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        totals = []\n        \n        def mine(m, n, g, x):\n            \n            if m >= 0 and m < len(x) and n >= 0 and n < len(x[m]) and x[m][n] > 0:\n                g += x[m][n]\n                \n                backup = x[m][n]\n                x[m][n] = 0\n                \n                mine(m + 1, n, g, x)\n                mine(m - 1, n, g, x)\n                mine(m, n + 1, g, x)\n                mine(m, n - 1, g, x)\n                \n                x[m][n] = backup\n            \n            totals.append(g)\n        \n        for m in range(0, len(grid)):\n            for n in range(0, len(grid[m])):\n                mine(m, n, 0, deepcopy(grid))\n        \n        return max(totals)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.max_gold = 0\n        self.row = len(grid)\n        self.col = len(grid[0])\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                self.search_gold(grid,i,j,0)\n        \n        return self.max_gold\n    \n    def search_gold(self,grid,i,j,val):\n        pos = [(1,0),(-1,0),(0,1),(0,-1)]\n        if i >= 0 and j >= 0 and i<self.row and j<self.col and grid[i][j]:\n            temp = grid[i][j]\n            val += grid[i][j]\n            grid[i][j] = 0\n            self.max_gold = max(self.max_gold,val)\n\n            for x,y in pos:\n                self.search_gold(grid,x+i,y+j,val)\n            \n            grid[i][j] = temp", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        mx = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                mx = max(mx, self.helper(grid, i, j))\n        return mx\n    \n    def helper(self, grid, i, j):\n        if grid[i][j] == 0:\n            return 0\n        res = grid[i][j]\n        newGrid = [row.copy() for row in grid]\n        newGrid[i][j] = 0\n        up, down, left, right = 0, 0, 0, 0\n        if i-1 >= 0:\n            up = self.helper(newGrid, i-1, j)\n        if i+1 < len(grid):\n            down = self.helper(newGrid, i+1, j)\n        if j-1 >= 0:\n            left = self.helper(newGrid, i, j-1)\n        if j+1 < len(grid[0]):\n            right = self.helper(newGrid, i, j+1)\n        res += max(up, down, left, right)\n        return res", "import copy\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.max = 0\n        for i in range(0, len(grid)):\n            for j in range(0, len(grid[0])):\n                if grid[i][j] != 0:\n                    self.helper(grid, i, j, 0)\n        return self.max\n        \n    def helper(self, grid, i, j, goldCount):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n            self.max = max(self.max, goldCount)\n            return\n        goldCount += grid[i][j]\n        val = grid[i][j]\n        grid[i][j] = 0\n        self.helper(grid, i+1, j, goldCount)\n        self.helper(grid, i-1, j, goldCount)\n        self.helper(grid, i, j+1, goldCount)\n        self.helper(grid, i, j-1, goldCount)\n        grid[i][j] = val", "class Solution:\n    \n    def explore(self, grid, row, col):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == 0:\n            return 0\n        total = curr_gold = grid[row][col]\n        max_gold = grid[row][col] = 0\n        for row_offset, col_offset in ((-1, 0), (0, 1), (1, 0), (0, -1)):\n            max_gold = max(max_gold, self.explore(grid, row + row_offset, col + col_offset))\n        grid[row][col] = curr_gold\n        return total + max_gold\n    \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        max_gold = 0\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                max_gold = max(max_gold, self.explore(grid, row, col))\n        return max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n      \n        if not grid or not grid[0]: return 0\n        \n        self.max_gold = 0\n        \n        rows = len(grid)\n        cols = len(grid[0])\n        \n        for row in range(rows):\n            for col in range(cols):\n                self.dfs(grid, row, col, 0)\n        \n        return self.max_gold\n    \n    def dfs(self, grid, row, col, gold):\n        rows = len(grid)\n        cols = len(grid[0])\n        \n        if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0:\n            return\n        \n        prev_gold = grid[row][col]\n        \n        grid[row][col] = 0\n        \n        gold += prev_gold\n        self.max_gold = max(self.max_gold, gold)\n        \n        for drow, dcol in [(row+1,col),(row-1,col),(row,col+1),(row,col-1)]:\n            self.dfs(grid, drow, dcol, gold)\n            \n        grid[row][col] = prev_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def getMaxGold(y,x,gold):\n            if y < 0 or y >= m or x < 0 or x >= n or grid[y][x] == 0: return gold\n            gold += grid[y][x]\n            origin, grid[y][x] = grid[y][x], 0\n            maxGold = 0\n            for ax,ay in action:\n                maxGold = max(getMaxGold(y+ay,x+ax,gold),maxGold)\n                #maxGold = max(getMaxGold(y+ay,x+ax,gold),maxGold)\n            grid[y][x] = origin\n            #return maxGold + origin\n            return maxGold\n            \n        action = [(1,0),(0,1),(-1,0),(0,-1)]\n        m, n = len(grid), len(grid[0])\n        return max(getMaxGold(y,x,0) for x in range(n) for y in range(m))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m=len(grid)\n        n=len(grid[0])\n        def dfs(x,y,visited,res):\n            \n            maxi=res[::]\n            for (i,j) in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:\n                if i>=0 and i<m and j>=0 and j<n and grid[i][j]>0 and (i,j) not in visited:\n                    visited.add((i,j))\n                    res.append(grid[i][j])\n                    result=dfs(i,j,visited,res)\n                    maxi=maxi if sum(maxi)>sum(result) else result\n                    # print(x,y,i,j,result)\n                    res.pop()\n                    visited.remove((i,j))\n            # print(x,y,maxi)\n            return maxi\n\n        maxi=0\n        for i in range (m):\n            for j in range(n):\n                if grid[i][j]>0:\n                    visited=set()\n                    res=[]\n                    res.append(grid[i][j])\n                    visited.add((i,j))\n                    result=dfs(i,j,visited,res)\n                    # visited.remove((i,j))\n                    # print(result)\n                    maxi=max(maxi,sum(result))\n        return maxi\n                    \n                \n", "class Solution:\n    def _getMaximumGold(self, cur_sum, i, j, grid):\n        m = len(grid)\n        n = len(grid[0])\n\n        max_sum = cur_sum\n\n        if i+1 < m and grid[i+1][j] != 0:\n            val = grid[i+1][j]\n            grid[i+1][j] = 0\n\n            temp_max_sum = self._getMaximumGold(cur_sum + val, i+1, j, grid)\n\n            grid[i+1][j] = val\n\n            if temp_max_sum > max_sum:\n                max_sum = temp_max_sum\n\n        if j+1 < n and grid[i][j+1] != 0:\n            val = grid[i][j+1]\n            grid[i][j+1] = 0\n\n            temp_max_sum = self._getMaximumGold(cur_sum + val, i, j+1, grid)\n\n            grid[i][j+1] = val\n\n            if temp_max_sum > max_sum:\n                max_sum = temp_max_sum\n\n        if i-1 >= 0 and grid[i-1][j] != 0:\n            val = grid[i-1][j]\n            grid[i-1][j] = 0\n\n            temp_max_sum = self._getMaximumGold(cur_sum + val, i-1, j, grid)\n            \n            grid[i-1][j] = val\n\n            if temp_max_sum > max_sum:\n                max_sum = temp_max_sum\n\n        if j-1 >= 0 and grid[i][j-1] != 0:\n            val = grid[i][j-1]\n            grid[i][j-1] = 0\n\n            temp_max_sum = self._getMaximumGold(cur_sum + val, i, j-1, grid)\n\n            grid[i][j-1] = val\n\n            if temp_max_sum > max_sum:\n                max_sum = temp_max_sum\n\n        return max_sum\n\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if grid is None:\n            return 0\n\n        m = len(grid)\n        n = len(grid[0])\n\n        total_max_sum = 0\n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    continue\n\n                start = grid[i][j]\n                grid[i][j] = 0\n\n                max_sum = self._getMaximumGold(start, i, j, grid)\n\n                if max_sum > total_max_sum:\n                    total_max_sum = max_sum\n\n                grid[i][j] = start\n\n        return total_max_sum\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        max_g = 0\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if(grid[i][j] == 0):\n                    continue\n                max_g = max(max_g,self.dfs(i,j,grid))\n        return max_g\n                \n    def dfs(self, i, j, grid):\n        if(i < 0 or j<0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0):\n            return 0\n        temp = grid[i][j]\n        grid[i][j] = 0\n        res = 0\n        for di, dj in [(0,1),(1,0),(0,-1),(-1,0)]:\n            res = max(res, temp+self.dfs(i+di,j+dj,grid))\n        grid[i][j] = temp\n        return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:                    \n        def dfs(row, col, cur_sum, visited):\n            if row<0 or col<0 or row>=len(grid) or col>=len(grid[0]) or visited[row][col]==1 or grid[row][col]==0:\n                return\n            visited[row][col] = 1\n            cur_sum += grid[row][col]\n            self.max_path = max(self.max_path, cur_sum)\n            for r, c in ((row+1, col), (row-1, col), (row, col-1), (row, col+1)):\n                dfs(r, c, cur_sum, visited)\n            visited[row][col] = 0\n\n        visited = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\n        self.max_path = 0\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] != 0:\n                    dfs(row, col, 0, visited)\n        return self.max_path\n        \n        \n\n                \n        \n        \n                        \n                        \n                    \n", "class Solution:\n    def dfs(self, cur_gold, max_gold, grid, visited, i, j):\n        if (i < 0) or (i >= len(grid)) or (j < 0) or (j >= len(grid[0])) or (visited[i][j] == 1) or (grid[i][j] == 0):\n            return\n        visited[i][j] = 1\n        self.dfs(cur_gold + grid[i][j], max_gold, grid, visited, i + 1, j)\n        self.dfs(cur_gold + grid[i][j], max_gold, grid, visited, i - 1, j)\n        self.dfs(cur_gold + grid[i][j], max_gold, grid, visited, i, j + 1)\n        self.dfs(cur_gold + grid[i][j], max_gold, grid, visited, i, j - 1)\n        max_gold[0] = max(max_gold[0], cur_gold + grid[i][j])\n        visited[i][j] = 0\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        visited = [[0 for i in range(n)] for j in range(m)]\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    max_gold = [0]\n                    visited = [[0 for i in range(n)] for j in range(m)]\n                    self.dfs(0, max_gold, grid, visited, i, j)\n                    # print(\\\"i j cur_max: \\\", i, j, max_gold[0])\n                    res = max(res, max_gold[0])\n        return res", "class Solution:\n    \n    def maxgold(self, grid, i, j, visited={}):\n        ##search for max gold path from i,j\n        if 0 <= i and i< len(grid) and j>=0 and j<len(grid[0]):\n            # print((i,j))\n            if (i,j) not in visited or visited[(i,j)]==0:\n                visited[(i,j)] = 1\n                if grid[i][j]!=0:\n                    value = grid[i][j] +  max(self.maxgold(grid, i+1, j, visited), self.maxgold(grid, i-1, j, visited), self.maxgold(grid, i, j+1, visited), self.maxgold(grid, i, j-1, visited))\n                    visited[(i,j)] = 0\n                    return value\n        \n        return 0\n        \n        \n    \n    \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        ##at each grid[i][j] such that\n        \n        val = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    ## do a search starting from grid[i][j]\n                    # print(self.maxgold(grid,i,j, {}))\n                    candidate = self.maxgold(grid,i,j,{})\n                    if candidate > val:\n                        val = candidate\n        \n        return val", "DIRECTIONS = [[1, 0], [-1, 0], [0, 1], [0, -1]]\nclass Solution:\n    def dfs(self, grid, i, j, memo):\n        if memo[i][j]:\n            return 0\n        memo[i][j] = True\n        gold = 0\n        for direction in DIRECTIONS:\n            x = i + direction[0]\n            y = j + direction[1]\n            if x >= 0 and x < len(grid) and y >= 0 and y < len(grid[0]) and grid[x][y] != 0:\n                gold = max(gold, self.dfs(grid, x, y, memo))\n        memo[i][j] = False\n        return gold + grid[i][j]\n                \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid or len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n        max_gold = 0\n        visited = [[0] * len(grid[0]) for _ in range(len(grid))]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 0 or visited[i][j]:\n                    continue\n                max_gold = max(max_gold, self.dfs(grid, i, j, visited))\n        return max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        output = 0\n        direcs = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n        def dfs(i, j, gold, seen):\n            nonlocal output\n            if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]) or grid[i][j] == 0:\n                output = max(output, gold)\n                return\n            gold += grid[i][j]\n            for di, dj in direcs:\n                if (i + di, j + dj) not in seen:\n                    seen.add((i + di, j + dj))\n                    dfs(i + di, j + dj, gold, seen)\n                    seen.remove((i + di, j + dj))\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0: dfs(i, j, 0, {(i, j)})\n        return output", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        maxy = [0]\n\n        print (grid)\n        def gold(grid,summ,i,j):\n    \n            if i<=len(grid)-1 and i>-1 and j<=len(grid[0])-1 and j>-1 and grid[i][j]!=0:\n        \n                temp = grid[i][j]\n    \n                grid[i][j]=0\n                gold(grid,summ+temp,i+1,j)\n                gold(grid,summ+temp,i,j+1)\n                gold(grid,summ+temp,i-1,j)\n                gold(grid,summ+temp,i,j-1)\n                grid[i][j]= temp\n            else:\n                maxy[0]=max(maxy[0],summ)\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]!=0:\n                    gold(grid,0,i,j)\n        return (maxy[0])\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.max_gold = 0 \n        def backtrack(grid, row, col, current):   \n            if 0<= row < len(grid) and 0<=col < len(grid[0]) and grid[row][col]:\n                temp = grid[row][col]\n                grid[row][col] = 0\n                for drow, dcol in [(0, 1), (1,0), (-1, 0), (0, -1)]:\n                    backtrack(grid, row+drow, col+dcol, current+temp)\n                grid[row][col] = temp \n            else:\n                self.max_gold = max(self.max_gold, current)\n\n                \n        #search for each grid \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]:\n                    backtrack(grid, i, j, 0 )\n        return self.max_gold\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        ### start with pos that dosen't have value above\n        def dfs(i: int, j: int, visited: List[List[int]]) -> int:\n            \n            result = grid[i][j]\n            for x, y in [[1,0], [0,1], [0,-1], [-1,0]]:\n                n_x, n_y = i + x, j+y              \n                if 0<=n_x< len(grid) and 0 <= n_y < len(grid[0]) and grid[n_x][n_y] and not visited[n_x][n_y]:\n                    visited[n_x][n_y] = 1\n                    child = dfs(n_x, n_y, visited)\n                    result = max(child + grid[i][j], result)\n                    visited[n_x][n_y] = 0\n                    \n            return result         \n        \n        total = 0\n        \n        visited = [[0] * len(grid[0]) for _ in range(len(grid))]\n        for i, row in enumerate(grid):\n            for j, v in enumerate(row):\n                if (i>0 and i < len(grid)-1 and grid[i-1][j] > 0 and grid[i+1][j] >0) and grid[i][j]:\n                    pass                    \n                elif grid[i][j]:\n                    visited[i][j] = 1 \n                    total = max(dfs(i, j, visited), total)\n                    visited[i][j] = 0\n                    \n        \n        return total\n                    \n                    \n                    \n        \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def max_gold(i, j):\n            if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0:\n                return 0\n            origin = grid[i][j]\n            grid[i][j] = 0\n            max_count = 0\n            for ni, nj in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                max_count = max(max_gold(ni, nj), max_count)\n            grid[i][j] = origin\n            return max_count + origin\n        \n        mx = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                mx = max(mx, max_gold(i, j))\n        \n        return mx\n", "class Solution:\n    def __init__(self):\n        self.EMPTY = 0\n        self.DIR = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        max_gold = 0\n        \n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != self.EMPTY:\n                    visited = set()\n                    visited.add((i, j))\n                    max_gold = max(max_gold, self.dfs(grid, i, j, visited))\n                    \n        return max_gold\n    \n    def dfs(self, grid, i, j, visited):\n        gold = 0\n        \n        for delta_i, delta_j in self.DIR:\n            next_i, next_j = i + delta_i, j + delta_j\n            \n            if not self.inbound(grid, next_i, next_j) or (next_i, next_j) in visited or grid[next_i][next_j] == self.EMPTY:\n                continue\n            \n            visited.add((next_i, next_j))\n            gold = max(gold, self.dfs(grid, next_i, next_j, visited))\n            visited.discard((next_i, next_j))\n        \n        return gold + grid[i][j]\n        \n    def inbound(self, grid, x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0])", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        \n        def collect(x,y):\n            if not (0<=x<m and 0<=y<n and grid[x][y]!=0):\n                return 0\n            gold, grid[x][y] = grid[x][y], 0\n            choices = [collect(x+i, y+j) for i,j in [(1,0),(0,1),(-1,0),(0,-1)]]\n            grid[x][y]=gold\n            \n            return gold+max(choices) \n        \n        return max(collect(x,y) for x in range(m) for y in range(n))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def nextPos(r, c):\n            if r > 0:\n                yield r-1, c\n            if r < m-1:\n                yield r+1, c\n            if c > 0:\n                yield r, c-1\n            if c < n-1:\n                yield r, c+1\n                \n        self.mx = 0\n        \n        def backtrack(r, c, visited, gold):\n            self.mx = max(self.mx, gold)\n            for nr, nc in nextPos(r, c):\n                if not visited[nr][nc] and grid[nr][nc] > 0:\n                    gold += grid[nr][nc]\n                    visited[nr][nc] = True\n                    backtrack(nr, nc, visited, gold)\n                    \n                    gold -= grid[nr][nc]\n                    visited[nr][nc] = False\n        \n            \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                visited = [[False for _ in range(n)] for _ in range(m)]\n                visited[i][j] = True\n                if grid[i][j] > 0:\n                    backtrack(i, j, visited, grid[i][j])\n        return self.mx", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def helper(i, j, a):\n            if i in [-1, len(grid)] or j in [-1, len(grid[0])] or grid[i][j] in [-1, 0]:\n                return a\n            y = grid[i][j]; x = a + y; \n            grid[i][j] = -1\n            a = max(helper(i+1, j, x), helper(i-1, j, x), helper(i, j+1, x), helper(i, j-1, x))\n            grid[i][j] = y\n            return a\n            \n        ans = -1\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                ans = max(ans, helper(i, j, 0))\n              \n        return ans\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        result = [float('-inf')]\n        \n        m, n = len(grid), len(grid[0])\n        visited = [[False for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):                \n                self.backtrack(grid, i, j, m, n, visited, result, 0)\n                        \n        return result[0]\n    \n    \n    def isValid(self, grid, i, j, m, n, vis):\n        return 0 <= i < m and 0 <= j < n and grid[i][j] != 0 and vis[i][j] == False\n    \n    \n    def backtrack(self, grid, i, j, m, n, vis, result, ttl):\n        if self.isValid(grid, i, j, m, n, vis):\n            newttl = ttl + grid[i][j]\n            \n            result[0] = max(result[0], newttl)\n            # newVis = vis.copy()\n            vis[i][j] = True\n            \n            \n            # Up\n            self.backtrack(grid, i-1, j, m, n, vis, result, newttl)\n            \n            # Left\n            self.backtrack(grid, i, j-1, m, n, vis, result, newttl)\n            \n            # Bottom\n            self.backtrack(grid, i+1, j, m, n, vis, result, newttl)\n            \n            # Right\n            self.backtrack(grid, i, j+1, m, n, vis, result, newttl)\n            \n            vis[i][j] = False", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def search(x, y):\n            if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]) or grid[x][y] == 0:\n                return 0\n            origin = grid[x][y]\n            grid[x][y] = 0 # mark as visited\n            \n            maxGold = 0\n            \n            for nx, ny in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):\n                maxGold = max(maxGold, search(nx, ny))\n                \n            grid[x][y] = origin\n            \n            return maxGold + origin\n            \n        return max(search(i, j) for i in range(len(grid)) for j in range(len(grid[0])))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        di = [(-1,0), (0,1), (1,0), (0,-1)]\n        ans = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    v = self.bfs(grid, i, j, di)\n                    # print(f'{v=} | {i=} | {j=}')\n                    ans = max(ans, v)\n        return ans\n                        \n    def bfs(self, A, r, c, di):\n        q = collections.deque([[r, c, A[r][c], {(r,c)}]])\n        mx = 0\n        while q:\n            x,y,n,seen = q.popleft()\n            seen.add((x,y))\n            mx = max(mx, n)\n            # print(f'{r=} | {c=} | {x=} | {y=} | {n=} | {mx=} | {seen=}')\n            for i,j in di:\n                nx,ny = x+i, y+j\n                if (nx,ny) not in seen and 0 <= nx < len(A) and 0 <= ny < len(A[0]) and A[nx][ny] != 0:\n                    q.append([nx, ny, n+A[nx][ny], seen.copy()])\n        return mx\n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        At each square, look at adjacent squares.\n        \n        If adjacent square is 0 then skip\n        If adjacent square has already been visited during this path then skip\n        If adjacent square is not in bounds of grid then skip\n        \n        Else add it to the list of squares visited on this path, then explore\n        that adjacent square.\n        \n        If there are no more adjacent squares to visit, then\n        record the path total and update the nonlocal total.\n        \n        Caveats:\n            - We can't cache because the max path from a square differs depending on the preceding path\n        \\\"\\\"\\\"\n        self.max_gold = 0\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        def dfs(path_gold = 0, i = 0, j = 0):\n            g = grid[i][j]\n            if g == 0:\n                if path_gold > self.max_gold:\n                    self.max_gold = path_gold\n                return\n            \n            curr_path_gold = path_gold + g\n            grid[i][j] = 0\n            if i > 0:\n                dfs(curr_path_gold, i - 1, j)\n            if i < m-1:\n                dfs(curr_path_gold, i + 1, j)\n\n            if j > 0:\n                dfs(curr_path_gold, i, j - 1)\n            if j < n-1:\n                dfs(curr_path_gold, i, j + 1)\n            grid[i][j] = g\n        \n        for i in range(m):\n            for j in range(n):\n                dfs(i = i, j = j)\n        \n        return self.max_gold\n            \n        \n            \n                \n                    ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        res = 0\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        \n\n        def dfs(i, j, sum):\n            if not( 0 <= i < m and 0 <= j < n) or grid[i][j] == 0:\n                return sum\n            sum += grid[i][j]\n            mx = 0\n            tmp = grid[i][j]\n            grid[i][j] = 0 \n            for x, y in [[i, j+1], [i, j-1], [i-1, j], [i+1, j]]:\n                mx = max(mx, dfs(x, y, sum))\n            grid[i][j] = tmp\n            return mx\n            \n\n            \n        max_val = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    max_val = max(max_val, dfs(i, j, 0))\n        return max_val\n        ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, sum: int) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or not grid[i][j] or grid[i][j] > 100:\n                return sum \n            sum += grid[i][j]\n            grid[i][j] += 1000\n            mx = 0\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                mx = max(dfs(x, y, sum), mx)\n            grid[i][j] -= 1000\n            return mx\n\n        m, n = len(grid), len(grid[0])\n        return max(dfs(i, j, 0) for j in range(n) for i in range(m))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        nrow, ncol = len(grid),len(grid[0])\n        \n        def getMaximumGold_helper(grid, i, j):\n            if i >= nrow or i<0 or j >= ncol or j<0:\n                return 0\n            \n            if grid[i][j] == 0:\n                return 0\n            \n            cur = grid[i][j]\n            grid[i][j] = 0\n            \n            res = cur + max(getMaximumGold_helper(grid,i,j+1),\n                       getMaximumGold_helper(grid,i,j-1),\n                       getMaximumGold_helper(grid,i+1,j),\n                       getMaximumGold_helper(grid,i-1,j))\n            \n            grid[i][j] = cur\n            return res\n    \n        max_gold = 0\n        for i in range(nrow):\n            for j in range(ncol):\n                cur_gold = getMaximumGold_helper(grid, i, j)\n                max_gold = max(max_gold,cur_gold)\n        return max_gold\n            \n            \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        ans = 0\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                \n                if grid[i][j] != 0:\n                    ans = max(ans, self.findGold(grid, i, j))\n        \n        return ans\n    \n    \n    def findGold(self, grid, row, col):\n        \n        if not(0 <= row < len(grid) and 0 <= col < len(grid[0])) or grid[row][col] == 0:\n            return 0\n        \n        ans = 0\n        temp = grid[row][col]\n        grid[row][col] = 0\n        \n        for i,j in [(1,0), (-1,0), (0,1), (0,-1)]:\n            ans = max(ans, self.findGold(grid, row+i, col+j))\n        \n        grid[row][col] = temp\n        return ans + temp\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        R, C = len(grid), len(grid[0])\n        self.visited = [[False] * C for _ in range(R)]\n        ans = 0\n        def dfs(grid, r, c, R, C):\n            if r < 0 or c < 0 or r >= R or c >= C or self.visited[r][c] or grid[r][c] == 0: return 0\n            self.visited[r][c] = True\n            max_ = max(dfs(grid, r-1, c, R, C), dfs(grid, r+1, c, R, C), dfs(grid, r, c-1, R, C), dfs(grid, r, c+1, R, C)) + grid[r][c]\n            self.visited[r][c] = False\n            return max_\n        \n        for r in range(R):\n            for c in range(C):\n                ans = max(ans, dfs(grid, r,c, R, C))\n        \n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, sum: int, seen: set) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or not grid[i][j] or (i, j) in seen:\n                return sum \n            seen.add((i, j))\n            sum += grid[i][j]\n            mx = 0\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                mx = max(dfs(x, y, sum, seen), mx)\n            seen.discard((i, j))   \n            return mx\n\n        m, n = len(grid), len(grid[0])\n        return max(dfs(i, j, 0, set()) for j in range(n) for i in range(m))\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        marked=[[False]*len(grid[0]) for i in range(len(grid))]\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c]==0:\n                    marked[r][c]=True\n        def visit(r,c,markL):\n            if r<0 or c<0 or r>=len(grid) or c>=len(grid[0]):\n                return 0\n            if markL[r][c]:\n                return 0\n            copy=list(map(list,markL))\n            copy[r][c]=True\n            return grid[r][c]+max(visit(r+1,c,copy),visit(r-1,c,copy),visit(r,c-1,copy),visit(r,c+1,copy))\n        maximum=-1\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if not marked[r][c]:  \n                    maximum=max(maximum,visit(r,c,marked))\n        print(marked)\n        return maximum\n", "def viable_neighbors(grid, coord):\n    y, x = coord\n    possible_coords = [\n        (y - 1, x),\n        (y, x + 1),\n        (y + 1, x),\n        (y, x - 1),\n    ]\n    viable_coords = []\n    for possible_y, possible_x in possible_coords:\n        if 0 <= possible_y < len(grid) and 0 <= possible_x < len(grid[0]) and grid[possible_y][possible_x] != 0:\n            viable_coords.append((possible_y, possible_x))\n            \n    return viable_coords\n\n\ndef dfs(grid, coord, visited, gold):\n    visited.add(coord)\n    neighbors = viable_neighbors(grid, coord)\n    new_gold = gold + grid[coord[0]][coord[1]]\n    \n    possible_golds = []\n    \n    for neighbor in neighbors:\n        if neighbor not in visited:\n            explored_gold = dfs(grid, neighbor, visited, new_gold)\n            possible_golds.append(explored_gold)\n    \n    visited.remove(coord)\n    return max(possible_golds or [new_gold])\n            \ndef solve(grid):\n    max_gold = 0\n    visited = set()\n    \n    for y, row in enumerate(grid):\n        for x, gold_amount in enumerate(row):\n            if gold_amount != 0:\n                gold_found = dfs(grid, (y, x), visited, 0)\n                if gold_found > max_gold:\n                    max_gold = gold_found\n            \n            visited.clear()\n            \n    return max_gold\n\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        data\n        \n        grid of m * n size, with integers in it. 0 means the grid should not be traversed\n        find the maximum gold possible gained from board if you start from _any_ position of the grid\n        \n        brute force: iterate through every cell in the grid as a starting point. perform depth first traversal on every neighbor node\n        and add up the total gold collected. save the largest collection and return the value.\n        \n        since each node can only be visited once, we have to explore possibilities, we need to explore every possibility and greedily get the biggest one\n        \n        \n        \n        \\\"\\\"\\\"\n        return solve(grid)", "DIRS = [(-1,0),(1,0),(0,-1),(0,1)]\nclass Solution:\n    def getMaximumGold(self, grid):\n        \n        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j, seen):\n            if i >= m or i < 0 or j >= n or j < 0 or (i,j) in seen or grid[i][j] == 0:\n                return 0\n            gold = 0\n            seen.add((i,j))\n            for i_inc, j_inc in DIRS:\n                ni, nj = i+i_inc, j+j_inc\n                gold = max(gold, dfs(ni, nj, seen))\n            seen.remove((i,j))\n            return gold + grid[i][j]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dfs(i, j, set()))\n        return res\n            \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def findMaxGold(grid, i, j):\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] > 0:\n                origin = grid[i][j] \n                grid[i][j] = 0      \n                d = [(1, 0), (0, -1), (-1, 0), (0, 1)]\n                maxGold = 0\n                for d1, d2 in d:\n                    maxGold = max(maxGold, findMaxGold(grid, i+d1, j+d2))\n                grid[i][j] = origin    \n                return origin + maxGold\n            else:\n                return 0                   \n            \n        maxGold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                maxGold = max(maxGold, findMaxGold(grid, i, j))\n        return maxGold    ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid: return 0\n        m,n=len(grid),len(grid[0])\n        \n        result = 0\n        best_path = set()\n        def dfs(i,j, visited, res):\n            nonlocal result, best_path\n            if res > result: \n                best_path=visited\n                result = res\n            for (a,b) in [(-1,0),(1,0),(0,-1),(0,1)]:\n                ci,cj = a+i,b+j\n                if 0<=ci<m and 0<=cj<n and (ci,cj) not in visited and grid[ci][cj]!=0:\n                    dfs(ci,cj, visited|set([(ci,cj)]), res+grid[ci][cj])\n    \n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]!=0 and (i,j) not in best_path:\n                    dfs(i,j,set([(i,j)]), grid[i][j])\n        return result ", "class Solution:\n    def getDegree(self, i, j, grid: List[List[int]]) -> int:\n        deg = 0\n        if i > 0 and grid[i-1][j] > 0:\n            deg += 1\n        if i < len(grid) - 1 and grid[i+1][j] > 0:\n            deg += 1  \n        if j > 0 and grid[i][j-1] > 0:\n            deg += 1\n        if j < len(grid[0]) - 1 and grid[i][j+1] > 0:\n            deg += 1\n        return deg\n    \n    def traverseMaxGoldDfs(self, i, j, grid) -> int:\n        # use dfs to get the max gold.\n        degree = self.getDegree(i, j, grid)\n        if degree == 0:\n            return grid[i][j]\n        \n        # then, check neighbours\n        temp = grid[i][j]\n        grid[i][j] = 0\n        gold = temp\n        res = 0\n        if i > 0 and grid[i-1][j] > 0:\n            res = max(res, self.traverseMaxGoldDfs(i-1, j, grid))\n        if i < len(grid) - 1 and grid[i+1][j] > 0:\n            res = max(res, self.traverseMaxGoldDfs(i+1, j, grid))\n        if j > 0 and grid[i][j-1] > 0:\n            res = max(res, self.traverseMaxGoldDfs(i, j-1, grid))\n        if j < len(grid[0]) - 1 and grid[i][j+1] > 0:\n            res = max(res, self.traverseMaxGoldDfs(i, j+1, grid))\n            \n        gold = max(gold, temp + res)  \n        grid[i][j] = temp\n        return gold\n    \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        maxGold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                degree = self.getDegree(i, j, grid)\n                if grid[i][j] > 0 and (degree <= 1 or degree  > 2):\n                    # traverse using bfs from here. \n                    gold = self.traverseMaxGoldDfs(i, j, grid)\n                    if gold > maxGold:\n                        maxGold = gold\n        return maxGold\n", "class Solution:\n    \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.row = len(grid)\n        self.col = len(grid[0])\n        self.res = 0\n        for i in range(self.row):\n            for j in range(self.col):\n                self.dfs(i, j, 0, grid)\n        return self.res\n    \n    def dfs(self, i, j, addition, grid):\n        if(i<0 or j<0 or i>=self.row or j>=self.col or grid[i][j] == 0 or grid[i][j] == \\\"#\\\"):\n            self.res = max(addition, self.res)\n            return\n        temp = grid[i][j]\n        grid[i][j] = \\\"#\\\"\n        self.dfs(i+1, j, addition+temp, grid)\n        self.dfs(i-1, j, addition+temp, grid)\n        self.dfs(i, j+1, addition+temp, grid)\n        self.dfs(i, j-1, addition+temp, grid)\n        grid[i][j] = temp\n        \n            \n            ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        \n        R = len(grid)\n        C = len(grid[0])\n        self.res = 0\n        \n        def backtrack(i,j, cur_gold):\n            self.res = max(self.res, cur_gold)\n            \n            if 0<=i<R and 0<=j<C and grid[i][j]!=0:\n                gold = grid[i][j]\n                grid[i][j]=0\n                backtrack(i+1, j,cur_gold+gold)\n                backtrack(i-1,j,cur_gold+gold)\n                backtrack(i,j+1,cur_gold+gold)\n                backtrack(i,j-1,cur_gold+gold)\n                grid[i][j]=gold\n            \n        \n        \n        \n        for i in range(R):\n            for j in range(C):\n                if grid[i][j]!=0:\n                    backtrack(i,j,0)\n        return self.res\n                \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m,n = len(grid), len(grid[0])\n        visited = set()\n        \n        def DFS(i,j,sum):\n            if i<0 or i==m or j<0 or j==n or grid[i][j]==0 or grid[i][j]>100:\n                return sum\n            sum += grid[i][j]\n            grid[i][j] += 101\n            maxi = 0\n            for x,y in [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]:\n                maxi = max(maxi, DFS(x,y,sum))\n            grid[i][j] -= 101\n            return maxi\n        \n        return max(DFS(i,j,0) for i in range(m) for j in range(n) if grid[i][j]!=0)", "class Solution():\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, sum_so_far: int, seen: set) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or not grid[i][j] or (i, j) in seen:\n                return sum_so_far \n            \n            seen.add((i, j))\n            sum_so_far += grid[i][j]\n            mx = 0\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                mx = max(dfs(x, y, sum_so_far, seen), mx)\n            seen.discard((i, j))   \n            return mx\n\n        m, n = len(grid), len(grid[0])\n        all_gold_path = []\n        for row in range(m):\n            for col in range(n): \n                all_gold_path.append(dfs(row, col, 0, set()))\n        return max(all_gold_path)\n        # return max(dfs(i, j, 0, set()) for j in range(n) for i in range(m))\n# class Solution:\n#     def getMaximumGold(self, grid: List[List[int]]) -> int:\n#         def findMaxGold(r: int, c: int) -> int:\n#             if r < 0 or r == m or c < 0 or c == n or grid[r][c] == 0: return 0\n#             origin = grid[r][c]\n#             grid[r][c] = 0  # mark as visited\n#             maxGold = 0\n#             for nr, nc in ((r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)):\n#                 maxGold = max(findMaxGold(nr, nc), maxGold)\n#             grid[r][c] = origin  # backtrack\n#             return maxGold + origin\n\n#         m, n = len(grid), len(grid[0])\n#         return max(findMaxGold(r, c) for c in range(n) for r in range(m))\n\n# class Solution:\n#     def getMaximumGold(self, grid: List[List[int]]) -> int:\n#         #2D array \n#         #0 means no gold \n#         #some_num > 0 means there is gold \n#         #Return the max gold you can collect with these conditions\n        \n#         #1) IN w.e cell you are collect ALL the gold in that cell \n#         #From you position move U D L R \n#         #You can't VISIT the same cell more than once. \n#         #You can start and stop collecting gold from ANY position in the grid that has some gold.\n#         visited = set()\n#         max_path = [0]\n#         row_len = len(grid)\n#         col_len = len(grid[0])\n        \n#         def gold_finder(cur_row, cur_col, visited, path_so_far):\n#             #Can't visit area that is zero. \n\n#             #Out of boundary check \n#             if cur_row < 0 or cur_row >= row_len or cur_col < 0 or cur_col >= col_len or grid[cur_row][cur_col] == 0: \n#                 max_path[0] = max(max_path[0], sum(path_so_far))\n#                 return \n#             # if grid[cur_row][cur_col] == 0: \n#             #     return \n                \n#             #If visited we can't visit you again. \n#             if (cur_row, cur_col) in visited: \n#                 return \n            \n#             visited.add((cur_row,cur_col))\n#             gold_finder(cur_row + 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n#             gold_finder(cur_row - 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n#             gold_finder(cur_row , cur_col + 1, visited, path_so_far + [grid[cur_row][cur_col]])\n#             gold_finder(cur_row, cur_col - 1, visited, path_so_far + [grid[cur_row][cur_col]])\n#             visited.remove((cur_row,cur_col))\n            \n#             return \n \n#         for row in range(row_len):\n#             for col in range(col_len): \n#                 gold_finder(row, col, visited, [])\n                \n                \n#         # print('before', max_path)\n#         # max_path = max(max_path)\n#         # print('after', max_path)\n#         return max_path[0]\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def dfs(i,j,runsum):\n            # ending condition ==> when all the nodes around you are visited or zero. there is no way to proceed further\n            runsum+= grid[i][j]\n            visited[i][j] = 1\n            dirr = [(i+1,j),(i,j+1),(i-1,j),(i,j-1)]\n            for r,c in dirr:\n                if r >= 0 and r <len(grid) and c>=0 and c <len(grid[0]):\n                    if visited[r][c] == 0 and grid[r][c]!=0:\n                        dfs(r,c,runsum)\n            visited[i][j] = 0\n            runningmax.append(runsum)\n            \n        def getCleanVisited():            \n            visited = []\n            for i in range(len(grid)):\n                visited.append([])\n                for j in range(len(grid[0])):\n                    visited[i].append(0)\n            return visited\n        \n        \n        overallmax = 0\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                visited = getCleanVisited()\n                runningmax = []\n                dfs(i,j,0)\n                overallmax = max(overallmax,max(runningmax))\n        \n        return overallmax", "class Solution:\n    \n    def maxgold(self, grid, i, j, visited={}):\n        ##search for max gold path from i,j\n        if 0 <= i and i< len(grid) and j>=0 and j<len(grid[0]):\n            # print((i,j))\n            if (i,j) not in visited or visited[(i,j)]==0:\n                visited[(i,j)] = 1\n                if grid[i][j]!=0:\n                    value = grid[i][j] +  max(self.maxgold(grid, i+1, j, visited), self.maxgold(grid, i-1, j, visited), self.maxgold(grid, i, j+1, visited), self.maxgold(grid, i, j-1, visited))\n                    visited[(i,j)] = 0\n                    return value\n        \n        return 0\n        \n        \n    \n    \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        ##at each grid[i][j] such that\n        \n        val = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    ## do a search starting from grid[i][j]\n                    # print(self.maxgold(grid,i,j, {}))\n                    if self.maxgold(grid,i,j,{}) > val:\n                        val = self.maxgold(grid,i,j,{})\n        \n        return val", "class Solution:\n    def traverse(self, pos, path_sum, grid, visited):\n        self.max_sum = max(self.max_sum, path_sum)\n        m = len(grid)\n        n = len(grid[0])\n        x, y = pos\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            xp = x + dx\n            yp = y + dy\n            if xp < m and xp >= 0 and yp < n and yp >= 0 and \\\\\n            grid[xp][yp] and (xp, yp) not in visited:\n                flag = True\n                visited.add((xp, yp))\n                self.traverse((xp, yp), path_sum + grid[xp][yp], grid, visited)\n        visited.remove((x, y))        \n        return\n                    \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.max_sum = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]:\n                    visited = set()\n                    visited.add((i, j))\n                    self.traverse((i, j), grid[i][j], grid, visited)\n        return self.max_sum\n                    ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        nrow, ncol = len(grid),len(grid[0])\n        \n        def getMaximumGold_helper(grid, i, j):\n            if i >= nrow or i<0 or j >= ncol or j<0:\n                return 0\n            \n            if grid[i][j] == 0:\n                return 0\n            \n            cur = grid[i][j]\n            grid[i][j] = 0\n            \n            res = cur + max(getMaximumGold_helper(grid,i,j+1),\n                       getMaximumGold_helper(grid,i,j-1),\n                       getMaximumGold_helper(grid,i+1,j),\n                       getMaximumGold_helper(grid,i-1,j))\n            \n            grid[i][j] = cur\n            return res\n    \n        max_gold = 0\n        for i in range(nrow):\n            for j in range(ncol):\n                print((i,j))\n                cur_gold = getMaximumGold_helper(grid, i, j)\n                print(cur_gold)\n                max_gold = max(max_gold,cur_gold)\n        return max_gold\n            \n            \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        nrow, ncol = len(grid), len(grid[0])\n        \n        max_len = 0\n        def dfs(trajectory, r, c):\n            nonlocal max_len\n            count_neighbor = 0\n            for dr, dc in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < nrow and 0 <= nc < ncol and grid[nr][nc] != 0 and (nr, nc) not in trajectory:\n                    count_neighbor += 1\n                    trajectory.add((nr, nc))\n                    dfs(trajectory, nr, nc)\n                    trajectory.remove((nr, nc))\n\n            if count_neighbor == 0:\n                max_len = max(max_len, sum(grid[i][j] for i, j in trajectory))\n\n        max_len = 0\n        for r in range(nrow):\n            for c in range(ncol):\n                if grid[r][c] != 0:\n                    dfs(set([(r, c)]), r, c)\n\n        return max_len\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        grid_height, grid_width = len(grid), len(grid[0])\n        visited = set()\n        def helper(i, j, gold = 0):\n            if i < 0 or i >= grid_height or j < 0 or j >= grid_width or (i,j) in visited or grid[i][j] == 0:\n                return gold\n            visited.add((i, j))\n            res = 0\n            for (a, b) in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                res = max(helper(i + a, j + b, gold + grid[i][j]), res)\n            visited.remove((i, j))\n            return res\n        return max(helper(i, j) for i in range(grid_height) for j in range(grid_width))", "class Solution:\n    def getMaximumGold(self, A: List[List[int]]) -> int:\n        def dfs(i,j):\n            if not (0<=i<m and 0<=j<n):\n                return 0\n            if A[i][j]==0:\n                return 0\n            if (i,j) in path:\n                return 0\n            path.add((i,j))\n            gold=0\n            for ni,nj in (i-1,j),(i,j+1),(i+1,j),(i,j-1):\n                gold=max(gold,dfs(ni,nj))\n            path.discard((i,j))\n            return A[i][j]+gold\n        \n        ans=0\n        maxpath=set()\n        path=set()\n        m,n=len(A),len(A[0])\n        for i in range(m):\n            for j in range(n):\n                if (i,j) in maxpath:\n                    pass\n                gold=dfs(i,j)\n                if gold>ans:\n                    ans=gold\n                    #maxpath=set(path)\n                path.clear()\n        \n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(grid, i, j):\n            if 0 <= i <len(grid) and 0 <= j <len(grid[0]) and grid[i][j] != 0:\n                temp = grid[i][j]\n                grid[i][j] = 0\n                d = [(1,0),(-1,0),(0,1),(0,-1)]\n                summax = 0\n                for m,n in d:\n                    x = i+m\n                    y = j+n\n                    summax = max(summax, dfs(grid,x,y))\n                grid[i][j]  = temp\n                return temp + summax\n            else:\n                return 0\n        res = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                res = max(res, dfs(grid,i,j))\n        return res\n    \n                \n        \n        \n\n        \n", "class Solution():\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, sum_so_far: int, seen: set) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or not grid[i][j] or (i, j) in seen:\n                return sum_so_far \n            \n            seen.add((i, j))\n            sum_so_far += grid[i][j]\n            mx = 0\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                mx = max(dfs(x, y, sum_so_far, seen), mx)\n            seen.discard((i, j))   \n            return mx\n\n        m, n = len(grid), len(grid[0])\n        all_gold_path = 0\n        for row in range(m):\n            for col in range(n): \n                all_gold_path = max(all_gold_path, dfs(row, col, 0, set()))\n        # print(all_gold_path)\n        return all_gold_path\n        # return max(dfs(i, j, 0, set()) for j in range(n) for i in range(m))\n# class Solution:\n#     def getMaximumGold(self, grid: List[List[int]]) -> int:\n#         def findMaxGold(r: int, c: int) -> int:\n#             if r < 0 or r == m or c < 0 or c == n or grid[r][c] == 0: return 0\n#             origin = grid[r][c]\n#             grid[r][c] = 0  # mark as visited\n#             maxGold = 0\n#             for nr, nc in ((r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)):\n#                 maxGold = max(findMaxGold(nr, nc), maxGold)\n#             grid[r][c] = origin  # backtrack\n#             return maxGold + origin\n\n#         m, n = len(grid), len(grid[0])\n#         return max(findMaxGold(r, c) for c in range(n) for r in range(m))\n\n# class Solution:\n#     def getMaximumGold(self, grid: List[List[int]]) -> int:\n#         #2D array \n#         #0 means no gold \n#         #some_num > 0 means there is gold \n#         #Return the max gold you can collect with these conditions\n        \n#         #1) IN w.e cell you are collect ALL the gold in that cell \n#         #From you position move U D L R \n#         #You can't VISIT the same cell more than once. \n#         #You can start and stop collecting gold from ANY position in the grid that has some gold.\n#         visited = set()\n#         max_path = [0]\n#         row_len = len(grid)\n#         col_len = len(grid[0])\n        \n#         def gold_finder(cur_row, cur_col, visited, path_so_far):\n#             #Can't visit area that is zero. \n\n#             #Out of boundary check \n#             if cur_row < 0 or cur_row >= row_len or cur_col < 0 or cur_col >= col_len or grid[cur_row][cur_col] == 0: \n#                 max_path[0] = max(max_path[0], sum(path_so_far))\n#                 return \n#             # if grid[cur_row][cur_col] == 0: \n#             #     return \n                \n#             #If visited we can't visit you again. \n#             if (cur_row, cur_col) in visited: \n#                 return \n            \n#             visited.add((cur_row,cur_col))\n#             gold_finder(cur_row + 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n#             gold_finder(cur_row - 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n#             gold_finder(cur_row , cur_col + 1, visited, path_so_far + [grid[cur_row][cur_col]])\n#             gold_finder(cur_row, cur_col - 1, visited, path_so_far + [grid[cur_row][cur_col]])\n#             visited.remove((cur_row,cur_col))\n            \n#             return \n \n#         for row in range(row_len):\n#             for col in range(col_len): \n#                 gold_finder(row, col, visited, [])\n                \n                \n#         # print('before', max_path)\n#         # max_path = max(max_path)\n#         # print('after', max_path)\n#         return max_path[0]\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        checked = set()\n        maximum = 0\n        for x in range(len(grid)):\n            for y in range(len(grid[0])):\n                # not 0\n                if (grid[x][y] and (x,y) not in checked):\n                    # print(\\\"checking: \\\" + str((x,y)))\n                    visited = set()\n                    value = self.recursive(0, x , y, grid, visited, checked) \n\n                    if (value > maximum):\n                        # print(\\\"new max point: \\\" + str((x,y)))\n                        # print(\\\"new max: \\\" + str(value))\n                        maximum = value\n        return maximum\n        \n    # not zero and not visited\n    def valid(self, x, y, grid, visited):\n        if (grid[x][y] == 0 or (x,y) in visited):\n            return False\n        return True\n    \n    def recursive(self, total, x, y, grid, visited, checked):\n        if (not self.valid(x,y,grid,visited)):\n            return total\n\n        visited = set(visited)\n        visited.add((x,y))\n        total = total + grid[x][y]\n        # left = (x-1,y)\n        # right = (x+1,y)\n        # top = (x,y-1)\n        # btm = (x,y+1)\n        left,right,top,btm = total,total,total,total\n        \n        if (x > 0):\n            left = self.recursive(total, x-1, y, grid, visited, checked)\n        \n        if (x < len(grid)-1):\n            right = self.recursive(total, x+1, y, grid, visited, checked)\n            \n        if (y > 0):\n            top =self.recursive(total, x, y-1, grid, visited, checked)\n        \n        if (y < len(grid[x])-1):\n            btm = self.recursive(total, x, y+1, grid, visited, checked)\n        \n        return max(left, right, top, btm, total)\n            \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        \n        m= len(grid);\n        n= len(grid[0]);\n        \n        visited=[[False for _ in range(n)] for _ in range(m)];\n        \n        self.ans= -1;\n        \n        def helper(i,j):\n            if i>=m or j>=n or i<0 or j<0 or grid[i][j]==0 or visited[i][j]:\n                return 0;\n            \n            visited[i][j]= True;\n            \n            a=helper(i,j+1);\n            b=helper(i,j-1);\n            c=helper(i+1,j);\n            d=helper(i-1,j);\n            \n            total= grid[i][j]+ max(max(max(a,b),c),d);\n            visited[i][j]= False;\n            return total;\n        \n        for i in range(m):\n            for j in range(n):\n                self.ans= max(self.ans,helper(i,j));\n        \n        return self.ans;", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(pos):\n            if grid[pos[0]][pos[1]] == 0:\n                return 0\n            \n            gold = grid[pos[0]][pos[1]]\n            grid[pos[0]][pos[1]] = 0\n            \n            next_pos = [\n                (pos[0]-1, pos[1]),\n                (pos[0]+1, pos[1]),\n                (pos[0], pos[1]-1),\n                (pos[0], pos[1]+1),\n            ]\n\n            max_child = 0\n            for p in next_pos:\n                if -1 < p[0] < n and -1 < p[1] < m:\n                    max_child = max(max_child, dfs(p))\n            \n            grid[pos[0]][pos[1]] = gold\n            return gold + max_child\n        \n        n = len(grid)\n        m = len(grid[0])\n        \n        max_gold = 0\n        for i in range(n):\n            for j in range(m):\n                max_gold = max(max_gold, dfs((i, j)))\n        return max_gold", "class Solution():\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, sum_so_far: int, seen: set) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or not grid[i][j] or (i, j) in seen:\n                return sum_so_far \n            seen.add((i, j))\n            sum_so_far += grid[i][j]\n            mx = 0\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                mx = max(dfs(x, y, sum_so_far, seen), mx)\n            seen.discard((i, j))   \n            return mx\n\n        m, n = len(grid), len(grid[0])\n        return max(dfs(i, j, 0, set()) for j in range(n) for i in range(m))\n# class Solution:\n#     def getMaximumGold(self, grid: List[List[int]]) -> int:\n#         def findMaxGold(r: int, c: int) -> int:\n#             if r < 0 or r == m or c < 0 or c == n or grid[r][c] == 0: return 0\n#             origin = grid[r][c]\n#             grid[r][c] = 0  # mark as visited\n#             maxGold = 0\n#             for nr, nc in ((r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)):\n#                 maxGold = max(findMaxGold(nr, nc), maxGold)\n#             grid[r][c] = origin  # backtrack\n#             return maxGold + origin\n\n#         m, n = len(grid), len(grid[0])\n#         return max(findMaxGold(r, c) for c in range(n) for r in range(m))\n\n# class Solution:\n#     def getMaximumGold(self, grid: List[List[int]]) -> int:\n#         #2D array \n#         #0 means no gold \n#         #some_num > 0 means there is gold \n#         #Return the max gold you can collect with these conditions\n        \n#         #1) IN w.e cell you are collect ALL the gold in that cell \n#         #From you position move U D L R \n#         #You can't VISIT the same cell more than once. \n#         #You can start and stop collecting gold from ANY position in the grid that has some gold.\n#         visited = set()\n#         max_path = [0]\n#         row_len = len(grid)\n#         col_len = len(grid[0])\n        \n#         def gold_finder(cur_row, cur_col, visited, path_so_far):\n#             #Can't visit area that is zero. \n\n#             #Out of boundary check \n#             if cur_row < 0 or cur_row >= row_len or cur_col < 0 or cur_col >= col_len or grid[cur_row][cur_col] == 0: \n#                 max_path[0] = max(max_path[0], sum(path_so_far))\n#                 return \n#             # if grid[cur_row][cur_col] == 0: \n#             #     return \n                \n#             #If visited we can't visit you again. \n#             if (cur_row, cur_col) in visited: \n#                 return \n            \n#             visited.add((cur_row,cur_col))\n#             gold_finder(cur_row + 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n#             gold_finder(cur_row - 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n#             gold_finder(cur_row , cur_col + 1, visited, path_so_far + [grid[cur_row][cur_col]])\n#             gold_finder(cur_row, cur_col - 1, visited, path_so_far + [grid[cur_row][cur_col]])\n#             visited.remove((cur_row,cur_col))\n            \n#             return \n \n#         for row in range(row_len):\n#             for col in range(col_len): \n#                 gold_finder(row, col, visited, [])\n                \n                \n#         # print('before', max_path)\n#         # max_path = max(max_path)\n#         # print('after', max_path)\n#         return max_path[0]\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        checked = set()\n        maximum = 0\n        for x in range(len(grid)):\n            for y in range(len(grid[0])):\n                # not 0\n                if (grid[x][y]):\n                    # print(\\\"checking: \\\" + str((x,y)))\n                    visited = set()\n                    value = self.recursive(0, x , y, grid, visited) \n\n                    if (value > maximum):\n                        # print(\\\"new max point: \\\" + str((x,y)))\n                        # print(\\\"new max: \\\" + str(value))\n                        maximum = value\n        return maximum\n                    \n                \n    def recursive(self, total, x, y, grid, visited):\n        if (grid[x][y] == 0):\n            return total\n        \n        if ((x,y) in visited):\n            return total\n        \n        visited.add((x,y))\n        total = total + grid[x][y]\n        # left = (x-1,y)\n        # right = (x+1,y)\n        # top = (x,y-1)\n        # btm = (x,y+1)\n        left,right,top,btm = total,total,total,total\n        \n        if (x > 0):\n            left = self.recursive(total, x-1, y, grid, set(visited))\n        \n        if (x < len(grid)-1):\n            right = self.recursive(total, x+1, y, grid, set(visited))\n            \n        if (y > 0):\n            top =self.recursive(total, x, y-1, grid, set(visited))\n        \n        if (y < len(grid[x])-1):\n            btm = self.recursive(total, x, y+1, grid, set(visited))\n        \n        return max(left, right, top, btm, total)\n            \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        # dfs. from all leave nodes.\n        def dfs(i, j, vis):\n            res = 0\n            for z1, z2 in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                x, y = i + z1, j + z2\n                if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (x, y) not in vis and grid[x][y] != 0:\n                    vis.add((x, y))\n                    res = max(res, dfs(x,y, vis)) \n                    vis.remove((x, y))\n            return res + grid[i][j]\n        \n        def check(i, j):\n            if i == 0 or j == 0 or i == len(grid) - 1 or j == len(grid[0]) - 1:\n                return True\n            cnt = 0\n            for z1, z2 in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                x, y = i+z1, j+z2\n                if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 0:\n                    cnt += 1\n            \n            if cnt <= 1:\n                return True\n            \n            return False\n        \n        res = 0\n        if not grid or not grid[0]:\n            return res\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0 and check(i, j):\n                    vis = set()\n                    vis.add((i, j))\n                    ans = dfs(i, j, vis)\n                    res = max(res, ans)\n        \n        return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, sum: int, seen: set) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or not grid[i][j] or (i, j) in seen:\n                return sum \n            seen.add((i, j))\n            sum += grid[i][j]\n            mx = 0\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                mx = max(dfs(x, y, sum, seen), mx)\n            seen.discard((i, j))   \n            return mx\n\n        m, n = len(grid), len(grid[0])\n        return max(dfs(i, j, 0, set()) for j in range(n) for i in range(m))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, sum: int, seen: set) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or not grid[i][j] or (i, j) in seen:\n                return sum \n            seen.add((i, j))\n            sum += grid[i][j]\n            mx = 0\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                mx = max(dfs(x, y, sum, seen), mx)\n            seen.remove((i, j)) \n            return mx\n\n        m, n = len(grid), len(grid[0])\n        return max(dfs(i, j, 0, set()) for j in range(n) for i in range(m))\n    \n    \\\"\\\"\\\"\n    Loop through the grid, for each element at (i, j) perform DFS to get the max value;\nif (i, j) is out of the bound, or grid[i][j] == 0, or visited already, return current sum;\nOtherwise, recurse to the neighbors and accumulate the sum.\n    \\\"\\\"\\\"\n    \n    \\\"\\\"\\\"\n    Each of the k gold cells can at most have 4 neighbors. Therefore,\nTime: O(k * 4 ^ k + m * n), space: O(m * n), where k = number of gold cells, m = grid.length, n = grid[0].length.\n    \\\"\\\"\\\"\n    ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        grid_height, grid_width = len(grid), len(grid[0])\n        visited = set()\n        def helper(i, j, gold = 0):\n            if i < 0 or i >= grid_height or j < 0 or j >= grid_width or (i,j) in visited or grid[i][j] == 0:\n                return gold\n            visited.add((i, j))\n            res = 0\n            for (a, b) in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                res = max(helper(i + a, j + b, gold + grid[i][j]), res)\n            visited.remove((i, j))\n            return res\n            \n        result = 0\n        for i in range(grid_height):\n            for j in range(grid_width):\n                result = max(helper(i, j), result)\n        return result", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def is_valid(i, j):\n            if 0 <= i < m and 0 <= j < n:\n                return True\n            return False\n        \n        def dfs(i, j, visited, cur_sum):\n            visited.add((i, j))\n            cur_sum += grid[i][j]\n            \n            cur_max = 0\n            for d in directions:\n                ni, nj = i+d[0], j+d[1]\n                if is_valid(ni,nj) and (ni,nj) not in visited and grid[ni][nj]>0:\n                    cur_max = max(cur_max, dfs(ni, nj, visited, cur_sum))\n                else:\n                    cur_max = max(cur_max, cur_sum)\n            visited.discard((i, j))\n            return cur_max\n            \n        m, n = len(grid), len(grid[0])\n        directions = [(1,0), (-1,0), (0,1), (0,-1)]\n        max_gold = 0\n        visited = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    max_gold = max(max_gold, dfs(i, j, set(), 0))\n                    \n        return max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def travel(grid, x,y, gold):\n            def valid(c, grid):\n                x,y = c\n                if x < 0 or x > len(grid) - 1 or y < 0 or y > len(grid[0]) - 1 or grid[x][y] == 0:\n                    return False\n                return True\n            #print(\\\"started at %s,%s\\\"%(x,y))\n            dirs = [(0,1),(0,-1),(1,0),(-1,0)]\n            g = grid[x][y]\n            grid[x][y] = 0\n            maxg = -1\n            for i in dirs:\n                nc = x+i[0],y+i[1]\n                if valid(nc, grid):\n                    maxg = max(maxg, travel(grid, nc[0],nc[1], gold + g))\n            grid[x][y] = g\n            if maxg == -1:\n                return gold + g\n            return maxg\n        \n        maxg = 0\n        for ri, row in enumerate(grid):\n            for ci, e in enumerate(row):\n                if e != 0:\n                    \n                    k = travel(grid,ri,ci,0)\n                    #print(\\\"Got %s gold for %s,%s\\\"%(k, ri, ci))\n                    maxg = max(maxg, k)\n        \n        return maxg\n\n                    \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        ans = 0\n        row = len(grid)\n        if not row:\n            return 0\n        col = len(grid[0])\n        if not col:\n            return 0\n        \n        dc = [0,1,0,-1]\n        dr = [-1,0,1,0]\n        \n        \n        def dfs(i,j):\n            if i<0 or i>=row or j<0 or j>=col or grid[i][j]<1:\n                return 0\n            t = 0\n            grid[i][j] = -grid[i][j]\n            for d in range(4):\n                t = max(t,dfs(i+dr[d],j+dc[d]))\n            grid[i][j] = -grid[i][j]\n            return t+grid[i][j]\n            \n            \n        for i in range(row):\n            for j in range(col):\n                if grid[i][j]:\n                    gold = dfs(i,j)\n                    ans = max(gold,ans)\n                    \n        \n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        row,col = len(grid),len(grid[0])\n        maxgold = 0\n        directions = [(1,0),(0,1),(-1,0),(0,-1)]\n        def collectgold(r,c,path,tot):\n            nonlocal maxgold\n            tot += grid[r][c]\n            if tot > maxgold: maxgold = tot\n            for x,y in directions:\n                if 0 <= r+x < row and 0 <= c+y < col and (r+x,c+y) not in path and grid[r+x][c+y]:\n                    collectgold(r+x,c+y,path+[(r+x,c+y)],tot)\n        for i in range(row):\n            for j in range(col):\n                if grid[i][j]:\n                    collectgold(i,j,[(i,j)],0)\n        return maxgold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        #want max gold with conditions\n        # collect all gold in cell\n        # up right left down\n        # cant visit more than 1\n        # never visit 0 cell\n        # start and stop at any position\n        \n        max_gold = []\n        def dfs(curr_row, curr_col, seen, curr_gold):\n            if curr_row < 0 or curr_row >= row_len \\\\\n                or curr_col < 0 or curr_col >= col_len \\\\\n                or grid[curr_row][curr_col] == 0:\n                return curr_gold\n            \n            if (curr_row, curr_col) in seen:\n                return curr_gold\n            \n            seen.add((curr_row, curr_col))\n            for nxt_row, nxt_col in [(curr_row+1, curr_col), \\\\\n                                     (curr_row-1, curr_col), \\\\\n                                     (curr_row, curr_col+1), \\\\\n                                     (curr_row, curr_col-1)]:\n            \n                max_gold.append(dfs(nxt_row, nxt_col, seen, curr_gold + grid[curr_row][curr_col]))\n            \n            seen.discard((curr_row, curr_col))\n            return curr_gold\n        \n        \n        \n        row_len = len(grid)\n        col_len = len(grid[0])\n        \n        for row in range(row_len):\n            for col in range(col_len):\n                dfs(row, col, set(), 0)\n        return max(max_gold)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:    \n        \n        def dfs(i: int, j: int, sum: int, seen: set) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or not grid[i][j] or (i, j) in seen:\n                return sum \n            seen.add((i, j))\n            sum += grid[i][j]\n            mx = 0\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                mx = max(dfs(x, y, sum, seen), mx)\n            seen.discard((i, j))   \n            return mx\n\n        m, n = len(grid), len(grid[0])\n        return max(dfs(i, j, 0, set()) for j in range(n) for i in range(m))\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.maxX = len(grid[0]) - 1\n        self.maxY = len(grid) - 1\n        self.maxGold = 0\n        for y in range(0, len(grid)):\n            for x in range(0, len(grid[0])):\n                if grid[y][x] != 0:\n                    self.helper(x, y, grid, 0)\n                    \n        return self.maxGold\n        \n    def helper(self, x, y, grid, gold):\n        # print(x,y,grid[y][x])\n        gold+= grid[y][x]\n        left = 0 if (x-1 < 0) else grid[y][x-1]\n        right = 0 if (x+1 > self.maxX) else grid[y][x+1]\n        top = 0 if (y-1 < 0) else grid[y-1][x]\n        bottom = 0 if (y+1 > self.maxY) else grid[y+1][x]\n        \n        if left == 0 and right == 0 and top == 0 and bottom == 0:\n            if gold > self.maxGold:\n                self.maxGold = gold\n            return\n\n        tmp = grid[y][x]\n        grid[y][x] = 0\n        if left != 0:\n            self.helper(x-1, y, grid, gold)\n        if right != 0:\n            self.helper(x+1, y, grid, gold)\n        if top != 0:\n            self.helper(x, y-1, grid, gold)\n        if bottom != 0:\n            self.helper(x, y+1, grid, gold)\n        grid[y][x] = tmp\n", "class Solution:\n    #class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def findMaxGold(r: int, c: int) -> int:\n            if r < 0 or r == m or c < 0 or c == n or grid[r][c] == 0: return 0\n            origin = grid[r][c]\n            grid[r][c] = 0  # mark as visited\n            maxGold = 0\n            for nr, nc in ((r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)):\n                maxGold = max(findMaxGold(nr, nc), maxGold)\n            grid[r][c] = origin  # backtrack\n            return maxGold + origin\n\n        m, n = len(grid), len(grid[0])\n        return max(findMaxGold(r, c) for c in range(n) for r in range(m))\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        seen = set()\n        \n        def dfs(i: int, j: int, sum: int) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or not grid[i][j] or (i, j) in seen:\n                return sum \n            seen.add((i, j))\n            sum += grid[i][j]\n            mx = 0\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                mx = max(dfs(x, y, sum), mx)\n            seen.remove((i, j))   \n            return mx\n\n        return max(dfs(i, j, 0) for j in range(n) for i in range(m))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        final = [0]\n        visited = set()\n        directions = [[1,0],[0,1],[-1,0],[0,-1]]\n        def bt(current_sum = 0, i=0, j=0):\n            if (i,j) in visited or i<0 or i>=len(grid) or j<0 or j>= len(grid[0]) or grid[i][j]==0:\n                final[0] =max(final[0],current_sum)\n                return\n            current_sum+=grid[i][j]\n            visited.add((i,j))\n            for direction in directions:\n                new_i = i+direction[0]\n                new_j = j+direction[1]\n                bt(current_sum,new_i,new_j)\n            visited.remove((i,j))\n            current_sum-=grid[i][j]\n        for row in range(len(grid)):\n            for col in range(len(grid[row])):\n                bt(i=row,j=col)\n        return final[0]\n", "'''\nWe do dfs backtracking starting on each element and try backtrack on every direction by removing from visited set. \n\nAnother good DFS backtracking practice\n\nTime(exponential, around 3^n)\nSpace(Number of plots with gold)\n'''\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        direction = [(1,0),(-1,0), (0,1),(0,-1)]\n        N = len(grid)\n        M = len(grid[0])\n        def dfs(src, seen, pSum):\n            curI, curJ = src[0], src[1]\n            if (curI, curJ) not in seen and curI >= 0 and curI < N and curJ >= 0 and curJ < M and grid[curI][curJ] != 0:\n                seen.add((curI, curJ))\n                pSum += grid[curI][curJ]\n                self.sol = max(self.sol, pSum)\n                for d in direction:\n                    nI, nJ = curI + d[0], curJ + d[1]\n                    dfs((nI, nJ), seen, pSum)\n                seen.remove((curI, curJ))\n        self.sol = -1\n        for i in range(N):\n            for j in range(M):\n                if grid[i][j] != 0:\n                    seen = set()\n                    dfs((i,j), seen, 0)\n        return self.sol\n                \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        p = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]!=0:\n                    p = max(p, self.dfs(grid, i, j, m, n))\n        return p\n                \n    def dfs(self, grid, starti, startj, m, n):\n        visited = [[0 for i in range(m)] for j in range(n)]\n        return self.dfsUtil(grid, starti, startj, visited, m ,n)\n        \n    def dfsUtil(self, grid, i, j, visited, m, n):\n        ct = grid[i][j]\n        k = 0\n        if visited[i][j]==0 and grid[i][j]!=0:\n            visited[i][j] = 1\n            neighbours = [[i+1,j], [i-1,j], [i,j+1], [i,j-1]]\n\n            for neighbour in neighbours:\n                if neighbour[0]>=0 and neighbour[0]<n and neighbour[1]>=0 and neighbour[1]<m:\n                    k = max(k, self.dfsUtil(grid, neighbour[0], neighbour[1], visited, m, n))\n            \n            visited[i][j] = 0\n            return ct + k\n        \n        else:\n            return 0", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        def walk(grid, i, j):\n            nonlocal m, n\n            if not grid or i < 0 or i >= m or j < 0 or j >= n:\n                return 0\n            if grid[i][j] < 1:\n                return 0\n            g = []\n            for k in range(m):\n                g.append(grid[k][:])\n            ans = grid[i][j]\n            g[i][j] = 0\n            ans += max(walk(g, i-1, j), walk(g, i+1, j), walk(g, i, j-1), walk(g, i, j+1))\n            return ans\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, walk(grid, i, j))\n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n       #Approach: Recursive backtracking\n        # Keep track of gold at each element and keep calculating max to get the result\n         \n        \n        r, c = len(grid), len(grid[0])\n        self.res = 0\n        dirs = [(1,0),(-1,0),(0,1),(0,-1)]\n        \n        def dfs(i,j,curr):\n            self.res = max(self.res, curr)\n            if i < r and j < c and i>= 0 and j >= 0 and grid[i][j] != 0:\n                gold = grid[i][j]\n                for x, y in dirs:\n                    grid[i][j] = 0\n                    dfs(i+x, j+y, curr+gold)\n                    grid[i][j] = gold\n                    \n        for i in range(r):\n            for j in range(c):\n                if grid[i][j] != 0:\n                    dfs(i,j,0)\n        \n        return self.res   \n    \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def dfs(i,j, v):\n            seen.add((i,j))\n            dp[i][j] = max(dp[i][j], v)\n            for x, y in (i-1, j), (i+1,j),(i,j-1),(i,j+1):\n                if 0<=x<m and 0<=y<n and grid[x][y] and (x, y) not in seen:\n                    dfs(x, y, v+grid[x][y])\n            seen.discard((i,j))\n        \n        \n            \n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    seen = set()\n                    dfs(i, j, grid[i][j])\n        return max(c for row in dp for c in row)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        values = [[0 for j in range(0, m)] for i in range(0,n)]\n        visited = [[0 for j in range(0, m)] for i in range(0,n)]\n        _max = 0\n        for i in range(0, n):\n            for j in range(0, m):\n                if grid[i][j] != 0:\n                    self._clear(visited)\n                    values[i][j] = self._dfs(i,j,grid,visited)\n                    _max = max(_max, values[i][j])\n                    \n        return _max\n        \n    \n    def _clear(self, grid: List[List[int]]) -> None:\n        n = len(grid)\n        m = len(grid[0])\n        for i in range(0, n):\n            for j in range(0, m):\n                grid[i][j] = 0\n        \n    def _dfs(self, i: int, j: int, grid: List[List[int]], visited: List[List[int]]) -> int:\n        if grid[i][j] == 0:\n            return 0\n        if visited[i][j] != 0:\n            return 0\n        \n        n = len(grid)\n        m = len(grid[0])\n\n        visited[i][j] = 1\n        \n        idx = [(0,1),(0,-1),(1,0),(-1,0)]\n        _max = 0\n        for p in idx:\n            if i+p[0] >= 0 and i+p[0] < n and j+p[1]>=0 and j+p[1] < m:\n                v = self._dfs(i+p[0], j+p[1], grid, visited)\n                _max = max(_max, v)\n                \n        visited[i][j] = 0\n        return grid[i][j] + _max", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def dfs(row, col, curgold):\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and grid[row][col] > 0:\n                temp = grid[row][col]\n                # Change to 0 so you wont repeat the process\n                grid[row][col] = 0\n                dfs(row+1, col, curgold + temp)\n                dfs(row-1, col, curgold + temp)\n                dfs(row, col+1, curgold + temp)\n                dfs(row, col-1, curgold + temp)\n        # Once you explore all your choices, calculate the max gold you have collected so far\n                self.maxgold = max(self.maxgold, curgold + temp)\n                grid[row][col] = temp\n                \n        self.maxgold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] > 0:\n                    dfs(i, j, 0)\n                    \n        return self.maxgold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def goDfsGo(row,col):\n            ret_max=0\n            temp_val=grid[row][col]\n            grid[row][col]=False\n            if row+1<len(grid) and grid[row+1][col]!=False and grid[row+1][col]!=0:\n                ret_max=max(ret_max,temp_val+goDfsGo(row+1,col))\n            \n            if row-1>=0 and grid[row-1][col]!=False and grid[row-1][col]!=0:\n                ret_max=max(ret_max,temp_val+goDfsGo(row-1,col))\n            \n            if col+1<len(grid[0]) and grid[row][col+1]!=False and grid[row][col+1]!=0:\n                ret_max=max(ret_max,temp_val+goDfsGo(row,col+1))\n            \n            if col-1>=0 and grid[row][col-1]!=False and grid[row][col-1]!=0:\n                ret_max=max(ret_max,temp_val+goDfsGo(row,col-1))\n            \n            grid[row][col]=temp_val\n            return max(ret_max,grid[row][col])        \n            \n        mah_max=0\n        #bool_list=[[True for i in range(len(grid[0]))] for i in range(len(grid))]\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col]!=0:\n                    mah_max=max(mah_max,goDfsGo(row,col))\n                    #print(mah_max)\n                \n        return mah_max", "class Solution:\n  def getNeighbors(self, root, grid):\n    deltas = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    x, y = root\n    return [(x+dx, y+dy) for dx, dy in deltas if 0 <= x+dx < len(grid) and 0 <= y+dy < len(grid[x])]\n  \n  def dfs(self, root, grid, visited):\n    if root in visited:\n      return 0\n    visited.add(root)\n    gold = 0\n    for nx, ny in self.getNeighbors(root, grid):\n      if (nx, ny) in visited:\n        continue\n      if grid[nx][ny] == 0:\n        continue\n      gold = max(gold, self.dfs((nx, ny), grid, visited))\n    visited.remove(root)\n    return gold + grid[root[0]][root[1]]\n  \n  def getMaximumGold(self, grid: List[List[int]]) -> int:\n    # dfs search problem\n    maxGold = 0\n    for i in range(len(grid)):\n      for j in range(len(grid[i])):\n        if grid[i][j] == 0:\n          continue\n        maxGold = max(maxGold, self.dfs((i, j), grid, set()))\n        \n    return maxGold\n  \n[[0, 0, 19,5,8],\n [11,20,14,1,0],\n [0, 0, 1, 1,1],\n [0, 2, 0, 2,0]]", "class Solution:\n    def dfs(self, pos, sum):\n        if pos in self.visit or pos[0] < 0 or pos[0] >= self.M or pos[\n                1] < 0 or pos[1] >= self.N or not self.grid[pos[0]][pos[1]]:\n            return\n        self.visit.add(pos)\n        sum += self.grid[pos[0]][pos[1]]\n        x, y = pos\n        self.maxGold = max(self.maxGold, sum)\n        [\n            self.dfs(node, sum)\n            for node in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\n        ]\n        self.visit.remove(pos)\n\n    def getMaximumGold(self, grid: List[List[int]]):  # -> int:\n        self.maxGold = 0\n        self.M = len(grid)\n        self.N = len(grid[0])\n        self.grid = grid\n        for beginX in range(self.M):\n            for beginY in range(self.N):\n                if grid[beginX][beginY] > 0:\n                    self.visit = set()\n                    self.dfs((beginX, beginY), 0)\n        return self.maxGold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])        \n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        greatest = 0\n        \n        starts = []\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col] != 0:\n                    q = collections.deque([])\n                    q.append((row, col, [(row, col)], grid[row][col]))\n                    maxx = 0\n                    while q:\n                        r, c, path, total = q.popleft()\n                        maxx = max(maxx, total)\n                        for y, x in directions:\n                            nr = r + y\n                            nc = c + x\n                            if nr >= 0 and nr < rows and nc >= 0 and nc < cols and \\\\\n                               grid[nr][nc] != 0 and (nr, nc) not in path:\n                                q.append((nr, nc, path + [(nr, nc)], total + grid[nr][nc]))\n\n                    greatest = max(maxx, greatest)\n        return greatest", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        \n        def initVisit(m, n):\n            visited = {}\n            for i in range(m):\n                for j in range(n):\n                    visited[(i, j)] = -1 \n            return visited\n        maxGold = 0\n        \n        def check(i,j ):\n            if 0 <= i < m and 0 <= j < n and grid[i][j] != 0 and visited[(i,j)] != 1:\n                return True\n            else:\n                return False\n         \n        def helper(i, j):\n            # print(visited)\n            \n            moves = [[-1, 0], [1,0], [0,-1], [0,1]]\n            maxSum = 0\n            for move in moves:\n                nextI, nextJ = move[0] + i, move[1] + j\n                if check(nextI, nextJ):\n                    # print(visited)\n                    visited[(i,j)] = 1\n                    maxSum = max(maxSum, helper(nextI, nextJ))\n                    visited[(i,j)] = 0\n            \n                    \n            \n            return maxSum + grid[i][j]\n        \n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    # visited = [[-1] * n] * m\n                    # print(visited)\n                    visited = initVisit(m,n)\n                    visited[(i,j)] = 1\n                    # print(visited)\n                    # print(grid[i][j])\n                    maxGold = max(maxGold, helper(i, j))\n                    # print(maxGold)\n                    # return 0\n\n        return maxGold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        out = 0\n        for y, row in enumerate(grid):\n            for x, val in enumerate(row):\n                if val != 0:\n                    cur_max = max_collect(x, y, grid)\n                    out = max(out, cur_max)\n        return out\n    \ndef max_collect(x, y, grid, visited = set([])):\n    if y < 0 or y >= len(grid):\n        return 0\n    if x < 0 or x >= len(grid[y]):\n        return 0\n    if grid[y][x] == 0:\n        return 0\n    if (x,y) in visited:\n        return 0\n    visited.add((x,y))\n    _max = 0\n    for xx,yy in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:\n        _max = max(_max, max_collect(xx, yy, grid, visited))\n    visited.remove((x,y))\n    return _max + grid[y][x]", "def is_valid_cell(row, col, rows, cols):\n    return 0 <= row < rows and 0<= col < cols\n\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        max_amount = 0\n        \n        def backtrack(row, col, rows, cols, grid):\n            if not is_valid_cell(row, col, rows, cols) or grid[row][col] == 0:\n                return 0\n            \n            directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n            original = grid[row][col]\n            grid[row][col] = 0  # mark row, col as visited\n            \n            max_sum = 0\n            for dr, dc in directions:\n                r = row + dr\n                c = col + dc\n                max_sum = max(max_sum, backtrack(r, c, rows, cols, grid))\n            \n            # unmark row, col\n            grid[row][col] = original\n            \n            return original + max_sum\n        \n        for row in range(rows):\n            for col in range(cols):\n                ans = backtrack(row, col, rows, cols, grid)\n                max_amount = max(max_amount, ans)\n        \n        return max_amount\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n       #Approach: Recursive backtracking\n        # Keep track of gold at each element and keep calculating max to get the result\n         \n        \n        r, c = len(grid), len(grid[0])\n        self.res = 0\n        dirs = [(0,1),(1,0),(-1,0),(0,-1)]\n        \n        def recurse(i,j, curr):\n            self.res = max(curr, self.res)\n            \n            if i < r and j < c and i>=0 and j >=0 and grid[i][j] != 0:\n                gold = grid[i][j]\n                \n                for x, y in dirs:\n                    grid[i][j] = 0\n                    recurse(i+x, j+y, curr+gold)\n                    grid[i][j] = gold\n            \n                    \n        \n        for i in range(r):\n            for j in range(c):\n                if grid[i][j] != 0:\n                    recurse(i,j,0)\n        \n        return self.res\n    \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        # All starting points\n        m = len(grid)\n        n = len(grid[0])\n        max_gold = 0\n        for row in range(m):\n            for col in range(n):\n                max_gold = max(max_gold, self.findMaxGold(grid, row, col, 0))\n        return max_gold\n                \n    def findMaxGold(self, grid, row, col, curr_gold):\n        if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and grid[row][col] != 0:\n            origin = grid[row][col]\n            # Mark as visited\n            grid[row][col] = 0\n            \n            max_gold = 0\n            x_moves = [1, -1, 0, 0]\n            y_moves = [0, 0, 1, -1]\n            \n            for i in range(0, 4):\n                max_gold = max(max_gold, self.findMaxGold(grid, row+x_moves[i], col+y_moves[i], max_gold))\n            \n            # Backtrack: mark as unvisited\n            grid[row][col] = origin\n            \n            return max_gold + origin\n        else:\n            return 0\n        \n    \n    # Time: O((m*n)^2)\n    # Space: O(m*n)\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        # All starting points\n        m = len(grid)\n        n = len(grid[0])\n        max_gold = 0\n        for row in range(m):\n            for col in range(n):\n                max_gold = max(max_gold, self.findMaxGold(grid, row, col, 0))\n        return max_gold\n                \n    def findMaxGold(self, grid, row, col, curr_gold):\n        if 0 <= row and row < len(grid) and 0 <= col and col < len(grid[0]) and grid[row][col] != 0:\n            origin = grid[row][col]\n            grid[row][col] = 0\n            max_gold = 0\n            \n            row_moves = [-1, 1, 0, 0]\n            col_moves = [0, 0, -1, 1]\n            \n            for i in range(0, 4):\n                max_gold = max(max_gold, self.findMaxGold(grid, row + row_moves[i], col+col_moves[i], max_gold))\n            \n            grid[row][col] = origin\n            \n            return max_gold + origin\n        else:\n            return 0\n        \n    \n    # Time: O((m*n)^2)\n    # Space: O(m*n)\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(row, col, visited):\n            if (row, col) in visited or grid[row][col] == 0:\n                return 0\n            \n            next_visited = visited | set([(row, col)])\n            next_pos = [\n                (row-1, col),\n                (row+1, col),\n                (row, col-1),\n                (row, col+1),\n            ]\n\n            max_child = 0\n            for (next_row, next_col) in next_pos:\n                if -1 < next_row < n and -1 < next_col < m:\n                    max_child = max(max_child, dfs(next_row, next_col, next_visited))\n            \n            return grid[row][col] + max_child\n        \n        n = len(grid)\n        m = len(grid[0])\n        \n        max_gold = 0\n        for i in range(n):\n            for j in range(m):\n                max_gold = max(max_gold, dfs(i, j, set()))\n                \n        return max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        grid_visited = [[0 for i in range(n)] for i in range(m)]\n        max_gold = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    temp = self.start_mine(grid, grid_visited, i, j)\n                    max_gold = max(max_gold, temp)\n        return max_gold\n                \n        \n    def start_mine(self, grid, grid_visited, i, j):\n        total = grid[i][j]\n        max_choice = 0\n        grid_visited[i][j] = 1\n        #up\n        if i-1 >= 0 and grid[i-1][j] != 0 and grid_visited[i-1][j] == 0:\n            temp = self.start_mine(grid, grid_visited, i-1, j)\n            max_choice = max(temp, max_choice)\n        \n        #down\n        if i+1 < len(grid) and grid[i+1][j] != 0 and grid_visited[i+1][j] == 0:\n            temp = self.start_mine(grid, grid_visited, i+1, j)\n            max_choice = max(temp, max_choice)\n        \n        #left\n        if j-1 >= 0 and grid[i][j-1] != 0 and grid_visited[i][j-1] == 0:\n            temp = self.start_mine(grid, grid_visited, i, j-1)\n            max_choice = max(temp, max_choice)\n        \n        #right\n        if j+1 < len(grid[0]) and grid[i][j+1] != 0 and grid_visited[i][j+1] == 0:\n            temp = self.start_mine(grid, grid_visited, i, j+1)\n            max_choice = max(temp, max_choice)\n            \n        grid_visited[i][j] = 0\n        return total + max_choice", "\nclass Solution:\n    \n    def __init__(self, *args, **kwargs):\n        self.visited = set()\n\n    def generate_neighbours(self, grid, i, j, m, n):\n        if i > 0:\n            yield i-1,j\n        if i+1 < n:\n            yield i+1,j\n        if j > 0:\n            yield i,j-1\n        if j+1 < m:\n            yield i,j+1\n    \n    def dfs(self, grid, i, j, m, n):\n        self.visited.add(f\\\"{i}-{j}\\\")\n        \n        if grid[i][j] == 0:\n            return 0\n\n        max_gold = 0\n        for x, y in  self.generate_neighbours(grid, i, j, m, n):\n            if f\\\"{x}-{y}\\\" in self.visited:\n                continue\n                \n            gold_found = self.dfs(grid, x, y, m, n)\n            max_gold = max(max_gold, gold_found)\n            \n        self.visited.remove(f\\\"{i}-{j}\\\")\n        return grid[i][j] + max_gold\n            \n    \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        \n        max_gold = 0\n        for i in range(n):\n            for j in range(m): \n                self.visited = set()\n                gold_found = self.dfs(grid, i, j, m, n,)\n                max_gold = max(max_gold, gold_found)\n        \n        return max_gold\n    \n    # [1,0,7,0,0,0]\n    # [2,0,6,0,1,0]\n    # [3,5,6,7,4,2]\n    # [4,3,1,0,2,0]\n    # [3,0,5,0,20,0]", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.ret = 0\n        self.grid = grid\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    self.dfs(i, j, 0)\n        return self.ret\n    \n    def dfs(self, i, j, cur_gold):\n        self.ret = max(self.ret, cur_gold)\n        if (0 <= i < len(self.grid) and 0 <= j < len(self.grid[0])) and self.grid[i][j] != 0:\n            gold = self.grid[i][j]\n            for m, n in [(-1, 0), (0, -1), (0, 1), (1, 0)]:\n                self.grid[i][j] = 0\n                self.dfs(i + m, j + n, cur_gold + gold)\n                self.grid[i][j] = gold", "class Solution:\n    \n    def __init__(self): \n        self.moves = [\n            (1,0),\n            (-1,0),\n            (0,1),\n            (0,-1)\n        ]\n    \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        best = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if self.canMove(i, j, grid, set()):\n                    total = self.moveNext(i, j, grid, set(), 0)\n                    best = max(best, total)\n        return best\n        \n    def moveNext(self, x, y, grid, visited, total):\n        visited.add((x,y))\n        total = total+grid[x][y]\n        best = total\n        for move in self.moves:\n            if self.canMove(x+move[0],y+move[1],grid, visited):\n                s = self.moveNext(x+move[0],y+move[1], grid, visited.copy(), total)\n                if s > best:\n                    best = s\n        return best\n        \n        \n    def canMove(self, x,y,grid,visited):\n        return ( x >= 0 and x < len(grid)) and (y >= 0 and y < len(grid[0])) and (grid[x][y] != 0) and ((x,y) not in visited)\n        \n", "class Solution:\n    '''\n    Leetcode1219\n    \u6838\u5fc3\u601d\u60f3\uff1abacktrack\uff0c\u548c\u4e4b\u524d\u7684\u9898\u7684\u89e3\u9898\u662f\u4e00\u6a21\u4e00\u6837\u7684\n    '''\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i, j , gold_so_far):\n            self.max_gold = max(self.max_gold, gold_so_far)\n            if 0 <= i < len(grid) and 0<= j < len(grid[0]) and grid[i][j] != 0:\n                gold_amt = grid[i][j]\n                grid[i][j]  = 0\n                neigbors = [[i+1, j], [i-1,j], [i, j+1],[i, j-1]]\n                for x, y in  neigbors:\n                    dfs(x, y, gold_so_far + gold_amt)\n                grid[i][j] = gold_amt\n            \n        \n        self.max_gold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] > 0:\n                    dfs(i, j , 0)\n        return self.max_gold\n        \n#         def search(i, j , gold_so_far):\n#             self.max_gold = max(self.max_gold, gold_so_far)\n#             if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] != 0:\n#                 gold_amnt = grid[i][j]\n#                 grid[i][j] = 0\n#                 neigbors = [[i+1, j], [i-1, j], [i, j+1], [i, j-1]]\n#                 for x, y in neigbors:\n#                     search(x, y, gold_so_far + gold_amnt)\n#                 grid[i][j] = gold_amnt\n        \n#         self.max_gold = 0\n#         for i in range(len(grid)):\n#             for j in range(len(grid[0])):\n#                 if grid[i][j] > 0:\n#                     search(i, j , 0)\n#         return self.max_gold\n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def sorround(curr):\n            posts = [[1,0],[0,1],[-1,0],[0,-1]]\n            for i in posts:\n                ii = i[0]+curr[0]\n                jj = i[1]+curr[1]\n                if(ii<len(grid) and ii>=0 and jj>=0 and jj < len(grid[0]) and grid[ii][jj]!=0):\n                    yield (ii,jj)\n        def depth_first_search(cur):\n            cur_sum = grid[cur[0]][cur[1]]\n            ans = 0\n            for i in sorround(cur):\n                if((i not in visited) or (visited[i]==False)):\n                    visited[i]=True\n                    mx = depth_first_search(i)\n                    ans=max(ans,mx)\n                    visited[i]=False\n            return cur_sum+ans\n        cans = 0\n        visited={}\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if(grid[i][j]!=0):\n                    visited[(i,j)]=True\n                    cs = depth_first_search((i,j))\n                    cans = max(cs,cans)\n                    visited[(i,j)]=False\n        return cans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n        \n        def collectGold(r, c, goldSoFar):\n            \n            pts = [[0,1],[1,0],[-1,0],[0,-1]]\n            \n            maxGold = goldSoFar\n            \n            for p in pts:\n                nR = p[0] + r\n                nC = p[1] + c\n                \n                if 0 <= nR < len(grid) and 0<= nC < len(grid[0]) and grid[nR][nC] != 0:\n                    v = grid[nR][nC]\n                    grid[nR][nC] = 0\n                    gold = collectGold(nR, nC, goldSoFar + v)\n                    maxGold = max(gold, maxGold)\n                    grid[nR][nC] = v\n                    \n            return maxGold\n        \n        maxGold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    v = grid[i][j]\n                    grid[i][j] = 0\n                    gold = collectGold(i, j, v)\n                    maxGold = max(maxGold, gold)\n                    grid[i][j] = v\n        return maxGold\n                \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])        \n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        greatest = 0\n        \n        starts = []\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col] != 0:\n                    q = collections.deque([])\n                    q.append((row, col, [(row, col)], grid[row][col]))\n                    maxx = 0\n                    while q:\n                        r, c, path, total = q.popleft()\n                        maxx = max(maxx, total)\n                        for y, x in directions:\n                            nr = r + y\n                            nc = c + x\n                            if nr >= 0 and nr < rows and nc >= 0 and nc < cols and \\\\\n                               grid[nr][nc] != 0 and (nr, nc) not in path:\n                                q.append((nr, nc, path + [(nr, nc)], total + grid[nr][nc]))\n\n                    greatest = max(maxx, greatest)\n        return greatest\n#         if not grid:\n#             return 0\n        \n#         rows = len(grid)\n#         cols = len(grid[0])\n#         m = -float('inf')\n        \n#         for i in range(rows):\n#             for j in range(cols):\n#                 if grid[i][j] !=0:\n#                     p = self.dfs(i, j, rows, cols, grid)\n#                     m = max(m, p)\n                    \n#         return m            \n    \n#     def dfs(self, i, j, rows, cols, grid):\n#         if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == 0:\n#             return 0\n        \n#         c = grid[i][j]\n#         grid[i][j] = 0\n        \n#         l = self.dfs(i, j - 1, rows, cols, grid)\n#         r = self.dfs(i, j + 1, rows, cols, grid)\n#         u = self.dfs(i + 1, j, rows, cols, grid)\n#         d = self.dfs(i - 1, j, rows, cols, grid)\n        \n#         grid[i][j] = c\n        \n#         return max(l, r, u, d) + c\n        ", "class Solution:\n    def __init__(self):\n        self.max = 0\n        self.grid=[[]]\n        self.dp = [[]]\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.grid = grid\n        self.dp = [[0 for j in range(len(grid[0]))] for i in range(len(grid))]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if self.grid[i][j] != 0: #and self.dp[i][j] == 0:\n                    visit = set()\n                    self.dp[i][j] = self.dfs(visit,(i,j))\n                    self.max=max(self.max, self.dp[i][j])\n        \n        #self.dp[4][4] = self.dfs(set(),(4,4))\n        #print(self.dp)\n        return self.max\n        \n    def dfs(self, visit, node):\n        \n        #visit.add(node)\n        i,j = node\n        #self.dp[i][j] = self.grid[i][j]\n        neighborVals = [0]\n        #print(visit)\n        for di, dj in [(-1,0),(0,1),(1,0),(0,-1)]:\n            if 0 <= i+di < len(self.grid) and 0 <= j+dj < len(self.grid[0]) and \\\\\n            (i+di,j+dj) not in visit:\n                if self.grid[i+di][j+dj] > 0: #and self.dp[i+di][j+dj] == 0:\n                    #self.dfs(visit, (i+di,j+dj))\n                    temp = set()\n                    temp.add(node)\n                    neighborVals.append(self.dfs(visit.union(temp), (i+di,j+dj))) #self.dp[i+di][j+dj])\n        #print(node,self.grid[i][j], neighborVals)\n        return self.grid[i][j] + max(neighborVals)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m,n = len(grid), len(grid[0])\n        visited = set()\n        \n        def dfs(i,j,sum):\n            if i<0 or i==m or j<0 or j==n or (i,j) in visited or grid[i][j]==0: \n                # reach the bottom of current path\n                return sum\n            visited.add((i,j))\n            maxi = 0\n            for x,y in [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]:\n                maxi = max(maxi, dfs(x,y,sum+grid[i][j]))\n            visited.remove((i,j))\n            return maxi\n        \n        return max(dfs(i,j,0) for i in range(m) for j in range(n) if grid[i][j]!=0)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def goDfsGo(row,col,bool_list):\n            ret_max=0\n            bool_list[row][col]=False\n            if row+1<len(grid) and bool_list[row+1][col]==True and grid[row+1][col]!=0:\n                ret_max=max(ret_max,grid[row][col]+goDfsGo(row+1,col,bool_list))\n            \n            if row-1>=0 and bool_list[row-1][col]==True and grid[row-1][col]!=0:\n                ret_max=max(ret_max,grid[row][col]+goDfsGo(row-1,col,bool_list))\n            \n            if col+1<len(grid[0]) and bool_list[row][col+1]==True and grid[row][col+1]!=0:\n                ret_max=max(ret_max,grid[row][col]+goDfsGo(row,col+1,bool_list))\n            \n            if col-1>=0 and bool_list[row][col-1]==True and grid[row][col-1]!=0:\n                ret_max=max(ret_max,grid[row][col]+goDfsGo(row,col-1,bool_list))\n            \n            bool_list[row][col]=True\n            return max(ret_max,grid[row][col])        \n            \n        mah_max=0\n        bool_list=[[True for i in range(len(grid[0]))] for i in range(len(grid))]\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col]!=0:\n                    mah_max=max(mah_max,goDfsGo(row,col,bool_list))\n                    #print(mah_max)\n                \n        return mah_max", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m , n = len(grid) , len(grid[0])\n        self.maxgold = 0\n        def isvalid(x,y):\n            return x >= 0 and x < m and y >= 0 and y < n\n        def backtrack(cell , gold , visited):\n            self.maxgold = max(self.maxgold , gold)\n            x , y = cell[0] , cell[1]\n            neighbours = [[x-1,y],[x+1,y],[x,y+1],[x,y-1]]\n            for nbr in neighbours:\n                if isvalid(nbr[0],nbr[1]) and not visited[nbr[0]][nbr[1]] and grid[nbr[0]][nbr[1]] != 0:\n                    visited[nbr[0]][nbr[1]] = True\n                    gold += grid[nbr[0]][nbr[1]]\n                    backtrack(nbr , gold , visited)\n                    self.maxgold = max(self.maxgold , gold)\n                    gold -= grid[nbr[0]][nbr[1]]\n                    visited[nbr[0]][nbr[1]] = False\n        visited = [[False]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    visited[i][j] = True\n                    backtrack([i,j] , grid[i][j] , visited)\n                    visited[i][j] = False\n        return self.maxgold", "class Solution:\n    \n    \n    def is_valid(self,grid,i,j):\n        valid_i = 0 <= i <= len(grid) - 1\n        valid_j = 0 <= j <= len(grid[0]) - 1\n        \n        if (not valid_i) or (not valid_j):\n            return False\n        if grid[i][j] == 0:\n            return False\n        \n        return True\n    \n    def find_path(self,grid,i,j,gold,visited,max_gold):\n        visited.add((i,j))\n        gold += grid[i][j]\n        max_gold[0] = max(gold,max_gold[0])\n        \n        \n        for x_,y_ in [(1,0),(-1,0),(0,1),(0,-1)]:\n            if self.is_valid(grid,i+x_,j+y_) and not ((i+x_,j+y_) in visited):\n                self.find_path(grid,i+x_,j+y_,gold,visited,max_gold)\n            \n        visited.remove((i,j))\n        \n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        max_gold = [float('-inf')]\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    self.find_path(grid,i,j,0,set(),max_gold)\n        \n        return max_gold[0] if max_gold != float('-inf') else 0", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        \n        def dfs(i, j, gold, visited):\n            nonlocal ans             \n            if i < 0 or i >= rows or j < 0 or j >= cols or (i, j) in visited or grid[i][j] == 0:               \n                ans = max(ans, gold)\n                return\n            visited.add((i, j))\n            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                dfs(i + di, j + dj, gold + grid[i][j], visited)\n            visited.remove((i, j))\n            \n        ans, rows, cols = 0, len(grid), len(grid[0])\n        for row in range(rows):\n            for col in range(cols):\n                dfs(row, col, 0, set())   \n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        nrow, ncol = len(grid), len(grid[0])\n        possible_starts = [(i,j) for i in range(nrow) for j in range(ncol) if grid[i][j]!=0]\n        \n        max_gold = 0\n        for start in possible_starts:\n            path_stack = [start]\n            #visited = {start}\n            cell_to_other_paths = collections.defaultdict(list)\n            x, y = start\n            cumulated_gold = grid[x][y]\n            while path_stack:\n                found_next = False\n                if x-1>=0 and grid[x-1][y]!=0 and (x-1,y) not in path_stack:\n                    found_next = True\n                    tmp_x, tmp_y = x-1, y\n                if x+1<nrow and grid[x+1][y]!=0 and (x+1,y) not in path_stack:\n                    if found_next:\n                        cell_to_other_paths[(x,y)].append((x+1,y))\n                    else:\n                        found_next = True\n                        tmp_x, tmp_y = x+1, y\n                if y-1>=0 and grid[x][y-1]!=0 and (x,y-1) not in path_stack:\n                    if found_next:\n                        cell_to_other_paths[(x,y)].append((x,y-1))\n                    else:\n                        found_next = True\n                        tmp_x, tmp_y = x, y-1\n                if y+1<ncol and grid[x][y+1]!=0 and (x,y+1) not in path_stack:\n                    if found_next:\n                        cell_to_other_paths[(x,y)].append((x,y+1))\n                    else:\n                        found_next = True\n                        tmp_x, tmp_y = x, y+1\n                    \n                if found_next:\n                    path_stack.append((tmp_x, tmp_y))\n                    #visited.add((tmp_x, tmp_y))\n                    cumulated_gold += grid[tmp_x][tmp_y]\n                    x, y = tmp_x, tmp_y\n                else:\n                    max_gold = max(max_gold, cumulated_gold)\n                    while path_stack and len(cell_to_other_paths.get(path_stack[-1],[]))==0:\n                        pop_x, pop_y = path_stack.pop(-1)\n                        cumulated_gold -= grid[pop_x][pop_y]\n                    if not path_stack:\n                        break\n                    x, y = cell_to_other_paths[path_stack[-1]].pop(0)\n                    path_stack.append((x,y))\n                    cumulated_gold += grid[x][y]\n                    \n        return max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        #2D array \n        #0 means no gold \n        #some_num > 0 means there is gold \n        #Return the max gold you can collect with these conditions\n        \n        #1) IN w.e cell you are collect ALL the gold in that cell \n        #From you position move U D L R \n        #You can't VISIT the same cell more than once. \n        #You can start and stop collecting gold from ANY position in the grid that has some gold.\n        visited = set()\n        max_path = [0]\n        row_len = len(grid)\n        col_len = len(grid[0])\n        \n        def gold_finder(cur_row, cur_col, visited, path_so_far):\n            #Can't visit area that is zero. \n\n            #Out of boundary check \n            if cur_row < 0 or cur_row >= row_len or cur_col < 0 or cur_col >= col_len or grid[cur_row][cur_col] == 0: \n                max_path[0] = max(max_path[0], sum(path_so_far))\n                return \n            # if grid[cur_row][cur_col] == 0: \n            #     return \n                \n            #If visited we can't visit you again. \n            if (cur_row, cur_col) in visited: \n                return \n            \n            visited.add((cur_row,cur_col))\n            gold_finder(cur_row + 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row - 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row , cur_col + 1, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row, cur_col - 1, visited, path_so_far + [grid[cur_row][cur_col]])\n            visited.remove((cur_row,cur_col))\n            \n            return \n \n        for row in range(row_len):\n            for col in range(col_len): \n                gold_finder(row, col, visited, [])\n                \n                \n        # print('before', max_path)\n        # max_path = max(max_path)\n        # print('after', max_path)\n        return max_path[0]", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        max_total = 0\n        num_rows = len(grid)\n        num_cols = len(grid[0])\n        \n        for i in range(num_rows):\n            for j in range(num_cols):\n                if grid[i][j] == 0:\n                    continue\n                start_pos = (i,j)\n                visited = {(i,j)}\n                \n                stack = [(start_pos, visited, grid[i][j])]\n                while stack:\n                    (x, y), visited, running_total = stack.pop(0)\n                    neighbors = ((x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y))\n                    valid_neighbors = [(i,j) for i, j in neighbors if 0 <= i < num_rows and 0 <= j < num_cols and grid[i][j] != 0 and (i,j) not in visited]\n                    if not valid_neighbors:\n                        if running_total > max_total:\n                            max_total = running_total\n                        continue\n                    else:\n                        for x,y in valid_neighbors:\n                            copy = visited.copy()\n                            copy.add((x,y))\n                            stack.append(((x,y), copy, running_total + grid[x][y]))\n        return max_total\n                            \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(pos, visited):\n            if pos in visited or grid[pos[0]][pos[1]] == 0:\n                return 0\n            \n            next_visited = visited | set([pos])\n            next_pos = [\n                (pos[0]-1, pos[1]),\n                (pos[0]+1, pos[1]),\n                (pos[0], pos[1]-1),\n                (pos[0], pos[1]+1),\n            ]\n\n            max_child = 0\n            for p in next_pos:\n                if -1 < p[0] < n and -1 < p[1] < m:\n                    max_child = max(max_child, dfs(p, next_visited))\n            \n            return grid[pos[0]][pos[1]] + max_child\n        \n        n = len(grid)\n        m = len(grid[0])\n        \n        max_gold = 0\n        for i in range(n):\n            for j in range(m):\n                max_gold = max(max_gold, dfs((i, j), set()))\n        return max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        max_total = 0\n        num_rows = len(grid)\n        num_cols = len(grid[0])\n        \n        for i in range(num_rows):\n            for j in range(num_cols):\n                if grid[i][j] == 0:\n                    continue\n                start_pos = (i,j)\n                visited = set()\n                \n                stack = [(start_pos, visited, grid[i][j])]\n                while stack:\n                    (x, y), visited, running_total = stack.pop(0)\n                    visited.add((x,y))\n                    neighbors = ((x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y))\n                    valid_neighbors = [(i,j) for i, j in neighbors if 0 <= i < num_rows and 0 <= j < num_cols and grid[i][j] != 0 and (i,j) not in visited]\n                    if not valid_neighbors:\n                        if running_total > max_total:\n                            max_total = running_total\n                        continue\n                    else:\n                        for x,y in valid_neighbors:\n                            copy = visited.copy()\n                            stack.append(((x,y), copy, running_total + grid[x][y]))\n        return max_total\n                            \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        directions = [(1,0),(-1,0),(0,1),(0,-1)]\n        self.maxgold = 0\n        \n        \n        def isValid(i, j):\n            if 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j] != 0:\n                return True\n            else:\n                return False\n        \n        def helper(i, j, cursum):\n            for direction in directions:\n                new_i = i+direction[0]\n                new_j = j+direction[1]\n                if isValid(new_i, new_j):\n                    gold = grid[new_i][new_j]\n                    grid[new_i][new_j] = 0\n                    helper(new_i, new_j, cursum+gold)\n                    grid[new_i][new_j] = gold\n            self.maxgold = max(self.maxgold, cursum)\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    gold = grid[i][j]\n                    grid[i][j] = 0\n                    helper(i, j, gold)\n                    grid[i][j] = gold\n        \n        return self.maxgold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        i_len = len(grid)\n        j_len = len(grid[0])\n        max_shit = 0\n        \n        def moves(i, j, amount):\n            nonlocal max_shit, i_len, j_len\n            if(i<0 or j<0 or i==i_len or j==j_len or grid[i][j]==0):\n                if amount>max_shit:\n                    max_shit=amount\n                return\n            amount += grid[i][j]\n            tmp = grid[i][j]\n            grid[i][j] = 0\n            moves(i+1, j, amount)\n            moves(i-1, j, amount)\n            moves(i, j+1, amount)\n            moves(i, j-1, amount)\n            grid[i][j] = tmp\n        \n        for i in range(i_len):\n            for j in range(j_len):\n                if(grid[i][j]!=0):\n                    moves(i, j, 0)\n        \n        return max_shit\n", "class Solution:\n    \n    def __init__(self):\n        self.moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def dfs(self, r, c):\n        if r < 0 or r == self.m or c < 0 or c == self.n or self.grid[r][c] == 0:\n            return 0\n        original = self.grid[r][c]\n        self.grid[r][c] = 0\n        maxGold = max(self.dfs(r+x, c+y) for x, y in self.moves)\n        self.grid[r][c] = original\n        return maxGold + original\n    \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.m = len(grid)\n        self.n = len(grid[0])\n        self.grid = grid\n        return max(self.dfs(i, j) for i in range(self.m) for j in range(self.n))\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        d=[]\n        m=len(grid)\n        n=len(grid[0])\n        gold=[]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]>0:\n                    gold.append((i,j))\n        d=[[1,0],[-1,0],[0,1],[0,-1]]\n        \n        def dfs(x,y,seen):\n            if (x,y) in seen or x<0 or x>=m or y<0 or y>=n or grid[x][y]<=0:\n                return 0\n            a=seen.copy()\n            a.add((x,y))\n            return grid[x][y]+max(dfs(x+dx,y+dy,a) for dx,dy in d)\n        \n        return max(dfs(x,y,set()) for x,y in gold)\n", "class Solution():\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, sum_so_far: int, seen: set) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or not grid[i][j] or (i, j) in seen:\n                return sum_so_far \n            \n            seen.add((i, j))\n            sum_so_far += grid[i][j]\n            mx = 0\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                mx = max(dfs(x, y, sum_so_far, seen), mx)\n            seen.discard((i, j))   \n            return mx\n\n        m, n = len(grid), len(grid[0])\n        all_gold_path = 0\n        for row in range(m):\n            for col in range(n): \n                all_gold_path = max(all_gold_path, dfs(row, col, 0, set()))\n        # print(all_gold_path)\n        return all_gold_path\n        # return max(dfs(i, j, 0, set()) for j in range(n) for i in range(m))\n# class Solution:\n#     def getMaximumGold(self, grid: List[List[int]]) -> int:\n#         def findMaxGold(r: int, c: int) -> int:\n#             if r < 0 or r == m or c < 0 or c == n or grid[r][c] == 0: return 0\n#             origin = grid[r][c]\n#             grid[r][c] = 0  # mark as visited\n#             maxGold = 0\n#             for nr, nc in ((r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)):\n#                 maxGold = max(findMaxGold(nr, nc), maxGold)\n#             grid[r][c] = origin  # backtrack\n#             return maxGold + origin\n\n#         m, n = len(grid), len(grid[0])\n#         return max(findMaxGold(r, c) for c in range(n) for r in range(m))\n\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        #2D array \n        #0 means no gold \n        #some_num > 0 means there is gold \n        #Return the max gold you can collect with these conditions\n        \n        #1) IN w.e cell you are collect ALL the gold in that cell \n        #From you position move U D L R \n        #You can't VISIT the same cell more than once. \n        #You can start and stop collecting gold from ANY position in the grid that has some gold.\n        visited = set()\n        max_path = [0]\n        row_len = len(grid)\n        col_len = len(grid[0])\n        \n        def gold_finder(cur_row, cur_col, visited, path_so_far):\n            #Can't visit area that is zero. \n\n            #Out of boundary check \n            if cur_row < 0 or cur_row >= row_len or cur_col < 0 or cur_col >= col_len or grid[cur_row][cur_col] == 0: \n                max_path[0] = max(max_path[0], sum(path_so_far))\n                return \n            # if grid[cur_row][cur_col] == 0: \n            #     return \n                \n            #If visited we can't visit you again. \n            if (cur_row, cur_col) in visited: \n                return \n            \n            visited.add((cur_row,cur_col))\n            gold_finder(cur_row + 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row - 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row , cur_col + 1, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row, cur_col - 1, visited, path_so_far + [grid[cur_row][cur_col]])\n            visited.remove((cur_row,cur_col))\n            \n            return \n \n        for row in range(row_len):\n            for col in range(col_len): \n                gold_finder(row, col, visited, [])\n                \n                \n        # print('before', max_path)\n        # max_path = max(max_path)\n        # print('after', max_path)\n        return max_path[0]", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        #2D array \n        #0 means no gold \n        #some_num > 0 means there is gold \n        #Return the max gold you can collect with these conditions\n        \n        #1) IN w.e cell you are collect ALL the gold in that cell \n        #From you position move U D L R \n        #You can't VISIT the same cell more than once. \n        #You can start and stop collecting gold from ANY position in the grid that has some gold.\n        visited = set()\n        max_path = [0]\n        row_len = len(grid)\n        col_len = len(grid[0])\n        \n        def gold_finder(cur_row, cur_col, visited, path_so_far):\n            #Can't visit area that is zero. \n\n            #Out of boundary check \n            if cur_row < 0 or cur_row >= row_len or cur_col < 0 or cur_col >= col_len or grid[cur_row][cur_col] == 0: \n                max_path[0] = max(max_path[0], sum(path_so_far))\n                return \n            # if grid[cur_row][cur_col] == 0: \n            #     return \n                \n            #If visited we can't visit you again. \n            if (cur_row, cur_col) in visited: \n                return \n            \n            visited.add((cur_row,cur_col))\n            gold_finder(cur_row + 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row - 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row , cur_col + 1, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row, cur_col - 1, visited, path_so_far + [grid[cur_row][cur_col]])\n            visited.remove((cur_row,cur_col))\n            \n            return \n \n        for row in range(row_len):\n            for col in range(col_len): \n                gold_finder(row, col, visited, [])\n                \n                \n        # print('before', max_path)\n        # max_path = max(max_path)\n        # print('after', max_path)\n        return max_path[0]\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        \n        x = [0, 1, 0, -1]\n        y = [1, 0, -1, 0]\n        \n        m, n = len(grid), len(grid[0])\n        \n        ans = -math.inf\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        \n        def helper(cur, total):\n            curX, curY = cur\n            total += grid[curX][curY]\n            visited[curX][curY] = True\n            \n            nonlocal ans\n            ans = max(ans, total)\n            \n            for dx, dy in zip(x, y):\n                candX, candY = curX + dx, curY + dy\n                \n                if 0 <= candX < m and 0 <= candY < n and grid[candX][candY] and not visited[candX][candY]:\n                    print(candX, candY)\n                    helper([candX, candY], total)\n                    \n            visited[curX][curY] = False\n                \n        for r in range(m):\n            for c in range(n):\n                if grid[r][c]:\n                    helper([r, c], 0)\n                    \n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        checked = set()\n        maximum = 0\n        for x in range(len(grid)):\n            for y in range(len(grid[0])):\n                # not 0\n                if (grid[x][y] and (x,y) not in checked):\n                    # print(\\\"checking: \\\" + str((x,y)))\n                    visited = set()\n                    value = self.recursive(0, x , y, grid, visited, checked) \n\n                    if (value > maximum):\n                        # print(\\\"new max point: \\\" + str((x,y)))\n                        # print(\\\"new max: \\\" + str(value))\n                        maximum = value\n        return maximum\n        \n    # not zero and not visited\n    def valid(self, x, y, grid, visited):\n        if (x <0 or x >= len(grid) or y < 0 or y >= len(grid[0])):\n            return False\n            \n        if (grid[x][y] == 0 or (x,y) in visited):\n            return False\n        return True\n    \n    def recursive(self, total, x, y, grid, visited, checked):\n        # visited = set(visited)\n        visited.add((x,y))\n        total = total + grid[x][y]\n        \n        vTop = False\n        vBtm = False\n        vRight = False\n        vLeft = False\n        \n        left,right,top,btm = 0,0,0,0\n        \n        if (self.valid(x-1,y,grid,visited)):\n            # print('top')\n            top = self.recursive(total, x-1, y, grid, visited, checked)\n            vTop = self.valid(x-1,y,grid,visited)\n        \n        if (self.valid(x+1,y,grid,visited)):\n            # print('btm')\n            btm = self.recursive(total, x+1, y, grid, visited, checked)\n            vBtm = self.valid(x+1,y,grid,visited)\n\n            \n        if (self.valid(x,y-1,grid,visited)):\n            # print('left')\n            left =self.recursive(total, x, y-1, grid, visited, checked)\n            vLeft = self.valid(x,y-1,grid,visited)\n\n        if (self.valid(x,y+1,grid,visited)):\n            # print('right')\n            right = self.recursive(total, x, y+1, grid, visited, checked)\n            vRight = self.valid(x,y+1,grid,visited)\n\n        \n        gotPath = vLeft or vRight or vTop or vBtm\n        # if (gotPath):\n        #     checked.add((x,y))\n        visited.remove((x,y))\n        return max(left, right, top, btm, total)\n            \n        \n", "class Solution():\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i: int, j: int, sum_so_far: int, seen: set) -> int:\n            if i < 0 or i >= m or j < 0 or j >= n or not grid[i][j] or (i, j) in seen:\n                return sum_so_far \n            \n            seen.add((i, j))\n            sum_so_far += grid[i][j]\n            max_all = 0\n            for x, y in ((i, j + 1), (i , j - 1), (i + 1, j), (i - 1, j)):\n                max_all = max(dfs(x, y, sum_so_far, seen), max_all)\n            seen.discard((i, j))   \n            return max_all\n\n        m, n = len(grid), len(grid[0])\n        all_gold_path = 0\n        for row in range(m):\n            for col in range(n): \n                all_gold_path = max(all_gold_path, dfs(row, col, 0, set()))\n        # print(all_gold_path)\n        return all_gold_path\n        # return max(dfs(i, j, 0, set()) for j in range(n) for i in range(m))\n# class Solution:\n#     def getMaximumGold(self, grid: List[List[int]]) -> int:\n#         def findMaxGold(r: int, c: int) -> int:\n#             if r < 0 or r == m or c < 0 or c == n or grid[r][c] == 0: return 0\n#             origin = grid[r][c]\n#             grid[r][c] = 0  # mark as visited\n#             maxGold = 0\n#             for nr, nc in ((r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)):\n#                 maxGold = max(findMaxGold(nr, nc), maxGold)\n#             grid[r][c] = origin  # backtrack\n#             return maxGold + origin\n\n#         m, n = len(grid), len(grid[0])\n#         return max(findMaxGold(r, c) for c in range(n) for r in range(m))\n\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        #2D array \n        #0 means no gold \n        #some_num > 0 means there is gold \n        #Return the max gold you can collect with these conditions\n        \n        #1) IN w.e cell you are collect ALL the gold in that cell \n        #From you position move U D L R \n        #You can't VISIT the same cell more than once. \n        #You can start and stop collecting gold from ANY position in the grid that has some gold.\n        visited = set()\n        max_path = [0]\n        row_len = len(grid)\n        col_len = len(grid[0])\n        \n        def gold_finder(cur_row, cur_col, visited, path_so_far):\n            #Can't visit area that is zero. \n\n            #Out of boundary check \n            if cur_row < 0 or cur_row >= row_len or cur_col < 0 or cur_col >= col_len or grid[cur_row][cur_col] == 0: \n                max_path[0] = max(max_path[0], sum(path_so_far))\n                return \n            # if grid[cur_row][cur_col] == 0: \n            #     return \n                \n            #If visited we can't visit you again. \n            if (cur_row, cur_col) in visited: \n                return \n            \n            visited.add((cur_row,cur_col))\n            gold_finder(cur_row + 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row - 1, cur_col, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row , cur_col + 1, visited, path_so_far + [grid[cur_row][cur_col]])\n            gold_finder(cur_row, cur_col - 1, visited, path_so_far + [grid[cur_row][cur_col]])\n            visited.remove((cur_row,cur_col))\n            \n            return \n \n        for row in range(row_len):\n            for col in range(col_len): \n                gold_finder(row, col, visited, [])\n                \n                \n        # print('before', max_path)\n        # max_path = max(max_path)\n        # print('after', max_path)\n        return max_path[0]", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.res = 0\n        m,n = len(grid),len(grid[0])\n        def dfs(x,y,visited,cnt):\n            if any(0<=nx< m and 0<=ny<n and grid[nx][ny] !=0 and (nx,ny) not in visited for nx,ny in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]] ):\n                \n                for nx,ny in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]:\n                    if 0<=nx< m and 0<=ny<n and grid[nx][ny] !=0 and (nx,ny) not in visited:\n                        dfs(nx,ny,visited|{(nx,ny)},cnt+grid[nx][ny])\n            else:\n                self.res = max(self.res, cnt)\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]!=0:\n                    dfs(i,j,{(i,j)},grid[i][j])\n        return self.res\n                \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        \n        def helper(r, c, total, visited):\n            nonlocal maxx\n            if r < 0 or r >= rows or c < 0 or c >= cols or\\\\\n                grid[r][c] == 0 or (r, c) in visited:\n                return\n            total += grid[r][c]\n            maxx = max(maxx, total)\n            helper(r + 1, c, total, visited + [(r, c)])\n            helper(r - 1, c, total, visited + [(r, c)])\n            helper(r, c + 1, total, visited + [(r, c)])\n            helper(r, c - 1, total, visited + [(r, c)])\n        \n        greatest = 0\n        \n        starts = []\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col] != 0:\n                    maxx = 0\n                    helper(row, col, 0, [])\n                    greatest = max(maxx, greatest)\n                    \n        return greatest\n                ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i, j, total):\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0 or grid[i][j] > 100:\n                return total\n            total += grid[i][j]\n            grid[i][j] += 1000\n            temp_max = 0\n            for x, y in ((i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)):\n                temp_max = max(dfs(x, y, total), temp_max)\n            grid[i][j] -= 1000\n            \n            return temp_max\n        \n        m = len(grid)\n        n = len(grid[0])\n        return max(dfs(i, j, 0) for i in range(m) for j in range(n))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m=len(grid)\n        n=len(grid[0])\n        maxi=0\n        \n        def findMaxGold(r,c):\n            if r < 0 or r == m or c < 0 or c == n or grid[r][c] == 0: return 0\n            origin = grid[r][c]\n            grid[r][c] = 0  # mark as visited\n            maxGold = 0\n            for nr, nc in ((r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)):\n                maxGold = max(findMaxGold(nr, nc), maxGold)\n            grid[r][c] = origin  # backtrack\n            return maxGold + origin\n                \n        for i in range(m):\n            for j in range(n):\n                maxi = max(maxi,findMaxGold(i,j))\n                    \n        return(maxi)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        results=[]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]==0:\n                    continue \n                tmp=grid[i][j]\n                grid[i][j]='*'\n                self.helper([tmp],i,j,grid,results)\n                grid[i][j]=tmp\n        maxV=-sys.maxsize\n        for i in results:\n            if sum(i)>maxV:\n                maxV=sum(i)\n        return maxV\n        \n    def helper(self,sub,ii,jj,grid,results):\n        # print(sub,grid[ii][jj])\n        if sub[-1]==0:\n            results.append(sub.copy())\n            return\n        \n            \n        ll=[[ii-1,jj],[ii+1,jj],[ii,jj-1],[ii,jj+1]]\n       \n        for l in ll:\n            \n            if l[0]<0 or l[0]>len(grid)-1:\n                continue\n            if l[1]<0 or l[1]>len(grid[0])-1:\n                continue\n            if grid[l[0]][l[1]]=='*':\n                continue\n                \n            sub.append(grid[l[0]][l[1]])\n            tmp=grid[l[0]][l[1]]\n            grid[l[0]][l[1]]='*'\n            self.helper(sub,l[0],l[1],grid,results)\n            grid[l[0]][l[1]]=tmp\n            sub.pop()\n            \n", "def isValid(i, j, n, m):\n    return i >= 0 and j >= 0 and i < n and j < m\n    \nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        directions = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n        n, m = len(grid), len(grid[0])\n        \n        def dfs(i, j, curr_sum, visited):\n            if not isValid(i, j, n, m) or (i, j) in visited or not grid[i][j]: return curr_sum\n            curr_sum += grid[i][j]\n            final = 0\n            visited.add((i, j))\n            for x,y in directions:\n                newX, newY = i+x, j+y\n                final = max(dfs(newX, newY, curr_sum, visited), final)\n            visited.remove((i, j))\n            return final\n        \n        ans = 0\n        visited = set()\n        for r in range(n):\n            for c in range(m):\n                ans = max(ans, dfs(r, c, 0, visited))\n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(grid, i, j):\n            if 0 <= i <len(grid) and 0 <= j <len(grid[0]) and grid[i][j] != 0:\n                temp = grid[i][j]\n                grid[i][j] = 0\n                d = [(1,0),(-1,0),(0,1),(0,-1)]\n                summax = 0\n                for m,n in d:\n                    x = i+m\n                    y = j+n\n                    summax = max(summax, dfs(grid,x,y))\n                grid[i][j]  = temp\n                return temp + summax\n            else:\n                return 0\n        if len(grid) == 0 or grid == '':\n            return 0\n        res = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                res = max(res, dfs(grid,i,j))\n        return res\n    \n                \n        \n        \n\n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        checked = set()\n        maximum = 0\n        for x in range(len(grid)):\n            for y in range(len(grid[0])):\n                # not 0\n                if (grid[x][y] and (x,y) not in checked):\n                    # print(\\\"checking: \\\" + str((x,y)))\n                    visited = set()\n                    value = self.recursive(0, x , y, grid, visited, checked) \n\n                    if (value > maximum):\n                        # print(\\\"new max point: \\\" + str((x,y)))\n                        # print(\\\"new max: \\\" + str(value))\n                        maximum = value\n        return maximum\n        \n    # not zero and not visited\n    def valid(self, x, y, grid, visited):\n        if (x <0 or x >= len(grid) or y < 0 or y >= len(grid[0])):\n            return False\n            \n        if (grid[x][y] == 0 or (x,y) in visited):\n            return False\n        return True\n    \n    def recursive(self, total, x, y, grid, visited, checked):\n        visited = set(visited)\n        visited.add((x,y))\n        total = total + grid[x][y]\n        \n        vTop = False\n        vBtm = False\n        vRight = False\n        vLeft = False\n        \n        left,right,top,btm = 0,0,0,0\n        \n        if (self.valid(x-1,y,grid,visited)):\n            # print('top')\n            top = self.recursive(total, x-1, y, grid, visited, checked)\n            vTop = self.valid(x-1,y,grid,visited)\n        \n        if (self.valid(x+1,y,grid,visited)):\n            # print('btm')\n            btm = self.recursive(total, x+1, y, grid, visited, checked)\n            vBtm = self.valid(x+1,y,grid,visited)\n\n            \n        if (self.valid(x,y-1,grid,visited)):\n            # print('left')\n            left =self.recursive(total, x, y-1, grid, visited, checked)\n            vLeft = self.valid(x,y-1,grid,visited)\n\n        if (self.valid(x,y+1,grid,visited)):\n            # print('right')\n            right = self.recursive(total, x, y+1, grid, visited, checked)\n            vRight = self.valid(x,y+1,grid,visited)\n\n        \n        gotPath = vLeft or vRight or vTop or vBtm\n        # if (gotPath):\n        #     checked.add((x,y))\n            \n        return max(left, right, top, btm, total)\n            \n        \n", "class Solution:\n    def __init__(self):\n        self.max = 0\n        self.grid=[[]]\n        self.dp = [[]]\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.grid = grid\n        self.dp = [[0 for j in range(len(grid[0]))] for i in range(len(grid))]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if self.grid[i][j] != 0: #and self.dp[i][j] == 0:\n                    visit = set()\n                    self.dp[i][j] = self.dfs(visit,(i,j))\n                    self.max=max(self.max, self.dp[i][j])\n        \n        #self.dp[4][4] = self.dfs(set(),(4,4))\n        #print(self.dp)\n        return self.max\n        \n    def dfs(self, visit, node):\n        \n        #visit.add(node)\n        i,j = node\n        #self.dp[i][j] = self.grid[i][j]\n        neighborVals = [0]\n        #print(visit)\n        for di, dj in [(-1,0),(0,1),(1,0),(0,-1)]:\n            if 0 <= i+di < len(self.grid) and 0 <= j+dj < len(self.grid[0]) and \\\\\n            (i+di,j+dj) not in visit:\n                if self.grid[i+di][j+dj] > 0: #and self.dp[i+di][j+dj] == 0:\n                    #self.dfs(visit, (i+di,j+dj))\n                    #temp = set()\n                    #temp.add(node)\n                    neighborVals.append(self.dfs(visit.union({node}), (i+di,j+dj)))\n        #print(node,self.grid[i][j], neighborVals)\n        return self.grid[i][j] + max(neighborVals)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        ans = 0\n        \n        for i in range(len(grid)-1, -1, -1):\n            for j in range(len(grid[0])-1, -1, -1):\n                \n                if grid[i][j] != 0:\n                    ans = max(ans, self.findGold(grid, i, j))\n        \n        return ans\n    \n    \n    def findGold(self, grid, row, col):\n        \n        if not(0 <= row < len(grid) and 0 <= col < len(grid[0])) or grid[row][col] == 0:\n            return 0\n        \n        ans = 0\n        temp = grid[row][col]\n        grid[row][col] = 0\n        \n        for i,j in [(1,0), (-1,0), (0,1), (0,-1)]:\n            ans = max(ans, self.findGold(grid, row+i, col+j))\n        \n        grid[row][col] = temp\n        return ans + temp\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        At each square, look at adjacent squares.\n        \n        If adjacent square is 0 then skip\n        If adjacent square has already been visited during this path then skip\n        If adjacent square is not in bounds of grid then skip\n        \n        Else add it to the list of squares visited on this path, then explore\n        that adjacent square.\n        \n        If there are no more adjacent squares to visit, then\n        record the path total and update the nonlocal total.\n        \n        Caveats:\n            - We can't cache because the max path from a square differs depending on the preceding path\n        \\\"\\\"\\\"\n        self.max_gold = 0\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        visited = [[False] * n for _ in range(m)]\n        \n        def dfs(path_gold = 0, i = 0, j = 0):\n            g = grid[i][j]\n            if g == 0 or visited[i][j]:\n                if path_gold > self.max_gold:\n                    self.max_gold = path_gold\n                return\n            \n            curr_path_gold = path_gold + g\n            visited[i][j] = True\n            if i > 0:\n                dfs(curr_path_gold, i - 1, j)\n            if i < m-1:\n                dfs(curr_path_gold, i + 1, j)\n\n            if j > 0:\n                dfs(curr_path_gold, i, j - 1)\n            if j < n-1:\n                dfs(curr_path_gold, i, j + 1)\n            visited[i][j] = False\n        \n        for i in range(m):\n            for j in range(n):\n                dfs(i = i, j = j)\n        \n        return self.max_gold\n            \n        \n            \n                \n                    ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        \n        \n        \n        ROWS = len(grid)\n        COLS = len(grid[0])\n        \n        self.mx = 0\n        seen = set()\n        def dfs(r,c):\n            if not 0 <= r < ROWS or not 0 <= c < COLS or (r,c) in seen or grid[r][c] == 0:\n                return 0\n            val = grid[r][c]\n            seen.add((r,c))\n            mx = max(dfs(r+1,c),dfs(r-1,c),dfs(r,c+1),dfs(r,c-1))\n            seen.remove((r,c))\n            return val + mx\n            \n        \n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] != 0:\n                    self.mx = max(self.mx, dfs(r,c))\n        return self.mx", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        ans = 0\n        \n        def bfs(a,s,d,f):\n            nonlocal ans\n            q = collections.deque([(a,s,d,f)])\n            \n            while q:\n                j,k, tot, seen = q.popleft()\n                for m,n in [[0,1], [0,-1], [1,0], [-1,0]]:\n                    jm, kn = j+m, k+n\n                    if jm > -1 and kn > -1 and jm < len(grid) and kn < len(grid[0]) and grid[jm][kn] and (jm,kn) not in seen:\n                        q.append((jm,kn,tot+grid[jm][kn], seen | {(jm,kn)}))\n                    else:\n                        ans = max(ans, tot)\n                \n        for i in range(len(grid)):\n            for x in range(len(grid[0])):\n                if grid[i][x]:\n                    bfs(i,x,grid[i][x], {(i,x)})\n        \n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        m, n = len(grid), len(grid[0])\n        \n        def bfs(i, j, path):\n            if i<0 or i>=m or j<0 or j>=n or grid[i][j]==0 or (i,j) in path:\n                return 0\n            return grid[i][j] + max([bfs(i-1, j, path+[(i,j)]), \n                                     bfs(i+1, j, path+[(i,j)]), \n                                     bfs(i, j-1, path+[(i,j)]), \n                                     bfs(i, j+1, path+[(i,j)])])\n        \n        maxval = None\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    path = []\n                    val = bfs(i,j, path)\n                    if maxval is None or val > maxval:\n                        maxval = val\n        return maxval\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def findMaxGold(r: int, c: int) -> int:\n            if r < 0 or r == m or c < 0 or c == n or grid[r][c] == 0: return 0\n            origin = grid[r][c]\n            grid[r][c] = 0  # mark as visited\n            maxGold = 0\n            for nr, nc in ((r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c)):\n                maxGold = max(findMaxGold(nr, nc), maxGold)\n            grid[r][c] = origin  # backtrack\n            return maxGold + origin\n\n        m, n = len(grid), len(grid[0])\n        return max(findMaxGold(r, c) for c in range(n) for r in range(m))\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def neighbor(r, c):\n            for dr, dc in (r+1, c), (r-1, c), (r, c+1), (r, c-1):\n                if  0 <= dr < nrow and 0 <= dc < ncol:\n                    yield dr, dc\n        \n        self.cur_gold = 0\n        self.max_gold = 0\n        \n        def backtrack(r, c):\n            if grid[r][c] == 0: # no gold, not allowed to process\n                return\n            gold_cnt = grid[r][c]\n            self.cur_gold += gold_cnt\n            \n            self.max_gold = max(self.max_gold, self.cur_gold)\n            grid[r][c] = 0\n            \n            for dr, dc in neighbor(r, c):\n                backtrack(dr, dc)\n                \n            grid[r][c] = gold_cnt # backtrack\n            self.cur_gold -= gold_cnt\n        \n        nrow, ncol = len(grid), len(grid[0])\n        for r in range(nrow):\n            for c in range(ncol):\n                backtrack(r, c)\n        \n        return self.max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        rows = len(grid)\n        cols = len(grid[0])\n        \n        def helper(r, c, total, visited):\n            nonlocal maxx\n            if r < 0 or r >= rows or c < 0 or c >= cols or\\\\\n                grid[r][c] == 0 or (r, c) in visited:\n                return\n            total += grid[r][c]\n            maxx = max(maxx, total)\n            helper(r + 1, c, total, visited + [(r, c)])\n            helper(r - 1, c, total, visited + [(r, c)])\n            helper(r, c + 1, total, visited + [(r, c)])\n            helper(r, c - 1, total, visited + [(r, c)])\n        \n        greatest = 0\n        \n        starts = []\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col] != 0:\n                    maxx = 0\n                    helper(row, col, 0, [])\n                    greatest = max(maxx, greatest)\n                    \n        return greatest", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.res = 0\n        self.grid = grid\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    self.dfs(i, j, 0)\n        return self.res\n\n    def dfs(self, i, j, cur_gold):\n        self.res = max(self.res, cur_gold)\n        if (0 <= i < len(self.grid) and 0 <= j < len(self.grid[0])) and self.grid[i][j] != 0:\n            gold = self.grid[i][j]\n            for m, n in [(-1, 0), (0, -1), (0, 1), (1, 0)]:\n                self.grid[i][j] = 0\n                self.dfs(i + m, j + n, cur_gold + gold)\n                self.grid[i][j] = gold\n            \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        checked = set()\n        maximum = 0\n        for x in range(len(grid)):\n            for y in range(len(grid[0])):\n                # not 0\n                if (grid[x][y] and (x,y) not in checked):\n                    # print(\\\"checking: \\\" + str((x,y)))\n                    visited = set()\n                    value = self.recursive(0, x , y, grid, visited, checked) \n\n                    if (value > maximum):\n                        # print(\\\"new max point: \\\" + str((x,y)))\n                        # print(\\\"new max: \\\" + str(value))\n                        maximum = value\n        return maximum\n        \n    # not zero and not visited\n    def valid(self, x, y, grid, visited):\n        if (x <0 or x >= len(grid) or y < 0 or y >= len(grid[0])):\n            return False\n            \n        if (grid[x][y] == 0 or (x,y) in visited):\n            return False\n        return True\n    \n    def recursive(self, total, x, y, grid, visited, checked):\n        visited = set(visited)\n        visited.add((x,y))\n        total = total + grid[x][y]\n        \n        vTop = False\n        vBtm = False\n        vRight = False\n        vLeft = False\n        \n        left,right,top,btm = 0,0,0,0\n        \n        if (self.valid(x-1,y,grid,visited)):\n            # print('top')\n            top = self.recursive(total, x-1, y, grid, visited, checked)\n            vTop = self.valid(x-1,y,grid,visited)\n        \n        if (self.valid(x+1,y,grid,visited)):\n            # print('btm')\n            btm = self.recursive(total, x+1, y, grid, visited, checked)\n            vBtm = self.valid(x+1,y,grid,visited)\n\n            \n        if (self.valid(x,y-1,grid,visited)):\n            # print('left')\n            left =self.recursive(total, x, y-1, grid, visited, checked)\n            vLeft = self.valid(x,y-1,grid,visited)\n\n        if (self.valid(x,y+1,grid,visited)):\n            # print('right')\n            right = self.recursive(total, x, y+1, grid, visited, checked)\n            vRight = self.valid(x,y+1,grid,visited)\n\n        \n        gotPath = vLeft or vRight or vTop or vBtm\n        # if (gotPath):\n        #     checked.add((x,y))\n        # visited.remove((x,y))\n        return max(left, right, top, btm, total)\n            \n        \n", "class Solution:\n    def dfs(self, i, j, gold, grid, m, n):\n        if 0 <= i < m and 0 <= j < n:\n            if grid[i][j] != 0:\n                temp = grid[i][j]\n                grid[i][j] = 0\n                gold = max(self.dfs(x,y,gold+temp,grid,m,n) for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)))\n                grid[i][j] = temp\n        return gold\n    \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        res = []\n        for i in range(m):\n            for j in range(n):\n                res.append(self.dfs(i, j, 0, grid, m,n))\n        \n        return max(res)\n\n        \n        \n", "class Solution:\n    DIRS = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        N, M = len(grid), len(grid[0])\n        self.res = 0\n        def dfs(x: int, y: int, v: int, done: set):\n            self.res = max(self.res, v)\n            for dx, dy in self.DIRS:\n                xx, yy = x + dx, y + dy\n                if not (0 <= xx < N) or not (0 <= yy < M) or (xx, yy) in done or grid[xx][yy] == 0:\n                    continue\n                done.add((xx, yy))\n                dfs(xx, yy, v + grid[xx][yy], done)\n                done.remove((xx, yy))\n        done = set()\n        for ii in range(N):\n            for jj in range(M):\n                zero_num = [idx for idx, (dx, dy) in enumerate(self.DIRS) if (0<= ii + dx < N) and (0 <= jj + dy < M) and grid[ii + dx][jj + dy]]\n                flag = len(zero_num) <= 1 or (len(zero_num) == 2 and 1 in zero_num and 2 in zero_num)\n                if grid[ii][jj] and flag:\n                    done.add((ii, jj))\n                    dfs(ii, jj, grid[ii][jj], done)\n                    done.remove((ii, jj))\n        return self.res\n            \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        def dfs(r, c, total, vis):\n            nonlocal maxx\n            if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] == 0 or (r,c) in vis:\n                return \n            total += grid[r][c]\n            maxx = max(total, maxx)\n            dfs(r+1, c, total, vis + [(r,c)])\n            dfs(r-1, c, total, vis + [(r,c)])\n            dfs(r, c+1, total, vis + [(r,c)])\n            dfs(r, c-1, total, vis + [(r,c)])\n        \n        grt = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    maxx = 0\n                    dfs(i, j, 0, [])\n                    grt = max(grt, maxx)\n        return grt\n                                \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid or (not grid[0]):\n            return 0\n        r, c = len(grid), len(grid[0])\n        def dfs(i, j, curr, visited):\n            self.mx = max(self.mx, curr)\n            for di, dj in [(0,1), (0,-1), (1,0), (-1,0)]:\n                if (0<=i+di<r) and (0<=j+dj<c) and (grid[i+di][j+dj]!=0) and ((i+di,j+dj) not in visited):\n                    visited.add((i+di,j+dj))\n                    dfs(i+di, j+dj, curr+grid[i+di][j+dj], visited)\n                    visited.remove((i+di, j+dj))\n            return\n        self.mx = 0\n        for i in range(r):\n            for j in range(c):\n                if grid[i][j] != 0:\n                    dfs(i, j, grid[i][j], {(i,j)})\n        return self.mx", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        n=len(grid)\n        m=len(grid[0])\n        def dfs(i,j,total,visited):\n            if i<0 or i>=n or j<0 or j>=m or grid[i][j]==0 or (i,j) in visited:\n                    return\n            nonlocal ma\n            total=total+grid[i][j]\n            ma=max(ma,total)\n            dfs(i + 1, j, total, visited + [(i, j)])\n            dfs(i - 1, j, total, visited + [(i, j)])\n            dfs(i, j + 1, total, visited + [(i, j)])\n            dfs(i, j - 1, total, visited + [(i, j)])\n\n\n        \n        c=-1\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]!=0:\n                    ma=0\n                    dfs(i,j,0,[])\n                    c=max(c,ma)\n    \n        return c", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        for line in grid:\n            print(line)\n        \n        def rec(visited, currgold, i ,j, path):\n        \n            if i>=len(grid) or i<0 or j>=len(grid[0]) or j<0:\n                return currgold\n\n            gold = grid[i][j]\n            if tuple([i,j]) in visited or gold == 0:\n                return currgold\n            else:\n                visited = visited.copy()\n                visited.add(tuple([i,j]))\n                path = path.copy()\n                path.append([i,j])\n                currgold += gold\n\n                return max(\n                            rec(visited, currgold, i+1,j,path),\n                            rec(visited, currgold, i-1,j,path),\n                            rec(visited, currgold, i,j+1,path),\n                            rec(visited, currgold, i,j-1,path)\n                        )\n                        \n                \n        maxgold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                visited = set()\n                path = list()\n                g = rec(visited, 0, i, j, path)\n                \n                if maxgold < g:\n                    maxgold = g\n        \n        return maxgold\n    \n    \n    \n    \n    \\\"\\\"\\\"\n    [1, 0, 7, 0, 0, 0]\n    [2, 0, 6, 0, 1, 0]\n    [3, 5, 6, 7, 4, 2]\n    [4, 3, 1, 0, 2, 0]\n    [3, 0, 5, 0, 20,0]\n\n    \n    \\\"\\\"\\\"", "hops = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        g = 0\n        path = set()\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                temp = self.goldHelper(grid, r, c, path)\n                # print(temp, r, c)\n                g = max(g, temp)\n        return g\n    \n    def goldHelper(self, grid: List[List[int]], r, c, path):\n        if (r, c) in path:\n            return 0\n        \n        if r < 0 or r >= len(grid):\n            return 0\n        \n        if c < 0 or c >= len(grid[0]):\n            return 0\n        \n        if grid[r][c] == 0:\n            return 0\n        \n        path.add((r, c))\n        curr = 0\n        \n        for v, a in hops:\n            curr = max(curr, self.goldHelper(grid, r + v, c + a, path))\n        \n        path.remove((r,c))\n        \n        return curr + grid[r][c]\n", "class Solution:\n    def __init__(self):\n        self.max_len = 0\n    def isValid(self,r, c, grid):\n        if r < 0 or c < 0 or r >= self.M or c >= self.N or grid[r][c] == 0:\n            return False\n        return True\n        \n    def dfs(self, r, c, visited, path_sum, grid):\n        if (r, c) in visited or not self.isValid(r, c, grid):\n             return \n        visited.add((r,c))\n        path_sum = path_sum + grid[r][c]\n        self.max_len = max(self.max_len, path_sum)\n        self.dfs(r + 1, c, set(visited), path_sum, grid)\n        self.dfs(r - 1, c, set(visited), path_sum, grid)\n        self.dfs(r, c + 1, set(visited), path_sum, grid)\n        self.dfs(r, c - 1, set(visited), path_sum, grid)\n          \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.M, self.N  = len(grid), len(grid[0])\n        \n        for m in range(self.M):\n            for n in range(self.N):\n                self.dfs(m, n, set(), 0, grid)\n        return self.max_len\n                \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.grid, self.lr, self.lc = grid, len(grid), len(grid[0]) if grid else 0\n        return max(self.helper(i, j) for i in range(self.lr) for j in range(self.lc) if grid[i][j]) if grid else 0\n        \n    def helper(self, x, y):\n        nei = [(i, j) for i, j in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)) if i in range(self.lr) and j in range(self.lc) and self.grid[i][j]]\n        res, val, self.grid[x][y] = self.grid[x][y], self.grid[x][y], 0\n        for n in nei:\n            res = max(res, self.helper(*n) + val)\n        self.grid[x][y] = val\n        return res\n", "class Solution:\n    def get_sum(self,grid,x,y,sum_,all_grids):\n        if [x,y] not in all_grids and not grid[x][y]==0:\n            sum_ = sum_ + grid[x][y]\n            all_grids.append([x,y])\n            \n            sum_top,sum_bottom,sum_left,sum_right = sum_,sum_,sum_,sum_\n            if x>0:\n                sum_top = self.get_sum(grid,x-1,y,sum_,all_grids.copy())\n            if x<len(grid)-1:\n                sum_bottom = self.get_sum(grid,x+1,y,sum_,all_grids.copy())\n            if y>0:\n                sum_left = self.get_sum(grid,x,y-1,sum_,all_grids.copy())\n            if y<len(grid[0])-1:\n                sum_right = self.get_sum(grid,x,y+1,sum_,all_grids.copy())\n\n            return max(sum_top,sum_bottom,sum_left,sum_right)\n        \n        else:\n            return sum_\n        \n        \n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        sums=[]\n        for m in range(len(grid)):\n            for n in range(len(grid[m])):\n                sums.append(self.get_sum(grid,m,n,0,[]))\n                \n        return max(sums)\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        csum = msum = 0\n        \n        def backtrack(r,c):\n            direct = [(r-1,c), (r+1,c), (r,c+1), (r,c-1)]\n            nonlocal msum, csum\n            isbool = True\n            for p,q in direct:\n                if 0 <= p < m and 0 <= q < n and 0 < grid[p][q]:\n                    isbool = False\n                    value = grid[p][q]\n                    csum += grid[p][q]\n                    grid[p][q] = 0\n                    backtrack(p,q)\n                    grid[p][q] = value\n                    csum -= value\n            if isbool:\n                msum = max(msum, csum)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    csum = value = grid[i][j] \n                    grid[i][j] = 0\n                    \n                    backtrack(i,j)\n                    \n                    grid[i][j] = value\n        return msum", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def q(g,i,j,t,s,vis):\n            if i>=len(g) or j>=len(g[0]) or i<0 or j<0 or g[i][j]==0 or vis[i][j]==1:\n                s[0]=max(s[0],t[0])\n                \n                \n                return \n            \n            temp=g[i][j]\n            g[i][j]=0\n            t[0]+=temp\n            q(g,i,j+1,t,s,vis)\n            q(g,i+1,j,t,s,vis)\n            q(g,i-1,j,t,s,vis)\n            q(g,i,j-1,t,s,vis)\n            t[0]-=temp\n            g[i][j]=temp\n                \n                \n        s=[0]\n        t=[0]\n        vis=[[0 for i in range(len(grid[0]))] for j in range(len(grid))]\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                t=[0]\n                q(grid,i,j,t,s,vis)\n                \n        return s[0]\n                \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        seen,n,m = {}, len(grid), len(grid[0])\n        maxy,x,y = 0, [1,-1,0,0], [0,0,-1,1]\n        dp = [[0]*m for _ in range(n)]\n        \n        def path(i,j,d):\n            mm = d\n            for k in range(len(x)):\n                r,c = i+x[k],j+y[k]\n                if 0<=r<n and 0<=c<m and grid[r][c]!=0:\n                    if (r,c) not in seen or not seen[(r,c)]:\n                        seen[(r,c)] = True\n                        mm = max(mm,path(r,c,d+grid[r][c]))\n                        seen[(r,c)] = False\n            return mm\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]==0: continue\n                seen[(i,j)] = True\n                maxy = max(maxy,path(i,j,grid[i][j]))\n                seen[(i,j)] = False\n        return maxy", "class Solution:\n    maxValue=float(\\\"-inf\\\")\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        directions=[[0,1],[1,0],[-1,0],[0,-1]]\n        visited=set()\n        def dfs(x,y,sum):\n            if 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!=0 and (x,y) not in visited :\n                visited.add((x,y))\n                sum=sum+grid[x][y]\n                self.maxValue=max(self.maxValue,sum)\n                for p,q in directions:\n                    dfs(x+p,y+q,sum)\n                    \n                visited.remove((x,y))    \n        \n        \n        for i in range(0,len(grid)):\n            for j in range(0,len(grid[0])):\n                if grid[i][j]!=0:\n                    dfs(i,j,0)\n        return self.maxValue", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        ans = [0]\n        def path(i,j,seen,val):\n            #print(seen)\n            ans[0] = max(ans[0],val)\n            adjacent = [(i+1,j),(i-1,j),(i,j-1),(i,j+1)]\n            for k,l in adjacent:\n                if k<0 or k>=m or l<0 or l>=n:\n                    continue\n                if grid[k][l] != 0 and (k,l) not in seen:\n                    path(k,l,seen+[(k,l)],val+grid[k][l])\n            \n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    path(i,j,[(i,j)],grid[i][j])\n        #print(ans)\n        return max(ans)", "class Solution:\n    def __init__(self):\n        self.EMPTY = 0\n        self.DIR = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        \n        max_gold = 0\n        m, n = len(grid), len(grid[0])\n        visited = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > 0 and not (i, j) in visited:\n                    max_gold = max(max_gold, self.dfs(grid, i, j, visited))\n                \n        return max_gold\n    \n    def dfs(self, grid, i, j, visited):\n        if not self.inbound(grid, i, j) or (i, j) in visited or grid[i][j] == self.EMPTY:\n            return 0\n        \n        visited.add((i, j))\n        gold = 0\n        \n        for delta_i, delta_j in self.DIR:\n            gold = max(gold, self.dfs(grid, i + delta_i, j + delta_j, visited))\n        \n        gold += grid[i][j]\n        visited.discard((i, j))\n        return gold\n    \n    def inbound(self, grid, x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0])", "class Solution:\n    def getMaxGoldHelper(self, visited, grid, curx, cury):\n        if (curx, cury) in visited:\n            return 0\n        visited.add((curx, cury))\n        ret = grid[cury][curx]\n        max_recur = 0\n        for (nextx, nexty) in [(curx - 1, cury), (curx +1, cury), (curx, cury - 1), (curx, cury + 1)]:\n            if nextx < 0 or nextx >= len(grid[0]) or nexty < 0 or nexty >= len(grid):\n                continue\n            if grid[nexty][nextx] > 0:\n                max_recur = max(max_recur, self.getMaxGoldHelper(visited, grid, nextx, nexty))\n        visited.remove((curx, cury))\n        return ret + max_recur\n    \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        max_seen = 0\n        for row in range(len(grid)):\n            for col in range(len(grid[row])):\n                max_seen = max(max_seen, self.getMaxGoldHelper(set(), grid, col, row))\n        return max_seen\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.nums=grid.copy()\n        self.results=[]\n        self.visited=[[False for i in range(len(grid[0]))]for i in range(len(grid))]\n        \n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                \n                if grid[i][j]!=0:\n                    maxVal=self.getTheGold(i,j,0)\n                    \n        return max(self.results)\n                \n                \n    def getTheGold(self,i,j,value):\n        #print(i,j)\n        if self.isSafe(i,j):\n            self.visited[i][j]=True\n            self.getTheGold(i+1,j,value+self.nums[i][j])\n            self.getTheGold(i,j+1,value+self.nums[i][j])            \n            self.getTheGold(i-1,j,value+self.nums[i][j])            \n            self.getTheGold(i,j-1,value+self.nums[i][j])            \n            self.visited[i][j]=False\n            \n            \n        else:\n            \n            return self.results.append(value)\n        \n    def isSafe(self,i,j):\n        if i>=0 and i<len(self.nums) and j>=0 and j<len(self.nums[0]):\n            \n            return self.nums[i][j]!=0 and self.visited[i][j]==False\n    \n        return False", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        self.grid = grid\n        #self.visited = []\n        self.total = 0\n        \n        for i in range(len(grid)):\n            for z in range(len(grid[0])):\n                self.pathfinder(i, z, 0, [])\n                self.visited = []\n    \n        return self.total\n    \n    def pathfinder(self, i, z, curVal, visited):\n        visited.append((i, z))\n        visitedCopy = visited.copy()\n        curVal += self.grid[i][z]\n        if curVal > self.total:\n            self.total = curVal\n        if i - 1 >= 0 and self.grid[i-1][z] != 0 and (i-1, z) not in visited:\n            self.pathfinder(i-1, z, curVal, visited)\n            visited = visitedCopy.copy()\n        if i + 1 <= len(self.grid)-1 and self.grid[i+1][z] != 0 and (i+1, z) not in visited:\n            self.pathfinder(i+1, z, curVal, visited)\n            visited = visitedCopy.copy()\n        if z - 1 >= 0 and self.grid[i][z-1] != 0 and (i, z-1) not in visited:\n            self.pathfinder(i, z-1, curVal, visited)\n            visited = visitedCopy.copy()\n        if z + 1 <= len(self.grid[0])-1 and self.grid[i][z+1] != 0 and (i, z+1) not in visited:\n            self.pathfinder(i, z+1, curVal, visited)\n             ", "class Solution:\n    def __init__(self):\n        self.EMPTY = 0\n        self.DIR = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        max_gold = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == self.EMPTY:\n                    continue\n                    \n                max_gold = max(max_gold, self.dfs(grid, i, j, set()))\n                \n        return max_gold\n    \n    def dfs(self, grid, x, y, visited):\n        if not self.inbound(grid, x, y) or (x, y) in visited or grid[x][y] == self.EMPTY:\n            return 0\n        \n        visited.add((x, y))\n        gold = 0\n        \n        for delta_x, delta_y in self.DIR:\n            next_x, next_y = x + delta_x, y + delta_y\n            \n            gold = max(gold, self.dfs(grid, next_x, next_y, visited))\n        \n        gold += grid[x][y]\n        visited.discard((x, y))\n        return gold\n        \n    def inbound(self, grid, x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0])", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        return max([self.helper(grid, row, col) for row in range(len(grid)) for col in range(len(grid[row]))])\n\n    \n    def helper(self, grid, row, col):\n        if not self.are_valid_coordinates(grid, row, col):\n            return 0\n        \n        curr_gold = grid[row][col] \n        grid[row][col] = -1\n        \n        all_results = [curr_gold] + [curr_gold + self.helper(grid, nrow, ncol) for nrow, ncol in self.get_neighbors(row, col)]\n\n        grid[row][col] = curr_gold\n        return max(all_results)\n        \n        \n    def are_valid_coordinates(self, grid, row, col):\n        return row >= 0 and col >= 0 and row < len(grid) and col < len(grid[row]) and grid[row][col] > 0\n    \n    def get_neighbors(self, row, col):\n        return [\n            (row-1, col),\n            (row+1, col),\n            (row, col-1),\n            (row, col+1),\n        ]", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        nr, nc = len(grid), len(grid[0])\n        delta = [(1,0),(-1,0),(0,1),(0,-1)]\n        def dfs(i, j):\n            gold, grid[i][j] = grid[i][j], 0\n            max_gold = 0\n            for dx, dy in delta:\n                x, y = i+dx, j+dy\n                if 0<=x<nr and 0<=y<nc and grid[x][y]>0:\n                    max_gold = max(max_gold, dfs(x,y))\n            grid[i][j] = gold\n            return max_gold+gold\n        return max(dfs(i,j) for i in range(nr) for j in range(nc) if grid[i][j] > 0)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        # print(len(grid), len(grid[0]))\n        \n        def helper(r, c, total, visited):\n            if r >= len(grid) or c >= len(grid[0]) or r < 0 or c < 0 or grid[r][c] == 0 or (r,c)  in visited:\n                return \n            \n            total += grid[r][c]\n            self.maxGold = max(self.maxGold, total)\n            \n            helper(r+1, c, total, visited + [(r,c)])\n            helper(r-1, c, total, visited + [(r,c)])\n            helper(r, c+1, total, visited + [(r,c)])\n            helper(r, c-1, total, visited + [(r,c)])\n        \n        gg = 0\n        self.maxGold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    helper(i,j, 0, [])\n                    gg = max(gg, self.maxGold)\n                    self.maxGold = 0                    \n                \n        return gg\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        num_rows = len(grid)\n        num_cols = len(grid[0])\n        deltas = ((-1, 0), (1, 0), (0, -1), (0, 1))\n        \n        def explore(y: int, x: int, score=0, visited=None) -> int:        \n            if not visited:\n                visited = set()\n                \n            if y < 0 or y >= num_rows or x < 0 or x >= num_cols:\n                return score \n            if grid[y][x] == 0 or (y, x) in visited:\n                return score\n\n            score += grid[y][x]\n            visited = set([*visited, (y, x)])\n            \n            best = score\n            for dy, dx in deltas:\n                best = max(best, explore(y+dy, x+dx, score, visited))\n            return best\n        \n        best = 0\n        for y in range(num_rows):\n            for x in range(num_cols):\n                best = max(best, explore(y, x))\n        return best\n", "class Solution:\n    def getMaximumGold(self, g: List[List[int]]) -> int:\n            def dfs(i, j, visited):\n                if not (0 <= i < len(g) and 0 <= j < len(g[0]) and g[i][j] != 0 and (i,j) not in visited):\n                    return 0\n                visited.add((i, j))\n                res = g[i][j] + max(0, max(dfs(i+x, j+y, visited) for x,y in [[-1, 0], [1, 0], [0, 1], [0, -1]]))\n                visited.remove((i, j))\n                return res\n            return max(dfs(i, j, set()) for i in range(len(g)) for j in range(len(g[0])))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.res = 0\n        self.grid = grid\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    self.dfs(i, j, 0)\n        return self.res\n\n    def dfs(self, i, j, cur_gold):\n        self.res = max(self.res, cur_gold)\n        if (0 <= i < len(self.grid) and 0 <= j < len(self.grid[0])) and self.grid[i][j] != 0:\n            gold = self.grid[i][j]\n            for m, n in [(-1, 0), (0, -1), (0, 1), (1, 0)]:\n                self.grid[i][j] = 0\n                self.dfs(i + m, j + n, cur_gold + gold)\n                self.grid[i][j] = gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        res = 0\n        summ = 0\n        visited = set()\n        # \u904d\u5386\u6240\u6709\u6709\u9ec4\u91d1\u7684\u70b9\u4f5c\u4e3a\u8d77\u59cb\u70b9\uff0c\u5bfb\u627e\u6700\u5927\u503c\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if self.in_area(grid, i, j):\n                    value = self.dfs(grid, i, j, summ, visited)\n                    res = max(res, value)\n        return res\n\n    def dfs(self, grid, r, c, summ, visited):\n        if not self.in_area(grid, r, c):\n            return summ\n        if not grid[r][c] or (r, c) in visited:\n            return summ\n\n        visited.add((r, c))\n        summ += grid[r][c]\n\n        res = 0\n        moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        for dr, dc in moves:\n            r2 = r + dr\n            c2 = c + dc\n            value = self.dfs(grid, r2, c2, summ, visited)\n            res = max(res, value)\n        visited.discard((r, c))\n        return res\n\n\n    def in_area(self, grid, r, c):\n        return 0 <= r < len(grid) and 0 <= c < len(grid[0])", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m,n = len(grid), len(grid[0])\n        visited = set()\n        \n        def DFS(i,j,sum):\n            if i<0 or i==m or j<0 or j==n or grid[i][j]==0 or (i,j) in visited:\n                return sum\n            visited.add((i,j))\n            maxi = 0\n            for x,y in [(i,j+1),(i,j-1),(i+1,j),(i-1,j)]:\n                maxi = max(maxi, DFS(x,y,sum+grid[i][j]))\n            visited.remove((i,j))\n            return maxi\n        \n        return max(DFS(i,j,0) for i in range(m) for j in range(n) if grid[i][j]!=0)", "class Solution:\n    def __init__(self):\n        self.m = 0\n        self.n = 0\n        self.grid = None\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        if not len(grid):\n            return 0\n        \n        self.grid = grid\n        self.m = len(grid)\n        self.n = len(grid[0])\n        \n        ans = 0\n        for i in range(self.m):\n            for j in range(self.n):\n                ans = max(ans,self.dfs(i,j))\n                \n        return ans\n                \n        \n        \n    def dfs(self,x,y):\n        \n        res = 0\n        amt = self.grid[x][y]\n        self.grid[x][y] = 0\n        \n        directions = [[-1,0],[1,0],[0,-1],[0,1]]\n        for dx,dy in directions:\n            i = x + dx\n            j = y + dy\n            if i >= 0 and i < self.m and j >= 0 and j < self.n and self.grid[i][j] != 0:\n                res = max(res,self.grid[i][j] + self.dfs(i,j))\n        \n        self.grid[x][y] = amt        \n        \n        return res\n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        R, C = len(grid), len(grid[0])\n        self.visited = [[False] * C for _ in range(R)]\n        def helper(grid, r, c, R, C):\n            if r < 0 or c < 0 or r >= R or c >= C or self.visited[r][c] or grid[r][c] == 0: return 0\n            self.visited[r][c] = True\n            max_ = max(helper(grid, r-1, c, R, C), helper(grid, r+1, c, R, C), helper(grid, r, c-1, R, C), helper(grid, r, c+1, R, C))\n            self.visited[r][c] = False\n            return max_ + grid[r][c]\n        \n        ans = 0\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] != 0:\n                    ans = max(ans, helper(grid, r, c, R, C))\n        \n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        res = 0\n        M = len(grid)\n        N = len(grid[0])\n        cords = [[0, 1], [0, -1], [-1, 0], [1, 0]]\n        \n        def recur(x, y):\n            if x < 0 or x >= M or y < 0 or y >= N or grid[x][y] == 0:\n                return 0\n            temp = grid[x][y]\n            grid[x][y] = 0\n            total = 0\n            for dx, dy in cords:\n                dx += x\n                dy += y\n                total = max(total, recur(dx, dy))\n            grid[x][y] = temp\n            return total + temp \n        \n        for i in range(M):\n            for j in range(N):\n                if grid[i][j] != 0:\n                    res = max(recur(i, j), res)\n        return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        path = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        path_indices = [0, 1, 2, 3]\n        \n        def value(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return 0\n            \n            return grid[i][j]\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or (i, j) in visited or grid[i][j] == 0:\n                return 0\n            \n            visited.add((i, j))\n            golds = [dfs(i+i_, j+j_) for i_, j_ in path]\n            idx = max(path_indices, key=lambda x: golds[x])\n            \n            gold = grid[i][j] + golds[idx]\n            visited.remove((i, j))\n            \n            return gold\n            \n        visited = set()\n        max_gold = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    gold = dfs(i, j)\n                    if gold > max_gold:\n                        max_gold = gold\n                        \n        return max_gold", "import sys\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n            \n        def isValid(start, grid):\n            valid = []\n            r,c = start\n            up, right, left, down = True, True, True, True\n            if r == 0:\n                up = False\n            if r == len(grid) - 1:\n                down = False\n            if c == 0:\n                left = False\n            if c == len(grid[0]) - 1:\n                right = False\n            \n            if down and grid[r+1][c] != 0:\n                valid.append((r+1,c))\n            if up and grid[r-1][c] != 0:\n                valid.append((r-1,c))\n            if right and grid[r][c+1] != 0:\n                valid.append((r,c+1))\n            if left and grid[r][c-1] != 0:\n                valid.append((r,c-1))\n            return valid\n            \n                 \n            \n        def findMaxPath(maxV, path, start, grid):\n            #print(maxV, path, start, grid)\n            validList = isValid(start, grid)\n            \n            if not validList:\n                if sum(path) > maxV:\n                    maxV = sum(path)\n            \n            for r,c in validList:\n                valI = grid[r][c]\n                grid[r][c] = 0\n                path.append(valI)\n                maxV = findMaxPath(maxV,path,(r,c),grid)\n                path.pop()\n                grid[r][c] = valI\n            \n            return maxV\n        \n        maxV = -sys.maxsize - 1\n        \n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] != 0:\n                    val = grid[r][c]\n                    grid[r][c] = 0\n                    maxV = findMaxPath(maxV,[val],(r,c),grid)\n                    grid[r][c] = val\n                    #print((r,c), maxV)\n        return maxV\n                \n        \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        path = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        path_indices = [0, 1, 2, 3]\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or (i, j) in visited or grid[i][j] == 0:\n                return 0\n            \n            visited.add((i, j))\n            golds = [dfs(i+i_, j+j_) for i_, j_ in path]\n            idx = max(path_indices, key=lambda x: golds[x])\n            \n            gold = grid[i][j] + golds[idx]\n            visited.remove((i, j))\n            \n            return gold\n            \n        visited = set()\n        max_gold = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    gold = dfs(i, j)\n                    if gold > max_gold:\n                        max_gold = gold\n                        \n        return max_gold", "class Solution:\n    def getMaximumGold(self, g: List[List[int]]) -> int:\n            def dfs(i, j, visited):\n                if not (0 <= i < len(g) and 0 <= j < len(g[0]) and g[i][j] != 0 and (i,j) not in visited):\n                    return -math.inf\n                visited.add((i, j))\n                res = g[i][j] + max(0, max(dfs(i+x, j+y, visited) for x,y in [[-1, 0], [1, 0], [0, 1], [0, -1]]))\n                visited.remove((i, j))\n                return res\n            return max(dfs(i, j, set()) for i in range(len(g)) for j in range(len(g[0])))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        iMax = len(grid)\n        jMax = len(grid[0])\n        \n        di = [0,1,0,-1]\n        dj = [1,0,-1,0]\n        numOfGold = 0\n        \n        goldNumDict = {}\n        for i in range(iMax):\n            for j in range(jMax):\n                if grid[i][j] != 0:\n                    goldNumDict[(i, j)] = numOfGold\n                    numOfGold += 1\n        \n        dp =defaultdict(int)\n        \n        def findGold(mNow, i0, j0, goldNow):\n            # if mNow in dp:\n            #     return dp[mNow]\n            subAns = goldNow\n            for k in range(4):\n                i1 = i0 + di[k]\n                j1 = j0 + dj[k]\n                if i1 < 0 or j1 < 0 or i1 == iMax or j1 == jMax or grid[i1][j1] == 0 or (mNow & (1<<goldNumDict[(i1, j1)])):\n                    continue\n                subAns = max(subAns, findGold((mNow | (1<<goldNumDict[i1, j1])), i1, j1, goldNow + grid[i1][j1]))\n            dp[mNow] = max(subAns, dp[mNow])\n            return subAns\n        \n        ans = 0\n        for i in range(iMax):\n            for j in range(jMax):\n                if grid[i][j] != 0:\n                    ans = max(ans, findGold((1<<goldNumDict[(i, j)]), i, j, grid[i][j]))\n        \n        return ans", "\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        R,C = len(grid), len(grid[0])\n        O=[]\n        def check(r,c,Z):\n            if -1<r<R and -1<c<C and (r,c) not in Z:\n                return True\n            return False\n        def bt(r,c,res,Z):\n            if grid[r][c]==0:\n                O.append(res)\n                return\n            else:\n                a = grid[r][c]\n                if check(r+1,c,Z+[(r,c)])==True:\n                    bt(r+1,c,res+a,Z+[(r,c)])\n                if check(r-1,c,Z+[(r,c)])==True:\n                    bt(r-1,c,res+a,Z+[(r,c)])\n                if check(r,c+1,Z+[(r,c)])==True:\n                    bt(r,c+1,res+a,Z+[(r,c)])\n                if check(r,c-1,Z+[(r,c)])==True:\n                    bt(r,c-1,res+a,Z+[(r,c)])\n                return \n\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j]!=0:\n                    bt(i,j,0,[])\n        return (max(O))\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.max_gold = 0\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                visited = set()\n                self.dfs(grid, 0, row, col, visited)\n                \n        return self.max_gold\n    \n    def dfs(self,grid, curr_gold, i, j, visited):\n    #base case\n        if (i,j) in visited or not (i >= 0 and i < len(grid) and j >= 0 and j < len(grid[0])) or grid[i][j] == 0: \n            if self.max_gold < curr_gold:\n                self.max_gold = curr_gold\n            return \n        visited.add((i,j))\n        self.dfs(grid, curr_gold + grid[i][j] ,i+1, j, visited)\n        visited.discard((i,j))\n        visited.add((i,j))\n        self.dfs(grid, curr_gold + grid[i][j], i-1, j, visited)\n        visited.discard((i,j))\n        visited.add((i,j))\n        self.dfs(grid, curr_gold + grid[i][j] , i, j-1, visited)\n        visited.discard((i,j))\n        visited.add((i,j))\n        self.dfs(grid, curr_gold + grid[i][j] , i, j+1, visited)\n        visited.discard((i,j))\n        return\n    \n        \n            \n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0 \n        row = len(grid)\n        col = len(grid[0])\n        rval = []\n        for x in range(row):\n            for y in range(col):\n                if grid[x][y] == 0:\n                    continue\n                self.traverse(rval, grid, grid[x][y], {(x,y): True}, x, y)\n                \n        return max(rval or [0])\n        \n    def traverse(self, rval, grid, path, visited, x, y):\n        if self.finished(grid, visited, x, y):\n            rval.append(path)\n            return\n        \n        for new_x, new_y in [(x, y+1), (x, y-1), (x+1, y), (x-1, y)]:\n            if not self.available(grid, visited, new_x, new_y):\n                continue\n            #path.append(grid[new_x][new_y])\n            visited[(x, y)] = True\n            self.traverse(rval, grid, path + grid[new_x][new_y], visited, new_x, new_y)\n            #path.pop(-1)\n            visited[(x, y)] = False\n                \n    def available(self, grid, visited, x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 0 and not visited.get((x, y), False)\n    \n    def finished(self, grid, visited, x, y):\n        for new_x, new_y in [(x, y+1), (x, y-1), (x+1, y), (x-1, y)]: \n            if self.available(grid, visited, new_x, new_y):\n                return False\n        return True", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        ones = set([])\n        start = []\n        answer = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != 0:\n                    ones.add((i, j))\n                    start.append([(i, j), grid[i][j], set([(i, j)])])\n                    answer = max(answer, grid[i][j])\n        nearby = {}\n        for a, b in ones:\n            nearby[(a, b)] = []\n            for c, d in [(a+1, b), (a-1, b), (a, b-1), (a, b+1)]:\n                if (c, d) in ones:\n                    if (a==c and abs(b-d)==1) or (abs(a-c)==1 and b==d):\n                        nearby[(a, b)].append((c, d))\n        while True:\n            next = []\n            for a, b, c in start:\n                for a2 in nearby[a]:\n                    if a2 not in c:\n                        b2 = b+grid[a2[0]][a2[1]]\n                        c2 = c.union(set([a2]))\n                        answer = max(answer, b2)\n                        next.append([a2, b2, c2])\n            start = next\n            if len(start)==0:\n                break\n        return answer\n                        \n                        \n        \n                                  \n                    \n", "def isValid(i, j, visited, grid):\n    m, n = len(grid), len(grid[0])\n    return i >= 0 and j >= 0 and i < m and j < n and grid[i][j] and (i,j) not in visited\n\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        directions = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n        self.ans = 0\n        \n        def dfs(i, j, curr_sum, visited):\n            if not isValid(i, j, visited, grid):\n                return curr_sum\n            curr_sum += grid[i][j]\n            visited.add((i,j))\n            curr_ans = 0\n            for x,y in directions:\n                newX, newY = i+x, j+y\n                curr_ans = max(dfs(newX, newY, curr_sum, visited), curr_ans)\n            self.ans = max(curr_ans, self.ans)\n            visited.remove((i,j))\n            return curr_ans\n        \n        for r in range(m):\n            for c in range(n):\n                dfs(r, c, 0, set())\n        return self.ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m=len(grid)\n        n=len(grid[0])\n        def fun(g,i,j):\n            if i<0 or i>=m or j<0 or j>=n or g[i][j]==0:\n                return 0\n            t=g[i][j]\n            g[i][j]=0\n            curr=t+max(fun(g,i-1,j),fun(g,i,j-1),fun(g,i+1,j),fun(g,i,j+1))\n            g[i][j]=t\n            return curr\n        ml=0\n        for i in range(m):\n            for j in range(n):\n                    ml=max(ml,fun(grid,i,j))\n        return ml\n", "\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        R,C = len(grid), len(grid[0])\n        self.O=0\n        def check(r,c,Z):\n            if -1<r<R and -1<c<C and (r,c) not in Z:\n                return True\n            return False\n        def bt(r,c,res,Z):\n            if grid[r][c]==0:\n                self.O = max(self.O,res)\n                return\n            else:\n                a = grid[r][c]\n                if check(r+1,c,Z+[(r,c)])==True:\n                    bt(r+1,c,res+a,Z+[(r,c)])\n                if check(r-1,c,Z+[(r,c)])==True:\n                    bt(r-1,c,res+a,Z+[(r,c)])\n                if check(r,c+1,Z+[(r,c)])==True:\n                    bt(r,c+1,res+a,Z+[(r,c)])\n                if check(r,c-1,Z+[(r,c)])==True:\n                    bt(r,c-1,res+a,Z+[(r,c)])\n                return \n\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j]!=0:\n                    bt(i,j,0,[])\n        return self.O\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m,n = len(grid), len(grid[0])\n        def collect(i,j):\n            if not (0 <= i < m and 0 <= j < n and grid[i][j]): return 0\n            gold = grid[i][j]\n            grid[i][j] = 0\n            possible = [collect(i+di,j+dj) for di, dj in [(1,0), (-1,0), (0,1), (0,-1)]]\n            grid[i][j] = gold\n            return max(possible) + gold\n        \n        return max(collect(i,j) for i in range(m) for j in range(n))\n        \n                \n                \n                    \n", "\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        R,C = len(grid), len(grid[0])\n        self.O=0\n        def check(r,c,Z):\n            if -1<r<R and -1<c<C and (r,c) not in Z :\n                return True\n            return False\n        def bt(r,c,res,Z):\n            if grid[r][c]==0:\n                self.O = max(self.O,res)\n                return\n            else:\n                a = grid[r][c]\n                if check(r+1,c,Z+[(r,c)])==True:\n                    bt(r+1,c,res+a,Z+[(r,c)])\n                if check(r-1,c,Z+[(r,c)])==True:\n                    bt(r-1,c,res+a,Z+[(r,c)])\n                if check(r,c+1,Z+[(r,c)])==True:\n                    bt(r,c+1,res+a,Z+[(r,c)])\n                if check(r,c-1,Z+[(r,c)])==True:\n                    bt(r,c-1,res+a,Z+[(r,c)])\n                return \n\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j]!=0:\n                    bt(i,j,0,[])\n        return self.O\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        def find_gold(grid, i, j, r, c, traversed):\n            if i < 0 or i >= r or j < 0 or j >= c or grid[i][j] == 0 or f\\\"{i}-{j}\\\" in traversed:\n                return 0\n            \n            return grid[i][j] + max(\n                    find_gold(grid, i + 1, j, r, c, traversed + [f\\\"{i}-{j}\\\"]), \n                    find_gold(grid, i - 1, j, r, c, traversed + [f\\\"{i}-{j}\\\"]), \n                    find_gold(grid, i, j + 1, r, c, traversed + [f\\\"{i}-{j}\\\"]), \n                    find_gold(grid, i, j - 1, r, c, traversed + [f\\\"{i}-{j}\\\"]))\n        \n        r = len(grid)\n        c = len(grid[0])\n        \n        maxi = 0\n        for i in range(r):\n            for j in range(c):\n                if grid[i][j] != 0:\n                    traversed = []\n                    maxi = max(maxi, find_gold(grid, i, j, r, c, traversed))\n        return maxi\n        ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0 \n        row = len(grid)\n        col = len(grid[0])\n        rval = []\n        for x in range(row):\n            for y in range(col):\n                if grid[x][y] == 0:\n                    continue\n                self.traverse(rval, grid, [grid[x][y]], {(x,y): True}, x, y)\n                \n        return max(rval or [0])\n        \n    def traverse(self, rval, grid, path, visited, x, y):\n        if self.finished(grid, visited, x, y):\n            rval.append(sum(path))\n            return\n        \n        for new_x, new_y in [(x, y+1), (x, y-1), (x+1, y), (x-1, y)]:\n            if not self.available(grid, visited, new_x, new_y):\n                continue\n            path.append(grid[new_x][new_y])\n            visited[(x, y)] = True\n            self.traverse(rval, grid, path, visited, new_x, new_y)\n            path.pop(-1)\n            visited[(x, y)] = False\n                \n    def available(self, grid, visited, x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != 0 and not visited.get((x, y), False)\n    \n    def finished(self, grid, visited, x, y):\n        for new_x, new_y in [(x, y+1), (x, y-1), (x+1, y), (x-1, y)]: \n            if self.available(grid, visited, new_x, new_y):\n                return False\n        return True", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        visited = set()\n        max_gold = 0\n        def dfs(r, c, max_gold):\n            if (r, c) in visited or grid[r][c] == 0:\n                return max_gold\n            visited.add((r, c))\n            for i, j in ((1, 0), (0, 1), (-1, 0), (0, -1)):\n                if 0 <= r+i < len(grid) and 0 <= c+j < len(grid[0]):\n                    max_gold = max(max_gold, grid[r][c] + dfs(r+i, c+j, 0))\n            visited.remove((r, c))\n            return max_gold\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] > 0:\n                    max_gold = max(max_gold, dfs(r, c, 0))\n        return max_gold\n", "import copy\nclass Solution:\n    def helper(self, grid, start_i, start_j, current_gold, visited):\n      candidates = []\n      current_gold += grid[start_i][start_j]\n      visited[(start_i, start_j)] = 1\n      if max(0, start_i-1) != start_i and grid[start_i-1][start_j] > 0 and (start_i-1, start_j) not in visited: \n        candidates.append((start_i-1, start_j))\n      if min(len(grid)-1, start_i+1) != start_i and grid[start_i+1][start_j] > 0 and (start_i+1, start_j) not in visited: \n        candidates.append((start_i+1, start_j))\n      if max(0, start_j-1) != start_j and grid[start_i][start_j-1] > 0 and (start_i, start_j-1) not in visited: \n        candidates.append((start_i, start_j-1))\n      if min(len(grid[0])-1, start_j+1) != start_j and grid[start_i][start_j+1] > 0 and (start_i, start_j+1) not in visited: \n        candidates.append((start_i, start_j+1))\n      res = 0\n      if not candidates: return current_gold\n      for can in candidates:\n        res = max(res, self.helper(grid, can[0], can[1], current_gold, dict(visited)))\n      return res\n            \n      \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n      res = 0\n      for i in range(len(grid)):\n        for j in range(len(grid[0])):\n          start_i = i\n          start_j = j\n          res = max(res, self.helper(grid, i, j, 0, {}))\n      return res", "class Solution:\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        if not len(grid):\n            return 0\n        \n        grid = grid\n        m = len(grid)\n        n = len(grid[0])\n        \n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans,self.dfs(i,j,grid))\n                \n        return ans\n                \n        \n        \n    def dfs(self,x,y,grid):\n        \n        res = 0\n        amt = grid[x][y]\n        grid[x][y] = 0\n        \n        directions = [[-1,0],[1,0],[0,-1],[0,1]]\n        for dx,dy in directions:\n            i = x + dx\n            j = y + dy\n            if i >= 0 and i < len(grid) and j >= 0 and j < len(grid[0]) and grid[i][j] != 0:\n                res = max(res,grid[i][j] + self.dfs(i,j,grid))\n        \n        grid[x][y] = amt        \n        \n        return res\n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        \n        rows = len(grid)\n        cols = len(grid[0])\n        \n        self.ans = 0\n        \n        def dfs(grid, row, col, currg):\n            \n            self.ans = max(self.ans, currg)\n            \n            if row >=0 and row<rows and col>=0 and col<cols and grid[row][col] != 0:\n                ga = grid[row][col]\n                \n                grid[row][col] = 0\n                # neighbors = [[row+1, col], [row-1, col], [row, col+1], [row, col-1]]\n                # for x, y in neighbors:\n                #     dfs(grid, x, y, currg+ga)\n                \n                for p in [(1, 0), (-1, 0), (0,1), (0, -1)]:\n                    dfs(grid, row + p[0], col + p[1], currg+ga)\n                    \n                grid[row][col] = ga\n                \n                        \n        for x in range(rows):\n            for y in range(cols):\n                if grid[x][y] != 0:\n                    dfs(grid,x,y,0)\n        \n        return self.ans\n                   \n                        \n                    \n        \n        \n", "from collections import defaultdict\nclass Solution:\n    def dfs(self, i, j, m, n, grid):\n        tmp = grid[i][j]\n        grid[i][j] = 0\n        max_next_sum = 0\n        for d in {(-1, 0), (1, 0), (0, -1), (0, 1)}:\n            new_i, new_j = i + d[0], j + d[1]\n            if 0 <= new_i < m and 0 <= new_j < n and grid[new_i][new_j]:\n                max_next_sum = max(max_next_sum, self.dfs(new_i, new_j, m, n, grid))\n        grid[i][j] = tmp\n        return grid[i][j] + max_next_sum\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        # DFS, try dfs from every non-zero position\n        # Key: visited matrix WILL NOT work in this question, because CAN NOT guarantee previous path(i, j) NOT overlap with current path\n        \n        res = 0\n        if len(grid) < 1 or len(grid[0]) < 1: return res\n        \n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    res = max(res, self.dfs(i, j, m, n, grid))\n        return res", "class Solution:\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        if not len(grid):\n            return 0\n        \n        grid = grid\n        m = len(grid)\n        n = len(grid[0])\n        \n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans,self.dfs(i,j,grid))\n                \n        return ans\n                \n        \n        \n    def dfs(self,x,y,grid):\n        \n        amt = grid[x][y]\n        res = 0\n        grid[x][y] = 0\n        \n        directions = [[-1,0],[1,0],[0,-1],[0,1]]\n        for dx,dy in directions:\n            i = x + dx\n            j = y + dy\n            if i >= 0 and i < len(grid) and j >= 0 and j < len(grid[0]) and grid[i][j] != 0:\n                res = max(res,self.dfs(i,j,grid))\n        \n        grid[x][y] = amt        \n        res += amt\n        \n        return res\n        \n", "class Solution:\n    def getMaximumGold(self, a: List[List[int]]) -> int:\n        \n        def dfs(a, r, c, curSum, res):\n                                \n            res[0] = max(res[0], curSum)\n                        \n            temp = a[r][c]\n            a[r][c] = -1\n            \n            directions = [[0, 1],[0, -1],[1, 0],[-1, 0]]\n            \n            for d in directions:                \n                nr, nc = r + d[0], c + d[1]\n                if nr >= 0 and nr < len(a) and nc >= 0 and nc < len(a[0]):\n                    if a[nr][nc] > 0:\n                        dfs(a, nr, nc, curSum + a[nr][nc], res)\n                        \n            a[r][c] = temp\n            \n            return\n        \n        \n        res = [0]\n        for i in range(0, len(a)):\n            for j in range(0, len(a[0])):\n                if a[i][j] > 0:\n                    dfs(a, i, j, a[i][j], res)\n                    \n        return res[0]\n            \n            \n            \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        \n        def dfs(i, j, gold):\n            nonlocal ans             \n            if i < 0 or i >= rows or j < 0 or j >= cols or (i, j) in visited or grid[i][j] == 0:               \n                ans = max(ans, gold)\n                return\n            visited.add((i, j))\n            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                dfs(i + di, j + dj, gold + grid[i][j])\n            visited.remove((i, j))\n            \n        ans, rows, cols = 0, len(grid), len(grid[0])\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col]:\n                    visited = set()\n                    dfs(row, col, 0)   \n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n            m, n = len(grid), len(grid[0])\n            def getMaxGoldForCoords(i,j):\n                if i < 0 or i >= m or j < 0 or j >= n:\n                    return 0\n                if grid[i][j] == 0:\n                    return 0\n                temp = grid[i][j]\n                grid[i][j] = 0\n                result = max(getMaxGoldForCoords(i+1, j), getMaxGoldForCoords(i-1, j), \n                           getMaxGoldForCoords(i, j+1), getMaxGoldForCoords(i, j-1)) + temp\n                grid[i][j] = temp\n                return result\n            res = 0\n            for i in range(m):\n                for j in range(n):\n                    res = max(res, getMaxGoldForCoords(i,j))\n            return res\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        def dfs(x, y):\n            if x < 0 or x == m or y < 0 or y == n or grid[x][y] == 0:\n                return 0\n            val = grid[x][y]\n            grid[x][y] = 0\n            gain = val + max(dfs(x+1,y), dfs(x-1,y), dfs(x, y-1), dfs(x, y+1))\n            grid[x][y] = val\n            return gain\n        \n        gold = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    gold = max(gold, dfs(i,j))\n        \n        return gold\n            \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        self.res = 0\n        rows = len(grid)\n        cols = len(grid[0])\n        \n\n        def backtrace(i,j,tot):\n            self.res = max(self.res,tot+grid[i][j])\n            gridVal = grid[i][j]\n            grid[i][j] = 0\n            \n            for (a,b) in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\n                if a >=0 and b >=0 and a < rows and b < cols and grid[a][b]!=0:\n                    backtrace(a,b,tot+gridVal)\n            grid[i][j] = gridVal\n        \n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j]!=0:\n                    backtrace(i,j,0)\n        return self.res", "class Solution:\n    def getMaximumGold(self, A: List[List[int]]) -> int:\n        def dfs(i,j):\n            if not (0<=i<m and 0<=j<n):\n                return 0,set()\n            val=A[i][j]\n            if val==0:\n                return 0,set()\n            A[i][j]=0\n            maxgold=0\n            maxpath=set()\n            for ni,nj in (i-1,j),(i,j+1),(i+1,j),(i,j-1):\n                gold,path=dfs(ni,nj)\n                if gold>maxgold:\n                    maxgold=gold\n                    maxpath=path\n            A[i][j]=val\n            maxpath.add((i,j))\n            return val+maxgold,maxpath\n\n        maxgold=0\n        maxpath=set()\n        m,n=len(A),len(A[0])\n        for i in range(m):\n            for j in range(n):\n                if (i,j) in maxpath:\n                    continue\n                gold,path=dfs(i,j)\n                if gold>maxgold:\n                    maxgold=gold\n                    maxpath=path\n\n        return maxgold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m,n=len(grid),len(grid[0])\n        def dfs(x,y):  #\u7531(x,y)\u51fa\u53d1\u53ef\u53d6\u7684\u6570\u76ee\n            if x<0 or x>=m or y<0 or y>=n or grid[x][y]==0:\n                return 0\n            t=grid[x][y]\n            grid[x][y]=0\n            s=t+max(dfs(x+1,y),dfs(x-1,y),dfs(x,y+1),dfs(x,y-1))\n            grid[x][y]=t\n            return s\n        res=0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    res=max(res,dfs(i,j))\n        return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        if not rows: return 0\n        cols = len(grid[0])\n        def dfs(i, j):\n            if i < 0 or j < 0 or i >= rows or j >= cols or grid[i][j] == 0:\n                return 0\n            val = grid[i][j]\n            grid[i][j] = 0\n            _sum = val + max(dfs(i-1, j), dfs(i, j-1), dfs(i+1, j), dfs(i, j+1))\n            grid[i][j] = val\n            return _sum\n\n        ans = 0\n        for i in range(rows):\n            for j in range(cols):\n                ans = max(ans, dfs(i, j))\n        return ans\n    \n#         m = len(grid)\n#         n = len(grid[0])\n#         visited = {}\n        \n#         def backtrack(path, i, j, start):\n    \n#             if grid[i][j] == 0:\n#                 # print(path)\n#                 return sum(path)\n            \n#             for x, y in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n#                 if (i + x, j + y) not in visited:\n#                     if not (i + x < 0 or j + y < 0 or i + x >= m or j + y >= n):\n#                         visited[(i + x, j + y)] = backtrack(path + [grid[i + x][j + y]], i + x, j + y, (i + x, j +y))\n#                     else:\n#                         visited[(i + x, j + y)] = float('-inf')\n\n#             visited[(i,j)] = sum(path) + max(visited[(i + x, j + y)] for x, y in ((0, 1), (0, -1), (1, 0), (-1, 0)))\n            \n            \n#         for i in range(m):\n#             for j in range(n):\n#                 if grid[i][j] != 0:\n#                     backtrack([grid[i][j]], i, j, (i,j)) \n        \n#         return \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def backtrack(r, c):\n            grid[r][c] = -grid[r][c]\n            maxlen = 0\n            for i, j in [[r+1, c], [r-1, c], [r, c+1], [r, c-1]]:\n                if 0 <= i < M and 0 <= j < N and grid[i][j] > 0:\n                    maxlen = max(maxlen, backtrack(i, j))\n            grid[r][c] = -grid[r][c]\n            return maxlen + grid[r][c]\n        \n        res = 0\n        M, N = len(grid), len(grid[0])\n        for r in range(M):\n            for c in range(N):\n                if grid[r][c] > 0:\n                    res = max(res, backtrack(r, c))\n        return res\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        max_gold =0\n        m, n = len(grid), len(grid[0])\n        \n        def get_max(i, j):\n            if i<0 or i >= m or j<0 or j>= n or grid[i][j] ==0:\n                return 0\n            tmp = grid[i][j]\n            max_gold = 0 \n            grid[i][j] = 0\n            max_gold = max(max_gold, get_max(i+1, j), get_max(i-1, j),get_max(i, j+1) ,get_max(i, j-1))\n            grid[i][j] = tmp\n            return max_gold + tmp\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] !=0:\n                    max_gold  = max(max_gold, get_max(i,j,))\n        return max_gold\n                    \n            \n            \n            \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        # DFS\n        \n        self.res = 0\n        rows = len(grid)\n        cols = len(grid[0])\n        \n        \n        def backtrace(i,j,tot):\n            self.res = max(self.res,tot+grid[i][j]) # \u66f4\u65b0\u6700\u5927\u503c\n            gridVal = grid[i][j]\n            grid[i][j] = 0 # \u4ee5\u9632\u56de\u9000\n            \n            for (a,b) in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\n                if a >=0 and b >=0 and a < rows and b < cols and grid[a][b]!=0:\n                    backtrace(a,b,tot+gridVal)\n            # DFS\u9700\u8981reset\n            grid[i][j] = gridVal\n        \n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j]!=0:\n                    backtrace(i,j,0)\n        return self.res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\n                return 0\n            \n            gold = grid[i][j]\n            grid[i][j] = 0 # mark as visited\n            \n            total = gold + max(dfs(i-1, j),\n                               dfs(i+1, j),\n                               dfs(i, j-1),\n                               dfs(i, j+1))\n            grid[i][j] = gold\n            return total\n            \n        dp = dict()\n        max_gold = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    gold = dfs(i, j)\n                    max_gold = max(gold, max_gold)\n                        \n        return max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        m=len(grid)\n        n=len(grid[0])\n        \n        def get(i,j):\n            \n            \n            \n            if i>=0 and i<m and j>=0 and j<n and grid[i][j]!=0:\n                gold=grid[i][j]\n                grid[i][j]=0\n                \n                maxx=gold+max(get(i+1,j),get(i-1,j), get(i,j+1),get(i,j-1))\n                grid[i][j]=gold\n            else:\n                maxx=0\n            return maxx\n        maxgold=0\n        for i in range(m):\n            for j in range(n):\n                maxgold=max(maxgold,get(i,j))\n        return maxgold\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        M, N = len(grid), len(grid[0])\n        self.res = 0\n                \n        def dfs(grid, i, j, cur):\n            nbr = [(i, j + 1), (i, j - 1), (i - 1, j), (i + 1, j)]\n            temp = grid[i][j]\n            self.res = max(self.res, cur + temp)\n    \n            for r, c in nbr:\n                if 0 <= r < M and 0 <= c < N and grid[r][c]:\n                    grid[i][j] = 0\n                    dfs(grid, r, c, cur + temp)\n                    grid[i][j] = temp\n    \n                    \n        for i in range(M):\n            for j in range(N):\n                if grid[i][j]:\n                    dfs(grid, i, j, 0)\n \n        print(('res = ', self.res))\n        \n        return self.res\n                    \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        At each square, look at adjacent squares.\n        \n        If adjacent square is 0 then skip\n        If adjacent square has already been visited during this path then skip\n        If adjacent square is not in bounds of grid then skip\n        \n        Else add it to the list of squares visited on this path, then explore\n        that adjacent square.\n        \n        If there are no more adjacent squares to visit, then\n        record the path total and update the nonlocal total.\n        \n        Caveats:\n            - We can't cache because the max path from a square differs depending on the preceding path\n        \\\"\\\"\\\"\n        self.max_gold = 0\n        m = len(grid)\n        n = len(grid[0])\n        \n        def dfs(path, path_gold = 0, i = 0, j = 0):\n            g = grid[i][j]\n            if g == 0 or (i, j) in path:\n                if path_gold > self.max_gold:\n                    self.max_gold = path_gold\n                return\n            \n            curr_path_gold = path_gold + g\n            path.add((i, j))\n            if i > 0:\n                dfs(path, curr_path_gold, i - 1, j)\n            if i < m-1:\n                dfs(path, curr_path_gold, i + 1, j)\n\n            if j > 0:\n                dfs(path, curr_path_gold, i, j - 1)\n            if j < n-1:\n                dfs(path, curr_path_gold, i, j + 1)\n            path.remove((i, j))\n        \n        for i in range(m):\n            for j in range(n):\n                dfs(set(), i = i, j = j)\n        \n        return self.max_gold\n            \n        \n            \n                \n                    ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        M, N = len(grid), len(grid[0])\n        self.res = 0\n                \n        def dfs(grid, i, j, cur):\n            nbr = [(i, j + 1), (i, j - 1), (i - 1, j), (i + 1, j)]\n            temp = grid[i][j]\n            self.res = max(self.res, cur + temp)\n    \n            for r, c in nbr:\n                if 0 <= r < M and 0 <= c < N and grid[r][c]:\n                    grid[i][j] = 0\n                   \n                    dfs(grid, r, c, cur + temp)\n                    grid[i][j] = temp\n    \n                    \n        for i in range(M):\n            for j in range(N):\n                if grid[i][j]:\n                    dfs(grid, i, j, 0)\n        # dfs(grid, 0, 1, 0)\n        print(('res = ', self.res))\n        \n        return self.res\n                    \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        \n        def backtrack(r, c):\n            if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] == 0:\n                return 0\n            tmp = grid[r][c]\n            grid[r][c] = 0\n            val = tmp\n            val += max(backtrack(r+1,c), backtrack(r-1,c), backtrack(r,c+1), backtrack(r,c-1))\n            grid[r][c] = tmp\n            return val\n        \n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    tmp = backtrack(i, j)\n                    ans = max(ans, tmp)\n        return ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:     \n        M, N = len(grid), len(grid[0])\n        self.res = 0\n                \n        def dfs(grid, i, j, cur):\n            nbr = [(i, j + 1), (i, j - 1), (i - 1, j), (i + 1, j)]\n            temp = grid[i][j]\n            self.res = max(self.res, cur + temp)\n    \n            for r, c in nbr:\n                if 0 <= r < M and 0 <= c < N and grid[r][c]:\n                    grid[i][j] = 0\n                    dfs(grid, r, c, cur + temp)\n                    grid[i][j] = temp\n    \n                    \n        for i in range(M):\n            for j in range(N):\n                if grid[i][j]:\n                    dfs(grid, i, j, 0)\n \n        print(('res = ', self.res))\n        \n        return self.res\n                    \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        self.res = 0\n        rows = len(grid)\n        cols = len(grid[0])\n        \n        def backtrace(i, j, tot):\n            self.res = max(self.res, tot+grid[i][j])\n            gridVal = grid[i][j]\n            grid[i][j] = 0\n            \n            for a, b in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\n                if a >=0 and b >=0 and a < rows and b < cols and grid[a][b]!=0:\n                    backtrace(a, b, tot+gridVal)\n                    \n            grid[i][j] = gridVal\n        \n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j]:\n                    backtrace(i, j, 0)\n                    \n        return self.res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        self.gold = 0\n        \n        def DFS(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return 0\n            if grid[i][j] == 0:\n                return 0\n            \n            tmp = grid[i][j]\n            grid[i][j] = 0\n            self.gold = max(tmp + DFS(i+1, j), tmp + DFS(i-1, j), tmp + DFS(i, j+1), tmp + DFS(i, j-1))\n            grid[i][j] = tmp\n            return self.gold\n\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                self.gold = 0\n                res = max(res, DFS(i, j))\n        return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        self.gold = 0\n        \n        def DFS(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return 0\n            if grid[i][j] <= 0:\n                return 0\n            \n            tmp = grid[i][j]\n            grid[i][j] = -1\n            self.gold = max(tmp + DFS(i+1, j), tmp + DFS(i-1, j), tmp + DFS(i, j+1), tmp + DFS(i, j-1))\n            grid[i][j] = tmp\n            return self.gold\n\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                self.gold = 0\n                res = max(res, DFS(i, j))\n        return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        m = len(grid)-1\n        n = len(grid[0])-1\n        \n        def dfs (i,j,visited):\n                        \n            val = 0\n            visited[i][j] = True\n            \n            for co in  ((-1,0), (1,0), (0,-1), (0,1)):\n                x = i + co[0]\n                y = j + co[1]\n                \n                if 0 <= x <= m and 0 <= y <= n and grid[x][y] !=0 and visited [x][y] == False:\n                    val = max (val, dfs(x,y,visited))\n            \n            visited[i][j] = False\n            return val + grid[i][j]\n        \n        vis = [[False] * (n+1) for _ in range (m+1)]\n        \n        res = 0\n        for i in range (m+1):\n            for j in range (n+1):\n                \n                if grid[i][j] != 0:\n                    res = max (res, dfs(i,j,vis))\n                    \n        return res", "import copy\nclass Solution:\n    def helper(self, grid, start_i, start_j, current_gold, visited):\n      candidates = []\n      current_gold += grid[start_i][start_j]\n      visited[(start_i, start_j)] = 1\n      if max(0, start_i-1) != start_i and grid[start_i-1][start_j] > 0 and (start_i-1, start_j) not in visited: \n        candidates.append((start_i-1, start_j))\n      if min(len(grid)-1, start_i+1) != start_i and grid[start_i+1][start_j] > 0 and (start_i+1, start_j) not in visited: \n        candidates.append((start_i+1, start_j))\n      if max(0, start_j-1) != start_j and grid[start_i][start_j-1] > 0 and (start_i, start_j-1) not in visited: \n        candidates.append((start_i, start_j-1))\n      if min(len(grid[0])-1, start_j+1) != start_j and grid[start_i][start_j+1] > 0 and (start_i, start_j+1) not in visited: \n        candidates.append((start_i, start_j+1))\n      res = 0\n      if not candidates: return current_gold\n      for can in candidates:\n        res = max(res, self.helper(grid, can[0], can[1], current_gold, dict(visited)))\n      return res\n            \n      \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n      res = 0\n      for i in range(len(grid)):\n        for j in range(len(grid[0])):\n          start_i = i\n          start_j = j\n          counter = 0\n          if max(0, start_i-1) != start_i and grid[start_i-1][start_j] > 0: \n            counter += 1\n          if min(len(grid)-1, start_i+1) != start_i and grid[start_i+1][start_j] > 0: \n            counter += 1\n          if max(0, start_j-1) != start_j and grid[start_i][start_j-1] > 0: \n            counter += 1\n          if min(len(grid[0])-1, start_j+1) != start_j and grid[start_i][start_j+1] > 0: \n            counter += 1\n          if counter <= 2:\n            dicts = {}\n            res = max(res, self.helper(grid, i, j, 0, dicts))\n          #print (dicts)\n      return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        nR = len(grid)\n        nC = len(grid[0])\n        vis = [[0 for i in range(nC)] for j in range(nR)]\n        \n        steps = [[0, -1], [-1, 0], [1, 0], [0, 1]]\n        _max = 0\n        \n        for r in range(nR):\n            for c in range(nC):\n                cell = grid[r][c]\n                if cell == 0:\n                    vis[r][c] = -1\n                    \n        for r in range(nR):\n            for c in range(nC):\n                if vis[r][c] == -1:\n                    continue\n                _max = max(_max, self.dfs(grid, vis, r, c, nR, nC, steps))\n        \n        return _max\n                        \n    def dfs(self, grid, vis, r, c, nR, nC, steps):\n        vis[r][c] = -1\n        cell = grid[r][c]\n        _max = cell\n        \n        for step in steps:\n            _r = r + step[0]\n            _c = c + step[1]\n            \n            if 0 <= _r < nR and 0 <= _c < nC and grid[_r][_c] != 0 and vis[_r][_c] == 0: \n                _max = max(_max, cell + self.dfs(grid, vis, _r, _c, nR, nC, steps))\n        \n        vis[r][c] = 0\n        return _max\n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(r, c):\n            res = grid[r][c]\n            nxt = 0\n            for ro, co in [(1,0), (-1,0), (0,1), (0,-1)]:\n                nr, nc = r+ro, c+co\n                if 0<=nr<M and 0<=nc<N and grid[nr][nc] and (nr, nc) not in seen:\n                    seen.add((nr, nc))\n                    nxt = max(nxt, dfs(nr, nc))\n                    seen.remove((nr, nc))\n                    \n            return res+nxt\n        \n        M, N = len(grid), len(grid[0])\n        res = 0\n        for i in range(M):\n            for j in range(N):\n                if grid[i][j]:\n                    seen = {(i, j)}\n                    res = max(res, dfs(i, j))\n                    \n        return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        res = 0\n        \n        for i in range(len(grid)):\n            \n            for j in range(len(grid[0])):\n                res = max(res, self.find(grid, i, j))\n                \n        return res\n        \n    def find(self, grid, i, j):\n        \n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or not grid[i][j]:\n            return 0\n        \n        current = grid[i][j]\n        \n        grid[i][j] = 0\n        \n        up = self.find(grid, i-1, j)\n        down = self.find(grid, i+1, j)\n        left = self.find(grid, i, j-1)\n        right = self.find(grid, i, j+1)\n        \n        maxx = max(up, down, left, right)\n        grid[i][j] = current\n        return maxx + current", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m,n=len(grid),len(grid[0])\n        \n        def dfs(i,j,g,c):\n            if 0<=i<m and 0<=j<n and grid[i][j]!=0:\n                c+=grid[i][j]\n                tmp=grid[i][j]\n                grid[i][j]=0\n                res=max(dfs(i+1,j,g,c),dfs(i-1,j,g,c),dfs(i,j+1,g,c),dfs(i,j-1,g,c))\n                grid[i][j]=tmp\n                return res\n            \n            return c\n        x=[dfs(i,j,grid,0) for i in range(m) for j in range(n) if grid[i][j]!=0]\n                    \n        return max(x) if x else 0", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m,n=len(grid),len(grid[0])\n        \n        def dfs(i,j,g,c):\n            if 0<=i<m and 0<=j<n and grid[i][j]!=0:\n                c+=grid[i][j]\n                tmp=grid[i][j]\n                grid[i][j]=0\n                res=max(dfs(i+1,j,g,c),dfs(i-1,j,g,c),dfs(i,j+1,g,c),dfs(i,j-1,g,c))\n                grid[i][j]=tmp\n                return res\n            else:\n                return c\n            return c\n        x=[]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]!=0:\n                    c=0\n                    x.append(dfs(i,j,grid,c))\n                    \n        return max(x)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def findSum(row, col, total):\n            if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):\n                return\n            if not grid[row][col]:\n                return\n            tmp = grid[row][col]\n            total += tmp\n            grid[row][col] = 0\n            if row < len(grid):\n                findSum(row+1, col, total)\n            if row >= 0:\n                findSum(row-1, col, total)\n            if col < len(grid[0]):\n                findSum(row, col+1, total)\n            if col >= 0:\n                findSum(row, col-1, total)\n            self.sm = max(self.sm, total)\n            grid[row][col] = tmp\n        \n        self.sm = 0\n        total = 0\n        for row in range(len(grid)):\n            for col in range(len(grid[row])):\n                if grid[row][col]:\n                    findSum(row, col, total)\n                    total = 0\n        return self.sm", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        self.ans = 0\n        R, C = len(grid), len(grid[0])\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == 0:\n                    continue\n                self.dfs(grid, r, c, grid[r][c], set([(r, c)]))\n        \n        return self.ans\n    \n    def dfs(self, g, r, c, tot, used):\n        if tot > self.ans:\n            self.ans = tot\n            \n        dirs = (0,1),(1,0),(0,-1),(-1,0)\n        R, C = len(g), len(g[0])\n        \n        for dr, dc in dirs:\n            r2, c2 = r + dr, c + dc\n            if not (0 <= r2 < R and 0 <= c2 < C):\n                continue\n            if (r2, c2) in used or g[r2][c2] == 0:\n                continue\n            used.add((r2, c2))\n            self.dfs(g, r2, c2, tot + g[r2][c2], used)\n            used.remove((r2, c2))", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def getGold(i,j,s,money):\n            nonlocal mx;\n            for c1,c2 in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\n                if (c1,c2) not in s and 0<=c1<len(grid) and 0<=c2<len(grid[0]) and grid[c1][c2]!=0:\n                    s.add((c1,c2))\n                    getGold(c1,c2,s,money+grid[c1][c2])\n                    s.remove((c1,c2))\n            mx=max(mx,money)\n        \n        mx=0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                s=set()\n                if grid[i][j]!=0:\n                    s.add((i,j))\n                    getGold(i,j,s,grid[i][j])\n        return mx", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        R=len(grid)\n        C=len(grid[0])\n        \n        result=0\n        directions=[(0,-1),(0,1),(-1,0),(1,0)]\n        \n        def dfs(i,j,total=0):\n            nonlocal result\n            result=max(result,total)\n            \n            visited.add((i, j))\n            for dx,dy in directions:\n                rx, cy = i + dx, j + dy\n                if 0 <= rx < R and 0 <= cy < C and (rx, cy) not in visited and grid[rx][cy] != 0:\n                    dfs(rx, cy, total+grid[rx][cy])\n            \n            visited.remove((i, j))\n        \n        visited = set()\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j]!=0:\n                    dfs(i,j,grid[i][j])\n        return result", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        \n        def dfs(grid, i,j):\n            if i<0 or i>=len(grid) or j<0 or j>=len(grid[0]) or grid[i][j] == 0 :\n                return 0\n            \n            res = grid[i][j]\n            grid[i][j] = 0\n            cost = res+max(dfs(grid,i+1,j), dfs(grid, i-1,j), dfs(grid, i,j+1), dfs(grid, i,j-1))\n            \n            grid[i][j] = res\n            return cost\n            \n        max_gold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    max_gold = max(max_gold, dfs(grid, i,j))\n        return max_gold", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n\n        def BFS(r, c):\n            nonlocal best, best_path, R, C, grid\n\n            if grid[r][c] > best:\n                best = grid[r][c]\n                best_path = set([(r,c)])\n\n            #(t) total gold, (r) row, (c) column, (p) path\n            q = [(grid[r][c], r, c, set([(r,c)]))]\n\n            while q:\n                next_level = []\n                for t, r, c, p in q:\n                    for i, j in ((r+1,c), (r-1,c), (r,c+1), (r,c-1)):\n                        if 0 <= i < R and 0 <= j < C and grid[i][j]:\n                            if (i,j) not in p:\n                                next_level.append((t+grid[i][j], i, j, p|set([(i,j)])))\n                                if t + grid[i][j] > best:\n                                    best = t + grid[i][j]\n                                    best_path = p|set([(i,j)])\n                q = next_level\n\n\n        R, C = len(grid), len(grid[0])\n        best = 0\n        best_path = set()\n\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c]:\n                    if (r,c) not in best_path:\n                        BFS(r,c)\n\n        return best", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(grid, i, j):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\n                return 0\n            if grid[i][j] <= 0:\n                return 0\n            \n            val = grid[i][j]\n            grid[i][j] = -1\n            ret = val + max(dfs(grid, i-1, j), dfs(grid, i+1, j), dfs(grid, i, j-1), dfs(grid, i, j+1))\n            grid[i][j] = val\n            return ret\n            \n        result = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                result = max(result, dfs(grid, i, j))\n        \n        return result\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        \n        self.ans = 0\n        \n        def dfs(grid, i, j, res):\n            \n            res = res + grid[i][j]\n            \n            tmp = grid[i][j]\n            grid[i][j] = 0 #mark as visited\n            \n            for r,c in ((i+1,j),(i,j+1),(i-1,j),(i,j-1)):\n                if 0 <= r < len(grid) and 0 <= c < len(grid[0]):\n                    if grid[r][c]:\n                        dfs(grid, r, c, res)\n                        \n            grid[i][j] = tmp\n                \n            self.ans = max(self.ans, res)\n            \n            \n                \n        for i in range(0,len(grid)):\n            for j in range(0,len(grid[0])):\n                if grid[i][j]:  \n                    dfs(grid, i, j, 0)\n        \n        return self.ans\n        \n                    \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def helper(i, j):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n                return 0\n            val = grid[i][j]\n            grid[i][j] = 0\n            res = val + max(helper(i + 1, j), helper(i - 1, j), helper(i, j + 1), helper(i , j - 1))\n            grid[i][j] = val\n            return res\n        self.res = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] != 0:\n                    self.res = max(self.res, helper(i, j))\n        return self.res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i, j, v):\n            seen.add((i, j))\n            dp[i][j] = max(dp[i][j], v)\n            for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):\n                if 0 <= x < m and 0 <= y < n and grid[x][y] and (x, y) not in seen:\n                    dfs(x, y, v + grid[x][y])\n            seen.discard((i, j))\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    seen = set()\n                    dfs(i, j, grid[i][j])\n        return max(c for row in dp for c in row)\n", "class Solution:\n    def dfs(self, i, j, gold):\n        flag = True\n        \n        for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n            if 0<=ni<self.m and 0<=nj<self.n and self.grid[ni][nj]>0:\n                tmp = self.grid[i][j]\n                self.grid[i][j] = 0\n                self.dfs(ni, nj, gold+self.grid[ni][nj])\n                self.grid[i][j] = tmp\n                flag = False\n        \n        if flag:\n            self.ans = max(self.ans, gold)\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.m, self.n = len(grid), len(grid[0])\n        self.grid = grid\n        self.ans = 0\n        \n        for i in range(self.m):\n            for j in range(self.n):\n                if grid[i][j]>0:\n                    self.dfs(i, j, grid[i][j])\n        \n        return self.ans\n        \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        \n        def dfs(path, curr_sum):\n            nonlocal res\n            \n            i, j = path[-1]\n            dirs_lst = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n            find = False\n            for di, dj in dirs_lst:\n                ni = i+di\n                nj = j+dj\n                if 0<=ni<M and 0<=nj<N and grid[ni][nj]>0:\n                    # if (i==1 and j==2):\n                    #     print (path, grid[ni][nj], grid)\n                    find = True\n                    curr_sum += grid[ni][nj]\n                    grid[ni][nj] = -grid[ni][nj]\n                    # vis.add((ni, nj))\n                    # print (path, curr_sum)\n                    path.append((ni, nj))\n                    dfs(path, curr_sum)\n                    path.pop()\n                    grid[ni][nj] = -grid[ni][nj]\n                    curr_sum -= grid[ni][nj]\n            if not find:\n                # if curr_sum==35:\n                #     print ('aa ', path, curr_sum)\n                res = max(res, curr_sum)\n        \n        \n        \n        res = 0\n        M = len(grid)\n        N = len(grid[0])\n        for i in range(M):\n            for j in range(N):\n                if grid[i][j]>0:\n                    # vis = set()\n                    grid[i][j] = -grid[i][j]\n                    dfs([(i, j)], -grid[i][j])\n                    grid[i][j] = -grid[i][j]\n                    # for x, y in vis:\n                    #     grid[x][y] = 0\n                    \n        return res\n", "\n'''class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:       \n        rLen = len(grid)\n        if rLen == 0:\n            return 0 \n        cLen = len(grid[0])\n        if cLen == 0:\n            return 0 \n        res = 0 \n        resPath = []\n        for i in range(rLen):\n            for j in range(cLen):\n                if grid[i][j] != 0 and [i,j] not in resPath:\n                    tmp, path = self.dfs(grid, i,j,rLen, cLen)\n                    if tmp > res:\n                        res = tmp\n                        resPath = path\n        return res'''\n        \n'''def dfs(self, grid, x,y,rLen, cLen):\n            val = grid[x][y]\n            grid[x][y] = 0\n            curSum = 0 \n            path = []\n            if x+1 < rLen and grid[x+1][y] != 0:\n                ret, retPath = self.dfs(grid, x+1,y,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret \n                    path = retPath\n            if x-1 >=0 and grid[x-1][y] != 0:\n                ret, retPath= self.dfs(grid, x-1,y,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret\n                    path = retPath\n            if y+1 < cLen and grid[x][y+1] != 0:\n                ret, retPath = self.dfs(grid, x,y+1,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret\n                    path = retPath\n            if y-1 >= 0 and grid[x][y-1] != 0:\n                ret, retPath = self.dfs(grid, x,y-1,rLen, cLen)\n                if ret > curSum:\n                    curSum = ret\n                    path = retPath\n            path.append([x,y])\n            grid[x][y] = val\n            return curSum + val, path'''\n \n        \n\n\n\n'''class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int: \n        self.rLen = len(grid)\n        self.cLen = len(grid[0])\n        res = 0 \n        path = None \n        for i in range(self.rLen):\n            for j in range(self.cLen):\n                if grid[i][j] != 0:\n                    ret, retPath = self.dfs(grid, i,j)\n                    #print(grid)\n                    if ret > res:\n                        res = ret \n                        path = retPath\n        return res\n    def dfs(self, grid,i,j):\n        if grid[i][j] != 0:\n            tmp = grid[i][j]\n            grid[i][j] = 0 \n            maxTotal = 0 \n            maxPath = []\n            for newI, newJ in [[i+1,j],[i-1,j],[i,j+1],[i,j-1]]:\n                if 0<=newI<len(grid) and 0<=newJ < len(grid[0]) and grid[newI][newJ] != 0:\n                    retTotal, retPath = self.dfs(grid,newI,newJ)\n                    if retTotal > maxTotal:\n                        maxTotal = retTotal \n                        maxPath = retPath \n            grid[i][j] = tmp \n            return maxTotal + tmp, maxPath + [(i,j)]\n        else:\n            return 0, []'''\n\nclass Solution:\n    def getMaximumGold(self, grid):\n        path = []\n        total = 0 \n        self.rLen = len(grid)\n        self.cLen = len(grid[0])\n        for i in range(self.rLen):\n            for j in range(self.cLen):\n                if grid[i][j] != 0:\n                    retTotal, retPath = self.dfs(grid,i,j)\n                    if retTotal > total:\n                        total = retTotal \n                        path = retPath \n        return total \n    def dfs(self,grid,i,j):\n        tmp = grid[i][j]\n        grid[i][j] = 0 \n        total = 0 \n        path = []\n        for newI, newJ in [[i+1,j],[i-1,j],[i,j+1], [i,j-1]]:\n            if 0<=newI<self.rLen and 0<=newJ<self.cLen and grid[newI][newJ] != 0:\n                retTotal, retPath = self.dfs(grid,newI, newJ)\n                if retTotal > total:\n                    total = retTotal \n                    path = retPath \n        grid[i][j] = tmp\n        return total + tmp, path + [[i,j]]\n    \n        \n\n\n'''from collections import namedtuple\nclass Solution:\n    neighbor = namedtuple('neighbor', ('idx', 'w'))\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(v, availa_lst, sum_, max_sum):\n            sum_ += v.w\n            if all([availa_lst[neibr.idx] for neibr in adj_list[v.idx]]):\n                return [True, max(sum_, max_sum)]\n            for neibr in adj_list[v.idx]:\n                if not availa_lst[neibr.idx]:\n                    availa_lst[neibr.idx] = True\n                    res, sum_path = dfs(neibr, availa_lst, sum_, max_sum)\n                    if res:\n                        max_sum = max(max_sum, sum_path)\n                    availa_lst[neibr.idx] = False\n            return [True, max_sum]\n        if not grid:\n            return 0\n        n, m = len(grid), len(grid[0])\n        # create vertices\n        V = [(row * m) + col for row in range(n) for col in range(m) if grid[row][col] != 0]\n        # create adjacency list\n        dict_ = {V[x]: x for x in range(len(V))}\n        adj_list = []\n        for v in V:\n            tmp_adj = []\n            v_row, v_col = v//m, v%m\n            if v_row != 0 and grid[v_row - 1][v_col] != 0:  # upper neighbor\n                up_idx = dict_[v-m]\n                tmp_adj.append(self.neighbor(up_idx, grid[v_row-1][v_col]))\n            if v_row != (n-1) and grid[v_row + 1][v_col] != 0:  # lower neighbor\n                dow_idx = dict_[v+m]\n                tmp_adj.append(self.neighbor(dow_idx, grid[v_row+1][v_col]))\n            if v_col != 0 and grid[v_row][v_col - 1] != 0:  # left neighbor\n                left_idx = dict_[v-1]\n                tmp_adj.append(self.neighbor(left_idx, grid[v_row][v_col-1]))\n            if v_col != (m-1) and grid[v_row][v_col+1] != 0:  # right neighbor\n                right_idx = dict_[v+1]\n                tmp_adj.append(self.neighbor(right_idx, grid[v_row][v_col+1]))\n            adj_list.append(tmp_adj)\n        # DFS on all vertices\n        max_path = -float('inf')\n        checked = [False] * len(V)\n        for v_idx, v in enumerate(V):\n            row, col = v//m, v%m\n            checked[v_idx] = True\n            max_path = max(max_path, dfs(self.neighbor(v_idx, grid[row][col]), checked, 0, -float('inf'))[1])\n            checked[v_idx] = False\n        return max_path'''\n        \n            \n'''import functools\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        @functools.lru_cache(None)\n        def dfs(u, visited):                # memoize on current_vertex, path\n            subres = 0\n            for v in graph[u]:\n                if (visited >> v) & 1 == 0: # if neighbor is not in path then recurse\n                    subres = max(subres, dfs(v, visited | (1 << v)))\n            return vertex_gold[u] + subres  # return gold here plus the best sub-result\n\n        vertex_gold = [] # vertex_gold[vertex_id] stores amount of gold\n        m = {}           # map of grid coordinate to vertex id\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if cell:\n                    m[i, j] = len(vertex_gold)  # populate map\n                    vertex_gold.append(cell)    # save gold\n        graph = collections.defaultdict(list)\n        for i, row in enumerate(grid):\n            for j, cell in enumerate(row):\n                if cell:                    # if gold, connect vertex to neighbors\n                    for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                        if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y]:\n                            graph[m[i, j]].append(m[x, y])\n        return max(dfs(u, 1 << u) for u in range(len(vertex_gold))) '''       \n            \n        \n        \n        \n        \n", "class Solution:\n    def getMaximumGold(self, grid: [[int]]) -> int:\n        result = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                # Search max possible return starting from this cell\n                result = max(self.search(grid, i, j), result)\n        return result\n\n\n    def search(self, grid, x, y):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\n            return 0\n        if grid[x][y] == 0:\n            return 0\n\n        result = grid[x][y]\n        temp = result\n        grid[x][y] = 0\n\n        # Search all neighbours\n        result += max(self.search(grid, x-1, y),\n                      self.search(grid, x, y-1),\n                      self.search(grid, x+1, y),\n                      self.search(grid, x, y+1))\n\n        grid[x][y] = temp\n\n        return result", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        \n        seen = set()\n        n,m = len(grid),len(grid[0])\n        self.ans = 0\n        def dfs(r,c,cur = 0):\n            seen.add((r,c))\n            cur += grid[r][c]\n            for dx,dy in [(1,0),(0,1),(-1,0),(0,-1)]:\n                x,y = r + dx, c + dy\n                if 0 <= x < n and 0 <= y < m and (x,y) not in seen and grid[x][y] != 0:\n                    dfs(x,y,cur)\n            seen.remove((r,c))\n            self.ans = max(self.ans, cur)\n        \n        for i in range(n):\n            for j in range(m):\n                if (i,j) not in seen and grid[i][j] != 0:\n                    dfs(i,j)\n                    \n        return self.ans", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid: return 0\n        m,n=len(grid),len(grid[0])\n        \n        \n        def dfs(i,j, visited, res):\n            nonlocal result, best_path\n            if res > result: \n                best_path=visited\n            ret = res\n            for (a,b) in [(-1,0),(1,0),(0,-1),(0,1)]:\n                ci,cj = a+i,b+j\n                if 0<=ci<m and 0<=cj<n and (ci,cj) not in visited and grid[ci][cj]!=0:\n                    ret= max(ret, dfs(ci,cj, visited|set([(ci,cj)]), res+grid[ci][cj]))\n            return ret\n    \n        result = 0\n        best_path = set()\n        for  i in range(m):\n            for j in range(n):\n                if grid[i][j]!=0 and (i,j) not in best_path:\n                    result = max(result, dfs(i,j,set([(i,j)]), grid[i][j]))\n        return result ", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(x, y, total):\n            nonlocal maxTotal, visited\n            maxTotal = max(maxTotal, total)            \n            visited.add((x, y))            \n            \n            for move in {(1, 0), (0, 1), (-1, 0), (0, -1)}:\n                i = x + move[0]\n                j = y + move[1]\n                \n                if 0 <= i < n and 0 <= j < m and grid[i][j] and (i,j) not in visited:\n                    dfs(i, j, total + grid[i][j])\n                    \n            visited.remove((x,y))       \n            \n        if not grid or not grid[0]: \n            return 0\n        \n        n = len(grid)\n        m = len(grid[0])\n        result = 0\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:\n                    maxTotal = 0\n                    visited = set()\n                    dfs(i, j, grid[i][j])\n                    \n                    if maxTotal > result: \n                        result = maxTotal\n        \n        return result", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i, j, v):\n            seen.add((i, j))\n            dp[i][j] = max(dp[i][j], v)\n            for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):\n                if 0 <= x < m and 0 <= y < n and grid[x][y] and (x, y) not in seen:\n                    dfs(x, y, v + grid[x][y])\n            seen.discard((i, j))\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    seen = set()\n                    dfs(i, j, grid[i][j])\n        return max(c for row in dp for c in row)", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        l = len(grid)\n        w = len(grid[0])\n        seen = set()\n        \n        def dfs(x, y):\n            if (x, y) not in seen and 0 <= x < l and 0 <= y < w and grid[x][y]:\n                seen.add((x, y))\n                r = max(dfs(x+1, y), dfs(x, y+1), dfs(x-1, y), dfs(x, y-1)) + grid[x][y]\n                seen.remove((x, y))\n                return r\n            else:\n                return 0\n                \n        return max(dfs(i, j) for i in range(l) for j in range(w))\n                \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(grid, i, j):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\n                return 0\n            if grid[i][j] <= 0:\n                return 0\n            \n            val = grid[i][j]\n            grid[i][j] = -1\n            ret = val + max(dfs(grid, i-1, j), dfs(grid, i+1, j), dfs(grid, i, j-1), dfs(grid, i, j+1))\n            grid[i][j] = val\n            return ret\n            \n        result = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                # Ideal of optimization: if the node should not be used as the start node,\n                # do not do DFS on it. But this may be difficult to check.\n                result = max(result, dfs(grid, i, j))\n        \n        return result\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        ans=0\n        m=len(grid)\n        n=len(grid[0])\n        visited=[[False for j in range(n)]for i in range(m)]\n        def helper(i,j):\n            if(i<0 or i>=m or j<0 or j>=n or visited[i][j] or grid[i][j]==0):\n                return 0\n            visited[i][j]=True\n            a=helper(i-1,j)\n            b=helper(i,j-1)\n            c=helper(i,j+1)\n            d=helper(i+1,j)\n            visited[i][j]=False\n            \n            return grid[i][j]+max(a,max(b,max(c,d)))\n        \n        for i in range(m):\n            for j in range(n):\n                if(grid[i][j]!=0):\n                    ans=max(ans,helper(i,j))\n        return ans\n    \n        \n                                \n                        \n", "best = 0\n            \ndef collect(grid, r, c, curr):\n    if r >= 0 and c >= 0 and r < len(grid) and c < len(grid[0]) and grid[r][c] != 0:\n        nonlocal best\n        val = grid[r][c]\n        curr += val\n        best = max(best, curr)\n        \n        temp = grid[r][c]\n        grid[r][c] = 0\n        \n        collect(grid, r + 1, c, curr)        \n        collect(grid, r - 1, c, curr)\n        collect(grid, r, c + 1, curr)\n        collect(grid, r, c - 1, curr)\n        curr -= val\n        \n        grid[r][c] = val\n        \n        \n\nclass Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        nonlocal best\n        best = 0\n        rows = len(grid)\n        cols = len(grid[0])        \n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] != 0:\n                    collect(grid, r, c, 0)\n        return best                    \n", "class Solution:\n    \n    def dfs(self, grid, i, j, m, n):\n        tmp = 0\n        \n        # print(self.visited)\n        # base case\n        if grid[i][j] == 0 or self.visited[i][j] == 1:\n            return 0\n        \n        self.visited[i][j]=1\n        \n        for x,y in self.direction:\n            x = i + x\n            y = j + y\n            if x>= 0 and y >= 0 and x < m and y < n and grid[x][y] != 0 and self.visited[x][y] != 1:\n                tmp = max(tmp,self.dfs(grid,x,y,m,n))\n        \n        self.visited[i][j] = 0\n        return tmp + grid[i][j]        \n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.direction = [[0,1],[0,-1],[1,0],[-1,0]]\n        m = len(grid)\n        n = len(grid[0])\n        self.visited = [[0 for _ in range(n)] for _ in range(m)]\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, self.dfs(grid, i, j, m,n))\n        return res\n                \n", "class Solution:\n    def getMaximumGold(self, grid: [[int]]) -> int:\n        result = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                # Search max possible return starting from this cell\n                result = max(self.search(grid, i, j), result)\n        return result\n\n\n    def search(self, grid, x, y):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\n            return 0\n        if grid[x][y] == 0:\n            return 0\n\n        result = grid[x][y]\n        temp = result\n        # Mark as 0 to show gold has been taken\n        grid[x][y] = 0\n\n        # Search all neighbours\n        result += max(self.search(grid, x-1, y),\n                      self.search(grid, x, y-1),\n                      self.search(grid, x+1, y),\n                      self.search(grid, x, y+1))\n\n        # Restore original gold in this cell for another path.  This is\n        # because grid is passed as reference, so one modifying it during one\n        # path will affect another (even though it may not have visited yet)\n        grid[x][y] = temp\n        \n        return result", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(grid, i, j):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\n                return 0\n            if grid[i][j] <= 0:\n                return 0\n            \n            val = grid[i][j]\n            grid[i][j] = -1\n            ret = val + max(dfs(grid, i-1, j), dfs(grid, i+1, j), dfs(grid, i, j-1), dfs(grid, i, j+1))\n            grid[i][j] = val\n            return ret\n            \n        result = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                # Ideal of optimization: if the node should not be used as the start node,\n                # do not do DFS on it.\n                num_neighbours = 0\n                if i > 0 and grid[i-1][j] > 0:\n                    num_neighbours += 1\n                if i < len(grid) - 1 and grid[i+1][j] > 0:\n                    num_neighbours += 1\n                if j > 0 and grid[i][j-1] > 0:\n                    num_neighbours += 1\n                if j < len(grid[0]) - 1 and grid[i][j+1] > 0:\n                    num_neighbours += 1\n                    \n                if num_neighbours > 2:\n                    continue\n                \n                result = max(result, dfs(grid, i, j))\n        \n        return result\n", "class Solution:\n    def __init__(self):\n        self.max_gold = float('-Inf')\n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        \n        def dfs(current,i,j):\n            if i<0 or i>=len(grid) or j<0 or j>=len(grid[0]) or grid[i][j]==0:\n                return\n            current+=grid[i][j]\n            temp=grid[i][j]\n            grid[i][j]=0\n            self.max_gold = max(current,self.max_gold)\n            \n            dfs(current,i-1,j)\n            dfs(current,i+1,j)\n            dfs(current,i,j-1)\n            dfs(current,i,j+1)\n            grid[i][j]=temp\n            \n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]!=0:\n                    dfs(0,i,j)\n        return self.max_gold if self.max_gold!=float('-Inf') else 0", "class Solution:\n    def dfs(self, grid, i, j):\n        if (i < 0) or (i >= len(grid)) or (j < 0) or (j >= len(grid[0])) or (grid[i][j] == 0):\n            return 0\n        \n        temp = grid[i][j]\n        grid[i][j] = 0\n        \n        max_gold = temp + max( \n        self.dfs(grid, i + 1, j),\n        self.dfs(grid,  i - 1, j),\n        self.dfs(grid, i, j + 1),\n        self.dfs(grid, i, j - 1))\n        grid[i][j] = temp\n        return max_gold\n        \n        \n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                max_gold = self.dfs(grid, i, j)\n                # print(\\\"max gold: \\\", max_gold)\n                res = max(res, max_gold)\n        return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.maxGold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] > 0:\n                    used = set()\n                    used.add((i,j))\n                    self.dfs(i, j, 0, grid, used)\n        return self.maxGold \n    \n    def dfs(self, i, j, total, grid, used):\n        total += grid[i][j]\n        if total > self.maxGold:\n            self.maxGold = total\n        for ni, nj in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):\n            if 0<= ni < len(grid) and 0<= nj < len(grid[0]) and (ni,nj) not in used and grid[ni][nj] > 0:\n                used.add((ni,nj))\n                self.dfs(ni, nj, total, grid, used)\n                used.remove((ni,nj))\n\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        self.maxGold = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] > 0:\n                    used = set()\n                    self.dfs(i, j, 0, grid, used)\n        return self.maxGold \n    \n    def dfs(self, i, j, total, grid, used):\n        used.add((i,j))\n        total += grid[i][j]\n        if total > self.maxGold:\n            self.maxGold = total\n        for ni, nj in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):\n            if 0<= ni < len(grid) and 0<= nj < len(grid[0]) and (ni,nj) not in used and grid[ni][nj] > 0:\n                self.dfs(ni, nj, total, grid, used)\n        used.remove((i,j))\n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        # _grid = [grid[i][:] for i in range(len(grid))]\n        m, n = len(grid), len(grid[0])\n        self.res = 0\n        def helper(r, c, grid, acc):\n            acc += grid[r][c]\n            self.res = max(self.res, acc)\n            temp, grid[r][c] = grid[r][c], 0\n            for ir, ic in [[-1,0],[0,-1],[1,0],[0,1]]:\n                if 0 <= r+ir < m and 0 <= c+ic < n and grid[r+ir][c+ic] > 0:\n                    helper(r+ir, c+ic, grid, acc)\n            grid[r][c] = temp\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    helper(i,j,grid,0)\n        return self.res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        def dfs(i, j, gold):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[i]) or grid[i][j] == 0:\n                return gold\n            temp = grid[i][j]\n            grid[i][j] = 0\n            res = max(\n                dfs(i - 1, j, gold + temp),\n                dfs(i + 1, j, gold + temp),\n                dfs(i, j - 1, gold + temp),\n                dfs(i, j + 1, gold + temp)\n            )\n            grid[i][j] = temp\n            return res\n        \n        res = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j] > 0:\n                    res = max(res, dfs(i, j, 0))\n        return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        moves = [[-1,0], [0,1], [1,0], [0,-1]]\n        \n        golds = [(i,j) for i in range(rows) for j in range(cols) if grid[i][j] != 0]\n        visited = {}\n        \n        def dfs(curr_r, curr_c, curr_gold):\n            tmp = []\n            for move in moves:\n                new_r, new_c = curr_r+move[0], curr_c+move[1]\n                \n                if new_r>=0 and new_r<rows and new_c>=0 and new_c<cols and grid[new_r][new_c] != 0 and (new_r, new_c) not in visited:\n                    visited[(new_r, new_c)] = 1\n                    tmp.append(dfs(new_r, new_c, curr_gold+grid[new_r][new_c]))\n                    del visited[(new_r, new_c)]\n            \n            if len(tmp) != 0:\n                return max(tmp)\n            else:\n                return curr_gold\n         \n        res = float('-inf')\n        for g in golds:\n            i, j = g\n            visited[(i,j)] = 1\n            tmp = dfs(i, j, grid[i][j])\n            res = max(res, tmp)\n            del visited[(i,j)]\n            # print(i, j, tmp)\n        return res", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        \n        self.ans=0\n        m=len(grid)\n        n=len(grid[0])\n        def backtrack(i,j,sumup):\n            nonlocal n,m\n            if i<0 or i>m-1 or j<0 or j>n-1 or grid[i][j]==0: return \n            sumup+=grid[i][j]\n            self.ans=max(self.ans,sumup)\n            temp=grid[i][j]\n            grid[i][j]=0\n            backtrack(i-1,j,sumup)\n            backtrack(i+1,j,sumup)\n            backtrack(i,j-1,sumup)\n            backtrack(i,j+1,sumup)\n            grid[i][j]=temp\n        \n        for i in range(m):\n            for j in range(n):\n                backtrack(i,j,0)\n        return self.ans\n            \n            \n", "class Solution:\n    def getMaximumGold(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n        self.ans = 0\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or grid[i][j] == 0:\n                return 0\n            \n            visited[i][j] = True\n            res = grid[i][j] + max(dfs(i-1, j), dfs(i+1, j), dfs(i, j-1), dfs(i, j+1))\n            visited[i][j] = False\n            self.ans = max(self.ans, res)\n            return res\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    dfs(i, j)\n        \n        return self.ans\n"]
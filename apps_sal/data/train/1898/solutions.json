["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        ans, to_delete = [], set(to_delete)\n        def search(root, is_root):\n            if not root: return None\n            root_deleted = root.val in to_delete\n            if is_root and not root_deleted:\n                ans.append(root)\n            root.left = search(root.left, root_deleted)\n            root.right = search(root.right, root_deleted)\n            return None if root_deleted else root\n        search(root, True)\n        return ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        ans = []\n        to_delete = set(to_delete)\n        \n        def dfs(node, has_parent):\n            if not node: return False\n            if node.val not in to_delete and not has_parent:\n                    ans.append(node)\n            if dfs(node.left, node.val not in to_delete): node.left = None\n            if dfs(node.right, node.val not in to_delete): node.right = None\n            return  node.val in to_delete\n        dfs(root, False)\n        return ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def merge(self, root, left, right):\n        replace_left = replace_right = None\n        for i in range(len(left)):\n            if left[i] == root.left:\n                replace_left = i\n                \n        for i in range(len(right)):\n            if right[i] == root.right:\n                replace_right = i\n                \n        if replace_left is not None and replace_right is None:\n            left[replace_left] = root\n            return left + right\n        elif replace_right is not None and replace_left is None:\n            right[replace_right] = root\n            return left + right\n        \n        result = (\n            [node for node in left if node != root.left] + \n            [node for node in right if node != root.right]\n        )\n        result.append(root)\n        return result\n    \n    def helper(self, root, to_delete):\n        if not root:\n            return []\n        if not root.left and not root.right:\n            if root.val in to_delete:\n                return []\n            return [root]\n        \n        left = self.delNodes(root.left, to_delete)\n        right = self.delNodes(root.right, to_delete)\n        \n        if root.left and root.left.val in to_delete:\n            root.left = None\n            \n        if root.right and root.right.val in to_delete:\n            root.right = None\n        \n        if root.val in to_delete:\n            return left + right\n        \n        return self.merge(root, left, right)\n            \n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        return self.helper(root, set(to_delete))\n            \n        \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        res = []\n        def rec(curr, deleted):\n            nonlocal res\n            if not curr:\n                return None\n            if curr.val in to_delete:\n                curr.left = rec(curr.left, True)\n                curr.right = rec(curr.right, True)\n                \n            else:\n                curr.left = rec(curr.left, False)\n                curr.right = rec(curr.right, False)\n                if deleted:\n                    res.append(curr)\n            return None if curr.val in to_delete else curr\n        rec(root, True)\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:     \n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        if root is None: return\n        tovisit = []\n        result = []\n        if root in to_delete:\n            if root.left is not None:\n                tovisit.append(root.left)\n                result.append(root.left)\n            if root.right is not None:\n                tovisit.append(root.right)\n                result.append(root.right)\n        else:\n            tovisit.append(root)\n            result.append(root)\n            \n        while len(tovisit) > 0:\n            new_tovisit = []\n            for item in tovisit:\n                if item.val in to_delete:\n                    if item.left is not None:\n                        result.append(item.left)\n                    if item.right is not None:\n                        result.append(item.right)\n                    if item in result:\n                        result.remove(item)\n                if item.left is not None:\n                    new_tovisit.append(item.left)\n                    if item.left.val in to_delete:\n                        item.left = None\n                if item.right is not None:\n                    new_tovisit.append(item.right)\n                    if item.right.val in to_delete:\n                        item.right = None\n            tovisit = new_tovisit\n        return result", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        roots = []\n        \n        def deleting(node, to_delete, roots):\n            if node == None:\n                return\n            elif node.val in to_delete:\n                if node.left != None:\n                    roots.append(node.left)\n                if node.right != None:\n                    roots.append(node.right)\n                    \n                try:\n                    while True:\n                        roots.remove(node)\n                except:\n                    pass\n                    \n            \n            if node.left != None and node.left.val in to_delete:\n                deleting(node.left, to_delete, roots)\n                node.left = None\n            else:\n                deleting(node.left, to_delete, roots)\n                \n            if node.right != None and node.right.val in to_delete:\n                deleting(node.right, to_delete, roots)\n                node.right = None\n            else:\n                deleting(node.right, to_delete, roots)\n                \n        deleting(root, to_delete, roots)\n        if root.val not in to_delete:\n            roots.append(root)\n            \n        return roots", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom queue import Queue\n\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        if not root:\n            return []\n        \n        deleted = set()\n        for node in to_delete:\n            deleted.add(node)\n        \n        out = []\n        self.bfs(root, deleted, out)\n        return out\n        \n    def bfs(self, root, deleted, out):\n        q = Queue()\n        q.put((root, True))\n        \n        while q.qsize() > 0:\n            node, parent_delete = q.get()\n            \n            if node.val in deleted:\n                curr_delete = True\n            else:\n                curr_delete = False\n                \n            if node.left:\n                q.put((node.left, curr_delete))\n                if node.left.val in deleted:\n                    node.left = None\n                    \n            if node.right:\n                q.put((node.right, curr_delete))\n                if node.right.val in deleted:\n                    node.right = None\n                                \n            if curr_delete:\n                node.left = None\n                node.right = None\n            elif parent_delete:\n                out.append(node)            ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        roots = []\n        roots.append(root)\n        \n        def removeRoot(root, roots):\n            index = 0\n            for i in roots:\n                if i == root:\n                    roots.pop(index)\n                index+=1\n                \n        def delete(root, prev, roots, to_delete):\n            left = root.left\n            right = root.right\n            if root.val in to_delete:\n                removeRoot(root, roots)\n                if left:\n                    roots.append(root.left)\n                if right:\n                    roots.append(root.right)\n                root.left = None\n                root.right = None\n                if prev:\n                    if prev.left == root:\n                        prev.left = None\n                    if prev.right == root:\n                        prev.right = None\n            \n            if left:\n                delete(left, root, roots, to_delete)\n            if right:\n                delete(right, root, roots, to_delete)\n                \n        delete(root, None, roots, to_delete)\n        return roots", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        # from collections import deque\n        # queue = deque([root])\n        # visited = []\n        # while queue:\n        #     curr = queue.popleft()\n        #     if curr:\n        #         visited.append(curr)\n        #         queue.extend([curr.left, curr.right])\n        # res = []\n        # for node in visited:\n        #     if node.val in to_delete:\n        #         if node.left: res.append(node.left)\n        #         if node.right: res.append(node.right)\n        #         node = None\n        # if root and root.val not in to_delete:\n        #     res.append(root)\n        # return res\n        \n        stack = [(root, True)]\n        res = []\n        while stack:\n            curr, toBeRoot = stack.pop()\n            if curr:\n                if curr.val not in to_delete and toBeRoot:\n                    res.append(curr)\n                toBeRoot = curr.val in to_delete\n                stack += [(curr.left,toBeRoot), (curr.right, toBeRoot)]\n                if curr.left and curr.left.val in to_delete: curr.left = None\n                if curr.right and curr.right.val in to_delete: curr.right = None\n                    \n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def walk(self, node, to_delete):\n        \n        if not node:\n            return []\n        \n        roots = []\n        \n        if node.left:\n            roots += self.walk(node.left, to_delete)\n            if node.left.val in to_delete:\n                node.left = None\n            elif node.val in to_delete:\n                roots.append(node.left)\n                \n        if node.right:\n            roots += self.walk(node.right, to_delete)\n            if node.right.val in to_delete:\n                node.right = None\n            elif node.val in to_delete:\n                roots.append(node.right)\n        \n        return roots\n    \n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        \n        if not root:\n            return None\n        \n        to_delete = set(to_delete)\n                \n        roots = self.walk(root, to_delete)\n        \n        if root.val not in to_delete:\n            roots.append(root)\n        \n        return roots", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # APP1: convert to_delete to a set, divide and conquer to get left, right.\n    # dfs: 1 return child root, None if child deleted. \n    # 2. check if cur in delete, pass it for recursion call\n    # 3 check if child is deleted, delete the link to children\n    # Runtime: 98%\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        if not root:\n            return []\n        res, to_delete = [], set(to_delete)\n        self.dfs(root, res, to_delete, True)\n        return res\n    \n    def dfs(self, root, res, to_delete, parent_deleted):\n        if not root:\n            return None\n        if parent_deleted and root.val not in to_delete:\n            res.append(root)\n            \n        root_deleted = True if root.val in to_delete else False\n        root.left = self.dfs(root.left, res, to_delete, root_deleted)\n        root.right = self.dfs(root.right, res, to_delete, root_deleted)\n        return None if root_deleted else root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        def dfs(root: TreeNode, has_parent: bool) -> TreeNode:\n            if not root:\n                return \n                \n            if root.val in to_delete:\n                root.left = dfs(root.left, has_parent=False)\n                root.right = dfs(root.right, has_parent=False)\n                return\n            else:\n                if not has_parent:\n                    result.append(root)\n                root.left = dfs(root.left, has_parent=True)\n                root.right = dfs(root.right, has_parent=True)\n                return root\n\n        result = []\n        dfs(root, has_parent=False)\n        return result\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n        \n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n\n        to_delete = set(to_delete)\n        res = []\n        def walk(root, parent_exist):\n            if root is None:\n                return None\n            if root.val in to_delete:\n                root.left = walk(root.left, parent_exist=False)\n                root.right = walk(root.right, parent_exist=False)\n                return None\n            else:\n                if not parent_exist:\n                    res.append(root)\n                root.left = walk(root.left, parent_exist=True)\n                root.right = walk(root.right, parent_exist=True)\n                return root\n        walk(root, parent_exist=False)\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        new_roots = []\n        def delete_nodes(node, parent_deleted):\n            if not node:\n                return False\n            delete = False\n            for value in to_delete:\n                if value == node.val:\n                    delete = True\n            if parent_deleted and not delete:\n                new_roots.append(node)\n            left, right = delete_nodes(node.left, delete), delete_nodes(node.right, delete)\n            if left:\n                node.left = None\n            if right:\n                node.right = None\n            return delete\n        \n        delete_nodes(root, True)\n        return new_roots", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        results = []\n        def dft(root, to_delete):\n            if not root:\n                return\n            dft(root.left, to_delete) \n            dft(root.right, to_delete)\n            if root.left and root.left.val in to_delete:\n                root.left = None\n            if root.right and root.right.val in to_delete:\n                root.right = None \n            if root.val in to_delete:\n                print((root.val))\n                if root.right:\n                    print((root.right.val))\n                    results.append(root.right)\n                    root.right = None\n                if root.left:\n                    print((root.left.val))\n                    results.append(root.left)\n                    root.left = None\n           \n        dft(root, to_delete)\n        if root.val not in to_delete:\n            results.append(root) \n        return results\n             \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        to_delete = set(to_delete)\n        ans = []\n        def helper(node, isRoot, parent, p_left):\n            if isRoot:\n                ans.append(node)\n                \n            if node.val in to_delete:\n                if isRoot:\n                    ans.pop()\n                if parent:\n                    if p_left:\n                        parent.left = None\n                    else:\n                        parent.right = None\n                if node.left:                    \n                    helper(node.left, True, node, True)\n                if node.right:                    \n                    helper(node.right, True, node, False)\n            else:\n                if node.left:\n                    helper(node.left, False, node, True)\n                if node.right:\n                    helper(node.right, False, node, False)\n                    \n            return\n        \n        helper(root, True, None, None)\n        return ans\n                    \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n#             if node.val in to_delete:\n#                 if node.left:\n#                     ans.append(node.left)\n#                     helper(node.left)\n#                 if node.right:\n#                     ans.append(node.right)\n#                     helper(node.right)\n#                 ans.pop()\n#                 to_delete.remove(node.val)\n                \n#             if node.left and node.left.val in to_delete:\n#                 node.left = None\n#             if node.right and node.right.val in to_delete:\n#                 node.right = None\n                \n#             return\n#         helper(root)\n#         return ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        self.deletes = set(to_delete)\n        self.res = list()\n        root = self.helper(root)\n        if root:\n            self.res.append(root)\n        return self.res\n    \n    def helper(self, root):\n        if not root:\n            return root\n        root.left = self.helper(root.left)\n        root.right = self.helper(root.right)\n        if root.val in self.deletes:\n            if root.left:\n                self.res.append(root.left)\n            if root.right:\n                self.res.append(root.right)\n            root = None\n        return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        if not root:\n            return []\n        \n        res = set([root])\n        \n        deleteSet = set(to_delete)\n        \n        def dfs(root):\n            \n            if not root:\n                return\n            \n            if root.val in deleteSet:\n                if root in res:\n                    res.remove(root)\n                if root.left:\n                    res.add(root.left)\n                if root.right:\n                    res.add(root.right)\n            \n            dfs(root.left)\n            dfs(root.right)\n            \n            if root.left and root.left.val in deleteSet:\n                root.left = None\n            if root.right and root.right.val in deleteSet:\n                root.right= None\n                \n            \n                \n        dfs(root)\n        \n        return list(res)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delete(self, root, to_delete, parent, res):\n        if not root:\n            return root\n        else:\n            if parent: \n                if root.val in to_delete:\n                    root.left = self.delete(root.left, to_delete, False, res)\n                    root.right = self.delete(root.right, to_delete, False, res)\n                    return None\n                else:\n                    root.left = self.delete(root.left, to_delete, True, res)\n                    root.right = self.delete(root.right, to_delete, True, res)\n                    return root\n            else:\n                if root.val in to_delete:\n                    root.left = self.delete(root.left, to_delete, False, res)\n                    root.right = self.delete(root.right, to_delete, False, res)\n                    return None\n                else:\n                    res.append(root)\n                    root.left = self.delete(root.left, to_delete, True, res)\n                    root.right = self.delete(root.right, to_delete, True, res)\n                    return root\n                \n        \n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        res = []\n        root = self.delete(root, set(to_delete), False, res)\n        return res\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        ret = []\n        def dfs(node, parent):\n            if node:\n                if node.val in to_delete:\n                    node.left=dfs(node.left, False)\n                    node.right=dfs(node.right, False)\n                else:\n                    if not parent:\n                        ret.append(node)\n                    node.left=dfs(node.left, True)\n                    node.right=dfs(node.right, True)\n                    return node\n        dfs(root, False)\n        return ret", "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def delNodes(self, root, to_delete):\n        \\\"\\\"\\\"\n        :type root: TreeNode\n        :type to_delete: List[int]\n        :rtype: List[TreeNode]\n        \\\"\\\"\\\"\n        if not root:\n            return root\n        res = []\n        self.dfs(root, to_delete, res)\n        if root.val not in to_delete:\n            res.append(root)\n        return res\n    \n    def dfs(self, root, to_delete, res):\n        if not root:\n            return\n        root.left = self.dfs(root.left, to_delete, res)\n        root.right = self.dfs(root.right, to_delete, res)\n        if root.val in to_delete:\n            if root.left:\n                res.append(root.left)\n            if root.right:\n                res.append(root.right)\n            return None\n        return root", "class Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        final_list = []\n        def rec(node):\n            if node == None:\n                return None\n            node.left = rec(node.left)\n            node.right = rec(node.right)\n            if node.val in to_delete:\n                if node.left!= None:\n                    final_list.append(node.left)\n                if node.right!= None:\n                    final_list.append(node.right)\n                return None\n            return node\n        rec(root)\n        if root.val not in to_delete:\n            final_list.append(root)\n        return(final_list)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        output = []\n        stack = [(0, root)]\n        # delete_set = set(to_delete)\n        \n        def stackChildren(level, node):\n            if node.right:\n                stack.append((level, node.right))\n                if level > 0 and node.right.val in to_delete:\n                    node.right = None\n            if node.left:\n                stack.append((level, node.left))\n                if level > 0 and node.left.val in to_delete:\n                    node.left = None\n            \n        while stack:\n            level, node = stack.pop()\n            if node.val in to_delete:\n                # delete_set.remove(node.val)\n                stackChildren(0, node)\n            else:\n                if level == 0:\n                    output.append(node)\n                stackChildren(level+1, node)\n                \n        return output"]
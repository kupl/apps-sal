["from math import gcd\nfrom itertools import groupby\n\ndef gcd_split(seq):\n gcds= [int(gcd(a,b)==1) for a,b in zip(seq[1:],seq[:-1])]\n gcds.append(int(gcd(seq[0],seq[-1])==1))\n # print(gcds)\n if max(gcds)==0:\n  return -1\n else:\n  splits=[len(list(x))+1 for num,x in groupby(gcds) if num==0]\n  # print(splits)\n  if gcds[0]==gcds[-1]==0:\n   splits[0] += splits[-1]-1\n   splits = splits[:-1]\n  return splits\n\nfor _ in range(int(input())):\n N=int(input())\n A=[int(x) for x in input().split()]\n split = gcd_split(A)\n # print(split)\n \n res=[]\n if split!=-1:\n  for K in range(2,N+1):\n   temp=(x for x in split if x>=K)\n   ins = sum([(x//(K-1)-1 if x%(K-1)==0 else x//(K-1)) for x in temp])\n   if ins==0:\n    break\n   else:\n    res.append(ins)\n else:\n  for K in range(2,N+1):\n   ins = N//(K-1)+(N%(K-1)>0)\n   if ins==0:\n    break\n   else:\n    res.append(ins)\n \n res = res + [0]*(N-1 -len(res))\n print(*res)", "# cook your dish here\ndef gcd(m,n):\n if m > n :\n  (a,b) = (n,m)\n else:\n  (a,b) = (m,n)\n r = b\n while r > 1:\n  r = b%a \n  (a,b) = (r,a)\n if r == 0:\n  return b\n else:\n  return 1\n\ndef rlmaker(rl,pc,n):\n d = 1 \n for i in range(0,pc+1):\n  if i <n-1 :\n   rl[i] += pc//d\n   d+=1\n return rl\ndef rlmakers(rl,pc,n):\n d = 1 \n for i in range(0,pc+1):\n  if i <n-1 :\n   if pc%d == 0:\n    rl[i] += pc//d\n   else:\n    rl[i] += ((pc//d)+1)\n   d+=1\n return rl\n  \n  \ndef insFinder(n,l):\n lstone = 0\n rl = []\n for i in range(0,n-1):\n  rl.append(0)\n pathli = []\n pc = 0\n start = -1\n end = -1\n c = 0\n for i in range (0,n-1):\n  if gcd(l[i],l[i+1]) != 1 :\n   if i == 0:\n    start = 0\n   if i == n-2:\n    end = n-1\n   if lstone == 1:\n    pc += 1 \n   else:\n    lstone = 1 \n    pc += 1\n  else:\n   if lstone == 1:\n    pathli.append(pc)\n    pc = 0\n    lstone = 0\n    \n if start == 0:\n  if end == n-1:\n   if gcd(l[n-1],l[0]) != 1:\n    pathli.append(pc)\n    if len(pathli) > 1:\n     pathli[0]+= (pathli[len(pathli)-1]+1)\n     pathli.remove(pathli[len(pathli)-1])\n    else:\n     c = 1\n     pathli[0]+=1\n   else:\n    pathli.append(pc)\n  else:\n   if gcd(l[n-1],l[0]) != 1:\n    pathli[0] += 1\n else:\n  if end == n-1:\n   if gcd(l[n-1],l[0]) != 1:\n    pc += 1\n    pathli.append(pc)\n   else:\n    pathli.append(pc)\n  else:\n   if gcd(l[n-1],l[0]) != 1:\n    pathli.append(1) \n if c == 1:\n  rl = rlmakers(rl,pathli[0],n)\n else:\n  for i in range(0,len(pathli)):\n   rl = rlmaker(rl,pathli[i],n)\n \n for i in range(0,n-1):\n  print(rl[i],end = ' ')\n  \n print(\"\") \n \nnt = int(input())\nfor i in range(0,nt):\n n = int(input())\n l = list(map(int,input().strip().split(' ')))\n insFinder(n,l)\n \n ", "# cook your dish here\n# cook your dish here\n# cook your dish here\nimport math\ndef gcd(num1,num2):\n if(num2==0):\n  return num1\n else:\n  return gcd(num2,num1%num2)\n\n\nt=int(input())\nfor i in range(t):\n n=int(input())\n a=list(map(int,input().split()))\n l=[] #list with sublist starting and ending point of greater then 1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0gcd\n sm=[]\n p1=0\n p2=0\n j=0\n while(j<n-1):\n  if(gcd(a[j],a[j+1])!=1):\n   p1=j+0\n   while(j<n-1 and gcd(a[j],a[j+1])!=1):\n    j+=1\n   p2=j+0\n   l.append([p1,p2])\n   sm.append(p2-p1+1)\n  else:\n   j+=1\n #last ka first aur age k kuch elements KA consider krna bch gya\n #agr last aur first ka gcd!=1 to dono merge honge\n if(len(l)>0 and l[0][1]-l[0][0]<n-1):\n  if(l[-1][1]==n-1 and l[0][0]==0):\n   if(gcd(a[-1],a[0])!=1):\n    #print(sm)\n    sm[0]+=sm[-1]\n    sm.pop()\n    #print(sm)\n  elif(gcd(a[-1],a[0])!=1 and l[0][0]==0):\n   sm[0]+=1\n  elif(gcd(a[-1],a[0])!=1 and l[-1][1]==n-1):\n   sm[-1]+=1\n  elif(gcd(a[-1],a[0])!=1):\n   sm.append(2)\n \n  w=[0]*(n+1)\n  for j in range(len(sm)):\n   for k in range(2,sm[j]+1):                #l[j][1]-l[j][0]+1 uska \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size h aur usko consider krne k liye +1 aur kiya h\n    w[k]+=math.ceil((sm[j]-1)//(k-1))\n  print(*w[2:])\n elif(len(l)>0):\n  w=[0]*(n+1)\n  if(gcd(a[-1],a[0])!=1):\n   for j in range(len(sm)):\n    for k in range(2,sm[j]+1):                #l[j][1]-l[j][0]+1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0uska size h aur usko consider krne k liye +1 aur kiya h\n     w[k]+=math.ceil((sm[j]-1)//(k-1))+1\n   print(*w[2:])\n  else:\n   for j in range(len(sm)):\n    for k in range(2,sm[j]+1):                #l[j][1]-l[j][0]+1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0uska size h aur usko consider krne k liye +1 aur kiya h\n     w[k]+=math.ceil((sm[j]-1)//(k-1))\n   print(*w[2:])\n else:\n  #print(\"No\")\n  w=[0]*(n+1)\n  if(gcd(a[-1],a[0])!=1):\n   w[2]=1\n   print(*w[2:])\n  else:\n   print(*w[2:])", "# cook your dish here\nimport math\ndef solveit(A,n):\n N=n\n G=[]\n for i in range(n):\n  v=(math.gcd(A[i],A[(i+1)%N]))\n  if (v==1):\n   G.append(1)\n  else:\n   G.append(0)\n\n pos=-1\n for i in range(n):\n  if (G[i]==1):\n   pos=i\n   break\n\n V=[]\n ans=[0 for i in range(N-1)]\n if (pos==-1):\n  for i in range(N-1):\n   ans[i]=math.ceil(N/(i+1))\n else:\n  c=0\n  for i in range(1,N+1):\n   if (G[(pos+i)%N]==0):\n    c=c+1\n\n   else:\n    if (c!=0):\n     V.append(c)\n    c=0\n\n \n  for val in V:\n   for i in range(min(val,N-1)):\n    ans[i]=ans[i]+(val//(i+1))\n\n print(*ans)\n   \n\n \nfor _ in range(int(input())):\n n=int(input())\n A=list(map(int,input().split()))\n solveit(A,n)\n\n", "# cook your dish here\nimport math\ndef solveit(A,n):\n N=n\n G=[]\n for i in range(n):\n  v=(math.gcd(A[i],A[(i+1)%N]))\n  if (v==1):\n   G.append(1)\n  else:\n   G.append(0)\n # print(G)\n pos=-1\n for i in range(n):\n  if (G[i]==1):\n   pos=i\n   break\n\n V=[]\n ans=[0 for i in range(N-1)]\n if (pos==-1):\n  for i in range(N-1):\n   ans[i]=math.ceil(N/(i+1))\n else:\n  c=0\n  for i in range(1,N+1):\n   if (G[(pos+i)%N]==0):\n    c=c+1\n\n   else:\n    if (c!=0):\n     V.append(c)\n    c=0\n\n \n  for val in V:\n   for i in range(min(val,N-1)):\n    ans[i]=ans[i]+(val//(i+1))\n\n print(*ans)\n   \n\n \nfor _ in range(int(input())):\n n=int(input())\n A=list(map(int,input().split()))\n solveit(A,n)\n\n", "# cook your dish here\nimport math\nfrom collections import defaultdict\nt=int(input())\nfor i in range(t):\n n=int(input())\n b=list(map(int,input().split()))\n j=0\n res=[]\n while(j<n):\n  if math.gcd(b[j],b[(j+1)%n])>1:\n   res.append(1)\n  else:\n   res.append(0)\n  j+=1\n j=0\n f=0\n ans=[]\n while(j<n):\n  if res[j]==0:\n   f=1\n   req=j\n   break\n  j+=1\n if f==0:\n  j=1\n  while(j<n):\n   ans.append(math.ceil(n/j))\n   j+=1\n  print(*ans)\n\n else:\n  j=req+1\n  s=0\n  while(j%n!=req):\n   if res[j%n]==1:\n    s+=1\n   else:\n    if s!=0:\n     ans.append(s)\n    s=0\n   j+=1\n  ans.append(s)\n  d=defaultdict(lambda:0)\n  j=0\n  l=len(ans)\n\n  while(j<l):\n   p=ans[j]\n   r=p\n   while(r>=1):\n    d[r]+=(p//r)\n    r+=-1\n   j+=1\n  ans=[]\n  r=1\n  while(r<n):\n   ans.append(d[r])\n   r+=1\n  print(*ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "# cook your dish here\nimport math\nfor _ in range(int(input())):\n n=int(input())\n A=list(map(int,input().split()))\n N=n\n G=[]\n for i in range(n):\n  v=(math.gcd(A[i],A[(i+1)%N]))\n  if (v==1):\n   G.append(1)\n  else:\n   G.append(0)\n pos=-1\n for i in range(n):\n  if (G[i]==1):\n   pos=i\n   break\n V=[]\n ans=[0 for i in range(N-1)]\n if (pos==-1):\n  for i in range(N-1):\n   ans[i]=math.ceil(N/(i+1))\n else:\n  c=0\n  for i in range(1,N+1):\n   if (G[(pos+i)%N]==0):\n    c=c+1\n   else:\n    if (c!=0):\n     V.append(c)\n    c=0\n  for val in V:\n   for i in range(min(val,N-1)):\n    ans[i]=ans[i]+(val//(i+1))\n print(*ans)"]
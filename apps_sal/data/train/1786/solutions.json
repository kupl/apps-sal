["import numpy as np\n\ndef slope(p1, p2):\n    dx, dy = vectorize(p1, p2)\n    return dy/dx if dx else float(\"inf\")\n\ndef vectorize(p1, p2):         return [b-a for a,b in zip(p1, p2)]\ndef getArea  (p1, p2, p3):     return np.cross(vectorize(p1, p2), vectorize(p1, p3)) / 2\ndef isConcave(p1, pivot, p2):  return getArea(pivot, p1, p2) >= 0\n\ndef convex_hull_area(points):\n    if len(points) < 3: return 0\n    \n    Z = min(points)                                                                      # Leftmost point in the graph (lowest if several ones at the same x)\n    q = sorted( (pt for pt in points if pt != Z),\n                key = lambda pt: (-slope(pt, Z), -np.linalg.norm(vectorize(Z, pt))))     # sorted points accordingly to the slope of the line formed by \"pt\" and \"Z\" (in reversed order)\n    \n    hull = [Z, q.pop()]                                                                  # Construct the convex hull (Graham Scan)\n    while q:\n        pt = q.pop()\n        while len(hull) > 1 and isConcave(hull[-2], hull[-1], pt):\n            hull.pop()\n        hull.append(pt)\n    \n    area = sum( getArea(Z, hull[i], hull[i+1]) for i in range(1, len(hull)-1) )          # Calculate area of the hull by adding the area of all the triangles formed by 2 consecutive points in the hull and having Z as summit\n    return round(area, 2)", "def cross(p1,p2,p):\n    return (p[1] - p1[1]) * (p2[0] - p1[0]) - (p2[1] - p1[1]) * (p[0] - p1[0])\n    \ndef dist_to(p1):\n    def f(p):\n        return (p1[0]-p[0]) * (p1[0]-p[0]) + (p1[1]-p[1]) * (p1[1]-p[1])\n    return f\n\ndef xy_yx(p1,p2):\n    return p1[0]*p2[1] - p1[1]*p2[0]\n    \ndef convex_hull_area(pts):\n    if len(pts) == 0:\n        return 0\n    pts = set(pts)\n    new = min(pts)\n    head = new\n    area = 0\n    while 1 :\n        tail = new\n        d_fn = dist_to(tail)\n        new = next(iter(pts))\n        for test in pts:\n            if test != new and test != tail:\n                c = cross(tail,new,test)\n                if tail == new or c > 0: \n                    new = test\n                elif c == 0 :\n                    new = max(new,test,key=d_fn)\n        area += xy_yx(tail, new)\n        if new is head:\n            return round(abs(area)/2.0,2)\n    \n    \n", "from numpy import cross, subtract\n\ndef convex_hull_area(points):\n    if len(points) < 3:\n        return 0\n    area = 0\n    for direction in 1, -1:\n        hull = []\n        for point in sorted(points)[::direction]:\n            while len(hull) > 1 and cross(*hull[-2:]) < cross(point, -subtract(*hull[-2:])):\n                hull.pop()\n            hull.append(point)\n        area += sum(cross(hull[i-1], point) for i, point in enumerate(hull))/2\n    return round(area, 2)", "# Monotone chain method\n\ndef cross(a,b,o):\n    return (a[0]-o[0]) * (b[1]-o[1]) - (b[0]-o[0]) * (a[1]-o[1])\n\ndef hull(pts):\n    q = []\n    for p in pts:\n        while len(q) > 1 and cross(q[-2], q[-1], p) <= 0: q.pop()\n        q.append(p)\n    q.pop()\n    return q\n\ndef convex_hull_area(points):\n    if len(points) < 3: return 0\n    points = sorted(points)\n    hl = hull(points) + hull(points[::-1])\n    hl.append(hl[0])\n    return round(sum(x1*y2 - y1*x2 for (x1,y1),(x2,y2) in zip(hl, hl[1:])) / 2, 2)", "def cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n        \ndef convex_hull_area(points):\n    points = sorted(points)\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    hull = lower[:-1] + upper[:-1]\n    \n    area = 0\n    n = len(hull)\n    j = n - 1\n    for i in range(0,n): \n        area += (hull[j][0] + hull[i][0]) * (hull[i][1] - hull[j][1]) \n        j = i \n    return round(area/2.0,2)\n"]
["class Solution:\n     def findMinMoves(self, machines):\n         \"\"\"\n         :type machines: List[int]\n         :rtype: int\n         \"\"\"\n         if sum(machines) % len(machines) != 0:\n             return -1\n         mean = sum(machines) // len(machines)\n         cum, step = 0, 0\n         for x in machines:\n             cum += x - mean\n             step = max(step, abs(cum), x-mean)\n         return step", "class Solution:\n     def findMinMoves(self, machines):\n         \"\"\"\n         :type machines: List[int]\n         :rtype: int\n         \"\"\"\n         total = sum(machines)\n         length = len(machines)\n         if total%length!=0:\n             return -1\n         \n         avg = int(total/length)\n         cum = 0\n         target = 0\n         result = 0\n         for m in machines:\n             cum+=m\n             target+=avg\n             max_share = m-avg # example [0,3,0] 3 must output 1 to one side at a time, so it needs 2 steps: one for each side.\n             result = max(result, abs(target-cum), max_share)\n             # When cum-target<0, it means right side must transfer abs(cum-target) to the left side\n             # example: [0, 0, 11, 5], avg=4, at the second 0, cum=0, target=2*avg=8, we need to transfer 8-0=8 to the left side\n             # the second 0 is the only interface to the right side, so the right side need 8 steps to fill the left side\n             \n             # When cum-target>0, it means left side must transfer abs(cum-target) to the right side\n             # example: [4,3,2,1,0], avg=2, at 3, cum=7, target=2*avg=4, we need to transfer 7-4=3 to the right side\n             # 3 is the only interface to the right side, so the left side need 3 steps to fill the right side\n         return result;\n", "class Solution:\n     def findMinMoves(self, machines):\n         \"\"\"\n         :type machines: List[int]\n         :rtype: int\n         \"\"\"        \n         N = len(machines)\n         if sum(machines)%N!=0: return -1\n         avg = sum(machines)//N\n         \n         result = 0\n         toNext = 0\n         for i in range(N):\n             fromPrev = toNext\n             toNext = fromPrev+machines[i]-avg\n             if fromPrev<0 and toNext>0:\n                 result = max(result,-fromPrev+toNext)\n             else:\n                 result = max(result,abs(fromPrev),abs(toNext))\n                         \n         return result\n             \n", "class Solution:\n     def findMinMoves(self, machines):\n         \"\"\"\n         :type machines: List[int]\n         :rtype: int\n         \"\"\"\n         n = len(machines)\n         if sum(machines) % n != 0:\n             return -1\n         \n         s = sum(machines)\n         k = s//n\n         \n         presum = 0\n         right = 0\n         max_net = 0\n         for i in range(n):\n             presum += machines[i]\n             left = -right\n             right = presum - k*(i+1)\n             net = left + right\n             \n             max_net = max(max_net, abs(left), abs(right), net)\n             \n         return max_net\n             \n             \n         \n", "class Solution:\n     def findMinMoves(self, machines):\n         \"\"\"\n         :type machines: List[int]\n         :rtype: int\n         \"\"\"\n         sum_before = [0]\n         i = 0\n         for m in machines:\n             sum_before.append(m + sum_before[i])\n             i+=1\n             \n         if sum_before[len(machines)]%len(machines)!=0:\n             return -1\n         \n         average = int(sum_before[len(machines)]/len(machines))\n         \n         result = 0\n         \n         i = 0\n         for m in machines:\n             left_require = average * i - sum_before[i] \n             right_require = average * (len(machines)-i-1) - (sum_before[len(machines)] - sum_before[i+1])\n             if left_require > 0 and right_require > 0:\n                 max_tran = left_require + right_require\n             else:\n                 max_tran = max(abs(left_require), abs(right_require))\n             result = max(result, max_tran)\n             i+=1\n                 \n         return result", "class Solution:\n     def findMinMoves(self, machines):\n         \"\"\"\n         :type machines: List[int]\n         :rtype: int\n         \"\"\"\n         total = sum(machines)\n         length = len(machines)\n         if total%length!=0:\n             return -1\n         \n         avg = int(total/length)\n         cnt = 0\n         result = 0\n         for m in machines:\n             cnt += m-avg; #load-avg is \"gain/lose\"\n             result = max(result, abs(cnt), m-avg)\n         return result;\n", "class Solution:\n   def findMinMoves(self,machines):\n     s = sum(machines)\n     l = len(machines)\n     if s%l: return -1\n     a, c, ans = int(s/l), 0, 0\n     for x in machines:\n       y = x - a\n       c += y\n       ans = max(ans, y, abs(c))\n     return ans\n     \"\"\"\n     :type machines: List[int]\n     :rtype: int\n     \"\"\"", "class Solution:\n     def __init__(self):\n         pass\n         \n     def findMinMoves(self, machines):\n         \"\"\"\n         :type machines: List[int]\n         :rtype: int\n         \"\"\"\n         \n         N = len(machines)\n         if N == 0:\n             return 0\n         \n         val_sum = sum(machines)\n         if val_sum%N != 0:\n             return -1\n         \n         val_each = val_sum//N\n         \n         go_left, go_right, net_change, max_step = 0, 0, 0, 0\n         for i in range(N):\n             go_left = -go_right\n             go_right = go_right + machines[i] - val_each\n             net_change = go_left + go_right\n             step = max(abs(go_left), abs(go_right), net_change)\n             max_step = max(max_step, step)\n             \n         return max_step"]
["import sys\n\nn, m = [int(x) for x in input().split()]\n\nadj_for = [[] for _ in range(n)]\nadj_back = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = [int(x) for x in sys.stdin.readline().split()]\n    a -= 1\n    b -= 1\n    adj_for[a].append(b)\n    adj_back[b].append(a)\n\n\nlens = [len(adj_back[i]) for i in range(n)]\nstack = [x for x in range(n) if lens[x] == 0]\ntoposort = [x for x in range(n) if lens[x] == 0]\n\nwhile len(stack):\n    cur = stack.pop()\n    for nb in adj_for[cur]:\n        lens[nb] -= 1\n        if lens[nb] == 0:\n            toposort.append(nb)\n            stack.append(nb)\n\nif len(toposort) != n:\n    print(-1)\n    return\n\nmin_above = list(range(n))\nmin_below = list(range(n))\n\nfor i in toposort:\n    for j in adj_back[i]:\n        if min_above[j] < min_above[i]:\n            min_above[i] = min_above[j]\n\nfor i in reversed(toposort):\n    for j in adj_for[i]:\n        if min_below[j] < min_below[i]:\n            min_below[i] = min_below[j]\n\nqt = [\"A\" if min_below[i] == min_above[i] == i else \"E\" for i in range(n)]\n\n# qt = [None for x in range(n)]\n# \n# for i in range(n):\n#     if qt[i] is not None:\n#         continue\n#     qt[i] = 'A'\n#     stack_for = [i]\n#     while len(stack_for):\n#         cur = stack_for.pop()\n#         for nb in adj_for[cur]:\n#             if qt[nb] is None:\n#                 qt[nb] = 'E'\n#                 stack_for.append(nb)\n# \n# \n#     stack_back = [i]\n#     while len(stack_back):\n#         cur = stack_back.pop()\n#         for nb in adj_back[cur]:\n#             if qt[nb] is None:\n#                 qt[nb] = 'E'\n#                 stack_back.append(nb)\n# \nprint(len([x for x in qt if x == 'A']))\nprint(\"\".join(qt))\n", "import collections\nimport sys\ninput=sys.stdin.readline\n\nn,m=map(int,input().split())\nans=['']*(n+1)\ng1=[[] for _ in range(n+1)]\ng2=[[] for _ in range(n+1)]\ndeg=[0]*(n+1)\nfor _ in range(m):\n  a,b=map(int,input().split())\n  g1[a].append(b)\n  g2[b].append(a)\n  deg[a]+=1\nstatus=[0]*(n+1)\nq=collections.deque()\nfor i in range(1,n+1):\n  if deg[i]==0:\n    q.append(i)\nwhile len(q)!=0:\n  v=q.pop()\n  status[v]=1\n  for u in g2[v]:\n    deg[u]-=1\n    if deg[u]==0:\n      q.append(u)\nif status.count(0)>=2:\n  print(-1)\nelse:\n  status1=[0]*(n+1)\n  status2=[0]*(n+1)\n  for i in range(1,n+1):\n    if status1[i]==0 and status2[i]==0:\n      ans[i]='A'\n    else:\n      ans[i]='E'\n    if status1[i]==0:\n      q=collections.deque()\n      q.append(i)\n      while len(q)!=0:\n        v=q.pop()\n        status1[v]=1\n        for u in g1[v]:\n          if status1[u]==0:\n            status1[u]=1\n            q.append(u)\n    if status2[i]==0:\n      q=collections.deque()\n      q.append(i)\n      while len(q)!=0:\n        v=q.pop()\n        status2[v]=1\n        for u in g2[v]:\n          if status2[u]==0:\n            status2[u]=1\n            q.append(u)\n  print(ans.count('A'))\n  print(''.join(map(str,ans[1:])))"]
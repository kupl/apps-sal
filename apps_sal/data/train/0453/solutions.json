["class Solution:\n    def minCost(self, houses: List[int], Cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dfs(i, j, k):\n            if i == len(houses):\n                if j == target:\n                    return 0\n                else:\n                    return float('inf')\n                \n            if houses[i] != 0:\n                return dfs(i + 1, int(houses[i] != k) + j, houses[i])\n            \n            cost = float('inf')\n            for index, c in enumerate(Cost[i]):\n                cost = min(cost, dfs(i + 1, int(index + 1 != k) + j, index + 1) + c)\n                \n            return cost\n        \n        return dfs(0, 0, 0) if dfs(0, 0, 0) != float('inf') else -1\n    \n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        \n        @lru_cache(None)\n        def dp(i, prev, count):\n            if count>target:\n                return float('inf')\n            if i == m:\n                return 0 if count==target else float('inf')\n            \n            return min((cost[i][c-1] if c!=houses[i] else 0)+dp(i+1, c, count+(prev!=c)) for c in range(1,n+1) if not houses[i] or c==houses[i])\n        ans = dp(0, houses[0], 1 if houses[0] else 0)\n        return -1 if ans==float('inf') else ans", "from functools import lru_cache\nimport math\n\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def paint(i, k, color):\n            # print(i, k, color)\n            if k == 1 and i == m:\n                return 0\n            if k == 0 or i == m:\n                return math.inf\n            total_cost = math.inf\n            if houses[i] != 0:\n                if houses[i] == color:\n                    return paint(i + 1, k, color)\n                else:\n                    return paint(i + 1, k - 1, houses[i])\n            for c in range(1, n + 1):\n                kk = k\n                if c != color:\n                    kk -= 1\n                cost_ = cost[i][c - 1] + paint(i + 1, kk, c)    \n                total_cost = min(total_cost, cost_)\n            # print(i, k, color, total_cost)\n            return total_cost\n        \n        res = paint(0, target + 1, -1)\n        return res if res != math.inf else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        #dp[house][target][color]\n        dp = [[[float('inf')]*(n+1) for j in range(target+1)] for i in range(m)]\n        \n        if houses[0] == 0:\n            for idx, c in enumerate(cost[0]):\n                dp[0][1][idx+1] = c\n        else:\n            dp[0][1][houses[0]] = 0\n            \n        for i in range(1, m):\n            if houses[i] != 0:\n                for t in range(1, target+1):\n                    for cidx in range(1, n+1):\n                        pre_cost = dp[i-1][t][cidx]\n                        if pre_cost == float('inf'):\n                            continue\n                        if houses[i] == cidx:\n                            dp[i][t][cidx] = min(dp[i][t][houses[i]], pre_cost)\n                        elif t + 1 <= target:\n                            dp[i][t + 1][houses[i]] = min(dp[i][t+1][houses[i]], pre_cost)\n            else:\n                for t in range(1, target+1):\n                    for cidx in range(1, n+1):\n                        pre_cost = dp[i-1][t][cidx]\n                        if pre_cost == float('inf'):\n                            continue\n                        for cidx2, c in enumerate(cost[i]):\n                            cidx2+=1\n                            if cidx == cidx2:\n                                dp[i][t][cidx2] = min(dp[i][t][cidx2], pre_cost + c)\n                            elif t +1 <= target:\n                                dp[i][t+1][cidx2] = min(dp[i][t+1][cidx2], pre_cost + c)\n        #print(dp)\n        res = float('inf')\n        for cidx in range(1, n+1):\n            res = min(res, dp[-1][target][cidx])\n            \n        if res == float('inf'):\n            return -1\n        return res\n                                \n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        #dp[house][target][color]\n        dp = [[[float('inf')]*(n+1) for j in range(target+1)] for i in range(m)]\n        \n        if houses[0] == 0:\n            for idx, c in enumerate(cost[0]):\n                dp[0][1][idx+1] = c\n        else:\n            dp[0][1][houses[0]] = 0\n            \n        for i in range(1, m):\n            if houses[i] != 0:\n                for t in range(1, target+1):\n                    for cidx in range(1, n+1):\n                        pre_cost = dp[i-1][t][cidx]\n                        if pre_cost == float('inf'):\n                            continue\n                        if houses[i] == cidx:\n                            dp[i][t][cidx] = min(dp[i][t][houses[i]], pre_cost)\n                        elif t + 1 <= target:\n                            dp[i][t + 1][houses[i]] = min(dp[i][t+1][houses[i]], pre_cost)\n            else:\n                for t in range(1, target+1):\n                    for cidx in range(1, n+1):\n                        pre_cost = dp[i-1][t][cidx]\n                        if pre_cost == float('inf'):\n                            continue\n                        for cidx2, c in enumerate(cost[i]):\n                            cidx2+=1\n                            if cidx == cidx2:\n                                dp[i][t][cidx2] = min(dp[i][t][cidx2], pre_cost + c)\n                            elif t +1 <= target:\n                                dp[i][t+1][cidx2] = min(dp[i][t+1][cidx2], pre_cost + c)\n        #print(dp)\n        res = min(dp[-1][target])\n        if res == float('inf'):\n            return -1\n        return res\n                                \n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def recur(index, prev_color, neighbor_count):\n            if index == m:\n                return 0 if neighbor_count == target else float('inf')\n            \n            if houses[index] != 0:                    \n                return recur(index + 1, houses[index], neighbor_count + int(prev_color != houses[index]))\n            \n            total = float('inf')\n            for color in range(1, n + 1):\n                total = min(total, cost[index][color - 1] + recur(index + 1, color, neighbor_count + int(prev_color != color)))\n            return total\n                            \n        final_ans = recur(0, -1, 0)\n        return final_ans if final_ans != float('inf') else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        dp = [[[float('inf') for _ in range (n)] for _ in range(target+1)] for _ in range(m)]\n        for c in range(1, n+1):\n            if houses[0] == 0: dp[0][1][c-1] = cost[0][c-1]\n            elif houses[0] == c: dp[0][1][c-1] = 0\n        for i in range(1, m):\n            for k in range (1, min(i+1,target)+1):\n                for c in range(1, n+1):\n                        prev = min (dp[i-1][k][c-1], min([dp[i-1][k-1][c_-1] for c_ in range(1, n+1) if c_ != c]))\n                        if houses[i]==0 or houses[i]==c:\n                            dp[i][k][c-1] = prev + cost[i][c-1] *(houses[i] == 0)\n        res = min(dp[-1][-1])\n        return -1 if res == float('inf') else res\n                \n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        maxc = 10**9\n        N = len(houses)\n        dp = [[[None]*(target+1) for _ in range(n+1)] for _ in range(m)]\n        \n        def solve(i,j,k):\n            if k < 0: return maxc\n            if dp[i][j][k] is None:\n                if i == N - 1:\n                    if k != 0:\n                        dp[i][j][k] = maxc\n                    else:\n                        if houses[i] == 0:\n                            dp[i][j][k] = cost[i][j-1]\n                        else:\n                            dp[i][j][k] = 0\n                else:\n                    dp[i][j][k] = cost[i][j-1] if houses[i] == 0 else 0\n                    if houses[i+1] == 0:\n                        dp[i][j][k] += min([solve(i+1, jj, k-1 if jj != j else k) for jj in range(1, n+1)])\n                    elif houses[i+1] == j:\n                        dp[i][j][k] += solve(i+1, j, k)\n                    else:\n                        dp[i][j][k] += solve(i+1, houses[i+1], k-1)\n            return dp[i][j][k]\n        \n        if houses[0] == 0:\n            result = min([solve(0, j, target-1) for j in range(1, n+1)])\n        else:\n            result = solve(0, houses[0], target-1)\n        \n        return result if result < maxc else -1\n", "from functools import lru_cache\nimport math\n\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def paint(i, color, k):\n            # print(i, k, color)\n            if k == 0 and i == m:\n                return 0\n            if k < 0 or i == m:\n                return math.inf\n            total_cost = math.inf\n            if houses[i] != 0:\n                return paint(i + 1, houses[i], k - (1 if houses[i] != color else 0))\n            for c in range(1, n + 1):\n                cost_ = cost[i][c - 1] + paint(i + 1, c, k - (1 if c != color else 0))    \n                total_cost = min(total_cost, cost_)\n            # print(i, k, color, total_cost)\n            return total_cost\n        \n        # neighbors = 0\n        # prev = 0\n        # for h in houses:\n        #     if h == 0: \n        #         continue\n        #     if h != prev:\n        #         neighbors += 1\n        #         prev = h\n        # if neighbors > target:\n        #     return -1\n        res = paint(0, -1, target)\n        return res if res != math.inf else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        # dp[i][c][k]: i means the ith house, c means the cth color, k means k neighbor groups\n        dp = [[[math.inf for _ in range(n)] for _ in range(target + 1)] for _ in range(m)]\n        \n        for c in range(1, n + 1):\n            if houses[0] == c: dp[0][1][c - 1] = 0\n            elif not houses[0]: dp[0][1][c - 1] = cost[0][c - 1]\n                \n        for i in range(1, m):\n            for k in range(1, min(target, i + 1) + 1):\n                for c in range(1, n + 1):\n                    if houses[i] and c != houses[i]: continue\n                    same_neighbor_cost = dp[i - 1][k][c - 1]\n                    diff_neighbor_cost = min([dp[i - 1][k - 1][c_] for c_ in range(n) if c_ != c - 1] or [math.inf])\n                    paint_cost = cost[i][c - 1] * (not houses[i])\n                    dp[i][k][c - 1] = min(same_neighbor_cost, diff_neighbor_cost) + paint_cost\n        res = min(dp[-1][-1])\n        return res if res < math.inf else -1\n            \n        \n        \n        \n", "class Solution:\n    def minCost(self, houses: List[int], costs: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def helper(hIdx, prevColor, groups):\n            if hIdx == m:\n                return 0 if groups == target else float('inf')\n            if houses[hIdx]: # painted\n                return helper(hIdx + 1, houses[hIdx], groups + int(houses[hIdx] != prevColor))\n            total = float('inf')\n            for c in range(1, n+1):\n                total = min(total, costs[hIdx][c-1] + helper(hIdx+1, c, groups + int(c != prevColor)))\n            return total\n        \n        res = helper(0, 0, 0)\n        return res if res < 10 ** 9 else -1\n", "# k: num of neighborhoods, i: num of houses, c: color of the last house\n# dp[k][i][c]: min cost to form k neighborhoods using the first i houses and the i-th house's color is c\n# init: dp[0][0][*] = 0, else is inf\n# if the i - 1 house's color != i house's color, means they are not in the same neighborhood\n# dp[k][i][ci] = dp[k - 1][i - 1][ci-1] + cost\n# else if the i - 1house's color == i house's color, means they are in the same neighborhood\n# dp[k][i][ci] = dp[k][i - 1][ci-1] + cost\n# if houses[i] == ci, house i is painted by color i, cost = 0, no need to paint\n# else, cost = cost[i][ci]\n# if ci != houses[i], means house i is painted by another color, dp[k][i][ci] = inf\n# ans = min(dp[target][m][*])\n# \u56e0\u4e3a\u9700\u8981\u679a\u4e3e\u6240\u6709\u7684 house i - 1 \u548c house i \u7684\u989c\u8272\u7684\u7ec4\u5408, \u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u4e58\u4ee5 n * n\n# \u56e0\u4e3a dp[k] \u53ea\u548c dp[k] \u548c dp[k - 1] \u6709\u5173, \u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u4ece O(target * m * n) -> O(m * n)\n# O(target * m * n * n) time compleixty, O(m * n) space complexity\nclass Solution:\n    def minCost(self, houses: List[int], costs: List[List[int]], m: int, n: int, target: int) -> int:\n        dp = [[[float('inf') for _ in range(n + 1)] for _ in range(m + 1)] for _ in range(target + 1)]\n        for c in range(n + 1):\n            dp[0][0][c] = 0\n\n        for k in range(1, target + 1):\n            for i in range(k, m + 1):  # \u56e0\u4e3a i < k \u7684\u60c5\u51b5\u4e0d\u5408\u6cd5, \u7ec4\u6210 k \u4e2a neighborhoods \u81f3\u5c11\u4e5f\u9700\u8981 k \u4e2a house\n                hi = houses[i - 1]\n                hj = 0  # \u521d\u59cb\u5316\u524d\u4e00\u4e2a\u623f\u5b50\u7684\u989c\u8272\u4e3a 0, \u5982\u679c i < 2, \u5219\u5b83\u5c31\u662f\u7b2c\u4e00\u4e2a\u623f\u5b50, \u6240\u4ee5\u8bbe\u524d\u4e00\u4e2a\u623f\u5b50\u53ef\u4ee5\u662f\u4efb\u4f55\u989c\u8272\u7684, \u5373 0\n                if i >= 2:\n                    hj = houses[i - 2]\n                for ci in range(1, n + 1):\n                    if hi != 0 and hi != ci:\n                        dp[k][i][ci] = float('inf')\n                        continue\n                    cost = 0\n                    if hi != ci:\n                        cost = costs[i - 1][ci - 1]\n                    for cj in range(1, n + 1):\n                        dp[k][i][ci] = min(dp[k][i][ci], dp[k - (ci != cj)][i - 1][cj] + cost)\n        \n        res = min(dp[target][m][c] for c in range(1, n + 1))\n        if res == float('inf'):\n            return -1\n        return res\n", "# https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-1473-paint-house-iii/\n# k: num of neighborhoods, i: num of houses, c: color of the last house\n# dp[k][i][c]: min cost to form k neighborhoods using the first i houses and the i-th house's color is c\n# init: dp[0][0][*] = 0, else is inf\n# if the i - 1 house's color != i house's color, means they are not in the same neighborhood\n# dp[k][i][ci] = dp[k - 1][i - 1][ci-1] + cost\n# else if the i - 1house's color == i house's color, means they are in the same neighborhood\n# dp[k][i][ci] = dp[k][i - 1][ci-1] + cost\n# if houses[i] == ci, house i is painted by color i, cost = 0, no need to paint\n# else, cost = cost[i][ci]\n# if ci != houses[i], means house i is painted by another color, dp[k][i][ci] = inf\n# ans = min(dp[target][m][*])\n# \u56e0\u4e3a\u9700\u8981\u679a\u4e3e\u6240\u6709\u7684 house i - 1 \u548c house i \u7684\u989c\u8272\u7684\u7ec4\u5408, \u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u4e58\u4ee5 n * n\n# \u56e0\u4e3a dp[k] \u53ea\u548c dp[k] \u548c dp[k - 1] \u6709\u5173, \u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u4ece O(target * m * n) -> O(m * n)\n# O(target * m * n * n) time compleixty, O(m * n) space complexity\nclass Solution:\n    def minCost(self, houses: List[int], costs: List[List[int]], m: int, n: int, target: int) -> int:\n        dp = [[[float('inf') for _ in range(n + 1)] for _ in range(m + 1)] for _ in range(target + 1)]\n        for c in range(n + 1):\n            dp[0][0][c] = 0\n\n        for k in range(1, target + 1):\n            for i in range(k, m + 1):  # \u56e0\u4e3a i < k \u7684\u60c5\u51b5\u4e0d\u5408\u6cd5, \u7ec4\u6210 k \u4e2a neighborhoods \u81f3\u5c11\u4e5f\u9700\u8981 k \u4e2a house\n                hi = houses[i - 1]\n                hj = 0  # \u521d\u59cb\u5316\u524d\u4e00\u4e2a\u623f\u5b50\u7684\u989c\u8272\u4e3a 0, \u5982\u679c i < 2, \u5219\u5b83\u5c31\u662f\u7b2c\u4e00\u4e2a\u623f\u5b50, \u6240\u4ee5\u8bbe\u524d\u4e00\u4e2a\u623f\u5b50\u53ef\u4ee5\u662f\u4efb\u4f55\u989c\u8272\u7684, \u5373 0\n                if i >= 2:\n                    hj = houses[i - 2]\n                for ci in range(1, n + 1):\n                    if hi != 0 and hi != ci:  # \u5f53\u8fd9\u4e2a\u623f\u5b50 i \u5df2\u7ecf\u6709\u989c\u8272\u4e14\u4e0d\u662f\u5f53\u524d\u60f3\u7ed9\u5b83\u7684\u989c\u8272\u65f6, \u76f4\u63a5\u8df3\u8fc7\n                        dp[k][i][ci] = float('inf')\n                        continue\n                    cost = 0  # \u5982\u679c\u8fd9\u4e2a\u623f\u5b50\u5df2\u7ecf\u6709\u989c\u8272\u4e14\u548c\u5f53\u524d\u60f3\u7ed9\u5b83\u7684\u989c\u8272\u4e00\u6837, cost \u4e3a 0\n                    if hi != ci:  # \u5982\u679c\u8fd9\u4e2a\u623f\u5b50\u6ca1\u6709\u989c\u8272, cost \u4e3a costs \u77e9\u9635\u4e2d\u7684\u503c\n                        cost = costs[i - 1][ci - 1]\n                    for cj in range(1, n + 1):\n                        dp[k][i][ci] = min(dp[k][i][ci], dp[k - (ci != cj)][i - 1][cj] + cost)\n        \n        res = min(dp[target][m][c] for c in range(1, n + 1))\n        if res == float('inf'):\n            return -1\n        return res\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        memo = {}\n        \n        @lru_cache(None)\n        def dfs(i, k, t):\n            \n            if t < 0 and t > m-i:\n                return float('inf')\n            \n            if m == i:\n                return 0 if t == 0 else float('inf')\n            \n            if (i, k, t) not in memo:\n                if houses[i]:\n                    memo[i,k,t] = dfs(i+1, houses[i], t - int(houses[i] != k))\n                else:\n                    \n                    memo[i,k,t] = min(cost[i][j-1] + dfs(i+1, j, t - int(j != k)) for j in range(1, n+1))\n            return memo[i,k,t]\n        \n        ans = dfs(0, 0, target)\n        return ans if ans != float('inf') else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        memo = [[[-1 for i in range(m+1)] for j in range(n+1)] for _ in range(m+1)]\n        def dp(i, prevColor, nbrs):\n            if nbrs > target : return float('inf')\n            if i == m:\n                if nbrs == target: return 0\n                else: return float('inf')\n            \n            if memo[i][prevColor][nbrs] != -1: return memo[i][prevColor][nbrs]\n            ans = float('inf')\n            if houses[i] == 0:\n                for j in range(n):\n                    if j+1 == prevColor:\n                        temp = dp(i+1, j+1, nbrs)\n                    else:\n                        temp = dp(i+1, j+1, nbrs+1)\n                    ans = min(ans, cost[i][j]+ temp)\n            else:\n                if prevColor == houses[i]:\n                    ans = min(ans, dp(i+1, houses[i], nbrs))\n                else:\n                    ans = min(ans, dp(i+1, houses[i], nbrs+1))\n            memo[i][prevColor][nbrs] = ans\n            return ans\n        ans = dp(0,0,0)\n        if ans == float('inf'): return -1\n        else: return ans\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        # dp[color][blocks]\n        \n        dp, dp2 = {(0, 0): 0}, {}\n        \n        for index, house in enumerate(houses):\n            for cj in (range(1, n + 1) if house == 0 else [house]):\n                for ci, b in dp:\n                    b2 = b + (ci != cj)\n                    if b2 > target:\n                        continue\n                    dp2[cj, b2] = min(dp2.get((cj, b2), float('inf')), dp[ci, b] + (cost[index][cj-1] if cj != house else 0))\n            dp, dp2 = dp2, {}\n        return min([dp[c, b] for c, b in dp if b == target] or [-1])", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        if n == 1 and target >= 2: return -1\n        if target > m: return -1\n        \n        c = 0\n        p = -1\n        for i in range(m):\n            if houses[i] > 0 and houses[i] != p:\n                c += 1\n                p = houses[i]\n        if c > target:\n            return -1\n        \n        cache = {}\n        MAX_VAL = float('inf')\n        \n        def process(i, p, t):\n            if t < 0:\n                return MAX_VAL\n            if i == m:\n                if t == 0:\n                    return 0\n                else:\n                    return MAX_VAL\n            else:\n                if not (i, p, t) in cache:\n                    ans = MAX_VAL\n                    if houses[i] > 0:\n                        if houses[i] == p:\n                            ans = process(i+1, p, t)\n                        else:\n                            ans = process(i+1, houses[i], t-1)\n                    else:\n                        ans = MAX_VAL\n                        for j in range(n):\n                            if p == j+1:\n                                ans = min(ans, cost[i][j] + process(i+1, p, t))\n                            else:\n                                ans = min(ans, cost[i][j] + process(i+1, j+1, t-1))\n                    cache[(i, p, t)] = ans\n            return cache[(i, p, t)]\n        \n        x = process(0, -1, target)\n        return x if x != MAX_VAL else -1\n            \n            \n            \n            \n            \n            \n        \n        \n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        # dp[color][target]\n        dp = {(0,0):0}\n        for i in range(len(houses)):\n            tmp = {}\n            color = range(1, n+1) if houses[i] == 0 else [houses[i]]\n            for curr in color:\n                for prev, j in dp:\n                    t = j if curr == prev else j+1\n                    if t > target:\n                        continue\n                    tmp[curr,t] = min(tmp.get((curr, t), float('inf')), dp[prev, j]+(cost[i][curr-1] if curr != houses[i] else 0))\n            dp = tmp\n        return min([dp[c, b] for c, b in dp if b == target] or [-1])", "class Solution:\n        def minCost(self, A, cost, m, n, target):\n            dp, dp2 = {(0, 0): 0}, {}\n            for i, a in enumerate(A):\n                for cj in (list(range(1, n + 1)) if a == 0 else [a]):\n                    for ci, b in dp:\n                        b2 = b + (ci != cj)\n                        if b2 > target: continue\n                        dp2[cj, b2] = min(dp2.get((cj,b2), float('inf')), dp[ci, b] + (cost[i][cj - 1] if cj != a else 0))\n                dp, dp2 = dp2, {}\n            return min([dp[c, b] for c, b in dp if b == target] or [-1])\n        \n        \n                            \n", "class Solution:\n  def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n    # TC: O(MNNT), SC: (NT)\n    # dp: (n-color, t-blocks): min-cost\n    dp0, dp1 = {(0, 0): 0}, {}\n    for i, k in enumerate(houses):\n      # assume painted houses can NOT be repainted..\n      for ik in ([k] if k > 0 else range(1, n + 1)):\n        # previous color and blocks\n        for pk, pb in dp0:\n          bb = pb + (ik != pk)\n          if bb > target:\n            continue\n          dp1[ik, bb] = min(dp1.get((ik, bb), float('inf')), dp0[pk, pb] + (0 if k > 0 else cost[i][ik - 1]))\n      dp0, dp1 = dp1, {}\n    return min([dp0[k, b] for k, b in dp0 if b == target] or [-1])", "from functools import lru_cache\nimport math\n\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def paint(i, k, color):\n            # print(i, k, color)\n            if k == 1 and i == m:\n                return 0\n            if k == 0 or i == m:\n                return math.inf\n            total_cost = math.inf\n            if houses[i] != 0:\n                if houses[i] != color:\n                    k -= 1\n                return paint(i + 1, k, houses[i])\n            for c in range(1, n + 1):\n                kk = k\n                if c != color:\n                    kk -= 1\n                cost_ = cost[i][c - 1] + paint(i + 1, kk, c)    \n                total_cost = min(total_cost, cost_)\n            # print(i, k, color, total_cost)\n            return total_cost\n        \n        # neighbors = 0\n        # prev = 0\n        # for h in houses:\n        #     if h == 0: \n        #         continue\n        #     if h != prev:\n        #         neighbors += 1\n        #         prev = h\n        # if neighbors > target:\n        #     return -1\n        res = paint(0, target + 1, -1)\n        return res if res != math.inf else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        houses = [c - 1 for c in houses]\n        ans = [[[float('inf') for k in range(target+1)] for j in range(n)] for i in range(m)]\n        \n        \n        for j in range(n):\n            if houses[0] == -1:\n                ans[0][j][1] = cost[0][j]\n            else:\n                ans[0][houses[0]][1] = 0\n\n        for i in range(1, m):\n            if houses[i] == -1:\n                for j in range(n):\n                    for l in range(n):\n                        for k in range(1, min(target+1, i+2)):\n                            if j == l:\n                                ans[i][j][k] = min(ans[i][j][k], ans[i-1][j][k] + cost[i][j])\n                            else:\n                                ans[i][j][k] = min(ans[i][j][k], ans[i-1][l][k-1] + cost[i][j])\n            else:\n                for k in range(1, min(target+1, i+2)):\n                    for l in range(n):\n                        if houses[i] == l:\n                            ans[i][houses[i]][k] = min(ans[i][houses[i]][k], ans[i-1][l][k])\n                        else:\n                            ans[i][houses[i]][k] = min(ans[i][houses[i]][k], ans[i-1][l][k-1])\n                            \n        res = float('inf')\n        for j in range(n):\n            res = min(res, ans[m-1][j][target])\n        if res == float('inf'):\n            res = -1\n        return res\n            \n        \n        \n        \n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        dp, dp2 = {(0, 0): 0}, {}\n        for i, a in enumerate(houses):\n            for cj in (range(1, n + 1) if a == 0 else [a]):\n                for ci, b in dp:\n                    b2 = b + (ci != cj)\n                    if b2 > target: continue\n                    dp2[cj, b2] = min(dp2.get((cj, b2), float('inf')), dp[ci, b] + (cost[i][cj - 1] if cj != a else 0))\n            dp, dp2 = dp2, {}\n        return min([dp[c, b] for c, b in dp if b == target] or [-1])", "class Solution:\n    def minCost(self, A, cost, m, n, target):\n        dp, dp2 = {(0, 0): 0}, {}\n        for i, a in enumerate(A):\n            for cj in (list(range(1, n + 1)) if a == 0 else [a]):\n                for ci, b in dp:\n                    b2 = b + (ci != cj)\n                    if b2 > target: continue\n                    dp2[cj, b2] = min(dp2.get((cj,b2), float('inf')), dp[ci, b] + (cost[i][cj - 1] if cj != a else 0))\n            dp, dp2 = dp2, {}\n        return min([dp[c, b] for c, b in dp if b == target] or [-1])\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        A=houses\n        dp, dp2 = {(0, 0): 0}, {}\n        for i, a in enumerate(A):\n            for cj in (range(1, n + 1) if a == 0 else [a]):\n                for ci, b in dp:\n                    b2 = b + (ci != cj)\n                    if b2 > target: continue\n                    dp2[cj, b2] = min(dp2.get((cj,b2), float('inf')), dp[ci, b] + (cost[i][cj - 1] if cj != a else 0))\n            dp, dp2 = dp2, {}\n        return min([dp[c, b] for c, b in dp if b == target] or [-1])", "class Solution:\n    def minCost(self, A, cost, m, n, target):\n        dp = {(0, 0): 0}\n        for i, a in enumerate(A):\n            dp2 = {}\n            for cj in (range(1, n + 1) if a == 0 else [a]):\n                for ci, b in dp:\n                    b2 = b + (ci != cj)\n                    if b2 > target: \n                        continue\n                    dp2[cj, b2] = min(dp2.get((cj,b2), float('inf')), dp[ci, b] + (cost[i][cj - 1] if cj != a else 0))\n            dp = dp2\n        return min([dp[c, b] for c, b in dp if b == target] or [-1])", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        dp = {(0, 0) : 0}\n        dp2 = {}\n        # dp (x,y) = z, x is the color, y is the number of neighbors and z is the min cost we get so far\n        \n        for index, house in enumerate(houses):\n            for color in (list(range(1, n + 1)) if house == 0 else [house]):\n                for preColor, block in dp:\n                    newBlock = 0\n                    if preColor == color:\n                        newBlock = block\n                    else:\n                        newBlock = block + 1 \n                    if newBlock > target:\n                        continue \n                    dp2[(color, newBlock)] = min(dp2.get((color, newBlock), float('inf')),  dp[(preColor, block)] + (cost[index][color - 1] if color != house else 0))\n            dp, dp2 = dp2, {}\n        \n            print(dp)\n        return min([dp[(i,color)] for i, color in dp if color == target] or [-1])\n                \n        \n\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        dp = []\n        for i in range(m):\n            dp.append([[-1]*(n+1) for _ in range(m+1)])\n        for i in range(m):\n            for j in range(1, i+2):\n                for k in range(1, n+1):\n                    if i == 0:\n                        if houses[0] == 0:\n                            dp[0][1][k] = cost[0][k-1]\n                        elif houses[0] == k:\n                            dp[0][1][k] = 0\n                    else:\n                        if houses[i] == 0:\n                            options = []\n                            for last_color in range(1, n+1):\n                                if last_color == k:\n                                    if dp[i-1][j][k] != -1:\n                                        options.append(cost[i][k-1] + dp[i-1][j][k])\n                                else:\n                                    if dp[i-1][j-1][last_color] != -1:\n                                        options.append(cost[i][k-1] + dp[i-1][j-1][last_color])\n                            if len(options) != 0:\n                                dp[i][j][k] = min(options)\n                        elif houses[i] == k:\n                            options = []\n                            for last_color in range(1, n+1):\n                                if last_color == k:\n                                    if dp[i-1][j][k] != -1:\n                                        options.append(dp[i-1][j][k])\n                                else:\n                                    if dp[i-1][j-1][last_color] != -1:\n                                        options.append(dp[i-1][j-1][last_color])\n                            if len(options) != 0:\n                                dp[i][j][k] = min(options)\n        #print(dp)\n        costs = list([x for x in dp[m-1][target] if x!=-1])\n        if len(costs) == 0:\n            return -1\n        else:\n            return min(costs)\n                            \n", "from functools import lru_cache\nimport math\n\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        MAX_COST = 10 ** 7\n        \n        @lru_cache(None)\n        def paint(i, color, k):\n            # print(i, k, color)\n            if k == 0 and i == m:\n                return 0\n            if k < 0 or i == m:\n                return MAX_COST\n            if m - i < k - 1:\n                return MAX_COST\n            if houses[i] != 0:\n                return paint(i + 1, houses[i], k - (1 if houses[i] != color else 0))\n            return min((cost[i][c - 1] + paint(i + 1, c, k - (1 if c != color else 0)) for c in range(1, n + 1)))\n            # print(i, k, color, total_cost)\n            # return total_cost\n        \n        # neighbors = 0\n        # prev = 0\n        # for h in houses:\n        #     if h == 0: \n        #         continue\n        #     if h != prev:\n        #         neighbors += 1\n        #         prev = h\n        # if neighbors > target:\n        #     return -1\n        res = paint(0, -1, target)\n        return res if res < MAX_COST else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        def dp(i, color, target):\n            if target < 0: return float('inf')\n            if cache[i][color][target] < 0:\n                if houses[i] > 0 and color != houses[i] - 1:\n                    cache[i][color][target] = float('inf')\n                elif i == m - 1:\n                    if target > 0:\n                        cache[i][color][target] = float('inf')\n                    else:\n                        cache[i][color][target] = cost[i][color] if houses[i] == 0 else 0\n                else:\n                    cost1 = cost[i][color] if houses[i] == 0 else 0\n                    cost2 = min(dp(i+1, c, target - int(c != color)) for c in range(n))\n                    cache[i][color][target] = cost1 + cost2\n            return cache[i][color][target]\n        \n        cache = [[[-1] * target for _ in range(n)] for _ in range(m)]\n        res = min(dp(0, c, target-1) for c in range(n))\n        return -1 if res == float('inf') else res", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        memo = {}\n        def dfs(idx, groups, prev_color):\n            nonlocal target, m, n\n            if (idx, groups, prev_color) in memo:\n                return memo[(idx, groups, prev_color)]\n            if groups > target:\n                return sys.maxsize \n            if idx == len(houses):\n                if groups == target:\n                    return 0\n                return sys.maxsize \n            else:\n                if houses[idx] != 0:\n                    return dfs(idx + 1, groups + (1 if houses[idx] != prev_color else 0), houses[idx])\n                else:\n                    low = sys.maxsize\n                    for i in range(n):\n                        low = min(low,cost[idx][i] + dfs(idx + 1, groups + (1 if (i + 1) != prev_color else 0), i + 1))\n                    memo[(idx, groups, prev_color)] = low\n                    return memo[(idx, groups, prev_color)]\n        ans = dfs(0, 0, -1)\n        return -1 if ans == sys.maxsize else ans", "from functools import lru_cache\nimport math\n\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def paint(i, k, color):\n            # print(i, k, color)\n            if k == 1 and i == m:\n                return 0\n            if k == 0 or i == m:\n                return math.inf\n            total_cost = math.inf\n            if houses[i] != 0:\n                if houses[i] != color:\n                    k -= 1\n                return paint(i + 1, k, houses[i])\n            for c in range(1, n + 1):\n                kk = k\n                if c != color:\n                    kk -= 1\n                cost_ = cost[i][c - 1] + paint(i + 1, kk, c)    \n                total_cost = min(total_cost, cost_)\n            # print(i, k, color, total_cost)\n            return total_cost\n        \n        neighbors = 0\n        prev = 0\n        for h in houses:\n            if h == 0: \n                continue\n            if h != prev:\n                neighbors += 1\n                prev = h\n        if neighbors > target:\n            return -1\n        res = paint(0, target + 1, -1)\n        return res if res != math.inf else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, t: int) -> int:\n        mem={}\n        \n        def recurse(i,lastc,target):\n            if target<0:\n                return float('inf')\n            if i==m:\n                return float('inf') if target!=0 else 0\n            if (i,lastc,target) not in mem:\n                if houses[i]>0:\n                    mem[(i,lastc,target)]=recurse(i+1,houses[i],target-1 if lastc!=houses[i] else target)\n                else:\n                    if lastc>0:\n                        mem[(i,lastc,target)]=recurse(i+1,lastc,target)+cost[i][lastc-1]\n                    else:\n                        mem[(i,lastc,target)]=float('inf')\n                    for j in range(1,n+1):\n                        if j!=lastc:\n                            mem[(i,lastc,target)]=min(recurse(i+1,j,target-1)+cost[i][j-1],mem[(i,lastc,target)])\n            return mem[(i,lastc,target)]\n        \n        result=recurse(0,0,t)\n        # print(mem)\n        if result==float('inf'):\n            return -1\n        return result", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        dp={}\n        def dfs(i, t, p):\n            key = (i, t, p)\n            \n            if i == len(houses):\n                return 0 if t == 0 else float('inf')\n            if key not in dp:                \n                if houses[i] == 0:\n                    dp[key] = min(dfs(i+1, t-(p != nc), nc)+cost[i][nc-1] for nc in range(1, n+1))\n                else:\n                    dp[key] = dfs(i+1, t-(p != houses[i]), houses[i])\n            return dp[key]\n        ret =  dfs(0, target, -1)\n        return -1 if  ret == float('inf') else ret\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        '''\n        houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n        Output: 9\n        \n        [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n        \n        if cur_t == target: same as pre\n        if cur_t < target: new or same as pre\n        \n        dp(i, cur_t) = \n        if memo\n        res = float('inf')\n        if i == len(houses):\n            if cur_t == target: return 0\n            else: return res\n        if cur_t > target: return res\n        \n        if houses[i] != 0:\n            if i>0 and houses[i] == houses[i-1]:\n                res = dp(i+1, cur_t)\n            else: res = dp(i+1, cur_t+1)\n        else:\n            for color in range(1,n+1):\n                if i>0 and color = houses[i-1]:\n                    houses[i] = color\n                    res = min(res, cost[i][color-1] + dp(i+1, cur_t))\n                    houses[i] = 0\n                else:\n                    houses[i] = color\n                    res = min(res, cost[i][color-1] + dp(i+1, cur_t+1))\n                    houses[i] = 0\n            \n        \n        \n        '''\n        memo = {}\n        def dp(i, pre_col, cur_t):\n            # print(i, cur_t)\n            res = float('inf')\n            if i == len(houses):\n                if cur_t == 0: return 0\n                else: return res\n            if cur_t < 0: return res\n            if (i, pre_col,cur_t) in memo.keys(): return memo[(i, pre_col,cur_t)]\n            \n            if houses[i] != 0:\n                if i>0 and houses[i] == pre_col:\n                    res = dp(i+1, pre_col, cur_t)\n                else: res = dp(i+1, houses[i], cur_t-1)\n            else:\n                for color in range(1,n+1):\n                    if i>0 and color == pre_col:\n                        # houses[i] = color\n                        res = min(res, cost[i][color-1] + dp(i+1, pre_col,cur_t))\n                        # houses[i] = 0\n                    else:\n                        # houses[i] = color\n                        res = min(res, cost[i][color-1] + dp(i+1,color, cur_t-1))\n                        # houses[i] = 0\n            memo[(i,pre_col, cur_t)] = res\n            return res\n        ans = dp(0, houses[0],target)\n        return ans if ans != float('inf') else -1", "class Solution:\n    def minCost(self, A, cost, m, n, target):\n        dp, dp2 = {(0, 0): 0}, {}\n        for i, a in enumerate(A):\n            for cj in (range(1, n + 1) if a == 0 else [a]):\n                for ci, b in dp:\n                    b2 = b + (ci != cj)\n                    if b2 > target: continue\n                    dp2[cj, b2] = min(dp2.get((cj,b2), float('inf')), dp[ci, b] + (cost[i][cj - 1] if cj != a else 0))\n            dp, dp2 = dp2, {}\n        return min([dp[c, b] for c, b in dp if b == target] or [-1])", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, t: int) -> int:\n        mem={}\n        \n        def recurse(i,lastc,target):\n            if target<0:\n                return float('inf')\n            if i==m:\n                return float('inf') if target!=0 else 0\n            if houses[i]>0:\n                return recurse(i+1,houses[i],target-1 if lastc!=houses[i] else target)\n            if (i,lastc,target) not in mem:\n                if lastc>0:\n                    mem[(i,lastc,target)]=recurse(i+1,lastc,target)+cost[i][lastc-1]\n                else:\n                    mem[(i,lastc,target)]=float('inf')\n                for j in range(1,n+1):\n                    if j!=lastc:\n                        mem[(i,lastc,target)]=min(recurse(i+1,j,target-1)+cost[i][j-1],mem[(i,lastc,target)])\n            return mem[(i,lastc,target)]\n        \n        result=recurse(0,0,t)\n        # print(mem)\n        if result==float('inf'):\n            return -1\n        return result", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        dp={}\n        def dfs(i, t, p):\n            key = (i, t, p)            \n            if i == len(houses) or t<0:\n                return 0 if t == 0 else float('inf')\n            if key not in dp:                \n                if houses[i] == 0:\n                    dp[key] = min(dfs(i+1, t-(p != nc), nc)+cost[i][nc-1] for nc in range(1, n+1))\n                else:\n                    dp[key] = dfs(i+1, t-(p != houses[i]), houses[i])\n            return dp[key]\n        ret =  dfs(0, target, -1)\n        return -1 if  ret == float('inf') else ret\n", "dp = [[[0]*102 for j in range(23)] for i in range(102)]\ndef dfs(i,house,cost,prev,tar):\n    if i>=len(house):\n        if tar==0:\n            return 0\n        else:\n            return 1000000000000\n    if tar<0:\n        return 1000000000000\n    if(dp[i][prev][tar]>0):\n        return dp[i][prev][tar]\n    res = 1000000000000000000\n    if house[i]==0:\n        for j in range(len(cost[i])):\n            res = min(res , cost[i][j] + dfs(i+1,house,cost,j+1,tar - ((j+1)!=prev)))\n    else:\n        res = min(res , dfs(i+1,house,cost,house[i],tar- (house[i]!=prev)))\n    #print(i,prev,tar,res)\n    dp[i][prev][tar]=res\n    return dp[i][prev][tar]\nclass Solution:\n    def minCost(self, house: List[int], cost: List[List[int]], m: int, n: int, tar: int) -> int:\n        for i in range(101):\n            for j in range(21):\n                for k in range(101):\n                    dp[i][j][k]=0\n        res = dfs(0,house,cost,n+1,tar)\n        #for i in dp:\n        #    print(i)\n        if res>=1000000000000:\n            return -1\n        else:\n            return res\n        \n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def min_cost_helper(i, prev_color, groups):\n            if i == m:\n                return 0 if groups == target else float('inf')\n            \n            if houses[i] != 0:\n                return min_cost_helper(i + 1, houses[i], groups + int(prev_color != houses[i]))\n            \n            total = float('inf')\n            for color in range(1, n + 1):\n                total = min(total, cost[i][color - 1] + min_cost_helper(i + 1, color, groups + int(prev_color != color)))\n            \n            return total\n        \n        ans = min_cost_helper(0, -1, 0)\n        return ans if ans != float('inf') else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dp(i, g, p):\n            if i == m:\n                return 0 if g == 0 else float('inf')\n            if m - i < g:\n                return float('inf')\n            if houses[i]:\n                return dp(i + 1, g - (p != houses[i]), houses[i])\n            else:\n                return min(dp(i + 1, g - (p != nc), nc) + cost[i][nc - 1] for nc in range(1, n + 1))\n        \n        ret = dp(0, target, -1)\n        return ret if ret != float('inf') else -1\n            \n        \n        \n#         dp = [[[float('inf') for _ in range(target + 1)] for _ in range(1 + n)] for _ in range(m)]\n#         if houses[0] != 0:\n#             dp[0][houses[0]][1] = 0\n#         else:\n#             for i in range(1, n + 1):\n#                 dp[0][i][1] = cost[0][i - 1]\n        \n#         for house in range(1, m):\n#             if houses[house] > 0:\n#                 for neigh in range(1, target + 1):\n#                     c1= houses[house]\n#                     dp[house][c1][neigh] = min(min(dp[house - 1][c2][neigh - 1] for c2 in range(1, n + 1) if c2 != c1), dp[house - 1][c1][neigh])\n#                 continue\n#             for c1 in range(1, n + 1):\n#                 for neigh in range(1, target + 1):\n#                     for c2 in range(1, n + 1):\n#                         if c1 == c2:\n#                             dp[house][c1][neigh] = min(dp[house][c1][neigh], dp[house - 1][c2][neigh] + cost[house][c1 - 1])\n#                         else:\n#                             dp[house][c1][neigh] = min(dp[house][c1][neigh], dp[house - 1][c2][neigh - 1] + cost[house][c1 - 1])\n#         ans = min(k[target] for k in dp[-1])  \n#         return ans if ans != float('inf') else -1\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        m_ = {}\n        \n        def dp(i, t, color):\n            key =  (i, t, color)\n            if key in m_: return m_[key]\n            if t == 0 and i == len(houses): return 0\n            if t < 0 or t > m - i: return float('inf')\n            if houses[i] == 0:\n                m_[key] = min(dp(i + 1, t - (c != color), c) + cost[i][c - 1] for c in range(1, n + 1))\n            else:\n                m_[key] = dp(i + 1, t - (houses[i] != color), houses[i])\n            \n            return m_[key]\n        \n        ans = dp(0, target, -1)\n        \n        return ans if ans < float('inf') else -1", "from functools import lru_cache\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dp(g, i, c):\n            if g > target or target - g > m - i: return sys.maxsize\n            if i == m: return 0 if g == target else sys.maxsize \n            ans = sys.maxsize \n            if houses[i] != 0:\n                ans = min(ans, dp(g + (houses[i]!=c), i+1, houses[i]))\n            else:\n                for j in range(n):\n                    ans = min(ans, cost[i][j] + dp(g + (j+1!=c), i+1, j+1))\n            return ans\n        \n        ans = dp(0, 0, 0)\n        return ans if ans < sys.maxsize else -1\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        if not houses: return 0\n        size = len(houses)\n        memo = dict()\n        def dfs(index, t, p):\n            key = (index, t, p)\n            if key in memo: return memo[key]\n            if index == size or t > size - index or t < 0:\n                if index == size and t == 0: return 0\n                else: return float('inf')\n            temp = float('inf')\n            if houses[index] == 0:\n                for nc in range(1, n + 1):\n                    temp = min(temp, dfs(index + 1, t - (nc != p), nc) + cost[index][nc - 1])\n            else:\n                temp = dfs(index + 1, t - (p != houses[index]), houses[index])\n            memo[key] = temp\n            return temp\n                \n        res = dfs(0, target, -1)\n        return res if res < float('inf') else -1\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        memo = {}\n        def dfs(i, j, target):\n            if target < 0 or target > m-i:\n                return float('inf')\n            if i == m:\n                return 0 if target == 0 else float('inf')\n            if (i, j, target) not in memo:\n                if houses[i]:\n                    memo[i,j,target] = dfs(i+1, houses[i], target-(houses[i]!=j))\n                else:\n                    memo[i,j,target] = min(cost[i][a-1] + dfs(i+1, a, target-(a!=j)) for a in range(1, n+1))\n            return memo[i,j,target]\n        ans = dfs(0, 0, target)\n        return ans if ans < float('inf') else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        dp = {}\n        def dfs(i, t, p):\n            key = (i,t,p)\n            if i == len(houses) or t < 0 or m-i < t:\n                return 0 if t == 0 and i == m else float('inf')\n            \n            if key not in dp:\n                if houses[i] == 0:\n                    dp[key] = min(dfs(i+1, t-(nc!=p), nc) + cost[i][nc-1] for nc in range(1, n+1))\n                else:\n                    dp[key] = dfs(i+1, t-(houses[i]!=p), houses[i])\n                    \n            return dp[key]\n        \n        ret = dfs(0, target, -1)\n            \n        return ret if ret < float('inf') else -1\n            \n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        dp={}\n        def dfs(i, t, p):\n            key = (i, t, p)            \n            if i == len(houses) or t<0 or m-i<t:\n                return 0 if t == 0 else float('inf')\n            if key not in dp:                \n                if houses[i] == 0:\n                    dp[key] = min(dfs(i+1, t-(p != nc), nc)+cost[i][nc-1] for nc in range(1, n+1))\n                else:\n                    dp[key] = dfs(i+1, t-(p != houses[i]), houses[i])\n            return dp[key]\n        ret =  dfs(0, target, -1)\n        return -1 if  ret == float('inf') else ret\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        \n        memo = {}\n        \n        def dfs(i, b ,c):\n            \n            if i == m and b == target:\n                return 0\n            if m - i < target - b or i == m or b > target:\n                return float('inf')\n            \n            key = (i, b, c)\n            if key not in memo:\n                if houses[i] != 0:\n                    memo[key] = dfs(i+1, b + (houses[i] != c), houses[i])\n                else:\n                    memo[key] = min( dfs(i+1, b + (nc != c), nc) + cost[i][nc-1] for nc in range(1, n+1))\n            \n            return memo[key]\n        \n        res = dfs(0, 0, -1)\n        if res == float('inf'):\n            return -1\n        else:\n            return res", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        dp = {}\n        # def func(i,t,p):\n        #     key = (i, t, p)\n        #     if i == len(houses) or t < 0 or m - i < t :\n        #         return 0 if t == 0 and i == len(houses) else float('inf')\n        #     if key not in dp:\n        #         if houses[i]==0:\n        #             dp[key] = min(func(i + 1, t - (nc != p), nc) + cost[i][nc - 1] for nc in range(n+1))\n        #         else:\n        #             dp[key] = func(i + 1, t - (houses[i]!=p), houses[i])\n        #     return dp[key]\n        # ret = func(0, target, -1)\n        # return ret if ret < float('inf') else -1\n        def dfs(i, t, p):\n            key = (i, t, p)\n            if i == len(houses) or t < 0 or m - i < t:\n                return 0 if t == 0 and i == len(houses) else float('inf')\n            if key not in dp:\n                if houses[i] == 0:\n                    dp[key] = min(dfs(i + 1, t - (nc != p), nc) + cost[i][nc - 1] for nc in range(1, n + 1))\n                else:\n                    dp[key] = dfs(i + 1, t - (houses[i] != p), houses[i])\n            return dp[key]\n        ret = dfs(0, target, -1)\n        return ret if ret < float('inf') else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        dp={}\n        def dfs(i, t, p):\n            key = (i, t, p)            \n            if i == len(houses) or t<0 or m-i<t:\n                return 0 if t == 0 else float('inf')\n            if key not in dp:      \n                if houses[i] == 0:\n                    dp[key] = min(dfs(i+1, t-(p != nc), nc)+cost[i][nc-1] for nc in range(1, n+1))\n                else:\n                    dp[key] = dfs(i+1, t-(p != houses[i]), houses[i])\n            return dp[key]\n        ret =  dfs(0, target, 0)\n        return -1 if  ret == float('inf') else ret\n", "import numpy as np\nfrom collections import defaultdict\n\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        \n        # DP(number of painted houses from left, last house color, number of groups in painted houses)\n        # DP(i, color, groups)\n        #       = min(DP(i - 1, x != color, groups - 1), DP(i - 1, color, groups)) + cost[i][x]\n\n        # m houses <= 100\n        # n colors <= 20\n        # number of states = m * n * target = 100 * 20 * 100 = 2e5\n        \n        INF = int(1e9)\n        DP = defaultdict(lambda: INF)  # (groups, last_color) -> min cost\n\n        if houses[0] == 0:\n            for col in range(1, n + 1):\n                DP[(1, col)] = cost[0][col - 1]\n        else:\n            DP[(1, houses[0])] = 0\n        \n        for i in range(1, m):\n            NDP = defaultdict(lambda: INF)\n            \n            ByGroups = defaultdict(list)  # (groups) -> [(cost, prev color)]\n            for key, min_cost in DP.items():\n                groups_prev, col_prev = key\n                ByGroups[groups_prev].append((min_cost, col_prev))\n\n            curr_colors = range(1, n + 1) if houses[i] == 0 else [houses[i]]\n                \n            for groups_prev, prev_colors_array in ByGroups.items():\n                prev_colors_array.sort()\n                prev_colors = [col_prev for min_cost, col_prev in prev_colors_array[:2]]\n                \n                for col_curr in curr_colors:\n                    paint_cost = cost[i][col_curr - 1] if houses[i] == 0 else 0\n\n                    for col_prev in [col_curr] + prev_colors:\n                        groups_curr = groups_prev + (col_prev != col_curr)\n                        curr_cost = DP[(groups_prev, col_prev)] + paint_cost\n                        if groups_curr <= target and curr_cost < INF:\n                            key = (groups_curr, col_curr)\n                            NDP[key] = min(NDP[key], curr_cost)\n                            \n            DP = NDP\n        \n        ans = -1\n        for key, min_cost in DP.items():\n            if key[0] == target and (ans < 0 or ans > min_cost):\n                ans = min_cost\n        return ans", "from functools import lru_cache\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dp(g, i, c):\n            if g > target or target - g > m - i: return sys.maxsize\n            if i == m: return 0 if g == target else sys.maxsize \n            ans = sys.maxsize \n            if houses[i] != 0:\n                ans = min(ans, dp(g+(houses[i]!=c), i+1, houses[i]))\n            else:\n                for j in range(n):\n                    ans = min(ans, cost[i][j] + dp(g+(j+1!=c), i+1, j+1))\n            return ans\n        \n        ans = dp(0, 0, 0)\n        return -1 if ans >= sys.maxsize else ans\n", "class Solution:\n    def onTrack(self,neighbours, visited, m, target):\n        return neighbours <= target and neighbours + m - visited >= target\n        \n    def minCost(self, houses, cost, m: int, n: int, target: int) -> int:\n        dp = {}\n        if not self.onTrack(1, 1, m, target):\n            return -1\n        if houses[0]!=0:\n            dp[houses[0]] = {1:0}\n        else:\n            for color in range(1,n+1):\n                dp[color] = {1:cost[0][color-1]}\n        # Start iteration\n        for each in range(1,m):\n            new = {}\n            if houses[each]!=0:\n                colors = list(range(houses[each], houses[each]+1))\n            else:\n                colors = list(range(1, n+1))\n            for new_color in colors:\n                for color in list(dp.keys()):\n                    isNew = int(color!=new_color)\n                    for neighbours in list(dp[color].keys()):\n                        if self.onTrack(neighbours+isNew, each+1, m, target):\n                            if new_color not in list(new.keys()):\n                                new[new_color] = {}\n                            new_cost = dp[color][neighbours]+cost[each][new_color-1]*int(houses[each]==0)\n                            last = new_cost\n                            if neighbours+isNew in list(new[new_color].keys()):\n                                last = min(new_cost, new[new_color][neighbours+isNew])\n                            new[new_color][neighbours+isNew]=last\n            if not new:\n                return -1\n            dp = new\n        result = float('inf')\n        for color in list(dp.keys()):\n            if target in list(dp[color].keys()):\n                result = min(result, dp[color][target])\n        if result!=float('inf'):\n            return result\n        else:\n            return -1\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        memo = {}\n        def dfs(i, j, target):\n            if target < 0 or target > m-i:\n                return float('inf')\n            if i == m:\n                if target == 0:\n                    return 0\n                else:\n                    return float('inf')\n            if (i, j, target) not in memo:\n                if houses[i]:\n                    memo[i,j,target] = dfs(i+1, houses[i], target-(houses[i]!=j))\n                else:\n                    memo[i,j,target] = min(cost[i][k-1] + dfs(i+1, k, target-(k!=j)) for k in range(1, n+1))\n            return memo[i,j,target]\n        ans = dfs(0, 0, target)\n        return ans if ans < float('inf') else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        memo = {}\n        def dfs(i, k, target):\n            if target < 0 or target > m-i:\n                return float('inf')\n            if i == m:\n                return 0 if target == 0 else float('inf')\n            if (i, k, target) not in memo:\n                if houses[i]:\n                    memo[i,k,target] = dfs(i+1, houses[i], target-(houses[i]!=k))\n                else:\n                    memo[i,k,target] = min(cost[i][a-1] + dfs(i+1, a, target-(a!=k)) for a in range(1, n+1))\n            return memo[i,k,target]\n        ans = dfs(0, 0, target)\n        return ans if ans < float('inf') else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        \n        # top-down approach\n        # key: (i, t, c) -> cost for paint i house left t group with c color\n        \n        cache = {}\n        \n        # dfs search\n        def dfs(i, t, c):\n            key = (i, t, c)\n            \n            # boundary condition\n            # 1. we paint all house and no target left\n            # 2. t must in  0 < t < m - i  \n            if i == len(houses) or t < 0 or m - i < t:\n                return 0 if i == len(houses) and t == 0 else float('inf')\n            \n            if key not in cache:\n                print(key)\n                if houses[i] == 0: \n                    # compte \n                    cache[key] = min(dfs(i + 1, t - int(nc != c), nc) + cost[i][nc - 1]\n                                   for nc in range(1, n + 1)) \n                else:\n                    # if already paint no extra cost add\n                    cache[key] = dfs(i + 1, t - int(c != houses[i]), houses[i])\n                    \n                \n            return cache[key]\n        \n        result = dfs(0, target, 0)\n        print(cache.keys())\n        \n        return result if result < float('inf') else -1", "from collections import defaultdict\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        '''\n        \n        m houses - n colors (1~n)\n        neighborhoods of same color\n        0 = not colored yet\n        cost[i][j] - cost to paint i with color j+1\n        \n        return minimal cost of painting remaining houses to get exactly target neighborhoods\n        \n        -have to keep track of min cost\n        -num neighbors==target at end\n        \n        dp => cost,numNeighbors\n        dp[house][lastneighbor] = min(dp[house][lastneighbor], min(cost + dp[house-1][neighbors])\n        \n        best now = last house with same color, correct num of neighbors or last house diff color, 1 less num of neighbors\n        \n        dp[h][numNeighbors][color] = colorCost + min(\n                dp[h-1][numNeighbors][color],\n                dp[h-1][numNeighbors-1][diffColor] <- iterate\n            )\n        \n        at house h,\n        dp[neighbors][color] = colorCost (if it's 0)\n                                + prev[neighbors][color]\n                                + prev[neighbors-1][anothercolor]\n        neighbors: [j-target,j+1]\n        \n        edge cases:\n        -if # of color neighborhoods > target: return -1\n        -num houses < target: return -1\n        '''\n        prev = [[0]*n for _ in range(target+1)]\n        for h,house in enumerate(houses):\n            dp = [[float('inf')]*n for _ in range(target+1)]\n            for numNeighbors in range(1,min(h+2,target+1)):\n                if house==0:\n                    for color in range(n):\n                        colorCost = cost[h][color]\n                        dp[numNeighbors][color] = min(\n                            dp[numNeighbors][color],\n                            colorCost + prev[numNeighbors][color],\n                            colorCost + min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                        )\n                else:\n                    color = house-1\n                    dp[numNeighbors][color] = min(\n                        dp[numNeighbors][color],\n                        prev[numNeighbors][color],\n                        min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                    )\n            prev = dp\n        out = min(prev[target][c] for c in range(n)) if houses[-1]==0 else prev[target][houses[-1]-1]\n        return out if out!=float('inf') else -1\n                \n", "from collections import defaultdict\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        '''\n        \n        m houses - n colors (1~n)\n        neighborhoods of same color\n        0 = not colored yet\n        cost[i][j] - cost to paint i with color j+1\n        \n        return minimal cost of painting remaining houses to get exactly target neighborhoods\n        \n        -have to keep track of min cost\n        -num neighbors==target at end\n        \n        dp => cost,numNeighbors\n        dp[house][lastneighbor] = min(dp[house][lastneighbor], min(cost + dp[house-1][neighbors])\n        \n        best now = last house with same color, correct num of neighbors or last house diff color, 1 less num of neighbors\n        \n        dp[h][numNeighbors][color] = colorCost + min(\n                dp[h-1][numNeighbors][color],\n                dp[h-1][numNeighbors-1][diffColor] <- iterate\n            )\n        \n        at house h,\n        dp[neighbors][color] = colorCost (if it's 0)\n                                + prev[neighbors][color]\n                                + prev[neighbors-1][anothercolor]\n        neighbors: [j-target,j+1]\n        \n        edge cases:\n        -if # of color neighborhoods > target: return -1\n        -num houses < target: return -1\n        '''\n        prev = [[0]*n for _ in range(2)]\n        for h,house in enumerate(houses):\n            dp = [[float('inf')]*n for _ in range(h+2)]\n            for numNeighbors in range(1,h+2):\n                if house==0:\n                    for color in range(n):\n                        colorCost = cost[h][color]\n                        if numNeighbors==h+1:\n                            dp[numNeighbors][color] = min(\n                                dp[numNeighbors][color],\n                                colorCost + min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                            )\n                        else:\n                            dp[numNeighbors][color] = min(\n                                dp[numNeighbors][color],\n                                colorCost + prev[numNeighbors][color],\n                                colorCost + min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                            )\n                else:\n                    color = house-1\n                    if numNeighbors==h+1:\n                        dp[numNeighbors][color] = min(\n                            dp[numNeighbors][color],\n                            min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                        )\n\n                    else:\n                        dp[numNeighbors][color] = min(\n                            dp[numNeighbors][color],\n                            prev[numNeighbors][color],\n                            min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                        )\n            prev = dp\n        \n        out = min(prev[target][c] for c in range(n))\n        return out if out!=float('inf') else -1\n                \n", "from collections import defaultdict\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        '''\n        \n        m houses - n colors (1~n)\n        neighborhoods of same color\n        0 = not colored yet\n        cost[i][j] - cost to paint i with color j+1\n        \n        return minimal cost of painting remaining houses to get exactly target neighborhoods\n        \n        -have to keep track of min cost\n        -num neighbors==target at end\n        \n        dp => cost,numNeighbors\n        dp[house][lastneighbor] = min(dp[house][lastneighbor], min(cost + dp[house-1][neighbors])\n        \n        best now = last house with same color, correct num of neighbors or last house diff color, 1 less num of neighbors\n        \n        dp[h][numNeighbors][color] = colorCost + min(\n                dp[h-1][numNeighbors][color],\n                dp[h-1][numNeighbors-1][diffColor] <- iterate\n            )\n        \n        at house h,\n        dp[neighbors][color] = colorCost (if it's 0)\n                                + prev[neighbors][color]\n                                + prev[neighbors-1][anothercolor]\n        neighbors: [j-target,j+1]\n        \n        edge cases:\n        -if # of color neighborhoods > target: return -1\n        -num houses < target: return -1\n        '''\n        prev = [[0]*n for _ in range(m+1)]\n        for h,house in enumerate(houses):\n            dp = [[float('inf')]*n for _ in range(m+1)]\n            for numNeighbors in range(1,h+2):\n                if house==0:\n                    for color in range(n):\n                        colorCost = cost[h][color]\n                        dp[numNeighbors][color] = min(\n                            dp[numNeighbors][color],\n                            colorCost + prev[numNeighbors][color],\n                            colorCost + min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                        )\n                else:\n                    color = house-1\n                    dp[numNeighbors][color] = min(\n                        dp[numNeighbors][color],\n                        prev[numNeighbors][color],\n                        min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                    )\n            prev = dp\n        out = min(prev[target][c] for c in range(n)) if houses[-1]==0 else prev[target][houses[-1]-1]\n        return out if out!=float('inf') else -1\n                \n", "from collections import defaultdict\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        '''\n        \n        m houses - n colors (1~n)\n        neighborhoods of same color\n        0 = not colored yet\n        cost[i][j] - cost to paint i with color j+1\n        \n        return minimal cost of painting remaining houses to get exactly target neighborhoods\n        \n        -have to keep track of min cost\n        -num neighbors==target at end\n        \n        dp => cost,numNeighbors\n        dp[house][lastneighbor] = min(dp[house][lastneighbor], min(cost + dp[house-1][neighbors])\n        \n        best now = last house with same color, correct num of neighbors or last house diff color, 1 less num of neighbors\n        \n        dp[h][numNeighbors][color] = colorCost + min(\n                dp[h-1][numNeighbors][color],\n                dp[h-1][numNeighbors-1][diffColor] <- iterate\n            )\n        \n        at house h,\n        dp[neighbors][color] = colorCost (if it's 0)\n                                + prev[neighbors][color]\n                                + prev[neighbors-1][anothercolor]\n        neighbors: [j-target,j+1]\n        \n        edge cases:\n        -if # of color neighborhoods > target: return -1\n        -num houses < target: return -1\n        '''\n        prev = [[0]*n for _ in range(target+1)]\n        out = float('inf')\n        for h,house in enumerate(houses):\n            dp = [[float('inf')]*n for _ in range(target+1)]\n            for numNeighbors in range(1,min(h+2,target+1)):\n                if house==0:\n                    for color in range(n):\n                        colorCost = cost[h][color]\n                        dp[numNeighbors][color] = min(\n                            dp[numNeighbors][color],\n                            colorCost + prev[numNeighbors][color],\n                            colorCost + min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                        )\n                else:\n                    color = house-1\n                    dp[numNeighbors][color] = min(\n                        dp[numNeighbors][color],\n                        prev[numNeighbors][color],\n                        min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                    )\n            prev = dp\n        \n        out = None\n        if houses[-1]==0:\n            out = min(prev[target][c] for c in range(n))\n        else:\n            out = prev[target][houses[-1]-1]\n        return out if out!=float('inf') else -1\n                \n", "from collections import defaultdict\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        '''\n        \n        m houses - n colors (1~n)\n        neighborhoods of same color\n        0 = not colored yet\n        cost[i][j] - cost to paint i with color j+1\n        \n        return minimal cost of painting remaining houses to get exactly target neighborhoods\n        \n        -have to keep track of min cost\n        -num neighbors==target at end\n        \n        dp => cost,numNeighbors\n        dp[house][lastneighbor] = min(dp[house][lastneighbor], min(cost + dp[house-1][neighbors])\n        \n        best now = last house with same color, correct num of neighbors or last house diff color, 1 less num of neighbors\n        \n        dp[h][numNeighbors][color] = colorCost + min(\n                dp[h-1][numNeighbors][color],\n                dp[h-1][numNeighbors-1][diffColor] <- iterate\n            )\n        \n        at house h,\n        dp[neighbors][color] = colorCost (if it's 0)\n                                + prev[neighbors][color]\n                                + prev[neighbors-1][anothercolor]\n        neighbors: [j-target,j+1]\n        \n        edge cases:\n        -if # of color neighborhoods > target: return -1\n        -num houses < target: return -1\n        '''\n        prev = [[0]*n for _ in range(target+1)]\n        out = float('inf')\n        for h,house in enumerate(houses):\n            dp = [[float('inf')]*n for _ in range(target+1)]\n            for numNeighbors in range(1,min(h+2,target+1)):\n                if house==0:\n                    for color in range(n):\n                        colorCost = cost[h][color]\n                        dp[numNeighbors][color] = min(\n                            dp[numNeighbors][color],\n                            colorCost + prev[numNeighbors][color],\n                            colorCost + min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                        )\n                        if numNeighbors==target and h==m-1:\n                            # print(h,numNeighbors,color,out,dp[numNeighbors][color])\n                            out = min(out,dp[numNeighbors][color])\n                else:\n                    color = house-1\n                    dp[numNeighbors][color] = min(\n                        dp[numNeighbors][color],\n                        prev[numNeighbors][color],\n                        min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                    )\n                    if numNeighbors==target and h==m-1:\n                        out = min(out,dp[numNeighbors][color])\n            prev = dp\n        \n        # out = None\n        # if houses[-1]==0:\n        #     out = min(prev[target][c] for c in range(n))\n        # else:\n        #     prev[target][houses[-1]-1]\n        return out if out!=float('inf') else -1\n                \n", "from collections import defaultdict\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        '''\n        \n        m houses - n colors (1~n)\n        neighborhoods of same color\n        0 = not colored yet\n        cost[i][j] - cost to paint i with color j+1\n        \n        return minimal cost of painting remaining houses to get exactly target neighborhoods\n        \n        -have to keep track of min cost\n        -num neighbors==target at end\n        \n        dp => cost,numNeighbors\n        dp[house][lastneighbor] = min(dp[house][lastneighbor], min(cost + dp[house-1][neighbors])\n        \n        best now = last house with same color, correct num of neighbors or last house diff color, 1 less num of neighbors\n        \n        dp[h][numNeighbors][color] = colorCost + min(\n                dp[h-1][numNeighbors][color],\n                dp[h-1][numNeighbors-1][diffColor] <- iterate\n            )\n        \n        at house h,\n        dp[neighbors][color] = colorCost (if it's 0)\n                                + prev[neighbors][color]\n                                + prev[neighbors-1][anothercolor]\n        neighbors: [j-target,j+1]\n        \n        edge cases:\n        -if # of color neighborhoods > target: return -1\n        -num houses < target: return -1\n        '''\n        prev = [[0]*n for _ in range(2)]\n        for h,house in enumerate(houses):\n            dp = [[float('inf')]*n for _ in range(h+2)]\n            for numNeighbors in range(1,h+2):\n                if house==0:\n                    for color in range(n):\n                        colorCost = cost[h][color]\n                        if numNeighbors==h+1:\n                            dp[numNeighbors][color] = min(\n                                dp[numNeighbors][color],\n                                colorCost + min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                            )\n                        else:\n                            dp[numNeighbors][color] = min(\n                                dp[numNeighbors][color],\n                                colorCost + prev[numNeighbors][color],\n                                colorCost + min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                            )\n                            \n                    \n                else:\n                    color = house-1\n                    if numNeighbors==h+1:\n                        dp[numNeighbors][color] = min(\n                            dp[numNeighbors][color],\n                            min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                        )\n\n                    else:\n                        # print(numNeighbors,color)\n                        # print(len(dp),len(dp[0]))\n                        dp[numNeighbors][color] = min(\n                            dp[numNeighbors][color],\n                            prev[numNeighbors][color],\n                            min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                        )\n            prev = dp\n        \n        out = min(prev[target][c] for c in range(n))\n        return out if out!=float('inf') else -1\n                \n", "from collections import defaultdict\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        '''\n        \n        m houses - n colors (1~n)\n        neighborhoods of same color\n        0 = not colored yet\n        cost[i][j] - cost to paint i with color j+1\n        \n        return minimal cost of painting remaining houses to get exactly target neighborhoods\n        \n        -have to keep track of min cost\n        -num neighbors==target at end\n        \n        dp => cost,numNeighbors\n        dp[house][lastneighbor] = min(dp[house][lastneighbor], min(cost + dp[house-1][neighbors])\n        \n        best now = last house with same color, correct num of neighbors or last house diff color, 1 less num of neighbors\n        \n        dp[h][numNeighbors][color] = colorCost + min(\n                dp[h-1][numNeighbors][color],\n                dp[h-1][numNeighbors-1][diffColor] <- iterate\n            )\n        \n        at house h,\n        dp[neighbors][color] = colorCost (if it's 0)\n                                + prev[neighbors][color]\n                                + prev[neighbors-1][anothercolor]\n        neighbors: [j-target,j+1]\n        \n        edge cases:\n        -if # of color neighborhoods > target: return -1\n        -num houses < target: return -1\n        '''\n        prev = [[0]*n for _ in range(m+1)]\n        for h,house in enumerate(houses):\n            dp = [[float('inf')]*n for _ in range(m+1)]\n            for numNeighbors in range(1,h+2):\n                if house==0:\n                    for color in range(n):\n                        colorCost = cost[h][color]\n                        dp[numNeighbors][color] = min(\n                            dp[numNeighbors][color],\n                            colorCost + prev[numNeighbors][color],\n                            colorCost + min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                        )\n                else:\n                    color = house-1\n                    dp[numNeighbors][color] = min(\n                        dp[numNeighbors][color],\n                        prev[numNeighbors][color],\n                        min(prev[numNeighbors-1][c] for c in range(n) if c!=color)\n                    )\n            prev = dp\n        \n        out = min(prev[target][c] for c in range(n))\n        return out if out!=float('inf') else -1\n                \n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        # dp[i][j][k] is the minimum cost to paint {0, 1, ..., `i`} houses of `j` neighborhoods, and the `i`th house is painted as color `k`\n        \n        dp = [[[math.inf for k in range(n)] for j in range(target)] for i in range(m)]\n        \n        pre = None\n        min_neighborhoods = 1\n        for i in range(m):\n            if houses[i]:\n                if pre is not None and houses[i] != pre:\n                    min_neighborhoods += 1\n                pre = houses[i]\n            if i == 0:\n                if houses[i]:\n                    k = houses[i]-1\n                    dp[i][0][k] = 0\n                else:\n                    for k in range(n):\n                        dp[i][0][k] = cost[i][k]\n                continue\n            for j in range(min_neighborhoods-1, min(i+1, target)):\n                if houses[i]:\n                    k = houses[i]-1\n                    dp[i][j][k] = min(min(dp[i-1][j-1][p] for p in range(n) if p != k), dp[i-1][j][k])\n                else:\n                    for k in range(n):\n                        dp[i][j][k] = cost[i][k] + min(min(dp[i-1][j-1][p] for p in range(n) if p != k), dp[i-1][j][k])\n\n        ans = min(dp[-1][-1])\n        if ans == math.inf:\n            return -1\n        else:\n            return ans", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        # dp[i][j][k] is the minimum cost to paint {0, 1, ..., `i`} houses of `j` neighborhoods, and the `i`th house is painted as color `k`\n        \n        dp = [[[math.inf for k in range(n)] for j in range(target)] for i in range(m)]\n        if houses[0]:\n            dp[0][0][houses[0]-1] = 0\n        else:\n            for k in range(n):\n                dp[0][0][k] = cost[0][k]\n        \n        pre = houses[0]\n        min_neighborhoods = 1\n        for i in range(1, m):\n            if houses[i]:\n                if pre and houses[i] != pre:\n                    min_neighborhoods += 1\n                pre = houses[i]\n            for j in range(min_neighborhoods-1, min(i+1, target)):\n                for k in (houses[i]-1,) if houses[i] else range(n):\n                    dp[i][j][k] = min(min(dp[i-1][j-1][p] for p in range(n) if p != k), dp[i-1][j][k])\n                    if not houses[i]:\n                        dp[i][j][k] += cost[i][k]\n                        \n        ans = min(dp[-1][-1])\n        return -1 if ans == math.inf else ans", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        \n\n        @lru_cache(None)\n        def dp(idx: int, pc: int, k: int) -> int:\n            if idx >= m:\n                return 0 - int(k != 0)\n            if k < 0:\n                return -1\n            if houses[idx] != 0:\n                return dp(idx+1, houses[idx], k - int(pc != houses[idx]))\n            \n            ans = -1\n            for i in range(1, n+1):\n                new_cost = cost[idx][i-1]\n                prev_cost = dp(idx+1, i, k - int(pc!=i))\n                if prev_cost >= 0:\n                    ans = min(ans if ans >0 else float('inf'), new_cost + prev_cost)\n            \n            return ans\n        \n        return dp(0, 0, target)\n    \n#         @lru_cache(None)\n#         def dp(idx: int, prev_color: int, k: int) -> int:\n\n#             # No more houses left to paint, return true if there are no more neighborhoods\n#             # to paint, false otherwise\n#             if idx >= m:\n#                 return 0 - int(k != 0)\n\n#             # No more neighborhoods colors available\n#             if k < 0:\n#                 return -1\n\n#             # Check if this house is already painted, if so, go to the next house\n#             # Note: `k - int(prev_color != new_color)` decreases the number of\n#             # neighborhoods left to paint if the current house color is different than the\n#             # previous one\n#             if houses[idx] != 0:\n#                 return dp(idx + 1, houses[idx], k - int(prev_color != houses[idx]))\n\n#             # Decide on the best color to paint current house\n#             best = -1\n\n#             # Try all possible colors\n#             for new_color in range(1, n + 1):\n#                 new_color_cost = cost[idx][new_color - 1]\n#                 other_costs = dp(idx + 1, new_color, k - int(prev_color != new_color))\n\n#                 # Check if painting this house with `new_color` will give us a lower cost\n#                 if other_costs >= 0:\n#                     best = min(best if best > 0 else float(\\\"inf\\\"),\n#                                new_color_cost + other_costs)\n#             return best\n\n#         # Start with the first house\n#         return dp(0, 0, target)\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        m = len(houses)\n        n += 1\n        @lru_cache(None)\n        def minCost(i, n_nei, prev_c):\n            if i == m:\n                if n_nei == target:\n                    return 0\n                return float('inf')\n            if n_nei > target:\n                return float('inf')\n            if houses[i] != 0:\n                if houses[i] == prev_c:\n                    return minCost(i+1, n_nei, prev_c)\n                return minCost(i+1, n_nei+1, houses[i])\n            return min(minCost(i+1, n_nei if c==prev_c else (n_nei+1), c)+cost[i][c-1] for c in range(1, n))\n        if houses[0] == 0:\n            res = min(minCost(1, 1, c) + cost[0][c-1] for c in range(1, n))\n        else:\n            res = minCost(1, 1, houses[0])\n        return res if res != float('inf') else -1", "import functools\n\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        \n        @functools.lru_cache(None)\n        def dfs(i, last_color, hoods):\n            # print(i, last_color, hoods)\n            if hoods > target: return float('inf')\n            \n            if i >= m: \n                if hoods != target: return float('inf')\n                return 0\n            \n            if houses[i] != 0:\n                if houses[i]-1 == last_color:\n                    return dfs(i+1, houses[i]-1, hoods)\n                else:\n                    return dfs(i+1, houses[i]-1, hoods + 1)\n            else:\n                cands = []\n                for color in range(n):\n                    if color == last_color:\n                        cands.append(cost[i][color] + dfs(i+1, color, hoods))\n                    else:\n                        cands.append(cost[i][color] + dfs(i+1, color, hoods + 1))\n                return min(cands)\n                \n        \n        ans = dfs(0, -1, 0)\n        \n        if ans == float('inf'): return -1\n        return ans", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        \n\n        @lru_cache(None)\n        def dp(idx, pc, k):\n            if idx >= m:\n                return 0 - int(k != 0)\n            if k < 0:\n                return -1\n            if houses[idx] != 0:\n                return dp(idx+1, houses[idx], k - int(pc != houses[idx]))\n            \n            ans = -1\n            for i in range(1, n+1):\n                new_cost = cost[idx][i-1]\n                prev_cost = dp(idx+1, i, k - int(pc!=i))\n                if prev_cost >= 0:\n                    ans = min(ans if ans >0 else float('inf'), new_cost + prev_cost)\n            \n            return ans\n        \n        return dp(0, 0, target)\n    \n#         @lru_cache(None)\n#         def dp(idx: int, prev_color: int, k: int) -> int:\n\n#             # No more houses left to paint, return true if there are no more neighborhoods\n#             # to paint, false otherwise\n#             if idx >= m:\n#                 return 0 - int(k != 0)\n\n#             # No more neighborhoods colors available\n#             if k < 0:\n#                 return -1\n\n#             # Check if this house is already painted, if so, go to the next house\n#             # Note: `k - int(prev_color != new_color)` decreases the number of\n#             # neighborhoods left to paint if the current house color is different than the\n#             # previous one\n#             if houses[idx] != 0:\n#                 return dp(idx + 1, houses[idx], k - int(prev_color != houses[idx]))\n\n#             # Decide on the best color to paint current house\n#             best = -1\n\n#             # Try all possible colors\n#             for new_color in range(1, n + 1):\n#                 new_color_cost = cost[idx][new_color - 1]\n#                 other_costs = dp(idx + 1, new_color, k - int(prev_color != new_color))\n\n#                 # Check if painting this house with `new_color` will give us a lower cost\n#                 if other_costs >= 0:\n#                     best = min(best if best > 0 else float(\\\"inf\\\"),\n#                                new_color_cost + other_costs)\n#             return best\n\n#         # Start with the first house\n#         return dp(0, 0, target)\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n       # f[house i][j neighborhoods][color k] 1<=j<=i\n       # =min(f[house i-1][j neighborhoods][color k],f[house i-1][j-1 neighborhoods][color l!=k]) + cost[i][k] if houses[i] == 0\n        \n        f = [[-1] * n for i in range(target + 1)]\n        if houses[0]:\n            f[1][houses[0] - 1] = 0\n        else:\n            for k in range(n):\n                f[1][k] = cost[0][k]\n        \n        for i in range(1, m):\n            g = [[-1] * n for i in range(target + 1)]\n            for j in range(1, min(i + 1, target) + 1):\n                for k in range(n):\n                    if houses[i] and houses[i] - 1 != k:\n                        continue\n                    g[j][k] = f[j][k]\n                    for l in range(n):\n                        if l != k and f[j - 1][l] != -1:\n                            if  g[j][k] == -1 or f[j - 1][l] < g[j][k]:\n                                g[j][k] = f[j - 1][l]\n                    if g[j][k] != -1 and not houses[i]:\n                        g[j][k] += cost[i][k]\n            f = g\n            \n        ans = list(filter(lambda x: x != -1, f[target]))\n        if not ans:\n            return -1\n        else:\n            return min(ans)", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, t: int, pc: int) -> int:\n            if i == m:\n                return math.inf if t != 0 else 0\n            if houses[i] != 0: return dfs(i + 1, t - (pc != houses[i]), houses[i])\n            else:\n                return min(dfs(i + 1, t - (pc != c), c) + cost[i][c - 1] for c in range(1, n + 1))\n        ans = dfs(0, target, -1)\n        return ans if ans != math.inf else -1\n", "from functools import lru_cache\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        \n        @lru_cache(None)\n        def dfs(i,prev,k):\n            if i>=m:\n                return 0 - int(k!=0)\n                \n            if k<0:\n                return -1\n                \n            if houses[i]!=0:\n                return dfs(i+1, houses[i], k - int(prev!=houses[i]))\n            \n            else:\n                temp = float('inf')\n                for c in range(1,n+1):\n                    c_cost = cost[i][c-1]\n                    other = dfs(i+1,c, k-int(prev!=c))\n                    \n                    if other>=0:\n                        temp = min(temp, c_cost+other)\n                if temp == float('inf'):\n                    return -1\n                return temp\n        return dfs(0,0,target)\n            \n            \n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        # dp[i][c][k]: i means the ith house, c means the cth color, k means k neighbor groups\n        dp = [[[math.inf for _ in range(n)] for _ in range(target + 1)] for _ in range(m)]\n        \n        for c in range(1, n + 1):\n            if houses[0] == c: dp[0][1][c - 1] = 0\n            elif not houses[0]: dp[0][1][c - 1] = cost[0][c - 1]\n                \n        for i in range(1, m):\n            for k in range(1, min(target, i + 1) + 1):\n                for c in range(1, n + 1):\n                    if houses[i] and c != houses[i]: continue\n                    same_neighbor_cost = dp[i - 1][k][c - 1]\n                    diff_neighbor_cost = min([dp[i - 1][k - 1][c_] for c_ in range(n) if c_ != c - 1] or [math.inf])\n                    paint_cost = cost[i][c - 1] * (not houses[i])\n                    dp[i][k][c - 1] = min(same_neighbor_cost, diff_neighbor_cost) + paint_cost\n        res = min(dp[-1][-1])\n        return res if res < math.inf else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        t = target\n        dp = [[[0 for i in range(t+1)] for j in range(n+1)] for i in range(m+1)]\n        for k in range(1,t+1):\n            for j in range(1,n+1):\n                dp[0][j][k] = 10**9\n        for i in range(1,m+1):    \n            for j in range(1,n+1):\n                dp[i][j][0] = 10**9\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                for k in range(1,t+1):\n                    if houses[i-1] == j and k<=i:\n                        dp[i][j][k] = min(dp[i-1][j][k],min([dp[i-1][p][k-1] if p!=j else 10**9 for p in range(1,n+1)]))\n                    elif houses[i-1]==0 and k<=i:\n                        dp[i][j][k] = cost[i-1][j-1]+min(dp[i-1][j][k],min([dp[i-1][p][k-1] if p!=j else 10**9 for p in range(1,n+1)]))\n                    else:\n                        dp[i][j][k] = 10**9\n                        \n        ans = 10**9\n        for j in range(1,n+1):\n            ans = min(ans, dp[m][j][t])\n        return ans if ans<10**9 else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        m = len(houses)\n        n += 1\n        @lru_cache(None)\n        def minCost(i, n_nei, prev_c):\n            if i == m:\n                if n_nei == target:\n                    return 0\n                return float('inf')\n            if n_nei > target:\n                return float('inf')\n            if houses[i] != 0:\n                if houses[i] == prev_c:\n                    return minCost(i+1, n_nei, prev_c)\n                return minCost(i+1, n_nei+1, houses[i])\n            return min(minCost(i+1, n_nei if c==prev_c else (n_nei+1), c)+cost[i][c-1] for c in range(1, n))\n        res = minCost(0, 0, -1)\n        return res if res != float('inf') else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dp(idx, prev_color, k):\n            if idx >= m:\n                return 0 - int(k != 0)\n            if k < 0:\n                return -1\n            \n            if houses[idx] != 0:\n                return dp(idx + 1, houses[idx], k - int(prev_color != houses[idx]))\n            \n            best = math.inf\n            \n            for new_color in range(1, n + 1):\n                new_cost = cost[idx][new_color - 1]\n                other_cost = dp(idx + 1, new_color, k - int(new_color != prev_color))\n                \n                if other_cost >= 0:\n                    best = min(best, new_cost + other_cost)\n                    \n            return best if best is not math.inf else -1\n        res = dp(0, 0, target)\n        return res \n", "from functools import lru_cache\n\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        \n        INF = 10**9\n\n        @lru_cache(None)\n        def dp(i, c, k):\n            # print(i, c, k, i == m)\n            if k > target:\n                return INF\n            if i >= m:\n                return 0 if k == target else INF\n            if houses[i] > 0:\n                k_next = k if houses[i] == c else k + 1\n                return dp(i + 1, houses[i], k_next)\n\n            result = INF\n            for j in range(1, n + 1):\n                k_next = k if j == c else k + 1\n                result = min(result, cost[i][j - 1] + dp(i + 1, j, k_next))\n\n            return result\n\n\n        ans = dp(0, 0, 0)\n        return ans if ans < INF else -1\n\n", "from functools import lru_cache\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dp(g, i, c):\n            if g > target: return sys.maxsize\n            if i == m: return 0 if g == target else sys.maxsize \n            ans = sys.maxsize \n            if houses[i] != 0:\n                ans = min(ans, dp(g+(houses[i]!=c), i+1, houses[i]))\n            else:\n                for j in range(n):\n                    ans = min(ans, cost[i][j] + dp(g+(j+1!=c), i+1, j+1))\n            return ans\n        \n        ans = dp(0, 0, 0)\n        return -1 if ans >= sys.maxsize else ans\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        # dp[i][k][c]\n        dp = [[[float('inf') for _ in range(n)] for _ in range(target+1)] for _ in range(m)]\n        \n        for c in range(1, n+1): # houses[i] == 0 \u662f\u6307\u989c\u8272\u5f85\u5237\n            if houses[0] == c:\n                dp[0][1][c-1] = 0 #lucky\u4e0d\u7528\u5237\n            elif not houses[0]:\n                dp[0][1][c-1] = cost[0][c-1] #\u8981\u5237\n                \n        for i in range(1, m):\n            for k in range(1, min(target, i+1) + 1):\n                for c in range(1, n+1):\n                    if houses[i] and c != houses[i]: continue\n                    same_neighbor_cost = dp[i-1][k][c-1]\n                    diff_neighbor_cost = min([dp[i-1][k-1][c_] for c_ in range(n) if c_ != c-1])\n                    paint_cost = cost[i][c-1] * (not houses[i])\n                    dp[i][k][c-1] = min(same_neighbor_cost, diff_neighbor_cost) + paint_cost\n        res = min(dp[-1][-1])\n        \n        return res if res < float('inf') else -1\n                \n                \n        \n", "from functools import lru_cache\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dp(g, i, c):\n            if g > target: return sys.maxsize\n            if i == m: return 0 if g == target else sys.maxsize \n            ans = sys.maxsize \n            if houses[i] != 0:\n                if houses[i] == c: ans = min(ans, dp(g, i+1, c))\n                else: ans = min(ans, dp(g+1, i+1, houses[i]))\n            else:\n                for j in range(n):\n                    if j + 1 == c: ans = min(ans, cost[i][j] + dp(g, i+1, c))\n                    else: ans = min(ans, cost[i][j] + dp(g+1, i+1, j+1))\n            return ans\n        \n        ans = dp(0, 0, 0)\n        return -1 if ans >= sys.maxsize else ans\n", "from functools import lru_cache\nclass Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dp(g, i, c):\n            if i == m: return 0 if g == target else sys.maxsize \n            ans = sys.maxsize \n            if houses[i] != 0:\n                if houses[i] == c: ans = min(ans, dp(g, i+1, c))\n                else: ans = min(ans, dp(g+1, i+1, houses[i]))\n            else:\n                for j in range(n):\n                    if j + 1 == c: ans = min(ans, cost[i][j] + dp(g, i+1, c))\n                    else: ans = min(ans, cost[i][j] + dp(g+1, i+1, j+1))\n            return ans\n        \n        ans = dp(0, 0, 0)\n        return -1 if ans >= sys.maxsize else ans\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        dp = [[float('inf')]*(target+1) for _ in range(n+1)]\n        if houses[0] != 0:\n            dp[houses[0]][1] = 0\n        else:\n            for c in range(n):\n                dp[c+1][1] = cost[0][c]\n        for i in range(1, len(houses)):\n            tmp = [[float('inf')]*(target+1) for _ in range(n+1)]\n            for j in range(1, target+1):\n                if houses[i] != 0:\n                    if houses[i-1] == 0:\n                        tmp[houses[i]][j] = min(dp[houses[i]][j], min([dp[color+1][j-1] for color in range(n) if color+1!=houses[i]]))\n                    elif houses[i-1] == houses[i]:\n                        tmp[houses[i]][j] = dp[houses[i]][j]\n                    else:\n                        tmp[houses[i]][j] = dp[houses[i-1]][j-1]\n                else:\n                    if houses[i-1]:\n                        for c in range(n):\n                            if c+1 == houses[i-1]:\n                                tmp[c+1][j] = dp[c+1][j] + cost[i][c]\n                            else:\n                                tmp[c+1][j] = dp[houses[i-1]][j-1] + cost[i][c]\n                    else:\n                        for c in range(n):\n                            tmp[c+1][j] = min(dp[c+1][j], min([dp[color+1][j-1] for color in range(n) if color!=c])) + cost[i][c]\n            dp = tmp\n        res = min([dp[c+1][target] for c in range(n)])\n        return res if res != float('inf') else -1", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def min_cost_helper(i, prev_color, groups):\n            if i == m:\n                return 0 if groups == target else float('inf')\n            \n            if houses[i] != 0:\n                return min_cost_helper(i + 1, houses[i], groups + int(prev_color != houses[i]))\n            \n            total = float('inf')\n            for color in range(1, n + 1):\n                total = min(total, cost[i][color - 1] + min_cost_helper(i + 1, color, groups + int(prev_color != color)))\n            \n            return total\n        \n        ans = min_cost_helper(0, -1, 0)\n        return ans if ans != float('inf') else -1\n", "class Solution:\n    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dp(idx, prev_color, k):\n            if idx >= m:\n                return 0 - int(k != 0)\n            if k < 0:\n                return -1\n            \n            if houses[idx] != 0:\n                return dp(idx + 1, houses[idx], k - int(prev_color != houses[idx]))\n            \n            best = math.inf\n            \n            for new_color in range(1, n + 1):\n                new_cost = cost[idx][new_color - 1]\n                other_cost = dp(idx + 1, new_color, k - int(new_color != prev_color))\n                \n                if other_cost >= 0:\n                    best = min(best, new_cost + other_cost)\n                    \n            return best if best is not math.inf else -1\n        res = dp(0, 0, target)\n        return res if res != math.inf else -1\n", "class Solution:\n    def minCost(self, houses: List[int], Cost: List[List[int]], m: int, n: int, target: int) -> int:\n        @lru_cache(None)\n        def dfs(i, j, k):\n            if j > target:\n                return float('inf')\n            if i == len(houses):\n                if j == target:\n                    return 0\n                else:\n                    return float('inf')\n                \n            cost = float('inf')\n            if houses[i] == 0:\n                for index, c in enumerate(Cost[i]):\n                    if i == 0:\n                        cost = min(cost, dfs(i + 1, 1, index + 1) + c)\n                    else:\n                        if index + 1 == k:\n                            cost = min(cost, dfs(i + 1, j, index + 1) + c)\n                        else:\n                            cost = min(cost, dfs(i + 1, j + 1, index + 1) + c)     \n                    houses[i] = 0\n            else:\n                if i == 0:\n                    cost = dfs(i + 1, 1, houses[i])\n                else:\n                    if houses[i] == k:\n                        cost = dfs(i + 1, j, houses[i])\n                    else:\n                        cost = dfs(i + 1, j + 1, houses[i])\n            return cost\n        \n        ans = dfs(0, 0, 0)\n        return ans if ans != float('inf') else -1\n    \n"]
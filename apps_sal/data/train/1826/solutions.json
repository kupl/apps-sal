["class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \\\"\\\"\\\"\n        Brute force solution is to perform the sum for each position\n        (r, c). This would require K * K operations for each of m * n positions.\n        \n        Instead, assuming we compute sums left to right and top down, we can\n        use our previous solution to calculate the next one, subtracting the\n        sums that fell out of the window and adding the sums that are in.\n        \n        Pseudo code would be something like this:\n        \n        prevBlockSum = ...\n        for r in range(m):\n            for c in range(n):\n                if c - K > 0:\n                    prevBlockSum -= sum()\n        \\\"\\\"\\\"\n        m = len(mat)\n        n = len(mat[0])\n        \n        cum = []\n        prevSums = [0] * n\n        for r in range(m):\n            rowSum = 0\n            cumSums = []\n            for c in range(n):\n                rowSum += mat[r][c]\n                cumSums.append(prevSums[c] + rowSum)\n            cum.append(cumSums)\n            prevSums = cumSums\n        \n        out = []\n        for i in range(m):\n            blockSums = []\n            for j in range(n):\n                r = i + K if i + K < m else m - 1\n                c = j + K if j + K < n else n - 1\n                \n                blockSum = cum[r][c]\n                if i - K > 0:\n                    blockSum -= cum[i-K-1][c]\n                if j - K > 0:\n                    blockSum -= cum[r][j-K-1]\n                if i - K > 0 and j - K > 0:\n                    blockSum += cum[i-K-1][j-K-1]\n                blockSums.append(blockSum)\n            out.append(blockSums)\n        \n        return out", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])        \n        mat[:] = [[0] * (n + 1)] + [[0] + row for row in mat]\n        res = [[0 for _ in range(n)] for _ in range(m)]\n        \n        # cum sum \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                mat[i][j] += mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1]\n        \n        # compute sums\n        for i in range(m):\n            for j in range(n):\n                r1, c1 = max(i-K, 0), max(j-K, 0)\n                r2, c2 = min(i+K+1, m), min(j+K+1, n)\n                res[i][j] = mat[r2][c2] - mat[r1][c2] - mat[r2][c1] + mat[r1][c1]\n        \n        return res\n                    \n                    \n        \n                        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n, m = len(mat), len(mat[0])\n        k = K\n        range_sum = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                top_left = range_sum[i-1][j-1] if j-1 >= 0 and i-1 >= 0 else 0\n                top = range_sum[i-1][j] if i-1 >=0 else 0\n                left = range_sum[i][j-1] if j-1>=0 else 0\n                range_sum[i][j] = top + left - top_left + mat[i][j]\n        print(range_sum)\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                # right_buttom point\n                col = min(m-1, j+k)\n                row = min(n-1, i+k)\n                print([row, col])\n                dp[i][j] = (range_sum[row][col]\n                           + (range_sum[i-k-1][j-k-1] if i-k-1>=0 and j-k-1>=0 else 0)\n                           - (range_sum[row][j-k-1] if j-k-1>=0 else 0)\n                           - (range_sum[i-k-1][col] if i-k-1>=0 else 0))\n        return dp", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        \n        answer = [[0]*n for _ in range(m)]\n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if j == 0:\n                    dp[i][j] = mat[i][j]\n                else:\n                    dp[i][j] = dp[i][j-1] + mat[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                for x in range(i-K, i+K+1):\n                    if x >= 0 and x < m:\n                        if j-K <=0:\n                            if j+K >= n:\n                                answer[i][j] += dp[x][-1]\n                            else:\n                                answer[i][j] += dp[x][j+K]\n                        elif j-K <= n:\n                            if j+K >= n:\n                                answer[i][j] += dp[x][-1] - dp[x][j-K-1]\n                            else:\n                                answer[i][j] += dp[x][j+K] - dp[x][j-K-1]\n                            \n        return answer\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        def get_sum(i, j):\n            ssum = 0\n            for a in range(-K, K+1):\n                for b in range(-K, K+1):\n                    ssum += mat[i+a][j+b] if (0<=(i+a)<m and 0<=(j+b)<n) else 0 \n            return ssum\n        \n        res = [[0 for _ in range(n)] for _ in range(m)]\n\n        for i in range(m):\n            for j in range(n):\n                if i==0 and j==0:\n                    res[i][j] = get_sum(0, 0)\n                else:\n                    if i == 0:\n                        # reuse the result from left cell\n                        res[i][j] = res[i][j-1] - sum([mat[b][j-K-1] if (0<=(j-K-1)<n and 0<=b<m) else 0 for b in range(i-K, i+K+1)]) + sum([mat[b][j+K] if (0<=(j+K)<n and 0<=b<m) else 0 for b in range(i-K, i+K+1)])\n                    else:\n                        # reuse the result from top cell\n                        res[i][j] = res[i-1][j] - sum([mat[i-K-1][b] if (0<=(i-K-1)<m and 0<=b<n) else 0 for b in range(j-K, j+K+1)]) + sum([mat[i+K][b] if (0<=(i+K)<m and 0<=b<n) else 0 for b in range(j-K, j+K+1)])\n                        \n        return res\n                        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        def calc(mat, area):\n            (a, b), (c, d) = area\n            return sum([sum(row[b:d+1])for row in mat[a:c+1]])\n        \n        m = len(mat)-1\n        n = len(mat[0])-1\n        row = []\n        lookup = {}\n        for i, r in enumerate(mat):\n            col = []\n            for j, c in enumerate(mat[0]):\n                area = (0 if i-K < 0 else i-K, 0 if j-K < 0 else j-K), (m if i+K > m else i+K, n if j+K > n else j+K)\n                key = str(area)\n                if key not in lookup:\n                    lookup[key] = calc(mat, area)\n                col += [lookup[key]]\n            row += [col]\n        return row", "class Solution:\n    def matrixBlockSum(self, A: List[List[int]], K: int) -> List[List[int]]:\n      m, n = len(A), len(A[0])\n      def force_inside(ra, rb, ca, cb):\n        return max(0, ra), min(m, rb), max(0, ca), min(n, cb)\n\n      def rect(i, j):\n        return force_inside(i-K, i+K+1, j-K, j+K+1)\n\n      def sum_rect(ra, rb, ca, cb):\n        ra, rb, ca, cb = force_inside(ra, rb, ca, cb)\n        s = 0\n        for p in range(ra,rb):\n          for q in range(ca, cb):\n            s += A[p][q]\n        return s\n\n      S = [[0 for j in range(n)] for i in range(m)]\n      for i in range(m):\n        for j in range(n):\n          ra, rb, ca, cb = rect(i,j)\n          if i == 0 and j == 0:\n            S[i][j] = sum_rect(ra, rb, ca, cb)\n          else:\n            if j == 0:\n              i0, j0 = i-1, 0\n            else:\n              i0, j0 = i, j-1\n            ra0, rb0, ca0, cb0 = rect(i0,j0)\n            S[i][j] = S[i0][j0]\n            S[i][j] -= sum_rect(ra0, ra, ca, cb)\n            S[i][j] -= sum_rect(ra, rb, ca0, ca)\n            S[i][j] += sum_rect(rb0, rb, ca, cb)\n            S[i][j] += sum_rect(ra, rb, cb0, cb)\n      return S", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        rows = collections.defaultdict(list)\n        \n        for i,row in enumerate(mat):\n            s = 0\n            for v in row:\n                s+=v\n                rows[i].append(s)\n        # print(rows)\n            \n        m,n = len(mat), len(mat[0])\n        ans = [ [0]*n for _ in range(m) ]\n        for i in range(m):\n            for j in range(n):\n                ind = [max(0,j-K), min(n-1,j+K)]\n                \n                # print((i,j),(max(0,i-K), min(m,i+K+1)),ind)\n                for k in range(max(0,i-K), min(m,i+K+1)):\n                    sum = rows[k][ind[1]]\n                    if ind[0]>0: sum = rows[k][ind[1]]- rows[k][ind[0]-1]\n                    \n                    # print((k,ind),sum)\n                    ans[i][j]+=sum\n                # print('--------------------')\n        return ans", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        def calc(mat, area):\n            (a, b), (c, d) = area\n            return sum([sum(row[b:d+1])for row in mat[a:c+1]])\n        \n        m = len(mat)-1\n        n = len(mat[0])-1\n        row = []\n        lookup = {}\n        for i, r in enumerate(mat):\n            col = []\n            for j, c in enumerate(mat[0]):\n                \n                # make sure to have out-of-boundary case\n                area = (0 if i-K < 0 else i-K, 0 if j-K < 0 else j-K), \\\\\n                        (m if i+K > m else i+K, n if j+K > n else j+K)\n                \n                key = str(area)\n                if key not in lookup:\n                    lookup[key] = calc(mat, area)\n                col += [lookup[key]]\n            row += [col]\n        return row", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        def calc(mat, area):\n            (a, b), (c, d) = area\n            return sum([sum(row[b:d+1])for row in mat[a:c+1]])\n        \n        m = len(mat)-1\n        n = len(mat[0])-1\n        row = []\n        lookup = {}\n        for i, r in enumerate(mat):\n            col = []\n            for j, c in enumerate(mat[0]):\n                \n                # make sure to have out-of-boundary case\n                area = (0 if i-K < 0 else i-K, 0 if j-K < 0 else j-K), (m if i+K > m else i+K, n if j+K > n else j+K)\n                \n                key = str(area)\n                if key not in lookup:\n                    lookup[key] = calc(mat, area)\n                col += [lookup[key]]\n            row += [col]\n        return row", "from scipy import signal, ndimage\nimport numpy as np\n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        N = 2*K + 1\n        return signal.convolve2d(mat, np.ones((N,N)), mode='same').astype(int)\n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        def calc(mat, area):\n            (a, b), (c, d) = area\n            return sum([sum(row[b:d+1])for row in mat[a:c+1]])\n        \n        m = len(mat)-1\n        n = len(mat[0])-1\n        row = []\n        lookup = {}\n        for i, r in enumerate(mat):\n            col = []\n            for j, c in enumerate(mat[0]):\n                \n                # make sure to have out-of-boundary case\n                area = (0 if i-K < 0 else i-K, 0 if j-K < 0 else j-K), (m if i+K > m else i+K, n if j+K > n else j+K)\n                \n                key = str(area)\n                if key not in lookup:\n                    lookup[key] = calc(mat, area)\n                col += [lookup[key]]\n            row += [col]\n        return row\n", "from scipy import signal\nimport numpy as np\n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        N = 2*K + 1\n        return signal.convolve2d(mat, np.ones((N,N)), mode='same').astype(int)\n        \n", "# class Solution:\n#     def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n#         row = len(mat)\n#         col = len(mat[0])\n        \n#         answer = [[0 for i in range(col)] for j in range(row)]\n        \n#         for i in range(row):\n#             for j in range(1,col):\n#                 # answer[i][j] = self.new_matrix(mat,i,j,K,row,col)\n#                 mat[i][j] = mat[i][j-1]+mat[i][j]\n#         print(mat)\n        \n#         for i in range(row):\n#             for j in range(col):\n#                 answer[i][j] = self.new_matrix(mat,i,j,K,row,col)\n#         return answer\n                \n#     def new_matrix(self,mat,i,j,k,row,col):\n#         ans = 0 \n#         new_row_low = i-k\n#         new_row_high = i + k\n#         new_col_low = j-k\n#         new_col_high = j+k\n        \n        \n#         while(new_row_low < 0):\n#             new_row_low +=1\n#         while(new_row_high > row-1):\n#             new_row_high -=1\n#         while(new_col_low < 0):\n#             new_col_low +=1\n#         while(new_col_high > col-1):\n#             new_col_high-=1\n        \n        \n        \n#         for a in range(new_row_low, new_row_high+1):\n            \n#             ans+= mat[a][new_col_high]\n            \n#             if(new_col_low-1 >= 0):\n                \n#                 ans -= mat[a][new_col_low-1]\n                \n#         return ans\n                    \n            \n        \nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        blockSum = [[0] * len(mat[0]) for _ in range(len(mat))]\n        \n        accumSum = [[0] * (len(mat[0]) + 1) for _ in range(len(mat) + 1)]\n        for x in range(len(mat)):\n            for y in range(len(mat[0])):\n                accumSum[x + 1][y + 1] = (accumSum[x][y + 1] if x >= 0 else 0) + (accumSum[x + 1][y] if y >= 0 else 0) - (accumSum[x][y] if x >= 0 and y >= 0 else 0) + mat[x][y]\n                \n        for x in range(len(mat)):\n            for y in range(len(mat[0])):\n                blockSum[x][y] = accumSum[max(x - K, 0)][max(y - K, 0)] + accumSum[min(x + K + 1, len(mat))][min(y + K + 1, len(mat[0]))] - accumSum[max(x - K, 0)][min(y + K + 1, len(mat[0]))] - accumSum[min(x + K + 1, len(mat))][max(y - K, 0)]\n        \n        return blockSum        \n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        p = []\n        for i in range(m):\n            row = [0]\n            s = 0\n            for j in range(n):\n                s += mat[i][j]\n                row.append(s)\n            p.append(row)\n        \n        ans = []\n        for i in range(m):\n            row = []\n            for j in range(n):\n                s = 0\n                top = max(0, i - k)\n                bottom = min(m, i + k + 1)\n                for g in range(top, bottom):\n                    left = max(0, j - k)\n                    right = min(n, j + k + 1)\n                    s += p[g][right] - p[g][left]\n                row.append(s)\n            ans.append(row)\n        return ans\n", "# # Brute Force: TLE\n# def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n#     m, n = len(mat), len(mat[0])\n#     ans = [[0 for _ in range(n)] for _ in range(m)]\n#     for i in range(m):\n#         for j in range(n):\n#             res = 0\n#             for block_row in range(max(0, i-K), min(m, i+K+1)):\n#                 for block_col in range(max(0, j-K), min(n, j+K+1)):\n#                     res += mat[block_row][block_col]\n#             ans[i][j] = res                                           \n#     return ans    \n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        ans = [[0 for _ in range(n)] for _ in range(m)]\n        \n        # Convert mat to accumulate sum for each row\n        for i in range(m):\n            for j in range(1, n):\n                mat[i][j] += mat[i][j-1]\n        \n        for i in range(m):\n            for j in range(n):\n                res = 0\n                for block_row in range(max(0, i-K), min(m, i+K+1)):\n                    res += mat[block_row][min(n-1, j+K)]\n                    if j - K - 1 >= 0:\n                        res -= mat[block_row][j-K-1]\n                ans[i][j] = res                                           \n        return ans        ", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        acc = [[0] + list(accumulate(m)) for m in mat]\n        print(acc)\n        m, n = len(mat), len(mat[0])\n        ans = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                for k in range(max(i - K, 0), min(i + K, m - 1) + 1):\n                    l, r = max(j - K, 0), min(j + K, n - 1)\n                    ans[i][j] += acc[k][r + 1] - acc[k][l]\n        return ans\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        # the last index of rows\n        m = len(mat) - 1\n        # the last index of columns\n        n = len(mat[0]) - 1\n        row = []\n        lookup = {}\n        for i, r in enumerate(mat):\n            col = []\n            for j, c in enumerate(mat[0]):\n                area = (0 if i-K<0 else i-K, 0 if j-K<0 else j-K), (m if i+K>m else i+K, n if j+K>n else j+K)\n                key = str(area)\n                if key not in lookup:\n                    lookup[key] = self.matrixBlockSumHelp(mat, area)\n                col += [lookup[key]]\n            row += [col]\n            \n        return row\n    \n    def matrixBlockSumHelp(self, mat, area):\n        (a, b), (c, d) = area\n        return sum([sum(row[b:d+1]) for row in mat[a:c+1]])", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        # mat2 = mat[:]   # can not 2-d matrix\n        mat2 = copy.deepcopy(mat)\n        \n        def help(i,j, K):\n            res = 0\n            for ii in range(i-K, i+K+1):\n                for jj in range(j-K, j+K+1):\n                    if 0<=ii<len(mat) and 0<=jj<len(mat[0]):\n                        res += mat[ii][jj]\n            return res\n        \n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                # print(mat)\n                if j == 0:\n                    mat2[i][j] = help(i,j, K)\n                else:\n                    mat2[i][j] = mat2[i][j-1]\n                    if j+K<len(mat[0]):\n                        for ii in range(i-K, i+K+1):\n                            if 0<=ii<len(mat):\n                                mat2[i][j] += mat[ii][j+K]\n                    if j-K-1>=0:\n                        for ii in range(i-K, i+K+1):\n                            if 0<=ii<len(mat):\n                                mat2[i][j] -= mat[ii][j-K-1]\n                    \n        return mat2\n", "from itertools import accumulate \nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        A = mat.copy()\n        for i in range(len(A)):\n            A[i] = [0]+list(accumulate(A[i]))\n        Ans = [[0 for i in range(len(A[0]))] for j in range(len(A))] \n        for i in range(len(A)):\n            for j in range(1,len(A[0])):\n                #print(max(0,i-K),min(len(A),i+K))\n                for p in range(max(0,i-K),min(len(A)-1,i+K)+1):\n                    #print(A[p],p)\n                    #print(min(j+K,len(A[0])),max(0,j-K))\n                    Ans[i][j] += A[p][min(j+K,len(A[0])-1)]-A[p][max(0,j-K-1)]\n        for i in range(len(Ans)):\n            Ans[i] = Ans[i][1:]\n        return Ans    \n                \n        \n", "from itertools import accumulate \nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        A = mat.copy()\n        for i in range(len(A)):\n            A[i] = [0]+list(accumulate(A[i]))\n        Ans = [[0 for i in range(len(A[0]))] for j in range(len(A))] \n        for i in range(len(A)):\n            for j in range(1,len(A[0])):\n                for p in range(max(0,i-K),min(len(A)-1,i+K)+1):\n                    Ans[i][j] += A[p][min(j+K,len(A[0])-1)]-A[p][max(0,j-K-1)]\n        for i in range(len(Ans)):\n            Ans[i] = Ans[i][1:]\n        return Ans    \n                \n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        m,n = len(mat), len(mat[0])\n        ans = [[0]*n for i in range(m)]\n        prefix = [[0]*(n+1) for i in range(m)]\n        for i in range(m):\n            for j in range(n):\n                prefix[i][j] = prefix[i][j-1] + mat[i][j]\n\n        for i in range(m):\n            for j in range(n):\n                for s in range(k+1):\n                    if i-s < 0: break\n                    ans[i][j] += prefix[i-s][min(n-1,j+k)]-prefix[i-s][max(-1,j-k-1)]\n                for s in range(1,k+1):\n                    if i+s > m-1: break\n                    ans[i][j] += prefix[i+s][min(n-1,j+k)]-prefix[i+s][max(-1,j-k-1)]\n        return ans ", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n            m,n = len(mat), len(mat[0])\n            ans = [[0]*n for i in range(m)]\n            prefix = [[0]*(n+1) for i in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    prefix[i][j] = prefix[i][j-1] + mat[i][j]\n\n            for i in range(m):\n                for j in range(n):\n                    for s in range(k+1):\n                        if i-s < 0: break\n                        ans[i][j] += prefix[i-s][min(n-1,j+k)]-prefix[i-s][max(-1,j-k-1)]\n                    for s in range(1,k+1):\n                        if i+s > m-1: break\n                        ans[i][j] += prefix[i+s][min(n-1,j+k)]-prefix[i+s][max(-1,j-k-1)]\n            return ans ", "import numpy as np\n\n\nclass Solution:\n    \n    def matrixBlockSum(self, mat, k):\n        p = 2*k + 1\n        m, n = len(mat), len(mat[0])\n        array = np.zeros((m + p, n + p), dtype=np.uint32)\n        array[k+1:-k,k+1:-k] = mat\n        np.cumsum(array, axis=0, out=array)\n        np.cumsum(array, axis=1, out=array)\n        return array[p:,p:] - array[p:,:-p] - array[:-p,p:] + array[:-p,:-p]\n\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        if not mat: return []\n        \n        m = len(mat)\n        n = len(mat[0])\n        \n        get = lambda i, j: mat[i][j] if 0 <= i < m and 0 <= j < n else 0\n        row = lambda i, j: sum([get(i, y) for y in range(j - K, j + K + 1)])\n        col = lambda i, j: sum([get(x, j) for x in range(i - K, i + K + 1)])\n        \n\n        answer = [[0] * n for _ in range(m)]\n        \n        for i in range(0, K + 1):\n            for j in range(0, K + 1):\n                answer[0][0] += get(i, j)\n\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0: continue\n                if j == 0:\n                    answer[i][j] = answer[i - 1][j] - row(i - K - 1, j) + row(i + K, j)\n                else:\n                    answer[i][j] = answer[i][j - 1] - col(i, j - K - 1) + col(i, j + K)\n                \n        return answer\n", "import numpy as np\nimport scipy.signal\n#convolve2d as convolv\n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        mat = np.array(mat)\n        return scipy.signal.convolve2d(mat, np.ones((2*K +1, 2*K + 1)), mode=\\\"same\\\").astype('int')\n        ", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n = len(mat)\n        m = len(mat[0])\n        answer = [[0] * m for i in range(n)]\n      \n        maxo = max\n        sumo = sum\n        for i in range(n):\n            for j in range(m):\n                r = maxo(0, i-K)           \n                sum1 = 0\n                while r <= i+K and r < n:\n                    \n                    if j-K < 0:\n                        if j+K < m:\n                            sum1 += sumo(mat[r][:j+K+1])\n                        else:\n                            sum1 += sumo(mat[r])\n                    else:\n                        if j+K < m:\n                            sum1 += sumo(mat[r][j-K:j+K+1])\n                        else:\n                            sum1 += sumo(mat[r][j-K:])\n                        \n                    r += 1\n                answer[i][j] = sum1\n            \n        return answer", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n = len(mat)\n        m = len(mat[0])\n        answer = [[0] * m for i in range(n)]\n        r = 0\n        c = 0\n        maxo = max\n        sumo = sum\n        for i in range(n):\n            for j in range(m):\n                r = maxo(0, i-K)           \n                sum1 = 0\n                while r <= i+K and r < n:\n                    if j-K < 0:\n                        if j+K < m:\n                            sum1 += sumo(mat[r][:j+K+1])\n                        else:\n                            sum1 += sumo(mat[r])\n                    else:\n                        if j+K < m:\n                            sum1 += sumo(mat[r][j-K:j+K+1])\n                        else:\n                            sum1 += sumo(mat[r][j-K:])\n                        \n                    r += 1\n                answer[i][j] = sum1\n            \n        return answer", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n = len(mat)\n        m = len(mat[0])\n        answer = [[0] * m for i in range(n)]\n        r = 0\n        c = 0\n        \n        for i in range(n):\n            tmp = []\n            for j in range(m):\n                if i - K < 0:\n                    r = 0\n                else:\n                    r = i-K\n                \n                sum1 = 0\n                while r <= i+K and r < n:\n                    if j-K < 0:\n                        if j+K < m:\n                            sum1 += sum(mat[r][:j+K+1])\n                        else:\n                            sum1 += sum(mat[r])\n                    else:\n                        if j+K < m:\n                            sum1 += sum(mat[r][j-K:j+K+1])\n                        else:\n                            sum1 += sum(mat[r][j-K:])\n                        \n                    r += 1\n                answer[i][j] = sum1\n            \n        return answer", "class Solution:\n    def sumHelper(self, mat: List[List[int]], rowLow: int, rowHigh: int, colLow: int, colHigh: int) -> int:\n        res = sum(sum(row[colLow:colHigh+1]) for row in mat[rowLow:rowHigh + 1])\n        return res\n    \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        rows = len(mat)\n        cols = len(mat[0])\n        res = [[0 for c in range(cols)] for r in range(rows)]\n        \n        for r in range(rows):\n            for c in range(cols):\n                lowR = r - K\n                if (lowR < 0): lowR = 0\n                highR = r + K\n                if (highR >= rows): highR = rows - 1\n                    \n                lowC = c - K\n                if (lowC < 0): lowC = 0\n                highC = c + K\n                if (highC >= cols): highC = cols - 1\n        \n                res[r][c] = self.sumHelper(mat, lowR, highR, lowC, highC)\n        \n        return res", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        answer = [[0 for j in i] for i in mat]\n        def calc(mat,a,b,c,d):\n            return sum([sum(row[b:d+1])for row in mat[a:c+1]])\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                a = i-K if i-K>=0 else 0\n                b = j-K if j-K>=0 else 0\n                c = i+K if i+K<=len(mat) else len(mat)\n                d = j+K if j+K<=len(mat[0]) else len(mat[0])\n                answer[i][j]=calc(mat,a,b,c,d)\n        return answer", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat[0]), len(mat)\n        dp = [[0]*m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = sum(sum(mat[col][max(0,j-K):j+K+1]) for col in\n                               range(max(0,i-K),min(i+K+1,n)))\n        return dp\n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        def matsum(mat, x1, y1, x2, y2):\n            sumi = 0\n            #print(x1, y1, x2, y2)\n            for row in mat[x1:x2+1]:\n                #print(row)\n                sumi += sum(row[y1:y2+1])\n                #print(sumi)\n            return sumi\n        \n        newmat = [[0]*len(row) for row in mat]\n        for ri, row in enumerate(mat):\n            \n            for ci, i in enumerate(row):\n                #print(ri, ci)\n                newmat[ri][ci] = matsum(mat, max(0, ri-K), max(0, ci-K), min(len(mat)-1, ri+K), min(len(row)-1, ci+K))\n        return newmat\n", "class Solution:\n    def prefix(self, d, i, j):\n        if i<0 or j<0:\n            return 0\n        if i>=len(d):\n            i = len(d)-1\n        if j>=len(d[0]):\n            j = len(d[0])-1\n        return d[i][j]\n            \n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        d = mat\n        row = len(mat)\n        col = len(mat[0])\n        for i in range(row):\n            for j in range(col):\n                d[i][j]+=self.prefix(d, i-1,j) + self.prefix(d, i,j-1) - self.prefix(d, i-1,j-1)\n        res = [[0]*col for _ in range(row)]\n        for i in range(row):\n            for j in range(col):\n                res[i][j] = self.prefix(d, i+k, j+k) \\\\\n                            - self.prefix(d, i+k, j-k-1) \\\\\n                            - self.prefix(d, i-k-1, j+k) \\\\\n                            + self.prefix(d, i-k-1, j-k-1)\n                            \n        return res\n        ", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        answer = []\n        r = 0\n        c = 0\n        \n        for i in range(len(mat)):\n            tmp = []\n            for j in range(len(mat[0])):\n                if i - K < 0:\n                    r = 0\n                else:\n                    r = i-K\n                \n                sum1 = 0\n                while r <= i+K and r < len(mat):\n                    if j-K < 0:\n                        if j+K < len(mat[0]):\n                            sum1 += sum(mat[r][:j+K+1])\n                        else:\n                            sum1 += sum(mat[r])\n                    else:\n                        if j+K < len(mat[0]):\n                            sum1 += sum(mat[r][j-K:j+K+1])\n                        else:\n                            sum1 += sum(mat[r][j-K:])\n                        \n                    r += 1\n                tmp.append(sum1)\n            answer.append(tmp)\n        return answer", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        def sumMatrix(center: tuple):\n            Sum = 0\n            \n            start_i = max(center[0] - K, 0)\n            stop_i = min(center[0] + K + 1, len(mat[0]))\n            \n            start_j = max(center[1] - K, 0)\n            stop_j = min(center[1] + K + 1, len(mat))\n            \n            for j in range(start_j, stop_j):\n                Sum += sum(mat[j][start_i:stop_i])\n            print('start_i', start_i, 'stop_i', stop_i, 'start_j', start_j, 'stop_j', stop_j)\n            print('sum', Sum)\n            return Sum\n        res = []\n        for i in range(len(mat)):\n            res.append([])\n            for j in range(len(mat[i])):\n                res[i].append(sumMatrix((j ,i)))\n        return res", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        \n        m = len(mat)\n        n = len(mat[0])\n        out = [[ 0 for x in range ( 0 , n)] for y in range ( m)]\n        for i in range ( 0,m):\n            for j in range ( 0,n):\n                \n                r_low= max ( 0, i-K)\n                r_high= min(i+K, m)\n                \n                c_low=max( 0, j-K)\n                c_high=min(j+K, n)\n                #print(r_low, r_high)\n                #print(c_low, c_high)\n                \n                s = 0 \n                for i2 in range ( r_low, min(r_high+1,m) ):\n                    #print(  mat[i2] [ c_low:c_high+1])\n                    s += sum ( mat[i2] [ c_low:c_high+1] )\n                print((i,j, n,m))\n                out[i][j] = s \n                #print(s,out[i][j])\n                #print(out)\n                #print(\\\"--\\\")\n        \n        return out \n", "class Solution:   \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        valid_row_indexes = range(len(mat))\n        valid_col_indexes = range(len(mat[0]))\n        answer = [[0]*len(mat[0]) for _ in range(len(mat))]\n        for r in valid_row_indexes:\n            for c in valid_col_indexes:\n                left = c-K if c-K in valid_col_indexes else None\n                right = c+K+1 if c+K in valid_col_indexes else None\n                answer[r][c] += sum([sum(mat[i][left:right]) for i in range(r-K, r+K+1) if i in valid_row_indexes])\n        return answer                ", "class Solution:\n    def matrixBlockSum(self, mat: list, K: int):\n        def calc_surround(r, c):\n            nonlocal mat, K\n            total = 0\n            for i in range(r-K, r+K+1):\n                for j in range(c-K, c+K+1):\n                    if 0 <= i < len(mat) and 0 <= j < len(mat[0]):\n                        total += mat[i][j]\n            return total\n\n        def calc_left_column(r, c):\n            nonlocal mat, K\n            total = 0\n            for i in range(r-K, r+K+1):\n                if 0 <= i < len(mat) and 0 <= c - K - 1 < len(mat[0]):\n                    total += mat[i][c-K-1]\n            return total\n\n        def calc_right_column(r, c):\n            nonlocal mat, K\n            total = 0\n            for i in range(r-K, r+K+1):\n                if 0 <= i < len(mat) and 0 <= c + K < len(mat[0]):\n                    total += mat[i][c+K]\n            return total\n\n        grid = [[0] * len(mat[0]) for _ in range(len(mat))]\n        for i in range(len(mat)):\n            cache = 0\n            for j in range(len(mat[0])):\n                if j == 0:\n                    cache = calc_surround(i, j)\n                else:\n                    left_c = calc_left_column(i, j)\n                    right_c = calc_right_column(i, j)\n                    cache = cache - left_c + right_c\n                grid[i][j] = cache\n        return grid", "from copy import deepcopy\n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        matrix = deepcopy(mat)\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                top = max(0, i - K)\n                bottom = min(len(mat), i + K + 1)\n                left = max(0, j - K)\n                right = min(len(mat[0]), j + K + 1)\n                matrix[i][j] = sum(map(sum, [row[left:right] for row in mat][top:bottom]))\n        return matrix", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n= len(mat)\n        m = len(mat[0])\n        matx = []\n        for i in range (n):\n            row = []\n            for j in range (m):\n                summ = 0\n                for y in range (max(0,i-K),min(n,i+K+1)):\n                    summ = summ + sum(mat[y][max(0,j-K):min(m,j+K+1)])\n                row.append(summ)\n            print (row)\n            matx.append(row)\n        return(matx)", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        if K==0:\n            return mat.copy()\n        \n        answers = []\n        dp = []\n        for row in mat:\n            answers.append(row.copy())\n            dp.append(row.copy())\n            \n        # add first line of dp\n        count = mat[0][0]\n        for j in range(1,len(mat[0])):\n            count += mat[0][j]\n            dp[0][j] = count\n            \n        for i in range(1,len(mat)):\n            count = 0\n            for j in range(len(mat[0])):\n                count += mat[i][j]\n                dp[i][j] = count + dp[i-1][j]\n        \n        \n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                \n                x_outer = i+K if i+K < len(mat)-1 else len(mat)-1\n                y_outer = j+K if j+K < len(mat[0])-1 else len(mat[0])-1\n                \n                total = dp[x_outer][y_outer]\n                if i-K > 0 and j-K > 0:\n                    total += dp[i-K-1][j-K-1]\n                if j-K > 0:\n                    total -= dp[x_outer][j-K-1]\n                if i-K > 0:\n                    total -= dp[i-K-1][y_outer]\n                \n                print((i,j,[i-K-1,j-K-1],[x_outer,y_outer], total))\n                answers[i][j] = total\n                \n        print(dp)\n            \n        return answers\n        \n        \n        \n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m,n=len(mat),len(mat[0])\n        if K>=max(m-1,n-1):\n            return [[sum([sum(i) for i in mat])]*n for _ in range(m)]\n        res=[[0]*n for _ in range(m)]\n        for r in range(m):\n            for c in range(n):\n \n                res[r][c]=sum([sum(i[max(c-K,0):min(n,c+K+1)]) for i in mat[max(0,r-K):min(m,r+K+1)]])\n        return res", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m,n = len(mat), len(mat[0])\n        # result_mat = [[0]*n]*m\n        result_mat = []\n        for i in range(m):\n            result_mat.append([0]*n)\n        \n        for i in range(m):\n            for j in range(n):\n                result_mat[i][j] = sum([sum(mat[k][max(0,j-K):min(n,j+K+1)]) for k in range(max(0,i-K),min(m,i+K+1))])\n        \n        return result_mat", "class Solution:\n    def matrixBlockSum(self, mat, K):\n\n\n        def idx(i, j):\n\n            return i * len(mat[j]) + j\n\n        prefixSum = dict()\n        prefixSum[-1] = 0\n        currSum = 0\n        for i in range(len(mat)):\n            for j in range(len(mat[i])):\n                currSum += mat[i][j]\n                prefixSum[idx(i, j)] = currSum\n\n        answer = [[0 for c in range(len(mat[r]))] for r in range(len(mat))]\n\n        for r in range(len(mat)):\n            for c in range(len(mat[r])):\n                currSum = 0\n                for i in range(max(r - K, 0), min(r + K + 1, len(mat))):\n                    currSum += prefixSum[idx(i, min(c + K, len(mat[i]) - 1))] - \\\\\n                        prefixSum[idx(i, max(c - K, 0) - 1)]\n\n                answer[r][c] = currSum\n\n        return answer\n\n        \n        ", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n = len(mat)\n        m = len(mat[0])\n        answer = [[0] * m for i in range(n)]\n      \n        maxo = max\n        sumo = sum\n        mino = min\n        for i in range(n):\n            for j in range(m):\n                r = maxo(0, i-K)           \n                sum1 = 0\n                while r <= i+K and r < n:\n                    sum1 += sumo(mat[r][maxo(0,j-K):mino(m, j+K+1)])\n                        \n                    r += 1\n                answer[i][j] = sum1\n            \n        return answer", "class Solution:\n    def distk(self,k,rowsum,colsum,i,j):\n        s=0\n        m=len(rowsum)\n        n=len(rowsum[0])\n        if(i-k>=0):\n            l=max(-1,j-k-1)\n            h=min(n-1,j+k)\n            s+=rowsum[i-k][h]\n            if(l>-1):\n                s-=rowsum[i-k][l]\n       \n        if(i+k<m):\n            l=max(-1,j-k-1)\n            h=min(n-1,j+k)\n            s+=rowsum[i+k][h]\n            if(l>-1):\n                s-=rowsum[i+k][l]\n      \n        if(j-k>=0):\n            l=max(-1,i-k)\n            h=min(m-1,i+k-1)\n            s+=colsum[h][j-k]\n            if(l>-1):\n                s-=colsum[l][j-k]\n       \n        if(j+k<n):\n            l=max(-1,i-k)\n            h=min(m-1,i+k-1)\n            s+=colsum[h][j+k]\n            if(l>-1):\n                s-=colsum[l][j+k]\n\n        return s\n            \n            \n            \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m=len(mat)\n        n=len(mat[0])\n        if(K<=0):\n            return mat\n        rowsum=[[0 for i in range(n)] for j in range(m)]\n        colsum=[[0 for i in range(n)] for j in range(m)]\n        for i in range(m):\n            rowsum[i][0]=mat[i][0]\n            for j in range(1,n):\n                rowsum[i][j]+=rowsum[i][j-1]+mat[i][j]\n        for i in range(n):\n            colsum[0][i]=mat[0][i]\n            for j in range(1,m):\n                colsum[j][i]+=colsum[j-1][i]+mat[j][i]\n        # print(rowsum,colsum)\n        ans=[[mat[j][i] for i in range(n)] for j in range(m)]\n        \n        for k in range(1,K+1):\n            for i in range(m):\n                for j in range(n):\n                    x=self.distk(k,rowsum,colsum,i,j)\n                    \n                    ans[i][j]+=x\n        return ans\n                    \n            \n        \n", "class Solution:\n    def distk(self,k,rowsum,colsum,i,j):\n        s=0\n        m=len(rowsum)\n        n=len(rowsum[0])\n        if(i-k>=0):\n            l=max(-1,j-k-1)\n            h=min(n-1,j+k)\n            s+=rowsum[i-k][h]\n            if(l>-1):\n                s-=rowsum[i-k][l]\n       \n        if(i+k<m):\n            l=max(-1,j-k-1)\n            h=min(n-1,j+k)\n            s+=rowsum[i+k][h]\n            if(l>-1):\n                s-=rowsum[i+k][l]\n      \n        if(j-k>=0):\n            l=max(-1,i-k)\n            h=min(m-1,i+k-1)\n            s+=colsum[h][j-k]\n            if(l>-1):\n                s-=colsum[l][j-k]\n       \n        if(j+k<n):\n            l=max(-1,i-k)\n            h=min(m-1,i+k-1)\n            s+=colsum[h][j+k]\n            if(l>-1):\n                s-=colsum[l][j+k]\n\n        return s      \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m=len(mat)\n        n=len(mat[0])\n        if(K<=0):\n            return mat\n        rowsum=[[0 for i in range(n)] for j in range(m)]\n        colsum=[[0 for i in range(n)] for j in range(m)]\n        for i in range(m):\n            rowsum[i][0]=mat[i][0]\n            for j in range(1,n):\n                rowsum[i][j]+=rowsum[i][j-1]+mat[i][j]\n        for i in range(n):\n            colsum[0][i]=mat[0][i]\n            for j in range(1,m):\n                colsum[j][i]+=colsum[j-1][i]+mat[j][i]\n        # print(rowsum,colsum)\n        ans=[[mat[j][i] for i in range(n)] for j in range(m)]\n        \n        for k in range(1,K+1):\n            for i in range(m):\n                for j in range(n):\n                    x=self.distk(k,rowsum,colsum,i,j)\n                    \n                    ans[i][j]+=x\n        return ans\n                    \n            \n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        # naive: always recomput block k*k for O(N*M) positions\n        # better: for large k, compute once then advance j by removing leftcol and adding rightcol, etc\n          # save rowsum and colsum O(N+M) mem then use to derive a given block?\n            # BUT we can't derive middle k slices of row/col  unless we do k rows....\n          # O(N*M)*()\n        N,M = len(mat),len(mat[0])\n        ans = [[0]*M for i in range(N)]\n        \n        def getBlockSum(i,j):\n          # print(f'{i},{j}')\n          rows = mat[max(0,i-K):i+K+1]  # [-1:2] -> empty!!\n          # print(f'{rows}')\n          block = list(zip(*rows))[max(0,j-K):j+K+1]\n          # print(f'{block}')\n          return sum(sum(blockrow) for blockrow in block)\n        \n        for i in range(N):\n          for j in range(M):\n            ans[i][j] = getBlockSum(i,j)\n        \n        return ans\n        \n        # rowSums,colSums = [0]*N,[0]*M\n        # for i in range(N):\n        #   rowSums[i] = sum(mat[i])\n        # for j in range(M):\n          # colSums[i] = sum(zip(*mat)[j])  #sum([mat[i][j] for i in range(N)])   # \n        \n", "class Solution:\n    \n    numRows = 0\n    numCols = 0\n    mat = [[]]\n    K = 0\n    \n    def getBounds(self, row, col):\n        return [(max(row-self.K, 0), max(col-self.K, 0)),   \\\\\n                (min(row+self.K,self.numRows-1), min(col+self.K,self.numCols-1))]\n    \n    def getBlockSum(self, bounds):\n        ret = 0\n        rowRestricted = self.mat[bounds[0][0] : bounds[1][0]+1]\n        for row in rowRestricted:\n            ret += sum(row[bounds[0][1]:bounds[1][1]+1])\n        return ret\n    \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        ret = []\n        self.numRows = len(mat)\n        self.numCols = len(mat[0])   #numCols >= 1\n        self.mat = mat\n        self.K = K\n        \n        for row in range(self.numRows):\n            tmpRow = []\n            for col in range(self.numCols):\n                bounds = self.getBounds(row, col)\n                tmpRow.append(self.getBlockSum(bounds))\n            ret.append(tmpRow)\n        \n        return ret", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        \n        for r in range(m):\n            mat[r] = [0]*K + mat[r] + [0]*K\n        for i in range(K):\n            mat = [[0]*(n+2*K)] + mat + [[0]*(n+2*K)]\n        ret = []\n        print(mat)\n        for i in range(m):\n            this = []\n            for j in range(n):\n                I, J = i+K, j+K\n                add = sum([sum(mat[r][J-K:J+K+1]) for r in range(I-K, I+K+1)])\n                # print(mat[r][J-K:J+K])\n                this.append(add)\n                # this.append(sum([sum(mat[r][c] for c in range(J-K, J+K)) for r in range(I-K, I+K)]))\n            ret.append(this)\n        return ret\n                \n            \n              \n", "class Solution:\n    def getArrIJ(self, i: int, j: int, arr: List[List[int]]) -> int:\n        if i >= len(arr) and j >= len(arr[0]):\n            return arr[len(arr) - 1][len(arr[0]) - 1]\n        if i >= len(arr):\n            return arr[len(arr) - 1][j]\n        if j >= len(arr[0]):\n            return arr[i][len(arr[0]) - 1]\n\n        if i < 0 and j < 0:\n            return arr[0][0]\n        if i < 0:\n            return arr[0][j]\n        if j < 0:\n            return arr[i][0]\n        \n        return arr[i][j]\n    \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        \n        res = []\n        for i in range(K + 1):\n            res.append([0] * (n + 2 * (K + 1)))\n        for i in range(m):\n            res.append([0] * (K + 1) + mat[i] + [0] * (K + 1))\n        for i in range(K + 1):\n            res.append([0] * (n + 2 * (K + 1)))\n\n        for i in range(1,m+2*(K+1)):\n            for j in range(1,n+2*(K+1)):\n                res[i][j] = res[i][j] + res[i-1][j] + res[i][j - 1] - res[i - 1][j - 1]\n\n        # print(res)       \n        for i in range(K+1,m+K+1):\n            for j in range(K+1,n+K+1):\n                # print(f'mat[{i-K}][{j-K}] = res[{i + K}][{j + K}] - (res[{i + K}][{j - K - 1}] + res[{i - K - 1}][{j + K}] - res[{i - K - 1}][{j - K - 1}])')\n                mat[i-K-1][j-K-1] = res[i + K][j + K] - (res[i + K][j - K - 1] + res[i - K - 1][j + K] - res[i - K - 1][j - K - 1])\n        return mat\n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m=len(mat)\n        n=len(mat[0])\n        ans=[[0 for i in range(n)] for j in range(m)]\n        for i in range(m):\n            for j in range(n):\n                for l in range(max(0,i-K),min(i+K+1,m)):\n                    ans[i][j]+=sum(mat[l][max(0,j-K):min(j+K+1,n)])\n                    \n        return ans", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        m, n = len(mat), len(mat[0])\n        \n        padded_mat = []\n        for i in range(K):\n            padded_mat.append([0]*(n+2*K))\n            \n        for i in range(m):\n            padded_mat.append([0]*K+mat[i]+[0]*K)\n            \n        for i in range(K):\n            padded_mat.append([0]*(n+2*K))\n        \n        sum_mat = []\n        for i in range(m):\n            sum_mat.append([0]*n)\n\n        for i in range(m):\n            for j in range(n):\n                sum_mat[i][j] = sum([sum(row[j:j+2*K+1]) for row in padded_mat[i:i+2*K+1]])\n            \n        return sum_mat", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        row_size,col_size = len(mat),len(mat[0])\n        ans = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\n        for x in mat:\n            for _ in range(K):\n                x.append(0)\n                x.insert(0,0)\n        row = [[0 for _ in range(len(mat[0]))] for _ in range(K)]\n        mat =  row + mat + row\n        print(mat)\n        \n        for r in range(K,K+row_size):\n            for c in range(K,K+col_size):\n                ans[r-K][c-K] = sum(sum(s[c-K:c+K+1]) for s in mat[r-K:r+K+1])\n        return ans\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        height = len(mat)\n        width = len(mat[0])\n        \n        z = [[None for _ in range(width)] for _ in range(height)]\n        \n        for x in range(width):\n            for y in range(height):\n                z[y][x] = sum(\n                    [\n                        i for j in [\n                        row[max(x - K, 0): x + K + 1] for row in mat[max(y - K, 0): y + K + 1]\n                        ] for i in j\n                    ]\n                ) \n        \n        \n        return z", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        prev = 0\n        \n        answer = []\n        \n        for row in range(len(mat)):\n            answer.append([])\n            for col in range(len(mat[0])):\n                # sub = 0\n                # if col-k >= 0:\n                l = max(0, col-k)\n                r = min(col+k+1, len(mat[0]))\n                t = max(0, row-k)\n                b = min(row+k+1, len(mat))\n                #print(row, col)\n                submat = [mat[i][l:r] for i in range(t,b)]\n                \n                total = 0\n                for one in submat:\n                    for two in one:\n                        total += two\n                answer[-1].append(total)\n                \n                #print(submat)\n                #print(total)\n#                 add = 0\n                \n#                 value = prev - () + ()\n#                 answer.append(value)\n\n        return answer", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        dp = []\n        for i in range(m + 2 * K):\n            row = []\n            for j in range(n + 2 * K):\n                row.append(0)\n            dp.append(row)\n                \n        for i in range(m):\n            for j in range(n):\n                dp[K + i][K + j] = mat[i][j]\n        \n        for i in range(m):\n            \n            for j in range(n):\n                temp = 0\n                for i1 in range(-K, K + 1):\n                    temp += sum(dp[i1 + K + i][j:j + 2 * K + 1])\n                \n                mat[i][j] = temp\n        return mat", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        answer = [[0 for i in range(n)] for i in range(m)]\n        \n        '''\n        answer[i][j] = sum(mat[r][c]) \n            for K <= r <= i + K \n            for j - K <= c <= j + K\n        '''\n        \n        for i in range(n):\n            for j in range(m):\n                c_lower = max(0, i - K)\n                c_upper = min(i + K + 1, n)\n                r_lower = max(0, j - K)\n                r_upper = min(j + K + 1, m)\n                print((m, n))\n                print(((r_lower, r_upper),(c_lower, c_upper)))\n                answer[j][i] = sum([mat[r][c] for r in range(r_lower, r_upper) for c in range(c_lower, c_upper)])\n                \n        return answer\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        M = len(mat)\n        N = len(mat[0])\n        \n        def get_sum(i,j):\n            def get_range(v, lim):\n                return [x for x in range(v-K,v+K+1) if x >= 0 and x < lim]\n            ir = get_range(i, M)\n            jr = get_range(j, N)\n            return sum([mat[x][y] for x in ir for y in jr])\n\n        res = []\n        for i in range(len(mat)):\n            res.append([])\n            for j in range(len(mat[i])):\n                res[i].append(get_sum(i,j))\n        return res", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        answer = [[None for _ in range(len(mat[0]))] for __ in range(len(mat))]\n        prefix_sum = [[0 for _ in range(len(mat[0]))] for __ in range(len(mat))]\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                prefix_sum[i][j] += mat[i][j]\n                prefix_sum[i][j] += prefix_sum[i - 1][j] if 0 <= i - 1 else 0\n                prefix_sum[i][j] += prefix_sum[i][j - 1] if 0 <= j - 1 else 0\n                prefix_sum[i][j] -= prefix_sum[i - 1][j - 1] if (0 <= i - 1 and 0 <= j - 1) else 0\n        print(prefix_sum)\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                bottom_right = prefix_sum[min(i + K, len(mat) - 1)][min(j + K, len(mat[0]) - 1)]\n                bottom_left = prefix_sum[min(i + K, len(mat) - 1)][j - K - 1] if (j - K - 1) >= 0 else 0\n                top_left = prefix_sum[i - K - 1][j - K - 1] if 0 <= i - K - 1 and 0 <= j - K - 1 else 0\n                top_right = prefix_sum[i - K - 1][min(j + K, len(mat[0]) - 1)] if 0 <= i - K - 1 else 0\n                answer[i][j] = bottom_right - bottom_left - top_right + top_left\n        return answer", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        m =len(mat)\n        n = len(mat[0])\n        arr=[]\n        for i in range(m):\n            temp=[]\n            for j in range(n):\n                s=0\n                \n                r_s=i-k\n                r_e=i+k+1\n                if r_s<0:\n                    r_s=0\n                if r_e>m:\n                    r_e=m\n                c_s=j-k\n                c_e=j+k+1\n                if c_s<0:\n                    c_s=0\n                if c_e>n:\n                    c_e=n\n                for ki in range(r_s,r_e):\n                    for l in range(c_s,c_e):\n                        s=mat[ki][l]+s\n                temp.append(s)\n            arr.append(temp)\n        return arr\n                \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        \n        m = len(mat)\n        n = len(mat[0])\n        \n        answer = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                \n                lower_row = max(0, i-K)\n                upper_row = min(m-1, i+K)\n                left_col = max(0, j-K)\n                right_col = min(n-1, j+K)\n                \n                total = 0\n                \n                for x in range(lower_row, upper_row + 1):\n                    for y in range(left_col, right_col + 1):\n                        total += mat[x][y]\n                \n                answer[i][j] = total\n                \n                \n                \n        return answer", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \\\"\\\"\\\"\n        Brute force solution is to perform the sum for each position\n        (r, c). This would require K * K operations for each of m * n positions.\n        \n        Instead, assuming we compute sums left to right and top down, we can\n        use our previous solution to calculate the next one, subtracting the\n        sums that fell out of the window and adding the sums that are in.\n        \n        Pseudo code would be something like this:\n        \n        prevBlockSum = ...\n        for r in range(m):\n            for c in range(n):\n                if c - K > 0:\n                    prevBlockSum -= sum()\n        \\\"\\\"\\\"\n        m = len(mat)\n        n = len(mat[0])\n        \n        out = []\n        for r in range(m):\n            new_row = []\n            for c in range(n):\n                blockSum = 0\n                \n                rs = r-K if r-K >= 0 else 0\n                re = r+K if r+K < m else m-1\n                cs = c-K if c-K >= 0 else 0\n                ce = c+K if c+K < n else n-1\n                \n                for i in range(rs, re+1):\n                    for j in range(cs, ce+1):\n                        blockSum += mat[i][j]\n                \n                new_row.append(blockSum)\n            out.append(new_row)\n        return out", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        ans = []\n        # answer[0][0] = -1 <= r <= 1 , -1 <= c <= 1\n        # answer[1][1] = 0 <= r <= 2, 0 <= c <= 2\n        \n        for i in range(0, len(mat)):\n            ans.append([])\n            for j in range(0, len(mat[0])):\n                rL = max(0, i - K)\n                rR = min(len(mat)-1, i + K)\n                cL = max(0, j - K)\n                cR = min(len(mat[0])-1, j + K)\n                posVal = 0\n                for rVal in range(rL, rR+1):\n                    for cVal in range(cL, cR+1):\n                        posVal += mat[rVal][cVal]\n                ans[i].append(posVal)\n        return ans", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        res=[]\n        for i in range(len(mat)):\n            row=[]\n            for j in range(len(mat[0])):\n                #print(mat[i][j])\n                # find the index limits of sub matrix\n                up= max(i-K, 0)\n                bottom= min(i+K, len(mat)-1)\n                left= max(j-K, 0)\n                right= min(j+K, len(mat[0])-1)\n                sum=0\n                for x in range(up, bottom+1):\n                    for y in range(left, right+1):\n                        sum += mat[x][y]\n                row.append(sum)\n            res.append(row)\n        return res", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        ans = []\n        for i in range(m):\n            temp = []\n            for j in range(n):\n                temp.append(sum([mat[r][c] for r in range(max(0, i-k), min(i+k+1, m)) for c in range(max(0, j-k), min(n, j+k+1))]))\n            ans.append(temp)\n        return ans", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        arr = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\n        def addsum(i,j):\n            i_start = i-k\n            i_end = i+k\n            j_start = j-k\n            j_end = j+k\n            ans = 0\n            if i-k<0:\n                i_start = 0\n            if i+k>=len(mat):\n                i_end = len(mat)-1\n            if j-k<0:\n                j_start = 0\n            if j+k>=len(mat[0]):\n                j_end = len(mat[0])-1\n            for m in range(i_start,i_end+1):\n                for n in range(j_start,j_end+1):\n                    ans+=mat[m][n]\n            arr[i][j] = ans\n            return \n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                addsum(i,j)\n        return arr", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        res_mat = []\n        M = len(mat)\n        N = len(mat[0])\n        # print(M,N)\n        for i, m in enumerate(mat):\n            res_list = []\n            for j, n in enumerate(m):\n                val = 0\n                r_min = i-K if i-K > 0 else 0\n                r_max = i+K+1 if i+K+1 < M else M\n                c_min = j-K if j-K > 0 else 0\n                c_max = j+K+1 if j+K+1 < N else N\n                # print(r_min, r_max, c_min, c_max)\n                for k in range(r_min, r_max):\n                    for l in range(c_min, c_max):\n                        val += mat[k][l]\n                res_list.append(val)\n                # print(res_list)\n            res_mat.append(res_list)\n            # print(res_mat)\n        return res_mat", "class Solution:\n    def sumHelper(self, mat: List[List[int]], rowLow: int, rowHigh: int, colLow: int, colHigh: int) -> int:\n        res = 0\n        for r in range(rowLow, rowHigh + 1):\n            for c in range(colLow, colHigh + 1):\n                res += mat[r][c]\n        return res\n    \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        rows = len(mat)\n        cols = len(mat[0])\n        res = [[0 for c in range(cols)] for r in range(rows)]\n        \n        for r in range(rows):\n            for c in range(cols):\n                lowR = r - K\n                if (lowR < 0): lowR = 0\n                highR = r + K\n                if (highR >= rows): highR = rows - 1\n                    \n                lowC = c - K\n                if (lowC < 0): lowC = 0\n                highC = c + K\n                if (highC >= cols): highC = cols - 1\n        \n                res[r][c] = self.sumHelper(mat, lowR, highR, lowC, highC)\n        \n        return res", "class Solution:\n    def suma(self,mat,m,n,red,stupac,K):\n        s = 0\n        poc_red = max(red-K,0)\n        kraj_red = min(red+K+1,m)\n        \n        poc_stupac = max(stupac-K,0)\n        kraj_stupac = min(stupac+K+1,n)\n        \n        for i in range(poc_red, kraj_red):\n            for j in range(poc_stupac, kraj_stupac):\n                s += mat[i][j]        \n        return s\n    \n        \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        res = [[0 for j in range(n)] for i in range(m)]\n        \n        for i in range(m):\n            for  j in range(n):\n                res[i][j] = self.suma(mat,m,n,i,j,K)\n        return res", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        \n        res = []\n        for i in range(K + 1):\n            res.append([0] * (n + 2 * (K + 1)))\n        for i in range(m):\n            res.append([0] * (K + 1) + mat[i] + [0] * (K + 1))\n        for i in range(K + 1):\n            res.append([0] * (n + 2 * (K + 1)))\n        \n        for i in range(1, m + 2*(K + 1)):\n            for j in range(1, n + 2*(K + 1)):\n                res[i][j] = res[i][j] + res[i - 1][j] + res[i][j - 1] - res[i - 1][j - 1]\n\n        for i in range(K + 1, m + K + 1):\n            for j in range(K + 1, n + K + 1):\n                mat[i - K - 1][j - K - 1] = res[i + K][j + K] - (res[i + K][j - K - 1] + res[i - K - 1][j + K] - res[i - K - 1][j - K - 1])\n        return mat\n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        rows, cols = len(mat), len(mat[0])\n        dp = [[0]*cols for _ in range(rows)]\n        \n        \n        def g(x,y):\n            nonlocal rows, cols\n            if x < 0 or y < 0: return 0\n            return dp[min(x,rows-1)][min(y,cols-1)]\n        \n        for i in range(rows):\n            for j in range(cols):\n                dp[i][j] = mat[i][j]+g(i-1,j)+g(i,j-1)-g(i-1,j-1)\n        ans = [[0]*cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                ans[i][j] = g(i+K,j+K)+g(i-K-1,j-K-1)-g(i+K,j-K-1)-g(i-K-1,j+K)\n        \n        return ans\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat[0]), len(mat)\n        dp = [[0]*(m+1) for _ in range(n+1)]\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1]\n                \n        for i in range(n):\n            for j in range(m):\n                l, r = max(0, i - K), max(0, j - K)\n                p, q = min(n, i + K + 1), min(m, j + K + 1)\n                mat[i][j] = dp[p][q] - dp[p][r] - dp[l][q] + dp[l][r]\n        return mat\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n\n        \n        k = K\n        # separable, so do two 1-d convolutions\n        def convolve(values):\n            acc = sum( values[:k] )\n            result = []\n            for i in range(len(values)):\n                if i + k < len(values):\n                    acc += values[i+k]\n                if i - k - 1 >= 0:\n                    acc -= values[i-k-1]\n                result.append(acc)\n            return result\n\n        def transpose(matrix):\n            m = len(matrix)\n            n = len(matrix[0])\n            transposed = []\n            for j in range(n):\n                col = [matrix[i][j] for i in range(m)]\n                row = col\n                transposed.append(row)\n            return transposed\n\n        convolved_rows = [convolve(row) for row in mat]\n        tranposed = transpose(convolved_rows)\n        convolved = [convolve(row) for row in tranposed]\n\n        return transpose(convolved)\n", "import numpy as np\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        pre = [[0]*n for j in range(m)]\n\n        for i in range(m):\n            pre[i][0] = mat[i][0]\n            for j in range(1, n):\n                pre[i][j] = pre[i][j - 1] + mat[i][j]\n    \n    \n        for i in range(n):\n            pre[0][i] = pre[0][i]\n            for j in range(1, m):\n                pre[j][i] = pre[j - 1][i] + pre[j][i]\n                \n        for i in range(m):\n            ru = max(i - k, 0)\n            rd = min(i + k, m - 1)\n            for j in range(n):\n                cl = max(0, j - k)\n                cr = min(n - 1, j + k)\n                value = pre[rd][cr]\n                \n                if ru - 1 >= 0:\n                    value -= pre[ru - 1][cr]\n                    \n                if cl - 1 >= 0:\n                    value -= pre[rd][cl - 1]\n                    \n                if ru - 1 >= 0 and cl - 1 >= 0:\n                    value += pre[ru - 1][cl - 1]\n        \n                mat[i][j] = value\n            \n        return mat", "class Solution:\n  def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n    # Obvious DP for O(MNK), do a second DP to bring down to O(MN)\n    M, N = len(mat), len(mat[0])\n    tsum, lsum = [[0 for _ in range(N)] for _ in range(M)], [[0 for _ in range(N)] for _ in range(M)]\n    for i in range(M):\n      for j in range(N):\n        tsum[i][j] = (0 if i == 0 else tsum[i-1][j]) + mat[i][j]\n        lsum[i][j] = (0 if j == 0 else lsum[i][j-1]) + mat[i][j]\n    \n    ans = [[0 for _ in range(N)] for _ in range(M)]\n    def l(i, j):\n      if j >= N:\n        return l(i, N-1)\n      elif 0 <= i < M and 0 <= j < N:\n        return lsum[i][j]\n      return 0\n    def t(i, j):\n      if i >= M:\n        return t(M-1, j)\n      elif 0 <= i < M and 0 <= j < N:\n        return tsum[i][j]\n      return 0\n    \n    for i in range(min(M, K+1)):\n      for j in range(min(N, K+1)):\n        ans[0][0] += mat[i][j]\n    for i in range(1, M):\n      ans[i][0] = ans[i-1][0] + l(i+K, K) - l(i-K-1, K)\n    for j in range(1, N):\n      ans[0][j] = ans[0][j-1] + t(K, j+K) - t(K, j-K-1)\n    for i in range(1, M):\n      for j in range(1, N):\n        tl = ans[i-1][j-1]\n        add = l(i+K, j+K) - l(i+K, j-K-1) + t(i+K-1, j+K) - t(i-K-1, j+K)\n        sub = t(i+K-1, j-K-1) - t(i-K-2, j-K-1) + l(i-K-1, j+K-1) - l(i-K-1, j-K-1)\n        ans[i][j] = tl + add - sub\n    return ans\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \\\"\\\"\\\"\n        neighbors=[(1,0),(0,1),(-1,0),(0,-1),(1,1),(-1,-1),(-1,1),(1,-1)]\n        dp=[[0 for i in range(len(mat[0]))] for i in range(len(mat))]\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                queue=[(i,j)]\n                visited=set()\n                sm=0\n                k=-1\n                while queue:\n                    if k==K:\n                        #print(sm)\n                        break\n                    for each in range(len(queue)):\n                        row,col=queue.pop(0)\n                        if (row,col) in visited:\n                            continue\n                        visited.add((row,col))\n                        sm+=mat[row][col]\n                        for r,c in neighbors:\n                            if 0<=row+r<len(mat) and 0<=col+c<len(mat[0]):\n                                queue.append((row+r,col+c))\n                    k+=1\n                dp[i][j]=sm\n        return dp\n        \\\"\\\"\\\"\n        prefix=[[0 for i in range(len(mat[0])+1)] for i in range(len(mat)+1)]\n        for i in range(1,len(prefix)):\n            for j in range(1,len(prefix[0])):\n                prefix[i][j]=(mat[i-1][j-1]+prefix[i-1][j]+prefix[i][j-1])-prefix[i-1][j-1]\n        \n        \n        ans=[[0 for i in range(len(mat[0]))] for i in range(len(mat))]\n        for i in range(len(ans)):\n            for j in range(len(ans[0])):\n                r1=max(0,i-K)\n                c1=max(0,j-K)\n                r2=min(len(mat)-1,i+K)\n                c2=min(len(mat[0])-1,j+K)\n                \n                ans[i][j]=(prefix[r2+1][c2+1]-prefix[r1][c2+1]-prefix[r2+1][c1])+prefix[r1][c1]\n        return ans", "class Solution:\n    def matrixBlockSum(self, mat, K):\n        # ok\n        n = len(mat) ; m = len(mat[0])\n        arr = [[0]*(m) for i in range(n)]\n        for i in range( n ):\n            for j in range(1, m):\n                mat[i][j]+=mat[i][j-1]\n        for j in range(m):\n            for i in range(1,n):\n                mat[i][j]+=mat[i-1][j]\n        # [print(mat[i]) for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                min_row, max_row = max( 0, i-K), min( n-1, i+K)\n                min_col, max_col = max( 0, j-K), min( m-1, j+K)\n\n                arr[i][j] = mat[max_row][max_col]\n\n                if min_row > 0:\n                    arr[i][j] -= mat[min_row-1][max_col]\n\n                if min_col > 0:\n                    arr[i][j] -= mat[max_row][min_col-1]\n\n                if min_col > 0 and min_row > 0:\n                    arr[i][j] += mat[min_row-1][min_col-1]\n        return arr", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \\\"\\\"\\\"\n        Assume:\n        \n        Algorithm:\n        \n        prefixsum\n        1. row: from left to right\n        2. col: from top to bottom\n        \n        xxxxxx\n        xxxxxx\n        xXXXXx\n        xXXXXx\n        xxxxxx\n        \n        result[i][j] = mat[i+K][j+K] - mat[i-K][j+K] - mat[i+K][j-K] + mat[i-K][j-K]\n                            rmax cmax       rmin                 cmin\n        need to consider boundary conditions\n        \n        \\\"\\\"\\\"\n        \n        m, n = len(mat), len(mat[0])\n        range_sum = [[0]*(n+1) for _ in range(m+1)]\n        result = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                range_sum[i+1][j+1] = range_sum[i][j+1] + range_sum[i+1][j] - range_sum[i][j] + mat[i][j]\n        print(range_sum)\n        for i in range(m):\n            for j in range(n):\n                rmin, rmax = max(0, i - K), min(m, i + K + 1)\n                cmin, cmax = max(0, j - K), min(n, j + K + 1)\n                result[i][j] = range_sum[rmax][cmax] - range_sum[rmin][cmax] - range_sum[rmax][cmin] + range_sum[rmin][cmin]\n        return result\n        \n                ", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        if not mat:\n            self.cum_matrix = [[]]\n        else:\n            nrow = len(mat)\n            ncol = len(mat[0])\n            \n            self.cum_matrix = [[0]*ncol for _ in range(nrow)]\n            \n            # initialize\n            self.cum_matrix[0][0] = mat[0][0]\n            for i in range(1,ncol):\n                self.cum_matrix[0][i] = self.cum_matrix[0][i-1]+mat[0][i]\n            for j in range(1,nrow):\n                self.cum_matrix[j][0] = self.cum_matrix[j-1][0]+mat[j][0]\n                \n            for c in range(1, ncol):\n                for r in range(1, nrow):\n                    self.cum_matrix[r][c] = (self.cum_matrix[r-1][c] + self.cum_matrix[r][ c-1] \n                                            - self.cum_matrix[r-1][c-1] + mat[r][c])\n        \n        res = [[0]*ncol for _ in range(nrow)]\n        \n        if not self.cum_matrix:\n            return []\n        \n        for r in range(nrow):\n            for c in range(ncol):\n                row1 = max(0, r-K)\n                col1 = max(0, c-K)\n                row2 = min(nrow-1, r+K)\n                col2 = min(ncol-1, c+K)\n\n                if row1 == 0 and col1 == 0:\n                    res[r][c] = (self.cum_matrix[row2][col2])\n                elif row1 == 0 and col1 > 0:\n                    res[r][c] = (self.cum_matrix[row2][col2]\n                        - self.cum_matrix[row2][col1-1] )\n                elif row1 > 0 and col1 == 0:\n                    res[r][c] = (self.cum_matrix[row2][col2]\n                        - self.cum_matrix[row1-1][col2] )\n                else:\n                    res[r][c] = (self.cum_matrix[row2][col2] - self.cum_matrix[row1-1][ col2] \n                            - self.cum_matrix[row2][col1-1] + self.cum_matrix[row1-1][col1-1])\n                    \n        return res\n\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix(matrix)\n# param_1 = obj.sumRegion(row1,col1,row2,col2)\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        iMax = len(mat)\n        jMax = len(mat[0])\n        ans = [[0 for j in range(jMax)] for i in range(iMax)]\n        \n        i = 0\n        j = 0\n        ans[i][j] = sum([sum([mat[i0][j0] for j0 in range(j, min(jMax, j+K+1))]) for i0 in range(i, min(iMax, i + K +1))])\n        # print(ans)\n        \n        i = 0\n        for j in range(1, jMax):\n            ans[i][j] = ans[i][j-1]\n            if j + K < jMax:\n                ans[i][j] += sum([mat[i0][j + K] for i0 in range(max(0, i-K), min(iMax, i+K+1))])\n            if j - K-1 >= 0:\n                ans[i][j] -= sum([mat[i0][j - K - 1] for i0 in range(max(0, i-K), min(iMax, i+K+1))])\n        # print(ans)\n        \n        j = 0\n        for i in range(1, iMax):\n            ans[i][j] = ans[i-1][j]\n            if i + K < iMax:\n                ans[i][j] += sum([mat[i+K][j0] for j0 in range(max(0, j-K), min(jMax, j+K+1))])\n            if i - K-1 >= 0:\n                ans[i][j] -= sum([mat[i-K-1][j0] for j0 in range(max(0, j-K), min(jMax, j+K+1))])\n                \n        for i in range(1, iMax):\n            for j in range(1, jMax):\n                ans[i][j] = ans[i][j-1]\n                if j + K < jMax:\n                    ans[i][j] += sum([mat[i0][j + K] for i0 in range(max(0, i-K), min(iMax, i+K+1))])\n                if j - K-1 >= 0:\n                    ans[i][j] -= sum([mat[i0][j - K - 1] for i0 in range(max(0, i-K), min(iMax, i+K+1))])           \n                \n        # print(ans) \n        return ans\n#         for i in range(iMax):\n#             for j in range(jMax):\n#                 if i == 0 and j== 0:\n#                     continue\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        rc, cc = len(mat), len(mat[0])\n        acc = [[0]*(cc+1) for _ in range(rc+1)]\n        for r in range(rc):\n            for c in range(cc):\n                acc[r+1][c+1] = acc[r][c+1] + acc[r+1][c]- acc[r][c]+mat[r][c]\n        res = [[0]*cc for _ in range(rc)]\n        for r in range(rc):\n            for c in range(cc):\n                res[r][c] = acc[min(r+K+1, rc)][min(c+K+1, cc)] - acc[max(r-K, 0)][min(c+1+K, cc)] - acc[min(r+1+K, rc)][max(c-K, 0)] + acc[max(r-K, 0)][max(c-K, 0)]\n        return res", "import copy\nclass Solution:\n    def matrixBlockSum(self, G: List[List[int]], K: int) -> List[List[int]]:\n        M, N, G[0] = len(G), len(G[0]), list(itertools.accumulate(G[0])); A = [[0]*N for _ in range(M)]\n        for i in range(1,M):\n            s = 0\n            for j in range(N): s += G[i][j]; G[i][j] = s + G[i-1][j]\n        for i,j in itertools.product(list(range(M)),list(range(N))):\n            R, C = min(M-1,i+K), min(N-1,j+K)\n            A[i][j] = G[R][C] - (i-K > 0 and G[i-K-1][C]) - (j-K > 0 and G[R][j-K-1]) + (i-K > 0 and j-K > 0 and G[i-K-1][j-K-1])\n        return A\n", "from itertools import accumulate as acc\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        ##dp \n        N = len(mat)\n        M = len(mat[0])\n        ## how do we accumulate\n        prefix = [*list(zip(*list(map(acc, list(zip(*list(map(acc, mat))))))))]\n        for i in prefix:\n            print(i)\n        dp = [[0 for _ in range(M)] for _ in range(N)]\n        \n        for i in range(N):\n            for j in range(M):\n                r = min(i+K,N-1)\n                b = min(j+K,M-1);\n                l = max(0,i-K)\n                t = max(0,j-K)\n                cursum = prefix[r][b]\n                #print(cursum)\n                if(l-1 >=0):\n                    cursum-=prefix[l-1][b]\n                if(t-1 >=0):\n                    cursum -= prefix[r][t-1];\n                if(l-1 >=0 and t-1 >=0):\n                    cursum += prefix[l-1][t-1];\n                dp[i][j] = cursum\n        return dp\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        rangeSum = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                rangeSum[i + 1][j + 1] = rangeSum[i + 1][j] + rangeSum[i][j + 1] - rangeSum[i][j] + mat[i][j]\n        ans = [[0] * n for _ in range(m)]        \n        for i in range(m):\n            for j in range(n):\n                r1, c1, r2, c2 = max(0, i - K), max(0, j - K), min(m, i + K + 1), min(n, j + K + 1)\n                ans[i][j] = rangeSum[r2][c2] - rangeSum[r1][c2] - rangeSum[r2][c1] + rangeSum[r1][c1]\n        return ans", "#753\n\nfrom copy import deepcopy\n\nclass Solution:\n  def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n    ret = deepcopy(mat)\n    m = len(mat)\n    n = len(mat[0])\n    \n    @lru_cache(None)\n    def row_sum(x, y):\n      if not 0 <= x < m:\n        return 0\n      ret = 0\n      for j in range(max(0, y), min(n, y + 2 * K + 1)):\n        ret += mat[x][j]\n      return ret\n    \n    @lru_cache(None)\n    def col_sum(x, y):\n      if not 0 <= y < n:\n        return 0\n      ret = 0\n      for i in range(max(0, x), min(m, x + 2 * K + 1)):\n        ret += mat[i][y]\n      #print(\\\"colsum\\\", x, y, ret)\n      return ret    \n    \n    \n    for i in range(m):\n      for j in range(n):\n        if i == 0 and j == 0:\n          t = 0\n          for u in range(0, min(K+1, m)):\n            for v in range(0, min(K+1, n)):\n              t += mat[u][v]\n          ret[0][0] = t\n          continue\n        \n        if i > 0:\n          ret[i][j] = ret[i-1][j] - row_sum(i-1-K, j-K) + row_sum(i+K, j-K)\n        else:\n          ret[i][j] = ret[i][j-1] - col_sum(i-K, j-K-1) + col_sum(i-K, j+K)\n          \n    return ret\n", "#753\n\nfrom copy import deepcopy\n\nclass Solution:\n  def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n    ret = deepcopy(mat)\n    m = len(mat)\n    n = len(mat[0])\n    \n    @lru_cache(4)\n    def row_sum(x, y):\n      if not 0 <= x < m:\n        return 0\n      ret = 0\n      for j in range(max(0, y), min(n, y + 2 * K + 1)):\n        ret += mat[x][j]\n      return ret\n    \n    @lru_cache(4)\n    def col_sum(x, y):\n      if not 0 <= y < n:\n        return 0\n      ret = 0\n      for i in range(max(0, x), min(m, x + 2 * K + 1)):\n        ret += mat[i][y]\n      #print(\\\"colsum\\\", x, y, ret)\n      return ret    \n    \n    \n    for i in range(m):\n      for j in range(n):\n        if i == 0 and j == 0:\n          t = 0\n          for u in range(0, min(K+1, m)):\n            for v in range(0, min(K+1, n)):\n              t += mat[u][v]\n          ret[0][0] = t\n          continue\n        \n        if i > 0:\n          ret[i][j] = ret[i-1][j] - row_sum(i-1-K, j-K) + row_sum(i+K, j-K)\n        else:\n          ret[i][j] = ret[i][j-1] - col_sum(i-K, j-K-1) + col_sum(i-K, j+K)\n          \n    return ret\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        cum_sum = [[0 for x in range(n+1)] for y in range(m+1)]\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if i == 0 and j == 0:\n                    cum_sum[i][j] = mat[i-1][j-1]\n                elif i == 0:\n                    cum_sum[i][j] = mat[i-1][j-1] + cum_sum[i][j-1]\n                elif j == 0:\n                    cum_sum[i][j] = mat[i-1][j-1] + cum_sum[i-1][j]\n                else:\n                    cum_sum[i][j] = mat[i-1][j-1] + cum_sum[i-1][j] + cum_sum[i][j-1] - cum_sum[i-1][j-1]\n        ans = [[0 for x in range(n)] for y in range(m)]\n        for i in range(m):\n            for j in range(n):\n                maxr = min(i+K, m-1)+1\n                maxc = min(j+K, n-1)+1\n                minr = max(i-K-1, -1)+1\n                minc = max(j-K-1, -1)+1\n                ans[i][j] = cum_sum[maxr][maxc] - cum_sum[maxr][minc] - cum_sum[minr][maxc] + cum_sum[minr][minc]\n        return ans\n                    \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        rows, cols = len(mat), len(mat[0])\n        dic , seen = {} , {} \n        for i, row in enumerate(mat):\n            prefix_sum = [0] * (cols + 1)\n            for j, num in enumerate(row):\n                prefix_sum[j] = prefix_sum[j-1] + num\n            \n            dic[i] = prefix_sum\n            \n        for i in range(rows):\n            for j in range(cols):\n                start_col = j-K if j-K >=0 else 0\n                end_col = j+K if j+K < cols else cols-1\n                start_row = i-K if i-K >=0 else 0\n                end_row = i+K if i+K < rows else rows-1\n                if (start_col, end_col, start_row, end_row) in seen:\n                    mat[i][j] = seen[start_col, end_col, start_row, end_row]\n                    continue\n                res = 0\n                for idx in range(start_row, end_row+1):\n                    res += dic[idx][end_col]- dic[idx][start_col-1]\n                mat[i][j] = res\n                seen[start_col, end_col, start_row, end_row] = res\n        return mat\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        \n        res = []\n        for i in range(K + 1):\n            res.append([0] * (n + 2 * (K + 1)))\n        for i in range(m):\n            res.append([0] * (K + 1) + mat[i] + [0] * (K + 1))\n        for i in range(K + 1):\n            res.append([0] * (n + 2 * (K + 1)))\n\n        for i in range(1, m + 2*(K + 1)):\n            for j in range(1, n + 2*(K + 1)):\n                res[i][j] = res[i][j] + res[i - 1][j] + res[i][j - 1] - res[i - 1][j - 1]\n\n        for i in range(K + 1, m + K + 1):\n            for j in range(K + 1, n + K + 1):\n                mat[i - K - 1][j - K - 1] = res[i + K][j + K] - (res[i + K][j - K - 1] + res[i - K - 1][j + K] - res[i - K - 1][j - K - 1])\n        return mat\n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        M = len(mat)\n        if M == 0:\n            return mat\n        N = len(mat[0])\n        \n        for i in range(1, M):\n            mat[i][0] += mat[i-1][0]\n        \n        for j in range(1, N):\n            mat[0][j] += mat[0][j-1]\n        \n        \n        for i in range(1, M):\n            for j in range(1, N):\n                mat[i][j] = (mat[i][j] + mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1])\n        \n        answer = [[0 for _ in range(N)] for _ in range(M)]\n        \n        for i in range(M):\n            for j in range(N):\n                rl = max(i-K, 0)\n                cl = max(j-K, 0)\n                rr = min(i+K, M-1)\n                cr = min(j+K, N-1)\n                \n                A, B, C, D = 0, 0, 0, mat[rr][cr]\n                \n                if rl - 1 >= 0:\n                    B = mat[rl-1][cr]\n                if cl - 1 >= 0:\n                    C = mat[rr][cl-1]\n                if rl - 1 >= 0 and cl - 1 >= 0:\n                    A = mat[rl-1][cl-1]\n                \n                answer[i][j] = D + A - B - C\n        \n        return answer\n                \n", "class Solution:\n    \n    def __init__(self):\n        from functools import lru_cache\n        return\n    \n    \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        self.cache = {}\n        k = K\n        n, m = len(mat), len(mat[0]) if len(mat) else 0\n                      \n        def brute_force():\n            def kernel(i, j, k):\n                minx, maxx = max(i-k,0), min(i+k+1, n)\n                miny, maxy = max(j-k,0), min(j+k+1, m)\n                s = 0\n                for ii in range(minx, maxx):\n                    for jj in range(miny, maxy):\n                        s += mat[ii][jj]\n                return s\n\n            ans = [[0 for j in range(m)] for i in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    ans[i][j] = kernel(i,j, k)\n            return ans\n        \n        #return brute_force()\n            \n        \n        def partials():\n            @lru_cache\n            def getrowsum(i,j,k):\n                if i < 0: return 0\n                if i >= n: return 0\n                miny, maxy = max(j-k,0), min(j+k+1,m)\n                return sum([mat[i][jj] for jj in range(miny, maxy)])\n\n            #@lru_cache\n            def getcolsum(ans,i,j,k):\n                if j < 0: return 0\n                if j >= m: return 0\n                if (i-1, j) in self.cache:\n                    self.cache[(i,j)] = self.cache[(i-1,j)] \\\\\n                           - (ans[i-k-1][j] if i-k-1 >= 0 else 0) \\\\\n                           + (ans[i+k][j] if i+k < n  else 0)\n                else:\n                    minx, maxx = max(i-k,0), min(i+k+1,n)\n                    self.cache[(i, j)] = sum([ans[ii][j] for ii in range(minx, maxx)])\n                return self.cache[(i, j)]\n\n            ans = [[0 for j in range(m)] for i in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    ans[i][j] = getrowsum(i,j,k)\n\n            res = [[0 for j in range(m)] for i in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    res[i][j] = getcolsum(ans,i,j,k)\n            return res\n        \n        return partials()\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        f = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    for i_ in range(i, i + K + 1):\n                        for j_ in range(j, j + K + 1):\n                            if i_ < m and j_ < n:\n                                f[i][j] += mat[i_][j_]\n                elif j == 0:\n                    f[i][j] = f[i - 1][j]\n                    if i - 1 - K >= 0:\n                        for j_ in range(j, j + K + 1):\n                            if j_ < n:\n                                f[i][j] -= mat[i - 1 - K][j_]\n                                \n                    if i + K < m:\n                        for j_ in range(j, j + K + 1):\n                            if j_ < n:\n                                f[i][j] += mat[i + K][j_]\n                else:\n                    f[i][j] = f[i][j - 1]\n                    if j - 1 - K >= 0:\n                        for i_ in range(i - K, i + K + 1):\n                            if 0 <= i_ < m:\n                                f[i][j] -= mat[i_][j - 1 - K]\n                                \n                    if j + K < n:\n                        for i_ in range(i - K, i + K + 1):\n                            if 0 <= i_ < m:\n                                f[i][j] += mat[i_][j + K]\n        return f", "import numpy as np\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        matrix= np.zeros((m+1, n+1))\n        for i in range (m):\n            for j in range (n):\n                matrix[i+1][j+1]=matrix[i+1][j]+matrix[i][j+1]-matrix[i][j]+mat[i][j]\n        result = np.zeros((m, n))\n        for i in range(m):\n            for j in range(n):\n                x1=max(i-K, 0)\n                y1=max(j-K, 0)\n                x2=min(i+K+1, m)\n                y2=min(j+K+1, n)\n                result[i][j]=matrix[x2][y2]-matrix[x1][y2]-matrix[x2][y1]+matrix[x1][y1]\n        return (result.astype(int))\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        res = [[0] * n for _ in range(m)]\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        for i in range(m):\n            for j in range(n):\n                dp[i+1][j+1] = dp[i][j+1] + dp[i+1][j] - dp[i][j] + mat[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                r1, c1, r2, c2 = max(0, i-K), max(0, j-K), min(m, i+K+1), min(n, j+K+1)\n                res[i][j] = dp[r2][c2] + dp[r1][c1] - dp[r2][c1] - dp[r1][c2]\n        return res", "class Solution:\n    \n    def __init__(self):\n        from functools import lru_cache\n        return\n    \n    \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        self.cache = {}\n        k = K\n        n, m = len(mat), len(mat[0]) if len(mat) else 0\n                      \n        def brute_force():\n            def kernel(i, j, k):\n                minx, maxx = max(i-k,0), min(i+k+1, n)\n                miny, maxy = max(j-k,0), min(j+k+1, m)\n                s = 0\n                for ii in range(minx, maxx):\n                    for jj in range(miny, maxy):\n                        s += mat[ii][jj]\n                return s\n\n            ans = [[0 for j in range(m)] for i in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    ans[i][j] = kernel(i,j, k)\n            return ans\n        \n        #return brute_force()\n            \n        \n        def partials():\n            @lru_cache\n            def getrowsum(i,j,k):\n                miny, maxy = max(j-k,0), min(j+k+1,m)\n                # row cache also needed\n                return sum([mat[i][jj] for jj in range(miny, maxy)])\n\n            #@lru_cache\n            def getcolsum(ans,i,j,k):\n                if (i-1, j) in self.cache:\n                    self.cache[(i,j)] = self.cache[(i-1,j)] \\\\\n                                        - (ans[i-k-1][j] if i-k-1 >= 0 else 0) \\\\\n                                        + (ans[i+k][j] if i+k < n  else 0)\n                else:\n                    minx, maxx = max(i-k,0), min(i+k+1,n)\n                    self.cache[(i, j)] = sum([ans[ii][j] for ii in range(minx, maxx)])\n                return self.cache[(i, j)]\n\n            ans = [[0 for j in range(m)] for i in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    ans[i][j] = getrowsum(i,j,k)\n\n            res = [[0 for j in range(m)] for i in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    res[i][j] = getcolsum(ans,i,j,k)\n            return res\n        \n        return partials()\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        k = K\n\\t\\t\n        cumsum = [[0]*n for _ in range(m)]\n        answer = [[0]*n for _ in range(m)]\n\n        cumsum[0][0]=mat[0][0]\n        for j in range(1,n):\n            cumsum[0][j] = cumsum[0][j-1] + mat[0][j]\n        for i in range(1,m):\n            cumsum[i][0] = cumsum[i-1][0] + mat[i][0]\n        for j in range(1,n):\n            for i in range(1,m):\n                cumsum[i][j] = cumsum[i][j-1] + cumsum[i-1][j] - cumsum[i-1][j-1] + mat[i][j]\n        \n        def getcumsum(i,j):\n            if i >=0 and j>=0:\n                return cumsum[min(max(0,i), m-1)][min(max(0,j), n-1)]\n            else: return 0\n            \n        for r in range(m):\n            for c in range(n):\n                answer[r][c] = getcumsum(r+k,c+k) - getcumsum(r+k,c-(k+1)) - getcumsum(r-(k+1),c+k) + getcumsum(r-(k+1),c-(k+1))\n        return answer", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        if not mat or not mat[0]:\n            return mat\n        answer = [[0 for _ in mat[0]] for _ in mat]\n        # create left->right horizontal running sums in each row of mat\n        for i in range(len(mat)):\n            for j in range(1, len(mat[0])):\n                mat[i][j] += mat[i][j - 1]\n        # create horizontal 2K+1-sums in answer\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                answer[i][j] = mat[i][min(j + K, len(mat[i]) - 1)]\n                if j - K > 0:\n                    answer[i][j] -= mat[i][j - K - 1]\n        mat, answer = answer, [[0 for _ in mat[0]] for _ in mat]\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                answer[i][j] = sum([mat[k][j] for k in range(max(0, i - K), min(len(mat), i + K + 1))])\n        \n        \n        return answer", "import numpy as np\n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        mat = np.array(mat)\n        answer = np.zeros(mat.shape)\n        for i, row in enumerate(mat):\n            row_start = max([0, i - K])\n            row_end = min([mat.shape[0] -1, i + K])\n            # Each new row, reinitialize the value and add/remove newly in/out of range items\n            if i > 0:\n                col_start = 0\n                col_end = min([mat.shape[1] -1, K])\n                val = answer[i - 1][0]\n                # Add the new row to the sum\n                if i + K <= mat.shape[0] -1:\n                    val += np.sum(mat[row_end,col_start:col_end + 1])\n                # Remove out of range row\n                if row_start > 0:\n                    val -= np.sum(mat[row_start -1,col_start:col_end + 1])\n            for j, col in enumerate(row):\n                col_start = max([0, j - K])\n                col_end = min([mat.shape[1] -1, j + K])\n                print((row_start, row_end, col_start, col_end))\n                if i == 0 and j == 0:\n                    val = np.sum(mat[row_start:row_end + 1, col_start:col_end + 1])\n                else:\n                    # Add the new column to the sum\n                    if j + K <= mat.shape[1] -1 and j != 0:\n                        val += np.sum(mat[row_start:row_end + 1,col_end])\n                    # Remove out of range column\n                    if col_start > 0:\n                        val -= np.sum(mat[row_start:row_end + 1,col_start - 1])\n                answer[i][j] = val\n        return answer.astype(np.int)\n            \n            \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        pre = [[0] * len(mat[0]) for i in range(len(mat))]\n        pre2 = [[0] * len(mat[0]) for i in range(len(mat))]\n        res = [[0] * len(mat[0]) for i in range(len(mat))]\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                pre[i][j] = sum(mat[i][y] for y in range(0, j+1))\n        for i in range(len(mat)): \n            for j in range(len(mat[0])):\n                pre2[i][j] = sum(pre[x][j] for x in range(0, i+1))\n        \\\"\\\"\\\"\n        [[1,2,3], 1 3 6     1   3   6\n         [4,5,6], 4 9 15    5   12  21\n         [7,8,9]] 7 15 24   12  27  45\n        \\\"\\\"\\\"\n        for i in range(len(mat)):\n            ru = max(i-K, 0)\n            rd = min(i+K, len(mat)-1)\n            for j in range(len(mat[0])):\n                cl = max(0, j-K)\n                cr = min(len(mat[0])-1, j + K)\n                v = pre2[rd][cr]\n                if ru - 1 >= 0:\n                    v -= pre2[ru-1][cr]\n                if cl - 1 >= 0:\n                    v -= pre2[rd][cl-1]\n                if ru - 1 >= 0 and cl - 1 >= 0:\n                    v += pre2[ru-1][cl-1]\n                res[i][j] = v\n        return res", "import numpy as np\n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        x_dim = len(mat[0])\n        y_dim = len(mat)\n\n        def move_down(mat, y, x_bounds):\n            if y >= y_dim or y < 0:\n                return 0\n\n            ans = 0\n            for x in range(x_bounds[0], x_bounds[1]):\n                if -1 < x < x_dim:\n                    ans += mat[y][x]\n            return ans\n\n        def move_right(mat, y_bounds, x):\n            if x >= x_dim or x < 0:\n                return 0\n\n            ans = 0\n            for y in range(y_bounds[0], y_bounds[1]):\n                if -1 < y < y_dim:\n                    ans += mat[y][x]\n            return ans\n\n        ans = np.array([[0] * len(mat[0])] * len(mat))\n\n        for i in range(0, min(K + 1, y_dim)):\n            for j in range(0, min(K + 1, x_dim)):\n                ans[0][0] += mat[i][j]\n\n        for i in range(1, y_dim):\n            ans[i][0] = ans[i - 1][0] - move_down(mat, i-K-1, (0, K + 1)) + \\\\\n                        move_down(mat, i + K, (0, K + 1))\n\n        for i in range(y_dim):\n            for j in range(1, x_dim):\n                if (i, j) == (0, 0):\n                    continue\n                ans[i][j] = ans[i][j - 1] - move_right(mat, (i - K, i + K + 1), j - K - 1) + \\\\\n                            move_right(mat, (i - K, i + K + 1), j + K)\n        return ans\n        ", "import numpy as np\n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        A = np.array(mat)\n        m, n = A.shape\n        return [[A[max(i-K, 0):i+K+1, max(j-K, 0):j+K+1].sum()\n                 for j in range(n)] for i in range(m)]", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        res = [[0 for j in range(len(mat[0]))] for i in range(len(mat))]\n        \n        for i in range(0, min(len(mat), K + 1)):\n            for j in range(0, min(len(mat[0]), K + 1)):\n                res[0][0] += mat[i][j]\n        \n        for i in range(0, len(mat)):\n            for j in range(0, len(mat[0])):\n                \n                if i == 0 and j == 0:\n                    continue\n                \n                \n                if j == 0:\n                    \n                    res[i][j] = res[i - 1][j]\n                    \n                    old_i = i - K - 1\n                    \n                    if old_i >= 0:\n                        for curr_j in range(max(0, j - K), min(len(mat[0]), j + K + 1)):\n                            res[i][j] -= mat[old_i][curr_j]\n                                           \n                    \n                    new_i = i + K\n                    \n                    if new_i < len(mat):\n                        for curr_j in range(max(0, j - K), min(len(mat[0]), j + K + 1)):\n                            res[i][j] += mat[new_i][curr_j]\n                else:\n                    res[i][j] = res[i][j - 1]\n                \n                    old_j = j - K - 1\n                    \n                    if old_j >= 0:\n                        for curr_i in range(max(0, i - K), min(len(mat), i + K + 1)):\n                            res[i][j] -= mat[curr_i][old_j]\n\n                    new_j = j + K\n\n                    if new_j < len(mat[0]):\n                        for curr_i in range(max(0, i - K), min(len(mat), i + K + 1)):\n                            res[i][j] += mat[curr_i][new_j]\n                        \n        return res\n                \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        if not mat or not mat[0]:\n            return []\n        \n        height = len(mat)\n        width = len(mat[0])\n        \n        prefix_sum = [[0]*width for _ in range(height)]\n        for i in range(height):\n            for j in range(width):\n                up = prefix_sum[i-1][j] if i > 0 else 0\n                left = prefix_sum[i][j-1] if j > 0 else 0\n                diag = prefix_sum[i-1][j-1] if i > 0 and j > 0 else 0\n                prefix_sum[i][j] = up + left - diag + mat[i][j]\n        \n        answer = [[0]*width for _ in range(height)]\n        for i in range(height):\n            for j in range(width):\n                lri = min(height - 1, i + K)  # lower right i\n                lrj = min(width - 1, j + K)  # lower right j\n                uli = i - K - 1  # upper left i\n                ulj = j - K - 1  # upper left j\n                \n                total = prefix_sum[lri][lrj]\n                up = prefix_sum[uli][lrj] if uli >= 0 else 0\n                left = prefix_sum[lri][ulj] if ulj >= 0 else 0\n                diag = prefix_sum[uli][ulj] if uli >= 0 and ulj >= 0 else 0\n                \n                answer[i][j] = total - up - left + diag\n                \n        return answer", "import numpy as np\n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n = len(mat)\n        m = len(mat[0])\n        arr = np.array([[0]*m]*n)\n        mat = np.array(mat)\n        \n        for i in range(n):\n            for j in range(m):\n                cur = mat[i,j]\n                if j-K < 0:\n                    hor_s = slice(0, j+K+1)\n                    # hor = mat[i, 0:j+K+1]\n                else:\n                    hor_s = slice(j-K, j+K+1)\n                    # hor = mat[i, j-K:j+K+1]\n                    \n                if i-K < 0:\n                    ver_s = slice(0, i+K+1)\n                    # ver = mat[0:i+K+1, j]\n                else:\n                    ver_s = slice(i-K, i+K+1)\n                    # ver = mat[i-K:i+K+1, j]\n                \n                arr[i,j] = mat[ver_s, hor_s].sum()\n        \n        return arr.tolist()\n        \n", "# Matrix Block Sum\n# \u0412\u0430\u0448 \u043a\u043e\u0434 \u043d\u0438\u0436\u0435\nimport numpy as np\n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        size_row=len(mat)\n        size_col=len(mat[0])\n        in_mat=np.array(mat)\n        res = np.zeros((size_row,size_col),dtype = np.int32)\n\n        res_cell=0\n\n        r_min = 0\n        r_max = min(size_row-1, K)\n        c_min = 0\n        c_max = min(size_col-1, K)\n        for row in in_mat[0:r_max+1:,0:c_max+1:]:\n            res_cell+=sum(row)\n        \n        remove_sum_right=0\n        add_sum_right=0\n\n        for i in range(size_row):#i - \u0441\u0442\u0440\u043e\u043a\u0430\n            if i != 0:\n                r_min = max(0, i-K)\n                r_max = min(size_row-1, i+K)\n                remove_sum_down = 0 if i-K<=0 else np.sum(in_mat[r_min-1:r_min:,:min(K+1,size_col):],axis=1)\n               \n                add_sum_down = 0 if i+K>size_row-1 else np.sum(in_mat[r_max:r_max+1:,:min(K+1,size_col):],axis=1)\n               \n                res_cell=res[i-1][0]+add_sum_down-remove_sum_down\n           \n            for j in range(size_col):#j - \u0441\u0442\u043e\u043b\u0431\u0435\u0446\n                if j==0:\n                    res[i][j]=res_cell\n                    continue\n                \n                c_min = max(0, j-K)\n                c_max = min(size_col-1, j+K)\n                remove_sum_right = 0 if j-K<=0 else np.sum(in_mat[r_min:r_max+1:,c_min-1:c_min:],axis=0)\n               \n                add_sum_right = 0 if j+K>size_col-1 else np.sum(in_mat[r_min:r_max+1:,c_max:c_max+1:],axis=0)\n                \n                res[i][j]=res_cell+add_sum_right-remove_sum_right\n                res_cell=res[i][j]\n             \n        return res", "import numpy as np\n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        size_row=len(mat)\n        size_col=len(mat[0])\n        in_mat=np.array(mat)\n        res = np.zeros((size_row,size_col),dtype = np.int32)\n\n        res_cell=0\n\n        r_min = 0\n        r_max = min(size_row-1, K)\n        c_min = 0\n        c_max = min(size_col-1, K)\n        for row in in_mat[0:r_max+1:,0:c_max+1:]:\n            res_cell+=sum(row)\n        #print('res_sel',res_cell)\n        remove_sum_right=0\n        add_sum_right=0\n\n        for i in range(size_row):#i - \u0441\u0442\u0440\u043e\u043a\u0430\n            if i != 0:\n                r_min = max(0, i-K)\n                r_max = min(size_row-1, i+K)\n                remove_sum_down = 0 if i-K<=0 else np.sum(in_mat[r_min-1:r_min:,:min(K+1,size_col):],axis=1)\n               # print('remove_sum_down ',remove_sum_down)\n                add_sum_down = 0 if i+K>size_row-1 else np.sum(in_mat[r_max:r_max+1:,:min(K+1,size_col):],axis=1)\n               # print('add_sum_down ',add_sum_down)\n                res_cell=res[i-1][0]+add_sum_down-remove_sum_down\n           \n            for j in range(size_col):#j - \u0441\u0442\u043e\u043b\u0431\u0435\u0446\n                if j==0:\n                    res[i][j]=res_cell\n                    continue\n                \n                c_min = max(0, j-K)\n                c_max = min(size_col-1, j+K)\n                remove_sum_right = 0 if j-K<=0 else np.sum(in_mat[r_min:r_max+1:,c_min-1:c_min:],axis=0)\n                #print('remove_sum_right ',remove_sum_right)\n\n                add_sum_right = 0 if j+K>size_col-1 else np.sum(in_mat[r_min:r_max+1:,c_max:c_max+1:],axis=0)\n                #print('add_sum_right ',add_sum_right)\n                #\u0441\u0443\u043c\u043c\u0430, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043d\u0430\u0434\u043e \u0432\u044b\u0447\u0435\u0441\u0442\u044c \u043f\u0440\u0438 \u0434\u0432\u0438\u0436\u0435\u043d\u0438\u0438 \u0432\u043f\u0440\u0430\u0432\u043e\n                res[i][j]=res_cell+add_sum_right-remove_sum_right\n                res_cell=res[i][j]\n                #print('\u043d\u043e\u0432\u0430\u044f \u044f\u0447\u0435\u0439\u043a\u0430')\n             \n        return res", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        nR = len(mat)\n        nC = len(mat[0])\n        newMat = [[None for j in range(nC)] for i in range(nR)]\n        for r,row in enumerate(mat):\n            i = 0\n            while i<nC:\n                if i-K>=0:\n                    newMat[r][i] = sum(row[(i-K):(i+K+1)])\n                    i+=1\n                else:\n                    newMat[r][i] = sum(row[0:(i+K+1)])\n                    i+=1\n        \n        finalAns = [[0 for j in range(nC)] for i in range(nR)]\n        \n        rowNum = 0\n        while rowNum<nR:\n            print(\\\"This is rowNum:\\\",rowNum)\n            if rowNum-K<=0:\n                minRow = 0\n            else:\n                minRow = rowNum-K\n\n            if rowNum+K>=nR:\n                maxRow = nR\n            else:\n                maxRow = rowNum+K+1\n                \n            print(minRow,maxRow)    \n            for col in range(nC):\n                for r in range(minRow,maxRow):\n                    finalAns[rowNum][col] += newMat[r][col]\n            rowNum+=1\n        \n        return finalAns", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        if not mat:\n            return \n        \n        m = len(mat)\n        n = len(mat[0])\n        sumMat = [[0 for i in range (n)] for j in range (m)]\n        verMat = [[0 for i in range (n)] for j in range (m)]\n        ansMat = [[0 for i in range (n)] for j in range (m)]\n        fnlMat = [[0 for i in range (n)] for j in range (m)]\n        #fill sumMat with running sum of row\n        for i in range (m):\n            running_sum = 0 \n            for j in range (n):\n                running_sum += mat[i][j]\n                sumMat[i][j] = running_sum \n\n        #fill verMat with results from sumMat \n        for i in range(m):\n            for j in range (n): \n                verMat[i][j] = self.sumRowWindow(sumMat, i, j, K)\n        \n        \n        for j in range (n):\n            running_sum = 0 \n            for i in range (m):\n                running_sum += verMat[i][j]\n                ansMat[i][j] = running_sum \n        \n        for i in range (m): \n            for j in range (n): \n                fnlMat[i][j] = self.sumColWindow(ansMat, i,j,K)\n\n#        for i in range (m):\n#            print(fnlMat[i])   \n        return fnlMat\n\n            \n    def sumColWindow(self, verMat, row_i, col_j, window_k):    \n        col = [verMat[i][col_j] for i in range(len(verMat))]\n        #print(col)\n        \n        window_left = max(-1, row_i-window_k-1)\n        window_right = min(len(col)-1, row_i+window_k)\n        \n        if window_left == -1: \n            return col[window_right]\n        \n        return col[window_right] - col[window_left]\n\n    \n    # O(1) operation \n    def sumRowWindow(self, sumMat, row_i, col_j, window_k): \n        row = sumMat[row_i]\n        \n        window_left = max(-1, col_j-window_k-1)\n        window_right = min(len(row)-1, col_j+window_k)\n        \n        if window_left == -1: \n            return row[window_right]\n        \n        return row[window_right] - row[window_left]\n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        h, w = len(mat), len(mat[0])\n        \n        dp = [[0 for i in range(w)] for j in range(h)]\n        for y in range(h):\n            for x in range(w):\n                sum = 0\n                for i in range(x - K if x - K >= 0 else 0, x + K + 1 if x + K + 1 <= w else w):\n                    sum += mat[y][i]\n                dp[y][x] = sum\n        \n        res = [[0 for i in range(w)] for j in range(h)]\n        for y in range(h):\n            for x in range(w):\n                sum = 0\n                for j in range(y - K if y - K >= 0 else 0, y + K + 1 if y + K + 1 <= h else h):\n                    sum += dp[j][x]\n                res[y][x] = sum\n                \n        return res", "import numpy as np\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        ans = [[0 for i in range(len(mat[0]))] for j in range(len(mat))]\n        print(ans)\n        mat = np.array(mat)\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                a = i - k if i - k >= 0 else 0\n                b = i + k if i + k <= len(mat) else len(mat)\n                c = j - k if j - k >= 0 else 0\n                d = j + k if j + k <= len(mat[0]) else len(mat[0])\n                ans[i][j] = np.sum(mat[a : b + 1, c : d + 1])\n        return ans\n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        k = K\n        n, m = len(mat), len(mat[0])\n        matrix = []\n        for i in range(n):\n            temp = []\n            for  j in range(m):\n                temp.append(0)\n            matrix.append(temp)\n        \n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    summ = 0\n                    for o in range(min(n, k+1)):\n                        for l in range(min(m, k+1)):\n                            summ += mat[o][l]\n                    matrix[i][j] = summ\n                elif j == 0:\n                    summ = 0\n                    remSumm = 0\n                    for l in range(min(m, k+1)):\n                        if i+k <= n-1:\n                            summ += mat[i+k][l]\n                        if i-k-1>= 0:\n                            remSumm += mat[i-k-1][l]\n                    matrix[i][j] = matrix[i-1][j] + summ - remSumm\n                else:\n                    summ = 0\n                    remSumm = 0\n                    for l in range(max(0, i-k), min(n, i+k+1)):\n                        if j + k <= m-1:\n                            summ += mat[l][j+k]\n                        if j-k-1 >= 0:\n                            remSumm += mat[l][j-k-1]\n                    matrix[i][j] = matrix[i][j-1] + summ - remSumm\n        return matrix\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n = len(mat)\n        m = len(mat[0])\n        result = [[0 for _ in range(m)] for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    for r in range(max(i - K, 0), min(i + K + 1, n)):\n                        for c in range(max(j - K, 0), min(j + K + 1, m)):\n                            result[i][j] += mat[r][c]\n                elif j > 0:\n                    prev_c = j - 1\n                    result[i][j] += result[i][prev_c]\n                    for r in range(max(i - K, 0), min(i + K + 1, n)):\n                        if j - K - 1 >= 0:\n                            result[i][j] -= mat[r][j - K - 1]\n                        if j + K < m:\n                            result[i][j] += mat[r][j + K]\n                else:\n                    prev_r = i - 1\n                    result[i][j] += result[prev_r][j]\n                    for c in range(max(j - K, 0), min(j + K + 1, m)):\n                        if i - K - 1 >= 0:\n                            result[i][j] -= mat[i - K - 1][c]\n                        if i + K < n:\n                            result[i][j] += mat[i + K][c]\n        return result", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        \n        RangeSum = [[0 for _ in range(n+1)] for _ in range(m+1)]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                RangeSum[i][j] = RangeSum[i-1][j] + RangeSum[i][j-1] - RangeSum[i-1][j-1] + mat[i-1][j-1]\n        \n        ans = [[0 for _ in range(n)] for _ in range(m)]\n        \n        print(RangeSum)\n        \n        for r in range(m):\n            for c in range(n):\n                i2 = min(m-1, r+K)\n                j2 = min(n-1, c+K)\n                i1 = max(0, r-K)\n                j1 = max(0, c-K)\n                # print(i1, j1, i2, j2)\n                ans[r][c] = RangeSum[i2+1][j2+1] - RangeSum[i2+1][j1] - RangeSum[i1][j2+1] + RangeSum[i1][j1]\n        \n        return ans", "import numpy as np\n\nclass Solution:\n\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n\n        mat_np = np.array(mat)\n\n        M, N = mat_np.shape # same shape with the sum_matrix\n\n        sum_np = np.zeros((M,N), dtype=int)\n\n        \n\n        for m in range(M):\n\n            for n in range(N):\n\n                sum_np[m,n] = np.sum(mat_np[max(0, m-K):min(m+K+1, M+1), \n\n                                            max(0, n-K):min(n+K+1, N+1)])\n\n                \n\n        return sum_np.tolist()", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        res = [[0]*n for _ in range(m)]\n        \n        # vert_slid_win = [0]*(K*2+1)\n        # for ii in range(0, K+1):\n        #     if ii>=0 and ii<m:\n        #         vert_slid_win[ii] = sum([mat[ii][c] for c in range(0, K+1) if c >=0 and c<m])\n                    \n        for i in range(m):\n            \n            hori_slid_win = [0]*(K*2+1)\n            for jj in range(0, K+1):\n                if jj>=0 and jj<n:\n                    hori_slid_win[jj+K] = sum([mat[r][jj] for r in range(i - K, i+K+1) if r >=0 and r<m])\n                    \n            for j in range(n):\n                res[i][j] = sum(hori_slid_win)\n                hori_slid_win.pop(0)\n                if j+K+1< n:\n                    hori_slid_win.append(sum([mat[r][j+K+1] for r in range(i - K, i+K+1) if r >=0 and r<m]))\n                # print(hori_slid_win)\n        return res ", "class Solution:\n    \n    def __init__(self):\n        from functools import lru_cache\n        return\n    \n    \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        self.cache = {}\n        k = K\n        # 2d kernel\n        n, m = len(mat), len(mat[0]) if len(mat) else 0\n                        \n        @lru_cache\n        def kernel(i,j, k):\n            minx, maxx = max(i-k,0), min(i+k+1, n)\n            miny, maxy = max(j-k,0), min(j+k+1, m)\n            s = 0\n            \n        def getrowsum(i,j,k):\n            if i < 0: return 0\n            if i >= n: return 0\n            miny, maxy = max(j-k,0), min(j+k+1,m)\n            return sum([mat[i][jj] for jj in range(miny, maxy)])\n\n        def getcolsum(ans,i,j,k):\n            if j < 0: return 0\n            if j >= m: return 0\n            minx, maxx = max(i-k,0), min(i+k+1,n)\n            return sum([ans[ii][j] for ii in range(minx, maxx)])\n            \n        ans = [[0 for j in range(m)] for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                ans[i][j] = getrowsum(i,j,k)\n\n        res = [[0 for j in range(m)] for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                res[i][j] = getcolsum(ans,i,j,k)\n        return res\n\n        # brute force\n        ans = [[0 for j in range(m)] for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                ans[i][j] = kernel(i,j, K)\n                \n        return ans", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        arr = [[0 for i in range(n+1)] for i in range(m)]\n        for i in range(m):\n            for j in range(n):\n                arr[i][j+1] = arr[i][j] + mat[i][j]\n\n        narr = [[0 for i in range(n)] for i in range(m)]\n        for i in range(m):\n            for j in range(n):\n                x1, x2, y1, y2 = max(0, j-k), min(n-1, j+k), max(0, i-k), min(m-1, i+k)\n                a = 0\n                for t in range(y1, y2+1):\n                    a += arr[t][x2+1]-arr[t][x1]\n                narr[i][j] = a\n        return narr", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        rows, cols = len(mat), len(mat[0])\n        dic = {}\n        for i, row in enumerate(mat):\n            prefix_sum = [0] * (cols + 1)\n            for j, num in enumerate(row):\n                prefix_sum[j] = prefix_sum[j-1] + num\n            dic[i] = prefix_sum\n       \n        for i in range(rows):\n            for j in range(cols):\n                start_col, end_col = max(j-K, 0), min(j+K, cols-1)\n                start_row, end_row = max(i-K, 0), min(i+K, rows-1)\n                res = 0\n                for idx in range(start_row, end_row+1):\n                    res += dic[idx][end_col]- dic[idx][start_col-1]\n                mat[i][j] = res\n        return mat\n", "import numpy as np\n\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        mat = np.array(mat)\n        answer = np.zeros(mat.shape)\n        for i, row in enumerate(mat):\n            row_start = max([0, i - K])\n            row_end = min([mat.shape[0], i + K])\n            for j, col in enumerate(row):\n                col_start = max([0, j - K])\n                col_end = min([mat.shape[1], j + K])\n                # TODO: \n                answer[i][j] = np.sum(mat[row_start:row_end + 1, col_start:col_end + 1])\n        return answer.astype(np.int)\n            \n            \n", "class Solution:\n    \n    def __init__(self):\n        from functools import lru_cache\n        return\n    \n    \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        self.cache = {}\n        k = K\n        n, m = len(mat), len(mat[0]) if len(mat) else 0\n                      \n        def brute_force():\n            def kernel(i, j, k):\n                minx, maxx = max(i-k,0), min(i+k+1, n)\n                miny, maxy = max(j-k,0), min(j+k+1, m)\n                s = 0\n                for ii in range(minx, maxx):\n                    for jj in range(miny, maxy):\n                        s += mat[ii][jj]\n                return s\n\n            ans = [[0 for j in range(m)] for i in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    ans[i][j] = kernel(i,j, k)\n            return ans\n        \n        #return brute_force()\n            \n        \n        def partials():\n            @lru_cache\n            def getrowsum(i,j,k):\n                if i < 0: return 0\n                if i >= n: return 0\n                miny, maxy = max(j-k,0), min(j+k+1,m)\n                return sum([mat[i][jj] for jj in range(miny, maxy)])\n\n            #@lru_cache\n            def getcolsum(ans,i,j,k):\n                if j < 0: return 0\n                if j >= m: return 0\n                minx, maxx = max(i-k,0), min(i+k+1,n)\n                return sum([ans[ii][j] for ii in range(minx, maxx)])\n\n            ans = [[0 for j in range(m)] for i in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    ans[i][j] = getrowsum(i,j,k)\n\n            res = [[0 for j in range(m)] for i in range(n)]\n            for i in range(n):\n                for j in range(m):\n                    res[i][j] = getcolsum(ans,i,j,k)\n            return res\n        \n        return partials()\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        r, c = len(mat), len(mat[0])\n        rsums = [[0] for i in range(r)]\n        for i in range(r):\n            for j in range(c):\n                rsums[i].append(rsums[i][-1]+mat[i][j])\n        for i in range(r):\n            for j in range(c):\n                mat[i][j] = 0\n                lr = 0 if i-k < 0 else i-k\n                rr = r-1 if i+k >= r else i+k\n                lc = 0 if j-k < 0 else j-k\n                rc = c-1 if j+k >= c else j+k\n                rc += 1\n                for x in range(lr, rr+1):\n                    mat[i][j] += (rsums[x][rc] - rsums[x][lc])\n        return mat", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m=len(mat)\n        n=len(mat[0])\n        answer=[]\n        temp=[]\n        val,i,j=0,0,0\n        for r in range(max(0,i-K),min(i+K+1,m)):\n            for c in range(max(0,j-K),min(j+K+1,n)):\n                val+=mat[r][c]\n        temp.append(val)\n        for i in range(m):\n            if i==0:\n                row=temp\n            else:\n                row=[]\n                r1=i-K-1\n                r2=i+K\n                subs2,adds2=0,0\n                for c in range(max(0,-K),min(K+1,n)):\n                    if r1>=0:\n                        subs2+=mat[r1][c]\n                    if r2<m:\n                        adds2+=mat[r2][c]\n                row.append(answer[-1][0]+adds2-subs2)\n            for j in range(1,n):\n                subs,adds=0,0\n                c1=j-K-1\n                c2=j+K\n                for r in range(max(0,i-K),min(i+K+1,m)):\n                    if c1>=0:\n                        subs+=mat[r][c1]\n                    if c2<n:\n                        adds+=mat[r][c2]\n                row.append(row[-1]+adds-subs)\n            answer.append(row)\n        return answer", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        #   \u79ef\u5206\u56fe\n        M = len(mat)\n        N = len(mat[0])\n        \n        if (K) >= (M-1) and (K) >= (N-1):\n            t = 0\n            for h in mat:\n                for w in h:\n                    t += w\n            rtv = [[t] * N for _ in range(M)]\n            return rtv\n\n        def calc(presums, h, w, K):\n            h1 = h - K\n            h2 = h + K+1\n            w1 = w - K\n            w2 = w + K+1\n            \n            w1 = max(w1, 0)\n            h1 = max(h1, 0)\n            w2 = min(w2, N)\n            h2 = min(h2, M)\n            \n            return presums[h1][w1] + presums[h2][w2] - presums[h1][w2] - presums[h2][w1]\n        \n        presums = [[0] * (N+1) for _ in range(M+1)]\n        \n        for h in range(M):\n            for w in range(N):\n                presums[h+1][w+1] = presums[h+1][w] + presums[h][w+1] - presums[h][w] + mat[h][w]\n        \n        rtv = [[0] * (N) for _ in range(M)]\n        \n        for h in range(M):\n            for w in range(N):\n                rtv[h][w] = calc(presums, h, w, K)\n        \n        \n        return rtv", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        k = K\n        n, m = len(mat), len(mat[0])\n        matrix = []\n        for i in range(n):\n            temp = []\n            for  j in range(m):\n                temp.append(0)\n            matrix.append(temp)\n        \n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    summ = 0\n                    for o in range(min(n, k+1)):\n                        for l in range(min(m, k+1)):\n                            summ += mat[o][l]\n                    matrix[i][j] = summ\n                elif j == 0:\n                    summ = 0\n                    remSumm = 0\n                    for l in range(min(m, k+1)):\n                        if i+k <= n-1:\n                            summ += mat[i+k][l]\n                        if i-k-1>= 0:\n                            remSumm += mat[i-k-1][l]\n                    print((i, j, matrix[i-1][j], summ, remSumm))\n                    matrix[i][j] = matrix[i-1][j] + summ - remSumm\n                else:\n                    summ = 0\n                    remSumm = 0\n                    for l in range(max(0, i-k), min(n, i+k+1)):\n                        if j + k <= m-1:\n                            summ += mat[l][j+k]\n                        if j-k-1 >= 0:\n                            remSumm += mat[l][j-k-1]\n                    print((i, j, matrix[i][j-1], summ, remSumm))\n                    matrix[i][j] = matrix[i][j-1] + summ - remSumm\n        return matrix\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        rows, cols = len(mat), len(mat[0])\n        ans = [[0 for _ in range(cols)] for _ in range(rows)]\n        \n        for i in range(rows):\n            for j in range(1, cols):\n                mat[i][j] += mat[i][j - 1]\n                if i > 0:\n                    mat[i][j - 1] += mat[i - 1][j - 1]\n            if i > 0:\n                mat[i][cols - 1] += mat[i - 1][cols - 1]\n        \n        for i in range(rows):\n            for j in range(cols):\n                top, bottom, left, right = i, i, j, j\n                \n                countT = k\n                while top > 0 and countT > 0:\n                    top -= 1\n                    countT -= 1\n                    \n                countB = k\n                while bottom < rows - 1 and countB > 0:\n                    bottom += 1\n                    countB -= 1\n                \n                countL = k\n                while left > 0 and countL > 0:\n                    left -= 1\n                    countL -= 1\n                \n                countR = k\n                while right < cols - 1 and countR > 0:\n                    right += 1\n                    countR -= 1\n                \n                ans[i][j] += mat[bottom][right]\n\n                if top - 1 >= 0 and countT == 0:\n                    ans[i][j] -= mat[top - 1][right]\n                if left - 1 >= 0 and countL == 0:\n                    ans[i][j] -= mat[bottom][left - 1]\n                if top - 1 >= 0 and left - 1 >= 0 and countT == 0 and countL == 0:\n                    ans[i][j] += mat[top - 1][left - 1]\n                \n        return ans", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        r, c = len(mat), len(mat[0])\n        rsums = [[0] for i in range(r)]\n        for i in range(r):\n            for j in range(c):\n                rsums[i].append(rsums[i][-1]+mat[i][j])\n        res = [[0 for i in range(c)] for j in range(r)]\n        for i in range(r):\n            for j in range(c):\n                mat[i][j] = 0\n                lr = 0 if i-k < 0 else i-k\n                rr = r-1 if i+k >= r else i+k\n                lc = 0 if j-k < 0 else j-k\n                rc = c-1 if j+k >= c else j+k\n                rc += 1\n                for x in range(lr, rr+1):\n                    mat[i][j] += (rsums[x][rc] - rsums[x][lc])\n        return mat", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        row = len(mat)\n        col = len(mat[0])\n        \n        answer = [[0 for i in range(col)] for j in range(row)]\n        \n        for i in range(row):\n            for j in range(1,col):\n                # answer[i][j] = self.new_matrix(mat,i,j,K,row,col)\n                mat[i][j] = mat[i][j-1]+mat[i][j]\n        print(mat)\n        \n        for i in range(row):\n            for j in range(col):\n                answer[i][j] = self.new_matrix(mat,i,j,K,row,col)\n        return answer\n                \n    def new_matrix(self,mat,i,j,k,row,col):\n        ans = 0 \n        new_row_low = i-k\n        new_row_high = i + k\n        new_col_low = j-k\n        new_col_high = j+k\n        \n        \n        while(new_row_low < 0):\n            new_row_low +=1\n        while(new_row_high > row-1):\n            new_row_high -=1\n        while(new_col_low < 0):\n            new_col_low +=1\n        while(new_col_high > col-1):\n            new_col_high-=1\n        \n        \n        \n        for a in range(new_row_low, new_row_high+1):\n            \n            ans+= mat[a][new_col_high]\n            \n            if(new_col_low-1 >= 0):\n                \n                ans -= mat[a][new_col_low-1]\n                \n        return ans\n                    \n            \n        \n        \n        \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        if not mat or not mat[0]:\n            return mat\n        R, C = len(mat), len(mat[0])\n        l2r = [[0] * C for _ in range(R)]\n        t2b = [[0] * C for _ in range(R)]\n        \n        for r in range(R):\n            for c in range(C):\n                l2r[r][c] += mat[r][c]\n                if c != 0:\n                    l2r[r][c] += l2r[r][c-1]\n                \n                t2b[r][c] += mat[r][c]\n                if r != 0:\n                    t2b[r][c] += t2b[r-1][c]\n        \n        ret = [[0] * C for _ in range(R)]\n        for r in range(R):\n            for c in range(C):\n                temp = 0\n                left = max(0, c-K)\n                right = min(C-1, c+K)\n                for _r in range(max(0, r - K), min(R, r+K+1)):\n                    if left == 0:\n                        temp += l2r[_r][right]\n                    else:\n                        temp += l2r[_r][right] - l2r[_r][left-1]\n                \n                ret[r][c] = temp\n        \n        return ret", "import copy\nclass Solution:    \n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n_row = len(mat)\n        n_column = len(mat[0])        \n        \n        print(n_row, n_column, K , \\\"n_row, n_column, K\\\")\n        \n        memo = [[0 for _ in range(n_column)] for _ in range(n_row)]\n        new_mat = [[0 for _ in range(n_column)] for _ in range(n_row)]\n        \n        ## column wise memoization    \n        if n_row > n_column:        \n            for i in range(n_row):\n                for j in range(n_column):                    \n                    start_row= 0 if i-K <0 else i-K\n                    end_row = n_row-1 if i+K > n_row-1 else i+K\n                    \n                    for r in range(start_row, end_row+1):\n                        memo[i][j] +=mat[r][j]                        \n        else:\n            for i in range(n_row):\n                for j in range(n_column):                    \n                    start_column= 0 if j-K <0 else j-K\n                    end_column = n_column-1 if j+K > n_column-1 else j+K\n                    \n                    for r in range(start_column, end_column+1):\n                        memo[i][j] +=mat[i][r]                                            \n                    \n        print(len(memo), len(memo[0]), \\\"n_row , n_columns of memo\\\")\n                        \n        ## main calculation\n        if n_row > n_column:\n            for i in range(n_row):\n                for j in range(n_column):    \n                    start_column= 0 if j-K <0 else j-K\n                    end_column = n_column-1 if j+K > n_column-1 else j+K                    \n                    \n                    for r in range(start_column, end_column+1):\n                        new_mat[i][j] += memo[i][r] \n        else:\n            for i in range(n_row):\n                for j in range(n_column):\n                    start_row= 0 if i-K <0 else i-K\n                    end_row = n_row-1 if i+K > n_row-1 else i+K\n                    \n                    for r in range(start_row, end_row+1):\n                        new_mat[i][j] += memo[r][j] \n                    \n        return new_mat", "import numpy as np\n\nclass Solution:\n    def matrixBlockSum(self, A, K):\n        A = np.array(A)\n        m, n = A.shape\n        return [[A[max(i-K, 0):i+K+1, max(j-K, 0):j+K+1].sum()\n                 for j in range(n)] for i in range(m)]", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n, m = len(mat), len(mat[0])\n\n        def blockSum(x, y, vertical=K, horizontal=K):\n            s = 0\n            for i in range(x - vertical, x + vertical + 1):\n                for j in range(y - horizontal, y + horizontal + 1):\n                    if 0 <= i < n and 0 <= j < m:\n                        s += mat[i][j]\n            return s\n\n        result = [[0 for j in range(m)] for i in range(n)]\n\n        for i in range(n):\n            result[i][0] = blockSum(0, 0) if i == 0 \\\\\n                else result[i - 1][0] \\\\\n                     + (blockSum(i + K, 0, 0, K) if i < n - K else 0) \\\\\n                     - (blockSum(i - (K + 1), 0, 0, K) if i >= K + 1 else 0)\n\n            for j in range(1, m):\n                result[i][j] = result[i][j - 1] \\\\\n                               + (blockSum(i, j + K, K, 0) if j < m - K else 0) \\\\\n                               - (blockSum(i, j - (K + 1), K, 0) if j >= K + 1 else 0)\n\n        return result", "\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        #i - K <= r <= i + K\n        #[0][0]\n        #0 - 1 <= r <= 1\n        #   -1 <= r <= 1\n        #j - K <= c <= j + K\n        #   -1 <= c <= 1\n        # => square with x=2\n        #a[0][0] = row0+row1+col0+col1\n        #        = 1+2=3+4+5 = 12\n        \n        #k = 1\n        #[1][0]\n        #1-1=0 <= r <= 2\n        #1+2+4+5+7+8=?=27 yes\n        \n        \n        sum_mtx = [[0 for col in range(len(mat[0]))] for row in range( len(mat)) ]\n        \n        #new matrix that is sum of prev_sum + curr_val\n        #[31, 2, 4]\n        #[12, 26, 9]\n        #=>\n        #[31, 33, 37] #curr_sum = left_sum + curr_val\n        #[43, 71 84] #1:43+ 2 + 26 = 71 = \n        #                                   71  + 9 + 4 = 84\n        #sum_mtx[0][0] = mat[0][0] #don't need\n        for row in range(len(mat)):\n            #reset each row\n            summ = 0\n            for col in range(len(mat[0])):\n                #left_sum(without the its above_sum) + curr_val\n                summ += mat[row][col] #ONLY summing horizontals\n                sum_mtx[row][col] = summ\n                \n                #for !row=0\n                if row > 0:\n                    #(left_sum* + curr_val + above_sum)\n                    sum_mtx[row][col] += sum_mtx[row-1][col]\n        #above mtx allows us to just select the 4 idxes instead of having to repeatedly compute the sums of the blocks:a,b,c,d every time\n        #print(sum_mtx)\n        \n        output_img = [[0 for col in range(len(mat[0]))] for row in range( len(mat)) ]\n        \n        \n        for row in range(len(mat)):\n            for col in range(len(mat[0])):\n                #the \\\"window\\\": like a zoom feature\n                max_row = min( len(mat)-1, K + row)\n                min_row = max( 0       , row - K)\n                min_col = max( col - K, 0)\n                max_col = min( col + K, len(mat[0])-1)\n                a_val, b_val, c_val = 0,0,0\n                d_val = sum_mtx[max_row][max_col]\n                \n                if min_col > 0:\n                    c_val = sum_mtx[max_row][min_col-1]\n                \n                if min_row > 0:\n                    b_val = sum_mtx[min_row-1][max_col]\n                \n                if c_val and b_val: #both exist\n                    a_val = sum_mtx[min_row-1][min_col-1]\n                \n                output_img[row][col] = d_val - b_val - c_val + a_val\n        return output_img\n\n", "import numpy as np\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m = len(mat)\n        n = len(mat[0])\n        if m == 1 and n == 1: return mat\n        mat = np.array(mat)        \n        ans = np.array([[0 for _ in range(n)] for _ in range(m)])\n        ans[0, 0] += mat[:min(m, K+1), :min(n, K+1)].sum()\n        for j in range(1, n):\n            ans[0, j] = ans[0, j - 1]\n            if j + K < n: ans[0, j] += mat[:min(K + 1, m), j + K].sum()\n            if j - K > 0: ans[0, j] -= mat[:min(K + 1, m), j - K - 1].sum()\n        for i in range(1, m):\n            ans[i, 0] = ans[i - 1, 0]\n            if i + K < m: ans[i, 0] += mat[i + K, :min(K + 1, n)].sum()\n            if i - K > 0: ans[i, 0] -= mat[i - K - 1, :min(K + 1, n)].sum()\n        for i in range(1, m):\n            for j in range(1, n):\n                ans[i, j] = ans[i, j - 1]\n                if j + K < n: ans[i, j] += mat[max(0, i - K): min(i + K + 1, m), j + K].sum()\n                if j - K > 0: ans[i, j] -= mat[max(0, i - K): min(i + K + 1, m), j - K - 1].sum()\n        return ans", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        import numpy as np\n        mat = np.array(mat)\n        ans = []\n        for i in range(mat.shape[0]):\n            temp = []\n            for j in range(mat.shape[1]):\n                left = 0 if i-K <0 else i-K\n                right = i+K+1\n                up = 0 if j-K <0 else j-K\n                down = j+K+1\n                temp.append(np.sum(mat[left:right,up:down]))\n            ans.append(temp)\n        return(ans)", "import numpy as np\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        # Edge case\n        if not mat or not mat[0]:\n            return []\n        # General case\n        mat = np.array(mat)\n        m, n = mat.shape\n        output = np.zeros((m, n), dtype=np.int)\n        for i in range(m):\n            for j in range(n):\n                rowLB, rowUB = max(0, i - K), min(i + K, m - 1) + 1\n                colLB, colUB = max(0, j - K), min(j + K, n - 1) + 1\n                output[rowLB: rowUB, colLB: colUB] += mat[i][j] * np.ones((rowUB - rowLB, colUB - colLB), dtype=np.int)\n        return output", "import numpy as np\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n = len(mat)\n        m = len(mat[0])\n        padded = np.pad(np.asarray(mat), K)\n        result = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                result[i][j] = np.sum(padded[i:i + 2 * K + 1, j:j + 2 * K + 1])\n        return result", "import numpy as np\nclass Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        n = len(mat)\n        m = len(mat[0])\n        padded = np.pad(np.asarray(mat), K)\n        # conv = np.ones(2 * K + 1, 2 * K + 1)\n        result = [[0] * m for _ in range(n)]\n        # print(padded)\n        for i in range(n):\n            for j in range(m):\n                result[i][j] = np.sum(padded[i:i + 2 * K + 1, j:j + 2 * K + 1])\n                # for row in padded[i:i + 2 * K + 1, j:j + 2 * K + 1]:\n                    # print(i,j, row, 2 * K)\n                # print()\n        return result", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        m, n = len(mat), len(mat[0])\n        k = K\n        row = [[0 for _ in range(n)] for _ in range(m)]\n        ans = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):        \n                for r in range(max(0, i-k), min(m, i+k+1)):\n                    row[i][j] += mat[r][j]\n\n        \n        for i in range(m):\n            for j in range(n):\n                    for c in range(max(0, j-k), min(n, j+k+1)):\n                        ans[i][j] += row[i][c]\n        \n        return ans", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        res=[]\n        t=[]\n        for i in range(len(mat)):\n            t.append([0]*len(mat[0]))\n            res.append([0]*len(mat[0]))\n            for j in range(len(mat[0])):\n                t[i][j]=mat[i][j]\n                if j>0:\n                    mat[i][j]+=mat[i][j-1]\n                    \n                \n        #print(mat,t)\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                s = 0\n                top = i-K\n                bot = i+K\n                left = j-K\n                if left<0: left =0\n                right = j+K\n                if right>=len(mat[0]):\n                    right=len(mat[0])-1\n                for k in range(top,bot+1):\n                    if k>=0 and k<len(mat):\n                        s+=(mat[k][right]-mat[k][left]+t[k][left])\n                res[i][j]=s\n        return res\n                \n                \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        cumMat = [[0 for _ in range(len(mat[0]) + 2)] for _ in range(len(mat) + 2)]\n        cumMat[1][1] = mat[0][0]\n        for i in range(2, len(mat) + 1):\n            cumMat[i][1] = mat[i - 1][0] + cumMat[i - 1][1]\n        for j in range(2, len(mat[0]) + 1):\n            cumMat[1][j] = mat[0][j - 1] + cumMat[1][j - 1]\n        for i in range(2, len(mat) + 1):\n            for j in range(2, len(mat[0]) + 1):\n                cumMat[i][j] = mat[i - 1][j - 1] + cumMat[i - 1][j] + cumMat[i][j - 1] - cumMat[i - 1][j - 1]\n          \n        answer = [[0 for _ in mat[0]] for _ in mat]\n        for i in range(1, len(cumMat) - 1):\n            for j in range(1, len(cumMat[0]) - 1):\n                i1 = max(1, i - K)\n                i2 = min(len(cumMat) - 2, i + K)\n                j1 = max(1, j - K)\n                j2 = min(len(cumMat[0]) - 2, j + K)\n                # print(i1)\n                # print(j1)\n                # print(i2)\n                # print(j2)\n                answer[i - 1][j - 1] = cumMat[i2][j2] - cumMat[i1 - 1][j2] - cumMat[i2][j1 - 1] + cumMat[i1 - 1][j1 - 1]\n                print(answer[i - 1][j - 1])\n        return answer", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        res=[]\n        t=[]\n        for i in range(len(mat)):\n            t.append([0]*len(mat[0]))\n            for j in range(len(mat[0])):\n                t[i][j]=mat[i][j]\n        for i in range(len(mat)):\n            res.append([0]*len(mat[0]))\n            t.append([0]*len(mat[0]))\n            for j in range(1,len(mat[0])):\n                \n                mat[i][j]+=mat[i][j-1]\n                \n        #print(mat,t)\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                s = 0\n                top = i-K\n                bot = i+K\n                left = j-K\n                if left<0: left =0\n                right = j+K\n                if right>=len(mat[0]):\n                    right=len(mat[0])-1\n                #print(left,right)\n                for k in range(top,bot+1):\n                    if k>=0 and k<len(mat):\n                        s+=(mat[k][right]-mat[k][left]+t[k][left])\n                        #print(s)\n                res[i][j]=s\n        return res\n                \n                \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\n        r, c = len(mat), len(mat[0])\n        rsums = [[0] for i in range(r)]\n        for i in range(r):\n            for j in range(c):\n                rsums[i].append(rsums[i][-1]+mat[i][j])\n        #for i in rsums:\n        #    print(*i)\n        res = [[0 for i in range(c)] for j in range(r)]\n        for i in range(r):\n            for j in range(c):\n                mat[i][j] = 0\n                lr = 0 if i-k < 0 else i-k\n                rr = r-1 if i+k >= r else i+k\n                lc = 0 if j-k < 0 else j-k\n                rc = c-1 if j+k >= c else j+k\n                rc += 1\n                #print((i,j),lr,rr,lc,rc)\n                for x in range(lr, rr+1):\n                    mat[i][j] += (rsums[x][rc] - rsums[x][lc])\n        return mat\n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m,n = len(mat), len(mat[0])\n        ans = [[0] *n for i in range(m)]\n        \n        def in_range(i,j):\n            return i>=0 and i<m and j>=0 and j<n\n        \n        ans[0][0] = sum([mat[i][j] for i in range(0,K+1) for j in range(0,K+1) if in_range(i,j)])\n        \n        for r in range(1,m):\n            add = sum([mat[r+K][j] for j in range(0,K+1) if r+K<m and j<n])\n            sub = sum([mat[r-K-1][j] for j in range(0,K+1) if r-K-1>=0 and j<n])\n            ans[r][0] = ans[r-1][0] + add - sub\n            \n        for r in range(0,m):\n            for c in range(1,n):\n                add = sum([mat[i][c+K] for i in range(r-K, r+K+1) if i>=0 and i<m and c+K<n])\n                sub = sum([mat[i][c-K-1] for i in range(r-K, r+K+1) if i>=0 and i<m and c-K-1>=0])\n                ans[r][c] = ans[r][c-1] + add - sub\n        \n        return ans                   \n", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        dp = []\n        result = []\n        for y in range(len(mat)):\n            dp.append([])\n            s = 0\n            for x in range(len(mat[y])):\n                s += mat[y][x]\n                dp[y].append(s)\n        \n        for y in range(len(mat)):\n            result.append([])\n            for x in range(len(mat[y])):    \n                cur = 0\n                for y1 in range(max(y-K, 0), min(y+K+1, len(mat))):\n                    if x-K-1 >=0:\n                        cur -= dp[y1][x-K-1]\n                    cur += (dp[y1][len(mat[y1])-1] if x+K >= len(mat[y1]) else dp[y1][x+K])\n                result[y].append(cur)                \n        return result", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        import numpy as np\n        from scipy.signal import convolve2d\n        mat = np.array(mat, dtype = int)\n        convolution = np.ones((2 * K + 1, 2 * K + 1), dtype = int)\n        mat = convolve2d(mat, convolution, 'same')\n        return mat", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        from numpy import array, ones\n        from scipy.signal import convolve2d\n        \n        mat = array(mat, dtype = int)\n        convolution = ones((2 * K + 1, 2 * K + 1), dtype = int)\n        mat = convolve2d(mat, convolution, 'same')\n        \n        return mat", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        \n        \n        def getSum(i,j):\n            ii = max(i-K, 0)\n            s = 0\n            while ii <= min(i+K, len(mat)-1):\n                jj = max(j-K, 0)\n                while jj <= min(j+K, len(mat[0])-1):\n                    s += mat[ii][jj]\n                    jj += 1\n                ii += 1\n            return s\n        \n        def editCol(i,j, s):\n            if j-K-1 >= 0:\n                ii = max(i-K, 0)\n                while ii <= min(i+K, len(mat)-1):\n                    s -= mat[ii][j-K-1]\n                    ii += 1\n            if j+K < len(mat[0]):\n                ii = max(i-K, 0)\n                while ii <= min(i+K, len(mat)-1):\n                    s += mat[ii][j+K]\n                    ii += 1\n            return s\n            \n        rett = []\n        for i in range(len(mat)):\n            s = getSum(i,0)\n            ret = [s]\n            for j in range(1,len(mat[i])):\n                s = editCol(i,j, s)\n                ret.append(s)\n            rett.append(ret)\n        return rett", "class Solution:\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        cum = [[0 for i in range(len(mat[0]))] for i in range(len(mat)) ] \n        for i in range(len(mat)):\n            for j in range(len(mat[i])):\n                if j==0:\n                    cum[i][j] = mat[i][j]\n                else:\n                    cum[i][j] = cum[i][j-1] + mat[i][j]\n        \n        ans = [[0 for i in range(len(mat[0]))] for i in range(len(mat)) ]\n        \n        # print(cum)\n        \n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                summ = 0\n                for k in range(max(0,i-K),min(len(mat),i+K+1)):\n                    if(j-K-1<0):\n                        summ += cum[k][min(j+K,len(cum[i])-1)]\n                    else:\n                        # print(k, len(cum[k]))\n                        summ += cum[k][min(j+K,len(cum[k])-1)] \n                        summ -= cum[k][j-K-1] \n                ans[i][j] = summ\n        print(ans)\n        return ans"]
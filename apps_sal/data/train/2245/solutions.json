["from sys import stdin, stdout\n\nrd = lambda: list(map(int, stdin.readline().split()))\n\nn, m, k = rd()\na = rd()\nb = [rd() for _ in range(m)]\nx = [0]*(m+1)\ny = [0]*(n+1)\n\nfor _ in range(k):\n  l, r = rd()\n  x[l-1] += 1\n  x[r  ] -= 1\n\ns = 0\nfor i in range(m):\n  l, r, d = b[i]\n  s += x[i]\n  y[l-1] += s*d\n  y[r  ] -= s*d\n\ns = 0\nfor i in range(n):\n  s += y[i]\n  a[i] += s\nprint(' '.join(map(str, a)))", "n, m, k = map(int, input().split())\nt = list(map(int, input().split()))\np = [tuple(map(int, input().split())) for i in range(m)]\n\nr, s = [0] * (m + 1), [0] * (n + 1)\nR, S = 0, 0\n\nfor i in range(k):\n    x, y = map(int, input().split())\n    r[x - 1] += 1\n    r[y] -= 1\n\nfor i, (x, y, d) in enumerate(p):\n    R += r[i]\n    d = d * R\n    s[x - 1] += d\n    s[y] -= d\n\nfor i in range(n):\n    S += s[i]\n    t[i] = str(t[i] + S)\n\nprint(' '.join(map(str, t)))", "read_input = lambda: list(map(int, input().split()))\n\nn, m, k = read_input()\ninit_array = read_input()\noperations = [read_input() for _ in range(m)]\nadditionals = [0]*(m+1)\nsums = [0]*(n+1)\n\n# Calculates the number of operations needed by using increments and decrements\nfor _ in range(k):\n  x, y = read_input()\n  additionals[x-1] += 1\n  additionals[y  ] -= 1\n\n# Calculates the operations times the number of times the operation is executed\nsum_so_far = 0\nfor i in range(m):\n  l, r, val_to_add = operations[i]\n  sum_so_far += additionals[i]\n  sums[l-1] += sum_so_far*val_to_add\n  sums[r  ] -= sum_so_far*val_to_add\n\n# Calculates the final number. Positives add while negatives remove\nsum_so_far = 0\nfor i in range(n):\n  sum_so_far += sums[i]\n  init_array[i] += sum_so_far\nprint(' '.join(map(str, init_array)))", "#import sys; sys.stdin = open(\"TF.txt\")\n\nR = lambda: list(map(int,input().split()))\ndef modif(lst):\n    lst[0]-=1\n    lst[1]-=1\n    return lst\nn,m,k = R()\na = R()\nop = [modif(R()) for i in range(m)]\nb = [0]*(n)\ncnt = [0]*(m)\nfor i in range(k):\n    l,r = R()\n    l-=1;r-=1\n    cnt[l] += 1\n    try: cnt[r+1] -= 1\n    except: pass\nq = [0]*(m)\ntoadd  = 0\nfor i,v in enumerate(cnt):\n    toadd += v\n    q[i] += toadd\nfor i,v in enumerate(q):\n    b[op[i][0]] += op[i][2] * v\n    try: b[op[i][1]+1] -= op[i][2] * v\n    except: pass\ntoadd = 0\nfor i,v in enumerate(b):\n    toadd += v\n    a[i] += toadd\nprint(*a)", "def main():\n    n, m, k = list(map(int, input().split()))\n    aa = list(map(int, input().split()))\n    lrd = list(tuple(map(int, input().split())) for _ in range(m))\n    cnt = [0] * (m + 1)\n    for _ in range(k):\n        x, y = list(map(int, input().split()))\n        cnt[x - 1] += 1\n        cnt[y] -= 1\n    delta, c = [0] * (n + 1), 0\n    for (l, r, d), dc in zip(lrd, cnt):\n        c += dc\n        d *= c\n        delta[l - 1] += d\n        delta[r] -= d\n    da = 0\n    for i, a, d in zip(list(range(n)), aa, delta):\n        da += d\n        aa[i] = a + da\n    print(\" \".join(map(str, aa)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m, k = [int(n) for n in input().split()]\na = [int(n) for n in input().split()]\ninstructions = []\ntemp = []\nfor i in range(n+1):\n\ttemp.append(0)\nfor i in range(m):\n\tinstructions.append([int(n) for n in input().split()])\nqueries = []\nfor i in range(m+1):\n\tqueries.append(0)\nfor i in range(k):\n\tx, y = [int(n) for n in input().split()]\n\tx-=1\n\ty-=1\n\tqueries[x]+=1\n\tqueries[y+1]-=1\n\nnum_queries = 0\nfor i in range(m):\n\tnum_queries += queries[i]\n\ttemp[instructions[i][0]-1] += num_queries*instructions[i][2]\n\ttemp[instructions[i][1]] -= num_queries*instructions[i][2]\n#print(temp[0]+a[0], end=\" \")\nx = temp[0]\nprint(x + a[0], end=\" \")\nfor i in range(1, n):\n\tx += temp[i]\n\tprint(x + a[i], end=\" \")\nprint()", "# -------\n# imports\n# -------\n\nimport sys\n\n\n# -------\n# solve\n# -------\n\ndef solve(r, w):\n    \"\"\"\n    :param r:\n    :param w:\n    :return:\n    \"\"\"\n    data = r.readline().split()\n    num_elems = int(data[0])\n    num_ops = int(data[1])\n    num_queries = int(data[2])\n\n    elem_list = [int(x) for x in r.readline().split()]\n    a = [0] * (num_ops + 1)\n    b = [0] * (num_elems + 1)\n\n    # get operations\n    op_list = []\n    for _ in range(num_ops):\n        op_list.append(tuple([int(x) for x in r.readline().split()]))\n\n    for _ in range(num_queries):\n        query = [int(x) for x in r.readline().split()]\n        a[query[0] - 1] += 1\n        a[query[1]] -= 1\n\n    c = 0\n    for i, cur_op in enumerate(op_list):\n        cur_op = op_list[i]\n        c += a[i]\n        b[cur_op[0] - 1] += c * cur_op[2]\n        b[cur_op[1]] -= c * cur_op[2]\n\n    c = 0\n    for i, elem in enumerate(elem_list):\n        c += b[i]\n        print(elem + c, end=' ')\n\n\n# -------\n# main\n# -------\n\ndef __starting_point():\n    solve(sys.stdin, sys.stdout)\n\n__starting_point()", "from sys import *\n\nrd = lambda: list(map(int, stdin.readline().split()))\n\nn, m, k = rd()\na = rd()\nb = [rd() for _ in range(m)]\nx = [0]*(m+1)\ny = [0]*(n+1)\n\nfor _ in range(k):\n  l, r = rd()\n  x[l-1] += 1\n  x[r]   -= 1\n\ns = 0\nfor i in range(m):\n  l, r, d = b[i]\n  s += x[i]\n  y[l-1] += s*d\n  y[r]   -= s*d\n\ns = 0\nfor i in range(n):\n  s += y[i]\n  a[i] += s\nprint(*a)", "#!/usr/bin/env python3\n\nimport sys\n\n(n, m, k) = list(map(int, sys.stdin.readline().split(' ')))\n\na = list(map(int, sys.stdin.readline().split(' ')))\nb = [0] * ((int)(1e5) + 1)\nc = [0] * ((int)(1e5) + 1)\nl = []\nr = []\nd = []\n\nfor i in range(m):\n    (li, ri, di) = list(map(int, sys.stdin.readline().split(' ')))\n    l.append(li)\n    r.append(ri)\n    d.append(di)\n\nfor i in range(k):\n    (xi, yi) = list(map(int, sys.stdin.readline().split(' ')))\n    c[xi - 1] += 1\n    c[yi] -= 1\n\ncur = 0\nfor i in range(0, m):\n    cur += c[i]\n    b[l[i]-1] += (cur*d[i])\n    b[r[i]] -= (cur*d[i])\n\nret = []\ncur = 0\nfor i in range(len(a)):\n    num = b[i]\n    cur += num\n    ret.append(str(cur + a[i]))\n\nsys.stdout.write(' '.join(ret) + '\\n')\n", "import sys\n\n(n, m, k) = list(map(int, sys.stdin.readline().split(' ')))\n\na = list(map(int, sys.stdin.readline().split(' ')))\nb = [0] * ((int)(1e5) + 1)\nc = [0] * ((int)(1e5) + 1)\nl = []\nr = []\nd = []\n\nfor i in range(m):\n    (li, ri, di) = list(map(int, sys.stdin.readline().split(' ')))\n    l.append(li)\n    r.append(ri)\n    d.append(di)\n\nfor i in range(k):\n    (xi, yi) = list(map(int, sys.stdin.readline().split(' ')))\n    c[xi - 1] += 1\n    c[yi] -= 1\n\ncur = 0\nfor i in range(0, m):\n    cur += c[i]\n    b[l[i]-1] += (cur*d[i])\n    b[r[i]] -= (cur*d[i])\n\nret = []\ncur = 0\nfor i in range(n):\n    cur += b[i]\n    ret.append(str(cur + a[i]))\n\nsys.stdout.write(' '.join(ret) + '\\n')\n", "def GregAndArray():\n    lenArray, numOperations, numQueries = map(int, input().split())\n    initialArray = list(map(int, input().split()))\n    \n    instructions = [list(map(int, input().split())) for _ in range(numOperations)]\n    \n    modifiedArray = [0 for _ in range(lenArray + 1)]\n    queries       = [0 for _ in range(numOperations + 1)]\n    \n    for _ in range(numQueries):\n    \tx, y = map(int, input().split())\n    \t\n    \tqueries[x-1] += 1\n    \tqueries[y]   -= 1\n    \n    temp = 0\n    for i in range(numOperations):\n    \ttemp += queries[i]\n    \tmodifiedArray[instructions[i][0]-1] += temp*instructions[i][2]\n    \tmodifiedArray[instructions[i][1]]   -= temp*instructions[i][2]\n    \n    temp = 0\n    toReturn = \"\"\n    for i in range(lenArray):\n        temp += modifiedArray[i]\n        toReturn += (str(temp + initialArray[i]) + \" \")\n    \n    print(toReturn)\n\nGregAndArray()", "int_list = lambda s: [int(n) for n in s.split(\" \")]\nn,m,k = int_list(input())\narr = int_list(input())\noperations = [int_list(input()) for _ in range(m)]\n\nincrs = [0]*len(arr)      # Amount to increment running total when traversing arr\nfreq = [0]*m              # The number of times the corresponding operation is used\n                          # stored in the same format as incrs\n\nfor _ in range(k):\n  l,r = int_list(input())\n  freq[l-1] += 1\n  if r < len(freq): freq[r] -= 1\n  \ntimes = 0                   # number of times to apply current operation\nfor i, op in enumerate(operations):\n  l,r,d = op\n  times += freq[i]          # update running total\n  incrs[l-1] += times*d     # encode operation in incrs\n  if r < len(incrs): incrs[r] -= times*d\n    \nprev = 0\nfor i,n in enumerate(arr):\n  arr[i] = prev + n + incrs[i]\n  prev += incrs[i]\n  \nprint(\" \".join([str(n) for n in arr]))", "def solve():\n    n, m, k = list(map(int, input().strip().split()))\n    array = list(map(int, input().strip().split()))\n    ops = [tuple(map(int, input().strip().split())) for _ in range(m)]\n    applied = [0 for _ in range(m + 1)]\n    qs = [tuple(map(int, input().strip().split())) for _ in range(k)]\n    for x, y in qs:\n        applied[x - 1] += 1\n        applied[y] -= 1\n    cumadds = [0 for _ in range(n + 1)]\n    repeats = 0\n    for i, (l, r, d) in enumerate(ops):\n        repeats += applied[i]\n        cumadds[l - 1] += repeats * d\n        cumadds[r] -= repeats * d\n    cum = 0\n    for i, cumadd in zip(list(range(n)), cumadds):\n        cum += cumadd\n        array[i] += cum\n    print(*array)\n\nsolve()\n", "int_list = lambda s: [int(n) for n in s.split(\" \")]\nn,m,k = int_list(input())\narr = int_list(input())\noperations = [int_list(input()) for _ in range(m)]\n\nincrs = [0]*len(arr)      # Amount to increment running total when traversing arr\nfreq = [0]*m              # The number of times the corresponding operation is used\n                          # stored in the same format as incrs\n\nfor _ in range(k):\n  l,r = int_list(input())\n  freq[l-1] += 1\n  if r < len(freq): freq[r] -= 1\n  \ntimes = 0                   # number of times to apply current operation\nfor i, op in enumerate(operations):\n  l,r,d = op\n  times += freq[i]          # update running total\n  incrs[l-1] += times*d     # encode operation in incrs\n  if r < len(incrs): incrs[r] -= times*d\n    \nprev = 0\nfor i,n in enumerate(arr):\n  arr[i] = prev + n + incrs[i]\n  prev += incrs[i]\n  \nprint(\" \".join([str(n) for n in arr]))", "from itertools import accumulate\n\nn, m, k = list(map(int, input().split()))\na = list(map(int, input().split()))\noper = [tuple(map(int, input().split())) for i in range(m)]\nzapr = [tuple(map(int, input().split())) for i in range(k)]\n\ncount_ = [0 for i in range(m + 1)]\n\nfor el in zapr:\n    x, y = el\n\n    count_[x - 1] += 1\n    count_[y] -= 1\n\ncounter_ = list(accumulate(count_))[:-1]\n\na.append(0)\na_count = [a[0]]\n\nfor i, el in enumerate(a[1:]):\n    a_count.append(el - a[i])\n\nfor i, el in enumerate(oper):\n    l, r, d = el\n    d *= counter_[i]\n\n    a_count[l - 1] += d\n    a_count[r] -= d\n\na = list(accumulate(a_count))[:-1]\n\nprint(' '.join(map(str, a)))\n", "def process_query(queries,m):\n    n = len(queries)\n    a = [0]*(m+1)\n    for q in queries:\n        a[q[0]-1] += 1; a[q[1]] -= 1\n    for i in range(1,m):\n        a[i] += a[i-1]\n    return a[:-1]\n\ndef apply_query(times,updates,n):\n    a = [0]*(n+1)\n    # print(len(a),len(times),len(updates))\n    for i in range(len(updates)):\n        a[updates[i][0]-1] += times[i]*updates[i][2]\n        a[updates[i][1]] -= times[i]*updates[i][2]\n    for i in range(1,n):\n        a[i] += a[i-1]\n    return a[:-1]\n\n\ndef main():\n    n, m, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    updates = [list(map(int, input().split())) for i in range(m)]\n    queries = [list(map(int, input().split())) for i in range(k)]\n    times_query = process_query(queries,m)\n    # print(\"times_query\",*times_query);\n    updated_a = apply_query(times_query,updates,n)\n\n    print(*[a[i] + updated_a[i] for i in range(n)])\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin, stdout\nn,m,k = map(int,stdin.readline().split())\na = [0]\na = a + list(map(int,stdin.readline().split()))\nop=[0]\nmn = [0]*(m+2)\nkp = [0]*(n+2)\n\nfor i in range(m):\n    op.append(list(map(int,stdin.readline().split())))\nfor i in range(k):\n    x,y = map(int,stdin.readline().split())\n    mn[x]+=1\n    mn[y+1]-=1\nfor i in range(1,m+1):\n    mn[i]+=mn[i-1]\n    op[i][2]*=mn[i]\n    kp[op[i][0]]+=op[i][2]\n    kp[op[i][1]+1]-=op[i][2]\nfor i in range(1,n+1):\n    kp[i]+=kp[i-1]\nfor i in range(1,n+1):\n    print(str(a[i]+kp[i]),end=\" \")\n    ", "def __starting_point():\n\n    n, m, k = list(map(int, input().split()))\n\n    nums = list(map(int, input().split()))\n\n    operations = [tuple(map(int, input().split()))  for _ in range(m)]\n    op_counter = [0] * (m+1)\n    # queries\n    for _ in range(k):\n        x, y = list(map(int, input().split()))\n        op_counter[x-1] += 1\n        op_counter[y] -= 1\n\n    acc = 0\n    offset = [0]*(n+1)\n    for i in range(m):\n        l, r, d = operations[i]\n        acc += op_counter[i]\n        offset[l-1] += acc * d\n        offset[r] -= acc * d\n\n    acc = 0\n    for i in range(n):\n        acc += offset[i]\n        nums[i] += acc\n    print(' '.join(map(str, nums)))\n\n\n__starting_point()"]
["# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         def dfs(node, cur_num):\n             if node is None: return 0\n             my_num = cur_num * 10 + node.val\n             if node.left is None and node.right is None: return my_num\n             return dfs(node.left, my_num) + dfs(node.right, my_num)\n         \n         return dfs(root,0)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if root is None:\n             return 0\n         ret = 0\n         que = [root]\n         while len(que) != 0:\n             node = que.pop(0)\n             if node.left is None and node.right is None:\n                 ret += node.val\n             if node.left:\n                 node.left.val = node.val*10 + node.left.val\n                 que.append(node.left)\n             if node.right:\n                 node.right.val = node.val*10 + node.right.val\n                 que.append(node.right)\n         return ret\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n def get(root):\n     if root is None:\n         return []\n     s = str(root.val)\n     if root.left or root.right:\n         return [s + c for c in get(root.left)] + [s + c for c in get(root.right)]\n     return [s]\n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         return sum(int(c or \"0\") for c in get(root))", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         # using dfs\n         #   when leafnode (add the dfs number to the final sum)\n         return self.dfs(root, 0)\n         \n     def dfs(self, node, num):\n         if not node:\n             return 0\n         newNum = num * 10 + node.val\n         if not node.right and not node.left:\n             return newNum\n         return self.dfs(node.right, newNum) + self.dfs(node.left, newNum)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n def dfs(root,path,sarr):\n     \n     if root is not None:\n         rvalue = path*10+root.val\n         if root.left is None and root.right is None:\n             sarr+=[rvalue]\n         else:\n             dfs(root.left,rvalue,sarr)\n             dfs(root.right,rvalue,sarr)\n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         sarr=[0]\n         dfs(root,0,sarr)\n         return sum(sarr)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         def traverse(node, nums):\n             if node is None:\n                 return 0\n             \n             nums += [node.val]\n             print(nums)\n             \n             if not node.left and not node.right:\n                 return int(''.join([str(num) for num in nums]))\n             \n             return sum([\n                 traverse(node.left, nums.copy()),\n                 traverse(node.right, nums.copy()),\n             ])\n             \n         return traverse(root, [])", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         res = []\n         def dfs(root, path):\n             if not root:\n                 return\n             if not root.left and not root.right:\n                 res.append(path*10+root.val)\n                 return\n             if root.left:\n                 dfs(root.left, path*10 + root.val)\n             if root.right:\n                 dfs(root.right, path*10 + root.val)\n         dfs(root, 0)\n         return sum(res)\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         if root is None:\n             return 0\n         res = []\n         self.dfs(root, root.val, res)\n         print(res)\n         return sum(res)\n     \n     def dfs(self, root, cur, res):\n         if root.left is None and root.right is None:\n             res.append(cur)\n         if root.left is not None:\n             self.dfs(root.left, cur*10+root.left.val, res)\n         if root.right is not None:\n             self.dfs(root.right, cur*10+root.right.val, res)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         def traverse(node, nums):\n             if node is None:\n                 return 0\n             \n             next_nums = []\n             next_nums.extend(nums)\n             next_nums.extend([node.val])\n             \n             if not node.left and not node.right:\n                 return int(''.join([str(num) for num in next_nums]))\n             \n             return sum([\n                 traverse(node.left, next_nums),\n                 traverse(node.right, next_nums),\n             ])\n             \n         return traverse(root, [])", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n from copy import deepcopy\n \n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         self.treeSum = 0\n         self.tree(root, [])\n         return self.treeSum\n     def tree(self, node, path):\n         if not node:\n             return \n         \n \n         path.append(str(node.val))\n         \n         self.tree(node.left, copy.deepcopy(path))\n         self.tree(node.right, copy.deepcopy(path))\n         \n         if not node.left and not node.right:\n             self.treeSum += int(''.join(path))\n     \n '''\n class Solution:\n     def sumNumbers(self, root):\n         self.res = 0\n         self.dfs(root, 0)\n         return self.res\n     \n     def dfs(self, root, value):\n         if root:\n             self.dfs(root.left, value*10+root.val)\n             self.dfs(root.right, value*10+root.val)\n             \n             if not root.left and not root.right:\n                 self.res += value*10 + root.val\n '''", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n from copy import deepcopy\n \n \n class Solution:\n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         self.treeSum = 0\n         self.tree(root, [])\n         return self.treeSum\n     def tree(self, node, path):\n         if not node:\n             return \n         \n \n         path.append(str(node.val))\n         \n         self.tree(node.left, copy.deepcopy(path))\n         self.tree(node.right, copy.deepcopy(path))\n         \n         if not node.left and not node.right:\n             self.treeSum += int(''.join(path))\n     \n '''\n \n class Solution:\n     def sumNumbers(self, root):\n         self.res = 0\n         self.dfs(root, 0)\n         return self.res\n     \n     def dfs(self, root, value):\n         if root:\n             #if not root.left and not root.right:\n             #    self.res += value*10 + root.val\n             self.dfs(root.left, value*10+root.val)\n             #if not root.left and not root.right:\n             #    self.res += value*10 + root.val\n             self.dfs(root.right, value*10+root.val)\n             if not root.left and not root.right:\n                 self.res += value*10 + root.val\n '''", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n from copy import deepcopy\n \n class Solution:\n     def __init__(self):\n         self.treeSum = 0\n         \n     def sumNumbers(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: int\n         \"\"\"\n         self.tree(root, [])\n         return self.treeSum\n     def tree(self, node, path):\n         if not node:\n             return False\n         \n         path.append(str(node.val))\n         \n         print(path, node.val)\n         l = self.tree(node.left, copy.deepcopy(path))\n         r = self.tree(node.right, copy.deepcopy(path))\n         \n         if not l and not r:\n             self.treeSum += int(''.join(path))\n         \n         return True"]
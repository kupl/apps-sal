["# cook your dish here\nimport bisect\nfor _ in range(int(input())):\n N,Q=list(map(int,input().strip().split(' ')))\n V=list(map(int,input().strip().split(' ')))\n VV=sorted(V)\n for ___ in range(Q):\n  x,y=list(map(int,input().strip().split(' ')))\n  x-=1\n  y-=1\n  ans1=abs(V[x]-V[y])+(y-x)\n  post1=bisect.bisect_left(VV,min(V[x],V[y]))\n  post2=bisect.bisect_right(VV,max(V[x],V[y]))\n  ans2=post2-post1\n  print(ans1,ans2)\n", "T=int(input())\nfor i in range(0,T):\n N,Q=map(int,input().split())\n s=[int(x) for x in input().split()]\n L=sorted(s)\n G=L[::-1]\n for j in range(0,Q):\n  x,y=map(int,input().split())\n  ans1=abs(s[y-1]-s[x-1])+y-x\n  print(ans1,end=\" \")\n\n  pos1=0\n  pos2=N\n\n  for k in range(0,len(L)):\n   if(L[k]<min(s[x-1],s[y-1])):\n    pos1=k\n   elif(L[k]==min(s[x-1],s[y-1])):\n    pos1=k\n    break\n   else:\n    break\n\n  for k in range(0,len(L)):\n   if(G[k]>max(s[x-1],s[y-1])):\n    pos2=N-k-1\n   elif(G[k]==max(s[x-1],s[y-1])):\n    pos2=N-k-1\n    break\n   else:\n    break\n\n  print(pos2-pos1+1)\n  \n", "for _ in range(int(input())):\n n,q = [int(a) for a in input().split()]\n v = list(map(int, input().split()))\n s = list(range(1, n+1))\n index_s = [x for _,x in sorted(zip(v,s))]\n sorted_v = sorted(v)\n #print(index_s)\n #print(sorted_v)\n for i in range(q):\n  x,y = [int(a) for a in input().split()]\n  check1 = min(x,y)\n  get_index1 = index_s.index(check1)\n  vx = sorted_v[get_index1]\n\n\n  check2 = max(x,y)\n  get_index2 = index_s.index(max(x,y))\n  vy = sorted_v[get_index2]\n\n  length = get_index2-get_index1 + 1\n  ans = vy-vx+y-x\n  print(ans, length)\n\n\n\n\n", "import bisect\n\nfor _ in range(int(input())):\n n, q = list(map(int, input().split()))\n ar = list(map(int, input().split()))\n\n new = ar.copy()\n new.sort()\n\n for __ in range(q):\n  x, y = list(map(int, input().split()))\n  cost = abs(ar[y - 1] - ar[x - 1]) + y - x\n\n  length = bisect.bisect_right(new, max(ar[y - 1], ar[x - 1]))\n  length -= bisect.bisect_left(new, min(ar[x - 1], ar[y - 1]))\n\n  print(cost, length)\n", "t = int(input())\nfor i in range(t):\n n, q = input().split()\n cities = [int(x) for x in input().split()]\n cities_sort = cities.copy()\n cities_sort.sort()\n for j in range(int(q)):\n  q1, q2 = [int(x) for x in input().split()]\n  a = cities[q1 - 1]\n  b = cities[q2 - 1]\n  if (a > b):\n   c = a\n   a = b\n   b = c\n  pos_a = cities_sort[::1].index(a)\n  pos_b = len(cities_sort) - 1 - cities_sort[::-1].index(b)\n  print(q2 - q1 + b - a, pos_b - pos_a + 1)", "t = int(input())\nfor i in range(t):\n n, q = list(map(int,input().split()))\n cities = list(map(int,input().split()))\n for j in range(int(q)):\n  q1, q2 = list(map(int,input().split()))\n  a = cities[q1 - 1]\n  b = cities[q2 - 1]\n  if (a > b):\n   c = a \n   a = b\n   b = c\n  size = 0\n  for c in cities:\n   if c >= a and c <= b:\n    size += 1\n  print(q2 - q1 + b - a, size)", "t=int(input())\nfor _ in range(t):\n n,q=list(map(int,input().split()))\n v=list(map(int,input().split()))\n vv=v[:]\n vv=[[j,i] for j,i in enumerate(v)]\n vv.sort(key=lambda x:x[1])\n vvv=[]\n for jj,i in enumerate(vv):\n  v[i[0]]=[jj,i[1]]\n #print(v)\n for i in range(q):\n  x,y=list(map(int,input().split()))\n  x-=1\n  y-=1\n  xx=v[x][0]\n  yy=v[y][0]\n  # print(vv[xx:yy+1])\n  # print('a',xx,yy)\n  if xx<yy:\n   le=yy-xx+1\n   cost=v[y][1]-v[x][1]\n   cost+=(y-x)\n   # cost-=1\n  elif xx==yy:\n   le=1\n   cost=0\n  else:\n   le=xx-yy+1\n   cost=v[x][1]-v[y][1]\n   cost-=(x-y)\n   # cost+=1\n   \n  print(cost,le)\n"]
["#!/usr/bin/env python3\n\nfrom collections import defaultdict\n\nDEBUG = False\n\n\ndef main():\n    if DEBUG:\n        test()\n\n    n = int(input())\n\n    paths = cycles(n)\n\n    print(len(paths))\n    for p in paths:\n        print('%d %s' % (len(p), ' '.join([str(v) for v in p])))\n\n\ndef cycles(n):\n    \"\"\"Builds a set of cycles for a fully connected graph with n vertices.\"\"\"\n    if n % 2 == 0:\n        return even(n)\n    else:\n        return odd(n)\n\n\ndef even(n):\n    \"\"\"Builds a set of cycles that a graph with even vertices.\"\"\"\n    assert n % 2 == 0\n\n    # Base case for complete graph such that V = {1, 2, 3, 4}.\n    cycles = [[1, 2, 3], [2, 3, 4], [3, 4, 1], [4, 1, 2]]\n\n    for i in range(6, n + 1, 2):\n        a, b = i, i - 1\n\n        # Use edges (a, 1), (a, 0), (b, 1), (b, 0), (a, b) exactly twice each.\n        cycles += [[a, 1, b], [a, 2, b], [a, 1, b, 2]]\n\n        # Similar to odd(...) as we are left with 2n - 2 edges to use\n        # connected to i - 4 of the vertices V' = {3 ... i - 2}. Notice that\n        # |V'| is even so we can apply the same strategy as in odd(...).\n        for k in range(3, i - 1, 2):\n            c, d = k, k + 1\n            cycles += [[a, c, b, d]] * 2\n\n    return cycles\n\n\ndef odd(n):\n    \"\"\"Builds a set of cycles that a graph with odd vertices.\"\"\"\n    assert n % 2 == 1\n\n    # Base case for complete graph such that V = {1, 2, 3}.\n    cycles = [[1, 2, 3]] * 2\n\n    for i in range(5, n + 1, 2):\n        a, b = i, i - 1\n        # Say the new vertices are {a, b}. Since the graph is fully connected\n        # adding these 2 vertices results in 2n + 1 more edges. We use a length\n        # 3 cycle a -> b -> 1 > a twice to use up 3 of these edges.\n        cycles += [[a, b, 1]] * 2\n\n        # At this point we are left with 2n + 1 - 3 = 2n - 2 edges to use\n        # connected to i - 3 of the vertices V' = {2 ... i - 2}. Notice that\n        # |V'| is even. To use these edges and cover vertices V' we take pairs\n        # c, d in V' and create two of each path a -> c -> b -> d -> a.\n        for k in range(2, i - 1, 2):\n            c, d = k, k + 1\n            cycles += [[a, c, b, d]] * 2\n\n    return cycles\n\n\ndef test():\n    \"\"\"Checks the cycles(...) solver for a bunch of inputs.\"\"\"\n    print('Testing...')\n\n    for n in range(3, 300, 21):\n        check(n, cycles(n))\n\n    print('Tests pass!')\n\n\ndef check(n, paths):\n    \"\"\"Checks the solution for errors.\"\"\"\n    # Check that all vertices are covered.\n    vertices = set(sum(paths, list()))\n    assert vertices == set(range(1, n + 1))\n\n    # Check that each edge is used exactly twice.\n    counts = defaultdict(int)\n\n    for p in paths:\n        assert len(p) == 3 or len(p) == 4\n        assert len(set(p)) == len(p)\n\n        for i in range(len(p)):\n            key = tuple(sorted([p[i - 1], p[i]]))\n            counts[key] += 1\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            assert counts[(i, j)] == 2\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
["class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        res = [i ^ (i >> 1) for i in range(1 << n)]\n        \n        idx = res.index(start)\n        return res[idx:] + res[:idx]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        return [start^i^(i>>1) for i in range(1<<n)]\n", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        res,s = [],None\n        for i in range(1<<n):\n            tmp = i^(i>>1)\n            res.append(i^(i>>1))\n            if tmp == start:\n                s = i\n        res += res\n        return res[s:s+len(res)//2]", "\nfrom collections import defaultdict, deque\n\n\ndef gen_perm(n):\n    if n == 1:\n        return [0, 1]\n    else:\n        gen_prev = gen_perm(n - 1)\n        right = [2 ** (n - 1) + num for num in gen_prev]\n        return gen_prev + list(reversed(right))\n    \n        \nclass Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        perm = gen_perm(n)\n        i = 0\n        while perm[i] != start:\n            i += 1\n        return perm[i:] + perm[:i]", "class Solution:\n    def helper(self, n):\n        return n ^ (n >> 1)\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        solution = list()\n        for i in range(0, 2 ** n):\n            solution.append(self.helper(i))\n        index = -1\n        for i in range(0, len(solution)):\n            if solution[i] == start:\n                index = i\n                break\n        # print(solution)\n        return solution[index:] + solution[:index]\n", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        gray=[]\n        for i in range(2**n):\n            gray.append(i^(i>>1))\n            if start==i^(i>>1):\n                index=i\n        return gray[index:]+gray[0:index]\n", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        gray = []\n        for i in range(2**n):\n            gray.append(i ^ (i >> 1))\n        idxStart = gray.index(start)\n        # print(gray)\n        result = []\n        for i in range(len(gray)):\n            result.append(gray[(i+idxStart)%len(gray)])\n        return result\n                    \n", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        N = 1 << n\n        grey = [ i ^ (i >> 1) for i in range(N)]\n        idx = grey.index(start)\n        return grey[idx:] + grey[:idx]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        gc, bit = [0, 1], 1\n        while bit < n:\n            bit += 1\n\n            next_vals = []\n            for val in reversed(gc):\n                next_vals.append( val + 2**(bit-1) )\n            gc.extend(next_vals)\n\n        ind = gc.index(start)\n        return gc[ind:] + gc[:ind]", "class Solution:\n    def helper(self, n):\n      if n == 1:\n        return ['0', '1']\n      else:\n        res = self.helper(n-1)\n        return ['0' + x for x in res] + ['1' + x for x in res[::-1]]\n      \n    def circularPermutation(self, n: int, start: int) -> List[int]:\n      res = [(int)(n,2) for n in self.helper(n)]\n      return res[res.index(start):] + res[:res.index(start)]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        a = ['0', '1']\n        \n        for i in range(n-1):\n            a0 = ['0'+b for b in a]\n            a1 = ['1'+b for b in a]\n            a = a0 + a1[::-1]\n            \n        intperm = [int(b, 2) for b in a]\n        idx = intperm.index(start)\n        \n        return intperm[idx:]+intperm[:idx]\n", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        bi = str(bin(start))[2:].zfill(n)\n        def get_perm(bi_start, l):\n            a = bi_start[-1*l]\n            b = str(1 - int(a))\n            if l == 1: return [a, b]\n            perms = get_perm(bi_start, l-1)\n            return [a+e for e in perms] + [b+e for e in perms[::-1]]\n        return list(map(lambda x: int(x, 2), get_perm(bi, len(bi))))", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        res=[0]*(1<<n)\n        for i in range(1<<n):\n            res[i]=start^i^i>>1\n        return res", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        def generateGray(n):\n            if (n <= 0):\n                return\n\n            arr = list()\n\n            arr.append(\\\"0\\\")\n            arr.append(\\\"1\\\")\n\n            i = 2\n            j = 0\n            while(True):\n\n                if i >= 1 << n:\n                    break\n\n                for j in range(i - 1, -1, -1):\n                    arr.append(arr[j])\n\n                for j in range(i):\n                    arr[j] = \\\"0\\\" + arr[j]\n\n                for j in range(i, 2 * i):\n                    arr[j] = \\\"1\\\" + arr[j]\n                i = i << 1\n\n            return arr\n        \n        def rotateArr(arr, i):\n            return arr[-i:] + arr[:-i]\n        \n        arr = generateGray(n)\n        start = \\\"{0:b}\\\".format(start)\n        res = ''\n        if len(start) != n:\n            d = n - len(start)\n            for i in range(d):\n                res += '0'\n            start = res + start\n        arr = rotateArr(arr, len(arr) - arr.index(start))\n        return list(map(lambda x: int(x, 2), arr))", "class Solution:\n    def helper(self, n):\n      if n == 1:\n        return ['0', '1']\n      else:\n        res = self.helper(n-1)\n        return ['0' + x for x in res] + ['1' + x for x in res[::-1]]\n      \n    def circularPermutation(self, n: int, start: int) -> List[int]:\n      #res = [(int)(n,2) for n in self.helper(n)]\n      #return res[res.index(start):] + res[:res.index(start)]\n      gray_code = ['0', '1']\n      n -= 1\n      while n > 0:\n        gray_code = ['0' + x for x in gray_code] + ['1' + x for x in gray_code[::-1]]\n        n -= 1\n      gray_code = [(int)(x,2) for x in gray_code]\n      return gray_code[gray_code.index(start):] + gray_code[:gray_code.index(start)]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        def extendPerm(arr):\n            arr.extend(['1'+num for num in arr[::-1]])\n            for i in range(len(arr) // 2):\n                arr[i] = '0' + arr[i]\n        arr = ['0', '1']\n        for i in range(n-1):\n            extendPerm(arr)\n        nums = [int(num, 2) for num in arr]\n        index = nums.index(start)\n        return nums[index:] + nums[:index]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        currentList = [\\\"0\\\", \\\"1\\\"]\n        \n        from copy import deepcopy\n        \n        for idx in range(n-1):\n            length_prev = len(currentList)\n            for idx in range(length_prev-1, -1, -1):\n                currentList.append(\\\"1\\\"+currentList[idx])\n            \n            for idx in range(length_prev):\n                currentList[idx] = \\\"0\\\"+currentList[idx]\n                \n        for idx in range(len(currentList)):\n            currentList[idx] = int(currentList[idx], 2)\n         \n        idx = currentList.index(start)\n        currentList = currentList[idx:] + currentList[:idx]\n        return currentList\n            \n            ", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        # generate the Gray code for `n` bits\n        gray_code = [1, 0]\n        for i in range(1, n):\n            next_gray_code = []\n            increase = 1 << i\n            for num in gray_code:\n                next_gray_code.append(num + increase)\n            for num in reversed(gray_code):\n                next_gray_code.append(num)\n            gray_code = next_gray_code\n        # then rotate the list backwards until `start` is at the beginning\n        idx = gray_code.index(start)\n        return gray_code[idx:] + gray_code[:idx]", "class Solution:\n    def circularPermutation(self, n, start):\n        start = bin(start)[2:]\n        \n        while len(start) != n:\n            start = '0' + start\n         \n        nums = [start]\n        for i in range(n):\n            tmp = []\n            for j in nums[::-1]:\n                if j[i] == '1':\n                    tmp.append(j[:i] + '0' + j[i+1:])\n                else:\n                    tmp.append(j[:i] + '1' + j[i+1:])\n            nums += tmp\n        return [int(i, 2) for i in nums]", "class Solution:\n    def circularPermutation(self, n, start):\n        def g(x):\n            return x^(x>>1)    \n        \n        return [start ^ g(i) for i in range(1 << n)]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        res = []\n        \n        for i in range(2**n):\n            res.append((i>>1)^i)\n        \n        idx = res.index(start)\n        return res[idx:]+res[:idx]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        used = {start}\n        two = [2**i for i in range(n)]\n        res = [start]\n\n        while len(res) < 2**n :\n            i = 0\n            a = res[-1]^two[i]\n            while a in used:\n                i+= 1\n                a = res[-1]^two[i]\n\n            used.add(a)\n            res.append(a)\n        return res", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        return [ start^i^(i>>1) for i in range(1<<n) ]\n", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        return [start ^ i ^ i >> 1 for i in range(1 << n)]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        return self.generateGrayArrWithCondition(n, start)\n    \n    def generateGrayArrWithCondition(self, n, start):\n        arr = []\n\n        arr.append(\\\"0\\\") \n        arr.append(\\\"1\\\") \n\n        i = 2\n        j = 0\n        while(True): \n            if i >= 1 << n: \n                break\n\n            for j in range(i - 1, -1, -1): \n                arr.append(arr[j]) \n\n            for j in range(i): \n                arr[j] = \\\"0\\\" + arr[j] \n\n            for j in range(i, 2 * i): \n                arr[j] = \\\"1\\\" + arr[j] \n            i = i << 1\n\n        for index, element in enumerate(arr):\n            arr[index] = int(element, 2)\n            if arr[index] == start:\n                break_at = index\n            \n        return arr[break_at:] + arr[:break_at]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        return self.solve(start, n)\n    def solve(self, num, length):\n        if length==1:\n            if num==1:\n                return [1, 0]\n            return [0, 1]\n        firstnum=1\n        if num<2**(length-1):\n            firstnum=0\n        res=self.solve(num-firstnum*2**(length-1), length-1)\n        ans=[]\n        for i in res:\n            ans.append(firstnum*2**(length-1)+i)\n        res.reverse()\n        for i in res:\n            ans.append((1-firstnum)*2**(length-1)+i)\n        return ans", "class Solution:\\r\n    def circularPermutation(self, n: int, start: int) -> List[int]:\\r\n        result = list(range(1 << n))\\r\n\\r\n        def reverse(lst, i, j):\\r\n            while i < j:\\r\n                lst[i], lst[j] = lst[j], lst[i]\\r\n                i, j = i + 1, j - 1\\r\n\\r\n        for i in range(1, n):\\r\n            for j in range(1, (1 << (n - i)) + 1, 2):\\r\n                reverse(result, j << i, ((j + 1) << i) - 1)\\r\n\\r\n        start_idx = result.index(start)\\r\n        result = result[start_idx: 1 << n] + result[0: start_idx]\\r\n        return result", "from itertools import chain\n\nclass Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        start_mask = start;\n        while start_mask:\n            start_mask >>= 1;\n            start ^= start_mask;\n        out = [x ^ (x >> 1) for x in chain(range(start, 2 ** n), range(start))]\n        # print(out)\n        return out", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        # dp = [0, 1]\n        # for i in range(1, n):\n        #     dp2 = dp + [d | 1 << i for d in dp[::-1]]\n        #     dp = dp2\n        \n        # Alternatively, using Gray Code\n        dp = [i ^ i >> 1 for i in range(1 << n)]\n        idx = dp.index(start)\n        return dp[idx:] + dp[: idx]\n", "\n\n\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        if n == 0:\n            return [0]\n        prv_code = self.grayCode(n-1)\n        return prv_code + [2 ** (n-1) + x for x in reversed(prv_code)]\n    \n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        ind=self.grayCode(n).index(start)\n        \n        \n        return self.grayCode(n)[ind:]+self.grayCode(n)[:ind]\n        \n        \n", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        # dp = [0, 1]\n        # for i in range(1, n):\n        #     dp2 = dp + [d | 1 << i for d in dp[::-1]]\n        #     dp = dp2\n        # idx = dp.index(start)\n        # return dp[idx:] + dp[: idx]\n        \n        # Alternatively, using Gray Code\n        return [start ^ i ^ i >> 1 for i in range(1 << n)]\n        \n", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        answer = [start]\n        visited = set(answer)\n        \n        next = start\n        while (next != None): \n            previous = next\n            next = None\n            for i in range(n):\n                newNum = previous ^ (1 << i)\n                # print(i, newNum, previous)\n                if newNum not in visited:\n                    visited.add(newNum)\n                    answer.append(newNum)\n                    next = newNum\n                    break\n            \n        return answer", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        perms = [2 ** i for i in range(n-1, -1, -1)]\n        \n        end = start ^ 1\n        \n        visited = set()\n        path = []\n        \n        def dfs(node):\n            if node == end:\n                path.append(node)\n                return True\n            \n            if node in visited: return False\n            \n            visited.add(node)\n            \n            for perm in perms:\n                if dfs(node ^ perm):\n                    path.append(node)\n                    return True\n            return False\n        \n        dfs(start)\n        return reversed(path)", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        return [start^i^(i>>1) for i in range(2**n)]\n", "class Solution:\\r\n    def circularPermutation(self, n: int, start: int) -> List[int]:\\r\n        result = list(range(1 << n))\\r\n\\r\n        def reverse(lst, i, j):\\r\n            print(i, j)\\r\n            while i < j:\\r\n                lst[i], lst[j] = lst[j], lst[i]\\r\n                i, j = i + 1, j - 1\\r\n\\r\n        for i in range(1, n):\\r\n            for j in range(1, (1 << (n - i)) + 1, 2):\\r\n                reverse(result, j << i, ((j + 1) << i) - 1)\\r\n\\r\n        start_idx = result.index(start)\\r\n        result = result[start_idx: 1 << n] + result[0: start_idx]\\r\n        return result", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        used = set()\n        result = [None] * int(2**n)\n        result[0] = start\n        used.add(start)\n        for i in range(1, len(result)):\n            for x in range(n):\n                bit = bool(result[i-1] & (1<<x))\n                if bit:\n                    val = result[i-1] - (1<<x)\n                else:\n                    val = result[i-1] + (1<<x)\n                if val not in used:\n                    used.add(val)\n                    result[i] = val\n                    break\n        return result", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        \n        array = list(map(self.binaryToGray, range(0, 2 ** n)))\n        index = array.index(start)\n\n        return array[index: ] + array[: index]\n\n    def binaryToGray(self, n: int) -> int:\n        return n ^ (n >> 1)", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        ans = []\n        lastNumberSet = set([start^(1<<i) for i in range(n)])\n        nMax = 2**n\n        \n        visited = set()\n        visited.add(start)\n        def helper(preNum, ni):\n            if ni == nMax:\n                if preNum in lastNumberSet:\n                    return True\n                return False\n            for i in range(n):\n                nextNum = preNum^(1<<i)\n                if nextNum not in visited:\n                    visited.add(nextNum)\n                    if helper(nextNum, ni+1):\n                        ans.append(nextNum)\n                        return True\n                    visited.remove(nextNum)\n            return False\n        \n        helper(start, 1)\n        return [start] + ans[::-1]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        original_list = [None for _ in range(1 << n)]\n        original_list[0] = 0\n        original_list[1] = 1\n        for i in range(1, n):\n            num_elements = 1 << i\n            for j in range(num_elements):\n                original_list[j] <<= 1\n            for j in range(num_elements):\n                original_list[num_elements + j] = original_list[num_elements - j - 1] + 1\n        \n        result_list = [None for _ in range(1 << n)]\n        current = 0\n        while original_list[current] != start:\n            current += 1\n            \n        for i in range(1 << n):\n            result_list[i] = original_list[(current + i) % (1 << n)]\n        \n        return result_list\n", "class Solution:\n    def backtracking(self,result,visited,n,found):\n        if len(result) == 2 ** n:\n            diff = result[-1] ^ result[0]\n            i = 0\n            is_one_bit = 0\n            while i<n:\n                if (1 << i) == diff:\n                    is_one_bit = 1\n                    break\n                i = i + 1\n            if is_one_bit == 1:\n                found[0] = 1\n            return\n        if found[0] == 1:\n            return\n        start = result[-1]\n        for i in range(n):\n            num = start ^ (1 << i)\n            if num in visited or num<0 or num>=2 ** n:\n                continue\n            result.append(num)\n            visited[num] = 1\n            self.backtracking(result,visited,n,found)\n            if found[0] == 1:\n                return\n            visited.pop(num)\n            result.pop()\n        \n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        if n == 0:\n            return [0]\n        result = [start]\n        found = [0]\n        visited = {}\n        visited[start] = 1\n        self.backtracking(result,visited,n,found)\n        return result", "class Solution:\n    def backtracking(self,result,visited,n,found):\n        if len(result) == 2 ** n:\n            diff = abs(result[-1] - result[0])\n            while diff%2 == 0:\n                diff = diff/2\n            if diff == 1:\n                found[0] = 1\n            return\n        if found[0] == 1:\n            return\n        start = result[-1]\n        for i in range(n):\n            num = start ^ (1 << i)\n            if num in visited or num<0 or num>=2 ** n:\n                continue\n            result.append(num)\n            visited[num] = 1\n            self.backtracking(result,visited,n,found)\n            if found[0] == 1:\n                return\n            visited.pop(num)\n            result.pop()\n        \n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        if n == 0:\n            return [0]\n        result = [start]\n        found = [0]\n        visited = {}\n        visited[start] = 1\n        self.backtracking(result,visited,n,found)\n        return result", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        def dfs(i):\n            if len(p) == 1 << n:\n                a = p[0] ^ p[1]\n                return a and a & (a - 1) == 0\n            j = 1\n            for _ in range(n):\n                k = i ^ j\n                if k not in visited:\n                    visited.add(k)\n                    p.append(k)\n                    if dfs(k):\n                        return True\n                    visited.remove(k)\n                    p.pop()\n                j <<= 1\n            return False\n        \n        visited = {start}\n        p = [start]\n        dfs(start)\n        return p", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        ans = []\n        lastNumberSet = set([start^(1<<i) for i in range(n)])\n        nMax = 2**n\n        \n        visited = set()\n        visited.add(start)\n        \n        def helper(preNum, ni):\n            if ni == nMax:\n                if preNum in lastNumberSet:\n                    return True\n                return False\n            for i in range(n):\n                nextNum = preNum^(1<<i)\n                if nextNum not in visited:\n                    visited.add(nextNum)\n                    if helper(nextNum, ni+1):\n                        ans.append(nextNum)\n                        return True\n                    visited.remove(nextNum)\n            return False\n        \n        helper(start, 1)\n        return [start] + ans[::-1]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        def encode_as_gray(n):\n            return n ^ (n >> 1)\n        arr = [encode_as_gray(i) for i in range(0, 2 ** n)]\n        i = arr.index(start)\n        return arr[i:] + arr[:i]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        gc = [0]\n        for i in range(1,2**n):\n            gc.append(gc[-1] ^ (i & -i)) # -i is similar to two component https://leetcode.com/problems/gray-code/discuss/245076/4-lines-Elegant-fast-and-easy-understand-Python-solution/688127 and https://stackoverflow.com/a/12250963/8006144\n            \n        l = len(gc)\n        for i in range(l):\n            fe = gc[0]\n            if fe == start:\n                break\n            else:\n                gc.append(gc.pop(0))\n        return gc\n", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        k=1\n        ans=[0,1]\n        while k<=n-1:\n            l=len(ans)\n            for i in range(l-1,-1,-1):\n                ans.append((2**k)+ans[i])\n            k=k+1\n        while 1:\n            if ans[0]==start:\n                break\n            else:\n                ans.append(ans.pop(0))\n        return ans", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        def f(n):\n            if n == 0: return [0]\n            else:\n                return f(n-1) + [2**(n-1) + v for v in f(n-1)[::-1]]\n        res = f(n)\n        i = res.index(start)\n        return res[i:] + res[:i]\n        \n", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        res = []\n        for i in range(1<<n):\n            res.append(start^i^i>>1)\n            \n        return res", "class Solution:\n\\tdef circularPermutation(self, n: int, start: int) -> List[int]:\n\\t\\tres=[]\n\\t\\tfor i in range(2**n):\n\\t\\t\\tres.append(i^(i>>1))\n\\t\\tstack=[]\n\\t\\ttem=[]\n\\t\\tfor j in range(len(res)):\n\\t\\t\\tif res[j]!=start:\n\\t\\t\\t\\tstack.append(res[j])\n\\t\\t\\telse:\n\\t\\t\\t\\ttem=res[j:]\n\\t\\t\\t\\tbreak\n\\t\\tans=tem+stack\n\\t\\treturn ans\n", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        def encode_as_gray(n):\n            return n ^ (n >> 1)\n        arr = [encode_as_gray(i) for i in range(0, 2 ** n)]\n        i = arr.index(start)\n        return arr[i:] + arr[:i]\n\n        return array[index: ] + array[: index]", "class Solution:\n    def circularPermutation(self, n: int, start: int) -> List[int]:\n        r = [0, 1]\n        for i in range(1, n):\n            r += [2 ** i + v for v in r[::-1]]\n        idx = r.index(start)\n        return r[idx:] + r[:idx]"]
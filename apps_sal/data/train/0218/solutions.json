["class Solution:\n    def orderlyQueue(self, S: str, K: int) -> str:\n        if K >= 2:\n            return ''.join(sorted(S))\n        \n        length = len(S)\n        S = S + S\n        i, j, k = 0, 1, 0\n        while j + k < len(S) and k < length:\n            if S[i + k] == S[j + k]:\n                k += 1\n                continue\n            elif S[i + k] < S[j + k]:\n                j = j + k + 1\n            else:\n                i = max(i + k + 1, j)\n                j = i + 1\n            k = 0\n        return S[i : i + length]\n", "class Solution:\n    def orderlyQueue(self, S: str, K: int) -> str:\n        if K==1:\n            tmp = S\n            for i in range(len(S)):\n                S = S[1:] + str(S[0])\n                if S<tmp:\n                    tmp = S\n            return tmp\n        else:\n            return ''.join(sorted(S))", "class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n        s = [c for c in s]\n        if k == 1:\n            temp = []\n            for i in range(len(s)):\n                temp_s = s[i:] + s[:i]\n                temp.append(''.join(temp_s))\n            temp.sort()\n            return temp[0]\n        else:\n            return ''.join(sorted(s)) # if k>=2 then you can basically swap adjacent elements, so you can do bubble sort as swapping of adjcaent elements is possible. so the ans will be the sorted string if k>=2.\n"]
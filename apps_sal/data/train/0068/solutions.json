["from itertools import groupby\ndef main():\n    N = int(input())\n    S = input()\n    \n    C = [len(list(x[1])) for x in groupby(S)]\n    M = len(C)\n    dup_idx = []\n    for i, c in enumerate(C):\n        if c > 1:\n            dup_idx.append(i)\n    \n    dup_idx.reverse()\n\n    curr = 0\n    while dup_idx:\n        i = dup_idx[-1]\n\n        if i < curr:\n            dup_idx.pop()\n            continue\n\n        C[i] -= 1\n        if C[i] == 1:\n            dup_idx.pop()\n\n        curr += 1\n\n    ans = curr + (M-curr+1)//2\n    \n    print(ans)\n\ndef __starting_point():\n    for __ in [0]*int(input()):\n        main()\n\n__starting_point()", "import sys\n\nT = int(sys.stdin.readline().strip())\nfor t in range (0, T):\n    n = int(sys.stdin.readline().strip())\n    s = sys.stdin.readline().strip()\n    L = [1]\n    for i in range (1, n):\n        if s[i] == s[i-1]:\n            L[-1] = L[-1] + 1\n        else:\n            L.append(1)\n    L.reverse()\n    i = n - 1\n    ans = 0\n    while len(L) > 0:\n        ans = ans + 1\n        v = True\n        i = min(i, len(L) - 1)\n        while i >= 0 and v == True:\n            if L[i] == 1:\n                i = i - 1\n                if i == -1:\n                    v = False\n            else:\n                v = False\n        if i == -1:\n            L.pop()\n        else:\n            L[i] = L[i] - 1\n        if len(L) > 0:\n            L.pop()\n    print(ans)\n", "import sys\ninput = sys.stdin.readline\n\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input().rstrip()\n    changes = 1\n    spare = 0\n    before = s[0]\n    spare_can = 1\n    for j in range(n-1):\n        if s[j+1] == before:\n            if spare_can > 0:\n                spare_can -= 1\n                spare += 1\n        else:\n            before = s[j+1]\n            changes +=1\n            spare_can +=1\n    ans = 0\n    ans += spare\n    changes-=spare\n    ans += (changes+1)//2\n    print(ans)   ", "n = int(input())\n\nfor _ in range(n):\n    k = int(input())\n    s = input()\n    s = s[0] + s + str(int(s[-1])^1)\n    \n    m = []\n\n    prev = 1\n    \n    for i in range(1, k+2):\n        if s[i] != s[i-1]:\n            m.append(i-prev)\n            prev = i\n\n    ans = 0\n    start = 0\n    end = len(m)\n    first = 0\n\n    while (start < end):\n        if m[start] > 1:\n            start += 1\n            first = max(first, start)\n            \n        else:\n            while (first < end) and (m[first] == 1):\n                first += 1\n            \n            if (first >= end):\n                end -= 1\n            else:\n                m[first] -= 1\n\n            start += 1\n\n        ans += 1\n\n    print(ans)\n", "for _ in range(int(input())):\n\tn = int(input())\n\n\ts = list(input())\n\n\tgroups = []\n\tlast = ''\n\tcnt = 0\n\tfor c in s:\n\t\tif c != last:\n\t\t\tif cnt: groups.append(cnt)\n\t\t\tcnt = 1\n\t\telse:\n\t\t\tcnt += 1\n\t\tlast = c\n\n\tif cnt: groups.append(cnt)\n\n\tm = len(groups)\n\ti = 0\n\tj = 0\n\n\tops = 0\n\twhile i < m:\n\t\tops += 1\n\n\t\twhile j < i or (j < m and groups[j] == 1): j += 1\n\n\t\tif j < m: groups[j] -= 1\n\t\telse: i += 1\n\t\ti += 1\n\n\tprint(ops)\n\n\n", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    S = input()\n    arr = []\n    seq = 1\n    for a,b in zip(S,S[1:]):\n        if a==b:\n            seq += 1\n        else:\n            arr.append(seq)\n            seq = 1\n    arr.append(seq)\n    hist = []\n    arr.reverse()\n    for i,a in enumerate(arr):\n        if a==1: continue\n        hist.append([i,a])\n    ans = 0\n    while len(arr):\n        if len(hist):\n            hist[-1][1] -= 1\n            if hist[-1][1] == 1:\n                hist.pop()\n        elif len(arr):\n            arr.pop()\n        else:\n            break\n        ans += 1\n        if len(arr):\n            arr.pop()\n        if len(hist) and hist[-1][0] == len(arr):\n            hist.pop()\n    print(ans)\n", "gans = []\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, list(input())))\n    u = []\n    k = 1\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            k += 1\n        else:\n            u.append(k)\n            k = 1\n    u.append(k)\n    dop = 0\n    ln = len(u)\n    for i in range(ln):\n        dop += u[i] - 1\n    cur = 0\n    ind = 0\n    while ind < ln:\n        if dop == 0:\n            ln -= 1\n        else:\n            cur += 1\n            dop -= 1\n        cnt = u[ind] - 1\n        if cur < cnt:\n            dop -= cnt - cur\n            cur = 0\n        else:\n            cur -= cnt\n        ind += 1\n    gans.append(ind)\nprint('\\n'.join(map(str, gans)))\n    \n", "import sys\ninput = sys.stdin.readline\n\nt=int(input())\n\nfor tests in range(t):\n    n=int(input())\n    S=input().strip()\n\n    L=[1]\n\n    for i in range(1,n):\n        if S[i]==S[i-1]:\n            L[-1]+=1\n        else:\n            L.append(1)\n        \n    de=0\n    i=0\n    ANS=0\n    LEN=len(L)\n    flag=0\n    \n    while de<LEN:\n\n        if flag==0:            \n            i=max(i,de)\n            while i<LEN:\n                if L[i]>1:\n                    break\n                else:\n                    i+=1\n\n            if i==LEN:\n                flag=1\n            else:\n                L[i]-=1\n\n        if flag==0:\n            de+=1\n            ANS+=1\n        else:\n            de+=2\n            ANS+=1\n    print(ANS)\n\n        \n        \n        \n", "import sys, math\nimport io, os\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n#from itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var) : sys.stdout.write('\\n'.join(map(str, var))+'\\n')\ndef out(var) : sys.stdout.write(str(var)+'\\n')\n#from decimal import Decimal\n#from fractions import Fraction\n#sys.setrecursionlimit(100000)\nINF = float('inf')\nmod=10**9+7\n\n\nfor t in range(int(data())):\n    n=int(data())\n    s=data()\n    ind=0\n    l=[]\n    for i in range(1,n):\n        if s[i]!=s[i-1]:\n            l.append(i-ind)\n            ind=i\n    l.append(n-ind)\n    l=l[::-1]\n    i=0\n    ans=0\n    j=len(l)-1\n    while l:\n        if l[-1]>1:\n            ans+=1\n            l.pop()\n            j-=1\n        else:\n            j=min(j,len(l)-1)\n            while j>=0 and l[j]==1:\n                j-=1\n            if j==-1:\n                l.pop()\n                if l:\n                    l.pop()\n            else:\n                l.pop()\n                l[j]-=1\n            ans+=1\n    out(ans)", "for _ in range (int(input())):\n    n=int(input())\n    s=input()\n    a=[]\n    curr=1\n    g=0\n    for i in range (1,n):\n        if s[i]==s[i-1]:\n            curr+=1\n        else:\n            a.append(curr)\n            if curr>1:\n                g+=1\n            curr=1\n    if curr>0:\n        if curr>1:\n            g+=1\n        a.append(curr)\n    #print(a)\n    j=0\n    i=0\n    res=0\n    while i<len(a):\n        if a[i]>1:\n            res+=1\n            i+=1\n        else:\n            j=max(i+1,j)\n            ch=0\n            while j<len(a):\n                if a[j]>1:\n                    a[j]-=1\n                    ch=1\n                    break\n                j+=1\n            if ch==1:\n                i+=1\n                res+=1\n            else:\n                i+=2\n                res+=1\n    print(res)", "def main():\n    n = int(input())\n    line = input()\n    turn_take = []\n    prev = line[-1]\n    can_be = 0\n    for i in range(n - 2, -1, -1):\n        if line[i] == prev:\n            can_be += 1\n        else:\n            prev = line[i]\n            turn_take.append(can_be)\n    turn_take.append(can_be)\n    turns = len(turn_take)\n    taken = 0\n    res = 0\n    for i in range(1, turns + 1):\n        if i > 1 and turn_take[-i] < turn_take[-i + 1]:\n            taken = min(0, taken + turn_take[-i + 1] - turn_take[-i])\n        if turn_take[-i] > -taken:\n            taken -= 1\n            res += 1\n        else:\n            res += (turns - i + 1)//2\n            if (turns - i + 1)%2 != 0:\n                res += 1\n            break\n    print(res)\n\n\ndef __starting_point():\n    t = int(input())\n    for i in range(t):\n        main()\n\"\"\"\n1 2 3 4 5\n1 2 4 4\n1 2 4\n1 3\n2\n1 2 3 4 5 6\n1 2 3 5 5\n1 2 3 5\n1 2 4\n1 3\n2\n1 2 3 4 5 6 7 ( max, max - 2)\n1 2 3 4 6 6 (max - 1, max - 1)\n1 2 3 4 6 (max - 1, max - 3)\n1 2 3 5 (max - 2 max - 4)\n1 2 4\n1 3\n2\n1 2 3 4 5 6 7 8 (6, 8)\n1 2 3 4 5 7 7 (7, 7)\n1 2 3 4 5 7 (5, 7)\n1 2 3 4 6 (4, 6)\n1 2 3 5 (3, 5)\n1 2 4 (2, 4)\n1 3 (1, 3)\n2\n\"\"\"\n__starting_point()", "t = int(input())\n\nfor case in range(t):\n    n = int(input())\n    s = input()\n    #print(\"Input read in OK\", n, s)\n\n    groups = [s[0]]\n    for x in s[1:]:\n        if x == groups[-1][-1]:\n            groups[-1] += x\n        else:\n            groups.append(x)\n\n    groups = [len(x) for x in groups]\n    to_use = 0\n    #print(\"groups are\", groups)\n\n    ops = 0\n    for i, x in enumerate(groups):\n        while to_use < len(groups):\n            if to_use < i:\n                to_use += 1\n                continue\n            if groups[to_use] <= 1:\n                to_use += 1\n                continue\n            break\n        else:\n            break\n\n        #print(\"using\", to_use)\n        groups[to_use] -= 1\n        groups[i] = 0\n        ops += 1\n    else:\n        print(ops)\n        continue\n\n    # We now have a situation where the grid is of the form 10101010.\n    # What do we do? Well,\n    # 1010 (even length = n/2)\n    # 10101 (odd length = (n + 1)/2)\n    # so (n+1)/2 it is\n    #print(\"ops before was\", ops)\n    size = len(groups) - i\n    #print(\"size is\", size)\n    ops += (size + 1) // 2\n    print(ops)\n        \n        \n", "import io\nimport os\nimport sys\nimport math\nimport heapq\n\ninput = sys.stdin.readline\nmod = 10**9 + 7\n \nt = int(input())\n\nfor i in range(t):\n    #n,k = list(map(int, input().split()))\n    n = int(input())\n    s = list(input().rstrip())\n    \n    arr = []\n    \n    st = s[0]\n    c = 0\n    for i in range(len(s)):\n        if s[i]!=st:\n            arr.append(c)\n            st = s[i]\n            c = 0\n            \n        c+=1\n            \n    if c>0:\n        arr.append(c)\n        \n    limit = 0\n    steps = 0\n    \n    #print(arr)\n    \n    for i in range(len(arr)):\n        limit += 1\n        if arr[i] > 1:\n            red = arr[i] - 1\n            #print(limit)\n            gh = min(red, limit)\n            arr[i] -= gh\n            limit -=gh\n            steps += gh\n          \n    #print(arr, len(arr), steps)\n    ans = math.ceil((len(arr) + steps) / 2)\n    #\n    print(ans)\n    \n"]
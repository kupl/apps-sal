["class Solution:\n     def nearestPalindromic(self, num):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         K = len(num)\n         candidates = set([10**K + 1, 10**(K-1) - 1])\n         Prefix = int(num[:(K+1)//2])\n \n         for start in map(str, [Prefix-1, Prefix, Prefix+1]):\n             candidates.add(start + [start, start[:-1]][K & 1][::-1])\n \n         candidates.discard(num)\n \n         return str(min(candidates, key=lambda x: (abs(int(x) - int(num)), int(x))))\n", "class Solution:\n     def nearestPalindromic(self, n):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         K = len(n)\n         candidates = [str(10**k + d) for k in (K-1, K) for d in (-1, 1)]\n \n         Prefix = int(n[:(K+1)//2])\n \n         for start in map(str, [Prefix - 1, Prefix, Prefix + 1]):\n             candidates.append(str(start) + (start[:-1] if K % 2 == 1 else start)[::-1])\n \n         ans, diff = 0, float('inf')\n         base = int(n)\n \n         for C in candidates:\n             b = int(C)\n             d = abs(b - base)\n \n             if d == 0 or d > diff or (d == diff and b > ans):\n                 continue\n \n             ans = int(C)\n             diff = d\n \n         return str(ans)\n", "class Solution:\n     def nearestPalindromic(self, n):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         K = len(n)\n         candidates = [str(10**k + d) for k in (K-1, K) for d in (-1, 1)]\n         prefix = n[:(K+1)//2]\n         P = int(prefix)\n         for start in map(str, (P-1, P, P+1)):\n             candidates.append(start + (start[:-1] if K%2 else start)[::-1])\n \n         def delta(x):\n             return abs(int(n) - int(x))\n \n         ans = None\n         for cand in candidates:\n             if cand != n and not cand.startswith('00'):\n                 if (ans is None or delta(cand) < delta(ans) or\n                         delta(cand) == delta(ans) and int(cand) < int(ans)):\n                     ans = cand\n         return ans\n", "class Solution:\n     def nearestPalindromic(self, n):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         evenPal = lambda sp : int(sp + sp[::-1])\n         oddPal = lambda sp : int(sp + sp[::-1][1:])\n         sn, n = n, int(n)\n         if len(sn) == 1: return str(n - 1)\n         ans = -999999999999999999\n         mid = len(sn) // 2\n         for sp in sn[:mid], sn[:mid + 1], str(int(sn[:mid]) * 10):\n             p = int(sp)\n             for pal in evenPal, oddPal:\n                 for d in -1, 0, 1:\n                     val = pal(str(p + d))\n                     if val == n: continue\n                     ans = min(ans, val, key = lambda x : (abs(x - n), x))\n         return str(ans)\n", "class Solution:\n     def getPalindromic(self,num,mid=''):\n         return str(num)+mid+str(num)[::-1]\n     def nearestPalindromic(self,n):\n         \"\"\"\n         :type n: str\n         :rtype: str\n         \"\"\"\n         if len(n)==1:\n             return str(int(n)-1)\n         midstr='' if len(n)%2==0 else n[len(n)//2]\n         midint=-1 if len(n)%2==0 else int(n[len(n)//2])\n         s=['']*6\n         # 99..99\n         s[0]='9'*(len(n)-1)\n         # (l-1)m(l-1)\n         s[1]=self.getPalindromic(int(n[:(len(n))//2])-1,midstr)\n         # l(m-1)l\n         s[2]=n[:len(n)//2]+str(midint-1)+n[:len(n)//2][::-1] if midint>0 else self.getPalindromic(int(n[:len(n)//2])-1)\n         # lml\n         s[3]=n[:len(n)//2]+midstr+n[:len(n)//2][::-1]\n         # l(m+1)l\n         s[4]=n[:len(n)//2]+str(midint+1)+n[:len(n)//2][::-1] if midint<10 and midint>-1 else self.getPalindromic(int(n[:len(n)//2])+1)\n         # 10..01\n         s[5]='1'+'0'*(len(n)-1)+'1'\n         nums=map(lambda x:abs(int(x)-int(n)),s)\n         nums=list(map(lambda x:x if x>0 else 1e18,nums))\n         return s[nums.index(min(nums))]"]
["class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        w = set(fronts[i] for i in range(len(fronts)) if fronts[i] == backs[i])\n        \n        x = set()\n        for a in fronts:\n            if a not in w:\n                x.add(a)\n        for a in backs:\n            if a not in w:\n                x.add(a)\n                \n        if not x:\n            return 0\n        return min(x)", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        same = {x for x, y in zip(fronts, backs) if x == y}\n        return min([i for i in fronts + backs if i not in same] or [0])", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        cands = set()\n        blacklist = set()\n        for f, b in zip(fronts, backs):\n            if f == b:\n                blacklist.add(f)\n                cands.discard(f)\n            else:\n                if f not in blacklist:\n                    cands.add(f)\n                if b not in blacklist:\n                    cands.add(b)\n        return 0 if not cands else min(cands)", "class Solution:\n    \n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        doubles = set()\n        for f, b in zip(fronts, backs):\n            if f == b:\n                doubles.add(f)\n        \n        min_x = None\n        for f, b in zip(fronts, backs):\n            if f not in doubles:\n                if min_x:\n                    min_x = min(min_x, f)\n                else:\n                    min_x = f\n                    \n            if b not in doubles:\n                if min_x:\n                    min_x = min(min_x, b)\n                else:\n                    min_x = b\n        \n        if not min_x:\n            return 0\n        return min_x\n                    \n                    \n                    \n                    \n", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        cands = [0]*2001\n        blacklist = [0]*2001\n        for f, b in zip(fronts, backs):\n            if f == b:\n                blacklist[f] = 1\n                cands[b] = 0\n            else:\n                if not blacklist[f]:\n                    cands[f] = 1\n                if not blacklist[b]:\n                    cands[b] = 1\n                    \n        for idx in range(1, 2001):\n            if cands[idx]:\n                return idx\n        return 0", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        res_map = {}\n        for idx in range(len(fronts)) :\n            if fronts[idx] == backs[idx] :\n                res_map.setdefault(fronts[idx], False)\n                res_map[fronts[idx]] = False\n            else :\n                res_map.setdefault(fronts[idx], True)\n                res_map.setdefault(backs[idx], True)\n        for num in sorted(res_map.keys()) :\n            if res_map[num] : return num\n        return 0", "class Solution(object):\n    def flipgame(self, fronts, backs):\n        same = {x for i, x in enumerate(fronts) if x == backs[i]}\n        ans = float('inf')\n        for x in itertools.chain(fronts, backs):\n            if x not in same:\n                ans = min(ans, x)\n\n        return ans if ans != float('inf') else 0", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        n = len(fronts)\n        dupes = {fronts[i] for i in range(n) if fronts[i] == backs[i]}\n        res = float('inf')\n        for num in itertools.chain(fronts, backs):\n            if num not in dupes:\n                res = min(res, num)\n        return res if res < float('inf') else 0", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        offlimits = set()\n        for f, b in zip(fronts, backs):\n            if f == b:\n                offlimits.add(f)\n        ans = math.inf\n        for f, b in zip(fronts, backs):\n            if f != b:\n                if f not in offlimits:\n                    ans = min(ans, f)\n                if b not in offlimits:\n                    ans = min(ans, b)\n                \n        return 0 if ans == math.inf else ans", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        not_allowed = set()\n        for f, b in zip(fronts, backs):\n            if f==b:\n                not_allowed.add(f)\n        res = math.inf\n        for f, b in zip(fronts, backs):\n            if f not in not_allowed:\n                res = min(res, f)\n            if b not in not_allowed:\n                res = min(res, b)\n        if math.isfinite(res):\n            return res\n        else:\n            return 0\n", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        front = dict()\n        back = dict()\n        for i in range(len(fronts)):\n            if fronts[i] in front:\n                front[fronts[i]].add(i)\n            else:\n                front[fronts[i]] = {i}\n            if backs[i] in back:\n                back[backs[i]].add(i)\n            else:\n                back[backs[i]] = {i}\n        ans = float('inf')\n        aux = set()\n        for elem in front:\n            if elem not in aux:\n                if elem not in back:\n                    ans = min(ans, elem)\n                else:\n                    flag = 1\n                    for index in back[elem]:\n                        if fronts[index] == elem:\n                            flag = 0\n                    if flag:    ans = min(ans, elem)\n                aux.add(elem)\n        for elem in back:\n            if elem not in aux:\n                if elem not in front:\n                    ans = min(ans, elem)\n                else:\n                    flag = 1\n                    for index in front[elem]:\n                        if backs[index] == elem:\n                            flag = 0\n                    if flag:    ans = min(ans, elem)\n                aux.add(elem)\n        return ans if ans != float('inf') else 0", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        n = len(fronts)\n        dupes = set(fronts[i] for i in range(n) if fronts[i] == backs[i])\n        res = float('inf')\n        for i in range(n):\n            if fronts[i] not in dupes:\n                res = min(res, fronts[i])\n            if backs[i] not in dupes:\n                res = min(res, backs[i])\n        return res if res < float('inf') else 0", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        \n        minimum = 10000\n        sames = []\n        for front, back in zip(fronts,backs):\n            \n            if front == back:\n                sames.append(front)\n                \n                \n        for front,back in zip(fronts,backs):\n            if front not in sames:\n                minimum = min(front, minimum)\n                \n            if back not in sames:\n                minimum = min(back, minimum)\n                \n        \n        if minimum == 10000:\n            return 0\n        else:\n            return minimum", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        same = [x for x, y in zip(fronts, backs) if(x==y)]\n        \n        return min([i for i in fronts+backs if(i not in same)] or [0])", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        bad=[]\n        for i in range(len(fronts)):\n            if fronts[i]==backs[i]:\n                bad.append(fronts[i])\n\n        ans=10000000000\n        for i in range(len(fronts)):\n            if fronts[i] not in bad:\n                ans=min(ans,fronts[i])\n            if backs[i] not in bad:\n                ans=min(ans, backs[i])\n        if ans>0 and ans!=10000000000:\n            return ans\n        return 0\n", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        s = set(fronts).union(set(backs))\n        \n        for c in sorted(s):\n            for i in range(len(fronts)):\n                if fronts[i] == c and backs[i] == c:\n                    break\n            else:\n                return c\n        return 0", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        exclusions = {x for x, y in zip(fronts, backs) if x == y}\n        ans = float('inf')\n        for x, y in zip(fronts, backs):\n            if not (x in exclusions and y in exclusions):\n                if x not in exclusions:\n                    ans = min(ans, x)\n                if y not in exclusions:\n                    ans = min(ans, y)\n        return ans if ans != float('inf') else 0", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        \n        a = set()\n        for i in range(len(fronts)):\n            if fronts[i] == backs[i]:\n                a.add(fronts[i])\n                \n                \n        l = []\n        \n        for i in range(len(fronts)):\n            if fronts[i] not in a:\n                # continue\n                l.append(fronts[i])\n            \n            if backs[i] not in a: \n                l.append(backs[i])\n\n        l.sort()\n        \n        if len(l) == 0:\n            return 0\n        \n        return l[0]", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        N = len(fronts)\n        impossible = set([fronts[i] for i in range(N) if fronts[i]==backs[i]])\n        res = float('inf')\n        for i in range(len(fronts)):\n            if fronts[i]!=backs[i]:\n                for num in [fronts[i], backs[i]]:\n                    if num not in impossible:\n                        res = min(res, num)\n        return res if res!=float('inf') else 0", "from collections import defaultdict\n\nclass Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        if len(fronts) == 1:\n            if fronts[0] == backs[0]:\n                return 0\n            else:\n                return fronts[0]\n        f, b = defaultdict(set), defaultdict(set)\n        for i in range(len(fronts)):\n            f[fronts[i]].add(backs[i])\n            b[backs[i]].add(fronts[i])\n            \n        ans = float('inf')\n        for i in range(len(fronts)):\n            if fronts[i] not in f[fronts[i]]:\n                ans = min(ans, fronts[i])\n            if backs[i] not in b[backs[i]]:\n                ans = min(ans, backs[i])\n        \n        if ans == float('inf'):\n            return 0\n        return ans\n", "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        seen=set()\n        double=set()\n        for i in range(len(fronts)):\n            seen.add(fronts[i])\n            seen.add(backs[i])\n            if fronts[i]==backs[i]:\n                double.add(fronts[i])\n        for k in sorted(list(seen)):\n            if not k in double:\n                return k\n        return 0\n"]
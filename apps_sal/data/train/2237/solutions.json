["import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nclass Binary_Indexed_Tree():\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+1)\n\n    def add(self, i, x):\n        while i <= self.n:\n            self.data[i] += x\n            i += i & -i\n\n    def get(self, i):\n        return self.sum_range(i, i)\n\n    def sum(self, i):\n        ret = 0\n        while i:\n            ret += self.data[i]\n            i &= i-1\n        return ret\n\n    def sum_range(self, l, r):\n        return self.sum(r)-self.sum(l-1)\n\n    def lower_bound(self, w):\n        if w<=0:\n            return 0\n        i = 0\n        k = 1<<(self.n.bit_length())\n        while k:\n            if i+k <= self.n and self.data[i+k] < w:\n                w -= self.data[i+k]\n                i += k\n            k >>= 1\n        return i+1\n\nn = int(input())\na = list(map(int, input().split()))\nd = {j:i for i,j in enumerate(a)}\nBIT1 = Binary_Indexed_Tree(n)\nBIT2 = Binary_Indexed_Tree(n)\nBIT3 = Binary_Indexed_Tree(n)\n\ntentou = 0\nans = []\nfor i in range(n):\n    tmp = 0\n    p = d[i+1]\n    inv_p = n-p\n    tentou += BIT1.sum(inv_p)\n    BIT1.add(inv_p, 1)\n\n    BIT2.add(p+1, 1)\n    BIT3.add(p+1, p+1)\n    m = i//2+1\n    mean = BIT2.lower_bound(i//2+1)\n    tmp = 0\n    if i%2 == 0:\n        tmp -= m*(m-1)\n    else:\n        tmp -= m*m\n    tmp += tentou\n    left = BIT3.sum_range(1, mean)\n    right = BIT3.sum_range(mean, n)\n    if i%2 == 0:\n        left = mean*m - left\n        right = right - mean*m\n    else:\n        left = mean*m - left\n        right = right - mean*(m+1)\n    tmp += left + right\n    ans.append(tmp)\nprint(*ans)\n\n", "import heapq\n\n\nclass DynamicMedian():\n    def __init__(self):\n        self.l_q = []  \n        self.r_q = []\n        self.l_sum = 0\n        self.r_sum = 0\n        \n    def add(self, val):\n        if len(self.l_q) == len(self.r_q):\n            self.l_sum += val\n            val = -heapq.heappushpop(self.l_q, -val)\n            self.l_sum -= val\n            heapq.heappush(self.r_q, val)\n            self.r_sum += val\n        else:\n            self.r_sum += val\n            val = heapq.heappushpop(self.r_q, val)\n            self.r_sum -= val\n            heapq.heappush(self.l_q, -val)\n            self.l_sum += val\n            \n    def median_low(self):\n        if len(self.l_q) + 1 == len(self.r_q):\n            return self.r_q[0]\n        else:\n            return -self.l_q[0]\n \n    def median_high(self):\n        return self.r_q[0]\n \n    def minimum_query(self):\n        res1 = (len(self.l_q) * self.median_high() - self.l_sum)\n        res2 = (self.r_sum - len(self.r_q) * self.median_high())\n        return res1 + res2\n\n#Binary Indexed Tree (Fenwick Tree)\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n \n    def add(self, i, val):\n        i = i + 1\n        while i <= self.n:\n            self.bit[i] += val\n            i += i & -i\n \n    def _sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n \n    def sum(self, i, j):\n        return self._sum(j) - self._sum(i)\n \n \nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\nbit = BIT(n)\ndm = DynamicMedian()\n  \nmemo = {}\nfor i in range(n):\n    memo[a[i] - 1] = i\n\nb = [0] * n\nfor i in range(n):\n    dm.add(memo[i])\n    b[i] = dm.minimum_query() - (i+1)**2 // 4\n\nans = [0] * n\ntmp = 0\nfor i in range(len(a)):\n    bit.add(memo[i], 1)\n    tmp += bit.sum(memo[i] + 1, n)\n    ans[i] = tmp + b[i]\nprint(*ans)\n    \n"]
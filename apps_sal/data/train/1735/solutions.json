["from heapq import *\n\nMOVES = tuple( (dx,dy) for dx in range(-1,2) for dy in range(-1,2) if dx or dy)\n\n\ndef shallowest_path(river):\n\n    lX,lY   = len(river), len(river[0])\n    pathDct = {}\n    cost    = [ [(float('inf'),float('inf'))]*lY for _ in range(lX) ]\n    for x in range(lX): cost[x][0] = (river[x][0],1)\n    \n    q = [ (river[x][0], lY==1, 1, (x,0)) for x in range(lX)]\n    heapify(q)\n    \n    while not q[0][1]:\n        c,_,steps,pos = heappop(q)\n        x,y = pos\n        for dx,dy in MOVES:\n            a,b = new = x+dx,y+dy\n            if 0<=a<lX and 0<=b<lY: \n                check = nC,nS = max(c, river[a][b]), steps+1\n                if cost[a][b] > check:\n                    cost[a][b] = check\n                    pathDct[new] = pos\n                    heappush(q, (nC, b==lY-1, nS, new))\n    \n    path, pos = [], q[0][-1]\n    while pos:\n        path.append(pos)\n        pos = pathDct.get(pos)\n    return path[::-1]", "from heapq import *\nfrom collections import defaultdict\n\nMOVES = ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1))\n\ndef shallowest_path(river):\n    q = [(river[x][0], 0, (x,0)) for x in range(len(river))]\n    path = {}\n    stored_steps = defaultdict(lambda : float('inf'))\n    heapify(q)\n\n    while q:\n        cost, step, (x,y) = heappop(q)\n        if (x,y) == (x,len(river[0])-1):\n            end = (x,y)\n            break\n\n        for dx,dy in MOVES:\n            xx = dx + x\n            yy = dy + y\n\n            if 0<=xx<len(river) and 0<=yy<len(river[0]):\n                new_step = step + 1\n\n                if new_step < stored_steps[(xx,yy)]:\n                    stored_steps[(xx,yy)] = new_step\n                    new_cost = max(cost, river[xx][yy])\n\n                    path[(xx,yy)] = (x,y)\n                    heappush(q, (new_cost, new_step, (xx,yy)))\n        \n    \n    coords = [end]\n\n    while coords[-1][1] != 0:\n        coords.append(path[end])\n        end = path[end]\n\n    return coords[::-1]", "def shallowest_path(river):    \n    depth = {(r, c):d for r, row in enumerate(river) for c, d in enumerate(row)}    \n    width = max(c for _, c in depth)\n\n    for mx in sorted(set(depth.values())):\n        D = {d for d in depth if depth[d] <= mx}\n        paths, D = [[d] for d in D if d[1] == 0], {d for d in D if d[1]}\n        \n        while paths:\n            newp = []        \n            for p in paths:\n                if p[-1][1] == width: return p\n                for d in {(p[-1][0]+rr, p[-1][1]+cc) for rr in [-1, 0, 1] for cc in [-1, 0, 1]} & D:\n                    newp, _ = newp + [p + [d]], D.discard(d)\n            paths = newp", "def shallowest_path(river):\n    mx,my,crit=len(river[0]),len(river),lambda e:e[0]+len(e[1])\n    M=[[(r[0]*mx*my,[(i,0)])]+[(99999*mx*my,[])]*(mx-1) for i,r in enumerate(river)]\n    Q=set(((j,1),(i,0)) for i in range(my) for j in [i-1,i,i+1] if 0<=j<my and mx>1)\n    while(Q):\n      Q,R=set(),Q\n      for (u,v),(i,j) in R:\n          if crit(M[u][v])>max(M[i][j][0],river[u][v]*mx*my)+len(M[i][j][1])+1:\n              M[u][v]=(max(M[i][j][0],river[u][v]*mx*my),M[i][j][1]+[(u,v)])\n              Q.update(((a,b),(u,v)) for a in [u-1,u,u+1] for b in [v,v-1,v+1][a==u:] if 0<b<mx and 0<=a<my)\n    return(min(M,key=lambda e:crit(e[-1]))[-1][1])", "from collections import namedtuple\nimport heapq\n\ndef shallowest_path(river):\n    rows = len(river)\n    if rows == 0:\n        return []\n    cols = len(river[0])\n    if cols == 0:\n        return []\n\n    Solution = namedtuple('Solution', ['depth', 'path'])\n    State = namedtuple('State', ['depth', 'path_length', 'path'])\n\n    best_solution = None\n    left_bank_q = [(river[row][0], row, 0) for row in range(rows)]\n    heapq.heapify(left_bank_q)\n\n    while left_bank_q:\n        visited = set()\n        initial_depth, row, col = heapq.heappop(left_bank_q)\n        walk_q = [State(depth=initial_depth, path_length=1, path=[(row, col)])]\n        while walk_q:\n            depth, path_length, path = heapq.heappop(walk_q)\n            current_row, current_col = path[-1]\n            if (current_row, current_col) in visited or (current_col == 0 and path_length > 1):\n                continue\n            if current_col == cols - 1: # We reached the right bank\n                if depth == 1 and len(path) == cols:\n                    return path # Optimal path\n                if best_solution is None or depth < best_solution.depth or (depth == best_solution.depth and len(path) < len(best_solution.path)):\n                    best_solution = Solution(depth, path)\n                continue\n            visited.add((current_row, current_col))\n            best_depth = float('inf') if best_solution is None else best_solution.depth\n            for row, col in neighbours(river, current_row, current_col):\n                if (row, col) not in visited and river[row][col] <= best_depth:\n                    heapq.heappush(walk_q, State(depth=max(depth, river[row][col]), path_length=path_length+1, path=path+[(row, col)]))\n\n    return best_solution.path\n\ndef neighbours(river, row, col):\n    rows = len(river)\n    cols = len(river[0])\n\n    return ((row + drow, col + dcol)\n            for drow in [-1, 0, 1]\n            for dcol in [-1, 0, 1]\n            if drow != 0 or dcol != 0\n            if 0 <= row+drow < rows\n            if 0 <= col+dcol < cols)\n", "from itertools   import product\nfrom collections import defaultdict\nfrom heapq       import *\n\ndef dijkstra(edges, f, t):\n    g = defaultdict(list)\n    for l,r,c in edges:\n        g[l].append((c,r))\n\n    q, seen, mins = [(0,f,())], set(), {f: 0}\n    while q:\n        (cost,v1,path) = heappop(q)\n        if v1 not in seen:\n            seen.add(v1)\n            path = (v1, path)\n            if v1 == t: return (cost, path)\n\n            for c, v2 in g.get(v1, ()):\n                if v2 in seen: continue\n                prev = mins.get(v2, None)\n                next = cost + c\n                if prev is None or next < prev:\n                    mins[v2] = next\n                    heappush(q, (next, v2, path))\n\n    return float(\"inf\"),()\n\ndef shallowest_path(river):\n    d={(y,x):v for y,line in enumerate(river) for x,v in enumerate(line)}\n    width=len(river[0])\n    height=len(river)\n    depthmin=max([min(d[y,x] for y in range(height)) for x in range(width)])\n    depths=sorted(set([v for v in list(d.values()) if v>=depthmin]))\n    start=(0,-1)\n    end  =(0,width)\n    for depth in depths:\n        edges =[(start,(y,0),0)      for y in range(height) if d[y,0]      <=depth]\n        edges+=[((y,width-1), end,0) for y in range(height) if d[y,width-1]<=depth]\n        for k in product(list(range(height)),list(range(width))):\n            if not k in d or d[k]>depth:continue\n            y,x=k\n            for k1 in [(y-1,x-1),(y-1,x),(y-1,x+1),(y,x-1),(y,x+1),(y+1,x-1),(y+1,x),(y+1,x+1)]:\n                if not k1 in d or d[k1]>depth:continue\n                edges.append((k,k1,1))\n        dist,res0=dijkstra(edges, start, end)\n        if dist==float(\"inf\"): continue\n        res=[]\n        while res0:\n            p,res0=res0\n            res.insert(0,p)      \n        return res[1:-1]\n    return []\n", "from heapq import *\nfrom collections import defaultdict\n\nMOVES = ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1))\n\ndef shallowest_path(river):\n    q = [(river[x][0], 0, (x,0)) for x in range(len(river))]\n    path = {}\n    stored_steps = defaultdict(lambda : float('inf'))\n    heapify(q)\n\n    while q:\n        cost, step, (x,y) = heappop(q)\n        if (x,y) == (x,len(river[0])-1):\n            end = (x,y)\n            break\n\n        for dx,dy in MOVES:\n            xx = dx + x\n            yy = dy + y\n\n            if 0<=xx<len(river) and 0<=yy<len(river[0]):\n                new_step = step + (abs(dx)+abs(dy))**.5\n\n                if new_step < stored_steps[(xx,yy)]:\n                    stored_steps[(xx,yy)] = new_step\n                    new_cost = max(cost, river[xx][yy])\n\n                    path[(xx,yy)] = (x,y)\n                    heappush(q, (new_cost, new_step, (xx,yy)))\n        \n    \n    coords = [end]\n\n    while coords[-1][1] != 0:\n        coords.append(path[end])\n        end = path[end]\n\n    return coords[::-1]", "from heapq import heappush, heappop\n\n\ndef shallowest_path(river):\n    ls_o_res, hippo, dc = {}, [], {(i, 0): {} for i in range(len(river))}\n    if len(river[0]) > 1:\n        for i in range(len(river)):\n            dc[(i, 0)][(i, 0)] = ((river[i][0], len([river[i][0]])),\n                                  (i, 0), [(i, 0)], [river[i][0]])\n            heappush(\n                hippo, (((river[i][0], len([river[i][0]])), (i, 0), [(i, 0)], [river[i][0]])))\n    else:\n        for i in range(len(river)):\n            ls_o_res[river[i][0]] = [(i, 0)]\n        return ls_o_res[min(ls_o_res.keys())]\n    yb, xb = len(river), len(river[0])\n    mito = (float(\"inf\"), float(\"inf\"))\n    while hippo:\n        vara = heappop(hippo)\n        moves, parent = [(1, 0), (-1, 0), (0, 1),\n                         (1, 1), (-1, 1), (-1, -1), (1, -1), (0, -1)], vara[1]\n        for y, x in moves:\n            i, j = parent\n            i, j = i+y, j+x\n            if 0 <= i < yb and 0 <= j < xb:\n                path = vara[2] + [(i, j)]\n                pathowar = vara[3]+[river[i][j]]\n                dist = (max(pathowar), len(pathowar))\n                if (i, j) not in dc[(i, 0)]:\n                    dc[(i, 0)][(i, j)] = (dist, (i, j), path, pathowar)\n                    heappush(hippo, (dist, (i, j), path, pathowar))\n                elif (i, j) in dc[(i, 0)] and dist < dc[(i, 0)][(i,j)][0]:\n                    dc[(i, 0)][(i, j)] = (dist, (i, j), path, pathowar)\n                    heappush(hippo, (dist, (i, j), path, pathowar))\n                if j == xb-1:\n                    print(dist)\n                    if dist < mito:\n                        mito = dist\n                        ls_o_res[mito] = path\n    return ls_o_res[min(ls_o_res.keys())]\n\n", "import math\ndef shallowest_path(river):\n    maxsize = 999999999\n    steps = [\n        (-1,-1),(-1, 0),(-1, 1),\n        ( 0,-1),        ( 0, 1),\n        ( 1,-1),( 1, 0),( 1, 1)\n    ]\n    h, w = len(river), len(river[0])\n    res = [[]] * h\n    for r in range(h):\n        res[r] = [(maxsize, [(r,0)])] * w                        \n    \n    points = []\n    for r in range(h):\n        res[r][0] = (river[r][0], [(r,0)])\n        points.append((r, 0))\n    \n    while len(points) > 0:\n        p = points.pop(0)\n        r, c = p[0], p[1]\n        deep = res[r][c][0]\n        path = res[r][c][1]\n        length = len(path)\n        if c < w - 1: \n            for s in steps:\n                nr = r + s[0]\n                nc = c + s[1]                \n                if nr >= 0 and nr < h and nc >= 0 and nc < w and (nr,nc) not in path:\n                    tdeep = res[nr][nc][0]\n                    tpath = res[nr][nc][1]\n                    tlength = len(tpath)\n                    ndeep = max(deep, river[nr][nc])\n                    if tdeep > ndeep or (tdeep == ndeep and tlength > length + 1):\n                        npath = path.copy()\n                        npath.append((nr, nc))\n                        res[nr][nc] = (ndeep, npath)\n                        if (nr, nc) not in points:\n                            points.append((nr, nc))\n                        \n    min_deep, min_path = maxsize, []\n    for r in range(h):\n        p = res[r][-1]\n        if p[0] < min_deep:\n            min_deep,  min_path = p[0], p[1]\n        elif p[0] == min_deep and len(p[1]) < len(min_path):\n            min_deep, min_path = p[0], p[1]\n    return min_path", "import heapq\n\ndef get_path(river):\n    big_num = 10992312321\n    nodes = []\n    b = {}\n    for y in range(len(river)):\n        heapq.heappush(nodes, [river[y][0] * big_num, (y, 0)])\n    while nodes[0][1][1] != len(river[0])-1:\n        weight, node = heappop(nodes)\n        ly, lx = node\n        for dy, dx in [(0,1), (1,1), (1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1)]:\n            if 0 <= ly+dy < len(river) and 0 <= lx+dx < len(river[0]) and (ly+dy, lx+dx) not in b:\n                b[(ly+dy, lx+dx)] = (ly, lx)\n                new_weight = max([weight // big_num, river[ly+dy][lx+dx]]) * big_num + weight % big_num + 1\n                heapq.heappush(nodes, [new_weight, (ly+dy, lx+dx)])\n    path = [nodes[0][1]]\n    while path[-1][1] != 0:\n        path.append(b[path[-1]])\n    return nodes[0][0] // big_num, path\n\ndef shallowest_path(river):\n    cost, path = get_path(river)\n    for y in range(len(river)):\n        for x in range(len(river[0])):\n            if river[y][x] < cost:\n                river[y][x] = 0\n    cost, path = get_path(river)\n    return path[::-1]"]
["import heapq\n\nfor _ in range(int(input())):\n    n = int(input())\n    voters = []\n    for i in range(n):\n        m,p = list(map(int, input().split()))\n        voters.append((m, -p))\n    voters.sort()\n    for i in range(n):\n        voters[i] = (voters[i][0], -voters[i][1])\n\n    ans = 0\n    costs = []\n    heapq.heapify(costs)\n    bought = 0\n    for i in range(n-1, -1, -1):\n        buysNeeded = voters[i][0] - i  - bought\n        heapq.heappush(costs, voters[i][1])\n        while buysNeeded > 0 and len(costs) > 0:\n            ans += heapq.heappop(costs)\n            bought += 1\n            buysNeeded -= 1\n\n    print(ans)\n", "'''\nCreated on 2019. 9. 21.\n\n@author: kkhh88\n'''\n#q = int(input())\n#x, y = map(int,input().split(' '))\n\nq = int(input())\nfor _ in range(q):    \n    n = int(input())\n    lr = []\n    for i in range(n):\n        lr.append(list(map(int,input().split(' '))))\n    \n    lr.sort(key=lambda x:x[1], reverse = True)\n    lr.sort(key=lambda x:x[0])\n    \n    cnt = [0]*n\n    for i in range(n):\n        if lr[i][0] > i:\n            if lr[i][0] - i > cnt[lr[i][0]]:\n                cnt[lr[i][0]] = lr[i][0] - i    \n    \n    i = n - 1\n    tmp = 0\n    ans = 0\n    lst = []\n    while i >= 0:\n        if i > 0 and lr[i][0] == lr[i-1][0]:\n            lst.append(lr[i][1])\n            i = i - 1\n        else:\n            lst.append(lr[i][1])\n            if cnt[lr[i][0]] > tmp:\n                lst.sort()\n                for _ in range(tmp, cnt[lr[i][0]]):\n                    ans = ans + lst.pop(0)\n                tmp = cnt[lr[i][0]]\n            i = i - 1\n    #print (cnt, lr)\n    print (ans)", "import sys\ndef I():\n    return sys.stdin.readline().rstrip()\n\nclass Heap:\n    def __init__( self ):\n        self.l = [ -1 ]\n        self.n = 0\n    def n( self ):\n        return self.n\n    def top( self ):\n        return self.l[ 1 ]\n    def ins( self, x ):\n        self.l.append( x )\n        n = len( self.l ) - 1\n        i = n\n        while i > 1:\n            j = i // 2\n            if self.l[ j ] > self.l[ i ]:\n                self.l[ j ], self.l[ i ] = self.l[ i ], self.l[ j ]\n                i = j\n            else:\n                break\n    def pop( self ):\n        r = self.l[ 1 ]\n        l = self.l.pop()\n        n = len( self.l ) - 1\n        if n:\n            self.l[ 1 ] = l\n            i = 1\n            while True:\n                j = i * 2\n                k = j + 1\n                if k < len( self.l ) and self.l[ i ] > max( self.l[ j ], self.l[ k ] ):\n                    if self.l[ j ] == min( self.l[ j ], self.l[ k ] ):\n                        self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\n                        i = j\n                    else:\n                        self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\n                        i = k\n                elif k < len( self.l ) and self.l[ i ] > self.l[ k ]:\n                    self.l[ i ], self.l[ k ] = self.l[ k ], self.l[ i ]\n                    i = k\n                elif j < len( self.l ) and self.l[ i ] > self.l[ j ]:\n                    self.l[ i ], self.l[ j ] = self.l[ j ], self.l[ i ]\n                    i = j\n                else:\n                    break\n        return r\n\nt = int( I() )\nfor _ in range( t ):\n    n = int( I() )\n    voter = [ list( map( int, I().split() ) ) for _ in range( n ) ]\n    h = Heap()\n    d = {}\n    for m, p in voter:\n        if m not in d:\n            d[ m ] = []\n        d[ m ].append( p )\n    need = {}\n    c = 0\n    sk = sorted( d.keys() )\n    for m in sk:\n        need[ m ] = max( 0, m - c )\n        c += len( d[ m ] )\n    c = 0\n    ans = 0\n    for m in sk[::-1]:\n        for p in d[ m ]:\n            h.ins( p )\n        while c < need[ m ]:\n            c += 1\n            ans += h.pop()\n    print( ans )\n", "import heapq\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    info = [list(map(int, input().split())) for i in range(n)]\n    info = sorted(info)\n    cnt = [0] * n\n    for i in range(n):\n        ind = info[i][0]\n        cnt[ind] += 1\n    ruiseki_cnt = [0] * (n+1)\n    for i in range(n):\n        ruiseki_cnt[i+1] = ruiseki_cnt[i] + cnt[i]\n    # print(cnt)\n    # print(ruiseki_cnt)\n    need = [0] * n\n    for i in range(1,n):\n        if cnt[i] != 0 and i > ruiseki_cnt[i]:\n            need[i] = min(i - ruiseki_cnt[i], i)\n    # print(need)\n    info = sorted(info, reverse = True)\n    #print(info)\n\n    num = n - 1\n    pos = 0\n    q = []\n    used_cnt = 0\n    ans = 0\n    while True:\n        if num == -1:\n            break\n        while True:\n            if pos < n and info[pos][0] >= num:\n                heapq.heappush(q, info[pos][1])\n                pos += 1\n            else:\n                break\n        if need[num] - used_cnt > 0:\n            tmp = need[num] - used_cnt\n            for _ in range(tmp):\n                ans += heapq.heappop(q)\n            used_cnt += tmp\n        num -= 1\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\nimport heapq\nfrom itertools import accumulate\n\nt=int(input())\n\nfor test in range(t):\n    n=int(input())\n    M=[[] for i in range(n)]\n    MCOUNT=[0]*(n)\n\n    for i in range(n):\n        m,p=list(map(int,input().split()))\n        M[m].append(p)\n        MCOUNT[m]+=1\n\n    #print(M)\n    #print(MCOUNT)\n\n    ACC=list(accumulate(MCOUNT))\n\n    #print(ACC)\n    HQ=[]\n    ANS=0\n    use=0\n\n    for i in range(n-1,-1,-1):\n        for j in M[i]:\n            heapq.heappush(HQ,j)\n\n        #print(HQ)\n            \n        while ACC[i-1]+use<i:\n            x=heapq.heappop(HQ)\n            ANS+=x\n            use+=1\n\n\n\n    print(ANS)\n            \n            \n        \n        \n        \n\n    \n\n    \n", "import sys\nimport heapq\n \n \ndef solve(pr, mm):\n    omm = []\n    n = len(mm)\n    for i in range(n + 1):\n        omm.append([])\n    \n    for i in range(n):\n        omm[mm[i]].append(pr[i])\n    \n    for i in range(n + 1):\n        omm[i] = sorted(omm[i])\n    \n    heap = []\n    c = 0\n    t = n\n    p = 0\n    for i in range(n, -1, -1):\n        for h in omm[i]:\n            heapq.heappush(heap, h)\n            \n        t -= len(omm[i])\n        mn = max(i - c - t, 0)\n        c += mn\n        for j in range(mn):\n            p += heapq.heappop(heap)\n        \n    return p\n    \n \ndef __starting_point():\n    t = int(input().strip())\n    for i in range(t):\n        n = int(input().strip())\n        ms = []\n        ps = []\n        for j in range(n):\n            arr = [int(v) for v in input().strip().split(' ')]\n            ms.append(arr[0])\n            ps.append(arr[1])\n            \n        print(solve(ps, ms))\n\n__starting_point()", "import heapq\n \nfor _ in range(int(input())):\n    n = int(input())\n    voters = []\n    for i in range(n):\n        m,p = list(map(int, input().split()))\n        voters.append((m, -p))\n    voters.sort()\n    for i in range(n):\n        voters[i] = (voters[i][0], -voters[i][1])\n \n    ans = 0\n    costs = []\n    heapq.heapify(costs)\n    bought = 0\n    for i in range(n-1, -1, -1):\n        buysNeeded = voters[i][0] - i  - bought\n        heapq.heappush(costs, voters[i][1])\n        while buysNeeded > 0 and len(costs) > 0:\n            ans += heapq.heappop(costs)\n            bought += 1\n            buysNeeded -= 1\n \n    print(ans)", "import sys\nfrom heapq import heappop, heappush\n\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n \nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    mp = []\n    for i in range(n):\n        mi, pi = list(map(int, input().split()))\n        mp.append((mi, pi))\n    mp.sort()\n    \n    prices = []\n    cost = 0\n    bribed = 0\n    i = n - 1\n    while i >= 0:\n        currM = mp[i][0]\n        heappush(prices, mp[i][1])\n        while i >= 1 and mp[i-1][0] == currM:\n            i -= 1\n            heappush(prices, mp[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heappop(prices)\n            bribed += 1\n        i -= 1\n    \n    print(cost)\n", "import sys\ninput = sys.stdin.readline\nimport heapq as hq\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  vt = [list(map(int,input().split())) for i in range(n)]\n  vt.sort(reverse=True)\n  q = []\n  hq.heapify(q)\n  ans = 0\n  cnt = 0\n  for i in range(n):\n    hq.heappush(q,vt[i][1])\n    if vt[i][0] >= n-i+cnt:\n      ans += hq.heappop(q)\n      cnt += 1\n  print(ans)", "import sys\nimport heapq as hq\n\nreadline = sys.stdin.readline\nread = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\ndef solve():\n    n = ni()\n    vot = [tuple(nm()) for _ in range(n)]\n    vot.sort(key = lambda x: (-x[0], x[1]))\n    q = list()\n    c = 0\n    cost = 0\n    for i in range(n):\n        hq.heappush(q, vot[i][1])\n        while n - i - 1 + c < vot[i][0]:\n            cost += hq.heappop(q)\n            c += 1\n    print(cost)\n    return\n\n\n# solve()\n\nT = ni()\nfor _ in range(T):\n    solve()\n", "import sys\nfrom heapq import *\n#sys.stdin = open('in', 'r')\nt = int(input())\nfor ti in range(t):\n    n = int(input())\n    a = []\n    for i in range(n):\n        mi, pi = list(map(int, input().split()))\n        a.append((mi, -pi))\n    a.sort()\n    c = 0\n    h = []\n    res = 0\n    for i in reversed(list(range(n))):\n        heappush(h, -a[i][1])\n        while c + i < a[i][0]:\n            res += heappop(h)\n            c += 1\n    print(res)\n\n\n#sys.stdout.write('YES\\n')\n#sys.stdout.write(f'{res}\\n')\n#sys.stdout.write(f'{y1} {x1} {y2} {x2}\\n')\n"]
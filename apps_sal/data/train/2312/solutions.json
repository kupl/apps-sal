["from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nfrom itertools import accumulate\nfrom functools import lru_cache\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\n\n\nn, q = li()\n\n\nqueue = [-1] * 20\n\nans = [[-1] * 20 for i in range(n + 1)]\nl = li()\nfor i, curr in enumerate(l):\n\n    for j in range(20):\n        if curr >> j & 1:\n            for k in range(20):        \n                ans[i][k] = max(ans[i][k], ans[queue[j]][k])\n            ans[i][j] = i\n    \n    for j in range(20):queue[j] = max(queue[j], ans[i][j])\n\n\nqueries = []\nfor i in range(q):queries.append(li())    \nfor i in range(q):\n    a, b = queries[i]\n    a -= 1\n    b -= 1\n\n    currans = 0\n\n    for j in range(20):\n        if (l[a] >> j) & 1 and ans[b][j] >= a:\n            currans = 1\n            break\n    print('Shi' if currans else 'Fou')"]
["class Solution:\n     def splitArray(self, nums, m):\n         \"\"\"\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         \"\"\"\n         accum = [0]\n         N = len(nums)\n         mmm = max(nums)\n         if m >= N:\n             return mmm\n         res = 0\n         for i in nums:\n             res += i\n             accum.append(res)\n         lower, upper = mmm , sum(nums)\n         while lower < upper:\n             mid = (lower + upper) // 2\n             if not self.isSplitable(accum, m, mid):\n                 lower = mid + 1\n             else:\n                 upper = mid\n         # print(lower, upper)\n         return upper\n     def isSplitable(self, accum, m, maxx):\n         start = 0\n         N = len(accum)\n         end = 0\n         count = 0\n         while end < N and count < m:\n             if accum[end] - accum[start] > maxx:\n                 # print('start: ', start, 'end:', end, 'sum', accum[end - 1] - accum[start])\n                 start = end - 1\n                 count += 1\n             end += 1\n             #print (count, end)\n         if accum[-1] - accum[start] > maxx: #\u6536\u5c3e\n             count += 2\n         else:\n             count += 1\n         # print('start: ', start, 'end:', end, 'sum', accum[end - 1] - accum[start])\n         # print (end, count)\n         if end != N or count > m:\n             return False\n         return True", "class Solution:\n     def splitArray(self, pages, k):\n         \"\"\"\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         \"\"\"\n         if not pages or k == 0:\n             return 0\n \n         pre = sums = [0] + pages[:]\n         for i in range(1, len(sums)):\n             sums[i] += sums[i-1]\n \n         for n in range(2, k + 1):\n             if n > len(pages):\n                 break\n \n             cur = [sys.maxsize] * len(pre)\n             i, j = n - 1, n\n             while j < len(pre):\n                 left, right = pre[i], sums[j] - sums[i]\n                 cur[j] = min(cur[j], max(left, right))\n                 if i + 1 < j and max(pre[i+1], sums[j] - sums[i+1]) < cur[j]:\n                     i += 1\n                 else:\n                     j += 1\n \n             pre = cur\n \n         return pre[-1]\n", "class Solution:\n     def splitArray(self, nums, m):\n         \"\"\"\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         \"\"\"\n         pre = sums = [0] + nums\n         for i in range(2, len(sums)):\n             sums[i] += sums[i-1]\n     \n         for k in range(2, m + 1):\n             i, j, cur = k - 1, k, [sys.maxsize] * len(pre)\n             while j < len(pre):\n                 left, right = pre[i], sums[j] - sums[i]\n                 cur[j] = min(cur[j], max(left, right))\n                 if i + 1 < j and max(pre[i+1], sums[j] - sums[i+1]) < cur[j]:\n                     i += 1\n                 else:\n                     j += 1\n             pre = cur\n \n         return pre[-1]", "class Solution(object):\n     def splitArray(self, nums, m):\n         \"\"\"\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         \"\"\"\n         def valid(mid):\n             cnt = 0\n             current = 0\n             for n in nums:\n                 current += n\n                 if current>mid:\n                     cnt += 1\n                     if cnt>=m:\n                         return False\n                     current = n\n             return True\n \n         l = max(nums)\n         h = sum(nums)\n \n         while l<h:\n             mid = l+(h-l)/2\n             if valid(mid):\n                 h = mid\n             else:\n                 l = mid+1\n         return int(l)", "class Solution:\n     def splitArray(self, nums, m):\n         \"\"\"\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         \"\"\"\n         def valid(mid):\n             cnt = 0\n             current = 0\n             for n in nums:\n                 current += n\n                 if current>mid:\n                     cnt += 1\n                     if cnt>=m:\n                         return False\n                     current = n\n             return True\n \n         l = max(nums)\n         h = sum(nums)\n \n         while l<h:\n             mid = l+(h-l)/2\n             if valid(mid):\n                 h = mid\n             else:\n                 l = mid+1\n         return int(l)", "class Solution:\n     \n     def soln_exists(self, nums, m, i):\n         index = 0\n         for x in range(m):\n             total = 0\n             while True:\n                 total += nums[index]\n                 index += 1\n                 if (total > i):\n                     break\n                 if index == len(nums):\n                     return True\n             index -= 1\n         return False\n     \n     def splitArray(self, nums, m):\n         \"\"\"\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         \"\"\"\n         work = 1\n         while not self.soln_exists(nums, m, work):\n             work *= 2\n         not_work = work / 2\n         while not_work < work - 1:\n             middle = not_work / 2 + work / 2\n             if self.soln_exists(nums, m, middle):\n                 work = middle\n             else:\n                 not_work = middle\n         return int(work)", "class Solution:\n     def splitArray(self, nums, m):\n         \"\"\"\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         \"\"\"\n         _sum = sum(nums)\n         avg = _sum / m\n         self.result = 10**10\n         n = len(nums)\n         cache = {}\n         def recur(idx, m):\n             # print(idx,m)\n             if idx == n:\n                 return 0\n             if m == 0:\n                 return 10**10\n             if (idx, m) in cache:\n                 return cache[(idx, m)]\n             _sum = 0\n             result = 10**10\n             i = idx##bugged \n             while i < n :\n                 _sum+=nums[i]\n                 if i == n - 1 or (_sum + nums[i+1] > avg):\n                     tmp = recur(i+1, m - 1)\n                     result = min(result, max(tmp, _sum))\n                     if _sum > tmp:\n                         cache[(idx, m)] = result\n                         return result\n                 i+=1\n             cache[(idx, m)] = result\n             return result\n         \n         x = recur(0,m)\n         # print(cache)\n         return x\n                 \n                 \n             \n             \n         \n         \n         \n         \n         \n         \n         \n", "class Solution:\n     def splitArray(self, nums, m):\n         \"\"\"\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         \"\"\"\n         return self.use_binary_search(nums, m)\n     \n     def use_binary_search(self, nums, m):\n         lo, hi = max(nums), sum(nums)\n         \n         while lo < hi:\n             mid = lo + (hi - lo) // 2\n             \n             if self.valid(mid, nums, m):\n                 hi = mid\n             else:\n                 lo = mid + 1\n         return lo\n     \n     def valid(self, target, nums, m):\n         total, count = 0, 1\n         for num in nums:\n             total += num\n             if total > target:\n                 total = num\n                 count += 1\n                 if count > m:\n                     return False\n         return True\n", "class Solution:\n     \n     def soln_exists(self, nums, m, i):\n         index = 0\n         for x in range(m):\n             total = 0\n             while True:\n                 total += nums[index]\n                 index += 1\n                 if (total > i):\n                     break\n                 if index == len(nums):\n                     return True\n             index -= 1\n         return False\n     \n     def splitArray(self, nums, m):\n         \"\"\"\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         \"\"\"\n         work = 1\n         while not self.soln_exists(nums, m, work):\n             work *= 2\n         not_work = work / 2\n         while not_work < work - 1:\n             middle = not_work / 2 + work / 2\n             if self.soln_exists(nums, m, middle):\n                 work = middle\n             else:\n                 not_work = middle\n         return int(work)", "class Solution:\n     \n     def soln_exists(self, nums, m, i):\n         index = 0\n         for x in range(m):\n             total = 0\n             while True:\n                 total += nums[index]\n                 index += 1\n                 if (total > i):\n                     break\n                 if index == len(nums):\n                     return True\n             index -= 1\n         return False\n     \n     def splitArray(self, nums, m):\n         \"\"\"\n         :type nums: List[int]\n         :type m: int\n         :rtype: int\n         \"\"\"\n         work = 1\n         while not self.soln_exists(nums, m, work):\n             work *= 2\n         not_work = work / 2\n         while not_work < work - 1:\n             middle = not_work / 2 + work / 2\n             if self.soln_exists(nums, m, middle):\n                 work = middle\n             else:\n                 not_work = middle\n         return int(work)"]
["# cook your dish here\n# cook your dish here\nn=0;m=0;\nA=[];B=[];\nanscount=0;k=0;\n\ndef generate(n,m,l):\n nonlocal anscount\n if(len(l)==n+m):\n  X=l\n  i,j = 0,0\n  C=[0 for t in range(n+m)]\n  while((i+j)<(n+m)):\n   if(X[i+j] == 0):\n    C[i+j] = A[i]\n    i = i+1\n   else:\n    C[i+j] = B[j]\n    j = j+1\n  ans = len(C)\n  for i in range(1,len(C)):\n   if(C[i]==C[i-1]):\n    ans-=1\n  if(ans==k):\n   anscount+=1\n else:\n  if(l.count(1)<m):\n   generate(n,m,l+[1])\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\n  else:\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\nfor _ in range(int(input())):\n anscount=0\n n,m,k=list(map(int,input().split()))\n A=list(map(int,input().split()))\n B=list(map(int,input().split()))\n generate(n,m,[])\n print(anscount)\n", "def find_interleavings_2(a, b, i, j):\n try:\n  return lev_memo[(i, j)], nbs_memo[(i, j)]\n except KeyError:\n  pass\n to_return = []\n nbs = []\n if i == len(a) and j == len(b):\n  return [[]], [0]\n elif i == len(a):\n  leaves, nbs1 = find_interleavings_2(a, b, i, j + 1)\n  for ind in range(len(leaves)):\n   leaf = leaves[ind]\n   to_return.append([b[j]] + leaf)\n   if len(leaf) == 0:\n    nbs.append(nbs1[ind] + 1)\n   elif leaf[0] == b[j]:\n    nbs.append(nbs1[ind])\n   else:\n    nbs.append(nbs1[ind] + 1)\n elif j == len(b):\n  leaves, nbs1 = find_interleavings_2(a, b, i + 1, j)\n  for ind in range(len(leaves)):\n   leaf = leaves[ind]\n   to_return.append([a[i]] + leaf)\n   if len(leaf) == 0:\n    nbs.append(nbs1[ind] + 1)\n   elif leaf[0] == a[i]:\n    nbs.append(nbs1[ind])\n   else:\n    nbs.append(nbs1[ind] + 1)\n else:\n  leaves, nbs1 = find_interleavings_2(a, b, i, j + 1)\n  for ind in range(len(leaves)):\n   leaf = leaves[ind]\n   to_return.append([b[j]] + leaf)\n   if len(leaf) == 0:\n    nbs.append(nbs1[ind] + 1)\n   elif leaf[0] == b[j]:\n    nbs.append(nbs1[ind])\n   else:\n    nbs.append(nbs1[ind] + 1)\n\n  leaves2, nbs2 = find_interleavings_2(a, b, i + 1, j)\n  for ind in range(len(leaves2)):\n   leaf = leaves2[ind]\n   to_return.append([a[i]] + leaf)\n   if len(leaf) == 0:\n    nbs.append(nbs1[ind] + 1)\n   elif leaf[0] == a[i]:\n    nbs.append(nbs2[ind])\n   else:\n    nbs.append(nbs2[ind] + 1)\n\n lev_memo[(i, j)] = to_return\n nbs_memo[(i, j)] = nbs\n to_remove_lev = []\n to_remove_nbs = []\n for nbi in range(len(nbs)):\n  if nbs[nbi] > k:\n   to_remove_lev.append(to_return[nbi])\n   to_remove_nbs.append(nbs[nbi])\n\n for tri in to_remove_lev:\n  to_return.remove(tri)\n for tri in to_remove_nbs:\n  nbs.remove(tri)\n return to_return, nbs\n\n\nfor _ in range(int(input())):\n n, m, k = list(map(int, input().split(\" \")))\n a = list(map(int, input().split(\" \")))\n b = list(map(int, input().split(\" \")))\n res = 0\n\n lev_memo = dict()\n nbs_memo = dict()\n ils, numBlo = find_interleavings_2(a, b, 0, 0)\n ils = [tuple(x) for x in ils]\n # print(ils, numBlo)\n memo = dict()\n for c in numBlo:\n  if c == k:\n   res += 1\n\n print(res)\n", "import math\n\n\ndef find_interleavings_2(a, b, i, j):\n try:\n  return lev_memo[(i, j)], nbs_memo[(i, j)]\n except KeyError:\n  pass\n to_return = []\n nbs = []\n if i == len(a) and j == len(b):\n  return [[]], [0]\n elif i == len(a):\n  leaves, nbs1 = find_interleavings_2(a, b, i, j + 1)\n  for ind in range(len(leaves)):\n   leaf = leaves[ind]\n   to_return.append([b[j]] + leaf)\n   if len(leaf) == 0:\n    nbs.append(nbs1[ind] + 1)\n   elif leaf[0] == b[j]:\n    nbs.append(nbs1[ind])\n   else:\n    nbs.append(nbs1[ind] + 1)\n elif j == len(b):\n  leaves, nbs1 = find_interleavings_2(a, b, i + 1, j)\n  for ind in range(len(leaves)):\n   leaf = leaves[ind]\n   to_return.append([a[i]] + leaf)\n   if len(leaf) == 0:\n    nbs.append(nbs1[ind] + 1)\n   elif leaf[0] == a[i]:\n    nbs.append(nbs1[ind])\n   else:\n    nbs.append(nbs1[ind] + 1)\n else:\n  leaves, nbs1 = find_interleavings_2(a, b, i, j + 1)\n  for ind in range(len(leaves)):\n   leaf = leaves[ind]\n   to_return.append([b[j]] + leaf)\n   if len(leaf) == 0:\n    nbs.append(nbs1[ind] + 1)\n   elif leaf[0] == b[j]:\n    nbs.append(nbs1[ind])\n   else:\n    nbs.append(nbs1[ind] + 1)\n\n  leaves2, nbs2 = find_interleavings_2(a, b, i + 1, j)\n  for ind in range(len(leaves2)):\n   leaf = leaves2[ind]\n   to_return.append([a[i]] + leaf)\n   if len(leaf) == 0:\n    nbs.append(nbs1[ind] + 1)\n   elif leaf[0] == a[i]:\n    nbs.append(nbs2[ind])\n   else:\n    nbs.append(nbs2[ind] + 1)\n\n lev_memo[(i, j)] = to_return\n nbs_memo[(i, j)] = nbs\n return to_return, nbs\n\n\nfor _ in range(int(input())):\n n, m, k = list(map(int, input().split(\" \")))\n a = list(map(int, input().split(\" \")))\n b = list(map(int, input().split(\" \")))\n res = 0\n\n lev_memo = dict()\n nbs_memo = dict()\n ils, numBlo = find_interleavings_2(a, b, 0, 0)\n ils = [tuple(x) for x in ils]\n #print(ils, numBlo)\n memo = dict()\n for c in numBlo:\n  if c == k:\n   res += 1\n\n print(res)\n", "import math\n\n\ndef find_interleavings_2(a, b, i, j):\n try:\n  return lev_memo[(i, j)]\n except KeyError:\n  pass\n to_return = []\n if i == len(a) and j == len(b):\n  return [[]]\n elif i == len(a):\n  for leaf in find_interleavings_2(a, b, i, j + 1):\n   to_return.append([b[j]] + leaf)\n elif j == len(b):\n  for leaf in find_interleavings_2(a, b, i + 1, j):\n   to_return.append([a[i]] + leaf)\n else:\n  for leaf in find_interleavings_2(a, b, i, j + 1):\n   to_return.append([b[j]] + leaf)\n  for leaf in find_interleavings_2(a, b, i + 1, j):\n   to_return.append([a[i]] + leaf)\n lev_memo[(i, j)] = to_return\n return to_return\n\n\nfor _ in range(int(input())):\n n, m, k = list(map(int, input().split(\" \")))\n a = list(map(int, input().split(\" \")))\n b = list(map(int, input().split(\" \")))\n res = 0\n\n lev_memo = dict()\n ils = find_interleavings_2(a, b, 0, 0)\n ils = [tuple(x) for x in ils]\n # print(ils)\n memo = dict()\n for c in ils:\n  try:\n   res += memo[c]\n   continue\n  except KeyError:\n   pass\n  num_blocks = 0\n  prev = math.inf\n  for i in c:\n   if i != prev:\n    num_blocks += 1\n   prev = i\n  # num_blocks += 1\n  if num_blocks == k:\n   res += 1\n   memo[c] = 1\n  else:\n   memo[c] = 0\n\n print(res)\n", "import math\n\n\ndef find_interleavings(a, b):\n c = list()\n\n def interleaf(i, j, l):\n  if i == len(a) and j == len(b):\n   c.append(tuple(l))\n  elif i == len(a):\n   interleaf(i, j + 1, l + [b[j]])\n  elif j == len(b):\n   interleaf(i + 1, j, l + [a[i]])\n  else:\n   interleaf(i + 1, j, l + [a[i]])\n   interleaf(i, j + 1, l + [b[j]])\n\n interleaf(0, 0, [])\n return c\n\n\ndef find_interleavings_2(a, b, i, j):\n to_return = []\n if i == len(a) and j == len(b):\n  return [[]]\n elif i == len(a):\n  for leaf in find_interleavings_2(a, b, i, j + 1):\n   to_return.append([b[j]] + leaf)\n elif j == len(b):\n  for leaf in find_interleavings_2(a, b, i + 1, j):\n   to_return.append([a[i]] + leaf)\n else:\n  for leaf in find_interleavings_2(a, b, i, j + 1):\n   to_return.append([b[j]] + leaf)\n  for leaf in find_interleavings_2(a, b, i + 1, j):\n   to_return.append([a[i]] + leaf)\n\n return to_return\n\n\nfor _ in range(int(input())):\n n, m, k = list(map(int, input().split(\" \")))\n a = list(map(int, input().split(\" \")))\n b = list(map(int, input().split(\" \")))\n res = 0\n\n ils = find_interleavings_2(a, b, 0, 0)\n ils = [tuple(x) for x in ils]\n # print(ils)\n memo = dict()\n for c in ils:\n  try:\n   res += memo[c]\n   continue\n  except KeyError:\n   pass\n  num_blocks = 0\n  prev = math.inf\n  for i in c:\n   if i != prev:\n    num_blocks += 1\n   prev = i\n  # num_blocks += 1\n  if num_blocks == k:\n   res += 1\n   memo[c] = 1\n  else:\n   memo[c] = 0\n\n print(res)\n", "import math\n\n\ndef find_interleavings(a, b):\n c = list()\n\n def interleaf(i, j, l):\n  if i == len(a) and j == len(b):\n   c.append(tuple(l))\n  elif i == len(a):\n   interleaf(i, j + 1, l + [b[j]])\n  elif j == len(b):\n   interleaf(i + 1, j, l + [a[i]])\n  else:\n   interleaf(i + 1, j, l + [a[i]])\n   interleaf(i, j + 1, l + [b[j]])\n\n interleaf(0, 0, [])\n return c\n\n\nfor _ in range(int(input())):\n n, m, k = list(map(int, input().split(\" \")))\n a = list(map(int, input().split(\" \")))\n b = list(map(int, input().split(\" \")))\n res = 0\n\n ils = find_interleavings(a, b)\n # print(ils)\n memo = dict()\n for c in ils:\n  try:\n   res += memo[c]\n   continue\n  except KeyError:\n   pass\n  num_blocks = 0\n  prev = math.inf\n  for i in c:\n   if i != prev:\n    num_blocks += 1\n   prev = i\n  # num_blocks += 1\n  if num_blocks == k:\n   res += 1\n   memo[c] = 1\n  else:\n   memo[c] = 0\n\n print(res)\n", "import math\n\n\ndef find_interleavings(a, b):\n c = list()\n\n def interleaf(i, j, l):\n  if i == len(a) and j == len(b):\n   c.append(l)\n  elif i == len(a):\n   interleaf(i, j + 1, l + [b[j]])\n  elif j == len(b):\n   interleaf(i + 1, j, l + [a[i]])\n  else:\n   interleaf(i + 1, j, l + [a[i]])\n   interleaf(i, j + 1, l + [b[j]])\n\n interleaf(0, 0, [])\n return c\n\n\nfor _ in range(int(input())):\n n, m, k = list(map(int, input().split(\" \")))\n a = list(map(int, input().split(\" \")))\n b = list(map(int, input().split(\" \")))\n res = 0\n\n ils = find_interleavings(a, b)\n #print(ils)\n for c in ils:\n  num_blocks = 0\n  prev = math.inf\n  for i in c:\n   if i != prev:\n    num_blocks += 1\n   prev = i\n  # num_blocks += 1\n  if num_blocks == k:\n   res += 1\n print(res)\n", "import math\n\n\ndef find_interleavings(a, b):\n c = list()\n\n def interleaf(i, j, l):\n  if i == len(a) and j == len(b):\n   c.append(l)\n  elif i == len(a):\n   interleaf(i, j + 1, l + [b[j]])\n  elif j == len(b):\n   interleaf(i + 1, j, l + [a[i]])\n  else:\n   interleaf(i + 1, j, l + [a[i]])\n   interleaf(i, j + 1, l + [b[j]])\n\n interleaf(0, 0, [])\n return c\n\n\nfor _ in range(int(input())):\n n, m, k = list(map(int, input().split(\" \")))\n a = list(map(int, input().split(\" \")))\n b = list(map(int, input().split(\" \")))\n res = 0\n\n ils = find_interleavings(a, b)\n #print(ils)\n for c in ils:\n  num_blocks = 0\n  prev = math.inf\n  for i in c:\n   if i != prev:\n    num_blocks += 1\n   prev = i\n  # num_blocks += 1\n  if num_blocks == k:\n   res += 1\n print(res)\n", "# cook your dish here\nn=0;m=0;\nA=[];B=[];\nanscount=0;k=0;\n\ndef generate(n,m,l):\n nonlocal anscount\n if(len(l)==n+m):\n  X=l\n  i,j = 0,0\n  C=[0 for t in range(n+m)]\n  while((i+j)<(n+m)):\n   if(X[i+j] == 0):\n    C[i+j] = A[i]\n    i = i+1\n   else:\n    C[i+j] = B[j]\n    j = j+1\n  ans = len(C)\n  for i in range(1,len(C)):\n   if(C[i]==C[i-1]):\n    ans-=1\n  if(ans==k):\n   anscount+=1\n else:\n  if(l.count(1)<m):\n   generate(n,m,l+[1])\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\n  else:\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\nfor _ in range(int(input())):\n anscount=0\n n,m,k=list(map(int,input().split()))\n A=list(map(int,input().split()))\n B=list(map(int,input().split()))\n generate(n,m,[])\n print(anscount)\n", "# cook your dish here\nn=0;m=0;\nA=[];B=[];\nanscount=0;k=0;\n\ndef generate(n,m,l):\n nonlocal anscount\n if(len(l)==n+m):\n  X=l\n  i,j = 0,0\n  C=[0 for t in range(n+m)]\n  while((i+j)<(n+m)):\n   if(X[i+j] == 0):\n    C[i+j] = A[i]\n    i = i+1\n   else:\n    C[i+j] = B[j]\n    j = j+1\n  ans = len(C)\n  for i in range(1,len(C)):\n   if(C[i]==C[i-1]):\n    ans-=1\n  if(ans==k):\n   anscount+=1\n else:\n  if(l.count(1)<m):\n   generate(n,m,l+[1])\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\n  else:\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\nfor _ in range(int(input())):\n anscount=0\n n,m,k=list(map(int,input().split()))\n A=list(map(int,input().split()))\n B=list(map(int,input().split()))\n generate(n,m,[])\n print(anscount)\n", "# cook your dish here\nn=0;m=0;\nA=[];B=[];\nanscount=0;k=0;\n\ndef generate(n,m,l):\n nonlocal anscount\n if(len(l)==n+m):\n  X=l\n  i,j = 0,0\n  C=[0 for t in range(n+m)]\n  while((i+j)<(n+m)):\n   if(X[i+j] == 0):\n    C[i+j] = A[i]\n    i = i+1\n   else:\n    C[i+j] = B[j]\n    j = j+1\n  ans = len(C)\n  for i in range(1,len(C)):\n   if(C[i]==C[i-1]):\n    ans-=1\n  if(ans==k):\n   anscount+=1\n else:\n  if(l.count(1)<m):\n   generate(n,m,l+[1])\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\n  else:\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\nfor _ in range(int(input())):\n anscount=0\n n,m,k=list(map(int,input().split()))\n A=list(map(int,input().split()))\n B=list(map(int,input().split()))\n generate(n,m,[])\n print(anscount)\n", "# cook your dish here\nn=0;m=0;\nA=[];B=[];\nanscount=0;k=0;\n\ndef generate(n,m,l):\n nonlocal anscount\n if(len(l)==n+m):\n  X=l\n  i,j = 0,0\n  C=[0 for t in range(n+m)]\n  while((i+j)<(n+m)):\n   if(X[i+j] == 0):\n    C[i+j] = A[i]\n    i = i+1\n   else:\n    C[i+j] = B[j]\n    j = j+1\n  ans = len(C)\n  for i in range(1,len(C)):\n   if(C[i]==C[i-1]):\n    ans-=1\n  if(ans==k):\n   anscount+=1\n else:\n  if(l.count(1)<m):\n   generate(n,m,l+[1])\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\n  else:\n   if(l.count(0)<n):\n    generate(n,m,l+[0])\nfor _ in range(int(input())):\n anscount=0\n n,m,k=list(map(int,input().split()))\n A=list(map(int,input().split()))\n B=list(map(int,input().split()))\n generate(n,m,[])\n print(anscount)\n", "# cook your dish here\nmod = 10 ** 8 + 7\n\ndef dic_add(dic, k1, v):\n if k1 <= k:\n  if k1 in dic:\n   dic[k1] = (dic[k1]+v) % mod\n  else:\n   dic[k1] = v\n\n\nfor _ in range(int(input())):\n n, m, k = list(map(int, input().split()))\n a_l = list(map(int, input().split()))\n b_l = list(map(int, input().split()))\n\n # 0: m end, 1: n end\n f_dp = [[[{} for _ in range(n+1)] for _ in range(m+1)] for _ in range(2)]\n\n f_dp[0][1][0] = {1: 1}\n f_dp[1][0][1] = {1: 1}\n dif = 1\n for j in range(1, m):\n  if b_l[j] != b_l[j - 1]:\n   dif += 1\n  f_dp[0][j+1][0] = {dif: 1}\n\n dif = 1\n for i in range(1, n):\n  if a_l[i] != a_l[i - 1]:\n   dif += 1\n  f_dp[1][0][i+1] = {dif: 1}\n\n for i in range(1, n + 1):\n  for j in range(1, m + 1):\n   # m end\n   if j -2 >= 0 and b_l[j-1] != b_l[j - 2]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[0][j - 1][i].items()):\n    dic_add(f_dp[0][j][i], kk + addi, vv)\n   \n   if b_l[j-1] != a_l[i-1]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[1][j-1][i].items()):\n    dic_add(f_dp[0][j][i], kk + addi, vv)\n    \n   # n end\n   if i -2 >= 0 and a_l[i-1] != a_l[i - 2]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[1][j][i-1].items()):\n    dic_add(f_dp[1][j][i], kk + addi, vv)\n   \n   if b_l[j-1] != a_l[i-1]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[0][j][i-1].items()):\n    dic_add(f_dp[1][j][i], kk + addi, vv)\n\n ans = 0\n if k in f_dp[0][m][n]:\n  ans += f_dp[0][m][n][k]\n if k in f_dp[1][m][n]:\n  ans += f_dp[1][m][n][k]\n print(ans%mod)\n", "# cook your dish here\nmod = 10 ** 8 + 7\n\ndef dic_add(dic, k1, v):\n if k1 <= k:\n  if k1 in dic:\n   dic[k1] = (dic[k1]+v) % mod\n  else:\n   dic[k1] = v\n\n\nfor _ in range(int(input())):\n n, m, k = list(map(int, input().split()))\n a_l = list(map(int, input().split()))\n b_l = list(map(int, input().split()))\n\n # 0: m end, 1: n end\n f_dp = [[[{} for _ in range(n+1)] for _ in range(m+1)] for _ in range(2)]\n\n f_dp[0][1][0] = {1: 1}\n f_dp[1][0][1] = {1: 1}\n dif = 1\n for j in range(1, m):\n  if b_l[j] != b_l[j - 1]:\n   dif += 1\n  f_dp[0][j+1][0] = {dif: 1}\n\n dif = 1\n for i in range(1, n):\n  if a_l[i] != a_l[i - 1]:\n   dif += 1\n  f_dp[1][0][i+1] = {dif: 1}\n\n for i in range(1, n + 1):\n  for j in range(1, m + 1):\n   # m end\n   if j -2 >= 0 and b_l[j-1] != b_l[j - 2]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[0][j - 1][i].items()):\n    dic_add(f_dp[0][j][i], kk + addi, vv)\n   \n   if b_l[j-1] != a_l[i-1]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[1][j-1][i].items()):\n    dic_add(f_dp[0][j][i], kk + addi, vv)\n    \n   # n end\n   if i -2 >= 0 and a_l[i-1] != a_l[i - 2]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[1][j][i-1].items()):\n    dic_add(f_dp[1][j][i], kk + addi, vv)\n   \n   if b_l[j-1] != a_l[i-1]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[0][j][i-1].items()):\n    dic_add(f_dp[1][j][i], kk + addi, vv)\n\n ans = 0\n if k in f_dp[0][m][n]:\n  ans += f_dp[0][m][n][k]\n if k in f_dp[1][m][n]:\n  ans += f_dp[1][m][n][k]\n print(ans%mod)\n", "# cook your dish here\nmod = 10 ** 8 + 7\n\ndef dic_add(dic, k1, v):\n if k1 <= k:\n  if k1 in dic:\n   dic[k1] = (dic[k1]+v) % mod\n  else:\n   dic[k1] = v\n\n\nfor _ in range(int(input())):\n n, m, k = list(map(int, input().split()))\n a_l = list(map(int, input().split()))\n b_l = list(map(int, input().split()))\n\n # 0: m end, 1: n end\n f_dp = [[[{} for _ in range(n+1)] for _ in range(m+1)] for _ in range(2)]\n\n f_dp[0][1][0] = {1: 1}\n f_dp[1][0][1] = {1: 1}\n dif = 1\n for j in range(1, m):\n  if b_l[j] != b_l[j - 1]:\n   dif += 1\n  f_dp[0][j+1][0] = {dif: 1}\n\n dif = 1\n for i in range(1, n):\n  if a_l[i] != a_l[i - 1]:\n   dif += 1\n  f_dp[1][0][i+1] = {dif: 1}\n\n for i in range(1, n + 1):\n  for j in range(1, m + 1):\n   # m end\n   if j -2 >= 0 and b_l[j-1] != b_l[j - 2]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[0][j - 1][i].items()):\n    dic_add(f_dp[0][j][i], kk + addi, vv)\n   \n   if b_l[j-1] != a_l[i-1]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[1][j-1][i].items()):\n    dic_add(f_dp[0][j][i], kk + addi, vv)\n    \n   # n end\n   if i -2 >= 0 and a_l[i-1] != a_l[i - 2]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[1][j][i-1].items()):\n    dic_add(f_dp[1][j][i], kk + addi, vv)\n   \n   if b_l[j-1] != a_l[i-1]:\n    addi = 1\n   else:\n    addi = 0\n   for kk, vv in list(f_dp[0][j][i-1].items()):\n    dic_add(f_dp[1][j][i], kk + addi, vv)\n\n ans = 0\n if k in f_dp[0][m][n]:\n  ans += f_dp[0][m][n][k]\n if k in f_dp[1][m][n]:\n  ans += f_dp[1][m][n][k]\n print(ans)\n"]
["from collections import defaultdict\n \n class Solution:\n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         \n         graph = defaultdict(list)\n         for from_, to_ in tickets:\n             graph[from_].append(to_)\n         \n         for each in graph:\n             graph[each].sort()\n         \n         res = []\n         self.dfs(graph, \"JFK\", res)\n         return res[::-1]\n     \n     \n     def dfs(self, graph, from_, results):\n         \n         while graph[from_]:\n             curr = graph[from_].pop(0)\n             self.dfs(graph, curr, results)\n         \n         results.append(from_)", "class Solution:\n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         dict = collections.defaultdict(list)\n         for flight in sorted(tickets)[::-1]:\n             dict[flight[0]].append(flight[1])\n         res = collections.deque()\n         \n         def visit(s):\n             while dict[s]:\n                 visit(dict[s].pop())\n             res.appendleft(s)\n         visit(\"JFK\")\n         return list(res)", "class Solution:\n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         targets = collections.defaultdict(list)\n         for a, b in sorted(tickets, reverse=True):\n             targets[a] += [b]\n         route, stack = [], ['JFK']\n         \n         while stack:\n             while targets[stack[-1]]:\n                 stack += [targets[stack[-1]].pop()]\n             route += [stack.pop()]\n         return route[::-1]\n", "class Solution:\n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         graph = {}\n         for line in tickets:\n             if line[0] not in graph:\n                 graph[line[0]] = [line[1]]\n             else:\n                 graph[line[0]].append(line[1])\n         for key in graph:\n             graph[key] = sorted(graph[key], reverse = True)\n         \n         res = []\n         cur = \"JFK\"\n         stack = []\n         for i in range(len(tickets)):\n             while (cur not in graph) or (not graph[cur]):\n                 stack.append(cur)\n                 cur = res.pop()   \n             res.append(cur)\n             cur = graph[cur].pop()\n             \n         res.append(cur)\n         while stack:\n             res.append(stack.pop())\n         return res\n             \n             \n", "from collections import deque, defaultdict\n import heapq\n \n class Solution:\n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         edges = defaultdict(list)\n         for ticket in tickets:\n             heapq.heappush(edges[ticket[0]], ticket[1])\n         order = deque([])\n         self.dfs(order, edges, 'JFK')\n         return list(order)\n     \n     def dfs(self, order, edges, city):\n         while edges[city]:\n             next_city = heapq.heappop(edges[city])\n             self.dfs(order, edges, next_city)\n         order.appendleft(city)\n         ", "from heapq import *\n class Solution:\n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         import collections\n         targets=collections.defaultdict(list)\n         for a,b in sorted(tickets):\n             targets[a]+=b,\n         # for key in targets:\n         #     heapify(targets[key])\n         res=[]\n         self.visit('JFK',res, targets)\n         return res[::-1]\n     \n     def visit(self,airport, res, targets):\n         while targets[airport]:\n             self.visit(targets[airport].pop(0),res,targets)\n         res.append(airport)", "class Solution:\n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         tickets.sort()\n         schedule = {}\n         for ticket in reversed(tickets):\n             schedule[ticket[0]] = schedule[ticket[0]] + [ticket[1]] if ticket[0] in schedule else [ticket[1]]\n         return list(reversed(self.fly(schedule, \"JFK\")))\n         \n     def fly(self, schedule, depart):\n         route = []\n         while depart in schedule and len(schedule[depart]) > 0:\n             route += self.fly(schedule, schedule[depart].pop())\n         route += [depart]\n         return route", "class Solution:\n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         self.hasmap = {}\n         for ticket in tickets:\n             self.hasmap.setdefault(ticket[0], []).append(ticket[1])\n         self.route = ['JFK']\n         return self.dfs('JFK', tickets)\n     \n     def dfs(self, start_airport, tickets):\n         if len(self.route) == len(tickets) + 1:\n             return self.route\n         \n         # sort destination by legixal order\n         # See one case that there is destination but not in the hashmap dictionary\n         dests =self.hasmap.get(start_airport)\n         if dests is not None:\n             for dest in sorted(dests):\n                 self.hasmap[start_airport].remove(dest)\n                 self.route.append(dest)\n                 work = self.dfs(dest, tickets)\n                 if work:\n                     return self.route\n                 self.route.pop()\n                 # add it back\n                 self.hasmap[start_airport].append(dest)", "from collections import deque\n from collections import defaultdict\n class Solution:\n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         d = defaultdict(list)\n         for flight in tickets:\n             d[flight[0]] += flight[1],\n         self.route = [\"JFK\"]\n         def dfs(start = 'JFK'):\n             if len(self.route) == len(tickets) + 1:\n                 return self.route\n             myDsts = sorted(d[start])\n             for dst in myDsts:\n                 d[start].remove(dst)\n                 self.route += dst,\n                 worked = dfs(dst)\n                 if worked:\n                     return worked\n                 self.route.pop()\n                 d[start] += dst,\n         return dfs()      \n         ", "class Solution:\n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         \n         d = collections.defaultdict(list)\n         tickets.sort(key = operator.itemgetter(1)) \n         \n         for src, dst in tickets:\n             d[src].append([dst, False])\n             \n         ans = []\n             \n         def DFS(src):\n             \n             ans.append(src)\n          \n             if len(ans) == len(tickets)+1: return True\n             \n             for i, a in enumerate(d[src]):\n             \n                 if not a[1]:\n                     d[src][i][1] = True\n                \n                     if DFS(a[0]):\n                         return True\n                     d[src][i][1] = False\n             ans.pop()\n             return False\n             \n         DFS('JFK')\n         return ans\n         \n                     \n", "class Solution(object):\n \n     def __init__(self):\n         self.res = []\n \n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         if tickets is None or len(tickets) == 0:\n             return []\n \n         dic = {}\n         dic_city = {}\n         for t in tickets:\n             if (t[0], t[1]) not in dic:\n                 dic[(t[0], t[1])] = 0\n             dic[(t[0], t[1])] += 1\n             if t[0] not in dic_city:\n                 dic_city[t[0]] = []\n             dic_city[t[0]].append(t[1])\n         for k in dic_city.keys():\n             dic_city[k] = set(dic_city[k])\n             dic_city[k] = list(dic_city[k])\n             dic_city[k].sort()\n         self.res = []\n         self.dfs(\"JFK\", dic, dic_city, [\"JFK\"], len(tickets)+1)\n         return self.res\n \n     def dfs(self, city, dic, dic_city, cur, tar):\n         if len(cur) == tar:\n             if not self.res:\n                 self.res = list(cur)\n             \n             return True\n         if city in dic_city:\n             citys = dic_city[city]\n             for c in citys:\n                 if (city, c) in dic and dic[(city, c)]>0:\n                     dic[(city, c)]-=1\n                     cur.append(c)\n                     if self.dfs(c, dic, dic_city, cur, tar):\n                         return True\n                     cur.pop()\n                     dic[(city, c)]+=1\n         return False", "class Solution:\n     def findItinerary(self, tickets):\n         \"\"\"\n         :type tickets: List[List[str]]\n         :rtype: List[str]\n         \"\"\"\n         d = collections.defaultdict(list)\n         tickets.sort()\n         for i,j in tickets:\n             d[i] += [j]\n             \n         def dfs(path, start):\n             path += [start]\n             if len(path) == length:\n                 return True\n             i = 0\n             while i <len(d[start]):\n                 next = d[start].pop(0)\n                 print((next, d[start]))\n                 i += 1\n                 if dfs(path, next):\n                     return True\n                 d[start] += [next]\n             path.pop()\n             return False    \n                 \n         path, length = [], len(tickets) + 1\n         dfs(path, 'JFK')\n         return path\n                 \n"]
["import heapq\nfrom collections import deque, defaultdict\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m,n = len(grid),len(grid[0])\n        key_lock_loc = {ch:(i,j) for i,row in enumerate(grid) for j,ch in enumerate(row) if ch not in {'.','#'}}\n        key_cnt = sum(key_lock in ('a','b','c','d','e','f')for key_lock in key_lock_loc)\n        \n        def bfs_from(src):\n            i,j = key_lock_loc[src]\n            seen = defaultdict(lambda: False)\n            seen[i,j] = True\n            # only locations which are not wall will be put into the queue\n            dque = deque([(i,j,0)]) \n            dist = {}\n            while dque:\n                i,j,d = dque.popleft()\n                ch = grid[i][j]\n                if ch != src and ch != '.': # reaches lock or key\n                    dist[ch] = d\n                    continue\n                # '#' or '.'\n                for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\n                    if not (0<=x<m and 0<=y<n) or grid[x][y] == '#' or seen[x,y]:\n                        continue\n                    seen[x,y] = True\n                    dque.append((x,y,d+1))\n            return dist\n        \n        dists = {key_lock:bfs_from(key_lock) for key_lock in key_lock_loc}\n        all_keys_bitmap = 2 ** key_cnt -1\n        \n        hq = [(0,'@',0)]\n        final_dist = defaultdict(lambda: float('inf'))\n        final_dist['@', 0] = 0\n        while hq:\n            d,ch,keys_bitmap = heapq.heappop(hq)\n            if final_dist[ch,keys_bitmap] < d:\n                continue\n            if keys_bitmap == all_keys_bitmap:\n                return d\n            for next_key_lock, d2 in list(dists[ch].items()):\n                keys_bitmap2 = keys_bitmap\n                if next_key_lock.islower(): # key\n                    keys_bitmap2 |= (1 <<(ord(next_key_lock) - ord('a')))\n                elif next_key_lock.isupper(): # ch\n                    if not(keys_bitmap &(1 <<(ord(next_key_lock) - ord('A')))):\n                        continue\n                if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                    final_dist[next_key_lock, keys_bitmap2]= d + d2\n                    heapq.heappush(hq,(d+d2,next_key_lock,keys_bitmap2))\n        return -1\n        \n                    \n", "class Solution:\n    def shortestPathAllKeys(self, grid) -> int:\n        from collections import deque\n        import copy\n        rows = len(grid)\n        if rows == 0:\n            return 0\n        cols = len(grid[0])\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        num_keys = 0\n        start = [-1, -1]\n        for i in range(rows):\n            for j in range(cols):\n                ch = grid[i][j]\n                if 0 <= ord(ch) - ord('a') <= 5:\n                    num_keys += 1\n                if ch == '@':\n                    start[0] = i\n                    start[1] = j\n        curr_level = deque()\n        next_level = deque()\n        visited = set()\n        visited.add((0, start[0], start[1]))\n        curr_level.append((0, start[0], start[1]))\n        steps = 0\n        while len(curr_level) > 0:\n            for i in range(len(curr_level)):\n                ori_keys, x, y = curr_level.popleft()\n                for d in dirs:\n                    keys = ori_keys\n                    new_x = x + d[0]\n                    new_y = y + d[1]\n                    if new_x < 0 or new_x >= rows or new_y < 0 or new_y >= cols:\n                        continue\n                    ch = grid[new_x][new_y]\n                    if ch == '#':\n                        continue\n                    ascii_minus_lower = ord(ch) - ord('a')\n                    ascii_minus_upper = ord(ch) - ord('A')\n                    if 0 <= ascii_minus_lower <= 5:\n                        keys |= (1 << ascii_minus_lower)\n                        if keys == ((1 << num_keys) - 1):\n                            return steps + 1\n                    if 0 <= ascii_minus_upper <= 5 and (((keys >> ascii_minus_upper) & 1) == 0):\n                        continue\n                    if (keys, new_x, new_y) not in visited:\n                        visited.add((keys, new_x, new_y))\n                        next_level.append((keys, new_x, new_y))\n            curr_level = copy.deepcopy(next_level)\n            next_level.clear()\n            steps += 1\n        return -1\n                    \n                            \n                    \n                \n        \n                    \n        \n", "class Solution:\n    def __init__(self):\n        self.DIR = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m, n = len(grid), len(grid[0])\n        start_x, start_y = -1, -1\n        target_keys = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '@':\n                    start_x, start_y = i, j\n                # elif grid[i][j].islower():\n                elif grid[i][j] in 'abcdef':\n                    target_keys |= 1 << (ord(grid[i][j]) - ord('a'))\n                    # final_keys <<= 1\n                    # final_keys |= 1\n        \n        pq = [(0, 0, start_x, start_y)]\n        visited = set((0, start_x, start_y))\n\n        while pq:\n            curr_steps, curr_keys, x, y = heapq.heappop(pq)\n\n            if curr_keys == target_keys:\n                return curr_steps\n\n            for delta_x, delta_y in self.DIR:\n                next_x, next_y = x + delta_x, y + delta_y\n\n                if not self.inbound(grid, next_x, next_y) or grid[next_x][next_y] == '#':\n                    continue\n\n                if grid[next_x][next_y] in 'ABCDEF':\n                    if (curr_keys >> (ord(grid[next_x][next_y]) - ord('A'))) & 1:\n                        next_keys = curr_keys\n                    else:\n                        continue\n                elif grid[next_x][next_y] in 'abcdef':\n                    next_keys = curr_keys | (1 << (ord(grid[next_x][next_y]) - ord('a')))\n                else: # the next location is @ or .\n                    next_keys = curr_keys\n\n                if (next_keys, next_x, next_y) in visited:\n                        continue\n\n                heapq.heappush(pq, (curr_steps + 1, next_keys, next_x, next_y))\n                visited.add((next_keys, next_x, next_y))\n        return -1\n                \n    def inbound(self, grid, x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0])", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m=len(grid)\n        n=len(grid[0])\n        \n        # handles neighbor, returns neighbor next state\n        def neighbor(i,j, keys):\n            keys_list = list(keys)\n            if grid[i][j] in ['.', '@']:\n                return (i,j,keys)\n            elif grid[i][j].islower():\n                if grid[i][j] in keys_list: # already picked key, treat as empty cell\n                    return (i,j,keys)\n                else: # pick up new key\n                    keys_list.append(grid[i][j])\n                    new_keys=''.join(keys_list)\n                    return (i,j,new_keys)\n            elif grid[i][j].isupper():\n                if grid[i][j].lower() in keys_list: # treat lock as empty cell if have the key\n                    return (i,j,keys)\n            return None\n        \n        def move(i,j,keys):\n            nexts=[]\n            if i>0:\n                nei = neighbor(i-1,j,keys)\n                if nei:\n                    nexts.append(nei)\n            if i<m-1:\n                nei=neighbor(i+1,j,keys)\n                if nei:\n                    nexts.append(nei)\n            if j>0:\n                nei=neighbor(i,j-1,keys)\n                if nei:\n                    nexts.append(nei)\n            if j<n-1:\n                nei= neighbor(i,j+1,keys)\n                if nei:\n                    nexts.append(nei)\n            return nexts\n                  \n        def get_start_and_keys():\n            x, y, keys = -1, -1, 0\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j]=='@':\n                        x, y = i, j\n                    elif grid[i][j].islower():\n                        keys +=1\n            return x, y, keys\n        \n        i0, j0, total_keys = get_start_and_keys()\n        q=deque()\n        start_point = (i0, j0, '')\n        q.append(start_point)\n        visited=set()\n        visited.add(start_point)\n        steps = -1\n        while q:\n            size=len(q)\n            steps +=1\n            for x in range(size):\n                pop=q.popleft()\n                i=pop[0]\n                j=pop[1]\n                keys=pop[2]\n                if len(keys)==total_keys:\n                    return steps\n                for nex in move(i,j,keys):\n                    if nex not in visited:\n                        q.append(nex)\n                        visited.add(nex)\n        return -1\n       \n                \n                \n                \n                \n                \n                \n        \n        \n        \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m=len(grid)\n        n=len(grid[0])\n        \n        # handles neighbor, returns neighbor next state\n        def neighbor(i,j, keys):\n            keys_list = list(keys)\n            if grid[i][j] in ['.', '@']:\n                return (i,j,keys)\n            elif grid[i][j].islower():\n                if grid[i][j] in keys_list: # already picked key, treat as empty cell\n                    return (i,j,keys)\n                else: # pick up new key\n                    keys_list.append(grid[i][j])\n                    new_keys=''.join(keys_list)\n                    return (i,j,new_keys)\n            elif grid[i][j].isupper():\n                if grid[i][j].lower() in keys_list: # treat lock as empty cell if have the key\n                    return (i,j,keys)\n            return None\n        \n        def move(i,j,keys):\n            nexts=[]\n            if i>0:\n                nei=neighbor(i-1,j,keys)\n                if nei:\n                    nexts.append(nei)\n            if i<m-1:\n                nei=neighbor(i+1,j,keys)\n                if nei:\n                    nexts.append(nei)\n            if j>0:\n                nei=neighbor(i,j-1,keys)\n                if nei:\n                    nexts.append(nei)\n            if j<n-1:\n                nei= neighbor(i,j+1,keys)\n                if nei:\n                    nexts.append(nei)\n            return nexts\n                  \n        def get_start_and_keys():\n            x, y, keys = -1, -1, 0\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j]=='@':\n                        x, y = i, j\n                    elif grid[i][j].islower():\n                        keys +=1\n            return x, y, keys\n        \n        i0, j0, total_keys = get_start_and_keys()\n        q=deque()\n        start_point = (i0, j0, '')\n        q.append(start_point)\n        visited=set()\n        visited.add(start_point)\n        steps = -1\n        while q:\n            size=len(q)\n            steps +=1\n            for x in range(size):\n                pop=q.popleft()\n                i=pop[0]\n                j=pop[1]\n                keys=pop[2]\n                if len(keys)==total_keys:\n                    return steps\n                for nex in move(i,j,keys):\n                    if nex not in visited:\n                        q.append(nex)\n                        visited.add(nex)\n        return -1 ", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m=len(grid)\n        n=len(grid[0])\n        \n        # handles neighbor, returns neighbor next state\n        def neighbor(i,j, keys):\n            keys_list = list(keys)\n            if grid[i][j] in ['.', '@']:\n                return (i,j,keys)\n            elif grid[i][j].islower():\n                if grid[i][j] in keys_list: # already picked key, treat as empty cell\n                    return (i,j,keys)\n                else: # pick up new key\n                    keys_list.append(grid[i][j])\n                    new_keys=''.join(keys_list)\n                    return (i,j,new_keys)\n            elif grid[i][j].isupper():\n                if grid[i][j].lower() in keys_list: # treat lock as empty cell if have the key\n                    return (i,j,keys)\n            return None\n        \n        def move(i,j,keys):\n            nexts=[]\n            if i>0:\n                nei=neighbor(i-1,j,keys)\n                if nei:\n                    nexts.append(nei)\n            if i<m-1:\n                nei=neighbor(i+1,j,keys)\n                if nei:\n                    nexts.append(nei)\n            if j>0:\n                nei=neighbor(i,j-1,keys)\n                if nei:\n                    nexts.append(nei)\n            if j<n-1:\n                nei= neighbor(i,j+1,keys)\n                if nei:\n                    nexts.append(nei)\n            return nexts\n                  \n        def get_start_and_keys():\n            x, y, keys = -1, -1, 0\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j]=='@':\n                        x, y = i, j\n                    elif grid[i][j].islower():\n                        keys +=1\n            return x, y, keys\n        \n        i0, j0, total_keys = get_start_and_keys()\n        q=deque()\n        start_point = (i0, j0, '')\n        q.append(start_point)\n        visited=set()\n        visited.add(start_point)\n        steps = -1\n        while q:\n            size=len(q)\n            steps +=1\n            for x in range(size):\n                pop=q.popleft()\n                i=pop[0]\n                j=pop[1]\n                keys=pop[2]\n                if len(keys)==total_keys:\n                    return steps\n                for nex in move(i,j,keys):\n                    if nex not in visited:\n                        q.append(nex)\n                        visited.add(nex)\n        return -1\n       \n                \n                \n                \n                \n                \n                \n        \n        \n        \n", "import heapq\nfrom collections import deque, defaultdict\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m,n = len(grid),len(grid[0])\n        key_lock_loc = {ch:(i,j) for i,row in enumerate(grid) for j,ch in enumerate(row) if ch not in {'.','#'}}\n\n        def bfs_from(src):\n            i,j = key_lock_loc[src]\n            seen = [[False] *n for _ in range(m)]\n            seen[i][j] = True\n            # only locations which are not wall will be put into the queue\n            dque = deque([(i,j,0)]) \n            dist = {}\n            while dque:\n                i,j,d = dque.popleft()\n                ch = grid[i][j]\n                if ch != src and ch != '.': # reaches lock or key\n                    dist[ch] = d\n                    continue\n                # '#' or '.'\n                for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\n                    if not (0<=x<m and 0<=y<n) or grid[x][y] == '#' or seen[x][y]:\n                        continue\n                    seen[x][y] = True\n                    dque.append((x,y,d+1))\n            return dist\n        \n        dists = {key_lock:bfs_from(key_lock) for key_lock in key_lock_loc}\n        target_state = 2 ** sum(key_lock.islower() for key_lock in key_lock_loc)-1\n        \n        hq = [(0,'@',0)]\n        final_dist = defaultdict(lambda: float('inf'))\n        final_dist['@',0] = 0\n        while hq:\n            d,loc,state = heapq.heappop(hq)\n            if final_dist[loc,state] < d:\n                continue\n            if state == target_state:\n                return d\n            for destination, d2 in list(dists[loc].items()):\n                state2 = state\n                if destination.islower(): # key\n                    state2 |= (1 <<(ord(destination) - ord('a')))\n                elif destination.isupper(): # loc\n                    if not(state &(1 <<(ord(destination) - ord('A')))):\n                        continue\n                if d + d2 < final_dist[destination, state2]:\n                    final_dist[destination, state2]= d + d2\n                    heapq.heappush(hq,(d+d2,destination,state2))\n        return -1\n        \n                    \n", "class Solution:\n    def __init__(self):\n        self.DIR = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m, n = len(grid), len(grid[0])\n        start_x, start_y = -1, -1\n        target_keys = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '@':\n                    start_x, start_y = i, j\n                elif grid[i][j].islower():\n                # elif grid[i][j] in 'abcdef':\n                    target_keys |= 1 << (ord(grid[i][j]) - ord('a'))\n                    # final_keys <<= 1\n                    # final_keys |= 1\n        \n        pq = [(0, 0, start_x, start_y)]\n        visited = set((0, start_x, start_y))\n\n        while pq:\n            curr_steps, curr_keys, x, y = heapq.heappop(pq)\n\n            if curr_keys == target_keys:\n                return curr_steps\n\n            for delta_x, delta_y in self.DIR:\n                next_x, next_y = x + delta_x, y + delta_y\n\n                if not self.inbound(grid, next_x, next_y) or grid[next_x][next_y] == '#':\n                    continue\n\n                if grid[next_x][next_y] in 'ABCDEF':\n                    if (curr_keys >> (ord(grid[next_x][next_y]) - ord('A'))) & 1:\n                        next_keys = curr_keys\n                    else:\n                        continue\n                elif grid[next_x][next_y] in 'abcdef':\n                    next_keys = curr_keys | (1 << (ord(grid[next_x][next_y]) - ord('a')))\n                else: # the next location is @ or .\n                    next_keys = curr_keys\n\n                if (next_keys, next_x, next_y) in visited:\n                        continue\n\n                heapq.heappush(pq, (curr_steps + 1, next_keys, next_x, next_y))\n                visited.add((next_keys, next_x, next_y))\n        return -1\n                \n    def inbound(self, grid, x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0])", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        \n        keylock={'a':0,'b':1,'c':2,'d':3,'e':4,'f':5,'A':'a','B':'b','C':'c','D':'d','E':'e','F':'f'}\n        \n        m=len(grid)\n        n=len(grid[0])\n        \n        #Find the start point and the bit representation of all keys\n        keys_target=0\n        for i in range(m):\n            for j in range(n):\n                if(grid[i][j]=='@'):\n                    start=(i,j)\n                elif(grid[i][j] in 'abcdef'):\n                    keys_target=keys_target|(1<<keylock[grid[i][j]])\n                    \n       \n        #Check if all keys have been acquired\n        def keyAllAcquired(value):\n            if((value & keys_target)==keys_target):\n                return True\n            else:\n                return False\n            \n        #check if it can be passed and within the boundary\n        def isMovable(i,j):\n            if(0<=i<=m-1 and 0<=j<=n-1 and grid[i][j]!='#'):\n                return True\n            else:\n                return False\n    \n        #State is defined as ((i,j),keyloc acquired)\n        visited_states={(start[0],start[1],0)}\n        q=collections.deque()\n        q.append((start[0],start[1],0))\n        \n        \n        #Use DFS to find the minimum paths to cover all available keys\n        step=0\n        while q:\n            #\n            q_len=len(q)\n            #Pop q_len number of elements from left of q\n            for _ in range(q_len):\n                i,j,keys=q.popleft()\n                #Return whenever all the keys in the grid are acquired\n                if(keyAllAcquired(keys)):\n                    return step\n                \n                #Move along 4 directions\n                directs=[-1,0,1,0,-1]\n                for d in range(4):\n                    newi=i+directs[d]\n                    newj=j+directs[d+1]\n                    \n                    #Before updating the state, check if the newi and newj is within the bound and don't hit\n                    #the wall\n                    if(isMovable(newi,newj)):\n                        #Check the following cases and make the move\n                        #Do nothing for other cases\n                        #keys\n                        if(grid[newi][newj] in 'abcdef'):\n                            new_state=(newi,newj,keys|1<<keylock[grid[newi][newj]])\n                            #check existence only for key\n                            if(new_state not in visited_states):\n                                visited_states.add(new_state)\n                                q.append(new_state)\n                        #locks \n                        elif(grid[newi][newj] in 'ABCDEF'):\n                            lower_int=keylock[keylock[grid[newi][newj]]]\n                            new_state=(newi,newj,keys|1<<(lower_int+6))\n                            #Check key and exisitence for lock\n                            if(keys & (1<<lower_int) and new_state not in visited_states):\n                                visited_states.add(new_state)\n                                q.append(new_state)\n                                \n                        #'.' or '@'     \n                        elif(grid[newi][newj] in '.@' and (newi,newj,keys) not in visited_states):\n                            visited_states.add((newi,newj,keys))\n                            q.append((newi,newj,keys))\n            step+=1\n\n        return -1\n            \n                           \n                           \n                           \n                            \n                            \n                            \n                    \n                \n            \n            \n        \n        \n        \n        \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m=len(grid)\n        n=len(grid[0])\n        \n        # for any path, cannot pick the same key twice\n        def neighbor(i,j, keys):\n            res=[]\n            keys_list = list(keys)\n            if grid[i][j] in ['.', '@']:\n                res.append((i,j,keys))\n            elif grid[i][j].islower():\n                if grid[i][j] in keys_list: # already picked key, treat as empty cell\n                    res.append((i,j,keys))\n                else: # pick up new key\n                    keys_list.append(grid[i][j])\n                    new_keys=''.join(keys_list)\n                    res.append((i,j,new_keys))\n            elif grid[i][j].isupper():\n                if grid[i][j].lower() in keys_list: # treat cell as empty if have the key\n                    res.append((i,j,keys))\n            return res\n        \n        def move(i,j,keys):\n            nexts=[]\n            if i>0:\n                x = neighbor(i-1,j,keys)\n                if x:\n                    nexts += x\n            if i<m-1:\n                nei=neighbor(i+1,j,keys)\n                if nei:\n                    nexts += nei\n            if j>0:\n                nei=neighbor(i,j-1,keys)\n                if nei:\n                    nexts += nei\n            if j<n-1:\n                nei= neighbor(i,j+1,keys)\n                if nei:\n                    nexts += nei\n            #print('move nexts', nexts)\n            return nexts\n                  \n        def get_start_and_keys():\n            x, y, keys = -1, -1, 0\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j]=='@':\n                        x, y = i, j\n                    if grid[i][j].islower():\n                        keys +=1\n            return x, y, keys\n        \n        \n        i0, j0, total_keys = get_start_and_keys()\n        #print(i0,j0,total_keys)\n        q=deque()\n        start_point = (i0, j0, '')\n        q.append(start_point)\n        visited=set()\n        visited.add(start_point)\n        steps = -1\n        while q:\n            size=len(q)\n            #print('q',q)\n            steps +=1\n            for x in range(size):\n                pop=q.popleft()\n                #print(pop, end=' ')\n                i=pop[0]\n                j=pop[1]\n                keys=pop[2]\n                if len(keys)==total_keys:\n                    return steps\n                for nex in move(i,j,keys):\n                    #print('nex', nex)\n                    #print('visited', visited)\n                    if nex not in visited:\n                        q.append(nex)\n                        visited.add(nex)\n        return -1\n       \n                \n                \n                \n                \n                \n                \n        \n        \n        \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        \n        keylock={'a':0,'b':1,'c':2,'d':3,'e':4,'f':5,'A':'a','B':'b','C':'c','D':'d','E':'e','F':'f'}\n        \n        m=len(grid)\n        n=len(grid[0])\n        \n        #Find the start point and the bit representation of all keys\n        keys_target=0\n        for i in range(m):\n            for j in range(n):\n                if(grid[i][j]=='@'):\n                    start=(i,j)\n                elif(grid[i][j] in 'abcdef'):\n                    keys_target=keys_target|(1<<keylock[grid[i][j]])\n                    \n       \n        #Check if all keys have been acquired\n        def keyAllAcquired(value):\n            if((value & keys_target)==keys_target):\n                return True\n            else:\n                return False\n            \n        #check if it can be passed and within the boundary\n        def isMovable(i,j):\n            if(0<=i<=m-1 and 0<=j<=n-1 and grid[i][j]!='#'):\n                return True\n            else:\n                return False\n    \n        #State is defined as ((i,j),keyloc acquired)\n        visited_states={(start,0)}\n        q=collections.deque()\n        q.append((start,0))\n        \n        \n        #Use DFS to find the minimum paths to cover all available keys\n        step=0\n        while q:\n            #\n            q_len=len(q)\n            #Pop q_len number of elements from left of q\n            for _ in range(q_len):\n                (i,j),keys=q.popleft()\n                #Return whenever all the keys in the grid are acquired\n                if(keyAllAcquired(keys)):\n                    return step\n                \n                #Move along 4 directions\n                directs=[-1,0,1,0,-1]\n                for d in range(4):\n                    newi=i+directs[d]\n                    newj=j+directs[d+1]\n                    \n                    #Before updating the state, check if the newi and newj is within the bound and don't hit\n                    #the wall\n                    if(isMovable(newi,newj)):\n                        #Check the following cases and make the move\n                        #Do nothing for other cases\n                        #keys\n                        if(grid[newi][newj] in 'abcdef'):\n                            new_state=((newi,newj),keys|1<<keylock[grid[newi][newj]])\n                            #check existence only for key\n                            if(new_state not in visited_states):\n                                visited_states.add(new_state)\n                                q.append(new_state)\n                        #locks \n                        elif(grid[newi][newj] in 'ABCDEF'):\n                            lower_int=keylock[keylock[grid[newi][newj]]]\n                            new_state=((newi,newj),keys|1<<(lower_int+6))\n                            #Check key and exisitence for lock\n                            if(keys & (1<<lower_int) and new_state not in visited_states):\n                                visited_states.add(new_state)\n                                q.append(new_state)\n                                \n                        #'.' or '@'     \n                        elif(grid[newi][newj] in '.@' and ((newi,newj),keys) not in visited_states):\n                            visited_states.add(((newi,newj),keys))\n                            q.append(((newi,newj),keys))\n            step+=1\n\n        return -1\n            \n                           \n                           \n                           \n                            \n                            \n                            \n                    \n                \n            \n            \n        \n        \n        \n        \n", "class Solution:\n    # Naive, BFS, starting from the start point without any key.\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        row, col = len(grid), len(grid[0])\n        x, y = None, None\n        num_keys = 0\n        for r in range(row):\n            for c in range(col):\n                if grid[r][c] == '@':\n                    x, y = r, c\n                elif grid[r][c] in 'abcdef':\n                    num_keys += 1\n        queue = collections.deque([(x, y, 0, 0, '.@abcdef')])  # r, c, steps, num_key, accessible\n        dires = [1, 0, -1, 0, 1]\n        visited = set()\n        while queue:\n            r, c, steps, cnt_keys, accessible = queue.popleft()\n            if grid[r][c] in 'abcdef' and grid[r][c].upper() not in accessible:\n                accessible += grid[r][c].upper()  # corresponding lock is accessible\n                cnt_keys += 1\n            if cnt_keys == num_keys:  # collected all keys\n                return steps\n            for d in range(len(dires) - 1):\n                new_r, new_c = r + dires[d], c + dires[d + 1]\n                if 0 <= new_r < row and 0 <= new_c < col and grid[r][c] in accessible:\n                    if (new_r, new_c, accessible) not in visited:\n                        visited.add((new_r, new_c, accessible))\n                        queue.append((new_r, new_c, steps + 1, cnt_keys, accessible))\n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m=len(grid)\n        n=len(grid[0])\n        \n        def neighbor(i,j, keys):\n            res=[]\n            keys_list = list(keys)\n            if grid[i][j] in ['.', '@']:\n                res.append((i,j,keys))\n            elif grid[i][j].islower():\n                if grid[i][j] in keys_list: # already picked key, treat as empty cell\n                    res.append((i,j,keys))\n                else: # pick up new key\n                    keys_list.append(grid[i][j])\n                    new_keys=''.join(keys_list)\n                    res.append((i,j,new_keys))\n            elif grid[i][j].isupper():\n                if grid[i][j].lower() in keys_list: # treat lock as empty cell if have the key\n                    res.append((i,j,keys))\n            return res\n        \n        def move(i,j,keys):\n            nexts=[]\n            if i>0:\n                nei = neighbor(i-1,j,keys)\n                if nei:\n                    nexts += nei\n            if i<m-1:\n                nei=neighbor(i+1,j,keys)\n                if nei:\n                    nexts += nei\n            if j>0:\n                nei=neighbor(i,j-1,keys)\n                if nei:\n                    nexts += nei\n            if j<n-1:\n                nei= neighbor(i,j+1,keys)\n                if nei:\n                    nexts += nei\n            return nexts\n                  \n        def get_start_and_keys():\n            x, y, keys = -1, -1, 0\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j]=='@':\n                        x, y = i, j\n                    elif grid[i][j].islower():\n                        keys +=1\n            return x, y, keys\n        \n        i0, j0, total_keys = get_start_and_keys()\n        q=deque()\n        start_point = (i0, j0, '')\n        q.append(start_point)\n        visited=set()\n        visited.add(start_point)\n        steps = -1\n        while q:\n            size=len(q)\n            steps +=1\n            for x in range(size):\n                pop=q.popleft()\n                i=pop[0]\n                j=pop[1]\n                keys=pop[2]\n                if len(keys)==total_keys:\n                    return steps\n                for nex in move(i,j,keys):\n                    if nex not in visited:\n                        q.append(nex)\n                        visited.add(nex)\n        return -1\n       \n                \n                \n                \n                \n                \n                \n        \n        \n        \n", "from collections import defaultdict, deque\nimport heapq\n\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        oa = ord('a')\n        oA = ord('A')\n        m,n = len(grid),len(grid[0])\n        key_lock_loc = {ch:(i,j) for i,row in enumerate(grid) for j,ch in enumerate(row) if ch not in '#.'}\n        key_cnt = sum(ch.islower() for ch in key_lock_loc)\n        \n        def dfs_from(src):\n            i,j = key_lock_loc[src]\n            seen = defaultdict(lambda: False)\n            seen[i,j] = True\n            dque = deque([(i,j,0)])\n            dist = {}\n            while dque:\n                i,j,d = dque.popleft()\n                ch = grid[i][j]\n                if ch != src and ch != '.':\n                    dist[ch] = d\n                    continue\n                for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\n                    if not (0<=x<m and 0<=y<n) or grid[x][y] == '#' or seen[x,y]:\n                        continue\n                    dque.append((x,y,d+1))\n                    seen[x,y] = True\n            return dist\n        \n        dists = {ch:dfs_from(ch) for ch in key_lock_loc}\n        target_state = 2**key_cnt - 1\n        final_dist = defaultdict(lambda: float('inf'))\n        hq = [(0,'@',0)] # (dist, ch, state)\n        final_dist['@',0] = 0\n        while hq:\n            d, ch, state = heapq.heappop(hq)\n            if d > final_dist[ch,state]:\n                continue\n            if state == target_state:\n                return d\n            \n            for ch1,d1 in dists[ch].items():\n                state1 = state\n                if ch1.islower():\n                    state1 |= 1<< (ord(ch1)-oa)\n                elif ch1.isupper() and not (state1 & 1<< (ord(ch1)-oA)):\n                        continue\n                if d + d1 < final_dist[ch1,state1]:\n                    final_dist[ch1,state1] = d + d1\n                    heapq.heappush(hq,(d+d1, ch1, state1))\n        return -1", "import heapq\nfrom collections import deque, defaultdict\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m,n = len(grid),len(grid[0])\n        key_lock_loc = {ch:(i,j) for i,row in enumerate(grid) for j,ch in enumerate(row) if ch not in {'.','#'}}\n        key_cnt = sum(key_lock.islower() for key_lock in key_lock_loc)\n\n        def bfs_from(src):\n            i,j = key_lock_loc[src]\n            seen = [[False] *n for _ in range(m)]\n            seen[i][j] = True\n            # only locations which are not wall will be put into the queue\n            dque = deque([(i,j,0)]) \n            dist = {}\n            while dque:\n                i,j,d = dque.popleft()\n                ch = grid[i][j]\n                if ch != src and ch != '.': # reaches lock or key\n                    dist[ch] = d\n                    continue\n                # '#' or '.'\n                for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\n                    if not (0<=x<m and 0<=y<n) or grid[x][y] == '#' or seen[x][y]:\n                        continue\n                    seen[x][y] = True\n                    dque.append((x,y,d+1))\n            return dist\n        \n        dists = {key_lock:bfs_from(key_lock) for key_lock in key_lock_loc}\n        all_keys_bitmap = 2 ** key_cnt -1\n        \n        hq = [(0,'@',0)]\n        final_dist = defaultdict(lambda: float('inf'))\n        final_dist['@',0] = 0\n        while hq:\n            d,ch,keys_bitmap = heapq.heappop(hq)\n            if final_dist[ch,keys_bitmap] < d:\n                continue\n            if keys_bitmap == all_keys_bitmap:\n                return d\n            for next_key_lock, d2 in list(dists[ch].items()):\n                keys_bitmap2 = keys_bitmap\n                if next_key_lock.islower(): # key\n                    keys_bitmap2 |= (1 <<(ord(next_key_lock) - ord('a')))\n                elif next_key_lock.isupper(): # ch\n                    if not(keys_bitmap &(1 <<(ord(next_key_lock) - ord('A')))):\n                        continue\n                if d + d2 < final_dist[next_key_lock, keys_bitmap2]:\n                    final_dist[next_key_lock, keys_bitmap2]= d + d2\n                    heapq.heappush(hq,(d+d2,next_key_lock,keys_bitmap2))\n        return -1\n        \n                    \n", "class Solution:\n    def shortestPathAllKeys(self, grid):\n        m,n,k,keys,d=len(grid),len(grid[0]),0,'',set()\n        grid.append('#'*n)\n        for i in range(m): grid[i]+='#'\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]=='@': si,sj=i,j\n                elif grid[i][j] in 'abcdef': keys+=grid[i][j]\n        a,keyss=[(si,sj,keys)],''.join([c.upper() for c in keys])\n        while a:\n            b=[]\n            for i,j,keys in a:\n                keys = keys.replace(grid[i][j], '')# keys=''.join([c for c in keys if c!=grid[i][j]])\n                if not keys: return k\n                for ii,jj in (i,j+1),(i+1,j),(i,j-1),(i-1,j):\n                    if grid[ii][jj]!='#' and (not(grid[ii][jj] in keyss and grid[ii][jj].lower() in keys)) and ((ii,jj,keys) not in d):\n                        d.add((ii,jj,keys))\n                        b.append((ii,jj,keys))\n            a,k=b,k+1\n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid):\n        m,n,k,keys,d=len(grid),len(grid[0]),0,'',set()\n        grid.append('#'*n)\n        for i in range(m): grid[i]+='#'\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]=='@': si,sj=i,j\n                elif grid[i][j] in 'abcdef': keys+=grid[i][j]\n        a,keyss=[(si,sj,keys)],''.join([c.upper() for c in keys])\n        while a:\n            b=[]\n            for i,j,keys in a:\n                #if grid[i][j] in keys: keys = keys.replace(grid[i][j], '')# keys=''.join([c for c in keys if c!=grid[i][j]])\n                keys = keys.replace(grid[i][j], '')# keys=''.join([c for c in keys if c!=grid[i][j]])\n                if not keys: return k\n                for ii,jj in (i,j+1),(i+1,j),(i,j-1),(i-1,j):\n                    if grid[ii][jj]!='#' and (not(grid[ii][jj] in keyss and grid[ii][jj].lower() in keys)) and ((ii,jj,keys) not in d):\n                        d.add((ii,jj,keys))\n                        b.append((ii,jj,keys))\n            a,k=b,k+1\n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid):\n        m,n,k,keys,d=len(grid),len(grid[0]),0,'',set()\n        grid.append('#'*n)\n        for i in range(m): grid[i]+='#'\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]=='@': si,sj=i,j\n                elif grid[i][j] in 'abcdef': keys+=grid[i][j]\n        a,keyss=[(si,sj,keys)],''.join([c.upper() for c in keys])\n        while a:\n            b=[]\n            for i,j,keys in a:\n                if grid[i][j] in keys: keys = keys.replace(grid[i][j], '')# keys=''.join([c for c in keys if c!=grid[i][j]])\n                if not keys: return k\n                for ii,jj in (i,j+1),(i+1,j),(i,j-1),(i-1,j):\n                    if grid[ii][jj]!='#' and (not(grid[ii][jj] in keyss and grid[ii][jj].lower() in keys)) and ((ii,jj,keys) not in d):\n                        d.add((ii,jj,keys))\n                        b.append((ii,jj,keys))\n            a,k=b,k+1\n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m,n,k,keys,d=len(grid),len(grid[0]),0,'',set()\n        grid.append('#'*n)\n        for i in range(m): grid[i]+='#'\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]=='@': si,sj=i,j\n                elif grid[i][j] in 'abcdef': keys+=grid[i][j]\n        a,keyss=[(si,sj,keys)],''.join([c.upper() for c in keys])\n        while a:\n            b=[]\n            for i,j,keys in a:\n                if grid[i][j] in keys: keys=''.join([c for c in keys if c!=grid[i][j]])\n                if not keys: return k\n                for ii,jj in (i,j+1),(i+1,j),(i,j-1),(i-1,j):\n                    if grid[ii][jj]!='#' and (not(grid[ii][jj] in keyss and grid[ii][jj].lower() in keys)) and ((ii,jj,keys) not in d):\n                        d.add((ii,jj,keys))\n                        b.append((ii,jj,keys))\n            a,k=b,k+1\n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        def bfs(r, c):\n            start = grid[r][c]\n            dist[start] = {}\n            queue = collections.deque([(r, c, 0)])\n            visited = {(r, c): True}\n            while queue:\n                i, j, d = queue.pop()\n                if grid[i][j] not in ['.', '#', start]:\n                    dist[start][grid[i][j]] = d\n                    continue\n                for ic, jc in [[i+1, j], [i-1, j], [i, j+1], [i, j-1]]:\n                    if 0 <= ic < m and 0 <= jc < n and (ic, jc) not in visited and grid[ic][jc] != '#':\n                        visited[(ic, jc)] = True\n                        queue.appendleft((ic, jc, d + 1))\n        \n        m, n = len(grid), len(grid[0])\n        dist = {}\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] not in ['.', '#']:\n                    bfs(r, c)\n        \n        prioq = [(0, '@', 0)] # distance, place, state\n        target_state = 0\n        visited = {}\n        for key in dist:\n            if 'a' <= key <= 'f':\n                target_state += 1 << (ord(key) - ord('a'))\n                \n        while prioq:\n            d, p, state = heapq.heappop(prioq)\n            if (p, state) in visited: continue\n            if state == target_state: return d\n            visited[(p, state)] = True\n            for dest, moves in list(dist[p].items()):\n                if 'A' <= dest <= 'F' and 1 << (ord(dest) - ord('A')) & state == 0:\n                    continue\n                new_state = state\n                if 'a' <= dest <= 'f':\n                    new_state |= 1 << (ord(dest) - ord('a'))\n                if (dest, new_state) not in visited:\n                    heapq.heappush(prioq, (d + moves, dest, new_state))\n        return -1\n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        q = collections.deque()\n        keys = 0\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '@':\n                    q.append((i, j, 0))\n                    visited.add((i, j, 0))\n                elif grid[i][j] >= 'a' and grid[i][j] <= 'f':\n                    keys += 1\n        goal = (1 << keys) - 1\n        \n        dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n        step = 0\n        while q:\n            size = len(q)\n            for _ in range(size):\n                i, j, state = q.popleft()\n                for di, dj in dirs:\n                    x = i + di\n                    y = j + dj\n                    \n                    if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == '#' or (x, y, state) in visited:\n                        continue\n                    \n                    nstate = state\n                    if grid[x][y] >= 'A' and grid[x][y] <= 'F':\n                        temp = ord(grid[x][y]) - ord('A')\n                        if state & (1 << temp) == 0:\n                            continue\n                    elif grid[x][y] >= 'a' and grid[x][y] <= 'f':\n                        temp = ord(grid[x][y]) - ord('a')\n                        nstate |= 1 << temp\n                        if nstate == goal:\n                            return step + 1\n                        \n                    visited.add((x, y, nstate))\n                    q.append((x, y, nstate))\n                \n            step += 1\n        \n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        #30*30*2^6 =900*64--10^5 < 10^6\n        \n        init_x, init_y = -1, -1\n        m = len(grid)\n        n = len(grid[0])\n        keycnt = 0\n\n        for i in range(m):\n            for j in range(n):\n                c = grid[i][j]\n                if c == '@':\n                    init_x, init_y = i, j\n                if c >= 'a' and c <= 'f':\n                    keycnt +=1\n        \n        init_state = (0, init_x, init_y)\n        q = collections.deque()\n        visited = set()\n        visited.add(init_state)\n        q.append(init_state)\n        steps = -1 \n        finalkey = 0\n        \n    \n        for i in range(keycnt):\n            finalkey |= (1 << i) \n        \n        while q:\n            lens = len(q)\n            steps += 1\n            \n            for _ in range(len(q)):\n                keys, x, y = q.popleft()\n                for nx, ny in ((x+1, y), (x-1, y),(x, y+1), (x, y-1)):\n                    \n                    if 0 > nx or nx >= m or 0 > ny or ny >=n:\n                        continue\n                        \n                    new_s = keys\n                    c = grid[nx][ny]\n                    if c == '#':\n                        continue\n\n                    if c >= 'A' and c <= 'F' and ((keys >> (ord(c) - ord('A'))) & 1 == 0):\n                        continue\n\n                    if c >= 'a' and c <= 'f':\n                        new_s |=  (1 << (ord(c) - ord('a')))\n                    \n                    if (new_s, nx, ny) in visited:\n                        continue\n                    if new_s == finalkey:\n                        return steps + 1\n                \n                    visited.add((new_s, nx, ny))\n                    q.append((new_s, nx, ny))\n                \n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        if not grid:\n            return -1\n        keys=[0]*6\n        m,n=len(grid),len(grid[0])\n        si,sj=0,0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]=='@':\n                    si,sj=i,j\n                if grid[i][j].islower():\n                    keys[ord(grid[i][j])-ord('a')]=1\n        mykeys=tuple(keys)\n        \n        q=[(si,sj,tuple([0]*6))]\n        visited={(si,sj,tuple([0]*6))}\n        c=0\n        while q:\n            nextq=[]\n            for i,j,keys in q:\n                for x,y in ((i+1,j),(i-1,j),(i,j-1),(i,j+1)):\n                    if 0<=x<m and 0<=y<n and grid[x][y]!='#':\n                        if grid[x][y] in '.@':\n                            if (x,y,keys) not in visited:\n                                nextq.append((x,y,keys))\n                                visited.add((x,y,keys))\n                        elif grid[x][y].islower():\n                            okeys=list(keys)\n                            okeys[ord(grid[x][y])-ord('a')]=1\n                            nkeys=tuple(okeys)\n                            if nkeys==mykeys:\n                                return c+1\n                            else:\n                                if (x,y,nkeys) not in visited:\n                                    nextq.append((x,y,nkeys))\n                                    visited.add((x,y,nkeys))\n                        elif grid[x][y].isupper():\n                            if keys[ord(grid[x][y].lower())-ord('a')]==1 and (x,y,keys) not in visited:\n                                nextq.append((x,y,keys))\n                                visited.add((x,y,keys))\n            c+=1\n            q=nextq\n        return -1\n                            \n            \n            \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        keys = 'abcdef'\n        locks = 'ABCDEF'\n        n, m = len(grid), len(grid[0])\n        x, y = -1, -1\n        target = 0\n        for i in range(n):\n            for j in range(m):\n                ch = grid[i][j]\n                if ch == '@':\n                    x, y = i, j\n                elif ch in keys:\n                    idx = keys.find(ch)\n                    target |= (1<<idx)\n                \n        visited = set()\n        visited.add((x,y,0))\n        q = deque()\n        q.append((x,y,0,0))\n        while q:\n            x, y, state, move = q.popleft()\n            if state == target:\n                return move\n            for dx, dy in [[-1,0],[1,0],[0,-1],[0,1]]:\n                dx += x\n                dy += y\n                tmp = state\n                if dx < 0 or dy < 0 or dx >= n or dy >= m:\n                    continue\n                ch = grid[dx][dy]\n                if ch == '#':\n                    continue\n                \n                if ch in locks:\n                    idx = locks.find(ch)\n                    # print(dx,dy,ch,idx)\n                    if state & (1<<idx) == 0:\n                        continue\n                if ch in keys:\n                    idx = keys.find(ch)\n                    tmp |= (1<<idx)\n                if (dx,dy,tmp) not in visited:\n                    visited.add((dx,dy,tmp))\n                    q.append((dx,dy,tmp,move+1))\n        return -1\n\n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m, n = len(grid), len(grid[0])\n        \n        q = collections.deque()\n        seen = set()\n        tot_keys = 0\n        for i, row in enumerate(grid):\n            for j, val in enumerate(row):\n                if val == '@':\n                    q.append((i, j, 0))\n                    seen.add((i, j, 0))\n                elif val in 'ABCDEF':\n                    tot_keys += 1\n        steps = 0\n        while q:\n            N = len(q)\n            for _ in range(N):\n                x, y, keys = q.popleft()\n                if keys == (1 << tot_keys) - 1:\n                    return steps\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n                    if (0 <= nx < m and 0 <= ny < n):\n                        if grid[nx][ny] == '#': continue\n                        if grid[nx][ny] in 'ABCDEF' and not (keys >> ord(grid[nx][ny]) - ord('A')) & 1:\n                            continue\n                        nxt = keys\n                        if grid[nx][ny] in 'abcdef':\n                            nxt |= (1 << ord(grid[nx][ny]) - ord('a'))\n                        if (nx, ny, nxt) not in seen:\n                            seen.add((nx, ny, nxt))\n                            q.append((nx, ny, nxt))\n            steps += 1\n        return -1    \n                        \n                            \n        \n", "from collections import deque\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        ## BFS search\n        dirs = [[0,1],[0,-1],[1,0],[-1,0]]\n        m = len(grid)\n        n = len(grid[0])\n        visited = set()\n        q = deque()\n        cnt = 0\n        ## find the starting point and count how many keys are there\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '@':\n                    q.append((i, j, 0))\n                    visited.add((i, j, 0))\n                elif grid[i][j] in 'abcdef':\n                    cnt += 1\n                    \n        keys = set('abcdef')\n        locks = set('ABCDEF')\n        ## use bit mask to represent how many keys we have\n        ## the target is to collect all keys, i.e, 2**(cnt)-1\n        target = 2**(cnt)-1\n        steps = 0\n        while len(q)>0:\n            q_sz = len(q)\n            for _ in range(q_sz):\n                x, y, cur_keys = q.popleft()\n                if cur_keys == target:\n                    return steps\n                for d in dirs:\n                    next_x, next_y = x+d[0], y+d[1]\n                    pos_flag = False ## mark if the next position is legal\n                    if 0<=next_x<m and 0<=next_y<n and grid[next_x][next_y] != '#':\n                        new_keys = cur_keys\n                        ## if the next position is a lock:\n                        ## we must have its corresponding key to make a legal\n                        ## otherwise, cannot reach next position\n                        if grid[next_x][next_y] in locks:\n                            lock = ord(grid[next_x][next_y]) - ord('A')\n                            if (1<<lock) & cur_keys != 0:\n                                pos_flag = True\n                        ## if the next position is a key\n                        elif grid[next_x][next_y] in keys:\n                            key = ord(grid[next_x][next_y]) - ord('a')\n                            new_keys = cur_keys | (1<<key) ## collect the key\n                            pos_flag = True\n                        else: ## the next position is '.'\n                            pos_flag = True\n                        ## only when the next position is legal\n                        ## and we have not reach there with current keys,\n                        ## we will reach there and search \n                        if pos_flag and (next_x, next_y, new_keys) not in visited:\n                            visited.add((next_x, next_y, new_keys))\n                            q.append((next_x, next_y, new_keys))\n            steps += 1\n        return -1", "from collections import deque\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        dirs = [[0,1],[0,-1],[1,0],[-1,0]]\n        m = len(grid)\n        n = len(grid[0])\n        visited = set()\n        q = deque()\n        cnt = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '@':\n                    q.append((i, j, 0))\n                    visited.add((i, j, 0))\n                elif grid[i][j] in 'abcdef':\n                    cnt += 1\n                    \n        keys = set('abcdef')\n        locks = set('ABCDEF')\n        target = 2**(cnt)-1\n        steps = 0\n        while len(q)>0:\n        # for _ in range(3):\n            q_sz = len(q)\n            for _ in range(q_sz):\n                x, y, cur_keys = q.popleft()\n                # print(\\\"steps\\\", steps, \\\":\\\", x, y, cur_keys)\n                if cur_keys == target:\n                    return steps\n                for d in dirs:\n                    next_x, next_y = x+d[0], y+d[1]\n                    pos_flag = False\n                    if 0<=next_x<m and 0<=next_y<n and grid[next_x][next_y] != '#':\n                        new_keys = cur_keys\n                        if grid[next_x][next_y] in locks:\n                            lock = ord(grid[next_x][next_y]) - ord('A')\n                            if (1<<lock) & cur_keys != 0:\n                                pos_flag = True\n                        elif grid[next_x][next_y] in keys:\n                            key = ord(grid[next_x][next_y]) - ord('a')\n                            new_keys = cur_keys | (1<<key)\n                            pos_flag = True\n                        else:\n                            pos_flag = True\n                            \n                        if pos_flag and (next_x, next_y, new_keys) not in visited:\n                            # print(\\\"steps\\\", steps, \\\":\\\", next_x, next_y, cur_keys)\n                            visited.add((next_x, next_y, new_keys))\n                            q.append((next_x, next_y, new_keys))\n            steps += 1\n        return -1\n# [\\\"@.a.#\\\",\\\"###.#\\\",\\\"b.A.B\\\"]\n# [\\\"@..aA\\\",\\\"..B#.\\\",\\\"....b\\\"]\n", "from collections import defaultdict, deque\nimport heapq\n\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        ord_a = ord('a')\n        ord_A = ord('A')\n        m,n = len(grid), len(grid[0])\n        key_lock_loc = {ch:(i,j) for i,row in enumerate(grid) for j,ch in enumerate(row) if ch not in '.#'}\n        key_cnt = sum(ch.islower() for ch in key_lock_loc)\n        \n        def dfs_from(src):\n            i,j  = key_lock_loc[src]\n            dque = deque([(i,j,0)])\n            seen = defaultdict(lambda: False)\n            seen[i,j] = True\n            dist = {}\n            while dque:\n                i,j,d = dque.popleft()\n                ch = grid[i][j]\n                if ch != src and ch!= '.':\n                    dist[ch] = d\n                    continue\n                for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\n                    if not (0<=x<m and 0<=y<n) or grid[x][y]=='#' or seen[x,y]:\n                        continue\n                    dque.append((x,y,d+1))\n                    seen[x,y] = True\n            return dist\n    \n        dists = {ch:dfs_from(ch) for ch in key_lock_loc}\n        final_dist = defaultdict(lambda: float('inf'))\n        hq = [(0,'@',0)] # distance, ch, state\n        final_state = 2**key_cnt - 1\n        \n        while hq:\n            d, ch, state = heapq.heappop(hq)\n            if d > final_dist[ch,state]:\n                continue\n            if state == final_state:\n                return d\n            for ch1,d1 in list(dists[ch].items()):\n                state1 = state\n                if ch1.islower():\n                    state1 |= 1<< (ord(ch1)-ord_a)\n                elif ch1.isupper():\n                    if not (state1 &1<< (ord(ch1)-ord_A)):\n                        continue\n                if d + d1 < final_dist[ch1,state1]:\n                    final_dist[ch1,state1] = d + d1\n                    heapq.heappush(hq,(d+d1, ch1, state1))\n        return -1\n        \n            \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        if not grid:\n            return -1\n        m, n = len(grid), len(grid[0])\n        numKeys = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '@':\n                    start = (i, j, 0)\n                elif ord('a') <= ord(grid[i][j]) <= ord('f'):\n                    numKeys += 1\n        bfs = [start]\n        seen = set()\n        d = [1, 0, -1, 0, 1]\n        step = 0\n        while bfs:\n            cur, bfs = bfs, []\n            for x, y, keys in cur:\n                # print(len(keys))\n                if keys == (1 << numKeys) - 1:\n                    return step\n                # print(x, y, keys, locks)\n                for i in range(4):\n                    xx, yy = x + d[i], y + d[i+1]\n                    if 0 <= xx < m and 0 <= yy < n and (xx, yy, keys) not in seen:\n                        seen.add((xx, yy, keys))\n                        if ord('a') <= ord(grid[xx][yy]) <= ord('f'):\n                            bfs.append((xx, yy, keys | (1 << (ord(grid[xx][yy]) - ord('a')))))\n                        elif ord('A') <= ord(grid[xx][yy]) <= ord('F'):\n                            if (1 << (ord(grid[xx][yy].lower()) - ord('a'))) & keys == 0:\n                                continue\n                            else:\n                                bfs.append((xx, yy, keys))\n                            # bfs.append((xx, yy, keys, locks | (1 << (ord(grid[xx][yy]) - ord('A')))))\n                        elif grid[xx][yy] == '.' or grid[xx][yy] == '@':\n                            bfs.append((xx, yy, keys))\n            step += 1\n            \n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        mx_key = max(grid[i][j] for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j].isalpha() and grid[i][j].islower())\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]=='@':\n                    si,sj = i,j\n                    break\n        needed_keys = (1<<(ord(mx_key)-ord('a')+1))-1\n        def key_id(c):\n            if c.isupper():\n                return ord(c)-ord('A'), True\n            return ord(c)-ord('a'), False # id, upper\n        seen = {(si,sj,0)}\n        q = deque([(0,si,sj,0)]) #cost,i,j,keys\n        while q:\n            cost,i,j,keys=q.popleft()\n            if keys==needed_keys:\n                return cost\n            for ni,nj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\n                if not 0<=ni<len(grid) or not 0<=nj<len(grid[0]) or grid[ni][nj]=='#':\n                    continue\n                # get new keys bitset\n                new_keys = keys\n                if grid[ni][nj].isalpha():\n                    idx,capped = key_id(grid[ni][nj])\n                    if capped:\n                        if not keys&(1<<idx):\n                            continue # cant enter a door we dont have a key to\n                    else:\n                        new_keys|=1<<idx\n                if (ni,nj,new_keys) in seen:\n                    continue\n                seen.add((ni,nj,new_keys))\n                q.append((cost+1,ni,nj,new_keys))\n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        if not grid or not grid[0]:\n            return -1\n        m, n = len(grid), len(grid[0])\n        sx = sy = target = -1\n        for i in range(m):\n            for j in range(n):\n                c = grid[i][j]\n                if c == '@':\n                    sx, sy = i, j\n                if c >= 'a' and c <= 'f':\n                    target = max(target, ord(c)-ord('a')+1)\n        target = (1 << target) - 1\n        q = deque([(sx, sy, 0)])\n        visited = set()\n        visited.add(q[0])\n        step = 0\n        while q:\n            for _ in range(len(q)):\n                x, y, key = q.popleft()\n                if key == target:\n                    return step\n                for i, j in [[0, 1], [1, 0], [0, -1], [-1, 0]]:\n                    if x+i >= 0 and x+i < m and y+j >= 0 and y+j < n:\n                        c = grid[x+i][y+j]\n                        new_key = key\n                        if c == '#':\n                            continue\n                        if c >= 'A' and c <= 'F' and (key >> (ord(c)-ord('A')) & 1 == 0):\n                            continue\n                        if c >='a' and c <= 'f':\n                            new_key |= 1 << (ord(c)-ord('a'))\n                        if (x+i, y+j, new_key) not in visited:\n                            visited.add((x+i, y+j, new_key))\n                            q.append((x+i, y+j, new_key))\n            step += 1\n        return -1\n                \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        import heapq\n        import collections\n        R, C = len(grid), len(grid[0])\n\n        # The points of interest\n        location = {v: (r, c)\n                    for r, row in enumerate(grid)\n                    for c, v in enumerate(row)\n                    if v not in '.#'}\n\n        def neighbors(r, c):\n            for cr, cc in ((r - 1, c), (r, c - 1), (r + 1, c), (r, c + 1)):\n                if 0 <= cr < R and 0 <= cc < C:\n                    yield cr, cc\n\n        # The distance from source to each point of interest\n        def bfs_from(source):\n            r, c = location[source]\n            seen = [[False] * C for _ in range(R)]\n            seen[r][c] = True\n            queue = collections.deque([(r, c, 0)])\n            dist = {}\n            while queue:\n                r, c, d = queue.popleft()\n                if source != grid[r][c] != '.':\n                    dist[grid[r][c]] = d\n                    continue  # Stop walking from here if we reach a point of interest\n                for cr, cc in neighbors(r, c):\n                    if grid[cr][cc] != '#' and not seen[cr][cc]:\n                        seen[cr][cc] = True\n                        queue.append((cr, cc, d + 1))\n            return dist\n\n        dists = {place: bfs_from(place) for place in location}\n        target_state = 2 ** sum(p.islower() for p in location) - 1\n\n        # Dijkstra\n        pq = [(0, '@', 0)]\n        final_dist = collections.defaultdict(lambda: float('inf'))\n        final_dist['@', 0] = 0\n        while pq:\n            d, place, state = heapq.heappop(pq)\n            if final_dist[place, state] < d: continue\n            if state == target_state: return d\n            for destination, d2 in dists[place].items():\n                state2 = state\n                if destination.islower():  # key\n                    state2 |= (1 << (ord(destination) - ord('a')))\n                elif destination.isupper():  # lock\n                    if not (state & (1 << (ord(destination) - ord('A')))):  # no key\n                        continue\n\n                if d + d2 < final_dist[destination, state2]:\n                    final_dist[destination, state2] = d + d2\n                    heapq.heappush(pq, (d + d2, destination, state2))\n\n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        # bfs: x,y, ownkeys -> n*m* 2^6\n        \n        def have_keys(status, key_id):\n            return status & (2**key_id)\n        \n        sx, sy = -1, -1\n        key_number = 0\n        key_idx = 'abcdef'\n        lock_idx = 'ABCDEF'\n        n, m = len(grid), len(grid[0])\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '@':\n                    sx, sy = i, j\n                elif grid[i][j] in key_idx:\n                    key_number = max(key_number, key_idx.find(grid[i][j]))\n        #print(sx, sy)\n        #print(key_number)\n        # bfs: (x, y, ownkeys)\n        final_ownkey = 2 ** (key_number+1) - 1\n        head, queue = 0, [(sx, sy, 0)]\n        moves = [(0,1), (0,-1), (1,0), (-1,0)]\n        \n        visited = {(sx, sy, 0): 0}\n        \n        while head < len(queue):\n            x, y, status = queue[head]\n            step = visited[queue[head]]\n            #print(x, y, status)\n            #print(step)\n            for dx, dy in moves:\n                tx, ty, new_status = x + dx, y + dy, status\n                if n > tx >= 0 and m > ty >=0:\n                    # wall?\n                    if grid[tx][ty] == '#':\n                        continue\n                        \n                    # locked\n                    if grid[tx][ty] in lock_idx and not have_keys(new_status, lock_idx.find(grid[tx][ty])):\n                        continue\n                        \n                    # first time pick up key\n                    if grid[tx][ty] in key_idx and not have_keys(new_status, key_idx.find(grid[tx][ty])):\n                        new_status += 2 ** key_idx.find(grid[tx][ty])\n                    \n                    if new_status == final_ownkey:\n                        return step + 1\n                    \n                    if (tx, ty, new_status) not in visited:\n                        queue.append((tx, ty, new_status))\n                        visited[(tx, ty, new_status)] = step + 1\n            #print(queue)\n            head += 1\n            \n        return -1\n            \n        \n            \n        \n        \n        \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        if not grid or not grid[0]:\n            return -1\n        m, n = len(grid), len(grid[0])\n        sx = sy = target = -1\n        for i in range(m):\n            for j in range(n):\n                c = grid[i][j]\n                if c == '@':\n                    sx, sy = i, j\n                if c >= 'a' and c <= 'f':\n                    target = max(target, ord(c)-ord('a')+1)\n        print((target, ))\n        target = (1 << target) - 1\n        print(target)\n        q = deque([(sx, sy, 0)])\n        visited = set()\n        visited.add(q[0])\n        step = 0\n        while q:\n            print(q)\n            for _ in range(len(q)):\n                x, y, key = q.popleft()\n                if key == target:\n                    return step\n                for i, j in [[0, 1], [1, 0], [0, -1], [-1, 0]]:\n                    if x+i >= 0 and x+i < m and y+j >= 0 and y+j < n:\n                        c = grid[x+i][y+j]\n                        new_key = key\n                        if c == '#':\n                            continue\n                        if c >= 'A' and c <= 'F' and (key >> (ord(c)-ord('A')) & 1 == 0):\n                            continue\n                        if c >='a' and c <= 'f':\n                            new_key |= 1 << (ord(c)-ord('a'))\n                        if (x+i, y+j, new_key) not in visited:\n                            visited.add((x+i, y+j, new_key))\n                            q.append((x+i, y+j, new_key))\n            step += 1\n        return -1\n                \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        def contains(k, v):\n            return (k // v) % 2 == 1\n            \n        adjs = [[-1, 0], [0, 1], [0, -1], [1, 0]]\n        keys = ['a', 'b', 'c', 'd', 'e', 'f']\n        locks = [c.upper() for c in keys]\n        key_to_val = {k: 2**i for i, k in enumerate(keys)}\n        lock_to_val = {k: 2**i for i, k in enumerate(locks)}\n        N, M = len(grid), len(grid[0])\n        visited = [[[-1]*64 for _ in range(M)] for _ in range(N)]\n        \n        queue = deque()\n        target = 0\n        for i in range(N):\n            for j in range(M):\n                if grid[i][j] == '@': \n                    queue.append([i, j, 0])\n                    visited[i][j][0] = 0\n                if grid[i][j] in keys: target += key_to_val[grid[i][j]]\n        if target == 0: return 0\n        \n        while len(queue) > 0:\n            i, j, k = queue.popleft()\n            for di, dj in adjs:\n                ii, jj = i + di, j + dj\n                if ii >= 0 and jj >= 0 and ii < N and jj < M:\n                    if grid[ii][jj] in ('.', '@') and visited[ii][jj][k] < 0:\n                        visited[ii][jj][k] = visited[i][j][k] + 1\n                        queue.append((ii, jj, k))\n                    elif grid[ii][jj] in keys:\n                        if not contains(k, key_to_val[grid[ii][jj]]):\n                            kk = k + key_to_val[grid[ii][jj]]\n                            if kk == target: return visited[i][j][k] + 1\n                        else:\n                            kk = k\n                        if visited[ii][jj][kk] < 0:\n                            visited[ii][jj][kk] = visited[i][j][k] + 1\n                            queue.append((ii, jj, kk))\n                    elif grid[ii][jj] in locks and contains(k, lock_to_val[grid[ii][jj]]) and visited[ii][jj][k] < 0:\n                        visited[ii][jj][k] = visited[i][j][k] + 1\n                        queue.append((ii, jj, k))\n        return -1\n                            \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        res,dire,all_keys = 0, [[0,1],[1,0],[0,-1],[-1,0]],0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '@': loc = (i,j)\n                if grid[i][j] in 'abcdef': all_keys += 1\n        cur, seen= set([(loc,())]), set([(loc,())])\n        def checker(loc,keys,di):\n            x,y = loc[0] + di[0], loc[1] + di[1]\n            if 0<=x < len(grid) and 0<= y < len(grid[0]):\n                t = grid[x][y]\n                if t in '@.' or (t in keys) or (t in 'ABCDEF' and str.lower(t) in keys): return ((x,y),keys), False\n                if t in 'abcdef': \n                        newkeys = tuple(sorted(set(list(keys) + [t])))\n                        if len(newkeys) == all_keys: return True, True\n                        return ((x,y),newkeys), False\n            return False, False\n        while cur:\n            res,tmp = res + 1, []\n            for node in cur:\n                loc, keys = node\n                for di in dire:\n                    new_node,state = checker(loc,keys,di)\n                    if state: return res\n                    if new_node not in seen and new_node: tmp += [new_node]\n            cur = set(tmp)\n            seen |= cur\n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        R, C = len(grid), len(grid[0])\n\n        # The points of interest\n        location = {v: (r, c)\n                    for r, row in enumerate(grid)\n                    for c, v in enumerate(row)\n                    if v not in '.#'}\n\n        def neighbors(r, c):\n            for cr, cc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):\n                if 0 <= cr < R and 0 <= cc < C:\n                    yield cr, cc\n\n        # The distance from source to each point of interest\n        def bfs_from(source):\n            r, c = location[source]\n            seen = [[False] * C for _ in range(R)]\n            seen[r][c] = True\n            queue = collections.deque([(r, c, 0)])\n            dist = {}\n            while queue:\n                r, c, d = queue.popleft()\n                if source != grid[r][c] != '.':\n                    dist[grid[r][c]] = d\n                    continue # Stop walking from here if we reach a point of interest\n                for cr, cc in neighbors(r, c):\n                    if grid[cr][cc] != '#' and not seen[cr][cc]:\n                        seen[cr][cc] = True\n                        queue.append((cr, cc, d+1))\n            return dist        \n\n        dists = {place: bfs_from(place) for place in location}\n        target_state = 2 ** sum(p.islower() for p in location) - 1\n\n        #Dijkstra\n        pq = [(0, '@', 0)]\n        final_dist = collections.defaultdict(lambda: float('inf'))\n        final_dist['@', 0] = 0\n        while pq:\n            d, place, state = heapq.heappop(pq)\n            if final_dist[place, state] < d: continue\n            if state == target_state: return d\n            for destination, d2 in dists[place].items():\n                state2 = state\n                if destination.islower(): #key\n                    state2 |= (1 << (ord(destination) - ord('a')))\n                elif destination.isupper(): #lock\n                    if not(state & (1 << (ord(destination) - ord('A')))): #no key\n                        continue\n\n                if d + d2 < final_dist[destination, state2]:\n                    final_dist[destination, state2] = d + d2\n                    heapq.heappush(pq, (d+d2, destination, state2))\n\n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        from collections import deque\n        start = [0,0]\n        numofKeys = 0\n        m = len(grid)\n        n = len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '@':\n                    start = [i,j]\n                if grid[i][j].isalpha():\n                    numofKeys += 1\n        numofKeys //= 2\n        keys = 0\n        visited = set()\n        stack = deque([[start[0],start[1], 0, 0]])\n        while stack:\n            #print(stack)\n            i, j, keys, count = stack.popleft()\n            for a, b in (i+1, j), (i-1, j), (i, j+1), (i, j-1):\n                if 0<=a<m and 0<=b<n:\n                    if grid[a][b].isalpha() and ord('a')<=ord(grid[a][b])<=ord('f'):\n                        newkeys = keys|(1<<(ord(grid[a][b])-ord('a')))\n                    elif grid[a][b].isalpha() and keys&(1<<(ord(grid[a][b])-ord('A'))):\n                        newkeys = keys\n                    elif grid[a][b].isalpha() or grid[a][b] == '#':\n                        continue\n                    else:\n                        newkeys = keys\n                    \n                    if newkeys == 2**numofKeys-1:\n                        return count+1\n                    elif (a,b,newkeys) in visited:\n                        continue\n                    else:\n                        visited.add((a,b,newkeys))\n                        stack.append((a,b,newkeys, count+1))\n        return -1\n                            \n                        \n", "class Solution:\n    def shortestPathAllKeys(self, grid) -> int:\n        row,col = len(grid),len(grid[0])\n        key_num,key = 0,{}\n        for i in range(row):\n            for j in range(col):\n                if grid[i][j]=='@': start_i,start_j=i,j\n                if grid[i][j] in 'abcdef' and grid[i][j] not in key:\n                    key[grid[i][j]]=key_num\n                    key_num+=1\n        q = [(start_i,start_j,0,0)]\n        visited = set()\n        while q:\n            l = len(q)\n            for _ in range(l):\n                i,j,state,step = q.pop(0)\n                if state==(1<<key_num)-1: return step\n                if (i,j,state) in visited: continue\n                visited.add((i,j,state))\n                for m,n in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\n                    if 0<=m<row and 0<=n<col and grid[m][n]!='#':\n                        if grid[m][n] in 'abcdef':\n                            q.append((m,n,state|(1<<key[grid[m][n]]),step+1))\n                        elif grid[m][n] == '.' or grid[m][n] =='@':\n                            q.append((m,n,state,step+1))\n                        elif grid[m][n] in 'ABCDEF':\n                            if (state>>key[grid[m][n].lower()])&1==0: continue\n                            q.append((m,n,state,step+1))\n        return -1\n                     \n                        \n            \n                    \n                \n\n        \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        R, C = len(grid), len(grid[0])\n        ii, jj =0 ,0 \n        target = 0\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j]=='@':\n                    ii, jj = i, j\n                if grid[i][j].islower():\n                    target+=1\n        def bfs(i, j):\n            from collections import deque\n            Q = deque([(i,j, 0 ,set())])\n            seen = {(i,j,tuple(sorted(set())))}\n            while Q:\n                i,j, d, s = Q.popleft()\n                for di, dj in [(0,1),(1,0),(0,-1),(-1,0)]:\n                    r, c = i+di, j+dj\n                    if 0<=r<R and 0<=c<C:\n                        if grid[r][c].islower():\n                            #s1 = s\n                            s1 =  s.copy()\n                            s1.add(grid[r][c])\n                            if len(s1)==target:return d+1\n                            tuple_s = tuple(sorted(set(s1)))\n                            if (r,c,tuple_s) not in seen:\n                                seen.add((r,c,tuple_s))\n                                Q.append((r,c, d+1,s1))\n                        elif grid[r][c].isupper():\n                            if grid[r][c].lower() in s:\n                                tuple_s = tuple(sorted(set(s)))\n                                if (r,c,tuple_s) not in seen:\n                                    seen.add((r,c,tuple_s))\n                                    Q.append((r,c,  d+1, s))\n                        elif grid[r][c]!='#':\n                            tuple_s = tuple(sorted(set(s)))\n                            if (r,c,tuple_s) not in seen:\n                                seen.add((r,c,tuple_s))\n                                Q.append((r,c, d+1, s))\n            return -1\n        return bfs(ii,jj)", "from collections import defaultdict, deque\nimport heapq, itertools\n\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        # Brute Force + Permutations\n        # Time  complexity: O(R x C x A x A!), where R, C are the dimensions of the grid,\n        # and A is the maximum number of keys.\n        # Space compleixty: O(R x C + A!)\n        # R, C = map(len, (grid, grid[0]))\n        # location = {v: (r, c)\n        #             for r, row in enumerate(grid)\n        #             for c, v in enumerate(row)\n        #             if v not in '.#'}\n\n        # def neighbors(r, c):\n        #     for cr, cc in (r - 1, c), (r, c - 1), (r + 1, c), (r, c + 1):\n        #         if 0 <= cr < R and 0 <= cc < C:\n        #             yield cr, cc\n\n        # def bfs(source, target, keys=()):\n        #     sr, sc = location[source]\n        #     tr, tc = location[target]\n        #     seen = [[False] * C for _ in range(R)]\n        #     seen[sr][sc] = True\n        #     queue = deque([(sr, sc, 0)])\n        #     while queue:\n        #         r, c, d = queue.popleft()\n        #         if r == tr and c == tc: return d\n        #         for cr, cc in neighbors(r, c):\n        #             if not seen[cr][cc] and grid[cr][cc] != '#':\n        #                 if grid[cr][cc].isupper() and grid[cr][cc].lower() not in keys:\n        #                     continue\n        #                 queue.append((cr, cc, d + 1))\n        #                 seen[cr][cc] = True\n        #     return float(\\\"inf\\\")\n\n        # ans = float(\\\"inf\\\")\n        # keys = \\\"\\\".join(chr(ord('a') + i) for i in range(len(location) // 2))\n        # for cand in itertools.permutations(keys):\n        #     bns = 0\n        #     for i, target in enumerate(cand):\n        #         source = cand[i - 1] if i > 0 else '@'\n        #         d = bfs(source, target, cand[:i])\n        #         bns += d\n        #         if bns >= ans: break\n        #     else:\n        #         ans = bns\n\n        # return ans if ans < float(\\\"inf\\\") else -1\n\n\n\n        # Points of Interest + Dijkstra\n        # Time  complexity: O(RC(2A + 1) + ElogN), where R, C are the dimensions of the grid, \n        # and A is the maximum number of keys, N = (2A + 1) x 2^A is the number of nodes when we\n        # perform Dijkstra's, and E = N x (2A + 1) is the maximum number of edges.\n        # Space complexity: ON(N)\n        R, C = len(grid), len(grid[0])\n\n        # The points of interest\n        location = {v: (r, c)\n                    for r, row in enumerate(grid)\n                    for c, v in enumerate(row)\n                    if v not in '.#'}\n\n        def neighbors(r, c):\n            for cr, cc in (r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1):\n                if 0 <= cr < R and 0 <= cc < C:\n                    yield cr, cc\n\n        # The distance from source to each point of interest\n        def bfs_from(source):\n            r, c = location[source]\n            seen = [[False] * C for _ in range(R)]\n            seen[r][c] = True\n            queue = deque([(r, c, 0)])\n            dist = {}\n            while queue:\n                r, c, d = queue.popleft()\n                if source != grid[r][c] != '.':\n                    dist[grid[r][c]] = d\n                    continue # Stop walking from here if we reach a point of interest\n                for cr, cc in neighbors(r, c):\n                    if grid[cr][cc] != '#' and not seen[cr][cc]:\n                        seen[cr][cc] = True\n                        queue.append((cr, cc, d+1))\n            return dist        \n\n        dists = {place: bfs_from(place) for place in location}\n        target_state = 2 ** sum(p.islower() for p in location) - 1\n\n        #Dijkstra\n        pq = [(0, '@', 0)]\n        final_dist = defaultdict(lambda: float('inf'))\n        final_dist['@', 0] = 0\n        while pq:\n            d, place, state = heapq.heappop(pq)\n            if final_dist[place, state] < d: continue\n            if state == target_state: return d\n            for destination, d2 in list(dists[place].items()):\n                state2 = state\n                if destination.islower(): #key\n                    state2 |= 1 << ord(destination) - ord('a')\n                elif destination.isupper(): #lock\n                    if not(state & (1 << ord(destination) - ord('A'))): #no key\n                        continue\n\n                if d + d2 < final_dist[destination, state2]:\n                    final_dist[destination, state2] = d + d2\n                    heapq.heappush(pq, (d+d2, destination, state2))\n\n        return -1\n", "class Solution:\n    def __init__(self):\n        self.DIR = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        init_x = init_y = -1\n        target_keys = 0\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '@':\n                    init_x, init_y = i, j\n                elif grid[i][j].islower():\n                    target_keys |= 1 << (ord(grid[i][j]) - ord('a'))\n\n        pq = [(0, 0, init_x, init_y)]\n        visited = set((0, init_x, init_y))\n\n        while pq:\n            curr_steps, curr_keys, x, y = heapq.heappop(pq)\n\n            if curr_keys == target_keys:\n                return curr_steps\n\n            for delta_x, delta_y in self.DIR:\n                next_x, next_y = x + delta_x, y + delta_y\n\n                if not self.inbound(grid, next_x, next_y) or grid[next_x][next_y] == '#':\n                    continue\n\n                if grid[next_x][next_y].isupper():\n                    if (curr_keys >> (ord(grid[next_x][next_y]) - ord('A'))) & 1:\n                        next_keys = curr_keys\n                    else:\n                        continue\n                elif grid[next_x][next_y].islower():\n                    next_keys = curr_keys | (1 << (ord(grid[next_x][next_y]) - ord('a')))\n                else: # the next location is @ or .\n                    next_keys = curr_keys\n\n                if (next_keys, next_x, next_y) in visited:\n                    continue\n\n                heapq.heappush(pq, (curr_steps + 1, next_keys, next_x, next_y))\n                visited.add((next_keys, next_x, next_y))\n\n        return -1\n\n    def inbound(self, grid, x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0])", "from collections import deque\ndirs = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        k = 0\n        m, n = len(grid), len(grid[0])\n        sr, sc = None, None\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] == '@':\n                    sr, sc = r, c\n                elif grid[r][c] in 'abcdefABCDEF':\n                    k = max(k, ord(grid[r][c].lower()) - ord('a') + 1)\n        dp = [[[float('inf') for z in range(1 << k)] for y in range(n)] for x in range(m)]\n        dp[sr][sc][0] = 0\n        dq = deque([(sr, sc, 0, 0)])\n        while dq:\n            size = len(dq)\n            for i in range(size):\n                r, c, ks, s = dq.popleft() # key state, step\n                for d in dirs:\n                    nr, nc = r + d[0], c + d[1]\n                    if not (0 <= nr < m) or not (0 <= nc < n):\n                        continue\n                    elif grid[nr][nc] == '#':\n                        continue\n                    elif grid[nr][nc] in '.@': # empty cell or starting point\n                        if s + 1 < dp[nr][nc][ks]:\n                            dp[nr][nc][ks] = s + 1\n                            dq.append((nr, nc, ks, s + 1))\n                    elif grid[nr][nc] in 'ABCDEF':\n                        lock = ord(grid[nr][nc]) - ord('A')\n                        if ks & (1 << lock):\n                            if s + 1 < dp[nr][nc][ks]:\n                                dp[nr][nc][ks] = s + 1\n                                dq.append((nr, nc, ks, s + 1))\n                    elif grid[nr][nc] in 'abcdef':\n                        key = ord(grid[nr][nc]) - ord('a')\n                        nks = ks | (1 << key)\n                        if s + 1 < dp[nr][nc][nks]:\n                            dp[nr][nc][nks] = s + 1\n                            dq.append((nr, nc, nks, s + 1))\n        ret = float('inf')\n        for r in range(m):\n            for c in range(n):\n                ret = min(ret, dp[r][c][-1])\n        return ret if ret != float('inf') else -1\n                \n", "from collections import defaultdict, deque\nimport heapq, itertools\n\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        # Brute Force + Permutations\n        # Time  complexity: O(R x C x A x A!), where R, C are the dimensions of the grid,\n        # and A is the maximum number of keys.\n        # Space compleixty: O(R x C + A!)\n        # R, C = map(len, (grid, grid[0]))\n        # location = {v: (r, c)\n        #             for r, row in enumerate(grid)\n        #             for c, v in enumerate(row)\n        #             if v not in '.#'}\n\n        # def neighbors(r, c):\n        #     for cr, cc in (r - 1, c), (r, c - 1), (r + 1, c), (r, c + 1):\n        #         if 0 <= cr < R and 0 <= cc < C:\n        #             yield cr, cc\n\n        # def bfs(source, target, keys=()):\n        #     sr, sc = location[source]\n        #     tr, tc = location[target]\n        #     seen = [[False] * C for _ in range(R)]\n        #     seen[sr][sc] = True\n        #     queue = deque([(sr, sc, 0)])\n        #     while queue:\n        #         r, c, d = queue.popleft()\n        #         if r == tr and c == tc: return d\n        #         for cr, cc in neighbors(r, c):\n        #             if not seen[cr][cc] and grid[cr][cc] != '#':\n        #                 if grid[cr][cc].isupper() and grid[cr][cc].lower() not in keys:\n        #                     continue\n        #                 queue.append((cr, cc, d + 1))\n        #                 seen[cr][cc] = True\n        #     return float(\\\"inf\\\")\n\n        # ans = float(\\\"inf\\\")\n        # keys = \\\"\\\".join(chr(ord('a') + i) for i in range(len(location) // 2))\n        # for cand in itertools.permutations(keys):\n        #     bns = 0\n        #     for i, target in enumerate(cand):\n        #         source = cand[i - 1] if i > 0 else '@'\n        #         d = bfs(source, target, cand[:i])\n        #         bns += d\n        #         if bns >= ans: break\n        #     else:\n        #         ans = bns\n\n        # return ans if ans < float(\\\"inf\\\") else -1\n\n\n\n        # Points of Interest + Dijkstra\n        # Time  complexity: O(RC(2A + 1) + ElogN), where R, C are the dimensions of the grid, \n        # and A is the maximum number of keys, N = (2A + 1) x 2^A is the number of nodes when we\n        # perform Dijkstra's, and E = N x (2A + 1) is the maximum number of edges.\n        # Space complexity: ON(N)\n        R, C = len(grid), len(grid[0])\n\n        # The points of interest\n        location = {v: (r, c)\n                    for r, row in enumerate(grid)\n                    for c, v in enumerate(row)\n                    if v not in '.#'}\n\n        def neighbors(r, c):\n            for cr, cc in (r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1):\n                if 0 <= cr < R and 0 <= cc < C:\n                    yield cr, cc\n\n        # The distance from source to each point of interest\n        def bfs_from(source):\n            r, c = location[source]\n            seen = [[False] * C for _ in range(R)]\n            seen[r][c] = True\n            queue = deque([(r, c, 0)])\n            dist = {}\n            while queue:\n                r, c, d = queue.popleft()\n                if source != grid[r][c] != '.':\n                    dist[grid[r][c]] = d\n                    continue # Stop walking from here if we reach a point of interest\n                for cr, cc in neighbors(r, c):\n                    if grid[cr][cc] != '#' and not seen[cr][cc]:\n                        seen[cr][cc] = True\n                        queue.append((cr, cc, d + 1))\n            return dist        \n\n        dists = {place: bfs_from(place) for place in location}\n        target_state = 2 ** sum(p.islower() for p in location) - 1\n\n        #Dijkstra\n        pq = [(0, '@', 0)]\n        final_dist = defaultdict(lambda: float('inf'))\n        final_dist['@', 0] = 0\n        while pq:\n            d, place, state = heapq.heappop(pq)\n            if final_dist[place, state] < d: continue\n            if state == target_state: return d\n            for destination, d2 in list(dists[place].items()):\n                state2 = state\n                if destination.islower(): #key\n                    state2 |= 1 << ord(destination) - ord('a')\n                elif destination.isupper(): #lock\n                    if not(state & (1 << ord(destination) - ord('A'))): #no key\n                        continue\n\n                if d + d2 < final_dist[destination, state2]:\n                    final_dist[destination, state2] = d + d2\n                    heapq.heappush(pq, (d + d2, destination, state2))\n\n        return -1\n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m, n = len(grid), len(grid[0])\n        \n        k = 0\n        stx, sty = 0, 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] in 'abcdef': k += 1\n                if grid[i][j] == '@': stx = i; sty = j\n        \n        def keys(mask):\n            ans = 0\n            for m in [1, 2, 4, 8, 16, 32]:\n                if mask & m: ans += 1\n            return ans\n        \n        def neighbors(i, j):\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                if i+dx < 0 or i+dx >= m or j+dy < 0 or j + dy >= n: continue\n                if grid[i+dx][j+dy] == '#': continue\n                    \n                yield i+dx, j+dy\n                \n        q = collections.deque()\n        seen = set()\n        \n        q.append((stx, sty, 0, 0))\n        while q:\n            i, j, mask, moves = q.popleft()\n            if grid[i][j] in 'ABCDEF':\n                id = 'ABCDEF'.index(grid[i][j])\n                if not mask & (1 << id): continue\n                    \n            if (i, j, mask) in seen: continue\n            seen.add((i, j, mask))\n            \n            if keys(mask) == k: return moves - 1\n\n            if grid[i][j] in 'abcdef':\n                mask |= (1 << (ord(grid[i][j]) - ord('a')))\n                \n            for ii, jj in neighbors(i, j):\n                q.append((ii, jj, mask, moves+1))\n            \n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        from heapq import heappush, heappop\n        R, C = len(grid), len(grid[0])\n        start = None\n        K = 0\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == '@':\n                    start = (r, c)\n                elif grid[r][c].isupper():\n                    K = max(K, ord(grid[r][c]) - ord('A') + 1)\n        \n        assert start is not None\n        assert K > 0\n        \n        h = [(0, *start, 0)]\n        seen = set()\n        while h:\n            m, r, c, keys = heappop(h)\n            if (r, c, keys) in seen:\n                continue\n            seen.add((r, c, keys))\n            if keys == (1 << K) - 1:\n                return m\n            for rp, cp in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                if 0 <= rp < R and 0 <= cp < C:\n                    char = grid[rp][cp]\n                    if char == '#' or char.isupper() and keys & (1 << (ord(char) - ord('A'))) == 0:\n                        continue\n                    new_keys = keys\n                    if char.islower():\n                        new_keys |= (1 << (ord(char) - ord('a')))\n                    heappush(h, (m+1, rp, cp, new_keys))\n        return -1\n                        \n                        \n                        \n", "from collections import deque\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        keyMap = {ch : 1 << offset for offset, ch in enumerate('abcdef')}\n        \n        def hasKey(state, key):\n            return state & keyMap[key]\n        def setKey(state, key):\n            return state | keyMap[key]        \n        # BFS?\n        keys = set()\n        start = None\n        target = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if 'a' <= grid[i][j] <= 'f':\n                    target = setKey(target, grid[i][j])\n                elif grid[i][j] == '@':\n                    start = (i, j)\n        def neighbors(i, j):\n            moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n            for di, dj in moves:\n                if 0 <= i + di < len(grid) and 0 <= j + dj < len(grid[0]) and grid[i][j] != '#':\n                    yield (i + di, j + dj)\n        \n\n        visited = set()      \n        q = deque([[start, 0, 0]])\n        while q:\n            coord, oldKeys, steps = q.popleft()\n            for n in neighbors(coord[0], coord[1]):\n                newKeys = oldKeys\n                c = grid[n[0]][n[1]]\n                if 'A' <= c <= 'F' and not hasKey(newKeys, c.lower()):\n                    continue            \n\n                if 'a' <= c <= 'f':\n                    newKeys = setKey(newKeys, c)\n\n                if newKeys == target:\n                    return steps + 1\n\n                if (n, newKeys) not in visited:\n                    visited.add((n, newKeys))\n                    q.append([n, newKeys, steps + 1])\n        return -1\n        \n        \n        \n        \n        \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        sr, sc = 0, 0\n        k, m, n = 0, len(grid), len(grid[0])\n        key_id = collections.defaultdict(int)\n        for i, x in enumerate('abcdef'):\n            key_id[x] = i + 1\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] == '@':\n                    sr, sc = r, c\n                k = max(k, key_id[grid[r][c]])\n        q = [(sr, sc, '')]\n        res = 0\n        vis = set((sr, sc, ''))\n        while q:\n            tmp = []\n            for r, c, keys in q:\n                if len(keys) == k:\n                    return res\n                for rr, cc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                    if 0<= rr < m and 0<= cc < n and grid[rr][cc] != '#':\n                        x = grid[rr][cc]\n                        if x in 'ABCDEF' and x.lower() not in keys:\n                            continue\n                        new_keys = keys[::]\n                        if x in 'abcdef' and x not in new_keys:\n                            new_keys += x\n                        if (rr, cc, new_keys) not in vis:\n                            vis.add((rr, cc, new_keys))\n                            tmp.append((rr, cc, new_keys))\n            res += 1\n            q = tmp\n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        \n        \n        n, m = len(grid), len(grid[0])\n        \n        startx, starty = -1,-1\n        nkeys = 0\n        \n        for i in range(n):\n            \n            for j in range(m):\n                \n                if grid[i][j] == '@':\n                    \n                    startx, starty = i,j\n                    \n                if grid[i][j] in 'abcdef':\n                    \n                    nkeys += 1\n                    \n        queue = deque([(startx,starty,0,'',0)])\n        \n        visited = set([(startx,starty,'')])\n        \n        while queue:\n            \n            node = queue.popleft()\n            \n            x,y,nkey,keys,moves = node\n            \n            if nkey == nkeys:\n                return moves\n            \n            for ni in [(x+1,y), (x,y+1), (x-1,y), (x,y-1)]:\n                \n                xx,yy = ni\n                \n                if xx < 0 or yy < 0 or xx >=n or yy >=m or grid[xx][yy] == '#':\n                    continue\n              \n                if grid[xx][yy] in 'ABCDEF':\n                    if grid[xx][yy].lower() in keys and (xx,yy,keys) not in visited:\n                        queue.append(((xx,yy,nkey,keys,moves+1)))\n                        visited.add((xx,yy,keys))\n                    \n                elif grid[xx][yy] in 'abcdef' and grid[xx][yy] not in keys:      \n                    visited.add((xx,yy,keys+grid[xx][yy]))\n                    queue.append((xx,yy,nkey+1,keys+grid[xx][yy],moves+1))\n                    \n                elif (xx,yy,keys) not in visited:\n                    visited.add((xx,yy,keys))\n                    queue.append((xx,yy,nkey,keys,moves+1))\n                    \n        return -1\n\n                    \n", "import heapq\nfrom collections import deque, defaultdict\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m,n = len(grid),len(grid[0])\n        key_lock_loc = {ch:(i,j) for i,row in enumerate(grid) for j,ch in enumerate(row) if ch not in {'.','#'}}\n        key_cnt = sum(key_lock.islower() for key_lock in key_lock_loc)\n\n        def bfs_from(src):\n            i,j = key_lock_loc[src]\n            seen = [[False] *n for _ in range(m)]\n            seen[i][j] = True\n            # only locations which are not wall will be put into the queue\n            dque = deque([(i,j,0)]) \n            dist = {}\n            while dque:\n                i,j,d = dque.popleft()\n                ch = grid[i][j]\n                if ch != src and ch != '.': # reaches lock or key\n                    dist[ch] = d\n                    continue\n                # '#' or '.'\n                for x,y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\n                    if not (0<=x<m and 0<=y<n) or grid[x][y] == '#' or seen[x][y]:\n                        continue\n                    seen[x][y] = True\n                    dque.append((x,y,d+1))\n            return dist\n        \n        dists = {key_lock:bfs_from(key_lock) for key_lock in key_lock_loc}\n        target_state = 2 ** key_cnt -1\n        \n        hq = [(0,'@',0)]\n        final_dist = defaultdict(lambda: float('inf'))\n        final_dist['@',0] = 0\n        while hq:\n            d,loc,state = heapq.heappop(hq)\n            if final_dist[loc,state] < d:\n                continue\n            if state == target_state:\n                return d\n            for destination, d2 in list(dists[loc].items()):\n                state2 = state\n                if destination.islower(): # key\n                    state2 |= (1 <<(ord(destination) - ord('a')))\n                elif destination.isupper(): # loc\n                    if not(state &(1 <<(ord(destination) - ord('A')))):\n                        continue\n                if d + d2 < final_dist[destination, state2]:\n                    final_dist[destination, state2]= d + d2\n                    heapq.heappush(hq,(d+d2,destination,state2))\n        return -1\n        \n                    \n", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m, n = len(grid), len(grid[0])\n        q, seen, keys = deque(), set(), set()        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '@':\n                    q.append((i,j,''))\n                    seen.add((i,j,''))\n                elif 'a' <= grid[i][j] <= 'f':\n                    keys.add(grid[i][j])\n        \n        steps = 0\n        while q:\n            size = len(q)\n            #print(list(q), grid[q[0][0]][q[0][1]])\n            for _ in range(size):\n                x,y,k = q.popleft()\n                if len(k) == len(keys): return steps\n                for i,j in [(0,1), (0,-1), (1,0), (-1,0)]:\n                    nx, ny, nk = x + i, y + j, k\n                    if nx < 0 or nx >= m or ny < 0 or ny >= n or grid[nx][ny] == '#':\n                        continue\n                    if 'A' <= grid[nx][ny] <= 'F' and grid[nx][ny].lower() not in nk:\n                        continue\n                    if 'a' <= grid[nx][ny] <= 'f' and grid[nx][ny] not in nk:\n                        nk += grid[nx][ny]\n                    if (nx,ny,nk) not in seen:\n                        q.append((nx,ny,nk))\n                        seen.add((nx,ny,nk))\n            steps += 1\n        return -1", "class Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        # simple BFS. store a bag of keys you have and when encounter a lock,\n        # check whether you have corresponding key in the bag\n        target = 0\n        queue, visited = [], set()\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if 'a' <= grid[i][j] <= 'f':\n                    target += 1\n                elif grid[i][j] == '@':\n                    queue.append((i, j, '.@abcdef', 0))\n                    visited.add((i, j, '.@abcedf'))\n        \n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        collected = set()\n        \n        while len(queue) != 0:\n            size = len(queue)\n            for _ in range(size):\n                x, y, bag, collected = queue.pop(0)\n                if collected == target:\n                    return ans\n                for ix, iy in dirs:\n                    xx = x+ix\n                    yy = y+iy\n                    if 0 <= xx < len(grid) and 0 <= yy < len(grid[0]) and grid[xx][yy] in bag:\n                        if 'a' <= grid[xx][yy] <= 'f' and grid[xx][yy].upper() not in bag:\n                            if (xx, yy, bag+grid[xx][yy].upper()) not in visited:\n                                queue.append((xx, yy, bag+grid[xx][yy].upper(), collected+1))\n                                visited.add((xx, yy, bag+grid[xx][yy].upper()))\n                        else:\n                            if (xx, yy, bag) not in visited:\n                                queue.append((xx, yy, bag, collected))\n                                visited.add((xx, yy, bag))\n            ans += 1\n        return -1", "'''\n[\\\"@.a.#\\\",\\\"###.#\\\",\\\"b.A.B\\\"]\n\n[\n\\\"@.a.#\\\",\n\\\"###.#\\\",\n\\\"b.A.B\\\"\n]\n\n\n[\n\\\"@..aA\\\",\n\\\"..B#.\\\",\n\\\"....b\\\"\n]\n\n\n'''\n\nclass Solution:\n    def shortestPathAllKeys(self, grid: List[str]) -> int:\n        n, m = len(grid), len(grid[0])\n        \n        queue = collections.deque()\n        seen = set()\n        nKeys = 0\n        moves = 0\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '@':\n                    queue.append([i, j, 0, 0, 'abcdef.@'])\n                elif grid[i][j] in 'abcdef':\n                    nKeys += 1\n        \n        while queue:\n            i, j, moves, curKeys, keys = queue.popleft()\n            \n            if grid[i][j] in 'abcdef' and grid[i][j].upper() not in keys:\n                keys += grid[i][j].upper()\n                curKeys += 1\n            \n            if curKeys == nKeys:\n                return moves\n            \n            for x, y in (-1, 0), (1, 0), (0, -1), (0, 1):\n                ni, nj = i + x, j + y\n                if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] in keys and  (ni, nj, keys) not in seen:\n                    seen.add((ni, nj, keys))\n                    queue.append([ni, nj, moves + 1, curKeys, keys])\n        \n        return -1\n        \n                        \n"]
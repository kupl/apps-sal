["rd = lambda: list(map(int, input().split()))\n\ndef root(x):\n  if f[x]!=x: f[x] = root(f[x])\n  return f[x]\n\nn, m = rd()\nN = list(range(n))\nf = list(N)\nlang = [0]*n\nfor i in N: lang[i] = set(rd()[1:])\nfor i in N:\n  for j in N[:i]:\n    rj = root(j)\n    if lang[rj].intersection(lang[i]):\n      f[rj] = i\n      lang[i] = lang[i].union(lang[rj])\nprint(sum(1 for i in N if i==root(i)) - (sum(map(len, lang))>0))\n", "rd = lambda: list(map(int, input().split()))\n\ndef root(x):\n  if f[x]!=x: f[x] = root(f[x])\n  return f[x]\n\nn, m = rd()\nN = list(range(n))\nf = list(N)\nlang = [0]*n\nfor i in N: lang[i] = set(rd()[1:])\nfor i in N:\n  for j in N[:i]:\n    if j==root(j) and lang[j].intersection(lang[i]):\n      f[j] = i\n      lang[i] = lang[i].union(lang[j])\nprint(sum(1 for i in N if i==root(i)) - (sum(map(len, lang))>0))\n", "rd = lambda: list(map(int, input().split()))\n\ndef root(x):\n  if f[x]!=x: f[x] = root(f[x])\n  return f[x]\n\nn, m = rd()\nN = list(range(n))\nf = list(N)\nlang = [None]*n\nfor i in N: lang[i] = set(rd()[1:])\nfor i in N:\n  for j in N[:i]:\n    if j==root(j) and lang[j].intersection(lang[i]):\n      f[j] = i\n      lang[i] = lang[i].union(lang[j])\nprint(sum(1 for i in N if i==root(i)) - (sum(map(len, lang))>0))\n", "n, m = map(int, input().split())\nq = [[] for i in range(n + 1)]\nr, s = [0] * (m + 1), 0\nfor i in range(1, n + 1):\n    t = list(map(int, input().split()))\n    if t[0]:\n        t = t[1: ]\n        d = set([r[j] for j in t])\n        if 0 in d: d.remove(0)\n        if len(d):\n            for j in d:\n                for k in q[j]:\n                    r[k] = i\n                q[i].extend(q[j])\n                q[j] = []\n            t = [j for j in t if r[j] == 0]\n            for k in t:\n                r[k] = i\n            q[i].extend(t)\n        else:\n            for k in t:\n                r[k] = i\n            q[i] = t          \n    else: s += 1\nprint(s + max(sum(len(i) > 0 for i in q) - 1, 0))", "v0 = 0\nl = []\nn, m = (int(x) for x in input().split())\nfor i in range(n):\n    l2 = []\n    curs = set([int(x) for x in input().split()][1:])\n    if not curs:\n        v0 += 1\n        continue\n    for s in l:\n        if curs & s:\n            curs |= s\n        else:\n            l2.append(s)\n    l2.append(curs)\n    l = l2\nprint(v0 + max(0, len(l) - 1))\n", "def recursive_dfs(graph, start, path=[]):\n  '''recursive depth first search from start'''\n  path=path+[start]\n  for node in graph[start]:\n    if not node in path:\n      path=recursive_dfs(graph, node, path)\n  return path\n\ndef connected(x, y):\n    if set(x).intersection(set(y)) != set():\n        return True\n    return False\n\nvertices = []\neach = {}\nadj = {}\nnum0 = 0\na, b = list(map(int, input().split(' ')))\nfor i in range(a):\n    x = list(map(int, input().split(' ')))\n    adj[i] = []\n    if x[0] == 0:\n        num0 += 1\n    else:\n        x = x[1:]\n        each[i] = x\n        vertices.append(i)\n\n        for j in vertices:\n            if connected(each[j], each[i]):\n                adj[j].append(i)\n                adj[i].append(j)\n            \nmarked = [False] * a\nnum = 0\nfor i in vertices:\n  if not marked[i]:\n    for j in recursive_dfs(adj, i):\n      marked[j] = True\n    num += 1\n\nif num == 0:\n    print(num0)\nelse:\n    print(num+num0-1)\n", "n, m = [int(x) for x in input().split()]\nl = [[]] * n\nfor i in range(n):\n\tl[i] = set(int(x) for x in input().split()[1:])\nwhile True:\n\tfor i in range(len(l)):\n\t\tfor j in range(i):\n\t\t\tif l[i] & l[j]:\n\t\t\t\tl[j] |= l[i]\n\t\t\t\tl = l[:i] + l[i + 1:]\n\t\t\t\tbreak\n\t\telse:\n\t\t\tcontinue\n\t\tbreak\n\telse:\n\t\tbreak\nans = len(l)\nfor s in l:\n\tif s:\n\t\tans -= 1\n\t\tbreak\nprint(ans)\n", "def main():\n    def root(a):\n        b = f[a]\n        while b != a:\n            a, b = b, f[b]\n        return a\n\n    n, m = list(map(int, input().split()))\n    f = list(range(n))\n    lang = []\n    for _ in range(n):\n        lang.append(set(list(map(int, input().split()[1:]))))\n    for i in range(n):\n        for j in range(i):\n            if j == root(j) and lang[j].intersection(lang[i]):\n                f[j] = i\n                lang[i].update(lang[j])\n    print(sum(i == root(i) for i in range(n)) - any(lang))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    def root(a):\n        b = f[a]\n        while b != a:\n            a, b = b, f[b]\n        return a\n\n    n, m = list(map(int, input().split()))\n    f = list(range(n))\n    lang = []\n    for _ in range(n):\n        lang.append(set(map(int, input().split()[1:])))\n    for i in range(n):\n        for j in range(i):\n            if j == root(j) and lang[j].intersection(lang[i]):\n                f[j] = i\n                lang[i].update(lang[j])\n    print(sum(i == root(i) for i in range(n)) - any(lang))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    def root(a):\n        b = f[a]\n        while b != a:\n            a, b = b, f[b]\n        return a\n\n    n, m = list(map(int, input().split()))\n    f = list(range(n))\n    lang = []\n    for _ in range(n):\n        ll = [False] * m\n        for i in map(int, input().split()[1:]):\n            ll[i - 1] = True\n        lang.append(ll)\n    for i, langi in enumerate(lang):\n        for j in range(i):\n            if j == root(j) and any(a and b for a, b in zip(lang[i], lang[j])):\n                f[j] = i\n                for _, flag in enumerate(lang[j]):\n                    langi[_] |= flag\n    print(sum(i == root(i) for i in range(n)) - any(map(any, lang)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    def root(a):\n        b = f[a]\n        while b != a:\n            a, b = b, f[b]\n        return a\n\n    n, m = list(map(int, input().split()))\n    f = list(range(n))\n    lang = []\n    for _ in range(n):\n        lang.append(set(map(int, input().split()[1:])))\n    for i, langi in enumerate(lang):\n        for j in range(i):\n            if j == root(j) and lang[j].intersection(langi):\n                f[j] = i\n                langi.update(lang[j])\n    print(sum(i == root(i) for i in range(n)) - any(lang))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    def root(x):\n        a, b = x, f[x]\n        while b != a:\n            a, b = b, f[b]\n        return a == x\n\n    n, m = list(map(int, input().split()))\n    f = list(range(n))\n    lang = []\n    for _ in range(n):\n        lang.append(set(map(int, input().split()[1:])))\n    for i, langi in enumerate(lang):\n        for j in range(i):\n            if root(j) and lang[j].intersection(langi):\n                f[j] = i\n                langi.update(lang[j])\n    print(sum(root(i) for i in range(n)) - any(lang))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    def root(x):\n        a, b = x, f[x]\n        while b != a:\n            a, b = b, f[b]\n        return a == x\n\n    n, m = list(map(int, input().split()))\n    f = list(range(n))\n    lang = [set(map(int, input().split()[1:])) for _ in range(n)]\n    for i, langi in enumerate(lang):\n        for j, langj in enumerate(lang[:i]):\n            if root(j) and langj.intersection(langi):\n                f[j] = i\n                langi.update(langj)\n    print(sum(root(i) for i in range(n)) - any(lang))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    f = list(range(n))\n    lang = [set(map(int, input().split()[1:])) for _ in range(n)]\n    for i, langi in enumerate(lang):\n        for j, langj in enumerate(lang[:i]):\n            if f[j] == j and langj.intersection(langi):\n                f[j] = i\n                langi.update(langj)\n    print(sum(i == x for i, x in enumerate(f)) - any(lang))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    f = [1] * n\n    lang = [set(map(int, input().split()[1:])) for _ in range(n)]\n    for i, langi in enumerate(lang):\n        for j, langj in enumerate(lang[:i]):\n            if f[j] and langj.intersection(langi):\n                f[j] = 0\n                langi.update(langj)\n    print(sum(f) - any(lang))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def find(sets, a):\n\tif a == sets[a]:\n\t\treturn a\n\tsets[a] = find(sets, sets[a])\n\treturn sets[a]\n\ndef join(sets, a, b):\n\ta = find(sets, a)\n\tb = find(sets, b)\n\tif a != b:\n\t\tsets[a] = b\n\nn, m = (int(x) for x in input().split())\nsets = list(range(n))\nlangs = []\nfor i in range(n):\n\tlangs.append(set([int(x) for x in input().split()][1:]))\nif all(len(lang) == 0 for lang in langs):\n\tprint(n)\n\treturn\nfor i in range(n):\n\tfor lang in langs[i]:\n\t\tfor j in range(i):\n\t\t\tif lang in langs[j]:\n\t\t\t\tjoin(sets, i, j)\nprint(len(set(find(sets, s) for s in sets)) - 1)\n", "# coding: utf-8\nn, m = [int(i) for i in input().split()]\nlanguages = []\nans = 0\nfor i in range(n):\n    tmp = set([int(j) for j in input().split()[1:]])\n    if tmp:\n        languages.append(tmp)\n    else:\n        n -= 1\n        ans += 1\ni = 0\nwhile i < n:\n    j = i+1\n    while j < n:\n        if languages[i]&languages[j]:\n            languages[i] = languages[i]|languages[j]\n            del(languages[j])\n            n -= 1\n        else:\n            j += 1\n    i += 1\ni = 0\nwhile i < n:\n    j = i+1\n    while j < n:\n        if languages[i]&languages[j]:\n            languages[i] = languages[i]|languages[j]\n            del(languages[j])\n            n -= 1\n        else:\n            j += 1\n    i += 1\nif n:\n    ans += n-1\nprint(ans)\n", "# coding: utf-8\ndef union(s,n):\n    i = 0\n    while i < n:\n        j = i+1\n        while j < n:\n            if s[i]&s[j]:\n                s[i] = s[i]|s[j]\n                del(s[j])\n                n -= 1\n            else:\n                j += 1\n        i += 1\n    return s, n\nn, m = [int(i) for i in input().split()]\nlanguages = []\nans = 0\nfor i in range(n):\n    tmp = set([int(j) for j in input().split()[1:]])\n    if tmp:\n        languages.append(tmp)\n    else:\n        n -= 1\n        ans += 1\nlanguages, n = union(languages,n)\nlanguages, n = union(languages,n)\nif languages:\n    ans += n-1\nprint(ans)\n", "n, m = map(int, input().split())\nq = [[] for i in range(n + 1)]\nr, s = [0] * (m + 1), 0\nfor i in range(1, n + 1):\n    t = list(map(int, input().split()))\n    if t[0]:\n        t = t[1: ]\n        d = set([r[j] for j in t])\n        if 0 in d: d.remove(0)\n        if len(d):\n            for j in d:\n                for k in q[j]:\n                    r[k] = i\n                q[i].extend(q[j])\n                q[j] = []\n            t = [j for j in t if r[j] == 0]\n            for k in t:\n                r[k] = i\n            q[i].extend(t)\n        else:\n            for k in t:\n                r[k] = i\n            q[i] = t          \n    else: s += 1\nprint(s + max(sum(len(i) > 0 for i in q) - 1, 0))", "3.4\n\nn, m = list(map(int, input().split()))\n\narr = [[] for i in range(n)]\nused = [0 for i in range(n)]\nans = 0\n\ndef dfs(vertex):\n    used[vertex] = 1\n    langs = arr[vertex]\n    for lang in langs:\n            for ind, next_vertex in enumerate(arr):\n                if lang in next_vertex and used[ind] == 0:\n                    dfs(ind)\ntest = 0\nfor i in range(n):\n    arr[i] = list(map(int, input().split()[1:]))\n    if len(arr[i]) == 0:\n        test += 1\nfor node in range(n):\n    if used[node] == 0:\n        dfs(node)\n        ans += 1\nprint(ans - 1 + (1 if test == n else 0))\n\n\n", "p = [i for i in range(110)]\nrank = [0 for i in range(110)]\n\ndef findSet(i):\n\tnonlocal p\n\tif(p[i]==i):\n\t\treturn i\n\tp[i] = findSet(p[i])\n\treturn p[i]\n\ndef isSameSet(i,j):\n\treturn findSet(i)==findSet(j)\n\ndef unionSet(i,j):\n\tnonlocal p,rank\n\tif(isSameSet(i,j)):\n\t\treturn\n\tx = findSet(i)\n\ty = findSet(j)\n\tif(rank[x]>rank[y]):\n\t\tp[y] = x\n\telse:\n\t\tp[x] = y\n\t\tif(rank[x]==rank[y]):\n\t\t\trank[y]+=1\n\nn,m = tuple(int(i) for i in input().split())\nlangs = [set() for i in range(n)]\n\nallzero = True\nfor i in range(n):\n\tA = list(int(i) for i in input().split())\n\tif(A[0]!=0):\n\t\tallzero = False\n\tfor j in range(len(A)):\n\t\tif(j>0):\n\t\t\tlangs[i].add(A[j])\nif not allzero:\n\tfor i in range(n):\n\t\tfor j in range(i+1,n):\n\t\t\tif(len(langs[i] & langs[j])>=1):\n\t\t\t\tunionSet(i,j)\n\n\troots = set()\n\tfor i in range(n):\n\t\troots.add(findSet(i))\n\n\tprint(len(roots)-1)\nelse:\n\tprint(n)", "from collections import deque,namedtuple\n\ndef dfs(adj,s,visited):\n    dq = deque([s])\n    while len(dq) > 0:\n        now = dq.pop()\n        if visited[now]: continue\n        visited[now] = 1\n        for i in adj[now]:\n            if not visited[i]:\n                dq.append(i)\n\ndef main():\n    n,m = map(int,input().strip().split())\n    adj,check = [[] for j in range(n+m)],0\n    for i in range(n):\n        l = [int(j) for j in input().split()][1:]\n        check = max(check,len(l))\n        for j in l:\n            adj[i].append(n+j-1)\n            adj[n+j-1].append(i)\n    visited,ans = [0 for i in range(n+m)],-1\n    if check == 0:\n        print(n)\n        return\n    for i in range(n):\n        if not visited[i]:\n            dfs(adj,i,visited)\n            ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "#DSU\nimport bisect,sys\nfrom collections import deque, namedtuple\nsys.setrecursionlimit(20000)\nN = 300\npar = [i for i in range(N)]\n\ndef find(i):\n    if i == par[i]: return i\n    par[i] = find(par[i])\n    return par[i]\n\ndef merge(a,b):\n    a = find(a)\n    b = find(b)\n    par[b] = a\n\ndef main():\n    n,m = map(int,input().split())\n    check,ans = 0,-1\n    for _ in range(n):\n        l = [int(i) for i in input().split()][1:]\n        check = max(check,len(l))\n        for i in l:\n            merge(_,n+i)\n    if not check:\n        print(n)\n        return\n    for i in range(n):\n        if i == par[i]:\n            ans += 1\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "#DSU\nimport bisect,sys\nfrom collections import deque, namedtuple\nN = 300\npar = [i for i in range(N)]\n\ndef find(i):\n    root = i\n    while root != par[root]: root = par[root]\n    while i != par[i]:\n        newp = par[i]\n        par[i] = root\n        i = newp\n    return root\n\ndef merge(a,b):\n    a = find(a)\n    b = find(b)\n    par[b] = a\n\ndef main():\n    n,m = map(int,input().split())\n    check,ans = 0,-1\n    for _ in range(n):\n        l = [int(i) for i in input().split()][1:]\n        check = max(check,len(l))\n        for i in l:\n            merge(_,n+i)\n    if not check:\n        print(n)\n        return\n    for i in range(n):\n        if i == par[i]:\n            ans += 1\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "#DSUA\nimport bisect,sys\nfrom collections import deque, namedtuple\nN = 300\npar = [i for i in range(N)]\n\ndef find(i):\n    root = i\n    while root != par[root]: root = par[root]\n    while i != par[i]:\n        newp = par[i]\n        par[i] = root\n        i = newp\n    return root\n\ndef merge(a,b):\n    a = find(a)\n    b = find(b)\n    par[b] = a\n\ndef main():\n    n,m = map(int,input().split())\n    check,ans = 0,-1\n    for _ in range(n):\n        l = [int(i) for i in input().split()][1:]\n        check = max(check,len(l))\n        for i in l:\n            merge(_,n+i)\n    if not check:\n        print(n)\n        return\n    for i in range(n):\n        if i == par[i]:\n            ans += 1\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()"]
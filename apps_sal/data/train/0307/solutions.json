["class Solution:\n    \n    def soupServings(self, N: int) -> float:\n        if N > 5000: return 1   # shortcut for large N (accurate to 1e-6)\n\n        @lru_cache(None)\n        def dp(a, b):\n            if a <= 0 and b <= 0: return 0.5\n            if a <= 0: return 1\n            if b <= 0: return 0\n            return (dp(a-100, b) + dp(a-75, b-25) + dp(a-50, b-50) + dp(a-25, b-75)) / 4\n\n        return dp(N, N)", "class Solution:\n    mem={}\n    def soupServings(self, N: int) -> float:\n          if N>4800:\n                return 1\n          def empty(a,b):\n             if (a,b) in self.mem:\n                    return self.mem[(a,b)]\n             if a<=0 and b<=0:\n                    return 0.5\n             if a<=0:\n                return 1\n             if b<=0:\n                return 0\n             ans=0.25*(empty(a-4,b)+empty(a-3,b-1)+empty(a-2,b-2)+empty(a-1,b-3))\n             self.mem[(a,b)]=ans\n             return ans\n          N=math.ceil(N/25)  \n          return empty(N,N)\n          \n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        seen={}\n        def find_prob(A,B):\n            if A==0 and B==0:\n                return 0.5\n            if A==0:\n                return 1\n            if B==0:\n                return 0\n            if (A,B) in seen:\n                return seen[A,B]\n            temp=0\n            for x,y in [[100,0],[75,25],[50,50],[25,75]]:\n                temp+=find_prob(A-x if A>x else 0,B-y if B>y else 0)\n            seen[A,B]=0.25*temp\n            return 0.25*temp\n        if N>4800: return 1.0\n        return find_prob(N,N)", "class Solution:\n    def soupServings(self, N: int) -> float:\n        def f(a,b):\n            if a <= 0 and b <= 0:\n                return 0.5\n            if a <= 0:\n                return 1\n            if b <= 0:\n                return 0\n            if _memo[a][b] >0:\n                return _memo[a][b]\n            \n            _memo[a][b] = 0.25 *(f(a - 4,b) + f(a - 3,b - 1)  + f(a - 2,b - 2)  + f(a - 1,b - 3) ) \n            return _memo[a][b]\n        _memo = [[0] * 200 for i in range(200)]\n        \n        if N >= 4800:\n            return 1\n        else:\n            return f((N + 24) // 25, (N + 24) // 25)\n         \n            \n            \n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        q, r = divmod(N, 25)\n        N = q + (r > 0)\n        if N >= 500:\n            return 1\n        \n        memo = {}\n        def dp(x, y):\n            if (x, y) not in memo:\n                if x <= 0 or y <= 0:\n                    res = 0.5 if x <= 0 and y <= 0 else 1.0 if x <= 0 else 0.0\n                else:\n                    res = 0.25 * (dp(x-4, y) + dp(x-3, y-1) + dp(x-2, y-2) + dp(x-1, y-3))\n                memo[x, y] = res\n            return memo[x, y]\n        \n        return dp(N, N)\n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        if N > 10000:\n            return 1\n        \n        rounds = (N + 25 - 1) // 25\n        dp = [{(N, N): 1}] + [collections.defaultdict(float) for _ in range(rounds)]\n        for i in range(1, rounds + 1):\n            for a, b in dp[i-1]:\n                if a <= 0 or b <= 0:\n                    dp[i][a, b] += dp[i-1][a, b]\n                else:\n                    dp[i][max(a-100, 0), b] += dp[i-1][a, b] * 0.25\n                    dp[i][max(a-75, 0), max(b-25, 0)] += dp[i-1][a, b] * 0.25\n                    dp[i][max(a-50, 0), max(b-50, 0)] += dp[i-1][a, b] * 0.25\n                    dp[i][max(a-25, 0), max(b-75, 0)] += dp[i-1][a, b] * 0.25\n        \n        res = dp[rounds][0, 0] / 2\n        for a, b in dp[rounds]:\n            if a <= 0 and b > 0:\n                res += dp[rounds][a,b]\n        return res", "#\nclass Solution:\n    def soupServings(self, N: int) -> float:\n        Q, R = divmod(N, 25)\n        N = Q + (R > 0)\n        if N >= 500: return 1\n\n        memo = {}\n        def dp(x, y):\n            if (x, y) not in memo:\n                if x <= 0 or y <= 0:\n                    ans = 0.5 if x<=0 and y<=0 else 1.0 if x<=0 else 0.0\n                else:\n                    ans = 0.25 * (dp(x-4,y)+dp(x-3,y-1)+dp(x-2,y-2)+dp(x-1,y-3))\n                memo[x, y] = ans\n            return memo[x, y]\n\n        return dp(N, N)", "class Solution:\n    def soupServings(self, N: int) -> float:\n        # 4,0\n        # 3,1\n        # 2,2\n        # 1,3\n        if N % 25 == 0:\n            N = N // 25\n        else:\n            N = (N // 25) + 1\n        \n        solA = {}\n        solB = {}\n        \n        def solutionA(a,b):\n            if a == 0 and b > 0:\n                return 1\n            elif a == 0 and b == 0:\n                return 0\n            elif a > 0 and b == 0:\n                return 0\n            else:\n                if (a,b) in solA:\n                    return solA[(a,b)]\n                else:\n                    solA[(a,b)] = 0.25 * (solutionA(max(a-4,0),b) + solutionA(max(a-3,0),max(b-1,0)) + solutionA(max(a-2,0),max(b-2,0)) + solutionA(max(a-1,0),max(b-3,0)))\n                    return solA[(a,b)]\n            \n        def solutionB(a,b):\n            if a == 0 and b == 0:\n                return 1\n            elif a == 0 or b == 0:\n                return 0\n            else:\n                if (a,b) in solB:\n                    return solB[(a,b)]\n                else:\n                    solB[(a,b)] = 0.25 * (solutionB(max(a-4,0),b) + solutionB(max(a-3,0),max(b-1,0)) + solutionB(max(a-2,0),max(b-2,0)) + solutionB(max(a-1,0),max(b-3,0)))\n                    return solB[(a,b)]\n                \n        if N > 300:\n            return 1\n        else:\n            return solutionA(N,N) + 0.5*solutionB(N,N)", "class Solution:\n    def soupServings(self, N):\n        if N>=5551: return 1\n        self.dd=collections.defaultdict(float)\n        return self.sub(N,N)\n        \n    def sub(self, an, bn):\n        if an<=0 and bn<=0: return 0.5\n        if an<=0: return 1\n        if bn<=0: return 0\n        if (an,bn) in self.dd: return self.dd[(an,bn)]\n        c1=self.sub(an-100, bn)\n        c2=self.sub(an-75, bn-25)\n        c3=self.sub(an-50, bn-50)\n        c4=self.sub(an-25, bn-75)\n        self.dd[(an,bn)]=0.25*sum([c1,c2,c3,c4])\n        return self.dd[(an,bn)]", "import math\nclass Solution:\n    def soupServings(self, N: int) -> float:\n        \n        \n        N = math.ceil(N/25)\n        \n        if N>=1000:\n            return 1\n        \n        dp = [[1 for i in range(N+1)] for j in range(N+1)]\n        \n        for i in range(0,N+1):\n            dp[i][0] = 0\n            \n        dp[0][0] = 0.5    \n            \n        for i in range(1,N+1):\n            for j in range(1,N+1):\n                M = lambda x: max(0,x)   \n                dp[i][j] = 0.25 * (dp[M(i - 4)][j] + dp[M(i -3)][j - 1] \n                               + dp[M(i - 2)][M(j - 2)] + dp[i - 1][M(j - 3)])   \n                \n                if(1 - dp[i][j] < 0.000001):\n                    break\n        \n            if(1 - dp[i][i] < 0.000001):\n                break\n\n        return dp[N][N]                \n                    \n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        memo = {}\n        if N > 4800: return 1\n        def dp(a ,b):\n            if (a, b) in memo: return memo[a, b]\n            if a <= 0 and b > 0: return 1\n            if a <= 0 and b <= 0: return 0.5\n            if a > 0 and b <= 0: return 0\n            memo[a, b] = (dp(a - 100, b) + dp(a - 75, b - 25) + dp(a - 50, b - 50) + dp(a - 25, b - 75)) / 4\n            return memo[a, b]\n        return dp(N, N)", "class Solution:\n    def soupServings(self, N: int) -> float:\n        if N>=10000:\n            return 1.0\n        L=N//25+1 if N%25>0 else N//25\n        res=dict()\n        res[0,0]=0.5\n        for l in range(1,L+1):\n            res[l,0]=0.0\n            res[0,l]=1.0\n        for m in range(1,L+1):\n            for n in range(1,L+1):\n                res[m,n]=0.25*(res[max([m-4,0]),n]+res[max([m-3,0]),max([n-1,0])]+res[max([m-2,0]),max(n-2,0)]+res[max(m-1,0),max(n-3,0)])\n        return res[L,L]", "# class Solution:\n#     def soupServings(self, N: int) -> float:\n#         n=N//25 + (N % 25 > 0)\n#         dp=[[0]*(n+1) for i in range(n+1)]\n#         dp[-1][-1]=1\n        \n#         x=[-4,-3,-2,-1]\n#         y=[0,-1,-2,-3]\n#         for i in range(n,0,-1):\n#             for j in range(n,0,-1):\n#                     for dx,dy in zip(x,y):\n#                         if i+dx>=0 and i+dy>=0:\n#                             dp[i+dx][j+dy]+=dp[i][j]*(0.25)\n#                         elif j+dy<0:\n#                             dp[i+dx][0]+=dp[i][j]*(0.25)\n#                         elif i+dx<0:\n#                             dp[0][j+dy]+=dp[i][j]*(0.25)\n#                         elif i+dx<0 and j+dy<0:\n#                             dp[0][0]+=dp[i][j]*(0.25)\n            \n#         Sum=0\n#         for j in range(n+1):\n#             Sum+=dp[0][j]\n                \n#         return Sum - dp[0][0] / 2\n            \n\nclass Solution:\n    def soupServings(self, N: int) -> float:\n        N = N//25 + (N % 25 > 0)\n        if N >= 500:\n            return 1\n        dp = [[0]*(N+1) for _ in range(N+1)]\n        operations = [(4, 0), (3, 1), (2, 2), (1, 3)]\n        dp[-1][-1] = 1\n        \n        for i in range(N, 0, -1):\n            for j in range(N, 0, -1):\n                for a, b in operations:\n                    if i-a < 0 and j-b < 0:\n                        dp[0][0] += dp[i][j]*0.25\n                    elif i-a < 0:\n                        dp[0][j-b] += dp[i][j]*0.25\n                    elif j-b < 0:\n                        dp[i-a][0] += dp[i][j]*0.25\n                    else:\n                        dp[i-a][j-b] += dp[i][j]*0.25    \n        a_total = 0\n        for i in range(N+1):\n            a_total += dp[0][i]\n        \n        return a_total - dp[0][0] / 2\n            \n            \n                    \n                \n                \n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        n=N//25 + (N % 25 > 0)\n        if n>=500:\n            return 1\n        dp=[[0]*(n+1) for i in range(n+1)]\n        dp[-1][-1]=1\n        \n        x=[-4,-3,-2,-1]\n        y=[0,-1,-2,-3]\n        for i in range(n,0,-1):\n            for j in range(n,0,-1):\n                for dx,dy in zip(x,y):\n                    if i+dx<0 and j+dy<0:\n                        dp[0][0]+=dp[i][j]*(0.25)\n                    elif i+dx<0:\n                        dp[0][j+dy]+=dp[i][j]*(0.25)\n                    elif j+dy<0:\n                        dp[i+dx][0]+=dp[i][j]*(0.25)\n                    else:\n                        dp[i+dx][j+dy]+=dp[i][j]*(0.25)\n                        \n            \n        Sum=0\n        for j in range(n+1):\n            Sum+=dp[0][j]\n                \n        return Sum - dp[0][0] / 2\n            \n\n# class Solution:\n#     def soupServings(self, N: int) -> float:\n#         N = N//25 + (N % 25 > 0)\n#         if N >= 500:\n#             return 1\n#         dp = [[0]*(N+1) for _ in range(N+1)]\n#         operations = [(4, 0), (3, 1), (2, 2), (1, 3)]\n#         dp[-1][-1] = 1\n        \n#         for i in range(N, 0, -1):\n#             for j in range(N, 0, -1):\n#                 for a, b in operations:\n#                     if i-a < 0 and j-b < 0:\n#                         dp[0][0] += dp[i][j]*0.25\n#                     elif i-a < 0:\n#                         dp[0][j-b] += dp[i][j]*0.25\n#                     elif j-b < 0:\n#                         dp[i-a][0] += dp[i][j]*0.25\n#                     else:\n#                         dp[i-a][j-b] += dp[i][j]*0.25    \n#         a_total = 0\n#         for i in range(N+1):\n#             a_total += dp[0][i]\n        \n#         return a_total - dp[0][0] / 2\n            \n            \n                    \n                \n                \n", "# class Solution:\n#     def soupServings(self, N: int) -> float:\n#         n=N//25 + (N % 25 > 0)\n#         dp=[[0]*(n+1) for i in range(n+1)]\n#         M=[[0]*(n+1) for i in range(n+1)]\n#         dp[n][n]=1\n        \n#         x=[-4,-3,-2,-1]\n#         y=[0,-1,-2,-3]\n#         for i in range(n,1,-1):\n#             for j in range(n,1,-1):\n#                 if dp[i][j]>0:\n#                     for dx,dy in zip(x,y):\n#                         if i+dx>=0 and i+dy>=0:\n#                             dp[i+dx][j+dy]+=dp[i][j]*(0.25)\n#                         elif i+dx>=0 and j+dy<0:\n#                             dp[i+dx][0]+=dp[i][j]*(0.25)\n#                         elif i+dx<0 and j+dy>=0:\n#                             dp[0][j+dy]+=dp[i][j]*(0.25)\n#                         elif i+dx<0 and j+dy<0:\n#                             dp[0][0]+=dp[i][j]*(0.25)\n            \n            \n#         Sum=0\n#         for j in range(len(dp[0])):\n#             Sum+=dp[0][j]\n                \n#         return Sum-dp[0][0]/2\n            \n\nclass Solution:\n    def soupServings(self, N: int) -> float:\n        N = N//25 + (N % 25 > 0)\n        if N >= 500:\n            return 1\n        dp = [[0]*(N+1) for _ in range(N+1)]\n        operations = [(4, 0), (3, 1), (2, 2), (1, 3)]\n        dp[-1][-1] = 1\n        \n        for i in range(N, 0, -1):\n            for j in range(N, 0, -1):\n                for a, b in operations:\n                    if i-a < 0 and j-b < 0:\n                        dp[0][0] += dp[i][j]*0.25\n                    elif i-a < 0:\n                        dp[0][j-b] += dp[i][j]*0.25\n                    elif j-b < 0:\n                        dp[i-a][0] += dp[i][j]*0.25\n                    else:\n                        dp[i-a][j-b] += dp[i][j]*0.25    \n        a_total = 0\n        for i in range(N+1):\n            a_total += dp[0][i]\n        \n        return a_total - dp[0][0] / 2\n            \n            \n                    \n                \n                \n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        import numpy as np\n        if N > 5000: return 1\n        if N == 0:\n            return 0.5\n        if N % 25 == 0:\n            N = N // 25\n        else:\n            N = N // 25 + 1\n        \n        # N is the dimension\n        # Initial Square equals to ( N + 1 ) * ( N + 1 )\n        Matrix = [ [ 0.0 for i in range( N + 1 ) ] for j in range( N + 1 ) ]\n        \n        Matrix = np.matrix( Matrix )\n        Matrix[ N, N ] = 1\n        \n        Explore_List = [ (N,N) ];\n        while( Explore_List ):\n            New_List = set()\n            for x, y in Explore_List:\n                if( x != 0 and y != 0 ):\n                    Matrix[ max( 0, x - 2 ), max( 0, y - 2 ) ] += Matrix[ x, y ] * 1/4\n                    New_List.add( (max( 0, x - 2 ), max( 0, y - 2 )) )\n                    Matrix[ max( 0, x - 1 ), max( 0, y - 3 ) ] += Matrix[ x, y ] * 1/4\n                    New_List.add( (max( 0, x - 1 ), max( 0, y - 3 )) )\n                    Matrix[ max( 0, x - 3 ), max( 0, y - 1 ) ] += Matrix[ x, y ] * 1/4\n                    New_List.add( (max( 0, x - 3 ), max( 0, y - 1 )) )\n                    Matrix[ max( 0, x - 4 ), max( 0, y - 0 ) ] += Matrix[ x, y ] * 1/4\n                    New_List.add( (max( 0, x - 4 ), max( 0, y - 0 )) )\n\n            Explore_List = New_List\n            \n        return Matrix[ 0 ].sum() - 1/2 * Matrix[ 0, 0 ]\n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        operations = [(100, 0), (75, 25), (50, 50), (25, 75)]\n        @lru_cache(maxsize=None)\n        def helper(remainA, remainB):\n            if remainA == 0 and remainB == 0:\n                return 0.5\n\n            if remainA == 0 or remainB == 0:\n                return remainA == 0\n\n            result = 0\n            for op in operations:\n                result += helper(max(0, remainA - op[0]), max(0, remainB - op[1]))\n\n            return result / 4\n        \n        N = min(N, 4801)\n        return helper(N, N)", "class Solution:\n    def soupServings(self, N: int) -> float:\n        \n        def prob(A,B,dp):\n            \n            \n        \n            if A==0 and B==0:\n                return 0.5\n            \n            if A==0:\n                return 1.0\n            \n            if dp[A][B]!=-1.0:\n                return dp[A][B]\n            \n            else:\n                \n                total_prob=0\n                total_prob+=1/4*prob(max(0,A-100),B,dp)\n                \n                if B-25>0 or (A-75<=0 and B-25<=0):\n                    total_prob+= 1/4*prob(max(0,A-75),max(0,B-25),dp)\n                \n                if B-50>0 or (A-50<=0 and B-50<=0):\n                    total_prob += 1/4*prob(max(0,A-50),max(0,B-50),dp)\n                \n                if B-75>0 or (A-25<=0 and B-75<=0):\n                    total_prob += 1/4*prob(max(0,A-25),max(0,B-75),dp)\n                \n                dp[A][B]=total_prob\n                \n                return dp[A][B]\n                    \n        \n        \n        if N>4800:\n            return 1.0\n        dp=[[-1.0 for i in range(N+1)] for j in range(N+1)]\n        \n        return prob(N,N,dp)", "class Solution:\n    def soupServings(self, N: int) -> float:\n        if(N>5000):\n            return 1\n        dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n        return (self.helper(N,N,dp))\n        \n    def helper(self,A,B,dp):\n        if(A<=0 and B<=0):\n            return 0.5\n        if(A<=0):\n            return 1\n        if(B<=0):\n            return 0\n        if(dp[A][B]!=-1):\n            return dp[A][B]\n        \n        dp[A][B] = (self.helper(A-100,B-0,dp) + self.helper(A-75,B-25,dp) + self.helper(A-50,B-50,dp)+self.helper(A-25,B-75,dp))*0.25\n        return dp[A][B]", "class Solution:\n    def soupServings(self, N: int) -> float:\n        compressed_N = N // 25\n        N = compressed_N + (1 if (N-compressed_N*25)>0 else 0)\n        \n        mem = {}\n        \n        def dp(a, b):\n            if (a, b) in mem:\n                return mem[(a,b)]\n            else:\n                if a <= 0 or b <= 0:\n                    result = 0.5 if a <=0 and b <= 0 else 1.0 if a <= 0 else 0.0\n                else:\n                    result = 0.25 * (dp(a-4, b) + dp(a-3, b-1) + dp(a-2, b-2) + dp(a-1, b-3))\n                mem[(a,b)] = result\n                return result\n        \n        if N <= 200:\n            return dp(N, N)\n        else:\n            for i in range(200, N+1):\n                current_result = dp(i, i)\n                if 1 - current_result < 1e-6:\n                    return 1.0\n            return current_result\n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        memo = {}\n        if N > 4800:\n            return 1\n        def dp(a ,b):\n            if (a, b) in memo: return memo[a, b]\n            if a <= 0 and b > 0: return 1\n            if a <= 0 and b <= 0: return 0.5\n            if a > 0 and b <= 0: return 0\n            memo[a, b] = (dp(a - 100, b) + dp(a - 75, b - 25) + dp(a - 50, b - 50) + dp(a - 25, b - 75)) / 4\n            return memo[a, b]\n        return dp(N, N)", "class Solution:\n    def soupServings(self, N: int) -> float:\n        compressed_N = N // 25\n        N = compressed_N + (1 if (N-compressed_N*25)>0 else 0)\n        \n        mem = {}\n        \n        def dp(a, b):\n            if (a, b) in mem:\n                return mem[(a,b)]\n            else:\n                if a <= 0 or b <= 0:\n                    result = 0.5 if a <=0 and b <= 0 else 1.0 if a <= 0 else 0.0\n                else:\n                    result = 0.25 * (dp(a-4, b) + dp(a-3, b-1) + dp(a-2, b-2) + dp(a-1, b-3))\n                mem[(a,b)] = result\n                return result\n        \n        if N <= 100:\n            return dp(N, N)\n        else:\n            for i in range(100, N+1):\n                current_result = dp(i, i)\n                if 1 - current_result < 1e-6:\n                    return 1.0\n            return current_result\n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        # 5:02 10/4/20\n        \n        def dfs(a,b):\n            if a<=0 and b<=0:\n                return 0.5\n            if a<=0 and b>0:\n                return 1\n            if a>0 and b<=0:\n                return 0\n            if memo[a][b]!=-1:\n                return memo[a][b]\n            memo[a][b]=0.25*(dfs(a-4,b)+dfs(a-3,b-1)+dfs(a-2,b-2)+dfs(a-1,b-3))\n            return memo[a][b]\n        if N>=5000:\n            return 1\n        n=N//25+int(N%25>0)\n        memo=[[-1]*200  for _ in range(200)]\n        return dfs(n,n)\n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        Q, R = divmod(N, 25)\n        N = Q + (R > 0)\n        if N >= 500: return 1\n\n        memo = {}\n        def dp(x, y):\n            if (x, y) not in memo:\n                if x <= 0 or y <= 0:\n                    ans = 0.5 if x<=0 and y<=0 else 1.0 if x<=0 else 0.0\n                else:\n                    ans = 0.25 * (dp(x-4,y)+dp(x-3,y-1)+dp(x-2,y-2)+dp(x-1,y-3))\n                memo[x, y] = ans\n            return memo[x, y]\n\n        return dp(N, N)", "class Solution:\n    \n    def soupServings(self, N: int) -> float:\n    \n        if N >= 12500:\n            return 1\n        \n        self.memory = {}\n        return self.helper(N, N)\n    \n    def helper(self, A, B):\n        \n        if (A, B) in self.memory:\n            return self.memory[(A,B)]        \n        elif A <= 0 and B <= 0:\n            return 0.5\n        elif B <= 0:\n            return 0\n        elif A <= 0:\n            return 1\n        \n        prob = 0\n        # option1 \n        prob += 0.25*self.helper(A-100, B)\n        \n        # option2\n        prob += 0.25*self.helper(A-75, B-25)\n        \n        # option3\n        prob += 0.25*self.helper(A-50, B-50)\n        \n        # option4\n        prob += 0.25*self.helper(A-25, B-75)\n        \n        self.memory[(A,B)] = prob\n        return prob\n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        if N > 4800: return 1\n        @lru_cache(None)\n        def dfs(a, b):\n            if a <= 0 and b <= 0: \n                return 0.5\n            if a <= 0: return 1\n            if b <= 0: return 0\n            return (dfs(a-100, b)+dfs(a-75,b-25)+dfs(a-50,b-50)+dfs(a-25,b-75))/4\n        return dfs(N, N)\n", "class Solution:\n    def soupServings(self, N: int) -> float:\n        if N > 5555:\n            return 1\n\n        memo = dict()\n        def Pa(A, B):\n            if (A, B) in memo:\n                return memo[(A, B)]\n            if A <= 0 and B <= 0:\n                return 0.5\n            if A <= 0:\n                return 1\n            if B <= 0:\n                return 0\n            else:\n                memo[(A, B)] = (Pa(A-100, B) + Pa(A-75, B-25) + Pa(A-50, B-50) + Pa(A-25, B-75)) / 4\n                return memo[(A, B)]\n\n        return Pa(N, N)"]
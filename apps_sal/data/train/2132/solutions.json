["import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef main():\n    n = I()\n    aa = [LI() for _ in range(n-1)]\n    e = collections.defaultdict(set)\n    for a,b in aa:\n        e[a].add(b)\n        e[b].add(a)\n\n    q = [[(1,-1)]]\n    qi = 0\n    while 1:\n        t = q[qi]\n        nq = []\n        for i,p in t:\n            for c in e[i]:\n                if c == p:\n                    continue\n                nq.append((c,i))\n        if len(nq) < 1:\n            break\n        q.append(nq)\n        qi += 1\n\n    gm = [1]\n    for i in range(1,n+1):\n        gm.append(i*gm[-1]%mod)\n\n    m = {}\n    def f(i, p):\n        t = 1\n        r = 1\n        for c in e[i]:\n            if c == p:\n                continue\n            # print('c',c)\n            r *= m[c]\n            r %= mod\n            t += 1\n\n        if p == -1:\n            r *= gm[t-1]\n            r *= n\n        else:\n            r *= gm[t]\n        r %= mod\n        m[i] = r\n        # print('r',i,p,r)\n        # print('g',gm[t],t)\n        return r\n\n    for qt in q[::-1]:\n        for i,p in qt:\n            # print('ip', i,p)\n            f(i,p)\n\n    r = f(1,-1)\n\n    return r\n\n\nprint(main())\n\n", "import sys\ninput = sys.stdin.readline\nMOD = 998244353\nfa = [1]\nfor i in range(1, 2*10**5+10):\n    fa.append(fa[-1]*i%MOD)\n\nN = int(input())\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = list(map(int, input().split()))\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\nP = [-1] * N\nQ = [0]\nwhile Q:\n    i = Q.pop()\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            Q.append(a)\n\nans = N\nfor i in range(len(X)):\n    ans = ans * fa[len(X[i])+(1 if i else 0)] % MOD\nprint(ans)\n", "p=998244353\nn=int(input())\nfacs=[1]\nfor i in range(1,n):\n    facs.append(facs[-1]*i%p)\ngraph=[[] for i in range(n)]\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    graph[u-1].append(v-1)\n    graph[v-1].append(u-1)\nprod=facs[len(graph[0])]*n\nfor i in range(1,n):\n    k=len(graph[i])\n    prod=prod*facs[k]%p\nprint(prod)", "p=998244353\nn=int(input())\nfacs=[1]\nfor i in range(1,n):\n    facs.append(facs[-1]*i%p)\ngraph=[0]*n\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    graph[u-1]+=1\n    graph[v-1]+=1\nprod=n\nfor i in range(n):\n    prod=prod*facs[graph[i]]%p\nprint(prod)", "mod=998244353\nn=int(input())\ndeg=[0]*(n+1)\nfac=[1]*(n+1)\nfor i in range(1,n+1):\n    fac[i]=(fac[i-1]*i)%mod\nfor i in range(n-1):\n    a,b=list(map(int,input().split()))\n    deg[a]+=1\n    deg[b]+=1\ns=1\nfor i in range(1,n+1):\n    s=(s*(fac[deg[i]]))%mod\ns=(s*n)%mod\nprint(s)\n    \n", "import io, os\n#input = io.StringIO(os.read(0, os.fstat(0).st_size).decode()).readline\n\n\ng = [0] * 200005\n\nr = int(input())\nn = r\n\nfor i in range(1, n):\n\tu, v = list(map(int, input().split()))\n\tg[u] += 1\n\tg[v] += 1\n\tr *= g[u] * g[v]\n\tr %= 998244353\n\nprint(r)\n", "import math\ndef factorial(n,j):\n    inf=998244353\n    j[0]=1\n    j[1]=1\n    for i in range(2,n+1):\n        j[i]=j[i-1]*i\n        j[i]%=inf\n    return j\n\n\nl1=[0]*(200009)\ny=factorial(200008,l1)\ninf=998244353\nn=int(input())\nl=[0]*(200009)\nx=1\nfor i in range(n-1):\n    u,v=input().split()\n    u,v=[int(u),int(v)]\n    l[u]+=1\n    l[v]+=1\nfor i in range(len(l)):\n    if l[i]>0:\n        x*=y[l[i]]\n        x%=inf\nprint((n*x)%inf)\n", "import math\ndef factorial(n,j):\n    inf=998244353\n    j[0]=1\n    j[1]=1\n    for i in range(2,n+1):\n        j[i]=j[i-1]*i\n        j[i]%=inf\n    return j\n\n\nl1=[0]*(200009)\ny=factorial(200008,l1)\ninf=998244353\nn=int(input())\nl=[0]*(200009)\nx=1\nfor i in range(n-1):\n    u,v=input().split()\n    u,v=[int(u),int(v)]\n    l[u]+=1\n    l[v]+=1\nfor i in range(len(l)):\n    if l[i]>0:\n        x*=y[l[i]]\n        x%=inf\nprint((n*x)%inf)\n", "\ng = [0] * 200005\n \nr = int(input())\nn = r\n \nfor i in range(1, n):\n\tu, v = map(int, input().split())\n\tg[u] += 1\n\tg[v] += 1\n\tr *= g[u] * g[v]\n\tr %= 998244353\n\n\nprint(r)", "import  sys\ninput=sys.stdin.readline\n#sys.setrecursionlimit(1000000)\n\nn=int(input())\nfr=[0]*(n+2)\nfr[0]=1\nd=[0]*(n+2)\nmod=int(998244353)\n\nfor i in range(1,n+1):\n    fr[i]=(fr[i-1]*i)%mod\n\nfor i in  range(n-1):\n    u,v=map(int,input().split())\n    d[u]+=1;d[v]+=1\n\nans=n\n\nfor i in range(1,n+1):\n    ans=ans*fr[d[i]]\n    ans%=mod\n\nprint(ans)"]
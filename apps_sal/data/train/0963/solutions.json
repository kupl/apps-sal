["def solve(l):\r\n   m = l.index(max(l))\r\n   if m == 0 or m == len(l) - 1:\r\n      return 1\r\n   return 1 + min(solve(l[0:m]), solve(l[m+1:]))\r\n\r\ntc = int(input())\r\nfor test in range(tc):\r\n   n = int(input())\r\n   l = list(map(int, input().split()))\r\n   print(solve(l))", "def solve(l):\r\n   m = l.index(max(l))\r\n   if m == 0 or m == len(l) - 1:\r\n      return 1\r\n   return 1 + min(solve(l[0:m]), solve(l[m+1:]))\r\n\r\ntc = int(input())\r\nfor test in range(tc):\r\n   n = int(input())\r\n   l = list(map(int, input().split()))\r\n   print(solve(l))", "def solve(l):\r\n   m = l.index(max(l))\r\n   if m == 0 or m == len(l) - 1:\r\n      return 1\r\n   return 1 + min(solve(l[0:m]), solve(l[m+1:]))\r\n\r\ntc = int(input())\r\nfor test in range(tc):\r\n   n = int(input())\r\n   l = list(map(int, input().split()))\r\n   print(solve(l))", "# cook your dish here\n        \ndef hill(lst):\n    maxm = lst.index(max(lst))\n\n    if maxm == 0 or maxm == len(lst) -1:\n        return 1\n    else:\n        return 1 + min(hill(lst[:maxm]), hill(lst[maxm + 1:]))\n\n    \n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    \n    lst = list(map(int, input().split(' ')))\n\n    print(hill(lst))\n", "def reservoirs(lhills):\r\n    hmax=lhills[0]\r\n    for i in lhills:\r\n        if i>hmax:\r\n            hmax=i\r\n    j=lhills.index(hmax)\r\n    if (j==0 or j==len(lhills)-1):\r\n        return 1\r\n    else:\r\n        return 1+min(reservoirs(lhills[:j]),reservoirs(lhills[j+1:]))\r\nt=int(input())\r\nfor _ in range(t):\r\n    n=int(input())\r\n    lhills=list(map(int,input().strip().split()))\r\n    print(reservoirs(lhills))", "def p(l):\r\n    n2=len(l)\r\n    m=l.index(max(l))\r\n    if m<1 or m>n2-2:\r\n        return 1\r\n    return 1+min(p(l[:m]), p(l[m+1:]))\r\nt=int(input())\r\nsolution=[]\r\nfor r in range (t):\r\n    n=int(input())\r\n    a=list(map(int, input().split()))\r\n    solution.append(p(a))\r\nprint(*solution, sep=\"\\n\")\r\n    \r\n", "def get_count(hills):\r\n    max_ = hills.index(max(hills))\r\n\r\n    if not max_ or max_ == len(hills) - 1:  return 1\r\n    return 1 + min(get_count(hills[:max_]), get_count(hills[max_+1:]))\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    arr = list(map(int, input().split()))\r\n\r\n    print(get_count(arr))", "def select_hill(hills):\n    m = hills.index(max(hills))\n    if m==0 or m==len(hills)-1 :\n        return 1\n    else:\n\t    return 1 + min(select_hill(hills[:m]),select_hill(hills[m + 1:]))\n    \n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    hills = list(map(int,input().split()))\n    print(select_hill(hills))", "import math\ndef res(n):\n\tl = len(n)\n\tmaxx = max(n)\n\ti = n.index(maxx)\n\tif(i == 0 or i == l - 1):\n\t\treturn 1\n\telse:\n\t\treturn 1 + min(res(n[:i]),res(n[i + 1:]))\n\n\n\nfor _ in range(int(input())):\n\tn = int(input())\n\tl=list(map(int,input().split()))\n\tprint(res(l))", "import math\ndef res(n):\n\tl = len(n)\n\tmaxx = max(n)\n\ti = 0\n\ti = n.index(maxx)\n\tif(i == 0 or i == l - 1):\n\t\treturn 1\n\telse:\n\t\treturn 1 + min(res(n[:i]),res(n[i + 1:]))\n\n\n\nfor _ in range(int(input())):\n\tn = int(input())\n\tl=list(map(int,input().split()))\n\tprint(res(l))", "# cook your dish here\nimport math\ndef res(n):\n\tl=len(n)\n\tmaxx=max(n)\n\ti=0\n\ti=n.index(maxx)\n\tif(i==0 or i==l-1):\n\t\treturn 1\n\telse:\n\t\treturn 1+min(res(n[:i]),res(n[i+1:]))\n\n\n\nt=int(input())\nwhile(t>0):\n\tt-=1\n\tn=int(input())\n\t#k,r=map(int,input().split())\n\tl=list(map(int,input().split()))\n\tprint(res(l))", "# cook your dish here\nT=int(input())\ndef maxk(arr,start,end):\n    maxno=arr[start]\n    maxi=start\n    for i in range(start,end):\n        if(arr[i]>maxno):\n            maxno=arr[i]\n            maxi=i\n    return maxi\n    \ndef rec(arr,start,end):\n    i=maxk(arr,start,end)\n    if(i==start or i==end-1):\n        return 1\n    #elif(i>start+int((end-start)/2)):\n    #    return 1+rec(arr,i+1,end)\n    #elif(i<start+int((end-start)/2)):\n    #    return 1+rec(arr,start,i)\n    else:\n        return 1+min(rec(arr,i+1,end),rec(arr,start,i))\n        \nfor t in range(T):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    \n    start=0\n    end=n\n    \n    count=rec(arr,start,end)\n            \n    print(count)", "def rec(h,low,high):\n    maxIndex=low\n    for i in range(low+1,high+1):\n        if h[i]>h[maxIndex]:\n            maxIndex = i\n    if maxIndex==low or maxIndex==high:\n        return 1\n    else:\n        return 1 + min(rec(h,low,maxIndex-1),rec(h,maxIndex+1,high))\nt = int(input())\nfor T in range(t):\n    n = int(input())\n    h = list(map(int,input().split()))\n    print(rec(h,0,n-1))", "for _ in range(int(input())):\r\n    n=int(input())\r\n    l=list(map(int,input().split()))\r\n    def func(l):\r\n        m=max(l)\r\n        m=l.index(m)\r\n        if(m==len(l)-1 or m==0):\r\n            return 1\r\n        ll=l[:m]\r\n        rl=l[m+1:]\r\n        return 1+min(func(rl),func(ll))\r\n    print(func(l))\r\n", "for i in range(int(input())):\n    n=int(input())\n    count = 0\n    hill = list(map(int, input().split()))\n    def res(hills):\n        maxval = max(hills)\n        maxpos = hills.index(maxval)\n        \n        left=list()\n        right=list()\n        \n        if maxpos is 0 or maxpos is len(hills)-1 :\n            return 1\n        \n        for j in range(maxpos):\n            left.append(hills[j])\n        for j in range(maxpos+1,len(hills)):\n            right.append(hills[j])\n        \n        return 1+min(res(right),res(left))\n    \n    print(res(hill))", "\n\n\n\n\nfor _ in range(0, int(input())):\n\n    N = int(input())\n\n    count = 0\n\n    hillsH = list(map(int, input().split()))\n    \n    def FindAns(hills):\n        maxIndex = 0\n        maxNum = max(hills)\n        maxIndex = hills.index(maxNum)\n    \n        listRight = []\n        listLeft = []\n\n        if maxIndex == 0 or maxIndex == len(hills) - 1:\n            return 1\n\n        for i in range(0, maxIndex):\n            listLeft.append(hills[i])\n\n        for i in range(maxIndex+1, len(hills)):\n            listRight.append(hills[i])\n\n        return 1 + min(FindAns(listLeft), FindAns(listRight)) \n        \n    print(FindAns(hillsH))", "# cook your dish here\nfor _ in range(int(input())):\n    n = int(input())\n    h = list(map(int,input().split()))\n    def res(a):\n        n=len(a)\n        max1=max(a)\n        ind=0\n        ind=a.index(max1)\n        if(ind==0 or ind==n-1):\n            return 1\n        else:                                         \n            return 1+ min(res(a[:ind]),res(a[ind+1:]))\n    print(res(h))", "from functools import lru_cache\n\nkases = int(input())\nwhile kases > 0:\n    kases = kases - 1\n    T = int(input())\n    arr = list(map(int, input().split(\" \")))\n    @lru_cache(maxsize=500)\n    def ans(i, j):\n        if i > j:\n            return 0\n        val = arr[i]\n        x = i\n        k = i\n        while k <= j:\n            if arr[k] > val:\n                val = arr[k]\n                x = k\n            k = k + 1\n        if x == i or x == j:\n            return 1\n        return 1 + min(ans(i, x - 1), ans(x + 1, j))\n    print(ans(0, T - 1))\n\n", "# cook your dish here\n#import math\ndef res(n):\n\tl=len(n)\n\tmaxx=max(n)\n\ti=0\n\ti=n.index(maxx)\n\tif(i==0 or i==l-1):\n\t\treturn 1\n\telse:\n\t\treturn 1+min(res(n[:i]),res(n[i+1:]))\n\n\n\nt=int(input())\nwhile(t>0):\n\tt-=1\n\tn=int(input())\n\t#k,r=map(int,input().split())\n\tl=list(map(int,input().split()))\n\tprint(res(l))", "t=int(input())\nfor i in range(t):\n    n=int(input())\n    h=list(map(int,input().split()))\n    def res(a):\n        n=len(a)\n        max1=max(a)\n        ind=0\n        ind=a.index(max1)\n        if(ind==0 or ind==n-1):\n            return 1\n        else:                                         \n            return 1+ min(res(a[:ind]),res(a[ind+1:]))\n    print(res(h))\n        \n", "def find_max(A,s,e):\n    m=0\n    m_index=s\n    for i in range(s,e+1):\n       if(A[i]>m):\n           m=A[i]\n           m_index=i\n    return m_index\n        \n        \ndef solution(A,s,e,ans):\n    m_index=find_max(A,s,e)\n    if(m_index==s or m_index==e):\n        ans=ans+1\n        return ans\n    return min(solution(A,m_index+1,e,ans+1),solution(A,s,m_index-1,ans+1))\n    \n    \n    \nT=int(input())\nfor _ in range(T):\n    N=int(input())\n    A=[int(x) for x in input().split()]\n    ans=solution(A,0,N-1,0)\n    print(ans)\n            \n            \n    ", "def large(a,i,j):\r\n    b=i\r\n    maxo=a[i]\r\n    t=i\r\n    while(b<=j):\r\n        if(a[b]>maxo):\r\n            maxo=a[b]\r\n            t=b\r\n        b=b+1\r\n    \r\n    return t\r\ndef f(a,i,j,count):\r\n    p=large(a,i,j)\r\n    if(p==i or p==j):\r\n        count=count+1\r\n        return count\r\n    else:\r\n        return min(f(a,i,p-1,count+1),f(a,p+1,j,count+1))\r\nt=int(input())\r\nfor x in range(t):\r\n    n=int(input())\r\n    a=list(map(int,input().split()))\r\n    print(f(a,0,n-1,0))\r\n", "\ndef solve(ar):\n    max = 0\n    posn = -1\n    for i in range(len(ar)):\n        if ar[i]>max:\n            max = ar[i]\n            posn = i\n\n    if posn == 0 or posn == len(ar)-1:\n        return 1\n\n\n    return 1+min(solve(ar[:posn]),solve(ar[posn+1:]))\n\n\n\n\n\n\n\n\n\n\nt = int(input())\n\nfor i in range(t):\n    n = int(input())\n    h = list(map(int,input().split()))\n    z = solve(h)\n    print(z)\n\n\n\n\n\n\n", "# N,M = map(int, input().split())\nT = int(input())\n\n\nfrom copy import copy\ndef dfs(lst): \n    topi = -1\n    topv = 0\n    for i,e in enumerate(lst):\n        if topv < e:\n            topv = e\n            topi = i\n    # print(\"top: \", topi, topv)\n    if topi == 0 or topi == len(lst)-1:\n        return 1\n\n    else:\n        return 1 + min(dfs(lst[:topi]), \n                   dfs(lst[topi+1:]))\n\nfor t in range(T):\n    N = int(input())\n    H = list(map(int, input().split()))\n    ans = dfs(H)\n\n    print(ans)\n\n"]
["from functools import reduce\n\ndef modpow(a, n, m):\n    if n == 0:\n        return 1\n    tmp = modpow(a, n // 2, m)\n    if n % 2 == 0:\n        return tmp * tmp % m\n    else:\n        return tmp * tmp * a % m\n\ndef modinv(a, m):\n    return modpow(a, m - 2, m)\n\nn, m = [int(_) for _ in input().split(' ')]\ns = sum([int(_) for _ in input().split(' ')])\n\nM = 1_000_000_007\nproduct = lambda x1, x2: x1 * x2 % M\n\nprint((reduce(product, list(range(m - s + 1, m + n + 1))) * modinv(reduce(product, list(range(1, s + n + 1))), M) % M))\n", "n,m,*a=map(int,open(0).read().split())\nd=10**9+7\nl=1\nr=1\nfor i in range(n+sum(a)):\n    l,r=l*(n+m-i)%d,r*(i+1)%d\nprint(l*pow(r,d-2,d)%d)", "def mod_combination(n, k, mod = 10 ** 9 + 7):\n    def extended_gcd(a, b):\n        if b == 0:\n            return (a, 1, 0)\n        d, x, y = extended_gcd(b, a % b)\n        return (d, y, x - (a // b) * y)\n    p, q = 1, 1\n    for i in range(n - k + 1, n + 1):\n        p = (p * i) % mod\n    for i in range(2, k + 1):\n        q = (q * i) % mod\n    return p * (extended_gcd(q, mod)[1] % mod) % mod\n\n\nN, M, *A = map(int, open(0).read().split())\n\nS = sum(A)\nprint(mod_combination(M + N, S + N))", "n,m = map(int,input().split())\na = list(map(int,input().split()))\nmod = 10**9+7\n\ns = sum(a)\nfact = 1\nans = 1\nfor i in range(s+n):\n    ans *= (m+n-i)\n    ans %=mod\n    fact *= (i+1)\n    fact %= mod\n    \nans *= pow(fact,mod-2,mod)\nprint(ans%mod)", "import itertools\nN, M, *A = [int(_) for _ in open(0).read().split()]\n\n\nclass Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * (max_fact + 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx\n            f[idx] %= mod\n        if mod > max_fact:\n            fi = [pow(f[-1], mod - 2, mod)]\n            for idx in range(max_fact, 0, -1):\n                fi += [fi[-1] * idx % mod]\n            fi = fi[::-1]\n        else:\n            fi = [pow(n, mod - 2, mod) for n in f]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        if n < r:\n            return 0\n        elif n < 2 * r:\n            r = n - r\n        f = self.f\n        fi = self.fi\n        mod = self.mod\n        if n < len(f):\n            return f[n] * fi[r] * fi[n - r] % mod\n        if r < len(f):\n            ret = fi[r]\n            for _ in range(r):\n                ret *= n\n                ret %= mod\n                n -= 1\n            return ret\n        else:\n            1 / 0\n\n    def permutation(self, n, r):\n        f = self.f\n        fi = self.fi\n        mod = self.mod\n        if n < len(f):\n            return f[n] * fi[n - r] % mod\n        elif r < len(f):\n            ret = 1\n            for _ in range(r):\n                ret *= n\n                ret %= mod\n                n -= 1\n            return ret\n        else:\n            1 / 0\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nsuma = sum(A)\nmax_fact = suma + N\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\n\nans = comb(M + N, N + suma)\nprint(ans)\n'''\nans = 0\nfor bs in itertools.product(range(M + 1), repeat=N):\n    f = 0\n    if sum(bs) > M:\n        continue\n    ans += list(\n        itertools.accumulate([comb(b, a) for a, b in zip(A, bs)],\n                             func=lambda x, y: x * y % mod))[-1]\n    ans %= mod\nprint(ans)\n'''\n'''\nans(N, M, sum(A))\n\nans(3, 1, 1) = C[4, 0]\nans(3, 2, 2) = C[5, 0]\nans(3, 3, 3) = C[6, 0]\n\nans(3, 4, 4) = C[7, 0]\n\nans(3, 6, 5) = C[9, 1]\nans(4, 6, 5) = C[10, 1]\n\nans(N, M, sum(A)) = C[N + M, M - sum(A)]\n'''\n", "import sys\ninput = sys.stdin.readline\n\nN,M=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nmod=10**9+7\n\nSUM=sum(A)\nr=M-SUM\nS=r+SUM+N\n\nF=1\nfor i in range(1,S-r+1):\n    F=F*i%mod\n\n\nif M<SUM:\n    print((0))\nelse:\n    ANS=1\n    y=1\n    for i in range(S-r):\n        ANS=ANS*S%mod\n        S-=1\n    ANS=ANS*pow(F,mod-2,mod)%mod\n\n\n    print(ANS)\n\n        \n    \n", "import sys\ninput = sys.stdin.readline\nfrom collections import deque, defaultdict, Counter\nfrom itertools import permutations, combinations, accumulate\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right\n\nSI = lambda: input()\nNI = lambda:int(input())\nMI = lambda:map(int, input().split())\ncutLF = lambda x:list(x)[:-1] if x[-1]=='\\n' else list(x)\nstrLST = lambda:cutLF(input())\n\nn,m=MI()\n*a,=MI()\ns=sum(a)\nmod=10**9+7\nhidari=[]\nstart=n+m\nfor i in range(n+s):\n    hidari.append(start-i)\n    \nleft=1\nright=1\nfor i in range(n+s):\n    left*=hidari[i]\n    left%=mod\n    right*=(i+1)\n    right%=mod\n\nprint(left*pow(right,mod-2,mod)%mod)", "import sys\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef modInverse(a, p):\n    return pow(a, p - 2, p)\n\n\ndef modBinomial(n, k, p):\n    k = min(k, n - k)\n    numerator = 1\n    for i in range(k):\n        numerator = (numerator * (n - i)) % p\n\n    denominator = 1\n    for i in range(1, k + 1):\n        denominator = (denominator * i) % p\n\n    return (numerator * modInverse(denominator, p)) % p\n\n\ndef main():\n    N, M = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n\n    MOD = 10 ** 9 + 7\n\n    if sum(A) > M:\n        print((0))\n        return\n\n    r = sum(A) + N\n\n    print((modBinomial(M + N, r, MOD)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "P = 10 ** 9 + 7\nN, M = map(int, input().split())\nA = [int(a) for a in input().split()]\ns = sum(A)\nu = 1\nv = 1\nfor i in range(M - s + 1, N + M + 1):\n    u = u * i % P\nfor i in range(1, s + N + 1):\n    v = i * v % P\nprint(u * pow(v, P - 2, P) % P)", "n, m = map(int, input().split())\na = list(map(int, input().split()))\ns = sum(a)\nmod = 10 ** 9 + 7\nans, cnt = 1, 1\nfor i in range(n + m, m - s, -1):\n    ans *= i\n    ans %= mod\nfor i in range(1, s + n + 1):\n    cnt *= i\n    cnt %= mod\nprint(ans * pow(cnt, mod - 2, mod) % mod)", "k = 72\nkk = k // 4\nK = 1<<k\nnu = lambda L: int(\"\".join([hex(K+a)[3:] for a in L[::-1]]), 16)\nst = lambda n: hex(n)[2:]\nli = lambda s, l, r: [int(a, 16) % P if len(a) else 0 for a in [s[-(i+1)*kk:-i*kk] for i in range(l, r)]]\n\ndef grow(d, v, h, start):\n    h += [0] * d\n    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]\n    nuf = nu(f)\n    a = d * inv[v] % P\n    t = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        t[i] = t[i-1] * (a - d + i - 1) % P\n    ti = [1] * (3*d+3)\n    ti[-1] = pow(t[-1], P-2, P)\n    for i in range(1, 3*d+3)[::-1]:\n        ti[i-1] = ti[i] * (a - d + i - 1) % P\n    iv = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        iv[i] = ti[i] * t[i-1] % P\n \n    ###\n    # g = [iv[i] for i in range(1, 2*d+2)]\n    g = iv[1:2*d+2]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d+1):\n        h[i] = h[i] * (fg[i] * t[d+i+1] % P * ti[i] % P) % P\n \n    ###\n    # g = [inv[i] for i in range(1, 2*d+2)]\n    g = inv[1:2*d+2]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d):\n        h[i+d+1] = fg[i] * fa[d+i+1] % P * fainv[i] % P\n \n    ###\n    # g = [iv[i] for i in range(d+2, 3*d+3)]\n    g = iv[d+2:3*d+3]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d):\n        h[i+d+1] = h[i+d+1] * (fg[i] * t[2*d+i+2] % P * ti[d+i+1] % P) % P\n \n    return h\n\n# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]\ndef create_table(v, start):\n    s = 1\n    X = [start, v + start]\n    while s < v:\n        X = grow(s, v, X, start)\n        s *= 2\n \n    table = [1]\n    for x in X:\n        table.append(table[-1] * x % P)\n    return table\n\ndef fact(i, table):\n    a = table[i//v]\n    for j in range(i//v*v+1, i+1):\n        a = a * j % P\n    return a\n\nP = 10 ** 9 + 7\nnn = 4000000\nv = 1 << (nn.bit_length() + 1) // 2\nfa = [1] * (2*v+2)\nfainv = [1] * (2*v+2)\nfor i in range(2*v+1):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(2*v+1)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\ninv = [0] * (2*v+2)\nfor i in range(1, 2*v+2):\n    inv[i] = fainv[i] * fa[i-1] % P\n\ndef prod(a, b, v): # a * (a + 1) * ... * (b - 1)\n    T = create_table(v, a)\n    c = b - a\n    s = T[c//v]\n    if c > 10:\n        vv = 1 << (c.bit_length() + 1) // 2\n        return s * prod(c // v * v + a, b, vv) % P\n    for i in range(c // v * v + a, b):\n        s = s * i % P\n    return s\n\ndef C(a, b):\n    if b * 2 > a: b = a - b\n    return prod(a - b + 1, a + 1, v) * pow(prod(1, b + 1, v), P - 2, P) % P\n\nif 1:\n    N, M = list(map(int, input().split()))\n    A = [int(a) for a in input().split()]\n    s = sum(A)\n    print((C(N + M, s + N) if M >= s else 0))\n\n\n# print(prod(1, nn, v))\n", "import bisect\nimport functools\nimport heapq\nimport itertools\nimport sys\nimport math\nimport random\nimport time\nfrom collections import Counter, deque, defaultdict\nfrom functools import reduce\nfrom operator import xor, itemgetter\nfrom pprint import pprint\nfrom types import FunctionType\nfrom typing import List, Any\nfrom sys import stdin\n\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 9)\n\ndef inp(): return stdin.readline().rstrip()\ndef lmi(): return list(map(int, stdin.readline().split()))\ndef narray(*shape, init: Any = 0):\n    if shape: return [narray(*shape[1:], init=init) for _ in range(shape[0])]\n    if callable(init): return init()\n    return init\n\n\ndef comb(N, k):\n    if (k > N) or (N < 0) or (k < 0):\n        return 0\n    N, k = list(map(int, (N, k)))\n    top = N\n    val = 1\n    while top > (N - k):\n        val *= top\n        top -= 1\n    n = 1\n    while n < k + 1:\n        val //= n\n        n += 1\n    return val\n\ndef cmb(x, y):\n    if x < y:\n        return 0\n    bunsi = 1\n    bunbo = 1\n    for i in range(1, y+1):\n        bunsi = (bunsi*(x+1-i)) % mod\n        bunbo = (bunbo*i) % mod\n    res = bunsi*pow(bunbo,mod-2,mod) % mod\n    return res\n\ndef main():\n    N, M = lmi()\n    A = lmi()\n    ans = cmb((M + N) % mod, (N + sum(A)) % mod) % mod\n    print(ans)\n\n\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "def binomial_coefficient(n, r, mod=10**9+7):\n    if r < 0 or r > n:\n        return 0\n    res = 1\n    div = 1\n    r = min(r, n - r)\n    for i in range(r):\n        res = res * (n - i) % mod\n        div = div * (i + 1) % mod\n    return res * pow(div, mod-2, mod) % mod\n\n\nmod = 10 ** 9 + 7\nn, m = map(int, input().split())\nA = list(map(int, input().split()))\nans = binomial_coefficient(n + m, sum(A) + n, mod)\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\nfrom itertools import accumulate\n\nsys.setrecursionlimit(10**6)\nINF = 10**12\np = 10**9 + 7\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    S = sum(A)\n    if M < S:\n        print((0))\n        return\n    # \u7b54\u3048\u306f(M+N)C(S+N)=(M+N)C(M-S)\n    ans = 1\n    div = 1\n    for i in range(N+S):\n        ans *= M + N - i\n        div *= N + S - i\n        ans %= p\n        div %= p\n        # print(ans, div)\n    print((ans*pow(div, p-2, p) % p))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN, M = mapint()\nAs = list(mapint())\nmod = 10**9 + 7\n\nSUM = sum(As)\nans = 1\nfor i in range(M-SUM+1, M+N+1):\n    ans *= i\n    ans %= mod\n\ninv = 1\nfor i in range(1, SUM+N+1):\n    inv *= i\n    inv %= mod\n\nprint(ans*pow(inv, mod-2, mod)%mod)", "# \u8003\u5bdf:\n#  1,\u4e00\u898b\u3059\u308b\u3068DP\u306e\u554f\u984c\u3002\n#    DP[m][i] = (B_1~B_i\u306e\u7dcf\u548c\u304cm\u3068\u306a\u308b\u3068\u304d\u3001i\u756a\u76ee\u307e\u3067\u3092\u639b\u3051\u7b97\u3057\u305f\u3082\u306e\u306e\u548c) \u3068\u3059\u308c\u3070\u3088\u3055\u305d\u3046\u3002\n#    \u3057\u304b\u3057\u3001M\u306e\u5236\u7d04\u304c\u5927\u304d\u3044\u3002\u4e0a\u306eDP\u306fO(MN)\u304b\u304b\u308b\u305f\u3081\u3001\u78ba\u5b9f\u306bTLE\u3059\u308b\u3002\n#  2,\u3044\u308d\u3044\u308d\u8003\u3048\u305f\u304c\u3001\u3084\u306f\u308aM\u306e\u5236\u7d04\u304c\u5927\u304d\u3059\u304e\u308b\u3002\u3082\u3063\u3068\u7c21\u5358\u306a\u8a08\u7b97\u5f0f\u304c\u3042\u308b\u306e\u3067\u306f\u306a\u3044\u304b\u3002\n#  3,\u6570\u3048\u4e0a\u3052\u306e\u554f\u984c\u3068\u3057\u3066\u6349\u3048\u308b\u3002\n#    (B_i A_i)\u306f\u3001\u3057\u304d\u308a\u3092A_i\u500b\u3001\u30dc\u30fc\u30eb\u3092K_i = (B_i-A_i)\u500b\u4e26\u3079\u308b\u5834\u5408\u306e\u6570\u3067\u3042\u308b\u3002\n#    \u639b\u3051\u7b97\u3057\u3066\u3044\u308b\u305f\u3081\u3001\u3057\u304d\u308aA_i\u500b\u3001\u30dc\u30fc\u30ebK_i\u500b\u306e\u30bb\u30af\u30b7\u30e7\u30f3(1~N)\u304c\u72ec\u7acb\u3057\u3066\u7f6e\u304b\u308c\u3066\u3044\u308b\u3068\u307f\u306a\u305b\u308b\u3002\n#    \u4f8b\uff1aN = 3, A = [1,2,3], K = B-A = [6,5,3]\u306e\u3068\u304d\n#     o o o | o o o (\u30bb\u30af\u30b7\u30e7\u30f31)\n#     o o | o | o o (\u30bb\u30af\u30b7\u30e7\u30f32)\n#     o | | o | o (\u30bb\u30af\u30b7\u30e7\u30f33)\n#    \u3055\u3089\u306bB_i\u3082\u53ef\u5909\u3002\u62d8\u675f\u6761\u4ef6\u306f\u3001\u4eca\u3042\u308b\u3057\u304d\u308a\u3068\u30dc\u30fc\u30eb\u306e\u5408\u8a08\u304cM\u500b\u4ee5\u4e0b\u3067\u3042\u308b\u3053\u3068\u306e\u307f\u3002\n#    \u30bb\u30af\u30b7\u30e7\u30f31~N\u3092\u6a2a\u4e26\u3079\u306b\u3057\u3066\u3001\u30bb\u30af\u30b7\u30e7\u30f3\u9593\u306b\u3055\u3089\u306b\u3057\u304d\u308a\u3092\u5c0e\u5165\u3059\u308b\u3002\n#    \u3055\u3089\u306b\u6700\u5f8c\u306e\u30bb\u30af\u30b7\u30e7\u30f3\u306e\u5f8c\u306b\u3057\u304d\u308a\u3092\u8a2d\u3051\u308b\u3002\n#    \u3057\u304d\u308a\u3068\u30dc\u30fc\u30eb\u306e\u5408\u8a08\u304cM\u500b\u306b\u6e80\u305f\u306a\u3044\u5834\u5408\u3001\u3053\u306e\u4ed5\u5207\u308a\u306e\u5f8c\u306b\u305d\u306e\u5206\u306e\u30dc\u30fc\u30eb\u3092\u7f6e\u304f\u3002\n#    \u4f8b\uff1aN = 3, A = [1,2,3], K = B-A = [6,5,3], M = 22(2\u500b\u3042\u307e\u308b)\u306e\u3068\u304d\n#     o o o | o o o x o o | o | o o x o | | o | o x o o  (\u30bb\u30af\u30b7\u30e7\u30f3\u9593\u306e\u3057\u304d\u308a\u3092\u300cx\u300d\u3068\u3057\u305f)\n#    \u3053\u3053\u3067\u30012\u7a2e\u985e\u306e\u3057\u304d\u308a\u3092\u533a\u5225\u3059\u308b\u5fc5\u8981\u304c\u306a\u3044\u3002\n#    (A_i\u304c\u6c7a\u307e\u3063\u3066\u3044\u308b\u305f\u3081\u3001\u3069\u306e\u4ed5\u5207\u308a\u304c\u3069\u3061\u3089\u306e\u610f\u5473\u306e\u3057\u304d\u308a\u3067\u3042\u308b\u304b\u306f\u4e00\u610f\u306b\u5fa9\u5143\u3067\u304d\u308b\u3002)\n#  \u7d50\u8ad6\uff1a\u3057\u304d\u308aN+\u03a3A\u500b\u3001\u30dc\u30fc\u30ebM-\u03a3A\u500b\u3092\u4e26\u3079\u308b\u5834\u5408\u306e\u6570\u3092\u6c42\u3081\u308c\u3070\u3088\u3044\u3002\n\nN, M = map(int,input().split())\nA = list(map(int,input().split()))\nmod = 10**9 + 7\n\ninvs = [0,1]\n\nX = N + M # \u3057\u304d\u308a\u3068\u30dc\u30fc\u30eb\u306e\u6570\u306e\u548c\nY = N + sum(A) # \u3057\u304d\u308a\u306e\u6570\n\ndef inv(x):\n  if x == 1: return 1\n  else: return  (-invs[mod % x] * (mod // x)) % mod\nfor i in range(2,Y+1): #\u4e8b\u524d\u306b\u9006\u5143\u8a08\u7b97\n  invs.append(inv(i))\n  \nans = 1\nfor i in range(Y): #(X Y)\u306e\u8a08\u7b97\n  ans *= (X-i) * invs[i+1]\n  ans %= mod\nprint(ans % mod)", "import sys\n\n\nclass IO:\n    @staticmethod\n    def get(type=str):\n        return type(input().strip())\n    \n    @staticmethod\n    def gets(type=str):\n        return [type(x) for x in input().split()]\n\n\ndef printerr(*args, **kw):\n    print(*args, **kw, file=sys.stderr)\n\n\ndef inv(n, p):\n    return pow(n, p-2, p)\n\ndef comb(n, k, p):\n    k = min(k, n-k)\n    t, d = 1, 1\n    for i in range(k):\n        t *= n - i\n        t %= P\n        d *= i+1\n        d %= P\n    return t * inv(d, P) % P\n\n\nP = 10 ** 9 + 7\n\ndef main():\n    n, m = IO.gets(int)\n    a = IO.gets(int)\n\n    x = sum(a) + n\n    dm = m - sum(a)\n    printerr(f\"x={x} dm={dm}\")\n\n    if dm < 0:\n        ans = 0\n    elif dm == 0:\n        ans = 1\n    else:\n        # ans = (1 - pow(x, m+1, P)) * inv(1 - x, P) % P\n        ans = comb(x+dm, dm, P)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "k = 72\nkk = k // 4\nK = 1<<k\ndef nu(L, sl = -1):\n    if sl == -1: sl = slice(0,len(L))\n    return int(\"\".join([hex(K+a)[3:] for a in L[sl][::-1]]), 16)\nst = lambda n: hex(n)[2:]\nli = lambda s, l, r: [int(a, 16) % P if len(a) else 0 for a in [s[-(i+1)*kk:-i*kk] for i in range(l, r)]]\n\ndef grow(d, v, h, start):\n    h += [0] * d\n    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]\n    nuf = nu(f)\n    a = d * inv[v] % P\n    t = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        t[i] = t[i-1] * (a - d + i - 1) % P\n    ti = [1] * (3*d+3)\n    ti[-1] = pow(t[-1], P-2, P)\n    for i in range(1, 3*d+3)[::-1]:\n        ti[i-1] = ti[i] * (a - d + i - 1) % P\n    iv = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        iv[i] = ti[i] * t[i-1] % P\n    ###\n    fg = li(st(nuf * nu(iv[1:2*d+2])), d, d * 2 + 1)\n    for i, (_fg, _ti) in enumerate(zip(fg, ti)):\n        h[i] = h[i] * (_fg * t[d+i+1] % P * _ti % P) % P\n    ###\n    fg1 = li(st(nuf * nu(inv[1:2*d+2])), d, d * 2 + 1)\n    fg2 = li(st(nuf * nu(iv[d+2:3*d+3])), d, d * 2 + 1)\n    fg1.pop()\n    for i, (_fg1, _fg2) in enumerate(zip(fg1, fg2)):\n        h[i+d+1] = _fg1 * _fg2 % P * fa[d+i+1] % P * fainv[i] % P * t[2*d+i+2] % P * ti[d+i+1] % P\n    return h\n\ndef create_table(v, start = 1):\n    s = 1\n    X = [start, v + start]\n    while s < v:\n        X = grow(s, v, X, start)\n        s *= 2\n    table = [1]\n    for x in X:\n        table.append(table[-1] * x % P)\n    return table\n\nP = 10 ** 9 + 7\nnn = 4000000\nv = 1 << (nn.bit_length() + 1) // 2\nfa = [1] * (2*v+2)\nfainv = [1] * (2*v+2)\nfor i in range(2*v+1):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(2*v+1)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\ninv = [0] * (2*v+2)\nfor i in range(1, 2*v+2):\n    inv[i] = fainv[i] * fa[i-1] % P\n\ndef prod(a, b, vv): # a * (a + 1) * ... * (b - 1) % P\n    T = create_table(vv, a)\n    c = b - a\n    s = T[c//vv]\n    for i in range(c // vv * vv + a, b):\n        s = s * i % P\n    return s\n\ndef C(a, b):\n    if not 0 <= b <= a: return 0\n    if b * 2 > a: b = a - b\n    return prod(a - b + 1, a + 1, v) * pow(prod(1, b + 1, v), P - 2, P) % P\n\nN, M = map(int, input().split())\ns = sum([int(a) for a in input().split()])\nprint(C(N + M, s + N))", "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    A = [int(a) for a in input().split()]\n    if M < sum(A):\n        print(0)\n        return 0\n    mod = 7 + 10 ** 9\n    \n    Ans = 1\n    sumA = sum(A)\n    for i in range(sumA + N):\n        Ans *= (M + N - i)\n        Ans %= mod\n    fact = 1\n    for i in range(1, sumA + N + 1):\n        fact *= i\n        fact %= mod\n    Ans *= pow(fact, mod - 2, mod)\n    print(Ans % mod)    \n    \n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "M=lambda:map(int,input().split())\nn,m=M()\na=sum(list(M()))\nd=10**9+7\nl=1\nr=1\nfor i in range(n+a):\n    l,r=l*(n+m-i)%d,r*(i+1)%d\nprint(l*pow(r,d-2,d)%d)", "import sys\n\nsys.setrecursionlimit(10**7)\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\ndef LS2(): return list(sys.stdin.readline().rstrip())\n\n\nN,M = MI()\nA = LI()\ns = sum(A)\nmod = 10**9+7\n\nif s > M:\n    print((0))\n    return\n\n# (M+N)_C_(s+N)\n\na = 1\nfor i in range(1,s+N+1):\n    a *= i\n    a %= mod\n\nans = pow(a,mod-2,mod)\nfor i in range(s+N):\n    ans *= M+N-i\n    ans %= mod\n\nprint(ans)\n", "from functools import reduce\n\ndef combination2(n, r, MOD=10**9+7):\n    if not 0 <= r <= n: return 0\n    r = min(r, n - r)\n    numerator = reduce(lambda x, y: x * y % MOD, range(n, n - r, -1), 1)\n    denominator = reduce(lambda x, y: x * y % MOD, range(1, r + 1), 1)\n    return numerator * pow(denominator, MOD - 2, MOD) % MOD\n\nN,M=map(int, input().split())\nA=list(map(int, input().split()))\nS=sum(A)\nprint(combination2(M+N,S+N))", "import sys\ndef input(): return sys.stdin.readline().rstrip()\n\ndef permutation(n, r, mod=10**9+7):  # \u9806\u5217\u6570\n    permutation = 1\n    for i in range(r):\n        permutation = permutation*(n-i) % mod\n    return permutation\n\ndef combination(n, r, mod=10**9+7):  # \u7d44\u307f\u5408\u308f\u305b\u6570\n    r = min(n-r, r)\n    bunshi = permutation(n, r, mod)\n    bunbo = 1\n    for i in range(1, r+1):\n        bunbo = bunbo*i % mod\n    return bunshi*pow(bunbo, mod-2, mod) % mod\n\n\ndef main():\n    mod = 10**9+7\n    mod2 = 998244353\n    n, m = map(int, input().split())\n    A = list(map(int, input().split()))\n    ans = 1\n    for AA in A:\n        ans *= AA\n        ans %= mod\n    sumA = sum(A)\n    if sumA > m:\n        print(0)\n    else:\n        nokori = m-sum(A)\n        print(combination(m+n, sumA+n, mod=10**9+7))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef modInverse(a, p):\n    return pow(a, p - 2, p)\n\n\ndef modBinomial(n, k, p):\n    k = min(k, n - k)\n    numerator = 1\n    for i in range(k):\n        numerator = (numerator * (n - i)) % p\n\n    denominator = 1\n    for i in range(1, k + 1):\n        denominator = (denominator * i) % p\n\n    return (numerator * modInverse(denominator, p)) % p\n\n\ndef main():\n    N, M = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n\n    MOD = 10 ** 9 + 7\n\n    if sum(A) > M:\n        print((0))\n        return\n\n    x = sum(A) + N + 1\n    sa = (M - sum(A))\n\n    nn = (x - 1 + sa)\n    rr = sa\n\n    print((modBinomial(nn, rr, MOD)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def comb(n, r, mod):\n    x, y = 1, 1\n    for i in range(n, n - r, -1):\n        x *= i\n        y *= i + r - n\n        x %= mod\n        y %= mod\n    return pow(y, mod - 2, mod) * x % mod\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nmod = pow(10, 9) + 7\nans = comb(n + m, n + sum(a), mod)\nprint(ans)", "import sys\nfrom collections import deque\nfrom copy import deepcopy\nfrom bisect import bisect_left, bisect_right, insort_left, insort_right\nfrom heapq import heapify, heappop, heappush\nfrom itertools import product, permutations, combinations, combinations_with_replacement\nfrom functools import reduce\nfrom math import gcd, sin, cos, tan, asin, acos, atan, degrees, radians\n\nsys.setrecursionlimit(10**6)\nINF = 10**20\neps = 1.0e-20\nMOD = 10**9+7\n\ndef lcm(x,y):\n    return x*y//gcd(x,y)\ndef lgcd(l):\n    return reduce(gcd,l)\ndef llcm(l):\n    return reduce(lcm,l)\ndef powmod(n,i,mod=MOD):\n    return pow(n,mod-1+i,mod) if i<0 else pow(n,i,mod)\ndef div2(x):\n    return x.bit_length()\ndef div10(x):\n    return len(str(x))-(x==0)\ndef intput():\n    return int(input())\ndef mint():\n    return map(int,input().split())\ndef lint():\n    return list(map(int,input().split()))\ndef ilint():\n    return int(input()), list(map(int,input().split()))\ndef judge(x, l=['Yes', 'No']):\n    print(l[0] if x else l[1])\ndef lprint(l, sep='\\n'):\n    for x in l:\n        print(x, end=sep)\ndef ston(c, c0='a'):\n    return ord(c)-ord(c0)\ndef ntos(x, c0='a'):\n    return chr(x+ord(c0))\nclass counter(dict):\n    def __init__(self, *args):\n        super().__init__(args)\n    def add(self,x,d=1):\n        self.setdefault(x,0)\n        self[x] += d\n    def list(self):\n        l = []\n        for k in self:\n            l.extend([k]*self[k])\n        return l\nclass comb():\n    def __init__(self, n, mod=None):\n        self.l = [1]\n        self.n = n\n        self.mod = mod\n    def get(self,k):\n        l,n,mod = self.l, self.n, self.mod\n        if k<0 or n<k:\n            return 0\n        k = n-k if k>n//2 else k\n        while len(l)<=k:\n            i = len(l)\n            l.append(l[i-1]*(n+1-i)//i if mod==None else (l[i-1]*(n+1-i)*powmod(i,-1,mod))%mod)\n        return l[k]\ndef pf(x,mode='counter'):\n    C = counter()\n    p = 2\n    while x>1:\n        k = 0\n        while x%p==0:\n            x //= p\n            k += 1\n        if k>0:\n            C.add(p,k)\n        p = p+2-(p==2) if p*p<x else x\n    if mode=='counter':\n        return C\n    S = set([1])\n    for k in C:\n        T = deepcopy(S)\n        for x in T:\n            for i in range(1,C[k]+1):\n                S.add(x*(k**i))\n    if mode=='set':\n        return S\n    if mode=='list':\n        return sorted(list(S))\n\n######################################################\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**4\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nN,M=mint()\nA=lint()\nS=sum(A)\nif S>M:\n    print(0)\n    return\n    \nn = S+N+M-S\nk = S+N\nmod = 10**9 + 7\n\n# def modinv(x):\n# x\u306e\u9006\u5143\u3092\u6c42\u3081\u308b\u969b\u306b[mod % x]\u306e\u9006\u5143\u304c\u5fc5\u8981\u306a\u306e\u3067\u3001\u95a2\u6570\u306e\u5f62\u3067x\u306e\u9006\u5143\u3092\u76f4\u63a5\u6c42\u3081\u308b\u3053\u3068\u306f\u96e3\u3057\u3044\u3002\u518d\u5e30\u3092\u4f7f\u3048\u3070\u884c\u3051\u305d\u3046\u3060\u3051\u3069\u3002\n\nmodinv_table = [-1] * (k+1)\nmodinv_table[1] = 1\nfor i in range(2, k+1):\n    modinv_table[i] = (-modinv_table[mod % i] * (mod // i)) % mod\n\ndef binomial_coefficients(n, k):\n    ans = 1\n    for i in range(k):\n        ans *= n-i\n        ans *= modinv_table[i + 1]\n        ans %= mod\n    return ans\n\nprint(binomial_coefficients(n, k))", "N, M = map(int, input().split())\nA = list(map(int, input().split()))\nS = sum(A)\nMOD = 10**9+7\ndef comb(n,r):\n  ans = div = 1\n  for i in range(r):\n    ans = ans * (n-i) % MOD\n    div = div * (i+1) % MOD\n  ans = ans * pow(div, MOD-2, MOD) % MOD\n  return ans\nans = comb(N+M, S+N)\nprint(ans)", "n,m=map(int,input().split())\na=list(map(int,input().split()))\nmod=10**9+7\ninv=[0,1]\nfor i in range(2,5*10**6):\n  inv+=[inv[mod%i]*(mod-int(mod/i))%mod]\ns=sum(a)\nans=1\nfor i in range(n+s):\n  ans*=(n+m-i)\n  ans%=mod\n  ans*=inv[i+1]\n  ans%=mod\nprint(ans)", "k = 72\nkk = k // 4\nK = 1<<k\nnu = lambda L: int(\"\".join([hex(K+a)[3:] for a in L[::-1]]), 16)\nst = lambda n: hex(n)[2:]\nli = lambda s, l, r: [int(a, 16) % P if len(a) else 0 for a in [s[-(i+1)*kk:-i*kk] for i in range(l, r)]]\n\ndef grow(d, v, h, start):\n    h += [0] * d\n    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]\n    nuf = nu(f)\n    a = d * inv[v] % P\n    t = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        t[i] = t[i-1] * (a - d + i - 1) % P\n    ti = [1] * (3*d+3)\n    ti[-1] = pow(t[-1], P-2, P)\n    for i in range(1, 3*d+3)[::-1]:\n        ti[i-1] = ti[i] * (a - d + i - 1) % P\n    iv = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        iv[i] = ti[i] * t[i-1] % P\n \n    ###\n    g = [inv[i] for i in range(1, 2*d+2)]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d):\n        h[i+d+1] = fg[i] * fa[d+i+1] % P * fainv[i] % P\n \n    ###\n    g = [iv[i] for i in range(1, 2*d+2)]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d+1):\n        h[i] = h[i] * (fg[i] * t[d+i+1] % P * ti[i] % P) % P\n \n    ###\n    g = [iv[i] for i in range(d+2, 3*d+3)]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d):\n        h[i+d+1] = h[i+d+1] * (fg[i] * t[2*d+i+2] % P * ti[d+i+1] % P) % P\n \n    return h\n\n# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]\ndef create_table(v, start):\n    s = 1\n    X = [start, v + start]\n    while s < v:\n        X = grow(s, v, X, start)\n        s *= 2\n \n    table = [1]\n    for x in X:\n        table.append(table[-1] * x % P)\n    return table\n\ndef fact(i, table):\n    a = table[i//v]\n    for j in range(i//v*v+1, i+1):\n        a = a * j % P\n    return a\n\nP = 10**9+7\nnn = 2020000\nv = 1 << (nn.bit_length() + 1) // 2\nfa = [1] * (2*v+2)\nfainv = [1] * (2*v+2)\nfor i in range(2*v+1):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(2*v+1)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\ninv = [0] * (2*v+2)\nfor i in range(1, 2*v+2):\n    inv[i] = fainv[i] * fa[i-1] % P\n\ndef prod(a, b): # a * (a + 1) * ... * (b - 1)\n    T = create_table(v, a)\n    c = b - a\n    s = T[c//v]\n    for i in range(c // v * v + a, b):\n        s = s * i % P\n    return s\n\ndef C(a, b):\n    if b * 2 > a: b = a - b\n    return prod(a - b + 1, a + 1) * pow(prod(1, b + 1), P - 2, P) % P\n\nP = 10 ** 9 + 7\nN, M = map(int, input().split())\nA = [int(a) for a in input().split()]\ns = sum(A)\nprint(C(N + M, s + N) if M >= s else 0)", "N,M = map(int, input().split())\nA = list(map(int, input().split()))\nmod = 10**9 + 7\n\ndef binomial_coefficients(n, k):\n    numera = 1  # \u5206\u5b50\n    denomi = 1  # \u5206\u6bcd\n\n    for i in range(k):\n        numera *= n-i\n        numera %= mod\n        denomi *= i+1\n        denomi %= mod\n    \n    return numera * pow(denomi,-1,mod) % mod\n\nprint(binomial_coefficients(M+N,N+sum(A)))", "n, m = list(map(int, input().split()))\nA = list(map(int, input().split()))\nmod = 10**9+7\n\ns = sum(A)\nans = 1\n\ndef comb(n, r, mod):\n    c = 1\n    for i in range(r):\n        c *= n-i\n        c %= mod\n\n    d = 1\n    for i in range(1, r+1):\n        d *= i\n        d %= mod\n\n    return (c * pow(d, mod-2, mod)) % mod\n\n\nprint((comb(m+n, s+n, mod)))\n\n", "N, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nS = sum(A)\nMOD = 10**9 + 7\n\na = b = 1\nfor i in range(1, S+N+1):\n    a *= M + N  + 1 - i\n    a %= MOD\n    b *= i\n    b %= MOD\n\nans = a * pow(b, MOD-2, MOD)\nans %= MOD\nprint(ans)\n", "MOD = 10 ** 9 + 7\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nr = n + sum(a)\nm += n\nif m < r:\n    print((0))\nelse:\n    ans = 1\n    v = 1\n    for i in range(r):\n        v *= i + 1\n        ans *= (m - i)\n        v %= MOD\n        ans %= MOD\n    print((ans * pow(v, MOD - 2, MOD) % MOD))\n", "class Factorials:\n    def __init__(self, n=10**6, mod=10**9+7):\n        self.mod = mod\n\n        # self.fac[i] \u2261 i! (factorial:\u968e\u4e57)\n        self.fac = [1] * (n+1)\n        for i in range(2, n+1):\n            self.fac[i] = self.fac[i-1] * i % mod\n\n        \"\"\"\n        # self.rec[i] \u2261 1 / i! (reciprocal:\u9006\u6570)\n        self.rec = [1] * (n+1)\n        self.rec[n] = pow(self.fac[n], mod-2, mod)\n        for i in range(n-1, 1, -1):\n            self.rec[i] = self.rec[i+1] * (i+1) % mod\n\n    # self.comb(n, r) \u2261 nCr\n    def comb(self, n, r):\n        return self.fac[n] * self.rec[r] * self.rec[n-r] % self.mod\n    \n    # self.perm(n, r) \u2261 nPr\n    def perm(self, n, r):\n        return self.fac[n] * self.rec[n-r] % self.mod\n\n    # self.inv(n) \u2261 1 / n \u2261 pow(n, mod-2, mod)\n    def inv(self, n):\n        return self.fac[n-1] * self.rec[n] % self.mod\n    \"\"\"\n\nmod = 10**9 + 7\n\ndef fact(n, r):\n    res = 1\n    for i in range(r):\n        res *= n - i\n        res %= mod\n    return res\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nsum_a = sum(a)\nif m < sum_a:\n    print(0)\n    return\n\nfct = Factorials(sum_a + n)\n\nprint(fact(n+m, sum_a+n) * pow(fct.fac[sum_a+n], mod-2, mod) % mod)", "def comb(n, r, mod):\n    x, y = 1, 1\n    for i in range(n, n - r, -1):\n        x *= i\n        y *= i + r - n\n        x %= mod\n        y %= mod\n    return pow(y, -1, mod) * x % mod\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nmod = pow(10, 9) + 7\nans = comb(n + m, n + sum(a), mod)\nprint(ans)", "mod = 10**9+7\nn, m = map(int, input().split())\ns = sum(map(int, input().split()))\na = n+m\nb = s+n\nnum = 1\nden = 1\nfor i in range(b):\n  num *= a-i\n  num %= mod\n  den *= i+1\n  den %= mod\nans = num * pow(den, mod-2, mod) % mod\nprint(ans)", "import sys\ninput = sys.stdin.readline\nN, M = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nmod = 10 ** 9 + 7\ndsm = M - sum(a)\nif dsm < 0:\n  print(0)\n  return\n\nclass Factorial:\n  def __init__(self, n, mod):\n    self.mod = mod\n    self.f = [1]\n    for i in range(1, n + 1):\n      self.f.append(self.f[-1] * i % mod)\n    self.i = [pow(self.f[-1], mod - 2, mod)]\n    for i in range(1, n + 1)[: : -1]:\n      self.i.append(self.i[-1] * i % mod)\n    self.i.reverse()\n  def factorial(self, i): return self.f[i]\n  def ifactorial(self, i): return self.i[i]\n  def combi(self, n, k): return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod\n  def permi(self, n, k): return self.f[n] * self.i[n - k] % self.mod\n\nsm = sum(a)\nres = Factorial(sm + N, mod).ifactorial(sm + N)\nfor x in range(N + M, N + M - sm - N, -1):\n  res *= x\n  res %= mod\nprint(res)", "N, M = map(int, input().split())\ns = sum(list(map(int, input().split())))\n\np = 10 ** 9 + 7\n\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n\nfor i in range(2, s + N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nans = factinv[s + N]\n\nfor i in range(s + N):\n    ans *= M + N - i\n    ans %= p\n\nprint(ans)", "from numba import njit\nN, M, *A = [int(_) for _ in open(0).read().split()]\nmod = 10**9 + 7\nsuma = sum(A)\nx = M + N\ny = N + suma\na = 1\nb = 1\n\n\n@njit('i8(i8,i8,i8)')\ndef pow_mod(base, exp, mod):\n    exp %= mod - 1\n    res = 1\n    while exp:\n        if exp & 1:\n            res = res * base % mod\n        base = base * base % mod\n        exp >>= 1\n    return res\n\n\n@njit('i8(i8,i8)')\ndef comb(x, y):\n    a = b = 1\n    for _ in range(y):\n        a *= x\n        b *= y\n        a %= mod\n        b %= mod\n        x -= 1\n        y -= 1\n    ret = a * pow_mod(b, mod - 2, mod) % mod\n    return ret\n\n\nprint((comb(M + N, N + suma)))\n", "import sys\n# import numpy as np\n# from numba import njit, i8, void\n\nMOD = 10**9 + 7\n\nN, M = list(map(int, sys.stdin.readline().rstrip().split()))\n# A = np.array([int(x) for x in sys.stdin.readline().rstrip().split()], dtype=np.int64)\nA = [int(x) for x in sys.stdin.readline().rstrip().split()]\n\n\n# @njit(void(i8, i8, i8[:]), cache=True)\ndef solve(N, M, A):\n\n    S = sum(A)\n\n    num = 1\n    don = 1\n\n    for i in range(1, S + N + 1):\n        num = num * (M + N - (i - 1)) % MOD\n        don = don * i % MOD\n\n    ans = num * pow(don, MOD - 2, MOD) % MOD\n\n    # print(INV)\n\n    print(ans)\n\n\nsolve(N, M, A)\n", "MOD = 10**9+7\nn, m = map(int, input().split())\na = list(map(int, input().split()))\ns = sum(a)\nans = 1\nden = 1\nfor i in range(s+n):\n\tans *= m + n - i\n\tans %= MOD\n\tden *= i+1\n\tden %= MOD\n\nans = (ans * pow(den, MOD-2, MOD)) % MOD\nprint(ans)", "def nCr(n,r):\n    A=B=1\n    for _ in range(r):\n        A*=n\n        A%=Mod\n\n        B*=r\n        B%=Mod\n\n        n-=1\n        r-=1\n\n    return (A*pow(B,Mod-2,Mod))%Mod\n\nN,M=map(int,input().split())\nA=list(map(int,input().split()))\nMod=10**9+7\nprint(nCr(M+N,sum(A)+N))", "MOD=10**9+7\n\ndef COM(n,r):\n    P,Q=1,1\n    for i in range(r):\n        P=P*(n-i)%MOD\n        Q=Q*(r-i)%MOD\n    return P*pow(Q,MOD-2,MOD)%MOD\n\nN,M=map(int,input().split())\nS=sum(list(map(int,input().split())))\n\nprint(COM(N+M,S+N))", "def cmb(x, y):\n    if x < y:\n        return 0\n    bunsi = 1\n    bunbo = 1\n    for i in range(1, y+1):\n        bunsi = (bunsi*(x+1-i)) % mod\n        bunbo = (bunbo*i) % mod\n    res = bunsi*pow(bunbo,mod-2,mod) % mod\n    return res\n\nn,m = map(int,input().split())\na = list(map(int,input().split()))\nmod = 10**9+7\n\ns = sum(a)\nans = cmb(m+n,s+n)\nprint(ans)", "n,m = list(map(int,input().split()))\nA = list(map(int,input().split()))\nmod = 10**9+7\ns = sum(A)\nif s>m:print((0));return\nans = 1\na = 1\nfor i in range(n+s):\n    ans*=m+n-i\n    a*=i+1\n    ans%=mod\n    a%=mod\n\nans = ans*pow(a,mod-2,mod)\nprint((ans%mod))\n", "import sys\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef modInverse(a, p):\n    return pow(a, p - 2, p)\n\n\ndef modBinomial(n, k, p):\n    numerator = 1\n    for i in range(k):\n        numerator = (numerator * (n - i)) % p\n\n    denominator = 1\n    for i in range(1, k + 1):\n        denominator = (denominator * i) % p\n\n    return (numerator * modInverse(denominator, p)) % p\n\n\ndef main():\n    N, M = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n\n    MOD = 10 ** 9 + 7\n\n    if sum(A) > M:\n        print((0))\n        return\n\n    x = sum(A) + N + 1\n    sa = (M - sum(A))\n\n    nn = (x - 1 + sa)\n    rr = sa\n\n    print((modBinomial(nn, min(rr, nn - rr), MOD)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def solve():\n    mod = 10**9 + 7\n    N, M = map(int,input().split())\n    A = list(map(int,input().split()))\n    M += N\n    S = sum(A) + N\n    if S > M:\n        print(0)\n        return\n    ans = 1\n    d = 1\n    for i in range(1,S+1):\n        ans = (ans*(M+1-i)) % mod \n        d = (d * i) % mod\n    ans = (ans * pow(d,mod-2,mod)) % mod\n    \"\"\"\n    for i in range(1,S+1):\n        ans = (ans*(M+1-i)) % mod\n        d = pow(i,mod-2,mod)\n        ans = (ans*d) % mod\n    \"\"\"\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n__starting_point()", "k = 72\nkk = k // 4\nK = 1<<k\nnu = lambda L: int(\"\".join([hex(K+a)[3:] for a in L[::-1]]), 16)\nst = lambda n: hex(n)[2:]\nli = lambda s, l, r: [int(a, 16) % P if len(a) else 0 for a in [s[-(i+1)*kk:-i*kk] for i in range(l, r)]]\n\ndef grow(d, v, h, start):\n    h += [0] * d\n    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]\n    nuf = nu(f)\n    a = d * inv[v] % P\n    t = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        t[i] = t[i-1] * (a - d + i - 1) % P\n    ti = [1] * (3*d+3)\n    ti[-1] = pow(t[-1], P-2, P)\n    for i in range(1, 3*d+3)[::-1]:\n        ti[i-1] = ti[i] * (a - d + i - 1) % P\n    iv = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        iv[i] = ti[i] * t[i-1] % P\n \n    ###\n    g = [inv[i] for i in range(1, 2*d+2)]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d):\n        h[i+d+1] = fg[i] * fa[d+i+1] % P * fainv[i] % P\n \n    ###\n    g = [iv[i] for i in range(1, 2*d+2)]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d+1):\n        h[i] = h[i] * (fg[i] * t[d+i+1] % P * ti[i] % P) % P\n \n    ###\n    g = [iv[i] for i in range(d+2, 3*d+3)]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d):\n        h[i+d+1] = h[i+d+1] * (fg[i] * t[2*d+i+2] % P * ti[d+i+1] % P) % P\n \n    return h\n\n# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]\ndef create_table(v, start):\n    s = 1\n    X = [start, v + start]\n    while s < v:\n        X = grow(s, v, X, start)\n        s *= 2\n \n    table = [1]\n    for x in X:\n        table.append(table[-1] * x % P)\n    return table\n\ndef fact(i, table):\n    a = table[i//v]\n    for j in range(i//v*v+1, i+1):\n        a = a * j % P\n    return a\n\nP = 10**9+7\nnn = 2020000\nv = 1 << (nn.bit_length() + 1) // 2\nfa = [1] * (2*v+2)\nfainv = [1] * (2*v+2)\nfor i in range(2*v+1):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(2*v+1)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\ninv = [0] * (2*v+2)\nfor i in range(1, 2*v+2):\n    inv[i] = fainv[i] * fa[i-1] % P\n\ndef prod(a, b): # a * (a + 1) * ... * (b - 1)\n    T = create_table(v, a)\n    c = b - a\n    s = T[c//v]\n    for i in range(c // v * v + a, b):\n        s = s * i % P\n    return s\n\ndef C(a, b):\n    if b * 2 > a: b = a - b\n    return prod(a - b + 1, a + 1) * pow(prod(1, b + 1), P - 2, P) % P\n\nP = 10 ** 9 + 7\nN, M = map(int, input().split())\nA = [int(a) for a in input().split()]\ns = sum(A)\nprint(C(N + M, s + N) if M >= s else 0)", "N,M = list(map(int,input().split()))\nA = list(map(int,input().split()))\nX,Y = M+N, sum(A)+N\np = 10**9+7\ndef nCr(n, r, mod=p):\n  a,b = 1,1\n  for i in range(r):\n    a *= n-i\n    a %= mod\n    b *= i+1\n    b %= mod\n  return (a*pow(b,mod-2,mod))%mod\nprint((nCr(X,Y,p)))\n", "P = 10 ** 9 + 7\nN, M = map(int, input().split())\nA = [int(a) for a in input().split()]\nu = 1\nv = 1\nfor i in range(sum(A) + N):\n    u = u * (N + M - i) % P\n    v = (i + 1) * v % P\nprint(u * pow(v, P - 2, P) % P)", "#!/usr/bin/env python3\n\nimport sys\nimport math\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nsys.setrecursionlimit(2147483647)\nfrom heapq import heappush, heappop,heappushpop\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nfrom itertools import permutations\nmod = 10**9 + 7\ninf = float('inf')\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\nn, m = LI()\na = LI()\ns = sum(a)\nif m + n < s + n:\n    print(0)\nelse:\n    ans = 1\n    inv = 1\n    for i in range(s+n):\n        ans *= m + n - i\n        ans %= mod\n        inv *= i+1\n        inv %= mod\n    print(ans * pow(inv, mod-2, mod) % mod)", "import sys\ndef input():return sys.stdin.readline()[:-1]\ndef N(): return int(input())\ndef NM():return map(int,input().split())\ndef L():return list(NM())\n\nn,m=NM()\na=L()\nmod=10**9+7\ndef comb(n,r):\n    b=1\n    a=1\n    for i in range(r):\n        b*=n-i\n        a*=i+1\n        b%=mod\n        a%=mod\n    return b*pow(a,mod-2,mod)%mod\nprint(comb(m+n,n+sum(a)))", "N,M = map(int,input().split())\nA = list(map(int,input().split()))\nsa = sum(A)\nMOD = 10**9+7\nif sa > M:\n    print(0)\n    return\nif sa == M:\n    print(1)\n    return\n\nx = 1 + sa + N\nn = M-sa\n\nbunsi = bunbo = 1\nfor i in range(max(x,n+1), x+n):\n    bunsi *= i\n    bunsi %= MOD\n\nfor i in range(1,min(x,n+1)):\n    bunbo *= i\n    bunbo %= MOD\n\nans = bunsi * pow(bunbo, MOD-2, MOD)\nans %= MOD\nprint(ans)", "def main():\n    mod=1000000007\n    n,m=map(int,input().split())\n    A=list(map(int,input().split()))\n    s=sum(A)\n    if s>m:\n        return 0\n    ans=1\n    inv=1\n    for i in range(s+n):\n        ans*=m+n-i\n        inv*=i+1\n        ans%=mod\n        inv%=mod\n    return ans*pow(inv,mod-2,mod)%mod\n    \ndef __starting_point():\n    print(main())\n__starting_point()", "import sys\n# import numpy as np\n# from numba import njit, i8, void\n\nMOD = 10**9 + 7\n\nN, M = list(map(int, sys.stdin.readline().rstrip().split()))\n# A = np.array([int(x) for x in sys.stdin.readline().rstrip().split()], dtype=np.int64)\nA = [int(x) for x in sys.stdin.readline().rstrip().split()]\n\n\n# @njit(void(i8, i8, i8[:]), cache=True)\ndef solve(N, M, A):\n\n    S = sum(A)\n\n    num = 1\n    don = 1\n\n    for i in range(1, S + N + 1):\n        num = num * (M + N - (i - 1)) % MOD\n        don = don * i % MOD\n\n    ans = num * pow(don, MOD - 2, MOD) % MOD\n\n    # print(INV)\n\n    print(ans)\n\n\nsolve(N, M, A)\n", "k = 72\nkk = k // 4\nK = 1<<k\nnu = lambda L: int(\"\".join([hex(K+a)[3:] for a in L[::-1]]), 16)\nst = lambda n: hex(n)[2:]\nli = lambda s, l, r: [int(a, 16) % P if len(a) else 0 for a in [s[-(i+1)*kk:-i*kk] for i in range(l, r)]]\n\ndef grow(d, v, h, start):\n    h += [0] * d\n    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]\n    nuf = nu(f)\n    a = d * inv[v] % P\n    t = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        t[i] = t[i-1] * (a - d + i - 1) % P\n    ti = [1] * (3*d+3)\n    ti[-1] = pow(t[-1], P-2, P)\n    for i in range(1, 3*d+3)[::-1]:\n        ti[i-1] = ti[i] * (a - d + i - 1) % P\n    iv = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        iv[i] = ti[i] * t[i-1] % P\n \n    ###\n    g = [inv[i] for i in range(1, 2*d+2)]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d):\n        h[i+d+1] = fg[i] * fa[d+i+1] % P * fainv[i] % P\n \n    ###\n    g = [iv[i] for i in range(1, 2*d+2)]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d+1):\n        h[i] = h[i] * (fg[i] * t[d+i+1] % P * ti[i] % P) % P\n \n    ###\n    g = [iv[i] for i in range(d+2, 3*d+3)]\n    fg = li(st(nuf * nu(g)), d, d * 2 + 1)\n    for i in range(d):\n        h[i+d+1] = h[i+d+1] * (fg[i] * t[2*d+i+2] % P * ti[d+i+1] % P) % P\n \n    return h\n\n# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]\ndef create_table(v, start):\n    s = 1\n    X = [start, v + start]\n    while s < v:\n        X = grow(s, v, X, start)\n        s *= 2\n \n    table = [1]\n    for x in X:\n        table.append(table[-1] * x % P)\n    return table\n\ndef fact(i, table):\n    a = table[i//v]\n    for j in range(i//v*v+1, i+1):\n        a = a * j % P\n    return a\n\nP = 10**9+7\nnn = 3000000\nv = 1 << (nn.bit_length() + 1) // 2\nfa = [1] * (2*v+2)\nfainv = [1] * (2*v+2)\nfor i in range(2*v+1):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(2*v+1)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\ninv = [0] * (2*v+2)\nfor i in range(1, 2*v+2):\n    inv[i] = fainv[i] * fa[i-1] % P\n\ndef prod(a, b): # a * (a + 1) * ... * (b - 1)\n    T = create_table(v, a)\n    c = b - a\n    s = T[c//v]\n    for i in range(c // v * v + a, b):\n        s = s * i % P\n    return s\n\ndef C(a, b):\n    if b * 2 > a: b = a - b\n    return prod(a - b + 1, a + 1) * pow(prod(1, b + 1), P - 2, P) % P\n\nP = 10 ** 9 + 7\nN, M = map(int, input().split())\nA = [int(a) for a in input().split()]\ns = sum(A)\nprint(C(N + M, s + N) if M >= s else 0)", "def solve(n, m, aaa):\n    s = sum(aaa)\n    if s > m:\n        return 0\n\n    ms = m - s\n    MOD = 10 ** 9 + 7\n\n    f = 1\n    for i in range(2, n + s + 1):\n        f = f * i % MOD\n    ans = pow(f, MOD - 2, MOD)\n\n    for x in range(m + n, ms, -1):\n        ans = ans * x % MOD\n\n    return ans\n\n\nn, m = list(map(int, input().split()))\naaa = list(map(int, input().split()))\nprint((solve(n, m, aaa)))\n", "# \u5834\u5408\u306e\u6570\u3092mod\u3067\u5272\u3063\u305f\u4f59\u308a nCr % mod\ndef ncr_mod(n,r,mod):\n  a,b=1,1\n  for i in range(r):\n    a*=n-i\n    a%=mod\n    b*=i+1\n    b%=mod\n  return (a*pow(b,mod-2,mod))%mod\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nmod=10**9+7\nans=ncr_mod(m+n,sum(a)+n,mod)\nprint(ans)", "N,M=list(map(int,input().split()))\nA=[int(i) for i in input().split()]\nsumA=sum(A)\nmod=10**9+7\ndef inv(x):\n    return pow(x,mod-2,mod)\nans=1\nF=1\nfor i in range(N+sumA):\n    ans*=(N+M-i)\n    ans%=mod\n    F*=(i+1)\n    F%=mod\nans*=inv(F)\nans%=mod\nprint(ans)\n", "N,M = map(int, input().split())\nA = list(map(int, input().split()))\nmod = 10**9 + 7\n\ndef binomial_coefficients(n, k):\n    numera = 1  # \u5206\u5b50\n    denomi = 1  # \u5206\u6bcd\n\n    for i in range(k):\n        numera *= n-i\n        numera %= mod\n        denomi *= i+1\n        denomi %= mod\n    return numera * pow(denomi, mod-2, mod) % mod\n\nprint(binomial_coefficients(M+N,N+sum(A)))", "import itertools\nN, M, *A = [int(_) for _ in open(0).read().split()]\n\n\nclass Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * (max_fact + 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx\n            f[idx] %= mod\n        if mod > max_fact:\n            fi = [pow(f[-1], mod - 2, mod)]\n            for idx in range(max_fact, 0, -1):\n                fi += [fi[-1] * idx % mod]\n            fi = fi[::-1]\n        else:\n            fi = [pow(n, mod - 2, mod) for n in f]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        mod = self.mod\n        if n < r:\n            return 0\n        elif n < len(f):\n            return f[n] * fi[r] * fi[n - r] % mod\n        elif n < 2 * r:\n            r = n - r\n        if r < len(f):\n            ret = fi[r]\n            for _ in range(r):\n                ret *= n\n                ret %= mod\n                n -= 1\n            return ret\n        else:\n            1 / 0\n\n    def permutation(self, n, r):\n        f = self.f\n        fi = self.fi\n        mod = self.mod\n        if n < len(f):\n            return f[n] * fi[n - r] % mod\n        elif r < len(f):\n            ret = 1\n            for _ in range(r):\n                ret *= n\n                ret %= mod\n                n -= 1\n            return ret\n        else:\n            1 / 0\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nsuma = sum(A)\nmax_fact = suma + N\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\n\nans = comb(M + N, suma + N)\nprint(ans)\n'''\nans = 0\nfor bs in itertools.product(range(M + 1), repeat=N):\n    f = 0\n    if sum(bs) > M:\n        continue\n    ans += list(\n        itertools.accumulate([comb(b, a) for a, b in zip(A, bs)],\n                             func=lambda x, y: x * y % mod))[-1]\n    ans %= mod\nprint(ans)\n'''\n'''\nans(N, M, sum(A))\n\nans(3, 1, 1) = C[4, 0]\nans(3, 2, 2) = C[5, 0]\nans(3, 3, 3) = C[6, 0]\n\nans(3, 4, 4) = C[7, 0]\n\nans(3, 6, 5) = C[9, 1]\nans(4, 6, 5) = C[10, 1]\n\nans(N, M, sum(A)) = C[N + M, M - sum(A)]\n'''\n", "mod = 10 ** 9 + 7\n\ndef comb(n, m):\n    ans = 1\n    a, b = 1, 1\n    for i in range(1, m + 1):\n        a = a * (n - i + 1) % mod\n        b = b * i % mod\n        ans %= mod\n    return a * pow(b, mod - 2, mod) % mod\n\nN, M = map(int, input().split())\nS = sum(map(int, input().split()))\nprint(comb(M + N, S + N))", "N,M = map(int,input().split())\nA = list(map(int,input().split()))\nmod = 10**9+7\nS = sum(A)\n\ndef cmb(a,b,mod):\n    if a < b:\n        return 0\n    b = min(b,a-b)\n    num = 1\n    for i in range(b):\n        num = num*(a-i) % mod\n    den = 1\n    for i in range(1,b+1):\n        den = den*i % mod\n    return num * pow(den,mod-2,mod) % mod\n\nprint(cmb(M+N,S+N,mod))", "n,m=map(int, input().split())\n*a,=map(int, input().split())\nmod=10**9+7\nl,r=1,1\nfor i in range(n+sum(a)):\n    l,r=l*(n+m-i)%mod,r*(i+1)%mod\nprint(l*pow(r,mod-2,mod)%mod)", "# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom fractions import Fraction\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations, accumulate\nfrom operator import add, mul, sub, itemgetter, attrgetter\n\n\nimport sys\n# sys.setrecursionlimit(10**6)\n# readline = sys.stdin.buffer.readline\nreadline = sys.stdin.readline\n\nINF = 1 << 60\n\n\ndef read_int():\n    return int(readline())\n\n\ndef read_int_n():\n    return list(map(int, readline().split()))\n\n\ndef read_float():\n    return float(readline())\n\n\ndef read_float_n():\n    return list(map(float, readline().split()))\n\n\ndef read_str():\n    return readline().strip()\n\n\ndef read_str_n():\n    return readline().strip().split()\n\n\ndef ep(*args):\n    print(*args, file=sys.stderr)\n\n\ndef epp(o):\n    import pprint\n    pprint.pprint(o, stream=sys.stderr)\n\ndef gen_2d_array(n, m, fill=0):\n    if callable(fill):\n        return [[fill()] * m for _ in range(n)]\n    else:\n        return [[fill] * m for _ in range(n)]\n\n\ndef gen_3d_array(n, m, k, fill=0):\n    if callable(fill):\n        return [[[fill()] * k for _ in range(m)] for _ in range(n)]\n    else:\n        return [[[fill] * k for _ in range(m)] for _ in range(n)]\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.perf_counter()\n        ret = f(*args, **kwargs)\n        e = time.perf_counter()\n\n        ep(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n@mt\ndef slv(N, M, A):\n    mod = 10**9 + 7\n    S = sum(A)\n    a = 1\n    b = 1\n    for i in range(1, N+S+1):\n        a *= i\n        a %= mod\n        b *= M+N-i+1\n        b %= mod\n\n    return b * pow(a, mod-2, mod) % mod\n\n\n\ndef main():\n    N, M = read_int_n()\n    A = read_int_n()\n    print(slv(N, M, A))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# Date [ 2020-12-05 22:15:25 ]\n# Problem [ d.py ]\n# Author Koki_tkg\n\nimport sys\n\ndef read_str(): return sys.stdin.readline().strip()\ndef read_int(): return int(sys.stdin.readline().strip())\ndef read_ints(): return list(map(int, sys.stdin.readline().strip().split()))\ndef read_str_split(): return list(sys.stdin.readline().strip())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\n\ndef nCr(n, r, MOD):\n    a, b = 1, 1\n    for i in range(r):\n        a = a * (n - i) % MOD\n        b = b * (i + 1) % MOD\n    return a * pow(b, MOD - 2, MOD) % MOD\n\ndef Main():\n    N, M = read_ints()\n    A = read_int_list()\n    print((nCr(N + M, N + sum(A), 10**9 + 7)))\n\ndef __starting_point():\n    Main()\n\n__starting_point()", "N, M = map(int, input().split())\nA = list(map(int, input().split()))\na = sum(A)\nbase = 10 ** 9 + 7\n# * pow(a, base-2, base) # equivalent to division by a\n\n# ans = comb(M+N, a+N)\n\ndef fact(x):\n  r = 1\n  for i in range(1,x+1):\n    r *= i\n    r %= base\n  return r\n\nans = 1\nfor i in range(a+N):\n  ans *= M+N-i\n  ans %= base\nans *= pow(fact(a+N), base-2, base)\nans %= base\nprint(ans)", "def comb(n,m):\n  p=10**9+7\n  \n  inv=[0]*(m+1)\n  finv=[0]*(m+1)\n  inv[1]=1\n  finv[0]=1\n  finv[1]=1\n  for i in range(2,m+1):\n    inv[i]=(-(p//i)*inv[p%i])%p\n    finv[i]=finv[i-1]*inv[i]%p\n  \n  if m>n:\n    return 0\n  elif n<0 or m<0:\n    return 0\n  else:\n    #print(inv)\n    #print(finv)\n    ans=1\n    for i in range(n,n-m,-1):\n      ans=(ans*i)%p\n      \n    return (ans*finv[m])%p\n  \nn,m=list(map(int,input().split()))\na=list(map(int,input().split()))\ns=sum(a)\nprint((comb(m+n,s+n)))\n\n", "k = 72\nkk = k // 4\nK = 1<<k\n# nu = lambda L: int(\"\".join([hex(K+a)[3:] for a in L[::-1]]), 16)\ndef nu(L, sl = -1):\n    if sl == -1: sl = slice(0,len(L))\n    return int(\"\".join([hex(K+a)[3:] for a in L[sl][::-1]]), 16)\nst = lambda n: hex(n)[2:]\nli = lambda s, l, r: [int(a, 16) % P if len(a) else 0 for a in [s[-(i+1)*kk:-i*kk] for i in range(l, r)]]\n\ndef grow(d, v, h, start):\n    h += [0] * d\n    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]\n    nuf = nu(f)\n    a = d * inv[v] % P\n    t = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        t[i] = t[i-1] * (a - d + i - 1) % P\n    ti = [1] * (3*d+3)\n    ti[-1] = pow(t[-1], P-2, P)\n    for i in range(1, 3*d+3)[::-1]:\n        ti[i-1] = ti[i] * (a - d + i - 1) % P\n    iv = [1] * (3*d+3)\n    for i in range(1, 3*d+3):\n        iv[i] = ti[i] * t[i-1] % P\n \n    ###\n    fg = li(st(nuf * nu(iv[1:2*d+2])), d, d * 2 + 1)\n    for i, (_fg, _ti) in enumerate(zip(fg, ti)):\n        h[i] = h[i] * (_fg * t[d+i+1] % P * _ti % P) % P\n \n    ###\n    fg1 = li(st(nuf * nu(inv[1:2*d+2])), d, d * 2 + 1)\n    fg2 = li(st(nuf * nu(iv[d+2:3*d+3])), d, d * 2 + 1)\n    fg1.pop()\n    for i, (_fg1, _fg2) in enumerate(zip(fg1, fg2)):\n        h[i+d+1] = _fg1 * fa[d+i+1] % P * fainv[i] % P * (_fg2 * t[2*d+i+2] % P * ti[d+i+1] % P) % P\n \n    return h\n\n# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]\ndef create_table(v, start):\n    s = 1\n    X = [start, v + start]\n    while s < v:\n        X = grow(s, v, X, start)\n        s *= 2\n \n    table = [1]\n    for x in X:\n        table.append(table[-1] * x % P)\n    return table\n\ndef fact(i, table):\n    a = table[i//v]\n    for j in range(i//v*v+1, i+1):\n        a = a * j % P\n    return a\n\nP = 10 ** 9 + 7\nnn = 4000000\nv = 1 << (nn.bit_length() + 1) // 2\nfa = [1] * (2*v+2)\nfainv = [1] * (2*v+2)\nfor i in range(2*v+1):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(2*v+1)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\ninv = [0] * (2*v+2)\nfor i in range(1, 2*v+2):\n    inv[i] = fainv[i] * fa[i-1] % P\n\ndef prod(a, b, vv): # a * (a + 1) * ... * (b - 1) % P\n    T = create_table(vv, a)\n    c = b - a\n    s = T[c//vv]\n    for i in range(c // vv * vv + a, b):\n        s = s * i % P\n    return s\n\ndef C(a, b):\n    if b * 2 > a: b = a - b\n    return prod(a - b + 1, a + 1, v) * pow(prod(1, b + 1, v), P - 2, P) % P\n\nN, M = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\ns = sum(A)\nprint((C(N + M, s + N) if M >= s else 0))\n", "import sys\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nP = int(1e9+7)\nsumA=sum(A)\n# \u5024\u304c\u5927\u304d\u304fmod P\u306a\u6642\ndef comb(n, r):\n    if n < r or r < 0:\n        return 0\n    nume = 1\n    deno = 1\n    for i in range(1, r + 1):\n        nume = (nume * (n - i + 1)) % P\n        deno = (deno* i ) % P\n    deno_inv = pow(deno, P-2, P)\n    return nume*deno_inv%P\n\nprint((comb(M+N, N+sumA)))\n"]
# 考察:
#  1,一見するとDPの問題。
#    DP[m][i] = (B_1~B_iの総和がmとなるとき、i番目までを掛け算したものの和) とすればよさそう。
#    しかし、Mの制約が大きい。上のDPはO(MN)かかるため、確実にTLEする。
#  2,いろいろ考えたが、やはりMの制約が大きすぎる。もっと簡単な計算式があるのではないか。
#  3,数え上げの問題として捉える。
#    (B_i A_i)は、しきりをA_i個、ボールをK_i = (B_i-A_i)個並べる場合の数である。
#    掛け算しているため、しきりA_i個、ボールK_i個のセクション(1~N)が独立して置かれているとみなせる。
#    例：N = 3, A = [1,2,3], K = B-A = [6,5,3]のとき
#     o o o | o o o (セクション1)
#     o o | o | o o (セクション2)
#     o | | o | o (セクション3)
#    さらにB_iも可変。拘束条件は、今あるしきりとボールの合計がM個以下であることのみ。
#    セクション1~Nを横並べにして、セクション間にさらにしきりを導入する。
#    さらに最後のセクションの後にしきりを設ける。
#    しきりとボールの合計がM個に満たない場合、この仕切りの後にその分のボールを置く。
#    例：N = 3, A = [1,2,3], K = B-A = [6,5,3], M = 22(2個あまる)のとき
#     o o o | o o o x o o | o | o o x o | | o | o x o o  (セクション間のしきりを「x」とした)
#    ここで、2種類のしきりを区別する必要がない。
#    (A_iが決まっているため、どの仕切りがどちらの意味のしきりであるかは一意に復元できる。)
#  結論：しきりN+ΣA個、ボールM-ΣA個を並べる場合の数を求めればよい。

N, M = map(int, input().split())
A = list(map(int, input().split()))
mod = 10**9 + 7

invs = [0, 1]

X = N + M  # しきりとボールの数の和
Y = N + sum(A)  # しきりの数


def inv(x):
    if x == 1:
        return 1
    else:
        return (-invs[mod % x] * (mod // x)) % mod


for i in range(2, Y + 1):  # 事前に逆元計算
    invs.append(inv(i))

ans = 1
for i in range(Y):  # (X Y)の計算
    ans *= (X - i) * invs[i + 1]
    ans %= mod
print(ans % mod)
